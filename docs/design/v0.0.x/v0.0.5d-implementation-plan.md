# v0.0.5d Implementation Plan: Configuration & Polish

**Version:** 0.0.5d
**Parent:** v0.0.5 (Dice Pool System)
**Prerequisites:** v0.0.5a Complete (Core Dice Engine), v0.0.5b Complete (Skill Check System), v0.0.5c Complete (Combat Integration)
**Status:** Ready for Implementation
**Target Tests:** 260 â†’ 272 (+12 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Architecture Overview](#architecture-overview)
4. [Detailed Implementation](#detailed-implementation)
   - [Command Layer](#command-layer)
   - [Service Layer](#service-layer)
   - [Presentation Layer](#presentation-layer)
   - [Descriptor System](#descriptor-system)
5. [Integration with GameView](#integration-with-gameview)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose
Phase 5d completes the v0.0.5 Dice Pool System by adding the presentation layer integration, user commands for direct dice rolling and skill checks, and polish features like descriptive flavor text for critical rolls. This phase ties together all the dice-related work from phases 5a, 5b, and 5c into a cohesive, user-facing experience.

### Scope
- **In Scope:** `roll` command, `check` command, dice roll rendering, skill check rendering, combat round rendering with dice breakdown, descriptor system for flavor text, help text updates
- **Out of Scope:** New game mechanics (covered in future versions)

### Key Deliverables

| Type | Count | Files |
|------|-------|-------|
| Command Records | 2 | RollCommand, SkillCheckCommand |
| Application DTOs | 1 | CombatRoundResultDto |
| Renderer Methods | 3 | RenderDiceRollAsync, RenderSkillCheckAsync, RenderCombatRoundAsync |
| Descriptor Service | 1 | DiceDescriptorService |
| Configuration Files | 1 | dice-descriptors.json |
| Unit Tests | 12 | 3 test files |

### Success Metrics
- All 12 new tests pass
- All existing tests (from v0.0.5a, v0.0.5b, v0.0.5c) continue to pass
- Total test count: ~272 tests
- Build completes with 0 errors, 0 warnings
- `roll 3d6+5` command displays formatted dice results
- `check perception moderate` command displays skill check breakdown

---

## Dependencies from Previous Phases

### From v0.0.5a (Core Dice Engine)

| Type | Location | Usage in 5d |
|------|----------|-------------|
| `DicePool` | `Domain/ValueObjects/DicePool.cs` | Parse command notation |
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Display roll breakdown |
| `DiceService` | `Application/Services/DiceService.cs` | Execute rolls from commands |
| `DiceRollDto` | `Application/DTOs/DiceDtos.cs` | Transfer to renderer |
| `AdvantageType` | `Domain/Enums/AdvantageType.cs` | Command parameter |
| `DiceType` | `Domain/Enums/DiceType.cs` | Display dice type names |

### From v0.0.5b (Skill Check System)

| Type | Location | Usage in 5d |
|------|----------|-------------|
| `SkillDefinition` | `Domain/Definitions/SkillDefinition.cs` | List available skills |
| `DifficultyClassDefinition` | `Domain/Definitions/DifficultyClassDefinition.cs` | List available DCs |
| `SkillCheckResult` | `Domain/ValueObjects/SkillCheckResult.cs` | Display check breakdown |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Execute skill checks |
| `SkillCheckResultDto` | `Application/DTOs/SkillCheckDtos.cs` | Transfer to renderer |

### From v0.0.5c (Combat Integration)

| Type | Location | Usage in 5d |
|------|----------|-------------|
| `CombatRoundResult` | `Domain/ValueObjects/CombatResults.cs` | Display combat breakdown |
| `MonsterCounterAttackResult` | `Domain/ValueObjects/CombatResults.cs` | Display monster attack |
| `CombatService` (updated) | `Domain/Services/CombatService.cs` | Dice-based combat |

### From Existing Codebase

| Type | Location | Usage in 5d |
|------|----------|-------------|
| `GameCommand` | `Application/Interfaces/IInputHandler.cs` | Base for new commands |
| `ConsoleInputHandler` | `Presentation.Tui/Adapters/ConsoleInputHandler.cs` | Parse new commands |
| `IGameRenderer` | `Application/Interfaces/IGameRenderer.cs` | Add render methods |
| `SpectreGameRenderer` | `Presentation.Tui/Adapters/SpectreGameRenderer.cs` | Implement rendering |
| `GameView` | `Presentation.Tui/Views/GameView.cs` | Handle new commands |
| `IGameConfigurationProvider` | `Application/Interfaces/IConfigurationProvider.cs` | Load descriptors |

---

## Architecture Overview

### System Integration Diagram

```
+------------------------------------------------------------------------------+
|                          v0.0.5d PRESENTATION LAYER                           |
+------------------------------------------------------------------------------+
|                                                                              |
|  +------------------------------------------------------------------------+  |
|  |                        COMMAND FLOW                                     |  |
|  |                                                                         |  |
|  |    User Input                                                           |  |
|  |        |                                                                |  |
|  |        v                                                                |  |
|  |  +-----------------+                                                    |  |
|  |  | ConsoleInput    |  "roll 3d6+5"                                      |  |
|  |  | Handler         |  "check perception moderate"                       |  |
|  |  |                 |  "check stealth"                                   |  |
|  |  +--------+--------+                                                    |  |
|  |           |                                                             |  |
|  |           v                                                             |  |
|  |  +-----------------+     +---------------------+                        |  |
|  |  | RollCommand     |     | SkillCheckCommand   |                        |  |
|  |  | (notation)      |     | (skillId, dcId?)    |                        |  |
|  |  +--------+--------+     +----------+----------+                        |  |
|  |           |                         |                                   |  |
|  |           v                         v                                   |  |
|  |  +--------------------------------------------------------------------+ |  |
|  |  |                          GameView                                   | |  |
|  |  |                                                                     | |  |
|  |  |    case RollCommand      => HandleRollAsync(notation)              | |  |
|  |  |    case SkillCheckCommand => HandleSkillCheckAsync(skill, dc)      | |  |
|  |  +--------------------------------------------------------------------+ |  |
|  |                                                                         |  |
|  +-------------------------------------------------------------------------+  |
|                                      |                                        |
|  +-----------------------------------+----------------------------------------+
|  |                        SERVICE LAYER                                       |
|  |                                   |                                        |
|  |                                   v                                        |
|  |  +--------------------+  +----------------------+  +-------------------+   |
|  |  | DiceService        |  | SkillCheckService    |  | DescriptorService |   |
|  |  |                    |  |                      |  |                   |   |
|  |  | Roll(notation)     |  | PerformCheck(...)    |  | GetDescriptor()   |   |
|  |  | Roll(pool, adv)    |  | GetAllSkills()       |  | GetCriticalText() |   |
|  |  +--------------------+  +----------------------+  +-------------------+   |
|  |                                                                            |
|  +----------------------------------------------------------------------------+
|                                      |                                        |
|  +-----------------------------------+----------------------------------------+
|  |                       RENDERING LAYER                                      |
|  |                                   |                                        |
|  |                                   v                                        |
|  |  +--------------------------------------------------------------------+   |
|  |  |                    SpectreGameRenderer                              |   |
|  |  |                                                                     |   |
|  |  |  RenderDiceRollAsync(DiceRollDto roll)                             |   |
|  |  |    - Display dice notation                                         |   |
|  |  |    - Show individual rolls with colors                             |   |
|  |  |    - Highlight criticals (green for max, red for 1)                |   |
|  |  |    - Show explosions if any                                        |   |
|  |  |    - Display modifier and total                                    |   |
|  |  |    - Show descriptor flavor text                                   |   |
|  |  |                                                                     |   |
|  |  |  RenderSkillCheckAsync(SkillCheckResultDto result)                 |   |
|  |  |    - Display skill name and attribute                              |   |
|  |  |    - Show roll breakdown: [dice] + bonus = total                   |   |
|  |  |    - Display vs DC with color-coded difficulty                     |   |
|  |  |    - Show success/failure with margin                              |   |
|  |  |    - Highlight critical success/failure                            |   |
|  |  |                                                                     |   |
|  |  |  RenderCombatRoundAsync(CombatRoundResultDto result)               |   |
|  |  |    - Display attack roll: [d10] + Finesse vs Defense               |   |
|  |  |    - Show hit/miss determination                                   |   |
|  |  |    - Display damage roll: [weapon dice] + Might                    |   |
|  |  |    - Show damage dealt after armor                                 |   |
|  |  |    - Display monster counterattack (same format)                   |   |
|  |  |    - Highlight critical hits/misses                                |   |
|  |  +--------------------------------------------------------------------+   |
|  |                                                                            |
|  +----------------------------------------------------------------------------+
|                                                                              |
+------------------------------------------------------------------------------+
```

### Descriptor System Flow

```
+------------------------------------------------------------------------------+
|                         DESCRIPTOR SYSTEM                                     |
+------------------------------------------------------------------------------+
|                                                                              |
|  +------------------------------------------------------------------------+  |
|  |                    dice-descriptors.json                                |  |
|  |                                                                         |  |
|  |  {                                                                      |  |
|  |    "descriptors": {                                                     |  |
|  |      "dice.natural_max": [                                              |  |
|  |        "The dice shine with otherworldly luck!",                        |  |
|  |        "Fortune smiles upon your roll!",                                |  |
|  |        "A perfect cast!"                                                |  |
|  |      ],                                                                 |  |
|  |      "dice.natural_one": [                                              |  |
|  |        "The dice tumble with ill fortune...",                           |  |
|  |        "Fate turns against you.",                                       |  |
|  |        "A dismal result."                                               |  |
|  |      ],                                                                 |  |
|  |      "combat.critical_hit": [...],                                      |  |
|  |      "combat.critical_miss": [...],                                     |  |
|  |      "skill.critical_success": [...],                                   |  |
|  |      "skill.critical_failure": [...]                                    |  |
|  |    }                                                                    |  |
|  |  }                                                                      |  |
|  +------------------------------------------------------------------------+  |
|                                      |                                        |
|                                      v                                        |
|  +------------------------------------------------------------------------+  |
|  |                   DiceDescriptorService                                 |  |
|  |                                                                         |  |
|  |  + GetDescriptor(category: string) -> string?                          |  |
|  |      Returns a random descriptor from the category, or null            |  |
|  |                                                                         |  |
|  |  + GetCriticalDescriptor(isCriticalHit: bool) -> string               |  |
|  |      Returns combat critical descriptor                                |  |
|  |                                                                         |  |
|  |  + GetSkillCheckDescriptor(result: SkillCheckResult) -> string?       |  |
|  |      Returns appropriate descriptor based on result                    |  |
|  |                                                                         |  |
|  +------------------------------------------------------------------------+  |
|                                                                              |
+------------------------------------------------------------------------------+
```

---

## Detailed Implementation

### Command Layer

#### 1. New Command Records

**File:** `src/Core/RuneAndRust.Application/Interfaces/IInputHandler.cs` (additions)

```csharp
/// <summary>
/// Command to roll dice directly using dice notation.
/// </summary>
/// <param name="Notation">The dice notation to roll (e.g., "3d6+5", "1d20!", "2d8").</param>
/// <param name="Advantage">Optional advantage/disadvantage modifier.</param>
/// <remarks>
/// Supports standard dice notation including:
/// - Basic rolls: "1d20", "3d6", "2d8"
/// - Modifiers: "1d20+5", "3d6-2"
/// - Exploding dice: "1d6!" (reroll on max)
/// - Multiple dice types: "2d6+1d4" (not implemented in v0.0.5)
/// </remarks>
public record RollCommand(string Notation, AdvantageType Advantage = AdvantageType.Normal) : GameCommand;

/// <summary>
/// Command to perform a skill check.
/// </summary>
/// <param name="SkillId">The skill to check (e.g., "perception", "stealth").</param>
/// <param name="DifficultyId">Optional difficulty class ID. If omitted, defaults to "moderate".</param>
/// <param name="Advantage">Optional advantage/disadvantage modifier.</param>
/// <remarks>
/// If the skill ID is not found, displays available skills.
/// If the difficulty ID is not found, displays available difficulty classes.
/// </remarks>
public record SkillCheckCommand(
    string SkillId,
    string? DifficultyId = null,
    AdvantageType Advantage = AdvantageType.Normal) : GameCommand;
```

#### 2. Command Parsing Updates

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/ConsoleInputHandler.cs`

```csharp
// Add to ParseCommand() method switch expression:

"roll" or "r" => ParseRollCommand(argument, input),
"check" or "ch" => ParseSkillCheckCommand(argument, input),

// Add new parsing methods:

/// <summary>
/// Parses a roll command from user input.
/// </summary>
/// <param name="argument">The argument part (dice notation).</param>
/// <param name="fullInput">The full input string for error reporting.</param>
/// <returns>A RollCommand if valid notation, UnknownCommand otherwise.</returns>
private GameCommand ParseRollCommand(string? argument, string fullInput)
{
    if (string.IsNullOrWhiteSpace(argument))
    {
        _logger.LogDebug("Roll command missing notation");
        return LogAndReturn(new UnknownCommand(fullInput),
            "Roll command requires dice notation (e.g., 'roll 3d6+5')");
    }

    // Check for advantage/disadvantage flags
    var advantage = AdvantageType.Normal;
    var notation = argument;

    if (argument.EndsWith(" adv", StringComparison.OrdinalIgnoreCase) ||
        argument.EndsWith(" advantage", StringComparison.OrdinalIgnoreCase))
    {
        advantage = AdvantageType.Advantage;
        notation = argument[..argument.LastIndexOf(' ')].Trim();
    }
    else if (argument.EndsWith(" dis", StringComparison.OrdinalIgnoreCase) ||
             argument.EndsWith(" disadvantage", StringComparison.OrdinalIgnoreCase))
    {
        advantage = AdvantageType.Disadvantage;
        notation = argument[..argument.LastIndexOf(' ')].Trim();
    }

    // Validate notation format (basic check)
    if (!DicePool.TryParse(notation, out _))
    {
        _logger.LogDebug("Invalid dice notation: {Notation}", notation);
        return LogAndReturn(new UnknownCommand(fullInput),
            $"Invalid dice notation: {notation}. Use format like '3d6+5', '1d20', '2d8!'");
    }

    _logger.LogDebug("Parsed roll command: {Notation}, Advantage: {Advantage}", notation, advantage);
    return new RollCommand(notation, advantage);
}

/// <summary>
/// Parses a skill check command from user input.
/// </summary>
/// <param name="argument">The argument part (skill and optional DC).</param>
/// <param name="fullInput">The full input string for error reporting.</param>
/// <returns>A SkillCheckCommand if valid, UnknownCommand otherwise.</returns>
private GameCommand ParseSkillCheckCommand(string? argument, string fullInput)
{
    if (string.IsNullOrWhiteSpace(argument))
    {
        _logger.LogDebug("Check command missing skill name");
        return LogAndReturn(new UnknownCommand(fullInput),
            "Check command requires skill name (e.g., 'check perception', 'check stealth moderate')");
    }

    var parts = argument.Split(' ', StringSplitOptions.RemoveEmptyEntries);
    var skillId = parts[0].ToLowerInvariant();
    string? difficultyId = null;
    var advantage = AdvantageType.Normal;

    // Parse remaining parts for DC and advantage
    for (int i = 1; i < parts.Length; i++)
    {
        var part = parts[i].ToLowerInvariant();
        if (part == "adv" || part == "advantage")
        {
            advantage = AdvantageType.Advantage;
        }
        else if (part == "dis" || part == "disadvantage")
        {
            advantage = AdvantageType.Disadvantage;
        }
        else if (difficultyId == null)
        {
            // First non-advantage part is the difficulty
            difficultyId = part;
        }
    }

    _logger.LogDebug("Parsed check command: Skill={Skill}, DC={DC}, Advantage={Advantage}",
        skillId, difficultyId ?? "default", advantage);

    return new SkillCheckCommand(skillId, difficultyId, advantage);
}
```

### Service Layer

#### 3. DiceDescriptorService.cs

**File:** `src/Core/RuneAndRust.Application/Services/DiceDescriptorService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Provides descriptive flavor text for dice rolls and skill checks.
/// </summary>
/// <remarks>
/// <para>Descriptors add immersion by providing contextual flavor text for notable
/// dice results, particularly critical successes and failures.</para>
/// <para>Descriptors are loaded from JSON configuration and selected randomly
/// from available options for variety.</para>
/// </remarks>
/// <example>
/// <code>
/// var descriptor = descriptorService.GetDescriptor("dice.natural_max");
/// // Returns: "The dice shine with otherworldly luck!" (or another random option)
/// </code>
/// </example>
public class DiceDescriptorService
{
    private readonly IGameConfigurationProvider _configProvider;
    private readonly ILogger<DiceDescriptorService> _logger;
    private readonly Random _random;
    private IReadOnlyDictionary<string, IReadOnlyList<string>>? _descriptors;

    /// <summary>
    /// Initializes a new instance of the DiceDescriptorService.
    /// </summary>
    /// <param name="configProvider">Provider for loading descriptor configuration.</param>
    /// <param name="logger">Logger instance.</param>
    /// <param name="random">Optional random instance for testing. If null, creates new Random.</param>
    public DiceDescriptorService(
        IGameConfigurationProvider configProvider,
        ILogger<DiceDescriptorService> logger,
        Random? random = null)
    {
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _random = random ?? new Random();
        _logger.LogDebug("DiceDescriptorService initialized");
    }

    /// <summary>
    /// Gets a random descriptor from the specified category.
    /// </summary>
    /// <param name="category">The descriptor category (e.g., "dice.natural_max").</param>
    /// <returns>A random descriptor string, or null if category not found.</returns>
    public string? GetDescriptor(string category)
    {
        EnsureDescriptorsLoaded();

        if (_descriptors == null || !_descriptors.TryGetValue(category, out var options))
        {
            _logger.LogDebug("No descriptors found for category: {Category}", category);
            return null;
        }

        if (options.Count == 0)
        {
            return null;
        }

        var selected = options[_random.Next(options.Count)];
        _logger.LogDebug("Selected descriptor for {Category}: {Descriptor}", category, selected);
        return selected;
    }

    /// <summary>
    /// Gets a descriptor for a dice roll based on its result.
    /// </summary>
    /// <param name="result">The dice roll result.</param>
    /// <returns>Appropriate descriptor, or null if no special result.</returns>
    public string? GetDiceRollDescriptor(DiceRollResult result)
    {
        if (result.IsNaturalMax)
        {
            return GetDescriptor("dice.natural_max");
        }

        if (result.IsNaturalOne)
        {
            return GetDescriptor("dice.natural_one");
        }

        // Check for high/low rolls (75%/25% of maximum)
        var percentage = (float)result.DiceTotal / result.Pool.MaximumResult;

        if (percentage >= 0.85f)
        {
            return GetDescriptor("dice.high_roll");
        }

        if (percentage <= 0.15f)
        {
            return GetDescriptor("dice.low_roll");
        }

        return null;
    }

    /// <summary>
    /// Gets a descriptor for a skill check based on its result.
    /// </summary>
    /// <param name="result">The skill check result.</param>
    /// <returns>Appropriate descriptor, or null if no special result.</returns>
    public string? GetSkillCheckDescriptor(SkillCheckResult result)
    {
        if (result.IsCriticalSuccess)
        {
            return GetDescriptor("skill.critical_success");
        }

        if (result.IsCriticalFailure)
        {
            return GetDescriptor("skill.critical_failure");
        }

        // Check for narrow success/failure (within 1-2 of DC)
        var margin = Math.Abs(result.Margin);
        if (margin <= 1)
        {
            return result.IsSuccess
                ? GetDescriptor("skill.narrow_success")
                : GetDescriptor("skill.narrow_failure");
        }

        // Check for overwhelming success/failure
        if (result.IsSuccess && result.Margin >= 10)
        {
            return GetDescriptor("skill.overwhelming_success");
        }

        if (!result.IsSuccess && result.Margin <= -10)
        {
            return GetDescriptor("skill.overwhelming_failure");
        }

        return null;
    }

    /// <summary>
    /// Gets a descriptor for a combat critical hit or miss.
    /// </summary>
    /// <param name="isCriticalHit">True for critical hit, false for critical miss.</param>
    /// <returns>Appropriate combat descriptor.</returns>
    public string? GetCombatCriticalDescriptor(bool isCriticalHit)
    {
        return isCriticalHit
            ? GetDescriptor("combat.critical_hit")
            : GetDescriptor("combat.critical_miss");
    }

    /// <summary>
    /// Ensures descriptors are loaded from configuration.
    /// </summary>
    private void EnsureDescriptorsLoaded()
    {
        if (_descriptors != null) return;

        try
        {
            _descriptors = _configProvider.GetDiceDescriptors();
            _logger.LogInformation("Loaded {Count} descriptor categories", _descriptors?.Count ?? 0);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to load dice descriptors, using defaults");
            _descriptors = GetDefaultDescriptors();
        }
    }

    /// <summary>
    /// Gets default descriptors when configuration is unavailable.
    /// </summary>
    private static IReadOnlyDictionary<string, IReadOnlyList<string>> GetDefaultDescriptors()
    {
        return new Dictionary<string, IReadOnlyList<string>>
        {
            ["dice.natural_max"] = new[]
            {
                "A perfect roll!",
                "Fortune smiles upon you!",
                "The dice glow with luck!"
            },
            ["dice.natural_one"] = new[]
            {
                "A dismal result...",
                "Fate turns against you.",
                "The dice betray you."
            },
            ["skill.critical_success"] = new[]
            {
                "Masterfully done!",
                "A display of true expertise!",
                "Perfection incarnate!"
            },
            ["skill.critical_failure"] = new[]
            {
                "A catastrophic blunder!",
                "Everything that could go wrong, did.",
                "A moment best forgotten..."
            },
            ["combat.critical_hit"] = new[]
            {
                "A devastating blow!",
                "You strike true!",
                "A mighty critical hit!"
            },
            ["combat.critical_miss"] = new[]
            {
                "Your attack goes wildly astray!",
                "A clumsy miss!",
                "You stumble badly!"
            }
        };
    }
}
```

#### 4. Update IGameConfigurationProvider

**File:** `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs` (additions)

```csharp
/// <summary>
/// Gets all dice descriptors by category.
/// </summary>
/// <returns>Dictionary mapping category names to lists of descriptors.</returns>
IReadOnlyDictionary<string, IReadOnlyList<string>> GetDiceDescriptors();
```

#### 5. Update JsonConfigurationProvider

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs` (additions)

```csharp
// Add private field
private IReadOnlyDictionary<string, IReadOnlyList<string>>? _diceDescriptors;

// Add JSON config class
private class DiceDescriptorsJsonConfig
{
    public Dictionary<string, List<string>> Descriptors { get; set; } = new();
}

// Implement method
/// <summary>
/// Gets all dice descriptors by category.
/// </summary>
/// <returns>Dictionary mapping category names to lists of descriptors.</returns>
public IReadOnlyDictionary<string, IReadOnlyList<string>> GetDiceDescriptors()
{
    if (_diceDescriptors != null) return _diceDescriptors;

    try
    {
        var filePath = Path.Combine(_configDirectory, "dice-descriptors.json");
        if (!File.Exists(filePath))
        {
            _logger.LogWarning("Dice descriptors configuration not found at {Path}", filePath);
            _diceDescriptors = new Dictionary<string, IReadOnlyList<string>>();
            return _diceDescriptors;
        }

        var json = File.ReadAllText(filePath);
        var config = JsonSerializer.Deserialize<DiceDescriptorsJsonConfig>(json, _jsonOptions);

        if (config?.Descriptors == null)
        {
            _diceDescriptors = new Dictionary<string, IReadOnlyList<string>>();
            return _diceDescriptors;
        }

        _diceDescriptors = config.Descriptors
            .ToDictionary(
                kvp => kvp.Key,
                kvp => (IReadOnlyList<string>)kvp.Value.AsReadOnly());

        _logger.LogInformation("Loaded {Count} dice descriptor categories", _diceDescriptors.Count);
        return _diceDescriptors;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to load dice descriptors configuration");
        _diceDescriptors = new Dictionary<string, IReadOnlyList<string>>();
        return _diceDescriptors;
    }
}
```

### Presentation Layer

#### 6. IGameRenderer Extensions

**File:** `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs` (additions)

```csharp
/// <summary>
/// Renders a dice roll result with visual formatting.
/// </summary>
/// <param name="roll">The dice roll result to display.</param>
/// <param name="ct">Cancellation token for async operation.</param>
/// <remarks>
/// Display should include:
/// - Dice notation used
/// - Individual die results (color-coded)
/// - Explosions if any occurred
/// - Modifier and final total
/// - Descriptor flavor text if applicable
/// </remarks>
Task RenderDiceRollAsync(DiceRollDto roll, CancellationToken ct = default);

/// <summary>
/// Renders a skill check result with full breakdown.
/// </summary>
/// <param name="result">The skill check result to display.</param>
/// <param name="ct">Cancellation token for async operation.</param>
/// <remarks>
/// Display should include:
/// - Skill name and linked attribute
/// - Dice roll breakdown
/// - Attribute bonus calculation
/// - Total vs Difficulty Class
/// - Success/Failure with margin
/// - Critical result highlighting
/// </remarks>
Task RenderSkillCheckAsync(SkillCheckResultDto result, CancellationToken ct = default);

/// <summary>
/// Renders a full combat round result with dice breakdown.
/// </summary>
/// <param name="result">The combat round result to display.</param>
/// <param name="ct">Cancellation token for async operation.</param>
/// <remarks>
/// Display should include:
/// - Attack roll: dice + modifier vs defense
/// - Hit/Miss determination with critical highlighting
/// - Damage roll (if hit): weapon dice + modifier
/// - Actual damage dealt after armor
/// - Monster counterattack (same format)
/// - Round summary (HP changes)
/// </remarks>
Task RenderCombatRoundAsync(CombatRoundResultDto result, CancellationToken ct = default);
```

#### 7. CombatRoundResultDto

**File:** `src/Core/RuneAndRust.Application/DTOs/CombatDtos.cs` (additions or new file)

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for combat round results with full dice breakdown for display.
/// </summary>
/// <param name="PlayerName">The attacking player's name.</param>
/// <param name="TargetName">The target monster's name.</param>
/// <param name="AttackRoll">The attack roll result.</param>
/// <param name="AttackTotal">Total attack value (roll + modifiers).</param>
/// <param name="TargetDefense">The target's defense value.</param>
/// <param name="IsHit">Whether the attack hit.</param>
/// <param name="IsCriticalHit">Whether this was a critical hit.</param>
/// <param name="IsCriticalMiss">Whether this was a critical miss.</param>
/// <param name="DamageRoll">The damage roll result (null if missed).</param>
/// <param name="BaseDamage">Base damage before armor reduction.</param>
/// <param name="ArmorReduction">Amount reduced by armor.</param>
/// <param name="FinalDamage">Actual damage dealt.</param>
/// <param name="MonsterCounterAttack">Monster's counterattack result (null if monster defeated).</param>
/// <param name="MonsterDefeated">Whether the monster was defeated this round.</param>
/// <param name="PlayerDefeated">Whether the player was defeated this round.</param>
/// <param name="PlayerHealthBefore">Player's health before the round.</param>
/// <param name="PlayerHealthAfter">Player's health after the round.</param>
/// <param name="MonsterHealthBefore">Monster's health before the round.</param>
/// <param name="MonsterHealthAfter">Monster's health after the round.</param>
/// <param name="AttackDescriptor">Flavor text for the attack.</param>
public record CombatRoundResultDto(
    string PlayerName,
    string TargetName,
    DiceRollDto AttackRoll,
    int AttackTotal,
    int TargetDefense,
    bool IsHit,
    bool IsCriticalHit,
    bool IsCriticalMiss,
    DiceRollDto? DamageRoll,
    int BaseDamage,
    int ArmorReduction,
    int FinalDamage,
    MonsterCounterAttackDto? MonsterCounterAttack,
    bool MonsterDefeated,
    bool PlayerDefeated,
    int PlayerHealthBefore,
    int PlayerHealthAfter,
    int MonsterHealthBefore,
    int MonsterHealthAfter,
    string? AttackDescriptor = null)
{
    /// <summary>
    /// Creates a DTO from domain combat round result.
    /// </summary>
    /// <param name="result">The domain result.</param>
    /// <param name="playerName">The player's name.</param>
    /// <param name="targetName">The target's name.</param>
    /// <param name="playerHealthBefore">Player HP before combat.</param>
    /// <param name="playerHealthAfter">Player HP after combat.</param>
    /// <param name="monsterHealthBefore">Monster HP before combat.</param>
    /// <param name="monsterHealthAfter">Monster HP after combat.</param>
    /// <param name="attackDescriptor">Optional flavor text.</param>
    /// <returns>A new CombatRoundResultDto.</returns>
    public static CombatRoundResultDto FromDomainResult(
        CombatRoundResult result,
        string playerName,
        string targetName,
        int playerHealthBefore,
        int playerHealthAfter,
        int monsterHealthBefore,
        int monsterHealthAfter,
        string? attackDescriptor = null)
    {
        return new CombatRoundResultDto(
            playerName,
            targetName,
            DiceRollDto.FromDomainResult(result.AttackRoll),
            result.AttackTotal,
            result.TargetDefense,
            result.IsHit,
            result.IsCriticalHit,
            result.IsCriticalMiss,
            result.DamageRoll != null ? DiceRollDto.FromDomainResult(result.DamageRoll.Value) : null,
            result.BaseDamage,
            result.ArmorReduction,
            result.DamageDealt,
            result.MonsterCounterAttack != null
                ? MonsterCounterAttackDto.FromDomainResult(result.MonsterCounterAttack)
                : null,
            result.MonsterDefeated,
            result.PlayerDefeated,
            playerHealthBefore,
            playerHealthAfter,
            monsterHealthBefore,
            monsterHealthAfter,
            attackDescriptor);
    }

    /// <summary>
    /// Gets a summary of the round outcome.
    /// </summary>
    public string Summary
    {
        get
        {
            if (IsCriticalHit)
                return $"CRITICAL HIT! {PlayerName} deals {FinalDamage} damage to {TargetName}!";
            if (IsCriticalMiss)
                return $"CRITICAL MISS! {PlayerName}'s attack goes wildly astray!";
            if (IsHit)
                return $"{PlayerName} hits {TargetName} for {FinalDamage} damage.";
            return $"{PlayerName} misses {TargetName}.";
        }
    }
}

/// <summary>
/// DTO for monster counterattack results.
/// </summary>
/// <param name="AttackRoll">The monster's attack roll.</param>
/// <param name="AttackTotal">Total attack value.</param>
/// <param name="PlayerDefense">The player's defense value.</param>
/// <param name="IsHit">Whether the attack hit.</param>
/// <param name="DamageRoll">The damage roll (null if missed).</param>
/// <param name="DamageDealt">Actual damage dealt.</param>
public record MonsterCounterAttackDto(
    DiceRollDto AttackRoll,
    int AttackTotal,
    int PlayerDefense,
    bool IsHit,
    DiceRollDto? DamageRoll,
    int DamageDealt)
{
    /// <summary>
    /// Creates a DTO from domain monster counterattack result.
    /// </summary>
    public static MonsterCounterAttackDto FromDomainResult(MonsterCounterAttackResult result)
    {
        return new MonsterCounterAttackDto(
            DiceRollDto.FromDomainResult(result.AttackRoll),
            result.AttackTotal,
            result.PlayerDefense,
            result.IsHit,
            result.DamageRoll != null ? DiceRollDto.FromDomainResult(result.DamageRoll.Value) : null,
            result.DamageDealt);
    }
}
```

#### 8. SpectreGameRenderer Implementation

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs` (additions)

```csharp
/// <summary>
/// Renders a dice roll result with visual formatting.
/// </summary>
public Task RenderDiceRollAsync(DiceRollDto roll, CancellationToken ct = default)
{
    // Build the roll display
    var rollsDisplay = FormatDiceRolls(roll.Rolls, roll.DiceType);

    // Add explosions if any
    if (roll.HadExplosions && roll.ExplosionRolls.Count > 0)
    {
        var explosionStr = string.Join(", ", roll.ExplosionRolls.Select(r =>
            $"[yellow]{r}[/]"));
        rollsDisplay += $" [yellow]+[/] {explosionStr} [yellow](explosions!)[/]";
    }

    // Format modifier
    var modifierStr = roll.Modifier switch
    {
        > 0 => $" [cyan]+{roll.Modifier}[/]",
        < 0 => $" [red]{roll.Modifier}[/]",
        _ => ""
    };

    // Format total with critical highlighting
    var totalColor = roll.IsNaturalMax ? "green" :
                     roll.IsNaturalOne ? "red" : "white";
    var totalDisplay = $"[{totalColor} bold]{roll.Total}[/]";

    // Add critical label
    var critLabel = roll.IsNaturalMax ? " [green bold]CRITICAL![/]" :
                    roll.IsNaturalOne ? " [red bold]FUMBLE![/]" : "";

    // Build output panel
    var panel = new Panel(
        $"[grey]Dice:[/] {roll.Notation}\n" +
        $"[grey]Rolls:[/] {rollsDisplay}{modifierStr}\n" +
        $"[grey]Total:[/] {totalDisplay}{critLabel}")
        .Header($"[cyan]Dice Roll[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(roll.IsNaturalMax ? Color.Green :
                     roll.IsNaturalOne ? Color.Red : Color.Grey);

    AnsiConsole.Write(panel);

    // Show descriptor if present
    if (!string.IsNullOrEmpty(roll.Descriptor))
    {
        AnsiConsole.MarkupLine($"[italic grey]{Markup.Escape(roll.Descriptor)}[/]");
    }

    return Task.CompletedTask;
}

/// <summary>
/// Renders a skill check result with full breakdown.
/// </summary>
public Task RenderSkillCheckAsync(SkillCheckResultDto result, CancellationToken ct = default)
{
    // Format dice rolls
    var rollsDisplay = FormatDiceRolls(result.DiceRoll.Rolls, result.DiceRoll.DiceType);

    // Format bonuses
    var bonusParts = new List<string>();
    if (result.AttributeBonus != 0)
    {
        var attrSign = result.AttributeBonus > 0 ? "+" : "";
        bonusParts.Add($"[cyan]{attrSign}{result.AttributeBonus}[/] (attr)");
    }
    if (result.OtherBonus != 0)
    {
        var otherSign = result.OtherBonus > 0 ? "+" : "";
        bonusParts.Add($"[yellow]{otherSign}{result.OtherBonus}[/] (bonus)");
    }
    var bonusStr = bonusParts.Count > 0 ? " " + string.Join(" ", bonusParts) : "";

    // Format DC with color
    var dcColor = result.DifficultyClass switch
    {
        <= 8 => "green",
        <= 12 => "yellow",
        <= 15 => "orange1",
        <= 18 => "red",
        _ => "purple"
    };

    // Format result
    var resultColor = result.IsCriticalSuccess ? "green" :
                      result.IsCriticalFailure ? "red" :
                      result.IsSuccess ? "green" : "red";
    var resultText = result.SuccessLevel;

    // Format margin
    var marginStr = result.Margin >= 0
        ? $"[green](+{result.Margin})[/]"
        : $"[red]({result.Margin})[/]";

    // Build output
    var panel = new Panel(
        $"[grey]Skill:[/] [white]{Markup.Escape(result.SkillName)}[/]\n" +
        $"[grey]Roll:[/] {rollsDisplay}{bonusStr} = [white bold]{result.TotalResult}[/]\n" +
        $"[grey]vs DC:[/] [{dcColor}]{result.DifficultyClass}[/] ({Markup.Escape(result.DifficultyName)})\n" +
        $"[grey]Result:[/] [{resultColor} bold]{resultText}[/] {marginStr}")
        .Header($"[cyan]Skill Check[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(result.IsSuccess ? Color.Green : Color.Red);

    AnsiConsole.Write(panel);

    // Show descriptor if present
    if (!string.IsNullOrEmpty(result.Descriptor))
    {
        AnsiConsole.MarkupLine($"[italic grey]{Markup.Escape(result.Descriptor)}[/]");
    }

    return Task.CompletedTask;
}

/// <summary>
/// Renders a full combat round result with dice breakdown.
/// </summary>
public Task RenderCombatRoundAsync(CombatRoundResultDto result, CancellationToken ct = default)
{
    var lines = new List<string>();

    // Player attack section
    lines.Add($"[yellow bold]{Markup.Escape(result.PlayerName)}'s Attack[/]");

    // Attack roll
    var attackRollsDisplay = FormatDiceRolls(result.AttackRoll.Rolls, result.AttackRoll.DiceType);
    var attackModStr = result.AttackRoll.Modifier > 0
        ? $" [cyan]+{result.AttackRoll.Modifier}[/]"
        : result.AttackRoll.Modifier < 0
            ? $" [red]{result.AttackRoll.Modifier}[/]"
            : "";

    lines.Add($"  [grey]Attack Roll:[/] {attackRollsDisplay}{attackModStr} = [white]{result.AttackTotal}[/] vs DEF [cyan]{result.TargetDefense}[/]");

    // Hit determination
    if (result.IsCriticalHit)
    {
        lines.Add($"  [green bold]>>> CRITICAL HIT! <<<[/]");
    }
    else if (result.IsCriticalMiss)
    {
        lines.Add($"  [red bold]>>> CRITICAL MISS! <<<[/]");
    }
    else if (result.IsHit)
    {
        lines.Add($"  [green]Hit![/]");
    }
    else
    {
        lines.Add($"  [grey]Miss.[/]");
    }

    // Damage (if hit)
    if (result.IsHit && result.DamageRoll != null)
    {
        var damageRollsDisplay = FormatDiceRolls(result.DamageRoll.Rolls, result.DamageRoll.DiceType);
        var damageModStr = result.DamageRoll.Modifier > 0
            ? $" [cyan]+{result.DamageRoll.Modifier}[/]"
            : "";

        lines.Add($"  [grey]Damage Roll:[/] {damageRollsDisplay}{damageModStr} = [white]{result.BaseDamage}[/]");

        if (result.ArmorReduction > 0)
        {
            lines.Add($"  [grey]Armor Reduction:[/] [blue]-{result.ArmorReduction}[/]");
        }

        lines.Add($"  [red bold]Damage Dealt: {result.FinalDamage}[/]");
    }

    // Monster counterattack
    if (result.MonsterCounterAttack != null)
    {
        lines.Add("");
        lines.Add($"[red bold]{Markup.Escape(result.TargetName)}'s Counterattack[/]");

        var monsterAttackDisplay = FormatDiceRolls(
            result.MonsterCounterAttack.AttackRoll.Rolls,
            result.MonsterCounterAttack.AttackRoll.DiceType);

        lines.Add($"  [grey]Attack Roll:[/] {monsterAttackDisplay} = [white]{result.MonsterCounterAttack.AttackTotal}[/] vs DEF [cyan]{result.MonsterCounterAttack.PlayerDefense}[/]");

        if (result.MonsterCounterAttack.IsHit)
        {
            lines.Add($"  [red]Hit![/]");
            if (result.MonsterCounterAttack.DamageRoll != null)
            {
                var monsterDamageDisplay = FormatDiceRolls(
                    result.MonsterCounterAttack.DamageRoll.Rolls,
                    result.MonsterCounterAttack.DamageRoll.DiceType);
                lines.Add($"  [grey]Damage Roll:[/] {monsterDamageDisplay}");
            }
            lines.Add($"  [red bold]Damage Dealt: {result.MonsterCounterAttack.DamageDealt}[/]");
        }
        else
        {
            lines.Add($"  [grey]Miss.[/]");
        }
    }

    // Round summary
    lines.Add("");
    lines.Add("[grey]--- Round Summary ---[/]");
    lines.Add($"  [white]{Markup.Escape(result.PlayerName)}:[/] HP {result.PlayerHealthBefore} -> [white]{result.PlayerHealthAfter}[/]");
    lines.Add($"  [white]{Markup.Escape(result.TargetName)}:[/] HP {result.MonsterHealthBefore} -> [white]{result.MonsterHealthAfter}[/]");

    if (result.MonsterDefeated)
    {
        lines.Add($"  [green bold]{Markup.Escape(result.TargetName)} has been defeated![/]");
    }
    else if (result.PlayerDefeated)
    {
        lines.Add($"  [red bold]{Markup.Escape(result.PlayerName)} has fallen![/]");
    }

    // Build panel
    var borderColor = result.IsCriticalHit ? Color.Green :
                      result.IsCriticalMiss || result.PlayerDefeated ? Color.Red :
                      Color.Yellow;

    var panel = new Panel(string.Join("\n", lines))
        .Header("[yellow]Combat Round[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(borderColor);

    AnsiConsole.Write(panel);

    // Show descriptor if present
    if (!string.IsNullOrEmpty(result.AttackDescriptor))
    {
        AnsiConsole.MarkupLine($"[italic grey]{Markup.Escape(result.AttackDescriptor)}[/]");
    }

    return Task.CompletedTask;
}

/// <summary>
/// Formats dice rolls with color coding.
/// </summary>
/// <param name="rolls">The individual die results.</param>
/// <param name="diceType">The type of dice rolled.</param>
/// <returns>Formatted string with Spectre markup.</returns>
private static string FormatDiceRolls(IReadOnlyList<int> rolls, string diceType)
{
    // Determine max value for the dice type
    var maxValue = diceType.ToUpperInvariant() switch
    {
        "D4" => 4,
        "D6" => 6,
        "D8" => 8,
        "D10" => 10,
        "D12" => 12,
        "D20" => 20,
        "D100" => 100,
        _ => int.MaxValue
    };

    var formattedRolls = rolls.Select(r =>
    {
        if (r == maxValue)
            return $"[green bold]{r}[/]";
        if (r == 1)
            return $"[red bold]{r}[/]";
        if (r >= maxValue * 0.75)
            return $"[green]{r}[/]";
        if (r <= maxValue * 0.25)
            return $"[red]{r}[/]";
        return $"[white]{r}[/]";
    });

    return $"[[{string.Join(", ", formattedRolls)}]]";
}
```

### Descriptor System

#### 9. dice-descriptors.json

**File:** `config/dice-descriptors.json`

```json
{
  "$schema": "dice-descriptors.schema.json",
  "descriptors": {
    "dice.natural_max": [
      "The dice shine with otherworldly luck!",
      "Fortune smiles upon your roll!",
      "A perfect cast!",
      "The dice seem to glow with inner light.",
      "Destiny favors you this moment."
    ],
    "dice.natural_one": [
      "The dice tumble with ill fortune...",
      "Fate turns against you.",
      "A dismal result.",
      "The dice seem to mock your efforts.",
      "Even the stones conspire against you."
    ],
    "dice.high_roll": [
      "A solid roll!",
      "The dice favor you.",
      "Well cast!"
    ],
    "dice.low_roll": [
      "The dice are not kind.",
      "A disappointing result.",
      "The roll could have been better."
    ],
    "skill.critical_success": [
      "Masterfully done!",
      "A display of true expertise!",
      "Perfection incarnate!",
      "You exceed all expectations!",
      "A legendary feat of skill!"
    ],
    "skill.critical_failure": [
      "A catastrophic blunder!",
      "Everything that could go wrong, did.",
      "A moment best forgotten...",
      "Embarrassingly poor execution.",
      "You couldn't have done worse if you tried."
    ],
    "skill.narrow_success": [
      "Just barely!",
      "By the skin of your teeth!",
      "A close call, but you made it."
    ],
    "skill.narrow_failure": [
      "So close, yet so far.",
      "Almost, but not quite.",
      "You came up just short."
    ],
    "skill.overwhelming_success": [
      "Child's play!",
      "You make it look easy.",
      "A triumphant success!"
    ],
    "skill.overwhelming_failure": [
      "Not even close.",
      "A complete disaster.",
      "You need much more practice."
    ],
    "combat.critical_hit": [
      "A devastating blow!",
      "You strike true!",
      "A mighty critical hit!",
      "Your weapon finds its mark perfectly!",
      "A blow that will be remembered!"
    ],
    "combat.critical_miss": [
      "Your attack goes wildly astray!",
      "A clumsy miss!",
      "You stumble badly!",
      "Your weapon swings through empty air.",
      "An embarrassing whiff!"
    ]
  }
}
```

---

## Integration with GameView

### 10. GameView Command Handling

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Views/GameView.cs` (additions)

```csharp
// Add dependencies
private readonly DiceService _diceService;
private readonly SkillCheckService _skillCheckService;
private readonly DiceDescriptorService _descriptorService;

// Update constructor to accept new dependencies
public GameView(
    GameSessionService gameService,
    IGameRenderer renderer,
    IInputHandler inputHandler,
    DiceService diceService,
    SkillCheckService skillCheckService,
    DiceDescriptorService descriptorService,
    ILogger<GameView> logger)
{
    // ... existing assignments ...
    _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
    _skillCheckService = skillCheckService ?? throw new ArgumentNullException(nameof(skillCheckService));
    _descriptorService = descriptorService ?? throw new ArgumentNullException(nameof(descriptorService));
}

// Add to ProcessCommandAsync switch:
case RollCommand rollCmd:
    _logger.LogDebug("Handling roll command: {Notation}", rollCmd.Notation);
    await HandleRollAsync(rollCmd.Notation, rollCmd.Advantage, ct);
    break;

case SkillCheckCommand checkCmd:
    _logger.LogDebug("Handling check command: {Skill}, DC: {DC}", checkCmd.SkillId, checkCmd.DifficultyId);
    await HandleSkillCheckAsync(checkCmd.SkillId, checkCmd.DifficultyId, checkCmd.Advantage, ct);
    break;

// Add handler methods:

/// <summary>
/// Handles the roll command to roll dice directly.
/// </summary>
/// <param name="notation">The dice notation to roll.</param>
/// <param name="advantage">Advantage/disadvantage modifier.</param>
/// <param name="ct">Cancellation token.</param>
private async Task HandleRollAsync(string notation, AdvantageType advantage, CancellationToken ct)
{
    try
    {
        var pool = DicePool.Parse(notation);
        var result = _diceService.Roll(pool, advantage);

        // Get descriptor
        var descriptor = _descriptorService.GetDiceRollDescriptor(result);

        // Create DTO
        var dto = DiceRollDto.FromDomainResult(result, descriptor);

        _logger.LogInformation("Dice roll: {Notation} = {Total}", notation, result.Total);
        await _renderer.RenderDiceRollAsync(dto, ct);
    }
    catch (FormatException ex)
    {
        _logger.LogWarning(ex, "Invalid dice notation: {Notation}", notation);
        await _renderer.RenderMessageAsync(
            $"Invalid dice notation: {ex.Message}. Use format like '3d6+5', '1d20', '2d8!'",
            MessageType.Warning, ct);
    }
}

/// <summary>
/// Handles the check command to perform a skill check.
/// </summary>
/// <param name="skillId">The skill to check.</param>
/// <param name="difficultyId">Optional difficulty class ID.</param>
/// <param name="advantage">Advantage/disadvantage modifier.</param>
/// <param name="ct">Cancellation token.</param>
private async Task HandleSkillCheckAsync(
    string skillId,
    string? difficultyId,
    AdvantageType advantage,
    CancellationToken ct)
{
    // Validate we have an active session
    if (_gameService.CurrentState == null)
    {
        await _renderer.RenderMessageAsync("No active game session.", MessageType.Warning, ct);
        return;
    }

    var player = _gameService.CurrentState.Player;

    try
    {
        // Default to "moderate" if no DC specified
        var dcId = difficultyId ?? "moderate";

        var result = _skillCheckService.PerformCheck(
            player.ToEntity(), // May need conversion method
            skillId,
            dcId,
            advantage);

        // Get descriptor
        var descriptor = _descriptorService.GetSkillCheckDescriptor(result);

        // Create DTO
        var dto = SkillCheckResultDto.FromDomainResult(result, descriptor);

        _logger.LogInformation(
            "Skill check: {Skill} vs DC {DC} = {Result}",
            result.SkillName, result.DifficultyClass, result.SuccessLevel);

        await _renderer.RenderSkillCheckAsync(dto, ct);
    }
    catch (ArgumentException ex) when (ex.Message.Contains("Unknown skill"))
    {
        _logger.LogWarning("Unknown skill requested: {Skill}", skillId);

        // Show available skills
        var skills = _skillCheckService.GetAllSkills();
        var skillList = string.Join(", ", skills.Select(s => s.Id));

        await _renderer.RenderMessageAsync(
            $"Unknown skill: '{skillId}'. Available skills: {skillList}",
            MessageType.Warning, ct);
    }
    catch (ArgumentException ex) when (ex.Message.Contains("Unknown difficulty"))
    {
        _logger.LogWarning("Unknown difficulty class requested: {DC}", difficultyId);

        // Show available DCs
        var dcs = _skillCheckService.GetDifficultyClasses();
        var dcList = string.Join(", ", dcs.Select(dc => $"{dc.Id} (DC {dc.TargetNumber})"));

        await _renderer.RenderMessageAsync(
            $"Unknown difficulty: '{difficultyId}'. Available: {dcList}",
            MessageType.Warning, ct);
    }
}
```

### 11. Update Help Text

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Views/GameView.cs` (update HandleHelpAsync)

```csharp
private Task HandleHelpAsync(CancellationToken ct)
{
    _logger.LogDebug("Displaying help menu");

    var helpTable = new Table()
        .Border(TableBorder.Rounded)
        .BorderColor(Color.Grey)
        .Title("[yellow]Commands[/]")
        .AddColumn(new TableColumn("[cyan]Command[/]"))
        .AddColumn(new TableColumn("[white]Description[/]"));

    // Movement
    helpTable.AddRow("[cyan]n, north[/]", "Move north");
    helpTable.AddRow("[cyan]s, south[/]", "Move south");
    helpTable.AddRow("[cyan]e, east[/]", "Move east");
    helpTable.AddRow("[cyan]w, west[/]", "Move west");

    // Exploration
    helpTable.AddRow("[cyan]look, l[/]", "Look around the current room");
    helpTable.AddRow("[cyan]examine <target>[/]", "Examine an item, monster, or room feature");

    // Inventory
    helpTable.AddRow("[cyan]inventory, i[/]", "View your inventory");
    helpTable.AddRow("[cyan]take <item>[/]", "Pick up an item");
    helpTable.AddRow("[cyan]drop <item>[/]", "Drop an item");
    helpTable.AddRow("[cyan]use <item>[/]", "Use/consume an item");

    // Combat & Abilities
    helpTable.AddRow("[cyan]attack, a[/]", "Attack an enemy");
    helpTable.AddRow("[cyan]abilities, ab[/]", "View your abilities");
    helpTable.AddRow("[cyan]cast <ability>[/]", "Use an ability");

    // Dice & Skills (NEW)
    helpTable.AddRow("[cyan]roll <notation>[/]", "Roll dice (e.g., 'roll 3d6+5', 'roll 1d20 adv')");
    helpTable.AddRow("[cyan]check <skill> [dc][/]", "Perform skill check (e.g., 'check perception moderate')");

    // Character
    helpTable.AddRow("[cyan]status[/]", "View character stats");

    // Game Management
    helpTable.AddRow("[cyan]save[/]", "Save your game");
    helpTable.AddRow("[cyan]load[/]", "Load a saved game");
    helpTable.AddRow("[cyan]help, h, ?[/]", "Show this help");
    helpTable.AddRow("[cyan]quit, q[/]", "Quit the game");

    AnsiConsole.Write(helpTable);

    // Add dice notation help
    AnsiConsole.WriteLine();
    var diceHelp = new Panel(
        "[grey]Dice Notation Examples:[/]\n" +
        "  [white]1d20[/]     - Roll one 20-sided die\n" +
        "  [white]3d6+5[/]    - Roll 3d6 and add 5\n" +
        "  [white]2d8-2[/]    - Roll 2d8 and subtract 2\n" +
        "  [white]1d6![/]     - Roll with exploding dice (reroll on max)\n" +
        "  [white]1d20 adv[/] - Roll with advantage (roll twice, take higher)")
        .Header("[cyan]Dice Help[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(Color.Grey);

    AnsiConsole.Write(diceHelp);

    return Task.CompletedTask;
}
```

---

## Testing Strategy

### Test Organization

```
tests/
+-- RuneAndRust.Application.UnitTests/
|   +-- Services/
|   |   +-- DiceDescriptorServiceTests.cs        (4 tests)
|   +-- Integration/
|       +-- RollCommandIntegrationTests.cs       (4 tests)
|       +-- SkillCheckCommandIntegrationTests.cs (4 tests)
```

### Test Files

#### 12. DiceDescriptorServiceTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Services/DiceDescriptorServiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class DiceDescriptorServiceTests
{
    private DiceDescriptorService _service = null!;
    private Mock<IGameConfigurationProvider> _mockConfig = null!;
    private Mock<ILogger<DiceDescriptorService>> _mockLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockConfig = new Mock<IGameConfigurationProvider>();
        _mockLogger = new Mock<ILogger<DiceDescriptorService>>();

        SetupDefaultDescriptors();

        // Use seeded random for deterministic tests
        var seededRandom = new Random(42);
        _service = new DiceDescriptorService(_mockConfig.Object, _mockLogger.Object, seededRandom);
    }

    private void SetupDefaultDescriptors()
    {
        var descriptors = new Dictionary<string, IReadOnlyList<string>>
        {
            ["dice.natural_max"] = new[] { "Perfect roll!" },
            ["dice.natural_one"] = new[] { "Terrible roll!" },
            ["skill.critical_success"] = new[] { "Amazing!" },
            ["skill.critical_failure"] = new[] { "Disaster!" },
            ["combat.critical_hit"] = new[] { "Devastating!" },
            ["combat.critical_miss"] = new[] { "Whiff!" }
        };

        _mockConfig.Setup(c => c.GetDiceDescriptors()).Returns(descriptors);
    }

    [Test]
    public void GetDescriptor_WhenCategoryExists_ReturnsDescriptor()
    {
        // Act
        var result = _service.GetDescriptor("dice.natural_max");

        // Assert
        result.Should().Be("Perfect roll!");
    }

    [Test]
    public void GetDescriptor_WhenCategoryNotFound_ReturnsNull()
    {
        // Act
        var result = _service.GetDescriptor("nonexistent.category");

        // Assert
        result.Should().BeNull();
    }

    [Test]
    public void GetDiceRollDescriptor_WhenNaturalMax_ReturnsCriticalDescriptor()
    {
        // Arrange
        var pool = new DicePool(1, DiceType.D10);
        var result = new DiceRollResult(pool, new[] { 10 }, 10);

        // Act
        var descriptor = _service.GetDiceRollDescriptor(result);

        // Assert
        descriptor.Should().Be("Perfect roll!");
    }

    [Test]
    public void GetSkillCheckDescriptor_WhenCriticalSuccess_ReturnsDescriptor()
    {
        // Arrange
        var pool = new DicePool(1, DiceType.D10);
        var diceResult = new DiceRollResult(pool, new[] { 10 }, 10);
        var skillResult = new SkillCheckResult(
            "perception", "Perception",
            diceResult,
            attributeBonus: 5,
            otherBonus: 0,
            difficultyClass: 12,
            difficultyName: "Moderate");

        // Act
        var descriptor = _service.GetSkillCheckDescriptor(skillResult);

        // Assert
        descriptor.Should().Be("Amazing!");
    }
}
```

#### 13. RollCommandIntegrationTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Integration/RollCommandIntegrationTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Integration;

[TestFixture]
public class RollCommandIntegrationTests
{
    private DiceService _diceService = null!;
    private Mock<ILogger<DiceService>> _mockDiceLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockDiceLogger = new Mock<ILogger<DiceService>>();

        // Use seeded random for deterministic tests
        var seededRandom = new Random(42);
        _diceService = new DiceService(_mockDiceLogger.Object, seededRandom);
    }

    [Test]
    public void Roll_WithValidNotation_ProducesResult()
    {
        // Arrange
        var pool = DicePool.Parse("3d6+5");

        // Act
        var result = _diceService.Roll(pool);

        // Assert
        result.Should().NotBeNull();
        result.Rolls.Should().HaveCount(3);
        result.Total.Should().BeGreaterThanOrEqualTo(8); // 3 + 5
        result.Total.Should().BeLessThanOrEqualTo(23);   // 18 + 5
    }

    [Test]
    public void Roll_WithAdvantage_RollsTwice()
    {
        // Arrange
        var pool = DicePool.Parse("1d20");

        // Act
        var result = _diceService.Roll(pool, AdvantageType.Advantage);

        // Assert
        result.AdvantageType.Should().Be(AdvantageType.Advantage);
        result.AllRollTotals.Should().HaveCount(2);
        result.Total.Should().Be(result.AllRollTotals.Max());
    }

    [Test]
    public void Roll_WithExplodingDice_CanExplode()
    {
        // This test uses a seeded random that should eventually produce max value
        // Arrange
        var pool = new DicePool(10, DiceType.D6, 0, true); // 10d6!

        // Act
        var result = _diceService.Roll(pool);

        // Assert - with 10 d6, statistically should have some explosions
        // (Note: this test may need adjustment based on seed)
        result.Should().NotBeNull();
    }

    [Test]
    public void Parse_WithInvalidNotation_ThrowsFormatException()
    {
        // Arrange & Act
        var act = () => DicePool.Parse("invalid");

        // Assert
        act.Should().Throw<FormatException>();
    }
}
```

#### 14. SkillCheckCommandIntegrationTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Integration/SkillCheckCommandIntegrationTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Integration;

[TestFixture]
public class SkillCheckCommandIntegrationTests
{
    private SkillCheckService _service = null!;
    private DiceService _diceService = null!;
    private Mock<IGameConfigurationProvider> _mockConfig = null!;
    private Mock<ILogger<SkillCheckService>> _mockLogger = null!;
    private Mock<ILogger<DiceService>> _mockDiceLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockConfig = new Mock<IGameConfigurationProvider>();
        _mockLogger = new Mock<ILogger<SkillCheckService>>();
        _mockDiceLogger = new Mock<ILogger<DiceService>>();

        SetupMocks();

        var seededRandom = new Random(42);
        _diceService = new DiceService(_mockDiceLogger.Object, seededRandom);
        _service = new SkillCheckService(_diceService, _mockConfig.Object, _mockLogger.Object);
    }

    private void SetupMocks()
    {
        var perception = SkillDefinition.Create(
            "perception", "Perception", "Notice things.",
            "wits", null, "1d10");

        var stealth = SkillDefinition.Create(
            "stealth", "Stealth", "Move silently.",
            "finesse", "wits", "1d10");

        _mockConfig.Setup(c => c.GetSkillById("perception")).Returns(perception);
        _mockConfig.Setup(c => c.GetSkillById("stealth")).Returns(stealth);
        _mockConfig.Setup(c => c.GetSkills())
            .Returns(new List<SkillDefinition> { perception, stealth });

        var moderate = DifficultyClassDefinition.Create(
            "moderate", "Moderate", "Requires effort.", 12);
        var hard = DifficultyClassDefinition.Create(
            "hard", "Hard", "Difficult.", 18);

        _mockConfig.Setup(c => c.GetDifficultyClassById("moderate")).Returns(moderate);
        _mockConfig.Setup(c => c.GetDifficultyClassById("hard")).Returns(hard);
        _mockConfig.Setup(c => c.GetDifficultyClasses())
            .Returns(new List<DifficultyClassDefinition> { moderate, hard });
    }

    private static Player CreateTestPlayer(int wits = 10, int finesse = 8)
    {
        var attributes = new PlayerAttributes(8, 8, 8, wits, finesse);
        return new Player("TestPlayer", "human", "soldier", attributes, "Test");
    }

    [Test]
    public void PerformCheck_WithValidSkillAndDC_ReturnsResult()
    {
        // Arrange
        var player = CreateTestPlayer(wits: 12);

        // Act
        var result = _service.PerformCheck(player, "perception", "moderate");

        // Assert
        result.SkillId.Should().Be("perception");
        result.SkillName.Should().Be("Perception");
        result.DifficultyClass.Should().Be(12);
        result.AttributeBonus.Should().Be(12); // wits value
    }

    [Test]
    public void PerformCheck_WithAdvantage_RollsTwice()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var result = _service.PerformCheck(
            player, "perception", "moderate", AdvantageType.Advantage);

        // Assert
        result.DiceResult.AdvantageType.Should().Be(AdvantageType.Advantage);
        result.DiceResult.AllRollTotals.Should().HaveCount(2);
    }

    [Test]
    public void PerformCheck_WithSecondaryAttribute_IncludesHalfBonus()
    {
        // Arrange
        var player = CreateTestPlayer(wits: 10, finesse: 8);

        // Act
        var result = _service.PerformCheck(player, "stealth", "moderate");

        // Assert
        // Stealth uses finesse (8) + wits/2 (5) = 13
        result.AttributeBonus.Should().Be(13);
    }

    [Test]
    public void PerformCheck_WithUnknownSkill_ThrowsArgumentException()
    {
        // Arrange
        var player = CreateTestPlayer();
        _mockConfig.Setup(c => c.GetSkillById("unknown")).Returns((SkillDefinition?)null);

        // Act
        var act = () => _service.PerformCheck(player, "unknown", "moderate");

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithMessage("Unknown skill: unknown*");
    }
}
```

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Service initialization | Debug | "DiceDescriptorService initialized" |
| Roll command received | Debug | "Handling roll command: 3d6+5" |
| Roll complete | Information | "Dice roll: 3d6+5 = 14" |
| Check command received | Debug | "Handling check command: perception, DC: moderate" |
| Check complete | Information | "Skill check: Perception vs DC 12 = Success" |
| Descriptor selected | Debug | "Selected descriptor for dice.natural_max: Perfect!" |
| Invalid notation | Warning | "Invalid dice notation: xyz" |
| Unknown skill | Warning | "Unknown skill requested: fake_skill" |
| Unknown DC | Warning | "Unknown difficulty class: fake_dc" |
| Descriptors loaded | Information | "Loaded 12 descriptor categories" |
| Descriptors failed | Warning | "Failed to load dice descriptors, using defaults" |

### Structured Logging Format

```csharp
_logger.LogInformation(
    "Dice roll complete: Notation={Notation} Total={Total} Rolls={@Rolls}",
    notation,
    result.Total,
    result.Rolls);

_logger.LogInformation(
    "Skill check: Skill={Skill} Roll={Roll} Bonus={Bonus} Total={Total} DC={DC} Result={Result}",
    result.SkillName,
    result.DiceResult.Total,
    result.TotalBonus,
    result.TotalResult,
    result.DifficultyClass,
    result.SuccessLevel);

_logger.LogDebug(
    "Descriptor selected: Category={Category} Descriptor={Descriptor}",
    category,
    selectedDescriptor);
```

---

## Implementation Checklist

### Command Layer
- [ ] Add `RollCommand` record to `IInputHandler.cs`
- [ ] Add `SkillCheckCommand` record to `IInputHandler.cs`
- [ ] Implement `ParseRollCommand()` in `ConsoleInputHandler.cs`
- [ ] Implement `ParseSkillCheckCommand()` in `ConsoleInputHandler.cs`
- [ ] Handle advantage/disadvantage flags in parsing

### Service Layer
- [ ] Create `DiceDescriptorService.cs`
  - [ ] `GetDescriptor(category)` method
  - [ ] `GetDiceRollDescriptor(result)` method
  - [ ] `GetSkillCheckDescriptor(result)` method
  - [ ] `GetCombatCriticalDescriptor(isCritical)` method
  - [ ] Default descriptors fallback
- [ ] Add `GetDiceDescriptors()` to `IGameConfigurationProvider`
- [ ] Implement `GetDiceDescriptors()` in `JsonConfigurationProvider`

### Presentation Layer
- [ ] Add `RenderDiceRollAsync()` to `IGameRenderer`
- [ ] Add `RenderSkillCheckAsync()` to `IGameRenderer`
- [ ] Add `RenderCombatRoundAsync()` to `IGameRenderer`
- [ ] Implement `RenderDiceRollAsync()` in `SpectreGameRenderer`
- [ ] Implement `RenderSkillCheckAsync()` in `SpectreGameRenderer`
- [ ] Implement `RenderCombatRoundAsync()` in `SpectreGameRenderer`
- [ ] Implement `FormatDiceRolls()` helper method
- [ ] Create `CombatRoundResultDto` in `CombatDtos.cs`
- [ ] Create `MonsterCounterAttackDto` in `CombatDtos.cs`

### GameView Integration
- [ ] Add `DiceService`, `SkillCheckService`, `DiceDescriptorService` dependencies
- [ ] Add `RollCommand` case to `ProcessCommandAsync`
- [ ] Add `SkillCheckCommand` case to `ProcessCommandAsync`
- [ ] Implement `HandleRollAsync()` method
- [ ] Implement `HandleSkillCheckAsync()` method
- [ ] Update `HandleHelpAsync()` with dice commands

### Configuration
- [ ] Create `config/dice-descriptors.json`
  - [ ] `dice.natural_max` descriptors
  - [ ] `dice.natural_one` descriptors
  - [ ] `dice.high_roll` descriptors
  - [ ] `dice.low_roll` descriptors
  - [ ] `skill.critical_success` descriptors
  - [ ] `skill.critical_failure` descriptors
  - [ ] `skill.narrow_success` descriptors
  - [ ] `skill.narrow_failure` descriptors
  - [ ] `skill.overwhelming_success` descriptors
  - [ ] `skill.overwhelming_failure` descriptors
  - [ ] `combat.critical_hit` descriptors
  - [ ] `combat.critical_miss` descriptors

### Tests
- [ ] Create `DiceDescriptorServiceTests.cs` (4 tests)
- [ ] Create `RollCommandIntegrationTests.cs` (4 tests)
- [ ] Create `SkillCheckCommandIntegrationTests.cs` (4 tests)

### Validation
- [ ] All 12 new tests pass
- [ ] All existing tests pass (~260)
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | `roll <notation>` command is recognized and parsed | Unit test |
| AC-2 | `roll` with advantage flag works (`roll 1d20 adv`) | Unit test |
| AC-3 | Invalid dice notation produces helpful error | Manual test |
| AC-4 | `check <skill>` command is recognized and parsed | Unit test |
| AC-5 | `check` defaults to "moderate" DC when not specified | Unit test |
| AC-6 | Unknown skill shows available skills | Manual test |
| AC-7 | Unknown DC shows available difficulty classes | Manual test |
| AC-8 | Dice rolls display with color-coded individual dice | Manual test |
| AC-9 | Natural max displays as green with CRITICAL label | Manual test |
| AC-10 | Natural 1 displays as red with FUMBLE label | Manual test |
| AC-11 | Skill checks show complete breakdown | Manual test |
| AC-12 | Combat rounds show full dice breakdown | Manual test |
| AC-13 | Descriptors appear for critical results | Manual test |
| AC-14 | Help text includes dice commands | Manual test |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | Command parsing handles edge cases gracefully | Unit test |
| NF-2 | Renderer methods are async-compatible | Code review |
| NF-3 | Descriptors load with fallback to defaults | Unit test |
| NF-4 | All public APIs documented with XML | Code review |
| NF-5 | Logging at appropriate levels | Code review |
| NF-6 | No breaking changes to existing code | Test suite |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| DiceService/SkillCheckService changes from 5a/5b | Medium | Low | Use interfaces where possible |
| CombatRoundResult changes from 5c | Medium | Medium | Verify 5c complete before integrating |
| SpectreConsole markup escaping issues | Low | Medium | Test with special characters |
| Descriptor file missing in deployment | Low | Medium | Default descriptors fallback |
| GameView constructor parameter overload | Medium | Low | Consider factory pattern if needed |
| Test flakiness with random descriptors | Low | Medium | Use seeded Random in tests |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Application/Services/DiceDescriptorService.cs` | Descriptor selection service | ~150 |
| `Application/DTOs/CombatDtos.cs` | Combat round result DTOs | ~120 |
| `config/dice-descriptors.json` | Descriptor configuration | ~100 |
| `Tests/.../DiceDescriptorServiceTests.cs` | Descriptor service tests | ~80 |
| `Tests/.../RollCommandIntegrationTests.cs` | Roll command tests | ~70 |
| `Tests/.../SkillCheckCommandIntegrationTests.cs` | Check command tests | ~100 |

### Files to Modify

| File | Changes | Est. Lines |
|------|---------|------------|
| `Application/Interfaces/IInputHandler.cs` | Add 2 command records | +20 |
| `Application/Interfaces/IGameRenderer.cs` | Add 3 render methods | +30 |
| `Application/Interfaces/IConfigurationProvider.cs` | Add descriptor method | +10 |
| `Presentation.Tui/Adapters/ConsoleInputHandler.cs` | Add parsing methods | +80 |
| `Presentation.Tui/Adapters/SpectreGameRenderer.cs` | Add render implementations | +200 |
| `Presentation.Tui/Views/GameView.cs` | Add handlers, update help | +120 |
| `Infrastructure/Configuration/JsonConfigurationProvider.cs` | Add descriptor loading | +50 |

### Final Metrics (v0.0.5 Complete)

| Metric | Before v0.0.5d | After v0.0.5d |
|--------|----------------|---------------|
| Domain Value Objects | 10 | 10 |
| Domain Definitions | 8 | 8 |
| Application Services | 12 | 13 |
| Application DTOs | 18 | 20 |
| Renderer Methods | 9 | 12 |
| Command Types | 13 | 15 |
| Config Files | 11 | 12 |
| Unit Tests | ~260 | ~272 |

---

## Completion Criteria for v0.0.5

When v0.0.5d is complete, the v0.0.5 Dice Pool System milestone will be fully implemented:

| Sub-version | Feature | Tests | Status |
|-------------|---------|-------|--------|
| v0.0.5a | Core Dice Engine | 18 | Required |
| v0.0.5b | Skill Check System | 20 | Required |
| v0.0.5c | Combat Integration | 15 | Required |
| **v0.0.5d** | **Configuration & Polish** | **12** | **This Plan** |

**Total v0.0.5 Features:**
- Complete dice rolling engine with standard dice types
- Dice notation parsing (e.g., "3d6+5", "1d20!", "2d8")
- Advantage/disadvantage mechanics
- Exploding dice support
- Skill check system with 10 skills and 8 difficulty classes
- Attribute-based skill bonuses
- Critical success/failure mechanics
- Dice-based combat with attack and damage rolls
- Combat critical hits doubling damage dice
- User commands for direct dice rolling and skill checks
- Rich visual rendering with color-coded dice
- Flavor text descriptors for notable results

---

## Next Steps

After completing v0.0.5d:

1. **v0.0.6 (Enhanced Combat)** - Multi-target abilities, status effects, combat positioning
2. **v0.0.7 (Progression System)** - Experience points, leveling, skill improvements
3. **v0.0.8 (Dungeon Generation)** - Procedural dungeon layouts, room templates

The dice pool system provides the foundation for all future randomized mechanics in the game.

---

*This implementation plan provides a comprehensive roadmap for completing v0.0.5d and the entire v0.0.5 Dice Pool System milestone. It integrates the dice, skill check, and combat systems from phases 5a-5c with a polished presentation layer and user commands.*
