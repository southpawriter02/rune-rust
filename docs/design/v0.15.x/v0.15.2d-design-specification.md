# v0.15.2d Design Specification: Stealth Movement

**Version:** 0.15.2d
**Theme:** Stealth Movement
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.2a-c Complete (Climbing, Leaping, Fall Damage Systems)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [StealthSurface Enum](#4-stealthsurface-enum)
5. [HiddenStatus Entity](#5-hiddenstatus-entity)
6. [HiddenBreakCondition Enum](#6-hiddenbreakcondition-enum)
7. [StealthContext Value Object](#7-stealthcontext-value-object)
8. [StealthCheckResult Value Object](#8-stealthcheckresult-value-object)
9. [PartyStealthResult Value Object](#9-partystealthresult-value-object)
10. [IStealthService Interface](#10-istealthservice-interface)
11. [StealthService Implementation](#11-stealthservice-implementation)
12. [SystemWideAlert Fumble Integration](#12-systemwidealert-fumble-integration)
13. [Configuration](#13-configuration)
14. [Commands](#14-commands)
15. [User-Facing Changes](#15-user-facing-changes)
16. [Logging Specifications](#16-logging-specifications)
17. [Unit Testing Requirements](#17-unit-testing-requirements)
18. [Use Cases](#18-use-cases)
19. [Deliverable Checklist](#19-deliverable-checklist)
20. [Acceptance Criteria](#20-acceptance-criteria)
21. [Future Considerations](#21-future-considerations)
22. [Implementation Notes](#22-implementation-notes)
23. [Document Metadata](#23-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.2d, the Stealth Movement phase. This part introduces surface-based stealth mechanics, the [Hidden] status effect, and party stealth using the weakest-link rule. The key components are:

1. **StealthSurface Enum**: Categorizes surfaces by noise level, determining stealth DCs from Silent (DC 2) to Very Noisy (DC 5).

2. **HiddenStatus Entity**: Tracks the [Hidden] state for characters, including when they entered, what will reveal them, and detection modifiers.

3. **PartyStealthResult Value Object**: Captures party stealth attempts where the character with the lowest dice pool makes the check for everyone.

4. **StealthService**: Orchestrates stealth checks, [Hidden] status management, and party stealth coordination.

This infrastructure enables tactical stealth gameplay with meaningful surface considerations and party coordination requirements.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Stealth Checks** | Basic skill check | Surface-based DC with environmental modifiers |
| **[Hidden] Status** | Not implemented | Full status tracking with break conditions |
| **Party Stealth** | Individual checks | Weakest-link party coordination |
| **Surface Types** | Not implemented | Silent/Normal/Noisy/VeryNoisy classification |
| **Environmental Mods** | Not implemented | Lighting, alert status, zone effects |
| **Fumble Effects** | Narrative only | [System-Wide Alert] with room propagation |

### 1.3 Scope

**In Scope:**
- Define `StealthSurface` enum with DC mapping
- Define `HiddenBreakCondition` enum for reveal triggers
- Define `HiddenStatus` entity for [Hidden] state tracking
- Define `StealthContext` value object for stealth configuration
- Define `StealthCheckResult` value object for stealth outcomes
- Define `PartyStealthResult` value object for party coordination
- Create `IStealthService` interface for stealth operations
- Implement `StealthService` with surface and party mechanics
- Integrate `SystemWideAlert` fumble consequence
- Configuration file `stealth-surfaces.json`
- Unit tests for stealth mechanics (~4 tests)

**Out of Scope:**
- Chase sequences - v0.15.2e
- Balance checks - v0.15.2f
- Specialization integration (Myrk-gengr abilities) - v0.15.2g
- Enemy perception AI - future version
- Sound propagation system - future version

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 2 | `StealthSurface`, `HiddenBreakCondition` |
| Entities | 1 | `HiddenStatus` |
| Value Objects | 3 | `StealthContext`, `StealthCheckResult`, `PartyStealthResult` |
| Interfaces | 1 | `IStealthService` |
| Services | 1 | `StealthService` |
| Configuration | 1 | `stealth-surfaces.json` |
| Unit Tests | ~4 | Surface DC, [Hidden] targeting, party weakest-link, fumble alert |

---

## 2. Dependencies

### 2.1 Required from v0.15.0 (Dice Pool Refactor)

| Component | Location | Usage in v0.15.2d |
|-----------|----------|-------------------|
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Provides `NetSuccesses`, `IsFumble` for stealth checks |
| `DiceConstants` | `Domain/Constants/DiceConstants.cs` | Success threshold (8), botch value (1) |
| `IDiceRollerService` | `Application/Interfaces/IDiceRollerService.cs` | Performs stealth check dice rolls |

### 2.2 Required from v0.15.1a (Skill Context & Modifiers)

| Component | Location | Usage in v0.15.2d |
|-----------|----------|-------------------|
| `SkillContext` | `Domain/ValueObjects/SkillContext.cs` | Passed to stealth checks with modifiers |
| `SkillContextBuilder` | `Application/Services/SkillContextBuilder.cs` | Builds context for stealth attempts |
| `EnvironmentModifier` | `Domain/ValueObjects/EnvironmentModifier.cs` | Lighting, zone modifiers |

### 2.3 Required from v0.15.1b (Outcome Classification)

| Component | Location | Usage in v0.15.2d |
|-----------|----------|-------------------|
| `SkillOutcome` | `Domain/Enums/SkillOutcome.cs` | Stealth result classification |
| `FumbleType` | `Domain/Enums/FumbleType.cs` | `SystemWideAlert` for stealth fumbles |
| `FumbleConsequenceService` | `Application/Services/FumbleConsequenceService.cs` | Triggers `SystemWideAlert` on fumble |

### 2.4 Required from v0.10.x (Status Effects)

| Component | Location | Usage in v0.15.2d |
|-----------|----------|-------------------|
| `IStatusEffectService` | `Application/Interfaces/IStatusEffectService.cs` | Manages [Hidden] status |
| `StatusEffectType` | `Domain/Enums/StatusEffectType.cs` | `Hidden` status type |

### 2.5 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.2e | Chase Sequences | Stealth-based escape attempts |
| v0.15.2g | Myrk-gengr | `[Slip into Shadow]`, `[Ghostly Form]` abilities |
| v0.11.x | Combat System | [Hidden] targeting restrictions |

---

## 3. Architecture Diagrams

### 3.1 Stealth Check Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          STEALTH CHECK FLOW                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  STEALTH REQUEST                                                            │
│  Player: "sneak" or "hide"                                                  │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    BUILD STEALTH CONTEXT                            │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  StealthContext                                                     │    │
│  │  ├── SurfaceType: Noisy (loose rubble)                              │    │
│  │  ├── BaseDc: 4 (from surface type)                                  │    │
│  │  ├── LightingModifier: -1 (Dim Light)                               │    │
│  │  ├── AlertModifier: +1 (Enemy Alerted)                              │    │
│  │  ├── ZoneModifier: 0 (no special zone)                              │    │
│  │  └── IsPartyCheck: false                                            │    │
│  │                                                                      │    │
│  │  DC Calculation:                                                    │    │
│  │  ├── Base DC (Noisy): 4 successes                                   │    │
│  │  ├── Dim Light: -1                                                  │    │
│  │  ├── Enemy Alerted: +1                                              │    │
│  │  └── Final DC: 4 successes                                          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    PERFORM SKILL CHECK                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Dice Pool: 5d10 (Acrobatics 3 + Finesse 2)                         │    │
│  │  Roll: [9, 4, 8, 10, 3] → 3 successes, 0 botches                    │    │
│  │  vs DC 4                                                            │    │
│  │                                                                      │    │
│  │  Net Successes: 3                                                   │    │
│  │  Margin: 3 - 4 = -1 (failure)                                       │    │
│  │                                                                      │    │
│  │  Outcome: Failure                                                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    DETERMINE RESULT                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  SUCCESS OUTCOMES:                                                  │    │
│  │  ├── Margin ≥ 5 (Critical) → [Hidden] + advantage on first attack   │    │
│  │  ├── Margin 1-4           → [Hidden] status applied                 │    │
│  │  └── Margin 0             → [Hidden] but enemies suspicious         │    │
│  │                                                                      │    │
│  │  FAILURE OUTCOMES:                                                  │    │
│  │  ├── Margin < 0           → Detected, not [Hidden]                  │    │
│  │  └── Fumble (0 + botch)   → [System-Wide Alert] triggered           │    │
│  │                                                                      │    │
│  │  Result: Failure - Character detected, not hidden                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  OUTPUT: StealthCheckResult.BecameHidden = false                            │
│          Enemies in room are now aware of character                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 [Hidden] Status Lifecycle

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        [HIDDEN] STATUS LIFECYCLE                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ENTRY CONDITIONS                                                           │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐           │
│  │  hide command   │   │ [Slip into      │   │ [One with the   │           │
│  │  (skill check)  │   │  Shadow] ability│   │  Static] zone   │           │
│  └────────┬────────┘   └────────┬────────┘   └────────┬────────┘           │
│           │                     │                     │                     │
│           └──────────────┬──────┴─────────────────────┘                     │
│                          │                                                   │
│                          ▼                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      [HIDDEN] STATUS ACTIVE                         │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  EFFECTS WHILE [HIDDEN]:                                            │    │
│  │  ├── Cannot be directly targeted by single-target attacks           │    │
│  │  ├── Can still be hit by AoE abilities                              │    │
│  │  ├── Grants advantage on first attack from hiding                   │    │
│  │  └── Detection modifier affects enemy Perception checks             │    │
│  │                                                                      │    │
│  │  HiddenStatus Entity:                                               │    │
│  │  ├── CharacterId: "player-1"                                        │    │
│  │  ├── IsHidden: true                                                 │    │
│  │  ├── HiddenSince: 2026-01-17T10:30:00Z                              │    │
│  │  ├── BreakConditions: [Attack, LoudAction, EnemyCriticalPerception] │    │
│  │  └── DetectionModifier: +2 (harder to spot)                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                          │                                                   │
│                          ▼                                                   │
│  EXIT CONDITIONS (BREAK CONDITIONS)                                         │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐           │
│  │    Attacking    │   │   Loud Action   │   │ Enemy Critical  │           │
│  │                 │   │ (yelling, etc)  │   │   Perception    │           │
│  └────────┬────────┘   └────────┬────────┘   └────────┬────────┘           │
│           │                     │                     │                     │
│           ├─────────────────────┼─────────────────────┤                     │
│           │                     │                     │                     │
│           ▼                     ▼                     ▼                     │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    [HIDDEN] STATUS REMOVED                          │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Character is now visible to all enemies                           │    │
│  │  Combat proceeds normally                                           │    │
│  │                                                                      │    │
│  │  EXCEPTION: [Ghostly Form] ability (Myrk-gengr)                     │    │
│  │  └── Once per encounter: Stay [Hidden] after attacking              │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  RE-ENTRY CONDITIONS:                                                       │
│  ├── Use `hide` command (requires line-of-sight break or distraction)      │
│  ├── Use specialization ability ([Slip into Shadow])                       │
│  └── Enter [Psychic Resonance] zone with [One with the Static]             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Party Stealth (Weakest Link)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       PARTY STEALTH (WEAKEST LINK)                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PARTY STEALTH REQUEST                                                      │
│  Leader: "party sneak" or system auto-triggers on party movement            │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    DETERMINE WEAKEST MEMBER                         │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Party Members' Acrobatics Pools:                                   │    │
│  │  ├── Kira (Gantry-Runner):  7d10  [Acrobatics 4 + Finesse 3]        │    │
│  │  ├── Theron (Scrap-Tinker): 4d10  [Acrobatics 2 + Finesse 2]        │    │
│  │  └── Elara (Myrk-gengr):    6d10  [Acrobatics 3 + Finesse 3]        │    │
│  │                                                                      │    │
│  │  Weakest Link: Theron (4d10)                                        │    │
│  │                                                                      │    │
│  │  NOTE: Party check uses the LOWEST pool member's roll               │    │
│  │        "A chain is only as strong as its weakest link"              │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    THERON MAKES THE CHECK                           │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Dice Pool: 4d10                                                    │    │
│  │  Surface: Normal (DC 3)                                             │    │
│  │  Modifiers: None                                                    │    │
│  │                                                                      │    │
│  │  Roll: [8, 5, 9, 2] → 2 successes, 0 botches                        │    │
│  │  vs DC 3                                                            │    │
│  │                                                                      │    │
│  │  Margin: 2 - 3 = -1 (failure)                                       │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    PARTY DETECTED                                   │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  PartyStealthResult:                                                │    │
│  │  ├── ParticipantIds: [Kira, Theron, Elara]                          │    │
│  │  ├── WeakestMemberId: Theron                                        │    │
│  │  ├── WeakestPool: 4d10                                              │    │
│  │  ├── Outcome: Failure                                               │    │
│  │  └── DetectedBy: [Guard-1, Guard-2] (enemies in room)               │    │
│  │                                                                      │    │
│  │  RESULT: Entire party is now visible to enemies                     │    │
│  │  MESSAGE: "Theron's armor clinks loudly against the rubble,         │    │
│  │           alerting the guards to your party's presence!"            │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  OPTIONAL ENHANCEMENT: [Cloak the Party] (Myrk-gengr)                       │
│  └── Grants party +2d10 on Passive Stealth checks                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       STEALTH SYSTEM LAYER ARCHITECTURE                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Enums/                                                             │    │
│  │  ├── StealthSurface.cs              ←── NEW                         │    │
│  │  ├── HiddenBreakCondition.cs        ←── NEW                         │    │
│  │  └── FumbleType.cs                  ←── FROM v0.15.1b (SystemWideAlert)│  │
│  │                                                                      │    │
│  │  Entities/                                                          │    │
│  │  └── HiddenStatus.cs                ←── NEW                         │    │
│  │                                                                      │    │
│  │  ValueObjects/                                                      │    │
│  │  ├── StealthContext.cs              ←── NEW                         │    │
│  │  ├── StealthCheckResult.cs          ←── NEW                         │    │
│  │  └── PartyStealthResult.cs          ←── NEW                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Interfaces/                                                        │    │
│  │  └── IStealthService.cs             ←── NEW                         │    │
│  │                                                                      │    │
│  │  Services/                                                          │    │
│  │  └── StealthService.cs              ←── NEW                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  INFRASTRUCTURE LAYER                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Configuration/                                                     │    │
│  │  └── stealth-surfaces.json          ←── NEW                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. StealthSurface Enum

### 4.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/StealthSurface.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of surfaces affecting stealth movement checks.
/// </summary>
/// <remarks>
/// <para>
/// Surface types determine the base DC for stealth checks. Noisier surfaces
/// require more successes to move silently. The DC values use the success-counting
/// system where each value represents successes needed.
/// </para>
/// <para>
/// Surface type is determined by the environment's floor composition and
/// can vary within a single room or area.
/// </para>
/// </remarks>
public enum StealthSurface
{
    /// <summary>
    /// Silent surface that absorbs sound.
    /// Base DC: 2 successes.
    /// </summary>
    /// <example>
    /// Thick carpet, moss-covered stone, deep sand, padded flooring.
    /// </example>
    Silent = 0,

    /// <summary>
    /// Normal surface with standard noise characteristics.
    /// Base DC: 3 successes.
    /// </summary>
    /// <example>
    /// Concrete, packed dirt, solid wood flooring, smooth stone.
    /// </example>
    Normal = 1,

    /// <summary>
    /// Noisy surface that amplifies footsteps.
    /// Base DC: 4 successes.
    /// </summary>
    /// <example>
    /// Loose rubble, gravel, dry leaves, creaky wooden boards.
    /// </example>
    Noisy = 2,

    /// <summary>
    /// Very noisy surface that makes silent movement nearly impossible.
    /// Base DC: 5 successes.
    /// </summary>
    /// <example>
    /// Scrap metal piles, broken glass, metal grating, chains.
    /// </example>
    VeryNoisy = 3
}
```

### 4.2 Surface Type Extensions

**File:** `src/Core/RuneAndRust.Domain/Extensions/StealthSurfaceExtensions.cs`

```csharp
namespace RuneAndRust.Domain.Extensions;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Extension methods for <see cref="StealthSurface"/> enum.
/// </summary>
public static class StealthSurfaceExtensions
{
    /// <summary>
    /// Gets the base DC for stealth checks on this surface type.
    /// </summary>
    /// <param name="surface">The surface type.</param>
    /// <returns>
    /// The base DC in successes needed: Silent (2), Normal (3), Noisy (4), VeryNoisy (5).
    /// </returns>
    public static int GetBaseDc(this StealthSurface surface)
    {
        return surface switch
        {
            StealthSurface.Silent => 2,
            StealthSurface.Normal => 3,
            StealthSurface.Noisy => 4,
            StealthSurface.VeryNoisy => 5,
            _ => 3
        };
    }

    /// <summary>
    /// Gets a human-readable description of the surface type.
    /// </summary>
    /// <param name="surface">The surface type.</param>
    /// <returns>A descriptive string for UI display.</returns>
    public static string GetDescription(this StealthSurface surface)
    {
        return surface switch
        {
            StealthSurface.Silent => "Silent surface (DC 2)",
            StealthSurface.Normal => "Normal surface (DC 3)",
            StealthSurface.Noisy => "Noisy surface (DC 4)",
            StealthSurface.VeryNoisy => "Very noisy surface (DC 5)",
            _ => "Unknown surface"
        };
    }

    /// <summary>
    /// Gets example materials for this surface type.
    /// </summary>
    /// <param name="surface">The surface type.</param>
    /// <returns>Array of example material names.</returns>
    public static string[] GetExamples(this StealthSurface surface)
    {
        return surface switch
        {
            StealthSurface.Silent => new[] { "carpet", "moss", "sand", "padding" },
            StealthSurface.Normal => new[] { "concrete", "dirt", "wood", "stone" },
            StealthSurface.Noisy => new[] { "rubble", "gravel", "leaves", "creaky boards" },
            StealthSurface.VeryNoisy => new[] { "scrap metal", "broken glass", "metal grating", "chains" },
            _ => Array.Empty<string>()
        };
    }

    /// <summary>
    /// Gets whether this surface allows natural silent movement.
    /// </summary>
    /// <param name="surface">The surface type.</param>
    /// <returns>True if DC ≤ 2, allowing easier stealth.</returns>
    public static bool IsNaturallySilent(this StealthSurface surface)
    {
        return surface == StealthSurface.Silent;
    }
}
```

---

## 5. HiddenStatus Entity

### 5.1 Entity Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/HiddenStatus.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Tracks the [Hidden] status for a character.
/// </summary>
/// <remarks>
/// <para>
/// The [Hidden] status provides significant tactical advantages:
/// <list type="bullet">
///   <item><description>Cannot be directly targeted by single-target attacks</description></item>
///   <item><description>Can still be hit by AoE abilities</description></item>
///   <item><description>First attack from hiding grants advantage</description></item>
///   <item><description>Enemies must pass Perception checks to detect</description></item>
/// </list>
/// </para>
/// <para>
/// [Hidden] is broken by attacking, loud actions, or enemy critical Perception.
/// Certain specialization abilities allow maintaining or re-entering [Hidden].
/// </para>
/// </remarks>
public sealed class HiddenStatus
{
    /// <summary>
    /// Gets the unique identifier for this hidden status instance.
    /// </summary>
    public string HiddenId { get; private set; }

    /// <summary>
    /// Gets the identifier of the character who is hidden.
    /// </summary>
    public string CharacterId { get; private set; }

    /// <summary>
    /// Gets a value indicating whether the character is currently hidden.
    /// </summary>
    public bool IsHidden { get; private set; }

    /// <summary>
    /// Gets the timestamp when the character entered [Hidden] state.
    /// </summary>
    public DateTime HiddenSince { get; private set; }

    /// <summary>
    /// Gets the timestamp when [Hidden] was broken, if applicable.
    /// </summary>
    public DateTime? BrokenAt { get; private set; }

    /// <summary>
    /// Gets the conditions that will break the [Hidden] status.
    /// </summary>
    public IReadOnlyList<HiddenBreakCondition> BreakConditions => _breakConditions.AsReadOnly();
    private readonly List<HiddenBreakCondition> _breakConditions;

    /// <summary>
    /// Gets the detection modifier for enemies trying to spot this character.
    /// </summary>
    /// <remarks>
    /// Positive values make the character harder to detect.
    /// Added to the DC for enemy Perception checks.
    /// </remarks>
    public int DetectionModifier { get; private set; }

    /// <summary>
    /// Gets the condition that broke [Hidden], if applicable.
    /// </summary>
    public HiddenBreakCondition? BrokenBy { get; private set; }

    /// <summary>
    /// Gets a value indicating whether the character has used their "from hiding" attack bonus.
    /// </summary>
    public bool HasUsedHidingBonus { get; private set; }

    /// <summary>
    /// Gets the source of this [Hidden] status.
    /// </summary>
    public string Source { get; private set; }

    // Private constructor for factory pattern
    private HiddenStatus()
    {
        HiddenId = string.Empty;
        CharacterId = string.Empty;
        Source = string.Empty;
        _breakConditions = new List<HiddenBreakCondition>();
    }

    /// <summary>
    /// Creates a new [Hidden] status for a character via successful stealth check.
    /// </summary>
    /// <param name="characterId">The ID of the character becoming hidden.</param>
    /// <param name="detectionModifier">Modifier to enemy Perception DCs (default 0).</param>
    /// <returns>A new HiddenStatus in the active [Hidden] state.</returns>
    public static HiddenStatus FromStealthCheck(string characterId, int detectionModifier = 0)
    {
        return new HiddenStatus
        {
            HiddenId = Guid.NewGuid().ToString(),
            CharacterId = characterId,
            IsHidden = true,
            HiddenSince = DateTime.UtcNow,
            DetectionModifier = detectionModifier,
            Source = "StealthCheck",
            _breakConditions =
            {
                HiddenBreakCondition.Attack,
                HiddenBreakCondition.LoudAction,
                HiddenBreakCondition.EnemyCriticalPerception
            }
        };
    }

    /// <summary>
    /// Creates a new [Hidden] status via [Slip into Shadow] ability.
    /// </summary>
    /// <param name="characterId">The ID of the character becoming hidden.</param>
    /// <returns>A new HiddenStatus with enhanced detection modifier.</returns>
    /// <remarks>
    /// [Slip into Shadow] grants +1 detection modifier compared to normal stealth.
    /// </remarks>
    public static HiddenStatus FromSlipIntoShadow(string characterId)
    {
        return new HiddenStatus
        {
            HiddenId = Guid.NewGuid().ToString(),
            CharacterId = characterId,
            IsHidden = true,
            HiddenSince = DateTime.UtcNow,
            DetectionModifier = 1, // Enhanced from ability
            Source = "SlipIntoShadow",
            _breakConditions =
            {
                HiddenBreakCondition.Attack,
                HiddenBreakCondition.LoudAction,
                HiddenBreakCondition.EnemyCriticalPerception
            }
        };
    }

    /// <summary>
    /// Creates a new [Hidden] status via [One with the Static] in [Psychic Resonance] zones.
    /// </summary>
    /// <param name="characterId">The ID of the character becoming hidden.</param>
    /// <returns>A new HiddenStatus with zone-specific break conditions.</returns>
    public static HiddenStatus FromOneWithTheStatic(string characterId)
    {
        return new HiddenStatus
        {
            HiddenId = Guid.NewGuid().ToString(),
            CharacterId = characterId,
            IsHidden = true,
            HiddenSince = DateTime.UtcNow,
            DetectionModifier = 2, // Strong bonus in corruption zones
            Source = "OneWithTheStatic",
            _breakConditions =
            {
                HiddenBreakCondition.Attack,
                HiddenBreakCondition.LoudAction,
                HiddenBreakCondition.EnemyCriticalPerception,
                HiddenBreakCondition.LeaveZone
            }
        };
    }

    /// <summary>
    /// Breaks the [Hidden] status due to a specific condition.
    /// </summary>
    /// <param name="condition">The condition that broke [Hidden].</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown when already not hidden.
    /// </exception>
    public void Break(HiddenBreakCondition condition)
    {
        if (!IsHidden)
        {
            throw new InvalidOperationException("Cannot break [Hidden] status - character is not hidden.");
        }

        IsHidden = false;
        BrokenAt = DateTime.UtcNow;
        BrokenBy = condition;
    }

    /// <summary>
    /// Marks that the character has used their "from hiding" attack advantage.
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// Thrown when not hidden or bonus already used.
    /// </exception>
    public void UseHidingBonus()
    {
        if (!IsHidden)
        {
            throw new InvalidOperationException("Cannot use hiding bonus - character is not hidden.");
        }

        if (HasUsedHidingBonus)
        {
            throw new InvalidOperationException("Hiding bonus has already been used.");
        }

        HasUsedHidingBonus = true;
    }

    /// <summary>
    /// Checks if a specific condition would break this [Hidden] status.
    /// </summary>
    /// <param name="condition">The condition to check.</param>
    /// <returns>True if this condition would break [Hidden].</returns>
    public bool WouldBreak(HiddenBreakCondition condition)
    {
        return IsHidden && _breakConditions.Contains(condition);
    }

    /// <summary>
    /// Gets a description of the [Hidden] status for display.
    /// </summary>
    /// <returns>A human-readable status description.</returns>
    public string ToDescription()
    {
        if (!IsHidden)
        {
            var brokenStr = BrokenBy.HasValue
                ? $" (broken by {BrokenBy.Value})"
                : "";
            return $"Not hidden{brokenStr}";
        }

        var durationSeconds = (DateTime.UtcNow - HiddenSince).TotalSeconds;
        var modStr = DetectionModifier != 0
            ? $", Detection +{DetectionModifier}"
            : "";
        var bonusStr = HasUsedHidingBonus
            ? ", attack bonus used"
            : ", attack bonus available";

        return $"[Hidden] for {durationSeconds:F0}s{modStr}{bonusStr}";
    }

    /// <inheritdoc/>
    public override string ToString() => ToDescription();
}
```

---

## 6. HiddenBreakCondition Enum

### 6.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/HiddenBreakCondition.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Conditions that can break the [Hidden] status.
/// </summary>
/// <remarks>
/// <para>
/// When a character with [Hidden] status triggers one of these conditions,
/// their [Hidden] status is immediately removed unless modified by abilities.
/// </para>
/// </remarks>
public enum HiddenBreakCondition
{
    /// <summary>
    /// Making any attack breaks [Hidden].
    /// </summary>
    /// <remarks>
    /// Exception: [Ghostly Form] ability allows staying hidden after attacking once per encounter.
    /// </remarks>
    Attack = 0,

    /// <summary>
    /// Performing a loud action breaks [Hidden].
    /// </summary>
    /// <example>
    /// Yelling, breaking objects, casting loud spells, triggering alarms.
    /// </example>
    LoudAction = 1,

    /// <summary>
    /// Enemy scores a critical success on Perception check.
    /// </summary>
    /// <remarks>
    /// Enemy must be actively searching and roll net ≥ 5 on Perception.
    /// </remarks>
    EnemyCriticalPerception = 2,

    /// <summary>
    /// Leaving the zone that granted [Hidden] (for zone-specific abilities).
    /// </summary>
    /// <remarks>
    /// Used by [One with the Static] when leaving [Psychic Resonance] zones.
    /// </remarks>
    LeaveZone = 3,

    /// <summary>
    /// Moving at more than half speed.
    /// </summary>
    /// <remarks>
    /// Running or dashing while hidden may break stealth in some contexts.
    /// </remarks>
    FastMovement = 4,

    /// <summary>
    /// Entering a brightly illuminated area.
    /// </summary>
    /// <remarks>
    /// Moving from shadow into full light may automatically break [Hidden].
    /// </remarks>
    EnterLight = 5,

    /// <summary>
    /// End of combat or encounter.
    /// </summary>
    /// <remarks>
    /// [Hidden] status typically resets when combat ends.
    /// </remarks>
    EncounterEnd = 6
}
```

---

## 7. StealthContext Value Object

### 7.1 Class Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/StealthContext.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Encapsulates all context for a stealth check.
/// </summary>
/// <remarks>
/// <para>
/// The stealth context includes:
/// <list type="bullet">
///   <item><description>Surface type determining base DC</description></item>
///   <item><description>Lighting conditions affecting difficulty</description></item>
///   <item><description>Enemy alert status</description></item>
///   <item><description>Zone-specific modifiers</description></item>
///   <item><description>Party check coordination</description></item>
/// </list>
/// </para>
/// </remarks>
/// <param name="SurfaceType">The type of surface being traversed.</param>
/// <param name="BaseDc">Base DC from surface type (in successes).</param>
/// <param name="LightingModifier">DC modifier from lighting conditions.</param>
/// <param name="AlertModifier">DC modifier if enemies are alerted.</param>
/// <param name="ZoneModifier">DC modifier from zone effects (e.g., [Psychic Resonance]).</param>
/// <param name="IsPartyCheck">Whether this is a party stealth check.</param>
/// <param name="PartyMemberIds">IDs of party members if party check.</param>
/// <param name="IsInCombat">Whether stealth is attempted during combat.</param>
public readonly record struct StealthContext(
    StealthSurface SurfaceType,
    int BaseDc,
    int LightingModifier = 0,
    int AlertModifier = 0,
    int ZoneModifier = 0,
    bool IsPartyCheck = false,
    IReadOnlyList<string>? PartyMemberIds = null,
    bool IsInCombat = false)
{
    /// <summary>
    /// DC modifier for dim light / obscuring terrain.
    /// </summary>
    public const int DimLightBonus = -1;

    /// <summary>
    /// DC modifier for being illuminated.
    /// </summary>
    public const int IlluminatedPenalty = 2;

    /// <summary>
    /// DC modifier for enemies being alerted / in combat.
    /// </summary>
    public const int AlertedPenalty = 1;

    /// <summary>
    /// DC modifier for [Psychic Resonance] zones.
    /// </summary>
    public const int PsychicResonanceBonus = -2;

    /// <summary>
    /// Gets the effective DC after all modifiers.
    /// </summary>
    /// <remarks>
    /// Minimum DC is 1 (regardless of bonuses).
    /// </remarks>
    public int EffectiveDc => Math.Max(1, BaseDc + LightingModifier + AlertModifier + ZoneModifier);

    /// <summary>
    /// Gets a value indicating whether the context has favorable lighting.
    /// </summary>
    public bool HasFavorableLighting => LightingModifier < 0;

    /// <summary>
    /// Gets a value indicating whether enemies are on alert.
    /// </summary>
    public bool EnemiesAlerted => AlertModifier > 0;

    /// <summary>
    /// Gets a value indicating whether in a beneficial zone.
    /// </summary>
    public bool InBeneficialZone => ZoneModifier < 0;

    /// <summary>
    /// Creates a stealth context with standard conditions.
    /// </summary>
    /// <param name="surface">The surface type.</param>
    /// <returns>A new StealthContext with base conditions.</returns>
    public static StealthContext Create(StealthSurface surface)
    {
        return new StealthContext(
            SurfaceType: surface,
            BaseDc: surface.GetBaseDc());
    }

    /// <summary>
    /// Creates a stealth context with environmental modifiers.
    /// </summary>
    /// <param name="surface">The surface type.</param>
    /// <param name="isDimLight">Whether in dim lighting.</param>
    /// <param name="isIlluminated">Whether in bright light.</param>
    /// <param name="enemiesAlerted">Whether enemies are alerted.</param>
    /// <param name="isInCombat">Whether currently in combat.</param>
    /// <param name="inPsychicResonance">Whether in a [Psychic Resonance] zone.</param>
    /// <returns>A new StealthContext with all modifiers calculated.</returns>
    public static StealthContext CreateWithModifiers(
        StealthSurface surface,
        bool isDimLight = false,
        bool isIlluminated = false,
        bool enemiesAlerted = false,
        bool isInCombat = false,
        bool inPsychicResonance = false)
    {
        var lightingMod = 0;
        if (isDimLight && !isIlluminated)
        {
            lightingMod = DimLightBonus;
        }
        else if (isIlluminated)
        {
            lightingMod = IlluminatedPenalty;
        }

        var alertMod = (enemiesAlerted || isInCombat) ? AlertedPenalty : 0;
        var zoneMod = inPsychicResonance ? PsychicResonanceBonus : 0;

        return new StealthContext(
            SurfaceType: surface,
            BaseDc: surface.GetBaseDc(),
            LightingModifier: lightingMod,
            AlertModifier: alertMod,
            ZoneModifier: zoneMod,
            IsInCombat: isInCombat);
    }

    /// <summary>
    /// Creates a party stealth context.
    /// </summary>
    /// <param name="surface">The surface type.</param>
    /// <param name="partyMemberIds">IDs of all party members.</param>
    /// <returns>A new StealthContext for party checks.</returns>
    public static StealthContext CreatePartyCheck(
        StealthSurface surface,
        IReadOnlyList<string> partyMemberIds)
    {
        return new StealthContext(
            SurfaceType: surface,
            BaseDc: surface.GetBaseDc(),
            IsPartyCheck: true,
            PartyMemberIds: partyMemberIds);
    }

    /// <summary>
    /// Gets a detailed description of the stealth context for display.
    /// </summary>
    /// <returns>A multi-line string describing all stealth factors.</returns>
    public string ToDescription()
    {
        var lines = new List<string>
        {
            $"Surface: {SurfaceType.GetDescription()}",
            $"Base DC: {BaseDc} successes"
        };

        if (LightingModifier != 0)
        {
            var lightDesc = LightingModifier < 0 ? "Dim Light" : "Illuminated";
            lines.Add($"Lighting: {lightDesc} ({LightingModifier:+#;-#;+0})");
        }

        if (AlertModifier != 0)
        {
            lines.Add($"Alert Status: Enemies aware ({AlertModifier:+#;-#;+0})");
        }

        if (ZoneModifier != 0)
        {
            lines.Add($"Zone Effect: [Psychic Resonance] ({ZoneModifier:+#;-#;+0})");
        }

        lines.Add($"Final DC: {EffectiveDc} successes");

        if (IsPartyCheck)
        {
            lines.Add($"Party Check: {PartyMemberIds?.Count ?? 0} members (weakest link)");
        }

        return string.Join(Environment.NewLine, lines);
    }

    /// <inheritdoc/>
    public override string ToString() =>
        $"Stealth DC {EffectiveDc} ({SurfaceType}{(IsPartyCheck ? ", party" : "")})";
}
```

---

## 8. StealthCheckResult Value Object

### 8.1 Class Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/StealthCheckResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the result of a stealth check.
/// </summary>
/// <remarks>
/// <para>
/// Stealth check outcomes:
/// <list type="bullet">
///   <item><description>Critical Success (margin ≥ 5): [Hidden] + advantage on first attack</description></item>
///   <item><description>Success (margin 0-4): [Hidden] status applied</description></item>
///   <item><description>Failure (margin < 0): Detected, not hidden</description></item>
///   <item><description>Fumble (0 successes + botch): [System-Wide Alert]</description></item>
/// </list>
/// </para>
/// </remarks>
/// <param name="CharacterId">The ID of the character who made the check.</param>
/// <param name="Context">The stealth context used for the check.</param>
/// <param name="Outcome">The skill outcome classification.</param>
/// <param name="NetSuccesses">Number of net successes from the dice roll.</param>
/// <param name="Margin">Margin of success or failure (NetSuccesses - DC).</param>
/// <param name="BecameHidden">Whether the character is now [Hidden].</param>
/// <param name="HiddenStatus">The [Hidden] status if successful.</param>
/// <param name="FumbleTriggered">Whether a fumble occurred.</param>
/// <param name="DetectionModifier">Detection modifier applied if hidden.</param>
/// <param name="Description">Narrative description of the outcome.</param>
public readonly record struct StealthCheckResult(
    string CharacterId,
    StealthContext Context,
    SkillOutcome Outcome,
    int NetSuccesses,
    int Margin,
    bool BecameHidden,
    HiddenStatus? HiddenStatus,
    bool FumbleTriggered = false,
    int DetectionModifier = 0,
    string? Description = null)
{
    /// <summary>
    /// Gets a value indicating whether this was a critical success.
    /// </summary>
    public bool IsCritical => Outcome == SkillOutcome.CriticalSuccess;

    /// <summary>
    /// Gets a value indicating whether stealth was successful.
    /// </summary>
    public bool Succeeded => Margin >= 0;

    /// <summary>
    /// Gets a value indicating whether the character was detected.
    /// </summary>
    public bool WasDetected => !BecameHidden && !FumbleTriggered;

    /// <summary>
    /// Gets a value indicating whether enemies have advantage detecting this character.
    /// </summary>
    /// <remarks>
    /// Marginal success (margin 0) means enemies are suspicious.
    /// </remarks>
    public bool EnemiesSuspicious => BecameHidden && Margin == 0;

    /// <summary>
    /// Creates a successful stealth check result.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="context">The stealth context.</param>
    /// <param name="netSuccesses">Net successes rolled.</param>
    /// <param name="outcome">The skill outcome.</param>
    /// <returns>A new StealthCheckResult for success.</returns>
    public static StealthCheckResult Success(
        string characterId,
        StealthContext context,
        int netSuccesses,
        SkillOutcome outcome)
    {
        var margin = netSuccesses - context.EffectiveDc;
        var detectionMod = outcome == SkillOutcome.CriticalSuccess ? 2 : 0;
        var hidden = Domain.Entities.HiddenStatus.FromStealthCheck(characterId, detectionMod);

        var description = outcome switch
        {
            SkillOutcome.CriticalSuccess =>
                "You blend into the shadows perfectly, becoming all but invisible.",
            SkillOutcome.ExceptionalSuccess =>
                "You move with practiced grace, unnoticed by your enemies.",
            SkillOutcome.FullSuccess =>
                "You slip into the shadows undetected.",
            SkillOutcome.MarginalSuccess =>
                "You manage to hide, but something feels off - they may be watching.",
            _ => "You attempt to hide."
        };

        return new StealthCheckResult(
            CharacterId: characterId,
            Context: context,
            Outcome: outcome,
            NetSuccesses: netSuccesses,
            Margin: margin,
            BecameHidden: true,
            HiddenStatus: hidden,
            DetectionModifier: detectionMod,
            Description: description);
    }

    /// <summary>
    /// Creates a failed stealth check result.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="context">The stealth context.</param>
    /// <param name="netSuccesses">Net successes rolled.</param>
    /// <returns>A new StealthCheckResult for failure.</returns>
    public static StealthCheckResult Failure(
        string characterId,
        StealthContext context,
        int netSuccesses)
    {
        var margin = netSuccesses - context.EffectiveDc;

        return new StealthCheckResult(
            CharacterId: characterId,
            Context: context,
            Outcome: SkillOutcome.Failure,
            NetSuccesses: netSuccesses,
            Margin: margin,
            BecameHidden: false,
            HiddenStatus: null,
            Description: "Your attempt at stealth fails - you've been spotted!");
    }

    /// <summary>
    /// Creates a fumbled stealth check result.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="context">The stealth context.</param>
    /// <returns>A new StealthCheckResult for fumble.</returns>
    public static StealthCheckResult Fumble(
        string characterId,
        StealthContext context)
    {
        return new StealthCheckResult(
            CharacterId: characterId,
            Context: context,
            Outcome: SkillOutcome.CriticalFailure,
            NetSuccesses: 0,
            Margin: -context.EffectiveDc,
            BecameHidden: false,
            HiddenStatus: null,
            FumbleTriggered: true,
            Description: "You stumble catastrophically, triggering a [System-Wide Alert]!");
    }

    /// <summary>
    /// Gets a formatted summary of the stealth check result.
    /// </summary>
    public string ToSummary()
    {
        var outcomeStr = Outcome switch
        {
            SkillOutcome.CriticalSuccess => "CRITICAL SUCCESS",
            SkillOutcome.ExceptionalSuccess => "Exceptional Success",
            SkillOutcome.FullSuccess => "Success",
            SkillOutcome.MarginalSuccess => "Marginal Success",
            SkillOutcome.Failure => "Failure",
            SkillOutcome.CriticalFailure => "FUMBLE",
            _ => Outcome.ToString()
        };

        var statusStr = BecameHidden ? " - [HIDDEN]" : FumbleTriggered ? " - ALERT!" : " - DETECTED";

        return $"Stealth: {outcomeStr} ({NetSuccesses} successes vs DC {Context.EffectiveDc}){statusStr}";
    }

    /// <inheritdoc/>
    public override string ToString() => ToSummary();
}
```

---

## 9. PartyStealthResult Value Object

### 9.1 Class Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/PartyStealthResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the result of a party stealth check using the weakest-link rule.
/// </summary>
/// <remarks>
/// <para>
/// Party stealth uses the weakest-link rule: the party member with the lowest
/// Acrobatics dice pool makes the check for the entire party. If they fail,
/// the entire party is detected.
/// </para>
/// <para>
/// "A chain is only as strong as its weakest link."
/// </para>
/// </remarks>
/// <param name="ParticipantIds">IDs of all party members in the check.</param>
/// <param name="WeakestMemberId">ID of the member with the lowest dice pool.</param>
/// <param name="WeakestPool">The dice pool size of the weakest member.</param>
/// <param name="Context">The stealth context for the check.</param>
/// <param name="Outcome">The skill outcome of the weakest member's roll.</param>
/// <param name="NetSuccesses">Net successes from the weakest member's roll.</param>
/// <param name="Margin">Margin of success or failure.</param>
/// <param name="PartyHidden">Whether the entire party is now hidden.</param>
/// <param name="DetectedBy">IDs of enemies who detected the party.</param>
/// <param name="FumbleTriggered">Whether a fumble triggered system-wide alert.</param>
public readonly record struct PartyStealthResult(
    IReadOnlyList<string> ParticipantIds,
    string WeakestMemberId,
    int WeakestPool,
    StealthContext Context,
    SkillOutcome Outcome,
    int NetSuccesses,
    int Margin,
    bool PartyHidden,
    IReadOnlyList<string>? DetectedBy = null,
    bool FumbleTriggered = false)
{
    /// <summary>
    /// Gets the number of party members in the check.
    /// </summary>
    public int PartySize => ParticipantIds.Count;

    /// <summary>
    /// Gets a value indicating whether the party was detected.
    /// </summary>
    public bool WasDetected => !PartyHidden;

    /// <summary>
    /// Gets a value indicating whether this was a critical party success.
    /// </summary>
    public bool IsCriticalSuccess => Outcome == SkillOutcome.CriticalSuccess;

    /// <summary>
    /// Gets a value indicating whether the party is on high alert.
    /// </summary>
    /// <remarks>
    /// Marginal success means the party is hidden but enemies are suspicious.
    /// </remarks>
    public bool EnemiesSuspicious => PartyHidden && Margin == 0;

    /// <summary>
    /// Creates a successful party stealth result.
    /// </summary>
    /// <param name="participantIds">All party member IDs.</param>
    /// <param name="weakestMemberId">ID of the weakest member.</param>
    /// <param name="weakestPool">Dice pool of the weakest member.</param>
    /// <param name="context">The stealth context.</param>
    /// <param name="netSuccesses">Net successes rolled.</param>
    /// <param name="outcome">The skill outcome.</param>
    /// <returns>A new PartyStealthResult for success.</returns>
    public static PartyStealthResult Success(
        IReadOnlyList<string> participantIds,
        string weakestMemberId,
        int weakestPool,
        StealthContext context,
        int netSuccesses,
        SkillOutcome outcome)
    {
        var margin = netSuccesses - context.EffectiveDc;

        return new PartyStealthResult(
            ParticipantIds: participantIds,
            WeakestMemberId: weakestMemberId,
            WeakestPool: weakestPool,
            Context: context,
            Outcome: outcome,
            NetSuccesses: netSuccesses,
            Margin: margin,
            PartyHidden: true);
    }

    /// <summary>
    /// Creates a failed party stealth result.
    /// </summary>
    /// <param name="participantIds">All party member IDs.</param>
    /// <param name="weakestMemberId">ID of the weakest member.</param>
    /// <param name="weakestPool">Dice pool of the weakest member.</param>
    /// <param name="context">The stealth context.</param>
    /// <param name="netSuccesses">Net successes rolled.</param>
    /// <param name="detectedBy">IDs of enemies who detected the party.</param>
    /// <returns>A new PartyStealthResult for failure.</returns>
    public static PartyStealthResult Failure(
        IReadOnlyList<string> participantIds,
        string weakestMemberId,
        int weakestPool,
        StealthContext context,
        int netSuccesses,
        IReadOnlyList<string>? detectedBy = null)
    {
        var margin = netSuccesses - context.EffectiveDc;

        return new PartyStealthResult(
            ParticipantIds: participantIds,
            WeakestMemberId: weakestMemberId,
            WeakestPool: weakestPool,
            Context: context,
            Outcome: SkillOutcome.Failure,
            NetSuccesses: netSuccesses,
            Margin: margin,
            PartyHidden: false,
            DetectedBy: detectedBy);
    }

    /// <summary>
    /// Creates a fumbled party stealth result.
    /// </summary>
    /// <param name="participantIds">All party member IDs.</param>
    /// <param name="weakestMemberId">ID of the weakest member.</param>
    /// <param name="weakestPool">Dice pool of the weakest member.</param>
    /// <param name="context">The stealth context.</param>
    /// <param name="detectedBy">IDs of enemies who detected the party.</param>
    /// <returns>A new PartyStealthResult for fumble.</returns>
    public static PartyStealthResult Fumble(
        IReadOnlyList<string> participantIds,
        string weakestMemberId,
        int weakestPool,
        StealthContext context,
        IReadOnlyList<string>? detectedBy = null)
    {
        return new PartyStealthResult(
            ParticipantIds: participantIds,
            WeakestMemberId: weakestMemberId,
            WeakestPool: weakestPool,
            Context: context,
            Outcome: SkillOutcome.CriticalFailure,
            NetSuccesses: 0,
            Margin: -context.EffectiveDc,
            PartyHidden: false,
            DetectedBy: detectedBy,
            FumbleTriggered: true);
    }

    /// <summary>
    /// Gets a description of the party stealth result.
    /// </summary>
    /// <returns>A narrative description of the outcome.</returns>
    public string ToDescription()
    {
        var weakestName = WeakestMemberId; // Would be resolved to character name in practice

        if (FumbleTriggered)
        {
            return $"{weakestName}'s catastrophic fumble triggers a [SYSTEM-WIDE ALERT]! " +
                   "All adjacent rooms have been alerted to your presence!";
        }

        if (WasDetected)
        {
            var detectCount = DetectedBy?.Count ?? 0;
            return $"{weakestName}'s attempt at stealth fails, alerting {detectCount} " +
                   "enemies to the party's presence!";
        }

        if (EnemiesSuspicious)
        {
            return $"The party barely manages to stay hidden, but {weakestName}'s " +
                   "movement has made the enemies suspicious...";
        }

        if (IsCriticalSuccess)
        {
            return "The party moves as one with the shadows, completely undetected!";
        }

        return "The party successfully sneaks past, guided by their weakest member's caution.";
    }

    /// <summary>
    /// Gets a formatted summary of the party stealth result.
    /// </summary>
    public string ToSummary()
    {
        var outcomeStr = Outcome switch
        {
            SkillOutcome.CriticalSuccess => "CRITICAL",
            SkillOutcome.Failure => "FAILED",
            SkillOutcome.CriticalFailure => "FUMBLE",
            _ => PartyHidden ? "SUCCESS" : "FAILED"
        };

        return $"Party Stealth ({PartySize} members): {outcomeStr} " +
               $"[{WeakestMemberId} rolled {NetSuccesses} vs DC {Context.EffectiveDc}]";
    }

    /// <inheritdoc/>
    public override string ToString() => ToSummary();
}
```

---

## 10. IStealthService Interface

### 10.1 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IStealthService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing stealth checks and [Hidden] status.
/// </summary>
/// <remarks>
/// <para>
/// The stealth service handles:
/// <list type="bullet">
///   <item><description>Individual stealth checks against surface DCs</description></item>
///   <item><description>Party stealth using weakest-link rule</description></item>
///   <item><description>[Hidden] status tracking and break conditions</description></item>
///   <item><description>[System-Wide Alert] fumble consequences</description></item>
/// </list>
/// </para>
/// </remarks>
public interface IStealthService
{
    /// <summary>
    /// Attempts a stealth check for an individual character.
    /// </summary>
    /// <param name="characterId">The ID of the character attempting stealth.</param>
    /// <param name="context">The stealth context with modifiers.</param>
    /// <param name="skillContext">Optional skill context overrides.</param>
    /// <returns>A StealthCheckResult with the attempt outcome.</returns>
    StealthCheckResult AttemptStealth(
        string characterId,
        StealthContext context,
        SkillContext? skillContext = null);

    /// <summary>
    /// Attempts a party stealth check using the weakest-link rule.
    /// </summary>
    /// <param name="partyMemberIds">IDs of all party members.</param>
    /// <param name="context">The stealth context with modifiers.</param>
    /// <returns>A PartyStealthResult with the party attempt outcome.</returns>
    PartyStealthResult AttemptPartyStealth(
        IReadOnlyList<string> partyMemberIds,
        StealthContext context);

    /// <summary>
    /// Gets the current [Hidden] status for a character.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>The HiddenStatus if character is hidden, null otherwise.</returns>
    HiddenStatus? GetHiddenStatus(string characterId);

    /// <summary>
    /// Checks if a character is currently [Hidden].
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>True if the character has active [Hidden] status.</returns>
    bool IsHidden(string characterId);

    /// <summary>
    /// Breaks the [Hidden] status for a character due to a condition.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="condition">The break condition that occurred.</param>
    /// <returns>True if [Hidden] was broken, false if not hidden.</returns>
    bool BreakHidden(string characterId, HiddenBreakCondition condition);

    /// <summary>
    /// Manually applies [Hidden] status via ability (e.g., [Slip into Shadow]).
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="source">The source of the [Hidden] status.</param>
    /// <param name="detectionModifier">Modifier to enemy detection DCs.</param>
    /// <returns>The created HiddenStatus.</returns>
    HiddenStatus ApplyHiddenStatus(
        string characterId,
        string source,
        int detectionModifier = 0);

    /// <summary>
    /// Gets the stealth DC for a surface type with modifiers.
    /// </summary>
    /// <param name="surface">The surface type.</param>
    /// <param name="isDimLight">Whether in dim lighting.</param>
    /// <param name="isIlluminated">Whether in bright light.</param>
    /// <param name="enemiesAlerted">Whether enemies are alerted.</param>
    /// <returns>The effective DC in successes needed.</returns>
    int GetStealthDc(
        StealthSurface surface,
        bool isDimLight = false,
        bool isIlluminated = false,
        bool enemiesAlerted = false);

    /// <summary>
    /// Gets the Acrobatics dice pool for a character.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>The character's Acrobatics dice pool size.</returns>
    int GetAcrobaticsDicePool(string characterId);

    /// <summary>
    /// Finds the party member with the lowest Acrobatics pool.
    /// </summary>
    /// <param name="partyMemberIds">IDs of all party members.</param>
    /// <returns>Tuple of (weakest member ID, dice pool size).</returns>
    (string MemberId, int DicePool) FindWeakestMember(IReadOnlyList<string> partyMemberIds);
}
```

---

## 11. StealthService Implementation

### 11.1 Service Implementation

**File:** `src/Core/RuneAndRust.Application/Services/StealthService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Implementation of <see cref="IStealthService"/> for managing stealth mechanics.
/// </summary>
public sealed class StealthService : IStealthService
{
    private readonly ISkillCheckService _skillCheck;
    private readonly ICharacterService _characterService;
    private readonly IFumbleConsequenceService _fumbleService;
    private readonly ILogger<StealthService> _logger;

    // In-memory storage for [Hidden] statuses (would be repository in full impl)
    private readonly Dictionary<string, HiddenStatus> _hiddenStatuses = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="StealthService"/> class.
    /// </summary>
    public StealthService(
        ISkillCheckService skillCheck,
        ICharacterService characterService,
        IFumbleConsequenceService fumbleService,
        ILogger<StealthService> logger)
    {
        _skillCheck = skillCheck ?? throw new ArgumentNullException(nameof(skillCheck));
        _characterService = characterService ?? throw new ArgumentNullException(nameof(characterService));
        _fumbleService = fumbleService ?? throw new ArgumentNullException(nameof(fumbleService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public StealthCheckResult AttemptStealth(
        string characterId,
        StealthContext context,
        SkillContext? skillContext = null)
    {
        _logger.LogInformation(
            "Character {CharacterId} attempting stealth on {Surface} surface (DC {Dc})",
            characterId, context.SurfaceType, context.EffectiveDc);

        // Build skill context for Acrobatics check
        var effectiveContext = skillContext ?? SkillContext.Create(
            skillName: "Acrobatics",
            baseDice: GetAcrobaticsDicePool(characterId),
            dc: context.EffectiveDc);

        // Perform the skill check
        var checkResult = _skillCheck.PerformCheck(characterId, effectiveContext);

        // Determine outcome
        StealthCheckResult result;

        if (checkResult.IsFumble)
        {
            _logger.LogWarning(
                "Character {CharacterId} fumbled stealth check - triggering [System-Wide Alert]",
                characterId);

            result = StealthCheckResult.Fumble(characterId, context);

            // Trigger fumble consequence
            _fumbleService.TriggerConsequence(
                characterId,
                FumbleType.SystemWideAlert,
                "Catastrophic stealth failure");
        }
        else if (checkResult.NetSuccesses >= context.EffectiveDc)
        {
            result = StealthCheckResult.Success(
                characterId,
                context,
                checkResult.NetSuccesses,
                checkResult.Outcome);

            // Store [Hidden] status
            if (result.HiddenStatus != null)
            {
                _hiddenStatuses[characterId] = result.HiddenStatus;
            }

            _logger.LogInformation(
                "Character {CharacterId} is now [Hidden] (margin {Margin})",
                characterId, result.Margin);
        }
        else
        {
            result = StealthCheckResult.Failure(
                characterId,
                context,
                checkResult.NetSuccesses);

            _logger.LogInformation(
                "Character {CharacterId} failed stealth check - detected",
                characterId);
        }

        return result;
    }

    /// <inheritdoc/>
    public PartyStealthResult AttemptPartyStealth(
        IReadOnlyList<string> partyMemberIds,
        StealthContext context)
    {
        if (partyMemberIds.Count == 0)
        {
            throw new ArgumentException("Party must have at least one member.", nameof(partyMemberIds));
        }

        _logger.LogInformation(
            "Party of {Count} attempting stealth on {Surface} surface (DC {Dc})",
            partyMemberIds.Count, context.SurfaceType, context.EffectiveDc);

        // Find weakest member
        var (weakestId, weakestPool) = FindWeakestMember(partyMemberIds);

        _logger.LogDebug(
            "Weakest link: {MemberId} with {Pool}d10 Acrobatics pool",
            weakestId, weakestPool);

        // Build skill context for weakest member
        var skillContext = SkillContext.Create(
            skillName: "Acrobatics",
            baseDice: weakestPool,
            dc: context.EffectiveDc);

        // Perform the skill check for the weakest member
        var checkResult = _skillCheck.PerformCheck(weakestId, skillContext);

        PartyStealthResult result;

        if (checkResult.IsFumble)
        {
            _logger.LogWarning(
                "Party fumbled stealth via {MemberId} - triggering [System-Wide Alert]",
                weakestId);

            result = PartyStealthResult.Fumble(
                partyMemberIds,
                weakestId,
                weakestPool,
                context);

            // Trigger fumble consequence
            _fumbleService.TriggerConsequence(
                weakestId,
                FumbleType.SystemWideAlert,
                "Party stealth catastrophic failure");

            // Clear any existing hidden statuses for party
            foreach (var memberId in partyMemberIds)
            {
                _hiddenStatuses.Remove(memberId);
            }
        }
        else if (checkResult.NetSuccesses >= context.EffectiveDc)
        {
            result = PartyStealthResult.Success(
                partyMemberIds,
                weakestId,
                weakestPool,
                context,
                checkResult.NetSuccesses,
                checkResult.Outcome);

            // Apply [Hidden] to all party members
            foreach (var memberId in partyMemberIds)
            {
                var hidden = HiddenStatus.FromStealthCheck(memberId);
                _hiddenStatuses[memberId] = hidden;
            }

            _logger.LogInformation(
                "Party is now [Hidden] (margin {Margin})",
                result.Margin);
        }
        else
        {
            result = PartyStealthResult.Failure(
                partyMemberIds,
                weakestId,
                weakestPool,
                context,
                checkResult.NetSuccesses);

            // Clear any existing hidden statuses for party
            foreach (var memberId in partyMemberIds)
            {
                _hiddenStatuses.Remove(memberId);
            }

            _logger.LogInformation(
                "Party failed stealth check - detected by {MemberId}'s fumble",
                weakestId);
        }

        return result;
    }

    /// <inheritdoc/>
    public HiddenStatus? GetHiddenStatus(string characterId)
    {
        return _hiddenStatuses.TryGetValue(characterId, out var status) && status.IsHidden
            ? status
            : null;
    }

    /// <inheritdoc/>
    public bool IsHidden(string characterId)
    {
        return _hiddenStatuses.TryGetValue(characterId, out var status) && status.IsHidden;
    }

    /// <inheritdoc/>
    public bool BreakHidden(string characterId, HiddenBreakCondition condition)
    {
        if (!_hiddenStatuses.TryGetValue(characterId, out var status) || !status.IsHidden)
        {
            return false;
        }

        if (!status.WouldBreak(condition))
        {
            _logger.LogDebug(
                "Condition {Condition} does not break [Hidden] for {CharacterId}",
                condition, characterId);
            return false;
        }

        status.Break(condition);

        _logger.LogInformation(
            "Character {CharacterId} [Hidden] broken by {Condition}",
            characterId, condition);

        return true;
    }

    /// <inheritdoc/>
    public HiddenStatus ApplyHiddenStatus(
        string characterId,
        string source,
        int detectionModifier = 0)
    {
        var hidden = source switch
        {
            "SlipIntoShadow" => HiddenStatus.FromSlipIntoShadow(characterId),
            "OneWithTheStatic" => HiddenStatus.FromOneWithTheStatic(characterId),
            _ => HiddenStatus.FromStealthCheck(characterId, detectionModifier)
        };

        _hiddenStatuses[characterId] = hidden;

        _logger.LogInformation(
            "Applied [Hidden] to {CharacterId} via {Source}",
            characterId, source);

        return hidden;
    }

    /// <inheritdoc/>
    public int GetStealthDc(
        StealthSurface surface,
        bool isDimLight = false,
        bool isIlluminated = false,
        bool enemiesAlerted = false)
    {
        var context = StealthContext.CreateWithModifiers(
            surface,
            isDimLight,
            isIlluminated,
            enemiesAlerted);

        return context.EffectiveDc;
    }

    /// <inheritdoc/>
    public int GetAcrobaticsDicePool(string characterId)
    {
        // In full implementation, this would query character stats
        // Acrobatics pool = Acrobatics skill ranks + Finesse attribute
        return _characterService.GetSkillDicePool(characterId, "Acrobatics");
    }

    /// <inheritdoc/>
    public (string MemberId, int DicePool) FindWeakestMember(IReadOnlyList<string> partyMemberIds)
    {
        string? weakestId = null;
        var weakestPool = int.MaxValue;

        foreach (var memberId in partyMemberIds)
        {
            var pool = GetAcrobaticsDicePool(memberId);
            if (pool < weakestPool)
            {
                weakestPool = pool;
                weakestId = memberId;
            }
        }

        return (weakestId ?? partyMemberIds[0], weakestPool);
    }
}
```

---

## 12. SystemWideAlert Fumble Integration

### 12.1 FumbleType Extension

The `FumbleType.SystemWideAlert` is defined in v0.15.1b. This section documents its integration with the stealth system.

```csharp
// In FumbleType enum (from v0.15.1b):

/// <summary>
/// All enemies in adjacent rooms are alerted to the party's presence.
/// </summary>
/// <remarks>
/// Triggered by stealth fumble (0 successes + ≥1 botch).
/// Adjacent rooms receive +2 to enemy Perception and enemies move to investigate.
/// </remarks>
SystemWideAlert = 8
```

### 12.2 Fumble Consequence Configuration

```csharp
// FumbleConsequence for SystemWideAlert:

new FumbleConsequence
{
    ConsequenceId = Guid.NewGuid().ToString(),
    CharacterId = characterId,
    FumbleType = FumbleType.SystemWideAlert,
    Description = "Your catastrophic failure echoes through the area, alerting all nearby enemies!",
    SkillAffected = "Acrobatics",
    MechanicalEffect = "+2 DC to all stealth checks for 10 minutes, adjacent room enemies alerted",
    IsActive = true,
    CreatedAt = DateTime.UtcNow,
    ExpiresAt = DateTime.UtcNow.AddMinutes(10),
    RecoveryCondition = "Leave the area or wait 10 minutes"
}
```

### 12.3 Alert Propagation

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      [SYSTEM-WIDE ALERT] PROPAGATION                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  FUMBLE LOCATION (Current Room)                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  [!] Character fumbles stealth check                                │    │
│  │      → All enemies in room immediately alerted                      │    │
│  │      → Combat may initiate                                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ADJACENT ROOMS (Connected Rooms)                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  [!] Alert propagates to all connected rooms                        │    │
│  │      → Enemies receive +2 to Perception checks                      │    │
│  │      → Enemies begin investigating                                  │    │
│  │      → Reinforcements may arrive in 2-4 rounds                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  EFFECT DURATION                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Duration: 10 minutes (real time) or until area is cleared         │    │
│  │  Recovery: Leave the area OR wait for alert to expire              │    │
│  │  Penalty: +2 DC to all stealth checks in affected area             │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 13. Configuration

### 13.1 stealth-surfaces.json

**File:** `src/Presentation/RuneAndRust.Console/Configuration/stealth-surfaces.json`

```json
{
  "$schema": "./stealth-surfaces.schema.json",
  "version": "0.15.2d",
  "surfaces": {
    "silent": {
      "name": "Silent",
      "baseDc": 2,
      "description": "Sound-absorbing surface that muffles footsteps",
      "examples": [
        "Thick carpet",
        "Moss-covered stone",
        "Deep sand",
        "Padded flooring"
      ]
    },
    "normal": {
      "name": "Normal",
      "baseDc": 3,
      "description": "Standard surface with typical noise characteristics",
      "examples": [
        "Concrete",
        "Packed dirt",
        "Solid wood flooring",
        "Smooth stone"
      ]
    },
    "noisy": {
      "name": "Noisy",
      "baseDc": 4,
      "description": "Surface that amplifies sound from movement",
      "examples": [
        "Loose rubble",
        "Gravel",
        "Dry leaves",
        "Creaky wooden boards"
      ]
    },
    "veryNoisy": {
      "name": "Very Noisy",
      "baseDc": 5,
      "description": "Extremely loud surface that makes stealth nearly impossible",
      "examples": [
        "Scrap metal piles",
        "Broken glass",
        "Metal grating",
        "Chains"
      ]
    }
  },
  "modifiers": {
    "lighting": {
      "dimLight": {
        "dcModifier": -1,
        "description": "Dim lighting or obscuring terrain"
      },
      "illuminated": {
        "dcModifier": 2,
        "description": "Bright lighting makes hiding difficult"
      }
    },
    "alertStatus": {
      "enemiesAlerted": {
        "dcModifier": 1,
        "description": "Enemies are actively searching"
      },
      "inCombat": {
        "dcModifier": 1,
        "description": "Combat makes stealth harder"
      }
    },
    "zones": {
      "psychicResonance": {
        "dcModifier": -2,
        "description": "[Psychic Resonance] zones disrupt enemy perception"
      }
    }
  },
  "hiddenStatus": {
    "effects": [
      "Cannot be directly targeted by single-target attacks",
      "Can still be hit by AoE abilities",
      "First attack from hiding grants advantage"
    ],
    "breakConditions": [
      {
        "condition": "Attack",
        "description": "Making any attack"
      },
      {
        "condition": "LoudAction",
        "description": "Yelling, breaking objects, loud abilities"
      },
      {
        "condition": "EnemyCriticalPerception",
        "description": "Enemy rolls net ≥5 on Perception"
      },
      {
        "condition": "LeaveZone",
        "description": "Leaving zone that granted [Hidden]"
      }
    ]
  },
  "fumbleConsequence": {
    "type": "SystemWideAlert",
    "description": "All enemies in adjacent rooms are alerted",
    "effects": [
      "+2 DC to stealth checks in affected area",
      "Enemies move to investigate",
      "Reinforcements may arrive"
    ],
    "duration": "10 minutes",
    "recovery": "Leave the area or wait for expiration"
  }
}
```

### 13.2 stealth-surfaces.schema.json

**File:** `src/Presentation/RuneAndRust.Console/Configuration/stealth-surfaces.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "stealth-surfaces.schema.json",
  "title": "Stealth Surfaces Configuration",
  "description": "Configuration for stealth surface types, modifiers, and [Hidden] status",
  "type": "object",
  "required": ["version", "surfaces", "modifiers", "hiddenStatus"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "version": {
      "type": "string",
      "description": "Schema version"
    },
    "surfaces": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "required": ["name", "baseDc", "description"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Display name for the surface type"
          },
          "baseDc": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10,
            "description": "Base DC in successes needed"
          },
          "description": {
            "type": "string",
            "description": "Description of the surface type"
          },
          "examples": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Example materials for this surface"
          }
        }
      }
    },
    "modifiers": {
      "type": "object",
      "properties": {
        "lighting": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "dcModifier": {
                "type": "integer"
              },
              "description": {
                "type": "string"
              }
            }
          }
        },
        "alertStatus": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "dcModifier": {
                "type": "integer"
              },
              "description": {
                "type": "string"
              }
            }
          }
        },
        "zones": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "dcModifier": {
                "type": "integer"
              },
              "description": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "hiddenStatus": {
      "type": "object",
      "required": ["effects", "breakConditions"],
      "properties": {
        "effects": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "breakConditions": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["condition", "description"],
            "properties": {
              "condition": {
                "type": "string"
              },
              "description": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "fumbleConsequence": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "effects": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "duration": {
          "type": "string"
        },
        "recovery": {
          "type": "string"
        }
      }
    }
  }
}
```

---

## 14. Commands

### 14.1 New Commands

| Command | Alias | Description | Example |
|---------|-------|-------------|---------|
| `sneak` | `stealth` | Attempt individual stealth | `sneak` |
| `hide` | - | Enter [Hidden] state | `hide` |
| `party sneak` | `party stealth` | Party stealth check | `party sneak` |

### 14.2 Command Parsing

```csharp
// In ConsoleInputHandler.ParseCommand():

"sneak" or "stealth" => ParseStealthCommand(argument),
"hide" => new HideCommand(characterId),
"party" when argument?.StartsWith("sneak") == true => ParsePartyStealthCommand(argument),

private GameCommand ParseStealthCommand(string? argument)
{
    // Parse optional surface type override
    var surface = argument?.ToLowerInvariant() switch
    {
        "silent" => StealthSurface.Silent,
        "noisy" => StealthSurface.Noisy,
        "loud" or "verynoisy" => StealthSurface.VeryNoisy,
        _ => null as StealthSurface?
    };

    return new StealthCommand(surface);
}
```

---

## 15. User-Facing Changes

### 15.1 Stealth Check Display

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          STEALTH CHECK DISPLAY                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Example 1: Successful Stealth                                              │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ╔═══════════════════════════════════════════════════════════════════════╗  │
│  ║  STEALTH CHECK                                                         ║  │
│  ║  Surface: Noisy (loose rubble)                                        ║  │
│  ║  DC: 4 successes                                                      ║  │
│  ║                                                                        ║  │
│  ║  Roll: 5d10 [9, 8, 10, 4, 6] = 3 successes                           ║  │
│  ║                                                                        ║  │
│  ║  Result: FAILURE                                                      ║  │
│  ║  You step on a loose piece of rubble, alerting the guards!           ║  │
│  ║                                                                        ║  │
│  ╚═══════════════════════════════════════════════════════════════════════╝  │
│                                                                              │
│                                                                              │
│  Example 2: Hidden Status Gained                                            │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ╔═══════════════════════════════════════════════════════════════════════╗  │
│  ║  STEALTH CHECK                                                         ║  │
│  ║  Surface: Normal (stone floor)                                        ║  │
│  ║  Lighting: Dim Light (-1 DC)                                          ║  │
│  ║  DC: 2 successes                                                      ║  │
│  ║                                                                        ║  │
│  ║  Roll: 6d10 [9, 8, 10, 8, 4, 6] = 4 successes                        ║  │
│  ║                                                                        ║  │
│  ║  Result: SUCCESS!                                                     ║  │
│  ║  You slip into the shadows undetected.                                ║  │
│  ║                                                                        ║  │
│  ║  [HIDDEN]                                                             ║  │
│  ║  • Cannot be directly targeted                                        ║  │
│  ║  • First attack grants advantage                                      ║  │
│  ║                                                                        ║  │
│  ╚═══════════════════════════════════════════════════════════════════════╝  │
│                                                                              │
│                                                                              │
│  Example 3: Party Stealth (Weakest Link)                                    │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ╔═══════════════════════════════════════════════════════════════════════╗  │
│  ║  PARTY STEALTH CHECK                                                   ║  │
│  ║  Party: Kira (7d10), Theron (4d10), Elara (6d10)                      ║  │
│  ║  Weakest Link: Theron (4d10)                                          ║  │
│  ║                                                                        ║  │
│  ║  Surface: Normal                                                      ║  │
│  ║  DC: 3 successes                                                      ║  │
│  ║                                                                        ║  │
│  ║  Theron rolls: 4d10 [8, 5, 9, 2] = 2 successes                       ║  │
│  ║                                                                        ║  │
│  ║  Result: PARTY DETECTED                                               ║  │
│  ║  Theron's armor clinks loudly against the stone, alerting             ║  │
│  ║  the guards to your party's presence!                                 ║  │
│  ║                                                                        ║  │
│  ╚═══════════════════════════════════════════════════════════════════════╝  │
│                                                                              │
│                                                                              │
│  Example 4: System-Wide Alert Fumble                                        │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ╔═══════════════════════════════════════════════════════════════════════╗  │
│  ║  STEALTH CHECK                                                         ║  │
│  ║  Surface: Very Noisy (metal grating)                                  ║  │
│  ║  DC: 5 successes                                                      ║  │
│  ║                                                                        ║  │
│  ║  Roll: 4d10 [1, 4, 3, 5] = 0 successes, 1 botch                      ║  │
│  ║                                                                        ║  │
│  ║  ██████████████████████████████████████████████████████████████████   ║  │
│  ║  ║                         FUMBLE!                                ║   ║  │
│  ║  ██████████████████████████████████████████████████████████████████   ║  │
│  ║                                                                        ║  │
│  ║  [SYSTEM-WIDE ALERT]                                                  ║  │
│  ║  Your catastrophic failure echoes through the corridors!              ║  │
│  ║  All adjacent rooms have been alerted to your presence!               ║  │
│  ║                                                                        ║  │
│  ║  Effects:                                                             ║  │
│  ║  • +2 DC to all stealth checks in this area                          ║  │
│  ║  • Enemies converging on your location                                ║  │
│  ║  • Duration: 10 minutes                                               ║  │
│  ║                                                                        ║  │
│  ╚═══════════════════════════════════════════════════════════════════════╝  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 16. Logging Specifications

### 16.1 Log Levels

| Level | Usage |
|-------|-------|
| `Debug` | DC calculations, pool determination, break condition checks |
| `Information` | Stealth attempts, [Hidden] status changes, party checks |
| `Warning` | Fumbles, [System-Wide Alert] triggers |
| `Error` | Invalid operations, missing character data |

### 16.2 Log Messages

```csharp
// Debug level
_logger.LogDebug(
    "Stealth DC calculated: {Dc} (base {Base} + {Light} + {Alert} + {Zone})",
    effectiveDc, baseDc, lightMod, alertMod, zoneMod);

_logger.LogDebug(
    "Finding weakest link among {Count} party members",
    partyMemberIds.Count);

// Information level
_logger.LogInformation(
    "Character {CharacterId} attempting stealth on {Surface} surface (DC {Dc})",
    characterId, context.SurfaceType, context.EffectiveDc);

_logger.LogInformation(
    "Character {CharacterId} is now [Hidden] (margin {Margin})",
    characterId, result.Margin);

_logger.LogInformation(
    "Character {CharacterId} [Hidden] broken by {Condition}",
    characterId, condition);

// Warning level
_logger.LogWarning(
    "Character {CharacterId} fumbled stealth check - triggering [System-Wide Alert]",
    characterId);

_logger.LogWarning(
    "Party fumbled stealth via {MemberId} - [System-Wide Alert] active",
    weakestId);
```

---

## 17. Unit Testing Requirements

### 17.1 Test Specifications (~4 tests)

#### StealthSurfaceTests.cs

```csharp
[TestFixture]
public class StealthSurfaceTests
{
    /// <summary>
    /// Tests that surface types return correct base DCs.
    /// </summary>
    [Test]
    [TestCase(StealthSurface.Silent, 2)]
    [TestCase(StealthSurface.Normal, 3)]
    [TestCase(StealthSurface.Noisy, 4)]
    [TestCase(StealthSurface.VeryNoisy, 5)]
    public void GetBaseDc_SurfaceType_ReturnsCorrectDc(
        StealthSurface surface, int expectedDc);
}
```

#### HiddenStatusTests.cs

```csharp
[TestFixture]
public class HiddenStatusTests
{
    /// <summary>
    /// Tests that [Hidden] prevents direct targeting.
    /// </summary>
    /// <remarks>
    /// Characters with [Hidden] cannot be targeted by single-target attacks.
    /// </remarks>
    [Test]
    public void HiddenStatus_WhenActive_PreventsDirectTargeting();

    /// <summary>
    /// Tests that [Hidden] is broken by attacking.
    /// </summary>
    [Test]
    public void HiddenStatus_OnAttack_BreaksHidden();
}
```

#### PartyStealthTests.cs

```csharp
[TestFixture]
public class PartyStealthTests
{
    /// <summary>
    /// Tests that party stealth uses the weakest member's roll.
    /// </summary>
    [Test]
    public void AttemptPartyStealth_MultipleMembers_UsesWeakestLink();
}
```

#### StealthFumbleTests.cs

```csharp
[TestFixture]
public class StealthFumbleTests
{
    /// <summary>
    /// Tests that stealth fumble triggers [System-Wide Alert].
    /// </summary>
    [Test]
    public void AttemptStealth_Fumble_TriggersSystemWideAlert();
}
```

### 17.2 Test Coverage Matrix

| Component | Test Category | Tests |
|-----------|---------------|-------|
| `StealthSurface` | DC Mapping | Surface-to-DC conversion |
| `HiddenStatus` | Targeting | Prevents single-target attacks |
| `HiddenStatus` | Break Conditions | Attack breaks [Hidden] |
| `PartyStealthResult` | Weakest Link | Uses lowest pool member |
| `StealthService` | Fumble | Triggers [System-Wide Alert] |

---

## 18. Use Cases

### 18.1 Use Case: Individual Stealth Check

**Actor:** Character
**Trigger:** Player uses `sneak` or `hide` command
**Preconditions:** Character is not in combat or enemies not alerted

**Flow:**
1. Service determines surface type from current room
2. Service calculates DC with environmental modifiers
3. Character makes Acrobatics check vs DC
4. If successful, character gains [Hidden] status
5. If failed, nearby enemies are alerted
6. If fumbled, [System-Wide Alert] triggers

**Postconditions:** Character is [Hidden] or detected

### 18.2 Use Case: Party Stealth Through Area

**Actor:** Party of characters
**Trigger:** Party movement through enemy-occupied area
**Preconditions:** Party members identified

**Flow:**
1. Service identifies party member with lowest Acrobatics pool
2. Service calculates stealth DC for area
3. Weakest member makes Acrobatics check for entire party
4. If successful, entire party gains [Hidden]
5. If failed, entire party is detected
6. If fumbled, [System-Wide Alert] affects adjacent rooms

**Postconditions:** Party is collectively [Hidden] or detected

### 18.3 Use Case: [Hidden] Attack Bonus

**Actor:** [Hidden] character
**Trigger:** Character attacks from [Hidden] state
**Preconditions:** Character has active [Hidden] status

**Flow:**
1. Character declares attack
2. Service checks if attack bonus has been used
3. If first attack, grants advantage on attack roll
4. Service marks `HasUsedHidingBonus = true`
5. Service breaks [Hidden] status (unless [Ghostly Form])

**Postconditions:** Attack made with advantage, [Hidden] removed

### 18.4 Use Case: Enemy Detects Hidden Character

**Actor:** Enemy NPC
**Trigger:** Enemy makes Perception check
**Preconditions:** Character has [Hidden] status

**Flow:**
1. Enemy rolls Perception vs detection DC
2. Service applies character's DetectionModifier
3. If enemy scores critical success (net ≥ 5), [Hidden] breaks
4. If enemy fails, character remains [Hidden]

**Postconditions:** Character revealed or still [Hidden]

### 18.5 Use Case: [Psychic Resonance] Zone Stealth

**Actor:** Character entering corrupted zone
**Trigger:** Entry into [Psychic Resonance] zone
**Preconditions:** Zone has corruption effect

**Flow:**
1. Service detects zone modifier (-2 DC)
2. Stealth checks in zone benefit from modifier
3. If character has [One with the Static], auto-enter [Hidden]
4. Leaving zone may break [Hidden] (for zone-granted status)

**Postconditions:** Stealth easier in corrupted areas

---

## 19. Deliverable Checklist

### 19.1 Domain Layer

| Item | Status | File |
|------|--------|------|
| `StealthSurface` enum | [ ] | `Domain/Enums/StealthSurface.cs` |
| `HiddenBreakCondition` enum | [ ] | `Domain/Enums/HiddenBreakCondition.cs` |
| `StealthSurfaceExtensions` | [ ] | `Domain/Extensions/StealthSurfaceExtensions.cs` |
| `HiddenStatus` entity | [ ] | `Domain/Entities/HiddenStatus.cs` |
| `StealthContext` value object | [ ] | `Domain/ValueObjects/StealthContext.cs` |
| `StealthCheckResult` value object | [ ] | `Domain/ValueObjects/StealthCheckResult.cs` |
| `PartyStealthResult` value object | [ ] | `Domain/ValueObjects/PartyStealthResult.cs` |

### 19.2 Application Layer

| Item | Status | File |
|------|--------|------|
| `IStealthService` interface | [ ] | `Application/Interfaces/IStealthService.cs` |
| `StealthService` implementation | [ ] | `Application/Services/StealthService.cs` |

### 19.3 Infrastructure Layer

| Item | Status | File |
|------|--------|------|
| `stealth-surfaces.json` configuration | [ ] | `Configuration/stealth-surfaces.json` |
| `stealth-surfaces.schema.json` schema | [ ] | `Configuration/stealth-surfaces.schema.json` |

### 19.4 Test Layer

| Item | Status | File |
|------|--------|------|
| `StealthSurfaceTests` | [ ] | `Tests/StealthSurfaceTests.cs` |
| `HiddenStatusTests` | [ ] | `Tests/HiddenStatusTests.cs` |
| `PartyStealthTests` | [ ] | `Tests/PartyStealthTests.cs` |
| `StealthFumbleTests` | [ ] | `Tests/StealthFumbleTests.cs` |

---

## 20. Acceptance Criteria

### 20.1 Functional Requirements

- [ ] Surface type correctly determines base DC (Silent=2, Normal=3, Noisy=4, VeryNoisy=5)
- [ ] Dim light reduces DC by 1
- [ ] Illuminated increases DC by 2
- [ ] Enemy alerted/combat increases DC by 1
- [ ] [Psychic Resonance] zone reduces DC by 2
- [ ] Successful stealth applies [Hidden] status
- [ ] [Hidden] prevents single-target attacks
- [ ] [Hidden] allows AoE damage
- [ ] First attack from [Hidden] grants advantage
- [ ] Attack breaks [Hidden] status
- [ ] Party stealth uses weakest member's roll
- [ ] Fumble triggers [System-Wide Alert]
- [ ] [System-Wide Alert] affects adjacent rooms

### 20.2 Quality Requirements

- [ ] ~4 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings
- [ ] All public methods have XML documentation
- [ ] Logging covers all significant operations

---

## 21. Future Considerations

### 21.1 Deferred to v0.15.2g

- **[Slip into Shadow]** ability: Enter [Hidden] without action
- **[Ghostly Form]** ability: Stay [Hidden] after attacking (once per encounter)
- **[Cloak the Party]** ability: Grant party +2d10 on Passive Stealth
- **[One with the Static]** ability: Auto-enter [Hidden] in [Psychic Resonance] zones

### 21.2 Potential Enhancements

- Sound propagation based on distance
- Enemy investigation behavior
- Distraction mechanics to re-enter [Hidden]
- Stealth takedowns from [Hidden]
- Cover-based stealth modifiers

---

## 22. Implementation Notes

### 22.1 Success-Counting DC Conversion

The original scope breakdown specified DCs like "DC 10" for silent surfaces. This has been converted to the success-counting system:

| Original (Sum-Based) | Converted (Success-Counting) |
|---------------------|------------------------------|
| DC 10 (Silent) | DC 2 successes |
| DC 14 (Normal) | DC 3 successes |
| DC 18 (Noisy) | DC 4 successes |
| DC 22 (Very Noisy) | DC 5 successes |

### 22.2 Integration Points

The Stealth Service must be registered in the DI container and integrated with:
- Combat system for [Hidden] targeting restrictions
- Room engine for surface type determination
- Enemy AI for detection behavior (future)
- Status effect system for [Hidden] status

### 22.3 Combat Integration

When a [Hidden] character is in combat:
- Enemy single-target abilities cannot target them
- Enemy AoE abilities can still hit them
- Their attacks gain advantage on first hit
- Attacking breaks [Hidden] (unless [Ghostly Form])

---

## 23. Document Metadata

| Property | Value |
|----------|-------|
| **Version** | 0.15.2d |
| **Theme** | Stealth Movement |
| **Created** | 2026-01-17 |
| **Author** | Claude |
| **Status** | Draft |
| **Parent** | v0.15.2 (Acrobatics Skill Expansion) |
| **Dependencies** | v0.15.1a-b (Skill Context, Fumble Types) |
| **Provides To** | v0.15.2e (Chase), v0.15.2g (Specialization), v0.11.x (Combat) |

---

*End of v0.15.2d Design Specification*
