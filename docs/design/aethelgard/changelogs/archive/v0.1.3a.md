> **Archived** - This changelog has been consolidated. See the complete version at [v0.1.3](../v0.1.x/v0.1.3.md).

# Changelog: v0.1.3a - The Codex (Data Foundation)

**Release Date:** 2025-12-19

---

## Summary

Version 0.1.3a establishes the **data foundation** for the Scavenger's Journal (Codex) system. This release introduces the core domain models for **Data Captures** (collectible lore fragments) and **Codex Entries** (the assembled lore targets), along with their persistence layer and comprehensive test coverage. Unlike inventory items, Data Captures exist in a separate progression system with no weight burden, allowing players to collect lore without sacrificing survival capacity. The implementation includes JSONB storage for flexible unlock thresholds, a one-to-many relationship between entries and fragments, and seed data for initial Field Guide tutorials and a sample Bestiary entry. This foundation prepares the system for v0.1.3b (capture logic and discovery triggers) and v0.1.3c (the Journal UI).

---

## New Files Created

### Core Layer - Enums

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/CaptureType.cs` | Classification of data capture methods (TextFragment, EchoRecording, VisualRecord, Specimen, OralHistory, RunicTrace) |
| `RuneAndRust.Core/Enums/EntryCategory.cs` | Codex entry categorization (FieldGuide, BlightOrigin, Bestiary, Factions, Technical, Geography) |

### Core Layer - Entities

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/CodexEntry.cs` | Static lore content with title, category, full text, fragment count, and JSONB unlock thresholds |
| `RuneAndRust.Core/Entities/DataCapture.cs` | Player-discovered fragments with character ownership, optional entry assignment, content, source, and quality |

### Core Layer - Interfaces

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/ICodexEntryRepository.cs` | Repository contract with category filtering, title search, and eager-loading methods |
| `RuneAndRust.Core/Interfaces/IDataCaptureRepository.cs` | Repository contract with character queries, fragment counting, and unassigned capture retrieval |

### Persistence Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Repositories/CodexEntryRepository.cs` | Full repository implementation with DEBUG logging for all operations |
| `RuneAndRust.Persistence/Repositories/DataCaptureRepository.cs` | Full repository implementation with eager loading and DEBUG logging |
| `RuneAndRust.Persistence/Data/CodexSeeder.cs` | Seeds 3 Field Guide entries and 1 Bestiary entry with Domain 4 compliant content |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Core/CodexEntryTests.cs` | 26 unit tests for CodexEntry entity properties, defaults, and unlock threshold operations |
| `RuneAndRust.Tests/Core/DataCaptureTests.cs` | 23 unit tests for DataCapture entity properties, defaults, and navigation |
| `RuneAndRust.Tests/Integration/CodexPersistenceTests.cs` | 23 integration tests for CRUD, JSONB serialization, relationships, and repository queries |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Added `DbSet<CodexEntry>` and `DbSet<DataCapture>`; configured entity mappings with JSONB for `UnlockThresholds`, unique index on `Title`, and one-to-many relationship with `SetNull` delete behavior |

---

## Code Implementation Details

### CaptureType Enum

```csharp
public enum CaptureType
{
    TextFragment = 0,    // Readable notes, slates, torn pages
    EchoRecording = 1,   // Audio logs (transcribed)
    VisualRecord = 2,    // Schematics, images, diagrams
    Specimen = 3,        // Biological samples
    OralHistory = 4,     // Dialogue, rumors
    RunicTrace = 5       // Magical/tech trace analysis
}
```

### EntryCategory Enum

```csharp
public enum EntryCategory
{
    FieldGuide = 0,      // Tutorials (unlocked via gameplay triggers)
    BlightOrigin = 1,    // The Glitch lore
    Bestiary = 2,        // Creature data
    Factions = 3,        // Political/social info
    Technical = 4,       // Pre-Glitch technology
    Geography = 5        // Locations
}
```

### CodexEntry Entity

```csharp
public class CodexEntry
{
    public Guid Id { get; set; }
    public string Title { get; set; }
    public EntryCategory Category { get; set; }
    public string FullText { get; set; }
    public int TotalFragments { get; set; }
    public Dictionary<int, string> UnlockThresholds { get; set; }  // JSONB
    public ICollection<DataCapture> Fragments { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastModified { get; set; }
}
```

**Key Properties:**
- `TotalFragments`: Number of fragments needed for 100% completion
- `UnlockThresholds`: Maps completion percentage to unlock tags (e.g., `{ 25: "WEAKNESS_REVEALED", 50: "HABITAT_REVEALED" }`)

### DataCapture Entity

```csharp
public class DataCapture
{
    public Guid Id { get; set; }
    public Guid CharacterId { get; set; }
    public Guid? CodexEntryId { get; set; }  // Nullable for unassigned
    public CaptureType Type { get; set; }
    public string FragmentContent { get; set; }
    public string Source { get; set; }
    public int Quality { get; set; }  // 15=standard, 30=specialist
    public bool IsAnalyzed { get; set; }
    public DateTime DiscoveredAt { get; set; }
    public CodexEntry? CodexEntry { get; set; }
}
```

**Key Properties:**
- `CodexEntryId`: Nullable FK allows unassigned fragments awaiting auto-assignment
- `Quality`: Affects Legend reward when entry is completed

### Repository Interfaces

**ICodexEntryRepository:**
```csharp
Task<IEnumerable<CodexEntry>> GetByCategoryAsync(EntryCategory category);
Task<CodexEntry?> GetByTitleAsync(string title);
Task<CodexEntry?> GetWithFragmentsAsync(Guid id);
Task AddRangeAsync(IEnumerable<CodexEntry> entries);
```

**IDataCaptureRepository:**
```csharp
Task<IEnumerable<DataCapture>> GetByCharacterIdAsync(Guid characterId);
Task<IEnumerable<DataCapture>> GetByEntryIdAsync(Guid entryId, Guid characterId);
Task<int> GetFragmentCountAsync(Guid entryId, Guid characterId);
Task<IEnumerable<DataCapture>> GetUnassignedAsync(Guid characterId);
Task AddRangeAsync(IEnumerable<DataCapture> captures);
```

### DbContext Configuration

```csharp
// JSONB conversion for UnlockThresholds
entity.Property(e => e.UnlockThresholds)
    .HasColumnType("jsonb")
    .HasConversion(
        v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
        v => JsonSerializer.Deserialize<Dictionary<int, string>>(v, (JsonSerializerOptions?)null)
            ?? new Dictionary<int, string>()
    )
    .IsRequired();

// Relationship with SetNull on delete
entity.HasMany(e => e.Fragments)
    .WithOne(d => d.CodexEntry)
    .HasForeignKey(d => d.CodexEntryId)
    .OnDelete(DeleteBehavior.SetNull);
```

### Seed Data

**Field Guide Entries (3):**
- "Psychic Stress" - Mental coherence mechanics
- "Combat Basics" - Violence and stamina management
- "Burden and Carrying Capacity" - Weight and inventory limits

**Bestiary Entry (1):**
- "Rusted Servitor" - 4-fragment entry with progressive unlocks at 25%, 50%, 75%, 100%

---

## Logging Matrix

### CodexEntryRepository

| Method | Level | Template |
|--------|-------|----------|
| GetByCategoryAsync | Debug | `"Fetching CodexEntries with category {Category}"` |
| GetByCategoryAsync | Debug | `"Retrieved {Count} CodexEntries with category {Category}"` |
| GetByTitleAsync | Debug | `"Fetching CodexEntry with title {Title}"` |
| GetByTitleAsync | Debug | `"CodexEntry with title {Title} not found"` / `"Retrieved CodexEntry: {Title}"` |
| GetWithFragmentsAsync | Debug | `"Fetching CodexEntry {Id} with Fragments"` |
| GetWithFragmentsAsync | Debug | `"Retrieved CodexEntry {Title} with {FragmentCount} fragments"` |
| AddRangeAsync | Debug | `"Adding {Count} CodexEntries"` / `"Successfully added {Count} CodexEntries to context"` |

### DataCaptureRepository

| Method | Level | Template |
|--------|-------|----------|
| GetByCharacterIdAsync | Debug | `"Fetching DataCaptures for Character {CharacterId}"` |
| GetByCharacterIdAsync | Debug | `"Retrieved {Count} DataCaptures for Character {CharacterId}"` |
| GetByEntryIdAsync | Debug | `"Fetching DataCaptures for Entry {EntryId} and Character {CharacterId}"` |
| GetFragmentCountAsync | Debug | `"Counting fragments for Entry {EntryId} and Character {CharacterId}"` |
| GetFragmentCountAsync | Debug | `"Character {CharacterId} has {Count} fragments for entry {EntryId}"` |
| GetUnassignedAsync | Debug | `"Fetching unassigned DataCaptures for Character {CharacterId}"` |
| AddRangeAsync | Debug | `"Adding {Count} DataCaptures"` / `"Successfully added {Count} DataCaptures to context"` |

---

## Test Coverage

### CodexEntryTests.cs (26 tests)

| Region | Tests |
|--------|-------|
| Identity | `CodexEntry_NewEntry_HasUniqueId`, `CodexEntry_Title_DefaultsToEmptyString`, `CodexEntry_Title_CanBeSet` |
| Classification | `CodexEntry_Category_DefaultsToFieldGuide`, `CodexEntry_Category_CanBeSetToAllCategories` (Theory, 6 cases) |
| Content | `CodexEntry_FullText_DefaultsToEmptyString`, `CodexEntry_FullText_CanBeSet`, `CodexEntry_TotalFragments_DefaultsToOne`, `CodexEntry_TotalFragments_CanBeSet` |
| Unlock Thresholds | `CodexEntry_UnlockThresholds_DefaultsToEmptyDictionary`, `CodexEntry_UnlockThresholds_CanAddEntries`, `CodexEntry_UnlockThresholds_CanBeInitializedInline`, `CodexEntry_UnlockThresholds_CanCheckForThreshold` |
| Navigation | `CodexEntry_Fragments_DefaultsToEmptyCollection`, `CodexEntry_Fragments_CanAddDataCaptures` |
| Metadata | `CodexEntry_CreatedAt_IsSetAutomatically`, `CodexEntry_LastModified_IsSetAutomatically` |
| Full Creation | `CodexEntry_FullCreation_AllPropertiesSet` |

### DataCaptureTests.cs (23 tests)

| Region | Tests |
|--------|-------|
| Identity | `DataCapture_NewCapture_HasUniqueId` |
| Ownership | `DataCapture_CharacterId_DefaultsToEmptyGuid`, `DataCapture_CharacterId_CanBeSet` |
| Assignment | `DataCapture_CodexEntryId_DefaultsToNull`, `DataCapture_CodexEntryId_CanBeSet`, `DataCapture_CodexEntryId_CanBeSetToNull` |
| Classification | `DataCapture_Type_DefaultsToTextFragment`, `DataCapture_Type_CanBeSetToAllTypes` (Theory, 6 cases) |
| Content | `DataCapture_FragmentContent_DefaultsToEmptyString`, `DataCapture_FragmentContent_CanBeSet`, `DataCapture_Source_DefaultsToEmptyString`, `DataCapture_Source_CanBeSet` |
| Quality | `DataCapture_Quality_DefaultsToFifteen`, `DataCapture_Quality_CanBeSetToStandard`, `DataCapture_Quality_CanBeSetToSpecialist` |
| State | `DataCapture_IsAnalyzed_DefaultsToFalse`, `DataCapture_IsAnalyzed_CanBeSetToTrue` |
| Metadata | `DataCapture_DiscoveredAt_IsSetAutomatically` |
| Navigation | `DataCapture_CodexEntry_DefaultsToNull`, `DataCapture_CodexEntry_CanBeSet` |
| Full Creation | `DataCapture_FullCreation_AllPropertiesSet`, `DataCapture_UnassignedCapture_HasNullCodexEntryId` |

### CodexPersistenceTests.cs (23 tests)

| Region | Tests |
|--------|-------|
| CodexEntry CRUD | `AddAsync_ShouldPersistCodexEntry`, `AddAsync_ShouldPersistAllCodexProperties`, `UpdateAsync_ShouldModifyCodexEntry`, `DeleteAsync_ShouldRemoveCodexEntry` |
| GetByCategoryAsync | `GetByCategoryAsync_ReturnsEntriesOfCategory`, `GetByCategoryAsync_NoMatches_ReturnsEmptyList` |
| GetByTitleAsync | `GetByTitleAsync_FindsExactMatch`, `GetByTitleAsync_CaseInsensitive`, `GetByTitleAsync_NotFound_ReturnsNull` |
| UnlockThresholds JSONB | `UnlockThresholds_SerializesAsJsonb`, `UnlockThresholds_EmptyDictionary_PersistsCorrectly` |
| DataCapture CRUD | `AddAsync_ShouldPersistDataCapture`, `AddAsync_ShouldPersistAllCaptureProperties` |
| GetByCharacterIdAsync | `GetByCharacterIdAsync_ReturnsCharacterCaptures`, `GetByCharacterIdAsync_NoCaptures_ReturnsEmptyList` |
| GetFragmentCountAsync | `GetFragmentCountAsync_ReturnsCorrectCount`, `GetFragmentCountAsync_NoFragments_ReturnsZero` |
| GetWithFragmentsAsync | `GetWithFragmentsAsync_IncludesRelatedCaptures` |
| GetUnassignedAsync | `GetUnassignedAsync_ReturnsUnassignedCaptures` |
| AddRangeAsync | `AddRangeAsync_AddsMultipleCodexEntries`, `AddRangeAsync_AddsMultipleDataCaptures` |
| Relationships | `DataCapture_LinkedToEntry_NavigationPropertyWorks` |

---

## Test Summary

| Category | Count | Status |
|----------|-------|--------|
| CodexEntryTests | 26 | Passed |
| DataCaptureTests | 23 | Passed |
| CodexPersistenceTests | 23 | Passed |
| **v0.1.3a Total** | **72** | **All Passed** |
| **Full Suite Total** | **1,118** | **All Passed** |

---

## Directory Structure

```
RuneAndRust.Core/
├── Entities/
│   ├── CodexEntry.cs          [NEW]
│   └── DataCapture.cs         [NEW]
├── Enums/
│   ├── CaptureType.cs         [NEW]
│   └── EntryCategory.cs       [NEW]
└── Interfaces/
    ├── ICodexEntryRepository.cs   [NEW]
    └── IDataCaptureRepository.cs  [NEW]

RuneAndRust.Persistence/
├── Data/
│   ├── RuneAndRustDbContext.cs    [MODIFIED]
│   └── CodexSeeder.cs             [NEW]
└── Repositories/
    ├── CodexEntryRepository.cs    [NEW]
    └── DataCaptureRepository.cs   [NEW]

RuneAndRust.Tests/
├── Core/
│   ├── CodexEntryTests.cs     [NEW]
│   └── DataCaptureTests.cs    [NEW]
└── Integration/
    └── CodexPersistenceTests.cs   [NEW]
```

---

## Technical Highlights

### JSONB Storage for Unlock Thresholds

The `UnlockThresholds` property uses PostgreSQL JSONB for flexible threshold storage:

```csharp
// Example unlock thresholds for a Bestiary entry
new Dictionary<int, string>
{
    { 25, "WEAKNESS_REVEALED" },
    { 50, "HABITAT_REVEALED" },
    { 75, "BEHAVIOR_REVEALED" },
    { 100, "FULL_ENTRY" }
}
```

This allows the UI to progressively reveal information as players collect more fragments without schema changes.

### Nullable Foreign Key Pattern

Data Captures use a nullable `CodexEntryId` to support unassigned fragments:

```csharp
entity.HasOne(d => d.CodexEntry)
    .WithMany(e => e.Fragments)
    .HasForeignKey(d => d.CodexEntryId)
    .OnDelete(DeleteBehavior.SetNull);
```

When a CodexEntry is deleted, associated captures become unassigned rather than deleted, preserving player discovery history.

### Domain 4 Compliance

All seed data content follows Domain 4 constraints (no precision measurements):

```csharp
// Compliant: "roughly as tall as a grown man"
// Non-compliant: "exactly 1.8 meters tall"
```

---

## Verification

```bash
# Build
dotnet build
# Build succeeded. 0 Error(s)

# Test new components
dotnet test --filter "FullyQualifiedName~Codex|FullyQualifiedName~DataCapture"
# Passed! - Failed: 0, Passed: 72, Skipped: 0

# Full test suite
dotnet test
# Passed! - Failed: 0, Passed: 1118, Skipped: 0
```

---

## Next Steps

**v0.1.3b: Capture Logic & Distribution**
- Implement `IDataCaptureService` for discovery and auto-assignment
- Integrate with `LootService` for capture generation
- Hook `Examine` command for capture triggers
- Publish `CaptureFoundEvent` for UI notification

**v0.1.3c: The Journal UI**
- Implement `journal` and `codex` terminal commands
- Create tabbed interface (Codex | Bestiary | Field Guide)
- Implement redaction renderer for incomplete entries
