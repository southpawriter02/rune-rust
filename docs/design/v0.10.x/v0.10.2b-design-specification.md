# v0.10.2b Design Specification: Talent Point Service

**Version:** 0.10.2b
**Parent:** v0.10.2 (Ability Trees)
**Prerequisites:** v0.10.2a Complete (Tree Definitions)
**Status:** Design Complete
**Estimated Unit Tests:** ~18

---

## 1. Overview

### Purpose

Implement the talent point management service for earning, spending, and tracking talent points. Players earn points on level-up and spend them to allocate into tree nodes. Allocations are tracked on the player entity with current rank per node. The service integrates with the LevelUpService to award points automatically.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | `ITalentPointService` |
| **Services** | `TalentPointService` |
| **Domain Entities** | `TalentAllocation` |
| **DTOs** | `AllocationResult`, `AllocationResultType` |
| **Player Updates** | `TalentAllocations`, `UnspentTalentPoints`, `TotalTalentPointsEarned` |
| **Events** | `TalentPointEarnedEvent`, `TalentPointSpentEvent`, `AbilityUnlockedEvent` |
| **Tests** | ~18 unit tests |

---

## 2. Feature Overview

```
v0.10.2b Features
├── ITalentPointService Interface
│   ├── GetUnspentPoints(player)
│   ├── GetTotalPointsEarned(player)
│   ├── GetTotalPointsSpent(player)
│   ├── AwardPoints(player, count)
│   ├── SpendPoint(player, nodeId)
│   ├── GetAllocation(player, nodeId)
│   ├── GetNodeRank(player, nodeId)
│   ├── CanSpendOn(player, nodeId)
│   ├── GetAllAllocations(player)
│   └── GetAllocationsForTree(player, treeId)
│
├── TalentPointService Implementation
│   ├── Award points on level-up
│   ├── Validate point spending
│   ├── Track allocations
│   └── Publish events
│
├── TalentAllocation Entity
│   ├── NodeId
│   ├── CurrentRank
│   ├── PointCostPerRank
│   ├── AllocatedAt
│   ├── IncrementRank()
│   └── GetTotalPointsSpent()
│
├── Player Entity Updates
│   ├── TalentAllocations collection
│   ├── UnspentTalentPoints
│   ├── TotalTalentPointsEarned
│   ├── AddTalentPoints(count)
│   ├── SpendTalentPoints(count)
│   └── AddTalentAllocation(allocation)
│
├── AllocationResult Record
│   ├── Success, Failed
│   ├── InsufficientPoints
│   ├── AtMaxRank
│   └── PrerequisitesNotMet
│
├── Events
│   ├── TalentPointEarnedEvent
│   ├── TalentPointSpentEvent
│   └── AbilityUnlockedEvent
│
└── LevelUpService Integration
    └── Award PointsPerLevel on level-up
```

---

## 3. Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    TALENT POINT ARCHITECTURE                            │
└─────────────────────────────────────────────────────────────────────────┘

                      ┌───────────────────────────┐
                      │      Level Up Event        │
                      └───────────────┬───────────┘
                                      │ OnLevelUp
                                      ▼
                      ┌───────────────────────────┐
                      │    ITalentPointService     │
                      ├───────────────────────────┤
                      │ + GetUnspentPoints()      │
                      │ + GetTotalPointsEarned()  │
                      │ + AwardPoints(count)      │
                      │ + SpendPoint(nodeId)      │
                      │ + GetAllocation(nodeId)   │
                      │ + GetNodeRank(nodeId)     │
                      │ + CanSpendOn(nodeId)      │
                      └───────────────┬───────────┘
                                      │
                      ┌───────────────┴───────────┐
                      │     TalentPointService     │
                      ├───────────────────────────┤
                      │ - _treeProvider           │
                      │ - _prerequisiteValidator  │
                      │                           │
                      │ + CheckHasPoints          │
                      │ + CheckNodeMaxRank        │
                      │ + UpdateAllocation        │
                      └───────────────────────────┘
                               │           │
                               ▼           ▼
                   ┌─────────────────┐  ┌─────────────────┐
                   │     Player      │  │IAbilityTreeProv │
                   │ + Unspent: int  │  │ (get node info) │
                   │ + Allocations[] │  └─────────────────┘
                   └─────────────────┘


    ALLOCATION TRACKING
    ───────────────────

    Player.TalentAllocations:
    ┌─────────────────────────────────────────────────────────┐
    │ NodeId          │ CurrentRank │ MaxRank │ TotalSpent   │
    ├─────────────────┼─────────────┼─────────┼──────────────┤
    │ frenzy          │ 2           │ 3       │ 2            │
    │ shield-wall     │ 3           │ 3       │ 3            │
    │ taunt           │ 1           │ 1       │ 1            │
    │ iron-skin       │ 0           │ 1       │ 0            │
    └─────────────────┴─────────────┴─────────┴──────────────┘

    Total Points Spent: 6
    Unspent Points: 2
```

---

## 4. TalentAllocation Entity

**File:** `src/Core/RuneAndRust.Domain/Entities/TalentAllocation.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Tracks a player's allocation into a talent tree node.
/// </summary>
public class TalentAllocation : IEntity
{
    public Guid Id { get; private set; }

    /// <summary>The node this allocation is for.</summary>
    public string NodeId { get; private set; } = null!;

    /// <summary>Current rank invested in this node.</summary>
    public int CurrentRank { get; private set; }

    /// <summary>Point cost per rank (for calculating refunds).</summary>
    public int PointCostPerRank { get; private set; }

    /// <summary>When the first rank was allocated.</summary>
    public DateTime AllocatedAt { get; private set; }

    /// <summary>When the last rank was added.</summary>
    public DateTime LastModifiedAt { get; private set; }

    // EF Core constructor
    private TalentAllocation() { }

    public static TalentAllocation Create(string nodeId, int pointCostPerRank)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(nodeId);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(pointCostPerRank);

        var now = DateTime.UtcNow;
        return new TalentAllocation
        {
            Id = Guid.NewGuid(),
            NodeId = nodeId.ToLowerInvariant(),
            CurrentRank = 1,
            PointCostPerRank = pointCostPerRank,
            AllocatedAt = now,
            LastModifiedAt = now
        };
    }

    /// <summary>Increases the rank by one.</summary>
    public void IncrementRank()
    {
        CurrentRank++;
        LastModifiedAt = DateTime.UtcNow;
    }

    /// <summary>Gets total points spent on this node.</summary>
    public int GetTotalPointsSpent()
    {
        return CurrentRank * PointCostPerRank;
    }

    public override string ToString() => $"{NodeId}: Rank {CurrentRank}";
}
```

---

## 5. Player Entity Updates

**Updates to:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

public partial class Player
{
    // ... existing members ...

    /// <summary>Talent points available to spend.</summary>
    public int UnspentTalentPoints { get; private set; }

    /// <summary>Total talent points ever earned.</summary>
    public int TotalTalentPointsEarned { get; private set; }

    /// <summary>Current talent allocations.</summary>
    private readonly List<TalentAllocation> _talentAllocations = new();
    public IReadOnlyList<TalentAllocation> TalentAllocations => _talentAllocations;

    /// <summary>Adds talent points.</summary>
    public void AddTalentPoints(int count)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(count);
        UnspentTalentPoints += count;
        TotalTalentPointsEarned += count;
    }

    /// <summary>Spends talent points.</summary>
    public void SpendTalentPoints(int count)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(count);
        if (count > UnspentTalentPoints)
        {
            throw new InvalidOperationException($"Cannot spend {count} points, only have {UnspentTalentPoints}");
        }
        UnspentTalentPoints -= count;
    }

    /// <summary>Adds a new talent allocation.</summary>
    public void AddTalentAllocation(TalentAllocation allocation)
    {
        ArgumentNullException.ThrowIfNull(allocation);
        _talentAllocations.Add(allocation);
    }

    /// <summary>Clears all talent allocations (for respec).</summary>
    public void ClearTalentAllocations()
    {
        _talentAllocations.Clear();
    }

    /// <summary>Refunds all spent talent points (for respec).</summary>
    public void RefundAllTalentPoints()
    {
        var totalSpent = _talentAllocations.Sum(a => a.GetTotalPointsSpent());
        UnspentTalentPoints += totalSpent;
    }

    /// <summary>Gets allocation for a specific node.</summary>
    public TalentAllocation? GetAllocation(string nodeId)
    {
        return _talentAllocations.FirstOrDefault(a =>
            a.NodeId.Equals(nodeId, StringComparison.OrdinalIgnoreCase));
    }
}
```

---

## 6. ITalentPointService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITalentPointService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing talent point allocation.
/// </summary>
public interface ITalentPointService
{
    /// <summary>Gets unspent talent points for a player.</summary>
    int GetUnspentPoints(Player player);

    /// <summary>Gets total points earned by a player.</summary>
    int GetTotalPointsEarned(Player player);

    /// <summary>Gets total points spent by a player.</summary>
    int GetTotalPointsSpent(Player player);

    /// <summary>Awards talent points to a player.</summary>
    /// <param name="player">The player to award points to.</param>
    /// <param name="count">Number of points to award.</param>
    void AwardPoints(Player player, int count);

    /// <summary>Spends a point on a tree node.</summary>
    /// <param name="player">The player spending the point.</param>
    /// <param name="nodeId">The node to allocate to.</param>
    /// <returns>Result of the allocation attempt.</returns>
    AllocationResult SpendPoint(Player player, string nodeId);

    /// <summary>Gets the current allocation for a node.</summary>
    TalentAllocation? GetAllocation(Player player, string nodeId);

    /// <summary>Gets the current rank of a node for a player.</summary>
    int GetNodeRank(Player player, string nodeId);

    /// <summary>Checks if a player can spend on a node.</summary>
    bool CanSpendOn(Player player, string nodeId);

    /// <summary>Gets all allocations for a player.</summary>
    IReadOnlyList<TalentAllocation> GetAllAllocations(Player player);

    /// <summary>Gets allocations for a specific tree.</summary>
    IReadOnlyList<TalentAllocation> GetAllocationsForTree(Player player, string treeId);

    /// <summary>Gets available nodes the player can spend on.</summary>
    IReadOnlyList<AbilityTreeNode> GetAvailableNodes(Player player);

    /// <summary>Gets the summary of points for a player.</summary>
    TalentPointSummary GetPointSummary(Player player);
}
```

---

## 7. TalentPointService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/TalentPointService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class TalentPointService : ITalentPointService
{
    private readonly IAbilityTreeProvider _treeProvider;
    private readonly IPrerequisiteValidator _prerequisiteValidator;
    private readonly IEventBus _eventBus;
    private readonly ILogger<TalentPointService> _logger;

    public TalentPointService(
        IAbilityTreeProvider treeProvider,
        IPrerequisiteValidator prerequisiteValidator,
        IEventBus eventBus,
        ILogger<TalentPointService> logger)
    {
        _treeProvider = treeProvider;
        _prerequisiteValidator = prerequisiteValidator;
        _eventBus = eventBus;
        _logger = logger;
    }

    public int GetUnspentPoints(Player player)
    {
        return player.UnspentTalentPoints;
    }

    public int GetTotalPointsEarned(Player player)
    {
        return player.TotalTalentPointsEarned;
    }

    public int GetTotalPointsSpent(Player player)
    {
        return player.TalentAllocations.Sum(a => a.GetTotalPointsSpent());
    }

    public void AwardPoints(Player player, int count)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(count);

        player.AddTalentPoints(count);

        _logger.LogInformation("{Player} earned {Count} talent point(s). Total unspent: {Unspent}",
            player.Name, count, player.UnspentTalentPoints);

        _eventBus.Publish(new TalentPointEarnedEvent(player.Id, count, player.UnspentTalentPoints));
    }

    public AllocationResult SpendPoint(Player player, string nodeId)
    {
        // Find the node
        var node = _treeProvider.FindNode(nodeId);
        if (node is null)
        {
            _logger.LogWarning("Node not found: {NodeId}", nodeId);
            return AllocationResult.Failed($"Node not found: {nodeId}");
        }

        // Check points available
        if (player.UnspentTalentPoints < node.PointCost)
        {
            _logger.LogDebug("{Player} has insufficient points for {Node}: need {Need}, have {Have}",
                player.Name, nodeId, node.PointCost, player.UnspentTalentPoints);
            return AllocationResult.InsufficientPoints(node.PointCost, player.UnspentTalentPoints);
        }

        // Check current rank
        var currentRank = GetNodeRank(player, nodeId);
        if (currentRank >= node.MaxRank)
        {
            _logger.LogDebug("{Player} already at max rank {Max} for {Node}",
                player.Name, node.MaxRank, nodeId);
            return AllocationResult.AtMaxRank(nodeId, node.MaxRank);
        }

        // Check prerequisites (delegated to validator)
        var prereqResult = _prerequisiteValidator.ValidatePrerequisites(player, node);
        if (!prereqResult.IsValid)
        {
            _logger.LogDebug("{Player} does not meet prerequisites for {Node}: {Reasons}",
                player.Name, nodeId, string.Join(", ", prereqResult.FailureReasons));
            return AllocationResult.PrerequisitesNotMet(prereqResult.FailureReasons);
        }

        // Allocate the point
        var allocation = player.GetAllocation(nodeId);
        if (allocation is null)
        {
            allocation = TalentAllocation.Create(nodeId, node.PointCost);
            player.AddTalentAllocation(allocation);
        }
        else
        {
            allocation.IncrementRank();
        }

        player.SpendTalentPoints(node.PointCost);

        _logger.LogInformation("{Player} spent {Cost} point(s) on {Node} (rank {Rank}/{Max})",
            player.Name, node.PointCost, nodeId, allocation.CurrentRank, node.MaxRank);

        _eventBus.Publish(new TalentPointSpentEvent(player.Id, nodeId, allocation.CurrentRank, node.PointCost));

        // Grant ability if first rank
        if (allocation.CurrentRank == 1)
        {
            _logger.LogInformation("{Player} unlocked ability {Ability} from talent {Node}",
                player.Name, node.AbilityId, nodeId);
            _eventBus.Publish(new AbilityUnlockedEvent(player.Id, node.AbilityId, nodeId));
        }

        return AllocationResult.Success(nodeId, allocation.CurrentRank);
    }

    public TalentAllocation? GetAllocation(Player player, string nodeId)
    {
        return player.GetAllocation(nodeId);
    }

    public int GetNodeRank(Player player, string nodeId)
    {
        var allocation = player.GetAllocation(nodeId);
        return allocation?.CurrentRank ?? 0;
    }

    public bool CanSpendOn(Player player, string nodeId)
    {
        var node = _treeProvider.FindNode(nodeId);
        if (node is null) return false;

        if (player.UnspentTalentPoints < node.PointCost) return false;
        if (GetNodeRank(player, nodeId) >= node.MaxRank) return false;

        var prereqResult = _prerequisiteValidator.ValidatePrerequisites(player, node);
        return prereqResult.IsValid;
    }

    public IReadOnlyList<TalentAllocation> GetAllAllocations(Player player)
    {
        return player.TalentAllocations;
    }

    public IReadOnlyList<TalentAllocation> GetAllocationsForTree(Player player, string treeId)
    {
        var tree = _treeProvider.GetTree(treeId);
        if (tree is null) return [];

        var treeNodeIds = tree.GetAllNodes().Select(n => n.NodeId).ToHashSet(StringComparer.OrdinalIgnoreCase);
        return player.TalentAllocations.Where(a => treeNodeIds.Contains(a.NodeId)).ToList();
    }

    public IReadOnlyList<AbilityTreeNode> GetAvailableNodes(Player player)
    {
        var tree = _treeProvider.GetTreeForClass(player.ClassId);
        if (tree is null) return [];

        return tree.GetAllNodes()
            .Where(n => CanSpendOn(player, n.NodeId))
            .ToList();
    }

    public TalentPointSummary GetPointSummary(Player player)
    {
        return new TalentPointSummary(
            Unspent: player.UnspentTalentPoints,
            TotalEarned: player.TotalTalentPointsEarned,
            TotalSpent: GetTotalPointsSpent(player),
            AllocatedNodes: player.TalentAllocations.Count
        );
    }
}
```

---

## 8. AllocationResult Record

**File:** `src/Core/RuneAndRust.Application/DTOs/AllocationResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of a talent point allocation attempt.
/// </summary>
public record AllocationResult(
    bool IsSuccess,
    AllocationResultType ResultType,
    string? NodeId,
    int? NewRank,
    string? FailureReason)
{
    public static AllocationResult Success(string nodeId, int newRank)
        => new(true, AllocationResultType.Success, nodeId, newRank, null);

    public static AllocationResult Failed(string reason)
        => new(false, AllocationResultType.Failed, null, null, reason);

    public static AllocationResult InsufficientPoints(int required, int available)
        => new(false, AllocationResultType.InsufficientPoints, null, null,
            $"Need {required} points, have {available}");

    public static AllocationResult AtMaxRank(string nodeId, int maxRank)
        => new(false, AllocationResultType.AtMaxRank, nodeId, maxRank,
            $"Already at max rank {maxRank}");

    public static AllocationResult PrerequisitesNotMet(IEnumerable<string> reasons)
        => new(false, AllocationResultType.PrerequisitesNotMet, null, null,
            string.Join("; ", reasons));
}

/// <summary>
/// Types of allocation results.
/// </summary>
public enum AllocationResultType
{
    /// <summary>Point successfully allocated.</summary>
    Success,

    /// <summary>Generic failure.</summary>
    Failed,

    /// <summary>Not enough unspent points.</summary>
    InsufficientPoints,

    /// <summary>Node already at maximum rank.</summary>
    AtMaxRank,

    /// <summary>Node/stat prerequisites not met.</summary>
    PrerequisitesNotMet
}
```

---

## 9. TalentPointSummary Record

**File:** `src/Core/RuneAndRust.Application/DTOs/TalentPointSummary.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Summary of a player's talent point status.
/// </summary>
public record TalentPointSummary(
    int Unspent,
    int TotalEarned,
    int TotalSpent,
    int AllocatedNodes);
```

---

## 10. Talent Point Events

**File:** `src/Core/RuneAndRust.Application/Events/TalentPointEvents.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>Published when a player earns talent points.</summary>
public record TalentPointEarnedEvent(
    Guid PlayerId,
    int PointsEarned,
    int TotalUnspent);

/// <summary>Published when a player spends a talent point.</summary>
public record TalentPointSpentEvent(
    Guid PlayerId,
    string NodeId,
    int NewRank,
    int PointsSpent);

/// <summary>Published when a player unlocks a new ability via talent.</summary>
public record AbilityUnlockedEvent(
    Guid PlayerId,
    string AbilityId,
    string FromNodeId);
```

---

## 11. LevelUp Integration

**Updates to:** `src/Core/RuneAndRust.Application/Services/LevelUpService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public partial class LevelUpService
{
    private readonly ITalentPointService _talentPointService;
    private readonly IAbilityTreeProvider _treeProvider;

    // In LevelUp method, after applying level benefits:
    private void AwardTalentPoints(Player player)
    {
        var tree = _treeProvider.GetTreeForClass(player.ClassId);
        var pointsToAward = tree?.PointsPerLevel ?? 1;

        _talentPointService.AwardPoints(player, pointsToAward);

        _logger.LogInformation("{Player} earned {Points} talent point(s) for reaching level {Level}",
            player.Name, pointsToAward, player.Level);
    }
}
```

---

## 12. Allocation Flow Visualization

```
SPEND POINT FLOW:
═══════════════════════════════════════════════════════════════════════

  Player clicks "Spend on Rage"
              │
              ▼
  SpendPoint(player, "rage")
              │
              ▼
  ┌─────────────────────────────────────────────────┐
  │ 1. Find Node                                    │
  │    node = _treeProvider.FindNode("rage")        │
  │    → Rage: T2, 2pt cost, max 1, req: frenzy     │
  └───────────────────────────┬─────────────────────┘
                              │
                              ▼
  ┌─────────────────────────────────────────────────┐
  │ 2. Check Points                                 │
  │    player.UnspentTalentPoints >= 2?             │
  │    → 3 >= 2 ✓                                   │
  └───────────────────────────┬─────────────────────┘
                              │
                              ▼
  ┌─────────────────────────────────────────────────┐
  │ 3. Check Current Rank                           │
  │    GetNodeRank(player, "rage") < 1?             │
  │    → 0 < 1 ✓                                    │
  └───────────────────────────┬─────────────────────┘
                              │
                              ▼
  ┌─────────────────────────────────────────────────┐
  │ 4. Validate Prerequisites                       │
  │    _prerequisiteValidator.Validate(player, node)│
  │    → Has "frenzy" rank 1+? ✓                    │
  │    → STR >= 14? ✓                               │
  └───────────────────────────┬─────────────────────┘
                              │
                              ▼
  ┌─────────────────────────────────────────────────┐
  │ 5. Create/Update Allocation                     │
  │    allocation = TalentAllocation.Create("rage") │
  │    player.AddTalentAllocation(allocation)       │
  └───────────────────────────┬─────────────────────┘
                              │
                              ▼
  ┌─────────────────────────────────────────────────┐
  │ 6. Spend Points                                 │
  │    player.SpendTalentPoints(2)                  │
  │    → UnspentPoints: 3 → 1                       │
  └───────────────────────────┬─────────────────────┘
                              │
                              ▼
  ┌─────────────────────────────────────────────────┐
  │ 7. Publish Events                               │
  │    → TalentPointSpentEvent                      │
  │    → AbilityUnlockedEvent (rank 1)              │
  └───────────────────────────┬─────────────────────┘
                              │
                              ▼
  AllocationResult.Success("rage", 1)


MULTI-RANK EXAMPLE (Frenzy):
═══════════════════════════════════════════════════════════════════════

  Initial State:
  ├── frenzy: rank 0, max 3
  └── UnspentPoints: 5

  SpendPoint("frenzy") → Creates allocation, rank 1
  SpendPoint("frenzy") → Increments rank to 2
  SpendPoint("frenzy") → Increments rank to 3
  SpendPoint("frenzy") → AtMaxRank error

  Final State:
  ├── frenzy: rank 3/3
  └── UnspentPoints: 2
```

---

## 13. Unit Testing Requirements (~18 tests)

| Feature | Tests |
|---------|-------|
| GetUnspentPoints returns correct value | 1 |
| GetTotalPointsEarned returns correct value | 1 |
| GetTotalPointsSpent calculates correctly | 1 |
| AwardPoints increases unspent and total | 1 |
| AwardPoints publishes event | 1 |
| SpendPoint creates new allocation | 1 |
| SpendPoint increments existing allocation | 1 |
| SpendPoint deducts points | 1 |
| SpendPoint fails with insufficient points | 1 |
| SpendPoint fails at max rank | 1 |
| SpendPoint fails without prerequisites | 1 |
| SpendPoint publishes TalentPointSpentEvent | 1 |
| SpendPoint publishes AbilityUnlockedEvent on rank 1 | 1 |
| GetNodeRank returns 0 for unallocated | 1 |
| GetNodeRank returns correct rank | 1 |
| CanSpendOn returns true when available | 1 |
| CanSpendOn returns false when at max | 1 |
| GetAvailableNodes returns spendable nodes | 1 |

---

## 14. Acceptance Criteria

- [ ] Points awarded on level-up via integration
- [ ] Unspent points tracked on Player
- [ ] Total points earned tracked on Player
- [ ] SpendPoint allocates to node correctly
- [ ] Cannot spend without sufficient points
- [ ] Cannot exceed node MaxRank
- [ ] CurrentRank increments on subsequent spends
- [ ] TalentAllocation created for new nodes
- [ ] TalentAllocation incremented for existing nodes
- [ ] GetNodeRank returns current rank
- [ ] GetNodeRank returns 0 for unallocated
- [ ] CanSpendOn checks all requirements
- [ ] GetAllAllocations returns full list
- [ ] GetAllocationsForTree filters by tree
- [ ] GetAvailableNodes returns spendable nodes
- [ ] TalentPointEarnedEvent fires on award
- [ ] TalentPointSpentEvent fires on spend
- [ ] AbilityUnlockedEvent fires on first rank
- [ ] ~18 unit tests pass

---

## 15. Dependencies

| From | Required |
|------|----------|
| v0.10.2a | `IAbilityTreeProvider`, `AbilityTreeNode` |
| Domain | `Player`, `TalentAllocation` |
| Application | `IEventBus`, `IPrerequisiteValidator` |
| Prior versions | Level-up system |

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
