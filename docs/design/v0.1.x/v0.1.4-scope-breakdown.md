# v0.1.4 World Persistence & Evolution - Scope Breakdown

**Version:** 0.1.4
**Theme:** World Persistence & Evolution
**Prerequisites:** v0.1.3 Complete (Advanced Procedural Architecture)
**Total Estimated Tests:** ~105 new tests

---

## Executive Summary

The World Persistence & Evolution version transforms dungeons from static environments into living worlds that remember player actions and change over time. This version introduces persistent room state tracking, monster repopulation mechanics, faction territory control, environmental storytelling, and dungeon evolution events. Together, these features create a dynamic world where player choices have lasting consequences.

Key focus areas:
- **Persistent World State**: Rooms remember cleared status, solved puzzles, destroyed barriers
- **Monster Repopulation**: Configurable respawn mechanics with spawner rooms
- **Faction Territory Control**: Monster groups claim and contest dungeon zones
- **Environmental Storytelling**: Procedural evidence of events and time passage
- **Dungeon Evolution Events**: Dynamic world changes like cave-ins and migrations

The work is divided into **four sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.1.4a | Persistent World State | RoomState entity, state tracking, save/load integration | ~25 |
| v0.1.4b | Monster Repopulation | Respawn mechanics, spawner rooms, repopulation rules | ~28 |
| v0.1.4c | Faction Territory | FactionDefinition, territory control, faction relationships | ~27 |
| v0.1.4d | Evolution & Storytelling | WorldEvent system, environmental evidence, time effects | ~25 |

---

## Existing Infrastructure

### Already Implemented (from v0.1.3)

| Feature | Location | Notes |
|---------|----------|-------|
| ArchitecturalStyle | `Domain/Definitions/ArchitecturalStyle.cs` | Construction patterns |
| StyleDescriptors | `Domain/ValueObjects/StyleDescriptors.cs` | Style-specific text |
| RoomShape | `Domain/Enums/RoomShape.cs` | Room geometry types |
| StructuralFeature | `Domain/Definitions/StructuralFeature.cs` | Room elements |
| LandmarkRoom | `Domain/Definitions/LandmarkRoom.cs` | Curated special rooms |
| DungeonAge | `Domain/Enums/DungeonAge.cs` | Age/decay states |
| CoherenceService | `Application/Services/CoherenceService.cs` | Structural logic |
| Room.Shape | `Domain/Entities/Room.cs` | Room geometry |
| Room.Age | `Domain/Entities/Room.cs` | Room age state |
| BiomeDefinition | `Domain/Definitions/BiomeDefinition.cs` | Themed zones |
| BiomeSpawnTable | `Domain/Definitions/BiomeSpawnTable.cs` | Biome content pools |
| MonsterDefinition | `Domain/Definitions/MonsterDefinition.cs` | Monster configuration |
| TierDefinition | `Domain/Definitions/TierDefinition.cs` | Monster tiers |
| Position3D | `Domain/ValueObjects/Position3D.cs` | 3D coordinates |
| SeededRandomService | `Application/Services/SeededRandomService.cs` | Reproducible random |

### Needs Implementation (v0.1.4)

| Feature | Phase | Notes |
|---------|-------|-------|
| RoomState | v0.1.4a | Persistent room tracking |
| PersistenceRules | v0.1.4a | What persists/resets |
| SpawnerRoom | v0.1.4b | Monster source points |
| RepopulationRules | v0.1.4b | Respawn configuration |
| FactionDefinition | v0.1.4c | Monster group entity |
| TerritoryControl | v0.1.4c | Zone ownership tracking |
| WorldEvent | v0.1.4d | Scheduled changes |
| EnvironmentalEvidence | v0.1.4d | Procedural storytelling |

---

## Feature Analysis & Categorization

### Persistence Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| RoomState entity | High | Room | **v0.1.4a** |
| RoomStateService | High | RoomState | **v0.1.4a** |
| PersistenceRules configuration | Medium | IConfigurationProvider | **v0.1.4a** |
| Cleared room tracking | Medium | RoomState | **v0.1.4a** |
| Puzzle/barrier state | Medium | RoomState | **v0.1.4a** |
| Save/load state integration | High | IGameRepository | **v0.1.4a** |

### Repopulation Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| SpawnerRoom entity | Medium | Room, MonsterDefinition | **v0.1.4b** |
| RepopulationRules configuration | Medium | IConfigurationProvider | **v0.1.4b** |
| RespawnTimer value object | Low | None | **v0.1.4b** |
| RepopulationService | High | SpawnerRoom, RoomState | **v0.1.4b** |
| Spawner destruction mechanics | Medium | SpawnerRoom | **v0.1.4b** |
| Per-room-type timers | Medium | RoomType, RepopulationRules | **v0.1.4b** |

### Faction Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| FactionDefinition entity | High | MonsterDefinition | **v0.1.4c** |
| TerritoryControl value object | Medium | FactionDefinition | **v0.1.4c** |
| FactionRelationship enum | Low | None | **v0.1.4c** |
| FactionService | High | FactionDefinition | **v0.1.4c** |
| Territory expansion logic | High | TerritoryControl | **v0.1.4c** |
| Cross-faction conflict | Medium | FactionRelationship | **v0.1.4c** |

### Evolution Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| WorldEvent entity | High | Room, Dungeon | **v0.1.4d** |
| EvolutionService | High | WorldEvent | **v0.1.4d** |
| EnvironmentalEvidence entity | Medium | RoomState | **v0.1.4d** |
| Time-based changes | Medium | WorldEvent | **v0.1.4d** |
| Cave-in mechanics | Medium | Room, Exit | **v0.1.4d** |
| Monster migration | Medium | FactionDefinition | **v0.1.4d** |

---

## Phase Definitions

---

## v0.1.4a: Persistent World State

### Overview

Create the foundational persistence system that tracks room state changes. This enables rooms to remember when they were cleared, puzzles solved, barriers destroyed, and chests opened. The system integrates with save/load to persist state across sessions.

### Scope

**In Scope:**
- `RoomState` entity for tracking persistent changes
- `RoomStateService` for state management
- `PersistenceRules` configuration defining what persists
- Cleared room tracking with timestamps
- Puzzle and barrier state tracking
- Chest/container state tracking
- Save/load integration for world state
- State querying for room descriptions

**Out of Scope:**
- Monster repopulation (v0.1.4b)
- Faction control (v0.1.4c)
- Evolution events (v0.1.4d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `RoomState` |
| Value Objects | 2 | `StateChange`, `PersistenceRules` |
| Services | 1 | `RoomStateService` |
| Configuration | 1 | `persistence-rules.json` |
| Repository Updates | 1 | `IGameRepository` state methods |
| Unit Tests | ~25 | State tracking, persistence tests |

### RoomState Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Tracks persistent state changes for a room.
/// </summary>
public class RoomState : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the room ID this state belongs to.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets whether the room has been cleared of monsters.
    /// </summary>
    public bool IsCleared { get; private set; }

    /// <summary>
    /// Gets when the room was last cleared.
    /// </summary>
    public DateTime? LastCleared { get; private set; }

    /// <summary>
    /// Gets the number of times this room has been cleared.
    /// </summary>
    public int ClearCount { get; private set; }

    /// <summary>
    /// Gets solved puzzle IDs in this room.
    /// </summary>
    public IReadOnlyList<string> SolvedPuzzles { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets destroyed barrier IDs in this room.
    /// </summary>
    public IReadOnlyList<string> DestroyedBarriers { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets opened container IDs in this room.
    /// </summary>
    public IReadOnlyList<string> OpenedContainers { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets collected item IDs from this room.
    /// </summary>
    public IReadOnlyList<string> CollectedItems { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets triggered trap IDs in this room.
    /// </summary>
    public IReadOnlyList<string> TriggeredTraps { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets custom state entries for extensibility.
    /// </summary>
    public IReadOnlyDictionary<string, string> CustomState { get; private set; }
        = new Dictionary<string, string>();

    /// <summary>
    /// Gets the history of state changes.
    /// </summary>
    public IReadOnlyList<StateChange> ChangeHistory { get; private set; } = Array.Empty<StateChange>();

    private RoomState() { /* EF Core */ }

    /// <summary>
    /// Creates a new room state for tracking.
    /// </summary>
    public static RoomState Create(Guid roomId)
    {
        return new RoomState
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            IsCleared = false,
            ClearCount = 0
        };
    }

    /// <summary>
    /// Marks the room as cleared.
    /// </summary>
    public void MarkCleared(DateTime clearedAt)
    {
        IsCleared = true;
        LastCleared = clearedAt;
        ClearCount++;
        AddChange(StateChangeType.Cleared, "Room cleared");
    }

    /// <summary>
    /// Marks the room as repopulated.
    /// </summary>
    public void MarkRepopulated()
    {
        IsCleared = false;
        AddChange(StateChangeType.Repopulated, "Monsters respawned");
    }

    /// <summary>
    /// Records a puzzle being solved.
    /// </summary>
    public void SolvePuzzle(string puzzleId)
    {
        if (SolvedPuzzles.Contains(puzzleId)) return;

        var puzzles = SolvedPuzzles.ToList();
        puzzles.Add(puzzleId);
        SolvedPuzzles = puzzles;
        AddChange(StateChangeType.PuzzleSolved, $"Solved: {puzzleId}");
    }

    /// <summary>
    /// Records a barrier being destroyed.
    /// </summary>
    public void DestroyBarrier(string barrierId)
    {
        if (DestroyedBarriers.Contains(barrierId)) return;

        var barriers = DestroyedBarriers.ToList();
        barriers.Add(barrierId);
        DestroyedBarriers = barriers;
        AddChange(StateChangeType.BarrierDestroyed, $"Destroyed: {barrierId}");
    }

    /// <summary>
    /// Records a container being opened.
    /// </summary>
    public void OpenContainer(string containerId)
    {
        if (OpenedContainers.Contains(containerId)) return;

        var containers = OpenedContainers.ToList();
        containers.Add(containerId);
        OpenedContainers = containers;
        AddChange(StateChangeType.ContainerOpened, $"Opened: {containerId}");
    }

    /// <summary>
    /// Checks if a puzzle has been solved.
    /// </summary>
    public bool IsPuzzleSolved(string puzzleId) => SolvedPuzzles.Contains(puzzleId);

    /// <summary>
    /// Checks if a barrier is destroyed.
    /// </summary>
    public bool IsBarrierDestroyed(string barrierId) => DestroyedBarriers.Contains(barrierId);

    /// <summary>
    /// Checks if a container is opened.
    /// </summary>
    public bool IsContainerOpened(string containerId) => OpenedContainers.Contains(containerId);

    private void AddChange(StateChangeType type, string description)
    {
        var history = ChangeHistory.ToList();
        history.Add(new StateChange
        {
            Type = type,
            Description = description,
            Timestamp = DateTime.UtcNow
        });

        // Keep last 50 changes
        if (history.Count > 50)
            history = history.TakeLast(50).ToList();

        ChangeHistory = history;
    }
}
```

### StateChange Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Records a change to room state.
/// </summary>
public readonly record struct StateChange
{
    /// <summary>
    /// Gets the type of change.
    /// </summary>
    public StateChangeType Type { get; init; }

    /// <summary>
    /// Gets a description of the change.
    /// </summary>
    public string Description { get; init; }

    /// <summary>
    /// Gets when the change occurred.
    /// </summary>
    public DateTime Timestamp { get; init; }
}

/// <summary>
/// Types of state changes that can occur.
/// </summary>
public enum StateChangeType
{
    /// <summary>Room monsters cleared.</summary>
    Cleared,

    /// <summary>Monsters respawned.</summary>
    Repopulated,

    /// <summary>Puzzle solved.</summary>
    PuzzleSolved,

    /// <summary>Barrier destroyed.</summary>
    BarrierDestroyed,

    /// <summary>Container opened.</summary>
    ContainerOpened,

    /// <summary>Item collected.</summary>
    ItemCollected,

    /// <summary>Trap triggered.</summary>
    TrapTriggered,

    /// <summary>Faction control changed.</summary>
    FactionChanged,

    /// <summary>World event occurred.</summary>
    WorldEvent,

    /// <summary>Custom state change.</summary>
    Custom
}
```

### RoomStateService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing persistent room state.
/// </summary>
public class RoomStateService : IRoomStateService
{
    private readonly IGameRepository _repository;
    private readonly IConfigurationProvider _config;
    private readonly ILogger<RoomStateService> _logger;
    private readonly Dictionary<Guid, RoomState> _stateCache = new();

    /// <summary>
    /// Gets the state for a room, creating if needed.
    /// </summary>
    public RoomState GetOrCreateState(Guid roomId)
    {
        if (_stateCache.TryGetValue(roomId, out var cached))
            return cached;

        var state = _repository.GetRoomState(roomId)
                    ?? RoomState.Create(roomId);

        _stateCache[roomId] = state;
        return state;
    }

    /// <summary>
    /// Marks a room as cleared.
    /// </summary>
    public void MarkRoomCleared(Room room)
    {
        var state = GetOrCreateState(room.Id);
        state.MarkCleared(DateTime.UtcNow);

        _logger.LogInformation(
            "Room {RoomId} cleared (count: {ClearCount})",
            room.Id,
            state.ClearCount);

        SaveState(state);
    }

    /// <summary>
    /// Records a puzzle solution.
    /// </summary>
    public void RecordPuzzleSolved(Room room, string puzzleId)
    {
        var rules = GetPersistenceRules();
        if (!rules.PersistPuzzles) return;

        var state = GetOrCreateState(room.Id);
        state.SolvePuzzle(puzzleId);
        SaveState(state);
    }

    /// <summary>
    /// Records a barrier destruction.
    /// </summary>
    public void RecordBarrierDestroyed(Room room, string barrierId)
    {
        var rules = GetPersistenceRules();
        if (!rules.PersistBarriers) return;

        var state = GetOrCreateState(room.Id);
        state.DestroyBarrier(barrierId);
        SaveState(state);
    }

    /// <summary>
    /// Records a container being opened.
    /// </summary>
    public void RecordContainerOpened(Room room, string containerId)
    {
        var rules = GetPersistenceRules();
        if (!rules.PersistContainers) return;

        var state = GetOrCreateState(room.Id);
        state.OpenContainer(containerId);
        SaveState(state);
    }

    /// <summary>
    /// Checks if a room should show cleared state.
    /// </summary>
    public bool ShouldShowCleared(Room room)
    {
        var state = GetOrCreateState(room.Id);
        return state.IsCleared;
    }

    /// <summary>
    /// Gets description modifications based on state.
    /// </summary>
    public string GetStateDescription(Room room)
    {
        var state = GetOrCreateState(room.Id);
        var descriptions = new List<string>();

        if (state.IsCleared)
        {
            descriptions.Add("The area shows signs of a recent battle.");
        }

        if (state.DestroyedBarriers.Any())
        {
            descriptions.Add("Rubble marks where barriers once stood.");
        }

        if (state.OpenedContainers.Any())
        {
            descriptions.Add("Empty containers lie discarded.");
        }

        return string.Join(" ", descriptions);
    }

    /// <summary>
    /// Saves all cached state to repository.
    /// </summary>
    public void SaveAllState()
    {
        foreach (var state in _stateCache.Values)
        {
            _repository.SaveRoomState(state);
        }

        _logger.LogDebug("Saved {Count} room states", _stateCache.Count);
    }

    /// <summary>
    /// Loads all state from repository.
    /// </summary>
    public void LoadAllState(Dungeon dungeon)
    {
        _stateCache.Clear();

        var states = _repository.GetAllRoomStates(dungeon.Id);
        foreach (var state in states)
        {
            _stateCache[state.RoomId] = state;
        }

        _logger.LogDebug("Loaded {Count} room states", states.Count);
    }

    private PersistenceRules GetPersistenceRules()
    {
        return _config.GetPersistenceRules() ?? PersistenceRules.Default;
    }

    private void SaveState(RoomState state)
    {
        _repository.SaveRoomState(state);
    }
}
```

### PersistenceRules Configuration

```json
{
  "persistenceRules": {
    "persistCleared": true,
    "persistPuzzles": true,
    "persistBarriers": true,
    "persistContainers": true,
    "persistTraps": true,
    "persistItems": true,
    "maxHistoryPerRoom": 50,
    "clearedStateDescription": "shows signs of a recent battle",
    "roomTypeOverrides": {
      "Boss": {
        "persistCleared": true,
        "respawnEnabled": false
      },
      "Safe": {
        "persistCleared": false
      },
      "Treasure": {
        "persistContainers": true,
        "respawnEnabled": false
      }
    }
  }
}
```

### Acceptance Criteria

- [ ] RoomState entity tracks all persistent state types
- [ ] StateChange records change history
- [ ] RoomStateService manages state lifecycle
- [ ] Persistence rules load from configuration
- [ ] Cleared rooms show appropriate descriptions
- [ ] Puzzles remain solved across sessions
- [ ] Barriers remain destroyed
- [ ] Containers remain opened
- [ ] Save/load integrates state correctly
- [ ] ~25 unit tests pass

---

## v0.1.4b: Monster Repopulation

### Overview

Implement configurable monster respawn mechanics. Rooms can repopulate based on timers and spawner rooms. Destroying all spawners in an area permanently clears it, giving players meaningful strategic choices.

### Scope

**In Scope:**
- `SpawnerRoom` entity for monster source points
- `RespawnTimer` value object for timing
- `RepopulationRules` configuration
- `RepopulationService` for respawn management
- Per-room-type respawn timers
- Spawner destruction mechanics
- Spawner-based repopulation logic
- Permanent clear on spawner destruction

**Out of Scope:**
- Faction control (v0.1.4c)
- Evolution events (v0.1.4d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `SpawnerRoom` |
| Value Objects | 2 | `RespawnTimer`, `RepopulationRules` |
| Services | 1 | `RepopulationService` |
| Configuration | 1 | `repopulation-rules.json` |
| Room Updates | 1 | Spawner reference properties |
| Unit Tests | ~28 | Respawn, spawner tests |

### SpawnerRoom Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a monster spawner that repopulates nearby rooms.
/// </summary>
public class SpawnerRoom : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the room containing this spawner.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the spawner type (e.g., "nest", "portal", "summoning-circle").
    /// </summary>
    public string SpawnerType { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the name of this spawner.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description shown to players.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets whether this spawner is active.
    /// </summary>
    public bool IsActive { get; private set; } = true;

    /// <summary>
    /// Gets whether this spawner has been destroyed.
    /// </summary>
    public bool IsDestroyed { get; private set; }

    /// <summary>
    /// Gets the monster IDs this spawner can produce.
    /// </summary>
    public IReadOnlyList<string> SpawnableMonsters { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the tier range for spawned monsters.
    /// </summary>
    public (string Min, string Max) TierRange { get; private set; }

    /// <summary>
    /// Gets the maximum number of monsters from one spawn event.
    /// </summary>
    public int MaxSpawnCount { get; private set; } = 3;

    /// <summary>
    /// Gets room IDs this spawner can repopulate.
    /// </summary>
    public IReadOnlyList<Guid> RepopulationTargets { get; private set; } = Array.Empty<Guid>();

    /// <summary>
    /// Gets the spawn radius (rooms away from spawner).
    /// </summary>
    public int SpawnRadius { get; private set; } = 2;

    /// <summary>
    /// Gets the respawn timer configuration.
    /// </summary>
    public RespawnTimer Timer { get; private set; } = default;

    /// <summary>
    /// Gets when this spawner last triggered.
    /// </summary>
    public DateTime? LastSpawnTime { get; private set; }

    /// <summary>
    /// Gets HP for destructible spawners (null = indestructible).
    /// </summary>
    public int? Health { get; private set; }

    /// <summary>
    /// Gets current HP.
    /// </summary>
    public int CurrentHealth { get; private set; }

    private SpawnerRoom() { /* EF Core */ }

    /// <summary>
    /// Creates a new spawner room.
    /// </summary>
    public static SpawnerRoom Create(
        Guid roomId,
        string spawnerType,
        string name,
        IEnumerable<string> spawnableMonsters,
        RespawnTimer timer,
        int spawnRadius = 2,
        int? health = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(spawnerType);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new SpawnerRoom
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            SpawnerType = spawnerType,
            Name = name,
            SpawnableMonsters = spawnableMonsters.ToList(),
            Timer = timer,
            SpawnRadius = spawnRadius,
            Health = health,
            CurrentHealth = health ?? 0,
            IsActive = true,
            IsDestroyed = false
        };
    }

    /// <summary>
    /// Damages the spawner.
    /// </summary>
    public bool TakeDamage(int damage)
    {
        if (!Health.HasValue || IsDestroyed) return false;

        CurrentHealth = Math.Max(0, CurrentHealth - damage);

        if (CurrentHealth <= 0)
        {
            Destroy();
            return true;
        }

        return false;
    }

    /// <summary>
    /// Destroys the spawner permanently.
    /// </summary>
    public void Destroy()
    {
        IsDestroyed = true;
        IsActive = false;
    }

    /// <summary>
    /// Deactivates the spawner temporarily.
    /// </summary>
    public void Deactivate()
    {
        IsActive = false;
    }

    /// <summary>
    /// Reactivates the spawner.
    /// </summary>
    public void Activate()
    {
        if (!IsDestroyed)
            IsActive = true;
    }

    /// <summary>
    /// Records a spawn event.
    /// </summary>
    public void RecordSpawn()
    {
        LastSpawnTime = DateTime.UtcNow;
    }

    /// <summary>
    /// Checks if enough time has passed to spawn again.
    /// </summary>
    public bool CanSpawn(DateTime currentTime)
    {
        if (!IsActive || IsDestroyed) return false;

        if (!LastSpawnTime.HasValue) return true;

        var elapsed = currentTime - LastSpawnTime.Value;
        return elapsed >= Timer.Duration;
    }
}
```

### RespawnTimer Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configures respawn timing for spawners.
/// </summary>
public readonly record struct RespawnTimer
{
    /// <summary>
    /// Gets the base respawn duration.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Gets random variance (+/- this amount).
    /// </summary>
    public TimeSpan Variance { get; init; }

    /// <summary>
    /// Gets whether respawn is triggered by player leaving area.
    /// </summary>
    public bool TriggerOnLeave { get; init; }

    /// <summary>
    /// Gets the minimum distance player must travel before respawn.
    /// </summary>
    public int MinPlayerDistance { get; init; }

    /// <summary>
    /// Gets whether to pause timer while player is nearby.
    /// </summary>
    public bool PauseWhenNear { get; init; }

    /// <summary>
    /// Creates a standard respawn timer.
    /// </summary>
    public static RespawnTimer Standard(int minutes) => new()
    {
        Duration = TimeSpan.FromMinutes(minutes),
        Variance = TimeSpan.FromMinutes(minutes / 4),
        TriggerOnLeave = false,
        MinPlayerDistance = 3,
        PauseWhenNear = true
    };

    /// <summary>
    /// Creates a fast respawn timer.
    /// </summary>
    public static RespawnTimer Fast => new()
    {
        Duration = TimeSpan.FromMinutes(5),
        Variance = TimeSpan.FromMinutes(2),
        TriggerOnLeave = true,
        MinPlayerDistance = 2,
        PauseWhenNear = true
    };

    /// <summary>
    /// Creates a slow respawn timer.
    /// </summary>
    public static RespawnTimer Slow => new()
    {
        Duration = TimeSpan.FromMinutes(30),
        Variance = TimeSpan.FromMinutes(10),
        TriggerOnLeave = false,
        MinPlayerDistance = 5,
        PauseWhenNear = false
    };

    /// <summary>
    /// Calculates actual respawn time with variance.
    /// </summary>
    public TimeSpan GetActualDuration(Random random)
    {
        var varianceSeconds = (int)Variance.TotalSeconds;
        var offset = random.Next(-varianceSeconds, varianceSeconds + 1);
        return Duration + TimeSpan.FromSeconds(offset);
    }
}
```

### RepopulationService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing monster repopulation.
/// </summary>
public class RepopulationService : IRepopulationService
{
    private readonly IRoomStateService _stateService;
    private readonly IMonsterService _monsterService;
    private readonly IConfigurationProvider _config;
    private readonly SeededRandomService _random;
    private readonly ILogger<RepopulationService> _logger;

    private readonly Dictionary<Guid, SpawnerRoom> _spawners = new();

    /// <summary>
    /// Registers a spawner room.
    /// </summary>
    public void RegisterSpawner(SpawnerRoom spawner)
    {
        _spawners[spawner.Id] = spawner;
        _logger.LogDebug("Registered spawner {SpawnerId} in room {RoomId}",
            spawner.Id, spawner.RoomId);
    }

    /// <summary>
    /// Gets all spawners for a room.
    /// </summary>
    public IReadOnlyList<SpawnerRoom> GetSpawnersForRoom(Guid roomId)
    {
        return _spawners.Values
            .Where(s => s.RoomId == roomId)
            .ToList();
    }

    /// <summary>
    /// Gets active spawners affecting a room.
    /// </summary>
    public IReadOnlyList<SpawnerRoom> GetActiveSpawnersAffecting(Room room)
    {
        return _spawners.Values
            .Where(s => s.IsActive && !s.IsDestroyed)
            .Where(s => s.RepopulationTargets.Contains(room.Id) ||
                       IsWithinRadius(s, room))
            .ToList();
    }

    /// <summary>
    /// Processes repopulation for all rooms.
    /// </summary>
    public RepopulationResult ProcessRepopulation(
        Dungeon dungeon,
        Position3D playerPosition,
        DateTime currentTime)
    {
        var result = new RepopulationResult();
        var rules = GetRepopulationRules();

        foreach (var spawner in _spawners.Values.Where(s => s.IsActive))
        {
            if (!spawner.CanSpawn(currentTime))
                continue;

            // Check player distance
            var spawnerRoom = dungeon.GetRoom(spawner.RoomId);
            if (spawnerRoom == null) continue;

            var distance = CalculateDistance(spawnerRoom.Position3D, playerPosition);
            if (distance < spawner.Timer.MinPlayerDistance)
            {
                if (spawner.Timer.PauseWhenNear)
                    continue;
            }

            // Get rooms to repopulate
            var targets = GetRepopulationTargets(dungeon, spawner);
            foreach (var target in targets)
            {
                var state = _stateService.GetOrCreateState(target.Id);
                if (!state.IsCleared) continue;

                // Repopulate the room
                var monsters = SpawnMonsters(spawner, target);
                if (monsters.Any())
                {
                    state.MarkRepopulated();
                    result.RepopulatedRooms.Add(target.Id);
                    result.MonstersSpawned += monsters.Count;

                    _logger.LogInformation(
                        "Repopulated room {RoomId} with {Count} monsters from spawner {SpawnerId}",
                        target.Id, monsters.Count, spawner.Id);
                }
            }

            spawner.RecordSpawn();
        }

        return result;
    }

    /// <summary>
    /// Destroys a spawner.
    /// </summary>
    public SpawnerDestroyResult DestroySpawner(SpawnerRoom spawner, Dungeon dungeon)
    {
        spawner.Destroy();

        // Check if all spawners for this area are destroyed
        var areaSpawners = GetSpawnersForArea(spawner, dungeon);
        var allDestroyed = areaSpawners.All(s => s.IsDestroyed);

        var result = new SpawnerDestroyResult
        {
            SpawnerId = spawner.Id,
            AllAreaSpawnersDestroyed = allDestroyed,
            AffectedRooms = spawner.RepopulationTargets.ToList()
        };

        if (allDestroyed)
        {
            _logger.LogInformation(
                "All spawners destroyed in area - rooms permanently cleared");

            // Mark all affected rooms as permanently cleared
            foreach (var roomId in spawner.RepopulationTargets)
            {
                // Set custom state to indicate permanent clear
                var state = _stateService.GetOrCreateState(roomId);
                // Custom state tracking handled by RoomState
            }
        }

        return result;
    }

    /// <summary>
    /// Checks if an area can respawn.
    /// </summary>
    public bool CanAreaRespawn(Room room)
    {
        var spawners = GetActiveSpawnersAffecting(room);
        return spawners.Any();
    }

    private IReadOnlyList<Room> GetRepopulationTargets(Dungeon dungeon, SpawnerRoom spawner)
    {
        var targets = new List<Room>();

        // Explicit targets
        foreach (var roomId in spawner.RepopulationTargets)
        {
            var room = dungeon.GetRoom(roomId);
            if (room != null) targets.Add(room);
        }

        // Radius-based targets
        var spawnerRoom = dungeon.GetRoom(spawner.RoomId);
        if (spawnerRoom != null)
        {
            var nearbyRooms = dungeon.GetRoomsWithinRadius(
                spawnerRoom.Position3D,
                spawner.SpawnRadius);
            targets.AddRange(nearbyRooms);
        }

        return targets.Distinct().ToList();
    }

    private List<Monster> SpawnMonsters(SpawnerRoom spawner, Room room)
    {
        var count = _random.NextForPosition(
            room.Position3D,
            1,
            spawner.MaxSpawnCount + 1,
            "respawn_count");

        var monsters = new List<Monster>();

        for (int i = 0; i < count; i++)
        {
            var monsterId = spawner.SpawnableMonsters[
                _random.NextForPosition(room.Position3D, 0,
                    spawner.SpawnableMonsters.Count, $"respawn_monster_{i}")];

            var monster = _monsterService.CreateMonster(monsterId);
            if (monster != null)
            {
                room.AddMonster(monster);
                monsters.Add(monster);
            }
        }

        return monsters;
    }

    private bool IsWithinRadius(SpawnerRoom spawner, Room room)
    {
        // Calculate if room is within spawner's radius
        // Implementation depends on dungeon topology
        return false; // Simplified
    }

    private int CalculateDistance(Position3D a, Position3D b)
    {
        return Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y) + Math.Abs(a.Z - b.Z);
    }

    private IReadOnlyList<SpawnerRoom> GetSpawnersForArea(SpawnerRoom spawner, Dungeon dungeon)
    {
        // Get all spawners that share repopulation targets
        return _spawners.Values
            .Where(s => s.RepopulationTargets.Intersect(spawner.RepopulationTargets).Any())
            .ToList();
    }

    private RepopulationRules GetRepopulationRules()
    {
        return _config.GetRepopulationRules() ?? RepopulationRules.Default;
    }
}

/// <summary>
/// Result of repopulation processing.
/// </summary>
public class RepopulationResult
{
    public List<Guid> RepopulatedRooms { get; } = new();
    public int MonstersSpawned { get; set; }
}

/// <summary>
/// Result of destroying a spawner.
/// </summary>
public class SpawnerDestroyResult
{
    public Guid SpawnerId { get; init; }
    public bool AllAreaSpawnersDestroyed { get; init; }
    public List<Guid> AffectedRooms { get; init; } = new();
}
```

### Repopulation Rules Configuration

```json
{
  "repopulationRules": {
    "enabled": true,
    "globalTimerMultiplier": 1.0,
    "pauseWhilePlayerInDungeon": false,
    "defaultTimer": {
      "durationMinutes": 15,
      "varianceMinutes": 5,
      "triggerOnLeave": false,
      "minPlayerDistance": 3,
      "pauseWhenNear": true
    },
    "roomTypeTimers": {
      "Standard": {
        "durationMinutes": 10,
        "varianceMinutes": 3
      },
      "Treasure": {
        "enabled": false
      },
      "Boss": {
        "enabled": false
      },
      "Trap": {
        "durationMinutes": 5,
        "varianceMinutes": 2
      }
    },
    "spawnerTypes": {
      "nest": {
        "maxSpawnCount": 4,
        "spawnRadius": 2,
        "destructible": true,
        "baseHealth": 50
      },
      "portal": {
        "maxSpawnCount": 2,
        "spawnRadius": 3,
        "destructible": true,
        "baseHealth": 30
      },
      "summoning-circle": {
        "maxSpawnCount": 3,
        "spawnRadius": 1,
        "destructible": true,
        "baseHealth": 20
      }
    }
  }
}
```

### Acceptance Criteria

- [ ] SpawnerRoom entity tracks spawner state
- [ ] RespawnTimer configures timing
- [ ] RepopulationService manages respawns
- [ ] Repopulation rules load from configuration
- [ ] Rooms respawn after timer expires
- [ ] Player proximity affects respawn
- [ ] Spawners can be destroyed
- [ ] All spawners destroyed = permanent clear
- [ ] Per-room-type timers work correctly
- [ ] ~28 unit tests pass

---

## v0.1.4c: Faction Territory Control

### Overview

Implement monster faction system with territory control. Factions claim dungeon zones, expand based on player actions, and conflict with each other. This creates a dynamic political landscape within the dungeon.

### Scope

**In Scope:**
- `FactionDefinition` entity for monster groups
- `TerritoryControl` value object for zone ownership
- `FactionRelationship` enum for inter-faction relations
- `FactionService` for faction management
- Territory expansion logic
- Cross-faction conflict mechanics
- Faction-based spawning
- Room faction assignment

**Out of Scope:**
- Evolution events (v0.1.4d)
- Environmental storytelling (v0.1.4d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `FactionDefinition` |
| Value Objects | 2 | `TerritoryControl`, `FactionStanding` |
| Enums | 1 | `FactionRelationship` |
| Services | 1 | `FactionService` |
| Configuration | 1 | `factions.json` |
| Room Updates | 1 | `ControllingFaction` property |
| Unit Tests | ~27 | Faction, territory tests |

### FactionDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a monster faction with territory and relationships.
/// </summary>
public class FactionDefinition
{
    /// <summary>
    /// Gets the unique identifier (e.g., "undead-legion").
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the faction name.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the faction description.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets monster IDs that belong to this faction.
    /// </summary>
    public IReadOnlyList<string> Members { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the faction's leader monster ID (if any).
    /// </summary>
    public string? LeaderId { get; init; }

    /// <summary>
    /// Gets relationships with other factions.
    /// </summary>
    public IReadOnlyDictionary<string, FactionRelationship> Relationships { get; init; }
        = new Dictionary<string, FactionRelationship>();

    /// <summary>
    /// Gets biomes this faction prefers.
    /// </summary>
    public IReadOnlyList<string> PreferredBiomes { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the expansion aggression level (0.0-1.0).
    /// </summary>
    public float ExpansionAggression { get; init; } = 0.5f;

    /// <summary>
    /// Gets the defensive strength multiplier.
    /// </summary>
    public float DefensiveStrength { get; init; } = 1.0f;

    /// <summary>
    /// Gets territory markers used by this faction.
    /// </summary>
    public IReadOnlyList<string> TerritoryMarkers { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the faction color for UI display.
    /// </summary>
    public string Color { get; init; } = "gray";

    /// <summary>
    /// Gets the faction icon/symbol.
    /// </summary>
    public string Icon { get; init; } = string.Empty;

    /// <summary>
    /// Gets tags for filtering.
    /// </summary>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();
}

/// <summary>
/// Relationship types between factions.
/// </summary>
public enum FactionRelationship
{
    /// <summary>No special relationship.</summary>
    Neutral,

    /// <summary>Will cooperate against common enemies.</summary>
    Allied,

    /// <summary>Actively hostile, will attack on sight.</summary>
    Hostile,

    /// <summary>Compete for territory but don't actively fight.</summary>
    Rival,

    /// <summary>Subservient to another faction.</summary>
    Vassal,

    /// <summary>Controls another faction.</summary>
    Overlord
}
```

### TerritoryControl Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks faction control over a dungeon zone.
/// </summary>
public readonly record struct TerritoryControl
{
    /// <summary>
    /// Gets the controlling faction ID.
    /// </summary>
    public string FactionId { get; init; }

    /// <summary>
    /// Gets the control strength (0.0-1.0).
    /// </summary>
    public float ControlStrength { get; init; }

    /// <summary>
    /// Gets when control was established.
    /// </summary>
    public DateTime EstablishedAt { get; init; }

    /// <summary>
    /// Gets the previous controlling faction (if any).
    /// </summary>
    public string? PreviousFactionId { get; init; }

    /// <summary>
    /// Gets whether this is contested territory.
    /// </summary>
    public bool IsContested { get; init; }

    /// <summary>
    /// Gets contesting faction IDs.
    /// </summary>
    public IReadOnlyList<string> ContestingFactions { get; init; }

    /// <summary>
    /// Creates uncontrolled territory.
    /// </summary>
    public static TerritoryControl Uncontrolled => new()
    {
        FactionId = string.Empty,
        ControlStrength = 0f,
        IsContested = false,
        ContestingFactions = Array.Empty<string>()
    };

    /// <summary>
    /// Creates controlled territory.
    /// </summary>
    public static TerritoryControl Controlled(
        string factionId,
        float strength = 1.0f) => new()
    {
        FactionId = factionId,
        ControlStrength = strength,
        EstablishedAt = DateTime.UtcNow,
        IsContested = false,
        ContestingFactions = Array.Empty<string>()
    };

    /// <summary>
    /// Creates contested territory.
    /// </summary>
    public TerritoryControl Contest(string contestingFactionId)
    {
        var contesting = ContestingFactions.ToList();
        if (!contesting.Contains(contestingFactionId))
            contesting.Add(contestingFactionId);

        return this with
        {
            IsContested = true,
            ContestingFactions = contesting
        };
    }

    /// <summary>
    /// Transfers control to a new faction.
    /// </summary>
    public TerritoryControl TransferTo(string newFactionId)
    {
        return new TerritoryControl
        {
            FactionId = newFactionId,
            ControlStrength = 0.5f, // Start at half strength
            EstablishedAt = DateTime.UtcNow,
            PreviousFactionId = FactionId,
            IsContested = false,
            ContestingFactions = Array.Empty<string>()
        };
    }

    /// <summary>
    /// Strengthens control.
    /// </summary>
    public TerritoryControl Strengthen(float amount)
    {
        return this with
        {
            ControlStrength = Math.Min(1.0f, ControlStrength + amount)
        };
    }

    /// <summary>
    /// Weakens control.
    /// </summary>
    public TerritoryControl Weaken(float amount)
    {
        return this with
        {
            ControlStrength = Math.Max(0f, ControlStrength - amount)
        };
    }
}
```

### FactionService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing faction territories and relationships.
/// </summary>
public class FactionService : IFactionService
{
    private readonly IConfigurationProvider _config;
    private readonly IRoomStateService _stateService;
    private readonly ILogger<FactionService> _logger;

    private readonly Dictionary<Guid, TerritoryControl> _roomControl = new();

    /// <summary>
    /// Gets a faction by ID.
    /// </summary>
    public FactionDefinition? GetFaction(string factionId)
    {
        return _config.GetFactionDefinitions()
            .FirstOrDefault(f => f.Id == factionId);
    }

    /// <summary>
    /// Gets all factions.
    /// </summary>
    public IReadOnlyList<FactionDefinition> GetAllFactions()
    {
        return _config.GetFactionDefinitions();
    }

    /// <summary>
    /// Gets the faction controlling a room.
    /// </summary>
    public TerritoryControl GetRoomControl(Guid roomId)
    {
        return _roomControl.GetValueOrDefault(roomId, TerritoryControl.Uncontrolled);
    }

    /// <summary>
    /// Sets faction control of a room.
    /// </summary>
    public void SetRoomControl(Guid roomId, TerritoryControl control)
    {
        var previous = GetRoomControl(roomId);

        _roomControl[roomId] = control;

        if (previous.FactionId != control.FactionId)
        {
            _logger.LogInformation(
                "Room {RoomId} control changed: {Old} -> {New}",
                roomId,
                previous.FactionId,
                control.FactionId);
        }
    }

    /// <summary>
    /// Gets the relationship between two factions.
    /// </summary>
    public FactionRelationship GetRelationship(string faction1Id, string faction2Id)
    {
        var faction1 = GetFaction(faction1Id);
        if (faction1 == null) return FactionRelationship.Neutral;

        return faction1.Relationships.GetValueOrDefault(faction2Id, FactionRelationship.Neutral);
    }

    /// <summary>
    /// Gets all rooms controlled by a faction.
    /// </summary>
    public IReadOnlyList<Guid> GetFactionTerritory(string factionId)
    {
        return _roomControl
            .Where(kv => kv.Value.FactionId == factionId)
            .Select(kv => kv.Key)
            .ToList();
    }

    /// <summary>
    /// Processes faction expansion attempts.
    /// </summary>
    public FactionExpansionResult ProcessExpansion(
        Dungeon dungeon,
        DateTime currentTime)
    {
        var result = new FactionExpansionResult();

        foreach (var faction in GetAllFactions())
        {
            var territory = GetFactionTerritory(faction.Id);
            var expansionTargets = GetExpansionTargets(dungeon, faction, territory);

            foreach (var target in expansionTargets)
            {
                var currentControl = GetRoomControl(target.Id);

                if (string.IsNullOrEmpty(currentControl.FactionId))
                {
                    // Claim uncontrolled territory
                    if (ShouldExpand(faction, target))
                    {
                        SetRoomControl(target.Id, TerritoryControl.Controlled(faction.Id, 0.3f));
                        result.ExpansionsMade.Add((faction.Id, target.Id));
                    }
                }
                else if (currentControl.FactionId != faction.Id)
                {
                    // Contest enemy territory
                    var relationship = GetRelationship(faction.Id, currentControl.FactionId);
                    if (relationship == FactionRelationship.Hostile ||
                        relationship == FactionRelationship.Rival)
                    {
                        var contested = currentControl.Contest(faction.Id);
                        SetRoomControl(target.Id, contested);
                        result.ContestationsStarted.Add((faction.Id, target.Id));
                    }
                }
            }
        }

        // Process contested territories
        ProcessContestedTerritories(dungeon, result);

        return result;
    }

    /// <summary>
    /// Handles player clearing a room - affects faction control.
    /// </summary>
    public void OnRoomCleared(Room room)
    {
        var control = GetRoomControl(room.Id);

        if (!string.IsNullOrEmpty(control.FactionId))
        {
            // Weaken faction control
            var weakened = control.Weaken(0.3f);

            if (weakened.ControlStrength <= 0)
            {
                // Territory lost
                SetRoomControl(room.Id, TerritoryControl.Uncontrolled);

                _logger.LogInformation(
                    "Faction {Faction} lost control of room {RoomId}",
                    control.FactionId, room.Id);
            }
            else
            {
                SetRoomControl(room.Id, weakened);
            }
        }
    }

    /// <summary>
    /// Gets monsters appropriate for faction territory.
    /// </summary>
    public IReadOnlyList<string> GetFactionMonstersForRoom(Room room)
    {
        var control = GetRoomControl(room.Id);

        if (string.IsNullOrEmpty(control.FactionId))
            return Array.Empty<string>();

        var faction = GetFaction(control.FactionId);
        return faction?.Members ?? Array.Empty<string>();
    }

    /// <summary>
    /// Gets territory markers for room decoration.
    /// </summary>
    public IReadOnlyList<string> GetTerritoryMarkers(Room room)
    {
        var control = GetRoomControl(room.Id);

        if (string.IsNullOrEmpty(control.FactionId))
            return Array.Empty<string>();

        var faction = GetFaction(control.FactionId);
        return faction?.TerritoryMarkers ?? Array.Empty<string>();
    }

    private IReadOnlyList<Room> GetExpansionTargets(
        Dungeon dungeon,
        FactionDefinition faction,
        IReadOnlyList<Guid> currentTerritory)
    {
        var targets = new List<Room>();

        foreach (var roomId in currentTerritory)
        {
            var room = dungeon.GetRoom(roomId);
            if (room == null) continue;

            // Get adjacent rooms
            var adjacent = dungeon.GetAdjacentRooms(room);
            targets.AddRange(adjacent.Where(r => !currentTerritory.Contains(r.Id)));
        }

        return targets.Distinct().ToList();
    }

    private bool ShouldExpand(FactionDefinition faction, Room target)
    {
        // Check if biome is preferred
        if (faction.PreferredBiomes.Any() &&
            !faction.PreferredBiomes.Contains(target.BiomeId))
        {
            return Random.Shared.NextDouble() < faction.ExpansionAggression * 0.5f;
        }

        return Random.Shared.NextDouble() < faction.ExpansionAggression;
    }

    private void ProcessContestedTerritories(Dungeon dungeon, FactionExpansionResult result)
    {
        var contested = _roomControl
            .Where(kv => kv.Value.IsContested)
            .ToList();

        foreach (var (roomId, control) in contested)
        {
            // Simulate conflict
            var defender = GetFaction(control.FactionId);
            var attackers = control.ContestingFactions
                .Select(GetFaction)
                .Where(f => f != null)
                .ToList();

            if (!attackers.Any()) continue;

            var defenderStrength = (defender?.DefensiveStrength ?? 1.0f) * control.ControlStrength;
            var attackerStrength = attackers.Sum(a => a!.ExpansionAggression) / attackers.Count;

            if (attackerStrength > defenderStrength)
            {
                // Attackers win - strongest attacker takes control
                var winner = attackers.OrderByDescending(a => a!.ExpansionAggression).First();
                var newControl = control.TransferTo(winner!.Id);
                SetRoomControl(roomId, newControl);
                result.ControlChanges.Add((control.FactionId, winner.Id, roomId));
            }
            else
            {
                // Defender holds - clear contestation
                var held = control with
                {
                    IsContested = false,
                    ContestingFactions = Array.Empty<string>()
                };
                SetRoomControl(roomId, held.Strengthen(0.1f));
            }
        }
    }
}

/// <summary>
/// Result of faction expansion processing.
/// </summary>
public class FactionExpansionResult
{
    public List<(string FactionId, Guid RoomId)> ExpansionsMade { get; } = new();
    public List<(string FactionId, Guid RoomId)> ContestationsStarted { get; } = new();
    public List<(string OldFaction, string NewFaction, Guid RoomId)> ControlChanges { get; } = new();
}
```

### Faction Configuration Example

```json
{
  "factions": [
    {
      "id": "undead-legion",
      "name": "The Undead Legion",
      "description": "Skeletal warriors and necromantic abominations bound to an ancient lich.",
      "members": ["skeleton-warrior", "skeleton-archer", "zombie", "ghost", "wight", "lich"],
      "leaderId": "lich",
      "relationships": {
        "goblin-tribes": "Hostile",
        "deep-dwellers": "Neutral",
        "fire-cult": "Rival"
      },
      "preferredBiomes": ["catacombs", "ancient-ruins"],
      "expansionAggression": 0.6,
      "defensiveStrength": 1.2,
      "territoryMarkers": ["bone-pile", "necromantic-symbol", "cursed-altar"],
      "color": "purple",
      "icon": "skull",
      "tags": ["undead", "evil", "organized"]
    },
    {
      "id": "goblin-tribes",
      "name": "The Goblin Tribes",
      "description": "Numerous but disorganized goblinoid clans fighting for scraps.",
      "members": ["goblin-warrior", "goblin-archer", "goblin-shaman", "hobgoblin", "bugbear"],
      "leaderId": null,
      "relationships": {
        "undead-legion": "Hostile",
        "deep-dwellers": "Rival",
        "fire-cult": "Neutral"
      },
      "preferredBiomes": ["mines", "sewers"],
      "expansionAggression": 0.8,
      "defensiveStrength": 0.7,
      "territoryMarkers": ["crude-totem", "garbage-pile", "graffiti"],
      "color": "green",
      "icon": "axe",
      "tags": ["goblinoid", "chaotic", "numerous"]
    },
    {
      "id": "deep-dwellers",
      "name": "Deep Dwellers",
      "description": "Ancient creatures from the depths, alien and unknowable.",
      "members": ["cave-fisher", "roper", "umber-hulk", "mind-flayer"],
      "leaderId": "mind-flayer",
      "relationships": {
        "undead-legion": "Neutral",
        "goblin-tribes": "Rival",
        "fire-cult": "Hostile"
      },
      "preferredBiomes": ["mines", "frozen-depths"],
      "expansionAggression": 0.3,
      "defensiveStrength": 1.5,
      "territoryMarkers": ["slime-trail", "strange-symbols", "cocoon"],
      "color": "blue",
      "icon": "eye",
      "tags": ["aberration", "mysterious", "powerful"]
    },
    {
      "id": "fire-cult",
      "name": "Cult of the Eternal Flame",
      "description": "Fire-worshipping fanatics and their elemental servants.",
      "members": ["fire-elemental", "magma-slime", "salamander", "fire-cultist", "flame-priest"],
      "leaderId": "flame-priest",
      "relationships": {
        "undead-legion": "Rival",
        "goblin-tribes": "Neutral",
        "deep-dwellers": "Hostile"
      },
      "preferredBiomes": ["volcanic-caverns"],
      "expansionAggression": 0.7,
      "defensiveStrength": 1.0,
      "territoryMarkers": ["brazier", "flame-symbol", "burnt-sacrifice"],
      "color": "red",
      "icon": "flame",
      "tags": ["elemental", "cult", "fire"]
    }
  ]
}
```

### Room Faction Update

```csharp
// In Room.cs
/// <summary>
/// Gets the controlling faction ID.
/// </summary>
public string? ControllingFactionId { get; private set; }

/// <summary>
/// Sets the controlling faction.
/// </summary>
public void SetControllingFaction(string? factionId)
{
    ControllingFactionId = factionId;
}
```

### Acceptance Criteria

- [ ] FactionDefinition entity supports all faction properties
- [ ] TerritoryControl tracks zone ownership
- [ ] FactionRelationship defines inter-faction relations
- [ ] FactionService manages faction state
- [ ] Factions load from JSON configuration
- [ ] Territory expansion works correctly
- [ ] Faction conflict mechanics work
- [ ] Player actions affect faction control
- [ ] Room spawning respects faction territory
- [ ] ~27 unit tests pass

---

## v0.1.4d: Evolution & Storytelling

### Overview

Implement world evolution events and environmental storytelling. The dungeon changes over time through cave-ins, migrations, and seasonal effects. Procedural evidence of events creates environmental narrative.

### Scope

**In Scope:**
- `WorldEvent` entity for scheduled changes
- `EvolutionService` for processing events
- `EnvironmentalEvidence` entity for storytelling
- Time-based changes (fires burn out, bodies decay)
- Cave-in mechanics affecting paths
- Monster migration between zones
- Seasonal/time effects
- Battle site evidence

**Out of Scope:**
- Custom event creation UI (future version)
- Player-triggered events (future version)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 2 | `WorldEvent`, `EnvironmentalEvidence` |
| Value Objects | 1 | `EventEffect` |
| Enums | 1 | `EventType` |
| Services | 1 | `EvolutionService` |
| Configuration | 1 | `evolution-events.json` |
| Unit Tests | ~25 | Event, evidence tests |

### WorldEvent Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a scheduled world change event.
/// </summary>
public class WorldEvent : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the event type.
    /// </summary>
    public EventType Type { get; private set; }

    /// <summary>
    /// Gets the event name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the event description.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets when the event is scheduled.
    /// </summary>
    public DateTime ScheduledAt { get; private set; }

    /// <summary>
    /// Gets whether the event has occurred.
    /// </summary>
    public bool HasOccurred { get; private set; }

    /// <summary>
    /// Gets when the event occurred.
    /// </summary>
    public DateTime? OccurredAt { get; private set; }

    /// <summary>
    /// Gets affected room IDs.
    /// </summary>
    public IReadOnlyList<Guid> AffectedRooms { get; private set; } = Array.Empty<Guid>();

    /// <summary>
    /// Gets the event effects to apply.
    /// </summary>
    public IReadOnlyList<EventEffect> Effects { get; private set; } = Array.Empty<EventEffect>();

    /// <summary>
    /// Gets whether this event is repeating.
    /// </summary>
    public bool IsRepeating { get; private set; }

    /// <summary>
    /// Gets the repeat interval.
    /// </summary>
    public TimeSpan? RepeatInterval { get; private set; }

    /// <summary>
    /// Gets the triggering faction (if faction-caused).
    /// </summary>
    public string? TriggeringFactionId { get; private set; }

    /// <summary>
    /// Gets the probability of this event occurring (0.0-1.0).
    /// </summary>
    public float Probability { get; private set; } = 1.0f;

    private WorldEvent() { /* EF Core */ }

    /// <summary>
    /// Creates a new world event.
    /// </summary>
    public static WorldEvent Create(
        EventType type,
        string name,
        string description,
        DateTime scheduledAt,
        IEnumerable<Guid> affectedRooms,
        IEnumerable<EventEffect> effects,
        float probability = 1.0f)
    {
        return new WorldEvent
        {
            Id = Guid.NewGuid(),
            Type = type,
            Name = name,
            Description = description,
            ScheduledAt = scheduledAt,
            AffectedRooms = affectedRooms.ToList(),
            Effects = effects.ToList(),
            Probability = probability,
            HasOccurred = false
        };
    }

    /// <summary>
    /// Creates a cave-in event.
    /// </summary>
    public static WorldEvent CaveIn(
        IEnumerable<Guid> affectedRooms,
        DateTime scheduledAt)
    {
        return Create(
            EventType.CaveIn,
            "Cave-In",
            "A section of the dungeon collapses.",
            scheduledAt,
            affectedRooms,
            new[] { EventEffect.BlockExit(), EventEffect.AddDebris() });
    }

    /// <summary>
    /// Creates a migration event.
    /// </summary>
    public static WorldEvent Migration(
        string factionId,
        IEnumerable<Guid> fromRooms,
        IEnumerable<Guid> toRooms,
        DateTime scheduledAt)
    {
        var effects = new List<EventEffect>
        {
            EventEffect.ClearMonsters(),
            EventEffect.SpawnMonsters(factionId)
        };

        return new WorldEvent
        {
            Id = Guid.NewGuid(),
            Type = EventType.Migration,
            Name = "Monster Migration",
            Description = $"Monsters move to new territory.",
            ScheduledAt = scheduledAt,
            AffectedRooms = fromRooms.Concat(toRooms).ToList(),
            Effects = effects,
            TriggeringFactionId = factionId,
            HasOccurred = false,
            Probability = 1.0f
        };
    }

    /// <summary>
    /// Marks the event as occurred.
    /// </summary>
    public void MarkOccurred()
    {
        HasOccurred = true;
        OccurredAt = DateTime.UtcNow;

        if (IsRepeating && RepeatInterval.HasValue)
        {
            // Schedule next occurrence
            ScheduledAt = DateTime.UtcNow + RepeatInterval.Value;
            HasOccurred = false;
            OccurredAt = null;
        }
    }

    /// <summary>
    /// Checks if the event should trigger.
    /// </summary>
    public bool ShouldTrigger(DateTime currentTime)
    {
        if (HasOccurred && !IsRepeating) return false;
        if (currentTime < ScheduledAt) return false;

        return Random.Shared.NextDouble() < Probability;
    }
}

/// <summary>
/// Types of world events.
/// </summary>
public enum EventType
{
    /// <summary>Passage collapse.</summary>
    CaveIn,

    /// <summary>Monsters move to new area.</summary>
    Migration,

    /// <summary>Seasonal change effect.</summary>
    Seasonal,

    /// <summary>Fire spreads or burns out.</summary>
    FireChange,

    /// <summary>Water level changes.</summary>
    Flooding,

    /// <summary>Faction conflict erupts.</summary>
    FactionConflict,

    /// <summary>New passage discovered.</summary>
    NewPassage,

    /// <summary>Magical event.</summary>
    MagicalSurge,

    /// <summary>Environmental decay.</summary>
    Decay
}
```

### EventEffect Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines an effect applied by a world event.
/// </summary>
public readonly record struct EventEffect
{
    /// <summary>
    /// Gets the effect type.
    /// </summary>
    public EffectType Type { get; init; }

    /// <summary>
    /// Gets the effect parameters.
    /// </summary>
    public IReadOnlyDictionary<string, string> Parameters { get; init; }

    /// <summary>
    /// Creates a block exit effect.
    /// </summary>
    public static EventEffect BlockExit(Direction? direction = null) => new()
    {
        Type = EffectType.BlockExit,
        Parameters = direction.HasValue
            ? new Dictionary<string, string> { ["direction"] = direction.Value.ToString() }
            : new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates an add debris effect.
    /// </summary>
    public static EventEffect AddDebris() => new()
    {
        Type = EffectType.AddDebris,
        Parameters = new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates a clear monsters effect.
    /// </summary>
    public static EventEffect ClearMonsters() => new()
    {
        Type = EffectType.ClearMonsters,
        Parameters = new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates a spawn monsters effect.
    /// </summary>
    public static EventEffect SpawnMonsters(string factionId) => new()
    {
        Type = EffectType.SpawnMonsters,
        Parameters = new Dictionary<string, string> { ["factionId"] = factionId }
    };

    /// <summary>
    /// Creates an add evidence effect.
    /// </summary>
    public static EventEffect AddEvidence(string evidenceType) => new()
    {
        Type = EffectType.AddEvidence,
        Parameters = new Dictionary<string, string> { ["type"] = evidenceType }
    };

    /// <summary>
    /// Creates a change description effect.
    /// </summary>
    public static EventEffect ChangeDescription(string newDescription) => new()
    {
        Type = EffectType.ChangeDescription,
        Parameters = new Dictionary<string, string> { ["description"] = newDescription }
    };

    /// <summary>
    /// Creates a hazard effect.
    /// </summary>
    public static EventEffect AddHazard(string hazardId) => new()
    {
        Type = EffectType.AddHazard,
        Parameters = new Dictionary<string, string> { ["hazardId"] = hazardId }
    };
}

/// <summary>
/// Types of event effects.
/// </summary>
public enum EffectType
{
    BlockExit,
    UnblockExit,
    AddDebris,
    ClearDebris,
    ClearMonsters,
    SpawnMonsters,
    AddEvidence,
    RemoveEvidence,
    ChangeDescription,
    AddHazard,
    RemoveHazard,
    ChangeBiome,
    ChangeAge
}
```

### EnvironmentalEvidence Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents procedural evidence of events in a room.
/// </summary>
public class EnvironmentalEvidence : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the room containing this evidence.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the evidence type.
    /// </summary>
    public EvidenceType Type { get; private set; }

    /// <summary>
    /// Gets the description shown to players.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the detailed examination description.
    /// </summary>
    public string ExamineDescription { get; private set; } = string.Empty;

    /// <summary>
    /// Gets when this evidence was created.
    /// </summary>
    public DateTime CreatedAt { get; private set; }

    /// <summary>
    /// Gets the decay state (how old/faded).
    /// </summary>
    public float DecayState { get; private set; } = 1.0f;

    /// <summary>
    /// Gets how long before full decay.
    /// </summary>
    public TimeSpan? DecayDuration { get; private set; }

    /// <summary>
    /// Gets associated faction (if relevant).
    /// </summary>
    public string? FactionId { get; private set; }

    /// <summary>
    /// Gets lootable items in the evidence.
    /// </summary>
    public IReadOnlyList<string> LootableItems { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether loot has been collected.
    /// </summary>
    public bool LootCollected { get; private set; }

    private EnvironmentalEvidence() { /* EF Core */ }

    /// <summary>
    /// Creates battle site evidence.
    /// </summary>
    public static EnvironmentalEvidence BattleSite(
        Guid roomId,
        string? factionId = null,
        IEnumerable<string>? loot = null)
    {
        return new EnvironmentalEvidence
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            Type = EvidenceType.BattleSite,
            Description = "Signs of a recent battle mar this area.",
            ExamineDescription = "Broken weapons, scattered armor, and dark stains suggest a violent confrontation. " +
                                "Some equipment might still be salvageable.",
            CreatedAt = DateTime.UtcNow,
            DecayDuration = TimeSpan.FromHours(24),
            FactionId = factionId,
            LootableItems = loot?.ToList() ?? new List<string>()
        };
    }

    /// <summary>
    /// Creates corpse evidence.
    /// </summary>
    public static EnvironmentalEvidence Corpse(
        Guid roomId,
        string creatureType,
        string? factionId = null)
    {
        return new EnvironmentalEvidence
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            Type = EvidenceType.Corpse,
            Description = $"The remains of a {creatureType} lie here.",
            ExamineDescription = $"A fallen {creatureType}. The body shows signs of recent death.",
            CreatedAt = DateTime.UtcNow,
            DecayDuration = TimeSpan.FromHours(48),
            FactionId = factionId
        };
    }

    /// <summary>
    /// Creates burned out fire evidence.
    /// </summary>
    public static EnvironmentalEvidence BurnedOutFire(Guid roomId)
    {
        return new EnvironmentalEvidence
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            Type = EvidenceType.BurnedOutFire,
            Description = "A cold fire pit with scattered ashes.",
            ExamineDescription = "The embers are long dead. Someone camped here, but not recently.",
            CreatedAt = DateTime.UtcNow,
            DecayDuration = TimeSpan.FromHours(72)
        };
    }

    /// <summary>
    /// Updates decay based on time passed.
    /// </summary>
    public void UpdateDecay(DateTime currentTime)
    {
        if (!DecayDuration.HasValue) return;

        var elapsed = currentTime - CreatedAt;
        DecayState = Math.Max(0f, 1f - (float)(elapsed / DecayDuration.Value));
    }

    /// <summary>
    /// Gets description modified by decay.
    /// </summary>
    public string GetDecayedDescription()
    {
        if (DecayState > 0.7f) return Description;
        if (DecayState > 0.3f) return $"Faded {Description.ToLower()}";
        return $"Barely visible traces of {Description.ToLower()}";
    }

    /// <summary>
    /// Collects loot from this evidence.
    /// </summary>
    public IReadOnlyList<string> CollectLoot()
    {
        if (LootCollected) return Array.Empty<string>();

        LootCollected = true;
        return LootableItems;
    }
}

/// <summary>
/// Types of environmental evidence.
/// </summary>
public enum EvidenceType
{
    BattleSite,
    Corpse,
    BurnedOutFire,
    BloodTrail,
    DiscardedEquipment,
    CampSite,
    Tracks,
    GraffitiOrMarking,
    Collapse,
    FloodDamage
}
```

### EvolutionService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for processing world evolution and events.
/// </summary>
public class EvolutionService : IEvolutionService
{
    private readonly IRoomStateService _stateService;
    private readonly IFactionService _factionService;
    private readonly IConfigurationProvider _config;
    private readonly ILogger<EvolutionService> _logger;

    private readonly List<WorldEvent> _scheduledEvents = new();
    private readonly Dictionary<Guid, List<EnvironmentalEvidence>> _evidence = new();

    /// <summary>
    /// Schedules a world event.
    /// </summary>
    public void ScheduleEvent(WorldEvent worldEvent)
    {
        _scheduledEvents.Add(worldEvent);
        _logger.LogDebug("Scheduled event {EventId}: {EventName} at {Time}",
            worldEvent.Id, worldEvent.Name, worldEvent.ScheduledAt);
    }

    /// <summary>
    /// Processes all pending events.
    /// </summary>
    public EvolutionResult ProcessEvents(Dungeon dungeon, DateTime currentTime)
    {
        var result = new EvolutionResult();

        var triggeredEvents = _scheduledEvents
            .Where(e => e.ShouldTrigger(currentTime))
            .ToList();

        foreach (var worldEvent in triggeredEvents)
        {
            ProcessEvent(dungeon, worldEvent, result);
            worldEvent.MarkOccurred();

            if (!worldEvent.IsRepeating || !worldEvent.RepeatInterval.HasValue)
            {
                _scheduledEvents.Remove(worldEvent);
            }
        }

        // Process evidence decay
        ProcessEvidenceDecay(currentTime);

        // Check for faction-triggered events
        ProcessFactionEvents(dungeon, currentTime, result);

        return result;
    }

    /// <summary>
    /// Adds environmental evidence to a room.
    /// </summary>
    public void AddEvidence(EnvironmentalEvidence evidence)
    {
        if (!_evidence.ContainsKey(evidence.RoomId))
            _evidence[evidence.RoomId] = new List<EnvironmentalEvidence>();

        _evidence[evidence.RoomId].Add(evidence);
    }

    /// <summary>
    /// Gets evidence in a room.
    /// </summary>
    public IReadOnlyList<EnvironmentalEvidence> GetEvidenceInRoom(Guid roomId)
    {
        return _evidence.GetValueOrDefault(roomId)?.AsReadOnly()
               ?? Array.Empty<EnvironmentalEvidence>();
    }

    /// <summary>
    /// Records a battle for environmental storytelling.
    /// </summary>
    public void RecordBattle(Room room, string? factionId, IEnumerable<string>? loot)
    {
        var evidence = EnvironmentalEvidence.BattleSite(room.Id, factionId, loot);
        AddEvidence(evidence);

        _logger.LogDebug("Recorded battle evidence in room {RoomId}", room.Id);
    }

    /// <summary>
    /// Processes a cave-in event.
    /// </summary>
    public void TriggerCaveIn(Dungeon dungeon, IEnumerable<Guid> roomIds)
    {
        var scheduledAt = DateTime.UtcNow;
        var caveIn = WorldEvent.CaveIn(roomIds, scheduledAt);
        ScheduleEvent(caveIn);
    }

    /// <summary>
    /// Processes a migration event.
    /// </summary>
    public void TriggerMigration(
        string factionId,
        IEnumerable<Guid> fromRooms,
        IEnumerable<Guid> toRooms)
    {
        var migration = WorldEvent.Migration(
            factionId,
            fromRooms,
            toRooms,
            DateTime.UtcNow);
        ScheduleEvent(migration);
    }

    private void ProcessEvent(Dungeon dungeon, WorldEvent worldEvent, EvolutionResult result)
    {
        _logger.LogInformation("Processing event {EventId}: {EventName}",
            worldEvent.Id, worldEvent.Name);

        foreach (var roomId in worldEvent.AffectedRooms)
        {
            var room = dungeon.GetRoom(roomId);
            if (room == null) continue;

            foreach (var effect in worldEvent.Effects)
            {
                ApplyEffect(dungeon, room, effect);
            }

            result.AffectedRooms.Add(roomId);
        }

        result.ProcessedEvents.Add(worldEvent.Id);
    }

    private void ApplyEffect(Dungeon dungeon, Room room, EventEffect effect)
    {
        switch (effect.Type)
        {
            case EffectType.BlockExit:
                if (effect.Parameters.TryGetValue("direction", out var dirStr) &&
                    Enum.TryParse<Direction>(dirStr, out var direction))
                {
                    room.BlockExit(direction);
                }
                else
                {
                    // Block random exit
                    var exits = room.Exits.Where(e => !e.IsBlocked).ToList();
                    if (exits.Any())
                    {
                        var exit = exits[Random.Shared.Next(exits.Count)];
                        room.BlockExit(exit.Direction);
                    }
                }
                break;

            case EffectType.AddDebris:
                room.AddFeature(new RoomFeature
                {
                    FeatureId = "rubble",
                    Position = "scattered",
                    Quantity = 1
                });
                break;

            case EffectType.ClearMonsters:
                room.ClearMonsters();
                break;

            case EffectType.SpawnMonsters:
                if (effect.Parameters.TryGetValue("factionId", out var factionId))
                {
                    var monsters = _factionService.GetFactionMonstersForRoom(room);
                    // Spawn logic would go here
                }
                break;

            case EffectType.AddEvidence:
                if (effect.Parameters.TryGetValue("type", out var evidenceType))
                {
                    var evidence = CreateEvidenceFromType(room.Id, evidenceType);
                    if (evidence != null) AddEvidence(evidence);
                }
                break;

            case EffectType.ChangeAge:
                if (effect.Parameters.TryGetValue("age", out var ageStr) &&
                    Enum.TryParse<DungeonAge>(ageStr, out var age))
                {
                    room.SetAge(age);
                }
                break;
        }
    }

    private void ProcessEvidenceDecay(DateTime currentTime)
    {
        foreach (var roomEvidence in _evidence.Values)
        {
            foreach (var evidence in roomEvidence.ToList())
            {
                evidence.UpdateDecay(currentTime);

                if (evidence.DecayState <= 0)
                {
                    roomEvidence.Remove(evidence);
                }
            }
        }
    }

    private void ProcessFactionEvents(Dungeon dungeon, DateTime currentTime, EvolutionResult result)
    {
        // Check for faction conflict events
        var factionResult = _factionService.ProcessExpansion(dungeon, currentTime);

        foreach (var (oldFaction, newFaction, roomId) in factionResult.ControlChanges)
        {
            // Create battle evidence for faction changes
            var evidence = EnvironmentalEvidence.BattleSite(roomId, newFaction);
            AddEvidence(evidence);
            result.FactionChanges.Add(roomId);
        }
    }

    private EnvironmentalEvidence? CreateEvidenceFromType(Guid roomId, string type)
    {
        return type.ToLower() switch
        {
            "battle" => EnvironmentalEvidence.BattleSite(roomId),
            "fire" => EnvironmentalEvidence.BurnedOutFire(roomId),
            _ => null
        };
    }
}

/// <summary>
/// Result of evolution processing.
/// </summary>
public class EvolutionResult
{
    public List<Guid> ProcessedEvents { get; } = new();
    public List<Guid> AffectedRooms { get; } = new();
    public List<Guid> FactionChanges { get; } = new();
}
```

### Evolution Events Configuration

```json
{
  "evolutionEvents": {
    "caveInChance": 0.02,
    "migrationChance": 0.05,
    "evidenceDecayEnabled": true,
    "eventTypes": {
      "caveIn": {
        "enabled": true,
        "minDepth": 3,
        "affectedExitCount": [1, 2],
        "effects": ["BlockExit", "AddDebris"]
      },
      "migration": {
        "enabled": true,
        "intervalMinutes": 60,
        "factionBased": true
      },
      "fireChange": {
        "enabled": true,
        "burnDurationMinutes": 30,
        "spreadChance": 0.1
      },
      "decay": {
        "enabled": true,
        "intervalMinutes": 120,
        "ageProgression": ["Fresh", "Ancient", "Collapsed"]
      }
    },
    "evidenceTypes": {
      "battleSite": {
        "decayHours": 24,
        "lootable": true,
        "lootChance": 0.3
      },
      "corpse": {
        "decayHours": 48,
        "lootable": true,
        "lootChance": 0.5
      },
      "burnedOutFire": {
        "decayHours": 72,
        "lootable": false
      }
    }
  }
}
```

### Acceptance Criteria

- [ ] WorldEvent entity supports all event types
- [ ] EventEffect applies various effects
- [ ] EnvironmentalEvidence tracks procedural storytelling
- [ ] EvolutionService processes scheduled events
- [ ] Cave-in mechanics block passages
- [ ] Monster migration moves factions
- [ ] Evidence decays over time
- [ ] Battle sites show lootable remains
- [ ] Evolution configuration loads correctly
- [ ] ~25 unit tests pass

---

## Dependencies & Prerequisites

```
v0.1.3 (Advanced Procedural Architecture) - REQUIRED
    
     ArchitecturalStyle, RoomShape, StructuralFeature 
     LandmarkRoom, DungeonAge, CoherenceService                     
     Room shape/age/style properties                                
                                                                       
                                                                       
v0.1.4 (World Persistence & Evolution)
    
     v0.1.4a: Persistent World State 
           Dependencies: v0.1.3 (Room properties)                     
                         v0.0.9 (MonsterDefinition for tracking)      
                                                                      
     v0.1.4b: Monster Repopulation 
           Dependencies: v0.1.4a (RoomState, cleared tracking)        
                         v0.0.9 (MonsterDefinition, TierDefinition)   
                                                                      
     v0.1.4c: Faction Territory Control 
           Dependencies: v0.1.4a, v0.1.4b                             
                         v0.1.2 (BiomeDefinition for preferences)     
                                                                      
     v0.1.4d: Evolution & Storytelling 
            Dependencies: v0.1.4a, v0.1.4b, v0.1.4c
                         v0.1.3d (DungeonAge for decay)
```

**Note:** Phases are sequential - each depends on prior phases within v0.1.4.

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.1.4a | ~4 | ~3 | ~25 | High |
| v0.1.4b | ~4 | ~3 | ~28 | High |
| v0.1.4c | ~4 | ~3 | ~27 | High |
| v0.1.4d | ~5 | ~4 | ~25 | High |
| **Total** | **~17** | **~13** | **~105** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| State complexity causing save/load issues | High | Medium | Comprehensive testing, versioning |
| Repopulation feeling unfair | Medium | Medium | Clear visual indicators, tuning |
| Faction system overwhelming complexity | High | Medium | Start simple, add features iteratively |
| Performance with many events | Medium | Low | Event batching, priority queues |
| Evidence cluttering rooms | Low | Medium | Decay system, cleanup |

---

## Design Decisions

### Persistence System

| Decision | Value | Notes |
|----------|-------|-------|
| **State storage** | Per-room RoomState | Granular tracking |
| **History limit** | 50 changes | Memory management |
| **Persistence rules** | JSON configuration | Easy tuning |
| **Save integration** | Repository pattern | Consistent with existing |

### Repopulation System

| Decision | Value | Notes |
|----------|-------|-------|
| **Timer approach** | Per-spawner + global | Flexible control |
| **Spawner destruction** | Permanent clear | Meaningful choice |
| **Player proximity** | Pause when near | Fair gameplay |
| **Room type rules** | Configurable | Customizable experience |

### Faction System

| Decision | Value | Notes |
|----------|-------|-------|
| **Territory tracking** | Per-room control | Granular zones |
| **Relationships** | Enum-based | Simple, clear |
| **Expansion** | Aggression-based | Personality per faction |
| **Conflict resolution** | Strength comparison | Deterministic outcomes |

### Evolution System

| Decision | Value | Notes |
|----------|-------|-------|
| **Event scheduling** | Time-based | Predictable |
| **Evidence decay** | Linear decay | Simple, visible |
| **Effect types** | Enum-based | Extensible |
| **Storytelling** | Procedural evidence | Emergent narrative |

---

## Files Summary

### Files to Create (New)

| Phase | File | Purpose |
|-------|------|---------|
| 1a | `RoomState.cs` | State tracking entity |
| 1a | `StateChange.cs` | Change history value object |
| 1a | `RoomStateService.cs` | State management |
| 1a | `persistence-rules.json` | Persistence configuration |
| 1b | `SpawnerRoom.cs` | Spawner entity |
| 1b | `RespawnTimer.cs` | Timer value object |
| 1b | `RepopulationService.cs` | Respawn management |
| 1b | `repopulation-rules.json` | Repopulation configuration |
| 1c | `FactionDefinition.cs` | Faction entity |
| 1c | `TerritoryControl.cs` | Territory value object |
| 1c | `FactionService.cs` | Faction management |
| 1c | `factions.json` | Faction configuration |
| 1d | `WorldEvent.cs` | Event entity |
| 1d | `EventEffect.cs` | Effect value object |
| 1d | `EnvironmentalEvidence.cs` | Evidence entity |
| 1d | `EvolutionService.cs` | Event processing |
| 1d | `evolution-events.json` | Evolution configuration |

### Files to Modify

| Phase | File | Changes |
|-------|------|---------|
| 1a | `IGameRepository.cs` | State persistence methods |
| 1a | `Room.cs` | State reference |
| 1a | `GameSessionService.cs` | State integration |
| 1b | `Room.cs` | Spawner reference |
| 1b | `GameSessionService.cs` | Repopulation triggers |
| 1c | `Room.cs` | ControllingFactionId property |
| 1c | `ContentPlacementService.cs` | Faction-aware spawning |
| 1d | `Room.cs` | Evidence/event references |
| 1d | `DescriptorService.cs` | Evidence descriptions |
| 1d | `GameSessionService.cs` | Event processing |

---

## Final Metrics

| Metric | Before v0.1.4 | After v0.1.4 |
|--------|---------------|--------------|
| Room state tracking | None | Per-room RoomState |
| Respawn mechanics | None | Configurable spawners |
| Faction system | None | 4+ factions |
| Territory control | None | Per-room zones |
| World events | None | Scheduled evolution |
| Environmental evidence | None | Procedural storytelling |
| Unit tests (persistence) | 0 | ~105 |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.1.4a Design Spec** - Create persistence specification
3. **Implement v0.1.4a** - Build state tracking system
4. **v0.1.4b Design Spec** - Create repopulation specification
5. **Implement v0.1.4b** - Build respawn system
6. **v0.1.4c Design Spec** - Create faction specification
7. **Implement v0.1.4c** - Build faction system
8. **v0.1.4d Design Spec** - Create evolution specification
9. **Implement v0.1.4d** - Build event and storytelling systems

---

*This scope breakdown establishes a comprehensive world persistence and evolution system. State tracking enables meaningful persistence, repopulation creates dynamic challenge, faction territories add political depth, and evolution events deliver emergent storytelling. Together, these features transform the dungeon into a living world that responds to and remembers player actions.*
