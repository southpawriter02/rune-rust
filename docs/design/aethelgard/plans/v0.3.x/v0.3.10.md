# v0.3.10: The Configurator (Settings & Persistence)

> **Status:** Planned
> **Milestone:** 4.5 - Interface Polish
> **Theme:** User preferences, settings UI, and input rebinding

## Table of Contents
- [Overview](#overview)
- [Phase A: The Preferences (Settings Engine)](#phase-a-the-preferences-settings-engine)
- [Phase B: The Control Panel (Options UI)](#phase-b-the-control-panel-options-ui)
- [Phase C: The Keymaster (Input Rebinding UI)](#phase-c-the-keymaster-input-rebinding-ui)
- [Testing Strategy](#testing-strategy)
- [Changelog](#changelog-v0310---the-configurator)

## Overview

This milestone bridges the gap between the hardcoded configuration flags introduced in v0.3.9 and a fully user-configurable experience. It separates the persistent storage of preferences from the UI that modifies them.

To manage the distinct domains of persistence, UI, and input customization, this version is split into three sub-versions:

| Phase | Codename | Focus |
|-------|----------|-------|
| A | The Preferences | Settings Engine - JSON persistence and validation |
| B | The Control Panel | Options UI - Tabbed settings interface |
| C | The Keymaster | Input Rebinding UI - Interactive key mapping |

---

## Phase A: The Preferences (Settings Engine)

**Goal:** Implement SettingsService to manage the serialization, validation, and persistence of user preferences to `data/options.json`.

### 1. Architecture & Data Flow

The system uses a DTO (Data Transfer Object) pattern to separate the runtime static state (GameSettings) from the serialized storage format (SettingsDto).

**Components:**
- **GameSettings (Static Class):** The runtime source of truth accessed by renderers and systems (e.g., `GameSettings.Theme`).
- **SettingsDto (Record):** A serializable record matching the JSON structure.
- **SettingsService (Engine Service):** Orchestrates loading, saving, validation, and factory resets.
- **options.json (File):** The physical storage located in the `data/` directory.

**Workflow: Startup (Load)**
1. **Boot:** Program.cs invokes `SettingsService.LoadAsync()`.
2. **Check:** Service checks if `data/options.json` exists.
3. **Branch A (File Missing):**
   - Create SettingsDto with default values.
   - Serialize and write to disk.
   - Apply defaults to GameSettings.
4. **Branch B (File Exists):**
   - Read JSON string.
   - Deserialize to SettingsDto.
   - Validate: Clamp values (e.g., Volume 0-100) and sanitize enums.
   - Apply validated values to GameSettings.

### 2. Use Cases

1. **First Run:** User launches game for the first time. System detects no config, creates `options.json` with defaults (Standard Theme, 100% Text Speed).
2. **Configuration Change:** User toggles "High Contrast" in the future UI. The UI updates `GameSettings.Theme` and calls `SettingsService.SaveAsync()`.
3. **Corrupted Config:** User manually edits `options.json` with invalid data (e.g., Volume: 500). System detects invalid range, clamps it to 100, applies it, and overwrites the file with the corrected value.

### 3. Logic Decision Trees

#### A. Load & Validate Logic
Input: Read JSON from Disk

1. **Deserialization:** Try parse JSON.
   - Fail: Log Error, Backup corrupt file, Reset to Defaults.
   - Success: Proceed to Validation.
2. **Validation Loop:**
   - Volume: Is value < 0? Set 0. Is value > 100? Set 100.
   - TextSpeed: Is value < 10? Set 10. Is value > 100? Set 100.
   - Theme: Is Enum defined? Yes -> Keep. No -> Set ThemeType.Standard.
3. **Application:** Copy validated DTO values to GameSettings static properties.

#### B. Save Logic
Input: Save Request

1. **Mapping:** Create new SettingsDto from current GameSettings properties.
2. **Directory Check:** Does `data/` directory exist? No: Create it.
3. **Serialization:** Serialize DTO to JSON (Indented formatting).
4. **Write:** Overwrite `options.json`.
5. **Log:** Record "Settings saved" event.

### 4. Code Implementation

#### A. Core Layer (DTO)
File: `RuneAndRust.Core/Models/SettingsDto.cs`
```csharp
public record SettingsDto
{
    public bool ReduceMotion { get; init; } = false;
    public int Theme { get; init; } = 0; // Maps to ThemeType int value
    public int TextSpeed { get; init; } = 100; // ms delay modifier (percentage)
    public int MasterVolume { get; init; } = 100;
    public int AutosaveIntervalMinutes { get; init; } = 5;
}
```

#### B. Engine Layer (Service)
File: `RuneAndRust.Engine/Services/SettingsService.cs`
```csharp
using System.Text.Json;
using RuneAndRust.Core.Settings; // Where GameSettings lives

public class SettingsService : ISettingsService
{
    private readonly ILogger<SettingsService> _logger;
    private const string FilePath = "data/options.json";

    public SettingsService(ILogger<SettingsService> logger)
    {
        _logger = logger;
    }

    public async Task LoadAsync()
    {
        try
        {
            if (!File.Exists(FilePath))
            {
                _logger.LogInformation("No settings file found. Creating defaults.");
                await ResetToDefaultsAsync();
                return;
            }

            var json = await File.ReadAllTextAsync(FilePath);
            var dto = JsonSerializer.Deserialize<SettingsDto>(json);

            if (dto == null) throw new JsonException("Deserialized settings were null");

            ApplyDtoToSettings(dto);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load settings. Reverting to defaults.");
            await ResetToDefaultsAsync();
        }
    }

    public async Task SaveAsync()
    {
        var dto = new SettingsDto
        {
            ReduceMotion = GameSettings.ReduceMotion,
            Theme = (int)GameSettings.Theme,
            TextSpeed = GameSettings.TextSpeed,
            MasterVolume = GameSettings.MasterVolume,
            AutosaveIntervalMinutes = GameSettings.AutosaveIntervalMinutes
        };

        var dir = Path.GetDirectoryName(FilePath);
        if (dir != null && !Directory.Exists(dir))
            Directory.CreateDirectory(dir);

        var json = JsonSerializer.Serialize(dto, new JsonSerializerOptions { WriteIndented = true });
        await File.WriteAllTextAsync(FilePath, json);

        _logger.LogInformation("Settings saved to disk.");
    }

    public async Task ResetToDefaultsAsync()
    {
        // define defaults
        GameSettings.ReduceMotion = false;
        GameSettings.Theme = ThemeType.Standard;
        GameSettings.TextSpeed = 100;
        GameSettings.MasterVolume = 100;
        GameSettings.AutosaveIntervalMinutes = 5;

        await SaveAsync();
    }

    private void ApplyDtoToSettings(SettingsDto dto)
    {
        // Validation Logic
        GameSettings.ReduceMotion = dto.ReduceMotion;

        // Enum Safety Check
        GameSettings.Theme = Enum.IsDefined(typeof(ThemeType), dto.Theme)
            ? (ThemeType)dto.Theme
            : ThemeType.Standard;

        // Range Clamping
        GameSettings.TextSpeed = Math.Clamp(dto.TextSpeed, 10, 200);
        GameSettings.MasterVolume = Math.Clamp(dto.MasterVolume, 0, 100);
        GameSettings.AutosaveIntervalMinutes = Math.Clamp(dto.AutosaveIntervalMinutes, 1, 60);

        _logger.LogInformation("Settings applied. Theme: {Theme}", GameSettings.Theme);
    }
}
```

### 5. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Settings | Load (Success) | Info | "Settings loaded. Theme: {Theme}, Motion: {Motion}" | Theme, Motion |
| Settings | Load (Fail) | Error | "Settings load failed. Error: {Message}. Resetting." | Message |
| Settings | Save | Debug | "Settings saved to {Path}" | Path |
| Settings | Validation | Warning | "Setting {Name} out of range ({Value}). Clamped to {Clamped}." | Name, Value, Clamped |

### 6. Testing Requirements

**Unit Tests (SettingsServiceTests.cs)**
- **Validation:**
  - `Load_ClampsVolume_WhenOver100`: Manually write JSON with Volume 150. Load. Assert `GameSettings.MasterVolume` is 100.
  - `Load_ValidatesTheme`: Write JSON with Theme 99 (Invalid). Load. Assert `GameSettings.Theme` is Standard.
- **Defaults:**
  - `Load_CreatesFile_WhenMissing`: Ensure `data/options.json` is created if it doesn't exist.

**Integration Tests**
- **Persistence Roundtrip:**
  1. Set `GameSettings.Theme = HighContrast`.
  2. Call `SaveAsync()`.
  3. Reset `GameSettings.Theme = Standard`.
  4. Call `LoadAsync()`.
  5. Verify `GameSettings.Theme` is HighContrast.

### 7. Deliverable Checklist (v0.3.10a)

- [ ] Core: Define `SettingsDto` record.
- [ ] Core: Update GameSettings static class with new properties (Volume, TextSpeed, Autosave).
- [ ] Core: Define `ISettingsService` interface.
- [ ] Engine: Implement SettingsService.
- [ ] Engine: Implement Validation/Clamping logic.
- [ ] Terminal: Update Program.cs to register ISettingsService as Singleton.
- [ ] Terminal: Update Program.cs to await `service.LoadAsync()` before the main loop starts.
- [ ] Data: Ensure `.gitignore` ignores `data/options.json` (user preference should not be committed).

---

## Phase B: The Control Panel (Options UI)

**Goal:** Create a tabbed TUI using Spectre.Console to modify settings at runtime without editing JSON files.

### 1. Architecture & Data Flow

The Options UI functions as a Modal Loop: it temporarily captures input focus until the user exits, at which point settings are persisted to disk.

**Components:**
- **OptionsViewModel:** A mutable state container representing the current state of the UI (active tab, selected index) and the pending values of settings.
- **OptionsScreenRenderer:** A stateless Spectre.Console renderer that draws the tab bar, setting list, and visual sliders.
- **SettingsManager:** An orchestration class (or method within GameService) that runs the input loop, modifies GameSettings, and calls `ISettingsService.SaveAsync`.

**Workflow:**
1. **Entry:** User types `options` or presses `O`.
2. **State Capture:** The system creates an OptionsViewModel populated with current GameSettings values.
3. **Render Loop:**
   - `OptionsScreenRenderer.Render(vm)` displays the UI.
   - Input is read.
   - **Modify:** User changes a setting (e.g., Text Speed). The ViewModel updates immediately.
   - **Apply:** GameSettings static properties are updated immediately to reflect visual changes (e.g., Theme change instantly repaints).
4. **Exit:** User presses Esc.
5. **Persistence:** `ISettingsService.SaveAsync()` writes changes to `options.json`.

### 2. Logic Decision Trees

#### A. Input Handling Logic
Input: ConsoleKeyInfo, ViewModel

1. **Navigation:**
   - Tab / Shift+Tab: Cycle Active Tab (General -> Display -> Audio). Reset Selection Index to 0.
   - Up / Down: Increment/Decrement Selection Index. Clamp to [0, Count-1].
2. **Modification (Left/Right):**
   - Target is Slider (Int): Increment/Decrement value by Step (e.g., ±10). Clamp to Min/Max.
   - Target is Enum (Theme): Cycle next/previous Enum value.
   - Target is Toggle (Bool): No effect (use Space/Enter).
3. **Modification (Enter/Space):**
   - Target is Toggle: Invert Boolean.
   - Target is Action: Execute (e.g., "Reset to Defaults").
4. **Exit (Esc):** Break loop, Trigger Save.

#### B. Render Logic (Slider Visuals)
Input: Value (50), Min (0), Max (100), Width (20)

1. Calculate Ratio: 0.5
2. Calculate Blocks: 20 * 0.5 = 10
3. Construct String: `[green]██████████[/][grey]░░░░░░░░░░[/]`
4. Append Value: " 50%"

### 3. Code Implementation

#### A. Core Layer (ViewModel)
File: `RuneAndRust.Core/ViewModels/OptionsViewModel.cs`
```csharp
public class OptionsViewModel
{
    public OptionsTab ActiveTab { get; set; } = OptionsTab.General;
    public int SelectedIndex { get; set; } = 0;

    // Flattened list of settings for the current tab for easy indexing
    public List<SettingItemView> CurrentItems { get; set; } = new();

    public void RefreshItems()
    {
        // Logic to repopulate CurrentItems based on ActiveTab and GameSettings state
    }
}

public enum OptionsTab { General, Display, Audio, Controls }

public record SettingItemView(string Name, string ValueDisplay, SettingType Type, bool IsSelected);
public enum SettingType { Toggle, Slider, Enum, Action }
```

#### B. Terminal Layer (Renderer)
File: `RuneAndRust.Terminal/Rendering/OptionsScreenRenderer.cs`
```csharp
public class OptionsScreenRenderer : IOptionsScreenRenderer
{
    public void Render(OptionsViewModel vm)
    {
        var layout = new Layout("Root")
            .SplitRows(
                new Layout("Header").Size(3),
                new Layout("Tabs").Size(3),
                new Layout("Content"),
                new Layout("Footer").Size(3)
            );

        // Render Tabs
        var tabGrid = new Grid().AddColumns(4);
        foreach (var tab in Enum.GetValues<OptionsTab>())
        {
            var style = tab == vm.ActiveTab ? "[bold gold1]" : "[grey]";
            var indicator = tab == vm.ActiveTab ? "▼" : " ";
            tabGrid.AddRow($"{style}{tab} {indicator}[/]");
        }
        layout["Tabs"].Update(new Panel(tabGrid).Border(BoxBorder.None));

        // Render Settings List
        var table = new Table().Border(TableBorder.None).HideHeaders();
        table.AddColumn("Name");
        table.AddColumn("Control");

        foreach (var item in vm.CurrentItems)
        {
            var prefix = item.IsSelected ? "[gold1]>[/] " : "  ";
            var color = item.IsSelected ? "white" : "grey";
            table.AddRow(
                new Markup($"{prefix}[{color}]{item.Name}[/]"),
                new Markup($"[{color}]{item.ValueDisplay}[/]")
            );
        }
        layout["Content"].Update(new Panel(table).Border(BoxBorder.Rounded));

        AnsiConsole.Clear();
        AnsiConsole.Write(layout);
    }
}
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Options | Open | Info | "Options menu opened" | - |
| Options | Change | Debug | "Setting {Name} changed to {Value}" | Name, Value |
| Options | Tab | Trace | "Switched option tab to {Tab}" | Tab |
| Settings | Persist | Info | "Options menu closed. Settings saved." | - |

### 5. Testing Strategy

**Unit Tests (OptionsViewModelTests.cs)**
- **Navigation:**
  - `RefreshItems_GeneratesCorrectList_ForGeneralTab`: Assert list contains "Autosave".
  - `RefreshItems_GeneratesCorrectList_ForDisplayTab`: Assert list contains "Theme".
- **Display Logic:**
  - `Slider_FormatsCorrectly`: Value 50, Range 0-100 -> Returns visual bar string.

**Integration Tests**
- **Live Update:**
  - Change Theme in ViewModel -> Verify `GameSettings.Theme` updates immediately.
  - Mock ISettingsService. Exit Menu -> Verify SaveAsync called.

### 6. Deliverable Checklist (v0.3.10b)

- [ ] Core: Define `OptionsViewModel` and `OptionsTab` enum.
- [ ] Core: Define `IOptionsScreenRenderer` interface.
- [ ] Terminal: Implement `OptionsScreenRenderer` with Layouts and Grids.
- [ ] Terminal: Implement `RenderSlider` helper method for ASCII bars.
- [ ] Engine: Implement OptionsController (or similar logic inside CommandParser/GameService) to handle the input loop.
- [ ] Engine: Wire `O` / `options` command to trigger the controller.
- [ ] Engine: Ensure `ISettingsService.SaveAsync` is called on exit.

---

## Phase C: The Keymaster (Input Rebinding UI)

**Goal:** Connect the InputConfigurationService (v0.3.9c) to the Options UI, allowing interactive key mapping.

### 1. Architecture & Data Flow

The Rebinding Loop: Unlike standard toggles or sliders, key rebinding requires a "Listening State" where the controller captures raw input without processing it as a command.

1. **Selection:** User navigates to the "Controls" tab and selects an action (e.g., "Move North").
2. **Activation:** User presses Enter. State shifts to Listening.
3. **Capture:** The next key press is intercepted by `Console.ReadKey(intercept: true)`.
4. **Validation:**
   - Is the key reserved (e.g., Esc)? -> Cancel.
   - Is the key already bound? -> Conflict Resolution.
5. **Execution:** Update InputConfigurationService.
6. **Refresh:** Re-render the UI with the new binding displayed.
7. **Persistence:** Changes save to `input_bindings.json` upon menu exit.

### 2. Logic Decision Trees

#### A. Binding Conflict Resolution
Input: NewKey, TargetAction

1. Check Existing: Does NewKey already map to an action (e.g., ExistingAction)?
   - No: Proceed to Bind.
   - Yes:
     1. **Identification:** Is ExistingAction == TargetAction?
        - Yes: Do nothing (already bound). Exit.
     2. **Conflict Detected:**
        - Log Warning.
        - Unbind: Remove binding for ExistingAction (it becomes unbound).
        - Bind: Map NewKey to TargetAction.
        - Feedback: Show toast/message: "Unbound [ExistingAction] to bind [TargetAction]."

#### B. Render Logic (Controls Tab)
Input: InputConfigurationService

1. Fetch All Bindings: Get dictionary of `<GameAction, ConsoleKey>`.
2. Categorize: Group by Action Category (Movement, Combat, Menu).
3. Format Rows:
   - Action Name (Left aligned).
   - Key Name (Right aligned).
   - Style: If Key is Missing/Unbound -> Red "[Unbound]". Else -> Cyan "[KeyName]".

### 3. Code Implementation

#### A. ViewModel Extension
File: `RuneAndRust.Core/ViewModels/OptionsViewModel.cs`
```csharp
// Added to support the new tab
public List<BindingItemView> Bindings { get; set; } = new();

public record BindingItemView(
    string ActionName,
    string KeyDisplay,
    GameAction Action,
    string Category,
    bool IsSelected
);
```

#### B. Engine Layer (Conflict Handling)
File: `RuneAndRust.Engine/Services/InputConfigurationService.cs`
```csharp
public void SetBinding(GameAction action, ConsoleKey newKey)
{
    // 1. Remove any existing binding for this action
    var existingKey = _keyMap.FirstOrDefault(x => x.Value == action).Key;
    if (existingKey != default)
    {
        _keyMap.Remove(existingKey);
    }

    // 2. Check conflict: Is this key used by another action?
    if (_keyMap.TryGetValue(newKey, out var conflictAction))
    {
        _logger.LogWarning("Binding conflict: {Key} taken by {OldAction}. Overwriting for {NewAction}.",
            newKey, conflictAction, action);
        // The key is overwritten in the dictionary automatically below,
        // effectively unbinding 'conflictAction'.
    }

    // 3. Set new binding
    _keyMap[newKey] = action;
}
```

#### C. Terminal Layer (Controller)
File: `RuneAndRust.Terminal/Services/OptionsController.cs`
```csharp
private void HandleControlsInput()
{
    var selectedItem = _vm.Bindings[_vm.SelectedIndex];

    // Enter 'Listening Mode'
    AnsiConsole.MarkupLine($"[yellow]Press new key for {selectedItem.ActionName} (Esc to cancel)...[/]");

    var keyInfo = Console.ReadKey(intercept: true);

    if (keyInfo.Key == ConsoleKey.Escape) return; // Cancel

    // Perform Rebind
    _inputConfig.SetBinding(selectedItem.Action, keyInfo.Key);

    // Refresh UI
    RefreshBindingsList();
}
```

### 4. Logging & Metrics

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Input | Rebind Start | Debug | "User initiating rebind for {Action}" | Action |
| Input | Rebind Success | Info | "Rebound {Action} to {Key}" | Action, Key |
| Input | Conflict | Warning | "Conflict detected. Unbound {OldAction} to assign {Key} to {NewAction}" | OldAction, Key, NewAction |
| Settings | Save Bindings | Info | "Input configuration saved to disk" | - |

### 5. Testing Requirements

**Unit Tests (InputConfigurationServiceTests.cs)**
- **SetBinding_NewKey:**
  - Action: MoveNorth, Key: W (Unused).
  - Result: `GetCommandForKey(W)` returns MoveNorth.
- **SetBinding_Overwrite:**
  - Setup: W binds to MoveNorth.
  - Action: Bind MoveSouth to W.
  - Result: W maps to MoveSouth. MoveNorth is now unbound (not in dictionary).
- **SetBinding_ClearOld:**
  - Setup: MoveNorth is W.
  - Action: Bind MoveNorth to UpArrow.
  - Result: UpArrow -> MoveNorth. W -> null (freed up).

**Integration Tests (OptionsScreenTests.cs)**
- **Workflow:**
  - Open Options -> Select Controls Tab.
  - Select "Inventory".
  - Simulate KeyPress I.
  - Verify ViewModel updates KeyDisplay to "I".

### 6. Deliverable Checklist (v0.3.10c)

- [ ] Core: Add `OptionsTab.Controls` enum value.
- [ ] Core: Update OptionsViewModel to hold binding list.
- [ ] Engine: Update InputConfigurationService with conflict resolution logic (`SetBinding`).
- [ ] Terminal: Update OptionsScreenRenderer to render the Controls tab (Category Headers, Key columns).
- [ ] Terminal: Update OptionsController to handle the "Listening" input loop.
- [ ] Data: Ensure `input_bindings.json` is updated on menu exit.

---

## Testing Strategy

### Unit Tests
| Test Class | Focus | Key Scenarios |
|------------|-------|---------------|
| SettingsServiceTests | Persistence & Validation | Clamp values, Validate enums, Create defaults |
| OptionsViewModelTests | UI State | Tab navigation, Item generation |
| InputConfigurationServiceTests | Rebinding Logic | New bindings, Overwrites, Clear old bindings |

### Integration Tests
| Scenario | Components | Validation |
|----------|------------|------------|
| Persistence Roundtrip | SettingsService + File System | Save/Load cycle preserves values |
| Live Update | OptionsViewModel -> GameSettings | Theme changes apply immediately |
| Rebind Workflow | OptionsController + InputConfigurationService | Key captures and persists |

---

## Changelog: v0.3.10 - The Configurator

**Release Date:** 2025-XX-XX

### Summary
"The Configurator" update puts control in the player's hands. A new Settings menu allows customization of audio, visuals, and gameplay preferences. The highlight is the new Key Rebinding system, allowing players to map any action to any key directly from the in-game UI.

### Features
- **Persistent Settings:**
  - Settings are now saved to `data/options.json`.
  - Automatically creates default configuration on first launch.
- **Options Menu:**
  - **Visuals:** Toggle Screen Shake, Change Color Theme (High Contrast/Colorblind), Adjust Text Speed.
  - **System:** Configure Autosave interval.
- **Configurable Options:**
  - `ReduceMotion`: Toggle screen shake/flash effects.
  - `Theme`: Select Colorblind/High-Contrast modes.
  - `TextSpeed`: Adjust typewriter effect speed (10-200%).
  - `MasterVolume`: (Placeholder) Audio volume control.
  - `AutosaveInterval`: Frequency of autosaves (1-60 mins).
- **Key Rebinding:**
  - Fully interactive "Press to Bind" interface.
  - Automatic conflict detection prevents broken controls.
- **Controls Menu:**
  - New tab in Options: **Controls**.
  - Categorized list of all game actions (Movement, Combat, Menus).

### Technical
- Implemented `SettingsService` for robust JSON serialization of user preferences.
- Added validation logic to auto-correct corrupted settings files (e.g., clamping invalid values).
- Implemented `OptionsScreenRenderer` using Spectre.Console layouts.
- Created `OptionsViewModel` to bridge static settings with UI state.
- Extended `InputConfigurationService` with robust Set/Remove logic.
- Implemented "Listening Mode" in `OptionsController` for raw input capture.
