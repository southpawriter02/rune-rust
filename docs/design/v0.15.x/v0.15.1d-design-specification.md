# v0.15.1d Design Specification: Extended Check Mechanics

**Version:** 0.15.1d
**Theme:** Extended Check Mechanics
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0 Complete (Dice Pool Refactor), v0.15.1a Complete (Skill Context & Modifiers), v0.15.1b Complete (Outcome Classification), v0.15.1c Complete (Master Abilities)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [CooperationType Enum](#4-cooperationtype-enum)
5. [CooperativeCheckResult Value Object](#5-cooperativecheckresult-value-object)
6. [ChainedCheckStatus Enum](#6-chainedcheckstatus-enum)
7. [ChainedCheckStep Value Object](#7-chainedcheckstep-value-object)
8. [ChainedCheckState Entity](#8-chainedcheckstate-entity)
9. [IExtendedSkillCheckService Interface](#9-iextendedskillcheckservice-interface)
10. [ExtendedSkillCheckService Implementation](#10-extendedskillcheckservice-implementation)
11. [IChainedCheckRepository Interface](#11-ichainedcheckrepository-interface)
12. [InMemoryChainedCheckRepository Implementation](#12-inmemorychainedcheckrepository-implementation)
13. [Data Model Changes](#13-data-model-changes)
14. [Configuration](#14-configuration)
15. [Commands](#15-commands)
16. [User-Facing Changes](#16-user-facing-changes)
17. [Logging Specifications](#17-logging-specifications)
18. [Unit Testing Requirements](#18-unit-testing-requirements)
19. [Use Cases](#19-use-cases)
20. [Deliverable Checklist](#20-deliverable-checklist)
21. [Acceptance Criteria](#21-acceptance-criteria)
22. [Future Considerations](#22-future-considerations)
23. [Implementation Notes](#23-implementation-notes)
24. [Document Metadata](#24-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.1d, the Extended Check Mechanics phase. This part introduces two advanced skill check mechanisms that build upon the infrastructure established in v0.15.0d (Contested & Extended Checks) and v0.15.1a-c:

1. **Cooperative Checks**: Multiple party members working together on a single skill challenge. Different cooperation types handle various scenarios:
   - **Weakest Link**: The lowest pool makes the check (party stealth)
   - **Best Attempt**: The highest roll counts (searching for traps)
   - **Combined**: Add all successes together (group lifting)
   - **Assisted**: Primary roller gets bonus dice from helpers

2. **Chained Checks**: Sequential skill challenges where each step must succeed before the next. Used for multi-stage procedures like:
   - Terminal hacking (Access → Authentication → Navigation)
   - Trap disarmament (Detection → Analysis → Disarmament)
   - Tracking pursuit (Acquisition → Pursuit → Closing)

This infrastructure enables the complex multi-stage and party-based skill systems used by v0.15.2-v0.15.5.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Cooperative Checks** | Not implemented | `CooperativeCheckResult` with 4 cooperation types |
| **Party Stealth** | Individual checks | `WeakestLink` cooperation type |
| **Group Assistance** | `additionalBonusDice` parameter | `Assisted` type with formal helper tracking |
| **Chained Checks** | Not implemented | `ChainedCheckState` entity tracks multi-step progress |
| **Step Dependencies** | N/A | Each step requires previous success |
| **Retry Logic** | N/A | Configurable retry attempts per step |
| **Context Per Step** | N/A | Different `SkillContext` per chain step |
| **Master Abilities** | N/A | Integrated via v0.15.1c service calls |

### 1.3 Scope

**In Scope:**
- Define `CooperationType` enum for cooperation classification (4 values)
- Create `CooperativeCheckResult` value object
- Implement cooperative check resolution for all 4 types
- Define `ChainedCheckStatus` enum for chain progress (5 values)
- Create `ChainedCheckStep` value object for step configuration
- Create `ChainedCheckState` entity for tracking multi-step progress
- Create `IExtendedSkillCheckService` interface for cooperative and chained checks
- Implement `ExtendedSkillCheckService` with full logic
- Create `IChainedCheckRepository` interface for state persistence
- Implement `InMemoryChainedCheckRepository`
- Unit tests for cooperative and chained checks (~10 tests per scope breakdown)

**Out of Scope:**
- Trauma economy integration - v0.15.1e
- Specialization bonus hooks - v0.15.1e
- Voice guidance integration - v0.15.1e
- Skill-specific chained procedures (climbing stages, terminal layers) - v0.15.2-v0.15.5
- UI for displaying chain progress - future version
- Persistent save/load of chain state - future version

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 2 | `CooperationType` (4 values), `ChainedCheckStatus` (5 values) |
| Value Objects | 2 | `CooperativeCheckResult`, `ChainedCheckStep` |
| Entities | 1 | `ChainedCheckState` |
| Interfaces | 2 | `IExtendedSkillCheckService`, `IChainedCheckRepository` |
| Services | 1 | `ExtendedSkillCheckService` |
| Repositories | 1 | `InMemoryChainedCheckRepository` |
| Unit Tests | ~10 | Cooperation types, chained progression, retry logic |

---

## 2. Dependencies

### 2.1 Required from v0.15.0a-c (Dice Pool Refactor)

| Component | Location | Usage in v0.15.1d |
|-----------|----------|-------------------|
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Provides `NetSuccesses`, `IsFumble` for each participant |
| `SkillCheckResult` | `Domain/ValueObjects/SkillCheckResult.cs` | Individual check results for each step/participant |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Performs individual checks called by extended service |

### 2.2 Required from v0.15.0d (Contested & Extended Checks)

| Component | Location | Usage in v0.15.1d |
|-----------|----------|-------------------|
| `ExtendedCheckState` | `Domain/Entities/ExtendedCheckState.cs` | Pattern reference for `ChainedCheckState` |
| `ExtendedCheckStatus` | `Domain/Enums/ExtendedCheckStatus.cs` | Similar status tracking pattern |

### 2.3 Required from v0.15.1a (Skill Context & Modifiers)

| Component | Location | Usage in v0.15.1d |
|-----------|----------|-------------------|
| `SkillContext` | `Domain/ValueObjects/SkillContext.cs` | Per-step context for chained checks |
| `SkillContextBuilder` | `Application/Services/SkillContextBuilder.cs` | Build context for each participant/step |

### 2.4 Required from v0.15.1b (Outcome Classification)

| Component | Location | Usage in v0.15.1d |
|-----------|----------|-------------------|
| `SkillOutcome` | `Domain/Enums/SkillOutcome.cs` | Outcome classification for each step result |
| `FumbleConsequence` | `Domain/Entities/FumbleConsequence.cs` | Fumble consequences during chains |

### 2.5 Required from v0.15.1c (Master Abilities)

| Component | Location | Usage in v0.15.1d |
|-----------|----------|-------------------|
| `IMasterAbilityService` | `Application/Interfaces/IMasterAbilityService.cs` | Check for auto-succeed during cooperative/chained |
| `MasterAbilityEvaluationResult` | `Domain/ValueObjects/MasterAbilityEvaluationResult.cs` | Handle master ability effects |

### 2.6 Required from v0.4.x-v0.5.x (Skill System)

| Component | Location | Usage in v0.15.1d |
|-----------|----------|-------------------|
| `Player` | `Domain/Entities/Player.cs` | Participant in cooperative checks |
| `SkillDefinition` | `Domain/Entities/SkillDefinition.cs` | Skill info for each step |

### 2.7 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.2 | Acrobatics | Party stealth (WeakestLink), climbing stages (Chained) |
| v0.15.3 | Rhetoric | Negotiation phases (Chained), group persuasion (Combined) |
| v0.15.4 | System Bypass | Terminal hacking layers (Chained), group lockpicking (Assisted) |
| v0.15.5 | Wasteland Survival | Tracking pursuit phases (Chained), group foraging (Combined) |

---

## 3. Architecture Diagrams

### 3.1 Cooperative Check Resolution Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    COOPERATIVE CHECK RESOLUTION FLOW                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INPUT: ParticipantIds[], SkillId, DC, CooperationType                      │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  STEP 1: EVALUATE MASTER ABILITIES FOR EACH PARTICIPANT             │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  foreach (participant in participants)                              │    │
│  │  {                                                                   │    │
│  │      masterEval = MasterAbilityService.EvaluateForCheck(            │    │
│  │          participant, skillId, subType, dc);                        │    │
│  │                                                                      │    │
│  │      if (masterEval.ShouldAutoSucceed)                              │    │
│  │          participantAutoSucceeds[participant] = true;               │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  STEP 2: GATHER DICE POOLS                                          │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  pools = []                                                          │    │
│  │  foreach (participant in participants)                              │    │
│  │  {                                                                   │    │
│  │      pool = CalculatePool(participant, skillId, context)            │    │
│  │      pools.Add((participant, pool))                                 │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  │  Example (Party Stealth):                                           │    │
│  │    Player A: FINESSE 3 + Acrobatics 2 = 5d10                       │    │
│  │    Player B: FINESSE 2 + Acrobatics 1 = 3d10 ← lowest              │    │
│  │    Player C: FINESSE 4 + Acrobatics 3 = 7d10                       │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  STEP 3: APPLY COOPERATION TYPE                                     │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  switch (cooperationType)                                           │    │
│  │  {                                                                   │    │
│  │      case WeakestLink:                                              │    │
│  │          // Lowest pool makes the check                             │    │
│  │          roller = pools.MinBy(p => p.pool);                         │    │
│  │          result = PerformCheck(roller, dc);                         │    │
│  │          break;                                                     │    │
│  │                                                                      │    │
│  │      case BestAttempt:                                              │    │
│  │          // Each rolls, highest result wins                         │    │
│  │          results = pools.Select(p => PerformCheck(p, dc));         │    │
│  │          result = results.MaxBy(r => r.NetSuccesses);              │    │
│  │          break;                                                     │    │
│  │                                                                      │    │
│  │      case Combined:                                                 │    │
│  │          // Sum all net successes                                   │    │
│  │          results = pools.Select(p => Roll(p.pool));                │    │
│  │          totalNet = results.Sum(r => r.NetSuccesses);              │    │
│  │          result = ClassifyOutcome(totalNet, dc);                   │    │
│  │          break;                                                     │    │
│  │                                                                      │    │
│  │      case Assisted:                                                 │    │
│  │          // Primary + 1d10 per helper with 2+ successes            │    │
│  │          primary = pools[0];                                        │    │
│  │          helpers = pools.Skip(1);                                  │    │
│  │          bonusDice = helpers.Count(h => Roll(h).NetSuccesses >= 2);│    │
│  │          result = PerformCheck(primary.pool + bonusDice, dc);      │    │
│  │          break;                                                     │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  STEP 4: BUILD COOPERATIVE RESULT                                   │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  CooperativeCheckResult                                             │    │
│  │  ├── CooperationType: WeakestLink                                  │    │
│  │  ├── ParticipantIds: ["player-a", "player-b", "player-c"]          │    │
│  │  ├── ActiveRollerId: "player-b"  (lowest pool)                     │    │
│  │  ├── IndividualResults: [ResultA, ResultB, ResultC]                │    │
│  │  ├── FinalOutcome: FullSuccess                                     │    │
│  │  ├── FinalNetSuccesses: 2                                          │    │
│  │  ├── DifficultyClass: 2                                            │    │
│  │  └── ContributingParticipants: ["player-b"]                        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  OUTPUT: CooperativeCheckResult                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Chained Check Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        CHAINED CHECK FLOW                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INPUT: CharacterId, List<ChainedCheckStep>                                 │
│                                                                              │
│  Example: Terminal Hacking                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Steps:                                                              │    │
│  │  1. Access (System Bypass, DC 2, 0 retries)                         │    │
│  │  2. Authentication (System Bypass, DC 3, 1 retry)                   │    │
│  │  3. Navigation (System Bypass, DC 2, 0 retries)                     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  1. INITIALIZE CHAIN STATE                                          │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  ChainedCheckState                                                  │    │
│  │  ├── CheckId: "chain-001"                                           │    │
│  │  ├── CharacterId: "player-1"                                        │    │
│  │  ├── Steps: [Access, Authentication, Navigation]                   │    │
│  │  ├── CurrentStepIndex: 0                                            │    │
│  │  ├── StepResults: []                                                │    │
│  │  ├── Status: InProgress                                             │    │
│  │  ├── StartedAt: 2026-01-17T10:30:00Z                               │    │
│  │  └── RetriesRemaining: [0, 1, 0]                                   │    │
│  │                                                                      │    │
│  │  Repository.Add(state);                                             │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  2. PROCESS STEP 1: ACCESS                                          │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  step = Steps[0]  // Access, DC 2                                   │    │
│  │  context = step.Context ?? SkillContext.Empty                       │    │
│  │                                                                      │    │
│  │  result = SkillCheckService.PerformCheckWithDC(                    │    │
│  │      player, "system-bypass", dc: 2, context)                       │    │
│  │                                                                      │    │
│  │  Roll: 4d10 → [8, 9, 3, 2] → 2 successes, 0 botch = 2 net          │    │
│  │  DC 2 met → FullSuccess                                             │    │
│  │                                                                      │    │
│  │  StepResults.Add(result)                                            │    │
│  │  CurrentStepIndex = 1                                               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  3. PROCESS STEP 2: AUTHENTICATION                                  │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  step = Steps[1]  // Authentication, DC 3                           │    │
│  │                                                                      │    │
│  │  result = SkillCheckService.PerformCheckWithDC(                    │    │
│  │      player, "system-bypass", dc: 3, context)                       │    │
│  │                                                                      │    │
│  │  Roll: 4d10 → [1, 4, 5, 6] → 0 successes, 1 botch = FUMBLE         │    │
│  │  DC 3 not met → CriticalFailure                                    │    │
│  │                                                                      │    │
│  │  RetriesRemaining[1] = 1                                            │    │
│  │  Player has 1 retry available                                       │    │
│  │                                                                      │    │
│  │  "Authentication failed. You may retry (1 attempt remaining)."     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  4. RETRY STEP 2: AUTHENTICATION                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  RetriesRemaining[1] = 0  (used last retry)                        │    │
│  │                                                                      │    │
│  │  result = SkillCheckService.PerformCheckWithDC(                    │    │
│  │      player, "system-bypass", dc: 3, context)                       │    │
│  │                                                                      │    │
│  │  Roll: 4d10 → [10, 8, 9, 3] → 3 successes, 0 botch = 3 net         │    │
│  │  DC 3 met → FullSuccess                                             │    │
│  │                                                                      │    │
│  │  StepResults.Add(result)                                            │    │
│  │  CurrentStepIndex = 2                                               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  5. PROCESS STEP 3: NAVIGATION → COMPLETE                           │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  step = Steps[2]  // Navigation, DC 2                               │    │
│  │                                                                      │    │
│  │  result = SkillCheckService.PerformCheckWithDC(...)                │    │
│  │  → FullSuccess                                                       │    │
│  │                                                                      │    │
│  │  StepResults.Add(result)                                            │    │
│  │  CurrentStepIndex = 3 (past end)                                    │    │
│  │  Status = Succeeded                                                 │    │
│  │  CompletedAt = 2026-01-17T10:35:00Z                                │    │
│  │                                                                      │    │
│  │  Return ChainedCheckResult { Status: Succeeded, AllResults: [...] } │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Cooperation Type Comparison

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      COOPERATION TYPE COMPARISON                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  WEAKEST LINK                                                        │    │
│  │  "The chain is only as strong as its weakest link"                  │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Use Case: Party Stealth - everyone must sneak                      │    │
│  │                                                                      │    │
│  │  Players: A (5d10), B (3d10), C (7d10)                              │    │
│  │  Roller:  B (lowest pool)                                           │    │
│  │  Result:  B's single roll determines group success                  │    │
│  │                                                                      │    │
│  │  Why: If one person is spotted, everyone is caught                  │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  BEST ATTEMPT                                                        │    │
│  │  "Give it your best shot"                                           │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Use Case: Searching a room - anyone can find the clue             │    │
│  │                                                                      │    │
│  │  Players: A (5d10), B (3d10), C (7d10)                              │    │
│  │  Rolls:   A → 2 net, B → 1 net, C → 4 net                          │    │
│  │  Result:  C's result (highest) determines success                   │    │
│  │                                                                      │    │
│  │  Why: Only need one person to succeed                               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  COMBINED                                                            │    │
│  │  "Many hands make light work"                                       │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Use Case: Group lifting - everyone contributes                     │    │
│  │                                                                      │    │
│  │  Players: A (5d10), B (3d10), C (7d10)                              │    │
│  │  Rolls:   A → 2 net, B → 1 net, C → 3 net                          │    │
│  │  Total:   2 + 1 + 3 = 6 net successes                               │    │
│  │  Result:  6 net vs DC determines outcome                            │    │
│  │                                                                      │    │
│  │  Why: Physical effort literally combines                            │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  ASSISTED                                                            │    │
│  │  "Help me with this"                                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Use Case: Lockpicking with lookout - one does, others support     │    │
│  │                                                                      │    │
│  │  Primary: A (5d10)                                                   │    │
│  │  Helpers: B (3d10) → 2 net (✓ grants +1d10)                        │    │
│  │           C (7d10) → 1 net (✗ no bonus)                            │    │
│  │                                                                      │    │
│  │  A's final pool: 5d10 + 1d10 = 6d10                                │    │
│  │  Result:  A rolls 6d10 vs DC                                        │    │
│  │                                                                      │    │
│  │  Why: Helpers contribute if they roll 2+ net successes             │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Entities/                                                           │    │
│  │  └── ChainedCheckState.cs           ←── NEW (chain tracking)        │    │
│  │                                                                      │    │
│  │  ValueObjects/                                                       │    │
│  │  ├── CooperativeCheckResult.cs      ←── NEW (cooperative result)    │    │
│  │  └── ChainedCheckStep.cs            ←── NEW (step configuration)    │    │
│  │                                                                      │    │
│  │  Enums/                                                              │    │
│  │  ├── CooperationType.cs             ←── NEW (cooperation types)     │    │
│  │  └── ChainedCheckStatus.cs          ←── NEW (chain status)          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Interfaces/                                                         │    │
│  │  ├── IExtendedSkillCheckService.cs  ←── NEW (service interface)     │    │
│  │  └── IChainedCheckRepository.cs     ←── NEW (persistence)           │    │
│  │                                                                      │    │
│  │  Services/                                                           │    │
│  │  └── ExtendedSkillCheckService.cs   ←── NEW (cooperative/chained)   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  INFRASTRUCTURE LAYER                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Repositories/                                                       │    │
│  │  └── InMemoryChainedCheckRepository.cs  ←── NEW (in-memory state)   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  DEPENDENCY INJECTION                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  services.AddScoped<IExtendedSkillCheckService,                     │    │
│  │                     ExtendedSkillCheckService>();                   │    │
│  │  services.AddSingleton<IChainedCheckRepository,                     │    │
│  │                        InMemoryChainedCheckRepository>();           │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. CooperationType Enum

### 4.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/CooperationType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines how multiple participants combine their efforts in a cooperative skill check.
/// </summary>
/// <remarks>
/// <para>
/// Each cooperation type represents a different mechanical approach to group skill checks:
/// </para>
/// <list type="bullet">
///   <item><description><see cref="WeakestLink"/>: Party stealth where one failure fails all</description></item>
///   <item><description><see cref="BestAttempt"/>: Multiple attempts where best result wins</description></item>
///   <item><description><see cref="Combined"/>: Physical tasks where effort literally adds</description></item>
///   <item><description><see cref="Assisted"/>: Primary roller gets bonus from helpers</description></item>
/// </list>
/// </remarks>
public enum CooperationType
{
    /// <summary>
    /// The participant with the lowest dice pool makes the check.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Used when the group can only succeed if everyone succeeds. The weakest
    /// member determines the outcome because they're most likely to fail.
    /// </para>
    /// <para>
    /// Common uses:
    /// <list type="bullet">
    ///   <item><description>Party stealth (one spotted = all spotted)</description></item>
    ///   <item><description>Group climbing (one falls = rope pulls others)</description></item>
    ///   <item><description>Synchronized actions (one mistake ruins timing)</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    WeakestLink = 0,

    /// <summary>
    /// Each participant rolls independently; the best result is used.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Used when only one participant needs to succeed for the group to benefit.
    /// All participants roll, and the highest net successes determines the outcome.
    /// </para>
    /// <para>
    /// Common uses:
    /// <list type="bullet">
    ///   <item><description>Searching a room (anyone can find the clue)</description></item>
    ///   <item><description>Spotting ambush (one alert person saves all)</description></item>
    ///   <item><description>Recalling lore (anyone might remember)</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    BestAttempt = 1,

    /// <summary>
    /// All participants roll; their net successes are summed together.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Used when effort literally combines, such as physical tasks where more
    /// people means more force. The total net successes from all participants
    /// is compared against the DC.
    /// </para>
    /// <para>
    /// Common uses:
    /// <list type="bullet">
    ///   <item><description>Lifting heavy objects (more people = more force)</description></item>
    ///   <item><description>Group foraging (more searchers = more yield)</description></item>
    ///   <item><description>Pushing/pulling obstacles (combined strength)</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    Combined = 2,

    /// <summary>
    /// One primary participant rolls with bonus dice from helpers.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Used when one person does the actual work while others provide support.
    /// Each helper rolls independently; helpers who achieve 2+ net successes
    /// grant +1d10 to the primary's pool.
    /// </para>
    /// <para>
    /// Common uses:
    /// <list type="bullet">
    ///   <item><description>Lockpicking with lookout (picker + spotters)</description></item>
    ///   <item><description>Surgery with assistants (surgeon + nurses)</description></item>
    ///   <item><description>Hacking with distraction (hacker + decoys)</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    Assisted = 3
}
```

---

## 5. CooperativeCheckResult Value Object

### 5.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CooperativeCheckResult.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of a cooperative skill check involving multiple participants.
/// </summary>
/// <remarks>
/// <para>
/// Contains the outcome of a cooperative check along with details about each
/// participant's contribution and the cooperation method used.
/// </para>
/// </remarks>
/// <param name="CooperationType">The cooperation method used.</param>
/// <param name="ParticipantIds">IDs of all participants in the check.</param>
/// <param name="SkillId">The skill used for the check.</param>
/// <param name="SubType">Optional skill subtype.</param>
/// <param name="DifficultyClass">The DC that was checked against.</param>
/// <param name="FinalOutcome">The final outcome of the cooperative check.</param>
/// <param name="FinalNetSuccesses">The final net successes (varies by cooperation type).</param>
/// <param name="ActiveRollerId">ID of the participant whose roll determined the outcome (for WeakestLink/BestAttempt).</param>
/// <param name="IndividualResults">Individual check results for each participant (for BestAttempt/Combined).</param>
/// <param name="HelperBonuses">For Assisted: which helpers contributed bonus dice.</param>
/// <param name="ContributingParticipants">IDs of participants who contributed to success.</param>
public readonly record struct CooperativeCheckResult(
    CooperationType CooperationType,
    IReadOnlyList<string> ParticipantIds,
    string SkillId,
    string? SubType,
    int DifficultyClass,
    SkillOutcome FinalOutcome,
    int FinalNetSuccesses,
    string? ActiveRollerId = null,
    IReadOnlyList<SkillCheckResult>? IndividualResults = null,
    IReadOnlyList<HelperContribution>? HelperBonuses = null,
    IReadOnlyList<string>? ContributingParticipants = null)
{
    /// <summary>
    /// Whether the cooperative check succeeded (any success outcome).
    /// </summary>
    public bool IsSuccess => FinalOutcome >= SkillOutcome.MarginalSuccess;

    /// <summary>
    /// Whether any participant fumbled during the check.
    /// </summary>
    public bool HadFumble => IndividualResults?.Any(r => r.IsFumble) ?? false;

    /// <summary>
    /// Gets the margin of success (positive) or failure (negative).
    /// </summary>
    public int Margin => FinalNetSuccesses - DifficultyClass;

    /// <summary>
    /// Gets a display string summarizing the cooperative check.
    /// </summary>
    public string ToDisplayString()
    {
        var typeStr = CooperationType switch
        {
            CooperationType.WeakestLink => "Weakest Link",
            CooperationType.BestAttempt => "Best Attempt",
            CooperationType.Combined => "Combined Effort",
            CooperationType.Assisted => "Assisted",
            _ => "Unknown"
        };

        var outcomeStr = FinalOutcome switch
        {
            SkillOutcome.CriticalFailure => "Critical Failure!",
            SkillOutcome.Failure => "Failure",
            SkillOutcome.MarginalSuccess => "Marginal Success",
            SkillOutcome.FullSuccess => "Success",
            SkillOutcome.ExceptionalSuccess => "Exceptional Success",
            SkillOutcome.CriticalSuccess => "Critical Success!",
            _ => "Unknown"
        };

        return $"{typeStr} ({ParticipantIds.Count} participants): {outcomeStr} ({FinalNetSuccesses} vs DC {DifficultyClass})";
    }
}

/// <summary>
/// Records a helper's contribution to an assisted check.
/// </summary>
/// <param name="HelperId">The helper's character ID.</param>
/// <param name="NetSuccesses">Net successes the helper rolled.</param>
/// <param name="GrantedBonus">Whether this helper granted a bonus die (net >= 2).</param>
public readonly record struct HelperContribution(
    string HelperId,
    int NetSuccesses,
    bool GrantedBonus);
```

---

## 6. ChainedCheckStatus Enum

### 6.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/ChainedCheckStatus.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Tracks the current status of a chained skill check.
/// </summary>
/// <remarks>
/// <para>
/// Chained checks progress through multiple steps. This enum tracks the overall
/// state of the chain, not individual step outcomes.
/// </para>
/// </remarks>
public enum ChainedCheckStatus
{
    /// <summary>
    /// The chain has not started processing steps yet.
    /// </summary>
    /// <remarks>
    /// Initial state after creating a <see cref="ChainedCheckState"/>.
    /// </remarks>
    NotStarted = 0,

    /// <summary>
    /// The chain is currently in progress with steps remaining.
    /// </summary>
    /// <remarks>
    /// At least one step has been attempted, and the chain has not yet
    /// succeeded or failed.
    /// </remarks>
    InProgress = 1,

    /// <summary>
    /// The current step failed but retries are available.
    /// </summary>
    /// <remarks>
    /// The player can choose to retry the current step or abandon the chain.
    /// </remarks>
    AwaitingRetry = 2,

    /// <summary>
    /// All steps completed successfully.
    /// </summary>
    /// <remarks>
    /// Terminal state. The chain cannot be continued or retried.
    /// </remarks>
    Succeeded = 3,

    /// <summary>
    /// The chain failed and cannot continue.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Terminal state. Occurs when:
    /// <list type="bullet">
    ///   <item><description>A step fails with no retries remaining</description></item>
    ///   <item><description>A fumble occurs on a step with no retry option</description></item>
    ///   <item><description>The player abandons the chain</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    Failed = 4
}
```

---

## 7. ChainedCheckStep Value Object

### 7.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ChainedCheckStep.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a single step in a chained skill check.
/// </summary>
/// <remarks>
/// <para>
/// Each step defines what skill check is required, its difficulty, and whether
/// retries are allowed. Steps are processed sequentially; each must succeed
/// before the next is attempted.
/// </para>
/// </remarks>
/// <param name="StepId">Unique identifier for this step within the chain.</param>
/// <param name="Name">Display name for the step (e.g., "Access", "Authentication").</param>
/// <param name="Description">Description of what this step represents.</param>
/// <param name="SkillId">The skill used for this step's check.</param>
/// <param name="SubType">Optional skill subtype (for master ability filtering).</param>
/// <param name="DifficultyClass">The DC for this step.</param>
/// <param name="DifficultyName">Display name for the difficulty (e.g., "Moderate").</param>
/// <param name="MaxRetries">Number of retry attempts allowed (0 = no retries).</param>
/// <param name="Context">Optional skill context with modifiers for this step.</param>
/// <param name="FailureConsequence">Optional consequence type if this step fumbles.</param>
/// <param name="SuccessMessage">Optional message to display on step success.</param>
/// <param name="FailureMessage">Optional message to display on step failure.</param>
public readonly record struct ChainedCheckStep(
    string StepId,
    string Name,
    string Description,
    string SkillId,
    string? SubType,
    int DifficultyClass,
    string DifficultyName = "Custom",
    int MaxRetries = 0,
    SkillContext? Context = null,
    FumbleType? FailureConsequence = null,
    string? SuccessMessage = null,
    string? FailureMessage = null)
{
    /// <summary>
    /// Whether this step allows retry attempts on failure.
    /// </summary>
    public bool AllowsRetries => MaxRetries > 0;

    /// <summary>
    /// Creates a simple step with minimal configuration.
    /// </summary>
    /// <param name="stepId">Step identifier.</param>
    /// <param name="name">Step name.</param>
    /// <param name="skillId">Skill ID for the check.</param>
    /// <param name="dc">Difficulty class.</param>
    /// <param name="retries">Number of retries (default 0).</param>
    /// <returns>A new chained check step.</returns>
    public static ChainedCheckStep Create(
        string stepId,
        string name,
        string skillId,
        int dc,
        int retries = 0)
    {
        return new ChainedCheckStep(
            StepId: stepId,
            Name: name,
            Description: $"{name} ({skillId} DC {dc})",
            SkillId: skillId,
            SubType: null,
            DifficultyClass: dc,
            DifficultyName: dc switch
            {
                <= 1 => "Trivial",
                2 => "Easy",
                3 => "Moderate",
                4 => "Challenging",
                >= 5 => "Hard"
            },
            MaxRetries: retries);
    }

    /// <summary>
    /// Gets a display string for this step.
    /// </summary>
    public string ToDisplayString() =>
        $"{Name}: {SkillId} DC {DifficultyClass}" +
        (MaxRetries > 0 ? $" ({MaxRetries} retries)" : "");
}
```

---

## 8. ChainedCheckState Entity

### 8.1 Entity Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/ChainedCheckState.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Tracks the state of a multi-step chained skill check in progress.
/// </summary>
/// <remarks>
/// <para>
/// Chained checks represent multi-stage procedures where each step must succeed
/// before the next is attempted. Examples include:
/// <list type="bullet">
///   <item><description>Terminal hacking: Access → Authentication → Navigation</description></item>
///   <item><description>Trap disarmament: Detection → Analysis → Disarmament</description></item>
///   <item><description>Tracking pursuit: Acquisition → Pursuit → Closing</description></item>
/// </list>
/// </para>
/// <para>
/// The state tracks progress through steps, retry attempts, and individual results.
/// </para>
/// </remarks>
public sealed class ChainedCheckState
{
    /// <summary>
    /// Unique identifier for this chained check instance.
    /// </summary>
    public string CheckId { get; private set; } = string.Empty;

    /// <summary>
    /// The character performing the chained check.
    /// </summary>
    public string CharacterId { get; private set; } = string.Empty;

    /// <summary>
    /// Display name for this chain (e.g., "Terminal Hacking", "Trap Disarmament").
    /// </summary>
    public string ChainName { get; private set; } = string.Empty;

    /// <summary>
    /// The steps in this chained check, in order.
    /// </summary>
    public IReadOnlyList<ChainedCheckStep> Steps { get; private set; } = Array.Empty<ChainedCheckStep>();

    /// <summary>
    /// Index of the current step (0-based).
    /// </summary>
    /// <remarks>
    /// When equal to <see cref="Steps"/>.Count, all steps have been completed.
    /// </remarks>
    public int CurrentStepIndex { get; private set; }

    /// <summary>
    /// Results from each completed step.
    /// </summary>
    public List<ChainedStepResult> StepResults { get; private set; } = new();

    /// <summary>
    /// Remaining retry attempts for each step.
    /// </summary>
    /// <remarks>
    /// Indexed by step index. Decremented each time a step is retried.
    /// </remarks>
    public List<int> RetriesRemaining { get; private set; } = new();

    /// <summary>
    /// Current status of the chain.
    /// </summary>
    public ChainedCheckStatus Status { get; private set; } = ChainedCheckStatus.NotStarted;

    /// <summary>
    /// When the chain was started.
    /// </summary>
    public DateTime StartedAt { get; private set; }

    /// <summary>
    /// When the chain completed (succeeded or failed).
    /// </summary>
    public DateTime? CompletedAt { get; private set; }

    /// <summary>
    /// Optional context data for tracking (e.g., target terminal ID).
    /// </summary>
    public string? TargetId { get; private set; }

    // Private constructor for deserialization
    private ChainedCheckState() { }

    /// <summary>
    /// Creates a new chained check state.
    /// </summary>
    /// <param name="checkId">Unique identifier for this chain.</param>
    /// <param name="characterId">Character performing the chain.</param>
    /// <param name="chainName">Display name for the chain.</param>
    /// <param name="steps">The steps in order.</param>
    /// <param name="targetId">Optional target identifier.</param>
    /// <returns>A new <see cref="ChainedCheckState"/> ready to process.</returns>
    /// <exception cref="ArgumentException">Thrown when required parameters are missing.</exception>
    public static ChainedCheckState Create(
        string checkId,
        string characterId,
        string chainName,
        IReadOnlyList<ChainedCheckStep> steps,
        string? targetId = null)
    {
        if (string.IsNullOrWhiteSpace(checkId))
            throw new ArgumentException("Check ID is required.", nameof(checkId));
        if (string.IsNullOrWhiteSpace(characterId))
            throw new ArgumentException("Character ID is required.", nameof(characterId));
        if (steps == null || steps.Count == 0)
            throw new ArgumentException("At least one step is required.", nameof(steps));

        return new ChainedCheckState
        {
            CheckId = checkId,
            CharacterId = characterId,
            ChainName = chainName,
            Steps = steps.ToList(),
            CurrentStepIndex = 0,
            StepResults = new List<ChainedStepResult>(),
            RetriesRemaining = steps.Select(s => s.MaxRetries).ToList(),
            Status = ChainedCheckStatus.NotStarted,
            StartedAt = DateTime.UtcNow,
            TargetId = targetId
        };
    }

    /// <summary>
    /// Gets the current step to process.
    /// </summary>
    /// <returns>The current step, or null if chain is complete.</returns>
    public ChainedCheckStep? GetCurrentStep()
    {
        if (CurrentStepIndex >= Steps.Count)
            return null;

        return Steps[CurrentStepIndex];
    }

    /// <summary>
    /// Records the result of a step attempt and advances state.
    /// </summary>
    /// <param name="result">The skill check result for this step.</param>
    /// <param name="wasRetry">Whether this was a retry attempt.</param>
    public void RecordStepResult(SkillCheckResult result, bool wasRetry = false)
    {
        var step = Steps[CurrentStepIndex];
        var stepResult = new ChainedStepResult(
            StepId: step.StepId,
            StepIndex: CurrentStepIndex,
            CheckResult: result,
            AttemptNumber: wasRetry ? step.MaxRetries - RetriesRemaining[CurrentStepIndex] + 1 : 1,
            WasRetry: wasRetry);

        StepResults.Add(stepResult);

        if (result.Outcome >= SkillOutcome.MarginalSuccess)
        {
            // Step succeeded - advance to next
            CurrentStepIndex++;
            Status = CurrentStepIndex >= Steps.Count
                ? ChainedCheckStatus.Succeeded
                : ChainedCheckStatus.InProgress;

            if (Status == ChainedCheckStatus.Succeeded)
            {
                CompletedAt = DateTime.UtcNow;
            }
        }
        else
        {
            // Step failed
            if (RetriesRemaining[CurrentStepIndex] > 0)
            {
                RetriesRemaining[CurrentStepIndex]--;
                Status = ChainedCheckStatus.AwaitingRetry;
            }
            else
            {
                Status = ChainedCheckStatus.Failed;
                CompletedAt = DateTime.UtcNow;
            }
        }
    }

    /// <summary>
    /// Checks if a retry is available for the current step.
    /// </summary>
    /// <returns>True if retries remain and status is AwaitingRetry.</returns>
    public bool CanRetry()
    {
        return Status == ChainedCheckStatus.AwaitingRetry &&
               CurrentStepIndex < Steps.Count &&
               RetriesRemaining[CurrentStepIndex] > 0;
    }

    /// <summary>
    /// Abandons the chain, marking it as failed.
    /// </summary>
    public void Abandon()
    {
        if (Status == ChainedCheckStatus.Succeeded || Status == ChainedCheckStatus.Failed)
            return;

        Status = ChainedCheckStatus.Failed;
        CompletedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Gets the total number of attempts across all steps.
    /// </summary>
    public int TotalAttempts => StepResults.Count;

    /// <summary>
    /// Gets the number of successful steps.
    /// </summary>
    public int SuccessfulSteps => StepResults
        .Where(r => r.CheckResult.Outcome >= SkillOutcome.MarginalSuccess)
        .GroupBy(r => r.StepIndex)
        .Count();

    /// <summary>
    /// Checks if the chain is in a terminal state.
    /// </summary>
    public bool IsComplete => Status == ChainedCheckStatus.Succeeded ||
                              Status == ChainedCheckStatus.Failed;

    /// <summary>
    /// Returns a string representation for debugging.
    /// </summary>
    public override string ToString() =>
        $"[{CheckId}] {ChainName}: Step {CurrentStepIndex + 1}/{Steps.Count} ({Status})";
}

/// <summary>
/// Records the result of a single step attempt within a chain.
/// </summary>
/// <param name="StepId">The step's identifier.</param>
/// <param name="StepIndex">Index of the step in the chain.</param>
/// <param name="CheckResult">The skill check result.</param>
/// <param name="AttemptNumber">Which attempt this was (1 = first try).</param>
/// <param name="WasRetry">Whether this was a retry attempt.</param>
public readonly record struct ChainedStepResult(
    string StepId,
    int StepIndex,
    SkillCheckResult CheckResult,
    int AttemptNumber,
    bool WasRetry);
```

---

## 9. IExtendedSkillCheckService Interface

### 9.1 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IExtendedSkillCheckService.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for handling cooperative and chained skill checks.
/// </summary>
/// <remarks>
/// <para>
/// This service extends the basic skill check functionality with two advanced mechanics:
/// </para>
/// <list type="bullet">
///   <item><description>Cooperative checks: Multiple participants working together</description></item>
///   <item><description>Chained checks: Sequential multi-step procedures</description></item>
/// </list>
/// <para>
/// Both mechanics integrate with master abilities from v0.15.1c and skill context
/// modifiers from v0.15.1a.
/// </para>
/// </remarks>
public interface IExtendedSkillCheckService
{
    #region Cooperative Checks

    /// <summary>
    /// Resolves a cooperative skill check with multiple participants.
    /// </summary>
    /// <param name="participantIds">IDs of participating characters.</param>
    /// <param name="skillId">The skill used for the check.</param>
    /// <param name="difficultyClass">The DC to meet or exceed.</param>
    /// <param name="cooperationType">How participants combine their efforts.</param>
    /// <param name="subType">Optional skill subtype for master ability filtering.</param>
    /// <param name="context">Optional shared context for all participants.</param>
    /// <returns>The cooperative check result.</returns>
    /// <exception cref="ArgumentException">
    /// Thrown when participantIds is empty or contains invalid IDs.
    /// </exception>
    CooperativeCheckResult ResolveCooperativeCheck(
        IReadOnlyList<string> participantIds,
        string skillId,
        int difficultyClass,
        CooperationType cooperationType,
        string? subType = null,
        SkillContext? context = null);

    /// <summary>
    /// Resolves a cooperative check with per-participant contexts.
    /// </summary>
    /// <param name="participants">Participant IDs with their individual contexts.</param>
    /// <param name="skillId">The skill used for the check.</param>
    /// <param name="difficultyClass">The DC to meet or exceed.</param>
    /// <param name="cooperationType">How participants combine their efforts.</param>
    /// <param name="subType">Optional skill subtype.</param>
    /// <returns>The cooperative check result.</returns>
    CooperativeCheckResult ResolveCooperativeCheckWithContexts(
        IReadOnlyList<(string ParticipantId, SkillContext? Context)> participants,
        string skillId,
        int difficultyClass,
        CooperationType cooperationType,
        string? subType = null);

    #endregion

    #region Chained Checks

    /// <summary>
    /// Starts a new chained skill check.
    /// </summary>
    /// <param name="characterId">The character performing the chain.</param>
    /// <param name="chainName">Display name for the chain.</param>
    /// <param name="steps">The steps in sequence.</param>
    /// <param name="targetId">Optional target identifier.</param>
    /// <returns>The initial chain state, ready for first step.</returns>
    ChainedCheckState StartChainedCheck(
        string characterId,
        string chainName,
        IReadOnlyList<ChainedCheckStep> steps,
        string? targetId = null);

    /// <summary>
    /// Processes the current step of a chained check.
    /// </summary>
    /// <param name="checkId">The chain's unique identifier.</param>
    /// <param name="stepContext">Optional context overriding the step's default.</param>
    /// <returns>Result containing updated state and step outcome.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the chain is not in a processable state.
    /// </exception>
    ChainedCheckProcessResult ProcessChainStep(
        string checkId,
        SkillContext? stepContext = null);

    /// <summary>
    /// Retries the current failed step of a chained check.
    /// </summary>
    /// <param name="checkId">The chain's unique identifier.</param>
    /// <param name="stepContext">Optional context for the retry.</param>
    /// <returns>Result containing updated state and step outcome.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown when no retry is available.
    /// </exception>
    ChainedCheckProcessResult RetryChainStep(
        string checkId,
        SkillContext? stepContext = null);

    /// <summary>
    /// Abandons a chained check in progress.
    /// </summary>
    /// <param name="checkId">The chain's unique identifier.</param>
    /// <returns>The final abandoned state.</returns>
    ChainedCheckState AbandonChain(string checkId);

    /// <summary>
    /// Gets the current state of a chained check.
    /// </summary>
    /// <param name="checkId">The chain's unique identifier.</param>
    /// <returns>The chain state, or null if not found.</returns>
    ChainedCheckState? GetChainState(string checkId);

    /// <summary>
    /// Gets all active chains for a character.
    /// </summary>
    /// <param name="characterId">The character's ID.</param>
    /// <returns>Collection of active chain states.</returns>
    IReadOnlyList<ChainedCheckState> GetActiveChainsForCharacter(string characterId);

    #endregion
}

/// <summary>
/// Result of processing a step in a chained check.
/// </summary>
/// <param name="State">The updated chain state.</param>
/// <param name="StepResult">The skill check result for this step.</param>
/// <param name="IsChainComplete">Whether the chain has reached a terminal state.</param>
/// <param name="Message">Display message for the result.</param>
public readonly record struct ChainedCheckProcessResult(
    ChainedCheckState State,
    SkillCheckResult StepResult,
    bool IsChainComplete,
    string Message);
```

---

## 10. ExtendedSkillCheckService Implementation

### 10.1 Service Implementation

**File:** `src/Core/RuneAndRust.Application/Services/ExtendedSkillCheckService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Handles cooperative and chained skill checks.
/// </summary>
/// <remarks>
/// <para>
/// This service orchestrates complex skill check scenarios:
/// </para>
/// <list type="bullet">
///   <item><description>Cooperative: Multiple participants with various combination methods</description></item>
///   <item><description>Chained: Sequential multi-step procedures with retry logic</description></item>
/// </list>
/// </remarks>
public sealed class ExtendedSkillCheckService : IExtendedSkillCheckService
{
    private readonly ISkillCheckService _skillCheckService;
    private readonly IMasterAbilityService _masterAbilityService;
    private readonly IChainedCheckRepository _chainRepository;
    private readonly IPlayerRepository _playerRepository;
    private readonly ILogger<ExtendedSkillCheckService> _logger;

    /// <summary>
    /// Creates a new extended skill check service.
    /// </summary>
    public ExtendedSkillCheckService(
        ISkillCheckService skillCheckService,
        IMasterAbilityService masterAbilityService,
        IChainedCheckRepository chainRepository,
        IPlayerRepository playerRepository,
        ILogger<ExtendedSkillCheckService> logger)
    {
        _skillCheckService = skillCheckService;
        _masterAbilityService = masterAbilityService;
        _chainRepository = chainRepository;
        _playerRepository = playerRepository;
        _logger = logger;
    }

    #region Cooperative Checks

    /// <inheritdoc />
    public CooperativeCheckResult ResolveCooperativeCheck(
        IReadOnlyList<string> participantIds,
        string skillId,
        int difficultyClass,
        CooperationType cooperationType,
        string? subType = null,
        SkillContext? context = null)
    {
        var participants = participantIds
            .Select(id => (ParticipantId: id, Context: context))
            .ToList();

        return ResolveCooperativeCheckWithContexts(
            participants, skillId, difficultyClass, cooperationType, subType);
    }

    /// <inheritdoc />
    public CooperativeCheckResult ResolveCooperativeCheckWithContexts(
        IReadOnlyList<(string ParticipantId, SkillContext? Context)> participants,
        string skillId,
        int difficultyClass,
        CooperationType cooperationType,
        string? subType = null)
    {
        if (participants.Count == 0)
            throw new ArgumentException("At least one participant is required.", nameof(participants));

        _logger.LogDebug(
            "Resolving {CooperationType} check for {ParticipantCount} participants, skill {SkillId} DC {DC}",
            cooperationType, participants.Count, skillId, difficultyClass);

        return cooperationType switch
        {
            CooperationType.WeakestLink => ResolveWeakestLink(participants, skillId, difficultyClass, subType),
            CooperationType.BestAttempt => ResolveBestAttempt(participants, skillId, difficultyClass, subType),
            CooperationType.Combined => ResolveCombined(participants, skillId, difficultyClass, subType),
            CooperationType.Assisted => ResolveAssisted(participants, skillId, difficultyClass, subType),
            _ => throw new ArgumentOutOfRangeException(nameof(cooperationType))
        };
    }

    private CooperativeCheckResult ResolveWeakestLink(
        IReadOnlyList<(string ParticipantId, SkillContext? Context)> participants,
        string skillId,
        int difficultyClass,
        string? subType)
    {
        // Find participant with lowest pool
        var poolsWithPlayers = new List<(string ParticipantId, Player Player, int Pool, SkillContext? Context)>();

        foreach (var (participantId, context) in participants)
        {
            var player = _playerRepository.GetById(participantId)
                ?? throw new InvalidOperationException($"Player {participantId} not found.");

            var pool = CalculateDicePool(player, skillId, context);
            poolsWithPlayers.Add((participantId, player, pool, context));
        }

        var weakest = poolsWithPlayers.MinBy(p => p.Pool)!;

        _logger.LogDebug(
            "WeakestLink: {PlayerId} has lowest pool ({Pool}d10)",
            weakest.ParticipantId, weakest.Pool);

        // Perform check for weakest
        var result = _skillCheckService.PerformCheckWithDC(
            weakest.Player, skillId, difficultyClass,
            context: weakest.Context, subType: subType);

        return new CooperativeCheckResult(
            CooperationType: CooperationType.WeakestLink,
            ParticipantIds: participants.Select(p => p.ParticipantId).ToList(),
            SkillId: skillId,
            SubType: subType,
            DifficultyClass: difficultyClass,
            FinalOutcome: result.Outcome,
            FinalNetSuccesses: result.DiceResult?.NetSuccesses ?? 0,
            ActiveRollerId: weakest.ParticipantId,
            IndividualResults: new[] { result },
            ContributingParticipants: new[] { weakest.ParticipantId });
    }

    private CooperativeCheckResult ResolveBestAttempt(
        IReadOnlyList<(string ParticipantId, SkillContext? Context)> participants,
        string skillId,
        int difficultyClass,
        string? subType)
    {
        var results = new List<(string ParticipantId, SkillCheckResult Result)>();

        foreach (var (participantId, context) in participants)
        {
            var player = _playerRepository.GetById(participantId)
                ?? throw new InvalidOperationException($"Player {participantId} not found.");

            var result = _skillCheckService.PerformCheckWithDC(
                player, skillId, difficultyClass,
                context: context, subType: subType);

            results.Add((participantId, result));
        }

        // Find best result
        var best = results.MaxBy(r => r.Result.DiceResult?.NetSuccesses ?? -100)!;

        _logger.LogDebug(
            "BestAttempt: {PlayerId} had best result ({Net} net)",
            best.ParticipantId, best.Result.DiceResult?.NetSuccesses ?? 0);

        return new CooperativeCheckResult(
            CooperationType: CooperationType.BestAttempt,
            ParticipantIds: participants.Select(p => p.ParticipantId).ToList(),
            SkillId: skillId,
            SubType: subType,
            DifficultyClass: difficultyClass,
            FinalOutcome: best.Result.Outcome,
            FinalNetSuccesses: best.Result.DiceResult?.NetSuccesses ?? 0,
            ActiveRollerId: best.ParticipantId,
            IndividualResults: results.Select(r => r.Result).ToList(),
            ContributingParticipants: new[] { best.ParticipantId });
    }

    private CooperativeCheckResult ResolveCombined(
        IReadOnlyList<(string ParticipantId, SkillContext? Context)> participants,
        string skillId,
        int difficultyClass,
        string? subType)
    {
        var results = new List<(string ParticipantId, SkillCheckResult Result)>();
        var totalNetSuccesses = 0;
        var contributors = new List<string>();

        foreach (var (participantId, context) in participants)
        {
            var player = _playerRepository.GetById(participantId)
                ?? throw new InvalidOperationException($"Player {participantId} not found.");

            var result = _skillCheckService.PerformCheckWithDC(
                player, skillId, difficultyClass,
                context: context, subType: subType);

            results.Add((participantId, result));

            var net = result.DiceResult?.NetSuccesses ?? 0;
            totalNetSuccesses += net;

            if (net > 0)
                contributors.Add(participantId);
        }

        // Classify combined result
        var finalOutcome = ClassifyCombinedOutcome(totalNetSuccesses, difficultyClass);

        _logger.LogDebug(
            "Combined: Total {Net} net successes from {Contributors} contributors",
            totalNetSuccesses, contributors.Count);

        return new CooperativeCheckResult(
            CooperationType: CooperationType.Combined,
            ParticipantIds: participants.Select(p => p.ParticipantId).ToList(),
            SkillId: skillId,
            SubType: subType,
            DifficultyClass: difficultyClass,
            FinalOutcome: finalOutcome,
            FinalNetSuccesses: totalNetSuccesses,
            IndividualResults: results.Select(r => r.Result).ToList(),
            ContributingParticipants: contributors);
    }

    private CooperativeCheckResult ResolveAssisted(
        IReadOnlyList<(string ParticipantId, SkillContext? Context)> participants,
        string skillId,
        int difficultyClass,
        string? subType)
    {
        if (participants.Count < 1)
            throw new ArgumentException("Assisted check requires at least one participant.", nameof(participants));

        var (primaryId, primaryContext) = participants[0];
        var primaryPlayer = _playerRepository.GetById(primaryId)
            ?? throw new InvalidOperationException($"Player {primaryId} not found.");

        var helpers = participants.Skip(1).ToList();
        var helperContributions = new List<HelperContribution>();
        var bonusDice = 0;

        // Roll for each helper to determine bonus
        foreach (var (helperId, helperContext) in helpers)
        {
            var helper = _playerRepository.GetById(helperId)
                ?? throw new InvalidOperationException($"Player {helperId} not found.");

            // Helpers make a simple check (no DC, just looking for 2+ net)
            var helperResult = _skillCheckService.PerformCheck(
                helper, skillId, context: helperContext, subType: subType);

            var helperNet = helperResult.DiceResult?.NetSuccesses ?? 0;
            var grantsBonus = helperNet >= 2;

            helperContributions.Add(new HelperContribution(helperId, helperNet, grantsBonus));

            if (grantsBonus)
                bonusDice++;
        }

        _logger.LogDebug(
            "Assisted: {BonusDice} bonus dice from {HelperCount} helpers",
            bonusDice, helpers.Count);

        // Build context with helper bonus
        var assistedContext = primaryContext ?? SkillContext.Empty;
        if (bonusDice > 0)
        {
            assistedContext = assistedContext.WithHelperBonus(bonusDice, helperContributions.Count(h => h.GrantedBonus));
        }

        // Primary makes the check with bonus
        var primaryResult = _skillCheckService.PerformCheckWithDC(
            primaryPlayer, skillId, difficultyClass,
            context: assistedContext, subType: subType);

        return new CooperativeCheckResult(
            CooperationType: CooperationType.Assisted,
            ParticipantIds: participants.Select(p => p.ParticipantId).ToList(),
            SkillId: skillId,
            SubType: subType,
            DifficultyClass: difficultyClass,
            FinalOutcome: primaryResult.Outcome,
            FinalNetSuccesses: primaryResult.DiceResult?.NetSuccesses ?? 0,
            ActiveRollerId: primaryId,
            IndividualResults: new[] { primaryResult },
            HelperBonuses: helperContributions,
            ContributingParticipants: new[] { primaryId }
                .Concat(helperContributions.Where(h => h.GrantedBonus).Select(h => h.HelperId))
                .ToList());
    }

    private int CalculateDicePool(Player player, string skillId, SkillContext? context)
    {
        // Calculate base pool from player stats
        var skill = player.GetSkillProficiency(skillId);
        var attribute = player.GetAttributeForSkill(skillId);
        var basePool = (int)skill + attribute;

        // Add context modifiers
        var contextBonus = context?.TotalDiceModifier ?? 0;

        return Math.Max(1, basePool + contextBonus);
    }

    private static SkillOutcome ClassifyCombinedOutcome(int totalNet, int dc)
    {
        var margin = totalNet - dc;

        return margin switch
        {
            < 0 when totalNet == 0 => SkillOutcome.CriticalFailure,
            < 0 => SkillOutcome.Failure,
            0 => SkillOutcome.MarginalSuccess,
            1 or 2 => SkillOutcome.FullSuccess,
            3 or 4 => SkillOutcome.ExceptionalSuccess,
            >= 5 => SkillOutcome.CriticalSuccess
        };
    }

    #endregion

    #region Chained Checks

    /// <inheritdoc />
    public ChainedCheckState StartChainedCheck(
        string characterId,
        string chainName,
        IReadOnlyList<ChainedCheckStep> steps,
        string? targetId = null)
    {
        var checkId = $"chain-{Guid.NewGuid():N}";

        var state = ChainedCheckState.Create(
            checkId, characterId, chainName, steps, targetId);

        _chainRepository.Add(state);

        _logger.LogInformation(
            "Started chained check {CheckId} '{ChainName}' for character {CharacterId} with {StepCount} steps",
            checkId, chainName, characterId, steps.Count);

        return state;
    }

    /// <inheritdoc />
    public ChainedCheckProcessResult ProcessChainStep(
        string checkId,
        SkillContext? stepContext = null)
    {
        var state = _chainRepository.GetById(checkId)
            ?? throw new InvalidOperationException($"Chain {checkId} not found.");

        if (state.Status == ChainedCheckStatus.Succeeded ||
            state.Status == ChainedCheckStatus.Failed)
        {
            throw new InvalidOperationException($"Chain {checkId} is already complete.");
        }

        if (state.Status == ChainedCheckStatus.AwaitingRetry)
        {
            throw new InvalidOperationException(
                $"Chain {checkId} is awaiting retry decision. Use RetryChainStep or AbandonChain.");
        }

        var step = state.GetCurrentStep()
            ?? throw new InvalidOperationException($"Chain {checkId} has no remaining steps.");

        var player = _playerRepository.GetById(state.CharacterId)
            ?? throw new InvalidOperationException($"Player {state.CharacterId} not found.");

        // Update status to InProgress if just starting
        if (state.Status == ChainedCheckStatus.NotStarted)
        {
            // State will be updated by RecordStepResult
        }

        // Determine context (step context, override, or empty)
        var context = stepContext ?? step.Context ?? SkillContext.Empty;

        // Perform the step check
        var result = _skillCheckService.PerformCheckWithDC(
            player, step.SkillId, step.DifficultyClass,
            difficultyName: step.DifficultyName,
            context: context,
            subType: step.SubType);

        // Record result and update state
        state.RecordStepResult(result, wasRetry: false);
        _chainRepository.Update(state);

        // Build message
        var message = BuildStepMessage(state, step, result);

        _logger.LogDebug(
            "Chain {CheckId} step {StepIndex} ({StepName}): {Outcome}",
            checkId, state.CurrentStepIndex, step.Name, result.Outcome);

        return new ChainedCheckProcessResult(
            State: state,
            StepResult: result,
            IsChainComplete: state.IsComplete,
            Message: message);
    }

    /// <inheritdoc />
    public ChainedCheckProcessResult RetryChainStep(
        string checkId,
        SkillContext? stepContext = null)
    {
        var state = _chainRepository.GetById(checkId)
            ?? throw new InvalidOperationException($"Chain {checkId} not found.");

        if (!state.CanRetry())
        {
            throw new InvalidOperationException($"Chain {checkId} cannot be retried.");
        }

        var step = state.GetCurrentStep()!;
        var player = _playerRepository.GetById(state.CharacterId)
            ?? throw new InvalidOperationException($"Player {state.CharacterId} not found.");

        var context = stepContext ?? step.Context ?? SkillContext.Empty;

        var result = _skillCheckService.PerformCheckWithDC(
            player, step.SkillId, step.DifficultyClass,
            difficultyName: step.DifficultyName,
            context: context,
            subType: step.SubType);

        state.RecordStepResult(result, wasRetry: true);
        _chainRepository.Update(state);

        var message = BuildStepMessage(state, step, result);

        _logger.LogDebug(
            "Chain {CheckId} step {StepIndex} ({StepName}) RETRY: {Outcome}",
            checkId, state.CurrentStepIndex, step.Name, result.Outcome);

        return new ChainedCheckProcessResult(
            State: state,
            StepResult: result,
            IsChainComplete: state.IsComplete,
            Message: message);
    }

    /// <inheritdoc />
    public ChainedCheckState AbandonChain(string checkId)
    {
        var state = _chainRepository.GetById(checkId)
            ?? throw new InvalidOperationException($"Chain {checkId} not found.");

        state.Abandon();
        _chainRepository.Update(state);

        _logger.LogInformation("Chain {CheckId} abandoned by player", checkId);

        return state;
    }

    /// <inheritdoc />
    public ChainedCheckState? GetChainState(string checkId)
    {
        return _chainRepository.GetById(checkId);
    }

    /// <inheritdoc />
    public IReadOnlyList<ChainedCheckState> GetActiveChainsForCharacter(string characterId)
    {
        return _chainRepository.GetActiveByCharacterId(characterId);
    }

    private static string BuildStepMessage(
        ChainedCheckState state,
        ChainedCheckStep step,
        SkillCheckResult result)
    {
        if (result.Outcome >= SkillOutcome.MarginalSuccess)
        {
            if (state.Status == ChainedCheckStatus.Succeeded)
            {
                return step.SuccessMessage ?? $"{step.Name} succeeded. {state.ChainName} complete!";
            }
            return step.SuccessMessage ?? $"{step.Name} succeeded. Proceed to next step.";
        }

        if (state.CanRetry())
        {
            return step.FailureMessage ??
                $"{step.Name} failed. {state.RetriesRemaining[state.CurrentStepIndex]} retry(ies) remaining.";
        }

        return step.FailureMessage ?? $"{step.Name} failed. {state.ChainName} cannot continue.";
    }

    #endregion
}
```

---

## 11. IChainedCheckRepository Interface

### 11.1 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IChainedCheckRepository.cs`

```csharp
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Repository for persisting chained check state.
/// </summary>
/// <remarks>
/// Chained checks may span multiple turns or game sessions, so their state
/// needs to be persisted between processing steps.
/// </remarks>
public interface IChainedCheckRepository
{
    /// <summary>
    /// Adds a new chained check state.
    /// </summary>
    /// <param name="state">The state to add.</param>
    void Add(ChainedCheckState state);

    /// <summary>
    /// Updates an existing chained check state.
    /// </summary>
    /// <param name="state">The state to update.</param>
    void Update(ChainedCheckState state);

    /// <summary>
    /// Gets a chained check state by its ID.
    /// </summary>
    /// <param name="checkId">The check's unique identifier.</param>
    /// <returns>The state if found; otherwise null.</returns>
    ChainedCheckState? GetById(string checkId);

    /// <summary>
    /// Gets all active (non-complete) chains for a character.
    /// </summary>
    /// <param name="characterId">The character's ID.</param>
    /// <returns>Collection of active chain states.</returns>
    IReadOnlyList<ChainedCheckState> GetActiveByCharacterId(string characterId);

    /// <summary>
    /// Removes a completed or abandoned chain.
    /// </summary>
    /// <param name="checkId">The check's unique identifier.</param>
    void Remove(string checkId);

    /// <summary>
    /// Removes all chains for a character.
    /// </summary>
    /// <param name="characterId">The character's ID.</param>
    void RemoveAllForCharacter(string characterId);
}
```

---

## 12. InMemoryChainedCheckRepository Implementation

### 12.1 Repository Implementation

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Repositories/InMemoryChainedCheckRepository.cs`

```csharp
using System.Collections.Concurrent;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Infrastructure.Repositories;

/// <summary>
/// In-memory implementation of chained check state persistence.
/// </summary>
/// <remarks>
/// Stores chain states in memory. State is lost when the application restarts.
/// For persistent storage, implement a database-backed repository.
/// </remarks>
public sealed class InMemoryChainedCheckRepository : IChainedCheckRepository
{
    private readonly ConcurrentDictionary<string, ChainedCheckState> _chains = new();

    /// <inheritdoc />
    public void Add(ChainedCheckState state)
    {
        if (state == null)
            throw new ArgumentNullException(nameof(state));

        if (!_chains.TryAdd(state.CheckId, state))
        {
            throw new InvalidOperationException(
                $"Chain with ID {state.CheckId} already exists.");
        }
    }

    /// <inheritdoc />
    public void Update(ChainedCheckState state)
    {
        if (state == null)
            throw new ArgumentNullException(nameof(state));

        _chains[state.CheckId] = state;
    }

    /// <inheritdoc />
    public ChainedCheckState? GetById(string checkId)
    {
        if (string.IsNullOrWhiteSpace(checkId))
            return null;

        return _chains.TryGetValue(checkId, out var state) ? state : null;
    }

    /// <inheritdoc />
    public IReadOnlyList<ChainedCheckState> GetActiveByCharacterId(string characterId)
    {
        if (string.IsNullOrWhiteSpace(characterId))
            return Array.Empty<ChainedCheckState>();

        return _chains.Values
            .Where(c => c.CharacterId == characterId && !c.IsComplete)
            .ToList()
            .AsReadOnly();
    }

    /// <inheritdoc />
    public void Remove(string checkId)
    {
        if (!string.IsNullOrWhiteSpace(checkId))
        {
            _chains.TryRemove(checkId, out _);
        }
    }

    /// <inheritdoc />
    public void RemoveAllForCharacter(string characterId)
    {
        if (string.IsNullOrWhiteSpace(characterId))
            return;

        var toRemove = _chains.Values
            .Where(c => c.CharacterId == characterId)
            .Select(c => c.CheckId)
            .ToList();

        foreach (var checkId in toRemove)
        {
            _chains.TryRemove(checkId, out _);
        }
    }
}
```

---

## 13. Data Model Changes

### 13.1 Summary of Changes

| Entity/Type | Change Type | Description |
|-------------|-------------|-------------|
| `CooperationType` | **NEW** | Enum for cooperation classification (4 values) |
| `ChainedCheckStatus` | **NEW** | Enum for chain progress tracking (5 values) |
| `CooperativeCheckResult` | **NEW** | Value object for cooperative check results |
| `ChainedCheckStep` | **NEW** | Value object for step configuration |
| `ChainedStepResult` | **NEW** | Value object for step result recording |
| `HelperContribution` | **NEW** | Value object for assisted check helpers |
| `ChainedCheckState` | **NEW** | Entity for tracking chain state |
| `SkillContext` | **MODIFIED** | Added `WithHelperBonus` method |

### 13.2 SkillContext Modification

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SkillContext.cs` (addition)

```csharp
/// <summary>
/// Creates a new context with helper bonus dice from an assisted check.
/// </summary>
/// <param name="bonusDice">Number of bonus dice from helpers.</param>
/// <param name="helperCount">Number of helpers who contributed.</param>
/// <returns>A new context with the helper modifier added.</returns>
public SkillContext WithHelperBonus(int bonusDice, int helperCount)
{
    if (bonusDice == 0)
        return this;

    var modifier = new SituationalModifier(
        ModifierId: "helper-bonus",
        DiceModifier: bonusDice,
        DcModifier: 0,
        Source: $"{helperCount} helper(s)",
        Duration: ModifierDuration.Instant);

    return this with
    {
        SituationalModifiers = SituationalModifiers.Append(modifier).ToList()
    };
}
```

---

## 14. Configuration

### 14.1 No New Configuration Files

v0.15.1d does not introduce new configuration files. Cooperative and chained check parameters are defined in code or passed at runtime.

Future versions may add configuration for:
- Default cooperation types per skill
- Pre-defined chain templates (e.g., "terminal-hacking-basic")
- Retry limits per skill or difficulty tier

---

## 15. Commands

### 15.1 No New User Commands

v0.15.1d provides service-level infrastructure. User-facing commands for cooperative and chained checks are introduced in skill-specific versions:

- v0.15.2: `stealth` (party stealth → WeakestLink)
- v0.15.3: `negotiate` (multi-phase → Chained)
- v0.15.4: `hack` (terminal layers → Chained)
- v0.15.5: `track` (pursuit phases → Chained)

### 15.2 Internal Service Usage

```csharp
// Example: Party stealth check
var result = _extendedService.ResolveCooperativeCheck(
    participantIds: new[] { "player-a", "player-b", "player-c" },
    skillId: "acrobatics",
    difficultyClass: 2,
    cooperationType: CooperationType.WeakestLink,
    subType: "stealth");

// Example: Terminal hacking chain
var state = _extendedService.StartChainedCheck(
    characterId: "player-1",
    chainName: "Terminal Hacking",
    steps: new[]
    {
        ChainedCheckStep.Create("access", "Access", "system-bypass", dc: 2),
        ChainedCheckStep.Create("auth", "Authentication", "system-bypass", dc: 3, retries: 1),
        ChainedCheckStep.Create("nav", "Navigation", "system-bypass", dc: 2)
    },
    targetId: "terminal-001");

// Process each step
var stepResult = _extendedService.ProcessChainStep(state.CheckId);
```

---

## 16. User-Facing Changes

### 16.1 Cooperative Check Display (WeakestLink - Party Stealth)

```
╔═══════════════════════════════════════════════════════════════════════════════╗
║                         PARTY STEALTH CHECK                                    ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  Cooperation Type: Weakest Link                                              ║
║  "The chain is only as strong as its weakest link"                           ║
║                                                                               ║
║  ┌───────────────────────────────────────────────────────────────────────┐   ║
║  │  PARTICIPANTS                                                          │   ║
║  │                                                                        │   ║
║  │  Aldric     FINESSE 3 + Acrobatics 2 = 5d10                           │   ║
║  │  Brynja     FINESSE 2 + Acrobatics 1 = 3d10  ◄ ROLLING (lowest pool) │   ║
║  │  Cormac     FINESSE 4 + Acrobatics 3 = 7d10                           │   ║
║  └───────────────────────────────────────────────────────────────────────┘   ║
║                                                                               ║
║  Brynja rolls: 3d10 → [8] [9] [4]                                           ║
║  Successes: 2  |  Botches: 0  |  Net: 2                                     ║
║  DC: 2  |  Margin: 0                                                         ║
║                                                                               ║
║  Result: MARGINAL SUCCESS                                                    ║
║                                                                               ║
║  The party moves through the corridor, barely avoiding detection.           ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
```

### 16.2 Cooperative Check Display (Assisted)

```
╔═══════════════════════════════════════════════════════════════════════════════╗
║                         ASSISTED LOCKPICKING                                   ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  Cooperation Type: Assisted                                                  ║
║  Primary: Aldric (lockpicking)                                               ║
║                                                                               ║
║  ┌───────────────────────────────────────────────────────────────────────┐   ║
║  │  HELPER CONTRIBUTIONS                                                  │   ║
║  │                                                                        │   ║
║  │  Brynja (lookout):  3d10 → 2 net successes  ✓ +1d10 bonus             │   ║
║  │  Cormac (tools):    4d10 → 1 net success    ✗ no bonus                │   ║
║  └───────────────────────────────────────────────────────────────────────┘   ║
║                                                                               ║
║  Aldric's pool: 5d10 (base) + 1d10 (Brynja) = 6d10                          ║
║                                                                               ║
║  Roll: [10] [8] [9] [4] [3] [2]                                             ║
║  Successes: 3  |  Botches: 0  |  Net: 3                                     ║
║  DC: 3  |  Margin: 0                                                         ║
║                                                                               ║
║  Result: MARGINAL SUCCESS                                                    ║
║                                                                               ║
║  The lock clicks open. Brynja's watchful eye kept you from being surprised. ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
```

### 16.3 Chained Check Display (Terminal Hacking)

```
╔═══════════════════════════════════════════════════════════════════════════════╗
║                         TERMINAL HACKING                                       ║
║                         Target: Security Terminal A-7                          ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  ┌───────────────────────────────────────────────────────────────────────┐   ║
║  │  PROGRESS                                                              │   ║
║  │                                                                        │   ║
║  │  [✓] Step 1: Access          DC 2  ──────────────────  SUCCESS        │   ║
║  │  [◆] Step 2: Authentication  DC 3  ──────────────────  IN PROGRESS    │   ║
║  │  [ ] Step 3: Navigation      DC 2  ──────────────────  PENDING        │   ║
║  └───────────────────────────────────────────────────────────────────────┘   ║
║                                                                               ║
║  ─────────────────────────────────────────────────────────────────────────   ║
║                                                                               ║
║  STEP 2: AUTHENTICATION                                                      ║
║  System Bypass DC 3 (1 retry available)                                      ║
║                                                                               ║
║  Roll: 4d10 → [1] [4] [5] [6]                                               ║
║  Successes: 0  |  Botches: 1  |  Net: 0                                     ║
║                                                                               ║
║  Result: CRITICAL FAILURE (FUMBLE)                                          ║
║                                                                               ║
║  ┌───────────────────────────────────────────────────────────────────────┐   ║
║  │  Authentication failed! Invalid credential sequence detected.          │   ║
║  │                                                                        │   ║
║  │  You may retry (1 attempt remaining) or abandon the hack.             │   ║
║  │  > retry | abandon                                                     │   ║
║  └───────────────────────────────────────────────────────────────────────┘   ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
```

### 16.4 Chained Check Display (Success)

```
╔═══════════════════════════════════════════════════════════════════════════════╗
║                         TERMINAL HACKING COMPLETE                              ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  ┌───────────────────────────────────────────────────────────────────────┐   ║
║  │  FINAL RESULTS                                                         │   ║
║  │                                                                        │   ║
║  │  [✓] Step 1: Access          DC 2  ──────  SUCCESS (1 attempt)        │   ║
║  │  [✓] Step 2: Authentication  DC 3  ──────  SUCCESS (2 attempts)       │   ║
║  │  [✓] Step 3: Navigation      DC 2  ──────  SUCCESS (1 attempt)        │   ║
║  └───────────────────────────────────────────────────────────────────────┘   ║
║                                                                               ║
║  Total Attempts: 4                                                           ║
║  Chain Status: SUCCEEDED                                                     ║
║                                                                               ║
║  You have gained admin access to Security Terminal A-7.                     ║
║  Available actions: security-logs, door-controls, camera-feed               ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
```

---

## 17. Logging Specifications

### 17.1 Log Events

| Event | Level | Template |
|-------|-------|----------|
| Cooperative check started | Debug | `"Resolving {CooperationType} check for {ParticipantCount} participants, skill {SkillId} DC {DC}"` |
| WeakestLink roller selected | Debug | `"WeakestLink: {PlayerId} has lowest pool ({Pool}d10)"` |
| BestAttempt winner selected | Debug | `"BestAttempt: {PlayerId} had best result ({Net} net)"` |
| Combined total calculated | Debug | `"Combined: Total {Net} net successes from {Contributors} contributors"` |
| Assisted bonus calculated | Debug | `"Assisted: {BonusDice} bonus dice from {HelperCount} helpers"` |
| Chain started | Information | `"Started chained check {CheckId} '{ChainName}' for character {CharacterId} with {StepCount} steps"` |
| Chain step processed | Debug | `"Chain {CheckId} step {StepIndex} ({StepName}): {Outcome}"` |
| Chain step retried | Debug | `"Chain {CheckId} step {StepIndex} ({StepName}) RETRY: {Outcome}"` |
| Chain abandoned | Information | `"Chain {CheckId} abandoned by player"` |

### 17.2 Example Log Output

```
[DBG] Resolving WeakestLink check for 3 participants, skill acrobatics DC 2
[DBG] WeakestLink: player-b has lowest pool (3d10)
[INF] Started chained check chain-abc123 'Terminal Hacking' for character player-1 with 3 steps
[DBG] Chain chain-abc123 step 0 (Access): FullSuccess
[DBG] Chain chain-abc123 step 1 (Authentication): CriticalFailure
[DBG] Chain chain-abc123 step 1 (Authentication) RETRY: FullSuccess
[DBG] Chain chain-abc123 step 2 (Navigation): FullSuccess
```

---

## 18. Unit Testing Requirements

### 18.1 Test Overview

Per the scope breakdown, ~10 unit tests are required:

| Test ID | Test Name | Description |
|---------|-----------|-------------|
| EC-001 | WeakestLink_UsesLowestPool | Cooperative WeakestLink uses lowest pool |
| EC-002 | BestAttempt_UsesHighestResult | Cooperative BestAttempt uses highest result |
| EC-003 | Combined_AddsSuccesses | Cooperative Combined adds successes |
| EC-004 | Assisted_GrantsHelperBonus | Cooperative Assisted grants helper bonus |
| EC-005 | Chained_RequiresSequentialSuccess | Chained check requires sequential success |
| EC-006 | Chained_FailsOnStepFailure | Chained check fails on step failure (no retries) |
| EC-007 | Chained_TracksProgress | Chained check tracks progress correctly |
| EC-008 | Chained_RetryAllowed | Failed step can be retried (if allowed) |
| EC-009 | Chained_CompletesOnAllStepsPass | Chained check completes when all steps pass |
| EC-010 | Chained_ContextAppliesPerStep | Context modifiers apply per-step |

### 18.2 Test Specifications

**File:** `tests/RuneAndRust.Tests/Application/Services/ExtendedSkillCheckServiceTests.cs`

```csharp
using NUnit.Framework;
using Moq;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Tests.Application.Services;

[TestFixture]
public class ExtendedSkillCheckServiceTests
{
    private Mock<ISkillCheckService> _skillCheckServiceMock;
    private Mock<IMasterAbilityService> _masterAbilityServiceMock;
    private Mock<IChainedCheckRepository> _chainRepositoryMock;
    private Mock<IPlayerRepository> _playerRepositoryMock;
    private Mock<ILogger<ExtendedSkillCheckService>> _loggerMock;
    private ExtendedSkillCheckService _service;

    [SetUp]
    public void SetUp()
    {
        _skillCheckServiceMock = new Mock<ISkillCheckService>();
        _masterAbilityServiceMock = new Mock<IMasterAbilityService>();
        _chainRepositoryMock = new Mock<IChainedCheckRepository>();
        _playerRepositoryMock = new Mock<IPlayerRepository>();
        _loggerMock = new Mock<ILogger<ExtendedSkillCheckService>>();

        _service = new ExtendedSkillCheckService(
            _skillCheckServiceMock.Object,
            _masterAbilityServiceMock.Object,
            _chainRepositoryMock.Object,
            _playerRepositoryMock.Object,
            _loggerMock.Object);
    }

    #region Cooperative Check Tests

    /// <summary>
    /// EC-001: Verifies WeakestLink uses the participant with the lowest dice pool.
    /// </summary>
    [Test]
    public void ResolveCooperativeCheck_WeakestLink_UsesLowestPool()
    {
        // Arrange
        SetupPlayersWithPools(("player-a", 5), ("player-b", 3), ("player-c", 7));
        SetupCheckResultWithNet("player-b", 2);

        // Act
        var result = _service.ResolveCooperativeCheck(
            new[] { "player-a", "player-b", "player-c" },
            "acrobatics", 2, CooperationType.WeakestLink);

        // Assert
        Assert.That(result.ActiveRollerId, Is.EqualTo("player-b"));
        Assert.That(result.CooperationType, Is.EqualTo(CooperationType.WeakestLink));
    }

    /// <summary>
    /// EC-002: Verifies BestAttempt uses the highest roll result.
    /// </summary>
    [Test]
    public void ResolveCooperativeCheck_BestAttempt_UsesHighestResult()
    {
        // Arrange
        SetupPlayersWithPools(("player-a", 5), ("player-b", 3), ("player-c", 7));
        SetupCheckResultsWithNets(("player-a", 2), ("player-b", 1), ("player-c", 4));

        // Act
        var result = _service.ResolveCooperativeCheck(
            new[] { "player-a", "player-b", "player-c" },
            "acrobatics", 2, CooperationType.BestAttempt);

        // Assert
        Assert.That(result.ActiveRollerId, Is.EqualTo("player-c"));
        Assert.That(result.FinalNetSuccesses, Is.EqualTo(4));
    }

    /// <summary>
    /// EC-003: Verifies Combined adds all net successes together.
    /// </summary>
    [Test]
    public void ResolveCooperativeCheck_Combined_AddsSuccesses()
    {
        // Arrange
        SetupPlayersWithPools(("player-a", 5), ("player-b", 3), ("player-c", 7));
        SetupCheckResultsWithNets(("player-a", 2), ("player-b", 1), ("player-c", 3));

        // Act
        var result = _service.ResolveCooperativeCheck(
            new[] { "player-a", "player-b", "player-c" },
            "might", 4, CooperationType.Combined);

        // Assert
        Assert.That(result.FinalNetSuccesses, Is.EqualTo(6)); // 2 + 1 + 3
        Assert.That(result.FinalOutcome, Is.EqualTo(SkillOutcome.FullSuccess));
    }

    /// <summary>
    /// EC-004: Verifies Assisted grants +1d10 per helper with 2+ net successes.
    /// </summary>
    [Test]
    public void ResolveCooperativeCheck_Assisted_GrantsHelperBonus()
    {
        // Arrange
        SetupPlayersWithPools(("player-a", 5), ("player-b", 3), ("player-c", 4));
        // Helper B gets 2 net (grants bonus), helper C gets 1 net (no bonus)
        SetupHelperResults(("player-b", 2), ("player-c", 1));
        SetupPrimaryWithBonus("player-a", expectedBonus: 1);

        // Act
        var result = _service.ResolveCooperativeCheck(
            new[] { "player-a", "player-b", "player-c" },
            "system-bypass", 3, CooperationType.Assisted);

        // Assert
        Assert.That(result.HelperBonuses, Has.Count.EqualTo(2));
        Assert.That(result.HelperBonuses![0].GrantedBonus, Is.True);  // player-b
        Assert.That(result.HelperBonuses![1].GrantedBonus, Is.False); // player-c
    }

    #endregion

    #region Chained Check Tests

    /// <summary>
    /// EC-005: Verifies chained check requires sequential success.
    /// </summary>
    [Test]
    public void ChainedCheck_RequiresSequentialSuccess()
    {
        // Arrange
        var steps = CreateThreeStepChain();
        var state = SetupChainState("player-1", steps);
        SetupStepSuccess();

        // Act
        var result1 = _service.ProcessChainStep(state.CheckId);

        // Assert
        Assert.That(result1.State.CurrentStepIndex, Is.EqualTo(1));
        Assert.That(result1.State.Status, Is.EqualTo(ChainedCheckStatus.InProgress));
    }

    /// <summary>
    /// EC-006: Verifies chained check fails on step failure with no retries.
    /// </summary>
    [Test]
    public void ChainedCheck_FailsOnStepFailure_NoRetries()
    {
        // Arrange
        var steps = new[] { ChainedCheckStep.Create("step1", "Step 1", "skill", 3, retries: 0) };
        var state = SetupChainState("player-1", steps);
        SetupStepFailure();

        // Act
        var result = _service.ProcessChainStep(state.CheckId);

        // Assert
        Assert.That(result.State.Status, Is.EqualTo(ChainedCheckStatus.Failed));
        Assert.That(result.IsChainComplete, Is.True);
    }

    /// <summary>
    /// EC-007: Verifies chained check tracks progress correctly.
    /// </summary>
    [Test]
    public void ChainedCheck_TracksProgress()
    {
        // Arrange
        var steps = CreateThreeStepChain();
        var state = SetupChainState("player-1", steps);
        SetupStepSuccess();

        // Act
        _service.ProcessChainStep(state.CheckId);
        _service.ProcessChainStep(state.CheckId);

        // Assert
        var currentState = _service.GetChainState(state.CheckId);
        Assert.That(currentState!.CurrentStepIndex, Is.EqualTo(2));
        Assert.That(currentState.SuccessfulSteps, Is.EqualTo(2));
    }

    /// <summary>
    /// EC-008: Verifies failed step can be retried when allowed.
    /// </summary>
    [Test]
    public void ChainedCheck_RetryAllowed_WhenRetriesRemaining()
    {
        // Arrange
        var steps = new[] { ChainedCheckStep.Create("step1", "Step 1", "skill", 3, retries: 1) };
        var state = SetupChainState("player-1", steps);
        SetupStepFailureThenSuccess();

        // Act
        var result1 = _service.ProcessChainStep(state.CheckId);
        Assert.That(result1.State.Status, Is.EqualTo(ChainedCheckStatus.AwaitingRetry));

        var result2 = _service.RetryChainStep(state.CheckId);

        // Assert
        Assert.That(result2.State.Status, Is.EqualTo(ChainedCheckStatus.Succeeded));
    }

    /// <summary>
    /// EC-009: Verifies chained check completes when all steps pass.
    /// </summary>
    [Test]
    public void ChainedCheck_Completes_WhenAllStepsPass()
    {
        // Arrange
        var steps = CreateThreeStepChain();
        var state = SetupChainState("player-1", steps);
        SetupStepSuccess();

        // Act
        _service.ProcessChainStep(state.CheckId);
        _service.ProcessChainStep(state.CheckId);
        var finalResult = _service.ProcessChainStep(state.CheckId);

        // Assert
        Assert.That(finalResult.State.Status, Is.EqualTo(ChainedCheckStatus.Succeeded));
        Assert.That(finalResult.IsChainComplete, Is.True);
    }

    /// <summary>
    /// EC-010: Verifies context modifiers apply per-step.
    /// </summary>
    [Test]
    public void ChainedCheck_ContextAppliesPerStep()
    {
        // Arrange
        var context = new SkillContextBuilder()
            .WithEquipment("toolkit", dice: 2, description: "Toolkit")
            .Build();

        var steps = new[]
        {
            new ChainedCheckStep("step1", "Step 1", "Desc", "skill", null, 3, Context: context)
        };
        var state = SetupChainState("player-1", steps);

        // Act
        _service.ProcessChainStep(state.CheckId);

        // Assert
        _skillCheckServiceMock.Verify(
            s => s.PerformCheckWithDC(
                It.IsAny<Player>(), "skill", 3,
                It.IsAny<string>(),
                It.Is<SkillContext>(c => c.TotalDiceModifier == 2),
                null),
            Times.Once);
    }

    #endregion

    // Helper methods for test setup
    private IReadOnlyList<ChainedCheckStep> CreateThreeStepChain() =>
        new[]
        {
            ChainedCheckStep.Create("step1", "Step 1", "skill", 2),
            ChainedCheckStep.Create("step2", "Step 2", "skill", 2),
            ChainedCheckStep.Create("step3", "Step 3", "skill", 2)
        };

    // Additional helper methods omitted for brevity...
}
```

---

## 19. Use Cases

### 19.1 Use Case 1: Party Stealth (WeakestLink)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: Party Stealth (WeakestLink)                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ACTOR: Party of 3 characters                                               │
│                                                                              │
│  PRECONDITIONS:                                                             │
│  - All party members present                                                │
│  - Stealth check required to pass guards                                    │
│                                                                              │
│  FLOW:                                                                       │
│  1. System identifies party stealth scenario                                │
│  2. ExtendedSkillCheckService.ResolveCooperativeCheck called               │
│  3. CooperationType.WeakestLink selected                                    │
│  4. Service calculates dice pools for all participants                     │
│  5. Participant with lowest pool identified (3d10)                         │
│  6. Only the weakest member rolls                                          │
│  7. Result determines success/failure for entire party                     │
│                                                                              │
│  POSTCONDITIONS:                                                            │
│  - If success: Party passes undetected                                      │
│  - If failure: All party members spotted                                    │
│  - No individual saves for other members                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 19.2 Use Case 2: Group Search (BestAttempt)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: Group Search (BestAttempt)                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ACTOR: Party of 3 characters                                               │
│                                                                              │
│  PRECONDITIONS:                                                             │
│  - Party searching a room for hidden clue                                   │
│  - Only one person needs to find it                                         │
│                                                                              │
│  FLOW:                                                                       │
│  1. Party initiates group search                                            │
│  2. CooperationType.BestAttempt selected                                    │
│  3. Each participant rolls their perception check                          │
│  4. Individual results: A → 2 net, B → 1 net, C → 4 net                   │
│  5. Best result (C's 4 net) used for final outcome                        │
│  6. Result compared against hidden clue DC                                 │
│                                                                              │
│  POSTCONDITIONS:                                                            │
│  - Clue found if best roll meets DC                                        │
│  - Record shows who found it (player C)                                    │
│  - Other players' failures don't matter                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 19.3 Use Case 3: Terminal Hacking (Chained)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: Terminal Hacking (Chained)                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ACTOR: Single character (player-1)                                         │
│                                                                              │
│  PRECONDITIONS:                                                             │
│  - Player at terminal requiring multi-step hack                             │
│  - System Bypass skill available                                            │
│                                                                              │
│  FLOW:                                                                       │
│  1. Player initiates hack command                                           │
│  2. StartChainedCheck creates 3-step chain:                                │
│     - Step 1: Access (DC 2, 0 retries)                                     │
│     - Step 2: Authentication (DC 3, 1 retry)                               │
│     - Step 3: Navigation (DC 2, 0 retries)                                 │
│  3. ProcessChainStep(step 1) → Success                                     │
│  4. ProcessChainStep(step 2) → Failure (fumble)                            │
│  5. Status: AwaitingRetry (1 retry available)                              │
│  6. Player chooses to retry                                                 │
│  7. RetryChainStep(step 2) → Success                                       │
│  8. ProcessChainStep(step 3) → Success                                     │
│  9. Status: Succeeded                                                       │
│                                                                              │
│  POSTCONDITIONS:                                                            │
│  - Terminal access granted                                                  │
│  - Player can access terminal functions                                     │
│  - Total attempts recorded: 4                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 19.4 Use Case 4: Chained Check Failure

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: Chained Check Failure                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ACTOR: Single character                                                    │
│                                                                              │
│  PRECONDITIONS:                                                             │
│  - Player attempting trap disarmament chain                                 │
│  - Step 2 has 0 retries                                                     │
│                                                                              │
│  FLOW:                                                                       │
│  1. StartChainedCheck with 3 steps                                         │
│  2. ProcessChainStep(step 1) → Success                                     │
│  3. ProcessChainStep(step 2) → Failure                                     │
│  4. No retries available for step 2                                        │
│  5. Status immediately set to Failed                                       │
│  6. Chain cannot continue                                                   │
│  7. Fumble consequence may trigger (ForcedExecution)                       │
│                                                                              │
│  POSTCONDITIONS:                                                            │
│  - Chain marked as Failed                                                   │
│  - Trap may trigger on player                                               │
│  - Cannot retry entire chain (must start over)                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 19.5 Use Case 5: Assisted Lockpicking

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: Assisted Lockpicking                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ACTOR: Primary (lockpicker) + 2 Helpers (lookouts)                         │
│                                                                              │
│  PRECONDITIONS:                                                             │
│  - One player skilled in lockpicking                                        │
│  - Other players can assist as lookouts                                     │
│                                                                              │
│  FLOW:                                                                       │
│  1. Party initiates assisted lockpicking                                   │
│  2. CooperationType.Assisted selected                                       │
│  3. Helpers roll first (just need 2+ net to help):                         │
│     - Helper B: 3d10 → 2 net (✓ grants +1d10)                             │
│     - Helper C: 4d10 → 1 net (✗ no bonus)                                 │
│  4. Primary receives +1d10 from successful helper                          │
│  5. Primary's pool: 5d10 (base) + 1d10 (helper) = 6d10                    │
│  6. Primary rolls 6d10 vs DC                                               │
│  7. Result determines lock success                                         │
│                                                                              │
│  POSTCONDITIONS:                                                            │
│  - Lock opened if primary succeeds                                         │
│  - Helper B credited in result                                              │
│  - Helper C tried but didn't contribute                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 20. Deliverable Checklist

### 20.1 Domain Layer

| File | Type | Status |
|------|------|--------|
| `Domain/Enums/CooperationType.cs` | Enum | ☐ |
| `Domain/Enums/ChainedCheckStatus.cs` | Enum | ☐ |
| `Domain/ValueObjects/CooperativeCheckResult.cs` | Value Object | ☐ |
| `Domain/ValueObjects/ChainedCheckStep.cs` | Value Object | ☐ |
| `Domain/Entities/ChainedCheckState.cs` | Entity | ☐ |
| `Domain/ValueObjects/SkillContext.cs` | Modified | ☐ |

### 20.2 Application Layer

| File | Type | Status |
|------|------|--------|
| `Application/Interfaces/IExtendedSkillCheckService.cs` | Interface | ☐ |
| `Application/Interfaces/IChainedCheckRepository.cs` | Interface | ☐ |
| `Application/Services/ExtendedSkillCheckService.cs` | Service | ☐ |

### 20.3 Infrastructure Layer

| File | Type | Status |
|------|------|--------|
| `Infrastructure/Repositories/InMemoryChainedCheckRepository.cs` | Repository | ☐ |

### 20.4 Tests

| File | Type | Status |
|------|------|--------|
| `Tests/Application/Services/ExtendedSkillCheckServiceTests.cs` | Unit Tests | ☐ |

### 20.5 Dependency Injection

| Registration | Status |
|--------------|--------|
| `IExtendedSkillCheckService` → `ExtendedSkillCheckService` (Scoped) | ☐ |
| `IChainedCheckRepository` → `InMemoryChainedCheckRepository` (Singleton) | ☐ |

---

## 21. Acceptance Criteria

### 21.1 Cooperative Check Criteria

| ID | Criterion | Status |
|----|-----------|--------|
| AC-001 | WeakestLink uses participant with lowest dice pool | ☐ |
| AC-002 | BestAttempt uses highest roll result among participants | ☐ |
| AC-003 | Combined sums all net successes | ☐ |
| AC-004 | Assisted grants +1d10 per helper with 2+ net | ☐ |
| AC-005 | Master abilities evaluated for each participant | ☐ |
| AC-006 | Context modifiers apply per participant | ☐ |

### 21.2 Chained Check Criteria

| ID | Criterion | Status |
|----|-----------|--------|
| AC-007 | Steps process in sequence | ☐ |
| AC-008 | Step failure with retries sets AwaitingRetry status | ☐ |
| AC-009 | Step failure without retries sets Failed status | ☐ |
| AC-010 | RetryChainStep decrements retries remaining | ☐ |
| AC-011 | All steps passing sets Succeeded status | ☐ |
| AC-012 | AbandonChain sets Failed status | ☐ |
| AC-013 | Context applies per-step when provided | ☐ |

### 21.3 Quality Criteria

| ID | Criterion | Status |
|----|-----------|--------|
| QC-001 | All ~10 unit tests pass | ☐ |
| QC-002 | Build completes with 0 errors | ☐ |
| QC-003 | Build completes with 0 warnings | ☐ |
| QC-004 | Logging captures all key events | ☐ |
| QC-005 | XML documentation complete | ☐ |

---

## 22. Future Considerations

### 22.1 Deferred to v0.15.1e

- **Trauma Economy**: Stress costs during cooperative/chained checks
- **Specialization Bonuses**: Archetype-specific cooperation modifiers
- **Voice Guidance**: Narrative descriptors for cooperation outcomes

### 22.2 Deferred to v0.15.2-v0.15.5

- **Party Stealth Implementation**: WeakestLink integration in Acrobatics
- **Climbing Stages**: Chained checks for multi-stage climbs
- **Negotiation Phases**: Chained checks for negotiation tracks
- **Terminal Layers**: Multi-layer hacking using chained checks
- **Tracking Pursuit**: Multi-phase tracking using chained checks
- **Group Foraging**: Combined cooperation for resource gathering

### 22.3 Future Enhancements

- **Pre-defined Chain Templates**: Configuration-based chain definitions
- **Chain Persistence**: Save/load chain state across sessions
- **Chain Visualization UI**: Progress bars and step displays
- **Cooperation Type Auto-Selection**: Context-aware type selection
- **Mixed Cooperation Chains**: Different cooperation types per step

---

## 23. Implementation Notes

### 23.1 Performance Considerations

1. **Repository Caching**: `InMemoryChainedCheckRepository` uses `ConcurrentDictionary` for thread-safe access.

2. **Lazy Evaluation**: Individual check results are computed only when needed for the cooperation type.

3. **Pool Calculation**: Dice pools are calculated once per participant and reused.

### 23.2 Design Decisions

1. **Helper Threshold**: Assisted checks require 2+ net successes to grant bonus. This ensures meaningful contribution.

2. **Retry Tracking**: Retries are tracked per-step, not per-chain. Different steps can have different retry limits.

3. **Context Override**: Step context can be overridden at process time for dynamic situations.

4. **Chain Immutability**: Once created, chain steps cannot be modified. This ensures consistent state.

### 23.3 Edge Cases

1. **Single Participant**: Cooperative checks with one participant work like normal checks (degenerate case).

2. **All Helpers Fail**: In Assisted, if no helpers get 2+ net, primary rolls with base pool only.

3. **Chain Abandonment**: Abandoning mid-chain sets Failed status but doesn't trigger fumble consequences.

4. **Master Auto-Succeed in Cooperative**: If any participant auto-succeeds in BestAttempt, that result is used.

---

## 24. Document Metadata

| Attribute | Value |
|-----------|-------|
| **Document Version** | 1.0 |
| **Created** | 2026-01-17 |
| **Last Updated** | 2026-01-17 |
| **Author** | Claude |
| **Status** | Draft |
| **Review Status** | Pending |

### 24.1 Change History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-01-17 | Claude | Initial specification |

### 24.2 References

- [v0.15.1-scope-breakdown.md](v0.15.1-scope-breakdown.md) - Scope definitions
- [v0.15.x-overview.md](v0.15.x-overview.md) - Version overview
- [v0.15.0d-design-specification.md](v0.15.0d-design-specification.md) - Contested & Extended Checks
- [v0.15.1a-design-specification.md](v0.15.1a-design-specification.md) - Skill Context & Modifiers
- [v0.15.1b-design-specification.md](v0.15.1b-design-specification.md) - Outcome Classification
- [v0.15.1c-design-specification.md](v0.15.1c-design-specification.md) - Master Abilities
