# Implementation Plan: v0.4.1a - Specialization Data & Seeding

**Status:** Ready for Review
**Theme:** "The Foundation"
**Scope:** Data structures, entities, EF Core migrations, seed data, and repository layer for Specializations

---

## Executive Summary

v0.4.1a establishes the foundational data layer for the Specialization system. This includes:
- New entities: `Specialization`, `SpecializationNode`, `CharacterSpecializationProgress`
- EF Core migration for PostgreSQL persistence
- Repository interfaces and implementations
- Seed data for two specializations: **Skald** (Investigator) and **Berserkr** (Warrior)
- Standard tree depth: 7-10 nodes per specialization with branching paths
- Reuses existing `ActiveAbility` entities (no new abilities created)

---

## Table of Contents

1. [Decision Tree](#1-decision-tree)
2. [Deliverable Checklist](#2-deliverable-checklist)
3. [Phase 1: Core Entities](#3-phase-1-core-entities)
4. [Phase 2: Character Integration](#4-phase-2-character-integration)
5. [Phase 3: Repository Layer](#5-phase-3-repository-layer)
6. [Phase 4: EF Core Migration](#6-phase-4-ef-core-migration)
7. [Phase 5: Seed Data](#7-phase-5-seed-data)
8. [Phase 6: Unit Tests](#8-phase-6-unit-tests)
9. [Logging Strategy](#9-logging-strategy)
10. [Changelog Template](#10-changelog-template)
11. [Critical Files](#11-critical-files)

---

## 1. Decision Tree

```
START: Implement v0.4.1a
│
├─ Q: Does SpecializationNode store AbilityId directly?
│  └─ YES: SpecializationNode.AbilityId (Guid) references ActiveAbility.Id
│
├─ Q: How to track unlocked nodes per character?
│  ├─ Option A: JSON column on Character (List<Guid>)
│  └─ Option B: Junction table (CharacterSpecializationProgress) ← CHOSEN
│     └─ Reason: Allows tracking unlock timestamps, supports querying, EF Core navigation
│
├─ Q: How to enforce tree prerequisites?
│  └─ SpecializationNode.ParentNodeIds (List<Guid>) stored as JSONB
│     └─ Service layer validates all parents are unlocked before allowing purchase
│
├─ Q: Where does PP come from for Specialization unlocks?
│  └─ Reuse existing Character.ProgressionPoints (same currency as attribute upgrades)
│     └─ Design Decision: v0.4.1a just defines data; v0.4.1b implements spending logic
│
├─ Q: How to model node position for UI rendering?
│  └─ SpecializationNode.PositionX, PositionY (int) for grid-based layout
│     └─ Tier implicitly defines Y; X allows horizontal spacing within a tier
│
└─ Q: How to handle Archetype restrictions?
   └─ Specialization.RequiredArchetype (ArchetypeType) enforced at unlock time
      └─ A Warrior can only unlock Berserkr/Guardian, not Skald
```

---

## 2. Deliverable Checklist

### Core Layer (`RuneAndRust.Core`)

- [ ] `Entities/Specialization.cs` - Specialization entity
- [ ] `Entities/SpecializationNode.cs` - Tree node entity
- [ ] `Entities/CharacterSpecializationProgress.cs` - Junction table entity
- [ ] `Enums/SpecializationType.cs` - Enum for specialization IDs
- [ ] `Interfaces/ISpecializationRepository.cs` - Repository interface
- [ ] Modify `Entities/Character.cs` - Add navigation properties

### Persistence Layer (`RuneAndRust.Persistence`)

- [ ] `Repositories/SpecializationRepository.cs` - Repository implementation
- [ ] `Migrations/V[N]__AddSpecializationTables.sql` - Migration script
- [ ] `Data/RuneAndRustDbContext.cs` - Add DbSets and configurations
- [ ] `SeedData/SpecializationSeeder.cs` - Seed data loader

### Engine Layer (`RuneAndRust.Engine`)

- [ ] (No changes in v0.4.1a - service layer comes in v0.4.1b)

### Terminal Layer (`RuneAndRust.Terminal`)

- [ ] `Program.cs` - Register `ISpecializationRepository`

### Test Layer (`RuneAndRust.Tests`)

- [ ] `Core/Entities/SpecializationTests.cs` - Entity validation tests
- [ ] `Core/Entities/SpecializationNodeTests.cs` - Node validation tests
- [ ] `Persistence/SpecializationRepositoryTests.cs` - Repository tests

---

## 3. Phase 1: Core Entities

### 3.1 SpecializationType Enum

**File:** `RuneAndRust.Core/Enums/SpecializationType.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Identifies distinct specialization paths available to characters.
/// Each specialization is tied to a specific Archetype.
/// </summary>
public enum SpecializationType
{
    /// <summary>Warrior specialization: Rage-focused damage dealer.</summary>
    Berserkr = 0,

    /// <summary>Warrior specialization: Defense-focused protector.</summary>
    Guardian = 1,

    /// <summary>Investigator specialization: Buff/debuff support via shouts.</summary>
    Skald = 10,

    /// <summary>Investigator specialization: Trap and positioning control.</summary>
    Trapper = 11,

    // Future: Adept and Mystic specializations (20-29, 30-39)
}
```

### 3.2 Specialization Entity

**File:** `RuneAndRust.Core/Entities/Specialization.cs`

```csharp
namespace RuneAndRust.Core.Entities;

/// <summary>
/// Represents a character specialization path (e.g., Berserkr, Skald).
/// Contains metadata and references the tree of unlockable nodes.
/// </summary>
public class Specialization
{
    /// <summary>Unique identifier.</summary>
    public Guid Id { get; set; } = Guid.NewGuid();

    /// <summary>Machine-readable type for lookups.</summary>
    public SpecializationType Type { get; set; }

    /// <summary>Display name (e.g., "Berserkr").</summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>AAM-VOICE compliant flavor description.</summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>The archetype required to unlock this specialization.</summary>
    public ArchetypeType RequiredArchetype { get; set; }

    /// <summary>Minimum character level to unlock (default: 1).</summary>
    public int RequiredLevel { get; set; } = 1;

    /// <summary>Navigation: All nodes in this specialization tree.</summary>
    public List<SpecializationNode> Nodes { get; set; } = new();

    /// <summary>Timestamp when this record was created.</summary>
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
```

### 3.3 SpecializationNode Entity

**File:** `RuneAndRust.Core/Entities/SpecializationNode.cs`

```csharp
namespace RuneAndRust.Core.Entities;

/// <summary>
/// A single node in a specialization tree. Represents an ability unlock point.
/// </summary>
public class SpecializationNode
{
    /// <summary>Unique identifier for this node.</summary>
    public Guid Id { get; set; } = Guid.NewGuid();

    /// <summary>FK to parent Specialization.</summary>
    public Guid SpecializationId { get; set; }

    /// <summary>Navigation to parent Specialization.</summary>
    public Specialization Specialization { get; set; } = null!;

    /// <summary>FK to the ability this node unlocks.</summary>
    public Guid AbilityId { get; set; }

    /// <summary>Navigation to the unlocked ability.</summary>
    public ActiveAbility Ability { get; set; } = null!;

    /// <summary>Tier level (1-4). Tier 4 = Capstone.</summary>
    public int Tier { get; set; } = 1;

    /// <summary>
    /// IDs of parent nodes that must be unlocked first.
    /// Empty for root nodes (Tier 1). Stored as JSONB.
    /// </summary>
    public List<Guid> ParentNodeIds { get; set; } = new();

    /// <summary>PP cost to unlock this node.</summary>
    public int CostPP { get; set; } = 1;

    /// <summary>Horizontal position in UI grid (0-indexed).</summary>
    public int PositionX { get; set; } = 0;

    /// <summary>Vertical position (usually matches Tier - 1).</summary>
    public int PositionY { get; set; } = 0;

    /// <summary>Display name override (if different from Ability.Name).</summary>
    public string? DisplayName { get; set; }

    /// <summary>Indicates if this is a capstone (final) node.</summary>
    public bool IsCapstone => Tier == 4;
}
```

### 3.4 CharacterSpecializationProgress Entity

**File:** `RuneAndRust.Core/Entities/CharacterSpecializationProgress.cs`

```csharp
namespace RuneAndRust.Core.Entities;

/// <summary>
/// Junction table tracking which nodes a character has unlocked.
/// </summary>
public class CharacterSpecializationProgress
{
    /// <summary>FK to Character.</summary>
    public Guid CharacterId { get; set; }

    /// <summary>Navigation to Character.</summary>
    public Character Character { get; set; } = null!;

    /// <summary>FK to unlocked SpecializationNode.</summary>
    public Guid NodeId { get; set; }

    /// <summary>Navigation to the unlocked node.</summary>
    public SpecializationNode Node { get; set; } = null!;

    /// <summary>When this node was unlocked.</summary>
    public DateTime UnlockedAt { get; set; } = DateTime.UtcNow;
}
```

---

## 4. Phase 2: Character Integration

### 4.1 Modify Character Entity

**File:** `RuneAndRust.Core/Entities/Character.cs`

**Add new region after `#region Status Effects`:**

```csharp
#region Specialization System (v0.4.1a)

/// <summary>
/// IDs of specializations this character has unlocked access to.
/// A character must unlock a specialization before purchasing nodes.
/// Stored as JSONB in PostgreSQL.
/// </summary>
public List<Guid> UnlockedSpecializationIds { get; set; } = new();

/// <summary>
/// Navigation: Junction table of all unlocked specialization nodes.
/// </summary>
public ICollection<CharacterSpecializationProgress> SpecializationProgress { get; set; }
    = new List<CharacterSpecializationProgress>();

/// <summary>
/// Checks if the character has unlocked a specific specialization.
/// </summary>
public bool HasSpecialization(Guid specId) => UnlockedSpecializationIds.Contains(specId);

/// <summary>
/// Checks if the character has unlocked a specific node.
/// </summary>
public bool HasNode(Guid nodeId) =>
    SpecializationProgress.Any(p => p.NodeId == nodeId);

#endregion
```

---

## 5. Phase 3: Repository Layer

### 5.1 Repository Interface

**File:** `RuneAndRust.Core/Interfaces/ISpecializationRepository.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Repository for Specialization and SpecializationNode queries.
/// </summary>
public interface ISpecializationRepository
{
    /// <summary>Gets all available specializations.</summary>
    Task<IEnumerable<Specialization>> GetAllAsync();

    /// <summary>Gets a specialization by ID, including all nodes.</summary>
    Task<Specialization?> GetByIdAsync(Guid id);

    /// <summary>Gets a specialization by type enum.</summary>
    Task<Specialization?> GetByTypeAsync(SpecializationType type);

    /// <summary>Gets all specializations available to a given archetype.</summary>
    Task<IEnumerable<Specialization>> GetByArchetypeAsync(ArchetypeType archetype);

    /// <summary>Gets a specific node by ID.</summary>
    Task<SpecializationNode?> GetNodeByIdAsync(Guid nodeId);

    /// <summary>Gets all nodes for a specialization, ordered by tier.</summary>
    Task<IEnumerable<SpecializationNode>> GetNodesForSpecializationAsync(Guid specId);

    /// <summary>Gets all unlocked nodes for a character.</summary>
    Task<IEnumerable<SpecializationNode>> GetUnlockedNodesAsync(Guid characterId);

    /// <summary>Records a node unlock for a character.</summary>
    Task RecordNodeUnlockAsync(Guid characterId, Guid nodeId);

    /// <summary>Saves changes to the database.</summary>
    Task SaveChangesAsync();
}
```

### 5.2 Repository Implementation

**File:** `RuneAndRust.Persistence/Repositories/SpecializationRepository.cs`

```csharp
namespace RuneAndRust.Persistence.Repositories;

public class SpecializationRepository : ISpecializationRepository
{
    private readonly RuneAndRustDbContext _context;
    private readonly ILogger<SpecializationRepository> _logger;

    public SpecializationRepository(
        RuneAndRustDbContext context,
        ILogger<SpecializationRepository> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task<IEnumerable<Specialization>> GetAllAsync()
    {
        _logger.LogDebug("[SpecRepo] GetAllAsync called");
        return await _context.Specializations
            .Include(s => s.Nodes)
                .ThenInclude(n => n.Ability)
            .ToListAsync();
    }

    public async Task<Specialization?> GetByIdAsync(Guid id)
    {
        _logger.LogDebug("[SpecRepo] GetByIdAsync: {Id}", id);
        return await _context.Specializations
            .Include(s => s.Nodes)
                .ThenInclude(n => n.Ability)
            .FirstOrDefaultAsync(s => s.Id == id);
    }

    public async Task<Specialization?> GetByTypeAsync(SpecializationType type)
    {
        _logger.LogDebug("[SpecRepo] GetByTypeAsync: {Type}", type);
        return await _context.Specializations
            .Include(s => s.Nodes)
                .ThenInclude(n => n.Ability)
            .FirstOrDefaultAsync(s => s.Type == type);
    }

    public async Task<IEnumerable<Specialization>> GetByArchetypeAsync(ArchetypeType archetype)
    {
        _logger.LogDebug("[SpecRepo] GetByArchetypeAsync: {Archetype}", archetype);
        return await _context.Specializations
            .Include(s => s.Nodes)
            .Where(s => s.RequiredArchetype == archetype)
            .ToListAsync();
    }

    public async Task<SpecializationNode?> GetNodeByIdAsync(Guid nodeId)
    {
        _logger.LogDebug("[SpecRepo] GetNodeByIdAsync: {NodeId}", nodeId);
        return await _context.SpecializationNodes
            .Include(n => n.Ability)
            .Include(n => n.Specialization)
            .FirstOrDefaultAsync(n => n.Id == nodeId);
    }

    public async Task<IEnumerable<SpecializationNode>> GetNodesForSpecializationAsync(Guid specId)
    {
        _logger.LogDebug("[SpecRepo] GetNodesForSpecializationAsync: {SpecId}", specId);
        return await _context.SpecializationNodes
            .Include(n => n.Ability)
            .Where(n => n.SpecializationId == specId)
            .OrderBy(n => n.Tier)
            .ThenBy(n => n.PositionX)
            .ToListAsync();
    }

    public async Task<IEnumerable<SpecializationNode>> GetUnlockedNodesAsync(Guid characterId)
    {
        _logger.LogDebug("[SpecRepo] GetUnlockedNodesAsync: {CharacterId}", characterId);
        return await _context.CharacterSpecializationProgress
            .Where(p => p.CharacterId == characterId)
            .Include(p => p.Node)
                .ThenInclude(n => n.Ability)
            .Select(p => p.Node)
            .ToListAsync();
    }

    public async Task RecordNodeUnlockAsync(Guid characterId, Guid nodeId)
    {
        _logger.LogDebug("[SpecRepo] RecordNodeUnlockAsync: Char={CharId}, Node={NodeId}",
            characterId, nodeId);

        var progress = new CharacterSpecializationProgress
        {
            CharacterId = characterId,
            NodeId = nodeId,
            UnlockedAt = DateTime.UtcNow
        };

        await _context.CharacterSpecializationProgress.AddAsync(progress);
    }

    public async Task SaveChangesAsync()
    {
        await _context.SaveChangesAsync();
    }
}
```

---

## 6. Phase 4: EF Core Migration

### 6.1 DbContext Configuration

**File:** `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs`

**Add DbSets:**

```csharp
public DbSet<Specialization> Specializations { get; set; }
public DbSet<SpecializationNode> SpecializationNodes { get; set; }
public DbSet<CharacterSpecializationProgress> CharacterSpecializationProgress { get; set; }
```

**Add to OnModelCreating:**

```csharp
// Specialization
modelBuilder.Entity<Specialization>(entity =>
{
    entity.HasKey(e => e.Id);
    entity.HasIndex(e => e.Type).IsUnique();
    entity.Property(e => e.Name).HasMaxLength(100).IsRequired();
    entity.Property(e => e.Description).HasMaxLength(1000);

    entity.HasMany(e => e.Nodes)
        .WithOne(n => n.Specialization)
        .HasForeignKey(n => n.SpecializationId)
        .OnDelete(DeleteBehavior.Cascade);
});

// SpecializationNode
modelBuilder.Entity<SpecializationNode>(entity =>
{
    entity.HasKey(e => e.Id);
    entity.Property(e => e.ParentNodeIds)
        .HasColumnType("jsonb");
    entity.Property(e => e.DisplayName).HasMaxLength(100);

    entity.HasOne(e => e.Ability)
        .WithMany()
        .HasForeignKey(e => e.AbilityId)
        .OnDelete(DeleteBehavior.Restrict);
});

// CharacterSpecializationProgress (Composite Key)
modelBuilder.Entity<CharacterSpecializationProgress>(entity =>
{
    entity.HasKey(e => new { e.CharacterId, e.NodeId });

    entity.HasOne(e => e.Character)
        .WithMany(c => c.SpecializationProgress)
        .HasForeignKey(e => e.CharacterId)
        .OnDelete(DeleteBehavior.Cascade);

    entity.HasOne(e => e.Node)
        .WithMany()
        .HasForeignKey(e => e.NodeId)
        .OnDelete(DeleteBehavior.Cascade);
});

// Character: Add JSONB for UnlockedSpecializationIds
modelBuilder.Entity<Character>(entity =>
{
    // ... existing config ...
    entity.Property(e => e.UnlockedSpecializationIds)
        .HasColumnType("jsonb");
});
```

### 6.2 Migration Script

**File:** `RuneAndRust.Persistence/Migrations/V[N]__AddSpecializationTables.sql`

```sql
-- v0.4.1a: Specialization System Tables

-- Specializations master table
CREATE TABLE IF NOT EXISTS "Specializations" (
    "Id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    "Type" INTEGER NOT NULL,
    "Name" VARCHAR(100) NOT NULL,
    "Description" VARCHAR(1000),
    "RequiredArchetype" INTEGER NOT NULL,
    "RequiredLevel" INTEGER NOT NULL DEFAULT 1,
    "CreatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE UNIQUE INDEX "IX_Specializations_Type" ON "Specializations" ("Type");

-- Specialization Nodes (Tree Structure)
CREATE TABLE IF NOT EXISTS "SpecializationNodes" (
    "Id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    "SpecializationId" UUID NOT NULL REFERENCES "Specializations"("Id") ON DELETE CASCADE,
    "AbilityId" UUID NOT NULL REFERENCES "ActiveAbilities"("Id") ON DELETE RESTRICT,
    "Tier" INTEGER NOT NULL DEFAULT 1,
    "ParentNodeIds" JSONB DEFAULT '[]',
    "CostPP" INTEGER NOT NULL DEFAULT 1,
    "PositionX" INTEGER NOT NULL DEFAULT 0,
    "PositionY" INTEGER NOT NULL DEFAULT 0,
    "DisplayName" VARCHAR(100)
);

CREATE INDEX "IX_SpecNodes_SpecId" ON "SpecializationNodes" ("SpecializationId");
CREATE INDEX "IX_SpecNodes_AbilityId" ON "SpecializationNodes" ("AbilityId");

-- Character Specialization Progress (Junction Table)
CREATE TABLE IF NOT EXISTS "CharacterSpecializationProgress" (
    "CharacterId" UUID NOT NULL REFERENCES "Characters"("Id") ON DELETE CASCADE,
    "NodeId" UUID NOT NULL REFERENCES "SpecializationNodes"("Id") ON DELETE CASCADE,
    "UnlockedAt" TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY ("CharacterId", "NodeId")
);

CREATE INDEX "IX_CharSpecProgress_CharId" ON "CharacterSpecializationProgress" ("CharacterId");

-- Add UnlockedSpecializationIds to Characters
ALTER TABLE "Characters"
ADD COLUMN IF NOT EXISTS "UnlockedSpecializationIds" JSONB DEFAULT '[]';
```

---

## 7. Phase 5: Seed Data

### 7.1 Seed Data Structure

**File:** `RuneAndRust.Persistence/SeedData/SpecializationSeeder.cs`

The seeder will create:

#### Berserkr (Warrior Specialization) - 8 Nodes

```
TIER 1 (Root - No Prerequisites)
├─ [0,0] Battle Cry (Buff: +2 Might for 3 turns) - Cost: 1 PP
├─ [1,0] Reckless Swing (High damage, self-damage) - Cost: 1 PP
└─ [2,0] Blood Frenzy (Gain Stamina on kill) - Cost: 1 PP

TIER 2 (Requires 1 Tier 1 node)
├─ [0,1] Intimidating Presence (AoE debuff) - Cost: 2 PP [Parent: Battle Cry]
└─ [1,1] Berserker Rage (+Damage when HP < 50%) - Cost: 2 PP [Parent: Reckless Swing]

TIER 3 (Requires 2 Tier 2 nodes)
├─ [0,2] War Cry (Team-wide buff) - Cost: 3 PP [Parents: Intimidating Presence, Berserker Rage]
└─ [1,2] Unrelenting (Ignore first fatal blow) - Cost: 3 PP [Parents: Berserker Rage]

TIER 4 - CAPSTONE (Requires all Tier 3)
└─ [0,3] Avatar of Fury (Ultimate transformation) - Cost: 5 PP [Parents: War Cry, Unrelenting]
```

#### Skald (Investigator Specialization) - 8 Nodes

```
TIER 1 (Root - No Prerequisites)
├─ [0,0] Inspiring Word (Heal + Buff ally) - Cost: 1 PP
├─ [1,0] Discordant Note (Single target debuff) - Cost: 1 PP
└─ [2,0] Echoing Chant (Status effect extension) - Cost: 1 PP

TIER 2 (Requires 1 Tier 1 node)
├─ [0,1] Verse of Valor (+Crit chance team) - Cost: 2 PP [Parent: Inspiring Word]
└─ [1,1] Cacophony (AoE damage + confusion) - Cost: 2 PP [Parent: Discordant Note]

TIER 3 (Requires 2 Tier 2 nodes)
├─ [0,2] Epic Recitation (Major team heal) - Cost: 3 PP [Parents: Verse of Valor]
└─ [1,2] Silencing Shriek (Interrupt + Silence) - Cost: 3 PP [Parents: Cacophony]

TIER 4 - CAPSTONE (Requires all Tier 3)
└─ [0,3] The Final Verse (Ultimate: revive + team buff) - Cost: 5 PP [Parents: Epic Recitation, Silencing Shriek]
```

### 7.2 Seeder Implementation Pattern

```csharp
public class SpecializationSeeder
{
    private readonly RuneAndRustDbContext _context;
    private readonly ILogger<SpecializationSeeder> _logger;

    public async Task SeedAsync()
    {
        if (await _context.Specializations.AnyAsync())
        {
            _logger.LogDebug("[Seeder] Specializations already exist, skipping seed");
            return;
        }

        _logger.LogInformation("[Seeder] Seeding Specializations...");

        // 1. Create Specialization records
        var berserkr = CreateBerserkr();
        var skald = CreateSkald();

        await _context.Specializations.AddRangeAsync(berserkr, skald);
        await _context.SaveChangesAsync();

        _logger.LogInformation("[Seeder] Seeded {Count} specializations with {NodeCount} total nodes",
            2, berserkr.Nodes.Count + skald.Nodes.Count);
    }

    private Specialization CreateBerserkr()
    {
        // Fetch existing abilities by name
        // Create Specialization entity
        // Create SpecializationNode entities with proper ParentNodeIds
        // Return populated Specialization
    }
}
```

---

## 8. Phase 6: Unit Tests

### 8.1 Test Classes

**Total Target:** 25-30 tests

#### SpecializationTests (8 tests)

| Test Name | Description |
|-----------|-------------|
| `Constructor_InitializesDefaults` | Verify Id, Name, Nodes defaults |
| `RequiredArchetype_EnforcesType` | Validate archetype assignment |
| `RequiredLevel_DefaultsToOne` | Check default level requirement |
| `Nodes_EmptyByDefault` | Ensure Nodes list initializes empty |
| `Type_UniquePerSpecialization` | Validate enum uniqueness |
| `Description_CanBeEmpty` | Allow null/empty descriptions |
| `CreatedAt_SetsOnConstruction` | Timestamp initialization |
| `Nodes_CanAddMultiple` | Test adding nodes to collection |

#### SpecializationNodeTests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `Constructor_InitializesDefaults` | Verify all defaults |
| `Tier_MustBePositive` | Validate tier range 1-4 |
| `ParentNodeIds_EmptyForTier1` | Root nodes have no parents |
| `ParentNodeIds_RequiredForHigherTiers` | Tier 2+ must have parents |
| `CostPP_MustBePositive` | Validate cost > 0 |
| `IsCapstone_TrueForTier4` | Computed property test |
| `IsCapstone_FalseForLowerTiers` | Computed property test |
| `Position_AllowsNegative` | Edge case for grid positioning |
| `DisplayName_OverridesAbilityName` | Optional name override |
| `AbilityId_Required` | FK validation |

#### SpecializationRepositoryTests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `GetAllAsync_ReturnsAll` | Fetch all specializations |
| `GetAllAsync_IncludesNodes` | Eager loading verification |
| `GetByIdAsync_ReturnsNull_WhenNotFound` | 404 case |
| `GetByIdAsync_ReturnsWithNodes` | Include children |
| `GetByTypeAsync_FindsByEnum` | Enum-based lookup |
| `GetByArchetypeAsync_FiltersCorrectly` | Archetype filtering |
| `GetNodeByIdAsync_ReturnsNull_WhenNotFound` | 404 case |
| `GetUnlockedNodesAsync_ReturnsEmpty_WhenNone` | New character case |
| `RecordNodeUnlockAsync_CreatesProgress` | Junction table insert |
| `RecordNodeUnlockAsync_SetsTimestamp` | Verify UnlockedAt |

### 8.2 Test Patterns

```csharp
public class SpecializationNodeTests
{
    [Fact]
    public void IsCapstone_TrueForTier4()
    {
        // Arrange
        var node = new SpecializationNode { Tier = 4 };

        // Act
        var result = node.IsCapstone;

        // Assert
        result.Should().BeTrue();
    }

    [Theory]
    [InlineData(1)]
    [InlineData(2)]
    [InlineData(3)]
    public void IsCapstone_FalseForLowerTiers(int tier)
    {
        // Arrange
        var node = new SpecializationNode { Tier = tier };

        // Act
        var result = node.IsCapstone;

        // Assert
        result.Should().BeFalse();
    }
}
```

---

## 9. Logging Strategy

### 9.1 Logging Matrix

| Component | Event | Level | Template |
|-----------|-------|-------|----------|
| SpecializationRepository | GetAllAsync | Debug | `[SpecRepo] GetAllAsync called` |
| SpecializationRepository | GetByIdAsync | Debug | `[SpecRepo] GetByIdAsync: {Id}` |
| SpecializationRepository | GetByTypeAsync | Debug | `[SpecRepo] GetByTypeAsync: {Type}` |
| SpecializationRepository | GetByArchetypeAsync | Debug | `[SpecRepo] GetByArchetypeAsync: {Archetype}` |
| SpecializationRepository | GetNodeByIdAsync | Debug | `[SpecRepo] GetNodeByIdAsync: {NodeId}` |
| SpecializationRepository | GetNodesForSpec | Debug | `[SpecRepo] GetNodesForSpecializationAsync: {SpecId}` |
| SpecializationRepository | GetUnlockedNodes | Debug | `[SpecRepo] GetUnlockedNodesAsync: {CharacterId}` |
| SpecializationRepository | RecordNodeUnlock | Debug | `[SpecRepo] RecordNodeUnlockAsync: Char={CharId}, Node={NodeId}` |
| SpecializationSeeder | Skip seed | Debug | `[Seeder] Specializations already exist, skipping seed` |
| SpecializationSeeder | Start seed | Info | `[Seeder] Seeding Specializations...` |
| SpecializationSeeder | Complete seed | Info | `[Seeder] Seeded {Count} specializations with {NodeCount} total nodes` |

---

## 10. Changelog Template

The changelog for v0.4.1a will follow the **Single-Part (Minimal)** template from `CHANGELOG_GENERATION_RULES.md`:

```markdown
# Changelog: v0.4.1a - The Foundation

**Release Date:** YYYY-MM-DD
**Total Tests:** N (M new tests added)

## Table of Contents
- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.1a](#directory-structure-after-v041a)
- [Running Tests](#running-tests)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

v0.4.1a establishes the data foundation for the Specialization system...

[Continue with all required sections per CHANGELOG_GENERATION_RULES.md]
```

---

## 11. Critical Files

### Files to Create

| File | Layer | Purpose |
|------|-------|---------|
| `RuneAndRust.Core/Enums/SpecializationType.cs` | Core | Specialization type enum |
| `RuneAndRust.Core/Entities/Specialization.cs` | Core | Specialization entity |
| `RuneAndRust.Core/Entities/SpecializationNode.cs` | Core | Tree node entity |
| `RuneAndRust.Core/Entities/CharacterSpecializationProgress.cs` | Core | Junction table entity |
| `RuneAndRust.Core/Interfaces/ISpecializationRepository.cs` | Core | Repository interface |
| `RuneAndRust.Persistence/Repositories/SpecializationRepository.cs` | Persistence | Repository impl |
| `RuneAndRust.Persistence/SeedData/SpecializationSeeder.cs` | Persistence | Seed data loader |
| `RuneAndRust.Tests/Core/Entities/SpecializationTests.cs` | Tests | Entity tests |
| `RuneAndRust.Tests/Core/Entities/SpecializationNodeTests.cs` | Tests | Node tests |
| `RuneAndRust.Tests/Persistence/SpecializationRepositoryTests.cs` | Tests | Repository tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/Character.cs` | Add `UnlockedSpecializationIds`, `SpecializationProgress`, helper methods |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Add DbSets and configurations |
| `RuneAndRust.Terminal/Program.cs` | Register `ISpecializationRepository` |

---

## Implementation Order

1. **Create Core entities and enums** (SpecializationType, Specialization, SpecializationNode, CharacterSpecializationProgress)
2. **Modify Character.cs** (add new properties and region)
3. **Create ISpecializationRepository interface**
4. **Update DbContext** (DbSets + OnModelCreating)
5. **Create migration script**
6. **Apply migration** (`dotnet ef database update`)
7. **Create SpecializationRepository implementation**
8. **Register in Program.cs** DI
9. **Create SpecializationSeeder** and run it
10. **Write unit tests** for entities and repository
11. **Generate changelog** following CHANGELOG_GENERATION_RULES.md

