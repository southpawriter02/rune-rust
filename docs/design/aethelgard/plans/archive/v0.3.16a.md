> **Archived** - This plan has been consolidated. See the complete version at [v0.3.16](../v0.3.x/v0.3.16.md).

# v0.3.16a: The Safety Net (Global Exception Handler)

This sub-version establishes the "Red Screen of Death" (RSOD) and the forensic logging infrastructure. It ensures that when the game crashes, the player receives a clear explanation rather than a silent closure, and the developer receives a detailed stack trace saved to disk.

Goal: Wrap the application lifecycle in a master exception handler that intercepts unhandled runtime errors, generates a timestamped crash report, and renders a user-friendly error screen via Spectre.Console.

1. Architecture & Data Flow
The Failure Pipeline
	1	Trigger: An unhandled exception occurs anywhere in the application (e.g., NullReferenceException in CombatService).
	2	Interception: The try/catch block surrounding host.RunAsync() in Program.cs catches the exception.
	3	Diagnosis:
	◦	The CrashService extracts the Stack Trace, Exception Message, and OS/Runtime version.
	◦	It attempts to grab a snapshot of the current GamePhase (if accessible).
	4	Persistence: CrashService writes a .log or .txt file to logs/crashes/.
	5	Presentation: CrashScreenRenderer hijacks the console, clears the buffer, and prints the "Critical Failure" UI.
	6	Termination: The application waits for user acknowledgement (Enter) or a timeout, then exits with code 1.

2. Logic Decision Trees
A. Global Exception Logic (Program.cs) Input: Exception ex
	1	Check Type: Is ex a TaskCanceledException or OperationCanceledException?
	◦	Yes: (User pressed Ctrl+C) -> Shutdown gracefully. Exit(0).
	2	Service Resolution: Can we resolve ICrashService from host.Services?
	◦	Yes: Delegate to _crashService.HandleCrash(ex).
	◦	No: (Host failed to build) -> Fallback to Console.WriteLine dump. Exit(1).
	3	Handling:
	◦	Log to Serilog (Fatal).
	◦	Write Crash Report to Disk.
	◦	Render Crash Screen.
	4	Termination: Environment.Exit(1).
B. Crash Report Generation Input: Exception, DateTime
	1	Format Filename: crash_YYYYMMDD_HHmmss.log.
	2	Build Content:
	◦	Header: App Version, Date, OS.
	◦	Error: Type, Message.
	◦	Stack Trace: Full string.
	◦	Inner Exception: (Recursive check).
	3	Write: Save to logs/crashes/.

3. Deliverable Checklist
	•	Core:
	◦	[ ] Define ICrashService interface.
	◦	[ ] Define CrashReport record (DTO for the log file).
	•	Engine:
	◦	[ ] Implement CrashService: Logic for writing files and formatting text.
	•	Terminal:
	◦	[ ] Implement CrashScreenRenderer: Spectre.Console layout for the error screen.
	◦	[ ] Refactor Program.cs: Wrap Main execution in try/catch.
	•	Testing:
	◦	[ ] Create CrashServiceTests.cs.

4. Code Implementation
A. Core Definition (RuneAndRust.Core/Models/CrashReport.cs)
public record CrashReport(
    DateTime Timestamp,
    string ExceptionType,
    string Message,
    string StackTrace,
    string GameVersion,
    string OperatingSystem
);
B. Engine Service (RuneAndRust.Engine/Services/CrashService.cs)
public class CrashService : ICrashService
{
    private readonly string _logDirectory = Path.Combine("logs", "crashes");

    public string GenerateReportPath(DateTime time)
        => Path.Combine(_logDirectory, $"crash_{time:yyyyMMdd_HHmmss}.txt");

    public void LogCrash(Exception ex)
    {
        Directory.CreateDirectory(_logDirectory);

        var report = new CrashReport(
            DateTime.Now,
            ex.GetType().Name,
            ex.Message,
            ex.StackTrace ?? "No stack trace available.",
            "v0.3.16a",
            Environment.OSVersion.ToString()
        );

        // Serialize formatted text
        var content =
            $"=== CRITICAL FAILURE REPORT ===\n" +
            $"Time: {report.Timestamp}\n" +
            $"OS: {report.OperatingSystem}\n" +
            $"Version: {report.GameVersion}\n\n" +
            $"Error: {report.ExceptionType}\n" +
            $"Message: {report.Message}\n\n" +
            $"--- Stack Trace ---\n{report.StackTrace}";

        File.WriteAllText(GenerateReportPath(report.Timestamp), content);
    }
}
C. Terminal Renderer (RuneAndRust.Terminal/Rendering/CrashScreenRenderer.cs)
public static class CrashScreenRenderer
{
    public static void Render(Exception ex)
    {
        AnsiConsole.Clear();
        var panel = new Panel(
            new Rows(
                new Markup("[bold white]A critical error has occurred.[/]"),
                new Text(""),
                new Markup($"[red]{Markup.Escape(ex.GetType().Name)}[/]"),
                new Markup($"[italic]{Markup.Escape(ex.Message)}[/]"),
                new Text(""),
                new Markup("[grey]A crash report has been saved to ./logs/crashes/[/]")
            ))
            .Header("[bold white on red] SYSTEM FAILURE [/]")
            .BorderColor(Color.Red)
            .Padding(2, 1);

        AnsiConsole.Write(panel);
        AnsiConsole.MarkupLine("\n[grey]Press [bold]ENTER[/] to exit...[/]");
        Console.ReadLine();
    }
}
D. Program Entry Point (RuneAndRust.Terminal/Program.cs)
public static async Task Main(string[] args)
{
    try
    {
        var host = CreateHostBuilder(args).Build();
        // ... Initialization ...
        await host.RunAsync();
    }
    catch (Exception ex) when (ex is not OperationCanceledException)
    {
        // 1. Render UI immediately (Blocking)
        CrashScreenRenderer.Render(ex);

        // 2. Attempt detailed logging
        try
        {
            // Note: In real scenarios, 'host' might be null if Build() failed.
            // We'd fallback to simple file IO here.
            var crashService = new CrashService(); // Manual instantiation to be safe
            crashService.LogCrash(ex);
        }
        catch { /* If logging fails, swallow it to ensure UI stays visible */ }

        Environment.Exit(1);
    }
}

5. Logging Requirements
The CrashService writes to a specific directory (logs/crashes/) distinct from the standard logs/runeandrust.log.
System
Event
Level
Message Template
Properties
Program
Catch
Fatal
"Application crashed: {Message}"
Message
CrashService
Write
System
Writes crash_{timestamp}.txt to disk.
-

6. Testing Strategy
Unit Tests (CrashServiceTests.cs)
	•	GenerateReportPath_CreatesValidFilename: Verify the timestamp format matches the sorting requirement.
	•	LogCrash_CreatesDirectory_IfMissing: Ensure logs/crashes/ is created on the fly.
	•	LogCrash_WritesContent: Mock File (or use a temp directory) to verify the output string contains the Exception Message.
Manual QA (The "Sabotage"):
	•	Setup: Insert throw new InvalidOperationException("Sabotage!"); in MainMenuController.Start().
	•	Action: Run game -> Select "Start".
	•	Verify:
	1	Red Panel appears with "Sabotage!".
	2	Application waits for Enter.
	3	logs/crashes/ contains a new file with the stack trace.

7. Draft Changelog (v0.3.16a)
# v0.3.16a Changelog: The Safety Net
**Release Date:** 2026-03-01

## Summary
This release establishes the global exception handling infrastructure. Players will no longer see the window simply vanish upon a critical error; instead, a "System Failure" screen provides context, and detailed logs are saved for developer review.

## New Features
*   **Crash Screen:** A specialized "Red Screen of Death" using Spectre.Console to display errors gracefully.
*   **Crash Reporting:** Automatic generation of timestamped `.txt` files in `logs/crashes/` containing stack traces and version info.

## Technical Changes
*   Wrapped `Program.Main` in a global `try/catch` block.
*   Implemented `CrashService` for file I/O operations independent of the main game loop.
*   Added `ICrashService` interface.