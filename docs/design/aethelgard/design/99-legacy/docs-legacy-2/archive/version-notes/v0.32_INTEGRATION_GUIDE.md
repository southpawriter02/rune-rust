# v0.32 Jötunheim Biome - Integration Guide
## Combat Engine & Sector Generation Integration

**Version**: v0.32 (Complete)
**Date**: 2025-11-16
**Prerequisites**: All v0.32.1-v0.32.4 implementations complete
**Integration Time**: 6-10 hours estimated

---

## I. Service Dependencies

### Services Required

All three Jötunheim services must be injected into relevant systems:

```csharp
// In CombatEngine.cs or equivalent combat orchestrator
private readonly JotunheimBiomeService _jotunheimBiomeService;
private readonly PowerConduitService _powerConduitService;
private readonly JotunCorpseTerrainService _jotunCorpseTerrainService;

public CombatEngine(
    // ... existing dependencies
    JotunheimBiomeService jotunheimBiomeService,
    PowerConduitService powerConduitService,
    JotunCorpseTerrainService jotunCorpseTerrainService)
{
    // ... existing initialization
    _jotunheimBiomeService = jotunheimBiomeService;
    _powerConduitService = powerConduitService;
    _jotunCorpseTerrainService = jotunCorpseTerrainService;
}
```

---

## II. Combat Initialization Integration

### Step 1: Biome Detection & NO Ambient Condition Verification

**Location**: `CombatEngine.InitializeCombat()` or similar

```csharp
public void InitializeCombat(Sector sector, Room room, List<PlayerCharacter> party)
{
    // ... existing initialization code

    // Biome-specific initialization
    if (room.BiomeId == 7) // Jötunheim
    {
        _log.Information("Initializing Jötunheim combat - NO ambient condition biome");

        // CRITICAL: Verify NO ambient condition (canonical design)
        var hasNoAmbient = _jotunheimBiomeService.VerifyNoAmbientCondition();
        if (!hasNoAmbient)
        {
            throw new InvalidOperationException(
                "INTEGRITY ERROR: Jötunheim must have NO ambient condition (biome_id=7, ambient_condition_id must be NULL)");
        }

        // Initialize steam vent tracking (NOT ambient condition)
        InitializeSteamVents(battlefield);

        _log.Information("Jötunheim combat initialized - physical threats only, no ambient effects");
    }
    // ... other biomes (Alfheim, Muspelheim, Niflheim, etc.)

    // ... rest of initialization
}

private void InitializeSteamVents(BattlefieldState battlefield)
{
    // Steam vents are tracked internally by JotunheimBiomeService
    // No additional initialization needed
    _log.Debug("Steam vents ready for 3-turn eruption cycle");
}
```

### Step 2: Enemy Generation Integration

**Location**: `CombatEngine.GenerateEnemies()` or `EncounterService.SpawnEnemies()`

```csharp
private List<Enemy> GenerateEnemiesForRoom(Room room, int difficulty)
{
    if (room.BiomeId == 7) // Jötunheim
    {
        // Use verticality tier if available
        var verticalityTier = room.VerticalityTier; // "Trunk" or "Roots"

        // Generate enemy group using weighted spawn system
        var enemyNames = _jotunheimBiomeService.GenerateEnemyGroup(difficulty, verticalityTier);

        // Convert enemy names to Enemy objects
        var enemies = new List<Enemy>();
        foreach (var enemyName in enemyNames)
        {
            var enemy = _enemyFactory.CreateEnemy(enemyName, room.BiomeId);
            enemies.Add(enemy);
        }

        _log.Information("Generated Jötunheim encounter: {Count} enemies - {Names}",
            enemies.Count, string.Join(", ", enemyNames));

        return enemies;
    }

    // ... other biome enemy generation
}
```

---

## III. Turn Processing Integration

### Step 1: Environmental Hazard Processing

**Location**: `CombatEngine.ProcessTurn()` or `CombatEngine.StartTurn()`

```csharp
public void ProcessTurn(int currentTurn)
{
    _log.Information("Processing turn {Turn}", currentTurn);

    // STEP 1: Process biome-specific environmental hazards FIRST
    if (_currentRoom.BiomeId == 7) // Jötunheim
    {
        _jotunheimBiomeService.ProcessEnvironmentalHazards(_battlefield, currentTurn);
        // This processes:
        // - Live Power Conduits (1d8 or 2d10 Energy)
        // - High-Pressure Steam Vents (every 3 turns: 2d6 Fire + knockback)
        // - Jötun Corpse Terrain (+2 Psychic Stress)
        // - Flooded Terrain (1 Poison)
        // - Toxic Haze (1d4 Poison in 4x4 zones)
    }
    else if (_currentRoom.BiomeId == 3) // Alfheim
    {
        _alfheimBiomeService.ProcessEnvironmentalHazards(_battlefield, currentTurn);
    }
    // ... other biomes

    // STEP 2: Player turn
    ProcessPlayerTurn();

    // STEP 3: Enemy turn
    ProcessEnemyTurn();

    // STEP 4: End of turn effects
    ProcessEndOfTurnEffects();
}
```

### Step 2: Assembly Line Forced Movement (Optional)

**Location**: `CombatEngine.ProcessEndOfTurnEffects()` or similar

```csharp
private void ProcessEndOfTurnEffects()
{
    // ... existing end-of-turn effects

    // Jötunheim assembly line forced movement
    if (_currentRoom.BiomeId == 7)
    {
        _jotunheimBiomeService.ProcessAssemblyLines(_battlefield);
        // Moves combatants 2 tiles in belt direction
        // Can force movement into Power Conduits (double damage)
    }

    // ... other end-of-turn effects
}
```

---

## IV. Damage Event Integration

### Ceiling Collapse Trigger

**Location**: `CombatEngine.OnDamageDealt()` or damage event handler

```csharp
public void OnDamageDealt(GridPosition impactPosition, int damageAmount, DamageType damageType)
{
    // ... existing damage processing

    // Jötunheim ceiling collapse check
    if (_currentRoom.BiomeId == 7 && damageAmount >= 10)
    {
        var collapsed = _jotunheimBiomeService.CheckCeilingCollapse(
            impactPosition,
            damageAmount,
            _battlefield);

        if (collapsed)
        {
            _log.Warning("Heavy impact triggered ceiling collapse!");
            // JotunheimBiomeService handles damage and terrain creation
            // 3d8 Physical damage in 2x2 area
            // Creates [Debris Pile] terrain (difficult + cover)
        }
    }

    // ... rest of damage processing
}
```

---

## V. Forced Movement Integration

### Power Conduit Forced Contact

**Location**: `ForcedMovementService.ApplyForcedMovement()` or similar

```csharp
public void ApplyForcedMovement(Combatant combatant, GridPosition destination, BattlefieldState battlefield)
{
    // ... move combatant to destination

    var destTile = battlefield.Grid.GetTile(destination);

    // Check for Power Conduit contact
    if (destTile.HasEnvironmentalFeature("Live Power Conduit"))
    {
        _powerConduitService.ProcessForcedMovementIntoConduit(combatant, destTile, battlefield);
        // Double damage from forced contact
        _log.Warning("{Combatant} forced into Live Power Conduit - double damage!",
            combatant.Name);
    }

    // ... other forced movement effects
}
```

---

## VI. Sector Generation Integration

### Step 1: Room Template Loading

**Location**: `BiomeGenerationService.GenerateSector()` or `DungeonService.GenerateJotunheimSector()`

```csharp
public Sector GenerateJotunheimSector(int sectorId, int difficulty, int roomCount = 10)
{
    _log.Information("Generating Jötunheim sector {SectorId}, difficulty {Difficulty}",
        sectorId, difficulty);

    var sector = new Sector
    {
        SectorId = sectorId,
        BiomeId = 7, // Jötunheim
        Difficulty = difficulty,
        Rooms = new List<Room>()
    };

    // Load room templates from database
    var jotunheimRepo = new JotunheimDataRepository(_connectionString);

    var trunkTemplates = jotunheimRepo.GetTrunkTemplates(); // 7 templates
    var rootsTemplates = jotunheimRepo.GetRootsTemplates(); // 3 templates

    // Determine verticality split (70% Trunk, 30% Roots)
    int trunkRooms = (int)(roomCount * 0.7); // 7 rooms
    int rootsRooms = roomCount - trunkRooms; // 3 rooms

    // Generate Trunk rooms (factory floor)
    for (int i = 0; i < trunkRooms; i++)
    {
        var template = trunkTemplates[_diceService.Roll(0, trunkTemplates.Count - 1)];
        var room = CreateRoomFromTemplate(template, sector, "Trunk");
        sector.Rooms.Add(room);
    }

    // Generate Roots rooms (maintenance tunnels)
    for (int i = 0; i < rootsRooms; i++)
    {
        var template = rootsTemplates[_diceService.Roll(0, rootsTemplates.Count - 1)];
        var room = CreateRoomFromTemplate(template, sector, "Roots");
        sector.Rooms.Add(room);
    }

    // Populate rooms with enemies, hazards, resources
    foreach (var room in sector.Rooms)
    {
        PopulateJotunheimRoom(room, difficulty, jotunheimRepo);
    }

    _log.Information("Jötunheim sector generated: {TrunkRooms} Trunk, {RootsRooms} Roots",
        trunkRooms, rootsRooms);

    return sector;
}
```

### Step 2: Room Population

```csharp
private void PopulateJotunheimRoom(Room room, int difficulty, JotunheimDataRepository repo)
{
    _log.Debug("Populating Jötunheim room {RoomId} ({Template}, {Tier})",
        room.RoomId, room.TemplateName, room.VerticalityTier);

    // 1. Generate enemies using weighted spawn system
    var enemyNames = _jotunheimBiomeService.GenerateEnemyGroup(difficulty, room.VerticalityTier);
    room.Enemies = enemyNames.Select(name => _enemyFactory.CreateEnemy(name, 7)).ToList();

    // 2. Place environmental hazards
    PlaceJotunheimHazards(room, difficulty, repo);

    // 3. Place resources
    PlaceJotunheimResources(room, difficulty, repo);

    // 4. Add industrial cover (4-8 per room)
    PlaceIndustrialCover(room);

    // 5. Generate Jötun corpse terrain (25% of Trunk rooms)
    if (room.VerticalityTier == "Trunk" && _diceService.Roll(1, 100) <= 25)
    {
        _jotunCorpseTerrainService.GenerateCorpseLayout(room.Grid);
        _log.Information("Jötun corpse terrain placed in room {RoomId}", room.RoomId);
    }

    _log.Debug("Room populated: {EnemyCount} enemies, {HazardCount} hazards",
        room.Enemies.Count, room.Hazards?.Count ?? 0);
}
```

### Step 3: Hazard Placement

```csharp
private void PlaceJotunheimHazards(Room room, int difficulty, JotunheimDataRepository repo)
{
    var hazards = repo.GetEnvironmentalHazards(room.HazardDensity);

    // Ensure high Power Conduit density (signature hazard)
    int powerConduitCount = _diceService.Roll(2, 3); // 2-3 per room

    for (int i = 0; i < powerConduitCount; i++)
    {
        var validTiles = room.Grid.Tiles
            .Where(t => t.IsPassable && !t.HasAnyHazard())
            .ToList();

        if (validTiles.Any())
        {
            var tile = validTiles[_diceService.Roll(0, validTiles.Count - 1)];
            tile.AddEnvironmentalFeature("Live Power Conduit");
            _environmentalObjectService.CreateObject(tile.Position, "Power Conduit", 15);
        }
    }

    // Place steam vents (1-2 per room)
    int steamVentCount = _diceService.Roll(1, 2);
    for (int i = 0; i < steamVentCount; i++)
    {
        var validTiles = room.Grid.Tiles
            .Where(t => t.IsPassable && !t.HasAnyHazard())
            .ToList();

        if (validTiles.Any())
        {
            var tile = validTiles[_diceService.Roll(0, validTiles.Count - 1)];
            tile.AddEnvironmentalFeature("High-Pressure Steam Vent");
        }
    }

    // Place unstable ceilings (1-2 per room, near heavy machinery)
    if (room.TemplateName.Contains("Assembly") || room.TemplateName.Contains("Fabrication"))
    {
        int unstableCount = _diceService.Roll(1, 2);
        for (int i = 0; i < unstableCount; i++)
        {
            var validTiles = room.Grid.Tiles
                .Where(t => !t.HasAnyHazard())
                .ToList();

            if (validTiles.Any())
            {
                var tile = validTiles[_diceService.Roll(0, validTiles.Count - 1)];
                tile.AddEnvironmentalFeature("Unstable Ceiling/Wall");
            }
        }
    }

    // Randomly flood some tiles (10-20% of room)
    int floodedTileCount = (int)(room.Grid.Tiles.Count() * 0.15);
    for (int i = 0; i < floodedTileCount; i++)
    {
        var validTiles = room.Grid.Tiles
            .Where(t => t.IsPassable && !t.HasTerrain("Flooded (Coolant)"))
            .ToList();

        if (validTiles.Any())
        {
            var tile = validTiles[_diceService.Roll(0, validTiles.Count - 1)];
            tile.AddTerrain("Flooded (Coolant)");

            // Check if this floods a Power Conduit (AMPLIFICATION)
            if (tile.HasEnvironmentalFeature("Live Power Conduit"))
            {
                _log.Warning("Power Conduit at ({X}, {Y}) FLOODED - AMPLIFICATION ACTIVE",
                    tile.Position.X, tile.Position.Y);
            }
        }
    }
}
```

### Step 4: Industrial Cover Placement

```csharp
private void PlaceIndustrialCover(Room room)
{
    // Jötunheim has very high cover density (4-8 objects per room)
    int coverCount = _diceService.Roll(4, 8);

    for (int i = 0; i < coverCount; i++)
    {
        var validTiles = room.Grid.Tiles
            .Where(t => t.IsPassable && !t.IsOccupied && !t.HasEnvironmentalFeature("Cover (Industrial)"))
            .ToList();

        if (validTiles.Any())
        {
            var tile = validTiles[_diceService.Roll(0, validTiles.Count - 1)];
            tile.AddEnvironmentalFeature("Cover (Industrial)");
            // Options: shipping containers, engine blocks, heavy machinery, scrap piles
        }
    }

    _log.Debug("Placed {Count} industrial cover objects in room", coverCount);
}
```

---

## VII. Database Migration Execution

### Execute SQL Migrations (in order)

```bash
# Navigate to project root
cd /path/to/rune-rust

# Execute migrations
sqlite3 runeandrust.db < Data/v0.32.1_jotunheim_schema.sql
sqlite3 runeandrust.db < Data/v0.32.2_environmental_hazards.sql
sqlite3 runeandrust.db < Data/v0.32.3_enemy_definitions.sql

# Verify migrations
sqlite3 runeandrust.db <<EOF
-- Check biome exists with NO ambient condition
SELECT biome_id, biome_name, ambient_condition_id
FROM Biomes WHERE biome_id = 7;
-- Expected: 7 | Jotunheim | NULL

-- Check room templates (should be 10)
SELECT COUNT(*) FROM Biome_RoomTemplates WHERE biome_id = 7;
-- Expected: 10

-- Check verticality split
SELECT z_level, COUNT(*), SUM(enemy_spawn_weight)
FROM Biome_RoomTemplates WHERE biome_id = 7
GROUP BY z_level;
-- Expected: Trunk 7 templates, Roots 3 templates

-- Check environmental hazards
SELECT COUNT(*) FROM Biome_EnvironmentalFeatures WHERE biome_id = 7;
-- Expected: 11

-- Check enemies
SELECT COUNT(*) FROM Biome_EnemySpawns WHERE biome_id = 7;
-- Expected: 6

-- Verify Undying dominance
SELECT
  SUM(CASE WHEN enemy_type LIKE 'Undying%' THEN spawn_weight ELSE 0 END) * 100.0 / SUM(spawn_weight) as undying_percent
FROM Biome_EnemySpawns WHERE biome_id = 7;
-- Expected: ~60%
EOF
```

---

## VIII. Dependency Injection Setup

### Register Services in DI Container

```csharp
// In Startup.cs or ServiceConfiguration.cs

public void ConfigureServices(IServiceCollection services)
{
    // ... existing service registrations

    // Jötunheim services
    services.AddSingleton<JotunheimDataRepository>(sp =>
        new JotunheimDataRepository(Configuration.GetConnectionString("GameDatabase")));

    services.AddScoped<PowerConduitService>();
    services.AddScoped<JotunCorpseTerrainService>();
    services.AddScoped<JotunheimBiomeService>();

    // ... other services
}
```

---

## IX. Testing Checklist

### Manual Integration Tests

**Power Conduit Tests**:
- [ ] Standard conduit damages adjacent character (verify 1d8 Energy)
- [ ] Flooded conduit damages 2-tile radius (verify 2d10 Energy, AMPLIFIED message)
- [ ] Forced movement into conduit deals double damage
- [ ] Conduit can be destroyed (15 HP threshold)
- [ ] Conduit destruction removes feature from tile

**Steam Vent Tests**:
- [ ] Turn 1: Silent (no message)
- [ ] Turn 2: Warning message ("hissing loudly - pressure is building!")
- [ ] Turn 3: Eruption (2d6 Fire damage, knockback 1 tile, cone area)
- [ ] Turn 4-6: Cycle repeats
- [ ] Multiple vents erupt independently

**Ceiling Collapse Tests**:
- [ ] Heavy damage (10+) triggers collapse within 2 tiles
- [ ] Light damage (<10) does NOT trigger collapse
- [ ] Collapse deals 3d8 Physical damage in 2x2 area
- [ ] Collapse creates [Debris Pile] terrain
- [ ] Unstable ceiling removed after collapse (one-time only)

**Jötun Proximity Stress Tests**:
- [ ] Character on corpse terrain gains +2 Stress per turn
- [ ] Stress accumulates over multiple turns (turn 5 = +10 total)
- [ ] Character NOT on corpse terrain gains no Stress
- [ ] Combat log shows Stress messages (every 3 turns to reduce spam)

**Corpse Terrain Generation Tests**:
- [ ] Hull Section: 4x6 platform at elevation +2
- [ ] Limb Bridge: 2-tile-wide bridge at elevation +3
- [ ] Interior Cavity: 3x4 enclosed area at elevation 0
- [ ] 25% of Trunk rooms have corpse terrain
- [ ] Roots rooms do NOT have corpse terrain (too small)

**Enemy Spawn Tests**:
- [ ] Generate 10 enemy groups, verify ~60% Undying
- [ ] Draugr Juggernaut spawns rarely (elite)
- [ ] Trunk rooms get all enemy types
- [ ] Roots rooms may have restricted spawns (check "Both" vs "Trunk" only)

**NO Ambient Condition Test** (CRITICAL):
- [ ] Combat starts in Jötunheim room
- [ ] NO ambient condition message appears
- [ ] VerifyNoAmbientCondition() returns true
- [ ] Only direct hazards deal damage (no ambient effects)

---

## X. Performance Considerations

### Optimization Tips

1. **Cache Enemy Spawn Weights**:
   ```csharp
   private Dictionary<string, Dictionary<string, int>>? _cachedSpawnWeights;

   private Dictionary<string, int> GetCachedSpawnWeights(string? verticalityTier)
   {
       var key = verticalityTier ?? "All";
       if (_cachedSpawnWeights == null)
       {
           _cachedSpawnWeights = new Dictionary<string, Dictionary<string, int>>();
       }

       if (!_cachedSpawnWeights.ContainsKey(key))
       {
           _cachedSpawnWeights[key] = _dataRepository.GetEnemySpawnWeights(verticalityTier);
       }

       return _cachedSpawnWeights[key];
   }
   ```

2. **Batch Hazard Processing**:
   - Process all conduits in one pass (already done in PowerConduitService)
   - Process all steam vents in one pass (already done in JotunheimBiomeService)

3. **Limit Combat Log Spam**:
   - Jötun proximity Stress logs only every 3 turns
   - Flooded terrain logs only every 2 turns
   - Already implemented in services

---

## XI. Common Issues & Solutions

### Issue 1: Power Conduits Not Dealing Damage

**Symptom**: Characters adjacent to conduits take no damage
**Cause**: `ProcessPowerConduitsForTurn()` not called in turn processing
**Solution**: Add to `ProcessTurn()` method:
```csharp
if (_currentRoom.BiomeId == 7)
{
    _jotunheimBiomeService.ProcessEnvironmentalHazards(_battlefield, currentTurn);
}
```

### Issue 2: Steam Vents Never Erupt

**Symptom**: Steam vents show warning but never erupt
**Cause**: Turn counter not incrementing or cycle check incorrect
**Solution**: Verify `ProcessSteamVents()` is called every turn, check `_steamVentLastEruption` dictionary

### Issue 3: Ceiling Collapse Always Triggers

**Symptom**: Every attack triggers ceiling collapse
**Cause**: Damage threshold check missing or incorrect
**Solution**: Verify `damageDealt >= 10` check in `CheckCeilingCollapse()`

### Issue 4: NO Ambient Condition Error on Startup

**Symptom**: "INTEGRITY ERROR: Jötunheim has ambient condition set"
**Cause**: Database has non-NULL `ambient_condition_id` for biome_id = 7
**Solution**: Execute SQL fix:
```sql
UPDATE Biomes SET ambient_condition_id = NULL WHERE biome_id = 7;
```

### Issue 5: Undying Spawn Rate Too Low/High

**Symptom**: Not seeing ~60% Undying enemies
**Cause**: Spawn weights incorrect in database or weighted roll logic broken
**Solution**: Verify spawn weights in database:
```sql
SELECT enemy_name, enemy_type, spawn_weight,
  ROUND(100.0 * spawn_weight / (SELECT SUM(spawn_weight) FROM Biome_EnemySpawns WHERE biome_id = 7), 1) as percentage
FROM Biome_EnemySpawns WHERE biome_id = 7
ORDER BY spawn_weight DESC;
```

---

## XII. Success Criteria

### Integration Complete When:

- [ ] Combat initializes in Jötunheim with NO ambient condition
- [ ] Power Conduits deal damage every turn (standard or flooded)
- [ ] Steam Vents erupt predictably every 3 turns with warning
- [ ] Ceiling Collapses trigger on heavy damage (10+)
- [ ] Jötun proximity Stress accumulates on corpse terrain (+2/turn)
- [ ] Enemy groups spawn with ~60% Undying dominance
- [ ] Jötun corpse terrain appears in ~25% of Trunk rooms
- [ ] All 46 unit tests pass
- [ ] No performance issues in 50+ turn combat scenarios
- [ ] Database queries execute in <10ms
- [ ] Sector generation completes in <500ms

---

## XIII. Related Documents

- **v0.32.1 Implementation Summary**: Database schema & room templates
- **v0.32.2 Implementation Summary**: Environmental hazards & services
- **v0.32.3 Implementation Summary**: Enemy definitions & spawn system
- **v0.32.4 Implementation Summary**: Service implementation & testing

---

**Integration Status**: Ready for manual integration
**Estimated Time**: 6-10 hours
**Prerequisites**: All v0.32.1-v0.32.4 implementations complete ✅
**Next Steps**: Execute database migrations, implement integration hooks, run manual tests

---

**Author**: Claude (AI Assistant)
**Review Status**: Ready for developer integration
**Last Updated**: 2025-11-16
