# v0.1.0b Design Specification: Procedural Room Generation

**Version:** 0.1.0b
**Phase Name:** Procedural Room Generation
**Parent Version:** v0.1.0 (Expanded Dungeon & Z-Axis)
**Prerequisites:** v0.1.0a Complete (Z-Axis Foundation)
**Estimated Tests:** ~25 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Room Template System](#4-room-template-system)
5. [Room Generator Service](#5-room-generator-service)
6. [Depth-Based Scaling](#6-depth-based-scaling)
7. [Generation Rules & Configuration](#7-generation-rules--configuration)
8. [On-Demand Room Generation](#8-on-demand-room-generation)
9. [Monster & Item Placement](#9-monster--item-placement)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement a procedural room generation system that creates dungeon rooms dynamically as players explore. This system uses configurable room templates organized by biome, applies depth-based difficulty scaling for monsters and loot, and integrates seamlessly with the existing environment context system from v0.0.11.

### 1.2 Current State

| Area | Current State (v0.1.0a) | Target State (v0.1.0b) |
|------|-------------------------|------------------------|
| Room creation | Static factory (`CreateStarterDungeon`) | Dynamic procedural generation |
| Room templates | None | Biome-specific configurable templates |
| Difficulty scaling | Fixed monster stats | Depth-based level modifiers |
| Loot quality | Fixed drop rates | Depth-enhanced drop chances |
| Exit generation | Manual connections | Probabilistic exit placement |
| Biome transitions | Single biome dungeon | Depth-based biome layering |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Configuration** | `room-templates.json`, `generation-rules.json` |
| **Services** | `IRoomGeneratorService`, `RoomGeneratorService` |
| **Configuration Classes** | `RoomTemplateConfiguration`, `GenerationRulesConfiguration` |
| **Value Objects** | `GenerationContext`, `GeneratedRoomResult` |
| **Tests** | ~25 new unit tests |

### 1.4 Architectural Significance

This version establishes the **procedural content generation pattern** that will be used throughout the game:
- Template-based content generation with weighted random selection
- Seeded randomization for reproducibility
- Configuration-driven generation rules
- Depth/difficulty scaling infrastructure

---

## 2. Feature Overview

```
v0.1.0b Procedural Room Generation
├── Room Template System
│   ├── RoomTemplate configuration class
│   ├── Biome-specific template collections
│   ├── Description pools per template
│   └── Weighted random template selection
├── Room Generator Service
│   ├── IRoomGeneratorService interface
│   ├── RoomGeneratorService implementation
│   ├── Position-based deterministic seeding
│   └── Template selection by biome
├── Depth-Based Scaling
│   ├── Monster level modifiers
│   ├── Loot quality modifiers
│   ├── Biome transition depths
│   └── Difficulty multipliers
├── Generation Rules
│   ├── Exit probability rules
│   ├── Room limits per level
│   ├── Minimum/maximum exits
│   └── Vertical connection chances
├── On-Demand Generation
│   ├── Generate on player movement
│   ├── GetOrGenerateRoom() method
│   └── Dungeon lazy population
└── Monster & Item Placement
    ├── Template-based spawn chances
    ├── Depth-scaled monster selection
    └── Loot quality enhancement
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  GameSessionHandler                                                          │
│  └── HandleMove()                                                           │
│      └── Triggers room generation if moving to unexplored position         │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  GameSessionService                   RoomGeneratorService                   │
│  ├── TryMove()                        ├── GenerateRoom()                    │
│  │   └── Call GetOrGenerateRoom()     ├── GetOrGenerateRoom()               │
│  └── GetCurrentRoom()                 ├── DetermineExits()                  │
│                                       ├── GetDepthDifficultyModifier()      │
│  Configuration:                       ├── SelectTemplate()                  │
│  ├── RoomTemplateConfiguration        └── GenerateContent()                 │
│  └── GenerationRulesConfiguration                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Entities:                      Value Objects:           Enums:             │
│  ┌─────────────────────┐       ┌─────────────────────┐                      │
│  │ Room                │       │ Position3D          │                      │
│  │ ├── Position3D      │       │ EnvironmentContext  │                      │
│  │ ├── Environment     │       │ GenerationContext   │                      │
│  │ └── IsGenerated     │       │ GeneratedRoomResult │                      │
│  └─────────────────────┘       └─────────────────────┘                      │
│  ┌─────────────────────┐                                                    │
│  │ Dungeon             │                                                    │
│  │ ├── GetOrGenerate() │                                                    │
│  │ └── MarkExplored()  │                                                    │
│  └─────────────────────┘                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetRoomTemplateConfiguration()                                         │
│  └── GetGenerationRulesConfiguration()                                      │
│                                                                              │
│  Config Files:                                                               │
│  ├── config/room-templates.json                                             │
│  └── config/generation-rules.json                                           │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Room Generation Flow

```
┌───────────────────┐
│ Player moves to   │
│ unexplored exit   │
└─────────┬─────────┘
          │
          ▼
┌───────────────────────────────────────┐
│ GameSessionService.TryMove(direction) │
├───────────────────────────────────────┤
│ 1. Get target position (Position3D)   │
│ 2. Check if room exists at position   │
│    ├── Exists? Return existing room   │
│    └── Not exists? Generate new room  │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────┐
│ RoomGeneratorService.GetOrGenerateRoom()  │
├───────────────────────────────────────────┤
│ 1. Calculate seed from position           │
│    └── seed = Hash(X, Y, Z, dungeonSeed)  │
│ 2. Determine biome for depth              │
│    └── Check biomeTransitionDepths        │
│ 3. Select template by biome               │
│    └── Weighted random from valid temps   │
│ 4. Generate room name from template       │
│ 5. Generate room description              │
│ 6. Determine exits (probability-based)    │
│ 7. Apply depth difficulty modifier        │
│ 8. Generate monsters (if any)             │
│ 9. Generate items (if any)                │
│ 10. Set environment context               │
│ 11. Return GeneratedRoomResult            │
└───────────────┬───────────────────────────┘
                │
                ▼
┌───────────────────────────────────────┐
│ Dungeon.AddRoom(generatedRoom)        │
│ Dungeon.ConnectRooms(from, dir, to)   │
└───────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────┐
│ Player enters newly generated room    │
│ Room description displayed            │
└───────────────────────────────────────┘
```

### 3.3 Template Selection Flow

```
┌─────────────────────────┐
│ GenerateRoom(position)  │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ Determine biome for this depth          │
├─────────────────────────────────────────┤
│ Z=0-1 → "dungeon" (100%)                │
│ Z=2-3 → "dungeon" (70%) | "cave" (30%)  │
│ Z=4-5 → "cave" (70%) | "volcanic" (30%) │
│ Z=6+  → "volcanic" (70%) | "cave" (30%) │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ Filter templates by biome               │
├─────────────────────────────────────────┤
│ template.biomes.Contains(currentBiome)  │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ Weighted random selection               │
├─────────────────────────────────────────┤
│ dungeon_corridor: weight 40             │
│ dungeon_chamber: weight 30              │
│ dungeon_alcove: weight 20               │
│ dungeon_junction: weight 10             │
│                                         │
│ Total = 100, roll 0-99                  │
│ 0-39 → corridor, 40-69 → chamber, etc.  │
└───────────┬─────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────┐
│ Return selected template                │
└─────────────────────────────────────────┘
```

---

## 4. Room Template System

### 4.1 Purpose

Define reusable room templates that specify possible names, descriptions, exit probabilities, and content spawn chances for procedurally generated rooms.

### 4.2 RoomTemplate Configuration Class

**File:** `src/Core/RuneAndRust.Application/Configuration/RoomTemplateConfiguration.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration for room templates loaded from JSON.
/// </summary>
public class RoomTemplateConfiguration
{
    /// <summary>
    /// Schema version for configuration validation.
    /// </summary>
    public string Version { get; init; } = "1.0";

    /// <summary>
    /// Available room templates keyed by template ID.
    /// </summary>
    public IReadOnlyDictionary<string, RoomTemplate> Templates { get; init; } =
        new Dictionary<string, RoomTemplate>();
}

/// <summary>
/// Defines a room template for procedural generation.
/// </summary>
/// <remarks>
/// Room templates specify the properties of generated rooms including
/// possible names, descriptions, exit probabilities, and content spawn chances.
/// Templates are associated with biomes and selected via weighted random.
/// </remarks>
public class RoomTemplate
{
    /// <summary>
    /// Unique identifier for this template.
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Biomes this template can appear in.
    /// </summary>
    public IReadOnlyList<string> Biomes { get; init; } = [];

    /// <summary>
    /// Possible room names (one selected randomly).
    /// </summary>
    public IReadOnlyList<string> Names { get; init; } = [];

    /// <summary>
    /// Descriptor pool IDs for generating descriptions.
    /// </summary>
    public IReadOnlyList<string> DescriptionPools { get; init; } = [];

    /// <summary>
    /// Static description templates (fallback if no pools).
    /// </summary>
    public IReadOnlyList<string> DescriptionTemplates { get; init; } = [];

    /// <summary>
    /// Exit probability per direction (0.0 to 1.0).
    /// </summary>
    public IReadOnlyDictionary<string, float> ExitProbabilities { get; init; } =
        new Dictionary<string, float>();

    /// <summary>
    /// Probability (0.0 to 1.0) of spawning a monster.
    /// </summary>
    public float MonsterChance { get; init; }

    /// <summary>
    /// Probability (0.0 to 1.0) of spawning an item.
    /// </summary>
    public float ItemChance { get; init; }

    /// <summary>
    /// Selection weight (higher = more likely).
    /// </summary>
    public int Weight { get; init; } = 10;

    /// <summary>
    /// Optional room type override (null = Standard).
    /// </summary>
    public string? RoomTypeOverride { get; init; }

    /// <summary>
    /// Minimum depth (Z level) for this template.
    /// </summary>
    public int MinDepth { get; init; } = 0;

    /// <summary>
    /// Maximum depth (Z level) for this template (-1 = no limit).
    /// </summary>
    public int MaxDepth { get; init; } = -1;

    /// <summary>
    /// Tags applied to rooms generated from this template.
    /// </summary>
    public IReadOnlyList<string> ImpliedTags { get; init; } = [];

    /// <summary>
    /// Gets the probability for a specific exit direction.
    /// </summary>
    /// <param name="direction">Direction name (e.g., "north", "up").</param>
    /// <returns>Probability from 0.0 to 1.0, defaults to 0.0 if not specified.</returns>
    public float GetExitProbability(string direction) =>
        ExitProbabilities.TryGetValue(direction.ToLowerInvariant(), out var prob) ? prob : 0f;

    /// <summary>
    /// Checks if this template is valid for the given depth.
    /// </summary>
    /// <param name="depth">The Z-level depth.</param>
    /// <returns>True if the template can be used at this depth.</returns>
    public bool IsValidForDepth(int depth)
    {
        if (depth < MinDepth) return false;
        if (MaxDepth >= 0 && depth > MaxDepth) return false;
        return true;
    }
}
```

### 4.3 Template Selection

Templates are selected using weighted random based on:
1. Biome match (template must support current biome)
2. Depth validity (MinDepth ≤ currentDepth ≤ MaxDepth)
3. Weight (higher weight = more likely selection)

---

## 5. Room Generator Service

### 5.1 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IRoomGeneratorService.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for procedural room generation.
/// </summary>
public interface IRoomGeneratorService
{
    /// <summary>
    /// Generates a new room at the specified position.
    /// </summary>
    /// <param name="position">The 3D position for the new room.</param>
    /// <param name="biomeId">The biome identifier for template selection.</param>
    /// <param name="seed">Seed for deterministic generation.</param>
    /// <returns>A result containing the generated room and metadata.</returns>
    GeneratedRoomResult GenerateRoom(Position3D position, string biomeId, int seed);

    /// <summary>
    /// Gets an existing room or generates a new one at the specified position.
    /// </summary>
    /// <param name="dungeon">The dungeon to check/add the room to.</param>
    /// <param name="position">The 3D position to check.</param>
    /// <param name="fromDirection">The direction the player came from (for guaranteed return exit).</param>
    /// <returns>The existing or newly generated room.</returns>
    Room GetOrGenerateRoom(Dungeon dungeon, Position3D position, Direction? fromDirection = null);

    /// <summary>
    /// Determines which exits a generated room should have.
    /// </summary>
    /// <param name="position">The room position.</param>
    /// <param name="template">The selected room template.</param>
    /// <param name="seed">Seed for deterministic generation.</param>
    /// <param name="guaranteedExit">A direction that must have an exit (for return path).</param>
    /// <returns>Collection of directions that should have exits.</returns>
    IEnumerable<Direction> DetermineExits(
        Position3D position,
        RoomTemplate template,
        int seed,
        Direction? guaranteedExit = null);

    /// <summary>
    /// Calculates the difficulty modifier for a given depth.
    /// </summary>
    /// <param name="depth">The Z-level depth.</param>
    /// <returns>A multiplier applied to monster stats and loot quality.</returns>
    float GetDepthDifficultyModifier(int depth);

    /// <summary>
    /// Determines the biome for a given depth based on transition rules.
    /// </summary>
    /// <param name="depth">The Z-level depth.</param>
    /// <param name="seed">Seed for deterministic biome selection.</param>
    /// <returns>The biome ID for this depth.</returns>
    string DetermineBiomeForDepth(int depth, int seed);
}
```

### 5.2 GenerationContext Value Object

**File:** `src/Core/RuneAndRust.Application/ValueObjects/GenerationContext.cs`

```csharp
namespace RuneAndRust.Application.ValueObjects;

/// <summary>
/// Context for room generation including seed and modifiers.
/// </summary>
/// <param name="Position">The 3D position being generated.</param>
/// <param name="Seed">The generation seed for this room.</param>
/// <param name="BiomeId">The biome for template selection.</param>
/// <param name="DifficultyModifier">The depth-based difficulty multiplier.</param>
/// <param name="GuaranteedExitDirection">Direction that must have an exit.</param>
public readonly record struct GenerationContext(
    Position3D Position,
    int Seed,
    string BiomeId,
    float DifficultyModifier,
    Direction? GuaranteedExitDirection = null)
{
    /// <summary>
    /// Gets the depth (Z-level) from the position.
    /// </summary>
    public int Depth => Position.Z;

    /// <summary>
    /// Creates a Random instance seeded for this context.
    /// </summary>
    public Random CreateRandom() => new(Seed);

    /// <summary>
    /// Creates a position-specific seed by combining position and base seed.
    /// </summary>
    public static int CreatePositionSeed(Position3D position, int baseSeed) =>
        HashCode.Combine(position.X, position.Y, position.Z, baseSeed);
}
```

### 5.3 GeneratedRoomResult Value Object

**File:** `src/Core/RuneAndRust.Application/ValueObjects/GeneratedRoomResult.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.ValueObjects;

/// <summary>
/// Result of procedural room generation.
/// </summary>
/// <param name="Room">The generated room entity.</param>
/// <param name="GeneratedExits">Directions with exits (not yet connected).</param>
/// <param name="TemplateId">The template used for generation.</param>
/// <param name="BiomeId">The biome applied to the room.</param>
/// <param name="DifficultyModifier">The depth-based difficulty multiplier.</param>
public readonly record struct GeneratedRoomResult(
    Room Room,
    IReadOnlyList<Direction> GeneratedExits,
    string TemplateId,
    string BiomeId,
    float DifficultyModifier)
{
    /// <summary>
    /// Checks if the generation produced any exits.
    /// </summary>
    public bool HasExits => GeneratedExits.Count > 0;

    /// <summary>
    /// Checks if a specific direction has an exit.
    /// </summary>
    public bool HasExit(Direction direction) => GeneratedExits.Contains(direction);
}
```

### 5.4 Service Implementation

**File:** `src/Core/RuneAndRust.Application/Services/RoomGeneratorService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Configuration;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.ValueObjects;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for procedural room generation.
/// </summary>
public class RoomGeneratorService : IRoomGeneratorService
{
    private readonly RoomTemplateConfiguration _templateConfig;
    private readonly GenerationRulesConfiguration _rulesConfig;
    private readonly BiomeConfiguration _biomeConfig;
    private readonly IMonsterService _monsterService;
    private readonly ILogger<RoomGeneratorService> _logger;

    /// <summary>
    /// Creates a new RoomGeneratorService.
    /// </summary>
    public RoomGeneratorService(
        RoomTemplateConfiguration templateConfig,
        GenerationRulesConfiguration rulesConfig,
        BiomeConfiguration biomeConfig,
        IMonsterService monsterService,
        ILogger<RoomGeneratorService> logger)
    {
        _templateConfig = templateConfig ?? throw new ArgumentNullException(nameof(templateConfig));
        _rulesConfig = rulesConfig ?? throw new ArgumentNullException(nameof(rulesConfig));
        _biomeConfig = biomeConfig ?? throw new ArgumentNullException(nameof(biomeConfig));
        _monsterService = monsterService ?? throw new ArgumentNullException(nameof(monsterService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public GeneratedRoomResult GenerateRoom(Position3D position, string biomeId, int seed)
    {
        var random = new Random(seed);
        var difficultyModifier = GetDepthDifficultyModifier(position.Z);

        // Select template
        var template = SelectTemplate(biomeId, position.Z, random);
        if (template == null)
        {
            _logger.LogWarning(
                "No valid template found for biome {Biome} at depth {Depth}, using fallback",
                biomeId, position.Z);
            template = CreateFallbackTemplate();
        }

        // Generate room name
        var name = SelectRandomFromList(template.Names, random) ?? "Unknown Chamber";

        // Generate description
        var description = GenerateDescription(template, random);

        // Create room
        var room = new Room(name, description, position);

        // Set environment context
        var environment = CreateEnvironmentContext(biomeId, template);
        room.SetEnvironment(environment);

        // Determine exits
        var exits = DetermineExits(position, template, seed, null).ToList();

        // Generate content
        GenerateRoomContent(room, template, difficultyModifier, random);

        _logger.LogDebug(
            "Generated room '{Name}' at {Position} using template {Template} (biome: {Biome})",
            name, position, template.Id, biomeId);

        return new GeneratedRoomResult(room, exits, template.Id, biomeId, difficultyModifier);
    }

    /// <inheritdoc />
    public Room GetOrGenerateRoom(Dungeon dungeon, Position3D position, Direction? fromDirection = null)
    {
        ArgumentNullException.ThrowIfNull(dungeon);

        // Check if room already exists
        var existingRoom = dungeon.GetRoomByPosition(position);
        if (existingRoom != null)
        {
            _logger.LogDebug("Returning existing room at {Position}", position);
            return existingRoom;
        }

        // Generate new room
        var baseSeed = dungeon.GetHashCode(); // Use dungeon as base seed
        var seed = GenerationContext.CreatePositionSeed(position, baseSeed);
        var biomeId = DetermineBiomeForDepth(position.Z, seed);

        var result = GenerateRoom(position, biomeId, seed);

        // Add to dungeon
        dungeon.AddRoom(result.Room);

        // Guarantee return exit if coming from somewhere
        if (fromDirection.HasValue)
        {
            var returnDirection = Dungeon.GetOppositeDirection(fromDirection.Value);
            if (!result.HasExit(returnDirection))
            {
                // Guaranteed return exit is handled during connection
            }
        }

        _logger.LogInformation(
            "Generated new room '{Name}' at {Position}",
            result.Room.Name, position);

        return result.Room;
    }

    /// <inheritdoc />
    public IEnumerable<Direction> DetermineExits(
        Position3D position,
        RoomTemplate template,
        int seed,
        Direction? guaranteedExit = null)
    {
        var random = new Random(seed + 1); // Offset seed for exit generation
        var exits = new List<Direction>();

        // Check each direction
        foreach (Direction direction in Enum.GetValues<Direction>())
        {
            var directionName = direction.ToString().ToLowerInvariant();
            var probability = template.GetExitProbability(directionName);

            // Guaranteed exit always included
            if (guaranteedExit.HasValue && direction == guaranteedExit.Value)
            {
                exits.Add(direction);
                continue;
            }

            // Roll for probability
            if (random.NextDouble() < probability)
            {
                exits.Add(direction);
            }
        }

        // Ensure minimum exits (excluding guaranteed)
        var minExits = _rulesConfig.MinExitsPerRoom;
        while (exits.Count < minExits && exits.Count < 6)
        {
            var availableDirections = Enum.GetValues<Direction>()
                .Where(d => !exits.Contains(d))
                .ToList();

            if (availableDirections.Count == 0) break;

            var randomDir = availableDirections[random.Next(availableDirections.Count)];
            exits.Add(randomDir);
        }

        // Enforce maximum exits
        var maxExits = _rulesConfig.MaxExitsPerRoom;
        if (exits.Count > maxExits && guaranteedExit.HasValue)
        {
            // Keep guaranteed exit, remove random others
            exits = exits
                .OrderBy(e => e == guaranteedExit.Value ? 0 : 1)
                .ThenBy(_ => random.Next())
                .Take(maxExits)
                .ToList();
        }

        return exits;
    }

    /// <inheritdoc />
    public float GetDepthDifficultyModifier(int depth)
    {
        if (depth <= 0) return 1.0f;

        var multiplier = _rulesConfig.DepthDifficultyMultiplier;
        return 1.0f + (depth * multiplier);
    }

    /// <inheritdoc />
    public string DetermineBiomeForDepth(int depth, int seed)
    {
        var random = new Random(seed + 2); // Offset seed for biome selection

        // Check biome transition depths
        foreach (var transition in _rulesConfig.BiomeTransitionDepths
            .OrderByDescending(t => t.Value.MinDepth))
        {
            var biomeId = transition.Key;
            var range = transition.Value;

            if (depth >= range.MinDepth && (range.MaxDepth < 0 || depth <= range.MaxDepth))
            {
                // Check transition probability
                var probability = range.TransitionProbability;
                if (random.NextDouble() < probability)
                {
                    return biomeId;
                }
            }
        }

        // Default to dungeon
        return "dungeon";
    }

    // ===== Private Methods =====

    private RoomTemplate? SelectTemplate(string biomeId, int depth, Random random)
    {
        var validTemplates = _templateConfig.Templates.Values
            .Where(t => t.Biomes.Contains(biomeId))
            .Where(t => t.IsValidForDepth(depth))
            .ToList();

        if (validTemplates.Count == 0) return null;

        // Weighted random selection
        var totalWeight = validTemplates.Sum(t => t.Weight);
        var roll = random.Next(totalWeight);
        var cumulative = 0;

        foreach (var template in validTemplates)
        {
            cumulative += template.Weight;
            if (roll < cumulative)
            {
                return template;
            }
        }

        return validTemplates.Last();
    }

    private static RoomTemplate CreateFallbackTemplate() => new()
    {
        Id = "fallback",
        Biomes = ["dungeon", "cave", "volcanic"],
        Names = ["Dark Chamber", "Unknown Room", "Mysterious Space"],
        DescriptionTemplates = ["A room shrouded in darkness. You can barely make out the walls."],
        ExitProbabilities = new Dictionary<string, float>
        {
            ["north"] = 0.5f,
            ["south"] = 0.5f,
            ["east"] = 0.5f,
            ["west"] = 0.5f
        },
        MonsterChance = 0.3f,
        ItemChance = 0.1f,
        Weight = 1
    };

    private string GenerateDescription(RoomTemplate template, Random random)
    {
        // Try description templates first
        if (template.DescriptionTemplates.Count > 0)
        {
            return SelectRandomFromList(template.DescriptionTemplates, random)
                ?? "A mysterious room.";
        }

        // Fallback
        return "A room of unknown origin.";
    }

    private static string? SelectRandomFromList(IReadOnlyList<string> list, Random random)
    {
        if (list.Count == 0) return null;
        return list[random.Next(list.Count)];
    }

    private EnvironmentContext CreateEnvironmentContext(string biomeId, RoomTemplate template)
    {
        var categoryValues = new Dictionary<string, string>
        {
            ["biome"] = biomeId
        };

        // Get biome defaults
        if (_biomeConfig.Biomes.TryGetValue(biomeId, out var biome))
        {
            foreach (var kvp in biome.DefaultCategoryValues)
            {
                categoryValues[kvp.Key] = kvp.Value;
            }
        }

        // Combine biome and template tags
        var tags = new List<string>();
        if (_biomeConfig.Biomes.TryGetValue(biomeId, out var biomeDef))
        {
            tags.AddRange(biomeDef.ImpliedTags);
        }
        tags.AddRange(template.ImpliedTags);

        return new EnvironmentContext(categoryValues, tags);
    }

    private void GenerateRoomContent(
        Room room,
        RoomTemplate template,
        float difficultyModifier,
        Random random)
    {
        // Monster generation
        if (random.NextDouble() < template.MonsterChance)
        {
            // TODO: Use _monsterService to spawn depth-appropriate monster
            // Monster level = baseLevel * difficultyModifier
            _logger.LogDebug(
                "Room {Room} would spawn monster (chance: {Chance}, modifier: {Modifier})",
                room.Name, template.MonsterChance, difficultyModifier);
        }

        // Item generation
        if (random.NextDouble() < template.ItemChance)
        {
            // TODO: Use item service to spawn depth-appropriate item
            // Item quality enhanced by depth
            _logger.LogDebug(
                "Room {Room} would spawn item (chance: {Chance}, modifier: {Modifier})",
                room.Name, template.ItemChance, difficultyModifier);
        }
    }
}
```

---

## 6. Depth-Based Scaling

### 6.1 Difficulty Modifier Calculation

The depth difficulty modifier affects monster stats and loot quality:

```
DifficultyModifier = 1.0 + (Depth × DepthDifficultyMultiplier)
```

**Default multiplier:** 0.15 (15% increase per level)

| Depth (Z) | Modifier | Monster Health | Monster Attack |
|-----------|----------|----------------|----------------|
| 0 | 1.00 | 100% | 100% |
| 1 | 1.15 | 115% | 115% |
| 2 | 1.30 | 130% | 130% |
| 3 | 1.45 | 145% | 145% |
| 4 | 1.60 | 160% | 160% |
| 5 | 1.75 | 175% | 175% |

### 6.2 Loot Quality Scaling

Loot quality improves with depth:

```
LootQualityModifier = 1.0 + (Depth × DepthLootQualityMultiplier)
```

**Default multiplier:** 0.10 (10% increase per level)

| Depth (Z) | Quality Modifier | Effect |
|-----------|------------------|--------|
| 0 | 1.00 | Base drop rates |
| 1-2 | 1.10-1.20 | +10-20% drop chance |
| 3-4 | 1.30-1.40 | +30-40% drop chance |
| 5+ | 1.50+ | +50%+ drop chance |

### 6.3 Biome Transition Depths

Biomes change as players descend:

| Depth Range | Primary Biome | Secondary Chance |
|-------------|---------------|------------------|
| 0-1 | dungeon | - |
| 2-3 | dungeon (70%) | cave (30%) |
| 4-5 | cave (60%) | volcanic (30%), dungeon (10%) |
| 6+ | volcanic (50%) | cave (40%), dungeon (10%) |

---

## 7. Generation Rules & Configuration

### 7.1 GenerationRulesConfiguration Class

**File:** `src/Core/RuneAndRust.Application/Configuration/GenerationRulesConfiguration.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration for procedural generation rules.
/// </summary>
public class GenerationRulesConfiguration
{
    /// <summary>
    /// Schema version for configuration validation.
    /// </summary>
    public string Version { get; init; } = "1.0";

    /// <summary>
    /// Maximum rooms allowed per dungeon level.
    /// </summary>
    public int MaxRoomsPerLevel { get; init; } = 50;

    /// <summary>
    /// Minimum exits per generated room.
    /// </summary>
    public int MinExitsPerRoom { get; init; } = 1;

    /// <summary>
    /// Maximum exits per generated room.
    /// </summary>
    public int MaxExitsPerRoom { get; init; } = 4;

    /// <summary>
    /// Difficulty multiplier applied per depth level.
    /// </summary>
    public float DepthDifficultyMultiplier { get; init; } = 0.15f;

    /// <summary>
    /// Loot quality multiplier applied per depth level.
    /// </summary>
    public float DepthLootQualityMultiplier { get; init; } = 0.10f;

    /// <summary>
    /// Base chance for stairs down to appear.
    /// </summary>
    public float StairsDownChanceBase { get; init; } = 0.08f;

    /// <summary>
    /// Whether stairs up are guaranteed at deeper levels.
    /// </summary>
    public bool StairsUpGuaranteedIfDeep { get; init; } = true;

    /// <summary>
    /// Depth at which stairs up become guaranteed.
    /// </summary>
    public int StairsUpGuaranteedDepth { get; init; } = 2;

    /// <summary>
    /// Maximum depth for dungeon generation.
    /// </summary>
    public int MaxDungeonDepth { get; init; } = 10;

    /// <summary>
    /// Biome transition depth configurations.
    /// </summary>
    public IReadOnlyDictionary<string, BiomeDepthRange> BiomeTransitionDepths { get; init; } =
        new Dictionary<string, BiomeDepthRange>();
}

/// <summary>
/// Defines the depth range and transition probability for a biome.
/// </summary>
public class BiomeDepthRange
{
    /// <summary>
    /// Minimum depth where this biome can appear.
    /// </summary>
    public int MinDepth { get; init; }

    /// <summary>
    /// Maximum depth for this biome (-1 = no limit).
    /// </summary>
    public int MaxDepth { get; init; } = -1;

    /// <summary>
    /// Probability (0.0 to 1.0) of transitioning to this biome.
    /// </summary>
    public float TransitionProbability { get; init; } = 1.0f;
}
```

---

## 8. On-Demand Room Generation

### 8.1 Integration with GameSessionService

When a player moves toward an unexplored exit, the system:

1. **Checks** if a room exists at the target position
2. **Generates** a new room if none exists
3. **Connects** the rooms bidirectionally
4. **Updates** the player position

### 8.2 Dungeon Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Dungeon.cs` (additions)

```csharp
/// <summary>
/// Checks if generation is allowed at the specified position.
/// </summary>
/// <param name="position">The target position.</param>
/// <returns>True if room generation is allowed.</returns>
public bool CanGenerateAt(Position3D position)
{
    // Check if room already exists
    if (HasRoomAt(position)) return false;

    // Check max rooms per level
    var roomsOnLevel = _rooms.Values.Count(r => r.Position.Z == position.Z);
    return roomsOnLevel < MaxRoomsPerLevel;
}

/// <summary>
/// Gets or creates a room at the specified position.
/// </summary>
/// <remarks>
/// This method is called by the RoomGeneratorService during on-demand generation.
/// It ensures thread-safe room creation.
/// </remarks>
public Room? GetOrAddRoom(Position3D position, Func<Room> roomFactory)
{
    if (HasRoomAt(position))
    {
        return GetRoomByPosition(position);
    }

    if (!CanGenerateAt(position))
    {
        return null; // Generation not allowed
    }

    var room = roomFactory();
    AddRoom(room);
    return room;
}

/// <summary>
/// Maximum rooms allowed per level (Z).
/// </summary>
public int MaxRoomsPerLevel { get; set; } = 50;
```

### 8.3 Exit Placeholder Pattern

When a room is generated, exits are created as "potential" connections:

```csharp
/// <summary>
/// Represents a potential exit that may lead to a generated or existing room.
/// </summary>
public void AddPotentialExit(Direction direction)
{
    if (!_exits.ContainsKey(direction))
    {
        _exits[direction] = Guid.Empty; // Placeholder for "unexplored"
    }
}

/// <summary>
/// Checks if an exit leads to an unexplored (not yet generated) room.
/// </summary>
public bool IsExitUnexplored(Direction direction) =>
    _exits.TryGetValue(direction, out var id) && id == Guid.Empty;
```

---

## 9. Monster & Item Placement

### 9.1 Monster Spawning

Monsters are spawned based on:
1. **Template chance:** `MonsterChance` from room template
2. **Depth modifier:** Harder monsters at deeper levels
3. **Biome filter:** Only biome-appropriate monsters

```csharp
/// <summary>
/// Spawns a monster appropriate for the room's depth and biome.
/// </summary>
private Monster? SpawnMonster(
    RoomTemplate template,
    string biomeId,
    int depth,
    float difficultyModifier,
    Random random)
{
    if (random.NextDouble() >= template.MonsterChance)
        return null;

    // Get monsters valid for this biome
    var validMonsters = _monsterService.GetMonstersByBiome(biomeId);
    if (validMonsters.Count == 0) return null;

    // Select by spawn weight
    var monster = SelectWeightedMonster(validMonsters, random);
    if (monster == null) return null;

    // Apply depth scaling
    monster = ScaleMonsterForDepth(monster, difficultyModifier);

    return monster;
}
```

### 9.2 Item Spawning

Items are spawned based on:
1. **Template chance:** `ItemChance` from room template
2. **Loot quality modifier:** Better items at deeper levels
3. **Template-specific item pools:** Some templates favor certain items

---

## 10. Data Model Changes

### 10.1 New Configuration Classes

| Type | Name | Location | Description |
|------|------|----------|-------------|
| Class | `RoomTemplateConfiguration` | `Application/Configuration/` | Room template container |
| Class | `RoomTemplate` | `Application/Configuration/` | Individual template definition |
| Class | `GenerationRulesConfiguration` | `Application/Configuration/` | Generation rules |
| Class | `BiomeDepthRange` | `Application/Configuration/` | Depth-biome mapping |

### 10.2 New Value Objects

| Type | Name | Location | Description |
|------|------|----------|-------------|
| Record | `GenerationContext` | `Application/ValueObjects/` | Generation state |
| Record | `GeneratedRoomResult` | `Application/ValueObjects/` | Generation result |

### 10.3 New Interfaces

| Type | Name | Location | Description |
|------|------|----------|-------------|
| Interface | `IRoomGeneratorService` | `Application/Interfaces/` | Room generation contract |

### 10.4 Modified Entities

| Entity | Changes |
|--------|---------|
| `Dungeon` | Add `CanGenerateAt()`, `GetOrAddRoom()`, `MaxRoomsPerLevel` |
| `Room` | Add `IsGenerated` flag, `AddPotentialExit()`, `IsExitUnexplored()` |

---

## 11. Configuration File Schemas

### 11.1 room-templates.json

**File:** `config/room-templates.json`

```json
{
  "version": "1.0",
  "templates": {
    "dungeon_corridor": {
      "id": "dungeon_corridor",
      "biomes": ["dungeon", "ruins"],
      "names": [
        "Dark Corridor",
        "Stone Passage",
        "Dusty Hallway",
        "Narrow Corridor",
        "Winding Passage"
      ],
      "descriptionTemplates": [
        "A narrow stone corridor stretches before you. Torches flicker on the walls, casting dancing shadows.",
        "The passage winds through ancient stonework. Cobwebs hang from the low ceiling.",
        "Worn flagstones line this corridor. The air is thick with dust and the smell of age."
      ],
      "exitProbabilities": {
        "north": 0.6,
        "south": 0.6,
        "east": 0.4,
        "west": 0.4,
        "up": 0.05,
        "down": 0.1
      },
      "monsterChance": 0.25,
      "itemChance": 0.10,
      "weight": 40,
      "impliedTags": ["corridor", "narrow"]
    },
    "dungeon_chamber": {
      "id": "dungeon_chamber",
      "biomes": ["dungeon"],
      "names": [
        "Ancient Chamber",
        "Forgotten Hall",
        "Dusty Room",
        "Stone Chamber",
        "Dark Hall"
      ],
      "descriptionTemplates": [
        "A large chamber opens before you. Pillars support the vaulted ceiling above.",
        "This room was once grand, but time has taken its toll. Crumbling columns line the walls.",
        "An echoing chamber filled with shadows. Faded murals cover the walls."
      ],
      "exitProbabilities": {
        "north": 0.5,
        "south": 0.5,
        "east": 0.5,
        "west": 0.5,
        "up": 0.03,
        "down": 0.08
      },
      "monsterChance": 0.40,
      "itemChance": 0.25,
      "weight": 30,
      "impliedTags": ["chamber", "large"]
    },
    "dungeon_alcove": {
      "id": "dungeon_alcove",
      "biomes": ["dungeon", "ruins"],
      "names": [
        "Small Alcove",
        "Hidden Nook",
        "Cramped Space",
        "Side Chamber"
      ],
      "descriptionTemplates": [
        "A small alcove branches off from the main passage. It's cramped but might hold secrets.",
        "This tiny space was perhaps a guard post or storage area long ago."
      ],
      "exitProbabilities": {
        "north": 0.3,
        "south": 0.3,
        "east": 0.3,
        "west": 0.3,
        "up": 0.0,
        "down": 0.0
      },
      "monsterChance": 0.15,
      "itemChance": 0.35,
      "weight": 15,
      "impliedTags": ["small", "alcove"]
    },
    "cave_cavern": {
      "id": "cave_cavern",
      "biomes": ["cave"],
      "names": [
        "Natural Cavern",
        "Underground Grotto",
        "Crystal Cave",
        "Dripping Cavern"
      ],
      "descriptionTemplates": [
        "A natural cavern opens around you. Water drips from stalactites above.",
        "The cave walls shimmer with mineral deposits. An underground stream echoes in the distance.",
        "Bioluminescent fungi cast an eerie blue glow across this underground space."
      ],
      "exitProbabilities": {
        "north": 0.5,
        "south": 0.5,
        "east": 0.5,
        "west": 0.5,
        "up": 0.1,
        "down": 0.15
      },
      "monsterChance": 0.35,
      "itemChance": 0.20,
      "weight": 35,
      "impliedTags": ["natural", "cavern", "wet"]
    },
    "cave_tunnel": {
      "id": "cave_tunnel",
      "biomes": ["cave"],
      "names": [
        "Winding Tunnel",
        "Natural Passage",
        "Rock Tunnel",
        "Underground Path"
      ],
      "descriptionTemplates": [
        "A natural tunnel winds through the rock. The walls are rough and uneven.",
        "This passage was carved by water over millennia. The stone is smooth and wet."
      ],
      "exitProbabilities": {
        "north": 0.7,
        "south": 0.7,
        "east": 0.3,
        "west": 0.3,
        "up": 0.05,
        "down": 0.1
      },
      "monsterChance": 0.20,
      "itemChance": 0.10,
      "weight": 40,
      "impliedTags": ["tunnel", "natural"]
    },
    "volcanic_chamber": {
      "id": "volcanic_chamber",
      "biomes": ["volcanic"],
      "names": [
        "Magma Chamber",
        "Volcanic Vent",
        "Lava Cavern",
        "Sulfurous Pit"
      ],
      "descriptionTemplates": [
        "Intense heat washes over you. Rivers of molten rock flow through channels in the floor.",
        "The air shimmers with heat. Cracks in the ground glow with molten rock below.",
        "Sulfurous fumes sting your eyes. The rock here is blackened and sharp."
      ],
      "exitProbabilities": {
        "north": 0.4,
        "south": 0.4,
        "east": 0.4,
        "west": 0.4,
        "up": 0.15,
        "down": 0.05
      },
      "monsterChance": 0.50,
      "itemChance": 0.30,
      "weight": 30,
      "minDepth": 4,
      "impliedTags": ["volcanic", "hot", "danger"]
    }
  }
}
```

### 11.2 generation-rules.json

**File:** `config/generation-rules.json`

```json
{
  "version": "1.0",
  "maxRoomsPerLevel": 50,
  "minExitsPerRoom": 1,
  "maxExitsPerRoom": 4,
  "depthDifficultyMultiplier": 0.15,
  "depthLootQualityMultiplier": 0.10,
  "stairsDownChanceBase": 0.08,
  "stairsUpGuaranteedIfDeep": true,
  "stairsUpGuaranteedDepth": 2,
  "maxDungeonDepth": 10,
  "biomeTransitionDepths": {
    "dungeon": {
      "minDepth": 0,
      "maxDepth": 3,
      "transitionProbability": 1.0
    },
    "cave": {
      "minDepth": 2,
      "maxDepth": 7,
      "transitionProbability": 0.6
    },
    "volcanic": {
      "minDepth": 5,
      "maxDepth": -1,
      "transitionProbability": 0.5
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `RoomGeneratorService` | Information | Room generated, room retrieved |
| `RoomGeneratorService` | Debug | Template selection, exit generation, content spawning |
| `RoomGeneratorService` | Warning | No valid template found, fallback used |
| `RoomGeneratorService` | Error | Generation failure, invalid configuration |
| `GameSessionService` | Information | Player moved to generated room |
| `GameSessionService` | Debug | On-demand generation triggered |
| `Dungeon` | Debug | Room added, room limit checked |
| `Dungeon` | Warning | Room limit reached for level |

### 12.2 Log Message Examples

```
[Information] Generated new room 'Dark Corridor' at (1, 0, Z=2) using template dungeon_corridor (biome: dungeon)
[Debug] Template selection: biome=cave, depth=3, selected=cave_cavern (weight 35/100)
[Debug] Exit generation: north (prob 0.6 → success), east (prob 0.4 → fail)
[Debug] Monster spawn check: template chance 0.35, roll 0.42 → no spawn
[Warning] No valid template found for biome volcanic at depth 2, using fallback
[Information] Player moved to generated room at (2, 1, Z=1)
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| RoomTemplate class | ~4 |
| RoomTemplateConfiguration | ~2 |
| GenerationRulesConfiguration | ~2 |
| GenerationContext | ~3 |
| GeneratedRoomResult | ~2 |
| RoomGeneratorService.GenerateRoom | ~4 |
| RoomGeneratorService.DetermineExits | ~3 |
| RoomGeneratorService.GetDepthDifficultyModifier | ~2 |
| RoomGeneratorService.DetermineBiomeForDepth | ~3 |
| **Total** | **~25** |

### 13.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `RoomTemplateTests.cs` | ~4 | Template properties, depth validation |
| `GenerationContextTests.cs` | ~3 | Seed creation, context properties |
| `RoomGeneratorServiceTests.cs` | ~12 | All service methods |
| `GenerationRulesConfigurationTests.cs` | ~4 | Rule loading, defaults |
| `DungeonGenerationTests.cs` | ~2 | GetOrAddRoom, CanGenerateAt |

### 13.3 Sample Test Cases

#### RoomTemplateTests.cs

```csharp
[Test]
public void IsValidForDepth_WithinRange_ReturnsTrue()
{
    var template = new RoomTemplate
    {
        MinDepth = 2,
        MaxDepth = 5
    };

    Assert.That(template.IsValidForDepth(3), Is.True);
}

[Test]
public void IsValidForDepth_BelowMinDepth_ReturnsFalse()
{
    var template = new RoomTemplate
    {
        MinDepth = 2,
        MaxDepth = 5
    };

    Assert.That(template.IsValidForDepth(1), Is.False);
}

[Test]
public void GetExitProbability_ExistingDirection_ReturnsProbability()
{
    var template = new RoomTemplate
    {
        ExitProbabilities = new Dictionary<string, float>
        {
            ["north"] = 0.75f
        }
    };

    Assert.That(template.GetExitProbability("north"), Is.EqualTo(0.75f));
}

[Test]
public void GetExitProbability_MissingDirection_ReturnsZero()
{
    var template = new RoomTemplate();

    Assert.That(template.GetExitProbability("east"), Is.EqualTo(0f));
}
```

#### RoomGeneratorServiceTests.cs

```csharp
[Test]
public void GetDepthDifficultyModifier_AtSurface_ReturnsOne()
{
    var service = CreateService();

    var modifier = service.GetDepthDifficultyModifier(0);

    Assert.That(modifier, Is.EqualTo(1.0f));
}

[Test]
public void GetDepthDifficultyModifier_AtDepthTwo_ReturnsScaledModifier()
{
    var service = CreateService(depthMultiplier: 0.15f);

    var modifier = service.GetDepthDifficultyModifier(2);

    Assert.That(modifier, Is.EqualTo(1.30f).Within(0.01f));
}

[Test]
public void GenerateRoom_WithValidTemplate_ReturnsRoom()
{
    var service = CreateServiceWithTemplates();
    var position = new Position3D(0, 0, 0);

    var result = service.GenerateRoom(position, "dungeon", 12345);

    Assert.That(result.Room, Is.Not.Null);
    Assert.That(result.Room.Position, Is.EqualTo(position));
}

[Test]
public void DetermineExits_WithGuaranteedExit_IncludesGuaranteedDirection()
{
    var service = CreateService();
    var template = CreateLowProbabilityTemplate();
    var position = new Position3D(0, 0, 0);

    var exits = service.DetermineExits(position, template, 12345, Direction.South);

    Assert.That(exits, Contains.Item(Direction.South));
}
```

---

## 14. Use Cases

### UC-001: Move to Unexplored Exit

**Actor:** Player
**Flow:** Enter room with unexplored exit → Move toward exit → System generates new room → Room is connected → Player enters new room → New room description displayed

### UC-002: Deterministic Room Generation

**Actor:** System
**Flow:** Player moves to position (3, 1, Z=2) → System calculates seed from position → Same position always generates same room → Reproducible dungeon layout

### UC-003: Biome Transition at Depth

**Actor:** System
**Flow:** Player descends to Z=4 → System rolls biome transition → Cave biome selected → Room generated with cave template → Cave environment context applied

### UC-004: Depth Difficulty Scaling

**Actor:** System
**Flow:** Generate room at Z=3 → Calculate difficulty modifier (1.45) → Monster spawned → Monster stats scaled by 145% → Higher XP reward

### UC-005: Exit Probability Generation

**Actor:** System
**Flow:** Select template (corridor) → Roll for each direction → North (0.6) success → East (0.4) fail → Generate exits: [North, South (guaranteed return)]

### UC-006: Room Limit Enforcement

**Actor:** System
**Flow:** Player explores level Z=1 → 50 rooms generated → Player tries to explore more → CanGenerateAt returns false → Generation blocked → Message displayed

---

## 15. Deliverable Checklist

### Configuration Classes

- [ ] `RoomTemplateConfiguration.cs` created
- [ ] `RoomTemplate.cs` class created
- [ ] `GenerationRulesConfiguration.cs` created
- [ ] `BiomeDepthRange.cs` class created

### Value Objects

- [ ] `GenerationContext.cs` created
- [ ] `GeneratedRoomResult.cs` created

### Interfaces

- [ ] `IRoomGeneratorService.cs` created

### Services

- [ ] `RoomGeneratorService.cs` implemented
- [ ] Template selection logic implemented
- [ ] Exit probability logic implemented
- [ ] Depth scaling implemented
- [ ] Biome transition implemented

### Entity Updates

- [ ] `Dungeon.cs` - Add `CanGenerateAt()` method
- [ ] `Dungeon.cs` - Add `GetOrAddRoom()` method
- [ ] `Dungeon.cs` - Add `MaxRoomsPerLevel` property
- [ ] `Room.cs` - Add `IsGenerated` property (optional)
- [ ] `Room.cs` - Add `AddPotentialExit()` method

### Configuration Files

- [ ] `config/room-templates.json` created (~6 templates)
- [ ] `config/generation-rules.json` created

### Infrastructure Updates

- [ ] `JsonConfigurationProvider` - Load room templates
- [ ] `JsonConfigurationProvider` - Load generation rules
- [ ] `DependencyInjection.cs` - Register RoomGeneratorService

### Tests

- [ ] `RoomTemplateTests.cs` (~4 tests)
- [ ] `GenerationContextTests.cs` (~3 tests)
- [ ] `RoomGeneratorServiceTests.cs` (~12 tests)
- [ ] `GenerationRulesConfigurationTests.cs` (~4 tests)
- [ ] `DungeonGenerationTests.cs` (~2 tests)
- [ ] All ~25 tests passing

### Documentation

- [ ] XML documentation for all new types
- [ ] Updated code comments for modified types

---

## 16. Acceptance Criteria

### Functional

- [ ] Room templates load from `config/room-templates.json`
- [ ] Generation rules load from `config/generation-rules.json`
- [ ] `RoomGeneratorService.GenerateRoom()` creates rooms from templates
- [ ] Generated room names come from template name pool
- [ ] Generated room descriptions come from template description pool
- [ ] Exit probabilities are respected during generation
- [ ] Depth difficulty modifier calculated correctly (1 + depth × 0.15)
- [ ] Biome transitions occur at configured depths
- [ ] Dungeon prevents generation beyond room limit per level
- [ ] On-demand room generation works when moving to unexplored exit
- [ ] Generated rooms have correct EnvironmentContext from biome
- [ ] Same position + seed always generates identical room

### Quality

- [ ] Build succeeds with 0 errors and 0 warnings
- [ ] All ~25 unit tests pass
- [ ] Configuration files validate (valid JSON, required fields present)
- [ ] XML documentation complete for all new/modified types
- [ ] No breaking changes to existing room/dungeon functionality

---

## 17. Dependencies

### 17.1 Prerequisites (REQUIRES)

```
v0.1.0b Procedural Room Generation
    │
    └── REQUIRES from v0.1.0a
        ├── Position3D value object
        ├── Direction enum with Up/Down
        ├── Dungeon.ConnectRoomsVertically()
        └── Room with Position3D support
    │
    └── REQUIRES from v0.0.11
        ├── EnvironmentContext value object
        ├── BiomeConfiguration class
        └── BiomeDefinition class
    │
    └── REQUIRES from v0.0.9
        ├── Monster entity and spawning
        ├── Item entity
        └── LootDrop value object
```

### 17.2 Provides (to future phases)

```
v0.1.0b Procedural Room Generation
    │
    └── PROVIDES to v0.1.0c
        ├── RoomGeneratorService (extend for room types)
        ├── RoomTemplate (add room type field)
        └── Exit generation (add hidden exit support)
    │
    └── PROVIDES to v0.1.0d
        ├── Generated room tracking (for map display)
        ├── Dungeon with multiple levels
        └── Room position for ASCII map
```

---

## 18. Future Considerations

### 18.1 Deferred to v0.1.0c (Room Types & Hidden Passages)

- **Room type assignment**: Templates may specify room type (Treasure, Trap, Boss)
- **Hidden exits in templates**: Exit probability could include hidden exit chance
- **Special room generation**: Boss rooms, treasure rooms with specific layouts

### 18.2 Deferred to v0.1.0d (Map Command & Polish)

- **Room exploration tracking**: Mark rooms as explored vs generated
- **Map integration**: Display generated rooms on ASCII map

### 18.3 Out of Scope (Future Versions)

- **Pre-generated dungeon sections**: Hand-crafted areas mixed with procedural
- **Dynamic dungeon events**: Rooms changing over time
- **Infinite dungeon mode**: Endless depth exploration
- **Biome blending**: Smooth transitions between biomes

---

*Document Version: 1.0*
*Last Updated: 2026-01-08*
*Author: Claude*
