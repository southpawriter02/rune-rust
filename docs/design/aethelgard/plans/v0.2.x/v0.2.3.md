# v0.2.3: The Hero's Toolkit (Abilities & Resources)

> **Status:** Complete
> **Milestone:** 3 - The Warrior
> **Theme:** Active abilities, resource economy, and archetype kits

## Table of Contents
- [Overview](#overview)
- [Phase A: The Fuel (Resource Management)](#phase-a-the-fuel-resource-management)
- [Phase B: The Engine (Ability Logic)](#phase-b-the-engine-ability-logic)
- [Phase C: The Arsenal (Archetype Kits)](#phase-c-the-arsenal-archetype-kits)
- [Testing Strategy](#testing-strategy)
- [Draft Changelog](#draft-changelog)

## Overview

This version implements the Active Ability System, Resource Economy (Stamina/AP), and Effect Scripting. It bridges the gap between basic attacks (v0.2.0) and the complex enemy AI (v0.2.2) by giving players their class-specific tools.

- **Phase A: The Fuel** - Resource management (Stamina and Aether)
- **Phase B: The Engine** - Ability logic and effect scripting
- **Phase C: The Arsenal** - Archetype-specific kits and UI integration

---

## Phase A: The Fuel (Resource Management)

**Goal:** Implement ResourceService to manage spending, regenerating, and validating resource costs (Stamina/AP) within the combat loop, including the "Overcast" mechanic for Mystics.

### 1. Architecture & Data Flow

We introduce a centralized service to handle all resource math, ensuring that UI updates, logging, and game state remain synchronized.

**Workflow: Spending Resources**
1. **Request:** CombatService receives an intent (e.g., "Use Wild Swing").
2. **Check:** Calls ResourceService.CanAfford(attacker, ResourceType.Stamina, 35).
3. **Result:**
   - True: Proceed.
   - False: Return error "Insufficient Stamina."
4. **Execution:** On success, calls ResourceService.Deduct(attacker, ResourceType.Stamina, 35).
5. **Side Effects:** If Type is Aether and Current < Cost, trigger Overcast (deduct HP instead).

**Workflow: Regeneration (Turn Start)**
1. **Trigger:** CombatService.NextTurn() identifies the active combatant.
2. **Calc:** ResourceService.CalculateRegen(combatant).
   - Formula: 5 + (Finesse * 2) (Standard) or 0 (if Stunned).
3. **Apply:** Add value, clamping to MaxStamina.
4. **Log:** Record regeneration for UI feedback.

### 2. Logic Decision Trees

**A. Resource Deduction Logic**
Input: Combatant, ResourceType, Amount
1. Type == Stamina?
   - If Current >= Amount -> Current -= Amount. Success.
   - Else -> Fail.
2. Type == Aether?
   - If Current >= Amount -> Current -= Amount. Success.
   - Else If Archetype == Mystic (Overcast):
     - Calculate Deficit = Amount - Current.
     - Calculate HpCost = Deficit * 2.
     - Set Current = 0.
     - Deduct HpCost from Health.
     - Log "Overcast!". Success.
   - Else -> Fail.

**B. Regeneration Logic**
Input: Combatant (Start of Turn)
1. Check Status: Is Stunned or Exhausted?
   - Yes: Regen = 0. Exit.
2. Calculate Base: Regen = 5.
3. Add Attribute: Regen += (Finesse / 2).
4. Apply: CurrentStamina += Regen.
5. Clamp: CurrentStamina = Math.Min(Current, Max).

### 3. Code Implementation

**File:** `RuneAndRust.Core/Enums/ResourceType.cs`
```csharp
public enum ResourceType
{
    Health = 0,
    Stamina = 1,
    Aether = 2,
    // Future: Fury, Momentum, Focus
}
```

**File:** `RuneAndRust.Engine/Services/ResourceService.cs`
```csharp
public class ResourceService : IResourceService
{
    private readonly ILogger<ResourceService> _logger;

    public bool CanAfford(Combatant combatant, ResourceType type, int cost)
    {
        return type switch
        {
            ResourceType.Stamina => combatant.CurrentStamina >= cost,
            ResourceType.Aether => combatant.Archetype == ArchetypeType.Mystic
                                   ? (combatant.CurrentHp > (cost - combatant.CurrentAp) * 2)
                                   : combatant.CurrentAp >= cost,
            _ => false
        };
    }

    public void Deduct(Combatant combatant, ResourceType type, int cost)
    {
        if (type == ResourceType.Stamina)
        {
            combatant.CurrentStamina = Math.Max(0, combatant.CurrentStamina - cost);
            _logger.LogInformation("{Name} spent {Cost} Stamina ({Current}/{Max})",
                combatant.Name, cost, combatant.CurrentStamina, combatant.MaxStamina);
        }
        else if (type == ResourceType.Aether)
        {
            if (combatant.CurrentAp >= cost)
            {
                combatant.CurrentAp -= cost;
            }
            else
            {
                // Overcast Logic
                int deficit = cost - combatant.CurrentAp;
                int hpCost = deficit * 2;
                combatant.CurrentAp = 0;
                combatant.CurrentHp -= hpCost;
                _logger.LogWarning("{Name} OVERCAST! Spent {HpCost} HP for {Deficit} missing AP.",
                    combatant.Name, hpCost, deficit);
            }
        }
    }

    public void RegenerateStamina(Combatant combatant)
    {
        int regenAmount = 10;

        int oldVal = combatant.CurrentStamina;
        combatant.CurrentStamina = Math.Min(combatant.MaxStamina, combatant.CurrentStamina + regenAmount);

        if (combatant.CurrentStamina != oldVal)
        {
            _logger.LogDebug("{Name} regen: +{Amount} Stamina", combatant.Name, (combatant.CurrentStamina - oldVal));
        }
    }
}
```

### 4. Logging Matrix

| Event | Level | Message Template | Properties |
|---|---|---|---|
| Spend | Info | "{Name} spent {Cost} {Resource}." | Name, Cost, Resource |
| Fail | Debug | "{Name} failed to afford {Cost} {Resource} (Has: {Current})." | Name, Cost, Resource, Current |
| Regen | Verbose | "{Name} regenerated {Amount} {Resource}." | Name, Amount, Resource |
| Overcast | Warning | "{Name} OVERCAST! {HpCost} HP paid for {ApCost} AP." | Name, HpCost, ApCost |

### 5. Testing Requirements

**Unit Tests (ResourceServiceTests.cs)**
- **Stamina:**
  - Deduct_SufficientStamina_ReducesCurrent: 50 - 30 = 20.
  - CanAfford_InsufficientStamina_ReturnsFalse.
- **Aether & Overcast:**
  - Deduct_SufficientAP_ReducesAP.
  - Deduct_InsufficientAP_Mystic_ReducesHP: 10 AP cost, 0 AP avail -> -20 HP.
  - CanAfford_InsufficientAP_NonMystic_ReturnsFalse.
  - CanAfford_Overcast_InsufficientHP_ReturnsFalse.
- **Regeneration:**
  - Regenerate_ClampsToMax: Current 45, Max 50, Regen 10 -> Result 50.

**Integration Tests:**
- Combat Loop: Start Combat -> Player Turn 1 -> Spend Stamina -> Player Turn 2 -> Verify Stamina Regenerated.

### 6. Deliverable Checklist (Phase A)

- [x] Core: Define ResourceType Enum.
- [x] Core: Update Combatant to ensure CurrentAp, MaxAp, CurrentStamina, MaxStamina are initialized.
- [x] Core: Create IResourceService interface.
- [x] Engine: Implement ResourceService.
- [x] Engine: Implement Overcast mechanics.
- [x] Engine: Inject IResourceService into CombatService.
- [x] Engine: Update CombatService.NextTurn to call RegenerateStamina.
- [x] Terminal: Update HUD/Status Header to show AP if Archetype is Mystic.

---

## Phase B: The Engine (Ability Logic)

**Goal:** Implement the AbilityService to parse and execute ability logic defined in data (e.g., "Deal Damage", "Apply Status"), enabling distinct behaviors for different Specializations.

### 1. Architecture & Data Flow

The AbilityService acts as an interpreter, translating static data (EffectScript) into runtime state changes.

**Workflow: The Ability Execution Pipeline**
1. **Input:** Player selects ability (e.g., Wild Swing).
2. **Validation:** AbilityService checks:
   - Is the ability on Cooldown?
   - Does the user have sufficient Resources (Stamina/AP)?
   - Is the target valid (Range/Type)?
3. **Cost:** Deduct Resources.
4. **Parsing:** Split EffectScript string into individual instructions.
5. **Execution:** Iterate through instructions and apply effects to targets.
   - Example Script: `DAMAGE:Physical:2d8:MIGHT;STATUS:Bleeding:2:1`
6. **Cleanup:** Set Cooldown on user. Log results.
7. **Output:** Return AbilityResult to CombatService for UI display.

### 2. Logic Decision Trees

**A. Effect Parsing Logic**
Input: Effect String (e.g., "DAMAGE:Physical:1d6")
1. Split: String.Split(':').
2. Switch Case (Token 0):
   - DAMAGE: Call AttackResolutionService.
   - HEAL: Add HP to target (Clamp to Max).
   - STATUS: Call StatusEffectService.Apply().
   - SELF: Change target context to "Self" for subsequent effects.
3. Extract Parameters: Parse remaining tokens (Type, Dice, Duration).

**B. Cooldown Management**
Input: Combatant, Ability ID
1. Check: Does Combatant.Cooldowns contain Ability ID?
   - Yes: Return False (Cannot use).
2. Apply (Post-Execution): Add Ability ID to dictionary with value = Ability.CooldownTurns.
3. Process (End Turn): Iterate dictionary. Decrement values. Remove if <= 0.

### 3. Code Implementation

**File:** `RuneAndRust.Core/Entities/ActiveAbility.cs`
```csharp
public class ActiveAbility
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;

    // Costs
    public int StaminaCost { get; set; }
    public int AetherCost { get; set; }

    // Mechanics
    public int CooldownTurns { get; set; }
    public int Range { get; set; } // 0 = Self, 1 = Melee, >1 = Ranged

    // The "Bytecode" of the ability
    // Format: "CMD:Param1:Param2;CMD:Param1"
    // Example: "DAMAGE:Physical:2d6;STATUS:Bleeding:2"
    public string EffectScript { get; set; } = string.Empty;
}
```

**File:** `RuneAndRust.Engine/Services/AbilityService.cs`
```csharp
public class AbilityService : IAbilityService
{
    private readonly IResourceService _resources;
    private readonly IStatusEffectService _statuses;
    private readonly IAttackResolutionService _combat;
    private readonly ILogger _logger;

    public AbilityResult Execute(Combatant user, Combatant target, ActiveAbility ability)
    {
        // 1. Validation
        if (user.Cooldowns.ContainsKey(ability.Id))
            return AbilityResult.Failure($"Ability is on cooldown ({user.Cooldowns[ability.Id]} turns).");

        if (!_resources.CanAfford(user, ResourceType.Stamina, ability.StaminaCost) ||
            !_resources.CanAfford(user, ResourceType.Aether, ability.AetherCost))
            return AbilityResult.Failure("Insufficient resources.");

        // 2. Pay Costs
        _resources.Deduct(user, ResourceType.Stamina, ability.StaminaCost);
        _resources.Deduct(user, ResourceType.Aether, ability.AetherCost);

        // 3. Parse & Execute Script
        var effects = ability.EffectScript.Split(';');
        var logBuilder = new StringBuilder();

        foreach (var instruction in effects)
        {
            var parts = instruction.Split(':');
            var command = parts[0].ToUpper();

            switch (command)
            {
                case "DAMAGE":
                    var type = Enum.Parse<DamageType>(parts[1]);
                    var damageResult = _combat.ResolveAbilityAttack(user, target, type, parts[2]);
                    logBuilder.Append($"Dealt {damageResult.FinalDamage} {type} damage. ");
                    break;

                case "STATUS":
                    var statusType = Enum.Parse<StatusEffectType>(parts[1]);
                    int duration = int.Parse(parts[2]);
                    int stacks = parts.Length > 3 ? int.Parse(parts[3]) : 1;
                    _statuses.ApplyEffect(target, statusType, duration, user.Id);
                    logBuilder.Append($"Applied {statusType}. ");
                    break;

                case "HEAL":
                     int healAmt = int.Parse(parts[1]);
                     target.CurrentHp = Math.Min(target.MaxHp, target.CurrentHp + healAmt);
                     logBuilder.Append($"Healed {healAmt} HP. ");
                     break;
            }
        }

        // 4. Apply Cooldown
        if (ability.CooldownTurns > 0)
        {
            user.Cooldowns[ability.Id] = ability.CooldownTurns;
        }

        return AbilityResult.Success(logBuilder.ToString());
    }

    public void ProcessCooldowns(Combatant combatant)
    {
        foreach(var key in combatant.Cooldowns.Keys.ToList())
        {
            combatant.Cooldowns[key]--;
            if (combatant.Cooldowns[key] <= 0) combatant.Cooldowns.Remove(key);
        }
    }
}
```

### 4. Logging Matrix

| Event | Level | Message Template | Properties |
|---|---|---|---|
| Execute | Info | "{User} used {Ability} on {Target}." | User, Ability, Target |
| Script | Verbose | "Parsing script: {Script}" | Script |
| Cooldown | Debug | "{User} ability {Ability} cooldown: {Turns}" | User, Ability, Turns |
| Failure | Warning | "{User} failed to use {Ability}: {Reason}" | User, Ability, Reason |

### 5. Testing Requirements

**Unit Tests (AbilityServiceTests.cs)**
- **Validation:**
  - Execute_OnCooldown_ReturnsFailure: Add ID to cooldown dict, try execute -> Fail.
  - Execute_InsufficientResource_ReturnsFailure: Set Stamina 0, Cost 20 -> Fail.
- **Script Parsing:**
  - Execute_DamageScript_CallsCombatService: Format "DAMAGE:Physical:2d6".
  - Execute_StatusScript_CallsStatusService: Format "STATUS:Bleeding:3".
  - Execute_CombinedScript_ExecutesBoth: "DAMAGE...;STATUS...".
- **Cooldowns:**
  - Execute_SetsCooldown: Verify user.Cooldowns contains ID.
  - ProcessCooldowns_DecrementsValue: 3 -> 2.
  - ProcessCooldowns_RemovesZero: 1 -> 0 -> Removed from dict.

### 6. Deliverable Checklist (Phase B)

- [x] Core: Define ActiveAbility class.
- [x] Core: Update Combatant with Dictionary<Guid, int> Cooldowns.
- [x] Core: Create IAbilityService interface.
- [x] Engine: Implement AbilityService.CanUse.
- [x] Engine: Implement AbilityService.Execute with script parser.
- [x] Engine: Implement AbilityService.ProcessCooldowns.
- [x] Engine: Inject IResourceService, IStatusEffectService into AbilityService.
- [x] Integration: Hook ProcessCooldowns into CombatService.NextTurn.
- [x] Integration: Extend IAttackResolutionService to handle "Ability Attack".

---

## Phase C: The Arsenal (Archetype Kits)

**Goal:** Seed the ActiveAbility database with the initial abilities defined in the Archetype specifications and wire the `use` command in the Combat UI.

### 1. Architecture & Data Flow

We move from "hardcoded actions" to "data-driven actions."

**Workflow: Ability Initialization**
1. **App Start:** AbilitySeeder populates the ActiveAbilities table if empty.
2. **Character Load:** When Combatant.FromCharacter() is called, the Combatant loads associated abilities from the database into a List<ActiveAbility>.

**Workflow: Execution Flow**
1. **Input:** User types `use wild-swing on goblin`.
2. **Resolution:** CommandParser identifies verb `use`.
3. **Lookup:** CombatService searches the Active Combatant's ability list for "wild-swing" (fuzzy match).
4. **Validation:** AbilityService.CanUse checks Resource and Cooldown.
5. **Execution:** AbilityService.Execute runs the EffectScript.
6. **Result:** Output returned to CombatLog.

### 2. Logic Decision Trees

**A. Command Parsing Logic (`use`)**
Input: "use [AbilityName] on [Target]?"
1. Check Context: Is game in CombatPhase?
   - No: Return "You can only use combat abilities in combat."
2. Find Ability: Does ActiveCombatant.Abilities contain a match for [AbilityName]?
   - No: Return "You don't know that ability."
3. Find Target:
   - If Ability.Range > 0: Did user specify target?
     - Yes: Validate target exists.
     - No: Default to last target or Error.
   - If Ability.Range == 0 (Self): Target = Self.
4. Execute: Call AbilityService.Execute(user, target, ability).

### 3. Code Implementation

**File:** `RuneAndRust.Persistence/Data/AbilitySeeder.cs`
```csharp
public static class AbilitySeeder
{
    public static List<ActiveAbility> GetSeeds()
    {
        return new List<ActiveAbility>
        {
            // WARRIOR
            new ActiveAbility {
                Name = "Wild Swing",
                Archetype = ArchetypeType.Warrior,
                Tier = 1,
                StaminaCost = 35,
                CooldownTurns = 0,
                Description = "A reckless heavy strike.",
                EffectScript = "DAMAGE:Physical:2d8"
            },
            new ActiveAbility {
                Name = "Defensive Stance",
                Archetype = ArchetypeType.Warrior,
                Tier = 1,
                StaminaCost = 0,
                CooldownTurns = 0,
                Description = "Focus on defense.",
                EffectScript = "STATUS:Fortified:1:1"
            },

            // SKIRMISHER
            new ActiveAbility {
                Name = "Precise Shot",
                Archetype = ArchetypeType.Skirmisher,
                Tier = 1,
                StaminaCost = 30,
                CooldownTurns = 0,
                Description = "A carefully aimed shot.",
                EffectScript = "DAMAGE:Physical:1d8"
            },

            // MYSTIC
            new ActiveAbility {
                Name = "Aether Dart",
                Archetype = ArchetypeType.Mystic,
                Tier = 1,
                StaminaCost = 0,
                AetherCost = 15,
                CooldownTurns = 0,
                Description = "A bolt of pure energy.",
                EffectScript = "DAMAGE:Arcane:1d10"
            },

            // ADEPT
            new ActiveAbility {
                Name = "Mend Wound",
                Archetype = ArchetypeType.Adept,
                Tier = 1,
                StaminaCost = 20,
                CooldownTurns = 2,
                Description = "Rapid field triage.",
                EffectScript = "HEAL:12"
            }
        };
    }
}
```

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs` (Update)
```csharp
public List<ActiveAbility> Abilities { get; set; } = new();

public static Combatant FromCharacter(Character c, IEnumerable<ActiveAbility> allAbilities)
{
    var combatant = new Combatant { /* ... props ... */ };

    // Simple logic: Give character all Tier 1 abilities for their Archetype
    combatant.Abilities = allAbilities
        .Where(a => a.Archetype == c.Archetype && a.Tier == 1)
        .ToList();

    return combatant;
}
```

**File:** `RuneAndRust.Engine/Services/CommandParser.cs`
```csharp
// Inside Combat Phase Switch
case "use":
case "u":
    if (parts.Length < 2) return new ParseResult { Message = "Use what?" };

    var (abilityName, targetName) = ParseTargetSyntax(input);

    var active = _gameState.CombatState.ActiveCombatant;
    var ability = active.Abilities.FirstOrDefault(a =>
        a.Name.Contains(abilityName, StringComparison.OrdinalIgnoreCase));

    if (ability == null) return new ParseResult { Message = "Ability not found." };

    Combatant target = active;
    if (!string.IsNullOrEmpty(targetName))
    {
        target = _combatService.FindCombatant(targetName);
        if (target == null) return new ParseResult { Message = "Target not found." };
    }

    var result = _abilityService.Execute(active, target, ability);

    if (result.Success)
    {
         _combatService.LogCombatEvent(result.Message);
    }
    return new ParseResult { Message = result.Message };
```

### 4. Logging Matrix

| Event | Level | Message Template | Properties |
|---|---|---|---|
| Seeding | Info | "Seeded {Count} abilities into database." | Count |
| Load | Debug | "{Name} loaded with {Count} abilities." | Name, Count |
| Command | Info | "Player command: Use {Ability} on {Target}." | Ability, Target |
| Script | Verbose | "EffectScript '{Script}' parsed: {Damage} Dmg, {Heal} Heal." | Script, Damage, Heal |

### 5. Validation & Testing

**Unit Tests (AbilityIntegrationTests.cs)**
- Seeding: Database_Contains_Tier1_Abilities: Verify count >= 4.
- Filtering: Combatant_Loads_Only_Archetype_Abilities: Warrior does not get Aether Dart.
- Execution:
  - Use_MendWound_HealsTarget: Check HP increase.
  - Use_AetherDart_DeductsAP: Check AP decrease (not Stamina).
  - Use_WildSwing_DeductsStamina: Check Stamina decrease.

**Integration Tests:**
- Command Loop:
  1. Start Combat.
  2. Type `use wild`.
  3. Verify: Output "You use Wild Swing...", Enemy HP decreased, Player Stamina decreased.

### 6. Deliverable Checklist (Phase C)

- [x] Data: Create AbilitySeeder class.
- [x] Data: Update DataSeeder to call AbilitySeeder.
- [x] Data: Add Archetype column to ActiveAbility entity.
- [x] Engine: Update Combatant.FromCharacter to inject abilities.
- [x] Engine: Update CommandParser to handle `use` command with target parsing.
- [x] Engine: Update CombatService to expose FindCombatant(name).
- [x] UI: Update CombatScreenRenderer to list available abilities in the Footer.
- [x] Tests: Test UseCommand parsing.
- [x] Tests: Test Archetype filtering.

---

## Testing Strategy

### Unit Tests (AbilityServiceTests)
- Cost_Deduction: Verify 35 Stamina is removed when using Wild Swing.
- Cooldown_Lock: Verify ability cannot be reused immediately if Cooldown > 0.
- Script_Parsing: Verify "DAMAGE:Fire:1d6" calls the damage service with correct parameters.

### Integration Tests
- **Combat Loop:**
  1. Player `use wild swing`.
  2. Check: Stamina reduced.
  3. Check: Enemy HP reduced.
  4. Check: Ability on cooldown next turn.

---

## Draft Changelog

```markdown
# Changelog: v0.2.3 - The Hero's Toolkit
**Release Date:** 2025-XX-XX

## Summary
Introduced the Active Ability system, Resource economy, and Tier 1 class kits. Players can now use specialized moves consuming Stamina or Aether.

## Features
- **Resource System:** Stamina (Physical) and Aether (Magical) now track consumption and regeneration.
- **Ability Engine:** Data-driven ability system supporting damage, healing, and status effect scripts.
- **Tier 1 Kits:**
    - **Warrior:** Wild Swing (Heavy Damage), Defensive Stance.
    - **Skirmisher:** Precise Shot (Ranged).
    - **Mystic:** Aether Dart (Magic Damage).
    - **Adept:** Mend Wound (Healing).
- **Cooldowns:** Abilities now enforce turn-based cooldowns.
- **Overcast Mechanic:** Mystics can cast spells even without Aether by burning HP at a 2:1 ratio.

## Technical
- Added `IResourceService` and `IAbilityService`.
- Implemented `EffectScript` parser for modular ability logic.
- Updated `Combatant` to track Cooldowns and dynamic Resources.
```

---

*This concludes Milestone 3 (v0.2.x). The combat engine is now fully functional with Stats, Equipment, AI, and Abilities. Next: Milestone 4 - The Survivor.*
