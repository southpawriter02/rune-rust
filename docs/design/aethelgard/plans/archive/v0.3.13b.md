> **Archived** - This plan has been consolidated. See the complete version at [v0.3.13](../v0.3.x/v0.3.13.md).

# v0.3.13b: The Combat Simulator

This version implements the "Headless Simulation" tools required to mathematically balance the combat system. By simulating thousands of battles between AI-controlled players and enemies, we can generate Time-To-Kill (TTK) curves, Win/Loss ratios, and Resource Drain metrics to tune the game's difficulty without manual playtesting.

Goal: Implement CombatSimulationService and the sim-combat CLI command to run batch combat scenarios. This service acts as a "Puppeteer," programmatically driving the CombatService by injecting commands for both the Player (via a new SimulatedPlayerAgent) and the Enemy (via existing EnemyAIService).

1. Architecture & Data Flow
The Simulation Pipeline
	1	Trigger: Developer runs dotnet run -- --sim-combat archetype=Warrior enemy=und_draugr_01 count=1000.
	2	Setup:
	◦	Create a dedicated IServiceScope for the batch.
	◦	Instantiate a temporary Character based on the requested Archetype.
	◦	Instantiate the Enemy based on the template ID.
	3	The Loop (Per Match):
	◦	Initialize CombatService.StartCombat().
	◦	While Combat Active:
	▪	Player Turn: SimulatedPlayerAgent analyzes state and calls CombatService.ExecutePlayerAttack() or UseItem.
	▪	Enemy Turn: Call CombatService.ProcessEnemyTurnAsync() (uses existing AI).
	▪	State Check: Monitor HP/Death events.
	4	Aggregation: Record turns taken, final HP, resources spent, and winner.
	5	Reporting: Output statistics to Markdown/CSV.

2. Logic Decision Trees
A. Simulated Player Agent Logic (The Baseline Strategy) Input: CombatState, PlayerEntity
	1	Survival Check: Is HP < 30% AND Has Potion?
	◦	Yes: Action -> Use Item (Potion).
	2	Finisher Check: Can any available ability kill the target (Enemy HP < Est. Damage)?
	◦	Yes: Action -> Use Ability (Finisher).
	3	Efficiency Check: Is Stamina > 60%?
	◦	Yes: Action -> Use Ability (Heavy Attack / Special).
	◦	No: Action -> Standard Attack (Resource conservation).
	4	Fallback: Action -> Light Attack / Pass.
B. Simulation Batch Logic Input: Batch Request (N iterations)
	1	Loop i = 0 to N:
	◦	Reset Player State (HP/Stamina to max).
	◦	Spawn fresh Enemy.
	◦	Run Combat Loop until CombatResult is returned.
	◦	Store SimMatchResult in list.
	2	Analysis:
	◦	Win Rate = (PlayerWins / N) * 100.
	◦	Avg Turns = Sum(Turns) / N.
	◦	Resource Delta = Avg(StartResources - EndResources).

3. Deliverable Checklist
	•	Core:
	◦	[ ] Define SimMatchResult record (Winner, Turns, HPRemaining, StaminaSpent).
	◦	[ ] Define SimBatchResult record (Aggregated stats).
	•	Engine:
	◦	[ ] Implement SimulatedPlayerAgent (Basic heuristic AI).
	◦	[ ] Implement CombatSimulationService (Orchestrator).
	◦	[ ] Update CombatService to allow external state inspection without UI rendering (Headless mode support).
	•	Terminal:
	◦	[ ] Update Program.cs to handle --sim-combat arguments.
	•	Project:
	◦	[ ] Create docs/balance/ directory for output reports.

4. Code Implementation
A. Engine Layer (The Agent) File: RuneAndRust.Engine/Simulation/SimulatedPlayerAgent.cs
public class SimulatedPlayerAgent
{
    private readonly ICombatService _combat;

    public SimulatedPlayerAgent(ICombatService combat)
    {
        _combat = combat;
    }

    public async Task TakeTurnAsync(Combatant player, Combatant target)
    {
        // Simple Heuristic: Heal if critical
        if (player.CurrentHp < player.MaxHp * 0.3)
        {
            // Simplified: In real imp, check inventory for potion
            // For v0.3.13b, we might assume infinite potions or skip healing
        }

        // Aggressive Strategy: Dump Stamina
        if (player.CurrentStamina >= 40)
        {
             _combat.ExecutePlayerAttack(target.Name, AttackType.Heavy);
             return;
        }

        // Conservation Strategy
        _combat.ExecutePlayerAttack(target.Name, AttackType.Light);
    }
}
B. Engine Layer (The Simulator) File: RuneAndRust.Engine/Services/CombatSimulationService.cs
public class CombatSimulationService
{
    private readonly IServiceScopeFactory _scopeFactory;

    public async Task RunBatchAsync(string archetype, string enemyId, int count)
    {
        var results = new List<SimMatchResult>();

        // Parallel processing for speed
        await Parallel.ForEachAsync(Enumerable.Range(0, count), async (_, token) =>
        {
            using var scope = _scopeFactory.CreateScope();
            var combatService = scope.ServiceProvider.GetRequiredService<ICombatService>();
            var agent = new SimulatedPlayerAgent(combatService);

            // Setup isolated combat context
            var player = CharacterFactory.CreateSimple("SimHero", LineageType.Human, Enum.Parse<ArchetypeType>(archetype));
            var enemy = _enemyFactory.CreateById(enemyId);

            combatService.StartCombat(new List<Enemy> { enemy });

            int turns = 0;
            while (combatService.IsCombatActive)
            {
                turns++;
                if (combatService.IsPlayerTurn)
                {
                    await agent.TakeTurnAsync(player, enemy);
                }
                else
                {
                    // Existing Enemy AI logic
                    await combatService.ProcessEnemyTurnAsync(enemy);
                }
            }

            // Record results...
        });

        // Generate Report...
    }
}

5. Logging Requirements
The simulator runs thousands of times, so logging must be minimal by default to avoid I/O bottlenecks.
System
Event
Level
Message Template
Properties
Sim
Batch Start
Info
"Starting simulation: {Archetype} vs {Enemy} ({Count} matches)."
Archetype, Enemy, Count
Sim
Match Complete
Debug
"Match {Id}: Winner {Winner}, Turns {Turns}."
Id, Winner, Turns
Sim
Batch End
Info
"Simulation complete. Win Rate: {WinRate}%. Avg Turns: {AvgTurns}."
WinRate, AvgTurns
Sim
Report
Info
"Report written to {Path}."
Path

6. Testing Strategy
Integration Test (CombatSimIntegrationTests.cs)
	•	Metric_Validity:
	◦	Arrange: Simulate Warrior vs "Weak Rat" (Minion).
	◦	Act: Run 100 iterations.
	◦	Assert: Win Rate should be ~100%. Avg Turns should be low (<3).
	•	Defeat_Scenario:
	◦	Arrange: Simulate "Naked Level 1" vs "Boss".
	◦	Act: Run 100 iterations.
	◦	Assert: Win Rate should be ~0%.
	•	Consistency:
	◦	Arrange: Run simulation with fixed Seed.
	◦	Act: Run twice.
	◦	Assert: Results are identical (Deterministic Logic).

7. Draft Changelog (v0.3.13b)
# v0.3.13b Changelog: The Combat Simulator
**Release Date:** 2026-01-20

## Summary
This release implements the `sim-combat` CLI tool, a headless simulation engine for balancing the game's combat math. Developers can now pit AI-controlled player archetypes against enemies in thousands of rapid-fire battles to determine win rates and Time-To-Kill metrics.

## New Features
*   **Combat Simulator:** CLI command `--sim-combat` runs batch battles without UI rendering.
*   **Simulated Player Agent:** A heuristic AI that controls the player character during simulations, making rational decisions based on HP and Stamina.
*   **Balance Reports:** Automatically generates CSV/Markdown reports detailing win rates, turn counts, and resource consumption.

## Technical Changes
*   Implemented `CombatSimulationService` using parallel execution.
*   Refactored `CombatService` to support headless execution (decoupled from TUI).
*   Added `SimulatedPlayerAgent` to logic layer.