# v0.5.3a Design Specification: Flanking System

**Version:** 0.5.3a
**Phase Name:** Flanking System
**Parent Version:** v0.5.3 (Tactical Positioning)
**Prerequisites:** v0.5.2c Complete (Terrain & Cover Display & Integration)
**Estimated Tests:** ~30 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [FacingDirection Enum](#4-facingdirection-enum)
5. [FacingDirection Extensions](#5-facingdirection-extensions)
6. [Entity Facing Modifications](#6-entity-facing-modifications)
7. [FlankingService](#7-flankingservice)
8. [CombatService Flanking Integration](#8-combatservice-flanking-integration)
9. [User-Facing Commands](#9-user-facing-commands)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification establishes the flanking system that rewards tactical coordination in melee combat. Creatures have a facing direction that updates when they attack. Flanking is achieved when two allies attack an enemy from opposite sides, providing attack bonuses. Attacking from behind provides both attack and damage bonuses.

Key mechanics:
- **Facing Direction**: 8 cardinal/ordinal directions creatures can face
- **Auto-Face**: Creatures automatically face targets they attack
- **Flanking Detection**: Allies on opposite sides trigger flanking bonuses
- **Behind Attacks**: Extra bonus for attacking from behind a target's facing

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Enums** | `FacingDirection` |
| **Domain Extensions** | `FacingDirectionExtensions` |
| **Entity Updates** | Player.Facing, Monster.Facing |
| **Application Interfaces** | `IFlankingService` |
| **Application Services** | `FlankingService` |
| **Result Types** | `FlankingResult`, `FlankingType` |
| **CombatService Updates** | Flanking bonus in attacks |
| **Configuration** | `combat.json` flanking section |
| **Tests** | ~30 unit tests |

### 1.3 Architectural Significance

This version establishes the **Positional Advantage Pattern**:

- **Directional Combat**: Facing matters for tactical decisions
- **Coordinated Attacks**: Allies working together gain bonuses
- **Configurable Bonuses**: All flanking values in JSON configuration
- **Visual Feedback**: Grid shows facing indicators

---

## 2. Feature Overview

```
v0.5.3a Flanking System
├── FacingDirection Enum
│   ├── North, NorthEast, East, SouthEast
│   └── South, SouthWest, West, NorthWest
├── FacingDirectionExtensions
│   ├── GetOpposite(): FacingDirection
│   ├── GetDirectionTo(from, to): FacingDirection
│   ├── IsOpposite(direction): bool
│   ├── IsAdjacent(direction): bool
│   ├── IsBehind(attacker, target, facing): bool
│   └── IsSide(attacker, target, facing): bool
├── Entity Facing Modifications
│   ├── Player.Facing, Monster.Facing
│   ├── SetFacing(direction): void
│   ├── FaceToward(position): void
│   └── CombatGrid facing methods
├── FlankingService
│   ├── CheckFlanking(attacker, target): FlankingResult
│   ├── GetFlankingAttackBonus(): int
│   ├── GetFlankingDamageBonus(): int
│   ├── GetFlankingPositions(target): positions
│   ├── GetAllyFlankingPositions(): positions
│   ├── IsAttackingFromBehind(): bool
│   └── IsAttackingFromSide(): bool
├── FlankingResult
│   ├── IsFlanking: bool
│   ├── FlankingType: None/Side/Behind/Flanked
│   ├── AttackBonus, DamageBonus: int
│   └── FlankingAllyId, Message
└── CombatService Integration
    ├── Apply flanking bonuses to attack
    ├── Auto-face on attack
    └── Build message with flanking info
```

### 2.1 Scope Alignment

**In Scope:**
- `FacingDirection` enum (N, NE, E, SE, S, SW, W, NW)
- Creature facing property (Player and Monster)
- Auto-face toward target on attack
- `IFlankingService` interface
- `FlankingService` for flanking calculations
- Flanking detection (opposite sides)
- Configurable flanking bonus (attack/damage)
- Flanking configuration in JSON
- Flanking indicator in grid display
- Combat message for flanking bonus

**Out of Scope:**
- Opportunity attacks (v0.5.3b)
- Area effects (v0.5.3c)

---

## 3. Architecture Diagrams

### 3.1 Facing Directions

```
┌─────────────────────────────────────────────────────────────────────┐
│                       FACING DIRECTIONS                              │
└─────────────────────────────────────────────────────────────────────┘

                    NW    N    NE
                      ╲   │   ╱
                       ╲  │  ╱
                    W ───●─── E
                       ╱  │  ╲
                      ╱   │   ╲
                    SW    S    SE

    8 Directions:
    ┌────────────────┬────────────────────────────────────────────┐
    │ Direction      │ Grid Meaning                               │
    ├────────────────┼────────────────────────────────────────────┤
    │ North          │ Decreasing Y (up on grid)                  │
    │ NorthEast      │ Increasing X, Decreasing Y                 │
    │ East           │ Increasing X (right on grid)               │
    │ SouthEast      │ Increasing X, Increasing Y                 │
    │ South          │ Increasing Y (down on grid)                │
    │ SouthWest      │ Decreasing X, Increasing Y                 │
    │ West           │ Decreasing X (left on grid)                │
    │ NorthWest      │ Decreasing X, Decreasing Y                 │
    └────────────────┴────────────────────────────────────────────┘
```

### 3.2 Flanking Detection

```
┌─────────────────────────────────────────────────────────────────────┐
│                      FLANKING DETECTION                              │
└─────────────────────────────────────────────────────────────────────┘

    TRUE FLANKING (ally on opposite side)
    ┌───┬───┬───┬───┬───┐
    │   │   │ A │   │   │     A = Ally
    ├───┼───┼───┼───┼───┤     T = Target (facing East →)
    │   │   │ T→│   │   │     @ = You (attacker)
    ├───┼───┼───┼───┼───┤
    │   │   │ @ │   │   │     Result: FLANKED (+2 attack)
    └───┴───┴───┴───┴───┘     Ally on opposite side from you

    ATTACKING FROM BEHIND
    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │     T = Target (facing South ↓)
    ├───┼───┼───┼───┼───┤     @ = You (behind target)
    │   │   │ T↓│   │   │
    ├───┼───┼───┼───┼───┤     Result: BEHIND (+2 attack, +2 damage)
    │   │ @ │   │   │   │     Attacking from opposite of facing
    └───┴───┴───┴───┴───┘

    ATTACKING FROM SIDE
    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │     T = Target (facing South ↓)
    ├───┼───┼───┼───┼───┤     @ = You (on side)
    │   │ @ │ T↓│   │   │
    ├───┼───┼───┼───┼───┤     Result: SIDE (no bonus, but noted)
    │   │   │   │   │   │     90 degrees from facing
    └───┴───┴───┴───┴───┘

    NO FLANKING ADVANTAGE
    ┌───┬───┬───┬───┬───┐
    │   │   │ @ │   │   │     T = Target (facing North ↑)
    ├───┼───┼───┼───┼───┤     @ = You (in front)
    │   │   │ T↑│   │   │
    ├───┼───┼───┼───┼───┤     Result: NONE (no bonus)
    │   │   │   │   │   │     Attacking from faced direction
    └───┴───┴───┴───┴───┘
```

### 3.3 Flanking Check Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                      FLANKING CHECK FLOW                             │
└─────────────────────────────────────────────────────────────────────┘

    Attack Request
          │
          ▼
    ┌───────────────────┐
    │ Get Positions     │
    │ Attacker & Target │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Adjacent?         │──No──▶ Return: No flanking (range too far)
    │ (distance == 1)   │
    └────────┬──────────┘
             │Yes
             ▼
    ┌───────────────────┐
    │ Get Target Facing │
    │ Get Ally Positions│
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Ally on Opposite? │──Yes──▶ Return: FLANKED (+2 attack)
    │ (true flanking)   │
    └────────┬──────────┘
             │No
             ▼
    ┌───────────────────┐
    │ Behind Target?    │──Yes──▶ Return: BEHIND (+2 atk, +2 dmg)
    │ (opposite facing) │
    └────────┬──────────┘
             │No
             ▼
    ┌───────────────────┐
    │ Side of Target?   │──Yes──▶ Return: SIDE (noted, no bonus)
    │ (perpendicular)   │
    └────────┬──────────┘
             │No
             ▼
    ┌───────────────────┐
    │ Return: NONE      │
    │ (no advantage)    │
    └───────────────────┘
```

### 3.4 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  GridRenderer (Extended)                                             │
│  └── Shows facing indicators (↑↓←→↗↘↙↖) on entities                │
├─────────────────────────────────────────────────────────────────────┤
│  AttackCommand (Extended)                                            │
│  └── Shows flanking info in attack messages                         │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  IFlankingService / FlankingService                                  │
│  ├── CheckFlanking(attackerId, targetId): FlankingResult            │
│  ├── CheckFlanking(pos, pos, facing, allies): FlankingResult        │
│  ├── GetFlankingAttackBonus(attacker, target): int                  │
│  ├── GetFlankingDamageBonus(attacker, target): int                  │
│  ├── GetFlankingPositions(target): IEnumerable<GridPosition>        │
│  ├── GetAllyFlankingPositions(attacker, target): positions          │
│  ├── IsAttackingFromBehind(attacker, target): bool                  │
│  └── IsAttackingFromSide(attacker, target): bool                    │
├─────────────────────────────────────────────────────────────────────┤
│  FlankingResult                                                      │
│  ├── IsFlanking: bool                                               │
│  ├── FlankingType: FlankingType enum                                │
│  ├── AttackBonus: int                                               │
│  ├── DamageBonus: int                                               │
│  ├── FlankingAllyId: Guid?                                          │
│  └── Message: string                                                │
├─────────────────────────────────────────────────────────────────────┤
│  CombatService (Extended from v0.5.2c)                               │
│  ├── ProcessAttack: includes flanking check                         │
│  ├── Auto-face toward target after attack                           │
│  └── Apply flanking attack/damage bonuses                           │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         DOMAIN LAYER                                 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌────────────────────┐  ┌──────────────────────────────────────┐  │
│  │  FacingDirection   │  │   FacingDirectionExtensions          │  │
│  │      (Enum)        │  │                                      │  │
│  ├────────────────────┤  ├──────────────────────────────────────┤  │
│  │ North      = 0     │  │ + GetOpposite(): FacingDirection     │  │
│  │ NorthEast  = 1     │  │ + GetDirectionTo(from, to): FacingDir│  │
│  │ East       = 2     │  │ + IsOpposite(other): bool            │  │
│  │ SouthEast  = 3     │  │ + IsAdjacent(other): bool            │  │
│  │ South      = 4     │  │ + IsBehind(atk, tgt, facing): bool   │  │
│  │ SouthWest  = 5     │  │ + IsSide(atk, tgt, facing): bool     │  │
│  │ West       = 6     │  └──────────────────────────────────────┘  │
│  │ NorthWest  = 7     │                                            │
│  └────────────────────┘                                            │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                   FlankingType (Enum)                       │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │ None    = 0    (no advantage)                               │   │
│  │ Side    = 1    (attacking from side, no bonus)              │   │
│  │ Behind  = 2    (attacking from behind, bonus atk+dmg)       │   │
│  │ Flanked = 3    (ally on opposite side, bonus atk)           │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              Player / Monster (Extended)                    │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │ [NEW] Facing: FacingDirection (default: South/North)        │   │
│  │ [NEW] SetFacing(direction): void                            │   │
│  │ [NEW] FaceToward(position): void                            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              CombatGrid (Extended)                          │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │ [NEW] GetEntityFacing(entityId): FacingDirection?           │   │
│  │ [NEW] SetEntityFacing(entityId, direction): void            │   │
│  │ [NEW] FaceEntityToward(entityId, position): void            │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. FacingDirection Enum

### 4.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/FacingDirection.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Cardinal and ordinal directions for creature facing.
/// </summary>
public enum FacingDirection
{
    /// <summary>North (up on grid, decreasing Y).</summary>
    North = 0,

    /// <summary>Northeast (up-right on grid).</summary>
    NorthEast = 1,

    /// <summary>East (right on grid, increasing X).</summary>
    East = 2,

    /// <summary>Southeast (down-right on grid).</summary>
    SouthEast = 3,

    /// <summary>South (down on grid, increasing Y).</summary>
    South = 4,

    /// <summary>Southwest (down-left on grid).</summary>
    SouthWest = 5,

    /// <summary>West (left on grid, decreasing X).</summary>
    West = 6,

    /// <summary>Northwest (up-left on grid).</summary>
    NorthWest = 7
}
```

---

## 5. FacingDirection Extensions

**File:** `src/Core/RuneAndRust.Domain/Extensions/FacingDirectionExtensions.cs`

```csharp
namespace RuneAndRust.Domain.Extensions;

public static class FacingDirectionExtensions
{
    /// <summary>Gets the opposite direction.</summary>
    public static FacingDirection GetOpposite(this FacingDirection direction) =>
        direction switch
        {
            FacingDirection.North => FacingDirection.South,
            FacingDirection.NorthEast => FacingDirection.SouthWest,
            FacingDirection.East => FacingDirection.West,
            FacingDirection.SouthEast => FacingDirection.NorthWest,
            FacingDirection.South => FacingDirection.North,
            FacingDirection.SouthWest => FacingDirection.NorthEast,
            FacingDirection.West => FacingDirection.East,
            FacingDirection.NorthWest => FacingDirection.SouthEast,
            _ => FacingDirection.North
        };

    /// <summary>Gets the direction from one position to another.</summary>
    public static FacingDirection GetDirectionTo(GridPosition from, GridPosition to)
    {
        var dx = to.X - from.X;
        var dy = to.Y - from.Y;

        var nx = dx == 0 ? 0 : dx / Math.Abs(dx);
        var ny = dy == 0 ? 0 : dy / Math.Abs(dy);

        return (nx, ny) switch
        {
            (0, -1) => FacingDirection.North,
            (1, -1) => FacingDirection.NorthEast,
            (1, 0) => FacingDirection.East,
            (1, 1) => FacingDirection.SouthEast,
            (0, 1) => FacingDirection.South,
            (-1, 1) => FacingDirection.SouthWest,
            (-1, 0) => FacingDirection.West,
            (-1, -1) => FacingDirection.NorthWest,
            _ => FacingDirection.North
        };
    }

    /// <summary>Checks if two directions are opposite.</summary>
    public static bool IsOpposite(this FacingDirection direction, FacingDirection other) =>
        direction.GetOpposite() == other;

    /// <summary>Checks if a direction is adjacent (within 45 degrees).</summary>
    public static bool IsAdjacent(this FacingDirection direction, FacingDirection other)
    {
        var diff = Math.Abs((int)direction - (int)other);
        return diff == 1 || diff == 7;
    }

    /// <summary>Checks if attacker is behind target relative to facing.</summary>
    public static bool IsBehind(GridPosition attacker, GridPosition target, FacingDirection targetFacing)
    {
        var attackDirection = GetDirectionTo(target, attacker);
        return attackDirection.IsOpposite(targetFacing);
    }

    /// <summary>Checks if attacker is to the side of target relative to facing.</summary>
    public static bool IsSide(GridPosition attacker, GridPosition target, FacingDirection targetFacing)
    {
        var attackDirection = GetDirectionTo(target, attacker);
        var facing = (int)targetFacing;
        var attack = (int)attackDirection;
        var diff = Math.Abs(facing - attack);
        return diff == 2 || diff == 6; // 90 degrees
    }

    /// <summary>Gets the facing arrow character.</summary>
    public static char GetArrow(this FacingDirection direction) =>
        direction switch
        {
            FacingDirection.North => '↑',
            FacingDirection.NorthEast => '↗',
            FacingDirection.East => '→',
            FacingDirection.SouthEast => '↘',
            FacingDirection.South => '↓',
            FacingDirection.SouthWest => '↙',
            FacingDirection.West => '←',
            FacingDirection.NorthWest => '↖',
            _ => '·'
        };
}
```

---

## 6. Entity Facing Modifications

### 6.1 Player Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

```csharp
// Add to Player:

/// <summary>Gets the direction the player is facing.</summary>
public FacingDirection Facing { get; private set; } = FacingDirection.South;

/// <summary>Sets the player's facing direction.</summary>
public void SetFacing(FacingDirection direction)
{
    Facing = direction;
}

/// <summary>Faces the player toward a target position.</summary>
public void FaceToward(GridPosition targetPosition, GridPosition currentPosition)
{
    Facing = FacingDirectionExtensions.GetDirectionTo(currentPosition, targetPosition);
}
```

### 6.2 Monster Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Monster.cs`

```csharp
// Add to Monster:

/// <summary>Gets the direction the monster is facing.</summary>
public FacingDirection Facing { get; private set; } = FacingDirection.North;

/// <summary>Sets the monster's facing direction.</summary>
public void SetFacing(FacingDirection direction)
{
    Facing = direction;
}

/// <summary>Faces the monster toward a target position.</summary>
public void FaceToward(GridPosition targetPosition, GridPosition currentPosition)
{
    Facing = FacingDirectionExtensions.GetDirectionTo(currentPosition, targetPosition);
}
```

### 6.3 CombatGrid Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/CombatGrid.cs`

```csharp
// Add to CombatGrid:

private readonly Dictionary<Guid, FacingDirection> _entityFacings = new();

/// <summary>Gets an entity's facing direction.</summary>
public FacingDirection? GetEntityFacing(Guid entityId) =>
    _entityFacings.TryGetValue(entityId, out var facing) ? facing : null;

/// <summary>Sets an entity's facing direction.</summary>
public void SetEntityFacing(Guid entityId, FacingDirection direction)
{
    _entityFacings[entityId] = direction;
}

/// <summary>Faces an entity toward a target position.</summary>
public void FaceEntityToward(Guid entityId, GridPosition targetPosition)
{
    var currentPos = GetEntityPosition(entityId);
    if (currentPos.HasValue)
    {
        var direction = FacingDirectionExtensions.GetDirectionTo(currentPos.Value, targetPosition);
        SetEntityFacing(entityId, direction);
    }
}
```

---

## 7. FlankingService

### 7.1 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IFlankingService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

public interface IFlankingService
{
    FlankingResult CheckFlanking(Guid attackerId, Guid targetId);
    FlankingResult CheckFlanking(GridPosition attackerPos, GridPosition targetPos,
        FacingDirection targetFacing, IEnumerable<GridPosition> allyPositions);
    int GetFlankingAttackBonus(Guid attackerId, Guid targetId);
    int GetFlankingDamageBonus(Guid attackerId, Guid targetId);
    IEnumerable<GridPosition> GetFlankingPositions(Guid targetId);
    IEnumerable<GridPosition> GetAllyFlankingPositions(Guid attackerId, Guid targetId);
    bool IsAttackingFromBehind(Guid attackerId, Guid targetId);
    bool IsAttackingFromSide(Guid attackerId, Guid targetId);
}

public readonly record struct FlankingResult(
    bool IsFlanking, FlankingType FlankingType,
    int AttackBonus, int DamageBonus,
    Guid? FlankingAllyId, string Message);

public enum FlankingType
{
    None = 0,
    Side = 1,
    Behind = 2,
    Flanked = 3
}
```

### 7.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/FlankingService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class FlankingService : IFlankingService
{
    private readonly ICombatGridService _gridService;
    private readonly ICombatStateService _combatStateService;
    private readonly IGameConfigurationProvider _config;
    private readonly ILogger<FlankingService> _logger;

    private int _flankingAttackBonus = 2;
    private int _flankingDamageBonus = 0;
    private int _behindAttackBonus = 2;
    private int _behindDamageBonus = 2;

    public FlankingService(
        ICombatGridService gridService,
        ICombatStateService combatStateService,
        IGameConfigurationProvider config,
        ILogger<FlankingService> logger)
    {
        _gridService = gridService;
        _combatStateService = combatStateService;
        _config = config;
        _logger = logger;
        LoadConfiguration();
    }

    private void LoadConfiguration()
    {
        var combatConfig = _config.GetCombatConfiguration();
        if (combatConfig?.Flanking != null)
        {
            _flankingAttackBonus = combatConfig.Flanking.AttackBonus;
            _flankingDamageBonus = combatConfig.Flanking.DamageBonus;
            _behindAttackBonus = combatConfig.Flanking.BehindAttackBonus;
            _behindDamageBonus = combatConfig.Flanking.BehindDamageBonus;
        }
    }

    public FlankingResult CheckFlanking(Guid attackerId, Guid targetId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            return new FlankingResult(false, FlankingType.None, 0, 0, null, "No active grid.");

        var attackerPos = grid.GetEntityPosition(attackerId);
        var targetPos = grid.GetEntityPosition(targetId);

        if (!attackerPos.HasValue || !targetPos.HasValue)
            return new FlankingResult(false, FlankingType.None, 0, 0, null, "Entity not on grid.");

        if (attackerPos.Value.DistanceTo(targetPos.Value) > 1)
            return new FlankingResult(false, FlankingType.None, 0, 0, null, "Must be adjacent to flank.");

        var targetFacing = grid.GetEntityFacing(targetId) ?? FacingDirection.North;
        var allyPositions = GetAlliedPositions(attackerId, grid);

        return CheckFlanking(attackerPos.Value, targetPos.Value, targetFacing, allyPositions);
    }

    public FlankingResult CheckFlanking(GridPosition attackerPos, GridPosition targetPos,
        FacingDirection targetFacing, IEnumerable<GridPosition> allyPositions)
    {
        // Check for ally on opposite side
        var attackerDir = FacingDirectionExtensions.GetDirectionTo(targetPos, attackerPos);
        var flankedByAlly = false;

        foreach (var allyPos in allyPositions)
        {
            if (allyPos.DistanceTo(targetPos) != 1) continue;

            var allyDir = FacingDirectionExtensions.GetDirectionTo(targetPos, allyPos);
            if (allyDir.IsOpposite(attackerDir))
            {
                flankedByAlly = true;
                break;
            }
        }

        var isBehind = FacingDirectionExtensions.IsBehind(attackerPos, targetPos, targetFacing);
        var isSide = FacingDirectionExtensions.IsSide(attackerPos, targetPos, targetFacing);

        if (flankedByAlly)
        {
            return new FlankingResult(true, FlankingType.Flanked,
                _flankingAttackBonus, _flankingDamageBonus, null,
                $"Flanking! (+{_flankingAttackBonus} attack)");
        }

        if (isBehind)
        {
            return new FlankingResult(true, FlankingType.Behind,
                _behindAttackBonus, _behindDamageBonus, null,
                $"Backstab! (+{_behindAttackBonus} attack, +{_behindDamageBonus} damage)");
        }

        if (isSide)
        {
            return new FlankingResult(false, FlankingType.Side, 0, 0, null,
                "Attacking from the side.");
        }

        return new FlankingResult(false, FlankingType.None, 0, 0, null, "No flanking advantage.");
    }

    public int GetFlankingAttackBonus(Guid attackerId, Guid targetId) =>
        CheckFlanking(attackerId, targetId).AttackBonus;

    public int GetFlankingDamageBonus(Guid attackerId, Guid targetId) =>
        CheckFlanking(attackerId, targetId).DamageBonus;

    public IEnumerable<GridPosition> GetFlankingPositions(Guid targetId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) yield break;

        var targetPos = grid.GetEntityPosition(targetId);
        if (!targetPos.HasValue) yield break;

        foreach (var cell in grid.GetAdjacentCells(targetPos.Value))
        {
            if (!cell.IsOccupied && cell.IsPassable)
                yield return cell.Position;
        }
    }

    public IEnumerable<GridPosition> GetAllyFlankingPositions(Guid attackerId, Guid targetId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) yield break;

        var attackerPos = grid.GetEntityPosition(attackerId);
        var targetPos = grid.GetEntityPosition(targetId);
        if (!attackerPos.HasValue || !targetPos.HasValue) yield break;

        var attackerDir = FacingDirectionExtensions.GetDirectionTo(targetPos.Value, attackerPos.Value);
        var oppositeDir = attackerDir.GetOpposite();

        foreach (var allyPos in GetAlliedPositions(attackerId, grid))
        {
            if (allyPos.DistanceTo(targetPos.Value) == 1)
            {
                var allyDir = FacingDirectionExtensions.GetDirectionTo(targetPos.Value, allyPos);
                if (allyDir == oppositeDir)
                    yield return allyPos;
            }
        }
    }

    public bool IsAttackingFromBehind(Guid attackerId, Guid targetId) =>
        CheckFlanking(attackerId, targetId).FlankingType == FlankingType.Behind;

    public bool IsAttackingFromSide(Guid attackerId, Guid targetId) =>
        CheckFlanking(attackerId, targetId).FlankingType == FlankingType.Side;

    private IEnumerable<GridPosition> GetAlliedPositions(Guid entityId, CombatGrid grid)
    {
        var combat = _combatStateService.GetCurrentCombat();
        if (combat == null) yield break;

        var entity = combat.GetCombatant(entityId);
        if (entity == null) yield break;

        foreach (var combatant in combat.Combatants)
        {
            if (combatant.Id == entityId) continue;
            if (combatant.IsPlayer == entity.IsPlayer)
            {
                var pos = grid.GetEntityPosition(combatant.Id);
                if (pos.HasValue) yield return pos.Value;
            }
        }
    }
}
```

---

## 8. CombatService Flanking Integration

**File:** `src/Core/RuneAndRust.Application/Services/CombatService.cs`

```csharp
// Update CombatService to include flanking:

public AttackResult ProcessAttack(Guid attackerId, Guid targetId, Item weapon)
{
    // ... existing validation ...

    var grid = _gridService.GetActiveGrid();
    var targetPos = grid?.GetEntityPosition(targetId);

    // Get cover bonus (from v0.5.2)
    var coverResult = _coverService.GetCoverBetween(attackerId, targetId);
    if (coverResult.CoverType == CoverType.Full)
        return AttackResult.BlockedByCover(coverResult.CoverObject);

    // Get flanking bonus (NEW)
    var flankingResult = _flankingService.CheckFlanking(attackerId, targetId);

    // Auto-face toward target after attack (NEW)
    if (targetPos.HasValue)
        grid?.FaceEntityToward(attackerId, targetPos.Value);

    // Calculate modifiers
    var attackModifier = weapon.AttackBonus + flankingResult.AttackBonus;
    var targetDefense = target.Defense + coverResult.DefenseBonus;

    // Roll attack
    var roll = _diceService.Roll(weapon.AttackDice ?? "2d6");
    var total = roll.Total + attackModifier;
    var hit = total >= targetDefense;

    // Apply damage with flanking bonus
    var damage = 0;
    if (hit)
    {
        var damageRoll = _diceService.Roll(weapon.Damage);
        damage = damageRoll.Total + weapon.DamageBonus + flankingResult.DamageBonus;
        target.TakeDamage(damage);
    }

    // Build message with flanking info
    var message = BuildAttackMessage(weapon, roll, attackModifier,
        targetDefense, coverResult, flankingResult, hit, damage);

    return hit ? AttackResult.Hit(damage, message) : AttackResult.Miss(message);
}
```

---

## 9. User-Facing Commands

### 9.1 Flanking Attack

```
> attack goblin

You strike the Goblin with your Iron Sword!

[Flanking: Your ally is on the opposite side! (+2 attack)]
[Attack Roll: 2d6 + 3 + 2 (flank) = 14 vs AC 11]
Hit! 8 damage to Goblin.

The Goblin turns to face you.
```

### 9.2 Attacking From Behind

```
> attack skeleton

You sneak up behind the Skeleton with your Dagger!

[Backstab: Attacking from behind! (+2 attack, +2 damage)]
[Attack Roll: 2d6 + 4 + 2 (behind) = 15 vs AC 10]
Hit! 9 damage (5 + 2 + 2 backstab) to Skeleton.
```

### 9.3 Grid with Facing Indicators

```
Combat Grid                              [Turn 3]
===============================================

  A B C D E F G H
1 . . . . . . . .
2 . . M↓. . . . .     @ = You (facing: S)
3 . A→. . . M←. .     M = Monster (arrows show facing)
4 . . . @↓. . . .     A = Ally
5 . . . . . . . .     ↑↓←→ = Facing direction

Flanking Opportunity:
  Move to D2 to flank Skeleton at C2 with Ally at B3

You (D4) | HP: 25/30 | Move: 4/4
```

---

## 10. Data Model Changes

| Type | Layer | Description |
|------|-------|-------------|
| `FacingDirection` | Domain/Enums | 8 cardinal/ordinal directions |
| `FacingDirectionExtensions` | Domain/Extensions | Direction utilities |
| `FlankingType` | Application/DTOs | None, Side, Behind, Flanked |
| `FlankingResult` | Application/DTOs | Flanking check result |
| `IFlankingService` | Application/Interfaces | Flanking service interface |
| `FlankingService` | Application/Services | Flanking calculations |
| `Player` | Domain/Entities | Add Facing property |
| `Monster` | Domain/Entities | Add Facing property |
| `CombatGrid` | Domain/Entities | Add facing tracking methods |

---

## 11. Configuration File Schemas

**File:** `config/combat.json` (flanking section)

```json
{
  "$schema": "./schemas/combat.schema.json",
  "flanking": {
    "enabled": true,
    "attackBonus": 2,
    "damageBonus": 0,
    "behindAttackBonus": 2,
    "behindDamageBonus": 2,
    "requiresAlly": true,
    "allyMustBeAdjacent": true,
    "description": "Flanking provides +2 attack when ally is on opposite side"
  }
}
```

---

## 12. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `FlankingService` | Debug | Flanking checks, direction calculations |
| `FlankingService` | Information | Flanking bonuses applied |
| `CombatService` | Debug | Facing updates after attacks |

---

## 13. Unit Testing Requirements

| Feature | Test Count |
|---------|------------|
| FacingDirection.GetOpposite | ~2 |
| FacingDirectionExtensions.GetDirectionTo | ~4 |
| FacingDirectionExtensions.IsBehind | ~3 |
| FacingDirectionExtensions.IsSide | ~3 |
| FlankingService.CheckFlanking | ~8 |
| FlankingService.GetFlankingPositions | ~3 |
| Entity Facing Properties | ~4 |
| CombatGrid Facing Methods | ~3 |
| **Total** | **~30** |

---

## 14. Use Cases

### UC-001: True Flanking
**Flow:** Attack with ally on opposite side → +2 attack bonus

### UC-002: Backstab
**Flow:** Attack from behind target's facing → +2 attack, +2 damage

### UC-003: Side Attack
**Flow:** Attack from side → No bonus (noted)

### UC-004: Front Attack
**Flow:** Attack from faced direction → No bonus

### UC-005: Auto-Face on Attack
**Flow:** Player attacks → Player now faces target

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `FacingDirection` enum
- [ ] `FacingDirectionExtensions`
- [ ] Player.Facing, SetFacing, FaceToward
- [ ] Monster.Facing, SetFacing, FaceToward
- [ ] CombatGrid facing methods

### Application Layer
- [ ] `IFlankingService` interface
- [ ] `FlankingService` implementation
- [ ] `FlankingResult`, `FlankingType`
- [ ] CombatService flanking integration

### Presentation Layer
- [ ] GridRenderer facing indicators

### Configuration
- [ ] `combat.json` flanking section

### Testing
- [ ] ~30 unit tests
- [ ] All tests passing

---

## 16. Acceptance Criteria

### Functional
- [ ] FacingDirection enum has all 8 directions
- [ ] Player and Monster have Facing property
- [ ] Creatures auto-face toward attack target
- [ ] Flanking detected when ally on opposite side
- [ ] Flanking provides +2 attack bonus (configurable)
- [ ] Attacking from behind provides +2 attack and +2 damage
- [ ] FlankingService calculates flanking correctly
- [ ] Grid display shows facing indicators
- [ ] Combat messages show flanking bonuses
- [ ] Flanking configuration loads from JSON

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~30 unit tests pass
- [ ] XML documentation complete

---

## 17. Dependencies

### Required from v0.5.0a

| Type | Usage |
|------|-------|
| `GridPosition` | Position calculations |
| `CombatGrid` | Entity positions |
| `GetAdjacentCells` | Adjacent position lookup |

### Required from v0.5.2c

| Type | Usage |
|------|-------|
| `CombatService` | Integration point |
| `CoverService` | Existing cover integration |

### Provides to v0.5.3b
- Entity facing for threat calculations
- Flanking infrastructure for reactions

---

## 18. Future Considerations

### Deferred to v0.5.3b
- Opportunity attacks
- Reaction system
- Disengage action

### Deferred to v0.5.3c
- Area effects
- AoE targeting

### Out of Scope
- Facing changing on damage
- Shield facing mechanics
- Facing-based defense bonuses

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: AI Assistant*
