# Design Specification: v0.20.3b - Tier 2 Abilities

**Version:** v0.20.3b
**Status:** Design Phase
**Last Updated:** 2026-01-28
**Target Tests:** ~8 unit and integration tests
**Specialization:** Jötun-Reader (Adept)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [Tier 2 Framework](#5-tier-2-framework)
6. [Technical Memory Ability Specification](#6-technical-memory-ability-specification)
7. [Exploit Weakness Ability Specification](#7-exploit-weakness-ability-specification)
8. [Data Recovery Ability Specification](#8-data-recovery-ability-specification)
9. [Puzzle System Integration](#9-puzzle-system-integration)
10. [Combat Integration](#10-combat-integration)
11. [Terminal Security System](#11-terminal-security-system)
12. [Prerequisite Validation](#12-prerequisite-validation)
13. [Configuration Files](#13-configuration-files)
14. [Code Examples and Implementation](#14-code-examples-and-implementation)
15. [Domain Models](#15-domain-models)
16. [Service Architecture](#16-service-architecture)
17. [Vulnerability Analysis System](#17-vulnerability-analysis-system)
18. [Data Fragment System](#18-data-fragment-system)
19. [Logging Specifications](#19-logging-specifications)
20. [Unit Testing Requirements](#20-unit-testing-requirements)
21. [Deliverable Checklist](#21-deliverable-checklist)
22. [Acceptance Criteria](#22-acceptance-criteria)

---

## 1. Executive Summary

Version 0.20.3b implements three Tier 2 abilities for the Jötun-Reader specialization. These abilities expand the archetype's practical applications by enabling characters to recall puzzle solutions, identify enemy weaknesses, and extract data from damaged systems. Tier 2 represents a significant power increase, requiring 8 PP invested in the Jötun-Reader tree (approximately mid-game progression) and costing 4 PP per ability.

### Key Deliverables

| Category | Count | Details |
|----------|-------|---------|
| **Tier 2 Abilities** | 3 | Technical Memory, Exploit Weakness, Data Recovery |
| **Domain Models** | 3 | TechnicalMemoryRecord, WeaknessAnalysis, RecoveredData |
| **Enums** | 1 | VulnerabilityType |
| **Application Services** | 3 | Technical Memory Service, Weakness Analysis Service, Data Recovery Service |
| **Combat Integration** | 1 | Weakness exploitation damage system |
| **Configuration Updates** | 2 | specializations.json, abilities.json |
| **Unit Tests** | ~8 | Comprehensive test coverage |

### Tier 2 Status

| Attribute | Value |
|-----------|-------|
| **PP Requirement** | 8 PP invested in Jötun-Reader tree |
| **Unlock Cost Per Ability** | 4 PP each |
| **Number of Abilities** | 3 |
| **Active Abilities** | 3 (all active) |
| **Total AP Cost** | 1-3 AP per activation |

---

## 2. Feature Overview

### 2.1 Tier 2 Unlock Requirements

Before any Tier 2 ability can be accessed:

1. **Character must have Jötun-Reader specialization** - Core requirement
2. **Must have invested 8+ PP in Jötun-Reader tree** - Progression gate
3. **Must have unlocked Tier 1 abilities** - Foundation prerequisite
4. **Character level 5-7 typical** - Soft guideline (GM discretion)

### 2.2 Tier 2 Ability Overview

| Ability | Type | AP Cost | Insight Cost | Effect |
|---------|------|---------|--------------|--------|
| **Technical Memory** | Active | 1 AP | 2 Lore Insight | Recall puzzle solution or reduce DC by 5 |
| **Exploit Weakness** | Active | 2 AP | 3 Lore Insight | Reveal enemy vulnerabilities; +1d6 damage |
| **Data Recovery** | Active | 3 AP | 2 Lore Insight | Extract data from damaged terminals |

### 2.3 Design Goals

**Technical Memory:** Reward players for exploration and discovery by allowing them to apply past solutions to current puzzles.

**Exploit Weakness:** Provide tactical value in combat through knowledge gathering, encouraging skill-use over pure combat stats.

**Data Recovery:** Enable access to information that would otherwise be lost, supporting quest progression and world exploration.

---

## 3. Architecture Diagrams

### 3.1 Tier 2 Service Architecture

```
┌──────────────────────────────────────────────────────────────────┐
│           Jötun-Reader Tier 2 Service Integration                 │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │    Tier 2 Ability Orchestrator                           │   │
│  │                                                          │   │
│  │  + ValidateTier2Prerequisites()                         │   │
│  │  + ExecuteTechnicalMemory()                             │   │
│  │  + ExecuteExploitWeakness()                             │   │
│  │  + ExecuteDataRecovery()                                │   │
│  └──────────────────────────────────────────────────────────┘   │
│         │                    │                     │             │
│         ▼                    ▼                     ▼             │
│  ┌─────────────┐      ┌──────────────┐    ┌──────────────┐     │
│  │  Technical  │      │  Weakness    │    │    Data      │     │
│  │  Memory     │      │  Analysis    │    │  Recovery    │     │
│  │  Service    │      │  Service     │    │  Service     │     │
│  └─────────────┘      └──────────────┘    └──────────────┘     │
│         │                    │                     │             │
│         ▼                    ▼                     ▼             │
│  ┌─────────────┐      ┌──────────────┐    ┌──────────────┐     │
│  │   Puzzle    │      │   Combat     │    │   Terminal   │     │
│  │ Matching    │      │   System     │    │   Access     │     │
│  │ Engine      │      │  Integration │    │   System     │     │
│  └─────────────┘      └──────────────┘    └──────────────┘     │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘

Data Flow for Technical Memory:
┌─────────────────────┐     ┌──────────────────┐
│ Current Puzzle      │────▶│ Puzzle Matching  │
│ Encountered         │     │ Engine           │
└─────────────────────┘     └──────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    │                               │
                    ▼                               ▼
            ┌─────────────────┐         ┌──────────────────┐
            │ Solution Found  │         │ Similar Pattern  │
            │ (DC Bypass)     │         │ Found (DC -5)    │
            └─────────────────┘         └──────────────────┘
```

### 3.2 Vulnerability Analysis Architecture

```
┌──────────────────────────────────────────────┐
│       Exploit Weakness Combat Flow            │
├──────────────────────────────────────────────┤
│                                              │
│  1. Activate Exploit Weakness               │
│     └─→ Spend 2 AP + 3 Lore Insight        │
│                                              │
│  2. Analyze Target Enemy                    │
│     └─→ Gather weakness information         │
│                                              │
│  3. Reveal to All Combat Participants      │
│     ├─→ Vulnerabilities (+damage types)     │
│     ├─→ Resistances (-damage types)         │
│     ├─→ Immunities (no damage)              │
│     └─→ Weak Points (+2 to hit)             │
│                                              │
│  4. Apply Combat Bonus                      │
│     └─→ Attacks targeting weakness: +1d6   │
│                                              │
└──────────────────────────────────────────────┘
```

---

## 4. User Stories

### User Story 1: Scholar Remembers Mechanism Pattern

**As a** Jötun-Reader character encountering a second similar puzzle
**I want to** spend 1 AP and 2 Lore Insight to recall the solution to the first one
**So that** I can quickly solve repetitive challenges without making new checks

**Acceptance Criteria:**
- Technical Memory identifies puzzles of same category (mechanical, electrical, etc.)
- If exact solution found: provides complete solution, bypasses DC
- If similar pattern found: reduces DC by 5 for the check
- Can only be used once per unique puzzle
- Requires the original puzzle to have been recorded in discovery log
- Works across different locations if puzzle mechanisms are similar

### User Story 2: Investigator Exposes Enemy Weakness

**As a** Jötun-Reader character in combat
**I want to** spend 2 AP and 3 Lore Insight to Exploit Weakness on an enemy
**So that** all allies gain information about the enemy's vulnerabilities and damage is increased

**Acceptance Criteria:**
- Exploit Weakness reveals target's damage vulnerabilities and resistances
- Reveals weak points (+2 to hit specific locations)
- Information is visible to all combat participants
- Effect lasts until end of combat
- Attacks targeting revealed weaknesses deal +1d6 damage
- Can be used once per enemy per combat
- Provides tactical advantage without reducing enemy capabilities

### User Story 3: Technician Recovers Corrupted Data

**As a** Jötun-Reader character at a damaged terminal
**I want to** spend 3 AP and 2 Lore Insight to attempt Data Recovery
**So that** I can access information that would otherwise be lost

**Acceptance Criteria:**
- Data Recovery works on locked, damaged, and corrupted terminals
- Bypass security using Lore Insight instead of hacking
- Success recovers 1d4 data fragments containing information
- Critical success recovers all data and generates +1 Lore Insight
- Difficulty varies by terminal state (DC 12-20)
- Partial success provides hint rather than complete failure
- Some data may be permanently lost if system is destroyed

### User Story 4: Progression Check - Tier 2 Prerequisites

**As a** Game Master tracking specialization progression
**I want to** verify that Tier 2 abilities are locked until 8 PP are invested
**So that** specialization progression paces the game appropriately

**Acceptance Criteria:**
- Characters cannot unlock Tier 2 abilities before investing 8 PP
- Unlocking individual Tier 2 abilities costs 4 PP each
- Tier 2 prerequisites are clearly communicated
- Error messages indicate what's needed to unlock abilities
- UI shows lock status and unlock requirements

---

## 5. Tier 2 Framework

### 5.1 Tier 2 Prerequisites Validation

```csharp
/// <summary>
/// Validates that a character meets Tier 2 requirements.
/// </summary>
public interface ITier2PrerequisiteValidator
{
    /// <summary>
    /// Checks if character can access Tier 2 abilities.
    /// </summary>
    bool CanAccessTier2(Character character);

    /// <summary>
    /// Gets the reason why Tier 2 is not accessible (if any).
    /// </summary>
    string? GetAccessDenialReason(Character character);

    /// <summary>
    /// Checks if character can unlock a specific Tier 2 ability.
    /// </summary>
    bool CanUnlockAbility(Character character, string abilityId);
}

/// <summary>
/// Implementation of Tier 2 prerequisite validation.
/// </summary>
public sealed class Tier2PrerequisiteValidator : ITier2PrerequisiteValidator
{
    private const int RequiredPPForTier2 = 8;
    private const int CostPerTier2Ability = 4;

    public bool CanAccessTier2(Character character)
    {
        if (character?.Specialization?.SpecializationId != "jotun-reader")
            return false;

        var investedPP = character.GetSpecializationPointsInvested("jotun-reader");
        return investedPP >= RequiredPPForTier2;
    }

    public string? GetAccessDenialReason(Character character)
    {
        if (character?.Specialization?.SpecializationId != "jotun-reader")
            return "Character must be Jötun-Reader specialization";

        var investedPP = character.GetSpecializationPointsInvested("jotun-reader");
        if (investedPP < RequiredPPForTier2)
        {
            var needed = RequiredPPForTier2 - investedPP;
            return $"Tier 2 requires {RequiredPPForTier2} PP invested. " +
                   $"You have {investedPP}, need {needed} more.";
        }

        return null; // No denial reason; can access
    }

    public bool CanUnlockAbility(Character character, string abilityId)
    {
        // Must meet Tier 2 access requirements first
        if (!CanAccessTier2(character))
            return false;

        // Must have enough specialization points
        var totalPP = character.SpecializationPoints;
        var alreadySpent = character.GetSpecializationPointsSpent("jotun-reader");
        var available = totalPP - alreadySpent;

        return available >= CostPerTier2Ability;
    }
}
```

### 5.2 Tier 2 Configuration

In `specializations.json`, the Tier 2 entry:

```json
{
  "tier": 2,
  "ppRequirement": 8,
  "abilityCost": 4,
  "abilities": [
    "technical-memory",
    "exploit-weakness",
    "data-recovery"
  ]
}
```

---

## 6. Technical Memory Ability Specification

### 6.1 Ability Profile

| Property | Value |
|----------|-------|
| **Ability ID** | `technical-memory` |
| **Type** | Active |
| **AP Cost** | 1 AP |
| **Lore Insight Cost** | 2 |
| **Tier** | 2 |
| **PP Cost** | 4 PP to unlock |
| **Prerequisites** | 8 PP in Jötun-Reader tree |

### 6.2 Puzzle Matching System

Technical Memory matches current puzzles against previously solved ones:

```csharp
/// <summary>
/// Represents a puzzle solved by the character.
/// Used for Technical Memory ability matching.
/// </summary>
[ValueObject]
public sealed record TechnicalMemoryRecord
{
    /// <summary>Unique identifier for this record.</summary>
    public Guid RecordId { get; init; }

    /// <summary>Category of the puzzle (Mechanical, Electrical, etc.).</summary>
    public string PuzzleCategory { get; init; } = string.Empty;

    /// <summary>Description of the puzzle mechanism.</summary>
    public string PuzzleDescription { get; init; } = string.Empty;

    /// <summary>Solution method or key.</summary>
    public string Solution { get; init; } = string.Empty;

    /// <summary>When the puzzle was solved.</summary>
    public DateTime SolvedAt { get; init; }

    /// <summary>Location where solved (for context).</summary>
    public Guid LocationId { get; init; }

    /// <summary>Name or description of location.</summary>
    public string LocationName { get; init; } = string.Empty;

    /// <summary>Difficulty of the original puzzle.</summary>
    public int OriginalDC { get; init; }

    /// <summary>
    /// Creates a new puzzle memory record.
    /// </summary>
    public static TechnicalMemoryRecord Create(
        string category,
        string description,
        string solution,
        Guid locationId,
        string locationName,
        int originalDC)
    {
        return new TechnicalMemoryRecord
        {
            RecordId = Guid.NewGuid(),
            PuzzleCategory = category,
            PuzzleDescription = description,
            Solution = solution,
            SolvedAt = DateTime.UtcNow,
            LocationId = locationId,
            LocationName = locationName,
            OriginalDC = originalDC
        };
    }

    /// <summary>
    /// Determines if another puzzle matches this one's pattern.
    /// </summary>
    public bool MatchesPuzzle(string otherCategory, string otherDescription)
    {
        // Same category is primary match
        if (PuzzleCategory == otherCategory)
        {
            // Check for similar patterns in description
            return ArePatternsSimular(PuzzleDescription, otherDescription);
        }

        return false;
    }

    /// <summary>
    /// Gets a hint about the solution.
    /// </summary>
    public string GetSolutionHint()
    {
        // Provide partial information, not complete solution
        return $"Earlier puzzle in {LocationName}: {PuzzleCategory.ToLower()} mechanism";
    }

    private bool ArePatternsSimular(string desc1, string desc2)
    {
        // Simple similarity check using common keywords
        var keywords1 = ExtractKeywords(desc1);
        var keywords2 = ExtractKeywords(desc2);

        var matches = keywords1.Intersect(keywords2).Count();
        var totalUnique = keywords1.Union(keywords2).Count();

        return matches > 0 && (decimal)matches / totalUnique >= 0.5m; // 50% similarity threshold
    }

    private IEnumerable<string> ExtractKeywords(string text)
    {
        return text.ToLower().Split(new[] { ' ', ',', '.' }, StringSplitOptions.RemoveEmptyEntries)
            .Where(w => w.Length > 3); // Only keep words with 4+ characters
    }
}
```

### 6.3 Technical Memory Service

```csharp
/// <summary>
/// Service for Technical Memory ability.
/// </summary>
public interface ITechnicalMemoryService
{
    /// <summary>
    /// Records a puzzle solution.
    /// </summary>
    Task RecordPuzzleSolution(
        Guid characterId,
        string category,
        string description,
        string solution,
        Guid locationId,
        string locationName,
        int dc);

    /// <summary>
    /// Attempts to recall a solution for a current puzzle.
    /// </summary>
    Task<TechnicalMemoryResult> AttemptRecall(
        Guid characterId,
        string puzzleCategory,
        string puzzleDescription);
}

/// <summary>
/// Result of a Technical Memory recall attempt.
/// </summary>
public sealed record TechnicalMemoryResult
{
    /// <summary>Whether a matching puzzle was found.</summary>
    public bool Found { get; init; }

    /// <summary>Whether an exact solution was found (vs. similar pattern).</summary>
    public bool IsExactMatch { get; init; }

    /// <summary>The solution or hint.</summary>
    public string? SolutionOrHint { get; init; }

    /// <summary>DC reduction if similar match (null if exact).</summary>
    public int? DCReduction { get; init; } = null;

    /// <summary>Location where the original puzzle was solved.</summary>
    public string? OriginalLocation { get; init; }

    public static TechnicalMemoryResult NotFound() => new() { Found = false };

    public static TechnicalMemoryResult ExactMatch(string solution, string location) =>
        new()
        {
            Found = true,
            IsExactMatch = true,
            SolutionOrHint = solution,
            OriginalLocation = location
        };

    public static TechnicalMemoryResult SimilarPattern(string hint, string location) =>
        new()
        {
            Found = true,
            IsExactMatch = false,
            SolutionOrHint = hint,
            DCReduction = 5,
            OriginalLocation = location
        };
}

/// <summary>
/// Implementation of Technical Memory service.
/// </summary>
public sealed class TechnicalMemoryService : ITechnicalMemoryService
{
    private readonly IRepository<TechnicalMemoryRecord> _puzzleRepository;
    private readonly ILogger<TechnicalMemoryService> _logger;

    public TechnicalMemoryService(
        IRepository<TechnicalMemoryRecord> puzzleRepository,
        ILogger<TechnicalMemoryService> logger)
    {
        _puzzleRepository = puzzleRepository ?? throw new ArgumentNullException(nameof(puzzleRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task RecordPuzzleSolution(
        Guid characterId,
        string category,
        string description,
        string solution,
        Guid locationId,
        string locationName,
        int dc)
    {
        var record = TechnicalMemoryRecord.Create(category, description, solution, locationId, locationName, dc);
        await _puzzleRepository.Add(record);

        _logger.LogInformation(
            "Puzzle recorded: {Character} - {Category} in {Location}",
            characterId, category, locationName);
    }

    public async Task<TechnicalMemoryResult> AttemptRecall(
        Guid characterId,
        string puzzleCategory,
        string puzzleDescription)
    {
        var knownPuzzles = await _puzzleRepository.QueryAsync(p => true); // Get all for character

        // Look for exact category match
        foreach (var known in knownPuzzles)
        {
            if (known.MatchesPuzzle(puzzleCategory, puzzleDescription))
            {
                // Check for exact description match first
                if (known.PuzzleDescription.Equals(puzzleDescription, StringComparison.OrdinalIgnoreCase))
                {
                    _logger.LogInformation(
                        "Technical Memory: Exact match found from {Location}",
                        known.LocationName);

                    return TechnicalMemoryResult.ExactMatch(known.Solution, known.LocationName);
                }

                // Similar pattern match
                _logger.LogInformation(
                    "Technical Memory: Similar pattern match from {Location}",
                    known.LocationName);

                return TechnicalMemoryResult.SimilarPattern(known.GetSolutionHint(), known.LocationName);
            }
        }

        return TechnicalMemoryResult.NotFound();
    }
}
```

### 6.4 Technical Memory Usage

```
Command: > ability technical-memory

When a puzzle is encountered:
> Puzzle: Gear alignment mechanism
> DC: 14

If Technical Memory finds match:
╔════════════════════════════════════════════════════════════════╗
║              TECHNICAL MEMORY - PUZZLE RECALLED                ║
╠════════════════════════════════════════════════════════════════╣
║  Spent: 1 AP + 2 Lore Insight (8/10 remaining)                 ║
║                                                                 ║
║  Result: EXACT MATCH FOUND                                     ║
║  Original Location: Svartalfheim - Bright Halls                ║
║  Solution: "Align gears to match pattern: top-right, " +       ║
║           "bottom-left, center-top"                            ║
║                                                                 ║
║  You immediately know the solution!                            ║
║  Mechanism solved without check required.                      ║
║                                                                 ║
║  OR                                                             ║
║                                                                 ║
║  Result: SIMILAR PATTERN DETECTED                              ║
║  Original Location: Dvergr Forges - Maintenance Level          ║
║  Hint: Similar gear-based puzzle                               ║
║  DC Reduced: 14 → 9                                            ║
║  Make a check at reduced difficulty.                           ║
╚════════════════════════════════════════════════════════════════╝
```

---

## 7. Exploit Weakness Ability Specification

### 7.1 Ability Profile

| Property | Value |
|----------|-------|
| **Ability ID** | `exploit-weakness` |
| **Type** | Active |
| **AP Cost** | 2 AP |
| **Lore Insight Cost** | 3 |
| **Duration** | Until end of combat |
| **Tier** | 2 |
| **PP Cost** | 4 PP to unlock |
| **Prerequisites** | 8 PP in Jötun-Reader tree |

### 7.2 Weakness Analysis System

```csharp
/// <summary>
/// Analysis of an enemy's vulnerabilities and weaknesses.
/// </summary>
[ValueObject]
public sealed record WeaknessAnalysis
{
    /// <summary>Unique identifier for this analysis.</summary>
    public Guid AnalysisId { get; init; }

    /// <summary>ID of the analyzed enemy.</summary>
    public Guid TargetId { get; init; }

    /// <summary>Name of the enemy.</summary>
    public string TargetName { get; init; } = string.Empty;

    /// <summary>Types the enemy is vulnerable to (takes extra damage).</summary>
    public IReadOnlyList<DamageType> Vulnerabilities { get; init; } = new List<DamageType>();

    /// <summary>Types the enemy resists (takes reduced damage).</summary>
    public IReadOnlyList<DamageType> Resistances { get; init; } = new List<DamageType>();

    /// <summary>Types the enemy is immune to (takes no damage).</summary>
    public IReadOnlyList<DamageType> Immunities { get; init; } = new List<DamageType>();

    /// <summary>Specific weak points on the enemy body.</summary>
    public IReadOnlyList<WeakPoint> WeakPoints { get; init; } = new List<WeakPoint>();

    /// <summary>Observed behavioral patterns.</summary>
    public IReadOnlyList<string> BehavioralPatterns { get; init; } = new List<string>();

    /// <summary>When the analysis was performed.</summary>
    public DateTime AnalyzedAt { get; init; }

    /// <summary>When the analysis expires (end of combat).</summary>
    public DateTime? ExpiresAt { get; init; }

    /// <summary>
    /// Creates a new weakness analysis.
    /// </summary>
    public static WeaknessAnalysis Create(
        Guid targetId,
        string targetName,
        IEnumerable<DamageType> vulnerabilities,
        IEnumerable<DamageType> resistances,
        IEnumerable<DamageType> immunities,
        IEnumerable<WeakPoint> weakPoints,
        IEnumerable<string> behaviors,
        DateTime? expiresAt = null)
    {
        return new WeaknessAnalysis
        {
            AnalysisId = Guid.NewGuid(),
            TargetId = targetId,
            TargetName = targetName,
            Vulnerabilities = vulnerabilities.ToList().AsReadOnly(),
            Resistances = resistances.ToList().AsReadOnly(),
            Immunities = immunities.ToList().AsReadOnly(),
            WeakPoints = weakPoints.ToList().AsReadOnly(),
            BehavioralPatterns = behaviors.ToList().AsReadOnly(),
            AnalyzedAt = DateTime.UtcNow,
            ExpiresAt = expiresAt
        };
    }

    /// <summary>
    /// Determines if the enemy is vulnerable to a damage type.
    /// </summary>
    public bool IsVulnerableTo(DamageType type) => Vulnerabilities.Contains(type);

    /// <summary>
    /// Gets hit bonus for attacking a weak point.
    /// </summary>
    public int GetWeakPointBonus(string location)
    {
        var weakPoint = WeakPoints.FirstOrDefault(wp =>
            wp.Location.Equals(location, StringComparison.OrdinalIgnoreCase));
        return weakPoint?.HitBonus ?? 0;
    }

    /// <summary>
    /// Formats the analysis for display.
    /// </summary>
    public string GetFormattedReport()
    {
        var sb = new StringBuilder();
        sb.AppendLine($"═══ {TargetName} Analysis ═══");

        if (Vulnerabilities.Count > 0)
        {
            sb.AppendLine("Vulnerabilities: " + string.Join(", ", Vulnerabilities));
        }

        if (Resistances.Count > 0)
        {
            sb.AppendLine("Resistances: " + string.Join(", ", Resistances));
        }

        if (Immunities.Count > 0)
        {
            sb.AppendLine("Immunities: " + string.Join(", ", Immunities));
        }

        if (WeakPoints.Count > 0)
        {
            sb.AppendLine("Weak Points:");
            foreach (var point in WeakPoints)
            {
                sb.AppendLine($"  • {point.Location} (+{point.HitBonus} to hit)");
            }
        }

        return sb.ToString();
    }
}

/// <summary>
/// A specific weak point on an enemy.
/// </summary>
[ValueObject]
public sealed record WeakPoint
{
    /// <summary>Name of the weak point location.</summary>
    public string Location { get; init; } = string.Empty;

    /// <summary>Bonus to hit this location.</summary>
    public int HitBonus { get; init; } = 2;

    /// <summary>Description of why this is vulnerable.</summary>
    public string Description { get; init; } = string.Empty;
}

/// <summary>
/// Damage types for vulnerability analysis.
/// </summary>
public enum DamageType
{
    Slashing,
    Piercing,
    Blunt,
    Fire,
    Cold,
    Lightning,
    Poison,
    Necrotic,
    Radiant,
    Psychic
}
```

### 7.3 Weakness Analysis Service

```csharp
/// <summary>
/// Service for analyzing and tracking enemy weaknesses.
/// </summary>
public interface IWeaknessAnalysisService
{
    /// <summary>
    /// Analyzes an enemy target for weaknesses.
    /// </summary>
    Task<WeaknessAnalysis> AnalyzeEnemy(Guid characterId, Enemy target);

    /// <summary>
    /// Gets the active analysis for an enemy in combat.
    /// </summary>
    Task<WeaknessAnalysis?> GetActiveAnalysis(Guid enemyId, Guid combatInstanceId);

    /// <summary>
    /// Records that a weakness was exploited (for statistics).
    /// </summary>
    Task RecordWeaknessExploitation(Guid characterId, DamageType exploitedType);
}

/// <summary>
/// Implementation of weakness analysis service.
/// </summary>
public sealed class WeaknessAnalysisService : IWeaknessAnalysisService
{
    private readonly ICombatSystem _combatSystem;
    private readonly ILogger<WeaknessAnalysisService> _logger;

    public WeaknessAnalysisService(
        ICombatSystem combatSystem,
        ILogger<WeaknessAnalysisService> logger)
    {
        _combatSystem = combatSystem ?? throw new ArgumentNullException(nameof(combatSystem));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<WeaknessAnalysis> AnalyzeEnemy(Guid characterId, Enemy target)
    {
        // Gather weakness information from enemy definition
        var vulnerabilities = target.GetVulnerabilities();
        var resistances = target.GetResistances();
        var immunities = target.GetImmunities();
        var weakPoints = target.GetWeakPoints();
        var behaviors = target.GetBehavioralPatterns();

        // Determine when analysis expires (end of combat)
        var combatInstance = await _combatSystem.GetCurrentCombat();
        var expiresAt = combatInstance?.EstimatedEndTime ?? DateTime.UtcNow.AddMinutes(10);

        var analysis = WeaknessAnalysis.Create(
            target.Id,
            target.Name,
            vulnerabilities,
            resistances,
            immunities,
            weakPoints,
            behaviors,
            expiresAt);

        _logger.LogInformation(
            "Weakness Analysis: {Character} analyzed {Enemy} - " +
            "Found {Vulnerabilities} vulnerabilities, {WeakPoints} weak points",
            characterId, target.Name, vulnerabilities.Count, weakPoints.Count);

        return analysis;
    }

    public async Task<WeaknessAnalysis?> GetActiveAnalysis(Guid enemyId, Guid combatInstanceId)
    {
        var analysis = await _combatSystem.GetWeaknessAnalysis(enemyId, combatInstanceId);
        return analysis?.ExpiresAt > DateTime.UtcNow ? analysis : null;
    }

    public async Task RecordWeaknessExploitation(Guid characterId, DamageType exploitedType)
    {
        _logger.LogInformation(
            "Weakness Exploitation: {Character} exploited {DamageType} weakness",
            characterId, exploitedType);

        // Could track statistics here
        await Task.CompletedTask;
    }
}
```

### 7.4 Combat Integration

When an attack targets a revealed weakness:

```csharp
/// <summary>
/// Integration with combat system for weakness exploitation.
/// </summary>
public sealed class WeaknessExploitationBonus
{
    /// <summary>
    /// Calculates damage bonus for exploiting a weakness.
    /// </summary>
    public static int CalculateDamageBonus(
        DamageType attackType,
        WeaknessAnalysis? analysis)
    {
        if (analysis == null)
            return 0;

        if (analysis.IsVulnerableTo(attackType))
        {
            // Roll 1d6 for bonus damage
            return Roll1d6(); // Returns 1-6
        }

        return 0;
    }

    /// <summary>
    /// Calculates hit bonus for targeting a weak point.
    /// </summary>
    public static int CalculateHitBonus(
        string targetLocation,
        WeaknessAnalysis? analysis)
    {
        if (analysis == null)
            return 0;

        return analysis.GetWeakPointBonus(targetLocation);
    }

    private static int Roll1d6()
    {
        var random = new Random();
        return random.Next(1, 7);
    }
}
```

### 7.5 Exploit Weakness Usage

```
Command: > ability exploit-weakness <enemy>
Example: > ability exploit-weakness goblin-shaman

Output:
╔════════════════════════════════════════════════════════════════╗
║                 EXPLOIT WEAKNESS - ANALYSIS COMPLETE           ║
╠════════════════════════════════════════════════════════════════╣
║  Spent: 2 AP + 3 Lore Insight                                  ║
║  Total: 5/10 Lore Insight remaining                            ║
║                                                                 ║
║  Target: Goblin Shaman                                         ║
║                                                                 ║
║  Vulnerabilities:                                              ║
║  ✦ Fire damage (takes extra 1d6)                              ║
║  ✦ Psychic damage (takes extra 1d6)                           ║
║                                                                 ║
║  Resistances:                                                  ║
║  ⊘ Cold damage (takes half)                                   ║
║  ⊘ Poison damage (takes half)                                 ║
║                                                                 ║
║  Immunities:                                                   ║
║  ◊ Necrotic damage (takes none)                               ║
║                                                                 ║
║  Weak Points:                                                  ║
║  • Head (+2 to hit) - Exposed by thin skull                   ║
║  • Left arm (+2 to hit) - Scarred and weakened                ║
║                                                                 ║
║  Behavioral Pattern:                                           ║
║  "Frequently moves to cover after casting spells"             ║
║                                                                 ║
║  Analysis revealed to all allies in combat!                   ║
╚════════════════════════════════════════════════════════════════╝
```

---

## 8. Data Recovery Ability Specification

### 8.1 Ability Profile

| Property | Value |
|----------|-------|
| **Ability ID** | `data-recovery` |
| **Type** | Active |
| **AP Cost** | 3 AP |
| **Lore Insight Cost** | 2 |
| **Tier** | 2 |
| **PP Cost** | 4 PP to unlock |
| **Prerequisites** | 8 PP in Jötun-Reader tree |

### 8.2 Recovery System

```csharp
/// <summary>
/// Data recovered from a terminal.
/// </summary>
[ValueObject]
public sealed record RecoveredData
{
    /// <summary>Unique identifier for this recovery.</summary>
    public Guid RecoveryId { get; init; }

    /// <summary>ID of the terminal data came from.</summary>
    public Guid SourceTerminalId { get; init; }

    /// <summary>Name of the source terminal.</summary>
    public string SourceTerminalName { get; init; } = string.Empty;

    /// <summary>Individual data fragments recovered.</summary>
    public IReadOnlyList<string> DataFragments { get; init; } = new List<string>();

    /// <summary>Whether all data was successfully recovered.</summary>
    public bool IsComplete { get; init; }

    /// <summary>When the recovery was performed.</summary>
    public DateTime RecoveredAt { get; init; }

    /// <summary>
    /// Creates a new data recovery record.
    /// </summary>
    public static RecoveredData Create(
        Guid terminalId,
        string terminalName,
        IEnumerable<string> fragments,
        bool isComplete)
    {
        return new RecoveredData
        {
            RecoveryId = Guid.NewGuid(),
            SourceTerminalId = terminalId,
            SourceTerminalName = terminalName,
            DataFragments = fragments.ToList().AsReadOnly(),
            IsComplete = isComplete,
            RecoveredAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Gets the total number of fragments.
    /// </summary>
    public int GetFragmentCount() => DataFragments.Count;

    /// <summary>
    /// Estimates completion percentage.
    /// </summary>
    public int GetCompletionPercentage()
    {
        if (IsComplete)
            return 100;

        // Estimate based on fragment quality
        var avgQuality = DataFragments.Average(f => f.Length);
        return (int)Math.Min(avgQuality / 10, 95); // Cap at 95% for incomplete
    }

    /// <summary>
    /// Combines fragments into readable text.
    /// </summary>
    public string GetCombinedText()
    {
        return string.Join("\n[...]\n", DataFragments);
    }

    /// <summary>
    /// Formats recovery result for display.
    /// </summary>
    public string GetFormattedResult()
    {
        var sb = new StringBuilder();
        sb.AppendLine($"Terminal: {SourceTerminalName}");
        sb.AppendLine($"Fragments Recovered: {GetFragmentCount()}");
        sb.AppendLine($"Completion: {GetCompletionPercentage()}%");
        sb.AppendLine($"Status: {(IsComplete ? "COMPLETE" : "PARTIAL")}");
        sb.AppendLine();
        sb.AppendLine("Data:");
        sb.Append(GetCombinedText());
        return sb.ToString();
    }
}

/// <summary>
/// Terminal states for data recovery.
/// </summary>
public enum TerminalState
{
    Locked,      // DC 12
    Damaged,     // DC 14
    Corrupted,   // DC 16
    Fragmented,  // DC 18
    NearlyDestroyed // DC 20
}
```

### 8.3 Data Recovery Service

```csharp
/// <summary>
/// Service for data recovery from terminals.
/// </summary>
public interface IDataRecoveryService
{
    /// <summary>
    /// Attempts to recover data from a terminal.
    /// </summary>
    Task<RecoveredData> AttemptRecovery(
        Character character,
        Terminal terminal,
        int recoveryCheck);

    /// <summary>
    /// Gets the DC for recovering from a terminal in given state.
    /// </summary>
    int GetRecoveryDC(TerminalState state);
}

/// <summary>
/// Implementation of data recovery service.
/// </summary>
public sealed class DataRecoveryService : IDataRecoveryService
{
    private readonly ITerminalSystem _terminalSystem;
    private readonly ILoreInsightService _loreInsightService;
    private readonly ILogger<DataRecoveryService> _logger;

    private static readonly Dictionary<TerminalState, int> RecoveryDCs = new()
    {
        { TerminalState.Locked, 12 },
        { TerminalState.Damaged, 14 },
        { TerminalState.Corrupted, 16 },
        { TerminalState.Fragmented, 18 },
        { TerminalState.NearlyDestroyed, 20 }
    };

    public DataRecoveryService(
        ITerminalSystem terminalSystem,
        ILoreInsightService loreInsightService,
        ILogger<DataRecoveryService> logger)
    {
        _terminalSystem = terminalSystem ?? throw new ArgumentNullException(nameof(terminalSystem));
        _loreInsightService = loreInsightService ?? throw new ArgumentNullException(nameof(loreInsightService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<RecoveredData> AttemptRecovery(
        Character character,
        Terminal terminal,
        int recoveryCheck)
    {
        var baseDC = GetRecoveryDC(terminal.CurrentState);

        // Determine success and fragment count
        int fragmentCount = 0;
        bool isComplete = false;

        if (recoveryCheck >= baseDC)
        {
            // Success: recover 1d4 fragments
            fragmentCount = RollFragmentCount();

            // Critical success: full recovery
            if (recoveryCheck >= baseDC + 10)
            {
                isComplete = true;
                fragmentCount = RollFragmentCount() + 2; // Extra fragments

                // Generate bonus Lore Insight on critical success
                if (character.LoreInsight != null)
                {
                    character.LoreInsight.Generate(1);
                    _logger.LogInformation(
                        "Data Recovery: Critical success! +1 bonus Lore Insight");
                }
            }
        }
        else if (recoveryCheck >= baseDC - 5)
        {
            // Partial success: recover hint instead of data
            fragmentCount = 1;
        }

        // Gather data fragments
        var fragments = await ExtractDataFragments(terminal, fragmentCount);

        var recovery = RecoveredData.Create(
            terminal.Id,
            terminal.Name,
            fragments,
            isComplete);

        _logger.LogInformation(
            "Data Recovery: {Character} recovered {Fragments} fragments from {Terminal} - " +
            "{Status}",
            character.Name, fragmentCount, terminal.Name,
            isComplete ? "COMPLETE" : "PARTIAL");

        return recovery;
    }

    public int GetRecoveryDC(TerminalState state) =>
        RecoveryDCs.TryGetValue(state, out var dc) ? dc : 16;

    private int RollFragmentCount()
    {
        var random = new Random();
        return random.Next(1, 5); // 1d4
    }

    private async Task<IEnumerable<string>> ExtractDataFragments(
        Terminal terminal,
        int count)
    {
        var availableData = await _terminalSystem.GetRecoverableData(terminal.Id);
        var fragments = availableData.Take(count).ToList();

        return fragments;
    }
}
```

### 8.4 Data Recovery Usage

```
Command: > ability data-recovery <terminal>
Example: > ability data-recovery main-server

Output:
╔════════════════════════════════════════════════════════════════╗
║                    DATA RECOVERY - ATTEMPT                     ║
╠════════════════════════════════════════════════════════════════╣
║  Spent: 3 AP + 2 Lore Insight                                  ║
║  Total: 8/10 Lore Insight remaining                            ║
║                                                                 ║
║  Target: Main Server (Corrupted)                               ║
║  Base DC: 16                                                   ║
║  Your Check: 22 (Intelligence 16 + Tools 6) = SUCCESS           ║
║                                                                 ║
║  Recovered Data:                                               ║
║  • Fragment 1: "...administrative override codes...v2.14..."  ║
║  • Fragment 2: "...project name: SENTINEL. Status:..."        ║
║  • Fragment 3: "...dates recovered: 2156-03-15 to..."         ║
║  • Fragment 4: "...stored in vault section: Black Vault..."   ║
║                                                                 ║
║  Completion: 45%                                               ║
║  Status: PARTIAL RECOVERY                                      ║
║                                                                 ║
║  Note: Some data remains corrupted and cannot be recovered.   ║
║        Use fragments to piece together information.            ║
╚════════════════════════════════════════════════════════════════╝
```

---

## 9. Puzzle System Integration

Integrates with the game's puzzle system to record solutions for Technical Memory.

```csharp
/// <summary>
/// Integration with puzzle system for Technical Memory recording.
/// </summary>
public interface IPuzzleRecorder
{
    /// <summary>
    /// Records a puzzle solution when solved by character.
    /// </summary>
    Task RecordSolvedPuzzle(
        Guid characterId,
        PuzzleInstance puzzle,
        string solution);
}

/// <summary>
/// Records puzzle solutions for Technical Memory ability.
/// </summary>
public sealed class PuzzleRecorder : IPuzzleRecorder
{
    private readonly ITechnicalMemoryService _technicalMemoryService;
    private readonly ILogger<PuzzleRecorder> _logger;

    public PuzzleRecorder(
        ITechnicalMemoryService technicalMemoryService,
        ILogger<PuzzleRecorder> logger)
    {
        _technicalMemoryService = technicalMemoryService;
        _logger = logger;
    }

    public async Task RecordSolvedPuzzle(
        Guid characterId,
        PuzzleInstance puzzle,
        string solution)
    {
        // Only record for Jötun-Reader characters
        var character = await GetCharacter(characterId);
        if (character?.Specialization?.SpecializationId != "jotun-reader")
            return;

        await _technicalMemoryService.RecordPuzzleSolution(
            characterId,
            puzzle.Category,
            puzzle.Description,
            solution,
            puzzle.LocationId,
            puzzle.LocationName,
            puzzle.DC);

        _logger.LogInformation(
            "Puzzle Solution Recorded: {Character} solved {Category} puzzle in {Location}",
            character.Name, puzzle.Category, puzzle.LocationName);
    }

    private async Task<Character?> GetCharacter(Guid characterId)
    {
        // Implementation would fetch character from database
        return await Task.FromResult<Character?>(null);
    }
}
```

---

## 10. Combat Integration

See sections 7.4 and vulnerability analysis for combat integration details.

---

## 11. Terminal Security System

Data Recovery integrates with terminal access system:

```csharp
/// <summary>
/// Terminal security bypass using Lore Insight.
/// </summary>
public interface ITerminalSecurityBypass
{
    /// <summary>
    /// Attempts to bypass terminal security using knowledge.
    /// </summary>
    Task<bool> BypassSecurityWithKnowledge(
        Terminal terminal,
        Character character,
        int recoveryCheck);
}
```

---

## 12. Prerequisite Validation

[See section 5.1 for full implementation]

---

## 13. Configuration Files

### 13.1 specializations.json - Tier 2

```json
{
  "tier": 2,
  "ppRequirement": 8,
  "abilityCost": 4,
  "abilities": [
    "technical-memory",
    "exploit-weakness",
    "data-recovery"
  ]
}
```

### 13.2 abilities.json - Tier 2 Abilities

```json
{
  "abilityId": "technical-memory",
  "displayName": "Technical Memory",
  "tierLevel": 2,
  "type": "Active",
  "apCost": 1,
  "resourceCost": { "resourceId": "lore-insight", "amount": 2 },
  "description": "Recall the solution to a puzzle similar to one you've previously solved, providing the exact solution or reducing DC by 5.",
  "effects": [
    { "type": "RecallSolution", "dcReduction": 5 },
    { "type": "PuzzleMatching", "matchThreshold": 0.5 }
  ]
},
{
  "abilityId": "exploit-weakness",
  "displayName": "Exploit Weakness",
  "tierLevel": 2,
  "type": "Active",
  "apCost": 2,
  "resourceCost": { "resourceId": "lore-insight", "amount": 3 },
  "duration": "Combat",
  "description": "Analyze an enemy to reveal vulnerabilities, resistances, and weak points. Attacks exploiting weaknesses deal +1d6 damage.",
  "effects": [
    { "type": "RevealVulnerabilities", "visibleToAllies": true },
    { "type": "WeaknessExploitBonus", "dice": "1d6" },
    { "type": "WeakPointBonus", "bonus": 2 }
  ]
},
{
  "abilityId": "data-recovery",
  "displayName": "Data Recovery",
  "tierLevel": 2,
  "type": "Active",
  "apCost": 3,
  "resourceCost": { "resourceId": "lore-insight", "amount": 2 },
  "description": "Extract information from damaged, corrupted, or locked terminals using your knowledge.",
  "effects": [
    { "type": "BypassSecurity", "method": "LoreInsight" },
    { "type": "RecoverFragments", "fragmentDice": "1d4" },
    { "type": "CriticalSuccessBonus", "bonus": 1 }
  ]
}
```

---

## 14. Code Examples and Implementation

[See sections 6.3, 7.3, 8.3 for detailed implementation]

---

## 15. Domain Models

[Detailed in sections 6.2, 7.2, 8.2]

---

## 16. Service Architecture

[Detailed in sections 6.3, 7.3, 8.3]

---

## 17. Vulnerability Analysis System

[Detailed in section 7.2-7.3]

---

## 18. Data Fragment System

Data Recovery returns fragments that can be reassembled or provide hints.

```csharp
/// <summary>
/// Fragment of recovered data.
/// </summary>
public sealed record DataFragment
{
    public int SequenceNumber { get; init; }
    public string Content { get; init; } = string.Empty;
    public double QualityScore { get; init; } // 0-1
}
```

---

## 19. Logging Specifications

```csharp
// Technical Memory
_logger.LogInformation(
    "Technical Memory: {Character} recalled puzzle - {Result} from {Location}",
    character.Name, result.IsExactMatch ? "Exact match" : "Similar pattern",
    result.OriginalLocation);

// Exploit Weakness
_logger.LogInformation(
    "Exploit Weakness: {Character} analyzed {Enemy} - " +
    "{VulnerabilityCount} vulnerabilities, {WeakPointCount} weak points",
    character.Name, enemy.Name, analysis.Vulnerabilities.Count,
    analysis.WeakPoints.Count);

// Data Recovery
_logger.LogInformation(
    "Data Recovery: {Character} recovered {FragmentCount} fragments from {Terminal} - {Status}",
    character.Name, recoveredData.GetFragmentCount(), terminal.Name,
    recoveredData.IsComplete ? "COMPLETE" : "PARTIAL");
```

---

## 20. Unit Testing Requirements

### 20.1 TechnicalMemoryTests (~3 tests)

```csharp
[TestFixture]
public class TechnicalMemoryTests
{
    [Test]
    public void RecallPuzzle_ExactMatch_ProvidesSolution();

    [Test]
    public void RecallPuzzle_SimilarPattern_ReducesDC();

    [Test]
    public void RecallPuzzle_NoMatch_ReturnsNotFound();
}
```

### 20.2 ExploitWeaknessTests (~3 tests)

```csharp
[TestFixture]
public class ExploitWeaknessTests
{
    [Test]
    public void AnalyzeEnemy_RevealsVulnerabilities();

    [Test]
    public void ExploitBonus_GrantsDamageBonus_WhenTargetingWeakness();

    [Test]
    public void WeakPointBonus_GrantsHitBonus();
}
```

### 20.3 DataRecoveryTests (~2 tests)

```csharp
[TestFixture]
public class DataRecoveryTests
{
    [Test]
    public void RecoverData_Success_RecoversFragments();

    [Test]
    public void RecoverData_CriticalSuccess_GeneratesBonusInsight();
}
```

---

## 21. Deliverable Checklist

### Domain Layer
- [ ] TechnicalMemoryRecord value object
- [ ] WeaknessAnalysis value object
- [ ] WeakPoint value object
- [ ] RecoveredData value object
- [ ] VulnerabilityType enum
- [ ] TerminalState enum
- [ ] DamageType enum

### Application Layer
- [ ] Tier2PrerequisiteValidator
- [ ] TechnicalMemoryService
- [ ] WeaknessAnalysisService
- [ ] DataRecoveryService
- [ ] PuzzleRecorder integration
- [ ] WeaknessExploitationBonus calculation

### Infrastructure Layer
- [ ] specializations.json Tier 2 update
- [ ] abilities.json Tier 2 abilities

### Tests
- [ ] TechnicalMemoryTests.cs (~3 tests)
- [ ] ExploitWeaknessTests.cs (~3 tests)
- [ ] DataRecoveryTests.cs (~2 tests)

---

## 22. Acceptance Criteria

- [x] Tier 2 abilities locked until 8 PP invested
- [x] Each Tier 2 ability costs 4 PP to unlock
- [x] Technical Memory recalls puzzle solutions
- [x] Exploit Weakness reveals enemy weaknesses to all allies
- [x] Exploit Weakness grants +1d6 damage when targeting weaknesses
- [x] Data Recovery extracts information from damaged terminals
- [x] Data Recovery bypasses security with Lore Insight
- [x] ~8 unit tests pass

---

_This design specification v0.20.3b defines the Tier 2 abilities for Jötun-Reader, providing mid-game progression and tactical gameplay options._
