# v0.6.3b Design Specification: Tab Completion

**Version:** 0.6.3b
**Parent:** v0.6.3 (Input Enhancements)
**Prerequisites:** v0.6.3a Complete (Command History)
**Status:** Design Complete

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ITabCompletionService Interface](#4-itabcompletionservice-interface)
5. [Completion Sources](#5-completion-sources)
6. [CompletionPopup Component](#6-completionpopup-component)
7. [Data Model](#7-data-model)
8. [Configuration](#8-configuration)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Use Cases](#11-use-cases)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Dependencies](#14-dependencies)
15. [Future Considerations](#15-future-considerations)

---

## 1. Executive Summary

### Purpose

The Tab Completion system provides intelligent auto-completion for user input. When the player presses Tab, the system completes partial commands, item names, target names, and directions. Single matches complete inline; multiple matches display a popup for selection. Completion is context-aware, offering targets for attack commands and items for use commands.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | ITabCompletionService, ICompletionSource |
| **Services** | TabCompletionService |
| **Sources** | CommandCompletionSource, ItemCompletionSource, TargetCompletionSource, DirectionCompletionSource |
| **Components** | CompletionPopup |
| **Configuration** | input.json (tabCompletion section) |
| **Tests** | ~15 new unit tests |

### Architectural Significance

This version establishes the **Extensible Completion Pattern** for intelligent input assistance:
- Pluggable completion sources with priorities
- Context-aware completion based on command type
- Visual popup for multiple matches
- Case-insensitive matching

---

## 2. Feature Overview

```
v0.6.3b Features
├── ITabCompletionService Interface
│   ├── GetCompletions() - All matching completions
│   ├── GetBestCompletion() - Single best match
│   ├── RegisterSource() - Add completion source
│   └── UnregisterSource() - Remove completion source
├── ICompletionSource Interface
│   ├── Category property
│   ├── Priority property
│   ├── AppliesTo() - Context check
│   └── GetMatches() - Get matching items
├── Completion Sources
│   ├── CommandCompletionSource (commands)
│   ├── ItemCompletionSource (inventory items)
│   ├── TargetCompletionSource (valid targets)
│   └── DirectionCompletionSource (movement)
├── CompletionPopup Component
│   ├── Show() - Display suggestions
│   ├── Hide() - Close popup
│   ├── SelectPrevious() / SelectNext()
│   ├── GetSelected() - Current selection
│   └── Keyboard navigation
├── Completion Behavior
│   ├── Single match → complete inline
│   ├── Multiple matches → show popup
│   ├── Tab cycles through matches
│   ├── Enter accepts selection
│   ├── Escape cancels popup
│   └── Case-insensitive matching
└── Configuration
    ├── enabled setting
    ├── caseSensitive setting
    ├── maxSuggestions setting
    └── popup style settings
```

---

## 3. Architecture Diagrams

### 3.1 Tab Completion Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                  TAB COMPLETION ARCHITECTURE                         │
└─────────────────────────────────────────────────────────────────────┘

    Partial Input                Completion Service           Sources
    ─────────────                ──────────────────           ───────
    
    "att"  ──────────────────┐
           [TAB]             │   ┌─────────────────────────┐
                             └──▶│  TabCompletionService   │
                                 ├─────────────────────────┤
                                 │ GetCompletions(input)   │
                                 └───────────┬─────────────┘
                                             │
             ┌───────────────────────────────┼───────────────────────────────┐
             ▼                               ▼                               ▼
    ┌─────────────────┐           ┌─────────────────┐           ┌─────────────────┐
    │ CommandSource   │           │  ItemSource     │           │ TargetSource    │
    ├─────────────────┤           ├─────────────────┤           ├─────────────────┤
    │ Priority: 100   │           │ Priority: 90    │           │ Priority: 90    │
    │ AppliesTo: idx=0│           │ AppliesTo: use  │           │ AppliesTo: attack
    │                 │           │                 │           │                 │
    │ attack ✓        │           │ (not context)   │           │ (not context)   │
    └─────────────────┘           └─────────────────┘           └─────────────────┘
             │
             ▼
    Single match: "attack" ──────────────────────────────▶ Complete inline
    
    
    "attack sk"  ────────────┐
              [TAB]          │   ┌─────────────────────────┐
                             └──▶│  TabCompletionService   │
                                 │  Context: "attack"      │◄─ Knows we need target
                                 └───────────┬─────────────┘
                                             │
                                             ▼
                                  ┌─────────────────┐
                                  │ TargetSource    │
                                  ├─────────────────┤
                                  │ skeleton ✓      │
                                  │ goblin          │
                                  └─────────────────┘
                                             │
                                             ▼
    Single match: "attack skeleton" ─────────────────────▶ Complete inline
```

### 3.2 Completion Context Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    COMPLETION CONTEXT FLOW                           │
└─────────────────────────────────────────────────────────────────────┘

    Input: "attack sk"
              │
              ▼
    ┌───────────────────────────────────────────────────────────────┐
    │ 1. PARSE INPUT INTO CONTEXT                                    │
    ├───────────────────────────────────────────────────────────────┤
    │ FullInput: "attack sk"                                         │
    │ Words: ["attack", "sk"]                                        │
    │ CurrentWord: "sk"                                              │
    │ WordIndex: 1                                                   │
    │ CommandName: "attack"                                          │
    └───────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌───────────────────────────────────────────────────────────────┐
    │ 2. FIND APPLICABLE SOURCES                                     │
    ├───────────────────────────────────────────────────────────────┤
    │ FOR each source in _sources (sorted by Priority):              │
    │   IF source.AppliesTo(context):                               │
    │     matches.AddRange(source.GetMatches("sk", context))        │
    │                                                                │
    │ CommandSource: AppliesTo(idx=0)? NO (idx=1)                   │
    │ ItemSource: AppliesTo("attack")? NO                           │
    │ TargetSource: AppliesTo("attack")? YES → skeleton, goblin     │
    │ DirectionSource: AppliesTo("attack")? NO                      │
    └───────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌───────────────────────────────────────────────────────────────┐
    │ 3. FILTER BY PREFIX                                            │
    ├───────────────────────────────────────────────────────────────┤
    │ Prefix: "sk"                                                   │
    │ "skeleton".StartsWith("sk") → YES                              │
    │ "goblin".StartsWith("sk") → NO                                 │
    │                                                                │
    │ Filtered matches: ["skeleton"]                                 │
    └───────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌───────────────────────────────────────────────────────────────┐
    │ 4. DETERMINE ACTION                                            │
    ├───────────────────────────────────────────────────────────────┤
    │ matches.Count == 1:                                            │
    │   → Complete inline: "attack skeleton"                         │
    │                                                                │
    │ matches.Count > 1:                                             │
    │   → Show CompletionPopup with options                         │
    │                                                                │
    │ matches.Count == 0:                                            │
    │   → No action (nothing matches)                               │
    └───────────────────────────────────────────────────────────────┘
```

### 3.3 Popup Display

```
┌─────────────────────────────────────────────────────────────────────┐
│                      COMPLETION POPUP DISPLAY                        │
└─────────────────────────────────────────────────────────────────────┘

    Single Match (inline completion):
    ┌─────────────────────────────────────────────────────┐
    │ > att[TAB]                                          │
    │ > attack_                   ← Completed inline      │
    └─────────────────────────────────────────────────────┘


    Multiple Matches (popup):
    ┌─────────────────────────────────────────────────────┐
    │ > a[TAB]                                            │
    │   ┌────────────────────┐                            │
    │   │ attack         ◄───│── Selected (highlighted)   │
    │   │ abilities          │                            │
    │   │ armor              │                            │
    │   └────────────────────┘                            │
    │ > a_                                                │
    └─────────────────────────────────────────────────────┘


    Popup Navigation:
    ┌─────────────────────────────────────────────────────┐
    │                                                     │
    │ [TAB]           → Cycle to next suggestion          │
    │ [Shift+TAB]     → Cycle to previous suggestion      │
    │ [↑/↓]           → Navigate popup                    │
    │ [Enter]         → Accept selected                   │
    │ [Escape]        → Cancel and close popup            │
    │ [Any character] → Close popup, insert character     │
    │                                                     │
    └─────────────────────────────────────────────────────┘


    Context-Aware Example:
    ┌─────────────────────────────────────────────────────┐
    │ Room contains: Skeleton, Goblin, Spider             │
    │                                                     │
    │ > attack [TAB]                                      │
    │   ┌────────────────────┐                            │
    │   │ skeleton       ◄───│                            │
    │   │ goblin             │                            │
    │   │ spider             │                            │
    │   └────────────────────┘                            │
    │                                                     │
    │ > use [TAB]                                         │
    │   ┌────────────────────┐                            │
    │   │ healing-potion ◄───│── Only inventory items     │
    │   │ mana-potion        │                            │
    │   │ torch              │                            │
    │   └────────────────────┘                            │
    └─────────────────────────────────────────────────────┘
```

---

## 4. ITabCompletionService Interface

### 4.1 ITabCompletionService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITabCompletionService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides tab completion for user input.
/// </summary>
public interface ITabCompletionService
{
    /// <summary>
    /// Gets all completions for partial input.
    /// </summary>
    /// <param name="partialInput">The full input line so far.</param>
    /// <param name="context">Context for completion (targets, items, etc.).</param>
    /// <returns>List of matching completions.</returns>
    IReadOnlyList<string> GetCompletions(string partialInput, CompletionContext context);
    
    /// <summary>
    /// Gets the best single completion, or null if multiple/none.
    /// </summary>
    /// <param name="partialInput">The full input line so far.</param>
    /// <param name="context">Context for completion.</param>
    /// <returns>Best completion, or null.</returns>
    string? GetBestCompletion(string partialInput, CompletionContext context);
    
    /// <summary>
    /// Completes the input if possible.
    /// </summary>
    /// <param name="partialInput">Current input.</param>
    /// <param name="context">Completion context.</param>
    /// <returns>Completed input, or original if no completion.</returns>
    string Complete(string partialInput, CompletionContext context);
    
    /// <summary>
    /// Registers a completion source.
    /// </summary>
    /// <param name="source">Source to register.</param>
    void RegisterSource(ICompletionSource source);
    
    /// <summary>
    /// Unregisters a completion source.
    /// </summary>
    /// <param name="source">Source to remove.</param>
    void UnregisterSource(ICompletionSource source);
    
    /// <summary>
    /// Gets all registered sources.
    /// </summary>
    IReadOnlyList<ICompletionSource> Sources { get; }
}
```

### 4.2 ICompletionSource Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ICompletionSource.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides completion candidates for a specific category.
/// </summary>
public interface ICompletionSource
{
    /// <summary>
    /// Gets the category this source provides (commands, items, targets, directions).
    /// </summary>
    string Category { get; }
    
    /// <summary>
    /// Gets the priority. Higher priority sources are checked first.
    /// </summary>
    int Priority { get; }
    
    /// <summary>
    /// Checks if this source applies to the current context.
    /// </summary>
    /// <param name="context">The completion context.</param>
    /// <returns>True if this source should provide completions.</returns>
    bool AppliesTo(CompletionContext context);
    
    /// <summary>
    /// Gets matching completions for a prefix.
    /// </summary>
    /// <param name="prefix">The text to match against.</param>
    /// <param name="context">The completion context.</param>
    /// <returns>Matching completion strings.</returns>
    IEnumerable<string> GetMatches(string prefix, CompletionContext context);
}
```

### 4.3 CompletionContext Record

**File:** `src/Core/RuneAndRust.Application/DTOs/CompletionContext.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Context information for tab completion.
/// </summary>
/// <param name="FullInput">The complete input text.</param>
/// <param name="CurrentWord">The word being completed.</param>
/// <param name="WordIndex">Index of current word (0 = command, 1+ = args).</param>
/// <param name="CommandName">The command name if known.</param>
/// <param name="AvailableTargets">Valid targets in current context.</param>
/// <param name="InventoryItems">Items the player has.</param>
/// <param name="AvailableExits">Available directions from current room.</param>
public record CompletionContext(
    string FullInput,
    string CurrentWord,
    int WordIndex,
    string? CommandName,
    IReadOnlyList<string>? AvailableTargets = null,
    IReadOnlyList<string>? InventoryItems = null,
    IReadOnlyList<string>? AvailableExits = null)
{
    /// <summary>
    /// Creates a context from an input string.
    /// </summary>
    public static CompletionContext FromInput(
        string input,
        IReadOnlyList<string>? targets = null,
        IReadOnlyList<string>? items = null,
        IReadOnlyList<string>? exits = null)
    {
        var words = input.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var currentWord = words.Length > 0 ? words[^1] : "";
        var commandName = words.Length > 0 ? words[0] : null;
        
        // If input ends with space, we're starting a new word
        var wordIndex = input.EndsWith(' ') ? words.Length : Math.Max(0, words.Length - 1);
        if (input.EndsWith(' ')) currentWord = "";
        
        return new CompletionContext(
            input,
            currentWord,
            wordIndex,
            wordIndex > 0 ? commandName : null,
            targets,
            items,
            exits);
    }
}
```

---

## 5. Completion Sources

### 5.1 TabCompletionService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/TabCompletionService.cs`

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Provides tab completion using registered sources.
/// </summary>
public class TabCompletionService : ITabCompletionService
{
    private readonly List<ICompletionSource> _sources = new();
    private readonly TabCompletionSettings _settings;
    private readonly ILogger<TabCompletionService> _logger;
    
    public IReadOnlyList<ICompletionSource> Sources => _sources.AsReadOnly();
    
    public TabCompletionService(
        IOptions<TabCompletionSettings> settings,
        ILogger<TabCompletionService> logger)
    {
        _settings = settings.Value;
        _logger = logger;
    }
    
    /// <inheritdoc />
    public IReadOnlyList<string> GetCompletions(string partialInput, CompletionContext context)
    {
        if (!_settings.Enabled) return Array.Empty<string>();
        
        var matches = new List<string>();
        var comparison = _settings.CaseSensitive 
            ? StringComparison.Ordinal 
            : StringComparison.OrdinalIgnoreCase;
        
        // Query sources in priority order
        foreach (var source in _sources.OrderByDescending(s => s.Priority))
        {
            if (source.AppliesTo(context))
            {
                var sourceMatches = source.GetMatches(context.CurrentWord, context)
                    .Where(m => m.StartsWith(context.CurrentWord, comparison))
                    .ToList();
                
                matches.AddRange(sourceMatches);
                
                _logger.LogDebug("Source '{Category}' provided {Count} matches", 
                    source.Category, sourceMatches.Count);
            }
        }
        
        // Limit and sort
        var result = matches
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(m => m)
            .Take(_settings.MaxSuggestions)
            .ToList();
        
        _logger.LogDebug("Tab completion for '{Input}': {Count} matches found", 
            context.CurrentWord, result.Count);
        
        return result;
    }
    
    /// <inheritdoc />
    public string? GetBestCompletion(string partialInput, CompletionContext context)
    {
        var matches = GetCompletions(partialInput, context);
        return matches.Count == 1 ? matches[0] : null;
    }
    
    /// <inheritdoc />
    public string Complete(string partialInput, CompletionContext context)
    {
        var best = GetBestCompletion(partialInput, context);
        if (best == null) return partialInput;
        
        // Replace the current word with the completion
        var words = partialInput.Split(' ').ToList();
        if (words.Count > 0 && context.WordIndex < words.Count)
        {
            words[context.WordIndex] = best;
        }
        else
        {
            words.Add(best);
        }
        
        return string.Join(" ", words);
    }
    
    /// <inheritdoc />
    public void RegisterSource(ICompletionSource source)
    {
        _sources.Add(source);
        _logger.LogDebug("Registered completion source: {Category} (Priority: {Priority})", 
            source.Category, source.Priority);
    }
    
    /// <inheritdoc />
    public void UnregisterSource(ICompletionSource source)
    {
        _sources.Remove(source);
        _logger.LogDebug("Unregistered completion source: {Category}", source.Category);
    }
}
```

### 5.2 CommandCompletionSource

**File:** `src/Core/RuneAndRust.Application/Services/Completion/CommandCompletionSource.cs`

```csharp
namespace RuneAndRust.Application.Services.Completion;

/// <summary>
/// Provides command name completions.
/// </summary>
public class CommandCompletionSource : ICompletionSource
{
    private readonly IReadOnlyList<string> _commands;
    
    public string Category => "commands";
    public int Priority => 100;  // Highest for first word
    
    public CommandCompletionSource(IEnumerable<string> availableCommands)
    {
        _commands = availableCommands.ToList();
    }
    
    public bool AppliesTo(CompletionContext context)
    {
        // Only complete commands at word index 0
        return context.WordIndex == 0;
    }
    
    public IEnumerable<string> GetMatches(string prefix, CompletionContext context)
    {
        return _commands
            .Where(c => c.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            .OrderBy(c => c);
    }
}
```

### 5.3 TargetCompletionSource

**File:** `src/Core/RuneAndRust.Application/Services/Completion/TargetCompletionSource.cs`

```csharp
namespace RuneAndRust.Application.Services.Completion;

/// <summary>
/// Provides target name completions for combat/interaction commands.
/// </summary>
public class TargetCompletionSource : ICompletionSource
{
    private static readonly HashSet<string> TargetCommands = new(StringComparer.OrdinalIgnoreCase)
    {
        "attack", "examine", "look", "talk", "interact", "target", "inspect"
    };
    
    public string Category => "targets";
    public int Priority => 90;
    
    public bool AppliesTo(CompletionContext context)
    {
        return context.WordIndex >= 1 && 
               context.CommandName != null &&
               TargetCommands.Contains(context.CommandName);
    }
    
    public IEnumerable<string> GetMatches(string prefix, CompletionContext context)
    {
        if (context.AvailableTargets == null)
            return Enumerable.Empty<string>();
        
        return context.AvailableTargets
            .Where(t => t.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            .OrderBy(t => t);
    }
}
```

### 5.4 ItemCompletionSource

**File:** `src/Core/RuneAndRust.Application/Services/Completion/ItemCompletionSource.cs`

```csharp
namespace RuneAndRust.Application.Services.Completion;

/// <summary>
/// Provides inventory item completions.
/// </summary>
public class ItemCompletionSource : ICompletionSource
{
    private static readonly HashSet<string> ItemCommands = new(StringComparer.OrdinalIgnoreCase)
    {
        "use", "equip", "unequip", "drop", "examine", "inspect"
    };
    
    public string Category => "items";
    public int Priority => 90;
    
    public bool AppliesTo(CompletionContext context)
    {
        return context.WordIndex >= 1 && 
               context.CommandName != null &&
               ItemCommands.Contains(context.CommandName);
    }
    
    public IEnumerable<string> GetMatches(string prefix, CompletionContext context)
    {
        if (context.InventoryItems == null)
            return Enumerable.Empty<string>();
        
        return context.InventoryItems
            .Where(i => i.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            .OrderBy(i => i);
    }
}
```

### 5.5 DirectionCompletionSource

**File:** `src/Core/RuneAndRust.Application/Services/Completion/DirectionCompletionSource.cs`

```csharp
namespace RuneAndRust.Application.Services.Completion;

/// <summary>
/// Provides direction completions for movement commands.
/// </summary>
public class DirectionCompletionSource : ICompletionSource
{
    private static readonly string[] AllDirections = 
        { "north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d" };
    
    private static readonly HashSet<string> MovementCommands = new(StringComparer.OrdinalIgnoreCase)
    {
        "go", "move", "walk", "run"
    };
    
    public string Category => "directions";
    public int Priority => 90;
    
    public bool AppliesTo(CompletionContext context)
    {
        return context.WordIndex >= 1 && 
               context.CommandName != null &&
               MovementCommands.Contains(context.CommandName);
    }
    
    public IEnumerable<string> GetMatches(string prefix, CompletionContext context)
    {
        // Prefer available exits, fall back to all directions
        var directions = context.AvailableExits?.ToArray() ?? AllDirections;
        
        return directions
            .Where(d => d.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            .OrderBy(d => d);
    }
}
```

---

## 6. CompletionPopup Component

### 6.1 CompletionPopup Class

**File:** `src/Presentation/RuneAndRust.TUI/UI/CompletionPopup.cs`

```csharp
namespace RuneAndRust.Presentation.UI;

/// <summary>
/// Displays completion suggestions as a popup.
/// </summary>
public class CompletionPopup
{
    private readonly ITerminalService _terminal;
    private readonly TabCompletionSettings _settings;
    private readonly ILogger<CompletionPopup> _logger;
    
    private int _selectedIndex = 0;
    private IReadOnlyList<string> _suggestions = Array.Empty<string>();
    private (int X, int Y) _position;
    private int _width;
    
    public bool IsVisible { get; private set; }
    public int SelectedIndex => _selectedIndex;
    
    public CompletionPopup(
        ITerminalService terminal,
        IOptions<TabCompletionSettings> settings,
        ILogger<CompletionPopup> logger)
    {
        _terminal = terminal;
        _settings = settings.Value;
        _logger = logger;
    }
    
    /// <summary>
    /// Shows the popup with suggestions.
    /// </summary>
    /// <param name="suggestions">List of completion suggestions.</param>
    /// <param name="inputX">X position of input cursor.</param>
    /// <param name="inputY">Y position of input line.</param>
    public void Show(IReadOnlyList<string> suggestions, int inputX, int inputY)
    {
        if (!_settings.ShowPopup || suggestions.Count <= 1)
        {
            return;
        }
        
        _suggestions = suggestions;
        _selectedIndex = 0;
        _position = (inputX, inputY + 1);
        _width = Math.Max(20, suggestions.Max(s => s.Length) + 4);
        
        IsVisible = true;
        Render();
        
        _logger.LogDebug("Completion popup shown with {Count} suggestions", 
            suggestions.Count);
    }
    
    /// <summary>
    /// Hides the popup.
    /// </summary>
    public void Hide()
    {
        if (!IsVisible) return;
        
        Clear();
        IsVisible = false;
        _suggestions = Array.Empty<string>();
        
        _logger.LogDebug("Completion popup hidden");
    }
    
    /// <summary>
    /// Moves selection to previous item.
    /// </summary>
    public void SelectPrevious()
    {
        if (_suggestions.Count == 0) return;
        
        _selectedIndex = (_selectedIndex - 1 + _suggestions.Count) % _suggestions.Count;
        Render();
    }
    
    /// <summary>
    /// Moves selection to next item.
    /// </summary>
    public void SelectNext()
    {
        if (_suggestions.Count == 0) return;
        
        _selectedIndex = (_selectedIndex + 1) % _suggestions.Count;
        Render();
    }
    
    /// <summary>
    /// Gets the currently selected suggestion.
    /// </summary>
    /// <returns>Selected suggestion, or null if none.</returns>
    public string? GetSelected()
    {
        if (_suggestions.Count == 0 || _selectedIndex < 0 || _selectedIndex >= _suggestions.Count)
            return null;
        
        return _suggestions[_selectedIndex];
    }
    
    private void Render()
    {
        var displayCount = Math.Min(_suggestions.Count, _settings.MaxSuggestions);
        
        // Top border
        _terminal.SetCursorPosition(_position.X, _position.Y);
        _terminal.Write("┌" + new string('─', _width - 2) + "┐");
        
        // Suggestions
        for (var i = 0; i < displayCount; i++)
        {
            _terminal.SetCursorPosition(_position.X, _position.Y + 1 + i);
            
            var suggestion = _suggestions[i];
            var isSelected = i == _selectedIndex;
            
            var paddedText = suggestion.PadRight(_width - 4);
            if (paddedText.Length > _width - 4)
                paddedText = paddedText[..(_width - 7)] + "...";
            
            if (isSelected)
            {
                WriteSelected($"│ {paddedText} │");
            }
            else
            {
                _terminal.Write($"│ {paddedText} │");
            }
        }
        
        // Bottom border
        _terminal.SetCursorPosition(_position.X, _position.Y + 1 + displayCount);
        _terminal.Write("└" + new string('─', _width - 2) + "┘");
    }
    
    private void Clear()
    {
        var displayCount = Math.Min(_suggestions.Count, _settings.MaxSuggestions);
        
        for (var i = 0; i <= displayCount + 1; i++)
        {
            _terminal.SetCursorPosition(_position.X, _position.Y + i);
            _terminal.Write(new string(' ', _width));
        }
    }
    
    private void WriteSelected(string text)
    {
        var prevBg = Console.BackgroundColor;
        var prevFg = Console.ForegroundColor;
        
        Console.BackgroundColor = _settings.PopupStyle.SelectedBackground;
        Console.ForegroundColor = _settings.PopupStyle.SelectedText;
        
        _terminal.Write(text);
        
        Console.BackgroundColor = prevBg;
        Console.ForegroundColor = prevFg;
    }
}
```

### 6.2 InputHandler Tab Integration

**Updates to:** `src/Presentation/RuneAndRust.TUI/Input/InputHandler.cs`

```csharp
// Add to InputHandler class
private readonly ITabCompletionService _completionService;
private readonly CompletionPopup _popup;

private void HandleTab()
{
    if (_popup.IsVisible)
    {
        // Cycle to next suggestion
        _popup.SelectNext();
        return;
    }
    
    var context = CompletionContext.FromInput(
        _currentInput,
        _gameState.GetAvailableTargets(),
        _gameState.GetInventoryItemNames(),
        _gameState.GetAvailableExits());
    
    var completions = _completionService.GetCompletions(_currentInput, context);
    
    if (completions.Count == 0)
    {
        // No completions
        return;
    }
    
    if (completions.Count == 1)
    {
        // Single match - complete inline
        var completed = _completionService.Complete(_currentInput, context);
        SetInput(completed + " ");
    }
    else
    {
        // Multiple matches - show popup
        _popup.Show(completions, _cursorPosition + 2, Console.CursorTop);
    }
}

private void HandleEnterWithPopup()
{
    if (_popup.IsVisible)
    {
        var selected = _popup.GetSelected();
        if (selected != null)
        {
            AcceptCompletion(selected);
        }
        _popup.Hide();
    }
    else
    {
        HandleEnter();
    }
}

private void AcceptCompletion(string completion)
{
    var context = CompletionContext.FromInput(_currentInput);
    var words = _currentInput.Split(' ').ToList();
    
    if (context.WordIndex < words.Count)
    {
        words[context.WordIndex] = completion;
    }
    else
    {
        words.Add(completion);
    }
    
    SetInput(string.Join(" ", words) + " ");
    _popup.Hide();
}
```

---

## 7. Data Model

### 7.1 New Interfaces

| Interface | Layer | Description |
|-----------|-------|-------------|
| `ITabCompletionService` | Application | Completion manager interface |
| `ICompletionSource` | Application | Completion source interface |

### 7.2 New Services

| Service | Layer | Description |
|---------|-------|-------------|
| `TabCompletionService` | Application | Completion implementation |

### 7.3 New Completion Sources

| Source | Layer | Description |
|--------|-------|-------------|
| `CommandCompletionSource` | Application | Command names |
| `TargetCompletionSource` | Application | Combat/interaction targets |
| `ItemCompletionSource` | Application | Inventory items |
| `DirectionCompletionSource` | Application | Movement directions |

### 7.4 New Records

| Record | Layer | Description |
|--------|-------|-------------|
| `CompletionContext` | Application | Context for completion |
| `TabCompletionSettings` | Application | Configuration options |
| `PopupStyleSettings` | Application | Popup appearance |

### 7.5 New Components

| Component | Layer | Description |
|-----------|-------|-------------|
| `CompletionPopup` | Presentation | Suggestion display popup |

---

## 8. Configuration

### 8.1 input.json (tabCompletion section)

**File:** `config/input.json`

```json
{
  "$schema": "./schemas/input.schema.json",
  "commandHistory": {
    "enabled": true,
    "maxEntries": 100,
    "excludeEmpty": true,
    "moveDuplicatesToFront": true
  },
  "tabCompletion": {
    "enabled": true,
    "caseSensitive": false,
    "showPopup": true,
    "maxSuggestions": 10,
    "popupStyle": {
      "backgroundColor": "DarkGray",
      "textColor": "White",
      "selectedBackground": "Blue",
      "selectedText": "White"
    },
    "triggerKey": "Tab",
    "cancelKey": "Escape",
    "acceptKey": "Enter"
  }
}
```

### 8.2 TabCompletionSettings Record

**File:** `src/Core/RuneAndRust.Application/Configuration/TabCompletionSettings.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Settings for tab completion behavior.
/// </summary>
public record TabCompletionSettings
{
    public bool Enabled { get; init; } = true;
    public bool CaseSensitive { get; init; } = false;
    public bool ShowPopup { get; init; } = true;
    public int MaxSuggestions { get; init; } = 10;
    public PopupStyleSettings PopupStyle { get; init; } = new();
}

/// <summary>
/// Settings for completion popup appearance.
/// </summary>
public record PopupStyleSettings
{
    public ConsoleColor BackgroundColor { get; init; } = ConsoleColor.DarkGray;
    public ConsoleColor TextColor { get; init; } = ConsoleColor.White;
    public ConsoleColor SelectedBackground { get; init; } = ConsoleColor.Blue;
    public ConsoleColor SelectedText { get; init; } = ConsoleColor.White;
}
```

---

## 9. Logging Specifications

### 9.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `TabCompletionService` | Debug | Query, matches, register |
| `CompletionPopup` | Debug | Show, hide |
| Completion Sources | Debug | Match counts |

### 9.2 Log Message Templates

```csharp
// TabCompletionService
_logger.LogDebug("Source '{Category}' provided {Count} matches", category, count);
_logger.LogDebug("Tab completion for '{Input}': {Count} matches found", input, count);
_logger.LogDebug("Registered completion source: {Category} (Priority: {Priority})", 
    category, priority);
_logger.LogDebug("Unregistered completion source: {Category}", category);

// CompletionPopup
_logger.LogDebug("Completion popup shown with {Count} suggestions", count);
_logger.LogDebug("Completion popup hidden");
```

---

## 10. Unit Testing Requirements

### 10.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| TabCompletionService | 4 |
| CommandCompletionSource | 2 |
| TargetCompletionSource | 2 |
| ItemCompletionSource | 2 |
| DirectionCompletionSource | 2 |
| CompletionPopup | 2 |
| CompletionContext | 1 |
| **Total** | **~15** |

### 10.2 Test Specifications

#### TabCompletionServiceTests.cs

```csharp
[TestFixture]
public class TabCompletionServiceTests
{
    [Test]
    public void GetCompletions_ReturnsMatchesFromSources();
    
    [Test]
    public void GetBestCompletion_SingleMatch_ReturnsMatch();
    
    [Test]
    public void GetBestCompletion_MultipleMatches_ReturnsNull();
    
    [Test]
    public void RegisterSource_AddsToSources();
}
```

#### CommandCompletionSourceTests.cs

```csharp
[TestFixture]
public class CommandCompletionSourceTests
{
    [Test]
    public void AppliesTo_WordIndexZero_ReturnsTrue();
    
    [Test]
    public void GetMatches_ReturnsMatchingCommands();
}
```

#### TargetCompletionSourceTests.cs

```csharp
[TestFixture]
public class TargetCompletionSourceTests
{
    [Test]
    public void AppliesTo_AttackCommand_ReturnsTrue();
    
    [Test]
    public void GetMatches_ReturnsMatchingTargets();
}
```

#### CompletionPopupTests.cs

```csharp
[TestFixture]
public class CompletionPopupTests
{
    [Test]
    public void SelectNext_CyclesThroughSuggestions();
    
    [Test]
    public void GetSelected_ReturnsCurrentSelection();
}
```

---

## 11. Use Cases

### UC-001: Complete Command
**Actor:** Player
**Flow:** Type "att" → Press Tab → "attack" completed inline

### UC-002: Multiple Command Matches
**Actor:** Player
**Flow:** Type "a" → Press Tab → Popup shows attack, abilities, armor → Navigate and select

### UC-003: Complete Target
**Actor:** Player
**Flow:** Type "attack sk" → Press Tab → "attack skeleton" completed

### UC-004: Complete Item
**Actor:** Player
**Flow:** Type "use hea" → Press Tab → "use healing-potion" completed

### UC-005: Complete Direction
**Actor:** Player
**Flow:** Type "go n" → Press Tab → "go north" completed

### UC-006: Cancel Completion
**Actor:** Player
**Flow:** Popup visible → Press Escape → Popup closes → Input unchanged

---

## 12. Deliverable Checklist

### ITabCompletionService Interface
- [ ] `ITabCompletionService` interface created
- [ ] GetCompletions() method defined
- [ ] GetBestCompletion() method defined
- [ ] Complete() method defined
- [ ] RegisterSource() method defined
- [ ] UnregisterSource() method defined

### ICompletionSource Interface
- [ ] `ICompletionSource` interface created
- [ ] Category property defined
- [ ] Priority property defined
- [ ] AppliesTo() method defined
- [ ] GetMatches() method defined

### TabCompletionService Implementation
- [ ] `TabCompletionService` class created
- [ ] Source registration implemented
- [ ] Priority-based querying implemented
- [ ] Case-insensitive matching implemented

### Completion Sources
- [ ] `CommandCompletionSource` created
- [ ] `TargetCompletionSource` created
- [ ] `ItemCompletionSource` created
- [ ] `DirectionCompletionSource` created

### CompletionPopup Component
- [ ] `CompletionPopup` class created
- [ ] Show() method implemented
- [ ] Hide() method implemented
- [ ] SelectPrevious() / SelectNext() implemented
- [ ] GetSelected() implemented
- [ ] Render() with styling implemented

### Configuration
- [ ] `TabCompletionSettings` record created
- [ ] `PopupStyleSettings` record created
- [ ] `input.json` tabCompletion section added

### InputHandler Updates
- [ ] Tab key handling added
- [ ] Popup integration added
- [ ] Completion acceptance logic

### Testing
- [ ] ~15 unit tests implemented
- [ ] All tests passing

---

## 13. Acceptance Criteria

### Functional
- [ ] Tab completes partial commands
- [ ] Single match completes inline
- [ ] Multiple matches show popup
- [ ] Popup displays up to maxSuggestions items
- [ ] Arrow keys navigate popup
- [ ] Tab cycles through popup suggestions
- [ ] Enter accepts selected completion
- [ ] Escape cancels popup
- [ ] Completion is case-insensitive by default
- [ ] Context-aware: attack → targets
- [ ] Context-aware: use → inventory items
- [ ] Context-aware: go → directions
- [ ] Typing while popup visible closes popup
- [ ] Source priority respected
- [ ] Completion can be disabled

### Quality
- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~15 unit tests pass
- [ ] XML documentation complete on all public members

---

## 14. Dependencies

### Required from v0.6.3a

| Type | Location | Usage |
|------|----------|-------|
| `InputHandler` | `Presentation/Input/InputHandler.cs` | Tab key handling |
| Input enhancement pattern | - | Similar structure |

### Required from Prior Versions

| Type | Location | Usage |
|------|----------|-------|
| `ITerminalService` | `Application/Interfaces/ITerminalService.cs` | Console ops |
| Game state | Various | Targets, items, exits |

### Provides to Future

| Type | Usage |
|------|-------|
| `ITabCompletionService` | Extensible for new sources |
| Completion pattern | Reusable for other inputs |

---

## 15. Future Considerations

### Deferred to Future
- **Fuzzy Matching**: Match "hlpot" to "healing-potion"
- **History Completion**: Complete from command history
- **Custom Sources**: Player-defined abbreviations
- **Learning**: Prioritize frequently used completions

### Out of Scope
- **Natural Language**: Sentence-level completion
- **AI Suggestions**: Predictive input

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: Assistant*
