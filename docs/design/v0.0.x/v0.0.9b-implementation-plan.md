# v0.0.9b Implementation Plan: Damage Types & Resistances

**Version:** 0.0.9b
**Parent:** v0.0.9 (Monster Variety & Loot)
**Prerequisites:** v0.0.9a Complete (Monster Definitions)
**Design Specification:** [v0.0.9b-design-specification.md](v0.0.9b-design-specification.md)
**Status:** Ready for Implementation
**Target Tests:** ~317 -> ~332 (+15 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Infrastructure Layer](#infrastructure-layer)
   - [Presentation Layer](#presentation-layer)
5. [Configuration](#configuration)
6. [Flow Diagrams](#flow-diagrams)
7. [Testing Strategy](#testing-strategy)
8. [Logging Strategy](#logging-strategy)
9. [Implementation Checklist](#implementation-checklist)
10. [Acceptance Criteria](#acceptance-criteria)
11. [Risk Assessment](#risk-assessment)
12. [File Summary](#file-summary)
13. [Provides to Future Phases](#provides-to-future-phases)

---

## Executive Summary

### Purpose

This phase formalizes the damage system by introducing configurable `DamageTypeDefinition`s (e.g., Fire, Ice, Physical) and a resistance mechanics system via `DamageResistances`. We will implement a `DamageCalculationService` that calculates final damage based on the attacker's damage type and the defender's resistances/vulnerabilities. This adds strategic depth to combat, encouraging players to exploit monster weaknesses.

### Scope

- **In Scope:**
  - `DamageTypeDefinition` entity loaded from `config/damage-types.json`.
  - `DamageResistances` value object for handling percentage-based modifiers (-100% to +100%).
  - `DamageInstance` value object for damage calculation results.
  - `DamageCalculationService` to centralize damage logic.
  - Integration with `MonsterDefinition` and `Monster` to give creatures resistances.
  - Updates to `Player` entity to support future resistance features.
  - Combat output updates to display effectiveness (e.g., "Vulnerable!", "Resisted").

- **Out of Scope:**
  - Weapon damage types (reserved for future).
  - Status effect damage (e.g., Poison DoT mechanics).
  - Equipment-based resistances (future).
  - Monster Tiers (v0.0.9c).

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **Resistance Math** | Percentage (-100 to +100) | Intuitive modifiers: 50 = 50% less damage, -50 = 50% more damage. |
| **Calculation Service** | Dedicated Service | Centralizes math logic, making it easy to test and extend without cluttering entities. |
| **Default Type** | "Physical" | Ensures backward compatibility for existing attacks that don't specify a type. |
| **Resistance Clamping** | -100 to +100 range | Prevents exploits, keeps math predictable (0x to 2x damage). |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.9a (Monster Definitions)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `MonsterDefinition` | `src/Core/RuneAndRust.Domain/Definitions/MonsterDefinition.cs` | Updated to include `BaseResistances`. |
| `Monster` | `src/Core/RuneAndRust.Domain/Entities/Monster.cs` | Updated to store runtime `Resistances`. |
| `IMonsterService` | `src/Core/RuneAndRust.Application/Interfaces/IMonsterService.cs` | Updated to populate resistances on spawn. |
| `MonsterService` | `src/Core/RuneAndRust.Application/Services/MonsterService.cs` | Updated to copy resistances during creation. |

### Dependencies from v0.0.8 (Experience & Leveling)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Player` | `src/Core/RuneAndRust.Domain/Entities/Player.cs` | Extended with `Resistances` property. |
| `CombatService` | `src/Core/RuneAndRust.Domain/Services/CombatService.cs` | Updated to use `DamageCalculationService`. |

---

## Current System Analysis

### Existing Damage Calculation

**Location:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs`

**Current Flow:**
```
CombatService.ResolveCombatRound(player, monster)
    ‚îú‚îÄ‚îÄ Calculate player damage = Player.Stats.Attack
    ‚îú‚îÄ‚îÄ Calculate monster defense = Monster.Stats.Defense
    ‚îú‚îÄ‚îÄ Apply damage = Attack - Defense
    ‚îî‚îÄ‚îÄ Return CombatResult
```

**Current Types:**
```csharp
// Damage is a simple integer subtraction
var damage = Math.Max(0, attacker.Attack - defender.Defense);
```

### New Damage Flow

```
CombatService.ResolveCombatRound(player, monster)
    ‚îú‚îÄ‚îÄ Calculate base damage = Player.Stats.Attack - Monster.Stats.Defense
    ‚îú‚îÄ‚îÄ DamageCalculationService.CalculateDamage(baseDamage, "physical", monster.Resistances)
    ‚îÇ   ‚îú‚îÄ‚îÄ Lookup resistance for damage type
    ‚îÇ   ‚îú‚îÄ‚îÄ Calculate multiplier (1.0 - resistance/100)
    ‚îÇ   ‚îú‚îÄ‚îÄ Apply multiplier to base damage
    ‚îÇ   ‚îî‚îÄ‚îÄ Return DamageInstance
    ‚îú‚îÄ‚îÄ Apply final damage to monster
    ‚îî‚îÄ‚îÄ Return CombatResult with DamageInstance details
```

---

## Detailed Implementation

### Domain Layer

#### 1. DamageTypeDefinition.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Definitions/DamageTypeDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a type of damage that can be dealt in combat.
/// </summary>
/// <remarks>
/// <para>Damage types are loaded from configuration and determine how
/// attacks interact with monster resistances and vulnerabilities.</para>
/// <para>The default damage type is "physical" for backward compatibility.</para>
/// </remarks>
public class DamageTypeDefinition
{
    /// <summary>
    /// Gets the unique identifier for this damage type.
    /// </summary>
    /// <example>"physical", "fire", "ice", "lightning"</example>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name of this damage type.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the description shown to players.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the color used for displaying this damage type.
    /// </summary>
    /// <remarks>
    /// Should be a valid Spectre.Console color name.
    /// </remarks>
    public string Color { get; init; } = "white";

    /// <summary>
    /// Gets the optional icon/emoji for this damage type.
    /// </summary>
    public string? Icon { get; init; }

    /// <summary>
    /// Gets the display sort order.
    /// </summary>
    public int SortOrder { get; init; } = 0;

    /// <summary>
    /// Creates a validated DamageTypeDefinition.
    /// </summary>
    /// <param name="id">The unique identifier.</param>
    /// <param name="name">The display name.</param>
    /// <param name="description">The description.</param>
    /// <param name="color">The Spectre.Console color name.</param>
    /// <param name="icon">Optional icon/emoji.</param>
    /// <param name="sortOrder">Display sort order.</param>
    /// <returns>A new DamageTypeDefinition.</returns>
    /// <exception cref="ArgumentException">Thrown when id or name is null/whitespace.</exception>
    public static DamageTypeDefinition Create(
        string id,
        string name,
        string description,
        string color = "white",
        string? icon = null,
        int sortOrder = 0)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new DamageTypeDefinition
        {
            Id = id.ToLowerInvariant(),
            Name = name,
            Description = description,
            Color = color,
            Icon = icon,
            SortOrder = sortOrder
        };
    }

    /// <summary>
    /// Gets the default Physical damage type.
    /// </summary>
    public static DamageTypeDefinition Physical => Create(
        "physical", "Physical", "Standard physical damage.", "white", "‚öîÔ∏è", 0);
}
```

#### 2. DamageResistances.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DamageResistances.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a set of damage type resistances for an entity.
/// </summary>
/// <remarks>
/// <para>Resistances are stored as percentages from -100 to +100:</para>
/// <list type="bullet">
/// <item>+100 = Immune (0% damage taken)</item>
/// <item>+50 = Resistant (50% damage taken)</item>
/// <item>0 = Normal (100% damage taken)</item>
/// <item>-50 = Vulnerable (150% damage taken)</item>
/// <item>-100 = Extremely Vulnerable (200% damage taken)</item>
/// </list>
/// </remarks>
public readonly record struct DamageResistances
{
    private readonly Dictionary<string, int>? _resistances;

    /// <summary>
    /// Gets the resistance values as a read-only dictionary.
    /// </summary>
    public IReadOnlyDictionary<string, int> Values => 
        _resistances ?? new Dictionary<string, int>();

    /// <summary>
    /// Gets an empty resistance set (no resistances or vulnerabilities).
    /// </summary>
    public static DamageResistances None => new();

    /// <summary>
    /// Creates a new DamageResistances from a dictionary.
    /// </summary>
    /// <param name="resistances">Dictionary of damage type ID to resistance percentage.</param>
    /// <remarks>
    /// Values are automatically clamped to the -100 to +100 range.
    /// Keys are normalized to lowercase.
    /// </remarks>
    public DamageResistances(IReadOnlyDictionary<string, int>? resistances = null)
    {
        if (resistances == null || resistances.Count == 0)
        {
            _resistances = null;
        }
        else
        {
            _resistances = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            foreach (var kvp in resistances)
            {
                _resistances[kvp.Key.ToLowerInvariant()] = Math.Clamp(kvp.Value, -100, 100);
            }
        }
    }

    /// <summary>
    /// Gets the resistance percentage for a specific damage type.
    /// </summary>
    /// <param name="damageTypeId">The damage type identifier.</param>
    /// <returns>The resistance percentage (-100 to +100), or 0 if not found.</returns>
    public int GetResistance(string damageTypeId)
    {
        if (string.IsNullOrWhiteSpace(damageTypeId) || _resistances == null) 
            return 0;
        return _resistances.TryGetValue(damageTypeId.ToLowerInvariant(), out var val) ? val : 0;
    }

    /// <summary>
    /// Gets the damage multiplier for a specific damage type.
    /// </summary>
    /// <param name="damageTypeId">The damage type identifier.</param>
    /// <returns>The multiplier (0.0 to 2.0, where 1.0 = normal damage).</returns>
    /// <example>
    /// +50 resistance = 0.5 multiplier (half damage)
    /// -50 resistance = 1.5 multiplier (50% extra damage)
    /// </example>
    public float GetMultiplier(string damageTypeId)
    {
        var resistance = GetResistance(damageTypeId);
        return 1.0f - (resistance / 100.0f);
    }

    /// <summary>
    /// Checks if the entity is vulnerable to a damage type.
    /// </summary>
    public bool IsVulnerable(string damageTypeId) => GetResistance(damageTypeId) < 0;

    /// <summary>
    /// Checks if the entity is resistant (but not immune) to a damage type.
    /// </summary>
    public bool IsResistant(string damageTypeId) => 
        GetResistance(damageTypeId) > 0 && GetResistance(damageTypeId) < 100;

    /// <summary>
    /// Checks if the entity is immune to a damage type.
    /// </summary>
    public bool IsImmune(string damageTypeId) => GetResistance(damageTypeId) >= 100;

    /// <summary>
    /// Combines this resistance set with another, taking the higher resistance for each type.
    /// </summary>
    /// <param name="other">The other resistance set to combine with.</param>
    /// <returns>A new DamageResistances with combined values.</returns>
    public DamageResistances CombineWith(DamageResistances other)
    {
        var combined = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        
        foreach (var kvp in Values) 
            combined[kvp.Key] = kvp.Value;
        
        foreach (var kvp in other.Values)
        {
            if (combined.TryGetValue(kvp.Key, out var existing))
                combined[kvp.Key] = Math.Max(existing, kvp.Value);
            else
                combined[kvp.Key] = kvp.Value;
        }
        
        return new DamageResistances(combined);
    }
}
```

#### 3. DamageInstance.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DamageInstance.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of a damage calculation including resistance effects.
/// </summary>
/// <param name="BaseDamage">The original damage before resistances.</param>
/// <param name="DamageTypeId">The type of damage dealt.</param>
/// <param name="FinalDamage">The damage after applying resistances.</param>
/// <param name="ResistanceApplied">The resistance percentage that was applied.</param>
/// <param name="WasResisted">True if damage was reduced by resistance.</param>
/// <param name="WasVulnerable">True if damage was increased by vulnerability.</param>
/// <param name="WasImmune">True if the target was immune.</param>
public readonly record struct DamageInstance(
    int BaseDamage,
    string DamageTypeId,
    int FinalDamage,
    int ResistanceApplied,
    bool WasResisted,
    bool WasVulnerable,
    bool WasImmune)
{
    /// <summary>
    /// Gets whether any resistance effect was applied.
    /// </summary>
    public bool HadResistanceEffect => WasResisted || WasVulnerable || WasImmune;

    /// <summary>
    /// Gets a human-readable description of the resistance effect.
    /// </summary>
    /// <returns>Description string, or empty if no effect.</returns>
    public string GetResistanceDescription()
    {
        if (WasImmune) return "Immune!";
        if (WasVulnerable) return $"Vulnerable! ({Math.Abs(ResistanceApplied)}% extra damage)";
        if (WasResisted) return $"Resisted ({ResistanceApplied}% reduced)";
        return string.Empty;
    }

    /// <summary>
    /// Creates a DamageInstance with no resistance effects.
    /// </summary>
    public static DamageInstance Normal(int damage, string damageTypeId) =>
        new(damage, damageTypeId, damage, 0, false, false, false);

    /// <summary>
    /// Creates a DamageInstance representing immunity.
    /// </summary>
    public static DamageInstance Immune(int baseDamage, string damageTypeId) =>
        new(baseDamage, damageTypeId, 0, 100, false, false, true);
}
```

#### 4. Update MonsterDefinition.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Definitions/MonsterDefinition.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

// Add to existing class:

/// <summary>
/// Gets the base damage resistances for this monster type.
/// </summary>
/// <remarks>
/// These resistances are copied to spawned Monster instances.
/// Can be modified by tiers or traits in v0.0.9c.
/// </remarks>
public DamageResistances BaseResistances { get; init; } = DamageResistances.None;

// Update Create method signature:
public static MonsterDefinition Create(
    string id,
    string name,
    string description,
    string examineText,
    int baseHealth,
    int baseAttack,
    int baseDefense,
    int baseExperienceValue,
    AIBehavior aiBehavior = AIBehavior.Aggressive,
    IEnumerable<string>? tags = null,
    int spawnWeight = 100,
    int sortOrder = 0,
    DamageResistances? baseResistances = null)  // NEW
{
    // ... existing validation ...

    return new MonsterDefinition
    {
        // ... existing properties ...
        BaseResistances = baseResistances ?? DamageResistances.None
    };
}
```

#### 5. Update Monster.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Monster.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

// Add to existing class:

/// <summary>
/// Gets the damage resistances for this monster instance.
/// </summary>
/// <remarks>
/// Copied from MonsterDefinition.BaseResistances on spawn.
/// May be modified by traits or temporary effects.
/// </remarks>
public DamageResistances Resistances { get; private set; } = DamageResistances.None;

// Update internal constructor:
internal Monster(
    string definitionId,
    string name,
    string description,
    int maxHealth,
    Stats stats,
    int experienceValue,
    DamageResistances resistances)  // NEW
{
    Id = Guid.NewGuid();
    DefinitionId = definitionId;
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Description = description ?? throw new ArgumentNullException(nameof(description));
    MaxHealth = maxHealth > 0 ? maxHealth : throw new ArgumentOutOfRangeException(nameof(maxHealth));
    Health = maxHealth;
    Stats = stats;
    ExperienceValue = experienceValue;
    Resistances = resistances;
}
```

#### 6. Update Player.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

// Add to existing class:

/// <summary>
/// Gets the player's damage resistances.
/// </summary>
/// <remarks>
/// Currently defaults to None. Will be populated by equipment
/// and class features in future versions.
/// </remarks>
public DamageResistances Resistances { get; private set; } = DamageResistances.None;

/// <summary>
/// Sets the player's damage resistances.
/// </summary>
/// <param name="resistances">The new resistance values.</param>
public void SetResistances(DamageResistances resistances)
{
    Resistances = resistances;
}
```

### Application Layer

#### 7. IDamageCalculationService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IDamageCalculationService.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for calculating damage with resistance effects.
/// </summary>
public interface IDamageCalculationService
{
    /// <summary>
    /// Calculates final damage after applying resistances.
    /// </summary>
    /// <param name="baseDamage">The raw damage before resistances.</param>
    /// <param name="damageTypeId">The type of damage being dealt.</param>
    /// <param name="targetResistances">The target's resistance values.</param>
    /// <returns>A DamageInstance with the calculation results.</returns>
    DamageInstance CalculateDamage(int baseDamage, string damageTypeId, DamageResistances targetResistances);

    /// <summary>
    /// Gets a human-readable description of a resistance value.
    /// </summary>
    string GetResistanceDescription(string damageTypeId, DamageResistances resistances);

    /// <summary>
    /// Gets a short label for a resistance value.
    /// </summary>
    string GetResistanceLabel(int resistance);
}
```

#### 8. DamageCalculationService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/DamageCalculationService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for calculating damage with resistance effects.
/// </summary>
/// <remarks>
/// This service centralizes all damage calculation logic, making it easy
/// to test and extend without modifying entity classes.
/// </remarks>
public class DamageCalculationService : IDamageCalculationService
{
    private readonly ILogger<DamageCalculationService> _logger;
    private readonly IGameConfigurationProvider _configProvider;

    /// <summary>
    /// The default damage type when none is specified.
    /// </summary>
    public const string DefaultDamageType = "physical";

    /// <summary>
    /// Creates a new DamageCalculationService.
    /// </summary>
    public DamageCalculationService(
        ILogger<DamageCalculationService> logger,
        IGameConfigurationProvider configProvider)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
    }

    /// <inheritdoc />
    public DamageInstance CalculateDamage(
        int baseDamage,
        string damageTypeId,
        DamageResistances targetResistances)
    {
        // Normalize damage type, default to physical
        var normalizedTypeId = string.IsNullOrWhiteSpace(damageTypeId) 
            ? DefaultDamageType 
            : damageTypeId.ToLowerInvariant();

        // Get resistance and calculate multiplier
        var resistance = targetResistances.GetResistance(normalizedTypeId);
        var multiplier = targetResistances.GetMultiplier(normalizedTypeId);

        // Calculate final damage (minimum 0)
        var finalDamage = (int)Math.Round(baseDamage * multiplier);
        finalDamage = Math.Max(0, finalDamage);

        // Determine resistance effect type
        var wasImmune = resistance >= 100;
        var wasResisted = resistance > 0 && resistance < 100;
        var wasVulnerable = resistance < 0;

        _logger.LogDebug(
            "Damage calculation: {BaseDamage} {DamageType} vs {Resistance}% = {FinalDamage} (Multiplier: {Multiplier})",
            baseDamage, normalizedTypeId, resistance, finalDamage, multiplier);

        return new DamageInstance(
            baseDamage,
            normalizedTypeId,
            finalDamage,
            resistance,
            wasResisted,
            wasVulnerable,
            wasImmune);
    }

    /// <inheritdoc />
    public string GetResistanceDescription(string damageTypeId, DamageResistances resistances)
    {
        var res = resistances.GetResistance(damageTypeId);
        if (res >= 100) return "Immune";
        if (res > 0) return $"Resistant ({res}% reduced)";
        if (res < 0) return $"Vulnerable ({Math.Abs(res)}% extra damage)";
        return string.Empty;
    }

    /// <inheritdoc />
    public string GetResistanceLabel(int resistance)
    {
        if (resistance >= 100) return "Immune";
        if (resistance >= 50) return "Resistant";
        if (resistance <= -50) return "Vulnerable";
        return string.Empty;
    }
}
```

#### 9. Update IConfigurationProvider.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs`

```csharp
// Add to existing interface:

/// <summary>
/// Gets all damage type definitions.
/// </summary>
IReadOnlyList<DamageTypeDefinition> GetDamageTypes();

/// <summary>
/// Gets a damage type definition by ID.
/// </summary>
DamageTypeDefinition? GetDamageTypeById(string damageTypeId);
```

#### 10. Update MonsterService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/MonsterService.cs`

```csharp
// Update CreateMonsterFromDefinition method:

private Monster CreateMonsterFromDefinition(MonsterDefinition definition)
{
    var stats = new Stats(definition.BaseHealth, definition.BaseAttack, definition.BaseDefense);
    return new Monster(
        definition.Id,
        definition.Name,
        definition.Description,
        definition.BaseHealth,
        stats,
        definition.BaseExperienceValue,
        definition.BaseResistances  // NEW - pass resistances
    );
}
```

### Infrastructure Layer

#### 11. DamageTypeConfigurationDto.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Configuration/DamageTypeConfigurationDto.cs`

```csharp
using System.Text.Json.Serialization;

namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration DTO for damage types JSON file.
/// </summary>
public class DamageTypeConfiguration
{
    [JsonPropertyName("damageTypes")]
    public List<DamageTypeDefinitionDto> DamageTypes { get; set; } = [];
}

/// <summary>
/// DTO for a single damage type definition.
/// </summary>
public class DamageTypeDefinitionDto
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;

    [JsonPropertyName("name")]
    public string Name { get; set; } = string.Empty;

    [JsonPropertyName("description")]
    public string Description { get; set; } = string.Empty;

    [JsonPropertyName("color")]
    public string Color { get; set; } = "white";

    [JsonPropertyName("icon")]
    public string? Icon { get; set; }

    [JsonPropertyName("sortOrder")]
    public int SortOrder { get; set; } = 0;
}
```

#### 12. Update JsonConfigurationProvider.cs (MODIFY)

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`

```csharp
private List<DamageTypeDefinition>? _damageTypes;

public IReadOnlyList<DamageTypeDefinition> GetDamageTypes()
{
    if (_damageTypes == null)
    {
        var config = LoadConfiguration<DamageTypeConfiguration>("damage-types.json");
        _damageTypes = config.DamageTypes.Select(MapToDamageTypeDefinition).ToList();
        _logger.LogInformation("Loaded {Count} damage type definitions", _damageTypes.Count);
    }
    return _damageTypes;
}

public DamageTypeDefinition? GetDamageTypeById(string damageTypeId)
{
    if (string.IsNullOrWhiteSpace(damageTypeId)) return null;
    return GetDamageTypes().FirstOrDefault(d => 
        d.Id.Equals(damageTypeId, StringComparison.OrdinalIgnoreCase));
}

private static DamageTypeDefinition MapToDamageTypeDefinition(DamageTypeDefinitionDto dto)
{
    return DamageTypeDefinition.Create(
        dto.Id, 
        dto.Name, 
        dto.Description, 
        dto.Color, 
        dto.Icon, 
        dto.SortOrder);
}

// Also update monster DTO parsing to include baseResistances:
private static MonsterDefinition MapToMonsterDefinition(MonsterDefinitionDto dto)
{
    Enum.TryParse<AIBehavior>(dto.AIBehavior, true, out var behavior);
    
    // Parse resistances from DTO
    DamageResistances resistances = DamageResistances.None;
    if (dto.BaseResistances != null && dto.BaseResistances.Count > 0)
    {
        resistances = new DamageResistances(dto.BaseResistances);
    }
    
    return MonsterDefinition.Create(
        dto.Id, dto.Name, dto.Description, dto.ExamineText,
        dto.BaseHealth, dto.BaseAttack, dto.BaseDefense, dto.BaseExperienceValue,
        behavior, dto.Tags, dto.SpawnWeight, dto.SortOrder,
        resistances);
}
```

### Presentation Layer

#### 13. Update GameSessionService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

```csharp
// Add dependency:
private readonly IDamageCalculationService _damageCalculationService;

// Update constructor:
public GameSessionService(
    // ... existing dependencies ...
    IDamageCalculationService damageCalculationService)
{
    // ... existing initialization ...
    _damageCalculationService = damageCalculationService;
}

// Update combat damage calculation:
private async Task HandleAttackResult(Player player, Monster monster, CancellationToken ct)
{
    // Calculate base damage
    var baseDamage = Math.Max(0, player.Stats.Attack - monster.Stats.Defense);
    
    // Apply resistance calculation
    var damageInstance = _damageCalculationService.CalculateDamage(
        baseDamage, 
        "physical",  // Default for now, weapons will override in future
        monster.Resistances);
    
    // Apply damage
    monster.TakeDamage(damageInstance.FinalDamage);
    
    // Render with resistance feedback
    await _renderer.RenderCombatDamageAsync(damageInstance, monster.Name, ct);
}
```

#### 14. Update SpectreGameRenderer.cs (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

```csharp
/// <summary>
/// Renders combat damage with resistance effects.
/// </summary>
public Task RenderCombatDamageAsync(DamageInstance damage, string targetName, CancellationToken ct = default)
{
    // Base damage message
    AnsiConsole.MarkupLine($"You deal [green]{damage.FinalDamage}[/] damage to the {targetName}!");
    
    // Resistance feedback
    if (damage.WasImmune)
    {
        AnsiConsole.MarkupLine($"[grey]The {targetName} is [bold]immune[/] to {damage.DamageTypeId} damage![/]");
    }
    else if (damage.WasVulnerable)
    {
        AnsiConsole.MarkupLine($"[red]It's super effective![/] [dim]({Math.Abs(damage.ResistanceApplied)}% extra damage)[/]");
    }
    else if (damage.WasResisted)
    {
        AnsiConsole.MarkupLine($"[grey]It's not very effective...[/] [dim]({damage.ResistanceApplied}% reduced)[/]");
    }
    
    return Task.CompletedTask;
}
```

---

## Configuration

### 15. damage-types.json (NEW)

**File:** `config/damage-types.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "damageTypes": [
    {
      "id": "physical",
      "name": "Physical",
      "description": "Standard physical damage from weapons and natural attacks.",
      "color": "white",
      "icon": "‚öîÔ∏è",
      "sortOrder": 0
    },
    {
      "id": "fire",
      "name": "Fire",
      "description": "Burning heat damage from flames and explosions.",
      "color": "red",
      "icon": "üî•",
      "sortOrder": 1
    },
    {
      "id": "ice",
      "name": "Ice",
      "description": "Freezing cold damage that can slow and shatter.",
      "color": "cyan",
      "icon": "‚ùÑÔ∏è",
      "sortOrder": 2
    },
    {
      "id": "lightning",
      "name": "Lightning",
      "description": "Electrical damage that can stun and chain.",
      "color": "yellow",
      "icon": "‚ö°",
      "sortOrder": 3
    },
    {
      "id": "poison",
      "name": "Poison",
      "description": "Toxic damage that can linger over time.",
      "color": "green",
      "icon": "‚ò†Ô∏è",
      "sortOrder": 4
    }
  ]
}
```

### 16. Update monsters.json (MODIFY)

**File:** `config/monsters.json`

Add `baseResistances` field to monsters:

```json
{
  "monsters": [
    {
      "id": "skeleton",
      "name": "Skeleton",
      "description": "An animated pile of bones.",
      "baseHealth": 25,
      "baseAttack": 10,
      "baseDefense": 1,
      "baseExperienceValue": 30,
      "baseResistances": {
        "physical": 25,
        "fire": -50,
        "ice": 50,
        "poison": 100
      }
    },
    {
      "id": "slime",
      "name": "Slime",
      "description": "A quivering mass of translucent gel.",
      "baseHealth": 40,
      "baseAttack": 4,
      "baseDefense": 0,
      "baseExperienceValue": 15,
      "baseResistances": {
        "physical": -25,
        "fire": 75,
        "ice": -75
      }
    }
  ]
}
```

---

## Flow Diagrams

### Damage Calculation Flow

```
Player attacks Monster (Base Damage: 10, Type: "fire")
       ‚îÇ
       ‚ñº
DamageCalculationService.CalculateDamage(10, "fire", monster.Resistances)
       ‚îÇ
       ‚îú‚îÄ‚ñ∫ 1. NORMALIZE INPUT
       ‚îÇ   ‚îú‚îÄ‚îÄ damageTypeId = "fire" (lowercase)
       ‚îÇ   ‚îî‚îÄ‚îÄ baseDamage = 10
       ‚îÇ
       ‚îú‚îÄ‚ñ∫ 2. GET RESISTANCE
       ‚îÇ   ‚îú‚îÄ‚îÄ monster.Resistances.GetResistance("fire")
       ‚îÇ   ‚îî‚îÄ‚îÄ Result: -50 (Vulnerable)
       ‚îÇ
       ‚îú‚îÄ‚ñ∫ 3. CALCULATE MULTIPLIER
       ‚îÇ   ‚îú‚îÄ‚îÄ multiplier = 1.0 - (-50/100)
       ‚îÇ   ‚îî‚îÄ‚îÄ Result: 1.5
       ‚îÇ
       ‚îú‚îÄ‚ñ∫ 4. APPLY DAMAGE
       ‚îÇ   ‚îú‚îÄ‚îÄ finalDamage = 10 * 1.5 = 15
       ‚îÇ   ‚îî‚îÄ‚îÄ Math.Max(0, 15) = 15
       ‚îÇ
       ‚îî‚îÄ‚ñ∫ 5. CREATE RESULT
           ‚îî‚îÄ‚îÄ DamageInstance {
                 BaseDamage: 10,
                 DamageTypeId: "fire",
                 FinalDamage: 15,
                 ResistanceApplied: -50,
                 WasVulnerable: true
               }
```

### Resistance Effect Decision Tree

```
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ   GetResistance(type)   ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ              ‚îÇ              ‚îÇ
      res >= 100     0 < res < 100    res < 0
           ‚îÇ              ‚îÇ              ‚îÇ
           ‚ñº              ‚ñº              ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  IMMUNE  ‚îÇ   ‚îÇ RESISTED ‚îÇ   ‚îÇVULNERABLE‚îÇ
    ‚îÇ  (0 dmg) ‚îÇ   ‚îÇ (reduced)‚îÇ   ‚îÇ(increased)‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Testing Strategy

### Test Categories

#### 1. DamageResistancesTests.cs (~6 tests)

| Test | Description |
|------|-------------|
| `Constructor_NullDictionary_CreatesEmpty` | Null input creates empty resistances |
| `Constructor_ClampValues_ToValidRange` | Values outside -100/+100 are clamped |
| `GetResistance_ExistingType_ReturnsValue` | Returns correct resistance value |
| `GetResistance_MissingType_ReturnsZero` | Missing types return 0 |
| `GetMultiplier_PositiveResistance_ReducesMultiplier` | +50 = 0.5 multiplier |
| `GetMultiplier_NegativeResistance_IncreasesMultiplier` | -50 = 1.5 multiplier |
| `IsImmune_At100Resistance_ReturnsTrue` | 100% = immune |
| `IsVulnerable_NegativeResistance_ReturnsTrue` | Negative = vulnerable |

#### 2. DamageInstanceTests.cs (~3 tests)

| Test | Description |
|------|-------------|
| `GetResistanceDescription_Immune_ReturnsImmuneText` | "Immune!" text |
| `GetResistanceDescription_Resisted_ReturnsResistText` | "Resisted (X% reduced)" |
| `GetResistanceDescription_Vulnerable_ReturnsVulnText` | "Vulnerable! (X% extra)" |

#### 3. DamageCalculationServiceTests.cs (~6 tests)

| Test | Description |
|------|-------------|
| `CalculateDamage_NoResistances_ReturnsBaseDamage` | Zero resistance = base damage |
| `CalculateDamage_PositiveResistance_ReducesDamage` | +50% = half damage |
| `CalculateDamage_NegativeResistance_IncreasesDamage` | -50% = 1.5x damage |
| `CalculateDamage_Immunity_ReturnsZero` | +100% = 0 damage |
| `CalculateDamage_NullType_DefaultsToPhysical` | Empty type = "physical" |
| `CalculateDamage_NeverNegative_ReturnsZeroMinimum` | Result never < 0 |

### Sample Test Implementation

```csharp
[TestFixture]
public class DamageResistancesTests
{
    [Test]
    public void GetMultiplier_PositiveResistance_ReducesMultiplier()
    {
        // Arrange
        var resistances = new DamageResistances(
            new Dictionary<string, int> { { "fire", 50 } });

        // Act
        var multiplier = resistances.GetMultiplier("fire");

        // Assert
        Assert.That(multiplier, Is.EqualTo(0.5f));
    }

    [Test]
    public void GetMultiplier_NegativeResistance_IncreasesMultiplier()
    {
        // Arrange
        var resistances = new DamageResistances(
            new Dictionary<string, int> { { "ice", -50 } });

        // Act
        var multiplier = resistances.GetMultiplier("ice");

        // Assert
        Assert.That(multiplier, Is.EqualTo(1.5f));
    }

    [Test]
    public void IsImmune_At100Resistance_ReturnsTrue()
    {
        // Arrange
        var resistances = new DamageResistances(
            new Dictionary<string, int> { { "poison", 100 } });

        // Act & Assert
        Assert.That(resistances.IsImmune("poison"), Is.True);
        Assert.That(resistances.IsResistant("poison"), Is.False);
    }
}

[TestFixture]
public class DamageCalculationServiceTests
{
    private DamageCalculationService _service = null!;
    private Mock<ILogger<DamageCalculationService>> _mockLogger = null!;
    private Mock<IGameConfigurationProvider> _mockConfig = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<DamageCalculationService>>();
        _mockConfig = new Mock<IGameConfigurationProvider>();
        _service = new DamageCalculationService(_mockLogger.Object, _mockConfig.Object);
    }

    [Test]
    public void CalculateDamage_NoResistances_ReturnsBaseDamage()
    {
        // Arrange
        var resistances = DamageResistances.None;

        // Act
        var result = _service.CalculateDamage(10, "physical", resistances);

        // Assert
        Assert.That(result.FinalDamage, Is.EqualTo(10));
        Assert.That(result.HadResistanceEffect, Is.False);
    }

    [Test]
    public void CalculateDamage_Immunity_ReturnsZero()
    {
        // Arrange
        var resistances = new DamageResistances(
            new Dictionary<string, int> { { "poison", 100 } });

        // Act
        var result = _service.CalculateDamage(50, "poison", resistances);

        // Assert
        Assert.That(result.FinalDamage, Is.EqualTo(0));
        Assert.That(result.WasImmune, Is.True);
    }
}
```

---

## Logging Strategy

### Log Levels

| Level | Usage |
|-------|-------|
| Debug | Damage calculations with full details |
| Information | Configuration loading |
| Warning | Missing damage types, invalid resistance values |
| Error | Configuration parsing failures |

### Log Messages

```csharp
// DamageCalculationService
_logger.LogDebug(
    "Damage calculation: {BaseDamage} {DamageType} vs {Resistance}% = {FinalDamage} (Multiplier: {Multiplier})",
    baseDamage, normalizedTypeId, resistance, finalDamage, multiplier);

// JsonConfigurationProvider
_logger.LogInformation("Loaded {Count} damage type definitions", _damageTypes.Count);

// When resistance is missing
_logger.LogWarning("Unknown damage type '{DamageType}', treating as no resistance", damageTypeId);
```

---

## Implementation Checklist

### Phase 1: Domain Layer
- [ ] Create `DamageTypeDefinition.cs`
- [ ] Create `DamageResistances.cs`
- [ ] Create `DamageInstance.cs`
- [ ] Modify `MonsterDefinition.cs` - add BaseResistances property
- [ ] Modify `Monster.cs` - add Resistances property, update constructor
- [ ] Modify `Player.cs` - add Resistances property and setter

### Phase 2: Application Layer
- [ ] Create `IDamageCalculationService.cs`
- [ ] Create `DamageCalculationService.cs`
- [ ] Create `DamageTypeConfigurationDto.cs`
- [ ] Modify `IConfigurationProvider.cs` - add damage type methods
- [ ] Modify `MonsterService.cs` - pass resistances during spawn

### Phase 3: Infrastructure Layer
- [ ] Modify `JsonConfigurationProvider.cs` - implement damage type loading
- [ ] Modify `JsonConfigurationProvider.cs` - parse monster resistances

### Phase 4: Configuration
- [ ] Create `config/damage-types.json`
- [ ] Modify `config/monsters.json` - add baseResistances to monsters

### Phase 5: Presentation Layer
- [ ] Modify `GameSessionService.cs` - use DamageCalculationService
- [ ] Modify `SpectreGameRenderer.cs` - render resistance feedback

### Phase 6: DI Registration
- [ ] Register `IDamageCalculationService` -> `DamageCalculationService`

### Phase 7: Testing
- [ ] Create `DamageResistancesTests.cs` (~6 tests)
- [ ] Create `DamageInstanceTests.cs` (~3 tests)
- [ ] Create `DamageCalculationServiceTests.cs` (~6 tests)

---

## Acceptance Criteria

### Damage Types
- [ ] `damage-types.json` loads successfully with 5+ damage types
- [ ] Physical is the default damage type when none specified
- [ ] Damage types have id, name, description, color properties

### Resistances
- [ ] Resistances clamped to -100 to +100 range
- [ ] +100 resistance = immunity (0 damage)
- [ ] +50 resistance = 50% damage reduction
- [ ] -50 resistance = 50% damage increase
- [ ] Missing resistance = 0 (normal damage)

### Combat Integration
- [ ] Damage calculation uses `DamageCalculationService`
- [ ] Combat displays "Super effective!" for vulnerabilities
- [ ] Combat displays "Not very effective..." for resistances
- [ ] Combat displays "Immune!" for immunities

### Monster Integration
- [ ] Monsters can have `baseResistances` in JSON
- [ ] Spawned monsters inherit resistances from definition
- [ ] Examine command shows monster resistances

### General
- [ ] ~15 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Combat balance disruption | Medium | Medium | Start with moderate resistance values (+/-25 to 50) |
| Math edge cases (divide by zero, overflow) | Low | High | Use clamped values, test boundary cases |
| Missing damage type config | Low | Medium | Fallback to "physical" as default |
| UI clutter from resistance messages | Medium | Low | Only show non-trivial effects (>10%) |
| Confusion with resistance percentages | Medium | Low | Clear documentation, consistent display format |

---

## File Summary

### New Files (5)

| Layer | File | Purpose |
|-------|------|---------|
| Domain | `Definitions/DamageTypeDefinition.cs` | Damage type entity |
| Domain | `ValueObjects/DamageResistances.cs` | Resistance storage |
| Domain | `ValueObjects/DamageInstance.cs` | Calculation result |
| Application | `Interfaces/IDamageCalculationService.cs` | Service interface |
| Application | `Services/DamageCalculationService.cs` | Service implementation |
| Application | `Configuration/DamageTypeConfigurationDto.cs` | JSON DTOs |
| Config | `config/damage-types.json` | Damage type definitions |

### Modified Files (7)

| Layer | File | Changes |
|-------|------|---------|
| Domain | `Definitions/MonsterDefinition.cs` | Add BaseResistances property |
| Domain | `Entities/Monster.cs` | Add Resistances property |
| Domain | `Entities/Player.cs` | Add Resistances property |
| Application | `Interfaces/IConfigurationProvider.cs` | Add damage type methods |
| Application | `Services/MonsterService.cs` | Pass resistances during spawn |
| Application | `Services/GameSessionService.cs` | Use damage calculation |
| Infrastructure | `Configuration/JsonConfigurationProvider.cs` | Load damage types and resistances |
| Presentation | `Adapters/SpectreGameRenderer.cs` | Render resistance feedback |
| Config | `config/monsters.json` | Add baseResistances to monsters |

### Test Files Summary

| File | Test Count |
|------|------------|
| `DamageResistancesTests.cs` | ~6 |
| `DamageInstanceTests.cs` | ~3 |
| `DamageCalculationServiceTests.cs` | ~6 |
| **Total** | **~15** |

---

## Provides to Future Phases

### To v0.0.9c (Monster Tiers & Traits)

| Type | Usage |
|------|-------|
| `DamageResistances` | Traits can modify resistances |
| `DamageCalculationService` | Trait effects (Armored) integrate with damage |
| `Monster.Resistances` | Tier multipliers may enhance resistances |

### To Equipment System (Future)

| Type | Usage |
|------|-------|
| `Player.Resistances` | Equipment can grant resistances |
| `DamageTypeDefinition` | Weapons will have damage types |
| `DamageCalculationService` | Equipment bonuses integrate with calculation |

### To Status Effects (Future)

| Type | Usage |
|------|-------|
| `DamageTypeDefinition` | Status effects (Poison, Burn) use damage types |
| `DamageResistances` | Resistance reduces DoT damage |
