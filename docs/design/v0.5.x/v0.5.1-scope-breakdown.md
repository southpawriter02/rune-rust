# v0.5.1 Range & Melee Combat - Scope Breakdown

**Version:** 0.5.1
**Theme:** Range & Melee Combat
**Prerequisites:** v0.5.0 Complete (Combat Grid Foundation)
**Total Estimated Tests:** ~75 new tests

---

## Executive Summary

The Range & Melee Combat version introduces range-based attack mechanics that leverage the combat grid from v0.5.0. Weapons and abilities now have range properties that determine valid targets based on grid distance. Melee attacks require adjacency, ranged attacks have maximum (and optional minimum) ranges, and line of sight calculations determine if a target can be seen. This version adds tactical depth by making positioning matter for attack validity.

Key focus areas:
- **Range Properties**: Weapons and abilities have configurable range values
- **Melee Requirements**: Adjacent-only attacks for melee weapons (range 1)
- **Ranged Mechanics**: Min/max range, range penalties, ranged weapon types
- **Line of Sight**: Basic LOS calculations for ranged attack validation

The work is divided into **three sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.5.1a | Range Core | Range properties, RangeType enum, melee adjacency | ~30 |
| v0.5.1b | Ranged Weapons | Ranged items, min range, range penalties | ~25 |
| v0.5.1c | Line of Sight | LOS service, blocking cells, attack integration | ~20 |

---

## Existing Infrastructure

### Already Implemented (from v0.5.0)

| Feature | Location | Notes |
|---------|----------|-------|
| CombatGrid | `Domain/Entities/CombatGrid.cs` | Grid for positioning |
| GridPosition | `Domain/ValueObjects/GridPosition.cs` | X,Y coordinates, distance |
| GridCell | `Domain/ValueObjects/GridCell.cs` | Cell occupancy |
| CombatGridService | `Application/Services/CombatGridService.cs` | Grid management |
| MovementService | `Application/Services/MovementService.cs` | Movement system |
| GridPosition.DistanceTo() | `Domain/ValueObjects/GridPosition.cs` | Distance calculation |
| CombatGrid.AreAdjacent() | `Domain/Entities/CombatGrid.cs` | Adjacency check |
| GridRenderer | `Presentation/Adapters/GridRenderer.cs` | ASCII display |

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| Item entity | `Domain/Entities/Item.cs` | Weapon items |
| ItemDefinition | `Domain/Definitions/ItemDefinition.cs` | Item configuration |
| AbilityDefinition | `Domain/Definitions/AbilityDefinition.cs` | Ability configuration |
| CombatService | `Application/Services/CombatService.cs` | Attack processing |
| AttackCommand | `Presentation/Commands/AttackCommand.cs` | Attack handling |
| DiceService | `Application/Services/DiceService.cs` | Dice rolls |

### Needs Implementation (v0.5.1)

| Feature | Phase | Notes |
|---------|-------|-------|
| RangeType enum | v0.5.1a | Melee, Ranged, Reach |
| Item.Range property | v0.5.1a | Weapon range |
| AbilityDefinition.Range | v0.5.1a | Ability range |
| IRangeService interface | v0.5.1a | Range calculations |
| RangeService | v0.5.1a | Range validation |
| Item.MinRange property | v0.5.1b | Minimum range |
| Range penalty config | v0.5.1b | Accuracy at distance |
| Ranged weapon definitions | v0.5.1b | Bows, crossbows, thrown |
| ILineOfSightService | v0.5.1c | LOS interface |
| LineOfSightService | v0.5.1c | LOS calculations |
| Attack range validation | v0.5.1c | Integration with combat |

---

## Feature Analysis & Categorization

### Range Core Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| RangeType enum | Low | None | **v0.5.1a** |
| Item.Range property | Medium | Item | **v0.5.1a** |
| AbilityDefinition.Range | Medium | AbilityDefinition | **v0.5.1a** |
| Melee adjacency requirement | Medium | CombatGrid | **v0.5.1a** |
| IRangeService interface | Low | None | **v0.5.1a** |
| RangeService | High | GridPosition, CombatGrid | **v0.5.1a** |
| Range validation in attack | Medium | RangeService, CombatService | **v0.5.1a** |
| Range display (valid targets) | Medium | RangeService, GridRenderer | **v0.5.1a** |

### Ranged Weapon Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| Item.MinRange property | Low | Item | **v0.5.1b** |
| Ranged weapon items | Medium | ItemDefinition | **v0.5.1b** |
| Thrown weapons | Medium | ItemDefinition | **v0.5.1b** |
| Ranged spells | Medium | AbilityDefinition | **v0.5.1b** |
| Range penalty configuration | Medium | Config | **v0.5.1b** |
| Long range accuracy penalty | Medium | RangeService | **v0.5.1b** |
| Optimal range calculation | Medium | RangeService | **v0.5.1b** |

### Line of Sight Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| ILineOfSightService | Low | None | **v0.5.1c** |
| LineOfSightService | High | CombatGrid, GridPosition | **v0.5.1c** |
| LOS blocking cells | Medium | GridCell | **v0.5.1c** |
| LOS path tracing | High | GridPosition | **v0.5.1c** |
| Attack LOS validation | Medium | CombatService | **v0.5.1c** |
| LOS display on grid | Medium | GridRenderer | **v0.5.1c** |

---

## Phase Definitions

---

## v0.5.1a: Range Core

[v0.5.1a Design Specification](v0.5.1a-design-specification.md)

### Overview

Establish the foundational range system including the RangeType enum, range properties on weapons and abilities, and the RangeService for validating attack distances. Melee attacks require adjacency (distance 1), while ranged attacks can reach further targets.

### Scope

**In Scope:**
- `RangeType` enum (Melee, Ranged, Reach)
- `Item.Range` property for weapons
- `Item.RangeType` property for weapons
- `AbilityDefinition.Range` property
- `AbilityDefinition.RangeType` property
- `IRangeService` interface
- `RangeService` for range calculations
- Melee adjacency validation (range 1)
- Reach validation (range 2)
- Range checking in attack command
- Valid target display based on range
- Range indicator in combat UI
- Update weapon definitions with range

**Out of Scope:**
- Minimum range (v0.5.1b)
- Range penalties (v0.5.1b)
- Ranged weapon items (v0.5.1b)
- Line of sight (v0.5.1c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Enums | 1 | `RangeType` |
| Item Updates | 1 | Add Range, RangeType properties |
| AbilityDefinition Updates | 1 | Add Range, RangeType properties |
| Application Interfaces | 1 | `IRangeService` |
| Application Services | 1 | `RangeService` |
| Command Updates | 1 | Attack command range validation |
| Configuration | 1 | Update items.json with ranges |
| Unit Tests | ~30 | Range, melee, reach tests |

### RangeType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of attack range for weapons and abilities.
/// </summary>
public enum RangeType
{
    /// <summary>
    /// Melee range - must be adjacent (distance 1).
    /// </summary>
    Melee,

    /// <summary>
    /// Reach range - can attack at distance 2.
    /// </summary>
    Reach,

    /// <summary>
    /// Ranged - can attack at configurable distance.
    /// </summary>
    Ranged
}
```

### Item Modifications

```
MODIFY: Item
├── ADD: Range: int (default: 1 for melee)
├── ADD: RangeType: RangeType (default: Melee)
├── ADD: GetEffectiveRange(): int
└── ADD: IsInRange(int distance): bool

MODIFY: ItemDefinition
├── ADD: Range: int (default: 1)
└── ADD: RangeType: RangeType (default: Melee)
```

### AbilityDefinition Modifications

```
MODIFY: AbilityDefinition
├── ADD: Range: int (default: 1 for melee abilities)
├── ADD: RangeType: RangeType (default: Melee)
├── ADD: GetEffectiveRange(): int
└── ADD: IsInRange(int distance): bool
```

### IRangeService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for range calculations and validation.
/// </summary>
public interface IRangeService
{
    /// <summary>
    /// Checks if a target is within attack range.
    /// </summary>
    RangeCheckResult CheckRange(
        Guid attackerId,
        Guid targetId,
        int weaponRange,
        RangeType rangeType);

    /// <summary>
    /// Checks if a target is within ability range.
    /// </summary>
    RangeCheckResult CheckAbilityRange(
        Guid casterId,
        Guid targetId,
        AbilityDefinition ability);

    /// <summary>
    /// Gets all valid targets within weapon range.
    /// </summary>
    IEnumerable<Guid> GetValidTargets(
        Guid attackerId,
        int range,
        RangeType rangeType);

    /// <summary>
    /// Gets the distance between two entities.
    /// </summary>
    int? GetDistance(Guid entityId1, Guid entityId2);

    /// <summary>
    /// Checks if two entities are adjacent.
    /// </summary>
    bool AreAdjacent(Guid entityId1, Guid entityId2);

    /// <summary>
    /// Gets the effective range for a weapon.
    /// </summary>
    int GetEffectiveRange(Item weapon);

    /// <summary>
    /// Gets the effective range for an ability.
    /// </summary>
    int GetEffectiveRange(AbilityDefinition ability);
}

public readonly record struct RangeCheckResult
{
    public bool InRange { get; init; }
    public int Distance { get; init; }
    public int WeaponRange { get; init; }
    public RangeType RangeType { get; init; }
    public string Message { get; init; }
    public RangeFailureReason? FailureReason { get; init; }
}

public enum RangeFailureReason
{
    NoActiveGrid,
    AttackerNotOnGrid,
    TargetNotOnGrid,
    OutOfRange,
    TooClose,
    NotAdjacent,
    NoLineOfSight
}
```

### RangeService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for range calculations and validation.
/// </summary>
public class RangeService : IRangeService
{
    private readonly ICombatGridService _gridService;
    private readonly ILogger<RangeService> _logger;

    public RangeService(
        ICombatGridService gridService,
        ILogger<RangeService> logger)
    {
        _gridService = gridService;
        _logger = logger;
    }

    /// <inheritdoc />
    public RangeCheckResult CheckRange(
        Guid attackerId,
        Guid targetId,
        int weaponRange,
        RangeType rangeType)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
        {
            return new RangeCheckResult
            {
                InRange = false,
                FailureReason = RangeFailureReason.NoActiveGrid,
                Message = "No active combat grid."
            };
        }

        var attackerPos = grid.GetEntityPosition(attackerId);
        var targetPos = grid.GetEntityPosition(targetId);

        if (!attackerPos.HasValue)
        {
            return new RangeCheckResult
            {
                InRange = false,
                FailureReason = RangeFailureReason.AttackerNotOnGrid,
                Message = "Attacker is not on the grid."
            };
        }

        if (!targetPos.HasValue)
        {
            return new RangeCheckResult
            {
                InRange = false,
                FailureReason = RangeFailureReason.TargetNotOnGrid,
                Message = "Target is not on the grid."
            };
        }

        var distance = attackerPos.Value.DistanceTo(targetPos.Value);

        // Check range based on type
        var inRange = rangeType switch
        {
            RangeType.Melee => distance == 1,
            RangeType.Reach => distance <= 2,
            RangeType.Ranged => distance <= weaponRange,
            _ => distance <= weaponRange
        };

        if (!inRange)
        {
            var reason = rangeType == RangeType.Melee
                ? RangeFailureReason.NotAdjacent
                : RangeFailureReason.OutOfRange;

            return new RangeCheckResult
            {
                InRange = false,
                Distance = distance,
                WeaponRange = weaponRange,
                RangeType = rangeType,
                FailureReason = reason,
                Message = rangeType == RangeType.Melee
                    ? $"Target is not adjacent (distance: {distance})."
                    : $"Target is out of range (distance: {distance}, range: {weaponRange})."
            };
        }

        _logger.LogDebug(
            "Range check passed: distance {Distance}, range {Range}, type {Type}",
            distance, weaponRange, rangeType);

        return new RangeCheckResult
        {
            InRange = true,
            Distance = distance,
            WeaponRange = weaponRange,
            RangeType = rangeType,
            Message = "Target is in range."
        };
    }

    /// <inheritdoc />
    public IEnumerable<Guid> GetValidTargets(
        Guid attackerId,
        int range,
        RangeType rangeType)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            yield break;

        var attackerPos = grid.GetEntityPosition(attackerId);
        if (!attackerPos.HasValue)
            yield break;

        var effectiveRange = rangeType switch
        {
            RangeType.Melee => 1,
            RangeType.Reach => 2,
            RangeType.Ranged => range,
            _ => range
        };

        foreach (var entityId in grid.GetEntitiesInRange(attackerPos.Value, effectiveRange))
        {
            if (entityId == attackerId)
                continue;

            // For melee, must be exactly adjacent
            if (rangeType == RangeType.Melee)
            {
                if (grid.AreAdjacent(attackerId, entityId))
                    yield return entityId;
            }
            else
            {
                yield return entityId;
            }
        }
    }

    /// <inheritdoc />
    public int? GetDistance(Guid entityId1, Guid entityId2)
    {
        return _gridService.GetDistance(entityId1, entityId2);
    }

    /// <inheritdoc />
    public bool AreAdjacent(Guid entityId1, Guid entityId2)
    {
        return _gridService.AreAdjacent(entityId1, entityId2);
    }

    /// <inheritdoc />
    public int GetEffectiveRange(Item weapon)
    {
        return weapon.RangeType switch
        {
            RangeType.Melee => 1,
            RangeType.Reach => 2,
            RangeType.Ranged => weapon.Range,
            _ => 1
        };
    }

    /// <inheritdoc />
    public int GetEffectiveRange(AbilityDefinition ability)
    {
        return ability.RangeType switch
        {
            RangeType.Melee => 1,
            RangeType.Reach => 2,
            RangeType.Ranged => ability.Range,
            _ => 1
        };
    }

    /// <inheritdoc />
    public RangeCheckResult CheckAbilityRange(
        Guid casterId,
        Guid targetId,
        AbilityDefinition ability)
    {
        return CheckRange(casterId, targetId, ability.Range, ability.RangeType);
    }
}
```

### User-Facing Changes

**Commands:**
```
> attack <target>         # Attack with equipped weapon (checks range)
> attack skeleton         # Fails if skeleton not in weapon range
> targets                 # Show valid targets in range
```

**Melee Attack (In Range):**
```
> attack skeleton

You swing your Iron Sword at the Skeleton at C2...

[Melee attack - adjacent target]
[Attack Roll: 2d6 + 3 = 14 vs AC 12]
Hit! 8 damage to Skeleton.
```

**Melee Attack (Out of Range):**
```
> attack skeleton

You can't attack the Skeleton - it's not adjacent!

[Distance: 3 cells]
[Iron Sword requires melee range (adjacent)]

Consider moving closer or using a ranged weapon.
```

**Valid Targets Display:**
```
> targets

Valid Targets (Iron Sword - Melee):
  • Skeleton at C3 [Adjacent]
  • Goblin at D3 [Adjacent]

Out of Range:
  • Skeleton Archer at F2 [3 cells away]
```

**Grid with Range Indicator:**
```
  A B C D E F G H
1 . . . . . . . .
2 . . M . . M . .       @ = You (D4)
3 . . * @ * . . .       M = Monster
4 . . * * * . . .       * = Melee range
5 . . . . . . . .       . = Empty

You (D4) | HP: 25/30 | Weapon: Iron Sword (Melee)
```

### Configuration Example

```json
{
  "$schema": "../schemas/items.schema.json",
  "items": [
    {
      "id": "iron-sword",
      "name": "Iron Sword",
      "type": "Weapon",
      "subType": "Sword",
      "damage": "1d8",
      "range": 1,
      "rangeType": "Melee"
    },
    {
      "id": "spear",
      "name": "Spear",
      "type": "Weapon",
      "subType": "Polearm",
      "damage": "1d6",
      "range": 2,
      "rangeType": "Reach"
    },
    {
      "id": "halberd",
      "name": "Halberd",
      "type": "Weapon",
      "subType": "Polearm",
      "damage": "1d10",
      "range": 2,
      "rangeType": "Reach"
    }
  ]
}
```

### Acceptance Criteria

- [ ] RangeType enum has Melee, Reach, Ranged values
- [ ] Item.Range stores weapon range correctly
- [ ] Item.RangeType stores range type correctly
- [ ] AbilityDefinition.Range stores ability range
- [ ] Melee attacks require adjacency (distance 1)
- [ ] Reach attacks work at distance 1 or 2
- [ ] RangeService validates attack range
- [ ] Attack command checks range before attacking
- [ ] Out-of-range attacks display helpful message
- [ ] Valid targets show range information
- [ ] Grid display can show melee range
- [ ] Existing melee weapons updated with Range=1
- [ ] ~30 unit tests pass

---

## v0.5.1b: Ranged Weapons

[v0.5.1b Design Specification](v0.5.1b-design-specification.md)

### Overview

Implement ranged weapon mechanics including minimum range, range penalties for long-distance shots, and specific ranged weapon types (bows, crossbows, thrown weapons). Ranged spells are also configured with appropriate ranges.

### Scope

**In Scope:**
- `Item.MinRange` property for ranged weapons
- Minimum range validation (can't shoot adjacent enemies with bows)
- Range penalty configuration (accuracy at long range)
- Long range accuracy penalty calculation
- Optimal range band (no penalty zone)
- Bow weapon definitions
- Crossbow weapon definitions
- Thrown weapon definitions
- Ranged spell ability definitions
- Update ability configuration with ranges
- Ammunition tracking awareness (for display, not consumption)

**Out of Scope:**
- Ammunition consumption (future version)
- Line of sight (v0.5.1c)
- Cover affecting ranged attacks (v0.5.2)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Item Updates | 1 | Add MinRange property |
| Service Updates | 1 | RangeService penalty calculation |
| Configuration | 2 | ranged-weapons.json, Update abilities.json |
| Weapon Definitions | ~6 | Shortbow, Longbow, Crossbow, Javelin, Dagger(thrown), Handaxe(thrown) |
| Ability Updates | ~4 | Fireball, Ice Bolt, etc. with ranges |
| Unit Tests | ~25 | Min range, penalties, ranged weapons |

### Item Modifications

```
MODIFY: Item
├── ADD: MinRange: int (default: 0)
├── ADD: OptimalRange: int? (for penalty calculation)
├── ADD: RangePenalty: int (penalty per cell beyond optimal)
├── ADD: HasMinRange: bool => MinRange > 0
└── ADD: IsInOptimalRange(int distance): bool

MODIFY: ItemDefinition
├── ADD: MinRange: int (default: 0)
├── ADD: OptimalRange: int? (default: null)
└── ADD: RangePenalty: int (default: 1)
```

### IRangeService Updates

```csharp
// Add to IRangeService:

/// <summary>
/// Checks if a target is within valid range (min and max).
/// </summary>
RangeCheckResult CheckFullRange(
    Guid attackerId,
    Guid targetId,
    Item weapon);

/// <summary>
/// Gets the range penalty for a given distance.
/// </summary>
int GetRangePenalty(int distance, Item weapon);

/// <summary>
/// Gets the range penalty for an ability.
/// </summary>
int GetAbilityRangePenalty(int distance, AbilityDefinition ability);

/// <summary>
/// Checks if target is too close (within min range).
/// </summary>
bool IsTooClose(Guid attackerId, Guid targetId, Item weapon);
```

### Range Penalty Calculation

```csharp
/// <summary>
/// Gets the range penalty for a given distance.
/// </summary>
public int GetRangePenalty(int distance, Item weapon)
{
    if (weapon.RangeType != RangeType.Ranged)
        return 0;

    // Check minimum range
    if (distance < weapon.MinRange)
        return int.MaxValue; // Can't attack

    // Check optimal range
    var optimalRange = weapon.OptimalRange ?? weapon.Range / 2;
    if (distance <= optimalRange)
        return 0; // No penalty in optimal range

    // Calculate penalty beyond optimal range
    var beyondOptimal = distance - optimalRange;
    return beyondOptimal * weapon.RangePenalty;
}
```

### User-Facing Changes

**Commands:**
```
> attack <target>         # Attack with ranged weapon
> throw dagger <target>   # Throw a weapon at target
```

**Ranged Attack (In Range):**
```
> attack goblin

You draw your Longbow and aim at the Goblin at F2...

[Ranged attack - distance: 4 cells]
[Optimal range: 6 cells - no penalty]
[Attack Roll: 2d6 + 3 = 13 vs AC 11]
Hit! 6 damage to Goblin.
```

**Ranged Attack (Long Range Penalty):**
```
> attack skeleton

You take aim at the distant Skeleton at H1...

[Ranged attack - distance: 7 cells]
[Longbow optimal range: 6]
[Long range penalty: -1]
[Attack Roll: 2d6 + 3 - 1 = 11 vs AC 12]
Miss! Your arrow falls short.
```

**Ranged Attack (Too Close):**
```
> attack goblin

The Goblin is too close for your Longbow!

[Distance: 1 cell]
[Longbow minimum range: 2 cells]

Switch to a melee weapon or move away.
```

**Thrown Weapon:**
```
> throw javelin skeleton

You hurl your Javelin at the Skeleton at E3...

[Thrown weapon - distance: 2 cells]
[Attack Roll: 2d6 + 2 = 12 vs AC 12]
Hit! 5 damage to Skeleton.

[Javelin is now at E3 - retrieve after combat]
```

**Ranged Spell:**
```
> cast fireball goblin

You hurl a ball of fire at the Goblin at G2...

[Ranged spell - distance: 5 cells]
[Fireball range: 8 cells - in range]
[Spell Attack: 2d6 + 4 = 15 vs AC 11]
Hit! The Goblin takes 12 fire damage!
```

### Configuration Example

```json
{
  "$schema": "../schemas/items.schema.json",
  "items": [
    {
      "id": "shortbow",
      "name": "Shortbow",
      "type": "Weapon",
      "subType": "Bow",
      "damage": "1d6",
      "range": 8,
      "minRange": 2,
      "optimalRange": 5,
      "rangePenalty": 1,
      "rangeType": "Ranged",
      "twoHanded": true
    },
    {
      "id": "longbow",
      "name": "Longbow",
      "type": "Weapon",
      "subType": "Bow",
      "damage": "1d8",
      "range": 12,
      "minRange": 2,
      "optimalRange": 6,
      "rangePenalty": 1,
      "rangeType": "Ranged",
      "twoHanded": true
    },
    {
      "id": "light-crossbow",
      "name": "Light Crossbow",
      "type": "Weapon",
      "subType": "Crossbow",
      "damage": "1d8",
      "range": 10,
      "minRange": 1,
      "optimalRange": 5,
      "rangePenalty": 1,
      "rangeType": "Ranged",
      "twoHanded": true
    },
    {
      "id": "javelin",
      "name": "Javelin",
      "type": "Weapon",
      "subType": "Thrown",
      "damage": "1d6",
      "range": 4,
      "minRange": 0,
      "optimalRange": 3,
      "rangePenalty": 2,
      "rangeType": "Ranged",
      "thrown": true
    },
    {
      "id": "throwing-dagger",
      "name": "Throwing Dagger",
      "type": "Weapon",
      "subType": "Thrown",
      "damage": "1d4",
      "range": 3,
      "minRange": 0,
      "optimalRange": 2,
      "rangePenalty": 1,
      "rangeType": "Ranged",
      "thrown": true,
      "meleeCapable": true,
      "meleeRange": 1,
      "meleeDamage": "1d4"
    }
  ]
}
```

### Ability Configuration Example

```json
{
  "$schema": "../schemas/abilities.schema.json",
  "abilities": [
    {
      "id": "fireball",
      "name": "Fireball",
      "description": "Hurl a ball of fire at an enemy.",
      "damageType": "Fire",
      "damage": "2d6",
      "range": 8,
      "rangeType": "Ranged",
      "manaCost": 5
    },
    {
      "id": "ice-bolt",
      "name": "Ice Bolt",
      "description": "Launch a bolt of freezing ice.",
      "damageType": "Cold",
      "damage": "1d8",
      "range": 6,
      "rangeType": "Ranged",
      "manaCost": 3
    },
    {
      "id": "shocking-grasp",
      "name": "Shocking Grasp",
      "description": "Electrify a touched enemy.",
      "damageType": "Lightning",
      "damage": "2d8",
      "range": 1,
      "rangeType": "Melee",
      "manaCost": 4
    },
    {
      "id": "thunder-wave",
      "name": "Thunder Wave",
      "description": "Release a wave of thunder around you.",
      "damageType": "Thunder",
      "damage": "1d6",
      "range": 2,
      "rangeType": "Reach",
      "manaCost": 4
    }
  ]
}
```

### Acceptance Criteria

- [ ] Item.MinRange prevents attacks on adjacent enemies
- [ ] MinRange validation returns clear error message
- [ ] OptimalRange defines no-penalty zone
- [ ] RangePenalty applies beyond optimal range
- [ ] Longbow has minRange 2, range 12
- [ ] Shortbow has minRange 2, range 8
- [ ] Crossbow has minRange 1, range 10
- [ ] Thrown weapons have range 3-4, minRange 0
- [ ] Thrown weapons can be used in melee if configured
- [ ] Ranged spells have appropriate ranges
- [ ] Range penalty shows in attack output
- [ ] Attack fails with helpful message if too close
- [ ] ~25 unit tests pass

---

## v0.5.1c: Line of Sight

[v0.5.1c Design Specification](v0.5.1c-design-specification.md)

### Overview

Implement line of sight calculations to validate that ranged attacks have a clear path to the target. Blocking cells (walls, large obstacles) interrupt LOS and prevent ranged attacks. LOS is traced using a simplified Bresenham line algorithm.

### Scope

**In Scope:**
- `ILineOfSightService` interface
- `LineOfSightService` implementation
- LOS blocking cell determination
- GridCell.BlocksLOS property
- Line tracing between positions
- LOS check in ranged attack validation
- LOS visualization on grid (optional)
- Melee attacks bypass LOS (always have LOS if adjacent)
- LOS failure message with blocking cell info

**Out of Scope:**
- Cover (v0.5.2) - provides defense, not LOS blocking
- Partial obscurement (future)
- Fog of war (future)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Application Interfaces | 1 | `ILineOfSightService` |
| Application Services | 1 | `LineOfSightService` |
| GridCell Updates | 1 | Add BlocksLOS property |
| RangeService Updates | 1 | LOS integration |
| CombatService Updates | 1 | LOS validation in attacks |
| GridRenderer Updates | 1 | Optional LOS display |
| Unit Tests | ~20 | LOS path, blocking tests |

### GridCell Modifications

```
MODIFY: GridCell
├── ADD: BlocksLOS: bool (default: false for normal cells)
├── ADD: SetBlocksLOS(bool): void
└── CLARIFY: Walls (#) always block LOS
```

### ILineOfSightService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for line of sight calculations.
/// </summary>
public interface ILineOfSightService
{
    /// <summary>
    /// Checks if there is line of sight between two entities.
    /// </summary>
    LineOfSightResult HasLineOfSight(Guid fromEntityId, Guid toEntityId);

    /// <summary>
    /// Checks if there is line of sight between two positions.
    /// </summary>
    LineOfSightResult HasLineOfSight(GridPosition from, GridPosition to);

    /// <summary>
    /// Gets all cells along the line between two positions.
    /// </summary>
    IEnumerable<GridPosition> GetLineCells(GridPosition from, GridPosition to);

    /// <summary>
    /// Gets the first blocking cell along the line.
    /// </summary>
    GridPosition? GetFirstBlockingCell(GridPosition from, GridPosition to);

    /// <summary>
    /// Gets all positions visible from a given position.
    /// </summary>
    IEnumerable<GridPosition> GetVisiblePositions(GridPosition from, int maxRange);
}

public readonly record struct LineOfSightResult
{
    public bool HasLOS { get; init; }
    public GridPosition FromPosition { get; init; }
    public GridPosition ToPosition { get; init; }
    public GridPosition? BlockedBy { get; init; }
    public string Message { get; init; }
}
```

### LineOfSightService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for line of sight calculations using Bresenham's line algorithm.
/// </summary>
public class LineOfSightService : ILineOfSightService
{
    private readonly ICombatGridService _gridService;
    private readonly ILogger<LineOfSightService> _logger;

    public LineOfSightService(
        ICombatGridService gridService,
        ILogger<LineOfSightService> logger)
    {
        _gridService = gridService;
        _logger = logger;
    }

    /// <inheritdoc />
    public LineOfSightResult HasLineOfSight(Guid fromEntityId, Guid toEntityId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
        {
            return new LineOfSightResult
            {
                HasLOS = false,
                Message = "No active combat grid."
            };
        }

        var fromPos = grid.GetEntityPosition(fromEntityId);
        var toPos = grid.GetEntityPosition(toEntityId);

        if (!fromPos.HasValue || !toPos.HasValue)
        {
            return new LineOfSightResult
            {
                HasLOS = false,
                Message = "Entity not on grid."
            };
        }

        return HasLineOfSight(fromPos.Value, toPos.Value);
    }

    /// <inheritdoc />
    public LineOfSightResult HasLineOfSight(GridPosition from, GridPosition to)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
        {
            return new LineOfSightResult
            {
                HasLOS = false,
                FromPosition = from,
                ToPosition = to,
                Message = "No active combat grid."
            };
        }

        // Adjacent cells always have LOS
        if (from.IsAdjacentTo(to))
        {
            return new LineOfSightResult
            {
                HasLOS = true,
                FromPosition = from,
                ToPosition = to,
                Message = "Adjacent - line of sight clear."
            };
        }

        // Check each cell along the line
        var blockingCell = GetFirstBlockingCell(from, to);

        if (blockingCell.HasValue)
        {
            _logger.LogDebug(
                "LOS blocked from {From} to {To} by cell at {Blocking}",
                from, to, blockingCell.Value);

            return new LineOfSightResult
            {
                HasLOS = false,
                FromPosition = from,
                ToPosition = to,
                BlockedBy = blockingCell.Value,
                Message = $"Line of sight blocked by obstacle at {blockingCell.Value}."
            };
        }

        return new LineOfSightResult
        {
            HasLOS = true,
            FromPosition = from,
            ToPosition = to,
            Message = "Line of sight clear."
        };
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetLineCells(GridPosition from, GridPosition to)
    {
        // Bresenham's line algorithm
        int x0 = from.X, y0 = from.Y;
        int x1 = to.X, y1 = to.Y;

        int dx = Math.Abs(x1 - x0);
        int dy = Math.Abs(y1 - y0);
        int sx = x0 < x1 ? 1 : -1;
        int sy = y0 < y1 ? 1 : -1;
        int err = dx - dy;

        while (true)
        {
            yield return new GridPosition(x0, y0);

            if (x0 == x1 && y0 == y1)
                break;

            int e2 = 2 * err;

            if (e2 > -dy)
            {
                err -= dy;
                x0 += sx;
            }

            if (e2 < dx)
            {
                err += dx;
                y0 += sy;
            }
        }
    }

    /// <inheritdoc />
    public GridPosition? GetFirstBlockingCell(GridPosition from, GridPosition to)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            return null;

        foreach (var pos in GetLineCells(from, to))
        {
            // Skip start and end positions
            if (pos.Equals(from) || pos.Equals(to))
                continue;

            var cell = grid.GetCell(pos);
            if (cell != null && (cell.BlocksLOS || !cell.IsPassable))
            {
                return pos;
            }
        }

        return null;
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetVisiblePositions(GridPosition from, int maxRange)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            yield break;

        for (int y = 0; y < grid.Height; y++)
        {
            for (int x = 0; x < grid.Width; x++)
            {
                var pos = new GridPosition(x, y);

                if (pos.Equals(from))
                    continue;

                if (from.DistanceTo(pos) > maxRange)
                    continue;

                var losResult = HasLineOfSight(from, pos);
                if (losResult.HasLOS)
                    yield return pos;
            }
        }
    }
}
```

### RangeService LOS Integration

```csharp
// Update RangeService.CheckRange to include LOS:

public RangeCheckResult CheckRange(
    Guid attackerId,
    Guid targetId,
    int weaponRange,
    RangeType rangeType)
{
    // ... existing range checks ...

    // For ranged attacks, check LOS
    if (rangeType == RangeType.Ranged)
    {
        var losResult = _losService.HasLineOfSight(attackerId, targetId);
        if (!losResult.HasLOS)
        {
            return new RangeCheckResult
            {
                InRange = false,
                Distance = distance,
                WeaponRange = weaponRange,
                RangeType = rangeType,
                FailureReason = RangeFailureReason.NoLineOfSight,
                Message = losResult.Message
            };
        }
    }

    // ... return success ...
}
```

### User-Facing Changes

**Ranged Attack Blocked by LOS:**
```
> attack skeleton

Your view of the Skeleton is blocked!

[Distance: 4 cells - in range]
[Line of sight blocked by wall at D3]

Move to a different position for a clear shot.
```

**LOS Display on Grid:**
```
> targets

  A B C D E F G H
1 . . . . . . . .
2 . . ✓ . . ? . .     @ = You (D4)
3 . . . # . . . .     ✓ = Valid target
4 . . ✓ @ ✓ . . .     ? = Blocked (no LOS)
5 . . . . . . . .     # = Wall (blocks LOS)

Valid Targets (Longbow):
  ✓ Goblin at C2 [3 cells, clear LOS]
  ✓ Skeleton at C4 [1 cell, clear LOS]
  ✓ Skeleton at E4 [1 cell, clear LOS]

Blocked:
  ? Skeleton at F2 [No line of sight - wall at D3]
```

**Successful Ranged with LOS:**
```
> attack goblin

You draw your Longbow and take aim at the Goblin...

[Distance: 3 cells - in range]
[Line of sight: clear]
[Attack Roll: 2d6 + 3 = 14 vs AC 11]
Hit! 7 damage to Goblin.
```

### Acceptance Criteria

- [ ] ILineOfSightService interface defined
- [ ] LineOfSightService implements Bresenham's algorithm
- [ ] Adjacent cells always have LOS
- [ ] Walls block line of sight
- [ ] BlocksLOS property on GridCell works
- [ ] Ranged attacks check LOS before attacking
- [ ] LOS failure shows blocking cell position
- [ ] Melee attacks don't require LOS check
- [ ] GetVisiblePositions returns all visible cells
- [ ] GetLineCells returns correct path
- [ ] LOS visualization available on grid
- [ ] ~20 unit tests pass

---

## Dependencies & Prerequisites

```
v0.5.0 (Combat Grid Foundation) - REQUIRED
    │
    ├── v0.5.0a: Grid Core ─────────────────────┐
    │       CombatGrid, GridPosition, GridCell  │
    │                                           │
    ├── v0.5.0b: Movement System ───────────────┤
    │       MovementSpeed, move command         │
    │                                           │
    └── v0.5.0c: Grid Display & Integration ────┘
            ASCII display, combat integration
                                                │
                                                ▼
v0.5.1 (Range & Melee Combat)
    │
    ├── v0.5.1a: Range Core ───────────────────────────────┐
    │       Dependencies: v0.5.0a (GridPosition.DistanceTo)│
    │       Provides: RangeType, Range props, RangeService │
    │                                                      │
    ├── v0.5.1b: Ranged Weapons ───────────────────────────┤
    │       Dependencies: v0.5.1a                          │
    │       Provides: MinRange, penalties, ranged items    │
    │                                                      │
    └── v0.5.1c: Line of Sight ────────────────────────────┘
            Dependencies: v0.5.1a, v0.5.1b
            Provides: LineOfSightService, LOS validation
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.5.1a | ~3 | ~5 | ~30 | High |
| v0.5.1b | ~1 | ~4 | ~25 | Medium |
| v0.5.1c | ~2 | ~3 | ~20 | High |
| **Total** | **~6** | **~12** | **~75** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Range balance issues | Medium | Medium | Configurable ranges per weapon |
| LOS algorithm complexity | Medium | Low | Use proven Bresenham's algorithm |
| Min range frustration | Medium | Medium | Clear messaging, weapon switching |
| Range penalty tuning | Low | Medium | Configurable in JSON |
| Performance with many entities | Low | Low | LOS calculation is O(n) per check |
| Edge cases in LOS | Medium | Medium | Comprehensive unit tests |

---

## Design Decisions (Confirmed)

### Range System

| Decision | Value | Notes |
|----------|-------|-------|
| **Melee Range** | 1 (adjacent) | Standard melee requirement |
| **Reach Range** | 2 cells | Polearms, long weapons |
| **Default Ranged** | Configurable | Per-weapon in JSON |
| **Distance Calculation** | Chebyshev | From v0.5.0 GridPosition |

### Ranged Weapons

| Decision | Value | Notes |
|----------|-------|-------|
| **Bow Min Range** | 2 | Can't shoot adjacent |
| **Crossbow Min Range** | 1 | Better at close range |
| **Thrown Min Range** | 0 | No minimum |
| **Range Penalty** | -1 per cell beyond optimal | Configurable |

### Line of Sight

| Decision | Value | Notes |
|----------|-------|-------|
| **Algorithm** | Bresenham | Standard line drawing |
| **Melee LOS** | Not required | Adjacent always has LOS |
| **Wall Blocking** | Always blocks | # cells block LOS |
| **Occupied Cells** | Don't block | Entities don't block LOS |

---

## Integration Points

### From v0.5.0
- GridPosition.DistanceTo() for range calculations
- CombatGrid.AreAdjacent() for melee validation
- GridCell for LOS blocking checks
- GridRenderer for range/LOS visualization

### To v0.5.2 (Terrain & Cover)
- LOS for cover calculations
- Range validation for cover bonuses
- Terrain affecting LOS (future)

### To v0.5.3 (Tactical Positioning)
- Range for opportunity attack determination
- LOS for flanking visibility
- Range for AoE targeting

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.5.1a Design Spec** - Range core system
3. **Implement v0.5.1a** - Build range infrastructure
4. **v0.5.1b Design Spec** - Ranged weapons
5. **Implement v0.5.1b** - Build ranged weapon mechanics
6. **v0.5.1c Design Spec** - Line of sight
7. **Implement v0.5.1c** - Complete LOS system

---

*This scope breakdown provides a structured approach to implementing v0.5.1 Range & Melee Combat. Each sub-phase builds on the previous, adding range-based tactical depth to the combat system established in v0.5.0.*
