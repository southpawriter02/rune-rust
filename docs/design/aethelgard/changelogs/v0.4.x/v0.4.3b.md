# Changelog: v0.4.3b - The Grimoire
**Release Date:** 2025-12-31

---

## Summary

v0.4.3b "The Grimoire" introduces the Spell entity and repository system, establishing the foundational data layer for the magic system in Rune & Rust. This release implements a comprehensive **Domain Layer** spell model with classification (schools, target types, ranges), casting mechanics (charge times, concentration requirements), and cost systems that integrate with the Flux framework (v0.4.3a). The implementation includes the **Persistence Layer** SpellRepository with 11 specialized query methods optimized for spellcasting workflows, complete entity framework configuration with indexes for query performance, and 35 unit tests achieving 100% repository coverage. The spell system introduces three new enums (SpellSchool, SpellTargetType, SpellRange) and establishes the data model for future spell effect scripting, archetype-restricted spellcasting, and charged spell mechanics.

Key architectural patterns applied:
- **Repository Pattern**: ISpellRepository interface extending IRepository<Spell> with specialized query methods
- **Entity Framework Configuration**: DbSet registration with unique name constraint, enum conversions, computed property ignoring, and performance indexes
- **Flux Integration**: FluxCost property connects spells to environmental flux accumulation system
- **Defensive Querying**: Case-insensitive name search, whitespace trimming, null-safe archetype filtering

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/SpellSchool.cs` | 4-value enum defining magical schools (Destruction, Restoration, Alteration, Divination) with XML documentation for each discipline |
| `RuneAndRust.Core/Enums/SpellTargetType.cs` | 7-value enum defining spell targeting options (Self, SingleEnemy, SingleAlly, AllEnemies, AllAllies, SingleAny, Area) |
| `RuneAndRust.Core/Enums/SpellRange.cs` | 5-value enum defining effective casting ranges (Self, Touch, Close, Medium, Far) |
| `RuneAndRust.Core/Entities/Spell.cs` | Spell entity with 17 properties organized into 8 regions (Identity, Classification, Costs, Power, Casting Mechanics, Requirements, Metadata, Computed Properties) |
| `RuneAndRust.Core/Interfaces/ISpellRepository.cs` | Repository contract extending IRepository<Spell> with 11 specialized query methods for school, target type, tier, archetype, name, charge status, concentration, range, and bulk operations |

### Persistence Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Repositories/SpellRepository.cs` | Repository implementation with comprehensive logging, query optimization (OrderBy clauses), case-insensitive name search, and null-safe archetype filtering |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Persistence/SpellRepositoryTests.cs` | Integration test suite with 35 tests covering all repository methods, CRUD operations, computed properties, ordering behavior, edge cases, and empty result handling |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Added `DbSet<Spell> Spells` property (line 160); configured Spell entity in OnModelCreating with table name "Spells", unique index on Name, string length constraints (Name: 100, Description: 2000, EffectScript: 500, TelegraphMessage: 500), enum-to-int conversions for School/TargetType/Range/Archetype, ignored computed properties (IsInstantCast, IsChargedSpell, IsArchetypeRestricted, TotalCost), and performance indexes on School, TargetType, Range, Tier, Archetype (lines 1375-1456) |
| `RuneAndRust.Terminal/Program.cs` | Registered `ISpellRepository` → `SpellRepository` as Scoped in DI container (line 99) with version comment "v0.4.3b - The Grimoire" |

---

## Code Implementation Details

### Enums

#### `SpellSchool.cs`

```csharp
public enum SpellSchool
{
    /// <summary>
    /// Offensive magic focused on dealing damage and destruction.
    /// Spells that harm, burn, freeze, or otherwise injure targets.
    /// </summary>
    Destruction = 0,

    /// <summary>
    /// Healing and protective magic focused on restoration.
    /// Spells that heal wounds, cure ailments, or shield allies.
    /// </summary>
    Restoration = 1,

    /// <summary>
    /// Transformation magic focused on changing properties.
    /// Spells that alter physical attributes, environments, or states.
    /// </summary>
    Alteration = 2,

    /// <summary>
    /// Knowledge and perception magic focused on information.
    /// Spells that reveal hidden things, predict outcomes, or detect threats.
    /// </summary>
    Divination = 3
}
```

**School Definitions:**
- Destruction (0): Offensive damage spells (fire, ice, lightning)
- Restoration (1): Healing and protective magic
- Alteration (2): Transformation and manipulation spells
- Divination (3): Knowledge and perception magic

---

#### `SpellTargetType.cs`

```csharp
public enum SpellTargetType
{
    Self = 0,          // Caster only (self-buffs, personal shields)
    SingleEnemy = 1,   // One hostile target (standard offensive targeting)
    SingleAlly = 2,    // One friendly target (targeted healing, buffs)
    AllEnemies = 3,    // All hostile entities (mass damage/debuff)
    AllAllies = 4,     // All friendly entities (mass healing/buff)
    SingleAny = 5,     // Any single target regardless of allegiance (utility spells)
    Area = 6           // Zone/area of effect (positioning-based)
}
```

**Target Type Classifications:**
- Self (0): Caster-only effects
- SingleEnemy (1): Standard single-target offense
- SingleAlly (2): Targeted support
- AllEnemies (3): AoE damage/debuffs
- AllAllies (4): AoE healing/buffs
- SingleAny (5): Flexible targeting
- Area (6): Spatial zone targeting

---

#### `SpellRange.cs`

```csharp
public enum SpellRange
{
    Self = 0,    // No range, affects caster only
    Touch = 1,   // Physical contact required (adjacent)
    Close = 2,   // Nearby targets within arm's reach
    Medium = 3,  // Standard combat range (most spells)
    Far = 4      // Distant targets across battlefield
}
```

**Range Categories:**
- Self (0): No range component
- Touch (1): Requires adjacency/contact
- Close (2): Short-range combat spells
- Medium (3): Standard combat distance
- Far (4): Long-range attacks/reconnaissance

---

### Entities

#### `Spell.cs`

**Properties (17 total, organized into 8 regions):**

##### Identity Region

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `Id` | `Guid` | `Guid.NewGuid()` | Unique identifier for the spell |
| `Name` | `string` | `string.Empty` | Display name (unique per database constraint) |
| `Description` | `string` | `string.Empty` | Effect description in AAM-VOICE Layer 2 style |

##### Classification Region

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `School` | `SpellSchool` | `Destruction` | Magical school affiliation |
| `TargetType` | `SpellTargetType` | `SingleEnemy` | Valid targeting configuration |
| `Range` | `SpellRange` | `Medium` | Effective casting range |

##### Costs Region

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `ApCost` | `int` | `2` | Action Point cost to cast |
| `FluxCost` | `int` | `5` | Flux added to environment when cast (v0.4.3a integration) |

##### Power Region

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `BasePower` | `int` | `10` | Base power for damage/healing calculations (modified by attributes/equipment) |
| `EffectScript` | `string?` | `null` | Script identifier for SpellEffectSystem (v0.4.3c planned) |

##### Casting Mechanics Region

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `ChargeTurns` | `int` | `0` | Turns required to charge before casting (0 = instant) |
| `TelegraphMessage` | `string?` | `null` | Message displayed when spell begins charging (combat telegraph) |
| `RequiresConcentration` | `bool` | `false` | Whether spell ends on damage/casting another spell |

##### Requirements Region

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `Tier` | `int` | `1` | Minimum tier to learn (1=novice, 2=apprentice, 3=journeyman, 4=master) |
| `Archetype` | `ArchetypeType?` | `null` | Required archetype (null = any archetype can learn) |

##### Metadata Region

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `CreatedAt` | `DateTime` | `DateTime.UtcNow` | Creation timestamp |
| `LastModified` | `DateTime` | `DateTime.UtcNow` | Last modification timestamp |

##### Computed Properties Region

| Property | Type | Logic |
|----------|------|-------|
| `IsInstantCast` | `bool` | `ChargeTurns == 0` |
| `IsChargedSpell` | `bool` | `ChargeTurns > 0` |
| `IsArchetypeRestricted` | `bool` | `Archetype.HasValue` |
| `TotalCost` | `int` | `ApCost + FluxCost` |

**Key Design Decisions:**
- FluxCost property integrates with AetherService from v0.4.3a
- Nullable EffectScript allows spells without scripted effects (basic damage/healing)
- Nullable TelegraphMessage only required for charged spells
- Tier system aligns with character progression (1-4 scale)
- Computed properties ignored by EF Core to prevent database column creation

---

### Interfaces

#### `ISpellRepository.cs`

**Method Signatures:**

```csharp
Task<IEnumerable<Spell>> GetBySchoolAsync(SpellSchool school);
```
- Retrieves all spells in a specific magical school
- Use case: Displaying school-specific spell lists in UI

```csharp
Task<IEnumerable<Spell>> GetByTargetTypeAsync(SpellTargetType targetType);
```
- Retrieves all spells with a specific target type
- Use case: AI spell selection based on combat scenario (single target vs AoE)

```csharp
Task<IEnumerable<Spell>> GetByMaxTierAsync(int maxTier);
```
- Retrieves all spells at or below specified tier (inclusive)
- Use case: Filtering spells available to character based on level/tier

```csharp
Task<IEnumerable<Spell>> GetByArchetypeAsync(ArchetypeType archetype);
```
- Retrieves spells with no archetype restriction OR matching archetype
- Logic: `WHERE Archetype IS NULL OR Archetype = @archetype`
- Use case: Character spell list filtering

```csharp
Task<Spell?> GetByNameAsync(string name);
```
- Case-insensitive name search with whitespace trimming
- Returns null if not found
- Use case: Spell lookup by player-typed name

```csharp
Task<IEnumerable<Spell>> GetChargedSpellsAsync();
```
- Retrieves spells with ChargeTurns > 0
- Use case: Telegraph system, charged spell UI indicators

```csharp
Task<IEnumerable<Spell>> GetInstantSpellsAsync();
```
- Retrieves spells with ChargeTurns == 0
- Use case: Quick-cast spell filtering

```csharp
Task<IEnumerable<Spell>> GetConcentrationSpellsAsync();
```
- Retrieves spells with RequiresConcentration == true
- Use case: Concentration tracking, spell interruption logic

```csharp
Task<IEnumerable<Spell>> GetByRangeAsync(SpellRange range);
```
- Retrieves spells within specified range category
- Use case: Range-based spell filtering for positioning logic

```csharp
Task AddRangeAsync(IEnumerable<Spell> spells);
```
- Bulk insert operation for seeding spell database
- Use case: Loading spell definitions from migration/seed data

---

### Repositories

#### `SpellRepository.cs`

**Constructor Dependencies:**
- `RuneAndRustDbContext context` (database access)
- `ILogger<GenericRepository<Spell>> logger` (base class logger)
- `ILogger<SpellRepository> spellLogger` (spell-specific logger)

**Query Optimization Patterns:**

GetBySchoolAsync ordering:
```csharp
.OrderBy(s => s.Tier)
.ThenBy(s => s.Name)
```
**Rationale:** Tier-based grouping with alphabetical secondary sort

GetByTargetTypeAsync ordering:
```csharp
.OrderBy(s => s.Name)
```
**Rationale:** Simple alphabetical sort for UI display

GetByMaxTierAsync ordering:
```csharp
.OrderBy(s => s.Tier)
.ThenBy(s => s.Name)
```
**Rationale:** Tier progression with alphabetical secondary sort

GetByArchetypeAsync ordering:
```csharp
.OrderBy(s => s.Tier)
.ThenBy(s => s.Name)
```
**Rationale:** Tier-based progression for character spell unlocks

GetChargedSpellsAsync ordering:
```csharp
.OrderBy(s => s.ChargeTurns)
.ThenBy(s => s.Name)
```
**Rationale:** Grouped by charge duration (fastest to slowest)

GetInstantSpellsAsync ordering:
```csharp
.OrderBy(s => s.Name)
```
**Rationale:** Alphabetical for UI consistency

GetConcentrationSpellsAsync ordering:
```csharp
.OrderBy(s => s.Name)
```
**Rationale:** Alphabetical for concentration tracking UI

GetByRangeAsync ordering:
```csharp
.OrderBy(s => s.Name)
```
**Rationale:** Alphabetical for range-filtered lists

**GetByNameAsync Implementation:**
```csharp
var normalizedName = name.Trim().ToLowerInvariant();
var spell = await _dbSet
    .FirstOrDefaultAsync(s => s.Name.ToLower() == normalizedName);
```
**Defensive Programming:**
- Whitespace trimming prevents lookup failures from user input
- Case-insensitive comparison using ToLowerInvariant()
- Returns null instead of throwing on not found

**GetByArchetypeAsync Implementation:**
```csharp
.Where(s => s.Archetype == null || s.Archetype == archetype)
```
**Null-Safe Filtering:**
- Includes universal spells (Archetype == null)
- Includes archetype-specific spells matching parameter
- Excludes spells restricted to other archetypes

---

### Database Configuration

#### `RuneAndRustDbContext.cs` - Spell Entity Configuration

**Table Configuration:**
```csharp
entity.ToTable("Spells");
entity.HasKey(s => s.Id);
entity.HasIndex(s => s.Name).IsUnique();
```

**String Length Constraints:**
- Name: 100 characters (searchable, indexed)
- Description: 2000 characters (AAM-VOICE flavor text)
- EffectScript: 500 characters (script identifier)
- TelegraphMessage: 500 characters (combat telegraph)

**Enum Conversions:**
```csharp
entity.Property(s => s.School).HasConversion<int>().IsRequired();
entity.Property(s => s.TargetType).HasConversion<int>().IsRequired();
entity.Property(s => s.Range).HasConversion<int>().IsRequired();
entity.Property(s => s.Archetype).HasConversion<int?>();
```
**Rationale:** Store enums as integers for database efficiency and compatibility

**Computed Properties (Ignored):**
```csharp
entity.Ignore(s => s.IsInstantCast);
entity.Ignore(s => s.IsChargedSpell);
entity.Ignore(s => s.IsArchetypeRestricted);
entity.Ignore(s => s.TotalCost);
```
**Rationale:** Prevents EF Core from creating unnecessary columns for calculated values

**Performance Indexes:**
```csharp
entity.HasIndex(s => s.School);      // School-based queries
entity.HasIndex(s => s.TargetType);  // Target filtering
entity.HasIndex(s => s.Range);       // Range-based queries
entity.HasIndex(s => s.Tier);        // Tier filtering
entity.HasIndex(s => s.Archetype);   // Archetype filtering
```
**Rationale:** Optimize common query patterns for spell lookup and filtering

---

## Logging Matrix

### SpellRepository Logs

| Event | Level | Template |
|-------|-------|----------|
| GetBySchoolAsync query | Debug | `[Spell] Fetching spells in school {School}` |
| GetBySchoolAsync result | Debug | `[Spell] Retrieved {Count} spells in school {School}` |
| GetByTargetTypeAsync query | Debug | `[Spell] Fetching spells with target type {TargetType}` |
| GetByTargetTypeAsync result | Debug | `[Spell] Retrieved {Count} spells with target type {TargetType}` |
| GetByMaxTierAsync query | Debug | `[Spell] Fetching spells up to tier {MaxTier}` |
| GetByMaxTierAsync result | Debug | `[Spell] Retrieved {Count} spells up to tier {MaxTier}` |
| GetByArchetypeAsync query | Debug | `[Spell] Fetching spells available to archetype {Archetype}` |
| GetByArchetypeAsync result | Debug | `[Spell] Retrieved {Count} spells available to archetype {Archetype}` |
| GetByNameAsync query | Debug | `[Spell] Searching for spell by name '{SpellName}'` |
| GetByNameAsync not found | Debug | `[Spell] Spell '{SpellName}' not found` |
| GetByNameAsync found | Debug | `[Spell] Found spell '{SpellName}' ({SpellId})` |
| GetChargedSpellsAsync query | Debug | `[Spell] Fetching charged spells (ChargeTurns > 0)` |
| GetChargedSpellsAsync result | Debug | `[Spell] Retrieved {Count} charged spells` |
| GetInstantSpellsAsync query | Debug | `[Spell] Fetching instant spells (ChargeTurns == 0)` |
| GetInstantSpellsAsync result | Debug | `[Spell] Retrieved {Count} instant spells` |
| GetConcentrationSpellsAsync query | Debug | `[Spell] Fetching concentration spells` |
| GetConcentrationSpellsAsync result | Debug | `[Spell] Retrieved {Count} concentration spells` |
| GetByRangeAsync query | Debug | `[Spell] Fetching spells with range {Range}` |
| GetByRangeAsync result | Debug | `[Spell] Retrieved {Count} spells with range {Range}` |
| AddRangeAsync operation | Debug | `[Spell] Adding {Count} spells to database` |
| AddRangeAsync complete | Debug | `[Spell] Successfully added {Count} spells to context` |

---

## Test Coverage

### Test Summary

```
Total: 35 | Passed: 35 | Failed: 0 | Duration: 1000ms
```

### Complete Test Inventory

#### SpellRepositoryTests (35 tests)

##### GetAllAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetAllAsync_ReturnsAll` | Verifies GetAllAsync returns all 3 spells in database |
| `GetAllAsync_ReturnsEmpty_WhenNone` | Verifies empty collection returned when no spells exist |

##### GetByIdAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetByIdAsync_ReturnsSpell_WhenFound` | Verifies spell retrieval by Guid returns correct entity with Name="Fireball" |
| `GetByIdAsync_ReturnsNull_WhenNotFound` | Verifies null returned for non-existent Guid |

##### GetBySchoolAsync Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `GetBySchoolAsync_FiltersCorrectly` | Verifies only Destruction spells returned (2 of 3 spells), all have School=Destruction |
| `GetBySchoolAsync_ReturnsEmpty_WhenNoMatch` | Verifies empty collection when querying for Divination with only Destruction spells |
| `GetBySchoolAsync_OrdersByTierThenName` | Verifies ordering: tier 1 spells alphabetically, then tier 2 spells (Alpha Strike, Beta Strike, Zap) |

##### GetByTargetTypeAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetByTargetTypeAsync_FiltersCorrectly` | Verifies only SingleEnemy spells returned (2 of 3 spells) |
| `GetByTargetTypeAsync_ReturnsEmpty_WhenNoMatch` | Verifies empty collection when querying for AllEnemies with only SingleEnemy spells |

##### GetByMaxTierAsync Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `GetByMaxTierAsync_FiltersCorrectly` | Verifies spells with Tier <= 2 returned (excludes tier 4 spell), returns 2 of 3 spells |
| `GetByMaxTierAsync_ReturnsAll_WhenMaxTierHigh` | Verifies all spells returned when maxTier=10 (higher than any spell tier) |
| `GetByMaxTierAsync_OrdersByTierThenName` | Verifies ordering: tier 1 alphabetically (Alpha, Beta), then tier 2 (Zap) |

##### GetByArchetypeAsync Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `GetByArchetypeAsync_ReturnsUnrestrictedSpells` | Verifies Mystic query returns universal spell (Archetype=null) but excludes Warrior-only spell |
| `GetByArchetypeAsync_IncludesArchetypeSpecificSpells` | Verifies Warrior query returns both universal spell AND Warrior-only spell (2 of 2) |
| `GetByArchetypeAsync_ExcludesOtherArchetypeSpells` | Verifies Warrior query excludes Mystic-only and Skirmisher-only spells (returns 0) |

##### GetByNameAsync Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `GetByNameAsync_FindsExactMatch` | Verifies spell found with exact name "Fireball" |
| `GetByNameAsync_IsCaseInsensitive` | Verifies "FIREBALL" matches "Fireball" (case-insensitive search) |
| `GetByNameAsync_TrimsWhitespace` | Verifies "  Fireball  " matches "Fireball" (whitespace trimming) |
| `GetByNameAsync_ReturnsNull_WhenNotFound` | Verifies null returned when searching for "Ice Shard" with only "Fireball" in database |

##### GetChargedSpellsAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetChargedSpellsAsync_FiltersCorrectly` | Verifies only spells with ChargeTurns > 0 returned (2 of 3 spells) |
| `GetChargedSpellsAsync_OrdersByChargeTurns` | Verifies ordering by charge duration: Fast (1 turn), Medium (2 turns), Slow (3 turns) |

##### GetInstantSpellsAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetInstantSpellsAsync_FiltersCorrectly` | Verifies only spells with ChargeTurns == 0 returned (2 of 3 spells) |
| `GetInstantSpellsAsync_OrdersByName` | Verifies alphabetical ordering: Alpha before Zap |

##### GetConcentrationSpellsAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetConcentrationSpellsAsync_FiltersCorrectly` | Verifies only spells with RequiresConcentration=true returned (2 of 3 spells) |
| `GetConcentrationSpellsAsync_ReturnsEmpty_WhenNone` | Verifies empty collection when no concentration spells exist |

##### GetByRangeAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetByRangeAsync_FiltersCorrectly` | Verifies only Touch range spells returned (2 of 3 spells) |
| `GetByRangeAsync_ReturnsEmpty_WhenNoMatch` | Verifies empty collection when querying for Self range with only Far range spells |

##### AddRangeAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `AddRangeAsync_AddsMultipleSpells` | Verifies bulk insert of 3 spells results in database count of 3 |
| `AddRangeAsync_HandlesEmptyList` | Verifies empty array input results in database count of 0 (no exceptions thrown) |

##### CRUD Operations Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `AddAsync_AddsSpell` | Verifies single spell insert via AddAsync with Name="Fireball" |
| `UpdateAsync_UpdatesSpell` | Verifies spell BasePower updated from 10 to 50 via UpdateAsync |
| `DeleteAsync_RemovesSpell` | Verifies spell removed from database, FindAsync returns null after delete |
| `DeleteAsync_HandlesNonExistent` | Verifies deleting non-existent Guid does not throw exception |

##### Computed Properties Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `Spell_IsInstantCast_ComputedCorrectly` | Verifies IsInstantCast=true for ChargeTurns=0, false for ChargeTurns=2 |
| `Spell_TotalCost_ComputedCorrectly` | Verifies TotalCost computed as ApCost (3) + FluxCost (7) = 10 |

---

## DI Registration

### Program.cs (Terminal)

```csharp
// Register Spell Repository (v0.4.3b - The Grimoire)
services.AddScoped<ISpellRepository, SpellRepository>();
```

**Location:** Line 99, after Npc Repository registration
**Lifetime:** Scoped (repository lifetime aligned with request/command scope)
**Rationale:** Scoped lifetime provides database context per operation while allowing shared context within transaction boundaries

---

## Verification Results

### Build Output

```
Build succeeded.
    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:02.76
```

**Note:** MSB3277 warning regarding EntityFrameworkCore.Relational version conflict is pre-existing and unrelated to this release. Version 9.0.1.0 chosen over 9.0.4.0 due to test project reference priority.

### Test Output

**SpellRepositoryTests:**
```
Passed!  - Failed:     0, Passed:    35, Skipped:     0, Total:    35, Duration: 1 s
```

**All 35 tests passed with no failures:**
- GetAllAsync: 2/2 passed
- GetByIdAsync: 2/2 passed
- GetBySchoolAsync: 3/3 passed
- GetByTargetTypeAsync: 2/2 passed
- GetByMaxTierAsync: 3/3 passed
- GetByArchetypeAsync: 3/3 passed
- GetByNameAsync: 4/4 passed
- GetChargedSpellsAsync: 2/2 passed
- GetInstantSpellsAsync: 2/2 passed
- GetConcentrationSpellsAsync: 2/2 passed
- GetByRangeAsync: 2/2 passed
- AddRangeAsync: 2/2 passed
- CRUD Operations: 4/4 passed
- Computed Properties: 2/2 passed

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   ├── Spell.cs [NEW]
│   └── (existing entities...)
├── Enums/
│   ├── SpellSchool.cs [NEW]
│   ├── SpellTargetType.cs [NEW]
│   ├── SpellRange.cs [NEW]
│   └── (existing enums...)
└── Interfaces/
    ├── ISpellRepository.cs [NEW]
    └── (existing interfaces...)

RuneAndRust.Persistence/
├── Data/
│   └── RuneAndRustDbContext.cs [MODIFIED]
└── Repositories/
    ├── SpellRepository.cs [NEW]
    └── (existing repositories...)

RuneAndRust.Terminal/
├── Program.cs [MODIFIED]
└── (existing files...)

RuneAndRust.Tests/
└── Persistence/
    ├── SpellRepositoryTests.cs [NEW]
    └── (existing persistence tests...)

docs/changelogs/v0.4.x/
├── v0.4.3a.md
├── v0.4.3b.md [NEW]
└── (existing changelogs...)
```

---

## Running Tests

### Run SpellRepository Tests Only

```bash
dotnet test --filter "FullyQualifiedName~SpellRepositoryTests"
```

**Expected Output:**
```
Passed!  - Failed:     0, Passed:    35, Skipped:     0, Total:    35
```

### Run All Persistence Repository Tests

```bash
dotnet test --filter "FullyQualifiedName~Persistence"
```

### Run Spell-Related Integration Tests (When Implemented)

```bash
dotnet test --filter "FullyQualifiedName~Spell"
```

---

## Next Steps

The following work is planned for subsequent releases:

1. **v0.4.3c: Spell Effect System**
   - Implement SpellEffectService to execute EffectScript references
   - Create SpellEffect model with damage/healing/status effect definitions
   - Add scripted spell effects (e.g., "DealFireDamage", "HealTarget", "ApplyBurning")
   - Integrate with CombatService for spell casting execution
   - Add spell effect resolution to combat log

2. **v0.4.3d: Spell Learning System**
   - Implement ISpellbookService for character spell management
   - Create CharacterSpell junction table for learned spells
   - Add spell learning UI in character progression screen
   - Implement tier/archetype restriction enforcement
   - Add Progression Point cost for spell unlocks

3. **v0.4.3e: Charged Spell Mechanics**
   - Implement spell charging system in CombatService
   - Add ChargeState tracking in combat state
   - Create telegraph system for enemy charged spells
   - Add UI indicators for charging spells
   - Implement charge interruption on damage (concentration spells)

4. **v0.4.4: Spell Seed Data**
   - Create V[#]__SeedSpells.sql migration script
   - Define 20-30 core spells across all schools
   - Write AAM-VOICE compliant spell descriptions (Domain 4)
   - Balance spell costs, power, tiers for progression curve
   - Assign archetype restrictions for unique class identity

5. **v0.4.5: Spell UI Integration**
   - Add SpellbookScreen for browsing learned spells
   - Implement spell selection in combat UI
   - Add spell casting command to CombatCommands
   - Display flux cost and environmental warnings
   - Implement spell range/target validation UI

---

## Design Decisions & Rationale

### Scoped Repository Lifetime

**Decision:** Register SpellRepository as Scoped
**Rationale:** Aligns with repository pattern best practices. Scoped lifetime ensures each command/request gets its own database context while allowing multiple repository calls to share the same context within a transaction boundary. Prevents context sharing issues in long-running operations.

### Unique Name Constraint

**Decision:** Add unique index on Spell.Name
**Rationale:** Spell names serve as natural keys for player-facing lookup ("cast Fireball"). Unique constraint prevents duplicate spell definitions and enables efficient case-insensitive name search without requiring Guid lookups. Simplifies spell reference in content scripting.

### Nullable EffectScript Property

**Decision:** Make EffectScript nullable with no default value
**Rationale:** Allows simple spells (basic damage/healing) to omit scripting until SpellEffectService is implemented (v0.4.3c). Prevents empty string clutter in database. Nullable design enables future deprecation of unscripted spells without schema migration.

### Enum-to-Int Conversion

**Decision:** Store enums as integers in database
**Rationale:** Ensures database compatibility across providers (PostgreSQL, SQLite, InMemory). Improves query performance for indexed enum columns. Maintains human-readable enum names in C# code while leveraging integer efficiency in database layer. Prevents string-based enum storage fragility.

### Computed Properties Ignored by EF Core

**Decision:** Ignore IsInstantCast, IsChargedSpell, IsArchetypeRestricted, TotalCost
**Rationale:** Prevents redundant database columns for derived values. Reduces schema complexity and eliminates synchronization bugs between computed properties and stored values. Values can be calculated on-demand from source properties (ChargeTurns, Archetype, ApCost, FluxCost).

### Case-Insensitive Name Search

**Decision:** Implement ToLowerInvariant() normalization in GetByNameAsync
**Rationale:** Improves player UX by accepting "fireball", "Fireball", "FIREBALL" as equivalent inputs. Whitespace trimming handles copy-paste errors and trailing spaces from user input. Culture-invariant comparison ensures consistent behavior across locales.

### Archetype Null-Safe Filtering

**Decision:** Use `WHERE Archetype IS NULL OR Archetype = @archetype` in GetByArchetypeAsync
**Rationale:** Universal spells (Archetype=null) should be available to all archetypes. Explicit null check prevents archetype-restricted spells from leaking to other archetypes. Simplifies seed data by allowing single spell definition for multi-archetype availability.

### FluxCost Property Integration

**Decision:** Add FluxCost property connecting to v0.4.3a AetherService
**Rationale:** Establishes data layer foundation for flux accumulation during spellcasting. Enables future SpellCastingService to call `_aetherService.AddFlux(spell.FluxCost)` without schema changes. Supports flux-based spell balancing (higher flux = higher environmental risk).

### Tier-Based Query Ordering

**Decision:** OrderBy Tier, ThenBy Name in school/archetype queries
**Rationale:** Presents spells in progression order (novice → master) with alphabetical secondary sort. Improves UI presentation by grouping spells by power level. Aligns with player mental model of spell progression.

### [Spell] Logging Prefix

**Decision:** Use `[Spell]` prefix for all SpellRepository log messages
**Rationale:** Enables easy log filtering with `grep "[Spell]"` for debugging spell-related queries. Maintains consistency with other repository logging patterns (`[Aether]`, `[Combat]`). Improves log readability in multi-system operations.

### Performance Index Strategy

**Decision:** Create indexes on School, TargetType, Range, Tier, Archetype
**Rationale:** Optimizes most common query patterns identified in repository interface. School/Tier/Archetype indexes support character spell list filtering. TargetType/Range indexes support AI spell selection logic. Index overhead justified by expected read-heavy workload (spells queried far more than modified).

---

**End of Changelog v0.4.3b**
