# v0.15.0b Design Specification: Seeded Random Provider

**Version:** 0.15.0b
**Theme:** Seeded Random Provider
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0a Complete (Core Dice Mechanics Refactor)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [IRandomProvider Interface](#4-irandomprovider-interface)
5. [RngContext Enum](#5-rngcontext-enum)
6. [SeededRandomProvider Implementation](#6-seededrandomprovider-implementation)
7. [IRngContextService Interface](#7-irngcontextservice-interface)
8. [RngContextService Implementation](#8-rngcontextservice-implementation)
9. [DiceService Integration](#9-diceservice-integration)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration](#11-configuration)
12. [Commands](#12-commands)
13. [User-Facing Changes](#13-user-facing-changes)
14. [Logging Specifications](#14-logging-specifications)
15. [Unit Testing Requirements](#15-unit-testing-requirements)
16. [Use Cases](#16-use-cases)
17. [Deliverable Checklist](#17-deliverable-checklist)
18. [Acceptance Criteria](#18-acceptance-criteria)
19. [Future Considerations](#19-future-considerations)
20. [Implementation Notes](#20-implementation-notes)
21. [Document Metadata](#21-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.0b, the Seeded Random Provider. This part introduces a testable, deterministic random number generation system that supports context-aware seeding for different game scenarios. The seeded RNG enables reproducible dice rolls for testing, debugging, and specific gameplay scenarios where determinism is required (e.g., locked seeds during combat encounters).

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **RNG Source** | Basic `System.Random` instance | `IRandomProvider` abstraction |
| **Seeding** | Random or single seed via constructor | Dynamic seeding with `SetSeed()`, `SaveState()`, `RestoreState()` |
| **Context Awareness** | None | `RngContext` enum for Combat, Exploration, Crafting, Dialogue |
| **State Management** | No state persistence | Save/restore RNG state for replay |
| **Testability** | Seeded Random in constructor | Full interface abstraction for mocking |
| **Batch Generation** | Individual `Next()` calls | `NextMany()` for efficient batch generation |

### 1.3 Scope

**In Scope:**
- `IRandomProvider` interface definition
- `RngContext` enum with five context types
- `SeededRandomProvider` implementation
- `IRngContextService` interface for context management
- `RngContextService` implementation
- Update `DiceService` to use `IRandomProvider`
- Unit tests for seeded RNG behavior (~6 tests)

**Out of Scope:**
- Skill check refactor - v0.15.0c
- Contested and extended checks - v0.15.0d
- Dice roll logging infrastructure - v0.15.0e
- Combat integration - v0.15.0f
- Persistent seed storage (database/file) - Future version
- Cryptographic RNG for security-sensitive operations - Not required

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Interfaces | 2 | `IRandomProvider`, `IRngContextService` |
| Enums | 1 | `RngContext` |
| Services | 2 | `SeededRandomProvider`, `RngContextService` |
| Service Updates | 1 | `DiceService` (refactored to use `IRandomProvider`) |
| Unit Tests | ~6 | Seeding, determinism, state save/restore, context |

---

## 2. Dependencies

### 2.1 Required from v0.15.0a

| Component | Location | Usage in v0.15.0b |
|-----------|----------|-------------------|
| `DiceService` | `Application/Services/DiceService.cs` | Refactor to use `IRandomProvider` |
| `DiceConstants` | `Domain/Constants/DiceConstants.cs` | Reference for D10 min/max values |
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Return type unchanged |

### 2.2 Current DiceService Random Usage

```csharp
// Current DiceService implementation
public class DiceService : IDiceService
{
    private readonly Random _random;

    public DiceService(ILogger<DiceService> logger, Random? random = null)
    {
        _random = random ?? new Random();
    }

    private int RollSingleDie(int faces) => _random.Next(1, faces + 1);
}
```

### 2.3 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.0c | `SkillCheckService` | Context-aware seeding for skill checks |
| v0.15.0e | `DiceRollLogger` | Logs seed values for roll replay |
| v0.15.0f | `CombatService` | Locked seeds during combat encounters |

---

## 3. Architecture Diagrams

### 3.1 IRandomProvider Integration Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    IRandomProvider INTEGRATION FLOW                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DI CONTAINER (Startup)                          │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  services.AddSingleton<IRandomProvider, SeededRandomProvider>();    │    │
│  │  services.AddSingleton<IRngContextService, RngContextService>();    │    │
│  │  services.AddScoped<IDiceService, DiceService>();                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ resolves                                  │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        DiceService                                   │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  private readonly IRandomProvider _randomProvider;                  │    │
│  │                                                                      │    │
│  │  public DiceService(IRandomProvider randomProvider, ...)            │    │
│  │  {                                                                   │    │
│  │      _randomProvider = randomProvider;                              │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  │  private int RollSingleDie(int faces)                               │    │
│  │      => _randomProvider.Next(1, faces + 1);                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    SeededRandomProvider                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  private Random _random;                                            │    │
│  │  private int _currentSeed;                                          │    │
│  │  private int _savedSeed;                                            │    │
│  │                                                                      │    │
│  │  Next(min, max) → _random.Next(min, max)                            │    │
│  │  SetSeed(seed) → _random = new Random(seed)                         │    │
│  │  SaveState()   → _savedSeed = _currentSeed                          │    │
│  │  RestoreState() → SetSeed(_savedSeed)                               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Context-Aware Seeding Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     CONTEXT-AWARE SEEDING FLOW                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  COMBAT SCENARIO: Player enters combat encounter                             │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  1. CombatService.StartEncounter()                                   │    │
│  │                                                                      │    │
│  │     _rngContextService.EnterContext(RngContext.Combat);             │    │
│  │     _rngContextService.LockSeedForContext(RngContext.Combat, seed); │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  2. RngContextService.EnterContext(Combat)                          │    │
│  │                                                                      │    │
│  │     _contextStack.Push(RngContext.Combat);                          │    │
│  │     _randomProvider.SetSeed(lockedSeed);                            │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  3. During Combat: All rolls use locked seed                        │    │
│  │                                                                      │    │
│  │     Player attacks → DiceService.Roll() → Same sequence each time   │    │
│  │                                                                      │    │
│  │     This prevents save-scumming during combat!                      │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  4. Combat ends: Exit context                                        │    │
│  │                                                                      │    │
│  │     _rngContextService.ExitContext();                               │    │
│  │     _rngContextService.ReleaseSeedLock(RngContext.Combat);          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  EXPLORATION SCENARIO: Player explores dungeon                               │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  - RngContext.Exploration                                            │    │
│  │  - Fresh seed on each load (allows retry on reload)                 │    │
│  │  - Trap detection rolls, loot rolls, random encounters              │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Save/Restore State Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       SAVE/RESTORE STATE FLOW                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  UNIT TEST SCENARIO: Testing specific roll sequence                          │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  // Arrange                                                          │    │
│  │  var provider = new SeededRandomProvider(42);                       │    │
│  │  provider.SaveState();                                              │    │
│  │                                                                      │    │
│  │  _currentSeed: 42                                                   │    │
│  │  _savedSeed: 42                                                     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  // Act - Generate some values                                       │    │
│  │  var roll1 = provider.Next(1, 11);  // e.g., 7                      │    │
│  │  var roll2 = provider.Next(1, 11);  // e.g., 3                      │    │
│  │  var roll3 = provider.Next(1, 11);  // e.g., 9                      │    │
│  │                                                                      │    │
│  │  // Internal Random state has advanced                              │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  // Restore - Reset to saved state                                   │    │
│  │  provider.RestoreState();                                           │    │
│  │                                                                      │    │
│  │  // Creates new Random(42), same sequence                           │    │
│  │  _currentSeed: 42  (restored)                                       │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  // Assert - Same sequence reproduced                                │    │
│  │  var roll1Again = provider.Next(1, 11);  // 7 (same!)               │    │
│  │  var roll2Again = provider.Next(1, 11);  // 3 (same!)               │    │
│  │  var roll3Again = provider.Next(1, 11);  // 9 (same!)               │    │
│  │                                                                      │    │
│  │  Assert.That(roll1Again, Is.EqualTo(roll1)); // PASS                │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Interfaces/                                                         │    │
│  │  ├── IRandomProvider.cs         ←── NEW                             │    │
│  │  └── IRngContextService.cs      ←── NEW                             │    │
│  │                                                                      │    │
│  │  Enums/                                                              │    │
│  │  └── RngContext.cs              ←── NEW                             │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ implements                                │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Services/                                                           │    │
│  │  ├── SeededRandomProvider.cs    ←── NEW                             │    │
│  │  ├── RngContextService.cs       ←── NEW                             │    │
│  │  └── DiceService.cs             ←── MODIFIED (uses IRandomProvider) │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. IRandomProvider Interface

### 4.1 Interface Definition

**File:** `src/Core/RuneAndRust.Domain/Interfaces/IRandomProvider.cs`

```csharp
namespace RuneAndRust.Domain.Interfaces;

/// <summary>
/// Provides random number generation with seeding and state management capabilities.
/// </summary>
/// <remarks>
/// <para>
/// This interface abstracts random number generation to enable:
/// <list type="bullet">
///   <item><description>Deterministic testing with known seeds</description></item>
///   <item><description>Reproducible gameplay sequences for debugging</description></item>
///   <item><description>Context-aware seeding (combat vs. exploration)</description></item>
///   <item><description>Save/restore state for roll replay</description></item>
/// </list>
/// </para>
/// <para>
/// Implementation note: The state save/restore mechanism saves the seed value,
/// not the internal Random state. Restoring recreates a new Random with the
/// saved seed, which produces the same sequence from the beginning.
/// </para>
/// </remarks>
public interface IRandomProvider
{
    /// <summary>
    /// Returns a random integer within the specified range.
    /// </summary>
    /// <param name="minInclusive">The inclusive lower bound of the random number.</param>
    /// <param name="maxExclusive">The exclusive upper bound of the random number.</param>
    /// <returns>A random integer where minInclusive ≤ value &lt; maxExclusive.</returns>
    /// <remarks>
    /// Follows the standard .NET Random.Next() convention:
    /// <list type="bullet">
    ///   <item><description>minInclusive is included in the range</description></item>
    ///   <item><description>maxExclusive is excluded from the range</description></item>
    /// </list>
    /// For dice rolls: Next(1, 11) returns 1-10 inclusive.
    /// </remarks>
    /// <example>
    /// <code>
    /// var d10Roll = provider.Next(1, 11);  // Returns 1-10
    /// var d6Roll = provider.Next(1, 7);    // Returns 1-6
    /// </code>
    /// </example>
    int Next(int minInclusive, int maxExclusive);

    /// <summary>
    /// Returns multiple random integers within the specified range.
    /// </summary>
    /// <param name="count">The number of random values to generate.</param>
    /// <param name="minInclusive">The inclusive lower bound of each random number.</param>
    /// <param name="maxExclusive">The exclusive upper bound of each random number.</param>
    /// <returns>An array of random integers.</returns>
    /// <remarks>
    /// More efficient than calling Next() multiple times when generating
    /// dice pool results. The sequence is deterministic for a given seed.
    /// </remarks>
    /// <exception cref="ArgumentOutOfRangeException">
    /// Thrown when count is negative.
    /// </exception>
    /// <example>
    /// <code>
    /// // Roll 5d10 in one call
    /// var diceRolls = provider.NextMany(5, 1, 11);
    /// </code>
    /// </example>
    int[] NextMany(int count, int minInclusive, int maxExclusive);

    /// <summary>
    /// Sets the seed for the random number generator.
    /// </summary>
    /// <param name="seed">The seed value to use.</param>
    /// <remarks>
    /// <para>
    /// Setting a seed resets the RNG to produce a deterministic sequence.
    /// The same seed always produces the same sequence of numbers.
    /// </para>
    /// <para>
    /// Use cases:
    /// <list type="bullet">
    ///   <item><description>Testing: Set known seed for predictable results</description></item>
    ///   <item><description>Combat: Lock seed to prevent save-scumming</description></item>
    ///   <item><description>Replay: Recreate exact roll sequences</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    void SetSeed(int seed);

    /// <summary>
    /// Gets the current seed value.
    /// </summary>
    /// <returns>The seed that was used to initialize the current RNG state.</returns>
    /// <remarks>
    /// This returns the seed that was set via constructor or SetSeed(),
    /// not a representation of the current internal state.
    /// </remarks>
    int GetCurrentSeed();

    /// <summary>
    /// Saves the current RNG state for later restoration.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Saves the current seed value so that RestoreState() can recreate
    /// the same sequence. Only one state can be saved at a time;
    /// calling SaveState() again overwrites the previous saved state.
    /// </para>
    /// <para>
    /// Note: This saves the seed, not the exact internal state.
    /// Restoring will replay the sequence from the beginning.
    /// </para>
    /// </remarks>
    void SaveState();

    /// <summary>
    /// Restores the RNG to the previously saved state.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Recreates the RNG with the saved seed, allowing the same
    /// sequence of numbers to be generated again.
    /// </para>
    /// <para>
    /// If SaveState() was never called, this may restore to the
    /// initial seed (implementation-defined) or throw an exception.
    /// </para>
    /// </remarks>
    /// <exception cref="InvalidOperationException">
    /// May be thrown if no state was previously saved (implementation-defined).
    /// </exception>
    void RestoreState();
}
```

### 4.2 Interface Method Summary

| Method | Parameters | Returns | Purpose |
|--------|------------|---------|---------|
| `Next` | `minInclusive`, `maxExclusive` | `int` | Single random value |
| `NextMany` | `count`, `minInclusive`, `maxExclusive` | `int[]` | Batch random values |
| `SetSeed` | `seed` | `void` | Reset RNG with seed |
| `GetCurrentSeed` | none | `int` | Get current seed value |
| `SaveState` | none | `void` | Save seed for restore |
| `RestoreState` | none | `void` | Restore saved seed |

---

## 5. RngContext Enum

### 5.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/RngContext.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the gameplay context for random number generation seeding behavior.
/// </summary>
/// <remarks>
/// <para>
/// Different game contexts have different seeding requirements:
/// <list type="bullet">
///   <item><description>Combat: Locked seed prevents save-scumming during fights</description></item>
///   <item><description>Exploration: Fresh seed on load allows retry on reload</description></item>
///   <item><description>Crafting: Locked seed per session for fair crafting</description></item>
///   <item><description>Dialogue: Fresh seed for varied conversation outcomes</description></item>
/// </list>
/// </para>
/// <para>
/// The context determines whether seeds are locked (deterministic within session)
/// or fresh (randomized on game load).
/// </para>
/// </remarks>
public enum RngContext
{
    /// <summary>
    /// Combat encounters with locked seed per encounter.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Seed is locked when combat begins and remains constant until combat ends.
    /// This prevents players from save-scumming to get better attack rolls.
    /// </para>
    /// <para>
    /// Reloading a save during combat produces the same roll sequence.
    /// </para>
    /// </remarks>
    Combat,

    /// <summary>
    /// Exploration and dungeon traversal with fresh seed on load.
    /// </summary>
    /// <remarks>
    /// <para>
    /// A new random seed is generated each time the game loads.
    /// This allows players to retry trap checks, random encounters,
    /// and loot rolls by reloading a save.
    /// </para>
    /// <para>
    /// Provides a more forgiving experience for exploration mistakes.
    /// </para>
    /// </remarks>
    Exploration,

    /// <summary>
    /// Crafting and item creation with locked seed per session.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Seed is locked when a crafting session begins. Quality rolls,
    /// bonus attribute rolls, and success chances are deterministic.
    /// </para>
    /// <para>
    /// Prevents save-scumming for perfect crafting results while
    /// still allowing different outcomes between sessions.
    /// </para>
    /// </remarks>
    Crafting,

    /// <summary>
    /// Dialogue and social interactions with fresh seed on load.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Fresh seed allows varied dialogue outcomes on reload.
    /// Persuasion checks, deception rolls, and NPC reactions
    /// can differ each attempt.
    /// </para>
    /// <para>
    /// Provides a more narrative-friendly experience where
    /// conversation replays feel natural.
    /// </para>
    /// </remarks>
    Dialogue,

    /// <summary>
    /// Default context when no specific context is active.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Uses the current active context's seeding behavior.
    /// If no context is active, behaves like Exploration (fresh seed).
    /// </para>
    /// <para>
    /// Used as a fallback when context is not explicitly specified.
    /// </para>
    /// </remarks>
    Default
}
```

### 5.2 Context Behavior Summary

| Context | Seed Behavior | Reload Behavior | Use Case |
|---------|--------------|-----------------|----------|
| `Combat` | Locked per encounter | Same sequence | Attack rolls, defense, damage |
| `Exploration` | Fresh on load | Different sequence | Trap checks, loot, encounters |
| `Crafting` | Locked per session | Same sequence | Quality rolls, bonus chances |
| `Dialogue` | Fresh on load | Different sequence | Persuasion, deception, reactions |
| `Default` | Inherits active | Varies | Fallback when unspecified |

---

## 6. SeededRandomProvider Implementation

### 6.1 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/SeededRandomProvider.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Provides seeded random number generation with state save/restore capability.
/// </summary>
/// <remarks>
/// <para>
/// This implementation wraps <see cref="System.Random"/> with seed management,
/// enabling deterministic sequences for testing and gameplay scenarios.
/// </para>
/// <para>
/// Thread Safety: This class is NOT thread-safe. If used across threads,
/// external synchronization is required, or use separate instances per thread.
/// </para>
/// </remarks>
public class SeededRandomProvider : IRandomProvider
{
    private Random _random;
    private int _currentSeed;
    private int _savedSeed;
    private bool _hasSavedState;
    private readonly ILogger<SeededRandomProvider>? _logger;

    /// <summary>
    /// Creates a new SeededRandomProvider with an optional initial seed.
    /// </summary>
    /// <param name="initialSeed">
    /// The seed to use. If null, generates a seed from current time.
    /// </param>
    /// <param name="logger">Optional logger for diagnostics.</param>
    public SeededRandomProvider(int? initialSeed = null, ILogger<SeededRandomProvider>? logger = null)
    {
        _logger = logger;
        _currentSeed = initialSeed ?? GenerateTimeSeed();
        _random = new Random(_currentSeed);
        _savedSeed = _currentSeed;
        _hasSavedState = false;

        _logger?.LogDebug("SeededRandomProvider initialized with seed {Seed}", _currentSeed);
    }

    /// <inheritdoc />
    public int Next(int minInclusive, int maxExclusive)
    {
        if (minInclusive >= maxExclusive)
        {
            throw new ArgumentOutOfRangeException(
                nameof(maxExclusive),
                $"maxExclusive ({maxExclusive}) must be greater than minInclusive ({minInclusive})");
        }

        var result = _random.Next(minInclusive, maxExclusive);

        _logger?.LogTrace(
            "Next({Min}, {Max}) = {Result} (seed: {Seed})",
            minInclusive, maxExclusive, result, _currentSeed);

        return result;
    }

    /// <inheritdoc />
    public int[] NextMany(int count, int minInclusive, int maxExclusive)
    {
        if (count < 0)
        {
            throw new ArgumentOutOfRangeException(
                nameof(count),
                $"count ({count}) must be non-negative");
        }

        if (minInclusive >= maxExclusive)
        {
            throw new ArgumentOutOfRangeException(
                nameof(maxExclusive),
                $"maxExclusive ({maxExclusive}) must be greater than minInclusive ({minInclusive})");
        }

        if (count == 0)
        {
            return Array.Empty<int>();
        }

        var results = new int[count];
        for (var i = 0; i < count; i++)
        {
            results[i] = _random.Next(minInclusive, maxExclusive);
        }

        _logger?.LogTrace(
            "NextMany({Count}, {Min}, {Max}) = [{Results}] (seed: {Seed})",
            count, minInclusive, maxExclusive, string.Join(", ", results), _currentSeed);

        return results;
    }

    /// <inheritdoc />
    public void SetSeed(int seed)
    {
        _logger?.LogDebug("Setting seed from {OldSeed} to {NewSeed}", _currentSeed, seed);

        _currentSeed = seed;
        _random = new Random(seed);
    }

    /// <inheritdoc />
    public int GetCurrentSeed() => _currentSeed;

    /// <inheritdoc />
    public void SaveState()
    {
        _savedSeed = _currentSeed;
        _hasSavedState = true;

        _logger?.LogDebug("Saved RNG state with seed {Seed}", _savedSeed);
    }

    /// <inheritdoc />
    public void RestoreState()
    {
        if (!_hasSavedState)
        {
            _logger?.LogWarning("RestoreState called without prior SaveState; using initial seed");
        }

        _logger?.LogDebug("Restoring RNG state from seed {Seed}", _savedSeed);

        SetSeed(_savedSeed);
    }

    /// <summary>
    /// Generates a seed based on current UTC time.
    /// </summary>
    /// <returns>A seed value derived from the current time.</returns>
    private static int GenerateTimeSeed()
    {
        return (int)(DateTime.UtcNow.Ticks % int.MaxValue);
    }
}
```

### 6.2 Implementation Notes

| Aspect | Design Decision | Rationale |
|--------|-----------------|-----------|
| **State Storage** | Stores seed, not internal Random state | .NET Random doesn't expose state; recreating from seed is deterministic |
| **Thread Safety** | Not thread-safe | Game logic typically runs on single thread; external sync if needed |
| **Null Seed** | Generate from time | Provides randomness when seed not specified |
| **Empty Count** | Returns empty array | Consistent with no-op behavior |
| **Range Validation** | Throws on invalid | Fail fast on invalid parameters |

---

## 7. IRngContextService Interface

### 7.1 Interface Definition

**File:** `src/Core/RuneAndRust.Domain/Interfaces/IRngContextService.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.Interfaces;

/// <summary>
/// Manages RNG contexts and their associated seeding behavior.
/// </summary>
/// <remarks>
/// <para>
/// This service maintains a stack of active contexts and coordinates
/// seed locking/unlocking based on context transitions.
/// </para>
/// <para>
/// Context stack allows nested contexts (e.g., dialogue within exploration),
/// with proper cleanup when exiting inner contexts.
/// </para>
/// </remarks>
public interface IRngContextService
{
    /// <summary>
    /// Enters a new RNG context, pushing it onto the context stack.
    /// </summary>
    /// <param name="context">The context to enter.</param>
    /// <remarks>
    /// <para>
    /// If the context has a locked seed (Combat, Crafting), the RNG
    /// will be set to that seed. Otherwise, behavior depends on context type.
    /// </para>
    /// <para>
    /// Contexts can be nested. The innermost context determines behavior.
    /// </para>
    /// </remarks>
    void EnterContext(RngContext context);

    /// <summary>
    /// Exits the current RNG context, popping it from the stack.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Returns to the previous context's seeding behavior.
    /// If no contexts remain, defaults to Default context.
    /// </para>
    /// <para>
    /// Does nothing if no context is currently active.
    /// </para>
    /// </remarks>
    void ExitContext();

    /// <summary>
    /// Gets the currently active RNG context.
    /// </summary>
    /// <returns>The current context, or Default if no context is active.</returns>
    RngContext GetCurrentContext();

    /// <summary>
    /// Locks a specific seed for a context.
    /// </summary>
    /// <param name="context">The context to lock.</param>
    /// <param name="seed">The seed to use when this context is active.</param>
    /// <remarks>
    /// <para>
    /// Locked seeds are used when entering the context. This prevents
    /// save-scumming by ensuring the same random sequence.
    /// </para>
    /// <para>
    /// If the specified context is currently active, the seed is
    /// applied immediately.
    /// </para>
    /// </remarks>
    void LockSeedForContext(RngContext context, int seed);

    /// <summary>
    /// Releases the seed lock for a context.
    /// </summary>
    /// <param name="context">The context to unlock.</param>
    /// <remarks>
    /// <para>
    /// After unlocking, the context will generate a fresh seed
    /// each time it becomes active.
    /// </para>
    /// <para>
    /// Typically called when a locked session ends (e.g., combat ends).
    /// </para>
    /// </remarks>
    void ReleaseSeedLock(RngContext context);

    /// <summary>
    /// Checks if a context has a locked seed.
    /// </summary>
    /// <param name="context">The context to check.</param>
    /// <returns>True if the context has a locked seed; otherwise false.</returns>
    bool IsContextSeedLocked(RngContext context);

    /// <summary>
    /// Gets the locked seed for a context, if any.
    /// </summary>
    /// <param name="context">The context to query.</param>
    /// <returns>The locked seed, or null if not locked.</returns>
    int? GetLockedSeed(RngContext context);
}
```

### 7.2 Interface Method Summary

| Method | Parameters | Returns | Purpose |
|--------|------------|---------|---------|
| `EnterContext` | `context` | `void` | Push context onto stack |
| `ExitContext` | none | `void` | Pop context from stack |
| `GetCurrentContext` | none | `RngContext` | Get active context |
| `LockSeedForContext` | `context`, `seed` | `void` | Lock seed for context |
| `ReleaseSeedLock` | `context` | `void` | Unlock context seed |
| `IsContextSeedLocked` | `context` | `bool` | Check if seed is locked |
| `GetLockedSeed` | `context` | `int?` | Get locked seed value |

---

## 8. RngContextService Implementation

### 8.1 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/RngContextService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages RNG context stack and seed locking for context-aware randomness.
/// </summary>
/// <remarks>
/// <para>
/// This service coordinates between game systems and the IRandomProvider,
/// ensuring appropriate seeding behavior for different gameplay scenarios.
/// </para>
/// <para>
/// Context stack enables nested contexts (e.g., a dialogue check during combat)
/// while maintaining proper seed behavior on exit.
/// </para>
/// </remarks>
public class RngContextService : IRngContextService
{
    private readonly IRandomProvider _randomProvider;
    private readonly ILogger<RngContextService> _logger;
    private readonly Stack<RngContext> _contextStack;
    private readonly Dictionary<RngContext, int> _lockedSeeds;

    /// <summary>
    /// Creates a new RngContextService.
    /// </summary>
    /// <param name="randomProvider">The random provider to manage.</param>
    /// <param name="logger">Logger for diagnostics.</param>
    public RngContextService(
        IRandomProvider randomProvider,
        ILogger<RngContextService> logger)
    {
        _randomProvider = randomProvider ?? throw new ArgumentNullException(nameof(randomProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _contextStack = new Stack<RngContext>();
        _lockedSeeds = new Dictionary<RngContext, int>();

        _logger.LogInformation("RngContextService initialized");
    }

    /// <inheritdoc />
    public void EnterContext(RngContext context)
    {
        _logger.LogDebug("Entering RNG context: {Context}", context);

        _contextStack.Push(context);

        // Apply locked seed if available
        if (_lockedSeeds.TryGetValue(context, out var seed))
        {
            _logger.LogDebug("Applying locked seed {Seed} for context {Context}", seed, context);
            _randomProvider.SetSeed(seed);
        }
        else if (context is RngContext.Exploration or RngContext.Dialogue or RngContext.Default)
        {
            // Fresh seed for non-locked contexts
            var freshSeed = GenerateFreshSeed();
            _logger.LogDebug("Generating fresh seed {Seed} for context {Context}", freshSeed, context);
            _randomProvider.SetSeed(freshSeed);
        }
        // Combat and Crafting without locked seed: keep current RNG state
    }

    /// <inheritdoc />
    public void ExitContext()
    {
        if (_contextStack.Count == 0)
        {
            _logger.LogWarning("ExitContext called with empty context stack");
            return;
        }

        var exitedContext = _contextStack.Pop();
        _logger.LogDebug("Exited RNG context: {Context}", exitedContext);

        // If there's a previous context, restore its seed behavior
        if (_contextStack.Count > 0)
        {
            var previousContext = _contextStack.Peek();
            if (_lockedSeeds.TryGetValue(previousContext, out var seed))
            {
                _logger.LogDebug(
                    "Restoring locked seed {Seed} for previous context {Context}",
                    seed, previousContext);
                _randomProvider.SetSeed(seed);
            }
        }
    }

    /// <inheritdoc />
    public RngContext GetCurrentContext()
    {
        return _contextStack.Count > 0 ? _contextStack.Peek() : RngContext.Default;
    }

    /// <inheritdoc />
    public void LockSeedForContext(RngContext context, int seed)
    {
        _logger.LogDebug("Locking seed {Seed} for context {Context}", seed, context);
        _lockedSeeds[context] = seed;

        // If this context is currently active, apply immediately
        if (_contextStack.Count > 0 && _contextStack.Peek() == context)
        {
            _randomProvider.SetSeed(seed);
        }
    }

    /// <inheritdoc />
    public void ReleaseSeedLock(RngContext context)
    {
        if (_lockedSeeds.Remove(context))
        {
            _logger.LogDebug("Released seed lock for context {Context}", context);
        }
        else
        {
            _logger.LogDebug("No seed lock to release for context {Context}", context);
        }
    }

    /// <inheritdoc />
    public bool IsContextSeedLocked(RngContext context)
    {
        return _lockedSeeds.ContainsKey(context);
    }

    /// <inheritdoc />
    public int? GetLockedSeed(RngContext context)
    {
        return _lockedSeeds.TryGetValue(context, out var seed) ? seed : null;
    }

    /// <summary>
    /// Generates a fresh seed from current time.
    /// </summary>
    private static int GenerateFreshSeed()
    {
        return (int)(DateTime.UtcNow.Ticks % int.MaxValue);
    }
}
```

### 8.2 Implementation Notes

| Aspect | Design Decision | Rationale |
|--------|-----------------|-----------|
| **Context Stack** | Stack-based nesting | Allows nested contexts with proper cleanup |
| **Locked Seeds Dictionary** | Separate from stack | Seeds persist even when context not active |
| **Fresh Seed on Exploration** | Generate new seed | Allows retry on reload per design |
| **Combat without Lock** | Keep current state | Allows manual lock control by caller |
| **Singleton Scope** | Recommended | Single source of context truth |

---

## 9. DiceService Integration

### 9.1 Updated DiceService Constructor

**File:** `src/Core/RuneAndRust.Application/Services/DiceService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Core dice rolling service using success-counting mechanics.
/// </summary>
/// <remarks>
/// <para>
/// Supports standard dice pools with success-counting, exploding dice,
/// and advantage/disadvantage rolls. Uses IRandomProvider for deterministic
/// testing and context-aware seeding.
/// </para>
/// </remarks>
public class DiceService : IDiceService
{
    private readonly IRandomProvider _randomProvider;
    private readonly ILogger<DiceService> _logger;
    private readonly IGameEventLogger? _eventLogger;

    /// <summary>
    /// Creates a new DiceService with the specified random provider.
    /// </summary>
    /// <param name="randomProvider">The random number provider.</param>
    /// <param name="logger">Logger for diagnostics.</param>
    /// <param name="eventLogger">Optional game event logger.</param>
    public DiceService(
        IRandomProvider randomProvider,
        ILogger<DiceService> logger,
        IGameEventLogger? eventLogger = null)
    {
        _randomProvider = randomProvider ?? throw new ArgumentNullException(nameof(randomProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _eventLogger = eventLogger;

        _logger.LogInformation(
            "DiceService initialized with IRandomProvider (seed: {Seed})",
            _randomProvider.GetCurrentSeed());
    }

    /// <summary>
    /// Backward-compatible constructor for testing with raw Random.
    /// </summary>
    /// <param name="logger">Logger for diagnostics.</param>
    /// <param name="random">Optional Random instance (wrapped in adapter).</param>
    /// <param name="eventLogger">Optional game event logger.</param>
    [Obsolete("Use constructor with IRandomProvider. This overload exists for backward compatibility.")]
    public DiceService(
        ILogger<DiceService> logger,
        Random? random = null,
        IGameEventLogger? eventLogger = null)
        : this(
            new RandomAdapter(random ?? new Random()),
            logger,
            eventLogger)
    {
    }

    /// <summary>
    /// Rolls a single die with the specified number of faces.
    /// </summary>
    private int RollSingleDie(int faces) => _randomProvider.Next(1, faces + 1);

    // ... rest of DiceService implementation unchanged from v0.15.0a
}

/// <summary>
/// Adapter to wrap System.Random in IRandomProvider interface.
/// </summary>
/// <remarks>
/// Provides backward compatibility for code using the old Random-based constructor.
/// State management methods are no-ops since Random doesn't expose state.
/// </remarks>
internal class RandomAdapter : IRandomProvider
{
    private readonly Random _random;
    private int _seed;

    public RandomAdapter(Random random, int seed = 0)
    {
        _random = random;
        _seed = seed;
    }

    public int Next(int minInclusive, int maxExclusive) => _random.Next(minInclusive, maxExclusive);

    public int[] NextMany(int count, int minInclusive, int maxExclusive)
    {
        var results = new int[count];
        for (var i = 0; i < count; i++)
        {
            results[i] = _random.Next(minInclusive, maxExclusive);
        }
        return results;
    }

    public void SetSeed(int seed) => _seed = seed; // Can't actually reseed existing Random

    public int GetCurrentSeed() => _seed;

    public void SaveState() { } // No-op

    public void RestoreState() { } // No-op
}
```

### 9.2 Key Integration Changes

| Aspect | Before | After |
|--------|--------|-------|
| **Dependency** | `Random? random` | `IRandomProvider randomProvider` |
| **Die Roll** | `_random.Next()` | `_randomProvider.Next()` |
| **Seed Access** | Not available | `_randomProvider.GetCurrentSeed()` |
| **Backward Compat** | Direct Random | `RandomAdapter` wrapper |

---

## 10. Data Model Changes

### 10.1 New Types Summary

| Type | Layer | File | Description |
|------|-------|------|-------------|
| `IRandomProvider` | Domain | `Interfaces/IRandomProvider.cs` | Random number abstraction |
| `IRngContextService` | Domain | `Interfaces/IRngContextService.cs` | Context management abstraction |
| `RngContext` | Domain | `Enums/RngContext.cs` | Context type enumeration |
| `SeededRandomProvider` | Application | `Services/SeededRandomProvider.cs` | Seeded RNG implementation |
| `RngContextService` | Application | `Services/RngContextService.cs` | Context management implementation |
| `RandomAdapter` | Application | `Services/DiceService.cs` | Backward compat adapter (internal) |

### 10.2 Modified Types Summary

| Type | Layer | File | Changes |
|------|-------|------|---------|
| `DiceService` | Application | `Services/DiceService.cs` | Constructor uses `IRandomProvider` |

### 10.3 Unchanged Types

| Type | Layer | Notes |
|------|-------|-------|
| `DiceRollResult` | Domain | No changes required |
| `DicePool` | Domain | No changes required |
| `DiceConstants` | Domain | No changes required |
| `IDiceService` | Domain | Interface unchanged |

---

## 11. Configuration

### 11.1 Dependency Injection Registration

**File:** `src/RuneAndRust.Console/Program.cs` (or equivalent startup)

```csharp
// Register seeded random provider as singleton
services.AddSingleton<IRandomProvider>(sp =>
{
    var logger = sp.GetService<ILogger<SeededRandomProvider>>();
    return new SeededRandomProvider(initialSeed: null, logger: logger);
});

// Register context service as singleton
services.AddSingleton<IRngContextService, RngContextService>();

// Register dice service (uses IRandomProvider via DI)
services.AddScoped<IDiceService, DiceService>();
```

### 11.2 No Configuration Files for v0.15.0b

Configuration files for RNG contexts are planned for a future version. v0.15.0b uses hardcoded default behaviors.

### 11.3 Future Configuration (Planned)

**Planned: `config/rng-contexts.json`**
```json
{
  "$schema": "./schemas/rng-contexts.schema.json",
  "contexts": {
    "Combat": {
      "seedBehavior": "locked",
      "lockTrigger": "encounterStart"
    },
    "Exploration": {
      "seedBehavior": "fresh",
      "freshTrigger": "gameLoad"
    },
    "Crafting": {
      "seedBehavior": "locked",
      "lockTrigger": "sessionStart"
    },
    "Dialogue": {
      "seedBehavior": "fresh",
      "freshTrigger": "gameLoad"
    }
  }
}
```

This is documented here for context but is **out of scope** for v0.15.0b.

---

## 12. Commands

### 12.1 No Command Changes

v0.15.0b does not introduce or modify any user-facing commands. The seeded random provider operates transparently behind the scenes.

### 12.2 Debug Commands (Potential Future)

Future versions may add debug commands for testing:

```
> debug rng seed 42        # Set specific seed
> debug rng state save     # Save current state
> debug rng state restore  # Restore saved state
> debug rng context combat # Enter combat context
```

These are **out of scope** for v0.15.0b.

---

## 13. User-Facing Changes

### 13.1 No Visible Changes

The seeded random provider is an internal implementation detail. Users will not see any changes in normal gameplay.

### 13.2 Behavior Changes

| Scenario | Before | After |
|----------|--------|-------|
| Combat reload | Different roll sequence | Same roll sequence (when implemented in v0.15.0f) |
| Exploration reload | Same/different (uncontrolled) | Different roll sequence (fresh seed) |
| Test runs | Non-deterministic | Deterministic with known seed |

---

## 14. Logging Specifications

### 14.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `SeededRandomProvider` | Debug | Seed changes, state save/restore |
| `SeededRandomProvider` | Trace | Individual Next() calls with values |
| `RngContextService` | Information | Service initialization |
| `RngContextService` | Debug | Context enter/exit, seed locks |
| `DiceService` | Information | Provider initialization with seed |

### 14.2 Log Message Formats

```
[Debug] SeededRandomProvider initialized with seed 42
[Debug] Setting seed from 42 to 12345
[Debug] Saved RNG state with seed 42
[Debug] Restoring RNG state from seed 42
[Trace] Next(1, 11) = 7 (seed: 42)
[Trace] NextMany(5, 1, 11) = [3, 7, 8, 2, 9] (seed: 42)

[Information] RngContextService initialized
[Debug] Entering RNG context: Combat
[Debug] Applying locked seed 12345 for context Combat
[Debug] Exited RNG context: Combat
[Debug] Locking seed 12345 for context Combat
[Debug] Released seed lock for context Combat

[Information] DiceService initialized with IRandomProvider (seed: 42)
```

---

## 15. Unit Testing Requirements

### 15.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Deterministic sequence | 2 |
| Save/restore state | 1 |
| Context management | 2 |
| NextMany batch generation | 1 |
| **Total** | **~6** |

### 15.2 Test Specifications

**File:** `tests/RuneAndRust.Application.UnitTests/Services/SeededRandomProviderTests.cs`

```csharp
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class SeededRandomProviderTests
{
    [Test]
    public void Next_WithSameSeed_ProducesIdenticalSequence()
    {
        // Arrange
        var provider1 = new SeededRandomProvider(42);
        var provider2 = new SeededRandomProvider(42);

        // Act
        var sequence1 = Enumerable.Range(0, 10).Select(_ => provider1.Next(1, 11)).ToArray();
        var sequence2 = Enumerable.Range(0, 10).Select(_ => provider2.Next(1, 11)).ToArray();

        // Assert
        Assert.That(sequence2, Is.EqualTo(sequence1));
    }

    [Test]
    public void Next_WithDifferentSeeds_ProducesDifferentSequence()
    {
        // Arrange
        var provider1 = new SeededRandomProvider(42);
        var provider2 = new SeededRandomProvider(123);

        // Act
        var sequence1 = Enumerable.Range(0, 10).Select(_ => provider1.Next(1, 11)).ToArray();
        var sequence2 = Enumerable.Range(0, 10).Select(_ => provider2.Next(1, 11)).ToArray();

        // Assert
        Assert.That(sequence2, Is.Not.EqualTo(sequence1));
    }

    [Test]
    public void SaveState_RestoreState_ReproducesSequence()
    {
        // Arrange
        var provider = new SeededRandomProvider(42);
        provider.SaveState();

        // Act - Generate some values
        var firstRun = Enumerable.Range(0, 5).Select(_ => provider.Next(1, 11)).ToArray();

        // Restore and generate again
        provider.RestoreState();
        var secondRun = Enumerable.Range(0, 5).Select(_ => provider.Next(1, 11)).ToArray();

        // Assert
        Assert.That(secondRun, Is.EqualTo(firstRun));
    }

    [Test]
    public void NextMany_ReturnsCorrectCount()
    {
        // Arrange
        var provider = new SeededRandomProvider(42);

        // Act
        var results = provider.NextMany(5, 1, 11);

        // Assert
        Assert.That(results, Has.Length.EqualTo(5));
        Assert.That(results, Has.All.InRange(1, 10));
    }

    [Test]
    public void NextMany_WithSameSeed_ProducesIdenticalArray()
    {
        // Arrange
        var provider1 = new SeededRandomProvider(42);
        var provider2 = new SeededRandomProvider(42);

        // Act
        var results1 = provider1.NextMany(10, 1, 11);
        var results2 = provider2.NextMany(10, 1, 11);

        // Assert
        Assert.That(results2, Is.EqualTo(results1));
    }

    [Test]
    public void GetCurrentSeed_ReturnsSetSeed()
    {
        // Arrange
        var provider = new SeededRandomProvider(42);

        // Act
        provider.SetSeed(12345);

        // Assert
        Assert.That(provider.GetCurrentSeed(), Is.EqualTo(12345));
    }
}
```

**File:** `tests/RuneAndRust.Application.UnitTests/Services/RngContextServiceTests.cs`

```csharp
using Microsoft.Extensions.Logging;
using Moq;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class RngContextServiceTests
{
    private Mock<IRandomProvider> _mockProvider = null!;
    private Mock<ILogger<RngContextService>> _mockLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockProvider = new Mock<IRandomProvider>();
        _mockLogger = new Mock<ILogger<RngContextService>>();
    }

    [Test]
    public void EnterContext_WithLockedSeed_AppliesSeedToProvider()
    {
        // Arrange
        var service = new RngContextService(_mockProvider.Object, _mockLogger.Object);
        service.LockSeedForContext(RngContext.Combat, 12345);

        // Act
        service.EnterContext(RngContext.Combat);

        // Assert
        _mockProvider.Verify(p => p.SetSeed(12345), Times.Once);
    }

    [Test]
    public void GetCurrentContext_WithNoContext_ReturnsDefault()
    {
        // Arrange
        var service = new RngContextService(_mockProvider.Object, _mockLogger.Object);

        // Act
        var context = service.GetCurrentContext();

        // Assert
        Assert.That(context, Is.EqualTo(RngContext.Default));
    }

    [Test]
    public void ExitContext_RestoresPreviousContext()
    {
        // Arrange
        var service = new RngContextService(_mockProvider.Object, _mockLogger.Object);
        service.LockSeedForContext(RngContext.Exploration, 111);
        service.LockSeedForContext(RngContext.Combat, 222);

        service.EnterContext(RngContext.Exploration);
        service.EnterContext(RngContext.Combat);

        // Reset mock to track only exit behavior
        _mockProvider.Invocations.Clear();

        // Act
        service.ExitContext();

        // Assert - Should restore exploration seed
        _mockProvider.Verify(p => p.SetSeed(111), Times.Once);
        Assert.That(service.GetCurrentContext(), Is.EqualTo(RngContext.Exploration));
    }

    [Test]
    public void IsContextSeedLocked_AfterLock_ReturnsTrue()
    {
        // Arrange
        var service = new RngContextService(_mockProvider.Object, _mockLogger.Object);

        // Act
        service.LockSeedForContext(RngContext.Combat, 42);

        // Assert
        Assert.That(service.IsContextSeedLocked(RngContext.Combat), Is.True);
        Assert.That(service.IsContextSeedLocked(RngContext.Exploration), Is.False);
    }

    [Test]
    public void ReleaseSeedLock_RemovesLock()
    {
        // Arrange
        var service = new RngContextService(_mockProvider.Object, _mockLogger.Object);
        service.LockSeedForContext(RngContext.Combat, 42);

        // Act
        service.ReleaseSeedLock(RngContext.Combat);

        // Assert
        Assert.That(service.IsContextSeedLocked(RngContext.Combat), Is.False);
        Assert.That(service.GetLockedSeed(RngContext.Combat), Is.Null);
    }
}
```

---

## 16. Use Cases

### 16.1 UC-150b-001: Deterministic Testing

**Actor:** Developer
**Flow:** Developer creates test → Sets known seed → Rolls dice → Verifies expected sequence

**Details:**
1. Test creates `SeededRandomProvider(42)`
2. Test creates `DiceService` with provider
3. Test calls `diceService.Roll("3d10")`
4. Test verifies exact roll values match expected
5. Test is repeatable on any machine

### 16.2 UC-150b-002: Combat Seed Locking

**Actor:** Combat System
**Flow:** Combat starts → Seed locked → All combat rolls deterministic → Combat ends → Seed released

**Details:**
1. `CombatService.StartEncounter()` called
2. Generate combat seed from encounter ID
3. `_rngContextService.LockSeedForContext(RngContext.Combat, seed)`
4. `_rngContextService.EnterContext(RngContext.Combat)`
5. All dice rolls during combat produce same sequence on reload
6. Combat ends: `ExitContext()`, `ReleaseSeedLock()`

### 16.3 UC-150b-003: Exploration Fresh Seed

**Actor:** Exploration System
**Flow:** Game loads → Fresh exploration seed → Player explores → Different rolls on reload

**Details:**
1. Game loads save file
2. `_rngContextService.EnterContext(RngContext.Exploration)`
3. Service generates fresh seed from current time
4. Trap checks, loot rolls use fresh sequence
5. If player reloads, different seed → different results

### 16.4 UC-150b-004: State Save/Restore for Replay

**Actor:** Debug System (future)
**Flow:** Save RNG state → Execute sequence → Restore → Replay exact sequence

**Details:**
1. Before critical roll: `_randomProvider.SaveState()`
2. Roll dice, record results
3. To replay: `_randomProvider.RestoreState()`
4. Same rolls reproduced for debugging

---

## 17. Deliverable Checklist

### 17.1 Domain Layer

- [ ] `IRandomProvider.cs` created in `Domain/Interfaces/`
- [ ] `IRngContextService.cs` created in `Domain/Interfaces/`
- [ ] `RngContext.cs` created in `Domain/Enums/`
- [ ] All interfaces have XML documentation

### 17.2 Application Layer

- [ ] `SeededRandomProvider.cs` created in `Application/Services/`
- [ ] `RngContextService.cs` created in `Application/Services/`
- [ ] `DiceService.cs` updated to use `IRandomProvider`
- [ ] `RandomAdapter` internal class added for backward compatibility
- [ ] All services have XML documentation

### 17.3 Unit Tests

- [ ] `SeededRandomProviderTests.cs` created (~6 tests)
- [ ] `RngContextServiceTests.cs` created (~5 tests)
- [ ] All tests pass
- [ ] Deterministic sequence verified
- [ ] Save/restore verified
- [ ] Context management verified

### 17.4 Documentation

- [ ] This design specification complete
- [ ] Code XML documentation complete

---

## 18. Acceptance Criteria

### 18.1 Functional

- [ ] Same seed produces identical random sequences
- [ ] Different seeds produce different sequences
- [ ] `SaveState()` and `RestoreState()` work correctly
- [ ] `NextMany()` returns correct count of values
- [ ] `SetSeed()` resets sequence to beginning
- [ ] `GetCurrentSeed()` returns correct value
- [ ] Combat context uses locked seed when set
- [ ] Exploration context generates fresh seed
- [ ] Context stack supports nesting
- [ ] `DiceService` uses `IRandomProvider` correctly

### 18.2 Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~6+ new unit tests pass
- [ ] All existing dice tests pass (backward compatibility)
- [ ] XML documentation complete on all public members

---

## 19. Future Considerations

### 19.1 Deferred to v0.15.0c (Skill Check Refactor)

- Skill check context integration
- Automatic context detection from skill type

### 19.2 Deferred to v0.15.0e (Dice Roll Logging)

- Log seed with each roll
- Roll replay using logged seeds
- `rng-contexts.json` configuration file

### 19.3 Deferred to v0.15.0f (Combat Integration)

- Combat encounter seed generation
- Automatic `EnterContext(Combat)` on encounter start
- Automatic `ExitContext()` on encounter end

### 19.4 Deferred to Future Version

- Persistent seed storage (save game)
- True state serialization (not just seed)
- Cryptographic RNG option for security
- Debug commands for RNG manipulation

---

## 20. Implementation Notes

### 20.1 Backward Compatibility

The `RandomAdapter` internal class wraps `System.Random` to maintain backward compatibility with existing code that uses the old `DiceService(logger, random)` constructor. This constructor is marked `[Obsolete]` to guide migration.

### 20.2 Thread Safety

`SeededRandomProvider` and `RngContextService` are **not thread-safe**. They are designed for single-threaded game logic. If concurrent access is needed, external synchronization or separate instances per thread are required.

### 20.3 State Save Limitation

The save/restore mechanism saves the **seed**, not the internal `Random` state. Restoring replays the sequence from the beginning. For exact state restoration, more sophisticated approaches (serializing internal state) would be needed, but .NET `Random` doesn't expose this.

### 20.4 Fresh Seed Generation

Fresh seeds are generated from `DateTime.UtcNow.Ticks % int.MaxValue`. This provides sufficient randomness for game purposes while remaining deterministic enough for testing when a specific seed is set.

---

## 21. Document Metadata

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*

---

*This design specification provides the detailed blueprint for implementing v0.15.0b Seeded Random Provider. This enables deterministic testing and context-aware seeding required for skill checks (v0.15.0c) and combat integration (v0.15.0f).*
