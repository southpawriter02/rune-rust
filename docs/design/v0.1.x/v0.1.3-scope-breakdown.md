# v0.1.3 Advanced Procedural Architecture - Scope Breakdown

**Version:** 0.1.3
**Theme:** Advanced Procedural Architecture
**Prerequisites:** v0.1.2 Complete (Dungeon Theming & Biomes)
**Total Estimated Tests:** ~95 new tests

---

## Executive Summary

The Advanced Procedural Architecture version enhances dungeon generation with architectural intelligence. This version introduces distinct construction patterns, varied room shapes, hand-crafted landmark rooms, structural coherence rules, and dungeon age/decay systems. Together, these features create dungeons that feel designed rather than randomly assembled.

Key focus areas:
- **Architectural Styles**: Distinct construction patterns (caves, halls, ruins, temples)
- **Room Shape Variety**: Non-rectangular rooms (circular, L-shaped, irregular)
- **Landmark Rooms**: Hand-crafted centerpieces for special encounters
- **Structural Coherence**: Logical architecture with corridors, supports, materials
- **Dungeon Age & Decay**: Environmental aging affecting descriptors and hazards

The work is divided into **four sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.1.3a | Architectural Styles | ArchitecturalStyle entity, style definitions, style selection | ~22 |
| v0.1.3b | Room Shapes & Features | RoomShape enum, StructuralFeature entity, shape generation | ~25 |
| v0.1.3c | Landmark Rooms | LandmarkRoom entity, curated designs, special room integration | ~25 |
| v0.1.3d | Dungeon Age & Coherence | DungeonAge system, coherence rules, material consistency | ~23 |

---

## Existing Infrastructure

### Already Implemented (from v0.1.2)

| Feature | Location | Notes |
|---------|----------|-------|
| BiomeDefinition | `Domain/Definitions/BiomeDefinition.cs` | Themed dungeon zones |
| BiomeDescriptors | `Domain/ValueObjects/BiomeDescriptors.cs` | Environmental descriptors |
| BiomeService | `Application/Services/BiomeService.cs` | Biome lookup/selection |
| BiomeSpawnTable | `Domain/Definitions/BiomeSpawnTable.cs` | Biome-specific content |
| BiomeHazard | `Domain/Definitions/BiomeHazard.cs` | Environmental hazards |
| BiomeTransition | `Domain/Definitions/BiomeTransition.cs` | Zone connection rules |
| Room.BiomeId | `Domain/Entities/Room.cs` | Biome assignment |
| RoomTemplate | `Domain/Entities/RoomTemplate.cs` | Slot-based patterns |
| TemplateSlot | `Domain/ValueObjects/TemplateSlot.cs` | Variable content positions |
| RoomType | `Domain/Enums/RoomType.cs` | Standard, Treasure, Boss, etc. |
| Position3D | `Domain/ValueObjects/Position3D.cs` | Z-axis support |
| SeededRandomService | `Application/Services/SeededRandomService.cs` | Reproducible generation |
| DifficultyRating | `Domain/ValueObjects/DifficultyRating.cs` | Position-based difficulty |
| DescriptorService | `Application/Services/DescriptorService.cs` | Weighted text generation |

### Needs Implementation (v0.1.3)

| Feature | Phase | Notes |
|---------|-------|-------|
| ArchitecturalStyle | v0.1.3a | Construction pattern entity |
| StyleDescriptors | v0.1.3a | Style-specific descriptions |
| RoomShape | v0.1.3b | Shape enum and geometry |
| StructuralFeature | v0.1.3b | Pillars, platforms, balconies |
| LandmarkRoom | v0.1.3c | Curated special rooms |
| DungeonAge | v0.1.3d | Age/decay system |
| CoherenceRules | v0.1.3d | Structural logic configuration |

---

## Feature Analysis & Categorization

### Architectural Style Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| ArchitecturalStyle entity | High | BiomeDefinition | **v0.1.3a** |
| StyleDescriptors value object | Medium | BiomeDescriptors | **v0.1.3a** |
| Style configuration (JSON) | Medium | IConfigurationProvider | **v0.1.3a** |
| ArchitecturalStyleService | Medium | ArchitecturalStyle | **v0.1.3a** |
| Style-biome compatibility | Medium | BiomeService | **v0.1.3a** |
| Room template style filtering | Medium | RoomTemplate | **v0.1.3a** |

### Room Shape Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| RoomShape enum | Low | None | **v0.1.3b** |
| ShapeDefinition value object | Medium | RoomShape | **v0.1.3b** |
| StructuralFeature entity | High | RoomShape | **v0.1.3b** |
| Shape-based exit placement | Medium | RoomShape, Direction | **v0.1.3b** |
| Shape generation from style | Medium | ArchitecturalStyle | **v0.1.3b** |
| Feature placement rules | Medium | StructuralFeature | **v0.1.3b** |

### Landmark Room Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| LandmarkRoom entity | High | RoomTemplate, RoomShape | **v0.1.3c** |
| Landmark configuration (JSON) | Medium | IConfigurationProvider | **v0.1.3c** |
| LandmarkRoomService | Medium | LandmarkRoom | **v0.1.3c** |
| Boss arena designs | Medium | RoomType.Boss | **v0.1.3c** |
| Puzzle chamber designs | Medium | LandmarkRoom | **v0.1.3c** |
| Safe haven designs | Medium | RoomType.Safe | **v0.1.3c** |

### Age & Coherence Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| DungeonAge enum | Low | None | **v0.1.3d** |
| AgeDescriptors value object | Medium | DungeonAge | **v0.1.3d** |
| CoherenceRules configuration | High | ArchitecturalStyle | **v0.1.3d** |
| MaterialPalette value object | Medium | BiomeDefinition | **v0.1.3d** |
| Corridor generation rules | Medium | ArchitecturalStyle | **v0.1.3d** |
| Age-based hazard modifiers | Medium | BiomeHazard, DungeonAge | **v0.1.3d** |

---

## Phase Definitions

---

## v0.1.3a: Architectural Styles

### Overview

Create the architectural style system defining distinct construction patterns. Each style determines room shapes, materials, decorations, and structural features typical of that construction type. Styles integrate with biomes to ensure thematic consistency.

### Scope

**In Scope:**
- `ArchitecturalStyle` entity with construction rules
- `StyleDescriptors` value object for style-specific text
- `ArchitecturalStyleService` for style lookup and selection
- Style configuration schema and JSON loading
- Style-biome compatibility matrix
- Room template filtering by style
- Default styles: Natural Caves, Carved Halls, Ruined Structures, Ancient Temples

**Out of Scope:**
- Room shape geometry (v0.1.3b)
- Structural features (v0.1.3b)
- Landmark rooms (v0.1.3c)
- Dungeon age system (v0.1.3d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `ArchitecturalStyle` |
| Value Objects | 2 | `StyleDescriptors`, `StyleRules` |
| Services | 1 | `ArchitecturalStyleService` |
| Configuration | 1 | `architectural-styles.json` |
| Service Updates | 1 | `RoomGeneratorService` style integration |
| Unit Tests | ~22 | Style definition, selection, compatibility |

### ArchitecturalStyle Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a distinct construction pattern for dungeon areas.
/// </summary>
public class ArchitecturalStyle
{
    /// <summary>
    /// Gets the unique identifier for this style (e.g., "natural-caves").
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name (e.g., "Natural Caves").
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the style description.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets style-specific descriptors for room generation.
    /// </summary>
    public StyleDescriptors Descriptors { get; init; } = default;

    /// <summary>
    /// Gets construction rules for this style.
    /// </summary>
    public StyleRules Rules { get; init; } = default;

    /// <summary>
    /// Gets biome IDs compatible with this style.
    /// </summary>
    public IReadOnlyList<string> CompatibleBiomes { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets preferred room shapes for this style.
    /// </summary>
    public IReadOnlyList<string> PreferredShapes { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets structural features common to this style.
    /// </summary>
    public IReadOnlyList<string> CommonFeatures { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the probability weight for style selection.
    /// </summary>
    public int Weight { get; init; } = 100;

    /// <summary>
    /// Gets whether this style uses doors between rooms.
    /// </summary>
    public bool UsesDoors { get; init; } = true;

    /// <summary>
    /// Gets whether this style has corridors connecting rooms.
    /// </summary>
    public bool HasCorridors { get; init; } = true;

    /// <summary>
    /// Gets the minimum depth where this style can appear.
    /// </summary>
    public int MinDepth { get; init; }

    /// <summary>
    /// Gets the maximum depth for this style (null = no limit).
    /// </summary>
    public int? MaxDepth { get; init; }

    /// <summary>
    /// Gets tags for filtering and categorization.
    /// </summary>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();
}
```

### StyleDescriptors Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Descriptors specific to an architectural style.
/// </summary>
public readonly record struct StyleDescriptors
{
    /// <summary>
    /// Gets wall descriptors (e.g., "rough stone", "carved marble").
    /// </summary>
    public IReadOnlyList<string> Walls { get; init; }

    /// <summary>
    /// Gets floor descriptors (e.g., "uneven rock", "polished tiles").
    /// </summary>
    public IReadOnlyList<string> Floors { get; init; }

    /// <summary>
    /// Gets ceiling descriptors (e.g., "jagged stalactites", "vaulted arches").
    /// </summary>
    public IReadOnlyList<string> Ceilings { get; init; }

    /// <summary>
    /// Gets passage descriptors (e.g., "narrow tunnel", "grand hallway").
    /// </summary>
    public IReadOnlyList<string> Passages { get; init; }

    /// <summary>
    /// Gets decoration descriptors (e.g., "mineral deposits", "carved reliefs").
    /// </summary>
    public IReadOnlyList<string> Decorations { get; init; }

    /// <summary>
    /// Gets the descriptor pool prefix for this style.
    /// </summary>
    public string DescriptorPoolPrefix { get; init; }

    /// <summary>
    /// Creates natural caves descriptors.
    /// </summary>
    public static StyleDescriptors NaturalCaves => new()
    {
        Walls = new[] { "rough stone", "mineral-veined rock", "damp limestone", "jagged surfaces" },
        Floors = new[] { "uneven ground", "scattered gravel", "smooth water-worn stone", "loose rubble" },
        Ceilings = new[] { "stalactite clusters", "low overhangs", "high natural domes", "dripping moisture" },
        Passages = new[] { "narrow squeeze", "winding tunnel", "natural fissure", "widening cavern" },
        Decorations = new[] { "crystal formations", "phosphorescent moss", "mineral deposits", "ancient fossils" },
        DescriptorPoolPrefix = "style.caves"
    };

    /// <summary>
    /// Creates carved halls descriptors.
    /// </summary>
    public static StyleDescriptors CarvedHalls => new()
    {
        Walls = new[] { "smooth-cut stone", "precise masonry", "decorated panels", "torch sconces" },
        Floors = new[] { "fitted flagstones", "geometric patterns", "worn pathways", "drainage channels" },
        Ceilings = new[] { "vaulted arches", "supporting beams", "carved coffers", "hanging lanterns" },
        Passages = new[] { "wide corridor", "pillared hall", "arched doorway", "grand passage" },
        Decorations = new[] { "carved reliefs", "stone pillars", "alcove statues", "inscribed tablets" },
        DescriptorPoolPrefix = "style.halls"
    };

    /// <summary>
    /// Creates ruined structures descriptors.
    /// </summary>
    public static StyleDescriptors RuinedStructures => new()
    {
        Walls = new[] { "crumbling masonry", "collapsed sections", "exposed foundations", "vine-covered stone" },
        Floors = new[] { "broken tiles", "debris piles", "treacherous gaps", "overgrown flagstones" },
        Ceilings = new[] { "partially collapsed", "exposed sky", "precarious beams", "bird nests" },
        Passages = new[] { "rubble-blocked", "improvised path", "collapsed tunnel", "unstable archway" },
        Decorations = new[] { "shattered statues", "faded murals", "scattered artifacts", "nature reclaiming" },
        DescriptorPoolPrefix = "style.ruins"
    };

    /// <summary>
    /// Creates ancient temples descriptors.
    /// </summary>
    public static StyleDescriptors AncientTemples => new()
    {
        Walls = new[] { "sacred inscriptions", "polished marble", "divine imagery", "gold inlays" },
        Floors = new[] { "mosaic patterns", "ceremonial tiles", "altar platforms", "processional paths" },
        Ceilings = new[] { "painted heavens", "domed sanctuaries", "hanging censers", "celestial motifs" },
        Passages = new[] { "ritual corridor", "pilgrimage path", "sanctum approach", "ceremonial gate" },
        Decorations = new[] { "divine statues", "offering bowls", "eternal flames", "sacred symbols" },
        DescriptorPoolPrefix = "style.temples"
    };
}
```

### StyleRules Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Construction rules for an architectural style.
/// </summary>
public readonly record struct StyleRules
{
    /// <summary>
    /// Gets the typical room size range (min, max in tiles).
    /// </summary>
    public (int Min, int Max) RoomSizeRange { get; init; }

    /// <summary>
    /// Gets the probability of having multiple exits (0.0-1.0).
    /// </summary>
    public float MultipleExitChance { get; init; }

    /// <summary>
    /// Gets the average exits per room.
    /// </summary>
    public float AverageExits { get; init; }

    /// <summary>
    /// Gets whether rooms tend toward symmetry.
    /// </summary>
    public bool PrefersSymmetry { get; init; }

    /// <summary>
    /// Gets whether rooms have regular (rectangular) shapes.
    /// </summary>
    public bool PrefersRegularShapes { get; init; }

    /// <summary>
    /// Gets the corridor width (0 = no corridors).
    /// </summary>
    public int CorridorWidth { get; init; }

    /// <summary>
    /// Gets the probability of hidden passages (0.0-1.0).
    /// </summary>
    public float HiddenPassageChance { get; init; }

    /// <summary>
    /// Gets the probability of traps (0.0-1.0).
    /// </summary>
    public float TrapChance { get; init; }

    /// <summary>
    /// Gets default style rules.
    /// </summary>
    public static StyleRules Default => new()
    {
        RoomSizeRange = (3, 8),
        MultipleExitChance = 0.6f,
        AverageExits = 2.5f,
        PrefersSymmetry = false,
        PrefersRegularShapes = true,
        CorridorWidth = 1,
        HiddenPassageChance = 0.1f,
        TrapChance = 0.15f
    };

    /// <summary>
    /// Gets natural caves rules.
    /// </summary>
    public static StyleRules NaturalCaves => new()
    {
        RoomSizeRange = (2, 12),
        MultipleExitChance = 0.7f,
        AverageExits = 2.8f,
        PrefersSymmetry = false,
        PrefersRegularShapes = false,
        CorridorWidth = 0, // No formal corridors
        HiddenPassageChance = 0.15f,
        TrapChance = 0.05f // Natural hazards instead
    };

    /// <summary>
    /// Gets ancient temples rules.
    /// </summary>
    public static StyleRules AncientTemples => new()
    {
        RoomSizeRange = (5, 15),
        MultipleExitChance = 0.4f,
        AverageExits = 2.0f,
        PrefersSymmetry = true,
        PrefersRegularShapes = true,
        CorridorWidth = 2, // Wide ceremonial corridors
        HiddenPassageChance = 0.2f, // Secret chambers
        TrapChance = 0.25f // Temple guardians
    };
}
```

### ArchitecturalStyleService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for architectural style management and selection.
/// </summary>
public class ArchitecturalStyleService : IArchitecturalStyleService
{
    private readonly IConfigurationProvider _config;
    private readonly IBiomeService _biomeService;
    private readonly SeededRandomService _random;
    private readonly ILogger<ArchitecturalStyleService> _logger;

    /// <summary>
    /// Gets an architectural style by ID.
    /// </summary>
    public ArchitecturalStyle? GetStyle(string styleId)
    {
        return _config.GetArchitecturalStyles()
            .FirstOrDefault(s => s.Id == styleId);
    }

    /// <summary>
    /// Gets all available architectural styles.
    /// </summary>
    public IReadOnlyList<ArchitecturalStyle> GetAllStyles()
    {
        return _config.GetArchitecturalStyles();
    }

    /// <summary>
    /// Gets styles compatible with a biome.
    /// </summary>
    public IReadOnlyList<ArchitecturalStyle> GetStylesForBiome(string biomeId)
    {
        return _config.GetArchitecturalStyles()
            .Where(s => s.CompatibleBiomes.Contains(biomeId) ||
                       !s.CompatibleBiomes.Any()) // Empty = all biomes
            .ToList();
    }

    /// <summary>
    /// Gets styles valid for a depth level.
    /// </summary>
    public IReadOnlyList<ArchitecturalStyle> GetStylesForDepth(int depth)
    {
        return _config.GetArchitecturalStyles()
            .Where(s => s.MinDepth <= depth)
            .Where(s => !s.MaxDepth.HasValue || s.MaxDepth.Value >= depth)
            .ToList();
    }

    /// <summary>
    /// Selects an architectural style for a position.
    /// </summary>
    public ArchitecturalStyle SelectStyleForPosition(
        Position3D position,
        string biomeId)
    {
        var validStyles = GetStylesForBiome(biomeId)
            .Where(s => s.MinDepth <= position.Z)
            .Where(s => !s.MaxDepth.HasValue || s.MaxDepth.Value >= position.Z)
            .ToList();

        if (!validStyles.Any())
        {
            _logger.LogWarning(
                "No valid styles for biome {Biome} at depth {Depth}, using default",
                biomeId,
                position.Z);
            return GetStyle("carved-halls") ?? validStyles.First();
        }

        var weightedStyles = validStyles.Select(s => (s, s.Weight));
        return _random.SelectWeighted(position, weightedStyles, "style_select");
    }

    /// <summary>
    /// Checks if a style is compatible with a biome.
    /// </summary>
    public bool IsCompatible(string styleId, string biomeId)
    {
        var style = GetStyle(styleId);
        if (style == null) return false;

        return !style.CompatibleBiomes.Any() ||
               style.CompatibleBiomes.Contains(biomeId);
    }

    /// <summary>
    /// Gets random style descriptors for a room.
    /// </summary>
    public string GetRandomDescriptor(
        string styleId,
        string descriptorType,
        Position3D position)
    {
        var style = GetStyle(styleId);
        if (style == null) return string.Empty;

        var pool = descriptorType.ToLowerInvariant() switch
        {
            "walls" => style.Descriptors.Walls,
            "floors" => style.Descriptors.Floors,
            "ceilings" => style.Descriptors.Ceilings,
            "passages" => style.Descriptors.Passages,
            "decorations" => style.Descriptors.Decorations,
            _ => Array.Empty<string>()
        };

        if (!pool.Any()) return string.Empty;

        var index = _random.NextForPosition(position, 0, pool.Count, $"style_desc_{descriptorType}");
        return pool[index];
    }
}
```

### Architectural Style Configuration Example

```json
{
  "$schema": "schemas/architectural-styles-schema.json",
  "styles": [
    {
      "id": "natural-caves",
      "name": "Natural Caves",
      "description": "Organic caverns formed by geological processes over millennia.",
      "compatibleBiomes": ["mines", "frozen-depths", "volcanic-caverns"],
      "preferredShapes": ["irregular", "circular"],
      "commonFeatures": ["stalactite", "stalagmite", "pool", "ledge"],
      "weight": 100,
      "usesDoors": false,
      "hasCorridors": false,
      "minDepth": 0,
      "tags": ["organic", "natural", "cave"],
      "descriptors": {
        "walls": ["rough stone", "mineral-veined rock", "damp limestone"],
        "floors": ["uneven ground", "scattered gravel", "smooth water-worn stone"],
        "ceilings": ["stalactite clusters", "low overhangs", "high natural domes"],
        "passages": ["narrow squeeze", "winding tunnel", "natural fissure"],
        "decorations": ["crystal formations", "phosphorescent moss", "mineral deposits"],
        "descriptorPoolPrefix": "style.caves"
      },
      "rules": {
        "roomSizeRange": [2, 12],
        "multipleExitChance": 0.7,
        "averageExits": 2.8,
        "prefersSymmetry": false,
        "prefersRegularShapes": false,
        "corridorWidth": 0,
        "hiddenPassageChance": 0.15,
        "trapChance": 0.05
      }
    },
    {
      "id": "carved-halls",
      "name": "Carved Halls",
      "description": "Precisely constructed passages with orderly architecture.",
      "compatibleBiomes": ["catacombs", "ancient-ruins", "mines"],
      "preferredShapes": ["rectangular", "l-shaped"],
      "commonFeatures": ["pillar", "alcove", "torch-sconce", "bench"],
      "weight": 100,
      "usesDoors": true,
      "hasCorridors": true,
      "minDepth": 0,
      "tags": ["constructed", "orderly", "formal"],
      "descriptors": {
        "walls": ["smooth-cut stone", "precise masonry", "decorated panels"],
        "floors": ["fitted flagstones", "geometric patterns", "worn pathways"],
        "ceilings": ["vaulted arches", "supporting beams", "carved coffers"],
        "passages": ["wide corridor", "pillared hall", "arched doorway"],
        "decorations": ["carved reliefs", "stone pillars", "alcove statues"],
        "descriptorPoolPrefix": "style.halls"
      },
      "rules": {
        "roomSizeRange": [4, 10],
        "multipleExitChance": 0.5,
        "averageExits": 2.5,
        "prefersSymmetry": false,
        "prefersRegularShapes": true,
        "corridorWidth": 1,
        "hiddenPassageChance": 0.1,
        "trapChance": 0.15
      }
    },
    {
      "id": "ruined-structures",
      "name": "Ruined Structures",
      "description": "Collapsed and decaying remnants of once-grand construction.",
      "compatibleBiomes": ["ancient-ruins", "catacombs"],
      "preferredShapes": ["irregular", "rectangular"],
      "commonFeatures": ["rubble", "collapsed-wall", "broken-pillar", "gap"],
      "weight": 80,
      "usesDoors": false,
      "hasCorridors": false,
      "minDepth": 2,
      "tags": ["ruined", "collapsed", "dangerous"],
      "descriptors": {
        "walls": ["crumbling masonry", "collapsed sections", "vine-covered stone"],
        "floors": ["broken tiles", "debris piles", "treacherous gaps"],
        "ceilings": ["partially collapsed", "exposed sky", "precarious beams"],
        "passages": ["rubble-blocked", "improvised path", "unstable archway"],
        "decorations": ["shattered statues", "faded murals", "scattered artifacts"],
        "descriptorPoolPrefix": "style.ruins"
      },
      "rules": {
        "roomSizeRange": [3, 10],
        "multipleExitChance": 0.4,
        "averageExits": 2.0,
        "prefersSymmetry": false,
        "prefersRegularShapes": false,
        "corridorWidth": 0,
        "hiddenPassageChance": 0.25,
        "trapChance": 0.2
      }
    },
    {
      "id": "ancient-temples",
      "name": "Ancient Temples",
      "description": "Grand sacred chambers with ceremonial architecture and divine imagery.",
      "compatibleBiomes": ["ancient-ruins", "catacombs"],
      "preferredShapes": ["rectangular", "circular"],
      "commonFeatures": ["altar", "pillar", "statue", "offering-bowl", "eternal-flame"],
      "weight": 60,
      "usesDoors": true,
      "hasCorridors": true,
      "minDepth": 3,
      "tags": ["sacred", "grand", "ceremonial"],
      "descriptors": {
        "walls": ["sacred inscriptions", "polished marble", "divine imagery"],
        "floors": ["mosaic patterns", "ceremonial tiles", "altar platforms"],
        "ceilings": ["painted heavens", "domed sanctuaries", "celestial motifs"],
        "passages": ["ritual corridor", "pilgrimage path", "ceremonial gate"],
        "decorations": ["divine statues", "offering bowls", "eternal flames"],
        "descriptorPoolPrefix": "style.temples"
      },
      "rules": {
        "roomSizeRange": [5, 15],
        "multipleExitChance": 0.4,
        "averageExits": 2.0,
        "prefersSymmetry": true,
        "prefersRegularShapes": true,
        "corridorWidth": 2,
        "hiddenPassageChance": 0.2,
        "trapChance": 0.25
      }
    }
  ]
}
```

### Acceptance Criteria

- [ ] ArchitecturalStyle entity created with all properties
- [ ] StyleDescriptors supports all descriptor types
- [ ] StyleRules defines construction parameters
- [ ] Styles load from JSON configuration
- [ ] ArchitecturalStyleService provides lookup and selection
- [ ] Style-biome compatibility filtering works
- [ ] Style selection respects depth constraints
- [ ] Room templates filter by style
- [ ] Four default styles configured
- [ ] ~22 unit tests pass

---

## v0.1.3b: Room Shapes & Features

### Overview

Implement non-rectangular room shapes and structural features. Each shape has distinct geometry affecting exit placement and combat. Structural features add tactical elements like pillars for cover and platforms for height advantage.

### Scope

**In Scope:**
- `RoomShape` enum (Rectangular, Circular, LShaped, Irregular)
- `ShapeDefinition` value object for geometry rules
- `StructuralFeature` entity for room elements
- Shape-based exit placement logic
- Shape generation from architectural style
- Feature placement rules and configuration
- Room entity updates for shape and features

**Out of Scope:**
- Landmark rooms (v0.1.3c)
- Dungeon age system (v0.1.3d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 1 | `RoomShape` |
| Value Objects | 1 | `ShapeDefinition` |
| Entities | 1 | `StructuralFeature` |
| Services | 1 | `ShapeGeneratorService` |
| Configuration | 1 | `structural-features.json` |
| Entity Updates | 1 | `Room` shape and features |
| Unit Tests | ~25 | Shape, feature, placement tests |

### RoomShape Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the geometric shape of a room.
/// </summary>
public enum RoomShape
{
    /// <summary>
    /// Standard rectangular room with four walls.
    /// Exits on any wall. Most common shape.
    /// </summary>
    Rectangular,

    /// <summary>
    /// Circular or oval room. Often used for ritual spaces or arenas.
    /// Exits at cardinal points.
    /// </summary>
    Circular,

    /// <summary>
    /// L-shaped room with two connected rectangular sections.
    /// Good for ambush opportunities with line-of-sight breaks.
    /// </summary>
    LShaped,

    /// <summary>
    /// Irregular natural cavern with organic boundaries.
    /// Exits anywhere along perimeter.
    /// </summary>
    Irregular,

    /// <summary>
    /// T-shaped intersection with three branches.
    /// Common in corridor junctions.
    /// </summary>
    TShaped,

    /// <summary>
    /// Cross-shaped room with four branches from center.
    /// Ceremonial or defensive crossroads.
    /// </summary>
    Cross
}
```

### ShapeDefinition Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines geometry and behavior rules for a room shape.
/// </summary>
public readonly record struct ShapeDefinition
{
    /// <summary>
    /// Gets the shape type.
    /// </summary>
    public RoomShape Shape { get; init; }

    /// <summary>
    /// Gets the name of this shape.
    /// </summary>
    public string Name { get; init; }

    /// <summary>
    /// Gets valid exit directions for this shape.
    /// </summary>
    public IReadOnlyList<Direction> ValidExitDirections { get; init; }

    /// <summary>
    /// Gets the maximum number of exits.
    /// </summary>
    public int MaxExits { get; init; }

    /// <summary>
    /// Gets whether exits must be on cardinal directions.
    /// </summary>
    public bool RequiresCardinalExits { get; init; }

    /// <summary>
    /// Gets whether line of sight is always clear.
    /// </summary>
    public bool ClearLineOfSight { get; init; }

    /// <summary>
    /// Gets cover positions as a percentage of room area.
    /// </summary>
    public float NaturalCoverPercent { get; init; }

    /// <summary>
    /// Gets the typical area multiplier vs rectangular.
    /// </summary>
    public float AreaMultiplier { get; init; }

    /// <summary>
    /// Gets descriptive text for this shape.
    /// </summary>
    public string ShapeDescriptor { get; init; }

    /// <summary>
    /// Gets rectangular shape definition.
    /// </summary>
    public static ShapeDefinition Rectangular => new()
    {
        Shape = RoomShape.Rectangular,
        Name = "Rectangular",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 4,
        RequiresCardinalExits = true,
        ClearLineOfSight = true,
        NaturalCoverPercent = 0f,
        AreaMultiplier = 1.0f,
        ShapeDescriptor = "rectangular chamber"
    };

    /// <summary>
    /// Gets circular shape definition.
    /// </summary>
    public static ShapeDefinition Circular => new()
    {
        Shape = RoomShape.Circular,
        Name = "Circular",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 4,
        RequiresCardinalExits = true,
        ClearLineOfSight = true,
        NaturalCoverPercent = 0f,
        AreaMultiplier = 0.785f, // Pi/4
        ShapeDescriptor = "circular chamber"
    };

    /// <summary>
    /// Gets L-shaped definition.
    /// </summary>
    public static ShapeDefinition LShaped => new()
    {
        Shape = RoomShape.LShaped,
        Name = "L-Shaped",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 3,
        RequiresCardinalExits = true,
        ClearLineOfSight = false, // Corners block LOS
        NaturalCoverPercent = 0.15f,
        AreaMultiplier = 0.75f,
        ShapeDescriptor = "L-shaped chamber"
    };

    /// <summary>
    /// Gets irregular shape definition.
    /// </summary>
    public static ShapeDefinition Irregular => new()
    {
        Shape = RoomShape.Irregular,
        Name = "Irregular",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 6,
        RequiresCardinalExits = false,
        ClearLineOfSight = false,
        NaturalCoverPercent = 0.25f,
        AreaMultiplier = 0.9f,
        ShapeDescriptor = "irregular cavern"
    };
}
```

### StructuralFeature Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a structural element that can appear in rooms.
/// </summary>
public class StructuralFeature
{
    /// <summary>
    /// Gets the unique identifier (e.g., "pillar").
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the description.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the feature category.
    /// </summary>
    public FeatureCategory Category { get; init; }

    /// <summary>
    /// Gets whether this feature provides cover.
    /// </summary>
    public bool ProvidesCover { get; init; }

    /// <summary>
    /// Gets the cover bonus percentage.
    /// </summary>
    public float CoverBonus { get; init; }

    /// <summary>
    /// Gets whether this feature blocks movement.
    /// </summary>
    public bool BlocksMovement { get; init; }

    /// <summary>
    /// Gets whether this feature blocks line of sight.
    /// </summary>
    public bool BlocksLineOfSight { get; init; }

    /// <summary>
    /// Gets whether this feature is climbable.
    /// </summary>
    public bool IsClimbable { get; init; }

    /// <summary>
    /// Gets height advantage if climbable.
    /// </summary>
    public int HeightAdvantage { get; init; }

    /// <summary>
    /// Gets whether this feature is interactive.
    /// </summary>
    public bool IsInteractive { get; init; }

    /// <summary>
    /// Gets the interaction type if interactive.
    /// </summary>
    public string? InteractionType { get; init; }

    /// <summary>
    /// Gets compatible architectural styles.
    /// </summary>
    public IReadOnlyList<string> CompatibleStyles { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets descriptors for room text generation.
    /// </summary>
    public IReadOnlyList<string> Descriptors { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the map symbol for display.
    /// </summary>
    public char MapSymbol { get; init; }
}

/// <summary>
/// Categories of structural features.
/// </summary>
public enum FeatureCategory
{
    /// <summary>Vertical support (pillars, columns).</summary>
    Support,

    /// <summary>Raised platform or level.</summary>
    Platform,

    /// <summary>Alcove or recessed area.</summary>
    Alcove,

    /// <summary>Water or liquid feature.</summary>
    Water,

    /// <summary>Decorative element.</summary>
    Decoration,

    /// <summary>Functional furniture.</summary>
    Furniture,

    /// <summary>Natural formation.</summary>
    Natural
}
```

### Room Updates

```csharp
// In Room.cs - new properties
/// <summary>
/// Gets the geometric shape of this room.
/// </summary>
public RoomShape Shape { get; private set; } = RoomShape.Rectangular;

/// <summary>
/// Gets the architectural style of this room.
/// </summary>
public string ArchitecturalStyleId { get; private set; } = "carved-halls";

/// <summary>
/// Gets structural features present in this room.
/// </summary>
public IReadOnlyList<RoomFeature> StructuralFeatures { get; private set; } = Array.Empty<RoomFeature>();

/// <summary>
/// Sets the room shape.
/// </summary>
public void SetShape(RoomShape shape)
{
    Shape = shape;
}

/// <summary>
/// Sets the architectural style.
/// </summary>
public void SetArchitecturalStyle(string styleId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(styleId);
    ArchitecturalStyleId = styleId;
}

/// <summary>
/// Adds a structural feature to the room.
/// </summary>
public void AddFeature(RoomFeature feature)
{
    var features = StructuralFeatures.ToList();
    features.Add(feature);
    StructuralFeatures = features;
}

/// <summary>
/// Represents a placed feature in a room.
/// </summary>
public readonly record struct RoomFeature
{
    public string FeatureId { get; init; }
    public string Position { get; init; } // "center", "north-wall", "corner-nw", etc.
    public int Quantity { get; init; }
}
```

### Structural Feature Configuration Example

```json
{
  "features": [
    {
      "id": "pillar",
      "name": "Stone Pillar",
      "description": "A thick stone column supporting the ceiling.",
      "category": "Support",
      "providesCover": true,
      "coverBonus": 0.5,
      "blocksMovement": true,
      "blocksLineOfSight": true,
      "isClimbable": false,
      "isInteractive": false,
      "compatibleStyles": ["carved-halls", "ancient-temples"],
      "descriptors": ["thick stone pillar", "carved column", "supporting column"],
      "mapSymbol": "O"
    },
    {
      "id": "raised-platform",
      "name": "Raised Platform",
      "description": "An elevated stone platform accessible by steps.",
      "category": "Platform",
      "providesCover": false,
      "coverBonus": 0,
      "blocksMovement": false,
      "blocksLineOfSight": false,
      "isClimbable": true,
      "heightAdvantage": 1,
      "isInteractive": false,
      "compatibleStyles": ["ancient-temples", "carved-halls"],
      "descriptors": ["raised dais", "elevated platform", "stepped altar base"],
      "mapSymbol": "="
    },
    {
      "id": "stalagmite",
      "name": "Stalagmite",
      "description": "A natural mineral formation rising from the floor.",
      "category": "Natural",
      "providesCover": true,
      "coverBonus": 0.3,
      "blocksMovement": true,
      "blocksLineOfSight": false,
      "isClimbable": false,
      "isInteractive": false,
      "compatibleStyles": ["natural-caves"],
      "descriptors": ["jagged stalagmite", "mineral spire", "crystalline formation"],
      "mapSymbol": "^"
    },
    {
      "id": "pool",
      "name": "Pool",
      "description": "A shallow pool of water.",
      "category": "Water",
      "providesCover": false,
      "coverBonus": 0,
      "blocksMovement": false,
      "blocksLineOfSight": false,
      "isClimbable": false,
      "isInteractive": true,
      "interactionType": "examine",
      "compatibleStyles": ["natural-caves", "ancient-temples"],
      "descriptors": ["still pool", "shallow water", "reflecting pool"],
      "mapSymbol": "~"
    },
    {
      "id": "balcony",
      "name": "Balcony",
      "description": "An elevated walkway along the walls.",
      "category": "Platform",
      "providesCover": true,
      "coverBonus": 0.25,
      "blocksMovement": false,
      "blocksLineOfSight": false,
      "isClimbable": true,
      "heightAdvantage": 2,
      "isInteractive": false,
      "compatibleStyles": ["carved-halls", "ancient-temples"],
      "descriptors": ["stone balcony", "elevated walkway", "overlooking gallery"],
      "mapSymbol": "_"
    }
  ]
}
```

### Acceptance Criteria

- [ ] RoomShape enum covers all specified shapes
- [ ] ShapeDefinition provides geometry rules
- [ ] StructuralFeature entity supports all feature types
- [ ] Features load from JSON configuration
- [ ] Room entity has Shape and StructuralFeatures
- [ ] Shape generation respects architectural style
- [ ] Exit placement follows shape rules
- [ ] Features provide cover/height as specified
- [ ] Feature placement rules work correctly
- [ ] ~25 unit tests pass

---

## v0.1.3c: Landmark Rooms

### Overview

Create hand-crafted landmark rooms for special encounters. These curated designs serve as centerpieces for boss fights, puzzle chambers, and safe havens. Landmark rooms have fixed layouts with specific features and content.

### Scope

**In Scope:**
- `LandmarkRoom` entity for curated designs
- Landmark configuration schema and JSON loading
- `LandmarkRoomService` for selection and generation
- Boss arena designs with combat features
- Puzzle chamber designs with interactive elements
- Safe haven designs with services/restoration
- Integration with RoomGeneratorService

**Out of Scope:**
- Dungeon age system (v0.1.3d)
- Coherence rules (v0.1.3d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `LandmarkRoom` |
| Value Objects | 1 | `LandmarkLayout` |
| Services | 1 | `LandmarkRoomService` |
| Configuration | 1 | `landmark-rooms.json` |
| Unit Tests | ~25 | Landmark definition, generation tests |

### LandmarkRoom Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a hand-crafted room design for special encounters.
/// </summary>
public class LandmarkRoom
{
    /// <summary>
    /// Gets the unique identifier (e.g., "boss-arena-dragon").
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the description shown to players.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the room type this landmark creates.
    /// </summary>
    public RoomType RoomType { get; init; }

    /// <summary>
    /// Gets the required room shape.
    /// </summary>
    public RoomShape Shape { get; init; }

    /// <summary>
    /// Gets the layout specification.
    /// </summary>
    public LandmarkLayout Layout { get; init; } = default;

    /// <summary>
    /// Gets compatible biomes (empty = any).
    /// </summary>
    public IReadOnlyList<string> CompatibleBiomes { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets compatible architectural styles (empty = any).
    /// </summary>
    public IReadOnlyList<string> CompatibleStyles { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the minimum depth where this can appear.
    /// </summary>
    public int MinDepth { get; init; }

    /// <summary>
    /// Gets the maximum depth (null = no limit).
    /// </summary>
    public int? MaxDepth { get; init; }

    /// <summary>
    /// Gets whether this room can only appear once per dungeon.
    /// </summary>
    public bool Unique { get; init; }

    /// <summary>
    /// Gets the selection weight.
    /// </summary>
    public int Weight { get; init; } = 100;

    /// <summary>
    /// Gets required difficulty rating for this landmark.
    /// </summary>
    public int? MinDifficulty { get; init; }

    /// <summary>
    /// Gets fixed features in this room.
    /// </summary>
    public IReadOnlyList<LandmarkFeature> Features { get; init; } = Array.Empty<LandmarkFeature>();

    /// <summary>
    /// Gets fixed monsters that spawn in this room.
    /// </summary>
    public IReadOnlyList<LandmarkSpawn> Spawns { get; init; } = Array.Empty<LandmarkSpawn>();

    /// <summary>
    /// Gets fixed loot in this room.
    /// </summary>
    public IReadOnlyList<LandmarkLoot> Loot { get; init; } = Array.Empty<LandmarkLoot>();

    /// <summary>
    /// Gets tags for filtering.
    /// </summary>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();
}

/// <summary>
/// A fixed feature placement in a landmark room.
/// </summary>
public readonly record struct LandmarkFeature
{
    public string FeatureId { get; init; }
    public string Position { get; init; }
    public int Quantity { get; init; }
}

/// <summary>
/// A fixed monster spawn in a landmark room.
/// </summary>
public readonly record struct LandmarkSpawn
{
    public string MonsterId { get; init; }
    public string Tier { get; init; }
    public int Count { get; init; }
    public bool IsBoss { get; init; }
}

/// <summary>
/// Fixed loot in a landmark room.
/// </summary>
public readonly record struct LandmarkLoot
{
    public string ItemId { get; init; }
    public int Quantity { get; init; }
    public string? ContainerType { get; init; }
    public bool Guaranteed { get; init; }
}
```

### LandmarkLayout Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines the layout specification for a landmark room.
/// </summary>
public readonly record struct LandmarkLayout
{
    /// <summary>
    /// Gets the size category.
    /// </summary>
    public RoomSizeCategory Size { get; init; }

    /// <summary>
    /// Gets fixed exit directions.
    /// </summary>
    public IReadOnlyList<Direction> FixedExits { get; init; }

    /// <summary>
    /// Gets whether additional exits can be added.
    /// </summary>
    public bool AllowAdditionalExits { get; init; }

    /// <summary>
    /// Gets special terrain zones.
    /// </summary>
    public IReadOnlyList<TerrainZone> TerrainZones { get; init; }

    /// <summary>
    /// Gets the central feature (if any).
    /// </summary>
    public string? CentralFeature { get; init; }

    /// <summary>
    /// Gets special lighting for this room.
    /// </summary>
    public string? SpecialLighting { get; init; }

    /// <summary>
    /// Gets ambient effects active in this room.
    /// </summary>
    public IReadOnlyList<string> AmbientEffects { get; init; }
}

/// <summary>
/// Room size categories.
/// </summary>
public enum RoomSizeCategory
{
    Small,      // 3-5 tiles
    Medium,     // 6-9 tiles
    Large,      // 10-15 tiles
    Grand,      // 16-25 tiles
    Massive     // 26+ tiles
}

/// <summary>
/// A special terrain zone within a room.
/// </summary>
public readonly record struct TerrainZone
{
    public string ZoneType { get; init; }    // "lava", "water", "pit", "raised"
    public string Position { get; init; }     // "center", "perimeter", "corners"
    public float Coverage { get; init; }      // Percentage of room
}
```

### LandmarkRoomService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for landmark room selection and generation.
/// </summary>
public class LandmarkRoomService : ILandmarkRoomService
{
    private readonly IConfigurationProvider _config;
    private readonly IStructuralFeatureService _featureService;
    private readonly SeededRandomService _random;
    private readonly ILogger<LandmarkRoomService> _logger;

    private readonly HashSet<string> _usedUniqueLandmarks = new();

    /// <summary>
    /// Gets a landmark room by ID.
    /// </summary>
    public LandmarkRoom? GetLandmark(string landmarkId)
    {
        return _config.GetLandmarkRooms()
            .FirstOrDefault(l => l.Id == landmarkId);
    }

    /// <summary>
    /// Gets landmarks for a room type.
    /// </summary>
    public IReadOnlyList<LandmarkRoom> GetLandmarksForType(RoomType roomType)
    {
        return _config.GetLandmarkRooms()
            .Where(l => l.RoomType == roomType)
            .ToList();
    }

    /// <summary>
    /// Gets landmarks valid for context.
    /// </summary>
    public IReadOnlyList<LandmarkRoom> GetValidLandmarks(
        RoomType roomType,
        string biomeId,
        string styleId,
        int depth,
        int difficulty)
    {
        return _config.GetLandmarkRooms()
            .Where(l => l.RoomType == roomType)
            .Where(l => l.MinDepth <= depth)
            .Where(l => !l.MaxDepth.HasValue || l.MaxDepth.Value >= depth)
            .Where(l => !l.MinDifficulty.HasValue || difficulty >= l.MinDifficulty.Value)
            .Where(l => !l.CompatibleBiomes.Any() || l.CompatibleBiomes.Contains(biomeId))
            .Where(l => !l.CompatibleStyles.Any() || l.CompatibleStyles.Contains(styleId))
            .Where(l => !l.Unique || !_usedUniqueLandmarks.Contains(l.Id))
            .ToList();
    }

    /// <summary>
    /// Selects a landmark for a special room.
    /// </summary>
    public LandmarkRoom? SelectLandmark(
        RoomType roomType,
        Position3D position,
        string biomeId,
        string styleId,
        int difficulty)
    {
        var valid = GetValidLandmarks(roomType, biomeId, styleId, position.Z, difficulty);

        if (!valid.Any())
        {
            _logger.LogDebug(
                "No valid landmarks for {RoomType} at depth {Depth}",
                roomType,
                position.Z);
            return null;
        }

        var selected = _random.SelectWeighted(
            position,
            valid.Select(l => (l, l.Weight)),
            "landmark_select");

        if (selected.Unique)
        {
            _usedUniqueLandmarks.Add(selected.Id);
        }

        return selected;
    }

    /// <summary>
    /// Generates a room from a landmark definition.
    /// </summary>
    public Room GenerateFromLandmark(
        LandmarkRoom landmark,
        Position3D position,
        string biomeId)
    {
        var room = Room.Create(
            landmark.Name,
            landmark.Description,
            position);

        room.SetRoomType(landmark.RoomType);
        room.SetShape(landmark.Shape);
        room.SetBiome(biomeId);

        // Add fixed features
        foreach (var feature in landmark.Features)
        {
            room.AddFeature(new RoomFeature
            {
                FeatureId = feature.FeatureId,
                Position = feature.Position,
                Quantity = feature.Quantity
            });
        }

        // Add fixed exits
        foreach (var direction in landmark.Layout.FixedExits)
        {
            room.AddExit(direction, isHidden: false);
        }

        _logger.LogInformation(
            "Generated landmark room {Landmark} at {Position}",
            landmark.Id,
            position);

        return room;
    }

    /// <summary>
    /// Resets unique landmark tracking for new dungeon.
    /// </summary>
    public void ResetUniqueLandmarks()
    {
        _usedUniqueLandmarks.Clear();
    }
}
```

### Landmark Room Configuration Example

```json
{
  "landmarks": [
    {
      "id": "boss-arena-standard",
      "name": "Grand Arena",
      "description": "A vast circular chamber designed for epic confrontations. Pillars ring the perimeter, and a raised central platform commands attention.",
      "roomType": "Boss",
      "shape": "Circular",
      "layout": {
        "size": "Grand",
        "fixedExits": ["South"],
        "allowAdditionalExits": false,
        "centralFeature": "raised-platform",
        "terrainZones": [],
        "specialLighting": "dramatic spotlight",
        "ambientEffects": ["echoing", "tension"]
      },
      "compatibleBiomes": [],
      "compatibleStyles": ["carved-halls", "ancient-temples"],
      "minDepth": 3,
      "unique": false,
      "weight": 100,
      "features": [
        { "featureId": "pillar", "position": "perimeter", "quantity": 8 },
        { "featureId": "raised-platform", "position": "center", "quantity": 1 }
      ],
      "spawns": [
        { "monsterId": null, "tier": "boss", "count": 1, "isBoss": true }
      ],
      "loot": [
        { "itemId": null, "quantity": 1, "containerType": "boss-chest", "guaranteed": true }
      ],
      "tags": ["boss", "arena", "combat"]
    },
    {
      "id": "boss-arena-volcanic",
      "name": "Magma Lord's Throne",
      "description": "A scorching chamber where rivers of lava flow around a central obsidian platform. Heat shimmers distort the air.",
      "roomType": "Boss",
      "shape": "Circular",
      "layout": {
        "size": "Grand",
        "fixedExits": ["North"],
        "allowAdditionalExits": false,
        "centralFeature": "obsidian-throne",
        "terrainZones": [
          { "zoneType": "lava", "position": "perimeter", "coverage": 0.3 }
        ],
        "specialLighting": "molten glow",
        "ambientEffects": ["heat-shimmer", "volcanic-rumble"]
      },
      "compatibleBiomes": ["volcanic-caverns"],
      "compatibleStyles": ["natural-caves"],
      "minDepth": 6,
      "unique": true,
      "weight": 100,
      "features": [
        { "featureId": "lava-pool", "position": "perimeter", "quantity": 4 },
        { "featureId": "obsidian-pillar", "position": "inner-ring", "quantity": 4 }
      ],
      "spawns": [
        { "monsterId": "magma-lord", "tier": "boss", "count": 1, "isBoss": true }
      ],
      "loot": [
        { "itemId": "heart-of-the-mountain", "quantity": 1, "guaranteed": true }
      ],
      "tags": ["boss", "volcanic", "fire", "unique"]
    },
    {
      "id": "safe-haven-shrine",
      "name": "Sacred Shrine",
      "description": "A peaceful sanctuary where divine light filters through crystal formations. A healing spring bubbles gently in the center.",
      "roomType": "Safe",
      "shape": "Circular",
      "layout": {
        "size": "Medium",
        "fixedExits": ["South"],
        "allowAdditionalExits": true,
        "centralFeature": "healing-spring",
        "terrainZones": [],
        "specialLighting": "divine radiance",
        "ambientEffects": ["peaceful", "regenerating"]
      },
      "compatibleBiomes": ["ancient-ruins", "catacombs"],
      "compatibleStyles": ["ancient-temples"],
      "minDepth": 2,
      "unique": false,
      "weight": 80,
      "features": [
        { "featureId": "healing-spring", "position": "center", "quantity": 1 },
        { "featureId": "offering-altar", "position": "north", "quantity": 1 }
      ],
      "spawns": [],
      "loot": [],
      "tags": ["safe", "healing", "sacred"]
    },
    {
      "id": "puzzle-chamber-pressure",
      "name": "Chamber of Weighted Stones",
      "description": "Ancient pressure plates pattern the floor. Statues stand in alcoves, their stone eyes seeming to watch your every move.",
      "roomType": "Trap",
      "shape": "Rectangular",
      "layout": {
        "size": "Large",
        "fixedExits": ["South", "North"],
        "allowAdditionalExits": false,
        "centralFeature": null,
        "terrainZones": [
          { "zoneType": "pressure-plates", "position": "floor-grid", "coverage": 0.6 }
        ],
        "specialLighting": "dim torch flicker",
        "ambientEffects": ["ominous", "mechanical-tension"]
      },
      "compatibleBiomes": ["ancient-ruins"],
      "compatibleStyles": ["ancient-temples", "carved-halls"],
      "minDepth": 3,
      "unique": false,
      "weight": 70,
      "minDifficulty": 20,
      "features": [
        { "featureId": "alcove-statue", "position": "walls", "quantity": 4 },
        { "featureId": "pressure-plate", "position": "floor-grid", "quantity": 9 }
      ],
      "spawns": [],
      "loot": [
        { "itemId": null, "quantity": 1, "containerType": "puzzle-reward-chest", "guaranteed": true }
      ],
      "tags": ["puzzle", "trap", "pressure", "interactive"]
    },
    {
      "id": "treasure-vault-guarded",
      "name": "Guardian's Treasury",
      "description": "Gleaming treasures fill this chamber, but animated guardians stand eternal watch over the hoard.",
      "roomType": "Treasure",
      "shape": "Rectangular",
      "layout": {
        "size": "Large",
        "fixedExits": ["South"],
        "allowAdditionalExits": false,
        "centralFeature": "treasure-pile",
        "terrainZones": [],
        "specialLighting": "gold reflection",
        "ambientEffects": ["wealthy", "guarded"]
      },
      "compatibleBiomes": ["ancient-ruins", "catacombs"],
      "compatibleStyles": ["carved-halls", "ancient-temples"],
      "minDepth": 4,
      "unique": false,
      "weight": 60,
      "features": [
        { "featureId": "treasure-pile", "position": "center", "quantity": 1 },
        { "featureId": "pillar", "position": "corners", "quantity": 4 }
      ],
      "spawns": [
        { "monsterId": "animated-armor", "tier": "elite", "count": 2, "isBoss": false }
      ],
      "loot": [
        { "itemId": null, "quantity": 3, "containerType": "treasure-chest", "guaranteed": true },
        { "itemId": "gold", "quantity": 500, "guaranteed": true }
      ],
      "tags": ["treasure", "guarded", "wealthy"]
    }
  ]
}
```

### Acceptance Criteria

- [ ] LandmarkRoom entity supports all landmark types
- [ ] LandmarkLayout defines room structure
- [ ] Landmarks load from JSON configuration
- [ ] LandmarkRoomService selects appropriate landmarks
- [ ] Unique landmarks only appear once
- [ ] Landmark features are placed correctly
- [ ] Boss arenas have combat-appropriate layouts
- [ ] Safe havens provide restoration features
- [ ] Puzzle chambers have interactive elements
- [ ] ~25 unit tests pass

---

## v0.1.3d: Dungeon Age & Coherence

### Overview

Implement dungeon age/decay affecting descriptors and hazards, plus structural coherence rules ensuring logical architecture. Age determines whether structures are fresh, ancient, collapsed, or reclaimed by nature.

### Scope

**In Scope:**
- `DungeonAge` enum (Fresh, Ancient, Collapsed, Reclaimed)
- `AgeDescriptors` value object for age-specific text
- `CoherenceRules` configuration for structural logic
- `MaterialPalette` value object for consistent materials
- Corridor generation rules by style
- Age-based hazard modifiers
- Age-based descriptor overlays

**Out of Scope:**
- Custom age creation (future version)
- Age progression over time (future version)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 1 | `DungeonAge` |
| Value Objects | 3 | `AgeDescriptors`, `MaterialPalette`, `CoherenceRules` |
| Services | 1 | `CoherenceService` |
| Configuration | 2 | `dungeon-ages.json`, `coherence-rules.json` |
| Entity Updates | 1 | `Room.Age` property |
| Unit Tests | ~23 | Age, coherence, material tests |

### DungeonAge Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the age and condition of dungeon structures.
/// </summary>
public enum DungeonAge
{
    /// <summary>
    /// Recently constructed or maintained. Clean, intact, possibly occupied.
    /// </summary>
    Fresh,

    /// <summary>
    /// Long abandoned. Dusty, worn, faded but structurally sound.
    /// </summary>
    Ancient,

    /// <summary>
    /// Partially destroyed. Rubble, blocked passages, unstable.
    /// </summary>
    Collapsed,

    /// <summary>
    /// Nature overtaking. Vegetation, water damage, wildlife.
    /// </summary>
    Reclaimed
}
```

### AgeDescriptors Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Descriptors that overlay based on dungeon age.
/// </summary>
public readonly record struct AgeDescriptors
{
    /// <summary>
    /// Gets the age this applies to.
    /// </summary>
    public DungeonAge Age { get; init; }

    /// <summary>
    /// Gets condition modifiers for surfaces.
    /// </summary>
    public IReadOnlyList<string> SurfaceConditions { get; init; }

    /// <summary>
    /// Gets atmosphere modifiers.
    /// </summary>
    public IReadOnlyList<string> AtmosphereModifiers { get; init; }

    /// <summary>
    /// Gets debris and clutter descriptors.
    /// </summary>
    public IReadOnlyList<string> Debris { get; init; }

    /// <summary>
    /// Gets lighting modifiers.
    /// </summary>
    public IReadOnlyList<string> LightingModifiers { get; init; }

    /// <summary>
    /// Gets smell modifiers.
    /// </summary>
    public IReadOnlyList<string> SmellModifiers { get; init; }

    /// <summary>
    /// Gets fresh age descriptors.
    /// </summary>
    public static AgeDescriptors Fresh => new()
    {
        Age = DungeonAge.Fresh,
        SurfaceConditions = new[] { "clean", "well-maintained", "recently swept", "polished" },
        AtmosphereModifiers = new[] { "lived-in", "active", "occupied" },
        Debris = Array.Empty<string>(),
        LightingModifiers = new[] { "well-lit", "maintained torches", "fresh candles" },
        SmellModifiers = new[] { "recent habitation", "burning oil", "cooked food" }
    };

    /// <summary>
    /// Gets ancient age descriptors.
    /// </summary>
    public static AgeDescriptors Ancient => new()
    {
        Age = DungeonAge.Ancient,
        SurfaceConditions = new[] { "dust-covered", "faded", "worn smooth", "time-weathered" },
        AtmosphereModifiers = new[] { "long-abandoned", "forgotten", "silent for ages" },
        Debris = new[] { "scattered dust", "cobwebs", "faded remnants" },
        LightingModifiers = new[] { "dim", "shadows deepened by time", "ancient darkness" },
        SmellModifiers = new[] { "ancient dust", "stale air", "the scent of ages" }
    };

    /// <summary>
    /// Gets collapsed age descriptors.
    /// </summary>
    public static AgeDescriptors Collapsed => new()
    {
        Age = DungeonAge.Collapsed,
        SurfaceConditions = new[] { "crumbling", "fractured", "unstable", "ruined" },
        AtmosphereModifiers = new[] { "dangerous", "precarious", "threatening collapse" },
        Debris = new[] { "fallen stones", "rubble piles", "debris", "broken supports" },
        LightingModifiers = new[] { "shafts through gaps", "dust-filtered light", "unstable shadows" },
        SmellModifiers = new[] { "dust and decay", "crushed stone", "exposed earth" }
    };

    /// <summary>
    /// Gets reclaimed age descriptors.
    /// </summary>
    public static AgeDescriptors Reclaimed => new()
    {
        Age = DungeonAge.Reclaimed,
        SurfaceConditions = new[] { "vine-covered", "moss-grown", "root-cracked", "nature-claimed" },
        AtmosphereModifiers = new[] { "wild", "untamed", "returning to nature" },
        Debris = new[] { "fallen leaves", "animal droppings", "bird nests", "pooled water" },
        LightingModifiers = new[] { "filtered through growth", "dappled green", "natural light through gaps" },
        SmellModifiers = new[] { "growing things", "damp earth", "wild animals", "fresh growth" }
    };
}
```

### MaterialPalette Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines consistent materials for a dungeon region.
/// </summary>
public readonly record struct MaterialPalette
{
    /// <summary>
    /// Gets the primary wall material.
    /// </summary>
    public string PrimaryMaterial { get; init; }

    /// <summary>
    /// Gets the secondary/accent material.
    /// </summary>
    public string SecondaryMaterial { get; init; }

    /// <summary>
    /// Gets the floor material.
    /// </summary>
    public string FloorMaterial { get; init; }

    /// <summary>
    /// Gets decorative metal used.
    /// </summary>
    public string MetalAccent { get; init; }

    /// <summary>
    /// Gets the color palette.
    /// </summary>
    public IReadOnlyList<string> Colors { get; init; }

    /// <summary>
    /// Creates a material palette for a biome.
    /// </summary>
    public static MaterialPalette ForBiome(string biomeId) => biomeId switch
    {
        "catacombs" => new MaterialPalette
        {
            PrimaryMaterial = "limestone",
            SecondaryMaterial = "marble",
            FloorMaterial = "worn flagstone",
            MetalAccent = "tarnished bronze",
            Colors = new[] { "bone white", "gray", "faded gold" }
        },
        "volcanic-caverns" => new MaterialPalette
        {
            PrimaryMaterial = "obsidian",
            SecondaryMaterial = "basalt",
            FloorMaterial = "cooled lava",
            MetalAccent = "blackened iron",
            Colors = new[] { "black", "red", "orange glow" }
        },
        "frozen-depths" => new MaterialPalette
        {
            PrimaryMaterial = "blue ice",
            SecondaryMaterial = "frosted stone",
            FloorMaterial = "frozen ground",
            MetalAccent = "silver",
            Colors = new[] { "ice blue", "white", "pale silver" }
        },
        _ => new MaterialPalette
        {
            PrimaryMaterial = "gray stone",
            SecondaryMaterial = "granite",
            FloorMaterial = "stone tiles",
            MetalAccent = "iron",
            Colors = new[] { "gray", "brown", "dark" }
        }
    };
}
```

### CoherenceService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for ensuring structural coherence in generated dungeons.
/// </summary>
public class CoherenceService : ICoherenceService
{
    private readonly IConfigurationProvider _config;
    private readonly IArchitecturalStyleService _styleService;
    private readonly IBiomeService _biomeService;
    private readonly ILogger<CoherenceService> _logger;

    /// <summary>
    /// Gets the material palette for a biome/style combination.
    /// </summary>
    public MaterialPalette GetMaterialPalette(string biomeId, string styleId)
    {
        var basePalette = MaterialPalette.ForBiome(biomeId);
        var style = _styleService.GetStyle(styleId);

        // Style can modify the palette
        if (style != null && style.Tags.Contains("constructed"))
        {
            return basePalette with
            {
                FloorMaterial = "fitted " + basePalette.FloorMaterial
            };
        }

        return basePalette;
    }

    /// <summary>
    /// Determines if a corridor is needed between rooms.
    /// </summary>
    public bool RequiresCorridor(
        Room fromRoom,
        Room toRoom,
        ArchitecturalStyle style)
    {
        if (!style.HasCorridors) return false;

        // Same room type might not need corridor
        if (fromRoom.RoomType == toRoom.RoomType) return false;

        // Caves don't use formal corridors
        if (style.Id == "natural-caves") return false;

        return true;
    }

    /// <summary>
    /// Determines if support features are needed.
    /// </summary>
    public IReadOnlyList<string> GetRequiredSupports(
        Room room,
        ArchitecturalStyle style)
    {
        var supports = new List<string>();

        // Large rooms need supports in constructed styles
        if (style.Tags.Contains("constructed") &&
            room.Shape != RoomShape.Irregular)
        {
            var sizeThreshold = style.Rules.RoomSizeRange.Max * 0.7f;

            // Assuming room has a size property or we calculate from shape
            if (style.CommonFeatures.Contains("pillar"))
            {
                supports.Add("pillar");
            }
        }

        return supports;
    }

    /// <summary>
    /// Gets age-modified descriptors for a room.
    /// </summary>
    public string GetAgeModifiedDescription(
        Room room,
        DungeonAge age,
        string baseDescription)
    {
        var ageDescriptors = age switch
        {
            DungeonAge.Fresh => AgeDescriptors.Fresh,
            DungeonAge.Ancient => AgeDescriptors.Ancient,
            DungeonAge.Collapsed => AgeDescriptors.Collapsed,
            DungeonAge.Reclaimed => AgeDescriptors.Reclaimed,
            _ => AgeDescriptors.Ancient
        };

        // Add condition modifiers
        var condition = ageDescriptors.SurfaceConditions.FirstOrDefault() ?? "";
        var atmosphere = ageDescriptors.AtmosphereModifiers.FirstOrDefault() ?? "";

        return $"{baseDescription} The {condition} surfaces speak of a {atmosphere} place.";
    }

    /// <summary>
    /// Gets hazard modifiers for dungeon age.
    /// </summary>
    public float GetAgeHazardModifier(DungeonAge age) => age switch
    {
        DungeonAge.Fresh => 0.5f,      // Fewer natural hazards
        DungeonAge.Ancient => 1.0f,     // Normal hazards
        DungeonAge.Collapsed => 1.5f,   // More structural hazards
        DungeonAge.Reclaimed => 1.2f,   // Nature hazards
        _ => 1.0f
    };

    /// <summary>
    /// Validates structural coherence of a dungeon region.
    /// </summary>
    public CoherenceValidationResult ValidateCoherence(
        IEnumerable<Room> rooms,
        string expectedStyle)
    {
        var roomList = rooms.ToList();
        var issues = new List<string>();

        // Check style consistency
        var styleViolations = roomList
            .Where(r => r.ArchitecturalStyleId != expectedStyle)
            .Count();

        if (styleViolations > roomList.Count * 0.2f)
        {
            issues.Add($"Too many style inconsistencies ({styleViolations}/{roomList.Count})");
        }

        // Check material consistency
        var biomes = roomList.Select(r => r.BiomeId).Distinct().ToList();
        if (biomes.Count > 2)
        {
            issues.Add("Too many biome transitions without proper zones");
        }

        return new CoherenceValidationResult
        {
            IsValid = !issues.Any(),
            Issues = issues
        };
    }
}

/// <summary>
/// Result of coherence validation.
/// </summary>
public readonly record struct CoherenceValidationResult
{
    public bool IsValid { get; init; }
    public IReadOnlyList<string> Issues { get; init; }
}
```

### Dungeon Age Configuration

```json
{
  "ages": [
    {
      "id": "fresh",
      "name": "Fresh",
      "description": "Recently constructed or actively maintained structures.",
      "hazardModifier": 0.5,
      "trapFunctionality": 1.0,
      "lootQualityModifier": 0.9,
      "encounterModifier": 1.2,
      "surfaceConditions": ["clean", "well-maintained", "recently swept"],
      "atmosphereModifiers": ["lived-in", "active", "occupied"],
      "debris": [],
      "lightingModifiers": ["well-lit", "maintained torches"],
      "smellModifiers": ["recent habitation", "burning oil"]
    },
    {
      "id": "ancient",
      "name": "Ancient",
      "description": "Long abandoned but structurally sound ruins.",
      "hazardModifier": 1.0,
      "trapFunctionality": 0.7,
      "lootQualityModifier": 1.0,
      "encounterModifier": 0.8,
      "surfaceConditions": ["dust-covered", "faded", "worn smooth"],
      "atmosphereModifiers": ["long-abandoned", "forgotten", "silent"],
      "debris": ["scattered dust", "cobwebs", "faded remnants"],
      "lightingModifiers": ["dim", "shadows deepened by time"],
      "smellModifiers": ["ancient dust", "stale air"]
    },
    {
      "id": "collapsed",
      "name": "Collapsed",
      "description": "Partially destroyed and structurally unstable.",
      "hazardModifier": 1.5,
      "trapFunctionality": 0.3,
      "lootQualityModifier": 0.8,
      "encounterModifier": 0.6,
      "surfaceConditions": ["crumbling", "fractured", "unstable"],
      "atmosphereModifiers": ["dangerous", "precarious", "threatening"],
      "debris": ["fallen stones", "rubble piles", "debris"],
      "lightingModifiers": ["shafts through gaps", "dust-filtered"],
      "smellModifiers": ["dust and decay", "crushed stone"]
    },
    {
      "id": "reclaimed",
      "name": "Reclaimed",
      "description": "Nature overtaking former structures.",
      "hazardModifier": 1.2,
      "trapFunctionality": 0.1,
      "lootQualityModifier": 0.7,
      "encounterModifier": 1.0,
      "surfaceConditions": ["vine-covered", "moss-grown", "root-cracked"],
      "atmosphereModifiers": ["wild", "untamed", "returning to nature"],
      "debris": ["fallen leaves", "animal droppings", "pooled water"],
      "lightingModifiers": ["filtered through growth", "dappled green"],
      "smellModifiers": ["growing things", "damp earth", "wildlife"]
    }
  ]
}
```

### Room Age Update

```csharp
// In Room.cs
/// <summary>
/// Gets the age/condition of this room's structures.
/// </summary>
public DungeonAge Age { get; private set; } = DungeonAge.Ancient;

/// <summary>
/// Sets the dungeon age for this room.
/// </summary>
public void SetAge(DungeonAge age)
{
    Age = age;
}
```

### Acceptance Criteria

- [ ] DungeonAge enum covers all age states
- [ ] AgeDescriptors provides age-specific text
- [ ] MaterialPalette ensures consistent materials
- [ ] CoherenceService validates structural logic
- [ ] Room entity has Age property
- [ ] Age modifies hazard probabilities
- [ ] Corridor generation respects style rules
- [ ] Age descriptors overlay on room descriptions
- [ ] Material consistency maintained per region
- [ ] ~23 unit tests pass

---

## Dependencies & Prerequisites

```
v0.1.2 (Dungeon Theming & Biomes) - REQUIRED
    
     BiomeDefinition, BiomeDescriptors, BiomeService 
     BiomeSpawnTable, BiomeHazard                                   
     BiomeTransition, DescriptorService integration                 
                                                                       
                                                                       
v0.1.3 (Advanced Procedural Architecture)
    
     v0.1.3a: Architectural Styles 
           Dependencies: v0.1.2a (BiomeDefinition)                    
                         v0.1.1a (RoomTemplate)                       
                                                                      
     v0.1.3b: Room Shapes & Features 
           Dependencies: v0.1.3a (ArchitecturalStyle)                 
                         v0.1.0 (Room, Direction)                     
                                                                      
     v0.1.3c: Landmark Rooms 
           Dependencies: v0.1.3a, v0.1.3b                             
                         v0.0.9 (TierDefinition for bosses)           
                                                                      
     v0.1.3d: Dungeon Age & Coherence 
            Dependencies: v0.1.3a, v0.1.3b, v0.1.3c
                         v0.1.2c (BiomeHazard for age modifiers)
```

**Note:** Phases are sequential - each depends on prior phases within v0.1.3.

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.1.3a | ~5 | ~3 | ~22 | High |
| v0.1.3b | ~4 | ~3 | ~25 | High |
| v0.1.3c | ~4 | ~2 | ~25 | Medium |
| v0.1.3d | ~5 | ~4 | ~23 | High |
| **Total** | **~18** | **~12** | **~95** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Style/biome compatibility complexity | Medium | Medium | Clear compatibility matrix |
| Shape geometry affecting gameplay | High | Medium | Extensive playtesting |
| Landmark uniqueness feeling forced | Medium | Low | Pool variety, optional usage |
| Coherence rules too restrictive | Medium | Medium | Configurable, flexible rules |
| Age system adding too much complexity | Low | Low | Age as descriptor overlay |

---

## Design Decisions

### Architectural Styles

| Decision | Value | Notes |
|----------|-------|-------|
| **Style storage** | JSON configuration | Easy to mod/extend |
| **Style-biome relationship** | Compatibility list | Flexible matching |
| **Corridor handling** | Per-style rules | Natural vs constructed |
| **Door usage** | Per-style flag | Caves vs halls |

### Room Shapes

| Decision | Value | Notes |
|----------|-------|-------|
| **Shape count** | 6 shapes | Covers common geometries |
| **Exit placement** | Shape-dependent | Realistic exits |
| **LOS/cover** | Shape-based | Tactical variety |
| **Feature compatibility** | Shape-aware | Sensible placement |

### Landmark Rooms

| Decision | Value | Notes |
|----------|-------|-------|
| **Unique flag** | Per-landmark | Prevents repetition |
| **Fixed layouts** | Full specification | Curated experience |
| **Biome filtering** | Optional list | Thematic consistency |
| **Difficulty gating** | Min difficulty | Progression-aware |

### Age & Coherence

| Decision | Value | Notes |
|----------|-------|-------|
| **Age as overlay** | Descriptor modifiers | Non-destructive |
| **Material palette** | Per-biome base | Consistency |
| **Coherence validation** | Soft warnings | Not blocking |
| **Hazard modifiers** | Age-based multipliers | Environmental storytelling |

---

## Files Summary

### Files to Create (New)

| Phase | File | Purpose |
|-------|------|---------|
| 1a | `ArchitecturalStyle.cs` | Style entity |
| 1a | `StyleDescriptors.cs` | Style descriptors |
| 1a | `StyleRules.cs` | Construction rules |
| 1a | `ArchitecturalStyleService.cs` | Style management |
| 1a | `architectural-styles.json` | Style configuration |
| 1b | `RoomShape.cs` | Shape enum |
| 1b | `ShapeDefinition.cs` | Shape geometry |
| 1b | `StructuralFeature.cs` | Feature entity |
| 1b | `structural-features.json` | Feature configuration |
| 1c | `LandmarkRoom.cs` | Landmark entity |
| 1c | `LandmarkLayout.cs` | Layout specification |
| 1c | `LandmarkRoomService.cs` | Landmark management |
| 1c | `landmark-rooms.json` | Landmark configuration |
| 1d | `DungeonAge.cs` | Age enum |
| 1d | `AgeDescriptors.cs` | Age descriptors |
| 1d | `MaterialPalette.cs` | Material consistency |
| 1d | `CoherenceService.cs` | Coherence validation |
| 1d | `dungeon-ages.json` | Age configuration |

### Files to Modify

| Phase | File | Changes |
|-------|------|---------|
| 1a | `RoomGeneratorService.cs` | Style integration |
| 1a | `IConfigurationProvider.cs` | Style loading |
| 1a | `Room.cs` | ArchitecturalStyleId property |
| 1b | `Room.cs` | Shape, StructuralFeatures |
| 1b | `RoomGeneratorService.cs` | Shape generation |
| 1c | `RoomGeneratorService.cs` | Landmark integration |
| 1d | `Room.cs` | Age property |
| 1d | `DescriptorService.cs` | Age overlays |
| 1d | `HazardService.cs` | Age modifiers |

---

## Final Metrics

| Metric | Before v0.1.3 | After v0.1.3 |
|--------|---------------|--------------|
| Architectural styles | 0 | 4 |
| Room shapes | 1 (rectangular) | 6 |
| Structural features | 0 | 10+ |
| Landmark rooms | 0 | 10+ |
| Dungeon ages | 0 | 4 |
| Material palettes | 0 | Per-biome |
| Unit tests (architecture) | 0 | ~95 |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.1.3a Design Spec** - Create architectural style specification
3. **Implement v0.1.3a** - Build style system
4. **v0.1.3b Design Spec** - Create room shapes specification
5. **Implement v0.1.3b** - Build shape and feature systems
6. **v0.1.3c Design Spec** - Create landmark specification
7. **Implement v0.1.3c** - Build landmark system
8. **v0.1.3d Design Spec** - Create age/coherence specification
9. **Implement v0.1.3d** - Build age and coherence systems

---

*This scope breakdown establishes a comprehensive architectural intelligence system. Architectural styles define construction patterns, room shapes add geometric variety, landmark rooms provide curated centerpieces, and the age/coherence system ensures environmental storytelling. Together, these features transform procedural dungeons into believable, designed spaces.*
