# v0.0.5b Implementation Plan: Skill Check System

**Version:** 0.0.5b
**Parent:** v0.0.5 (Dice Pool System)
**Prerequisite:** v0.0.5a Complete (Core Dice Engine)
**Status:** Ready for Implementation
**Target Tests:** 220 → 240 (+20 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from v0.0.5a](#dependencies-from-v005a)
3. [Dependencies from v0.0.4a-d](#dependencies-from-v004a-d)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Infrastructure Layer](#infrastructure-layer)
   - [Configuration Files](#configuration-files)
5. [Testing Strategy](#testing-strategy)
6. [Logging Strategy](#logging-strategy)
7. [Implementation Checklist](#implementation-checklist)
8. [Acceptance Criteria](#acceptance-criteria)
9. [Risk Assessment](#risk-assessment)
10. [File Summary](#file-summary)

---

## Executive Summary

### Purpose
Phase 5b builds the skill check framework that integrates dice rolls with player attributes and configuration-driven skills. This phase enables non-combat actions like perception checks, lockpicking attempts, and social interactions to use dice-based mechanics.

### Scope
- **In Scope:** Skill definitions, difficulty classes, skill check service, skill check results, configuration loading
- **Out of Scope:** Combat integration (5c), UI rendering (5d), commands (5d)

### Key Deliverables

| Type | Count | Files |
|------|-------|-------|
| Domain Definitions | 2 | SkillDefinition, DifficultyClassDefinition |
| Domain Value Objects | 1 | SkillCheckResult |
| Application Services | 1 | SkillCheckService |
| Application DTOs | 1 | SkillCheckDtos.cs |
| Configuration Files | 2 | skills.json, difficulty.json |
| Unit Tests | 20 | 4 test files |

### Success Metrics
- All 20 new tests pass
- All existing tests (from v0.0.5a) continue to pass
- Build completes with 0 errors, 0 warnings
- Skills integrate with PlayerAttributes (Might, Fortitude, Will, Wits, Finesse)

---

## Dependencies from v0.0.5a

Phase 5b builds directly on the Core Dice Engine from v0.0.5a:

### Required Types from v0.0.5a

| Type | Location | Usage in 5b |
|------|----------|-------------|
| `DicePool` | `Domain/ValueObjects/DicePool.cs` | Parse skill's baseDicePool notation |
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Store raw dice roll in SkillCheckResult |
| `DiceService` | `Application/Services/DiceService.cs` | Roll dice for skill checks |
| `AdvantageType` | `Domain/Enums/AdvantageType.cs` | Support advantage/disadvantage on checks |
| `SuccessLevel` | `Domain/Enums/SuccessLevel.cs` | Determine check success level |
| `DiceRollDto` | `Application/DTOs/DiceDtos.cs` | Embed in SkillCheckResultDto |

### Integration Points

```
SkillCheckService
    ├── Uses DiceService.Roll(DicePool, AdvantageType)
    ├── Uses DicePool.Parse(string notation)
    ├── Uses SuccessLevel enum for results
    └── Embeds DiceRollResult in SkillCheckResult
```

---

## Dependencies from v0.0.4a-d

Phase 5b leverages the class-based combat infrastructure:

### Required Types from v0.0.4 Series

| Type | Location | Usage in 5b |
|------|----------|-------------|
| `Player` | `Domain/Entities/Player.cs` | Access Attributes for bonus calculation |
| `PlayerAttributes` | `Domain/ValueObjects/PlayerAttributes.cs` | Get Might, Fortitude, Will, Wits, Finesse values |
| `IGameConfigurationProvider` | `Application/Interfaces/IConfigurationProvider.cs` | Extend with skill/DC methods |
| `JsonConfigurationProvider` | `Infrastructure/Configuration/JsonConfigurationProvider.cs` | Load skills.json, difficulty.json |

### PlayerAttributes Integration

The skill check system maps skills to player attributes:

| Attribute | Skills Using as Primary |
|-----------|------------------------|
| **Might** | Athletics, Intimidation |
| **Finesse** | Acrobatics, Stealth, Lockpicking |
| **Will** | Persuasion, Arcana |
| **Wits** | Perception, Investigation |
| **Fortitude** | Endurance |

Secondary attributes provide half-bonus for some skills (e.g., Athletics uses Might + Fortitude/2).

---

## Detailed Implementation

### Domain Layer

#### 1. SkillDefinition.cs

**File:** `src/Core/RuneAndRust.Domain/Definitions/SkillDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a skill that can be checked against a difficulty class.
/// Skills are configured via JSON and linked to player attributes.
/// </summary>
/// <remarks>
/// <para>Each skill has a primary attribute (e.g., "finesse" for Lockpicking) that provides
/// a modifier bonus to the skill check roll.</para>
/// <para>Some skills have a secondary attribute that provides half its value as additional bonus.</para>
/// <para>Skills can require training; untrained attempts may incur penalties.</para>
/// </remarks>
/// <example>
/// <code>
/// var perception = SkillDefinition.Create(
///     id: "perception",
///     name: "Perception",
///     description: "Noticing hidden things and spotting danger.",
///     primaryAttribute: "wits",
///     category: "Mental");
/// </code>
/// </example>
public class SkillDefinition
{
    /// <summary>
    /// Gets the unique identifier for this skill.
    /// </summary>
    /// <remarks>
    /// IDs are lowercase, hyphenated strings (e.g., "lock-picking", "perception").
    /// Used as keys in configuration and skill check operations.
    /// </remarks>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name shown to players (e.g., "Lockpicking", "Perception").
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the description explaining what this skill covers.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the primary attribute that modifies this skill.
    /// </summary>
    /// <remarks>
    /// Must be one of: "might", "fortitude", "will", "wits", "finesse".
    /// The player's attribute value is added as a bonus to skill check rolls.
    /// </remarks>
    public string PrimaryAttribute { get; init; } = string.Empty;

    /// <summary>
    /// Gets the optional secondary attribute that provides half bonus.
    /// </summary>
    /// <remarks>
    /// When set, half of this attribute's value (rounded down) is added to the check.
    /// Example: Athletics uses Might (primary) + Fortitude/2 (secondary).
    /// </remarks>
    public string? SecondaryAttribute { get; init; }

    /// <summary>
    /// Gets the base dice pool notation for this skill (e.g., "1d20", "2d10").
    /// </summary>
    /// <remarks>
    /// Defaults to "1d10" for standard d10-based resolution.
    /// Parsed using <see cref="ValueObjects.DicePool.Parse"/> at check time.
    /// </remarks>
    public string BaseDicePool { get; init; } = "1d10";

    /// <summary>
    /// Gets whether this skill can be attempted without training.
    /// </summary>
    /// <remarks>
    /// If false, untrained attempts suffer the <see cref="UntrainedPenalty"/>.
    /// </remarks>
    public bool AllowUntrained { get; init; } = true;

    /// <summary>
    /// Gets the penalty applied when attempting this skill untrained.
    /// </summary>
    /// <remarks>
    /// Applied as a negative modifier when <see cref="AllowUntrained"/> is true
    /// but the player lacks skill training.
    /// </remarks>
    public int UntrainedPenalty { get; init; } = 0;

    /// <summary>
    /// Gets the category for grouping skills in the UI.
    /// </summary>
    /// <remarks>
    /// Common categories: "Physical", "Mental", "Social", "Knowledge", "Specialty".
    /// </remarks>
    public string Category { get; init; } = "General";

    /// <summary>
    /// Gets tags for filtering and searching skills.
    /// </summary>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the sort order for display purposes.
    /// </summary>
    public int SortOrder { get; init; } = 0;

    /// <summary>
    /// Private constructor for EF Core and JSON deserialization.
    /// </summary>
    private SkillDefinition() { }

    /// <summary>
    /// Creates a new skill definition with validation.
    /// </summary>
    /// <param name="id">Unique identifier (required, normalized to lowercase).</param>
    /// <param name="name">Display name (required).</param>
    /// <param name="description">Description of the skill.</param>
    /// <param name="primaryAttribute">Primary attribute ID (required).</param>
    /// <param name="secondaryAttribute">Optional secondary attribute ID.</param>
    /// <param name="baseDicePool">Dice notation (defaults to "1d10").</param>
    /// <param name="allowUntrained">Whether untrained attempts are allowed.</param>
    /// <param name="untrainedPenalty">Penalty for untrained attempts.</param>
    /// <param name="category">Skill category.</param>
    /// <param name="tags">Optional tags for filtering.</param>
    /// <param name="sortOrder">Display sort order.</param>
    /// <returns>A validated skill definition.</returns>
    /// <exception cref="ArgumentException">If required fields are missing or invalid.</exception>
    public static SkillDefinition Create(
        string id,
        string name,
        string description,
        string primaryAttribute,
        string? secondaryAttribute = null,
        string baseDicePool = "1d10",
        bool allowUntrained = true,
        int untrainedPenalty = 0,
        string category = "General",
        IReadOnlyList<string>? tags = null,
        int sortOrder = 0)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id, nameof(id));
        ArgumentException.ThrowIfNullOrWhiteSpace(name, nameof(name));
        ArgumentException.ThrowIfNullOrWhiteSpace(primaryAttribute, nameof(primaryAttribute));

        // Validate primary attribute is known
        var validAttributes = new[] { "might", "fortitude", "will", "wits", "finesse" };
        var normalizedPrimary = primaryAttribute.ToLowerInvariant();
        if (!validAttributes.Contains(normalizedPrimary))
        {
            throw new ArgumentException(
                $"Primary attribute must be one of: {string.Join(", ", validAttributes)}",
                nameof(primaryAttribute));
        }

        // Validate secondary attribute if provided
        if (secondaryAttribute != null)
        {
            var normalizedSecondary = secondaryAttribute.ToLowerInvariant();
            if (!validAttributes.Contains(normalizedSecondary))
            {
                throw new ArgumentException(
                    $"Secondary attribute must be one of: {string.Join(", ", validAttributes)}",
                    nameof(secondaryAttribute));
            }
        }

        // Validate dice pool notation
        if (!string.IsNullOrEmpty(baseDicePool))
        {
            if (!ValueObjects.DicePool.TryParse(baseDicePool, out _))
            {
                throw new ArgumentException(
                    $"Invalid dice pool notation: {baseDicePool}",
                    nameof(baseDicePool));
            }
        }

        if (untrainedPenalty < 0)
        {
            throw new ArgumentOutOfRangeException(
                nameof(untrainedPenalty),
                "Untrained penalty cannot be negative");
        }

        return new SkillDefinition
        {
            Id = id.ToLowerInvariant(),
            Name = name,
            Description = description ?? string.Empty,
            PrimaryAttribute = normalizedPrimary,
            SecondaryAttribute = secondaryAttribute?.ToLowerInvariant(),
            BaseDicePool = string.IsNullOrWhiteSpace(baseDicePool) ? "1d10" : baseDicePool,
            AllowUntrained = allowUntrained,
            UntrainedPenalty = untrainedPenalty,
            Category = category ?? "General",
            Tags = tags ?? Array.Empty<string>(),
            SortOrder = sortOrder
        };
    }

    /// <summary>
    /// Checks if this skill has the specified tag.
    /// </summary>
    /// <param name="tag">The tag to check for (case-insensitive).</param>
    /// <returns>True if the skill has the tag.</returns>
    public bool HasTag(string tag)
    {
        return Tags.Any(t => t.Equals(tag, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Checks if this skill belongs to the specified category.
    /// </summary>
    /// <param name="category">The category to check (case-insensitive).</param>
    /// <returns>True if the skill is in the category.</returns>
    public bool IsInCategory(string category)
    {
        return Category.Equals(category, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Returns true if this skill has a secondary attribute modifier.
    /// </summary>
    public bool HasSecondaryAttribute => !string.IsNullOrEmpty(SecondaryAttribute);

    /// <summary>
    /// Returns true if this skill requires training (i.e., has an untrained penalty).
    /// </summary>
    public bool RequiresTraining => !AllowUntrained || UntrainedPenalty > 0;

    /// <inheritdoc />
    public override string ToString() => $"{Name} ({PrimaryAttribute})";
}
```

#### 2. DifficultyClassDefinition.cs

**File:** `src/Core/RuneAndRust.Domain/Definitions/DifficultyClassDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a difficulty class (DC) threshold for skill checks.
/// Difficulty classes are configured via JSON and provide standard DC targets.
/// </summary>
/// <remarks>
/// <para>Each difficulty class has a target number that the skill check result must
/// meet or exceed for success.</para>
/// <para>Standard difficulties range from Trivial (DC 5) to Nearly Impossible (DC 30).</para>
/// </remarks>
/// <example>
/// <code>
/// var moderate = DifficultyClassDefinition.Create(
///     id: "moderate",
///     name: "Moderate",
///     description: "Requires some skill or effort.",
///     targetNumber: 12);
/// </code>
/// </example>
public class DifficultyClassDefinition
{
    /// <summary>
    /// Gets the unique identifier for this difficulty class.
    /// </summary>
    /// <remarks>
    /// IDs are lowercase strings (e.g., "trivial", "easy", "moderate", "hard").
    /// Used as keys in configuration and when requesting specific DCs.
    /// </remarks>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name shown to players (e.g., "Trivial", "Moderate", "Hard").
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the description explaining the difficulty level.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the target number that must be met or exceeded for success.
    /// </summary>
    /// <remarks>
    /// The skill check total (dice roll + modifiers) must be >= this value to succeed.
    /// </remarks>
    public int TargetNumber { get; init; }

    /// <summary>
    /// Gets the display color for this difficulty level (hex code).
    /// </summary>
    /// <remarks>
    /// Used for visual indication in the UI. Colors typically range from
    /// green (easy) through yellow (moderate) to red (hard) and purple (legendary).
    /// </remarks>
    public string Color { get; init; } = "#FFFFFF";

    /// <summary>
    /// Gets the sort order for display purposes.
    /// </summary>
    public int SortOrder { get; init; }

    /// <summary>
    /// Private constructor for EF Core and JSON deserialization.
    /// </summary>
    private DifficultyClassDefinition() { }

    /// <summary>
    /// Creates a new difficulty class definition with validation.
    /// </summary>
    /// <param name="id">Unique identifier (required, normalized to lowercase).</param>
    /// <param name="name">Display name (required).</param>
    /// <param name="description">Description of the difficulty level.</param>
    /// <param name="targetNumber">DC target (must be at least 1).</param>
    /// <param name="color">Display color as hex code.</param>
    /// <param name="sortOrder">Display sort order.</param>
    /// <returns>A validated difficulty class definition.</returns>
    /// <exception cref="ArgumentException">If required fields are missing.</exception>
    /// <exception cref="ArgumentOutOfRangeException">If target number is less than 1.</exception>
    public static DifficultyClassDefinition Create(
        string id,
        string name,
        string description,
        int targetNumber,
        string color = "#FFFFFF",
        int sortOrder = 0)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id, nameof(id));
        ArgumentException.ThrowIfNullOrWhiteSpace(name, nameof(name));

        if (targetNumber < 1)
        {
            throw new ArgumentOutOfRangeException(
                nameof(targetNumber),
                targetNumber,
                "Target number must be at least 1");
        }

        // Validate color format if provided
        if (!string.IsNullOrEmpty(color) && !color.StartsWith('#'))
        {
            color = "#" + color;
        }

        return new DifficultyClassDefinition
        {
            Id = id.ToLowerInvariant(),
            Name = name,
            Description = description ?? string.Empty,
            TargetNumber = targetNumber,
            Color = color ?? "#FFFFFF",
            SortOrder = sortOrder
        };
    }

    /// <summary>
    /// Checks if a result meets this difficulty class.
    /// </summary>
    /// <param name="result">The skill check total result.</param>
    /// <returns>True if the result meets or exceeds the target number.</returns>
    public bool IsMet(int result) => result >= TargetNumber;

    /// <summary>
    /// Calculates the margin of success or failure.
    /// </summary>
    /// <param name="result">The skill check total result.</param>
    /// <returns>Positive for success margin, negative for failure margin.</returns>
    public int GetMargin(int result) => result - TargetNumber;

    /// <inheritdoc />
    public override string ToString() => $"{Name} (DC {TargetNumber})";
}
```

#### 3. SkillCheckResult.cs

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SkillCheckResult.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the complete result of a skill check, including dice roll breakdown,
/// attribute modifiers, and success determination.
/// </summary>
/// <remarks>
/// <para>Immutable value object containing all information about a skill check.</para>
/// <para>Success level is automatically determined based on the dice roll and total result:</para>
/// <list type="bullet">
///   <item><description>Critical Success: Natural max on first die (e.g., 10 on d10)</description></item>
///   <item><description>Critical Failure: Natural 1 on first die</description></item>
///   <item><description>Success: Total result >= Difficulty Class</description></item>
///   <item><description>Failure: Total result &lt; Difficulty Class</description></item>
/// </list>
/// </remarks>
/// <example>
/// <code>
/// var result = new SkillCheckResult(
///     skillId: "perception",
///     skillName: "Perception",
///     diceResult: diceRollResult,
///     attributeBonus: 3,
///     otherBonus: 0,
///     difficultyClass: 12,
///     difficultyName: "Moderate");
///
/// if (result.IsSuccess)
///     Console.WriteLine($"You spot the hidden trap with {result.Margin} to spare!");
/// </code>
/// </example>
public readonly record struct SkillCheckResult
{
    /// <summary>
    /// Gets the ID of the skill that was checked.
    /// </summary>
    public string SkillId { get; init; }

    /// <summary>
    /// Gets the display name of the skill.
    /// </summary>
    public string SkillName { get; init; }

    /// <summary>
    /// Gets the underlying dice roll result.
    /// </summary>
    public DiceRollResult DiceResult { get; init; }

    /// <summary>
    /// Gets the bonus from the player's primary (and optionally secondary) attribute.
    /// </summary>
    public int AttributeBonus { get; init; }

    /// <summary>
    /// Gets the bonus from other sources (equipment, abilities, situational).
    /// </summary>
    public int OtherBonus { get; init; }

    /// <summary>
    /// Gets the total result of the check (dice + all bonuses).
    /// </summary>
    public int TotalResult { get; init; }

    /// <summary>
    /// Gets the difficulty class that was checked against.
    /// </summary>
    public int DifficultyClass { get; init; }

    /// <summary>
    /// Gets the name of the difficulty level.
    /// </summary>
    public string DifficultyName { get; init; }

    /// <summary>
    /// Gets the degree of success or failure.
    /// </summary>
    public SuccessLevel SuccessLevel { get; init; }

    /// <summary>
    /// Gets the margin by which the check succeeded or failed.
    /// </summary>
    /// <remarks>
    /// Positive values indicate success margin, negative values indicate failure margin.
    /// </remarks>
    public int Margin => TotalResult - DifficultyClass;

    /// <summary>
    /// Gets whether the check succeeded (Success or CriticalSuccess).
    /// </summary>
    public bool IsSuccess => SuccessLevel is SuccessLevel.Success or SuccessLevel.CriticalSuccess;

    /// <summary>
    /// Gets whether the check was a critical result (natural max or natural 1).
    /// </summary>
    public bool IsCritical => SuccessLevel is SuccessLevel.CriticalSuccess or SuccessLevel.CriticalFailure;

    /// <summary>
    /// Gets whether this was a critical success (natural max on first die).
    /// </summary>
    public bool IsCriticalSuccess => SuccessLevel == SuccessLevel.CriticalSuccess;

    /// <summary>
    /// Gets whether this was a critical failure (natural 1 on first die).
    /// </summary>
    public bool IsCriticalFailure => SuccessLevel == SuccessLevel.CriticalFailure;

    /// <summary>
    /// Gets the raw dice total before bonuses.
    /// </summary>
    public int RawDiceTotal => DiceResult.Total;

    /// <summary>
    /// Gets the total bonus applied (attribute + other).
    /// </summary>
    public int TotalBonus => AttributeBonus + OtherBonus;

    /// <summary>
    /// Creates a skill check result with automatic success level determination.
    /// </summary>
    /// <param name="skillId">The skill ID.</param>
    /// <param name="skillName">The skill display name.</param>
    /// <param name="diceResult">The dice roll result.</param>
    /// <param name="attributeBonus">Bonus from player attributes.</param>
    /// <param name="otherBonus">Bonus from other sources.</param>
    /// <param name="difficultyClass">The DC to check against.</param>
    /// <param name="difficultyName">The difficulty level name.</param>
    public SkillCheckResult(
        string skillId,
        string skillName,
        DiceRollResult diceResult,
        int attributeBonus,
        int otherBonus,
        int difficultyClass,
        string difficultyName)
    {
        SkillId = skillId;
        SkillName = skillName;
        DiceResult = diceResult;
        AttributeBonus = attributeBonus;
        OtherBonus = otherBonus;
        TotalResult = diceResult.Total + attributeBonus + otherBonus;
        DifficultyClass = difficultyClass;
        DifficultyName = difficultyName;

        // Determine success level based on dice result and total
        SuccessLevel = DetermineSuccessLevel(diceResult, TotalResult, difficultyClass);
    }

    /// <summary>
    /// Determines the success level based on dice roll and result.
    /// </summary>
    private static SuccessLevel DetermineSuccessLevel(
        DiceRollResult diceResult,
        int totalResult,
        int difficultyClass)
    {
        // Critical failure on natural 1 (always fails regardless of total)
        if (diceResult.IsNaturalOne)
        {
            return SuccessLevel.CriticalFailure;
        }

        // Critical success on natural max (always succeeds)
        if (diceResult.IsNaturalMax)
        {
            return SuccessLevel.CriticalSuccess;
        }

        // Normal success/failure based on total vs DC
        return totalResult >= difficultyClass
            ? SuccessLevel.Success
            : SuccessLevel.Failure;
    }

    /// <summary>
    /// Returns a formatted string showing the check breakdown.
    /// </summary>
    /// <returns>A detailed breakdown string.</returns>
    public override string ToString()
    {
        var bonusStr = new List<string>();
        if (AttributeBonus != 0)
            bonusStr.Add($"{(AttributeBonus > 0 ? "+" : "")}{AttributeBonus} (attr)");
        if (OtherBonus != 0)
            bonusStr.Add($"{(OtherBonus > 0 ? "+" : "")}{OtherBonus} (bonus)");

        var bonusPart = bonusStr.Count > 0 ? " " + string.Join(" ", bonusStr) : "";

        var criticalNote = SuccessLevel switch
        {
            SuccessLevel.CriticalSuccess => " [CRITICAL SUCCESS!]",
            SuccessLevel.CriticalFailure => " [CRITICAL FAILURE!]",
            _ => ""
        };

        return $"{SkillName}: [{DiceResult.DiceTotal}]{bonusPart} = {TotalResult} vs DC {DifficultyClass} ({DifficultyName}) -> {SuccessLevel}{criticalNote}";
    }
}
```

### Application Layer

#### 4. SkillCheckService.cs

**File:** `src/Core/RuneAndRust.Application/Services/SkillCheckService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for performing skill checks using dice rolls and player attributes.
/// </summary>
/// <remarks>
/// <para>Integrates the dice rolling system with player attributes and configuration-driven
/// skill definitions and difficulty classes.</para>
/// <para>Skill checks follow this flow:</para>
/// <list type="number">
///   <item><description>Load skill definition from configuration</description></item>
///   <item><description>Calculate attribute bonus from player</description></item>
///   <item><description>Roll dice pool with optional advantage/disadvantage</description></item>
///   <item><description>Compare total to difficulty class</description></item>
///   <item><description>Return complete result with breakdown</description></item>
/// </list>
/// </remarks>
/// <example>
/// <code>
/// var result = skillCheckService.PerformCheck(
///     player,
///     skillId: "perception",
///     difficultyClassId: "moderate");
///
/// if (result.IsSuccess)
///     Console.WriteLine("You notice the hidden trap!");
/// </code>
/// </example>
public class SkillCheckService
{
    private readonly DiceService _diceService;
    private readonly IGameConfigurationProvider _configProvider;
    private readonly ILogger<SkillCheckService> _logger;

    /// <summary>
    /// Initializes a new instance of the SkillCheckService.
    /// </summary>
    /// <param name="diceService">Service for rolling dice.</param>
    /// <param name="configProvider">Provider for skill and DC configuration.</param>
    /// <param name="logger">Logger instance.</param>
    /// <exception cref="ArgumentNullException">If any parameter is null.</exception>
    public SkillCheckService(
        DiceService diceService,
        IGameConfigurationProvider configProvider,
        ILogger<SkillCheckService> logger)
    {
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("SkillCheckService initialized");
    }

    /// <summary>
    /// Performs a skill check for a player against a named difficulty class.
    /// </summary>
    /// <param name="player">The player making the check.</param>
    /// <param name="skillId">The skill to check (e.g., "perception").</param>
    /// <param name="difficultyClassId">The difficulty level ID (e.g., "moderate").</param>
    /// <param name="advantageType">Whether to roll with advantage or disadvantage.</param>
    /// <param name="additionalBonus">Extra bonus from situational effects.</param>
    /// <returns>The complete skill check result.</returns>
    /// <exception cref="ArgumentNullException">If player is null.</exception>
    /// <exception cref="ArgumentException">If skill or difficulty class is not found.</exception>
    public SkillCheckResult PerformCheck(
        Player player,
        string skillId,
        string difficultyClassId,
        AdvantageType advantageType = AdvantageType.Normal,
        int additionalBonus = 0)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentException.ThrowIfNullOrWhiteSpace(skillId, nameof(skillId));
        ArgumentException.ThrowIfNullOrWhiteSpace(difficultyClassId, nameof(difficultyClassId));

        _logger.LogDebug(
            "Performing skill check: Player={Player}, Skill={Skill}, DC={DC}, Advantage={Advantage}",
            player.Name, skillId, difficultyClassId, advantageType);

        // Get skill definition
        var skill = _configProvider.GetSkillById(skillId)
            ?? throw new ArgumentException($"Unknown skill: {skillId}", nameof(skillId));

        // Get difficulty class
        var dc = _configProvider.GetDifficultyClassById(difficultyClassId)
            ?? throw new ArgumentException($"Unknown difficulty class: {difficultyClassId}", nameof(difficultyClassId));

        return PerformCheckInternal(player, skill, dc, advantageType, additionalBonus);
    }

    /// <summary>
    /// Performs a skill check for a player against a specific DC value.
    /// </summary>
    /// <param name="player">The player making the check.</param>
    /// <param name="skillId">The skill to check.</param>
    /// <param name="difficultyClass">The numeric DC to check against.</param>
    /// <param name="difficultyName">Optional name for the difficulty (defaults to "Custom").</param>
    /// <param name="advantageType">Whether to roll with advantage or disadvantage.</param>
    /// <param name="additionalBonus">Extra bonus from situational effects.</param>
    /// <returns>The complete skill check result.</returns>
    public SkillCheckResult PerformCheckWithDC(
        Player player,
        string skillId,
        int difficultyClass,
        string difficultyName = "Custom",
        AdvantageType advantageType = AdvantageType.Normal,
        int additionalBonus = 0)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentException.ThrowIfNullOrWhiteSpace(skillId, nameof(skillId));

        if (difficultyClass < 1)
        {
            throw new ArgumentOutOfRangeException(nameof(difficultyClass), "Difficulty class must be at least 1");
        }

        _logger.LogDebug(
            "Performing skill check: Player={Player}, Skill={Skill}, DC={DC}, Advantage={Advantage}",
            player.Name, skillId, difficultyClass, advantageType);

        var skill = _configProvider.GetSkillById(skillId)
            ?? throw new ArgumentException($"Unknown skill: {skillId}", nameof(skillId));

        // Calculate attribute bonus
        var attributeBonus = CalculateAttributeBonus(player, skill);

        // Calculate total other bonus (including untrained penalty if applicable)
        var otherBonus = CalculateOtherBonus(player, skill, additionalBonus);

        // Roll the dice
        var dicePool = DicePool.Parse(skill.BaseDicePool);
        var rollResult = _diceService.Roll(dicePool, advantageType);

        // Create result
        var result = new SkillCheckResult(
            skillId,
            skill.Name,
            rollResult,
            attributeBonus,
            otherBonus,
            difficultyClass,
            difficultyName);

        LogCheckResult(result);

        return result;
    }

    /// <summary>
    /// Performs a contested skill check between two players.
    /// </summary>
    /// <param name="activePlayer">The player initiating the contest.</param>
    /// <param name="passivePlayer">The player defending in the contest.</param>
    /// <param name="activeSkillId">The skill the active player uses.</param>
    /// <param name="passiveSkillId">The skill the passive player uses (can be same or different).</param>
    /// <param name="activeAdvantage">Advantage type for active player.</param>
    /// <param name="passiveAdvantage">Advantage type for passive player.</param>
    /// <returns>Tuple of (active result, passive result, winner name).</returns>
    public (SkillCheckResult ActiveResult, SkillCheckResult PassiveResult, string Winner) PerformContestedCheck(
        Player activePlayer,
        Player passivePlayer,
        string activeSkillId,
        string passiveSkillId,
        AdvantageType activeAdvantage = AdvantageType.Normal,
        AdvantageType passiveAdvantage = AdvantageType.Normal)
    {
        ArgumentNullException.ThrowIfNull(activePlayer);
        ArgumentNullException.ThrowIfNull(passivePlayer);

        _logger.LogDebug(
            "Performing contested check: {Active} ({ActiveSkill}) vs {Passive} ({PassiveSkill})",
            activePlayer.Name, activeSkillId, passivePlayer.Name, passiveSkillId);

        // Both players roll against DC 0 (their totals are compared)
        var activeResult = PerformCheckWithDC(activePlayer, activeSkillId, 0, "Contested", activeAdvantage);
        var passiveResult = PerformCheckWithDC(passivePlayer, passiveSkillId, 0, "Contested", passiveAdvantage);

        // Determine winner (active wins ties)
        var winner = activeResult.TotalResult >= passiveResult.TotalResult
            ? activePlayer.Name
            : passivePlayer.Name;

        _logger.LogInformation(
            "Contested check: {Active} ({ActiveTotal}) vs {Passive} ({PassiveTotal}) -> {Winner} wins",
            activePlayer.Name, activeResult.TotalResult,
            passivePlayer.Name, passiveResult.TotalResult,
            winner);

        return (activeResult, passiveResult, winner);
    }

    /// <summary>
    /// Internal method to perform the actual skill check.
    /// </summary>
    private SkillCheckResult PerformCheckInternal(
        Player player,
        SkillDefinition skill,
        DifficultyClassDefinition dc,
        AdvantageType advantageType,
        int additionalBonus)
    {
        // Calculate attribute bonus
        var attributeBonus = CalculateAttributeBonus(player, skill);

        // Calculate total other bonus
        var otherBonus = CalculateOtherBonus(player, skill, additionalBonus);

        // Roll the dice
        var dicePool = DicePool.Parse(skill.BaseDicePool);
        var rollResult = _diceService.Roll(dicePool, advantageType);

        // Create result
        var result = new SkillCheckResult(
            skill.Id,
            skill.Name,
            rollResult,
            attributeBonus,
            otherBonus,
            dc.TargetNumber,
            dc.Name);

        LogCheckResult(result);

        return result;
    }

    /// <summary>
    /// Calculates the attribute bonus for a skill check.
    /// </summary>
    /// <param name="player">The player making the check.</param>
    /// <param name="skill">The skill being checked.</param>
    /// <returns>The total attribute bonus.</returns>
    private int CalculateAttributeBonus(Player player, SkillDefinition skill)
    {
        var primaryBonus = GetAttributeValue(player, skill.PrimaryAttribute);

        if (skill.HasSecondaryAttribute)
        {
            var secondaryBonus = GetAttributeValue(player, skill.SecondaryAttribute!) / 2;
            return primaryBonus + secondaryBonus;
        }

        return primaryBonus;
    }

    /// <summary>
    /// Calculates other bonuses including untrained penalty.
    /// </summary>
    private int CalculateOtherBonus(Player player, SkillDefinition skill, int additionalBonus)
    {
        var otherBonus = additionalBonus;

        // Apply untrained penalty if applicable
        if (skill.RequiresTraining && !PlayerHasSkillTraining(player, skill.Id))
        {
            otherBonus -= skill.UntrainedPenalty;
            _logger.LogDebug(
                "Applied untrained penalty of -{Penalty} for {Skill}",
                skill.UntrainedPenalty, skill.Name);
        }

        return otherBonus;
    }

    /// <summary>
    /// Gets a player's attribute value by attribute ID.
    /// </summary>
    /// <param name="player">The player.</param>
    /// <param name="attributeId">The attribute ID.</param>
    /// <returns>The attribute value.</returns>
    private static int GetAttributeValue(Player player, string attributeId)
    {
        return attributeId.ToLowerInvariant() switch
        {
            "might" => player.Attributes.Might,
            "fortitude" => player.Attributes.Fortitude,
            "will" => player.Attributes.Will,
            "wits" => player.Attributes.Wits,
            "finesse" => player.Attributes.Finesse,
            _ => 0
        };
    }

    /// <summary>
    /// Checks if a player has training in a skill.
    /// </summary>
    /// <remarks>
    /// TODO: Implement skill training system in future version.
    /// Currently always returns true (no training system implemented).
    /// </remarks>
    private static bool PlayerHasSkillTraining(Player player, string skillId)
    {
        // Future: Check player.TrainedSkills or similar
        return true;
    }

    /// <summary>
    /// Logs the skill check result.
    /// </summary>
    private void LogCheckResult(SkillCheckResult result)
    {
        var level = result.IsCritical ? LogLevel.Information : LogLevel.Debug;

        _logger.Log(level,
            "Skill check complete: Skill={Skill} Roll={Roll} Bonus={Bonus} Total={Total} DC={DC} Result={Result}",
            result.SkillName,
            result.DiceResult.Total,
            result.TotalBonus,
            result.TotalResult,
            result.DifficultyClass,
            result.SuccessLevel);

        if (result.IsCriticalSuccess)
        {
            _logger.LogInformation("Critical success on {Skill}!", result.SkillName);
        }
        else if (result.IsCriticalFailure)
        {
            _logger.LogInformation("Critical failure on {Skill}!", result.SkillName);
        }
    }

    /// <summary>
    /// Gets all available skill definitions.
    /// </summary>
    /// <returns>Read-only list of all skills.</returns>
    public IReadOnlyList<SkillDefinition> GetAllSkills()
    {
        return _configProvider.GetSkills();
    }

    /// <summary>
    /// Gets skills filtered by category.
    /// </summary>
    /// <param name="category">The category to filter by.</param>
    /// <returns>Skills in the specified category.</returns>
    public IReadOnlyList<SkillDefinition> GetSkillsByCategory(string category)
    {
        return _configProvider.GetSkills()
            .Where(s => s.IsInCategory(category))
            .OrderBy(s => s.SortOrder)
            .ThenBy(s => s.Name)
            .ToList();
    }

    /// <summary>
    /// Gets all difficulty class definitions.
    /// </summary>
    /// <returns>Read-only list of all difficulty classes.</returns>
    public IReadOnlyList<DifficultyClassDefinition> GetDifficultyClasses()
    {
        return _configProvider.GetDifficultyClasses()
            .OrderBy(dc => dc.SortOrder)
            .ToList();
    }

    /// <summary>
    /// Gets a difficulty class by ID.
    /// </summary>
    /// <param name="id">The difficulty class ID.</param>
    /// <returns>The difficulty class, or null if not found.</returns>
    public DifficultyClassDefinition? GetDifficultyClass(string id)
    {
        return _configProvider.GetDifficultyClassById(id);
    }

    /// <summary>
    /// Finds the nearest difficulty class for a given DC value.
    /// </summary>
    /// <param name="targetNumber">The target DC value.</param>
    /// <returns>The closest matching difficulty class.</returns>
    public DifficultyClassDefinition? GetNearestDifficultyClass(int targetNumber)
    {
        var allDCs = _configProvider.GetDifficultyClasses();
        return allDCs
            .OrderBy(dc => Math.Abs(dc.TargetNumber - targetNumber))
            .FirstOrDefault();
    }
}
```

#### 5. SkillCheckDtos.cs

**File:** `src/Core/RuneAndRust.Application/DTOs/SkillCheckDtos.cs`

```csharp
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for skill check results displayed to the player.
/// </summary>
/// <param name="SkillId">The skill identifier.</param>
/// <param name="SkillName">The skill display name.</param>
/// <param name="DiceRoll">The underlying dice roll details.</param>
/// <param name="AttributeBonus">Bonus from player attributes.</param>
/// <param name="OtherBonus">Bonus from other sources.</param>
/// <param name="TotalResult">Total result of the check.</param>
/// <param name="DifficultyClass">The DC that was checked against.</param>
/// <param name="DifficultyName">The difficulty level name.</param>
/// <param name="SuccessLevel">The degree of success/failure.</param>
/// <param name="Margin">The margin of success or failure.</param>
/// <param name="IsSuccess">Whether the check succeeded.</param>
/// <param name="IsCritical">Whether this was a critical result.</param>
/// <param name="Descriptor">Optional flavor text for the result.</param>
public record SkillCheckResultDto(
    string SkillId,
    string SkillName,
    DiceRollDto DiceRoll,
    int AttributeBonus,
    int OtherBonus,
    int TotalResult,
    int DifficultyClass,
    string DifficultyName,
    string SuccessLevel,
    int Margin,
    bool IsSuccess,
    bool IsCritical,
    string? Descriptor = null)
{
    /// <summary>
    /// Creates a DTO from a domain skill check result.
    /// </summary>
    /// <param name="result">The domain result to convert.</param>
    /// <param name="descriptor">Optional flavor text.</param>
    /// <returns>A new SkillCheckResultDto.</returns>
    public static SkillCheckResultDto FromDomainResult(
        SkillCheckResult result,
        string? descriptor = null)
    {
        return new SkillCheckResultDto(
            result.SkillId,
            result.SkillName,
            DiceRollDto.FromDomainResult(result.DiceResult),
            result.AttributeBonus,
            result.OtherBonus,
            result.TotalResult,
            result.DifficultyClass,
            result.DifficultyName,
            result.SuccessLevel.ToString(),
            result.Margin,
            result.IsSuccess,
            result.IsCritical,
            descriptor);
    }

    /// <summary>
    /// Gets a formatted summary of the check result.
    /// </summary>
    public string Summary =>
        $"{SkillName}: {TotalResult} vs DC {DifficultyClass} - {SuccessLevel}";

    /// <summary>
    /// Gets whether this was a critical success.
    /// </summary>
    public bool IsCriticalSuccess =>
        SuccessLevel == nameof(Domain.Enums.SuccessLevel.CriticalSuccess);

    /// <summary>
    /// Gets whether this was a critical failure.
    /// </summary>
    public bool IsCriticalFailure =>
        SuccessLevel == nameof(Domain.Enums.SuccessLevel.CriticalFailure);
}

/// <summary>
/// DTO for skill definitions.
/// </summary>
/// <param name="Id">Skill identifier.</param>
/// <param name="Name">Display name.</param>
/// <param name="Description">Skill description.</param>
/// <param name="PrimaryAttribute">Primary attribute ID.</param>
/// <param name="SecondaryAttribute">Optional secondary attribute ID.</param>
/// <param name="BaseDicePool">Dice notation for the skill.</param>
/// <param name="AllowUntrained">Whether untrained attempts are allowed.</param>
/// <param name="UntrainedPenalty">Penalty for untrained attempts.</param>
/// <param name="Category">Skill category.</param>
/// <param name="Tags">Skill tags.</param>
public record SkillDefinitionDto(
    string Id,
    string Name,
    string Description,
    string PrimaryAttribute,
    string? SecondaryAttribute,
    string BaseDicePool,
    bool AllowUntrained,
    int UntrainedPenalty,
    string Category,
    IReadOnlyList<string> Tags)
{
    /// <summary>
    /// Creates a DTO from a domain skill definition.
    /// </summary>
    /// <param name="skill">The domain skill definition.</param>
    /// <returns>A new SkillDefinitionDto.</returns>
    public static SkillDefinitionDto FromDomain(SkillDefinition skill)
    {
        return new SkillDefinitionDto(
            skill.Id,
            skill.Name,
            skill.Description,
            skill.PrimaryAttribute,
            skill.SecondaryAttribute,
            skill.BaseDicePool,
            skill.AllowUntrained,
            skill.UntrainedPenalty,
            skill.Category,
            skill.Tags);
    }

    /// <summary>
    /// Gets whether this skill requires training.
    /// </summary>
    public bool RequiresTraining => !AllowUntrained || UntrainedPenalty > 0;

    /// <summary>
    /// Gets whether this skill has a secondary attribute.
    /// </summary>
    public bool HasSecondaryAttribute => !string.IsNullOrEmpty(SecondaryAttribute);
}

/// <summary>
/// DTO for difficulty class definitions.
/// </summary>
/// <param name="Id">Difficulty class identifier.</param>
/// <param name="Name">Display name.</param>
/// <param name="Description">Description of the difficulty.</param>
/// <param name="TargetNumber">The DC target number.</param>
/// <param name="Color">Display color as hex code.</param>
public record DifficultyClassDto(
    string Id,
    string Name,
    string Description,
    int TargetNumber,
    string Color)
{
    /// <summary>
    /// Creates a DTO from a domain difficulty class definition.
    /// </summary>
    /// <param name="dc">The domain difficulty class definition.</param>
    /// <returns>A new DifficultyClassDto.</returns>
    public static DifficultyClassDto FromDomain(DifficultyClassDefinition dc)
    {
        return new DifficultyClassDto(
            dc.Id,
            dc.Name,
            dc.Description,
            dc.TargetNumber,
            dc.Color);
    }
}

/// <summary>
/// DTO for contested skill check results.
/// </summary>
/// <param name="ActivePlayerName">Name of the initiating player.</param>
/// <param name="PassivePlayerName">Name of the defending player.</param>
/// <param name="ActiveResult">The active player's check result.</param>
/// <param name="PassiveResult">The passive player's check result.</param>
/// <param name="Winner">Name of the winning player.</param>
public record ContestedCheckResultDto(
    string ActivePlayerName,
    string PassivePlayerName,
    SkillCheckResultDto ActiveResult,
    SkillCheckResultDto PassiveResult,
    string Winner)
{
    /// <summary>
    /// Gets whether the active player won.
    /// </summary>
    public bool ActivePlayerWon => Winner == ActivePlayerName;

    /// <summary>
    /// Gets the margin of victory.
    /// </summary>
    public int VictoryMargin => Math.Abs(ActiveResult.TotalResult - PassiveResult.TotalResult);
}
```

### Infrastructure Layer

#### 6. Update IGameConfigurationProvider.cs

**File:** `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs`

Add the following methods to the interface:

```csharp
// Add to IGameConfigurationProvider interface:

/// <summary>
/// Gets all skill definitions.
/// </summary>
/// <returns>Read-only list of all skills.</returns>
IReadOnlyList<SkillDefinition> GetSkills();

/// <summary>
/// Gets a skill definition by ID.
/// </summary>
/// <param name="id">The skill ID.</param>
/// <returns>The skill definition, or null if not found.</returns>
SkillDefinition? GetSkillById(string id);

/// <summary>
/// Gets all difficulty class definitions.
/// </summary>
/// <returns>Read-only list of all difficulty classes.</returns>
IReadOnlyList<DifficultyClassDefinition> GetDifficultyClasses();

/// <summary>
/// Gets a difficulty class definition by ID.
/// </summary>
/// <param name="id">The difficulty class ID.</param>
/// <returns>The difficulty class definition, or null if not found.</returns>
DifficultyClassDefinition? GetDifficultyClassById(string id);
```

#### 7. Update JsonConfigurationProvider.cs

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`

Add skill and difficulty class loading:

```csharp
// Add private fields for caching
private IReadOnlyList<SkillDefinition>? _skills;
private IReadOnlyList<DifficultyClassDefinition>? _difficultyClasses;

// Add JSON config classes
private class SkillsJsonConfig
{
    public List<SkillJsonEntry> Skills { get; set; } = new();
}

private class SkillJsonEntry
{
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string PrimaryAttribute { get; set; } = string.Empty;
    public string? SecondaryAttribute { get; set; }
    public string BaseDicePool { get; set; } = "1d10";
    public bool AllowUntrained { get; set; } = true;
    public int UntrainedPenalty { get; set; } = 0;
    public string Category { get; set; } = "General";
    public List<string> Tags { get; set; } = new();
    public int SortOrder { get; set; } = 0;
}

private class DifficultyJsonConfig
{
    public List<DifficultyClassJsonEntry> DifficultyClasses { get; set; } = new();
}

private class DifficultyClassJsonEntry
{
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int TargetNumber { get; set; }
    public string Color { get; set; } = "#FFFFFF";
    public int SortOrder { get; set; } = 0;
}

// Implementation methods
public IReadOnlyList<SkillDefinition> GetSkills()
{
    if (_skills != null) return _skills;

    try
    {
        var filePath = Path.Combine(_configDirectory, "skills.json");
        if (!File.Exists(filePath))
        {
            _logger.LogWarning("Skills configuration not found at {Path}, using defaults", filePath);
            _skills = GetDefaultSkills();
            return _skills;
        }

        var json = File.ReadAllText(filePath);
        var config = JsonSerializer.Deserialize<SkillsJsonConfig>(json, _jsonOptions);

        if (config?.Skills == null || config.Skills.Count == 0)
        {
            _logger.LogWarning("No skills found in configuration, using defaults");
            _skills = GetDefaultSkills();
            return _skills;
        }

        _skills = config.Skills
            .Select(ToSkillDefinition)
            .Where(s => s != null)
            .Cast<SkillDefinition>()
            .OrderBy(s => s.SortOrder)
            .ThenBy(s => s.Name)
            .ToList();

        _logger.LogInformation("Loaded {Count} skills from configuration", _skills.Count);
        return _skills;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to load skills configuration");
        _skills = GetDefaultSkills();
        return _skills;
    }
}

public SkillDefinition? GetSkillById(string id)
{
    if (string.IsNullOrWhiteSpace(id)) return null;
    return GetSkills().FirstOrDefault(s =>
        s.Id.Equals(id, StringComparison.OrdinalIgnoreCase));
}

public IReadOnlyList<DifficultyClassDefinition> GetDifficultyClasses()
{
    if (_difficultyClasses != null) return _difficultyClasses;

    try
    {
        var filePath = Path.Combine(_configDirectory, "difficulty.json");
        if (!File.Exists(filePath))
        {
            _logger.LogWarning("Difficulty configuration not found at {Path}, using defaults", filePath);
            _difficultyClasses = GetDefaultDifficultyClasses();
            return _difficultyClasses;
        }

        var json = File.ReadAllText(filePath);
        var config = JsonSerializer.Deserialize<DifficultyJsonConfig>(json, _jsonOptions);

        if (config?.DifficultyClasses == null || config.DifficultyClasses.Count == 0)
        {
            _logger.LogWarning("No difficulty classes found in configuration, using defaults");
            _difficultyClasses = GetDefaultDifficultyClasses();
            return _difficultyClasses;
        }

        _difficultyClasses = config.DifficultyClasses
            .Select(ToDifficultyClassDefinition)
            .Where(dc => dc != null)
            .Cast<DifficultyClassDefinition>()
            .OrderBy(dc => dc.SortOrder)
            .ToList();

        _logger.LogInformation("Loaded {Count} difficulty classes from configuration", _difficultyClasses.Count);
        return _difficultyClasses;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to load difficulty configuration");
        _difficultyClasses = GetDefaultDifficultyClasses();
        return _difficultyClasses;
    }
}

public DifficultyClassDefinition? GetDifficultyClassById(string id)
{
    if (string.IsNullOrWhiteSpace(id)) return null;
    return GetDifficultyClasses().FirstOrDefault(dc =>
        dc.Id.Equals(id, StringComparison.OrdinalIgnoreCase));
}

private SkillDefinition? ToSkillDefinition(SkillJsonEntry entry)
{
    try
    {
        return SkillDefinition.Create(
            id: entry.Id,
            name: entry.Name,
            description: entry.Description,
            primaryAttribute: entry.PrimaryAttribute,
            secondaryAttribute: entry.SecondaryAttribute,
            baseDicePool: entry.BaseDicePool,
            allowUntrained: entry.AllowUntrained,
            untrainedPenalty: entry.UntrainedPenalty,
            category: entry.Category,
            tags: entry.Tags,
            sortOrder: entry.SortOrder);
    }
    catch (Exception ex)
    {
        _logger.LogWarning(ex, "Failed to create skill definition for {Id}", entry.Id);
        return null;
    }
}

private DifficultyClassDefinition? ToDifficultyClassDefinition(DifficultyClassJsonEntry entry)
{
    try
    {
        return DifficultyClassDefinition.Create(
            id: entry.Id,
            name: entry.Name,
            description: entry.Description,
            targetNumber: entry.TargetNumber,
            color: entry.Color,
            sortOrder: entry.SortOrder);
    }
    catch (Exception ex)
    {
        _logger.LogWarning(ex, "Failed to create difficulty class definition for {Id}", entry.Id);
        return null;
    }
}

private static IReadOnlyList<SkillDefinition> GetDefaultSkills()
{
    return new List<SkillDefinition>
    {
        SkillDefinition.Create("athletics", "Athletics", "Physical feats of strength, climbing, jumping.", "might", "fortitude", "1d10", true, 0, "Physical", new[] { "physical", "strength" }, 1),
        SkillDefinition.Create("acrobatics", "Acrobatics", "Balance, tumbling, and agile maneuvers.", "finesse", null, "1d10", true, 0, "Physical", new[] { "physical", "agility" }, 2),
        SkillDefinition.Create("stealth", "Stealth", "Moving silently and remaining hidden.", "finesse", "wits", "1d10", true, 0, "Physical", new[] { "physical", "sneaking" }, 3),
        SkillDefinition.Create("perception", "Perception", "Noticing hidden things and spotting danger.", "wits", null, "1d10", true, 0, "Mental", new[] { "mental", "awareness" }, 4),
        SkillDefinition.Create("endurance", "Endurance", "Resisting poison, disease, and exhaustion.", "fortitude", null, "1d10", true, 0, "Physical", new[] { "physical", "resilience" }, 5),
    };
}

private static IReadOnlyList<DifficultyClassDefinition> GetDefaultDifficultyClasses()
{
    return new List<DifficultyClassDefinition>
    {
        DifficultyClassDefinition.Create("trivial", "Trivial", "Almost anyone can do this.", 5, "#88FF88", 1),
        DifficultyClassDefinition.Create("easy", "Easy", "A simple task.", 8, "#44DD44", 2),
        DifficultyClassDefinition.Create("moderate", "Moderate", "Requires some skill.", 12, "#FFFF44", 3),
        DifficultyClassDefinition.Create("challenging", "Challenging", "Difficult for most people.", 15, "#FFAA44", 4),
        DifficultyClassDefinition.Create("hard", "Hard", "Only skilled individuals succeed reliably.", 18, "#FF6644", 5),
    };
}
```

### Configuration Files

#### 8. skills.json

**File:** `config/skills.json`

```json
{
  "$schema": "skills.schema.json",
  "skills": [
    {
      "id": "athletics",
      "name": "Athletics",
      "description": "Physical feats of strength, climbing, jumping, and swimming.",
      "primaryAttribute": "might",
      "secondaryAttribute": "fortitude",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Physical",
      "tags": ["physical", "strength"],
      "sortOrder": 1
    },
    {
      "id": "acrobatics",
      "name": "Acrobatics",
      "description": "Balance, tumbling, and agile maneuvers.",
      "primaryAttribute": "finesse",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Physical",
      "tags": ["physical", "agility"],
      "sortOrder": 2
    },
    {
      "id": "stealth",
      "name": "Stealth",
      "description": "Moving silently and remaining hidden.",
      "primaryAttribute": "finesse",
      "secondaryAttribute": "wits",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Physical",
      "tags": ["physical", "sneaking"],
      "sortOrder": 3
    },
    {
      "id": "perception",
      "name": "Perception",
      "description": "Noticing hidden things, spotting danger, and awareness.",
      "primaryAttribute": "wits",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Mental",
      "tags": ["mental", "awareness"],
      "sortOrder": 4
    },
    {
      "id": "investigation",
      "name": "Investigation",
      "description": "Searching for clues, deducing information, and solving puzzles.",
      "primaryAttribute": "wits",
      "secondaryAttribute": "will",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Mental",
      "tags": ["mental", "intellect"],
      "sortOrder": 5
    },
    {
      "id": "lockpicking",
      "name": "Lockpicking",
      "description": "Opening locks without the key.",
      "primaryAttribute": "finesse",
      "baseDicePool": "1d10",
      "allowUntrained": false,
      "untrainedPenalty": 5,
      "category": "Specialty",
      "tags": ["specialty", "tools"],
      "sortOrder": 6
    },
    {
      "id": "intimidation",
      "name": "Intimidation",
      "description": "Frightening or coercing others through threats.",
      "primaryAttribute": "might",
      "secondaryAttribute": "will",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Social",
      "tags": ["social", "influence"],
      "sortOrder": 7
    },
    {
      "id": "persuasion",
      "name": "Persuasion",
      "description": "Convincing others through charm and logic.",
      "primaryAttribute": "will",
      "secondaryAttribute": "wits",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Social",
      "tags": ["social", "influence"],
      "sortOrder": 8
    },
    {
      "id": "arcana",
      "name": "Arcana",
      "description": "Knowledge of magic, runes, and supernatural phenomena.",
      "primaryAttribute": "will",
      "baseDicePool": "1d10",
      "allowUntrained": false,
      "untrainedPenalty": 5,
      "category": "Knowledge",
      "tags": ["knowledge", "magic"],
      "sortOrder": 9
    },
    {
      "id": "endurance",
      "name": "Endurance",
      "description": "Resisting poison, disease, and physical exhaustion.",
      "primaryAttribute": "fortitude",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Physical",
      "tags": ["physical", "resilience"],
      "sortOrder": 10
    }
  ]
}
```

#### 9. difficulty.json

**File:** `config/difficulty.json`

```json
{
  "$schema": "difficulty.schema.json",
  "difficultyClasses": [
    {
      "id": "trivial",
      "name": "Trivial",
      "description": "Almost anyone can do this.",
      "targetNumber": 5,
      "color": "#88FF88",
      "sortOrder": 1
    },
    {
      "id": "easy",
      "name": "Easy",
      "description": "A simple task for someone with basic ability.",
      "targetNumber": 8,
      "color": "#44DD44",
      "sortOrder": 2
    },
    {
      "id": "moderate",
      "name": "Moderate",
      "description": "Requires some skill or effort.",
      "targetNumber": 12,
      "color": "#FFFF44",
      "sortOrder": 3
    },
    {
      "id": "challenging",
      "name": "Challenging",
      "description": "Difficult for most people.",
      "targetNumber": 15,
      "color": "#FFAA44",
      "sortOrder": 4
    },
    {
      "id": "hard",
      "name": "Hard",
      "description": "Only skilled individuals succeed reliably.",
      "targetNumber": 18,
      "color": "#FF6644",
      "sortOrder": 5
    },
    {
      "id": "very_hard",
      "name": "Very Hard",
      "description": "Even experts struggle.",
      "targetNumber": 22,
      "color": "#FF4444",
      "sortOrder": 6
    },
    {
      "id": "heroic",
      "name": "Heroic",
      "description": "A legendary feat.",
      "targetNumber": 25,
      "color": "#FF00FF",
      "sortOrder": 7
    },
    {
      "id": "impossible",
      "name": "Nearly Impossible",
      "description": "Only the most exceptional can hope to succeed.",
      "targetNumber": 30,
      "color": "#8800FF",
      "sortOrder": 8
    }
  ]
}
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Definitions/
│   │   ├── SkillDefinitionTests.cs         (5 tests)
│   │   └── DifficultyClassDefinitionTests.cs (3 tests)
│   └── ValueObjects/
│       └── SkillCheckResultTests.cs        (5 tests)
│
└── RuneAndRust.Application.UnitTests/
    └── Services/
        └── SkillCheckServiceTests.cs       (7 tests)
```

### Test Files

#### 10. SkillDefinitionTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/Definitions/SkillDefinitionTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Definitions;

namespace RuneAndRust.Domain.UnitTests.Definitions;

[TestFixture]
public class SkillDefinitionTests
{
    [Test]
    public void Create_WithValidParameters_CreatesSkillDefinition()
    {
        // Arrange & Act
        var skill = SkillDefinition.Create(
            id: "perception",
            name: "Perception",
            description: "Notice hidden things.",
            primaryAttribute: "wits",
            category: "Mental");

        // Assert
        skill.Id.Should().Be("perception");
        skill.Name.Should().Be("Perception");
        skill.PrimaryAttribute.Should().Be("wits");
        skill.Category.Should().Be("Mental");
        skill.BaseDicePool.Should().Be("1d10");
        skill.AllowUntrained.Should().BeTrue();
    }

    [Test]
    public void Create_WithSecondaryAttribute_IncludesSecondary()
    {
        // Arrange & Act
        var skill = SkillDefinition.Create(
            id: "athletics",
            name: "Athletics",
            description: "Physical feats.",
            primaryAttribute: "might",
            secondaryAttribute: "fortitude");

        // Assert
        skill.HasSecondaryAttribute.Should().BeTrue();
        skill.SecondaryAttribute.Should().Be("fortitude");
    }

    [Test]
    public void Create_WithEmptyId_ThrowsArgumentException()
    {
        // Arrange & Act
        var act = () => SkillDefinition.Create(
            id: "",
            name: "Test",
            description: "Test",
            primaryAttribute: "might");

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithParameterName("id");
    }

    [Test]
    public void Create_WithInvalidPrimaryAttribute_ThrowsArgumentException()
    {
        // Arrange & Act
        var act = () => SkillDefinition.Create(
            id: "test",
            name: "Test",
            description: "Test",
            primaryAttribute: "invalid");

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithParameterName("primaryAttribute");
    }

    [Test]
    public void HasTag_WhenTagExists_ReturnsTrue()
    {
        // Arrange
        var skill = SkillDefinition.Create(
            id: "stealth",
            name: "Stealth",
            description: "Hide.",
            primaryAttribute: "finesse",
            tags: new[] { "physical", "sneaking" });

        // Act & Assert
        skill.HasTag("physical").Should().BeTrue();
        skill.HasTag("PHYSICAL").Should().BeTrue();
        skill.HasTag("mental").Should().BeFalse();
    }
}
```

#### 11. DifficultyClassDefinitionTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/Definitions/DifficultyClassDefinitionTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Definitions;

namespace RuneAndRust.Domain.UnitTests.Definitions;

[TestFixture]
public class DifficultyClassDefinitionTests
{
    [Test]
    public void Create_WithValidParameters_CreatesDifficultyClass()
    {
        // Arrange & Act
        var dc = DifficultyClassDefinition.Create(
            id: "moderate",
            name: "Moderate",
            description: "Requires effort.",
            targetNumber: 12,
            color: "#FFFF44");

        // Assert
        dc.Id.Should().Be("moderate");
        dc.Name.Should().Be("Moderate");
        dc.TargetNumber.Should().Be(12);
        dc.Color.Should().Be("#FFFF44");
    }

    [Test]
    public void Create_WithZeroTargetNumber_ThrowsArgumentOutOfRangeException()
    {
        // Arrange & Act
        var act = () => DifficultyClassDefinition.Create(
            id: "test",
            name: "Test",
            description: "Test",
            targetNumber: 0);

        // Assert
        act.Should().Throw<ArgumentOutOfRangeException>()
            .WithParameterName("targetNumber");
    }

    [Test]
    public void IsMet_WhenResultMeetsOrExceeds_ReturnsTrue()
    {
        // Arrange
        var dc = DifficultyClassDefinition.Create(
            id: "moderate",
            name: "Moderate",
            description: "Test",
            targetNumber: 12);

        // Act & Assert
        dc.IsMet(12).Should().BeTrue();
        dc.IsMet(15).Should().BeTrue();
        dc.IsMet(11).Should().BeFalse();
    }
}
```

#### 12. SkillCheckResultTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/SkillCheckResultTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class SkillCheckResultTests
{
    [Test]
    public void Constructor_WhenTotalMeetsDC_ReturnsSuccess()
    {
        // Arrange
        var dicePool = new DicePool(1, DiceType.D10);
        var diceResult = new DiceRollResult(dicePool, new[] { 7 }, 7);

        // Act
        var result = new SkillCheckResult(
            "perception", "Perception",
            diceResult,
            attributeBonus: 3,
            otherBonus: 2,
            difficultyClass: 12,
            difficultyName: "Moderate");

        // Assert
        result.TotalResult.Should().Be(12); // 7 + 3 + 2
        result.SuccessLevel.Should().Be(SuccessLevel.Success);
        result.IsSuccess.Should().BeTrue();
        result.Margin.Should().Be(0);
    }

    [Test]
    public void Constructor_WhenNaturalMax_ReturnsCriticalSuccess()
    {
        // Arrange
        var dicePool = new DicePool(1, DiceType.D10);
        var diceResult = new DiceRollResult(dicePool, new[] { 10 }, 10);

        // Act
        var result = new SkillCheckResult(
            "perception", "Perception",
            diceResult,
            attributeBonus: 0,
            otherBonus: 0,
            difficultyClass: 20,
            difficultyName: "Hard");

        // Assert
        result.SuccessLevel.Should().Be(SuccessLevel.CriticalSuccess);
        result.IsCriticalSuccess.Should().BeTrue();
    }

    [Test]
    public void Constructor_WhenNaturalOne_ReturnsCriticalFailure()
    {
        // Arrange
        var dicePool = new DicePool(1, DiceType.D10);
        var diceResult = new DiceRollResult(dicePool, new[] { 1 }, 1);

        // Act
        var result = new SkillCheckResult(
            "perception", "Perception",
            diceResult,
            attributeBonus: 10,
            otherBonus: 5,
            difficultyClass: 5,
            difficultyName: "Trivial");

        // Assert
        result.TotalResult.Should().Be(16);
        result.SuccessLevel.Should().Be(SuccessLevel.CriticalFailure);
        result.IsCriticalFailure.Should().BeTrue();
    }

    [Test]
    public void Margin_CalculatesCorrectly()
    {
        // Arrange
        var dicePool = new DicePool(1, DiceType.D10);
        var diceResult = new DiceRollResult(dicePool, new[] { 5 }, 5);

        // Act
        var result = new SkillCheckResult(
            "stealth", "Stealth",
            diceResult,
            attributeBonus: 3,
            otherBonus: 0,
            difficultyClass: 12,
            difficultyName: "Moderate");

        // Assert
        result.TotalResult.Should().Be(8);
        result.Margin.Should().Be(-4);
        result.IsSuccess.Should().BeFalse();
    }

    [Test]
    public void ToString_FormatsCorrectly()
    {
        // Arrange
        var dicePool = new DicePool(1, DiceType.D10);
        var diceResult = new DiceRollResult(dicePool, new[] { 8 }, 8);
        var result = new SkillCheckResult(
            "perception", "Perception",
            diceResult,
            attributeBonus: 3,
            otherBonus: 0,
            difficultyClass: 12,
            difficultyName: "Moderate");

        // Act
        var str = result.ToString();

        // Assert
        str.Should().Contain("Perception");
        str.Should().Contain("DC 12");
        str.Should().Contain("Moderate");
    }
}
```

#### 13. SkillCheckServiceTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Services/SkillCheckServiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class SkillCheckServiceTests
{
    private SkillCheckService _service = null!;
    private Mock<ILogger<SkillCheckService>> _mockLogger = null!;
    private Mock<ILogger<DiceService>> _mockDiceLogger = null!;
    private Mock<IGameConfigurationProvider> _mockConfig = null!;
    private DiceService _diceService = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<SkillCheckService>>();
        _mockDiceLogger = new Mock<ILogger<DiceService>>();
        _mockConfig = new Mock<IGameConfigurationProvider>();

        // Use seeded random for deterministic tests
        var seededRandom = new Random(42);
        _diceService = new DiceService(_mockDiceLogger.Object, seededRandom);

        SetupDefaultMocks();

        _service = new SkillCheckService(
            _diceService,
            _mockConfig.Object,
            _mockLogger.Object);
    }

    private void SetupDefaultMocks()
    {
        var perception = SkillDefinition.Create(
            "perception", "Perception", "Notice things.",
            "wits", null, "1d10");

        var athletics = SkillDefinition.Create(
            "athletics", "Athletics", "Physical feats.",
            "might", "fortitude", "1d10");

        var lockpicking = SkillDefinition.Create(
            "lockpicking", "Lockpicking", "Open locks.",
            "finesse", null, "1d10", false, 5);

        _mockConfig.Setup(c => c.GetSkillById("perception")).Returns(perception);
        _mockConfig.Setup(c => c.GetSkillById("athletics")).Returns(athletics);
        _mockConfig.Setup(c => c.GetSkillById("lockpicking")).Returns(lockpicking);
        _mockConfig.Setup(c => c.GetSkills())
            .Returns(new List<SkillDefinition> { perception, athletics, lockpicking });

        var moderate = DifficultyClassDefinition.Create(
            "moderate", "Moderate", "Requires effort.", 12);
        var hard = DifficultyClassDefinition.Create(
            "hard", "Hard", "Difficult.", 18);

        _mockConfig.Setup(c => c.GetDifficultyClassById("moderate")).Returns(moderate);
        _mockConfig.Setup(c => c.GetDifficultyClassById("hard")).Returns(hard);
        _mockConfig.Setup(c => c.GetDifficultyClasses())
            .Returns(new List<DifficultyClassDefinition> { moderate, hard });
    }

    private static Player CreateTestPlayer(int wits = 8, int might = 8, int finesse = 8, int fortitude = 8)
    {
        var attributes = new PlayerAttributes(might, fortitude, 8, wits, finesse);
        return new Player("TestPlayer", "human", "soldier", attributes, "Test");
    }

    [Test]
    public void PerformCheck_WithValidParameters_ReturnsResult()
    {
        // Arrange
        var player = CreateTestPlayer(wits: 12);

        // Act
        var result = _service.PerformCheck(player, "perception", "moderate");

        // Assert
        result.SkillId.Should().Be("perception");
        result.SkillName.Should().Be("Perception");
        result.DifficultyClass.Should().Be(12);
        result.AttributeBonus.Should().Be(12); // wits value
    }

    [Test]
    public void PerformCheck_WithSecondaryAttribute_CalculatesBonusCorrectly()
    {
        // Arrange
        var player = CreateTestPlayer(might: 10, fortitude: 6);

        // Act
        var result = _service.PerformCheck(player, "athletics", "moderate");

        // Assert
        result.AttributeBonus.Should().Be(13); // 10 (might) + 3 (fortitude/2)
    }

    [Test]
    public void PerformCheck_WithAdvantage_RollsTwice()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var result = _service.PerformCheck(
            player, "perception", "moderate",
            AdvantageType.Advantage);

        // Assert
        result.DiceResult.AdvantageType.Should().Be(AdvantageType.Advantage);
        result.DiceResult.AllRollTotals.Should().HaveCount(2);
    }

    [Test]
    public void PerformCheck_WithUnknownSkill_ThrowsArgumentException()
    {
        // Arrange
        var player = CreateTestPlayer();
        _mockConfig.Setup(c => c.GetSkillById("unknown")).Returns((SkillDefinition?)null);

        // Act
        var act = () => _service.PerformCheck(player, "unknown", "moderate");

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithMessage("Unknown skill: unknown*");
    }

    [Test]
    public void PerformCheckWithDC_UsesExactDCValue()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var result = _service.PerformCheckWithDC(
            player, "perception", 15, "Custom DC");

        // Assert
        result.DifficultyClass.Should().Be(15);
        result.DifficultyName.Should().Be("Custom DC");
    }

    [Test]
    public void GetAllSkills_ReturnsConfiguredSkills()
    {
        // Act
        var skills = _service.GetAllSkills();

        // Assert
        skills.Should().HaveCount(3);
        skills.Should().Contain(s => s.Id == "perception");
    }

    [Test]
    public void GetDifficultyClasses_ReturnsOrderedList()
    {
        // Act
        var dcs = _service.GetDifficultyClasses();

        // Assert
        dcs.Should().HaveCount(2);
        dcs.First().Id.Should().Be("moderate");
    }
}
```

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Service initialization | Information | "SkillCheckService initialized" |
| Check request | Debug | "Performing skill check: Player=Hero, Skill=perception, DC=moderate" |
| Attribute bonus | Debug | "Calculated attribute bonus: 12 (wits: 12, secondary: 0)" |
| Untrained penalty | Debug | "Applied untrained penalty of -5 for Lockpicking" |
| Check complete | Debug | "Skill check complete: Skill=Perception Roll=8 Bonus=12 Total=20 DC=12 Result=Success" |
| Critical result | Information | "Critical success on Perception!" |
| Configuration load | Information | "Loaded 10 skills from configuration" |
| Configuration error | Warning | "Failed to create skill definition for xyz" |

### Structured Logging Format

```csharp
_logger.LogDebug(
    "Performing skill check: Player={Player}, Skill={Skill}, DC={DC}, Advantage={Advantage}",
    player.Name, skillId, difficultyClassId, advantageType);

_logger.LogDebug(
    "Skill check complete: Skill={Skill} Roll={Roll} Bonus={Bonus} Total={Total} DC={DC} Result={Result}",
    result.SkillName,
    result.DiceResult.Total,
    result.TotalBonus,
    result.TotalResult,
    result.DifficultyClass,
    result.SuccessLevel);
```

---

## Implementation Checklist

### Domain Layer
- [ ] Create `src/Core/RuneAndRust.Domain/Definitions/SkillDefinition.cs`
  - [ ] Properties with init accessors
  - [ ] Create() factory method with validation
  - [ ] Attribute validation (must be known attribute)
  - [ ] Dice pool notation validation
  - [ ] HasTag() and IsInCategory() helper methods
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/Definitions/DifficultyClassDefinition.cs`
  - [ ] Properties with init accessors
  - [ ] Create() factory method with validation
  - [ ] IsMet() and GetMargin() methods
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/SkillCheckResult.cs`
  - [ ] Readonly record struct
  - [ ] Auto-determine SuccessLevel
  - [ ] Computed properties (IsSuccess, IsCritical, Margin)
  - [ ] ToString() with breakdown
  - [ ] XML documentation

### Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/Services/SkillCheckService.cs`
  - [ ] PerformCheck() with named DC
  - [ ] PerformCheckWithDC() with numeric DC
  - [ ] PerformContestedCheck() for opposed checks
  - [ ] CalculateAttributeBonus() with secondary support
  - [ ] CalculateOtherBonus() with untrained penalty
  - [ ] GetAllSkills(), GetSkillsByCategory()
  - [ ] GetDifficultyClasses(), GetDifficultyClass()
  - [ ] Comprehensive logging
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/SkillCheckDtos.cs`
  - [ ] SkillCheckResultDto with FromDomainResult()
  - [ ] SkillDefinitionDto with FromDomain()
  - [ ] DifficultyClassDto with FromDomain()
  - [ ] ContestedCheckResultDto

### Infrastructure Layer
- [ ] Update `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs`
  - [ ] Add GetSkills()
  - [ ] Add GetSkillById()
  - [ ] Add GetDifficultyClasses()
  - [ ] Add GetDifficultyClassById()
- [ ] Update `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`
  - [ ] Add private caching fields
  - [ ] Add JSON config classes
  - [ ] Implement GetSkills() with lazy loading
  - [ ] Implement GetSkillById()
  - [ ] Implement GetDifficultyClasses() with lazy loading
  - [ ] Implement GetDifficultyClassById()
  - [ ] Add ToSkillDefinition() converter
  - [ ] Add ToDifficultyClassDefinition() converter
  - [ ] Add GetDefaultSkills() fallback
  - [ ] Add GetDefaultDifficultyClasses() fallback

### Configuration Files
- [ ] Create `config/skills.json` with 10 skills
- [ ] Create `config/difficulty.json` with 8 difficulty classes

### Tests
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Definitions/SkillDefinitionTests.cs` (5 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Definitions/DifficultyClassDefinitionTests.cs` (3 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/SkillCheckResultTests.cs` (5 tests)
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/SkillCheckServiceTests.cs` (7 tests)

### Validation
- [ ] All 20 new tests pass
- [ ] All existing tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | 10 skills defined in configuration | Config file review |
| AC-2 | 8 difficulty classes defined | Config file review |
| AC-3 | Skill checks use player's primary attribute | Unit test |
| AC-4 | Secondary attributes provide half bonus | Unit test |
| AC-5 | Untrained penalty applied when appropriate | Unit test |
| AC-6 | Critical success on natural max | Unit test |
| AC-7 | Critical failure on natural 1 | Unit test |
| AC-8 | Advantage/disadvantage supported | Unit test |
| AC-9 | Skill check results include full breakdown | Unit test |
| AC-10 | Contested checks determine winner | Unit test |
| AC-11 | Unknown skill throws ArgumentException | Unit test |
| AC-12 | Unknown DC throws ArgumentException | Unit test |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | SkillDefinition is immutable | Code review |
| NF-2 | DifficultyClassDefinition is immutable | Code review |
| NF-3 | SkillCheckResult is immutable | Code review |
| NF-4 | All public APIs documented with XML | Code review |
| NF-5 | Logging at appropriate levels | Code review |
| NF-6 | Configuration loading handles missing files | Unit test |
| NF-7 | No breaking changes to existing code | Test suite |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| DicePool.Parse not available from 5a | High | Low | Verify 5a complete before starting |
| Player.Attributes structure changes | Medium | Low | Use existing PlayerAttributes |
| Configuration loading conflicts | Medium | Medium | Follow existing pattern exactly |
| Test flakiness with dice rolls | Medium | Medium | Use seeded Random in tests |
| Breaking IGameConfigurationProvider changes | Medium | Low | Add methods, don't modify existing |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Domain/Definitions/SkillDefinition.cs` | Skill definition entity | ~150 |
| `Domain/Definitions/DifficultyClassDefinition.cs` | DC definition entity | ~80 |
| `Domain/ValueObjects/SkillCheckResult.cs` | Skill check result value object | ~130 |
| `Application/Services/SkillCheckService.cs` | Skill check orchestration | ~250 |
| `Application/DTOs/SkillCheckDtos.cs` | DTOs for presentation | ~120 |
| `config/skills.json` | Skill configuration (10 skills) | ~100 |
| `config/difficulty.json` | DC configuration (8 DCs) | ~60 |
| `Tests/.../SkillDefinitionTests.cs` | Skill definition tests | ~80 |
| `Tests/.../DifficultyClassDefinitionTests.cs` | DC definition tests | ~50 |
| `Tests/.../SkillCheckResultTests.cs` | Result value object tests | ~100 |
| `Tests/.../SkillCheckServiceTests.cs` | Service tests | ~150 |

### Files to Modify

| File | Changes |
|------|---------|
| `Application/Interfaces/IConfigurationProvider.cs` | Add 4 methods for skills/DCs |
| `Infrastructure/Configuration/JsonConfigurationProvider.cs` | Add skill/DC loading (~150 lines) |

### Final Metrics

| Metric | Before v0.0.5b | After v0.0.5b |
|--------|----------------|---------------|
| Domain Definitions | 6 | 8 |
| Domain Value Objects | 8 | 9 |
| Application Services | 9 | 10 |
| Application DTOs | 15 | 16 |
| Unit Tests | ~220 | ~240 |
| Config Files | 9 | 11 |

---

## Next Steps

After completing v0.0.5b:

1. **v0.0.5c (Combat Integration)** - Integrate dice-based attack/damage rolls
2. **v0.0.5d (Configuration & Polish)** - Add commands, rendering, descriptors
3. **v0.0.6 (Enhanced Combat)** - Multi-target, status effects

The skill check system provides the foundation for all future skill-based mechanics including trap detection, social encounters, and environmental challenges.
