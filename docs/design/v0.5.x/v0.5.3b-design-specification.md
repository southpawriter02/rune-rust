# v0.5.3b Design Specification: Opportunity Attacks

**Version:** 0.5.3b
**Phase Name:** Opportunity Attacks
**Parent Version:** v0.5.3 (Tactical Positioning)
**Prerequisites:** v0.5.3a Complete (Flanking System)
**Estimated Tests:** ~30 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ThreatService](#4-threatservice)
5. [Reaction System](#5-reaction-system)
6. [MovementService Integration](#6-movementservice-integration)
7. [DisengageCommand](#7-disengagecommand)
8. [Grid Threat Display](#8-grid-threat-display)
9. [User-Facing Commands](#9-user-facing-commands)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification implements the opportunity attack system that punishes careless movement near enemies. Creatures with melee weapons threaten adjacent squares. Moving out of a threatened square without disengaging triggers an opportunity attack. Each creature gets one reaction per round to make opportunity attacks.

Key mechanics:
- **Threatened Squares**: Entities with melee weapons threaten adjacent cells
- **Opportunity Attacks**: Trigger when leaving threatened squares
- **Reaction System**: One reaction per round per entity
- **Disengage Action**: Spend action to move safely without triggering attacks

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Application Interfaces** | `IThreatService` |
| **Application Services** | `ThreatService` |
| **Result Types** | `OpportunityAttackCheckResult`, `OpportunityAttackResult` |
| **Combat State Updates** | Reaction tracking |
| **MovementService Updates** | Opportunity attack integration |
| **Commands** | `DisengageCommand` |
| **Configuration** | `combat.json` opportunity attacks section |
| **Tests** | ~30 unit tests |

### 1.3 Architectural Significance

This version establishes the **Tactical Movement Pattern**:

- **Zone Control**: Melee fighters control space around them
- **Reaction Economy**: Limited reactions create meaningful choices
- **Risk vs Reward**: Moving freely has consequences
- **Disengage Option**: Tactical escape without punishment

---

## 2. Feature Overview

```
v0.5.3b Opportunity Attacks
├── ThreatService
│   ├── GetThreatenedSquares(entityId): positions
│   ├── GetThreateningEntities(position): entityIds
│   ├── IsPositionThreatened(pos, movingId): bool
│   ├── CheckOpportunityAttacks(id, from, to): result
│   ├── ExecuteOpportunityAttacks(id, from, to): results
│   ├── HasUsedReaction(entityId): bool
│   ├── UseReaction(entityId): void
│   ├── ResetReactions(): void
│   ├── IsDisengaging(entityId): bool
│   ├── SetDisengaging(entityId): void
│   └── ClearDisengaging(entityId): void
├── Result Types
│   ├── OpportunityAttackCheckResult
│   │   ├── TriggersOpportunityAttacks: bool
│   │   ├── AttackingEntities: List<Guid>
│   │   ├── IsDisengaging: bool
│   │   └── Message: string
│   └── OpportunityAttackResult
│       ├── AttackerId, AttackerName
│       ├── Hit: bool, Damage: int
│       └── AttackRoll, Message
├── MovementService Integration
│   ├── Check for opportunity attacks before move
│   ├── Warn player if attacks would trigger
│   ├── Execute attacks before movement completes
│   └── Handle entity death during movement
├── DisengageCommand
│   ├── Marks entity as disengaging
│   ├── Consumes action for turn
│   └── Prevents opportunity attacks this turn
└── Grid Threat Display
    ├── Show threatened squares (*)
    ├── Show threat warnings
    └── Show available options
```

### 2.1 Scope Alignment

**In Scope:**
- `IThreatService` interface
- `ThreatService` for threat calculations
- Threatened square tracking
- Opportunity attack triggers
- Reaction system (one reaction per round)
- Reaction reset on turn start
- `DisengageCommand` to avoid opportunity attacks
- Threat display on grid
- Opportunity attack execution
- Configuration for opportunity attacks

**Out of Scope:**
- Area effects (v0.5.3c)
- Reach weapons extending threat (simplification)

---

## 3. Architecture Diagrams

### 3.1 Threatened Squares

```
┌─────────────────────────────────────────────────────────────────────┐
│                      THREATENED SQUARES                              │
└─────────────────────────────────────────────────────────────────────┘

    Entity with melee weapon threatens all 8 adjacent squares:

    ┌───┬───┬───┬───┬───┐
    │   │ * │ * │ * │   │     * = Threatened by M
    ├───┼───┼───┼───┼───┤     M = Entity with melee weapon
    │   │ * │ M │ * │   │
    ├───┼───┼───┼───┼───┤     Moving OUT of a threatened
    │   │ * │ * │ * │   │     square triggers opportunity attack
    ├───┼───┼───┼───┼───┤
    │   │   │   │   │   │
    └───┴───┴───┴───┴───┘

    Requirements:
    ├── Entity must have melee weapon equipped
    ├── Threatens all 8 adjacent squares
    └── No threat if entity has no melee weapon
```

### 3.2 Opportunity Attack Trigger

```
┌─────────────────────────────────────────────────────────────────────┐
│                   OPPORTUNITY ATTACK TRIGGER                         │
└─────────────────────────────────────────────────────────────────────┘

    Moving OUT of a threatened square triggers an attack:

    Step 1: Player at D3, adjacent to Monster at C3
    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │     @ = Player
    ├───┼───┼───┼───┼───┤     M = Monster (melee weapon)
    │   │   │ M │ @ │   │
    ├───┼───┼───┼───┼───┤
    │   │   │   │   │   │
    └───┴───┴───┴───┴───┘

    Step 2: Player moves to E3 (AWAY from M)
    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │     D3 was threatened by M
    ├───┼───┼───┼───┼───┤     E3 is NOT adjacent to M
    │   │   │ M │ · │ @ │     → OPPORTUNITY ATTACK TRIGGERED!
    ├───┼───┼───┼───┼───┤
    │   │   │   │   │   │
    └───┴───┴───┴───┴───┘

    Step 2b: Player moves to D2 (stays adjacent to M)
    ┌───┬───┬───┬───┬───┐
    │   │   │ @ │   │   │     D3 was threatened by M
    ├───┼───┼───┼───┼───┤     D2 is STILL adjacent to M
    │   │   │ M │ · │   │     → NO opportunity attack
    ├───┼───┼───┼───┼───┤
    │   │   │   │   │   │
    └───┴───┴───┴───┴───┘
```

### 3.3 Opportunity Attack Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                   OPPORTUNITY ATTACK FLOW                            │
└─────────────────────────────────────────────────────────────────────┘

    Move Command
         │
         ▼
    ┌───────────────────┐
    │ Is Disengaging?   │──Yes──▶ Continue movement (no OA)
    └────────┬──────────┘
             │No
             ▼
    ┌───────────────────┐
    │ Check Threatening │
    │ Entities at FROM  │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ For each threatener│
    │ Is enemy?         │──No──▶ Skip (ally)
    └────────┬──────────┘
             │Yes
             ▼
    ┌───────────────────┐
    │ Has used reaction?│──Yes──▶ Skip (reaction spent)
    └────────┬──────────┘
             │No
             ▼
    ┌───────────────────┐
    │ Still adjacent    │──Yes──▶ Skip (not leaving threat)
    │ to TO position?   │
    └────────┬──────────┘
             │No
             ▼
    ┌───────────────────┐
    │ ADD to attackers  │
    │ list              │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Warn player:      │
    │ OA will trigger!  │
    └────────┬──────────┘
             │(player confirms)
             ▼
    ┌───────────────────┐
    │ Execute each OA   │
    │ Use reaction      │
    │ Roll attack       │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Player alive?     │──No──▶ Movement fails (death)
    └────────┬──────────┘
             │Yes
             ▼
    ┌───────────────────┐
    │ Complete movement │
    └───────────────────┘
```

### 3.4 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  GridRenderer (Extended)                                             │
│  ├── Shows threatened squares with '*'                              │
│  ├── Shows threat warnings                                          │
│  └── Shows disengage option                                         │
├─────────────────────────────────────────────────────────────────────┤
│  MoveCommand (Extended)                                              │
│  ├── Warns about opportunity attacks                                │
│  ├── Prompts for confirmation                                       │
│  └── Shows OA results                                               │
├─────────────────────────────────────────────────────────────────────┤
│  DisengageCommand (NEW)                                              │
│  └── Sets disengage status for turn                                 │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  IThreatService / ThreatService                                      │
│  ├── GetThreatenedSquares(entityId): IEnumerable<GridPosition>      │
│  ├── GetThreateningEntities(position): IEnumerable<Guid>            │
│  ├── IsPositionThreatened(position, movingId): bool                 │
│  ├── CheckOpportunityAttacks(id, from, to): OACheckResult           │
│  ├── ExecuteOpportunityAttacks(id, from, to): IEnumerable<OAResult> │
│  ├── HasUsedReaction(entityId): bool                                │
│  ├── UseReaction(entityId): void                                    │
│  ├── ResetReactions(): void                                         │
│  ├── IsDisengaging(entityId): bool                                  │
│  ├── SetDisengaging(entityId): void                                 │
│  └── ClearDisengaging(entityId): void                               │
├─────────────────────────────────────────────────────────────────────┤
│  OpportunityAttackCheckResult                                        │
│  ├── TriggersOpportunityAttacks: bool                               │
│  ├── AttackingEntities: IReadOnlyList<Guid>                         │
│  ├── IsDisengaging: bool                                            │
│  └── Message: string                                                │
├─────────────────────────────────────────────────────────────────────┤
│  OpportunityAttackResult                                             │
│  ├── AttackerId: Guid                                               │
│  ├── AttackerName: string                                           │
│  ├── Hit: bool                                                      │
│  ├── Damage: int                                                    │
│  ├── AttackRoll: string                                             │
│  └── Message: string                                                │
├─────────────────────────────────────────────────────────────────────┤
│  MovementService (Extended from v0.5.2a)                             │
│  ├── Check for OA before move                                       │
│  ├── Execute OAs before movement                                    │
│  ├── Handle death during movement                                   │
│  └── Include OA results in MovementResult                           │
├─────────────────────────────────────────────────────────────────────┤
│  CombatService (Extended)                                            │
│  └── ProcessOpportunityAttack(attackerId, targetId): AttackResult   │
├─────────────────────────────────────────────────────────────────────┤
│  CombatStateService (Extended)                                       │
│  └── OnRoundStart: ResetReactions()                                 │
├─────────────────────────────────────────────────────────────────────┤
│  TurnService (Extended)                                              │
│  └── OnTurnEnd: ClearDisengaging(entityId)                          │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. ThreatService

### 4.1 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IThreatService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

public interface IThreatService
{
    IEnumerable<GridPosition> GetThreatenedSquares(Guid entityId);
    IEnumerable<Guid> GetThreateningEntities(GridPosition position);
    bool IsPositionThreatened(GridPosition position, Guid movingEntityId);
    OpportunityAttackCheckResult CheckOpportunityAttacks(Guid movingEntityId, GridPosition from, GridPosition to);
    IEnumerable<OpportunityAttackResult> ExecuteOpportunityAttacks(Guid movingEntityId, GridPosition from, GridPosition to);
    bool HasUsedReaction(Guid entityId);
    void UseReaction(Guid entityId);
    void ResetReactions();
    bool IsDisengaging(Guid entityId);
    void SetDisengaging(Guid entityId);
    void ClearDisengaging(Guid entityId);
}

public readonly record struct OpportunityAttackCheckResult(
    bool TriggersOpportunityAttacks,
    IReadOnlyList<Guid> AttackingEntities,
    bool IsDisengaging,
    string Message);

public readonly record struct OpportunityAttackResult(
    Guid AttackerId,
    string AttackerName,
    bool Hit,
    int Damage,
    string AttackRoll,
    string Message);
```

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/ThreatService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class ThreatService : IThreatService
{
    private readonly ICombatGridService _gridService;
    private readonly ICombatStateService _combatStateService;
    private readonly ICombatService _combatService;
    private readonly ILogger<ThreatService> _logger;

    private readonly HashSet<Guid> _usedReactions = new();
    private readonly HashSet<Guid> _disengaging = new();

    public ThreatService(
        ICombatGridService gridService,
        ICombatStateService combatStateService,
        ICombatService combatService,
        ILogger<ThreatService> logger)
    {
        _gridService = gridService;
        _combatStateService = combatStateService;
        _combatService = combatService;
        _logger = logger;
    }

    public IEnumerable<GridPosition> GetThreatenedSquares(Guid entityId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) yield break;

        var position = grid.GetEntityPosition(entityId);
        if (!position.HasValue) yield break;

        var combatant = _combatStateService.GetCombatant(entityId);
        if (combatant == null || !HasMeleeWeapon(combatant)) yield break;

        foreach (var cell in grid.GetAdjacentCells(position.Value))
            yield return cell.Position;
    }

    public IEnumerable<Guid> GetThreateningEntities(GridPosition position)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) yield break;

        foreach (var cell in grid.GetAdjacentCells(position))
        {
            if (cell.OccupantId.HasValue)
            {
                var occupant = _combatStateService.GetCombatant(cell.OccupantId.Value);
                if (occupant != null && HasMeleeWeapon(occupant))
                    yield return cell.OccupantId.Value;
            }
        }
    }

    public bool IsPositionThreatened(GridPosition position, Guid movingEntityId)
    {
        var moving = _combatStateService.GetCombatant(movingEntityId);
        if (moving == null) return false;

        foreach (var threateningId in GetThreateningEntities(position))
        {
            var threatening = _combatStateService.GetCombatant(threateningId);
            if (threatening != null && threatening.IsPlayer != moving.IsPlayer)
                return true;
        }
        return false;
    }

    public OpportunityAttackCheckResult CheckOpportunityAttacks(
        Guid movingEntityId, GridPosition from, GridPosition to)
    {
        if (IsDisengaging(movingEntityId))
        {
            return new OpportunityAttackCheckResult(
                false, Array.Empty<Guid>(), true,
                "You are disengaging - no opportunity attacks.");
        }

        var moving = _combatStateService.GetCombatant(movingEntityId);
        if (moving == null)
        {
            return new OpportunityAttackCheckResult(
                false, Array.Empty<Guid>(), false, "Entity not found.");
        }

        var attackers = new List<Guid>();
        var grid = _gridService.GetActiveGrid();

        foreach (var threateningId in GetThreateningEntities(from))
        {
            var threatening = _combatStateService.GetCombatant(threateningId);
            if (threatening == null) continue;
            if (threatening.IsPlayer == moving.IsPlayer) continue; // Ally
            if (HasUsedReaction(threateningId)) continue;

            var threatenerPos = grid?.GetEntityPosition(threateningId);
            if (threatenerPos.HasValue && to.DistanceTo(threatenerPos.Value) <= 1)
                continue; // Still adjacent

            attackers.Add(threateningId);
        }

        if (attackers.Count == 0)
        {
            return new OpportunityAttackCheckResult(
                false, Array.Empty<Guid>(), false,
                "No opportunity attacks triggered.");
        }

        var names = attackers
            .Select(id => _combatStateService.GetCombatant(id)?.Name ?? "Unknown")
            .ToList();

        return new OpportunityAttackCheckResult(
            true, attackers,  false,
            $"Warning: Moving will trigger opportunity attacks from {string.Join(", ", names)}!");
    }

    public IEnumerable<OpportunityAttackResult> ExecuteOpportunityAttacks(
        Guid movingEntityId, GridPosition from, GridPosition to)
    {
        var check = CheckOpportunityAttacks(movingEntityId, from, to);
        if (!check.TriggersOpportunityAttacks) yield break;

        foreach (var attackerId in check.AttackingEntities)
        {
            UseReaction(attackerId);

            var attacker = _combatStateService.GetCombatant(attackerId);
            if (attacker == null) continue;

            var attackResult = _combatService.ProcessOpportunityAttack(attackerId, movingEntityId);

            yield return new OpportunityAttackResult(
                attackerId, attacker.Name,
                attackResult.Success, attackResult.DamageDealt,
                attackResult.AttackRollDetails, attackResult.Message);

            _logger.LogInformation(
                "Opportunity attack: {Attacker} vs {Target} - {Result}",
                attacker.Name, movingEntityId, attackResult.Success ? "Hit" : "Miss");
        }
    }

    public bool HasUsedReaction(Guid entityId) => _usedReactions.Contains(entityId);
    public void UseReaction(Guid entityId) => _usedReactions.Add(entityId);
    public void ResetReactions() => _usedReactions.Clear();

    public bool IsDisengaging(Guid entityId) => _disengaging.Contains(entityId);
    public void SetDisengaging(Guid entityId) => _disengaging.Add(entityId);
    public void ClearDisengaging(Guid entityId) => _disengaging.Remove(entityId);

    private bool HasMeleeWeapon(CombatantInfo combatant) =>
        combatant.EquippedWeapon?.RangeType == RangeType.Melee;
}
```

---

## 5. Reaction System

### 5.1 Reaction Tracking

Each entity can use one reaction per round:

```csharp
// ThreatService tracks reactions
private readonly HashSet<Guid> _usedReactions = new();

public bool HasUsedReaction(Guid entityId) => _usedReactions.Contains(entityId);
public void UseReaction(Guid entityId) => _usedReactions.Add(entityId);
public void ResetReactions() => _usedReactions.Clear();
```

### 5.2 Reaction Reset

**File:** `src/Core/RuneAndRust.Application/Services/CombatStateService.cs`

```csharp
// On round start, reset all reactions:
public void StartNewRound()
{
    _threatService.ResetReactions();
    _currentRound++;
    _logger.LogInformation("Round {Round} started, reactions reset", _currentRound);
}
```

---

## 6. MovementService Integration

**File:** `src/Core/RuneAndRust.Application/Services/MovementService.cs`

```csharp
public MovementResult Move(Guid entityId, MovementDirection direction)
{
    // ... existing validation ...

    var newPosition = currentPosition.Move(direction);

    // Check for opportunity attacks
    var opportunityCheck = _threatService.CheckOpportunityAttacks(
        entityId, currentPosition, newPosition);

    var opportunityResults = new List<OpportunityAttackResult>();

    if (opportunityCheck.TriggersOpportunityAttacks)
    {
        // Execute opportunity attacks before movement
        opportunityResults = _threatService.ExecuteOpportunityAttacks(
            entityId, currentPosition, newPosition).ToList();

        // Check if entity died from opportunity attacks
        var entity = _combatStateService.GetCombatant(entityId);
        if (entity == null || entity.CurrentHp <= 0)
        {
            return new MovementResult
            {
                Success = false,
                FailureReason = MovementFailureReason.EntityDied,
                OpportunityAttacks = opportunityResults,
                Message = "You were killed while trying to move!"
            };
        }
    }

    // ... perform movement ...
    // ... terrain damage ...

    return new MovementResult
    {
        Success = true,
        OldPosition = currentPosition,
        NewPosition = newPosition,
        MovementPointsUsed = totalCost,
        MovementPointsRemaining = entity.MovementPointsRemaining - totalCost,
        OpportunityAttacks = opportunityResults,
        Message = BuildMovementMessage(/*...*/)
    };
}
```

### 6.1 Updated MovementResult

```csharp
public readonly record struct MovementResult
{
    // ... existing properties ...
    public IReadOnlyList<OpportunityAttackResult> OpportunityAttacks { get; init; }
}

public enum MovementFailureReason
{
    None,
    OutOfBounds,
    Occupied,
    Impassable,
    InsufficientMovementPoints,
    EntityDied  // NEW: died from opportunity attack
}
```

---

## 7. DisengageCommand

**File:** `src/Core/RuneAndRust.Application/Commands/DisengageCommand.cs`

```csharp
namespace RuneAndRust.Application.Commands;

public class DisengageCommand : ICommand
{
    public string Name => "disengage";
    public string Description => "Use your action to disengage, moving without triggering opportunity attacks this turn.";
    public string[] Aliases => new[] { "withdraw", "retreat" };

    private readonly IThreatService _threatService;
    private readonly ICombatStateService _combatStateService;
    private readonly ITurnService _turnService;

    public DisengageCommand(
        IThreatService threatService,
        ICombatStateService combatStateService,
        ITurnService turnService)
    {
        _threatService = threatService;
        _combatStateService = combatStateService;
        _turnService = turnService;
    }

    public CommandResult Execute(CommandContext context)
    {
        var combat = _combatStateService.GetCurrentCombat();
        if (combat == null)
        {
            return new CommandResult
            {
                Success = false,
                Message = "You can only disengage during combat."
            };
        }

        var player = combat.GetPlayerCombatant();
        if (player == null)
        {
            return new CommandResult
            {
                Success = false,
                Message = "Player not in combat."
            };
        }

        if (_threatService.IsDisengaging(player.Id))
        {
            return new CommandResult
            {
                Success = false,
                Message = "You are already disengaging this turn."
            };
        }

        // Check if action already used
        if (_turnService.HasUsedAction(player.Id))
        {
            return new CommandResult
            {
                Success = false,
                Message = "You have already used your action this turn."
            };
        }

        // Mark as disengaging and consume action
        _threatService.SetDisengaging(player.Id);
        _turnService.UseAction(player.Id);

        return new CommandResult
        {
            Success = true,
            Message = "You carefully disengage from combat. You can now move without triggering opportunity attacks this turn."
        };
    }
}
```

### 7.1 Turn End Cleanup

```csharp
// TurnService.EndTurn:
public void EndTurn(Guid entityId)
{
    _threatService.ClearDisengaging(entityId);
    // ... other cleanup ...
}
```

---

## 8. Grid Threat Display

**File:** `src/Presentation/RuneAndRust.Presentation/Adapters/GridRenderer.cs`

```csharp
// Add threat display to grid rendering:

public string RenderGridWithThreats(CombatGrid grid, Guid playerId)
{
    var sb = new StringBuilder();
    var playerPos = grid.GetEntityPosition(playerId);
    var threatenedPositions = GetThreatenedPositionsForPlayer(playerId);

    // ... render grid header ...

    for (int y = 0; y < grid.Height; y++)
    {
        for (int x = 0; x < grid.Width; x++)
        {
            var pos = new GridPosition(x, y);
            var cell = grid.GetCell(pos);

            if (threatenedPositions.Contains(pos) && !cell.IsOccupied)
            {
                sb.Append(" * "); // Threatened square
            }
            else
            {
                sb.Append(RenderCell(cell, grid.GetCover(pos), playerId));
            }
        }
        sb.AppendLine();
    }

    // Show threat info
    if (playerPos.HasValue && IsPositionThreatened(playerPos.Value, playerId))
    {
        sb.AppendLine();
        sb.AppendLine("Threats:");
        foreach (var threatenerId in _threatService.GetThreateningEntities(playerPos.Value))
        {
            var threatener = _combatStateService.GetCombatant(threatenerId);
            if (threatener != null)
            {
                var pos = grid.GetEntityPosition(threatenerId);
                sb.AppendLine($"  You are threatened by {threatener.Name} at {pos}");
            }
        }
        sb.AppendLine("  Moving away will trigger an opportunity attack");
        sb.AppendLine();
        sb.AppendLine("Options:");
        sb.AppendLine("  - Use 'disengage' to move safely");
        sb.AppendLine("  - Stay adjacent and attack");
        sb.AppendLine("  - Move and risk opportunity attack");
    }

    return sb.ToString();
}
```

---

## 9. User-Facing Commands

### 9.1 Movement with Threat Warning

```
> move north

WARNING: Moving will trigger opportunity attacks!
  - Skeleton (C3) threatens your current position

Do you want to move anyway? (yes/no/disengage)
> yes

The Skeleton swings at you as you try to escape!
[Opportunity Attack: Skeleton]
[Attack Roll: 2d6 + 2 = 11 vs AC 14]
Miss! The skeleton's sword misses you.

You move carefully...
[Movement: D3 → D2]
[Movement Points: 4 → 3 remaining]
```

### 9.2 Opportunity Attack Hits

```
> move west

WARNING: Moving will trigger opportunity attacks!
  - Goblin (D4) threatens your current position

> yes

The Goblin stabs at you as you flee!
[Opportunity Attack: Goblin]
[Attack Roll: 2d6 + 3 = 16 vs AC 14]
Hit! 5 damage.
HP: 25/30 → 20/30

You move to C3...
[Movement: D3 → C3]
```

### 9.3 Disengage Action

```
> disengage

You carefully disengage from combat.
You can now move without triggering opportunity attacks this turn.

> move north

You slip away from the Skeleton without provoking an attack.
[Movement: D3 → D2]
[Movement Points: 4 → 3 remaining]
```

### 9.4 Grid with Threatened Squares

```
Combat Grid                              [Turn 3]
===============================================

  A B C D E F G H
1 . . . . . . . .
2 . . * * * . . .     @ = You (D4)
3 . . * M * . . .     M = Skeleton (C3)
4 . . * @←. . . .     * = Threatened squares
5 . . . . . . . .     ← = You are adjacent to threat

Threats:
  You are threatened by Skeleton at C3
  Moving away will trigger an opportunity attack

Options:
  - Use 'disengage' to move safely
  - Stay adjacent and attack
  - Move and risk opportunity attack

You (D4) | HP: 25/30 | Action: Available
```

---

## 10. Data Model Changes

| Type | Layer | Description |
|------|-------|-------------|
| `IThreatService` | Application/Interfaces | Threat service interface |
| `ThreatService` | Application/Services | Threat calculations |
| `OpportunityAttackCheckResult` | Application/DTOs | OA check result |
| `OpportunityAttackResult` | Application/DTOs | OA execution result |
| `DisengageCommand` | Application/Commands | Disengage action |
| `MovementResult` | Application/DTOs | Add OpportunityAttacks property |
| `MovementFailureReason` | Domain/Enums | Add EntityDied |

---

## 11. Configuration File Schemas

**File:** `config/combat.json` (opportunity attacks section)

```json
{
  "$schema": "./schemas/combat.schema.json",
  "opportunityAttacks": {
    "enabled": true,
    "requiresMeleeWeapon": true,
    "oneReactionPerRound": true,
    "disengageAction": {
      "enabled": true,
      "consumesAction": true
    },
    "description": "Moving out of an enemy's reach triggers an opportunity attack"
  }
}
```

---

## 12. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `ThreatService` | Debug | Threat checks, OA evaluations |
| `ThreatService` | Information | OA executed, reactions used |
| `MovementService` | Information | OA triggered during movement |
| `CombatStateService` | Information | Reactions reset on round start |

---

## 13. Unit Testing Requirements

| Feature | Test Count |
|---------|------------|
| ThreatService.GetThreatenedSquares | ~4 |
| ThreatService.GetThreateningEntities | ~3 |
| ThreatService.IsPositionThreatened | ~3 |
| ThreatService.CheckOpportunityAttacks | ~6 |
| ThreatService.ExecuteOpportunityAttacks | ~4 |
| Reaction System | ~4 |
| Disengage System | ~3 |
| MovementService OA Integration | ~3 |
| **Total** | **~30** |

---

## 14. Use Cases

### UC-001: Opportunity Attack Triggers
**Flow:** Move out of threatened square → Warning → Confirm → OA executed

### UC-002: Reaction Limit
**Flow:** Entity makes OA → Reaction used → Can't make another OA this round

### UC-003: Disengage Prevents OA
**Flow:** Disengage action → Move away → No OA triggered

### UC-004: Staying Adjacent Avoids OA
**Flow:** Move but stay adjacent to threatener → No OA triggered

### UC-005: Death During Movement
**Flow:** Move → OA hits → Entity dies → Movement fails

---

## 15. Deliverable Checklist

### Application Layer
- [ ] `IThreatService` interface
- [ ] `ThreatService` implementation
- [ ] `OpportunityAttackCheckResult`
- [ ] `OpportunityAttackResult`
- [ ] `DisengageCommand`
- [ ] MovementService OA integration
- [ ] CombatService.ProcessOpportunityAttack

### Combat State Updates
- [ ] Reaction tracking in ThreatService
- [ ] Reaction reset on round start
- [ ] Disengage tracking and cleanup

### Presentation Layer
- [ ] Grid threat display
- [ ] Movement OA warnings
- [ ] Disengage command registration

### Configuration
- [ ] `combat.json` opportunity attacks section

### Testing
- [ ] ~30 unit tests
- [ ] All tests passing

---

## 16. Acceptance Criteria

### Functional
- [ ] Creatures with melee weapons threaten adjacent squares
- [ ] Moving out of threatened square triggers opportunity attack
- [ ] Opportunity attacks are executed before movement completes
- [ ] Each creature gets one reaction per round
- [ ] Reactions reset at start of round
- [ ] Disengage action prevents opportunity attacks
- [ ] Disengage consumes the action for the turn
- [ ] Grid displays threatened squares
- [ ] Movement warns about opportunity attacks
- [ ] Configuration enables/disables feature

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~30 unit tests pass
- [ ] XML documentation complete

---

## 17. Dependencies

### Required from v0.5.3a

| Type | Usage |
|------|-------|
| Entity facing | Potential future OA direction rules |
| FlankingService infrastructure | Similar ally/enemy detection |

### Required from v0.5.0a

| Type | Usage |
|------|-------|
| `GridPosition` | Position calculations |
| `CombatGrid` | Entity positions, adjacent cells |
| `MovementService` | Integration point |

### Provides to v0.5.3c
- Movement validation infrastructure
- Reaction system for AoE reactions (future)

---

## 18. Future Considerations

### Deferred to v0.5.3c
- Area effects
- AoE targeting

### Out of Scope
- Reach weapons extending threat range
- Sentinel-style stopping movement
- Opportunity attack on spellcasting
- Multiple reactions per round

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: AI Assistant*
