# v0.5.1c Design Specification: Line of Sight

**Version:** 0.5.1c
**Phase Name:** Line of Sight
**Parent Version:** v0.5.1 (Range & Melee Combat)
**Prerequisites:** v0.5.1b Complete (Ranged Weapons)
**Estimated Tests:** ~20 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [GridCell Modifications](#4-gridcell-modifications)
5. [LineOfSightService](#5-lineofsightservice)
6. [RangeService LOS Integration](#6-rangeservice-los-integration)
7. [User-Facing Commands](#7-user-facing-commands)
8. [Data Model Changes](#8-data-model-changes)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Use Cases](#11-use-cases)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Dependencies](#14-dependencies)
15. [Future Considerations](#15-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification implements line of sight (LOS) calculations to validate that ranged attacks have a clear path to the target. Blocking cells such as walls and large obstacles interrupt LOS and prevent ranged attacks. LOS is traced using Bresenham's line algorithm, a proven approach for grid-based line drawing.

Key mechanics:
- **LOS Tracing**: Bresenham's algorithm determines cells between attacker and target
- **Blocking Cells**: Walls and obstacles interrupt line of sight
- **Melee Bypass**: Adjacent cells always have LOS (no check needed)
- **Attack Integration**: Ranged attacks require LOS validation

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Updates** | `GridCell.BlocksLOS` property |
| **Application Interfaces** | `ILineOfSightService` |
| **Application Services** | `LineOfSightService` |
| **Result Types** | `LineOfSightResult` |
| **RangeService Updates** | LOS integration in range checks |
| **GridRenderer Updates** | Optional LOS visualization |
| **Tests** | ~20 unit tests |

### 1.3 Architectural Significance

This version completes the **Range & Melee Combat** system:

- **Tactical Positioning**: LOS creates meaningful cover opportunities
- **Environmental Interaction**: Walls and obstacles affect combat
- **Ranged Balance**: Can't shoot through walls even if in range
- **Clear Feedback**: Players know why attacks are blocked

---

## 2. Feature Overview

```
v0.5.1c Line of Sight
├── GridCell Modifications
│   ├── BlocksLOS: bool (default: false)
│   └── SetBlocksLOS(bool): void
├── LineOfSightService
│   ├── HasLineOfSight(fromEntity, toEntity)
│   ├── HasLineOfSight(fromPos, toPos)
│   ├── GetLineCells(from, to) [Bresenham]
│   ├── GetFirstBlockingCell(from, to)
│   └── GetVisiblePositions(from, maxRange)
├── LineOfSightResult
│   ├── HasLOS: bool
│   ├── FromPosition, ToPosition
│   ├── BlockedBy: GridPosition?
│   └── Message: string
├── RangeService LOS Integration
│   ├── CheckRange includes LOS for Ranged
│   └── RangeFailureReason.NoLineOfSight
└── GridRenderer Updates
    └── LOS visualization with ✓/? symbols
```

### 2.1 Scope Alignment

**In Scope:**
- `ILineOfSightService` interface
- `LineOfSightService` implementation
- LOS blocking cell determination
- `GridCell.BlocksLOS` property
- Line tracing between positions (Bresenham's algorithm)
- LOS check in ranged attack validation
- LOS visualization on grid (optional)
- Melee attacks bypass LOS (always have LOS if adjacent)
- LOS failure message with blocking cell info

**Out of Scope:**
- Cover (v0.5.2) - provides defense, not LOS blocking
- Partial obscurement (future)
- Fog of war (future)

---

## 3. Architecture Diagrams

### 3.1 Bresenham's Line Algorithm

```
┌─────────────────────────────────────────────────────────────────────┐
│                     BRESENHAM'S LINE ALGORITHM                       │
└─────────────────────────────────────────────────────────────────────┘

    From A2 to G5: Trace the line and check each cell

      A   B   C   D   E   F   G   H
    ┌───┬───┬───┬───┬───┬───┬───┬───┐
  1 │   │   │   │   │   │   │   │   │
    ├───┼───┼───┼───┼───┼───┼───┼───┤
  2 │ @ │ · │   │   │   │   │   │   │   @ = Start (A2)
    ├───┼───┼───┼───┼───┼───┼───┼───┤   X = End (G5)
  3 │   │   │ · │ · │   │   │   │   │   · = Line path
    ├───┼───┼───┼───┼───┼───┼───┼───┤   # = Blocking cell
  4 │   │   │   │   │ · │ · │   │   │
    ├───┼───┼───┼───┼───┼───┼───┼───┤
  5 │   │   │   │   │   │   │ X │   │
    └───┴───┴───┴───┴───┴───┴───┴───┘

    Line cells: A2 → B2 → C3 → D3 → E4 → F4 → G5
    Check each intermediate cell for BlocksLOS

    Example with blocking:

      A   B   C   D   E   F   G   H
    ┌───┬───┬───┬───┬───┬───┬───┬───┐
  2 │ @ │ · │   │   │   │   │   │   │
    ├───┼───┼───┼───┼───┼───┼───┼───┤
  3 │   │   │ · │ # │   │   │   │   │   # blocks LOS!
    ├───┼───┼───┼───┼───┼───┼───┼───┤
  4 │   │   │   │   │ ✗ │ ✗ │   │   │   ✗ = Path blocked
    ├───┼───┼───┼───┼───┼───┼───┼───┤
  5 │   │   │   │   │   │   │ X │   │   Can't see X
    └───┴───┴───┴───┴───┴───┴───┴───┘
```

### 3.2 LOS Check Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                         LOS CHECK FLOW                               │
└─────────────────────────────────────────────────────────────────────┘

    Ranged Attack Request
              │
              ▼
    ┌───────────────────┐
    │ Get Positions     │
    │ (from, to)        │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Are Adjacent?     │──Yes──▶ LOS = true (bypass check)
    │ (distance == 1)   │
    └────────┬──────────┘
             │No
             ▼
    ┌───────────────────┐
    │ Trace Line        │
    │ (Bresenham)       │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ For each cell     │
    │ in line path:     │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Cell.BlocksLOS    │──Yes──▶ Fail: LOS blocked
    │ or !IsPassable?   │          Return blocking cell
    └────────┬──────────┘
             │No (all clear)
             ▼
    ┌───────────────────┐
    │ LOS = true        │
    │ Path is clear     │
    └───────────────────┘
```

### 3.3 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  GridRenderer (Extended)                                             │
│  ├── RenderWithLOS(grid, fromPos, range): string                    │
│  └── LOS symbols: ✓ = visible, ? = blocked                          │
├─────────────────────────────────────────────────────────────────────┤
│  TargetsCommand (Extended)                                           │
│  └── Shows LOS status for each target                               │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  ILineOfSightService / LineOfSightService                            │
│  ├── HasLineOfSight(fromEntityId, toEntityId): LineOfSightResult    │
│  ├── HasLineOfSight(from, to): LineOfSightResult                    │
│  ├── GetLineCells(from, to): IEnumerable<GridPosition>              │
│  ├── GetFirstBlockingCell(from, to): GridPosition?                  │
│  └── GetVisiblePositions(from, maxRange): IEnumerable<GridPosition> │
├─────────────────────────────────────────────────────────────────────┤
│  LineOfSightResult                                                   │
│  ├── HasLOS: bool                                                   │
│  ├── FromPosition: GridPosition                                     │
│  ├── ToPosition: GridPosition                                       │
│  ├── BlockedBy: GridPosition?                                       │
│  └── Message: string                                                │
├─────────────────────────────────────────────────────────────────────┤
│  RangeService (Extended from v0.5.1b)                                │
│  └── CheckRange now includes LOS check for RangeType.Ranged         │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         DOMAIN LAYER                                 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                GridCell (Extended from v0.5.0a)              │  │
│  ├──────────────────────────────────────────────────────────────┤  │
│  │ [v0.5.0a] Position, IsOccupied, OccupantId, IsPassable      │  │
│  │ [NEW] BlocksLOS: bool (default: false)                      │  │
│  │ [NEW] SetBlocksLOS(bool): void                              │  │
│  │ [CLARIFY] !IsPassable implies BlocksLOS for walls           │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.4 LOS vs Blocking Rules

```
┌─────────────────────────────────────────────────────────────────────┐
│                      LOS BLOCKING RULES                              │
└─────────────────────────────────────────────────────────────────────┘

    Cell Type          │ BlocksLOS │ Notes
    ────────────────────┼───────────┼────────────────────────────────
    Empty cell (.)     │    No     │ Clear for LOS
    Occupied by entity │    No     │ Can shoot past allies/enemies
    Wall (#)           │   Yes     │ Always blocks LOS
    Impassable         │   Yes     │ !IsPassable → blocks LOS
    Pillar/Obstacle    │   Yes     │ BlocksLOS explicitly true
    ────────────────────┼───────────┼────────────────────────────────

    Special Cases:
    ┌─────────────────────────────────────────────────────────────┐
    │ • Adjacent cells always have LOS (distance 1)              │
    │ • Start and end positions are NOT checked for blocking     │
    │ • Diagonal movement through corners: allowed (permissive)  │
    │ • Melee/Reach attacks don't check LOS                      │
    └─────────────────────────────────────────────────────────────┘
```

---

## 4. GridCell Modifications

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/GridCell.cs`

```csharp
// Add to GridCell:

/// <summary>Gets whether this cell blocks line of sight.</summary>
public bool BlocksLOS { get; private set; }

/// <summary>Sets whether this cell blocks line of sight.</summary>
public void SetBlocksLOS(bool blocksLOS)
{
    BlocksLOS = blocksLOS;
}

/// <summary>Gets whether this cell blocks line of sight (computed).</summary>
/// <remarks>
/// Returns true if BlocksLOS is explicitly set or if the cell is impassable.
/// Walls and obstacles block LOS, but occupied cells do not.
/// </remarks>
public bool EffectivelyBlocksLOS => BlocksLOS || !IsPassable;
```

---

## 5. LineOfSightService

### 5.1 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ILineOfSightService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for line of sight calculations.
/// </summary>
public interface ILineOfSightService
{
    /// <summary>Checks if there is line of sight between two entities.</summary>
    LineOfSightResult HasLineOfSight(Guid fromEntityId, Guid toEntityId);

    /// <summary>Checks if there is line of sight between two positions.</summary>
    LineOfSightResult HasLineOfSight(GridPosition from, GridPosition to);

    /// <summary>Gets all cells along the line between two positions.</summary>
    IEnumerable<GridPosition> GetLineCells(GridPosition from, GridPosition to);

    /// <summary>Gets the first blocking cell along the line.</summary>
    GridPosition? GetFirstBlockingCell(GridPosition from, GridPosition to);

    /// <summary>Gets all positions visible from a given position.</summary>
    IEnumerable<GridPosition> GetVisiblePositions(GridPosition from, int maxRange);
}

public readonly record struct LineOfSightResult(
    bool HasLOS,
    GridPosition FromPosition,
    GridPosition ToPosition,
    GridPosition? BlockedBy,
    string Message);
```

### 5.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/LineOfSightService.cs`

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for line of sight calculations using Bresenham's line algorithm.
/// </summary>
public class LineOfSightService : ILineOfSightService
{
    private readonly ICombatGridService _gridService;
    private readonly ILogger<LineOfSightService> _logger;

    public LineOfSightService(
        ICombatGridService gridService,
        ILogger<LineOfSightService> logger)
    {
        _gridService = gridService;
        _logger = logger;
    }

    public LineOfSightResult HasLineOfSight(Guid fromEntityId, Guid toEntityId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            return new LineOfSightResult(false, default, default, null, "No active combat grid.");

        var fromPos = grid.GetEntityPosition(fromEntityId);
        var toPos = grid.GetEntityPosition(toEntityId);

        if (!fromPos.HasValue || !toPos.HasValue)
            return new LineOfSightResult(false, default, default, null, "Entity not on grid.");

        return HasLineOfSight(fromPos.Value, toPos.Value);
    }

    public LineOfSightResult HasLineOfSight(GridPosition from, GridPosition to)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            return new LineOfSightResult(false, from, to, null, "No active combat grid.");

        // Adjacent cells always have LOS
        if (from.IsAdjacentTo(to))
        {
            return new LineOfSightResult(true, from, to, null,
                "Adjacent - line of sight clear.");
        }

        // Check each cell along the line
        var blockingCell = GetFirstBlockingCell(from, to);

        if (blockingCell.HasValue)
        {
            _logger.LogDebug("LOS blocked from {From} to {To} by cell at {Block}",
                from, to, blockingCell.Value);

            return new LineOfSightResult(false, from, to, blockingCell.Value,
                $"Line of sight blocked by obstacle at {blockingCell.Value}.");
        }

        return new LineOfSightResult(true, from, to, null, "Line of sight clear.");
    }

    public IEnumerable<GridPosition> GetLineCells(GridPosition from, GridPosition to)
    {
        // Bresenham's line algorithm
        int x0 = from.X, y0 = from.Y;
        int x1 = to.X, y1 = to.Y;

        int dx = Math.Abs(x1 - x0);
        int dy = Math.Abs(y1 - y0);
        int sx = x0 < x1 ? 1 : -1;
        int sy = y0 < y1 ? 1 : -1;
        int err = dx - dy;

        while (true)
        {
            yield return new GridPosition(x0, y0);

            if (x0 == x1 && y0 == y1)
                break;

            int e2 = 2 * err;

            if (e2 > -dy)
            {
                err -= dy;
                x0 += sx;
            }

            if (e2 < dx)
            {
                err += dx;
                y0 += sy;
            }
        }
    }

    public GridPosition? GetFirstBlockingCell(GridPosition from, GridPosition to)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) return null;

        foreach (var pos in GetLineCells(from, to))
        {
            // Skip start and end positions
            if (pos.Equals(from) || pos.Equals(to))
                continue;

            var cell = grid.GetCell(pos);
            if (cell != null && cell.EffectivelyBlocksLOS)
                return pos;
        }

        return null;
    }

    public IEnumerable<GridPosition> GetVisiblePositions(GridPosition from, int maxRange)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) yield break;

        for (int y = 0; y < grid.Height; y++)
        {
            for (int x = 0; x < grid.Width; x++)
            {
                var pos = new GridPosition(x, y);

                if (pos.Equals(from)) continue;
                if (from.DistanceTo(pos) > maxRange) continue;

                var losResult = HasLineOfSight(from, pos);
                if (losResult.HasLOS)
                    yield return pos;
            }
        }
    }
}
```

---

## 6. RangeService LOS Integration

**File:** `src/Core/RuneAndRust.Application/Services/RangeService.cs`

```csharp
// Update RangeService to include LOS check for ranged attacks:

private readonly ILineOfSightService _losService;

public RangeService(
    ICombatGridService gridService,
    ILineOfSightService losService,  // NEW dependency
    ILogger<RangeService> logger)
{
    _gridService = gridService;
    _losService = losService;
    _logger = logger;
}

public RangeCheckResult CheckRange(
    Guid attackerId, Guid targetId, int weaponRange, RangeType rangeType)
{
    // ... existing grid and position checks from v0.5.1a ...

    var grid = _gridService.GetActiveGrid();
    if (grid == null)
        return Fail(RangeFailureReason.NoActiveGrid, "No active combat grid.");

    var distance = GetDistance(attackerId, targetId);
    if (!distance.HasValue)
        return Fail(RangeFailureReason.AttackerNotOnGrid, "Entity not on grid.");

    var dist = distance.Value;

    // ... existing range validation from v0.5.1a/b ...

    // NEW: For ranged attacks, check line of sight
    if (rangeType == RangeType.Ranged)
    {
        var losResult = _losService.HasLineOfSight(attackerId, targetId);
        if (!losResult.HasLOS)
        {
            _logger.LogDebug("LOS check failed: {Message}", losResult.Message);
            return new RangeCheckResult
            {
                InRange = false,
                Distance = dist,
                WeaponRange = weaponRange,
                RangeType = rangeType,
                FailureReason = RangeFailureReason.NoLineOfSight,
                Message = losResult.Message,
                BlockedBy = losResult.BlockedBy
            };
        }
    }

    // ... continue with existing success path ...
}
```

### 6.1 Updated RangeCheckResult

```csharp
public readonly record struct RangeCheckResult
{
    // From v0.5.1a:
    public bool InRange { get; init; }
    public int Distance { get; init; }
    public int WeaponRange { get; init; }
    public RangeType RangeType { get; init; }
    public string Message { get; init; }
    public RangeFailureReason? FailureReason { get; init; }

    // From v0.5.1b:
    public int Penalty { get; init; }
    public bool IsOptimal { get; init; }
    public bool TooClose { get; init; }

    // NEW in v0.5.1c:
    public GridPosition? BlockedBy { get; init; }
}
```

---

## 7. User-Facing Commands

### 7.1 Ranged Attack Blocked by LOS

```
> attack skeleton

Your view of the Skeleton is blocked!

[Distance: 4 cells - in range]
[Line of sight blocked by wall at D3]

Move to a different position for a clear shot.
```

### 7.2 LOS Display on Grid (targets command)

```
> targets

  A B C D E F G H
1 . . . . . . . .
2 . . ✓ . . ? . .     @ = You (D4)
3 . . . # . . . .     ✓ = Valid target
4 . . ✓ @ ✓ . . .     ? = Blocked (no LOS)
5 . . . . . . . .     # = Wall (blocks LOS)

Valid Targets (Longbow):
  ✓ Goblin at C2 [3 cells, clear LOS]
  ✓ Skeleton at C4 [1 cell, clear LOS]
  ✓ Skeleton at E4 [1 cell, clear LOS]

Blocked:
  ? Skeleton at F2 [No line of sight - wall at D3]
```

### 7.3 Successful Ranged with LOS

```
> attack goblin

You draw your Longbow and take aim at the Goblin...

[Distance: 3 cells - in range]
[Line of sight: clear]
[Attack Roll: 2d6 + 3 = 14 vs AC 11]
Hit! 7 damage to Goblin.
```

### 7.4 Melee Attack (No LOS Check)

```
> attack skeleton

You swing your Iron Sword at the Skeleton at C4...

[Melee attack - adjacent target]
[Attack Roll: 2d6 + 3 = 15 vs AC 12]
Hit! 9 damage to Skeleton.
```

---

## 8. Data Model Changes

| Type | Layer | Description |
|------|-------|-------------|
| `GridCell` | Domain/ValueObjects | Add BlocksLOS, SetBlocksLOS, EffectivelyBlocksLOS |
| `ILineOfSightService` | Application/Interfaces | LOS service interface |
| `LineOfSightService` | Application/Services | Bresenham's algorithm implementation |
| `LineOfSightResult` | Application/DTOs | LOS check result |
| `RangeService` | Application/Services | LOS integration |
| `RangeCheckResult` | Application/DTOs | Add BlockedBy field |

---

## 9. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `LineOfSightService` | Debug | LOS checks, blocking cell detection |
| `LineOfSightService` | Information | Visible position queries |
| `RangeService` | Debug | LOS failures in range checks |

---

## 10. Unit Testing Requirements

| Feature | Test Count |
|---------|------------|
| GridCell.BlocksLOS | ~2 |
| GridCell.EffectivelyBlocksLOS | ~3 |
| LineOfSightService.HasLineOfSight | ~5 |
| LineOfSightService.GetLineCells | ~4 |
| LineOfSightService.GetFirstBlockingCell | ~3 |
| LineOfSightService.GetVisiblePositions | ~2 |
| RangeService LOS Integration | ~1 |
| **Total** | **~20** |

### 10.1 Key Test Scenarios

```csharp
// Adjacent always has LOS
[Test]
public void HasLineOfSight_WhenAdjacent_ReturnsTrue()

// Clear path has LOS
[Test]
public void HasLineOfSight_WhenPathClear_ReturnsTrue()

// Wall blocks LOS
[Test]
public void HasLineOfSight_WhenWallBlocks_ReturnsFalse()

// Occupied cell doesn't block LOS
[Test]
public void HasLineOfSight_WhenEntityInPath_ReturnsTrue()

// GetLineCells returns correct Bresenham path
[Test]
public void GetLineCells_DiagonalLine_ReturnsCorrectPath()

// Start/end positions not checked
[Test]
public void GetFirstBlockingCell_SkipsStartAndEnd_ReturnsNull()
```

---

## 11. Use Cases

### UC-001: Ranged Attack with Clear LOS
**Flow:** Player → Range OK → LOS check → Clear → Attack proceeds

### UC-002: Ranged Attack Blocked
**Flow:** Player → Range OK → LOS check → Wall at D3 → Fail with message

### UC-003: Melee Attack (LOS Bypassed)
**Flow:** Player adjacent → Melee → No LOS check → Attack proceeds

### UC-004: Show Visible Targets
**Flow:** `targets` command → GetValidTargets → Check LOS → Display ✓/?

### UC-005: Reach Attack (LOS Bypassed)
**Flow:** Player at distance 2 with spear → Reach → No LOS check

---

## 12. Deliverable Checklist

### Domain Layer
- [ ] `GridCell.BlocksLOS` property
- [ ] `GridCell.SetBlocksLOS()` method
- [ ] `GridCell.EffectivelyBlocksLOS` computed property

### Application Layer
- [ ] `ILineOfSightService` interface
- [ ] `LineOfSightService` implementation (Bresenham)
- [ ] `LineOfSightResult` record
- [ ] `RangeService` LOS integration
- [ ] Updated `RangeCheckResult` with BlockedBy

### Presentation Layer
- [ ] GridRenderer LOS visualization (optional)
- [ ] Updated `targets` command with LOS status

### Testing
- [ ] ~20 unit tests
- [ ] All tests passing

---

## 13. Acceptance Criteria

### Functional
- [ ] ILineOfSightService interface defined
- [ ] LineOfSightService implements Bresenham's algorithm correctly
- [ ] Adjacent cells always have LOS (distance 1)
- [ ] Walls (#) block line of sight
- [ ] GridCell.BlocksLOS property works correctly
- [ ] Impassable cells block LOS (!IsPassable)
- [ ] Occupied cells do NOT block LOS
- [ ] Ranged attacks check LOS before attacking
- [ ] LOS failure shows blocking cell position
- [ ] Melee attacks don't require LOS check
- [ ] Reach attacks don't require LOS check
- [ ] GetVisiblePositions returns all visible cells
- [ ] GetLineCells returns correct Bresenham path
- [ ] LOS visualization available on grid (targets command)

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~20 unit tests pass
- [ ] XML documentation complete

---

## 14. Dependencies

### Required from v0.5.0a

| Type | Usage |
|------|-------|
| `CombatGrid` | Grid access for LOS checks |
| `GridPosition` | Position calculations, IsAdjacentTo |
| `GridCell` | BaseType to extend with BlocksLOS |

### Required from v0.5.1a

| Type | Usage |
|------|-------|
| `RangeType` | Determine if LOS check needed |
| `RangeService` | Integration point for LOS |
| `RangeCheckResult` | Extended with BlockedBy |

### Provides to v0.5.2
- LOS foundation for cover calculations
- Blocking detection for partial cover

---

## 15. Future Considerations

### Deferred to v0.5.2
- Cover system (partial defense, not LOS blocking)
- Cover detection from blocking cells

### Deferred to Future Versions
- Partial obscurement (fog, smoke)
- Fog of war (hidden areas)
- Light-based visibility
- Height/elevation affecting LOS
- Symmetric LOS (A sees B ↔ B sees A)

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: AI Assistant*
