Here is the comprehensive implementation plan for v0.1.0: Character Creation.
v0.1.0: The Survivor's Beginning
Goal: Implement the Character Creation Wizard. This transforms the application from a generic engine into an RPG by allowing players to define their avatar's Lineage, Background, Archetype, and Attributes, culminating in a persistent Character record in the PostgreSQL database.

## Table of Contents
- [1. Implementation Workflow](#1-implementation-workflow)
- [2. Code Implementation](#2-code-implementation)
- [3. Architecture Decision Tree](#3-architecture-decision-tree-v010)
- [4. Logging Requirements](#4-logging-requirements)
- [5. Deliverable Checklist](#5-deliverable-checklist-v010)

1. Implementation Workflow
	1	Domain Expansion: Define Enums for Lineage, Archetype, and Background in Core.
	2	Entity Update: Expand the Character entity to store these properties and derived stats (HP, Stamina, AP).
	3	Engine Logic: Implement the CharacterFactory to handle assembly and StatCalculationService for derived formulas.
	4	UI Implementation: Create the CharacterCreationController in the Terminal project to guide the user through the 6-step wizard.
	5	Persistence: Create an EF Core migration to update the database schema.
	6	Verification: Test that a created character persists and loads correctly with accurate derived stats.

2. Code Implementation
A. Core Layer (Definitions)
We define the static choices available to the player.
File: RuneAndRust.Core/Enums/ArchetypeType.cs
namespace RuneAndRust.Core.Enums;

public enum ArchetypeType
{
    Warrior = 1,
    Adept = 2,
    Skirmisher = 3,
    Mystic = 4
}
File: RuneAndRust.Core/Enums/LineageType.cs
namespace RuneAndRust.Core.Enums;

public enum LineageType
{
    Human = 1,    // "Clan-Born"
    RuneMarked = 2,
    IronBlooded = 3,
    VargrKin = 4
}
File: RuneAndRust.Core/Entities/Character.cs (Updated)
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

public class Character
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;

    // Bio Data
    public LineageType Lineage { get; set; }
    public ArchetypeType Archetype { get; set; }
    // Background stored as string for flexibility or Enum if strict
    public string Background { get; set; } = string.Empty;

    // Core Attributes (The 5 Pillars)
    public Dictionary<Attribute, int> Attributes { get; set; } = new();

    // Derived Resources (Calculated)
    public int MaxHp { get; set; }
    public int CurrentHp { get; set; }
    public int MaxStamina { get; set; }
    public int CurrentStamina { get; set; }
    public int MaxAp { get; set; }
    public int CurrentAp { get; set; }

    // Progression
    public int Legend { get; set; }
    public int ProgressionPoints { get; set; }
}
B. Engine Layer (Business Logic)
We need a factory to assemble the character and a calculator for the derived stats based on the "Standardized Formulas" identified in the review report.
File: RuneAndRust.Engine/Services/StatCalculationService.cs (Updated)
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Engine.Services;

public class StatCalculationService : IStatCalculationService
{
    public void RecalculateDerivedStats(Character character)
    {
        var attrs = character.Attributes;

        // 1. HP: 50 + (Sturdiness * 10)
        character.MaxHp = 50 + (attrs[Attribute.Sturdiness] * 10);

        // 2. Stamina: 20 + (Might + Finesse) * 5
        character.MaxStamina = 20 + ((attrs[Attribute.Might] + attrs[Attribute.Finesse]) * 5);

        // 3. AP: 20 + (Will + Wits) * 5
        // Note: Non-Mystics might have 0 AP later, but for now we calculate potential
        character.MaxAp = 20 + ((attrs[Attribute.Will] + attrs[Attribute.Wits]) * 5);

        // Reset currents to max on creation
        character.CurrentHp = character.MaxHp;
        character.CurrentStamina = character.MaxStamina;
        character.CurrentAp = character.MaxAp;
    }
}
File: RuneAndRust.Engine/Factories/CharacterFactory.cs
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using Attribute = RuneAndRust.Core.Enums.Attribute;

namespace RuneAndRust.Engine.Factories;

public class CharacterFactory
{
    private readonly IStatCalculationService _statCalc;

    public CharacterFactory(IStatCalculationService statCalc)
    {
        _statCalc = statCalc;
    }

    public Character CreateSimple(string name, LineageType lineage, ArchetypeType archetype)
    {
        var character = new Character
        {
            Name = name,
            Lineage = lineage,
            Archetype = archetype,
            Attributes = GetArchetypeDefaults(archetype)
        };

        // Apply lineage bonuses (e.g., Clan-Born +5 HP) would happen here or in stat calc
        _statCalc.RecalculateDerivedStats(character);

        return character;
    }

    private Dictionary<Attribute, int> GetArchetypeDefaults(ArchetypeType type)
    {
        // Based on SPEC-CORE-ARCHETYPES
        return type switch
        {
            ArchetypeType.Warrior => new() {
                { Attribute.Might, 4 }, { Attribute.Finesse, 3 },
                { Attribute.Wits, 2 }, { Attribute.Will, 2 },
                { Attribute.Sturdiness, 4 }
            },
            ArchetypeType.Skirmisher => new() {
                { Attribute.Might, 3 }, { Attribute.Finesse, 4 },
                { Attribute.Wits, 3 }, { Attribute.Will, 2 },
                { Attribute.Sturdiness, 3 }
            },
            ArchetypeType.Mystic => new() {
                { Attribute.Might, 2 }, { Attribute.Finesse, 3 },
                { Attribute.Wits, 4 }, { Attribute.Will, 4 },
                { Attribute.Sturdiness, 2 }
            },
            ArchetypeType.Adept => new() {
                { Attribute.Might, 3 }, { Attribute.Finesse, 3 },
                { Attribute.Wits, 3 }, { Attribute.Will, 2 },
                { Attribute.Sturdiness, 3 }
            },
            _ => throw new ArgumentOutOfRangeException()
        };
    }
}
C. Terminal Layer (UI Flow)
The Wizard controls the sequence of inputs.
File: RuneAndRust.Terminal/Controllers/CharacterCreationController.cs
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Entities;
using RuneAndRust.Engine.Factories;
using Spectre.Console;

namespace RuneAndRust.Terminal.Controllers;

public class CharacterCreationController
{
    private readonly CharacterFactory _factory;

    public CharacterCreationController(CharacterFactory factory)
    {
        _factory = factory;
    }

    public Character RunWizard()
    {
        AnsiConsole.Clear();
        AnsiConsole.Write(new FigletText("New Saga").Color(Color.Gold1));

        // 1. Name
        var name = AnsiConsole.Ask<string>("Enter your [green]True Name[/]:");

        // 2. Lineage
        var lineage = AnsiConsole.Prompt(
            new SelectionPrompt<LineageType>()
                .Title("Select your [blue]Lineage[/]:")
                .AddChoices(Enum.GetValues<LineageType>()));

        // 3. Archetype
        var archetype = AnsiConsole.Prompt(
            new SelectionPrompt<ArchetypeType>()
                .Title("Select your [red]Archetype[/]:")
                .AddChoices(Enum.GetValues<ArchetypeType>()));

        // 4. Create (Simple Mode for v0.1.0)
        var character = _factory.CreateSimple(name, lineage, archetype);

        // 5. Confirmation
        DisplaySummary(character);

        return character;
    }

    private void DisplaySummary(Character c)
    {
        var table = new Table();
        table.AddColumn("Attribute");
        table.AddColumn("Value");

        foreach(var attr in c.Attributes)
        {
            table.AddRow(attr.Key.ToString(), attr.Value.ToString());
        }

        AnsiConsole.MarkupLine($"[bold]Character Created:[/] {c.Name} ({c.Lineage} {c.Archetype})");
        AnsiConsole.MarkupLine($"HP: [red]{c.MaxHp}[/] | STA: [green]{c.MaxStamina}[/] | AP: [purple]{c.MaxAp}[/]");
        AnsiConsole.Write(table);
        AnsiConsole.MarkupLine("\nPress [green]Enter[/] to begin your saga...");
        Console.ReadLine();
    }
}

3. Architecture Decision Tree (v0.1.0)
	•	Q: Should we implement Point-Buy or Simple Mode first?
	◦	A: Simple Mode. Use the pre-defined attribute arrays from SPEC-CORE-ARCHETYPES. This allows us to validate the persistence and derived stats logic without building a complex point-allocation UI in the console.
	•	Q: Where do the Starting Abilities go?
	◦	A: Postpone to v0.2.0. For v0.1.0, we only care about the Stats and Identity. Abilities are part of the Combat Milestone.
	•	Q: How do we handle "Specialization Selection"?
	◦	A: Default to "None". The spec says the first specialization is free at creation, but for the "Walking Skeleton," we can treat the base Archetype as the functional unit until v0.4.1.

4. Logging Requirements
Update CharacterFactory to log these events (per logging-matrix.md):
Event
Level
Template
Creation Start
Information
"Character creation wizard started."
Selection
Debug
"Player selected Lineage: {Lineage}, Archetype: {Archetype}"
Calculation
Trace
"Derived Stats: HP {MaxHp}, STA {MaxStamina}, AP {MaxAp}"
Success
Information
"Character '{Name}' created successfully. ID: {Id}"

5. Deliverable Checklist (v0.1.0)
	•	[ ] Core: ArchetypeType, LineageType Enums defined.
	•	[ ] Core: Character entity updated with new properties (Lineage, Archetype, Derived Stats).
	•	[ ] Engine: StatCalculationService implements standardized formulas.
	•	[ ] Engine: CharacterFactory implemented with CreateSimple method.
	•	[ ] Persistence: EF Core Migration AddCharacterDetails created and applied.
	•	[ ] Terminal: CharacterCreationController implemented with Spectre.Console.
	•	[ ] Integration: The start command in CommandParser triggers the creation wizard if no save exists.
	•	[ ] Testing:
	◦	[ ] CharacterFactoryTests: Verify Warrior gets MIGHT 4, STURDINESS 4.
	◦	[ ] StatCalculationTests: Verify HP/Stamina/AP math matches formulas.
	◦	[ ] PersistenceTests: Verify Lineage and Archetype are saved/loaded correctly from PostgreSQL.
Once this is complete, the player can launch the app, type start, build a character, and see their stats persist to the database.
Ready to implement the CharacterFactory?
