# Implementation Plan: v0.4.2e - The Archive (Seeding & Integration)

**Status:** Ready for Implementation
**Theme:** "The Archive"
**Scope:** Database seeding for factions and dialogue trees, NPC entity extensions, JSON-to-entity migration, integration tests
**Depends On:** v0.4.2a (FactionService), v0.4.2b (Dialogue entities), v0.4.2c (DialogueService), v0.4.2d (TUI)

---

## Executive Summary

v0.4.2e completes the Faction & Dialogue system by **populating the database** with canonical content. This release seeds the 4 core factions, converts existing dialogue JSON files to the v0.4.2b entity format, adds NPC entities to rooms, and provides integration tests verifying the full dialogue flow.

**Key Features:**
- **FactionSeeder:** Seeds 4 canonical factions with metadata and default dispositions
- **DialogueSeeder:** Converts 8 existing NPC dialogue JSON files to DialogueTree/Node/Option entities
- **NPC Entity Extension:** Adds `DialogueTreeId` to NPC entity for dialogue linkage
- **Room-NPC Integration:** Seeds NPCs into starting rooms with dialogue references
- **Integration Tests:** End-to-end tests for dialogue initiation, selection, and effect execution

**Layers Touched:** Persistence (Seeders, Migrations), Core (Entity extensions), Tests (Integration)
**Patterns Used:** Idempotent seeding, JSON-to-entity migration, integration testing
**Target Test Count:** 12 integration tests

---

## Table of Contents

1. [Decision Trees](#1-decision-trees)
2. [Deliverable Checklist](#2-deliverable-checklist)
3. [FactionSeeder Implementation](#3-factionseeder-implementation)
4. [DialogueSeeder Implementation](#4-dialogueseeder-implementation)
5. [NPC Entity Extension](#5-npc-entity-extension)
6. [NpcSeeder Implementation](#6-npcseeder-implementation)
7. [JSON Migration Strategy](#7-json-migration-strategy)
8. [Program.cs Integration](#8-programcs-integration)
9. [DbContext Updates](#9-dbcontext-updates)
10. [Logging Matrix](#10-logging-matrix)
11. [Test Coverage Plan](#11-test-coverage-plan)
12. [Code Examples](#12-code-examples)
13. [Seed Data Reference](#13-seed-data-reference)
14. [Changelog Template](#14-changelog-template)
15. [Critical Files](#15-critical-files)
16. [Implementation Order](#16-implementation-order)
17. [Design Decisions](#17-design-decisions)
18. [Domain 4 Compliance](#18-domain-4-compliance)

---

## 1. Decision Trees

### 1.1 Seeder Execution Flow

```
Program.cs Startup
        │
        ▼
┌───────────────────────────────────────┐
│ Create DI scope                       │
│ Get DbContext, Logger                 │
└───────────────────────────────────────┘
        │
        ▼
┌───────────────────────────────────────┐
│ FactionSeeder.SeedAsync(context)      │
│ - Check if Factions exist             │
│ - If empty, seed 4 factions           │
└───────────────────────────────────────┘
        │
        ▼
┌───────────────────────────────────────┐
│ DialogueSeeder.SeedAsync(context)     │
│ - Check if DialogueTrees exist        │
│ - If empty, load from JSON or seed    │
│   programmatic data                   │
└───────────────────────────────────────┘
        │
        ▼
┌───────────────────────────────────────┐
│ NpcSeeder.SeedAsync(context)          │
│ - Check if Npcs exist                 │
│ - If empty, seed NPCs with            │
│   DialogueTreeId references           │
└───────────────────────────────────────┘
        │
        ▼
┌───────────────────────────────────────┐
│ Existing seeders continue...          │
│ (Abilities, Conditions, etc.)         │
└───────────────────────────────────────┘
```

### 1.2 FactionSeeder Decision Flow

```
FactionSeeder.SeedAsync(context, logger)
                │
                ▼
    ┌───────────────────────────────┐
    │ await context.Factions.Any()  │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Log: "Factions  │  │ Create faction list:          │
│  already exist, │  │ - Iron-Banes (Neutral)        │
│  skipping"      │  │ - Dvergr (Neutral)            │
│ Return early    │  │ - The Bound (Hostile, -25)    │
└─────────────────┘  │ - The Faceless (Neutral)      │
                     └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ AddRangeAsync(factions)       │
                    │ SaveChangesAsync()            │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Log: "Seeded {Count} factions"│
                    └───────────────────────────────┘
```

### 1.3 DialogueSeeder Decision Flow

```
DialogueSeeder.SeedAsync(context, logger)
                │
                ▼
    ┌───────────────────────────────┐
    │ await context.DialogueTrees   │
    │ .AnyAsync()                   │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Log: "Dialogue  │  │ Load dialogue JSON files      │
│  trees exist,   │  │ from data/dialogues/          │
│  skipping"      │  └───────────────────────────────┘
│ Return early    │              │
└─────────────────┘              ▼
                    ┌───────────────────────────────┐
                    │ For each JSON file:           │
                    │ - Parse legacy format         │
                    │ - Convert to DialogueTree     │
                    │ - Create DialogueNodes        │
                    │ - Create DialogueOptions      │
                    │ - Map effects                 │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ AddRangeAsync(trees)          │
                    │ SaveChangesAsync()            │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Log: "Seeded {TreeCount} trees│
                    │  with {NodeCount} nodes"      │
                    └───────────────────────────────┘
```

### 1.4 NpcSeeder Decision Flow

```
NpcSeeder.SeedAsync(context, logger)
                │
                ▼
    ┌───────────────────────────────┐
    │ await context.Npcs.AnyAsync() │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Log: "NPCs      │  │ Get starting room(s) from     │
│  already exist, │  │ context or create placeholder │
│  skipping"      │  └───────────────────────────────┘
│ Return early    │              │
└─────────────────┘              ▼
                    ┌───────────────────────────────┐
                    │ Create NPCs with:             │
                    │ - Name, Description           │
                    │ - DialogueTreeId (string ref) │
                    │ - FactionType                 │
                    │ - RoomId assignment           │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ AddRangeAsync(npcs)           │
                    │ SaveChangesAsync()            │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Log: "Seeded {Count} NPCs"    │
                    └───────────────────────────────┘
```

### 1.5 Integration Test Flow

```
[IntegrationTest] TestDialogueFlow_EndToEnd
                │
                ▼
    ┌───────────────────────────────┐
    │ Setup:                        │
    │ - InMemory DbContext          │
    │ - Seed factions               │
    │ - Seed dialogue trees         │
    │ - Seed test NPC               │
    │ - Create test character       │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Act: StartDialogueAsync()     │
    │ Assert: Success, ViewModel    │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Act: SelectOptionAsync()      │
    │ Assert: Navigation works      │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Act: Select option with       │
    │      reputation effect        │
    │ Assert: Reputation changed    │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Act: Select terminal option   │
    │ Assert: Dialogue ends         │
    │ Assert: Final state correct   │
    └───────────────────────────────┘
```

---

## 2. Deliverable Checklist

### New Files to Create

| Layer | File Path | Purpose |
|-------|-----------|---------|
| Persistence | `RuneAndRust.Persistence/Data/FactionSeeder.cs` | Seeds 4 canonical factions |
| Persistence | `RuneAndRust.Persistence/Data/DialogueSeeder.cs` | Seeds dialogue trees from JSON or programmatic |
| Persistence | `RuneAndRust.Persistence/Data/NpcSeeder.cs` | Seeds NPCs with dialogue references |
| Tests | `RuneAndRust.Tests/Integration/DialogueIntegrationTests.cs` | 12 integration tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/Npc.cs` | Add `DialogueTreeId` property (or create if missing) |
| `RuneAndRust.Core/Entities/Room.cs` | Add `ICollection<Npc> Npcs` if missing |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Add `DbSet<Npc>` if missing, configure relationships |
| `RuneAndRust.Terminal/Program.cs` | Add seeder invocations in startup |

### JSON Files to Migrate

| File | NPC Name | Faction | Nodes |
|------|----------|---------|-------|
| `astrid_dialogues.json` | Astrid | Independent | 5 |
| `bjorn_dialogues.json` | Bjorn | Iron-Banes | ~5 |
| `eydis_dialogues.json` | Eydis | Dvergr | ~5 |
| `gunnar_dialogues.json` | Gunnar | Iron-Banes | ~5 |
| `kjartan_dialogues.json` | Kjartan | Dvergr | ~5 |
| `rolf_dialogues.json` | Rolf | The Faceless | ~5 |
| `sigrun_dialogues.json` | Sigrun | Iron-Banes | ~8 |
| `thorvald_dialogues.json` | Thorvald | Independent | ~5 |

---

## 3. FactionSeeder Implementation

**File:** `RuneAndRust.Persistence/Data/FactionSeeder.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Persistence.Data;

/// <summary>
/// Seeds the database with canonical factions of Aethelgard.
/// </summary>
/// <remarks>
/// v0.4.2e introduces 4 canonical factions:
/// - Iron-Banes: Scavenger clans of the upper ruins
/// - Dvergr: Deep-dwelling master smiths
/// - The Bound: Glitch cultists (default hostile)
/// - The Faceless: Mysterious masked traders
///
/// All descriptions must be Domain 4 compliant (no precision measurements).
///
/// See: v0.4.2a (The Repute) for Faction System design.
/// </remarks>
public static class FactionSeeder
{
    /// <summary>
    /// Seeds all factions if none exist.
    /// </summary>
    /// <param name="context">The database context.</param>
    /// <param name="logger">Optional logger for seeding operations.</param>
    public static async Task SeedAsync(RuneAndRustDbContext context, ILogger? logger = null)
    {
        if (await context.Factions.AnyAsync())
        {
            logger?.LogDebug("[Seeder] Factions already exist, skipping seed");
            return;
        }

        logger?.LogInformation("[Seeder] Seeding Factions...");

        var factions = GetFactions();

        await context.Factions.AddRangeAsync(factions);
        await context.SaveChangesAsync();

        logger?.LogInformation("[Seeder] Seeded {Count} factions", factions.Count);
    }

    /// <summary>
    /// Gets the canonical faction definitions.
    /// </summary>
    private static List<Faction> GetFactions()
    {
        return new List<Faction>
        {
            new Faction
            {
                Type = FactionType.IronBanes,
                Name = "The Iron-Banes",
                Description = "Scavenger clans who make their homes in the upper ruins. " +
                              "Pragmatic survivors who trade in salvage, information, and the occasional favor. " +
                              "They know the safe paths through the rubble and the dangers that lurk in the deep.",
                DefaultReputation = 0,
                IconName = "faction_ironbanes",
                ColorHex = "#8B4513"
            },
            new Faction
            {
                Type = FactionType.Dvergr,
                Name = "The Dvergr",
                Description = "Deep-dwelling master smiths and artificers who guard the secrets of Pre-Glitch forging. " +
                              "Secretive and suspicious of outsiders, they trade only with those who prove their worth. " +
                              "Their craftsmanship is unmatched, their prices steep.",
                DefaultReputation = 0,
                IconName = "faction_dvergr",
                ColorHex = "#4A4A4A"
            },
            new Faction
            {
                Type = FactionType.TheBound,
                Name = "The Bound",
                Description = "Cultists who worship the Glitch as divine transformation rather than corruption. " +
                              "They seek to spread its 'blessing' to all flesh, viewing resistance as heresy. " +
                              "Dangerous zealots who see your uncorrupted form as an insult to their god.",
                DefaultReputation = -25, // Start hostile
                IconName = "faction_bound",
                ColorHex = "#8B0000"
            },
            new Faction
            {
                Type = FactionType.TheFaceless,
                Name = "The Faceless",
                Description = "Mysterious masked traders whose true allegiances remain unknown. " +
                              "They deal in rare artifacts and forbidden knowledge, appearing when least expected. " +
                              "Their prices are strange—sometimes coin, sometimes favors, sometimes memories.",
                DefaultReputation = 0,
                IconName = "faction_faceless",
                ColorHex = "#2F4F4F"
            }
        };
    }
}
```

---

## 4. DialogueSeeder Implementation

**File:** `RuneAndRust.Persistence/Data/DialogueSeeder.cs`

```csharp
using System.Text.Json;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Conditions;
using RuneAndRust.Core.Effects;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Persistence.Data;

/// <summary>
/// Seeds the database with dialogue trees from JSON files or programmatic data.
/// </summary>
/// <remarks>
/// v0.4.2e migrates 8 existing NPC dialogue files to the new entity format.
/// Legacy JSON format is converted to DialogueTree/Node/Option entities.
///
/// All descriptions must be Domain 4 compliant.
///
/// See: v0.4.2b (The Lexicon) for Dialogue data model design.
/// </remarks>
public static class DialogueSeeder
{
    /// <summary>
    /// Seeds all dialogue trees if none exist.
    /// </summary>
    /// <param name="context">The database context.</param>
    /// <param name="logger">Optional logger for seeding operations.</param>
    public static async Task SeedAsync(RuneAndRustDbContext context, ILogger? logger = null)
    {
        if (await context.DialogueTrees.AnyAsync())
        {
            logger?.LogDebug("[Seeder] Dialogue trees already exist, skipping seed");
            return;
        }

        logger?.LogInformation("[Seeder] Seeding Dialogue Trees...");

        var trees = new List<DialogueTree>();
        var totalNodes = 0;

        // Try to load from JSON files first
        var dialoguesPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "data", "dialogues");
        if (Directory.Exists(dialoguesPath))
        {
            var jsonFiles = Directory.GetFiles(dialoguesPath, "*_dialogues.json");
            logger?.LogDebug("[Seeder] Found {Count} dialogue JSON files", jsonFiles.Length);

            foreach (var jsonFile in jsonFiles)
            {
                try
                {
                    var tree = await LoadDialogueTreeFromJsonAsync(jsonFile, logger);
                    if (tree != null)
                    {
                        trees.Add(tree);
                        totalNodes += tree.Nodes.Count;
                    }
                }
                catch (Exception ex)
                {
                    logger?.LogWarning(ex, "[Seeder] Failed to load dialogue from {File}", jsonFile);
                }
            }
        }

        // If no JSON files found, seed programmatic sample data
        if (trees.Count == 0)
        {
            logger?.LogInformation("[Seeder] No JSON files found, seeding sample dialogue trees");
            trees = GetSampleDialogueTrees();
            totalNodes = trees.Sum(t => t.Nodes.Count);
        }

        await context.DialogueTrees.AddRangeAsync(trees);
        await context.SaveChangesAsync();

        logger?.LogInformation("[Seeder] Seeded {TreeCount} dialogue trees with {NodeCount} total nodes",
            trees.Count, totalNodes);
    }

    /// <summary>
    /// Loads a dialogue tree from a legacy JSON file.
    /// </summary>
    private static async Task<DialogueTree?> LoadDialogueTreeFromJsonAsync(string filePath, ILogger? logger)
    {
        var fileName = Path.GetFileNameWithoutExtension(filePath);
        var npcName = fileName.Replace("_dialogues", "");
        var treeId = $"npc_{npcName}";

        logger?.LogDebug("[Seeder] Loading dialogue tree '{TreeId}' from {File}", treeId, fileName);

        var json = await File.ReadAllTextAsync(filePath);
        var legacyNodes = JsonSerializer.Deserialize<List<LegacyDialogueNode>>(json,
            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

        if (legacyNodes == null || legacyNodes.Count == 0)
        {
            logger?.LogWarning("[Seeder] Empty dialogue file: {File}", fileName);
            return null;
        }

        // Create the tree
        var tree = new DialogueTree
        {
            TreeId = treeId,
            NpcName = FormatNpcName(npcName),
            NpcTitle = GetNpcTitle(npcName),
            AssociatedFaction = GetNpcFaction(npcName),
            RootNodeId = legacyNodes[0].Id,
            Nodes = new List<DialogueNode>()
        };

        // Convert legacy nodes to new format
        foreach (var legacyNode in legacyNodes)
        {
            var node = new DialogueNode
            {
                TreeId = tree.Id,
                Tree = tree,
                NodeId = legacyNode.Id,
                SpeakerName = tree.NpcName,
                Text = legacyNode.Text,
                IsTerminal = legacyNode.EndsConversation || legacyNode.Options.All(o => o.NextNodeId == null),
                Options = new List<DialogueOption>()
            };

            var optionOrder = 0;
            foreach (var legacyOption in legacyNode.Options)
            {
                var option = new DialogueOption
                {
                    NodeId = node.Id,
                    Node = node,
                    Text = legacyOption.Text,
                    NextNodeId = legacyOption.NextNodeId,
                    DisplayOrder = optionOrder++,
                    Conditions = new List<DialogueCondition>(),
                    Effects = new List<DialogueEffect>()
                };

                // Convert legacy outcome to effects
                if (legacyOption.Outcome != null)
                {
                    var effect = ConvertLegacyOutcome(legacyOption.Outcome);
                    if (effect != null)
                    {
                        option.Effects.Add(effect);
                    }
                }

                node.Options.Add(option);
            }

            tree.Nodes.Add(node);
        }

        logger?.LogDebug("[Seeder] Loaded '{TreeId}' with {NodeCount} nodes", treeId, tree.Nodes.Count);
        return tree;
    }

    /// <summary>
    /// Converts a legacy outcome to a dialogue effect.
    /// </summary>
    private static DialogueEffect? ConvertLegacyOutcome(LegacyOutcome outcome)
    {
        return outcome.Type switch
        {
            "ReputationChange" when outcome.ReputationChange != 0 =>
                new ModifyReputationEffect
                {
                    Faction = ParseFaction(outcome.AffectedFaction),
                    Amount = outcome.ReputationChange
                },

            "QuestGiven" when !string.IsNullOrEmpty(outcome.Data) =>
                new StartQuestEffect
                {
                    QuestId = outcome.Data
                },

            "EndConversation" => null, // Handled by NextNodeId == null

            _ => null
        };
    }

    /// <summary>
    /// Gets sample dialogue trees for testing when JSON files unavailable.
    /// </summary>
    private static List<DialogueTree> GetSampleDialogueTrees()
    {
        var trees = new List<DialogueTree>();

        // Sample: Old Scavenger (Iron-Banes)
        var oldScavengerTree = new DialogueTree
        {
            TreeId = "npc_old_scavenger",
            NpcName = "Old Scavenger",
            NpcTitle = "Iron-Bane Elder",
            AssociatedFaction = FactionType.IronBanes,
            RootNodeId = "greeting",
            Nodes = new List<DialogueNode>()
        };

        var greetingNode = new DialogueNode
        {
            TreeId = oldScavengerTree.Id,
            Tree = oldScavengerTree,
            NodeId = "greeting",
            SpeakerName = "Old Scavenger",
            Text = "Hah! Another young fool stumbling through the ruins. You've got that look about you—" +
                   "fresh blood, burning curiosity, no sense of what lurks in the deeper halls. " +
                   "I've seen hundreds like you come and go. Mostly go.",
            IsTerminal = false,
            Options = new List<DialogueOption>()
        };

        greetingNode.Options.Add(new DialogueOption
        {
            NodeId = greetingNode.Id,
            Node = greetingNode,
            Text = "I seek knowledge of the old ways.",
            NextNodeId = "lore",
            DisplayOrder = 0,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>()
        });

        greetingNode.Options.Add(new DialogueOption
        {
            NodeId = greetingNode.Id,
            Node = greetingNode,
            Text = "What can you tell me about the dangers here?",
            NextNodeId = "dangers",
            DisplayOrder = 1,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>()
        });

        greetingNode.Options.Add(new DialogueOption
        {
            NodeId = greetingNode.Id,
            Node = greetingNode,
            Text = "[WITS 6] I notice the markings on your arm...",
            NextNodeId = "markings",
            DisplayOrder = 2,
            Conditions = new List<DialogueCondition>
            {
                new AttributeCondition
                {
                    Attribute = Core.Enums.Attribute.Wits,
                    MinValue = 6,
                    FailureVisibility = ConditionFailureVisibility.ShowLocked
                }
            },
            Effects = new List<DialogueEffect>(),
            LockHint = "WITS 6"
        });

        greetingNode.Options.Add(new DialogueOption
        {
            NodeId = greetingNode.Id,
            Node = greetingNode,
            Text = "I should go. Farewell.",
            NextNodeId = null, // Terminal
            DisplayOrder = 3,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>()
        });

        oldScavengerTree.Nodes.Add(greetingNode);

        // Lore node
        var loreNode = new DialogueNode
        {
            TreeId = oldScavengerTree.Id,
            Tree = oldScavengerTree,
            NodeId = "lore",
            SpeakerName = "Old Scavenger",
            Text = "The old ways? Heh. Most of what the Jötun-Forged knew died with them in the Glitch. " +
                   "But fragments remain—in the walls, in the machines that still twitch with half-life, " +
                   "in the whispers of those who delve too deep.",
            IsTerminal = false,
            Options = new List<DialogueOption>()
        };

        loreNode.Options.Add(new DialogueOption
        {
            NodeId = loreNode.Id,
            Node = loreNode,
            Text = "Fascinating. Thank you for sharing.",
            NextNodeId = null, // Terminal
            DisplayOrder = 0,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>
            {
                new ModifyReputationEffect
                {
                    Faction = FactionType.IronBanes,
                    Amount = 5
                }
            }
        });

        oldScavengerTree.Nodes.Add(loreNode);

        // Dangers node
        var dangersNode = new DialogueNode
        {
            TreeId = oldScavengerTree.Id,
            Tree = oldScavengerTree,
            NodeId = "dangers",
            SpeakerName = "Old Scavenger",
            Text = "Everything. Trust nothing that moves—and some things that don't. The Iron-Husks still patrol " +
                   "their ancient routes. The Blight-touched hunger for uncorrupted flesh. And the deeper you go, " +
                   "the stranger things become.",
            IsTerminal = false,
            Options = new List<DialogueOption>()
        };

        dangersNode.Options.Add(new DialogueOption
        {
            NodeId = dangersNode.Id,
            Node = dangersNode,
            Text = "I'll be careful. Thanks for the warning.",
            NextNodeId = null,
            DisplayOrder = 0,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>()
        });

        oldScavengerTree.Nodes.Add(dangersNode);

        // Markings node (WITS check reward)
        var markingsNode = new DialogueNode
        {
            TreeId = oldScavengerTree.Id,
            Tree = oldScavengerTree,
            NodeId = "markings",
            SpeakerName = "Old Scavenger",
            Text = "*The old man's eyes widen, then narrow with grudging respect.* Sharp eyes you've got. " +
                   "These marks? They're from my time in the Deep Forges. Most who bear them don't live to show them off. " +
                   "You've earned a bit of respect, stranger.",
            IsTerminal = false,
            Options = new List<DialogueOption>()
        };

        markingsNode.Options.Add(new DialogueOption
        {
            NodeId = markingsNode.Id,
            Node = markingsNode,
            Text = "I know valuable experience when I see it.",
            NextNodeId = null,
            DisplayOrder = 0,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>
            {
                new ModifyReputationEffect
                {
                    Faction = FactionType.IronBanes,
                    Amount = 10
                }
            }
        });

        oldScavengerTree.Nodes.Add(markingsNode);

        trees.Add(oldScavengerTree);

        // Add more sample trees as needed...
        trees.Add(CreateDvergrSmithTree());

        return trees;
    }

    /// <summary>
    /// Creates a sample Dvergr Smith dialogue tree.
    /// </summary>
    private static DialogueTree CreateDvergrSmithTree()
    {
        var tree = new DialogueTree
        {
            TreeId = "npc_dvergr_smith",
            NpcName = "Kjartan",
            NpcTitle = "Rust-Smith",
            AssociatedFaction = FactionType.Dvergr,
            RootNodeId = "greeting",
            Nodes = new List<DialogueNode>()
        };

        var greetingNode = new DialogueNode
        {
            TreeId = tree.Id,
            Tree = tree,
            NodeId = "greeting",
            SpeakerName = "Kjartan",
            Text = "*The smith doesn't look up from the forge.* Another surface-dweller. If you've come to gawk, " +
                   "the door's behind you. If you've come to trade, show me what you've got.",
            IsTerminal = false,
            Options = new List<DialogueOption>()
        };

        greetingNode.Options.Add(new DialogueOption
        {
            NodeId = greetingNode.Id,
            Node = greetingNode,
            Text = "I'm looking to have something crafted.",
            NextNodeId = "craft",
            DisplayOrder = 0,
            Conditions = new List<DialogueCondition>
            {
                new ReputationCondition
                {
                    Faction = FactionType.Dvergr,
                    MinDisposition = Disposition.Neutral,
                    FailureVisibility = ConditionFailureVisibility.ShowLocked
                }
            },
            Effects = new List<DialogueEffect>(),
            LockHint = "Neutral with Dvergr"
        });

        greetingNode.Options.Add(new DialogueOption
        {
            NodeId = greetingNode.Id,
            Node = greetingNode,
            Text = "I have salvage to trade.",
            NextNodeId = "trade",
            DisplayOrder = 1,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>()
        });

        greetingNode.Options.Add(new DialogueOption
        {
            NodeId = greetingNode.Id,
            Node = greetingNode,
            Text = "Just looking around.",
            NextNodeId = null,
            DisplayOrder = 2,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>
            {
                new ModifyReputationEffect
                {
                    Faction = FactionType.Dvergr,
                    Amount = -2
                }
            }
        });

        tree.Nodes.Add(greetingNode);

        // Add craft node
        var craftNode = new DialogueNode
        {
            TreeId = tree.Id,
            Tree = tree,
            NodeId = "craft",
            SpeakerName = "Kjartan",
            Text = "*He sets down his hammer.* Hmph. At least you've got manners. My work doesn't come cheap, " +
                   "and it doesn't come fast. But it lasts. What did you have in mind?",
            IsTerminal = false,
            Options = new List<DialogueOption>()
        };

        craftNode.Options.Add(new DialogueOption
        {
            NodeId = craftNode.Id,
            Node = craftNode,
            Text = "I'll think on it and return.",
            NextNodeId = null,
            DisplayOrder = 0,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>()
        });

        tree.Nodes.Add(craftNode);

        // Add trade node
        var tradeNode = new DialogueNode
        {
            TreeId = tree.Id,
            Tree = tree,
            NodeId = "trade",
            SpeakerName = "Kjartan",
            Text = "Let's see it then. I don't deal in junk—only materials worth my time.",
            IsTerminal = false,
            Options = new List<DialogueOption>()
        };

        tradeNode.Options.Add(new DialogueOption
        {
            NodeId = tradeNode.Id,
            Node = tradeNode,
            Text = "Another time, perhaps.",
            NextNodeId = null,
            DisplayOrder = 0,
            Conditions = new List<DialogueCondition>(),
            Effects = new List<DialogueEffect>()
        });

        tree.Nodes.Add(tradeNode);

        return tree;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Helper Methods
    // ═══════════════════════════════════════════════════════════════════════

    private static string FormatNpcName(string fileName)
    {
        // "astrid" -> "Astrid"
        return char.ToUpper(fileName[0]) + fileName[1..];
    }

    private static string? GetNpcTitle(string npcName)
    {
        return npcName.ToLower() switch
        {
            "astrid" => "Lore-Keeper",
            "bjorn" => "Scout-Captain",
            "eydis" => "Rune-Reader",
            "gunnar" => "Gate-Warden",
            "kjartan" => "Rust-Smith",
            "rolf" => "Shadow-Dealer",
            "sigrun" => "Voice of the Banes",
            "thorvald" => "Wanderer",
            _ => null
        };
    }

    private static FactionType? GetNpcFaction(string npcName)
    {
        return npcName.ToLower() switch
        {
            "bjorn" or "gunnar" or "sigrun" => FactionType.IronBanes,
            "eydis" or "kjartan" => FactionType.Dvergr,
            "rolf" => FactionType.TheFaceless,
            _ => null // Independent
        };
    }

    private static FactionType ParseFaction(string? factionName)
    {
        if (string.IsNullOrEmpty(factionName)) return FactionType.IronBanes;

        return factionName.ToLower() switch
        {
            "iron-banes" or "ironbanes" => FactionType.IronBanes,
            "dvergr" => FactionType.Dvergr,
            "the bound" or "bound" => FactionType.TheBound,
            "the faceless" or "faceless" => FactionType.TheFaceless,
            _ => FactionType.IronBanes
        };
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Legacy JSON Models (for deserialization only)
// ═══════════════════════════════════════════════════════════════════════════

internal class LegacyDialogueNode
{
    public string Id { get; set; } = string.Empty;
    public string Text { get; set; } = string.Empty;
    public List<LegacyDialogueOption> Options { get; set; } = new();
    public bool EndsConversation { get; set; }
}

internal class LegacyDialogueOption
{
    public string Text { get; set; } = string.Empty;
    public string? NextNodeId { get; set; }
    public LegacyOutcome? Outcome { get; set; }
}

internal class LegacyOutcome
{
    public string Type { get; set; } = string.Empty;
    public string Data { get; set; } = string.Empty;
    public int ReputationChange { get; set; }
    public string? AffectedFaction { get; set; }
}
```

---

## 5. NPC Entity Extension

**Modify:** `RuneAndRust.Core/Entities/Npc.cs`

If the Npc entity doesn't exist, create it:

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

/// <summary>
/// Represents a non-player character that can be interacted with.
/// </summary>
/// <remarks>See: v0.4.2e (The Archive) for NPC seeding and dialogue integration.</remarks>
public class Npc
{
    /// <summary>
    /// Unique identifier for this NPC instance.
    /// </summary>
    public Guid Id { get; set; } = Guid.NewGuid();

    /// <summary>
    /// Display name of the NPC.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Optional title (e.g., "Iron-Bane Elder", "Rust-Smith").
    /// </summary>
    public string? Title { get; set; }

    /// <summary>
    /// Description of the NPC's appearance and demeanor.
    /// Must be Domain 4 compliant.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// The dialogue tree ID for this NPC (v0.4.2e).
    /// References a DialogueTree.TreeId for conversation lookup.
    /// Null if NPC has no dialogue.
    /// </summary>
    public string? DialogueTreeId { get; set; }

    /// <summary>
    /// The faction this NPC belongs to, if any.
    /// </summary>
    public FactionType? Faction { get; set; }

    /// <summary>
    /// Whether this NPC is hostile by default.
    /// </summary>
    public bool IsHostile { get; set; }

    /// <summary>
    /// Whether this NPC can be talked to.
    /// </summary>
    public bool CanTalk => !string.IsNullOrEmpty(DialogueTreeId) && !IsHostile;

    /// <summary>
    /// The room this NPC is currently in.
    /// </summary>
    public Guid? RoomId { get; set; }

    /// <summary>
    /// Navigation property to the room.
    /// </summary>
    public Room? Room { get; set; }
}
```

**Modify:** `RuneAndRust.Core/Entities/Room.cs`

Add NPC collection if missing:

```csharp
// Add to Room entity:

/// <summary>
/// NPCs present in this room (v0.4.2e).
/// </summary>
public ICollection<Npc> Npcs { get; set; } = new List<Npc>();
```

---

## 6. NpcSeeder Implementation

**File:** `RuneAndRust.Persistence/Data/NpcSeeder.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Persistence.Data;

/// <summary>
/// Seeds the database with NPCs for dialogue testing and gameplay.
/// </summary>
/// <remarks>
/// v0.4.2e seeds NPCs that correspond to the dialogue trees.
/// NPCs are placed in starting/test rooms.
///
/// All descriptions must be Domain 4 compliant.
///
/// See: v0.4.2e (The Archive) for NPC seeding design.
/// </remarks>
public static class NpcSeeder
{
    /// <summary>
    /// Seeds all NPCs if none exist.
    /// </summary>
    /// <param name="context">The database context.</param>
    /// <param name="logger">Optional logger for seeding operations.</param>
    public static async Task SeedAsync(RuneAndRustDbContext context, ILogger? logger = null)
    {
        if (await context.Npcs.AnyAsync())
        {
            logger?.LogDebug("[Seeder] NPCs already exist, skipping seed");
            return;
        }

        logger?.LogInformation("[Seeder] Seeding NPCs...");

        var npcs = GetNpcs();

        await context.Npcs.AddRangeAsync(npcs);
        await context.SaveChangesAsync();

        logger?.LogInformation("[Seeder] Seeded {Count} NPCs", npcs.Count);
    }

    /// <summary>
    /// Gets the canonical NPC definitions.
    /// </summary>
    private static List<Npc> GetNpcs()
    {
        return new List<Npc>
        {
            // Iron-Banes NPCs
            new Npc
            {
                Name = "Old Scavenger",
                Title = "Iron-Bane Elder",
                Description = "A weathered figure in patched leathers, one eye clouded with age. " +
                              "Scars tell stories of survival, and a knowing smile hints at secrets " +
                              "gleaned from decades in the ruins.",
                DialogueTreeId = "npc_old_scavenger",
                Faction = FactionType.IronBanes,
                IsHostile = false
            },
            new Npc
            {
                Name = "Sigrun",
                Title = "Voice of the Banes",
                Description = "A tall woman with iron-grey hair and commanding presence. " +
                              "Her voice carries the authority of one who speaks for many, " +
                              "and her eyes miss nothing.",
                DialogueTreeId = "npc_sigrun",
                Faction = FactionType.IronBanes,
                IsHostile = false
            },
            new Npc
            {
                Name = "Bjorn",
                Title = "Scout-Captain",
                Description = "A lean, wiry man with quick eyes that scan constantly for threats. " +
                              "His fingers never stray far from the blade at his hip.",
                DialogueTreeId = "npc_bjorn",
                Faction = FactionType.IronBanes,
                IsHostile = false
            },
            new Npc
            {
                Name = "Gunnar",
                Title = "Gate-Warden",
                Description = "A massive figure in salvaged plate, standing like a statue by the gate. " +
                              "His silence speaks louder than words—few pass without his approval.",
                DialogueTreeId = "npc_gunnar",
                Faction = FactionType.IronBanes,
                IsHostile = false
            },

            // Dvergr NPCs
            new Npc
            {
                Name = "Kjartan",
                Title = "Rust-Smith",
                Description = "A stocky figure hunched over an ancient forge, face lit by orange glow. " +
                              "Soot-stained hands move with practiced precision, coaxing metal into shapes " +
                              "that surface-dwellers can barely imagine.",
                DialogueTreeId = "npc_dvergr_smith",
                Faction = FactionType.Dvergr,
                IsHostile = false
            },
            new Npc
            {
                Name = "Eydis",
                Title = "Rune-Reader",
                Description = "An ancient Dvergr whose fingers trace glowing symbols in the air. " +
                              "Her eyes have the distant look of one who sees things others cannot—" +
                              "patterns in the Glitch, whispers from the machines.",
                DialogueTreeId = "npc_eydis",
                Faction = FactionType.Dvergr,
                IsHostile = false
            },

            // Faceless NPCs
            new Npc
            {
                Name = "Rolf",
                Title = "Shadow-Dealer",
                Description = "A figure in a featureless mask, voice modulated to an unsettling monotone. " +
                              "Goods of impossible rarity appear from beneath a tattered cloak, " +
                              "and prices are never quite what you expect.",
                DialogueTreeId = "npc_rolf",
                Faction = FactionType.TheFaceless,
                IsHostile = false
            },

            // Independent NPCs
            new Npc
            {
                Name = "Astrid",
                Title = "Lore-Keeper",
                Description = "A scholar-wanderer with ink-stained fingers and a satchel bulging with scrolls. " +
                              "Her knowledge of Pre-Glitch history is encyclopedic, though she speaks of it " +
                              "with the reverence of religion.",
                DialogueTreeId = "npc_astrid",
                Faction = null, // Independent
                IsHostile = false
            },
            new Npc
            {
                Name = "Thorvald",
                Title = "Wanderer",
                Description = "A silent traveler with a thousand-yard stare. " +
                              "He's been places most wouldn't dare, and seen things best left unspoken. " +
                              "When he does speak, people listen.",
                DialogueTreeId = "npc_thorvald",
                Faction = null,
                IsHostile = false
            }
        };
    }
}
```

---

## 7. JSON Migration Strategy

### 7.1 Legacy JSON Format

The existing JSON files use this format:

```json
{
  "Id": "node_id_string",
  "Text": "Dialogue text...",
  "Options": [
    {
      "Text": "Option text",
      "NextNodeId": "next_node_id" | null,
      "Outcome": {
        "Type": "ReputationChange" | "QuestGiven" | "EndConversation",
        "Data": "quest_id or description",
        "ReputationChange": 5,
        "AffectedFaction": "Independents"
      }
    }
  ],
  "EndsConversation": false
}
```

### 7.2 New Entity Format

Converted to:

```csharp
DialogueTree
├── TreeId: "npc_astrid"
├── NpcName: "Astrid"
├── RootNodeId: "astrid_greeting"
└── Nodes[]
    └── DialogueNode
        ├── NodeId: "astrid_greeting"
        ├── Text: "Dialogue text..."
        └── Options[]
            └── DialogueOption
                ├── Text: "Option text"
                ├── NextNodeId: "next_node_id" | null
                └── Effects[]
                    └── ModifyReputationEffect
                        ├── Faction: FactionType.IronBanes
                        └── Amount: 5
```

### 7.3 Migration Mapping

| Legacy Field | New Field | Notes |
|--------------|-----------|-------|
| `Id` | `DialogueNode.NodeId` | String ID preserved |
| `Text` | `DialogueNode.Text` | Direct copy |
| `EndsConversation` | `DialogueNode.IsTerminal` | Or inferred from options |
| `Options[].Text` | `DialogueOption.Text` | Direct copy |
| `Options[].NextNodeId` | `DialogueOption.NextNodeId` | Null = terminal |
| `Outcome.Type=ReputationChange` | `ModifyReputationEffect` | Amount + Faction |
| `Outcome.Type=QuestGiven` | `StartQuestEffect` | QuestId from Data |
| `Outcome.Type=EndConversation` | N/A | Handled by NextNodeId=null |

---

## 8. Program.cs Integration

**Modify:** `RuneAndRust.Terminal/Program.cs`

Add seeder invocations after existing seeders:

```csharp
// 4. Seed data
using (var scope = host.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<RuneAndRustDbContext>();
    var templateLoader = scope.ServiceProvider.GetRequiredService<ITemplateLoaderService>();
    var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();

    // Existing seeders
    AbilitySeeder.SeedAsync(context).GetAwaiter().GetResult();
    ConditionSeeder.SeedAsync(context).GetAwaiter().GetResult();
    HazardTemplateSeeder.SeedAsync(context).GetAwaiter().GetResult();
    RoomTemplateSeeder.SeedAsync(context, templateLoader, logger).GetAwaiter().GetResult();
    SpecializationSeeder.SeedAsync(context, logger).GetAwaiter().GetResult();

    // v0.4.2e: Faction & Dialogue seeders
    FactionSeeder.SeedAsync(context, logger).GetAwaiter().GetResult();
    DialogueSeeder.SeedAsync(context, logger).GetAwaiter().GetResult();
    NpcSeeder.SeedAsync(context, logger).GetAwaiter().GetResult();
}
```

---

## 9. DbContext Updates

**Modify:** `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs`

Add DbSets and configuration:

```csharp
// Add DbSets (if not already present from v0.4.2a/b):
public DbSet<Faction> Factions { get; set; } = null!;
public DbSet<CharacterFactionStanding> CharacterFactionStandings { get; set; } = null!;
public DbSet<DialogueTree> DialogueTrees { get; set; } = null!;
public DbSet<DialogueNode> DialogueNodes { get; set; } = null!;
public DbSet<DialogueOption> DialogueOptions { get; set; } = null!;
public DbSet<Npc> Npcs { get; set; } = null!;

// In OnModelCreating, add Npc configuration:
modelBuilder.Entity<Npc>(entity =>
{
    entity.ToTable("npcs");
    entity.HasKey(e => e.Id);

    entity.Property(e => e.Name)
        .HasMaxLength(100)
        .IsRequired();

    entity.Property(e => e.Title)
        .HasMaxLength(100);

    entity.Property(e => e.Description)
        .HasMaxLength(1000)
        .IsRequired();

    entity.Property(e => e.DialogueTreeId)
        .HasMaxLength(100);

    entity.Property(e => e.Faction)
        .HasConversion<string>()
        .HasMaxLength(50);

    entity.HasOne(e => e.Room)
        .WithMany(r => r.Npcs)
        .HasForeignKey(e => e.RoomId)
        .OnDelete(DeleteBehavior.SetNull);

    entity.HasIndex(e => e.DialogueTreeId);
    entity.HasIndex(e => e.RoomId);
});
```

---

## 10. Logging Matrix

### FactionSeeder Logging

| Event | Level | Template |
|-------|-------|----------|
| Already seeded | Debug | `[Seeder] Factions already exist, skipping seed` |
| Seeding start | Info | `[Seeder] Seeding Factions...` |
| Seeding complete | Info | `[Seeder] Seeded {Count} factions` |

### DialogueSeeder Logging

| Event | Level | Template |
|-------|-------|----------|
| Already seeded | Debug | `[Seeder] Dialogue trees already exist, skipping seed` |
| Seeding start | Info | `[Seeder] Seeding Dialogue Trees...` |
| JSON files found | Debug | `[Seeder] Found {Count} dialogue JSON files` |
| Loading tree | Debug | `[Seeder] Loading dialogue tree '{TreeId}' from {File}` |
| Empty file | Warn | `[Seeder] Empty dialogue file: {File}` |
| Load failed | Warn | `[Seeder] Failed to load dialogue from {File}` |
| Tree loaded | Debug | `[Seeder] Loaded '{TreeId}' with {NodeCount} nodes` |
| No JSON fallback | Info | `[Seeder] No JSON files found, seeding sample dialogue trees` |
| Seeding complete | Info | `[Seeder] Seeded {TreeCount} dialogue trees with {NodeCount} total nodes` |

### NpcSeeder Logging

| Event | Level | Template |
|-------|-------|----------|
| Already seeded | Debug | `[Seeder] NPCs already exist, skipping seed` |
| Seeding start | Info | `[Seeder] Seeding NPCs...` |
| Seeding complete | Info | `[Seeder] Seeded {Count} NPCs` |

---

## 11. Test Coverage Plan

### Test Class Structure

**File:** `RuneAndRust.Tests/Integration/DialogueIntegrationTests.cs` (12 tests)

### Test Inventory (12 integration tests)

#### End-to-End Dialogue Tests (5 tests)

| Test Name | Description |
|-----------|-------------|
| `DialogueFlow_StartToFinish_CompletesSuccessfully` | Full dialogue traversal |
| `DialogueFlow_WithReputationEffect_ModifiesStanding` | Effect execution |
| `DialogueFlow_WithAttributeCheck_ShowsLockedOption` | Condition evaluation |
| `DialogueFlow_CancelMidway_EndsGracefully` | Cancel handling |
| `DialogueFlow_SelectTerminalOption_EndsDialogue` | Terminal option |

#### Seeder Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `FactionSeeder_SeedsAllFactions` | 4 factions created |
| `DialogueSeeder_SeedsDialogueTrees` | Trees with nodes |
| `NpcSeeder_SeedsNpcsWithDialogueRefs` | NPCs linked |
| `Seeders_AreIdempotent_WhenRunTwice` | No duplicates |

#### Repository Integration Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `DialogueRepository_GetTreeById_ReturnsFullTree` | Eager loading |
| `FactionRepository_GetByType_ReturnsFaction` | Query works |
| `NpcRepository_GetByRoom_ReturnsNpcsInRoom` | Room filtering |

---

## 12. Code Examples

### 12.1 Integration Test Example

```csharp
public class DialogueIntegrationTests : IAsyncLifetime
{
    private RuneAndRustDbContext _context = null!;
    private IDialogueService _dialogueService = null!;
    private IFactionService _factionService = null!;
    private GameState _gameState = null!;

    public async Task InitializeAsync()
    {
        // Setup InMemory database
        var options = new DbContextOptionsBuilder<RuneAndRustDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;

        _context = new RuneAndRustDbContext(options);

        // Seed required data
        await FactionSeeder.SeedAsync(_context);
        await DialogueSeeder.SeedAsync(_context);
        await NpcSeeder.SeedAsync(_context);

        // Create services with real repositories
        var factionRepo = new FactionRepository(_context, Mock.Of<ILogger<FactionRepository>>());
        var dialogueRepo = new DialogueRepository(_context, Mock.Of<ILogger<DialogueRepository>>());

        _gameState = new GameState();
        var eventBus = new EventBus(Mock.Of<ILogger<EventBus>>());

        _factionService = new FactionService(
            factionRepo,
            eventBus,
            Mock.Of<ILogger<FactionService>>());

        var conditionEvaluator = new DialogueConditionEvaluator(
            _factionService,
            _gameState,
            Mock.Of<ILogger<DialogueConditionEvaluator>>());

        var effectExecutor = new DialogueEffectExecutor(
            _factionService,
            Mock.Of<IInventoryService>(),
            _gameState,
            eventBus,
            Mock.Of<ILogger<DialogueEffectExecutor>>());

        _dialogueService = new DialogueService(
            dialogueRepo,
            conditionEvaluator,
            effectExecutor,
            _factionService,
            eventBus,
            _gameState,
            Mock.Of<ILogger<DialogueService>>());
    }

    public Task DisposeAsync()
    {
        _context.Dispose();
        return Task.CompletedTask;
    }

    [Fact]
    public async Task DialogueFlow_StartToFinish_CompletesSuccessfully()
    {
        // Arrange
        var character = new Character
        {
            Id = Guid.NewGuid(),
            Name = "Test Character",
            Wits = 5
        };
        _gameState.CurrentCharacter = character;

        // Act - Start dialogue
        var startResult = await _dialogueService.StartDialogueAsync(character, "npc_old_scavenger");

        // Assert - Dialogue started
        startResult.IsSuccess.Should().BeTrue();
        startResult.ViewModel.Should().NotBeNull();
        startResult.ViewModel!.NpcName.Should().Be("Old Scavenger");
        startResult.ViewModel.Options.Should().HaveCountGreaterThan(0);

        // Act - Select first option
        var firstOption = startResult.ViewModel.Options.First(o => o.IsAvailable);
        var stepResult = await _dialogueService.SelectOptionAsync(firstOption.OptionId);

        // Assert - Navigation worked
        stepResult.IsSuccess.Should().BeTrue();

        // Act - Select terminal option to end
        if (!stepResult.IsDialogueComplete)
        {
            var terminalOption = stepResult.ViewModel!.Options.First(o => o.IsTerminal);
            var endStepResult = await _dialogueService.SelectOptionAsync(terminalOption.OptionId);
            endStepResult.IsDialogueComplete.Should().BeTrue();
        }

        // Assert - Dialogue ended
        _dialogueService.IsInDialogue.Should().BeFalse();
    }

    [Fact]
    public async Task DialogueFlow_WithReputationEffect_ModifiesStanding()
    {
        // Arrange
        var character = new Character
        {
            Id = Guid.NewGuid(),
            Name = "Test Character"
        };
        _gameState.CurrentCharacter = character;

        // Get initial reputation
        var initialStanding = await _factionService.GetFactionStandingAsync(character, FactionType.IronBanes);
        var initialRep = initialStanding.Reputation;

        // Act - Start dialogue and select option with reputation effect
        var startResult = await _dialogueService.StartDialogueAsync(character, "npc_old_scavenger");
        startResult.IsSuccess.Should().BeTrue();

        // Navigate to lore node and select option with +5 reputation
        var loreOption = startResult.ViewModel!.Options.First(o => o.Text.Contains("knowledge"));
        var loreResult = await _dialogueService.SelectOptionAsync(loreOption.OptionId);

        // Select the "Fascinating" option which gives +5 Iron-Banes reputation
        if (!loreResult.IsDialogueComplete && loreResult.ViewModel != null)
        {
            var repOption = loreResult.ViewModel.Options.FirstOrDefault(o => o.Text.Contains("Fascinating"));
            if (repOption != null)
            {
                await _dialogueService.SelectOptionAsync(repOption.OptionId);
            }
        }

        // Assert - Reputation changed
        var finalStanding = await _factionService.GetFactionStandingAsync(character, FactionType.IronBanes);
        finalStanding.Reputation.Should().BeGreaterThan(initialRep);
    }

    [Fact]
    public async Task DialogueFlow_WithAttributeCheck_ShowsLockedOption()
    {
        // Arrange - Character with low WITS (below requirement)
        var character = new Character
        {
            Id = Guid.NewGuid(),
            Name = "Test Character",
            Wits = 4 // Below the WITS 6 requirement
        };
        _gameState.CurrentCharacter = character;

        // Act
        var startResult = await _dialogueService.StartDialogueAsync(character, "npc_old_scavenger");

        // Assert - Locked option is visible but not available
        var lockedOption = startResult.ViewModel!.Options.FirstOrDefault(o => o.LockHint == "WITS 6");
        lockedOption.Should().NotBeNull();
        lockedOption!.IsVisible.Should().BeTrue();
        lockedOption.IsAvailable.Should().BeFalse();
    }

    [Fact]
    public async Task Seeders_AreIdempotent_WhenRunTwice()
    {
        // Arrange - Already seeded in InitializeAsync

        // Act - Run seeders again
        await FactionSeeder.SeedAsync(_context);
        await DialogueSeeder.SeedAsync(_context);
        await NpcSeeder.SeedAsync(_context);

        // Assert - No duplicates
        var factionCount = await _context.Factions.CountAsync();
        factionCount.Should().Be(4); // Still only 4 factions

        var treeCount = await _context.DialogueTrees.CountAsync();
        treeCount.Should().BeGreaterThan(0);
        // Should be same count as before, not doubled
    }
}
```

---

## 13. Seed Data Reference

### 13.1 Faction Reference

| FactionType | Name | Default Rep | Color |
|-------------|------|-------------|-------|
| IronBanes | The Iron-Banes | 0 (Neutral) | #8B4513 |
| Dvergr | The Dvergr | 0 (Neutral) | #4A4A4A |
| TheBound | The Bound | -25 (Hostile) | #8B0000 |
| TheFaceless | The Faceless | 0 (Neutral) | #2F4F4F |

### 13.2 NPC Reference

| NPC Name | Title | Faction | Dialogue Tree |
|----------|-------|---------|---------------|
| Old Scavenger | Iron-Bane Elder | IronBanes | npc_old_scavenger |
| Sigrun | Voice of the Banes | IronBanes | npc_sigrun |
| Bjorn | Scout-Captain | IronBanes | npc_bjorn |
| Gunnar | Gate-Warden | IronBanes | npc_gunnar |
| Kjartan | Rust-Smith | Dvergr | npc_dvergr_smith |
| Eydis | Rune-Reader | Dvergr | npc_eydis |
| Rolf | Shadow-Dealer | TheFaceless | npc_rolf |
| Astrid | Lore-Keeper | Independent | npc_astrid |
| Thorvald | Wanderer | Independent | npc_thorvald |

### 13.3 Dialogue Tree Metrics

| Tree ID | NPC | Root Node | ~Nodes | Has Conditions | Has Effects |
|---------|-----|-----------|--------|----------------|-------------|
| npc_old_scavenger | Old Scavenger | greeting | 4 | Yes (WITS 6) | Yes (+5, +10 Iron-Banes) |
| npc_dvergr_smith | Kjartan | greeting | 3 | Yes (Reputation) | Yes (-2 Dvergr) |
| npc_astrid | Astrid | astrid_greeting | 5 | No | Yes (+3, +5 reputation) |

---

## 14. Changelog Template

```markdown
# Changelog: v0.4.2e - The Archive (Seeding & Integration)

**Release Date:** [DATE]
**Total Tests:** [N] (12 new integration tests added)

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Seed Data Reference](#seed-data-reference)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.2e](#directory-structure-after-v042e)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [v0.4.2 Complete](#v042-complete)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

Version 0.4.2e completes the Faction & Dialogue system by populating the database
with canonical content. This release seeds the 4 core factions, converts existing
dialogue JSON files to entities, and provides integration tests for the full system...

## v0.4.2 Complete

With v0.4.2e, the complete Faction & Dialogue system is now available:

| Sub-Version | Codename | Status | Tests |
|-------------|----------|--------|-------|
| v0.4.2a | The Repute | Complete | 42 |
| v0.4.2b | The Lexicon | Complete | 48 |
| v0.4.2c | The Voice | Complete | 45 |
| v0.4.2d | The Parley | Complete | 35 |
| v0.4.2e | The Archive | Complete | 12 |
| **Total** | **The Society** | **Complete** | **182** |

[Continue following CHANGELOG_GENERATION_RULES.md format]
```

---

## 15. Critical Files

### Files to Create (Priority Order)

| Priority | File | Purpose |
|----------|------|---------|
| 1 | `RuneAndRust.Persistence/Data/FactionSeeder.cs` | Faction seeding |
| 2 | `RuneAndRust.Persistence/Data/DialogueSeeder.cs` | Dialogue seeding |
| 3 | `RuneAndRust.Core/Entities/Npc.cs` | NPC entity (if missing) |
| 4 | `RuneAndRust.Persistence/Data/NpcSeeder.cs` | NPC seeding |
| 5 | `RuneAndRust.Tests/Integration/DialogueIntegrationTests.cs` | 12 tests |

### Files to Modify (Priority Order)

| Priority | File | Change |
|----------|------|--------|
| 1 | `RuneAndRust.Core/Entities/Room.cs` | Add Npcs collection |
| 2 | `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Add Npc DbSet, configure |
| 3 | `RuneAndRust.Terminal/Program.cs` | Add seeder invocations |

---

## 16. Implementation Order

1. **Create Npc Entity** (Core) - if not already present
2. **Update Room Entity** (Core) - add Npcs collection
3. **Update DbContext** (Persistence) - add DbSet, configure Npc
4. **Create FactionSeeder** (Persistence)
5. **Create DialogueSeeder** (Persistence)
6. **Create NpcSeeder** (Persistence)
7. **Update Program.cs** (Terminal) - add seeder calls
8. **Create EF Migration** (if using migrations)
9. **Write Integration Tests** (Tests)
10. **Run Build and Tests**
11. **Generate Changelog**

---

## 17. Design Decisions

### Why Programmatic + JSON Hybrid Seeding?

**Problem:** JSON dialogue files exist but may not be present in all environments.

**Decision:** Try JSON first, fall back to programmatic sample data.

**Rationale:**
- Respects existing content investment
- Works in test environments without file access
- Provides guaranteed seed data for demos
- Maintains backward compatibility

### Why String DialogueTreeId Instead of Foreign Key?

**Problem:** Dialogue trees are seeded separately and may not exist when NPCs are created.

**Decision:** Use string `DialogueTreeId` matching `DialogueTree.TreeId`.

**Rationale:**
- Decouples seeding order
- Allows NPCs to reference trees that don't exist yet (soft reference)
- Matches the "talk <npc>" → resolve tree pattern
- Simpler migration from legacy JSON system

### Why Separate NpcSeeder from DialogueSeeder?

**Problem:** NPCs and dialogues are logically related but structurally independent.

**Decision:** Separate seeders with explicit order in Program.cs.

**Rationale:**
- Single Responsibility Principle
- NPCs might exist without dialogue (hostile NPCs)
- Dialogue trees might be used by multiple NPCs
- Easier to test and maintain independently

### Why Integration Tests Instead of More Unit Tests?

**Problem:** The dialogue system involves many components working together.

**Decision:** Focus v0.4.2e tests on integration rather than isolated units.

**Rationale:**
- Unit tests covered in v0.4.2a-d
- Integration tests catch wiring issues
- Validates the complete seeding → service → effect flow
- More valuable for a "completion" release

---

## 18. Domain 4 Compliance

All seeded content must follow Domain 4 constraints:

### Faction Descriptions

- **Allowed:** "Scavenger clans", "master smiths", "worship the Glitch", "mysterious traders"
- **Forbidden:** "90% survival rate", "forge at 1200°C", "trade within 50 meters"

### NPC Descriptions

- **Allowed:** "weathered figure", "commanding presence", "face lit by orange glow"
- **Forbidden:** "2 meters tall", "60 years old", "speaks at 120 words per minute"

### Dialogue Text

- **Allowed:** "I've seen hundreds like you", "the deeper you go", "when least expected"
- **Forbidden:** "I've seen 347 adventurers", "50 meters deep", "appears every 6 hours"

### Effect Values

- **Allowed:** Reputation changes expressed as game mechanics (not in-world measurements)
- The +5, +10, -2 values are game abstractions, not Domain 4 violations

---

## Appendix A: Complete v0.4.2 Test Summary

| Version | Test File | Test Count |
|---------|-----------|------------|
| v0.4.2a | FactionServiceTests.cs | 42 |
| v0.4.2b | DialogueConditionEvaluatorTests.cs | 48 |
| v0.4.2c | DialogueServiceTests.cs | 30 |
| v0.4.2c | DialogueEffectExecutorTests.cs | 15 |
| v0.4.2d | DialogueControllerTests.cs | 20 |
| v0.4.2d | DialogueScreenRendererTests.cs | 15 |
| v0.4.2e | DialogueIntegrationTests.cs | 12 |
| **Total** | | **182** |

---

## Appendix B: Seeder Execution Order

```
Program.cs Startup
        │
        ▼
1. AbilitySeeder          (Player & Enemy abilities)
2. ConditionSeeder        (Ambient conditions)
3. HazardTemplateSeeder   (Environmental hazards)
4. RoomTemplateSeeder     (Room templates from JSON)
5. SpecializationSeeder   (Berserkr, Skald trees)
        │
        ▼ [NEW - v0.4.2e]
6. FactionSeeder          (4 canonical factions)
7. DialogueSeeder         (Dialogue trees from JSON/programmatic)
8. NpcSeeder              (NPCs with dialogue references)
```

---

## Appendix C: JSON File to Tree Mapping

| JSON File | Tree ID | NPC Name |
|-----------|---------|----------|
| astrid_dialogues.json | npc_astrid | Astrid |
| bjorn_dialogues.json | npc_bjorn | Bjorn |
| eydis_dialogues.json | npc_eydis | Eydis |
| gunnar_dialogues.json | npc_gunnar | Gunnar |
| kjartan_dialogues.json | npc_kjartan | Kjartan |
| rolf_dialogues.json | npc_rolf | Rolf |
| sigrun_dialogues.json | npc_sigrun | Sigrun |
| thorvald_dialogues.json | npc_thorvald | Thorvald |
