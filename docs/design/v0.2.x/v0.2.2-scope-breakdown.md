# v0.2.2 Merchant System - Scope Breakdown

**Version:** 0.2.2
**Theme:** Merchant System
**Prerequisites:** v0.2.1 Complete (Codex & Lore Discovery)
**Total Estimated Tests:** ~85 new tests

---

## Executive Summary

The Merchant System version introduces a complete economy and trading system to the dungeon. Players can buy and sell items with gold, negotiate prices through haggling, and interact with specialty merchants offering unique inventories. Dynamic pricing based on charisma, reputation, and merchant disposition creates meaningful economic decisions, while the shop UI provides clear item comparison for informed purchasing.

Key focus areas:
- **Shop System**: Core buy/sell mechanics with gold currency
- **Dynamic Pricing**: Prices influenced by charisma, reputation, and haggling
- **Merchant Types**: Specialty shops with themed inventories
- **Shop UI**: TUI interface with item comparison and appraisal
- **Inventory Management**: Limited merchant stock with refresh mechanics

The work is divided into **three sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.2.2a | Shop Foundation | Merchant entity, buy/sell commands, basic pricing | ~30 |
| v0.2.2b | Dynamic Pricing & Haggling | Price modifiers, charisma, haggle command | ~30 |
| v0.2.2c | Shop UI & Specialty Merchants | TUI interface, merchant types, inventory refresh | ~25 |

---

## Existing Infrastructure

### Already Implemented (from v0.2.0 and v0.2.1)

| Feature | Location | Notes |
|---------|----------|-------|
| NPC entity | `Domain/Entities/NPC.cs` | Base for Merchant |
| NPCType enum | `Domain/Enums/NPCType.cs` | Includes Merchant type |
| NPCAttitude | `Domain/Enums/NPCAttitude.cs` | Affects pricing |
| FactionDefinition | `Domain/Definitions/FactionDefinition.cs` | Reputation source |
| ReputationLevel | `Domain/Enums/ReputationLevel.cs` | Price modifiers |
| Player entity | `Domain/Entities/Player.cs` | Gold, reputation |
| Item entity | `Domain/Entities/Item.cs` | Trade goods |
| Inventory entity | `Domain/Entities/Inventory.cs` | Player items |
| DicePool | `Domain/ValueObjects/DicePool.cs` | Haggling rolls |
| SkillCheckResult | `Domain/ValueObjects/SkillCheckResult.cs` | Haggle outcomes |
| DialogueService | `Application/Services/DialogueService.cs` | Merchant dialogue |
| CodexEntry | `Domain/Entities/CodexEntry.cs` | Item lore affects value |

### Needs Implementation (v0.2.2)

| Feature | Phase | Notes |
|---------|-------|-------|
| Merchant entity | v0.2.2a | Extends NPC with shop features |
| ShopInventory | v0.2.2a | Merchant stock management |
| PriceCalculation | v0.2.2a | Base pricing logic |
| HaggleService | v0.2.2b | Negotiation mechanics |
| PriceModifier | v0.2.2b | Dynamic price adjustments |
| MerchantType enum | v0.2.2c | Specialty categories |
| ShopView | v0.2.2c | TUI shopping interface |

---

## Feature Analysis & Categorization

### Shop Foundation Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| Merchant entity | High | NPC | **v0.2.2a** |
| ShopInventory value object | Medium | Item | **v0.2.2a** |
| `buy <item>` command | Medium | Merchant, Player | **v0.2.2a** |
| `sell <item>` command | Medium | Merchant, Player | **v0.2.2a** |
| BasePrice on Item | Low | Item | **v0.2.2a** |
| Basic price calculation | Medium | ShopInventory | **v0.2.2a** |
| Gold transaction handling | Medium | Player | **v0.2.2a** |

### Dynamic Pricing Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| PriceModifier value object | Medium | None | **v0.2.2b** |
| Charisma stat on Player | Low | Player | **v0.2.2b** |
| Reputation price effects | Medium | FactionDefinition | **v0.2.2b** |
| Attitude price effects | Medium | NPCAttitude | **v0.2.2b** |
| `haggle` command | High | DicePool | **v0.2.2b** |
| HaggleService | High | PriceModifier | **v0.2.2b** |
| Haggle cooldown/limits | Medium | HaggleService | **v0.2.2b** |

### Shop UI & Merchant Type Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| MerchantType enum | Low | None | **v0.2.2c** |
| Specialty inventories | Medium | MerchantType | **v0.2.2c** |
| Inventory refresh logic | Medium | ShopInventory | **v0.2.2c** |
| `shop` command (TUI) | High | IGameRenderer | **v0.2.2c** |
| Item comparison display | Medium | ShopView | **v0.2.2c** |
| `appraise <item>` command | Medium | Item | **v0.2.2c** |
| Shop inventory display | Medium | ShopView | **v0.2.2c** |

---

## Phase Definitions

---

## v0.2.2a: Shop Foundation

### Overview

Establish the core merchant system including the merchant entity, shop inventory, and basic buy/sell commands. This phase enables players to purchase items from merchants and sell items from their inventory using gold.

### Scope

**In Scope:**
- `Merchant` entity extending NPC with shop capabilities
- `ShopInventory` value object for stock management
- `ShopItem` value object for priced inventory entries
- `buy <item>` command to purchase from merchant
- `sell <item>` command to sell to merchant
- `BasePrice` and `SellMultiplier` on Item entity
- Basic price calculation (base price only)
- Gold transaction handling
- Merchant inventory display in `talk` command

**Out of Scope:**
- Dynamic pricing modifiers (v0.2.2b)
- Haggling (v0.2.2b)
- Charisma stat (v0.2.2b)
- Specialty merchant types (v0.2.2c)
- Shop UI interface (v0.2.2c)
- Inventory refresh (v0.2.2c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `Merchant` |
| Value Objects | 2 | `ShopInventory`, `ShopItem` |
| Enums | 1 | `TransactionType` |
| Services | 1 | `ShopService` |
| Commands | 2 | `buy`, `sell` |
| Item Updates | 1 | Add pricing properties |
| Configuration | 1 | `merchants.json` |
| Unit Tests | ~30 | Entity, service, transaction tests |

### Merchant Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a merchant NPC that buys and sells items.
/// </summary>
public class Merchant : NPC
{
    /// <summary>
    /// Gets the merchant's inventory of items for sale.
    /// </summary>
    public ShopInventory Inventory { get; private set; } = ShopInventory.Empty;

    /// <summary>
    /// Gets the merchant's gold reserves for buying items.
    /// </summary>
    public int Gold { get; private set; }

    /// <summary>
    /// Gets the buy price multiplier (how much merchant charges).
    /// </summary>
    public decimal BuyMultiplier { get; private set; } = 1.0m;

    /// <summary>
    /// Gets the sell price multiplier (how much merchant pays).
    /// </summary>
    public decimal SellMultiplier { get; private set; } = 0.5m;

    /// <summary>
    /// Gets the faction this merchant belongs to for reputation pricing.
    /// </summary>
    public string? FactionId { get; private set; }

    /// <summary>
    /// Gets whether the merchant is currently open for business.
    /// </summary>
    public bool IsOpen { get; private set; } = true;

    /// <summary>
    /// Gets the last time inventory was refreshed.
    /// </summary>
    public DateTime? LastRefresh { get; private set; }

    /// <summary>
    /// Gets the number of successful transactions with this merchant.
    /// </summary>
    public int TransactionCount { get; private set; }

    private Merchant() : base() { /* EF Core */ }

    /// <summary>
    /// Creates a merchant from a definition.
    /// </summary>
    public static Merchant CreateMerchant(
        MerchantDefinition definition,
        Guid? roomId = null)
    {
        ArgumentNullException.ThrowIfNull(definition);

        var merchant = new Merchant
        {
            Gold = definition.StartingGold,
            BuyMultiplier = definition.BuyMultiplier,
            SellMultiplier = definition.SellMultiplier,
            FactionId = definition.FactionId,
            Inventory = ShopInventory.Create(definition.InitialStock),
            IsOpen = true,
            LastRefresh = DateTime.UtcNow
        };

        // Initialize base NPC properties
        merchant.InitializeFromDefinition(definition, roomId);

        return merchant;
    }

    /// <summary>
    /// Calculates the buy price for an item (what player pays).
    /// </summary>
    public int GetBuyPrice(Item item)
    {
        if (item.BasePrice <= 0) return 0;
        return (int)Math.Ceiling(item.BasePrice * BuyMultiplier);
    }

    /// <summary>
    /// Calculates the sell price for an item (what merchant pays player).
    /// </summary>
    public int GetSellPrice(Item item)
    {
        if (item.BasePrice <= 0) return 0;
        return (int)Math.Floor(item.BasePrice * SellMultiplier);
    }

    /// <summary>
    /// Attempts to sell an item to a player.
    /// </summary>
    public TransactionResult SellToPlayer(ShopItem shopItem, Player player)
    {
        if (!IsOpen)
            return TransactionResult.Failure("The shop is closed.");

        if (!Inventory.Contains(shopItem.ItemId))
            return TransactionResult.Failure("Item not in stock.");

        var price = GetBuyPrice(shopItem.Item);

        if (player.Gold < price)
            return TransactionResult.Failure($"Not enough gold. You need {price} gold.");

        // Process transaction
        player.SpendGold(price);
        Gold += price;
        Inventory = Inventory.RemoveItem(shopItem.ItemId);
        TransactionCount++;

        return TransactionResult.Success(
            TransactionType.PlayerBuy,
            shopItem.Item,
            price);
    }

    /// <summary>
    /// Attempts to buy an item from a player.
    /// </summary>
    public TransactionResult BuyFromPlayer(Item item, Player player)
    {
        if (!IsOpen)
            return TransactionResult.Failure("The shop is closed.");

        var price = GetSellPrice(item);

        if (price <= 0)
            return TransactionResult.Failure("The merchant isn't interested in that item.");

        if (Gold < price)
            return TransactionResult.Failure("The merchant doesn't have enough gold.");

        // Process transaction
        player.AddGold(price);
        Gold -= price;
        TransactionCount++;

        return TransactionResult.Success(
            TransactionType.PlayerSell,
            item,
            price);
    }

    /// <summary>
    /// Adds an item to the merchant's inventory.
    /// </summary>
    public void AddToInventory(Item item, int quantity = 1)
    {
        Inventory = Inventory.AddItem(item, quantity);
    }

    /// <summary>
    /// Sets the shop's open/closed status.
    /// </summary>
    public void SetOpen(bool isOpen)
    {
        IsOpen = isOpen;
    }

    /// <summary>
    /// Adds gold to merchant's reserves.
    /// </summary>
    public void AddGold(int amount)
    {
        if (amount > 0)
            Gold += amount;
    }
}
```

### ShopInventory Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a merchant's inventory of items for sale.
/// </summary>
public class ShopInventory
{
    /// <summary>
    /// Gets the items available for purchase.
    /// </summary>
    public IReadOnlyList<ShopItem> Items { get; private set; } = Array.Empty<ShopItem>();

    /// <summary>
    /// Gets an empty inventory.
    /// </summary>
    public static ShopInventory Empty => new() { Items = Array.Empty<ShopItem>() };

    private ShopInventory() { }

    /// <summary>
    /// Creates an inventory from a list of items.
    /// </summary>
    public static ShopInventory Create(IEnumerable<ShopItem> items)
    {
        return new ShopInventory
        {
            Items = items.ToList()
        };
    }

    /// <summary>
    /// Checks if the inventory contains an item.
    /// </summary>
    public bool Contains(string itemId)
    {
        return Items.Any(i => i.ItemId == itemId && i.Quantity > 0);
    }

    /// <summary>
    /// Gets an item by ID.
    /// </summary>
    public ShopItem? GetItem(string itemId)
    {
        return Items.FirstOrDefault(i => i.ItemId == itemId);
    }

    /// <summary>
    /// Adds an item to the inventory.
    /// </summary>
    public ShopInventory AddItem(Item item, int quantity = 1)
    {
        var items = Items.ToList();
        var existing = items.FirstOrDefault(i => i.ItemId == item.Id.ToString());

        if (existing != null)
        {
            var index = items.IndexOf(existing);
            items[index] = existing with { Quantity = existing.Quantity + quantity };
        }
        else
        {
            items.Add(new ShopItem
            {
                ItemId = item.Id.ToString(),
                Item = item,
                Quantity = quantity
            });
        }

        return new ShopInventory { Items = items };
    }

    /// <summary>
    /// Removes an item from the inventory.
    /// </summary>
    public ShopInventory RemoveItem(string itemId, int quantity = 1)
    {
        var items = Items.ToList();
        var existing = items.FirstOrDefault(i => i.ItemId == itemId);

        if (existing == null) return this;

        var newQuantity = existing.Quantity - quantity;
        if (newQuantity <= 0)
        {
            items.Remove(existing);
        }
        else
        {
            var index = items.IndexOf(existing);
            items[index] = existing with { Quantity = newQuantity };
        }

        return new ShopInventory { Items = items };
    }

    /// <summary>
    /// Gets the total number of unique items.
    /// </summary>
    public int UniqueItemCount => Items.Count;

    /// <summary>
    /// Gets the total quantity of all items.
    /// </summary>
    public int TotalQuantity => Items.Sum(i => i.Quantity);
}
```

### ShopItem Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents an item in a merchant's inventory.
/// </summary>
public readonly record struct ShopItem
{
    /// <summary>
    /// Gets the item's unique identifier.
    /// </summary>
    public string ItemId { get; init; }

    /// <summary>
    /// Gets the item reference.
    /// </summary>
    public Item Item { get; init; }

    /// <summary>
    /// Gets the quantity in stock.
    /// </summary>
    public int Quantity { get; init; }

    /// <summary>
    /// Gets whether this is unlimited stock.
    /// </summary>
    public bool IsUnlimited { get; init; }
}
```

### TransactionResult Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of a buy/sell transaction.
/// </summary>
public readonly record struct TransactionResult
{
    /// <summary>
    /// Gets whether the transaction succeeded.
    /// </summary>
    public bool IsSuccess { get; init; }

    /// <summary>
    /// Gets the transaction type.
    /// </summary>
    public TransactionType Type { get; init; }

    /// <summary>
    /// Gets the item involved.
    /// </summary>
    public Item? Item { get; init; }

    /// <summary>
    /// Gets the final price.
    /// </summary>
    public int Price { get; init; }

    /// <summary>
    /// Gets the error message if failed.
    /// </summary>
    public string? ErrorMessage { get; init; }

    /// <summary>
    /// Creates a successful transaction result.
    /// </summary>
    public static TransactionResult Success(TransactionType type, Item item, int price)
    {
        return new TransactionResult
        {
            IsSuccess = true,
            Type = type,
            Item = item,
            Price = price
        };
    }

    /// <summary>
    /// Creates a failed transaction result.
    /// </summary>
    public static TransactionResult Failure(string message)
    {
        return new TransactionResult
        {
            IsSuccess = false,
            ErrorMessage = message
        };
    }
}

/// <summary>
/// Types of shop transactions.
/// </summary>
public enum TransactionType
{
    /// <summary>Player buying from merchant.</summary>
    PlayerBuy,

    /// <summary>Player selling to merchant.</summary>
    PlayerSell
}
```

### Item Modifications

```
MODIFY: Item
├── ADD: BasePrice: int (default 0)
├── ADD: SellMultiplier: decimal (default 0.5)
├── ADD: CanBeSold: bool (default true)
└── ADD: IsQuestItem: bool (default false, prevents selling)
```

### Player Modifications

```
MODIFY: Player
├── ADD: Gold: int (default 0)
├── ADD: SpendGold(int amount): bool
├── ADD: AddGold(int amount): void
└── ADD: CanAfford(int amount): bool
```

### ShopService Interface

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages shop transactions and merchant interactions.
/// </summary>
public interface IShopService
{
    /// <summary>
    /// Gets available items from a merchant.
    /// </summary>
    IEnumerable<ShopItem> GetMerchantInventory(Merchant merchant);

    /// <summary>
    /// Attempts to buy an item from a merchant.
    /// </summary>
    TransactionResult BuyItem(Player player, Merchant merchant, string itemId);

    /// <summary>
    /// Attempts to sell an item to a merchant.
    /// </summary>
    TransactionResult SellItem(Player player, Merchant merchant, Item item);

    /// <summary>
    /// Gets the buy price for an item.
    /// </summary>
    int GetBuyPrice(Merchant merchant, Item item);

    /// <summary>
    /// Gets the sell price for an item.
    /// </summary>
    int GetSellPrice(Merchant merchant, Item item);

    /// <summary>
    /// Finds a merchant in the current room.
    /// </summary>
    Merchant? FindMerchant(Room room, string? merchantName = null);
}
```

### User-Facing Changes

**Commands:**
```
> buy <item>              # Purchase item from merchant
> buy "Iron Sword"        # Purchase item with spaces in name
> sell <item>             # Sell item to merchant
> sell all junk           # Sell all items marked as junk
```

**Output Example:**
```
> talk grimbold
Grimbold looks up from his ledger. "Welcome to my shop! See anything
you like?"

FOR SALE:
  Iron Sword .......... 50 gold (3 in stock)
  Leather Armor ....... 35 gold (2 in stock)
  Health Potion ....... 15 gold (10 in stock)
  Torch ............... 5 gold (unlimited)

Your gold: 127

[1] Browse wares
[2] Sell items
[3] Just passing through

---

> buy "Iron Sword"
You purchase the Iron Sword for 50 gold.
Remaining gold: 77

---

> sell "Rusty Dagger"
Grimbold examines the Rusty Dagger.
"I'll give you 3 gold for it."

You sell the Rusty Dagger for 3 gold.
Your gold: 80
```

### Configuration Example

```json
{
  "$schema": "../schemas/merchants.schema.json",
  "merchants": [
    {
      "id": "grimbold-trader",
      "name": "Grimbold the Trader",
      "type": "Merchant",
      "defaultAttitude": "Neutral",
      "greeting": "Welcome to my shop! See anything you like?",
      "description": "A stout dwarf with a braided beard sits behind a worn counter.",
      "startingGold": 500,
      "buyMultiplier": 1.0,
      "sellMultiplier": 0.5,
      "factionId": "merchant-guild",
      "initialStock": [
        { "itemId": "iron-sword", "quantity": 3 },
        { "itemId": "leather-armor", "quantity": 2 },
        { "itemId": "health-potion", "quantity": 10 },
        { "itemId": "torch", "quantity": -1, "unlimited": true }
      ]
    }
  ]
}
```

### Acceptance Criteria

- [ ] Merchant entity extends NPC with shop features
- [ ] ShopInventory tracks items and quantities
- [ ] `buy <item>` deducts gold and adds item to player
- [ ] `sell <item>` adds gold and removes item from player
- [ ] Items have BasePrice for transaction calculations
- [ ] Merchant gold changes with transactions
- [ ] Stock decreases when items purchased
- [ ] Cannot buy with insufficient gold
- [ ] Quest items cannot be sold
- [ ] ~30 unit tests pass

---

## v0.2.2b: Dynamic Pricing & Haggling

### Overview

Implement price modifiers based on charisma, reputation, and merchant attitude, plus the haggling system that allows players to negotiate better prices through skill checks.

### Scope

**In Scope:**
- `PriceModifier` value object for price adjustments
- `Charisma` stat on Player entity
- Reputation-based price modifiers
- Attitude-based price modifiers
- `haggle` command for price negotiation
- `HaggleService` for negotiation logic
- Haggle success/failure outcomes
- Haggle attempt limits per merchant
- Price lock after successful haggle

**Out of Scope:**
- Specialty merchant types (v0.2.2c)
- Shop UI interface (v0.2.2c)
- Inventory refresh mechanics (v0.2.2c)
- Item appraisal display (v0.2.2c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Value Objects | 3 | `PriceModifier`, `HaggleAttempt`, `HaggleResult` |
| Services | 1 | `HaggleService` |
| Commands | 1 | `haggle` |
| Player Updates | 1 | Add Charisma stat |
| Merchant Updates | 1 | Track haggle state |
| Unit Tests | ~30 | Pricing, haggling, modifier tests |

### PriceModifier Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents factors that modify transaction prices.
/// </summary>
public readonly record struct PriceModifier
{
    /// <summary>
    /// Gets the base multiplier (1.0 = no change).
    /// </summary>
    public decimal BaseMultiplier { get; init; }

    /// <summary>
    /// Gets the charisma modifier.
    /// </summary>
    public decimal CharismaModifier { get; init; }

    /// <summary>
    /// Gets the reputation modifier.
    /// </summary>
    public decimal ReputationModifier { get; init; }

    /// <summary>
    /// Gets the attitude modifier.
    /// </summary>
    public decimal AttitudeModifier { get; init; }

    /// <summary>
    /// Gets the haggle modifier (if successful).
    /// </summary>
    public decimal HaggleModifier { get; init; }

    /// <summary>
    /// Gets the combined multiplier.
    /// </summary>
    public decimal TotalMultiplier =>
        BaseMultiplier * CharismaModifier * ReputationModifier * AttitudeModifier * HaggleModifier;

    /// <summary>
    /// Gets a default modifier with no adjustments.
    /// </summary>
    public static PriceModifier Default => new()
    {
        BaseMultiplier = 1.0m,
        CharismaModifier = 1.0m,
        ReputationModifier = 1.0m,
        AttitudeModifier = 1.0m,
        HaggleModifier = 1.0m
    };

    /// <summary>
    /// Applies this modifier to a base price.
    /// </summary>
    public int ApplyToBuyPrice(int basePrice)
    {
        return (int)Math.Ceiling(basePrice * TotalMultiplier);
    }

    /// <summary>
    /// Applies this modifier to a sell price (inverse for player benefit).
    /// </summary>
    public int ApplyToSellPrice(int basePrice)
    {
        // For selling, lower multiplier = better for player
        var sellMultiplier = 2.0m - TotalMultiplier; // Inverse
        sellMultiplier = Math.Max(0.5m, Math.Min(1.5m, sellMultiplier)); // Clamp
        return (int)Math.Floor(basePrice * sellMultiplier);
    }

    /// <summary>
    /// Creates a modifier from character stats and context.
    /// </summary>
    public static PriceModifier Calculate(
        int charisma,
        ReputationLevel reputation,
        NPCAttitude attitude,
        bool hasHaggled = false,
        decimal haggleDiscount = 0m)
    {
        return new PriceModifier
        {
            BaseMultiplier = 1.0m,
            CharismaModifier = CalculateCharismaModifier(charisma),
            ReputationModifier = CalculateReputationModifier(reputation),
            AttitudeModifier = CalculateAttitudeModifier(attitude),
            HaggleModifier = hasHaggled ? (1.0m - haggleDiscount) : 1.0m
        };
    }

    private static decimal CalculateCharismaModifier(int charisma)
    {
        // Each point of charisma above 10 reduces prices by 2%
        // Each point below 10 increases prices by 2%
        var difference = charisma - 10;
        return 1.0m - (difference * 0.02m);
    }

    private static decimal CalculateReputationModifier(ReputationLevel reputation)
    {
        return reputation switch
        {
            ReputationLevel.Exalted => 0.80m,   // 20% discount
            ReputationLevel.Revered => 0.85m,   // 15% discount
            ReputationLevel.Honored => 0.90m,   // 10% discount
            ReputationLevel.Friendly => 0.95m,  // 5% discount
            ReputationLevel.Neutral => 1.00m,   // No change
            ReputationLevel.Unfriendly => 1.10m, // 10% markup
            ReputationLevel.Hostile => 1.25m,   // 25% markup
            ReputationLevel.Hated => 1.50m,     // 50% markup (if they'll trade at all)
            _ => 1.00m
        };
    }

    private static decimal CalculateAttitudeModifier(NPCAttitude attitude)
    {
        return attitude switch
        {
            NPCAttitude.Friendly => 0.95m,  // 5% discount
            NPCAttitude.Neutral => 1.00m,   // No change
            NPCAttitude.Wary => 1.05m,      // 5% markup
            NPCAttitude.Hostile => 1.20m,   // 20% markup
            _ => 1.00m
        };
    }
}
```

### HaggleResult Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of a haggle attempt.
/// </summary>
public readonly record struct HaggleResult
{
    /// <summary>
    /// Gets whether the haggle was successful.
    /// </summary>
    public bool IsSuccess { get; init; }

    /// <summary>
    /// Gets the success level achieved.
    /// </summary>
    public SuccessLevel SuccessLevel { get; init; }

    /// <summary>
    /// Gets the discount percentage achieved (0-30%).
    /// </summary>
    public decimal DiscountPercent { get; init; }

    /// <summary>
    /// Gets the dice roll result.
    /// </summary>
    public DiceRollResult RollResult { get; init; }

    /// <summary>
    /// Gets the difficulty class that was checked.
    /// </summary>
    public int DC { get; init; }

    /// <summary>
    /// Gets a flavor message for the result.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets whether the merchant's attitude changed.
    /// </summary>
    public bool AttitudeChanged { get; init; }

    /// <summary>
    /// Gets the new attitude if changed.
    /// </summary>
    public NPCAttitude? NewAttitude { get; init; }

    /// <summary>
    /// Creates a successful haggle result.
    /// </summary>
    public static HaggleResult Success(
        SuccessLevel level,
        decimal discount,
        DiceRollResult roll,
        int dc,
        string message)
    {
        return new HaggleResult
        {
            IsSuccess = true,
            SuccessLevel = level,
            DiscountPercent = discount,
            RollResult = roll,
            DC = dc,
            Message = message
        };
    }

    /// <summary>
    /// Creates a failed haggle result.
    /// </summary>
    public static HaggleResult Failure(
        SuccessLevel level,
        DiceRollResult roll,
        int dc,
        string message,
        bool attitudeChanged = false,
        NPCAttitude? newAttitude = null)
    {
        return new HaggleResult
        {
            IsSuccess = false,
            SuccessLevel = level,
            DiscountPercent = 0,
            RollResult = roll,
            DC = dc,
            Message = message,
            AttitudeChanged = attitudeChanged,
            NewAttitude = newAttitude
        };
    }
}
```

### HaggleService Interface

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages haggling negotiations with merchants.
/// </summary>
public interface IHaggleService
{
    /// <summary>
    /// Attempts to haggle with a merchant.
    /// </summary>
    HaggleResult AttemptHaggle(Player player, Merchant merchant);

    /// <summary>
    /// Gets whether the player can haggle with this merchant.
    /// </summary>
    bool CanHaggle(Player player, Merchant merchant);

    /// <summary>
    /// Gets the remaining haggle attempts for a merchant.
    /// </summary>
    int GetRemainingAttempts(Player player, Merchant merchant);

    /// <summary>
    /// Gets the current haggle discount if any.
    /// </summary>
    decimal GetCurrentDiscount(Player player, Merchant merchant);

    /// <summary>
    /// Calculates the haggle DC based on merchant and context.
    /// </summary>
    int CalculateHaggleDC(Merchant merchant);
}
```

### Haggle Mechanics

```csharp
// Haggle DC calculation
public int CalculateHaggleDC(Merchant merchant)
{
    var baseDC = 12;

    // Attitude affects DC
    baseDC += merchant.Attitude switch
    {
        NPCAttitude.Friendly => -2,
        NPCAttitude.Neutral => 0,
        NPCAttitude.Wary => 2,
        NPCAttitude.Hostile => 5,
        _ => 0
    };

    // Previous purchases lower DC
    if (merchant.TransactionCount > 10) baseDC -= 2;
    else if (merchant.TransactionCount > 5) baseDC -= 1;

    return Math.Max(8, baseDC); // Minimum DC 8
}

// Discount based on success level
public decimal GetDiscount(SuccessLevel level)
{
    return level switch
    {
        SuccessLevel.CriticalSuccess => 0.20m, // 20% discount
        SuccessLevel.Success => 0.10m,          // 10% discount
        SuccessLevel.PartialSuccess => 0.05m,   // 5% discount
        _ => 0m
    };
}
```

### Player Modifications

```
MODIFY: Player
├── ADD: Charisma: int (default 10)
├── ADD: HaggleAttempts: Dictionary<Guid, int> (merchantId -> attempts)
├── ADD: HaggleDiscounts: Dictionary<Guid, decimal> (merchantId -> discount)
└── ADD: GetHaggleBonus(): int (Charisma modifier)
```

### Merchant Modifications

```
MODIFY: Merchant
├── ADD: MaxHaggleAttempts: int (default 3)
├── ADD: HaggleCooldownMinutes: int (default 60)
└── ADD: LastHaggleAttempt: Dictionary<Guid, DateTime>
```

### User-Facing Changes

**Commands:**
```
> haggle                  # Attempt to negotiate better prices
```

**Output Example:**
```
> haggle
You try to negotiate a better deal with Grimbold.

[Haggle Check: DC 12]
Rolling 2d6 + Charisma (2)...
Rolled: 5, 4 = 9 + 2 = 11
Failed!

Grimbold frowns. "My prices are fair. Take it or leave it."
Attempts remaining: 2

---

> haggle
[Haggle Check: DC 12]
Rolling 2d6 + Charisma (2)...
Rolled: 6, 5 = 11 + 2 = 13
Success!

Grimbold strokes his beard thoughtfully. "Alright, alright. For you,
I'll knock 10% off my prices."

[HAGGLE SUCCESS] 10% discount applied to all purchases!

---

Current Prices (with 10% discount):
  Iron Sword .......... 45 gold (was 50)
  Leather Armor ....... 32 gold (was 35)
  Health Potion ....... 14 gold (was 15)
```

### Acceptance Criteria

- [ ] PriceModifier calculates combined multipliers
- [ ] Charisma affects buy/sell prices
- [ ] Reputation level modifies prices appropriately
- [ ] Merchant attitude affects prices
- [ ] `haggle` command initiates negotiation
- [ ] Haggle uses dice pool skill check
- [ ] Successful haggle grants discount
- [ ] Critical failure can worsen attitude
- [ ] Haggle attempts limited per merchant
- [ ] Discount persists until leaving shop
- [ ] ~30 unit tests pass

---

## v0.2.2c: Shop UI & Specialty Merchants

### Overview

Implement the TUI shop interface for browsing and comparing items, specialty merchant types with themed inventories, and inventory refresh mechanics.

### Scope

**In Scope:**
- `MerchantType` enum for specialty categories
- Specialty merchant inventory generation
- Inventory refresh logic
- `shop` command for TUI interface
- Item comparison display
- `appraise <item>` command
- Buy/sell within shop interface
- Merchant stock refresh timers

**Out of Scope:**
- GUI shop interface (future version)
- Merchant restocking from external sources (future)
- Player-owned shops (future)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 1 | `MerchantType` |
| Value Objects | 1 | `ItemComparison` |
| Services | 1 | `InventoryRefreshService` |
| Commands | 2 | `shop`, `appraise` |
| TUI Views | 1 | `ShopView` |
| Configuration | 1 | `merchant-types.json` |
| Unit Tests | ~25 | UI, refresh, specialty tests |

### MerchantType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of specialty merchants.
/// </summary>
public enum MerchantType
{
    /// <summary>General goods, varied inventory.</summary>
    GeneralStore,

    /// <summary>Specializes in weapons.</summary>
    Weaponsmith,

    /// <summary>Specializes in armor and shields.</summary>
    Armorer,

    /// <summary>Sells potions and magical consumables.</summary>
    Alchemist,

    /// <summary>Sells scrolls and magical items.</summary>
    Enchanter,

    /// <summary>Buys and sells gems and jewelry.</summary>
    Jeweler,

    /// <summary>Sells food and supplies.</summary>
    Provisioner,

    /// <summary>Deals in rare and exotic goods.</summary>
    CurioDealer
}
```

### ItemComparison Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Comparison between a shop item and player's equipped item.
/// </summary>
public readonly record struct ItemComparison
{
    /// <summary>
    /// Gets the shop item being compared.
    /// </summary>
    public Item ShopItem { get; init; }

    /// <summary>
    /// Gets the currently equipped item (if any).
    /// </summary>
    public Item? EquippedItem { get; init; }

    /// <summary>
    /// Gets stat differences (positive = shop item better).
    /// </summary>
    public IReadOnlyDictionary<string, int> StatDifferences { get; init; }

    /// <summary>
    /// Gets whether the shop item is an upgrade.
    /// </summary>
    public bool IsUpgrade { get; init; }

    /// <summary>
    /// Gets whether the shop item is a downgrade.
    /// </summary>
    public bool IsDowngrade { get; init; }

    /// <summary>
    /// Gets whether items are equivalent.
    /// </summary>
    public bool IsEquivalent => !IsUpgrade && !IsDowngrade;

    /// <summary>
    /// Creates a comparison between two items.
    /// </summary>
    public static ItemComparison Create(Item shopItem, Item? equippedItem)
    {
        if (equippedItem == null)
        {
            return new ItemComparison
            {
                ShopItem = shopItem,
                EquippedItem = null,
                StatDifferences = new Dictionary<string, int>(),
                IsUpgrade = true,
                IsDowngrade = false
            };
        }

        var differences = new Dictionary<string, int>();

        // Compare attack
        var attackDiff = (shopItem.WeaponBonuses?.AttackBonus ?? 0) -
                        (equippedItem.WeaponBonuses?.AttackBonus ?? 0);
        if (attackDiff != 0) differences["Attack"] = attackDiff;

        // Compare defense
        var defenseDiff = (shopItem.ArmorValue ?? 0) - (equippedItem.ArmorValue ?? 0);
        if (defenseDiff != 0) differences["Defense"] = defenseDiff;

        // Determine upgrade/downgrade
        var totalDiff = differences.Values.Sum();

        return new ItemComparison
        {
            ShopItem = shopItem,
            EquippedItem = equippedItem,
            StatDifferences = differences,
            IsUpgrade = totalDiff > 0,
            IsDowngrade = totalDiff < 0
        };
    }
}
```

### InventoryRefreshService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages merchant inventory refresh.
/// </summary>
public interface IInventoryRefreshService
{
    /// <summary>
    /// Checks if a merchant's inventory should refresh.
    /// </summary>
    bool ShouldRefresh(Merchant merchant);

    /// <summary>
    /// Refreshes a merchant's inventory.
    /// </summary>
    void RefreshInventory(Merchant merchant);

    /// <summary>
    /// Gets the time until next refresh.
    /// </summary>
    TimeSpan GetTimeUntilRefresh(Merchant merchant);

    /// <summary>
    /// Generates stock for a merchant type.
    /// </summary>
    IEnumerable<ShopItem> GenerateStock(MerchantType type, int merchantLevel);
}
```

### Shop TUI Interface

```
┌─────────────────────────────────────────────────────────────┐
│                    GRIMBOLD'S TRADING POST                  │
│                        General Store                         │
├─────────────────────────────────────────────────────────────┤
│  Your Gold: 127            Reputation: Friendly (+5% off)   │
│  Haggle Discount: 10%                                       │
├─────────────────────────────────────────────────────────────┤
│  FOR SALE                           PRICE    STOCK   COMP   │
│  ─────────────────────────────────────────────────────────  │
│  [1] Iron Sword                     45g      3       ▲+2    │
│  [2] Leather Armor                  32g      2       ▲+3    │
│  [3] Health Potion                  14g      10      ──     │
│  [4] Torch                          5g       ∞       ──     │
│  [5] Rope (50ft)                    8g       5       ──     │
├─────────────────────────────────────────────────────────────┤
│  YOUR ITEMS (Sellable)              VALUE                   │
│  ─────────────────────────────────────────────────────────  │
│  [a] Rusty Dagger                   3g                      │
│  [b] Goblin Ear x5                  10g                     │
│  [c] Minor Health Potion            5g                      │
├─────────────────────────────────────────────────────────────┤
│  Commands: [#] Buy  [letter] Sell  [h]aggle  [q]uit         │
│            [c]ompare [#]  [i]nventory                       │
└─────────────────────────────────────────────────────────────┘
```

### User-Facing Changes

**Commands:**
```
> shop                    # Open shop interface
> shop grimbold           # Open specific merchant's shop
> appraise <item>         # See detailed value breakdown
> appraise "Iron Sword"   # Appraise item with spaces
```

**Output Example:**
```
> appraise "Rusty Dagger"
=== ITEM APPRAISAL ===

Rusty Dagger
Type: Weapon (Dagger)
Condition: Poor

Base Value: 5 gold
Condition Modifier: -40%
─────────────────────
Estimated Value: 3 gold

Grimbold would pay: 3 gold
(Sell price includes your 10% haggle bonus)

---

> shop
[Opens TUI shop interface]

> compare 1
=== ITEM COMPARISON ===

Iron Sword vs. Your: Rusty Dagger

                    Iron Sword    Rusty Dagger    Diff
Attack Bonus:       +5            +2              ▲ +3
Damage:             1d8           1d4             ▲ +1 die
Weight:             3 lbs         1 lb            ▼ +2 lbs
Value:              50g           5g

VERDICT: Significant Upgrade
Price: 45 gold (with discounts)
```

### Configuration Example

```json
{
  "$schema": "../schemas/merchant-types.schema.json",
  "merchantTypes": {
    "Weaponsmith": {
      "stockCategories": ["weapons", "weapon-accessories"],
      "excludeCategories": ["armor", "potions", "scrolls"],
      "priceModifier": 0.95,
      "stockRefreshHours": 24,
      "minStock": 5,
      "maxStock": 15,
      "rarityWeights": {
        "common": 60,
        "uncommon": 30,
        "rare": 10
      }
    },
    "Alchemist": {
      "stockCategories": ["potions", "reagents", "poisons"],
      "excludeCategories": ["weapons", "armor"],
      "priceModifier": 1.0,
      "stockRefreshHours": 12,
      "minStock": 10,
      "maxStock": 25,
      "rarityWeights": {
        "common": 50,
        "uncommon": 35,
        "rare": 15
      }
    },
    "GeneralStore": {
      "stockCategories": ["all"],
      "excludeCategories": ["rare", "legendary"],
      "priceModifier": 1.05,
      "stockRefreshHours": 48,
      "minStock": 15,
      "maxStock": 30,
      "rarityWeights": {
        "common": 70,
        "uncommon": 25,
        "rare": 5
      }
    }
  }
}
```

### Acceptance Criteria

- [ ] MerchantType enum covers all specialty types
- [ ] Specialty merchants stock appropriate items
- [ ] Inventory refreshes after configured time
- [ ] `shop` command opens TUI interface
- [ ] Shop UI displays items with prices
- [ ] Item comparison shows stat differences
- [ ] Upgrade/downgrade indicators display
- [ ] `appraise` command shows value breakdown
- [ ] Can buy/sell from within shop UI
- [ ] ~25 unit tests pass

---

## Dependencies & Prerequisites

```
v0.2.1 (Codex & Lore Discovery) - REQUIRED
    │
    ├── CodexEntry ──────────────────────┐
    │   (Item lore affects perceived value)
    ├── Player.Reputation ───────────────┤
    └── FactionDefinition ───────────────┘
                                         │
                                         ▼
v0.2.2 (Merchant System)
    │
    ├── v0.2.2a: Shop Foundation ────────────────────┐
    │       Dependencies: NPC, Item, Player           │
    │                                                 │
    ├── v0.2.2b: Dynamic Pricing & Haggling ─────────┤
    │       Dependencies: v0.2.2a, DicePool           │
    │                     Reputation system           │
    │                                                 │
    └── v0.2.2c: Shop UI & Specialty Merchants ──────┘
            Dependencies: v0.2.2a, v0.2.2b
                          IGameRenderer
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.2.2a | ~8 | ~4 | ~30 | Medium |
| v0.2.2b | ~5 | ~4 | ~30 | High |
| v0.2.2c | ~6 | ~3 | ~25 | Medium |
| **Total** | **~19** | **~11** | **~85** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Economy balance issues | High | Medium | Configurable multipliers, testing |
| Haggle exploit potential | Medium | Medium | Attempt limits, cooldowns |
| TUI complexity | Medium | Low | Iterative UI development |
| Item pricing inconsistency | Medium | Medium | Central pricing service |
| Stock generation randomness | Low | Low | Seeded random, configuration |

---

## Design Decisions (Confirmed)

### Economy Architecture

| Decision | Value | Notes |
|----------|-------|-------|
| **Currency** | Gold only | Single currency for simplicity |
| **Base Sell Ratio** | 50% | Players get half of base price |
| **Maximum Haggle Discount** | 20% | Critical success ceiling |
| **Haggle Attempts** | 3 per merchant | Resets on cooldown |

### Pricing System

| Decision | Value | Notes |
|----------|-------|-------|
| **Charisma Effect** | 2% per point | From base 10 |
| **Reputation Range** | -50% to +20% | Hated to Exalted |
| **Attitude Range** | -20% to +5% | Hostile to Friendly |
| **Price Stacking** | Multiplicative | All modifiers multiply |

### Merchant Types

| Decision | Value | Notes |
|----------|-------|-------|
| **Type Count** | 8 types | As specified |
| **Specialty Bonus** | 5% discount | On specialty items |
| **Refresh Period** | 12-48 hours | By type |

---

## Integration Points

### From v0.2.1
- CodexEntry for item lore (affects appraisal flavor text)
- Player reputation system for pricing

### From v0.2.0
- NPC system as merchant base
- Dialogue system for merchant interaction
- Attitude system for pricing

### To v0.3.0 (Quest System)
- Quest rewards can include gold
- Merchants can be quest givers
- Quest items marked non-sellable

### To v0.11.0 (Crafting)
- Merchants sell crafting materials
- Players sell crafted items
- Specialty merchants for crafting goods

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.2.2a Design Spec** - Create detailed design specification
3. **Implement v0.2.2a** - Build shop foundation
4. **v0.2.2b Design Spec** - Pricing and haggling details
5. **Implement v0.2.2b** - Build dynamic pricing
6. **Implement v0.2.2c** - Build shop UI and merchant types

---

*This scope breakdown provides a structured approach to implementing v0.2.2 Merchant System. Each sub-phase builds on the previous, allowing for incremental development and testing while establishing a complete economy and trading system.*
