# v0.3.23a: The Abstraction (Input Mapping)

**Status:** Planned
**Parent Plan:** [v0.3.23](./v0.3.23.md)
**Context:** This sub-plan focuses on the architectural shift from reading raw console keys to consuming semantic `InputEvent` objects. This is a prerequisite for the non-blocking loop (v0.3.23b).

## 1. Domain Modeling

### 1.1. Define Input Events
Create a new file `RuneAndRust.Core/Models/Input/InputEvent.cs`. This will define the hierarchy of input events.

```csharp
namespace RuneAndRust.Core.Models.Input;

using RuneAndRust.Core.Enums;

/// <summary>
/// Base record for all input events in the system.
/// </summary>
public abstract record InputEvent;

/// <summary>
/// Represents a semantic game action (e.g., MoveNorth, Attack, Confirm).
/// </summary>
public record ActionEvent(GameAction Action) : InputEvent;

/// <summary>
/// Represents a raw key press that wasn't mapped to an action (e.g., for text input).
/// </summary>
public record RawKeyEvent(ConsoleKeyInfo KeyInfo) : InputEvent;

/// <summary>
/// Represents a mouse interaction (v0.3.23c preparation).
/// </summary>
public record MouseEvent(int X, int Y, bool IsLeftClick) : InputEvent;
```

### 1.2. Define IInputService
Create `RuneAndRust.Core/Interfaces/IInputService.cs`.

```csharp
namespace RuneAndRust.Core.Interfaces;

using RuneAndRust.Core.Models.Input;

public interface IInputService
{
    /// <summary>
    /// Reads the next input event.
    /// In the initial implementation (v0.3.23a), this may still be blocking.
    /// In v0.3.23b, this will become non-blocking or part of the loop logic.
    /// </summary>
    InputEvent ReadNext();

    /// <summary>
    /// Checks if input is available (non-blocking check).
    /// </summary>
    bool IsInputAvailable();
}
```

## 2. Implementation

### 2.1. Implement InputService
Create `RuneAndRust.Engine/Services/InputService.cs`.

- **Dependencies:** `IInputConfigurationService`
- **Logic:**
    1.  `ReadNext()` calls `Console.ReadKey(intercept: true)`.
    2.  Check `_config.GetCommandForKey(key.Key)`.
    3.  If command exists, try parse `GameAction`.
        - Return `ActionEvent(action)`.
    4.  Else, return `RawKeyEvent(key)`.

### 2.2. Register Service
Update `RuneAndRust.Terminal/Program.cs` (or `Startup.cs` equivalent) to register `IInputService` -> `InputService` as a Singleton or Scoped service.

## 3. Refactoring Consumers

### 3.1. Refactor TerminalInputHandler
Modify `RuneAndRust.Terminal/Services/TerminalInputHandler.cs`.
- Replace direct `Console.ReadKey()` usage.
- Inject `IInputService`.
- Update logic to switch on `InputEvent` types.
    - `ActionEvent`: Handle game logic.
    - `RawKeyEvent`: Handle specific logic if needed (or ignore).

### 3.2. Update Controllers (if applicable)
- `OptionsController`: Ensure it handles `GameAction.Menu`, `GameAction.Confirm`, etc.
- `CreationWizard`: This likely needs raw text input. It should handle `RawKeyEvent` for typing names.

## 4. Verification

### 4.1. Unit Tests
Create `RuneAndRust.Tests/Engine/InputServiceTests.cs`.
- Test `ReadNext()` with mapped keys -> Returns `ActionEvent`.
- Test `ReadNext()` with unmapped keys -> Returns `RawKeyEvent`.
- Mock `IInputConfigurationService` behavior.

### 4.2. Manual Verification
- Run the game.
- Verify basic movement (WASD/Arrows) works via the new mapping.
- Verify Menus work.
- Verify Character Creation (text input) works.
