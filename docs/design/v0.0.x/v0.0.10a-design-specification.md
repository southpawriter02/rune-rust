# v0.0.10a Design Specification: Logging Infrastructure

**Version:** 0.0.10a
**Phase Name:** Logging Infrastructure
**Parent Version:** v0.0.10 (Documentation & Polish)
**Prerequisites:** v0.0.9 Complete (Monster Variety & Loot)
**Estimated Tests:** ~15 unit tests

---

## 1. Overview

### 1.1 Purpose

Standardize and complete the structured logging infrastructure across all layers of the application. While logging is already partially implemented in several services (GameSessionService, CombatService, AbilityService, etc.), this phase establishes consistent patterns, adds logging to remaining services, implements operation correlation, and configures log output settings.

### 1.2 Current State

Logging is already integrated in the following locations:

| Layer | File | Status |
|-------|------|--------|
| Domain | `CombatService.cs` | Complete |
| Application | `GameSessionService.cs` | Complete |
| Application | `AbilityService.cs` | Complete |
| Application | `ResourceService.cs` | Complete |
| Application | `ClassService.cs` | Partial |
| Application | `DescriptorService.cs` | Partial |
| Application | `LexiconService.cs` | Partial |
| Application | `PlayerCreationService.cs` | Partial |
| Application | `InputValidationService.cs` | Partial |
| Application | `ItemEffectService.cs` | Partial |
| Infrastructure | `JsonConfigurationProvider.cs` | Minimal |
| Infrastructure | `InMemoryGameRepository.cs` | Minimal |
| Presentation | `GameView.cs` | Minimal |
| Presentation | `CharacterCreationView.cs` | Minimal |
| Presentation | `MainMenuView.cs` | Minimal |

### 1.3 Scope

**In Scope:**
- Standardize logging patterns across all existing services
- Add comprehensive logging to services with minimal/no logging
- Implement operation correlation IDs for tracking requests across layers
- Configure log levels via `appsettings.json`
- Add file-based logging sink
- Create logging extension methods for common patterns
- Define log message templates for consistency
- Add performance logging for key operations
- Document logging standards

**Out of Scope:**
- External logging services (Application Insights, Seq, etc.)
- Log aggregation/analysis systems
- Real-time log monitoring UI
- Log retention policies (left to deployment configuration)

### 1.4 Design Goals

1. **Consistency**: All services follow the same logging patterns
2. **Observability**: Key operations are traceable through logs
3. **Performance**: Logging has minimal impact on game performance
4. **Configurability**: Log levels adjustable without code changes
5. **Correlation**: Related operations can be traced together
6. **Testability**: Logging can be verified in unit tests

---

## 2. Logging Standards

### 2.1 Log Level Guidelines

| Level | Use Case | Examples |
|-------|----------|----------|
| **Trace** | Detailed internal flow, method entry/exit | `"Entering CalculateDamage with attack={Attack}"` |
| **Debug** | Development-useful information | `"Player position: ({X}, {Y})"`, `"Found {Count} items in room"` |
| **Information** | Key business operations | `"Player defeated monster, gained {XP} XP"`, `"Game saved"` |
| **Warning** | Unexpected but handled situations | `"Configuration file not found, using defaults"` |
| **Error** | Operation failures that don't crash the app | `"Failed to save game: {Exception}"` |
| **Critical** | System-level failures | `"Database connection lost"`, `"Configuration invalid"` |

### 2.2 Structured Logging Patterns

All log messages should use structured logging with semantic property names:

```csharp
// GOOD: Structured with semantic properties
_logger.LogInformation(
    "Player {PlayerId} moved {Direction} to room {RoomId}",
    player.Id, direction, room.Id);

// GOOD: Include context in property names
_logger.LogDebug(
    "Combat initiated: {PlayerName} (HP:{PlayerHealth}) vs {MonsterName} (HP:{MonsterHealth})",
    player.Name, player.Health, monster.Name, monster.Health);

// BAD: String interpolation loses structure
_logger.LogInformation($"Player {player.Id} moved to room {room.Id}");

// BAD: Generic property names
_logger.LogInformation("Player {0} moved to {1}", player.Id, room.Id);
```

### 2.3 Log Message Templates

Define consistent templates for common operations:

```csharp
public static class LogTemplates
{
    // Service initialization
    public const string ServiceInitialized = "{ServiceName} initialized";
    public const string ServiceInitializedWithCount = "{ServiceName} initialized with {Count} {ItemType}";

    // Player actions
    public const string PlayerAction = "Player {PlayerName} {Action}";
    public const string PlayerActionWithTarget = "Player {PlayerName} {Action} {Target}";
    public const string PlayerActionResult = "Player {PlayerName} {Action}: {Result}";

    // Combat
    public const string CombatInitiated = "Combat initiated: {PlayerName} vs {MonsterName}";
    public const string CombatDamage = "{Attacker} dealt {Damage} damage to {Defender}";
    public const string CombatResult = "Combat resolved: {Outcome}";

    // State changes
    public const string StateChanged = "{EntityType} {EntityId} state changed: {OldState} -> {NewState}";
    public const string ResourceChanged = "{ResourceType} changed: {OldValue} -> {NewValue}";

    // Errors
    public const string OperationFailed = "{Operation} failed: {Reason}";
    public const string EntityNotFound = "{EntityType} not found: {EntityId}";
}
```

---

## 3. Operation Correlation

### 3.1 Correlation Scope

Track related operations across layers using `ILogger.BeginScope`:

```csharp
public class GameSessionService
{
    public async Task<MoveResult> MovePlayerAsync(Direction direction)
    {
        var operationId = Guid.NewGuid().ToString("N")[..8];

        using (_logger.BeginScope(new Dictionary<string, object>
        {
            ["OperationId"] = operationId,
            ["Operation"] = "MovePlayer",
            ["SessionId"] = _currentSession?.Id ?? Guid.Empty
        }))
        {
            _logger.LogDebug("Starting move operation {Direction}", direction);

            // All logs within this scope include OperationId, Operation, SessionId
            var result = PerformMove(direction);

            _logger.LogInformation("Move operation complete: {Success}", result.Success);
            return result;
        }
    }
}
```

### 3.2 IOperationScope Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IOperationScope.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides operation scope for correlation across service calls.
/// </summary>
public interface IOperationScope
{
    /// <summary>
    /// Gets the current operation identifier.
    /// </summary>
    string OperationId { get; }

    /// <summary>
    /// Gets the current session identifier.
    /// </summary>
    Guid? SessionId { get; }

    /// <summary>
    /// Creates a new child scope for a sub-operation.
    /// </summary>
    /// <param name="operationName">The name of the sub-operation.</param>
    /// <returns>A disposable scope.</returns>
    IDisposable BeginOperation(string operationName);
}
```

### 3.3 OperationScope Implementation

**File:** `src/Core/RuneAndRust.Application/Services/OperationScope.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Provides operation scope for correlation across service calls.
/// </summary>
public class OperationScope : IOperationScope
{
    private readonly ILogger _logger;
    private readonly Stack<string> _operationStack = new();

    /// <inheritdoc />
    public string OperationId { get; }

    /// <inheritdoc />
    public Guid? SessionId { get; private set; }

    /// <summary>
    /// Creates a new operation scope.
    /// </summary>
    /// <param name="logger">The logger to use for scope creation.</param>
    /// <param name="sessionId">Optional session identifier.</param>
    public OperationScope(ILogger logger, Guid? sessionId = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        OperationId = Guid.NewGuid().ToString("N")[..8];
        SessionId = sessionId;
    }

    /// <summary>
    /// Sets the session ID for this scope.
    /// </summary>
    /// <param name="sessionId">The session identifier.</param>
    public void SetSessionId(Guid sessionId)
    {
        SessionId = sessionId;
    }

    /// <inheritdoc />
    public IDisposable BeginOperation(string operationName)
    {
        _operationStack.Push(operationName);

        return _logger.BeginScope(new Dictionary<string, object>
        {
            ["OperationId"] = OperationId,
            ["Operation"] = operationName,
            ["SessionId"] = SessionId ?? Guid.Empty,
            ["Depth"] = _operationStack.Count
        });
    }
}
```

---

## 4. Service Integration

### 4.1 Services Requiring Logging Enhancement

| Service | Current State | Required Changes |
|---------|---------------|------------------|
| `ClassService` | Basic | Add method entry/exit, decision logging |
| `DescriptorService` | Basic | Add lookup logging, cache hits |
| `LexiconService` | Basic | Add term resolution logging |
| `PlayerCreationService` | Basic | Add creation step logging |
| `InputValidationService` | Basic | Add validation result logging |
| `ItemEffectService` | Basic | Add effect application logging |
| `JsonConfigurationProvider` | Minimal | Add file load logging, errors |
| `InMemoryGameRepository` | Minimal | Add CRUD operation logging |

### 4.2 Enhanced Service Pattern

Example of a fully logged service:

**File:** `src/Core/RuneAndRust.Application/Services/ClassService.cs` (Enhanced)

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.DTOs;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages class definitions and player class assignment.
/// </summary>
public class ClassService
{
    private readonly IGameConfigurationProvider _configProvider;
    private readonly ILogger<ClassService> _logger;

    public ClassService(
        IGameConfigurationProvider configProvider,
        ILogger<ClassService> logger)
    {
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        var classCount = _configProvider.GetClasses().Count;
        var archetypeCount = _configProvider.GetArchetypes().Count;

        _logger.LogInformation(
            LogTemplates.ServiceInitializedWithCount,
            nameof(ClassService), classCount, "classes");

        _logger.LogDebug(
            "ClassService loaded {ArchetypeCount} archetypes and {ClassCount} classes",
            archetypeCount, classCount);
    }

    /// <summary>
    /// Gets a class definition by ID.
    /// </summary>
    public ClassDefinition? GetClass(string classId)
    {
        _logger.LogDebug("GetClass called for: {ClassId}", classId);

        var classDef = _configProvider.GetClassById(classId);

        if (classDef == null)
        {
            _logger.LogDebug(LogTemplates.EntityNotFound, "Class", classId);
        }
        else
        {
            _logger.LogDebug(
                "Found class {ClassId}: {ClassName} (Archetype: {ArchetypeId})",
                classId, classDef.Name, classDef.ArchetypeId);
        }

        return classDef;
    }

    /// <summary>
    /// Assigns a class to a player.
    /// </summary>
    public bool AssignClass(Player player, string classId)
    {
        _logger.LogDebug(
            "AssignClass: Player={PlayerName}, ClassId={ClassId}",
            player.Name, classId);

        var classDef = GetClass(classId);
        if (classDef == null)
        {
            _logger.LogWarning(
                LogTemplates.OperationFailed,
                "AssignClass", $"Class '{classId}' not found");
            return false;
        }

        // Check requirements
        if (!MeetsRequirements(player, classDef))
        {
            _logger.LogWarning(
                "Player {PlayerName} does not meet requirements for class {ClassName}",
                player.Name, classDef.Name);
            return false;
        }

        // Assign class
        var archetype = _configProvider.GetArchetypeById(classDef.ArchetypeId);
        player.SetClass(classDef.ArchetypeId, classId);

        _logger.LogInformation(
            "Class assigned: {PlayerName} is now a {ClassName} ({ArchetypeName})",
            player.Name, classDef.Name, archetype?.Name ?? classDef.ArchetypeId);

        return true;
    }

    private bool MeetsRequirements(Player player, ClassDefinition classDef)
    {
        if (!classDef.Requirements.HasRequirements)
        {
            _logger.LogDebug("Class {ClassId} has no requirements", classDef.Id);
            return true;
        }

        var req = classDef.Requirements;
        var attr = player.Attributes;

        var meetsMight = req.MinMight == null || attr.Might >= req.MinMight;
        var meetsFortitude = req.MinFortitude == null || attr.Fortitude >= req.MinFortitude;
        var meetsWill = req.MinWill == null || attr.Will >= req.MinWill;
        var meetsWits = req.MinWits == null || attr.Wits >= req.MinWits;
        var meetsFinesse = req.MinFinesse == null || attr.Finesse >= req.MinFinesse;

        _logger.LogDebug(
            "Requirement check for {PlayerName} on {ClassId}: " +
            "Might={MeetsMight}, Fortitude={MeetsFortitude}, Will={MeetsWill}, " +
            "Wits={MeetsWits}, Finesse={MeetsFinesse}",
            player.Name, classDef.Id,
            meetsMight, meetsFortitude, meetsWill, meetsWits, meetsFinesse);

        return meetsMight && meetsFortitude && meetsWill && meetsWits && meetsFinesse;
    }
}
```

### 4.3 Infrastructure Logging

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs` (Enhanced)

```csharp
// Add to constructor
_logger.LogInformation(
    "JsonConfigurationProvider initialized with config path: {ConfigPath}",
    _configPath);

// Add to LoadConfiguration<T>
private T LoadConfiguration<T>(string fileName) where T : new()
{
    var filePath = Path.Combine(_configPath, fileName);
    _logger.LogDebug("Loading configuration from: {FilePath}", filePath);

    if (!File.Exists(filePath))
    {
        _logger.LogWarning(
            "Configuration file not found: {FilePath}. Using defaults.",
            filePath);
        return new T();
    }

    try
    {
        var json = File.ReadAllText(filePath);
        var config = JsonSerializer.Deserialize<T>(json, _jsonOptions);

        _logger.LogDebug(
            "Successfully loaded configuration: {FileName} ({Size} bytes)",
            fileName, json.Length);

        return config ?? new T();
    }
    catch (JsonException ex)
    {
        _logger.LogError(ex,
            "Failed to parse configuration file: {FilePath}",
            filePath);
        throw;
    }
}
```

---

## 5. Configuration

### 5.1 appsettings.json Schema

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/appsettings.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information",
      "RuneAndRust": "Debug",
      "RuneAndRust.Domain": "Information",
      "RuneAndRust.Application": "Debug",
      "RuneAndRust.Infrastructure": "Information",
      "RuneAndRust.Presentation": "Information"
    },
    "Console": {
      "FormatterName": "simple",
      "FormatterOptions": {
        "SingleLine": true,
        "TimestampFormat": "HH:mm:ss ",
        "IncludeScopes": true
      }
    },
    "File": {
      "Path": "logs/runeandrust.log",
      "RollingInterval": "Day",
      "FileSizeLimitBytes": 10485760,
      "RetainedFileCountLimit": 7
    }
  }
}
```

### 5.2 Log Output Formats

#### Console Output (Development)
```
12:34:56 [INF] GameSessionService: Starting new game for player: TestPlayer
12:34:56 [DBG] GameSessionService: Initial game state - Player: TestPlayer, Health: 100/100
12:34:57 [INF] [Op:a1b2c3d4] Player moved North: Entrance Hall -> Dark Corridor
12:34:58 [INF] [Op:a1b2c3d4] Combat initiated: TestPlayer vs Goblin
12:34:58 [DBG] [Op:a1b2c3d4] Combat: Dealt 12 damage, received 5 damage
```

#### File Output (Production)
```json
{"Timestamp":"2026-01-07T12:34:56.789Z","Level":"Information","Message":"Starting new game for player: TestPlayer","Properties":{"PlayerName":"TestPlayer","SourceContext":"RuneAndRust.Application.Services.GameSessionService"}}
{"Timestamp":"2026-01-07T12:34:57.123Z","Level":"Information","Message":"Player moved North","Properties":{"OperationId":"a1b2c3d4","Direction":"North","FromRoom":"Entrance Hall","ToRoom":"Dark Corridor"}}
```

### 5.3 Logging Configuration Helper

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Logging/LoggingConfiguration.cs`

```csharp
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace RuneAndRust.Infrastructure.Logging;

/// <summary>
/// Configures logging for the application.
/// </summary>
public static class LoggingConfiguration
{
    /// <summary>
    /// Adds configured logging to the service collection.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="configuration">The configuration.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddRuneAndRustLogging(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        services.AddLogging(builder =>
        {
            builder.ClearProviders();
            builder.AddConfiguration(configuration.GetSection("Logging"));
            builder.AddConsole();

            // Add file logging if configured
            var fileConfig = configuration.GetSection("Logging:File");
            if (fileConfig.Exists())
            {
                var filePath = fileConfig["Path"] ?? "logs/runeandrust.log";
                builder.AddFile(filePath, options =>
                {
                    options.FileSizeLimitBytes = fileConfig.GetValue<long?>("FileSizeLimitBytes");
                    options.RetainedFileCountLimit = fileConfig.GetValue<int?>("RetainedFileCountLimit");
                });
            }
        });

        return services;
    }
}
```

---

## 6. Performance Logging

### 6.1 Performance Scope

For tracking performance of key operations:

**File:** `src/Core/RuneAndRust.Application/Logging/PerformanceScope.cs`

```csharp
using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace RuneAndRust.Application.Logging;

/// <summary>
/// Provides automatic performance logging for operations.
/// </summary>
public class PerformanceScope : IDisposable
{
    private readonly ILogger _logger;
    private readonly string _operationName;
    private readonly Stopwatch _stopwatch;
    private readonly LogLevel _logLevel;
    private readonly long _warningThresholdMs;

    /// <summary>
    /// Creates a new performance scope.
    /// </summary>
    /// <param name="logger">The logger to use.</param>
    /// <param name="operationName">The name of the operation being measured.</param>
    /// <param name="logLevel">The log level for normal completion (default: Debug).</param>
    /// <param name="warningThresholdMs">Threshold in ms above which a warning is logged (default: 1000).</param>
    public PerformanceScope(
        ILogger logger,
        string operationName,
        LogLevel logLevel = LogLevel.Debug,
        long warningThresholdMs = 1000)
    {
        _logger = logger;
        _operationName = operationName;
        _logLevel = logLevel;
        _warningThresholdMs = warningThresholdMs;
        _stopwatch = Stopwatch.StartNew();

        _logger.LogTrace("Starting operation: {Operation}", operationName);
    }

    /// <inheritdoc />
    public void Dispose()
    {
        _stopwatch.Stop();
        var elapsed = _stopwatch.ElapsedMilliseconds;

        if (elapsed > _warningThresholdMs)
        {
            _logger.LogWarning(
                "Operation {Operation} took {ElapsedMs}ms (threshold: {ThresholdMs}ms)",
                _operationName, elapsed, _warningThresholdMs);
        }
        else
        {
            _logger.Log(_logLevel,
                "Operation {Operation} completed in {ElapsedMs}ms",
                _operationName, elapsed);
        }
    }
}
```

### 6.2 Usage Example

```csharp
public async Task<GameStateDto> StartNewGameAsync(string playerName, CancellationToken ct = default)
{
    using var perfScope = new PerformanceScope(_logger, "StartNewGame");

    _logger.LogInformation("Starting new game for player: {PlayerName}", playerName);

    _currentSession = GameSession.CreateNew(playerName);
    await _repository.SaveAsync(_currentSession, ct);

    return _currentSession.ToDto();
}
```

---

## 7. Logging Extension Methods

**File:** `src/Core/RuneAndRust.Application/Logging/LoggerExtensions.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.Logging;

/// <summary>
/// Extension methods for common logging patterns.
/// </summary>
public static class LoggerExtensions
{
    /// <summary>
    /// Logs player action with context.
    /// </summary>
    public static void LogPlayerAction(
        this ILogger logger,
        Player player,
        string action,
        string? target = null,
        string? result = null)
    {
        if (target != null && result != null)
        {
            logger.LogInformation(
                "Player {PlayerName} {Action} {Target}: {Result}",
                player.Name, action, target, result);
        }
        else if (target != null)
        {
            logger.LogInformation(
                "Player {PlayerName} {Action} {Target}",
                player.Name, action, target);
        }
        else
        {
            logger.LogInformation(
                "Player {PlayerName} {Action}",
                player.Name, action);
        }
    }

    /// <summary>
    /// Logs combat event with full context.
    /// </summary>
    public static void LogCombat(
        this ILogger logger,
        Player player,
        Monster monster,
        int damageDealt,
        int damageReceived,
        bool monsterDefeated,
        bool playerDefeated)
    {
        logger.LogInformation(
            "Combat: {PlayerName} vs {MonsterName} - " +
            "Dealt: {DamageDealt}, Received: {DamageReceived}, " +
            "MonsterDefeated: {MonsterDefeated}, PlayerDefeated: {PlayerDefeated}",
            player.Name, monster.Name,
            damageDealt, damageReceived,
            monsterDefeated, playerDefeated);
    }

    /// <summary>
    /// Logs state change with before/after values.
    /// </summary>
    public static void LogStateChange<T>(
        this ILogger logger,
        string entityType,
        object entityId,
        string propertyName,
        T oldValue,
        T newValue)
    {
        logger.LogInformation(
            "{EntityType} {EntityId} {PropertyName} changed: {OldValue} -> {NewValue}",
            entityType, entityId, propertyName, oldValue, newValue);
    }

    /// <summary>
    /// Creates a performance scope for the operation.
    /// </summary>
    public static PerformanceScope BeginPerformanceScope(
        this ILogger logger,
        string operationName,
        LogLevel logLevel = LogLevel.Debug,
        long warningThresholdMs = 1000)
    {
        return new PerformanceScope(logger, operationName, logLevel, warningThresholdMs);
    }
}
```

---

## 8. Test Support

### 8.1 Test Logger

For verifying logging in unit tests:

**File:** `tests/RuneAndRust.TestUtilities/Logging/TestLogger.cs`

```csharp
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;

namespace RuneAndRust.TestUtilities.Logging;

/// <summary>
/// Logger implementation that captures log entries for testing.
/// </summary>
/// <typeparam name="T">The category type.</typeparam>
public class TestLogger<T> : ILogger<T>
{
    private readonly ConcurrentQueue<LogEntry> _entries = new();

    /// <summary>
    /// Gets all captured log entries.
    /// </summary>
    public IReadOnlyList<LogEntry> Entries => _entries.ToList();

    /// <summary>
    /// Gets entries at a specific log level.
    /// </summary>
    public IEnumerable<LogEntry> GetEntries(LogLevel level) =>
        _entries.Where(e => e.Level == level);

    /// <summary>
    /// Checks if any entry contains the specified message fragment.
    /// </summary>
    public bool ContainsMessage(string fragment) =>
        _entries.Any(e => e.Message.Contains(fragment, StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Clears all captured entries.
    /// </summary>
    public void Clear() => _entries.Clear();

    /// <inheritdoc />
    public IDisposable? BeginScope<TState>(TState state) where TState : notnull =>
        new TestScope();

    /// <inheritdoc />
    public bool IsEnabled(LogLevel logLevel) => true;

    /// <inheritdoc />
    public void Log<TState>(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception? exception,
        Func<TState, Exception?, string> formatter)
    {
        _entries.Enqueue(new LogEntry(
            logLevel,
            formatter(state, exception),
            exception,
            DateTime.UtcNow));
    }

    private class TestScope : IDisposable
    {
        public void Dispose() { }
    }
}

/// <summary>
/// Represents a captured log entry.
/// </summary>
public record LogEntry(
    LogLevel Level,
    string Message,
    Exception? Exception,
    DateTime Timestamp);
```

### 8.2 Test Logger Factory

**File:** `tests/RuneAndRust.TestUtilities/Logging/TestLoggerFactory.cs`

```csharp
using Microsoft.Extensions.Logging;

namespace RuneAndRust.TestUtilities.Logging;

/// <summary>
/// Factory for creating test loggers.
/// </summary>
public class TestLoggerFactory : ILoggerFactory
{
    private readonly Dictionary<Type, object> _loggers = new();

    /// <summary>
    /// Gets a test logger for the specified type.
    /// </summary>
    public TestLogger<T> GetTestLogger<T>()
    {
        var type = typeof(T);
        if (!_loggers.TryGetValue(type, out var logger))
        {
            logger = new TestLogger<T>();
            _loggers[type] = logger;
        }
        return (TestLogger<T>)logger;
    }

    /// <inheritdoc />
    public ILogger CreateLogger(string categoryName) =>
        new TestLogger<object>();

    /// <inheritdoc />
    public void AddProvider(ILoggerProvider provider) { }

    /// <inheritdoc />
    public void Dispose() { }
}
```

---

## 9. Acceptance Criteria

### 9.1 Functional Requirements

- [ ] All services have ILogger<T> injected
- [ ] All services log at appropriate levels (Information for key operations, Debug for details)
- [ ] Log messages use structured logging with semantic properties
- [ ] Operation correlation tracks related operations
- [ ] Performance logging identifies slow operations
- [ ] Configuration file controls log levels
- [ ] File logging writes to configured path
- [ ] Console logging shows readable output

### 9.2 Non-Functional Requirements

- [ ] Logging has minimal performance impact (<5% overhead)
- [ ] Log messages follow consistent templates
- [ ] Test utilities enable log verification in unit tests
- [ ] Documentation describes logging standards

---

## 10. Test Specifications

### 10.1 Logging Infrastructure Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `TestLogger_CapturesLogEntries` | Verify test logger captures entries |
| `TestLogger_FiltersByLevel` | Verify level filtering works |
| `TestLogger_ContainsMessage_FindsFragment` | Verify message search |
| `PerformanceScope_LogsElapsedTime` | Verify timing is logged |
| `PerformanceScope_WarnsOnSlowOperation` | Verify warning threshold |

### 10.2 Operation Scope Tests (~4 tests)

| Test Name | Description |
|-----------|-------------|
| `OperationScope_GeneratesUniqueId` | Each scope has unique ID |
| `OperationScope_TracksSessionId` | Session ID is included |
| `OperationScope_BeginOperation_CreatesScope` | Scope creation works |
| `OperationScope_NestedOperations_TrackDepth` | Nesting tracked correctly |

### 10.3 Service Logging Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `GameSessionService_LogsNewGame` | New game logged at Information |
| `GameSessionService_LogsMove` | Movement logged correctly |
| `CombatService_LogsCombatRound` | Combat details logged |
| `ClassService_LogsClassAssignment` | Class assignment logged |
| `ConfigurationProvider_LogsFileLoad` | File loading logged |
| `ConfigurationProvider_LogsFileNotFound` | Missing file warning logged |

---

## 11. Dependencies

### 11.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| Microsoft.Extensions.Logging | Latest | Complete | Already in use |
| All application services | v0.0.9 | Complete | Services exist |
| Configuration system | v0.0.3 | Complete | appsettings.json |

### 11.2 External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Microsoft.Extensions.Logging | 9.0.x | Core logging abstractions |
| Microsoft.Extensions.Logging.Console | 9.0.x | Console output |
| Microsoft.Extensions.Logging.Configuration | 9.0.x | Config binding |

---

## 12. Files Summary

### 12.1 New Files

| File | Purpose |
|------|---------|
| `src/Core/RuneAndRust.Application/Interfaces/IOperationScope.cs` | Operation correlation interface |
| `src/Core/RuneAndRust.Application/Services/OperationScope.cs` | Correlation implementation |
| `src/Core/RuneAndRust.Application/Logging/LogTemplates.cs` | Standard log templates |
| `src/Core/RuneAndRust.Application/Logging/LoggerExtensions.cs` | Logging helper extensions |
| `src/Core/RuneAndRust.Application/Logging/PerformanceScope.cs` | Performance timing |
| `src/Infrastructure/RuneAndRust.Infrastructure/Logging/LoggingConfiguration.cs` | Configuration helper |
| `src/Presentation/RuneAndRust.Presentation.Tui/appsettings.json` | Logging configuration |
| `tests/RuneAndRust.TestUtilities/Logging/TestLogger.cs` | Test logger |
| `tests/RuneAndRust.TestUtilities/Logging/TestLoggerFactory.cs` | Test logger factory |
| `tests/RuneAndRust.Application.UnitTests/Logging/LoggingTests.cs` | Logging tests |

### 12.2 Modified Files

| File | Changes |
|------|---------|
| `ClassService.cs` | Enhanced logging throughout |
| `DescriptorService.cs` | Add comprehensive logging |
| `LexiconService.cs` | Add comprehensive logging |
| `PlayerCreationService.cs` | Add comprehensive logging |
| `InputValidationService.cs` | Add comprehensive logging |
| `ItemEffectService.cs` | Add comprehensive logging |
| `JsonConfigurationProvider.cs` | Add file operation logging |
| `InMemoryGameRepository.cs` | Add CRUD logging |
| `DependencyInjection.cs` | Register logging services |

---

## 13. Future Considerations

### 13.1 v0.0.10b Preparation

Test utilities created here will be used for:
- Verifying services log expected messages
- Testing error handling produces appropriate logs

### 13.2 External Logging (Future)

The infrastructure is designed to easily add:
- Application Insights sink
- Seq sink
- Serilog integration
- Structured log shipping

---

*This design specification establishes consistent logging patterns across the application, enabling observability and debugging while maintaining code quality and testability.*
