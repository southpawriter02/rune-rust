# v0.9.0a Design Specification: Core Audio Service

**Version:** 0.9.0a
**Parent:** v0.9.0 (Audio Foundation)
**Prerequisites:** v0.8.3c Complete (Combat Summary)
**Status:** Design Complete
**Estimated Unit Tests:** ~8

---

## 1. Overview

### Purpose

Implement the core audio service providing audio playback capabilities for the entire application. Includes `IAudioService` interface, `AudioService` implementation, audio channel management for separate volume control (Master, Music, Effects, UI, Voice), and `AudioCache` for efficient file reuse with LRU eviction.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | `IAudioService` |
| **Services** | `AudioService` |
| **Support Classes** | `AudioCache`, `AudioPlayback`, `CachedAudio` |
| **Enums** | `AudioChannel` |
| **Configuration** | `audio.json` schema |
| **Tests** | ~8 unit tests |

---

## 2. Feature Overview

```
v0.9.0a Features
├── IAudioService Interface
│   ├── Play(path, channel, volume, loop) → Guid
│   ├── Stop/Pause/Resume by playback ID
│   ├── Stop/Pause/Resume by channel
│   ├── StopAll()
│   ├── SetChannelVolume(channel, volume)
│   ├── GetChannelVolume(channel)
│   ├── SetChannelMuted(channel, muted)
│   ├── IsChannelMuted(channel)
│   ├── PreloadAsync(paths)
│   ├── ClearCache()
│   ├── IsEnabled / SetEnabled()
│   └── Dispose()
│
├── AudioChannel Enum
│   ├── Master (affects all)
│   ├── Music (background)
│   ├── Effects (combat/game SFX)
│   ├── UI (interface sounds)
│   └── Voice (dialogue/future)
│
├── AudioService Implementation
│   ├── Channel volume tracking
│   ├── Effective volume calculation
│   ├── Active playback management
│   ├── Mute per channel + global
│   └── Resource cleanup
│
├── AudioCache
│   ├── LRU cache (max 50 files)
│   ├── GetOrLoad pattern
│   ├── Eviction on full
│   └── Preload support
│
└── File Format Support
    ├── OGG (recommended)
    ├── WAV
    └── MP3
```

---

## 3. Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────┤
│  IAudioService : IDisposable                                           │
│  ├── Play, Stop, Pause, Resume                                         │
│  ├── SetChannelVolume, GetChannelVolume                                │
│  ├── SetChannelMuted, IsChannelMuted                                   │
│  ├── PreloadAsync, ClearCache                                          │
│  └── IsEnabled, SetEnabled                                             │
│                                                                         │
│  AudioChannel (Enum)                                                   │
│  └── Master, Music, Effects, UI, Voice                                 │
└─────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                       INFRASTRUCTURE LAYER                              │
├─────────────────────────────────────────────────────────────────────────┤
│  AudioService : IAudioService                                          │
│  ├── _channelVolumes: Dictionary<AudioChannel, float>                  │
│  ├── _channelMuted: Dictionary<AudioChannel, bool>                     │
│  ├── _activePlaybacks: Dictionary<Guid, AudioPlayback>                 │
│  ├── _cache: AudioCache                                                │
│  └── _isEnabled: bool                                                  │
│                                                                         │
│  AudioCache                                                             │
│  ├── _cache: Dictionary<string, CachedAudio>                           │
│  ├── _accessOrder: LinkedList<string> (LRU tracking)                   │
│  └── _maxSize: int (default 50)                                        │
│                                                                         │
│  AudioPlayback                                                          │
│  ├── Id: Guid                                                          │
│  ├── Channel: AudioChannel                                             │
│  ├── Volume: float                                                     │
│  ├── IsLooping: bool                                                   │
│  ├── IsPaused: bool                                                    │
│  └── Start(), Stop(), Pause(), Resume()                                │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. IAudioService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IAudioService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Core audio playback service for the application.
/// </summary>
public interface IAudioService : IDisposable
{
    /// <summary>Plays an audio file on a channel.</summary>
    /// <param name="audioPath">Path to the audio file.</param>
    /// <param name="channel">Channel to play on.</param>
    /// <param name="volume">Volume multiplier (0.0-1.0).</param>
    /// <param name="loop">Whether to loop the audio.</param>
    /// <returns>Playback ID for control, or Guid.Empty if failed.</returns>
    Guid Play(string audioPath, AudioChannel channel, float volume = 1.0f, bool loop = false);

    /// <summary>Stops playback by ID.</summary>
    void Stop(Guid playbackId);

    /// <summary>Stops all playback on a channel.</summary>
    void StopChannel(AudioChannel channel);

    /// <summary>Stops all playback.</summary>
    void StopAll();

    /// <summary>Pauses playback by ID.</summary>
    void Pause(Guid playbackId);

    /// <summary>Pauses all playback on a channel.</summary>
    void PauseChannel(AudioChannel channel);

    /// <summary>Resumes paused playback by ID.</summary>
    void Resume(Guid playbackId);

    /// <summary>Resumes all paused playback on a channel.</summary>
    void ResumeChannel(AudioChannel channel);

    /// <summary>Sets volume for a channel (0.0-1.0).</summary>
    void SetChannelVolume(AudioChannel channel, float volume);

    /// <summary>Gets current volume for a channel.</summary>
    float GetChannelVolume(AudioChannel channel);

    /// <summary>Sets mute state for a channel.</summary>
    void SetChannelMuted(AudioChannel channel, bool muted);

    /// <summary>Gets mute state for a channel.</summary>
    bool IsChannelMuted(AudioChannel channel);

    /// <summary>Preloads audio files into cache.</summary>
    Task PreloadAsync(IEnumerable<string> audioPaths, CancellationToken ct = default);

    /// <summary>Clears the audio cache.</summary>
    void ClearCache();

    /// <summary>Gets whether audio is currently enabled.</summary>
    bool IsEnabled { get; }

    /// <summary>Enables or disables all audio.</summary>
    void SetEnabled(bool enabled);
}
```

---

## 5. AudioChannel Enum

**File:** `src/Core/RuneAndRust.Application/Enums/AudioChannel.cs`

```csharp
namespace RuneAndRust.Application.Enums;

/// <summary>
/// Audio channels for separate volume control.
/// </summary>
public enum AudioChannel
{
    /// <summary>Master volume affecting all channels.</summary>
    Master,

    /// <summary>Background music.</summary>
    Music,

    /// <summary>Combat and game sound effects.</summary>
    Effects,

    /// <summary>UI interaction sounds.</summary>
    UI,

    /// <summary>Voice/dialogue audio (future).</summary>
    Voice
}
```

---

## 6. AudioService Implementation

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Services/AudioService.cs`

```csharp
namespace RuneAndRust.Infrastructure.Services;

public class AudioService : IAudioService
{
    private readonly ILogger<AudioService> _logger;
    private readonly AudioCache _cache;
    private readonly Dictionary<AudioChannel, float> _channelVolumes;
    private readonly Dictionary<AudioChannel, bool> _channelMuted;
    private readonly Dictionary<Guid, AudioPlayback> _activePlaybacks;
    private bool _isEnabled = true;
    private bool _disposed;

    public bool IsEnabled => _isEnabled;

    public AudioService(ILogger<AudioService> logger, int cacheSize = 50)
    {
        _logger = logger;
        _cache = new AudioCache(cacheSize);
        _channelVolumes = InitializeDefaultVolumes();
        _channelMuted = InitializeDefaultMutes();
        _activePlaybacks = new Dictionary<Guid, AudioPlayback>();
        _logger.LogInformation("AudioService initialized with cache size {Size}", cacheSize);
    }

    public Guid Play(string audioPath, AudioChannel channel, float volume = 1.0f, bool loop = false)
    {
        if (!_isEnabled || _channelMuted[AudioChannel.Master] || _channelMuted[channel])
        {
            _logger.LogDebug("Audio disabled/muted, skipping: {Path}", audioPath);
            return Guid.Empty;
        }

        var audioData = _cache.GetOrLoad(audioPath);
        if (audioData is null)
        {
            _logger.LogWarning("Failed to load audio: {Path}", audioPath);
            return Guid.Empty;
        }

        var effectiveVolume = CalculateEffectiveVolume(channel, volume);
        var playbackId = Guid.NewGuid();
        var playback = new AudioPlayback(playbackId, channel, audioData, effectiveVolume, loop);
        _activePlaybacks[playbackId] = playback;
        playback.Start();

        _logger.LogDebug("Playing: {Path} on {Channel} at {Vol}", audioPath, channel, effectiveVolume);
        return playbackId;
    }

    public void Stop(Guid playbackId)
    {
        if (_activePlaybacks.TryGetValue(playbackId, out var playback))
        {
            playback.Stop();
            _activePlaybacks.Remove(playbackId);
            _logger.LogDebug("Stopped playback: {Id}", playbackId);
        }
    }

    public void StopChannel(AudioChannel channel)
    {
        var toStop = _activePlaybacks.Where(p => p.Value.Channel == channel).ToList();
        foreach (var (id, playback) in toStop)
        {
            playback.Stop();
            _activePlaybacks.Remove(id);
        }
        _logger.LogDebug("Stopped {Count} playbacks on {Channel}", toStop.Count, channel);
    }

    public void StopAll()
    {
        foreach (var playback in _activePlaybacks.Values) playback.Stop();
        _activePlaybacks.Clear();
        _logger.LogDebug("Stopped all playbacks");
    }

    public void Pause(Guid playbackId)
    {
        if (_activePlaybacks.TryGetValue(playbackId, out var playback))
            playback.Pause();
    }

    public void PauseChannel(AudioChannel channel)
    {
        foreach (var playback in _activePlaybacks.Values.Where(p => p.Channel == channel))
            playback.Pause();
    }

    public void Resume(Guid playbackId)
    {
        if (_activePlaybacks.TryGetValue(playbackId, out var playback))
            playback.Resume();
    }

    public void ResumeChannel(AudioChannel channel)
    {
        foreach (var playback in _activePlaybacks.Values.Where(p => p.Channel == channel))
            playback.Resume();
    }

    public void SetChannelVolume(AudioChannel channel, float volume)
    {
        _channelVolumes[channel] = Math.Clamp(volume, 0f, 1f);
        UpdateActivePlaybackVolumes(channel);
        _logger.LogDebug("Set {Channel} volume to {Vol}", channel, volume);
    }

    public float GetChannelVolume(AudioChannel channel) =>
        _channelVolumes.GetValueOrDefault(channel, 1.0f);

    public void SetChannelMuted(AudioChannel channel, bool muted)
    {
        _channelMuted[channel] = muted;
        if (channel == AudioChannel.Master && muted) PauseAll();
        else if (channel == AudioChannel.Master && !muted) ResumeAll();
        _logger.LogDebug("Set {Channel} muted = {Muted}", channel, muted);
    }

    public bool IsChannelMuted(AudioChannel channel) =>
        _channelMuted.GetValueOrDefault(channel, false);

    public async Task PreloadAsync(IEnumerable<string> audioPaths, CancellationToken ct = default)
    {
        foreach (var path in audioPaths)
        {
            ct.ThrowIfCancellationRequested();
            _cache.GetOrLoad(path);
        }
        _logger.LogDebug("Preloaded audio files");
    }

    public void ClearCache() => _cache.Clear();

    public void SetEnabled(bool enabled)
    {
        _isEnabled = enabled;
        if (!enabled) StopAll();
        _logger.LogInformation("Audio enabled = {Enabled}", enabled);
    }

    private float CalculateEffectiveVolume(AudioChannel channel, float baseVolume) =>
        _channelVolumes[AudioChannel.Master] * _channelVolumes[channel] * baseVolume;

    private void UpdateActivePlaybackVolumes(AudioChannel channel)
    {
        var affected = channel == AudioChannel.Master
            ? _activePlaybacks.Values
            : _activePlaybacks.Values.Where(p => p.Channel == channel);
        foreach (var p in affected)
            p.SetVolume(CalculateEffectiveVolume(p.Channel, p.BaseVolume));
    }

    private void PauseAll() { foreach (var p in _activePlaybacks.Values) p.Pause(); }
    private void ResumeAll() { foreach (var p in _activePlaybacks.Values) p.Resume(); }

    private Dictionary<AudioChannel, float> InitializeDefaultVolumes() => new()
    {
        [AudioChannel.Master] = 0.8f, [AudioChannel.Music] = 0.6f,
        [AudioChannel.Effects] = 0.8f, [AudioChannel.UI] = 0.7f, [AudioChannel.Voice] = 0.9f
    };

    private Dictionary<AudioChannel, bool> InitializeDefaultMutes() => new()
    {
        [AudioChannel.Master] = false, [AudioChannel.Music] = false,
        [AudioChannel.Effects] = false, [AudioChannel.UI] = false, [AudioChannel.Voice] = false
    };

    public void Dispose()
    {
        if (_disposed) return;
        StopAll();
        _cache.Clear();
        _disposed = true;
        _logger.LogInformation("AudioService disposed");
    }
}
```

---

## 7. AudioCache

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Services/AudioCache.cs`

```csharp
namespace RuneAndRust.Infrastructure.Services;

/// <summary>Caches loaded audio files with LRU eviction.</summary>
public class AudioCache
{
    private readonly int _maxSize;
    private readonly Dictionary<string, CachedAudio> _cache;
    private readonly LinkedList<string> _accessOrder;

    public AudioCache(int maxSize = 50)
    {
        _maxSize = maxSize;
        _cache = new Dictionary<string, CachedAudio>();
        _accessOrder = new LinkedList<string>();
    }

    public CachedAudio? GetOrLoad(string path)
    {
        if (_cache.TryGetValue(path, out var cached))
        {
            _accessOrder.Remove(path);
            _accessOrder.AddFirst(path);
            return cached;
        }

        var audio = LoadAudioFile(path);
        if (audio is null) return null;

        while (_cache.Count >= _maxSize)
        {
            var oldest = _accessOrder.Last!.Value;
            _accessOrder.RemoveLast();
            _cache[oldest].Dispose();
            _cache.Remove(oldest);
        }

        _cache[path] = audio;
        _accessOrder.AddFirst(path);
        return audio;
    }

    private CachedAudio? LoadAudioFile(string path)
    {
        if (!File.Exists(path)) return null;
        return new CachedAudio(path); // NAudio implementation
    }

    public void Clear()
    {
        foreach (var audio in _cache.Values) audio.Dispose();
        _cache.Clear();
        _accessOrder.Clear();
    }
}

public class CachedAudio : IDisposable
{
    public string Path { get; }
    // NAudio: AudioFileReader or similar
    public CachedAudio(string path) => Path = path;
    public void Dispose() { /* Release audio resources */ }
}
```

---

## 8. Default Volume Configuration

```json
{
  "audio": {
    "enabled": true,
    "channels": {
      "master": 0.8,
      "music": 0.6,
      "effects": 0.8,
      "ui": 0.7,
      "voice": 0.9
    },
    "muted": {
      "master": false,
      "music": false,
      "effects": false,
      "ui": false,
      "voice": false
    }
  }
}
```

---

## 9. Unit Testing Requirements (~8 tests)

| Feature | Tests |
|---------|-------|
| Play returns valid Guid | 1 |
| Play returns Empty when muted | 1 |
| SetChannelVolume clamps 0-1 | 1 |
| CalculateEffectiveVolume | 1 |
| StopAll clears playbacks | 1 |
| AudioCache GetOrLoad caches | 1 |
| AudioCache LRU eviction | 1 |
| SetEnabled(false) stops all | 1 |

---

## 10. Acceptance Criteria

- [ ] AudioService can play audio files
- [ ] Play returns controllable playback ID
- [ ] Stop/Pause/Resume work by ID
- [ ] Stop/Pause/Resume work by channel
- [ ] StopAll stops everything
- [ ] Five channels supported (Master, Music, Effects, UI, Voice)
- [ ] SetChannelVolume works (0.0-1.0)
- [ ] Master volume affects all channels
- [ ] Mute works per channel
- [ ] Master mute mutes everything
- [ ] AudioCache caches loaded files
- [ ] LRU eviction at max size (50)
- [ ] PreloadAsync loads files into cache
- [ ] SetEnabled(false) stops all audio
- [ ] Dispose cleans up resources
- [ ] ~8 unit tests pass

---

## 11. Dependencies

| From | Required |
|------|----------|
| External | NAudio (or cross-platform equivalent) |
| Domain | File system access |
| Infrastructure | ILogger |

---

## 12. Future Considerations

**Deferred:** Cross-fade between tracks, positional audio, audio compression, streaming large files, dynamic audio mixing.

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
