# v0.6.2a Design Specification: Combat Grid View

**Version:** 0.6.2a
**Parent:** v0.6.2 (Combat Display)
**Prerequisites:** v0.6.1d Complete (Inventory Grid)
**Status:** Design Complete

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [CombatGridView Component](#4-combatgridview-component)
5. [CombatantListPanel Component](#5-combatantlistpanel-component)
6. [TurnInfoBar Component](#6-turninfobar-component)
7. [Data Model](#7-data-model)
8. [Configuration](#8-configuration)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Use Cases](#11-use-cases)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Dependencies](#14-dependencies)
15. [Future Considerations](#15-future-considerations)

---

## 1. Executive Summary

### Purpose

The Combat Grid View implements an enhanced tactical combat display that integrates with the screen layout system. The view consists of three coordinated components: a main grid panel showing the tactical map with entities and terrain, a sidebar panel listing all combatants with their health bars and status effects, and a footer bar showing turn information and available actions.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Components** | CombatGridView, CombatantListPanel, TurnInfoBar |
| **Enums** | HighlightType |
| **Panel Configurations** | Combat layout with 3 panels |
| **Tests** | ~15 new unit tests |

### Architectural Significance

This version establishes the **Combat UI Integration Pattern** that combines multiple visual components:
- Grid-based tactical display with coordinate labels
- Real-time combatant status tracking
- Turn order and action economy visualization
- Cell highlighting for movement/attack ranges

---

## 2. Feature Overview

```
v0.6.2a Features
â”œâ”€â”€ CombatGridView Component
â”‚   â”œâ”€â”€ Grid panel with 8x8 cells
â”‚   â”œâ”€â”€ Coordinate labels (A-H, 1-8)
â”‚   â”œâ”€â”€ Entity position markers (@, M)
â”‚   â”œâ”€â”€ Terrain type indicators (., ~, #)
â”‚   â”œâ”€â”€ Cell highlighting (movement, attack, ability)
â”‚   â”œâ”€â”€ Selected cell indicator
â”‚   â””â”€â”€ Grid legend display
â”œâ”€â”€ CombatantListPanel Component
â”‚   â”œâ”€â”€ Combatant list in turn order
â”‚   â”œâ”€â”€ HP bars per combatant
â”‚   â”œâ”€â”€ MP/resource bars
â”‚   â”œâ”€â”€ Status effect icons
â”‚   â”œâ”€â”€ Current turn indicator (â–º)
â”‚   â””â”€â”€ Level/class display
â”œâ”€â”€ TurnInfoBar Component
â”‚   â”œâ”€â”€ Round number display
â”‚   â”œâ”€â”€ Current turn entity name
â”‚   â”œâ”€â”€ Action point indicator
â”‚   â”œâ”€â”€ Move point indicator
â”‚   â””â”€â”€ Bonus action indicator
â””â”€â”€ Integration
    â””â”€â”€ CombatService display hooks
```

---

## 3. Architecture Diagrams

### 3.1 Combat Grid View Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   COMBAT GRID VIEW ARCHITECTURE                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    DOMAIN                       APPLICATION                PRESENTATION
    â”€â”€â”€â”€â”€â”€                       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ CombatState â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  CombatService   â”‚â”€â”€â”€â–¶â”‚ CombatGridView â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Grid        â”‚            â”‚ ExecuteAction()  â”‚    â”‚ Render()       â”‚
    â”‚ Combatants  â”‚            â”‚ GetValidMoves()  â”‚    â”‚ HighlightCells()
    â”‚ TurnOrder   â”‚            â”‚ GetValidTargets()â”‚    â”‚ SetSelectedCell()
    â”‚ Round       â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
          â–²                                                     â”‚
          â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                                    â–¼                â–¼                â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ CombatGrid  â”‚                  â”‚ GridPanel    â”‚  â”‚CombatantList â”‚  â”‚ TurnInfoBar  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚ (Main area)  â”‚  â”‚ (Sidebar)    â”‚  â”‚ (Footer)     â”‚
    â”‚ Cells[,]    â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ GetCell()   â”‚                  â”‚ RenderGrid() â”‚  â”‚ RenderList() â”‚  â”‚ RenderInfo() â”‚
    â”‚ GetEntities â”‚                  â”‚ RenderLabels()â”‚ â”‚ RenderHealth()â”‚ â”‚ RenderActions()
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚ RenderTerrain() â”‚ RenderStatus()â”‚ â”‚ RenderMove() â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Combat View Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              COMBAT GRID VIEW                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              COMBAT GRID               â”‚           COMBATANTS                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                        â”‚                                       â”‚
â”‚      A   B   C   D   E   F   G   H     â”‚  â–º @ Hero        Lv5 Warrior         â”‚
â”‚    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”   â”‚    HP â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘  80/100       â”‚
â”‚  1 â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚   â”‚    MP â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  30/50        â”‚
â”‚    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   â”‚    [Defensive Stance]                â”‚
â”‚  2 â”‚ . â”‚ . â”‚ M â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚   â”‚                                       â”‚
â”‚    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   â”‚    M Skeleton     HP â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘  15/30 â”‚
â”‚  3 â”‚ . â”‚ . â”‚ . â”‚ . â”‚ @ â”‚ . â”‚ . â”‚ . â”‚   â”‚      [Poisoned] ğŸŸ¢                    â”‚
â”‚    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   â”‚                                       â”‚
â”‚  4 â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚   â”‚    M Goblin       HP â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  20/20 â”‚
â”‚    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   â”‚                                       â”‚
â”‚  5 â”‚ . â”‚ ~ â”‚ ~ â”‚ ~ â”‚ . â”‚ M â”‚ . â”‚ . â”‚   â”‚    M Goblin       HP â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘  15/20 â”‚
â”‚    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   â”‚                                       â”‚
â”‚  6 â”‚ . â”‚ . â”‚ ~ â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚   â”‚                                       â”‚
â”‚    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   â”‚                                       â”‚
â”‚  7 â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚   â”‚                                       â”‚
â”‚    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   â”‚                                       â”‚
â”‚  8 â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚ . â”‚   â”‚                                       â”‚
â”‚    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜   â”‚                                       â”‚
â”‚                                        â”‚  â–º = Current Turn                     â”‚
â”‚  Legend: @ = You  M = Monster          â”‚  ğŸŸ¢ = Status Effect                   â”‚
â”‚          . = Open  ~ = Water           â”‚                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Round 3  |  YOUR TURN  |  Action: âœ“ Available  |  Move: 4/4  |  Bonus: âœ“     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 Cell Highlighting System

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CELL HIGHLIGHTING SYSTEM                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    HighlightType.Movement (Blue):
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚   â”‚     â–‘ = Valid move (Blue)
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤     @ = Player
    â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚ @ â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚ M â”‚     (Cannot move through M)
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚â–‘â–‘â–‘â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜


    HighlightType.Attack (Red):
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤     â–“ = Attack range (Red)
    â”‚   â”‚â–“â–“â–“â”‚â–“â–“â–“â”‚â–“â–“â–“â”‚   â”‚     @ = Player
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚â–“â–“â–“â”‚ @ â”‚â–“â–“â–“â”‚   â”‚     Melee: Adjacent cells
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚â–“â–“â–“â”‚â–“â–“â–“â”‚â–“â–“â–“â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜


    HighlightType.Ability (Purple):
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤     â—Š = AoE effect area (Purple)
    â”‚   â”‚   â”‚â—Šâ—Šâ—Šâ”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤     Fireball: 3x3 area
    â”‚   â”‚â—Šâ—Šâ—Šâ”‚â—Šâ—Šâ—Šâ”‚â—Šâ—Šâ—Šâ”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚â—Šâ—Šâ—Šâ”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜


    HighlightType.Threatened (Orange):
    Cells where enemies have opportunity attacks


    HighlightType.Selected (Yellow):
    Currently targeted/selected cell with double border
```

---

## 4. CombatGridView Component

### 4.1 CombatGridView Class

**File:** `src/Presentation/RuneAndRust.TUI/UI/CombatGridView.cs`

```csharp
namespace RuneAndRust.Presentation.UI;

/// <summary>
/// Renders the enhanced combat grid view with combatant list and turn info.
/// </summary>
public class CombatGridView
{
    private readonly ScreenLayout _layout;
    private readonly ITerminalService _terminal;
    private readonly IColorThemeService _colorService;
    private readonly HealthBar _healthBar;
    private readonly CombatantListPanel _combatantList;
    private readonly TurnInfoBar _turnInfo;
    private readonly ILogger<CombatGridView> _logger;
    
    private readonly HashSet<GridPosition> _highlightedCells = new();
    private HighlightType _currentHighlightType = HighlightType.Movement;
    private GridPosition? _selectedCell;
    
    // Grid display constants
    private const int CellWidth = 3;
    private const int CellHeight = 1;
    private const int GridSize = 8;
    
    // Entity symbols
    private const char PlayerSymbol = '@';
    private const char MonsterSymbol = 'M';
    private const char AllySymbol = 'A';
    
    // Terrain symbols
    private static readonly Dictionary<TerrainType, char> TerrainSymbols = new()
    {
        { TerrainType.Open, '.' },
        { TerrainType.Water, '~' },
        { TerrainType.Wall, '#' },
        { TerrainType.Difficult, ',' },
        { TerrainType.Hazard, '^' }
    };
    
    public CombatGridView(
        ScreenLayout layout,
        ITerminalService terminal,
        IColorThemeService colorService,
        HealthBar healthBar,
        CombatantListPanel combatantList,
        TurnInfoBar turnInfo,
        ILogger<CombatGridView> logger)
    {
        _layout = layout;
        _terminal = terminal;
        _colorService = colorService;
        _healthBar = healthBar;
        _combatantList = combatantList;
        _turnInfo = turnInfo;
        _logger = logger;
    }
    
    /// <summary>
    /// Renders the complete combat view.
    /// </summary>
    /// <param name="state">The current combat state.</param>
    public void Render(CombatState state)
    {
        var gridPanel = _layout.GetPanel(PanelPosition.MainContent);
        var sidebarPanel = _layout.GetPanel(PanelPosition.Sidebar);
        var footerPanel = _layout.GetPanel(PanelPosition.Footer);
        
        if (gridPanel == null)
        {
            _logger.LogWarning("MainContent panel not found for combat grid");
            return;
        }
        
        // Render grid in main content
        RenderGrid(state, gridPanel.Value.ContentArea);
        
        // Render combatant list in sidebar
        if (sidebarPanel != null)
        {
            _combatantList.Render(state.Combatants, state.CurrentTurnIndex, 
                sidebarPanel.Value.ContentArea);
        }
        
        // Render turn info in footer
        if (footerPanel != null)
        {
            _turnInfo.Render(state, footerPanel.Value.ContentArea);
        }
        
        _logger.LogDebug("Combat view rendered: Round {Round}, Turn {TurnIndex}", 
            state.Round, state.CurrentTurnIndex);
    }
    
    /// <summary>
    /// Highlights cells for movement, attack, or ability range.
    /// </summary>
    /// <param name="cells">Cells to highlight.</param>
    /// <param name="type">Type of highlight.</param>
    public void HighlightCells(IEnumerable<GridPosition> cells, HighlightType type)
    {
        _highlightedCells.Clear();
        foreach (var cell in cells)
        {
            _highlightedCells.Add(cell);
        }
        _currentHighlightType = type;
        
        _logger.LogDebug("Highlighted {Count} cells with type {Type}", 
            _highlightedCells.Count, type);
    }
    
    /// <summary>
    /// Clears all cell highlighting.
    /// </summary>
    public void ClearHighlights()
    {
        _highlightedCells.Clear();
        _selectedCell = null;
    }
    
    /// <summary>
    /// Sets the currently selected cell.
    /// </summary>
    /// <param name="position">Cell position, or null to clear.</param>
    public void SetSelectedCell(GridPosition? position)
    {
        _selectedCell = position;
    }
    
    /// <summary>
    /// Refreshes just the entity positions without full redraw.
    /// </summary>
    /// <param name="state">Current combat state.</param>
    public void RefreshEntities(CombatState state)
    {
        var panel = _layout.GetPanel(PanelPosition.MainContent);
        if (panel == null) return;
        
        var area = panel.Value.ContentArea;
        RenderEntities(state, area);
    }
    
    private void RenderGrid(CombatState state, (int X, int Y, int Width, int Height) area)
    {
        RenderTitle("COMBAT GRID", area.X, area.Y, area.Width);
        
        var gridStartX = area.X + 4; // Space for row numbers
        var gridStartY = area.Y + 2; // Space for column labels
        
        // Column labels (A-H)
        RenderColumnLabels(gridStartX, area.Y + 1);
        
        // Grid rows with row numbers
        for (var row = 0; row < GridSize; row++)
        {
            RenderRow(state, row, gridStartX, gridStartY + row * 2);
        }
        
        // Legend
        RenderLegend(area.X, gridStartY + GridSize * 2 + 1, area.Width);
    }
    
    private void RenderColumnLabels(int startX, int y)
    {
        _terminal.SetCursorPosition(startX, y);
        _terminal.Write("    ");
        
        for (var col = 0; col < GridSize; col++)
        {
            var label = (char)('A' + col);
            _terminal.Write($" {label} ");
        }
    }
    
    private void RenderRow(CombatState state, int row, int startX, int y)
    {
        // Row number
        _terminal.SetCursorPosition(startX - 3, y);
        _terminal.Write($"{row + 1} ");
        
        // Top border (first row or grid border)
        _terminal.SetCursorPosition(startX, y);
        if (row == 0)
        {
            _terminal.Write("â”Œ" + string.Concat(Enumerable.Repeat("â”€â”€â”€â”¬", GridSize - 1)) + "â”€â”€â”€â”");
        }
        else
        {
            _terminal.Write("â”œ" + string.Concat(Enumerable.Repeat("â”€â”€â”€â”¼", GridSize - 1)) + "â”€â”€â”€â”¤");
        }
        
        // Cell contents
        _terminal.SetCursorPosition(startX, y + 1);
        for (var col = 0; col < GridSize; col++)
        {
            var position = new GridPosition(col, row);
            var cell = state.Grid.GetCell(position);
            var entity = state.GetEntityAt(position);
            
            var isHighlighted = _highlightedCells.Contains(position);
            var isSelected = _selectedCell == position;
            
            _terminal.Write("â”‚");
            RenderCell(cell, entity, isHighlighted, isSelected, state);
        }
        _terminal.Write("â”‚");
        
        // Bottom border (last row only)
        if (row == GridSize - 1)
        {
            _terminal.SetCursorPosition(startX, y + 2);
            _terminal.Write("â””" + string.Concat(Enumerable.Repeat("â”€â”€â”€â”´", GridSize - 1)) + "â”€â”€â”€â”˜");
        }
    }
    
    private void RenderCell(
        GridCell cell, 
        Combatant? entity, 
        bool isHighlighted, 
        bool isSelected,
        CombatState state)
    {
        var bgColor = GetCellBackgroundColor(isHighlighted, isSelected);
        var symbol = GetCellSymbol(cell, entity, state);
        var fgColor = GetEntityColor(entity, state);
        
        var prevBg = Console.BackgroundColor;
        var prevFg = Console.ForegroundColor;
        
        if (bgColor.HasValue) Console.BackgroundColor = bgColor.Value;
        if (fgColor.HasValue) Console.ForegroundColor = fgColor.Value;
        
        _terminal.Write($" {symbol} ");
        
        Console.BackgroundColor = prevBg;
        Console.ForegroundColor = prevFg;
    }
    
    private ConsoleColor? GetCellBackgroundColor(bool isHighlighted, bool isSelected)
    {
        if (isSelected) return ConsoleColor.DarkYellow;
        if (!isHighlighted) return null;
        
        return _currentHighlightType switch
        {
            HighlightType.Movement => ConsoleColor.DarkBlue,
            HighlightType.Attack => ConsoleColor.DarkRed,
            HighlightType.Ability => ConsoleColor.DarkMagenta,
            HighlightType.Threatened => ConsoleColor.DarkYellow,
            HighlightType.Selected => ConsoleColor.DarkYellow,
            _ => null
        };
    }
    
    private char GetCellSymbol(GridCell cell, Combatant? entity, CombatState state)
    {
        if (entity != null)
        {
            if (entity.IsPlayer) return PlayerSymbol;
            if (entity.IsAlly) return AllySymbol;
            return MonsterSymbol;
        }
        
        return TerrainSymbols.GetValueOrDefault(cell.Terrain, '.');
    }
    
    private ConsoleColor? GetEntityColor(Combatant? entity, CombatState state)
    {
        if (entity == null) return ConsoleColor.Gray;
        
        if (entity.IsPlayer) return ConsoleColor.Green;
        if (entity.IsAlly) return ConsoleColor.Cyan;
        
        // Enemies in red, current turn enemy in bright red
        var isCurrentTurn = state.GetCurrentCombatant()?.Id == entity.Id;
        return isCurrentTurn ? ConsoleColor.Red : ConsoleColor.DarkRed;
    }
    
    private void RenderEntities(CombatState state, (int X, int Y, int Width, int Height) area)
    {
        // Re-render just entity cells
        var gridStartX = area.X + 4;
        var gridStartY = area.Y + 2;
        
        foreach (var combatant in state.Combatants)
        {
            if (combatant.Position.HasValue)
            {
                var pos = combatant.Position.Value;
                var cellX = gridStartX + 1 + pos.X * 4;
                var cellY = gridStartY + 1 + pos.Y * 2;
                
                _terminal.SetCursorPosition(cellX, cellY);
                var symbol = combatant.IsPlayer ? PlayerSymbol : 
                            combatant.IsAlly ? AllySymbol : MonsterSymbol;
                var color = GetEntityColor(combatant, state);
                
                var prevFg = Console.ForegroundColor;
                if (color.HasValue) Console.ForegroundColor = color.Value;
                _terminal.Write($" {symbol} ");
                Console.ForegroundColor = prevFg;
            }
        }
    }
    
    private void RenderLegend(int x, int y, int width)
    {
        var legend = $"Legend: {PlayerSymbol} = You  {MonsterSymbol} = Monster  " +
                    $"{TerrainSymbols[TerrainType.Open]} = Open  " +
                    $"{TerrainSymbols[TerrainType.Water]} = Water";
        
        _terminal.SetCursorPosition(x, y);
        _terminal.Write(legend);
    }
    
    private void RenderTitle(string title, int x, int y, int width)
    {
        var padding = (width - title.Length) / 2;
        _terminal.SetCursorPosition(x + padding, y);
        _terminal.Write(title);
    }
}
```

### 4.2 HighlightType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/HighlightType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of cell highlighting for combat grid.
/// </summary>
public enum HighlightType
{
    /// <summary>Blue - Valid movement targets.</summary>
    Movement,
    
    /// <summary>Red - Valid attack targets.</summary>
    Attack,
    
    /// <summary>Purple - Ability effect range.</summary>
    Ability,
    
    /// <summary>Orange - Threatened squares (opportunity attacks).</summary>
    Threatened,
    
    /// <summary>Yellow - Current selection.</summary>
    Selected
}
```

---

## 5. CombatantListPanel Component

### 5.1 CombatantListPanel Class

**File:** `src/Presentation/RuneAndRust.TUI/UI/CombatantListPanel.cs`

```csharp
namespace RuneAndRust.Presentation.UI;

/// <summary>
/// Renders the list of combatants with health and status.
/// </summary>
public class CombatantListPanel
{
    private readonly ITerminalService _terminal;
    private readonly HealthBar _healthBar;
    private readonly ILogger<CombatantListPanel> _logger;
    
    // Display constants
    private const int CombatantEntryHeight = 4;
    private const char TurnIndicator = 'â–º';
    
    public CombatantListPanel(
        ITerminalService terminal,
        HealthBar healthBar,
        ILogger<CombatantListPanel> logger)
    {
        _terminal = terminal;
        _healthBar = healthBar;
        _logger = logger;
    }
    
    /// <summary>
    /// Renders the combatant list.
    /// </summary>
    /// <param name="combatants">All combatants in combat.</param>
    /// <param name="currentTurnIndex">Index of current turn.</param>
    /// <param name="area">Available content area.</param>
    public void Render(
        IReadOnlyList<Combatant> combatants, 
        int currentTurnIndex,
        (int X, int Y, int Width, int Height) area)
    {
        // Title
        RenderTitle("COMBATANTS", area.X, area.Y, area.Width);
        
        var currentY = area.Y + 2;
        var visibleCombatants = (area.Height - 4) / CombatantEntryHeight;
        
        for (var i = 0; i < Math.Min(combatants.Count, visibleCombatants); i++)
        {
            var combatant = combatants[i];
            var isCurrentTurn = i == currentTurnIndex;
            
            RenderCombatant(combatant, isCurrentTurn, area.X, currentY, area.Width);
            currentY += CombatantEntryHeight;
        }
        
        // Legend at bottom
        RenderListLegend(area.X, area.Y + area.Height - 2, area.Width);
    }
    
    private void RenderCombatant(
        Combatant combatant, 
        bool isCurrentTurn, 
        int x, int y, int width)
    {
        // Line 1: Turn indicator, symbol, name, level/class
        _terminal.SetCursorPosition(x, y);
        
        var turnMarker = isCurrentTurn ? TurnIndicator : ' ';
        var symbol = combatant.IsPlayer ? '@' : 'M';
        var nameClass = $"{combatant.Name}";
        
        if (combatant.Level > 0 && !string.IsNullOrEmpty(combatant.ClassName))
        {
            nameClass += $"  Lv{combatant.Level} {combatant.ClassName}";
        }
        
        var line1 = $"{turnMarker} {symbol} {nameClass}";
        if (line1.Length > width) line1 = line1[..(width - 1)];
        
        var color = combatant.IsPlayer ? ConsoleColor.Green : 
                   combatant.IsAlly ? ConsoleColor.Cyan : ConsoleColor.Red;
        
        WriteColored($"{turnMarker} ", isCurrentTurn ? ConsoleColor.Yellow : ConsoleColor.DarkGray);
        WriteColored($"{symbol} ", color);
        _terminal.Write(nameClass.Length > width - 4 ? nameClass[..(width - 7)] + "..." : nameClass);
        
        // Line 2: HP bar
        _terminal.SetCursorPosition(x + 2, y + 1);
        var hpText = _healthBar.Render(combatant.CurrentHealth, combatant.MaxHealth, 
            width - 4, BarStyle.Detailed);
        _terminal.Write($"HP {hpText}");
        
        // Line 3: MP bar (if applicable)
        if (combatant.MaxMana > 0)
        {
            _terminal.SetCursorPosition(x + 2, y + 2);
            var mpText = _healthBar.Render(combatant.CurrentMana, combatant.MaxMana, 
                width - 4, BarStyle.Detailed);
            WriteColored($"MP {mpText}", ConsoleColor.Blue);
        }
        
        // Line 3/4: Status effects
        if (combatant.StatusEffects.Any())
        {
            var statusY = combatant.MaxMana > 0 ? y + 3 : y + 2;
            _terminal.SetCursorPosition(x + 2, statusY);
            var statuses = string.Join(" ", 
                combatant.StatusEffects.Take(3).Select(s => $"[{s.Name}]"));
            WriteColored(statuses, ConsoleColor.DarkYellow);
        }
    }
    
    private void RenderListLegend(int x, int y, int width)
    {
        _terminal.SetCursorPosition(x, y);
        _terminal.Write($"{TurnIndicator} = Current Turn");
    }
    
    private void RenderTitle(string title, int x, int y, int width)
    {
        var padding = (width - title.Length) / 2;
        _terminal.SetCursorPosition(x + padding, y);
        _terminal.Write(title);
    }
    
    private void WriteColored(string text, ConsoleColor color)
    {
        var prevColor = Console.ForegroundColor;
        Console.ForegroundColor = color;
        _terminal.Write(text);
        Console.ForegroundColor = prevColor;
    }
}
```

---

## 6. TurnInfoBar Component

### 6.1 TurnInfoBar Class

**File:** `src/Presentation/RuneAndRust.TUI/UI/TurnInfoBar.cs`

```csharp
namespace RuneAndRust.Presentation.UI;

/// <summary>
/// Renders the turn information bar at the bottom of combat view.
/// </summary>
public class TurnInfoBar
{
    private readonly ITerminalService _terminal;
    private readonly ILogger<TurnInfoBar> _logger;
    
    // Symbols
    private const char ActionAvailable = 'âœ“';
    private const char ActionUsed = 'âœ—';
    
    public TurnInfoBar(
        ITerminalService terminal,
        ILogger<TurnInfoBar> logger)
    {
        _terminal = terminal;
        _logger = logger;
    }
    
    /// <summary>
    /// Renders the turn information bar.
    /// </summary>
    /// <param name="state">Current combat state.</param>
    /// <param name="area">Available content area.</param>
    public void Render(CombatState state, (int X, int Y, int Width, int Height) area)
    {
        var currentCombatant = state.GetCurrentCombatant();
        if (currentCombatant == null) return;
        
        var parts = new List<string>();
        
        // Round number
        parts.Add($"Round {state.Round}");
        
        // Whose turn
        var turnText = currentCombatant.IsPlayer 
            ? "YOUR TURN" 
            : $"{currentCombatant.Name.ToUpper()}'S TURN";
        parts.Add(turnText);
        
        // Action availability
        var actionSymbol = state.ActionAvailable ? ActionAvailable : ActionUsed;
        var actionColor = state.ActionAvailable ? "Available" : "Used";
        parts.Add($"Action: {actionSymbol} {actionColor}");
        
        // Movement remaining
        parts.Add($"Move: {state.MovementRemaining}/{currentCombatant.MovementSpeed}");
        
        // Bonus action (if applicable)
        if (currentCombatant.HasBonusAction)
        {
            var bonusSymbol = state.BonusActionAvailable ? ActionAvailable : ActionUsed;
            parts.Add($"Bonus: {bonusSymbol}");
        }
        
        // Build and render the bar
        var separator = "  |  ";
        var fullText = string.Join(separator, parts);
        
        // Center in the bar
        var padding = (area.Width - fullText.Length) / 2;
        
        _terminal.SetCursorPosition(area.X + Math.Max(0, padding), area.Y);
        
        foreach (var (part, index) in parts.Select((p, i) => (p, i)))
        {
            if (index > 0)
            {
                WriteColored(separator, ConsoleColor.DarkGray);
            }
            
            // Color specific parts
            if (part.StartsWith("YOUR TURN"))
            {
                WriteColored(part, ConsoleColor.Green);
            }
            else if (part.Contains(ActionAvailable.ToString()))
            {
                WritePartWithSymbol(part, ActionAvailable, ConsoleColor.Green);
            }
            else if (part.Contains(ActionUsed.ToString()))
            {
                WritePartWithSymbol(part, ActionUsed, ConsoleColor.Red);
            }
            else
            {
                _terminal.Write(part);
            }
        }
    }
    
    private void WritePartWithSymbol(string part, char symbol, ConsoleColor symbolColor)
    {
        var symbolIndex = part.IndexOf(symbol);
        if (symbolIndex >= 0)
        {
            _terminal.Write(part[..symbolIndex]);
            WriteColored(symbol.ToString(), symbolColor);
            _terminal.Write(part[(symbolIndex + 1)..]);
        }
        else
        {
            _terminal.Write(part);
        }
    }
    
    private void WriteColored(string text, ConsoleColor color)
    {
        var prevColor = Console.ForegroundColor;
        Console.ForegroundColor = color;
        _terminal.Write(text);
        Console.ForegroundColor = prevColor;
    }
}
```

---

## 7. Data Model

### 7.1 New Enums

| Enum | Layer | Description |
|------|-------|-------------|
| `HighlightType` | Domain | Cell highlight types |

### 7.2 New Components

| Component | Layer | Description |
|-----------|-------|-------------|
| `CombatGridView` | Presentation | Main combat view orchestrator |
| `CombatantListPanel` | Presentation | Combatant list in sidebar |
| `TurnInfoBar` | Presentation | Turn info in footer |

### 7.3 Extended Entities (Assumed from v0.5.x)

| Entity | Property | Usage |
|--------|----------|-------|
| `CombatState` | `Round`, `CurrentTurnIndex` | Turn tracking |
| `CombatState` | `ActionAvailable`, `BonusActionAvailable` | Action economy |
| `CombatState` | `MovementRemaining` | Movement tracking |
| `Combatant` | `Position`, `CurrentHealth`, `MaxHealth` | Combatant state |
| `Combatant` | `CurrentMana`, `MaxMana`, `StatusEffects` | Resource/status |
| `GridCell` | `Terrain` | Terrain type |

---

## 8. Configuration

### 8.1 Combat Grid Configuration

**File:** `config/ui.json` (combatGrid section)

```json
{
  "combatGrid": {
    "size": 8,
    "cellWidth": 3,
    "coordinateStyle": "chess",
    "entitySymbols": {
      "player": "@",
      "monster": "M",
      "ally": "A"
    },
    "terrainSymbols": {
      "open": ".",
      "water": "~",
      "wall": "#",
      "difficult": ",",
      "hazard": "^"
    },
    "highlightColors": {
      "movement": "DarkBlue",
      "attack": "DarkRed",
      "ability": "DarkMagenta",
      "threatened": "DarkYellow",
      "selected": "DarkYellow"
    },
    "entityColors": {
      "player": "Green",
      "ally": "Cyan",
      "enemy": "DarkRed",
      "currentTurnEnemy": "Red"
    },
    "turnInfo": {
      "actionAvailableSymbol": "âœ“",
      "actionUsedSymbol": "âœ—"
    }
  }
}
```

### 8.2 Configuration Schema

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `size` | int | 8 | Grid dimensions (8x8) |
| `cellWidth` | int | 3 | Character width per cell |
| `coordinateStyle` | string | chess | A-H, 1-8 labels |
| `entitySymbols.*` | char | @, M, A | Entity display symbols |
| `terrainSymbols.*` | char | ., ~, #, etc. | Terrain display symbols |
| `highlightColors.*` | ConsoleColor | various | Highlight background colors |
| `entityColors.*` | ConsoleColor | various | Entity foreground colors |

---

## 9. Logging Specifications

### 9.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `CombatGridView` | Debug | Render complete, highlight count |
| `CombatGridView` | Warning | Panel not found |
| `CombatantListPanel` | Debug | Combatant render count |
| `TurnInfoBar` | Debug | Turn info rendered |

### 9.2 Log Message Templates

```csharp
// CombatGridView
_logger.LogDebug("Combat view rendered: Round {Round}, Turn {TurnIndex}", 
    round, turnIndex);
_logger.LogDebug("Highlighted {Count} cells with type {Type}", count, type);
_logger.LogWarning("MainContent panel not found for combat grid");

// CombatantListPanel
_logger.LogDebug("Rendered {Count} combatants, current turn: {TurnIndex}", 
    count, turnIndex);

// TurnInfoBar
_logger.LogDebug("Turn info rendered: Round {Round}, Action: {ActionAvailable}", 
    round, actionAvailable);
```

---

## 10. Unit Testing Requirements

### 10.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| CombatGridView | 6 |
| CombatantListPanel | 4 |
| TurnInfoBar | 3 |
| HighlightType | 2 |
| **Total** | **~15** |

### 10.2 Test Specifications

#### CombatGridViewTests.cs

```csharp
[TestFixture]
public class CombatGridViewTests
{
    [Test]
    public void Render_WithValidState_RendersGridAndPanels();
    
    [Test]
    public void HighlightCells_AddsToHighlightedSet();
    
    [Test]
    public void ClearHighlights_RemovesAllHighlights();
    
    [Test]
    public void SetSelectedCell_UpdatesSelectedPosition();
    
    [Test]
    public void GetCellSymbol_ForPlayer_ReturnsAtSign();
    
    [Test]
    public void GetCellBackgroundColor_WhenHighlighted_ReturnsHighlightColor();
}
```

#### CombatantListPanelTests.cs

```csharp
[TestFixture]
public class CombatantListPanelTests
{
    [Test]
    public void Render_WithCombatants_DisplaysAllEntries();
    
    [Test]
    public void Render_CurrentTurn_ShowsTurnIndicator();
    
    [Test]
    public void Render_WithStatusEffects_DisplaysStatusIcons();
    
    [Test]
    public void Render_WithMana_ShowsManaBar();
}
```

#### TurnInfoBarTests.cs

```csharp
[TestFixture]
public class TurnInfoBarTests
{
    [Test]
    public void Render_PlayerTurn_ShowsYourTurn();
    
    [Test]
    public void Render_ActionAvailable_ShowsCheckmark();
    
    [Test]
    public void Render_ShowsMovementRemaining();
}
```

---

## 11. Use Cases

### UC-001: Enter Combat
**Actor:** Player
**Flow:** Combat starts â†’ Render() â†’ Grid shows with entities â†’ Combatant list populates â†’ Turn info displays

### UC-002: Show Movement Range
**Actor:** Player
**Flow:** Select move action â†’ HighlightCells(validMoves, Movement) â†’ Blue cells appear â†’ Select target â†’ Move

### UC-003: Target Enemy
**Actor:** Player
**Flow:** Select attack â†’ HighlightCells(validTargets, Attack) â†’ Red cells around enemies â†’ SetSelectedCell() â†’ Attack executes

### UC-004: Track Turn Order
**Actor:** Combat System
**Flow:** Turn changes â†’ CombatantListPanel updates â–º indicator â†’ TurnInfoBar shows new entity â†’ Actions reset

---

## 12. Deliverable Checklist

### CombatGridView Component
- [ ] `CombatGridView` class created
- [ ] Render() method implemented
- [ ] HighlightCells() method implemented
- [ ] ClearHighlights() method implemented
- [ ] SetSelectedCell() method implemented
- [ ] RefreshEntities() method implemented
- [ ] RenderGrid() private method
- [ ] RenderColumnLabels() private method
- [ ] RenderRow() private method
- [ ] RenderCell() private method
- [ ] RenderLegend() private method

### CombatantListPanel Component
- [ ] `CombatantListPanel` class created
- [ ] Render() method implemented
- [ ] RenderCombatant() method implemented
- [ ] HP/MP bars integration
- [ ] Status effect display
- [ ] Turn indicator (â–º)

### TurnInfoBar Component
- [ ] `TurnInfoBar` class created
- [ ] Render() method implemented
- [ ] Round display
- [ ] Turn entity display
- [ ] Action/move/bonus indicators

### Enums
- [ ] `HighlightType` enum created

### Configuration
- [ ] `ui.json` combatGrid section added

### Testing
- [ ] ~15 unit tests implemented
- [ ] All tests passing

---

## 13. Acceptance Criteria

### Functional
- [ ] Combat grid renders in main panel
- [ ] Coordinate labels display (A-H, 1-8)
- [ ] Entity markers show (@, M, A)
- [ ] Terrain types display correctly (., ~, #, etc.)
- [ ] Combatant list shows all combatants in sidebar
- [ ] HP bars display for each combatant
- [ ] MP bars display for combatants with mana
- [ ] Status effects show as [Name] blocks
- [ ] Current turn indicator (â–º) highlights active combatant
- [ ] Turn info bar shows round number
- [ ] Turn info bar shows "YOUR TURN" or enemy name
- [ ] Action/move/bonus availability shows with âœ“/âœ—
- [ ] Cell highlighting works for movement (blue)
- [ ] Cell highlighting works for attacks (red)
- [ ] Cell highlighting works for abilities (purple)
- [ ] Selected cell shows with different background
- [ ] Grid legend displays symbol meanings

### Quality
- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~15 unit tests pass
- [ ] XML documentation complete on all public members

---

## 14. Dependencies

### Required from v0.6.0a

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `ScreenLayout` | `Presentation/UI/ScreenLayout.cs` | Panel management |
| `Panel` | `Presentation/UI/Panel.cs` | Content areas |
| `ITerminalService` | `Application/Interfaces/ITerminalService.cs` | Terminal output |

### Required from v0.6.0c

| Type | Location | Usage |
|------|----------|-------|
| `IColorThemeService` | `Application/Interfaces/IColorThemeService.cs` | Color management |

### Required from v0.6.1a

| Type | Location | Usage |
|------|----------|-------|
| `HealthBar` | `Presentation/UI/HealthBar.cs` | HP/MP bar rendering |

### Required from v0.5.x

| Type | Location | Usage |
|------|----------|-------|
| `CombatState` | `Domain/Entities/CombatState.cs` | Combat data |
| `CombatGrid` | `Domain/Entities/CombatGrid.cs` | Grid data |
| `Combatant` | `Domain/Entities/Combatant.cs` | Entity data |
| `GridCell` | `Domain/Entities/GridCell.cs` | Cell data |
| `GridPosition` | `Domain/ValueObjects/GridPosition.cs` | Position |
| `TerrainType` | `Domain/Enums/TerrainType.cs` | Terrain types |

### Provides to v0.6.2b

| Type | Usage |
|------|-------|
| `CombatGridView` | Animation display integration |
| Grid panel area | Animation rendering target |

---

## 15. Future Considerations

### Deferred to v0.6.2b
- **Combat Animations**: Hit/miss animations, ability effects (next part)

### Deferred to v0.7.x
- **Clickable Grid**: Mouse-based cell selection (GUI)
- **Zoom/Pan**: Grid scrolling for larger maps

### Out of Scope
- **3D Grid**: Isometric or 3D rendering
- **Fog of War**: Hidden cells based on vision

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: Assistant*
