# v0.2.2: The Adversary

> **Status:** Complete
> **Milestone:** 3 - The Warrior
> **Theme:** Enemy templates, AI behaviors, and Elite traits

## Table of Contents
- [Overview](#overview)
- [Phase A: The Bestiary (Data & Definitions)](#phase-a-the-bestiary-data--definitions)
- [Phase B: The Mind (AI Behaviors)](#phase-b-the-mind-ai-behaviors)
- [Phase C: The Elite (Traits & Affixes)](#phase-c-the-elite-traits--affixes)
- [Testing Strategy](#testing-strategy)
- [Draft Changelog](#draft-changelog)

## Overview

This version transforms enemies from static punching bags into distinct threats with unique behaviors, stats, and loot tables. It integrates SPEC-COMBAT-012 (Enemy Design) and connects enemies to the Loot System.

- **Phase A: The Bestiary** - Data structures for distinct enemy types
- **Phase B: The Mind** - AI behaviors using probability-based decision trees
- **Phase C: The Elite** - Creature traits and affixes for Elite/Champion enemies

---

## Phase A: The Bestiary (Data & Definitions)

**Goal:** Implement the EnemyTemplate system, the EnemyFactory for instantiating scalable mobs, and seed the initial roster of canonical enemies (Draugr, Haugbui, etc.).

### 1. Architecture & Data Flow

We utilize a Prototype Pattern where static EnemyTemplates are hydrated into live Enemy entities, scaled dynamically by the player's progression (Party Power Score).

**Workflow:**
1. **Encounter Trigger:** EncounterGenerationService requests an enemy (e.g., "Standard Draugr").
2. **Template Lookup:** EnemyFactory retrieves the EnemyTemplate from the repository.
3. **Scaling Calculation:** The factory consults SpawnScalingService to calculate a scaler (e.g., 1.2x HP).
4. **Instantiation:** A new Enemy entity is created:
   - Stats = Base Stats * Scaler.
   - Loot Table = Linked from Template.
   - Archetype = Defined in Template (drives AI in Phase B).
5. **Placement:** The entity is added to the CombatState.

### 2. Logic Decision Trees

**A. Factory Scaling Logic**
Input: Template, PartyPowerScore (PPS)
1. Identify Tier: Is Template Minion, Standard, Elite, or Boss?
2. Calculate Multiplier:
   - Standard: Multiplier = 1.0 + ((PPS - ZoneBase) * 0.1).
   - Minion: Scale damage only, HP fixed low.
   - Boss: Fixed stats (Do not scale downward).
3. Apply Variance: Apply ±5% RNG to HP/Stamina to prevent "cookie-cutter" feel.
4. Output: Final MaxHP, MaxStamina, Attribute Dictionary.

**B. Entity Classification Logic (Domain 6 Compliance)**
When creating Templates:
- Is it Mechanical?
  - Yes: Tag Mechanical. Immune to Bleed/Poison. Vulnerable to Shock.
- Is it a "Zombie"?
  - Check: Is it Iron Heart powered? -> Undying (Draugr/Haugbui).
  - Check: Is it Bio-Parasitic? -> Blighted (Symbiotic Plate/Husk).
  - Note: "Galdr" is not an entity type (per Domain 3).

### 3. Code Implementation

**File:** `RuneAndRust.Core/Enums/EnemyArchetype.cs`
```csharp
public enum EnemyArchetype
{
    Tank,           // High HP/Soak, Low Dmg (e.g., Haugbui)
    DPS,            // Balanced (e.g., Draugr)
    GlassCannon,    // High Dmg, Low HP (e.g., Scrap-Hound)
    Support,        // Buffs/Debuffs (e.g., Engineer)
    Swarm,          // Low stats, group tactics (e.g., Servitors)
    Caster,         // Ranged/AoE (e.g., Rust-Witch)
    Boss            // Multi-phase (e.g., Ruin-Warden)
}
```

**File:** `RuneAndRust.Core/Models/Combat/EnemyTemplate.cs`
```csharp
public record EnemyTemplate(
    string Id,                  // e.g., "enemy_draugr_grunt"
    string Name,                // Display Name
    string Description,         // Flavor Text (AAM-VOICE compliant)
    EnemyArchetype Archetype,   // AI Behavior Key
    ThreatTier Tier,            // Minion/Standard/Elite/Boss
    int BaseHp,
    int BaseStamina,
    int BaseSoak,               // Armor
    Dictionary<Attribute, int> Attributes, // Core stats
    List<string> AbilityIds,    // Links to Ability Registry
    string LootTableId,         // Links to LootTable Registry
    List<string> Tags           // "Mechanical", "Undying", "Construct"
);
```

**File:** `RuneAndRust.Engine/Factories/EnemyFactory.cs`
```csharp
public class EnemyFactory : IEnemyFactory
{
    private readonly ISpawnScalingService _scaling;
    private readonly IDiceService _dice;

    public Enemy CreateEnemy(EnemyTemplate template, int partyPowerScore)
    {
        // 1. Calculate Scaling
        var scaler = _scaling.GetScalingFactor(template.Tier, partyPowerScore);

        // 2. Apply Variance (random +/- 5%)
        float variance = 1.0f + (_dice.Roll(1, 10).Total - 5) / 100f;
        int finalHp = (int)(template.BaseHp * scaler.HpMultiplier * variance);

        // 3. Construct Entity
        return new Enemy
        {
            Id = Guid.NewGuid(),
            Name = template.Name,
            TemplateId = template.Id,
            Archetype = template.Archetype,
            MaxHp = finalHp,
            CurrentHp = finalHp,
            MaxStamina = (int)(template.BaseStamina * scaler.StaminaMultiplier),
            CurrentStamina = (int)(template.BaseStamina * scaler.StaminaMultiplier),
            ArmorSoak = template.BaseSoak,
            Attributes = ScaleAttributes(template.Attributes, scaler.AttributeBonus),
            LootTableId = template.LootTableId,
            Tags = template.Tags
        };
    }
}
```

### 4. Data Seeding (The Bestiary)

Initial "Standard" enemies based on Domain 6 and SPEC-COMBAT-012:

| ID | Name | Archetype | Tier | Tags | Notes |
|---|---|---|---|---|---|
| und_draugr_01 | Rusted Draugr | DPS | Standard | Undying, IronHeart | Security automaton. Firmware Echo I. |
| und_haug_01 | Haugbui Laborer | Tank | Standard | Undying, IronHeart | Construction unit. Task-loop: Stack. |
| mec_serv_01 | Utility Servitor | Swarm | Minion | Mechanical | Janitorial unit. Weak. |
| bst_vargr_01 | Ash-Vargr | GlassCannon | Standard | Beast | Ambush predator. |
| hum_raider_01 | Rust-Clan Scav | Support | Standard | Humanoid | Uses gadgets/traps. |

### 5. Logging Matrix

| System | Event | Level | Message Template |
|---|---|---|---|
| Factory | Creation | Info | "Created {Name} [Tier: {Tier}] (HP: {HP}, Scaler: {Scaler}x)" |
| Scaling | Calc | Debug | "Scaling {Template} for PPS {PPS}: Multiplier {Mult}" |
| Tags | Check | Trace | "{Name} tags: {Tags}" |

### 6. Testing Strategy

**Unit Tests:**
- EnemyFactory_AppliesArchetype: Verify created enemy has the template's archetype.
- EnemyFactory_ScalesHP: Input Base HP 100, Scaler 1.5 -> Output HP ~150.
- EnemyFactory_Variance: Create 100 enemies; verify HP is not identical (variance check).
- EnemyFactory_AssignsLootTable: Verify LootTableId string is copied correctly.

**Integration Tests:**
- SeedData_Validity: Verify all seeded templates have valid Ability IDs.
- Combat_Load: Instantiate a combat encounter using CreateEnemy and verify the Combatant adapter correctly reads the new properties.

### 7. Deliverable Checklist (Phase A)

- [x] Core: Define EnemyTemplate record.
- [x] Core: Define EnemyArchetype and ThreatTier enums.
- [x] Core: Update Enemy entity with Archetype, TemplateId, Tags.
- [x] Engine: Implement EnemyFactory.
- [x] Engine: Implement ISpawnScalingService (basic version).
- [x] Engine: Create BestiarySeeder with the 5 core enemies.
- [x] Tests: FactoryScalingTests.
- [x] Tests: TemplateDataValidationTests.

---

## Phase B: The Mind (AI Behaviors)

**Goal:** Implement the EnemyAIService to drive enemy turns using the Probability-Based Decision Matrix defined in SPEC-AI-001.

### 1. Architecture & Data Flow

We introduce a "Think" phase into the Combat Loop.

**Workflow:**
1. **Turn Start:** CombatService detects active combatant is an Enemy.
2. **Request Action:** Calls EnemyAIService.DetermineAction(actor, combatState).
3. **Evaluate Context:** AI analyzes self (HP), targets (Player HP/Status), and RNG.
4. **Select Pattern:** Based on Enemy.Archetype (from Phase A).
5. **Execute:** Returns a CombatAction object (Attack, Defend, Flee, Ability).
6. **Resolution:** CombatService executes the command and logs the narrative.

```
sequenceDiagram
    participant CombatLoop
    participant AIService
    participant RNG
    participant ActionResolver

    CombatLoop->>AIService: DetermineAction(Enemy, State)
    AIService->>AIService: Identify Archetype (e.g. Aggressive)

    alt HP < 25% & Trait=Cowardly
        AIService-->>CombatLoop: Action: Flee
    else Standard
        AIService->>RNG: Roll d100
        RNG-->>AIService: Result (e.g. 85)
        AIService->>AIService: Map 85 to Behavior Table
        AIService-->>CombatLoop: Action: Heavy Attack
    end

    CombatLoop->>ActionResolver: Execute(Action)
```

### 2. Logic Decision Trees (The Brain)

Based on SPEC-AI-001, behaviors are driven by weighted probability tables modified by state triggers.

**A. Aggressive AI (Archetype: DPS / GlassCannon)**
Primary Goal: Damage Output.
1. Check Condition: Is HP < 20% AND Trait == Cowardly?
   - Yes: Flee.
2. Select Target: Lowest HP Player Character (if known), else Random.
3. Roll d100:
   - 00-79: Standard Attack.
   - 80-89: Heavy/Special Attack (if Stamina allows).
   - 90-99: Taunt/Intimidate (if applicable) OR Standard Attack.

**B. Defensive AI (Archetype: Tank)**
Primary Goal: Survival and protection.
1. Check Condition: Is HP < 40%?
   - Yes: Defend/Block (+Soak/Defense).
2. Check Condition: Is an Ally < 50% HP?
   - Yes: Guard (Move to intercept/Taunt).
3. Roll d100:
   - 00-59: Standard Attack.
   - 60-100: Defensive Stance (Trade damage for soak).

**C. Swarm AI (Archetype: Swarm)**
Primary Goal: Overwhelm via numbers.
1. Check Condition: Is another Swarm unit adjacent to Player?
   - Yes: Flank Attack (+Hit Chance).
   - No: Move to adjacency.

### 3. Code Implementation

**File:** `RuneAndRust.Core/Models/Combat/CombatAction.cs`
```csharp
public enum ActionType { Attack, Defend, Flee, Ability, Pass }

public record CombatAction(
    ActionType Type,
    Guid SourceId,
    Guid? TargetId,
    string? AbilityId = null,
    string? FlavorText = null
);
```

**File:** `RuneAndRust.Engine/Services/EnemyAIService.cs`
```csharp
public class EnemyAIService : IEnemyAIService
{
    private readonly IDiceService _dice;
    private readonly ILogger _logger;

    public CombatAction DetermineAction(Combatant enemy, CombatState state)
    {
        var target = state.TurnOrder.FirstOrDefault(c => c.IsPlayer);
        if (target == null) return new CombatAction(ActionType.Pass, enemy.Id, null);

        return enemy.Archetype switch
        {
            EnemyArchetype.Tank => ExecuteDefensiveLogic(enemy, target),
            EnemyArchetype.Swarm => ExecuteSwarmLogic(enemy, target),
            _ => ExecuteAggressiveLogic(enemy, target)
        };
    }

    private CombatAction ExecuteAggressiveLogic(Combatant self, Combatant target)
    {
        if (self.Tags.Contains("Cowardly") && (float)self.CurrentHp / self.MaxHp < 0.25)
        {
            _logger.LogInformation("{Name} panics and attempts to flee!", self.Name);
            return new CombatAction(ActionType.Flee, self.Id, null);
        }

        int roll = _dice.RollSingle(100, "AI Behavior Check");

        if (roll >= 80 && self.CurrentStamina >= 40)
        {
             return new CombatAction(ActionType.Attack, self.Id, target.Id, "Heavy");
        }

        return new CombatAction(ActionType.Attack, self.Id, target.Id, "Standard");
    }
}
```

**File:** `RuneAndRust.Engine/Services/CombatService.cs`
```csharp
public async Task NextTurn()
{
    var active = _gameState.CombatState.ActiveCombatant;

    if (!active.IsPlayer)
    {
        await Task.Delay(750);

        var action = _aiService.DetermineAction(active, _gameState.CombatState);

        switch (action.Type)
        {
            case ActionType.Attack:
                var atkType = ParseAttackType(action.AbilityId);
                var result = ExecuteAttack(active, _gameState.CombatState.GetCombatant(action.TargetId), atkType);
                LogCombatEvent(result);
                break;

            case ActionType.Defend:
                active.IsDefending = true;
                LogCombatEvent($"{active.Name} raises their guard.");
                break;

            case ActionType.Flee:
                LogCombatEvent($"{active.Name} flees the battle!");
                RemoveDefeatedCombatant(active);
                break;
        }

        if (!CheckVictoryCondition())
        {
             await NextTurn();
        }
    }
}
```

### 4. Logging Matrix

| Event | Level | Message Template | Properties |
|---|---|---|---|
| AI Start | Trace | "[AI] {Name} (Arch:{Archetype}) thinking. HP: {HP}% Stm: {Stamina}" | Name, Archetype, HP, Stamina |
| Trigger | Debug | "[AI] Trigger matched: {Trigger} (Val: {Value})" | Trigger, Value |
| Decision | Info | "[AI] {Name} chose {Action} vs {Target}. Roll: {Roll}" | Name, Action, Target, Roll |
| Resource Fail | Warning | "[AI] Wanted {Action} but insufficient Stamina. Fallback: Standard Attack" | Action |

### 5. Deliverable Checklist (Phase B)

- [x] Core: Define CombatAction record.
- [x] Core: Update IEnemyAIService interface.
- [x] Engine: Implement EnemyAIService with switch/case for Archetypes.
- [x] Engine: Implement ExecuteAggressiveLogic (80/20 split).
- [x] Engine: Implement ExecuteDefensiveLogic (HP threshold checks).
- [x] Engine: Integrate AI call into CombatService.NextTurn.
- [x] Engine: Add Task.Delay for pacing enemy turns.
- [x] Testing: AI_Aggressive_AttacksByDefault.
- [x] Testing: AI_Aggressive_PowerAttack.
- [x] Testing: AI_Defensive_TurtlesLowHP.

---

## Phase C: The Elite (Traits & Affixes)

**Goal:** Implement the CreatureTraitService (SPEC-COMBAT-015) to procedurally generate Elite enemies with unique behaviors (e.g., Explosive, Vampiric) and integrate these traits into the Combat Loop.

### 1. Architecture & Data Flow

We inject a trait generation step into the enemy creation pipeline.

**Workflow: The Promotion Process**
1. **Spawn Request:** EncounterService requests an enemy (e.g., "Ash-Vargr").
2. **RNG Check:** EnemyFactory rolls for tier upgrade (Standard → Elite).
   - Elite Chance: 15% (Base) + (DangerLevel * 5%).
3. **Trait Selection:** If Elite, call CreatureTraitService.GenerateTraits().
   - Selects 1-3 traits based on compatibility and exclusion rules.
4. **Application:** CreatureTraitService.ApplyTraits() modifies the Enemy entity:
   - Stat Modifiers: +HP, +Damage, +Armor (applied immediately).
   - Behavior Tags: Added to Enemy.Traits list for runtime logic.
   - Name Prefix: "Ash-Vargr" → "Explosive Ash-Vargr".
5. **Runtime Hooks:** CombatService checks ActiveCombatant.Traits during specific events (OnHit, OnDeath, TurnStart).

### 2. Logic Decision Trees

**A. Trait Generation Logic**
Input: Enemy Template, Threat Tier
1. Determine Count:
   - Elite: 1 Trait.
   - Champion: 2-3 Traits.
2. Filter Pool:
   - Exclude traits incompatible with Template Tags (e.g., Bleeding on Mechanical).
   - Exclude traits incompatible with already selected traits (e.g., Fast and Stationary).
3. Select & Apply:
   - Pick random trait.
   - Apply stat modifiers immediately (MaxHP *= 1.5).
   - Add to Traits list.
   - Prefix name.

**B. Runtime Trigger Logic (Explosive Trait)**
Input: Combatant Death Event
1. Check Traits: Does victim have CreatureTrait.Explosive?
   - No: Proceed to normal death.
   - Yes: Execute Explosion.
2. Execute Explosion:
   - Identify all active combatants (Player + Enemies).
   - Damage = Victim.MaxHP * 0.25 (Fire damage).
   - Apply damage to all.
   - Log: "{Name} explodes violently!"

### 3. Code Implementation

**File:** `RuneAndRust.Core/Enums/CreatureTraitType.cs`
```csharp
public enum CreatureTraitType
{
    // Stat Modifiers
    Armored = 1,        // +Armor, -Speed
    Relentless = 2,     // +HP, Cannot be Stunned

    // On-Hit Effects
    Vampiric = 10,      // Heals on damage dealt
    Corrosive = 11,     // Applies Armor Shred on hit

    // Reactive/Passive
    Explosive = 20,     // AoE damage on death
    Regenerating = 21,  // Heals % HP per turn
    Thorns = 22         // Reflects damage back to attacker
}
```

**File:** `RuneAndRust.Core/Entities/Enemy.cs` (Update)
```csharp
public partial class Enemy
{
    public List<CreatureTraitType> ActiveTraits { get; set; } = new();
    public bool IsElite => ActiveTraits.Any();
}
```

**File:** `RuneAndRust.Engine/Services/CreatureTraitService.cs`
```csharp
public class CreatureTraitService : ICreatureTraitService
{
    private readonly IDiceService _dice;

    public void EnhanceEnemy(Enemy enemy, ThreatTier tier)
    {
        if (tier == ThreatTier.Standard) return;

        int traitCount = tier == ThreatTier.Champion ? 2 : 1;

        var availableTraits = Enum.GetValues<CreatureTraitType>().ToList();

        for (int i = 0; i < traitCount; i++)
        {
            var trait = availableTraits[_dice.RollSingle(availableTraits.Count) - 1];
            ApplyTrait(enemy, trait);
            availableTraits.Remove(trait);
        }

        enemy.MaxHp = (int)(enemy.MaxHp * 1.5);
        enemy.CurrentHp = enemy.MaxHp;
        enemy.Name = $"Elite {enemy.Name}";
    }

    private void ApplyTrait(Enemy enemy, CreatureTraitType trait)
    {
        enemy.ActiveTraits.Add(trait);

        switch (trait)
        {
            case CreatureTraitType.Armored:
                enemy.ArmorSoak += 3;
                enemy.Name = $"Armored {enemy.Name}";
                break;
            case CreatureTraitType.Relentless:
                enemy.Tags.Add("ImmuneToStun");
                enemy.Name = $"Relentless {enemy.Name}";
                break;
        }
    }
}
```

**File:** `RuneAndRust.Engine/Services/CombatService.cs` (Snippet)
```csharp
private void ProcessTurnStart(Combatant active)
{
    // Trait: Regenerating
    if (active.EnemySource?.ActiveTraits.Contains(CreatureTraitType.Regenerating) == true)
    {
        int healAmt = (int)(active.MaxHp * 0.10);
        active.CurrentHp = Math.Min(active.MaxHp, active.CurrentHp + healAmt);
        LogCombatEvent($"{active.Name} regenerates {healAmt} HP.");
    }
}

public void RemoveDefeatedCombatant(Combatant victim)
{
    // Trait: Explosive
    if (victim.EnemySource?.ActiveTraits.Contains(CreatureTraitType.Explosive) == true)
    {
        LogCombatEvent($"[red]WARNING: {victim.Name} detonates on death![/]");
        var damage = 15;

        var player = _gameState.CombatState.TurnOrder.First(c => c.IsPlayer);
        player.CurrentHp -= damage;
        LogCombatEvent($"{player.Name} takes {damage} explosion damage!");
    }
}
```

### 4. Logging Matrix

| System | Event | Level | Message Template | Properties |
|---|---|---|---|---|
| TraitService | Enhancement | Info | "Promoted {Enemy} to {Tier} with traits: {Traits}" | Enemy, Tier, Traits |
| Combat | Trigger | Info | "{Attacker}'s {Trait} activated!" | Attacker, Trait |
| Combat | Resist | Info | "{Target} ignores Stun ({Trait})" | Target, Trait |

### 5. Testing Requirements

**Unit Tests:**
- EnhanceEnemy_AppliesCorrectStatMultipliers: Verify Elite gets 1.5x HP.
- EnhanceEnemy_AddsTraitsToList: Verify ActiveTraits count > 0.
- EnhanceEnemy_PrefixesName: Verify Name changes (e.g., "Armored Draugr").
- ApplyTrait_Armored_IncreasesSoak: Verify Soak goes up.
- ApplyTrait_Relentless_AddsImmunityTag: Verify "ImmuneToStun" tag added.

**Integration Tests:**
- Regeneration: Simulate 3 turns. Verify Enemy HP increases each StartTurn.
- Explosion: Kill an Explosive enemy. Verify Player HP decreases immediately after death.

### 6. Deliverable Checklist (Phase C)

- [x] Core: Define CreatureTraitType enum.
- [x] Core: Update Enemy entity with List<CreatureTraitType>.
- [x] Engine: Implement CreatureTraitService.
- [x] Engine: Integrate EnhanceEnemy call into EnemyFactory.CreateFromTemplate.
- [x] Engine: Implement Regenerating logic in CombatService.NextTurn.
- [x] Engine: Implement Explosive logic in CombatService.RemoveDefeatedCombatant.
- [x] Engine: Implement Vampiric logic in AttackResolutionService.
- [x] Visuals: Update CombatScreenRenderer to show Trait tags.
- [x] Data: Add "Elite" chance to EncounterGenerationService.

---

## Testing Strategy

### Unit Testing Suite
- **EnemyFactoryTests.cs:** Verify stats fall within variance ranges.
- **EnemyAITests.cs:** Mock RNG to force specific AI choices and verify correct Action output.
- **TraitTests.cs:** Verify traits modify stats (e.g., Armored adds +2 Soak) correctly.

### Logging Matrix

| System | Event | Level | Message Template |
|---|---|---|---|
| AI | Decision | Debug | "{Enemy} (HP:{HP}%) selected behavior {Behavior} -> {Action}" |
| Factory | Spawn | Info | "Spawned {Rarity} {Name} (Traits: {Traits})" |
| Traits | Trigger | Info | "{Name}'s {Trait} triggered! Effect: {Effect}" |

---

## Draft Changelog

```markdown
# Changelog: v0.2.2 - The Adversary
**Release Date:** 2025-XX-XX

## Summary
The "punching bags" fight back. This update introduces the Enemy AI system, defined Bestiary templates, and the Elite enemy system.

## Features
- **Enemy AI Profiles:** Enemies now utilize Aggressive, Defensive, or Tactical logic based on their archetype.
    - *Aggressive:* Focuses weak targets, rarely flees.
    - *Defensive:* Guards allies, turtles when wounded.
- **The Bestiary:** Implemented templates for 5 core enemies (Servitor, Vargr, Engineer, Drone, Skeleton).
- **Elite System:** Enemies have a chance to spawn as **Elites** or **Champions** with randomized traits.
    - *Explosive:* Detonates on death.
    - *Armored:* High base Soak.
    - *Regenerating:* Recovers HP per turn.
- **Combat Logic:** Enemies now consume Stamina and utilize distinct attack types.

## Technical
- Implemented `EnemyFactory` for procedural stat generation.
- Added `EnemyAIService` decision trees.
- Integrated `CreatureTraitService` into the Combat Event loop.
```

---

*Next: v0.2.3 - The Hero's Toolkit (Abilities & Resources)*
