# v0.4.4b: The Galdr (Chanting System)

> **Status:** Planned
> **Parent:** v0.4.4 - The Mystic (Archetype Specialization)
> **Theme:** Multi-turn spellcasting through sustained incantation—power builds with patience, but concentration wavers under duress.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Deliverables Checklist](#deliverables-checklist)
5. [Implementation Workflow](#implementation-workflow)
6. [Code Examples](#code-examples)
7. [Logging Specification](#logging-specification)
8. [Unit Testing](#unit-testing)
9. [Integration Points](#integration-points)
10. [Domain 4 Compliance](#domain-4-compliance)
11. [Changelog Template](#changelog-template)

---

## Overview

v0.4.4b introduces **Galdr**—the ancient art of chanted magic. Unlike instant spells that release power in a single moment, Galdr spells accumulate potency over multiple turns through sustained concentration. This creates tactical depth: powerful effects require commitment and expose the caster to interruption.

### Core Concept

> *"The Old Ones did not merely speak power into being—they sang it, wove it through syllables that bent the Weave itself. A Galdr begun is a promise to the Aether; break that promise, and the Aether breaks you."*
> — Jötun-Reader Field Notes, Codex Entry #512

### Galdr vs Instant Spells

| Aspect | Instant Spells | Galdr (Chanted) |
|--------|----------------|-----------------|
| **Cast Time** | 1 turn | 2-5 turns |
| **Power** | Fixed base power | Accumulates per turn (+20% per turn sustained) |
| **AP Cost** | Spent immediately | Reserved, spent on completion |
| **Interruption** | N/A | Concentration checks on damage |
| **Movement** | Allowed after cast | Breaks chant immediately |
| **Backlash** | Standard risk | Amplified on interruption (lost energy backlash) |
| **Resonance** | Standard gain | Reduced gain (Channeled mode inherent) |

### Galdr Phases

| Phase | Description | Duration |
|-------|-------------|----------|
| **Weaving** | Initial turn—beginning the incantation | Turn 1 |
| **Sustaining** | Maintaining concentration, building power | Turns 2 to (N-1) |
| **Releasing** | Final turn—unleashing accumulated power | Turn N |

### Concentration Mechanics

When a chanting Mystic takes damage, they must make a **Concentration Check**:

- **Difficulty Class (DC)**: `max(10, Damage / 2)`
- **Check**: Roll WILL dice pool
- **Success Threshold**: Successes ≥ DC / 5 (rounded down)
- **Modifiers**:
  - `+2` pool from "Iron Focus" trait
  - `-1` pool per Stress tier (Anxious, Shaken, etc.)
  - `+1` pool from Steady resonance threshold

### Interruption Triggers

| Trigger | Save Allowed? | Consequence |
|---------|---------------|-------------|
| **Damage** | Yes (WILL save) | If failed: Interruption + Backlash |
| **Movement** | No | Automatic interruption |
| **Other Action** | No | Automatic interruption (except `wait`, `continue`) |
| **Silence Effect** | No | Automatic interruption + prevents new chants |
| **Voluntary Cancel** | N/A | Clean cancel, no backlash, partial resonance refund |

### Interruption Backlash

When a Galdr is forcibly interrupted (not voluntarily cancelled), the accumulated energy backfires:

| Accumulated Turns | Backlash Damage | Stress Inflicted |
|-------------------|-----------------|------------------|
| 1 turn | 1d6 | 5 |
| 2 turns | 2d6 | 10 |
| 3 turns | 3d6 | 15 |
| 4+ turns | 4d6 | 20 |

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        MagicService                              │
│   (Orchestrates spell casting, delegates to GaldrService)       │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       IGaldrService                              │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ + StartGaldr(caster, spell, target): GaldrStartResult       ││
│  │ + AdvanceGaldr(caster): GaldrAdvanceResult                  ││
│  │ + ReleaseGaldr(caster): GaldrReleaseResult                  ││
│  │ + InterruptGaldr(caster, reason): GaldrInterruptResult      ││
│  │ + CancelGaldr(caster): GaldrCancelResult                    ││
│  │ + CheckConcentration(caster, damage): ConcentrationResult   ││
│  │ + IsChanting(caster): bool                                  ││
│  │ + GetActiveGaldr(caster): GaldrState?                       ││
│  │ + GetAccumulatedPower(caster): decimal                      ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       GaldrService                               │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ - _logger: ILogger<GaldrService>                            ││
│  │ - _eventBus: IEventBus                                      ││
│  │ - _diceService: IDiceService                                ││
│  │ - _resonanceService: IResonanceService                      ││
│  │ - _backslashService: IBacklashService                       ││
│  │ - _statusEffectService: IStatusEffectService                ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────┬───────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┬───────────────┐
              ▼               ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   GaldrState    │ │   GaldrPhase    │ │InterruptReason  │ │ConcentrationRes │
│    (Model)      │ │     (Enum)      │ │    (Enum)       │ │    (Record)     │
└─────────────────┘ └─────────────────┘ └─────────────────┘ └─────────────────┘
```

### Layer Distribution

| Component | Layer | Namespace |
|-----------|-------|-----------|
| `GaldrState` | Core | `RuneAndRust.Core.Models.Magic` |
| `GaldrPhase` | Core | `RuneAndRust.Core.Enums` |
| `InterruptReason` | Core | `RuneAndRust.Core.Enums` |
| `GaldrStartResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `GaldrAdvanceResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `GaldrReleaseResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `GaldrInterruptResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `GaldrCancelResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `ConcentrationResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `GaldrStartedEvent` | Core | `RuneAndRust.Core.Events` |
| `GaldrAdvancedEvent` | Core | `RuneAndRust.Core.Events` |
| `GaldrCompletedEvent` | Core | `RuneAndRust.Core.Events` |
| `GaldrInterruptedEvent` | Core | `RuneAndRust.Core.Events` |
| `IGaldrService` | Core | `RuneAndRust.Core.Interfaces` |
| `GaldrService` | Engine | `RuneAndRust.Engine.Services` |
| `GaldrServiceTests` | Tests | `RuneAndRust.Tests.Services` |

### Spell Entity Extension

```csharp
// Extension to existing Spell entity
public class Spell
{
    // ... existing properties ...

    /// <summary>
    /// True if this spell requires multi-turn chanting.
    /// </summary>
    public bool IsGaldr { get; set; } = false;

    /// <summary>
    /// Number of turns required to complete the Galdr (2-5).
    /// Only applicable if IsGaldr is true.
    /// </summary>
    public int GaldrTurns { get; set; } = 0;

    /// <summary>
    /// Power multiplier per sustained turn (default 0.20 = +20% per turn).
    /// </summary>
    public decimal PowerAccumulationRate { get; set; } = 0.20m;
}
```

---

## Decision Trees

### DT-1: StartGaldr

```
StartGaldr(caster, spell, target)
│
├─► [1] Validate Caster is Mystic?
│   ├─ NO → Return Error("Only Mystics can perform Galdr")
│   └─ YES → Continue
│
├─► [2] Validate Spell is Galdr-Type?
│   ├─ NO → Return Error("This spell cannot be chanted")
│   └─ YES → Continue
│
├─► [3] Check Already Chanting?
│   ├─ YES → Return Error("Already sustaining a Galdr")
│   └─ NO → Continue
│
├─► [4] Check Silenced Status?
│   ├─ YES → Return Error("Cannot begin Galdr while silenced")
│   └─ NO → Continue
│
├─► [5] Validate AP Available?
│   │   (AP is reserved, not spent until completion)
│   ├─ NO → Return Error("Insufficient Aether Points")
│   └─ YES → Continue
│
├─► [6] Validate Target (if applicable)?
│   ├─ INVALID → Return Error("Invalid target")
│   └─ VALID → Continue
│
├─► [7] Initialize GaldrState
│   ├─ Set Spell reference
│   ├─ Set Target reference
│   ├─ Set TurnsRemaining = spell.GaldrTurns
│   ├─ Set TurnsSustained = 0
│   ├─ Set AccumulatedPower = 1.0m (base)
│   ├─ Set Phase = GaldrPhase.Weaving
│   └─ Set StartedAt = current turn
│
├─► [8] Reserve AP
│   └─ caster.ReservedAp += spell.ApCost
│
├─► [9] Apply Resonance Gain (Channeled mode inherent)
│   └─ ResonanceService.ModifyResonance(caster, +5, "Galdr begun")
│
├─► [10] Publish GaldrStartedEvent
│   └─ Include spell name, target, total turns required
│
└─► [11] Return GaldrStartResult
    ├─ Success = true
    ├─ Spell, Target, TurnsRequired
    └─ Message = "You begin the incantation of {SpellName}..."
```

### DT-2: AdvanceGaldr

```
AdvanceGaldr(caster)
│
├─► [1] Validate Active Galdr Exists?
│   ├─ NO → Return Error("No active Galdr to advance")
│   └─ YES → Continue
│
├─► [2] Check Silenced Status?
│   ├─ YES → Trigger Interruption (Silence)
│   └─ NO → Continue
│
├─► [3] Decrement TurnsRemaining
│   └─ galdrState.TurnsRemaining--
│
├─► [4] Increment TurnsSustained
│   └─ galdrState.TurnsSustained++
│
├─► [5] Accumulate Power
│   └─ galdrState.AccumulatedPower += spell.PowerAccumulationRate
│
├─► [6] Apply Resonance Gain
│   └─ ResonanceService.ModifyResonance(caster, +3, "Galdr sustained")
│
├─► [7] Update Phase
│   ├─ IF TurnsRemaining == 1 → Phase = Releasing
│   └─ ELSE → Phase = Sustaining
│
├─► [8] Check Completion?
│   ├─ TurnsRemaining == 0 → Trigger ReleaseGaldr()
│   └─ TurnsRemaining > 0 → Continue sustaining
│
├─► [9] Publish GaldrAdvancedEvent
│   └─ Include turns remaining, accumulated power
│
└─► [10] Return GaldrAdvanceResult
    ├─ TurnsRemaining, TurnsSustained
    ├─ AccumulatedPower, Phase
    └─ Message = "The incantation builds... ({N} turns remaining)"
```

### DT-3: ReleaseGaldr

```
ReleaseGaldr(caster)
│
├─► [1] Validate Active Galdr Exists?
│   ├─ NO → Return Error("No active Galdr to release")
│   └─ YES → Continue
│
├─► [2] Validate TurnsRemaining == 0?
│   ├─ NO → Return Error("Galdr not yet complete")
│   └─ YES → Continue
│
├─► [3] Calculate Final Power
│   ├─ basePower = spell.BasePower
│   ├─ accumulatedMultiplier = galdrState.AccumulatedPower
│   ├─ potencyModifier = ResonanceService.GetPotencyModifier(caster)
│   └─ finalPower = basePower * accumulatedMultiplier * potencyModifier
│
├─► [4] Spend Reserved AP
│   ├─ caster.ReservedAp -= spell.ApCost
│   └─ caster.CurrentAp -= spell.ApCost
│
├─► [5] Apply Flux (reduced for Channeled)
│   └─ AetherService.ModifyFlux(spell.FluxCost - 5, "Galdr released")
│
├─► [6] Execute Spell Effect
│   └─ EffectScriptExecutor.Execute(spell.EffectScript, target, finalPower)
│
├─► [7] Apply Final Resonance Gain
│   └─ ResonanceService.ModifyResonance(caster, +5, "Galdr completed")
│
├─► [8] Clear GaldrState
│   └─ caster.GaldrState = null
│
├─► [9] Publish GaldrCompletedEvent
│   └─ Include spell, final power, target, effect results
│
└─► [10] Return GaldrReleaseResult
    ├─ Success = true
    ├─ FinalPower, EffectResult
    └─ Message = "The {SpellName} culminates in a surge of power!"
```

### DT-4: CheckConcentration

```
CheckConcentration(caster, damageReceived)
│
├─► [1] Validate Active Galdr Exists?
│   ├─ NO → Return ConcentrationResult.NotApplicable
│   └─ YES → Continue
│
├─► [2] Calculate Difficulty Class
│   ├─ baseDC = 10
│   ├─ damageDC = damageReceived / 2
│   └─ finalDC = max(baseDC, damageDC)
│
├─► [3] Calculate Success Threshold
│   └─ threshold = finalDC / 5 (rounded down, minimum 1)
│
├─► [4] Build Dice Pool
│   ├─ basePool = caster.GetAttribute(Attribute.Will)
│   ├─ IF HasTrait("Iron Focus") → pool += 2
│   ├─ IF StressTier >= Anxious → pool -= 1
│   ├─ IF StressTier >= Shaken → pool -= 1 (cumulative)
│   ├─ IF ResonanceThreshold >= Steady → pool += 1
│   └─ finalPool = max(1, pool)
│
├─► [5] Roll Concentration Check
│   └─ result = DiceService.Roll(finalPool, "Concentration Check")
│
├─► [6] Evaluate Result
│   ├─ IF result.Successes >= threshold → MAINTAINED
│   └─ ELSE → BROKEN
│
├─► [7] Log Result
│   ├─ IF MAINTAINED → Info: "Concentration held despite {Damage} damage"
│   └─ IF BROKEN → Warning: "Concentration BROKEN by {Damage} damage!"
│
├─► [8] Handle Broken Concentration
│   └─ IF BROKEN → Call InterruptGaldr(caster, InterruptReason.DamageFailed)
│
└─► [9] Return ConcentrationResult
    ├─ Success (bool)
    ├─ DC, Threshold, DicePool
    ├─ Roll (successes, botches)
    └─ Modifiers applied
```

### DT-5: InterruptGaldr

```
InterruptGaldr(caster, reason)
│
├─► [1] Validate Active Galdr Exists?
│   ├─ NO → Return Error("No active Galdr to interrupt")
│   └─ YES → Continue
│
├─► [2] Capture State Before Clearing
│   ├─ spell = galdrState.Spell
│   ├─ turnsSustained = galdrState.TurnsSustained
│   ├─ accumulatedPower = galdrState.AccumulatedPower
│   └─ target = galdrState.Target
│
├─► [3] Calculate Backlash Damage
│   ├─ diceCount = min(turnsSustained, 4)
│   ├─ roll d6 * diceCount
│   └─ backlashDamage = sum of rolls
│
├─► [4] Calculate Stress Inflicted
│   └─ stressAmount = 5 * min(turnsSustained, 4)
│
├─► [5] Apply Backlash Damage to Caster
│   └─ caster.CurrentHp -= backlashDamage
│
├─► [6] Apply Stress
│   └─ TraumaService.InflictStress(caster, stressAmount, "Galdr Backlash")
│
├─► [7] Refund Reserved AP (not spent since not completed)
│   └─ caster.ReservedAp -= spell.ApCost
│
├─► [8] Apply Partial Flux (energy released chaotically)
│   └─ AetherService.ModifyFlux(spell.FluxCost / 2, "Galdr interrupted")
│
├─► [9] Clear GaldrState
│   └─ caster.GaldrState = null
│
├─► [10] Publish GaldrInterruptedEvent
│   └─ Include reason, backlash damage, stress, turns lost
│
└─► [11] Return GaldrInterruptResult
    ├─ Reason (Damage, Movement, Action, Silence)
    ├─ BacklashDamage, StressInflicted
    ├─ TurnsLost, PowerLost
    └─ Message = "The Galdr shatters! Aetheric backlash deals {X} damage!"
```

### DT-6: CancelGaldr (Voluntary)

```
CancelGaldr(caster)
│
├─► [1] Validate Active Galdr Exists?
│   ├─ NO → Return Error("No active Galdr to cancel")
│   └─ YES → Continue
│
├─► [2] Capture State Before Clearing
│   └─ spell = galdrState.Spell
│
├─► [3] Refund Reserved AP
│   └─ caster.ReservedAp -= spell.ApCost
│
├─► [4] Partial Resonance Refund (50%)
│   ├─ resonanceGained = 5 + (3 * turnsSustained)
│   ├─ refundAmount = resonanceGained / 2
│   └─ ResonanceService.ModifyResonance(caster, -refundAmount, "Galdr cancelled")
│
├─► [5] No Backlash (voluntary cancel)
│   └─ backlashDamage = 0, stress = 0
│
├─► [6] Clear GaldrState
│   └─ caster.GaldrState = null
│
├─► [7] Log Cancellation
│   └─ Info: "{Name} voluntarily cancels {SpellName}"
│
└─► [8] Return GaldrCancelResult
    ├─ Success = true
    ├─ ResonanceRefunded
    └─ Message = "You release the incantation harmlessly."
```

### DT-7: ProcessTurnStart (CombatService Integration)

```
ProcessTurnStart(combatant)
│
├─► [1] Check if Combatant has Active Galdr
│   ├─ NO → Continue to other turn-start processing
│   └─ YES → Continue
│
├─► [2] Check Phase
│   ├─ IF Phase == Weaving → Transition to Sustaining
│   ├─ IF Phase == Sustaining → Call AdvanceGaldr
│   └─ IF Phase == Releasing → Auto-trigger ReleaseGaldr
│
└─► [3] Return to Normal Turn Processing
```

### DT-8: OnDamageReceived Hook

```
OnDamageReceived(combatant, damage, source)
│
├─► [1] Check if Combatant has Active Galdr
│   ├─ NO → Return (no concentration check needed)
│   └─ YES → Continue
│
├─► [2] Call CheckConcentration
│   └─ result = GaldrService.CheckConcentration(combatant, damage)
│
├─► [3] If Concentration Broken
│   └─ Interruption already handled by CheckConcentration
│
└─► [4] Return to Damage Processing
```

---

## Deliverables Checklist

### Core Layer (`RuneAndRust.Core`)

- [ ] **Enums**
  - [ ] `GaldrPhase.cs` - None, Weaving, Sustaining, Releasing
  - [ ] `InterruptReason.cs` - DamageFailed, Movement, Action, Silence, Voluntary

- [ ] **Models**
  - [ ] `GaldrState.cs` - Active chant tracking
  - [ ] `GaldrStartResult.cs` - Start operation result
  - [ ] `GaldrAdvanceResult.cs` - Advance operation result
  - [ ] `GaldrReleaseResult.cs` - Release operation result
  - [ ] `GaldrInterruptResult.cs` - Interrupt operation result
  - [ ] `GaldrCancelResult.cs` - Cancel operation result
  - [ ] `ConcentrationResult.cs` - Concentration check result

- [ ] **Events**
  - [ ] `GaldrStartedEvent.cs` - Published when Galdr begins
  - [ ] `GaldrAdvancedEvent.cs` - Published each sustained turn
  - [ ] `GaldrCompletedEvent.cs` - Published on successful release
  - [ ] `GaldrInterruptedEvent.cs` - Published on forced interruption

- [ ] **Interfaces**
  - [ ] `IGaldrService.cs` - Service contract

- [ ] **Entity Extensions**
  - [ ] Add `IsGaldr`, `GaldrTurns`, `PowerAccumulationRate` to `Spell` entity
  - [ ] Add `GaldrState`, `ReservedAp` to `Character`/`Combatant`

### Engine Layer (`RuneAndRust.Engine`)

- [ ] **Services**
  - [ ] `GaldrService.cs` - Full implementation with logging

- [ ] **Integration**
  - [ ] `CombatService` - Hook `OnDamageReceived` for concentration checks
  - [ ] `CombatService` - Hook `ProcessTurnStart` for Galdr advancement
  - [ ] `MagicService` - Delegate Galdr spells to `GaldrService`

### Terminal Layer (`RuneAndRust.Terminal`)

- [ ] **Commands**
  - [ ] `chant [spell]` - Begin a Galdr
  - [ ] `continue` - Sustain current Galdr (or auto-advance)
  - [ ] `release` - Manually release Galdr (if ready)
  - [ ] `cancel` - Voluntarily cancel Galdr

- [ ] **Widgets**
  - [ ] `GaldrWidget` - Display active chant status, turns remaining, power

### Infrastructure Layer

- [ ] **DI Registration**
  - [ ] Register `IGaldrService` → `GaldrService` in `Program.cs`

### Test Layer (`RuneAndRust.Tests`)

- [ ] **Unit Tests**
  - [ ] `GaldrServiceTests.cs` - 45+ unit tests

### Database

- [ ] **Migration**
  - [ ] Add Galdr columns to Spell table
  - [ ] Seed 4-6 Galdr spells

---

## Implementation Workflow

### Phase 1: Foundation (Enums & Models)

```
Step 1.1: Create GaldrPhase enum
Step 1.2: Create InterruptReason enum
Step 1.3: Create GaldrState model
Step 1.4: Create all result records (Start, Advance, Release, Interrupt, Cancel)
Step 1.5: Create ConcentrationResult record
Step 1.6: Extend Spell entity with Galdr properties
Step 1.7: Extend Character/Combatant with GaldrState and ReservedAp
Step 1.8: Build and verify Core compiles
```

### Phase 2: Events

```
Step 2.1: Create GaldrStartedEvent
Step 2.2: Create GaldrAdvancedEvent
Step 2.3: Create GaldrCompletedEvent
Step 2.4: Create GaldrInterruptedEvent
Step 2.5: Verify event bus compatibility
```

### Phase 3: Interface

```
Step 3.1: Create IGaldrService interface
Step 3.2: Define all method signatures with XML docs
Step 3.3: Review interface with team (if applicable)
```

### Phase 4: Service Implementation

```
Step 4.1: Create GaldrService class skeleton with DI
Step 4.2: Implement IsChanting, GetActiveGaldr (simple queries)
Step 4.3: Implement StartGaldr with full validation
Step 4.4: Implement AdvanceGaldr with power accumulation
Step 4.5: Implement CheckConcentration with dice pool modifiers
Step 4.6: Implement InterruptGaldr with backlash calculation
Step 4.7: Implement CancelGaldr with resonance refund
Step 4.8: Implement ReleaseGaldr with effect execution
Step 4.9: Implement GetAccumulatedPower helper
Step 4.10: Add comprehensive logging throughout
```

### Phase 5: Testing

```
Step 5.1: Create GaldrServiceTests class with test fixtures
Step 5.2: Implement StartGaldr tests (7)
Step 5.3: Implement AdvanceGaldr tests (8)
Step 5.4: Implement CheckConcentration tests (12)
Step 5.5: Implement InterruptGaldr tests (8)
Step 5.6: Implement CancelGaldr tests (4)
Step 5.7: Implement ReleaseGaldr tests (4)
Step 5.8: Implement Integration tests (2)
Step 5.9: Verify 80%+ code coverage
```

### Phase 6: Integration

```
Step 6.1: Register GaldrService in DI container
Step 6.2: Integrate with CombatService (damage hook)
Step 6.3: Integrate with CombatService (turn processing)
Step 6.4: Integrate with MagicService (Galdr delegation)
Step 6.5: Add TUI commands (chant, continue, release, cancel)
Step 6.6: Create GaldrWidget for status display
Step 6.7: End-to-end manual testing
```

### Phase 7: Content

```
Step 7.1: Create database migration for Spell extension
Step 7.2: Seed 4-6 Galdr spells across schools
Step 7.3: Test seeded spells in-game
```

---

## Code Examples

### GaldrPhase.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Represents the current phase of an active Galdr (chanted spell).
/// </summary>
public enum GaldrPhase
{
    /// <summary>
    /// No active Galdr.
    /// </summary>
    None = 0,

    /// <summary>
    /// First turn—beginning the incantation.
    /// </summary>
    Weaving = 1,

    /// <summary>
    /// Middle turns—sustaining concentration and building power.
    /// </summary>
    Sustaining = 2,

    /// <summary>
    /// Final turn—ready to release accumulated power.
    /// </summary>
    Releasing = 3
}
```

### InterruptReason.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Reasons why a Galdr may be interrupted.
/// </summary>
public enum InterruptReason
{
    /// <summary>
    /// Failed concentration check after taking damage.
    /// </summary>
    DamageFailed = 0,

    /// <summary>
    /// Caster moved during the chant.
    /// </summary>
    Movement = 1,

    /// <summary>
    /// Caster took another action (not wait/continue).
    /// </summary>
    Action = 2,

    /// <summary>
    /// Caster was silenced.
    /// </summary>
    Silence = 3,

    /// <summary>
    /// Caster voluntarily cancelled (no backlash).
    /// </summary>
    Voluntary = 4
}
```

### GaldrState.cs

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Tracks the state of an active Galdr (multi-turn chanted spell).
/// </summary>
public class GaldrState
{
    /// <summary>
    /// The spell being chanted.
    /// </summary>
    public required Spell Spell { get; set; }

    /// <summary>
    /// The intended target of the spell (if applicable).
    /// </summary>
    public Guid? TargetId { get; set; }

    /// <summary>
    /// Current phase of the Galdr.
    /// </summary>
    public GaldrPhase Phase { get; set; } = GaldrPhase.Weaving;

    /// <summary>
    /// Number of turns remaining until the Galdr can be released.
    /// </summary>
    public int TurnsRemaining { get; set; }

    /// <summary>
    /// Number of turns the caster has successfully sustained the chant.
    /// </summary>
    public int TurnsSustained { get; set; } = 0;

    /// <summary>
    /// Accumulated power multiplier (starts at 1.0, increases per turn).
    /// </summary>
    public decimal AccumulatedPower { get; set; } = 1.0m;

    /// <summary>
    /// Combat round when the Galdr was started.
    /// </summary>
    public int StartedAtRound { get; set; }

    /// <summary>
    /// Turn index when the Galdr was started.
    /// </summary>
    public int StartedAtTurn { get; set; }

    /// <summary>
    /// True if the Galdr is ready to be released (TurnsRemaining == 0).
    /// </summary>
    public bool IsReadyToRelease => TurnsRemaining <= 0;

    /// <summary>
    /// True if the Galdr is in progress (not None phase).
    /// </summary>
    public bool IsActive => Phase != GaldrPhase.None;

    /// <summary>
    /// Percentage of completion (0-100).
    /// </summary>
    public int CompletionPercent => Spell.GaldrTurns > 0
        ? (int)((TurnsSustained / (decimal)Spell.GaldrTurns) * 100)
        : 0;

    /// <summary>
    /// Creates a new GaldrState for the given spell.
    /// </summary>
    public static GaldrState Create(Spell spell, Guid? targetId, int currentRound, int currentTurn)
    {
        return new GaldrState
        {
            Spell = spell,
            TargetId = targetId,
            Phase = GaldrPhase.Weaving,
            TurnsRemaining = spell.GaldrTurns,
            TurnsSustained = 0,
            AccumulatedPower = 1.0m,
            StartedAtRound = currentRound,
            StartedAtTurn = currentTurn
        };
    }
}
```

### ConcentrationResult.cs

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Result of a concentration check when a chanting Mystic takes damage.
/// </summary>
public record ConcentrationResult(
    bool Success,
    int DifficultyClass,
    int SuccessThreshold,
    int DicePool,
    int Successes,
    int Botches,
    IReadOnlyList<int> Rolls,
    IReadOnlyDictionary<string, int> Modifiers)
{
    /// <summary>
    /// True if concentration was maintained.
    /// </summary>
    public bool ConcentrationMaintained => Success;

    /// <summary>
    /// True if concentration was broken (Galdr will be interrupted).
    /// </summary>
    public bool ConcentrationBroken => !Success;

    /// <summary>
    /// Margin of success (positive) or failure (negative).
    /// </summary>
    public int Margin => Successes - SuccessThreshold;

    /// <summary>
    /// True if the roll was a fumble (0 successes with botches).
    /// </summary>
    public bool IsFumble => Successes == 0 && Botches > 0;

    /// <summary>
    /// Factory for creating a "not applicable" result (no active Galdr).
    /// </summary>
    public static ConcentrationResult NotApplicable => new(
        Success: true,
        DifficultyClass: 0,
        SuccessThreshold: 0,
        DicePool: 0,
        Successes: 0,
        Botches: 0,
        Rolls: Array.Empty<int>(),
        Modifiers: new Dictionary<string, int>());
}
```

### GaldrInterruptResult.cs

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Result of a Galdr interruption (forced or voluntary).
/// </summary>
public record GaldrInterruptResult(
    bool WasInterrupted,
    InterruptReason Reason,
    string SpellName,
    int TurnsLost,
    decimal PowerLost,
    int BacklashDamage,
    int StressInflicted,
    int FluxReleased,
    string Message)
{
    /// <summary>
    /// True if this was a voluntary cancellation (no backlash).
    /// </summary>
    public bool WasVoluntary => Reason == InterruptReason.Voluntary;

    /// <summary>
    /// True if backlash damage was applied.
    /// </summary>
    public bool HadBacklash => BacklashDamage > 0;

    /// <summary>
    /// Factory for error results.
    /// </summary>
    public static GaldrInterruptResult Error(string message) => new(
        WasInterrupted: false,
        Reason: InterruptReason.Voluntary,
        SpellName: "",
        TurnsLost: 0,
        PowerLost: 0,
        BacklashDamage: 0,
        StressInflicted: 0,
        FluxReleased: 0,
        Message: message);
}
```

### IGaldrService.cs

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for managing Galdr (multi-turn chanted spells).
/// </summary>
public interface IGaldrService
{
    /// <summary>
    /// Begins a new Galdr incantation.
    /// </summary>
    GaldrStartResult StartGaldr(Character caster, Spell spell, Guid? targetId);

    /// <summary>
    /// Advances an active Galdr by one turn, accumulating power.
    /// </summary>
    GaldrAdvanceResult AdvanceGaldr(Character caster);

    /// <summary>
    /// Releases a completed Galdr, executing its effect with accumulated power.
    /// </summary>
    GaldrReleaseResult ReleaseGaldr(Character caster);

    /// <summary>
    /// Forcibly interrupts an active Galdr, applying backlash.
    /// </summary>
    GaldrInterruptResult InterruptGaldr(Character caster, InterruptReason reason);

    /// <summary>
    /// Voluntarily cancels an active Galdr without backlash.
    /// </summary>
    GaldrCancelResult CancelGaldr(Character caster);

    /// <summary>
    /// Performs a concentration check when the caster takes damage.
    /// </summary>
    ConcentrationResult CheckConcentration(Character caster, int damageReceived);

    /// <summary>
    /// Returns true if the character has an active Galdr.
    /// </summary>
    bool IsChanting(Character caster);

    /// <summary>
    /// Gets the active Galdr state, or null if not chanting.
    /// </summary>
    GaldrState? GetActiveGaldr(Character caster);

    /// <summary>
    /// Gets the accumulated power multiplier for the active Galdr.
    /// </summary>
    decimal GetAccumulatedPower(Character caster);
}
```

### GaldrService.cs

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models;
using RuneAndRust.Core.Models.Magic;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Manages Galdr (multi-turn chanted spells) including concentration and interruption.
/// </summary>
public class GaldrService : IGaldrService
{
    private readonly ILogger<GaldrService> _logger;
    private readonly IEventBus _eventBus;
    private readonly IDiceService _diceService;
    private readonly IResonanceService _resonanceService;
    private readonly IBacklashService _backlashService;
    private readonly IStatusEffectService _statusEffectService;
    private readonly IAetherService _aetherService;

    private const int BaseConcentrationDC = 10;
    private const int ResonanceGainOnStart = 5;
    private const int ResonanceGainPerTurn = 3;
    private const int ResonanceGainOnComplete = 5;
    private const int MaxBacklashDice = 4;
    private const int StressPerSustainedTurn = 5;

    public GaldrService(
        ILogger<GaldrService> logger,
        IEventBus eventBus,
        IDiceService diceService,
        IResonanceService resonanceService,
        IBacklashService backlashService,
        IStatusEffectService statusEffectService,
        IAetherService aetherService)
    {
        _logger = logger;
        _eventBus = eventBus;
        _diceService = diceService;
        _resonanceService = resonanceService;
        _backlashService = backlashService;
        _statusEffectService = statusEffectService;
        _aetherService = aetherService;

        _logger.LogDebug("GaldrService initialized");
    }

    /// <inheritdoc />
    public GaldrStartResult StartGaldr(Character caster, Spell spell, Guid? targetId)
    {
        _logger.LogDebug(
            "StartGaldr called: Caster={Name}, Spell={Spell}, Target={Target}",
            caster.Name, spell.Name, targetId);

        // Validate caster is Mystic
        if (caster.Archetype != ArchetypeType.Mystic)
        {
            _logger.LogWarning("StartGaldr failed: {Name} is not a Mystic", caster.Name);
            return GaldrStartResult.Error("Only Mystics can perform Galdr");
        }

        // Validate spell is Galdr-type
        if (!spell.IsGaldr)
        {
            _logger.LogWarning("StartGaldr failed: {Spell} is not a Galdr spell", spell.Name);
            return GaldrStartResult.Error($"{spell.Name} cannot be chanted as a Galdr");
        }

        // Check not already chanting
        if (IsChanting(caster))
        {
            _logger.LogWarning("StartGaldr failed: {Name} already chanting", caster.Name);
            return GaldrStartResult.Error("You are already sustaining a Galdr");
        }

        // Check not silenced
        if (_statusEffectService.HasEffect(caster, StatusEffectType.Silenced))
        {
            _logger.LogWarning("StartGaldr failed: {Name} is silenced", caster.Name);
            return GaldrStartResult.Error("Cannot begin a Galdr while silenced");
        }

        // Validate AP available (reserve, don't spend)
        if (caster.CurrentAp < spell.ApCost)
        {
            _logger.LogWarning(
                "StartGaldr failed: {Name} has insufficient AP ({Current}/{Required})",
                caster.Name, caster.CurrentAp, spell.ApCost);
            return GaldrStartResult.Error("Insufficient Aether Points");
        }

        // Initialize GaldrState
        var galdrState = GaldrState.Create(
            spell,
            targetId,
            currentRound: 0, // TODO: Get from CombatState
            currentTurn: 0);

        caster.GaldrState = galdrState;

        // Reserve AP
        caster.ReservedAp += spell.ApCost;

        _logger.LogTrace(
            "Reserved {AP} AP for Galdr, TurnsRequired={Turns}",
            spell.ApCost, spell.GaldrTurns);

        // Apply initial resonance gain
        _resonanceService.ModifyResonance(caster, ResonanceGainOnStart, $"Galdr begun: {spell.Name}");

        // Publish event
        var startEvent = new GaldrStartedEvent(
            CasterId: caster.Id,
            CasterName: caster.Name,
            SpellName: spell.Name,
            TargetId: targetId,
            TurnsRequired: spell.GaldrTurns);

        _eventBus.Publish(startEvent);

        _logger.LogInformation(
            "Galdr started: {Name} begins chanting {Spell} ({Turns} turns)",
            caster.Name, spell.Name, spell.GaldrTurns);

        return new GaldrStartResult(
            Success: true,
            SpellName: spell.Name,
            TargetId: targetId,
            TurnsRequired: spell.GaldrTurns,
            ApReserved: spell.ApCost,
            Message: $"You begin the incantation of {spell.Name}...");
    }

    /// <inheritdoc />
    public GaldrAdvanceResult AdvanceGaldr(Character caster)
    {
        _logger.LogDebug("AdvanceGaldr called: Caster={Name}", caster.Name);

        var galdrState = caster.GaldrState;
        if (galdrState == null || !galdrState.IsActive)
        {
            _logger.LogWarning("AdvanceGaldr failed: No active Galdr for {Name}", caster.Name);
            return GaldrAdvanceResult.Error("No active Galdr to advance");
        }

        // Check for silence (breaks chant)
        if (_statusEffectService.HasEffect(caster, StatusEffectType.Silenced))
        {
            _logger.LogWarning("Galdr broken by Silence for {Name}", caster.Name);
            InterruptGaldr(caster, InterruptReason.Silence);
            return GaldrAdvanceResult.Interrupted("Your voice is silenced—the Galdr shatters!");
        }

        // Decrement turns remaining
        galdrState.TurnsRemaining--;
        galdrState.TurnsSustained++;

        // Accumulate power
        var powerGain = galdrState.Spell.PowerAccumulationRate;
        galdrState.AccumulatedPower += powerGain;

        _logger.LogTrace(
            "Galdr advanced: TurnsRemaining={Remaining}, TurnsSustained={Sustained}, Power={Power}",
            galdrState.TurnsRemaining, galdrState.TurnsSustained, galdrState.AccumulatedPower);

        // Apply resonance gain
        _resonanceService.ModifyResonance(caster, ResonanceGainPerTurn, "Galdr sustained");

        // Update phase
        if (galdrState.TurnsRemaining <= 0)
        {
            galdrState.Phase = GaldrPhase.Releasing;
        }
        else if (galdrState.Phase == GaldrPhase.Weaving)
        {
            galdrState.Phase = GaldrPhase.Sustaining;
        }

        // Publish event
        var advanceEvent = new GaldrAdvancedEvent(
            CasterId: caster.Id,
            CasterName: caster.Name,
            SpellName: galdrState.Spell.Name,
            TurnsRemaining: galdrState.TurnsRemaining,
            TurnsSustained: galdrState.TurnsSustained,
            AccumulatedPower: galdrState.AccumulatedPower,
            Phase: galdrState.Phase);

        _eventBus.Publish(advanceEvent);

        var message = galdrState.IsReadyToRelease
            ? $"The {galdrState.Spell.Name} is ready to release!"
            : $"The incantation builds... ({galdrState.TurnsRemaining} turns remaining)";

        _logger.LogInformation(
            "Galdr advanced for {Name}: {Spell} at {Power:P0} power, {Remaining} turns remaining",
            caster.Name, galdrState.Spell.Name, galdrState.AccumulatedPower, galdrState.TurnsRemaining);

        return new GaldrAdvanceResult(
            Success: true,
            SpellName: galdrState.Spell.Name,
            TurnsRemaining: galdrState.TurnsRemaining,
            TurnsSustained: galdrState.TurnsSustained,
            AccumulatedPower: galdrState.AccumulatedPower,
            Phase: galdrState.Phase,
            IsReadyToRelease: galdrState.IsReadyToRelease,
            Message: message);
    }

    /// <inheritdoc />
    public ConcentrationResult CheckConcentration(Character caster, int damageReceived)
    {
        _logger.LogDebug(
            "CheckConcentration called: Caster={Name}, Damage={Damage}",
            caster.Name, damageReceived);

        var galdrState = caster.GaldrState;
        if (galdrState == null || !galdrState.IsActive)
        {
            _logger.LogTrace("No active Galdr for {Name}, concentration check not applicable", caster.Name);
            return ConcentrationResult.NotApplicable;
        }

        // Calculate DC: max(10, damage/2)
        var damageDC = damageReceived / 2;
        var finalDC = Math.Max(BaseConcentrationDC, damageDC);

        // Calculate success threshold: DC / 5, minimum 1
        var threshold = Math.Max(1, finalDC / 5);

        _logger.LogTrace(
            "Concentration DC: max({Base}, {DamageDC}) = {Final}, Threshold = {Threshold}",
            BaseConcentrationDC, damageDC, finalDC, threshold);

        // Build dice pool with modifiers
        var modifiers = new Dictionary<string, int>();
        var baseWill = caster.GetAttribute(CharacterAttribute.Will);
        modifiers["Base WILL"] = baseWill;

        var pool = baseWill;

        // Iron Focus trait bonus
        if (caster.HasTrait("Iron Focus"))
        {
            pool += 2;
            modifiers["Iron Focus"] = 2;
        }

        // Stress penalties
        var stressTier = GetStressTier(caster.CurrentStress);
        if (stressTier >= 1) // Anxious
        {
            pool -= 1;
            modifiers["Stress (Anxious)"] = -1;
        }
        if (stressTier >= 2) // Shaken
        {
            pool -= 1;
            modifiers["Stress (Shaken)"] = -1;
        }

        // Resonance bonus at Steady+
        var resonanceThreshold = _resonanceService.GetThreshold(caster);
        if (resonanceThreshold >= ResonanceThreshold.Steady)
        {
            pool += 1;
            modifiers["Resonance (Steady)"] = 1;
        }

        // Ensure minimum pool of 1
        pool = Math.Max(1, pool);

        _logger.LogTrace("Concentration pool: {Pool} dice", pool);

        // Roll concentration check
        var rollResult = _diceService.Roll(pool, $"{caster.Name} Concentration Check");

        var success = rollResult.Successes >= threshold;

        _logger.LogInformation(
            "Concentration check for {Name}: {Successes} successes vs {Threshold} threshold = {Result}",
            caster.Name, rollResult.Successes, threshold, success ? "MAINTAINED" : "BROKEN");

        // If failed, trigger interruption
        if (!success)
        {
            _logger.LogWarning(
                "Concentration BROKEN for {Name}! Damage={Damage}, Rolled {Successes}/{Threshold}",
                caster.Name, damageReceived, rollResult.Successes, threshold);

            InterruptGaldr(caster, InterruptReason.DamageFailed);
        }

        return new ConcentrationResult(
            Success: success,
            DifficultyClass: finalDC,
            SuccessThreshold: threshold,
            DicePool: pool,
            Successes: rollResult.Successes,
            Botches: rollResult.Botches,
            Rolls: rollResult.Rolls,
            Modifiers: modifiers);
    }

    /// <inheritdoc />
    public GaldrInterruptResult InterruptGaldr(Character caster, InterruptReason reason)
    {
        _logger.LogDebug(
            "InterruptGaldr called: Caster={Name}, Reason={Reason}",
            caster.Name, reason);

        var galdrState = caster.GaldrState;
        if (galdrState == null || !galdrState.IsActive)
        {
            _logger.LogWarning("InterruptGaldr failed: No active Galdr for {Name}", caster.Name);
            return GaldrInterruptResult.Error("No active Galdr to interrupt");
        }

        // Capture state before clearing
        var spellName = galdrState.Spell.Name;
        var turnsSustained = galdrState.TurnsSustained;
        var accumulatedPower = galdrState.AccumulatedPower;
        var apReserved = galdrState.Spell.ApCost;

        // Calculate backlash (for non-voluntary interrupts)
        var backlashDamage = 0;
        var stressInflicted = 0;

        if (reason != InterruptReason.Voluntary)
        {
            // Backlash damage: 1d6 per turn sustained, max 4d6
            var diceCount = Math.Min(turnsSustained, MaxBacklashDice);
            if (diceCount > 0)
            {
                for (var i = 0; i < diceCount; i++)
                {
                    backlashDamage += _diceService.RollSingle(6, $"Galdr Backlash {i + 1}");
                }
            }

            // Stress: 5 per sustained turn, max 20
            stressInflicted = Math.Min(turnsSustained * StressPerSustainedTurn, 20);

            // Apply backlash damage
            caster.CurrentHp -= backlashDamage;

            _logger.LogWarning(
                "Galdr backlash for {Name}: {Damage} damage, {Stress} stress",
                caster.Name, backlashDamage, stressInflicted);

            // Apply stress via trauma service (if available)
            // _traumaService.InflictStress(caster, stressInflicted, "Galdr Backlash");
        }

        // Refund reserved AP (not spent)
        caster.ReservedAp -= apReserved;

        // Release partial flux (chaotic energy)
        var fluxReleased = galdrState.Spell.FluxCost / 2;
        _aetherService.ModifyFlux(fluxReleased, "Galdr interrupted");

        // Clear GaldrState
        caster.GaldrState = null;

        // Publish event
        var interruptEvent = new GaldrInterruptedEvent(
            CasterId: caster.Id,
            CasterName: caster.Name,
            SpellName: spellName,
            Reason: reason,
            TurnsLost: turnsSustained,
            PowerLost: accumulatedPower,
            BacklashDamage: backlashDamage,
            StressInflicted: stressInflicted);

        _eventBus.Publish(interruptEvent);

        var message = reason switch
        {
            InterruptReason.DamageFailed => $"The Galdr shatters! Aetheric backlash deals {backlashDamage} damage!",
            InterruptReason.Movement => "Your movement breaks the incantation!",
            InterruptReason.Action => "Taking another action disrupts the Galdr!",
            InterruptReason.Silence => "Silence smothers the incantation!",
            InterruptReason.Voluntary => "You release the incantation harmlessly.",
            _ => "The Galdr is interrupted!"
        };

        _logger.LogInformation(
            "Galdr interrupted for {Name}: {Spell}, Reason={Reason}, Backlash={Damage}",
            caster.Name, spellName, reason, backlashDamage);

        return new GaldrInterruptResult(
            WasInterrupted: true,
            Reason: reason,
            SpellName: spellName,
            TurnsLost: turnsSustained,
            PowerLost: accumulatedPower,
            BacklashDamage: backlashDamage,
            StressInflicted: stressInflicted,
            FluxReleased: fluxReleased,
            Message: message);
    }

    /// <inheritdoc />
    public GaldrCancelResult CancelGaldr(Character caster)
    {
        _logger.LogDebug("CancelGaldr called: Caster={Name}", caster.Name);

        var galdrState = caster.GaldrState;
        if (galdrState == null || !galdrState.IsActive)
        {
            _logger.LogWarning("CancelGaldr failed: No active Galdr for {Name}", caster.Name);
            return GaldrCancelResult.Error("No active Galdr to cancel");
        }

        var spellName = galdrState.Spell.Name;
        var turnsSustained = galdrState.TurnsSustained;

        // Calculate resonance refund (50% of gained)
        var resonanceGained = ResonanceGainOnStart + (ResonanceGainPerTurn * turnsSustained);
        var resonanceRefund = resonanceGained / 2;

        // Refund reserved AP
        caster.ReservedAp -= galdrState.Spell.ApCost;

        // Apply resonance refund (negative modification)
        _resonanceService.ModifyResonance(caster, -resonanceRefund, "Galdr cancelled");

        // Clear GaldrState
        caster.GaldrState = null;

        _logger.LogInformation(
            "Galdr cancelled for {Name}: {Spell}, Refunded {Resonance} resonance",
            caster.Name, spellName, resonanceRefund);

        return new GaldrCancelResult(
            Success: true,
            SpellName: spellName,
            ResonanceRefunded: resonanceRefund,
            Message: "You release the incantation harmlessly.");
    }

    /// <inheritdoc />
    public GaldrReleaseResult ReleaseGaldr(Character caster)
    {
        _logger.LogDebug("ReleaseGaldr called: Caster={Name}", caster.Name);

        var galdrState = caster.GaldrState;
        if (galdrState == null || !galdrState.IsActive)
        {
            _logger.LogWarning("ReleaseGaldr failed: No active Galdr for {Name}", caster.Name);
            return GaldrReleaseResult.Error("No active Galdr to release");
        }

        if (!galdrState.IsReadyToRelease)
        {
            _logger.LogWarning(
                "ReleaseGaldr failed: Galdr not ready ({Remaining} turns remaining)",
                galdrState.TurnsRemaining);
            return GaldrReleaseResult.Error(
                $"The Galdr is not yet complete ({galdrState.TurnsRemaining} turns remaining)");
        }

        var spell = galdrState.Spell;
        var targetId = galdrState.TargetId;

        // Calculate final power
        var basePower = spell.BasePower;
        var accumulatedMultiplier = galdrState.AccumulatedPower;
        var potencyModifier = _resonanceService.GetPotencyModifier(caster);
        var finalPower = basePower * accumulatedMultiplier * potencyModifier;

        _logger.LogTrace(
            "Galdr power calculation: {Base} * {Accumulated} * {Potency} = {Final}",
            basePower, accumulatedMultiplier, potencyModifier, finalPower);

        // Spend reserved AP
        caster.ReservedAp -= spell.ApCost;
        caster.CurrentAp -= spell.ApCost;

        // Apply flux (reduced for channeled)
        var fluxCost = Math.Max(0, spell.FluxCost - 5);
        _aetherService.ModifyFlux(fluxCost, $"Galdr released: {spell.Name}");

        // Apply final resonance gain
        _resonanceService.ModifyResonance(caster, ResonanceGainOnComplete, "Galdr completed");

        // TODO: Execute spell effect via EffectScriptExecutor
        // var effectResult = _effectExecutor.Execute(spell.EffectScript, target, finalPower);

        // Clear GaldrState
        caster.GaldrState = null;

        // Publish event
        var completeEvent = new GaldrCompletedEvent(
            CasterId: caster.Id,
            CasterName: caster.Name,
            SpellName: spell.Name,
            TargetId: targetId,
            FinalPower: finalPower,
            TurnsSustained: galdrState.TurnsSustained);

        _eventBus.Publish(completeEvent);

        _logger.LogInformation(
            "Galdr completed: {Name} releases {Spell} with {Power:F1} power!",
            caster.Name, spell.Name, finalPower);

        return new GaldrReleaseResult(
            Success: true,
            SpellName: spell.Name,
            TargetId: targetId,
            FinalPower: finalPower,
            ApSpent: spell.ApCost,
            FluxAdded: fluxCost,
            Message: $"The {spell.Name} culminates in a surge of power!");
    }

    /// <inheritdoc />
    public bool IsChanting(Character caster)
    {
        return caster.GaldrState?.IsActive ?? false;
    }

    /// <inheritdoc />
    public GaldrState? GetActiveGaldr(Character caster)
    {
        return caster.GaldrState?.IsActive == true ? caster.GaldrState : null;
    }

    /// <inheritdoc />
    public decimal GetAccumulatedPower(Character caster)
    {
        return caster.GaldrState?.AccumulatedPower ?? 1.0m;
    }

    /// <summary>
    /// Gets the stress tier (0=Calm, 1=Anxious, 2=Shaken, 3+=Panicked).
    /// </summary>
    private static int GetStressTier(int currentStress)
    {
        return currentStress switch
        {
            >= 75 => 3,
            >= 50 => 2,
            >= 25 => 1,
            _ => 0
        };
    }
}
```

### Events

```csharp
// GaldrStartedEvent.cs
namespace RuneAndRust.Core.Events;

public record GaldrStartedEvent(
    Guid CasterId,
    string CasterName,
    string SpellName,
    Guid? TargetId,
    int TurnsRequired);

// GaldrAdvancedEvent.cs
public record GaldrAdvancedEvent(
    Guid CasterId,
    string CasterName,
    string SpellName,
    int TurnsRemaining,
    int TurnsSustained,
    decimal AccumulatedPower,
    GaldrPhase Phase);

// GaldrCompletedEvent.cs
public record GaldrCompletedEvent(
    Guid CasterId,
    string CasterName,
    string SpellName,
    Guid? TargetId,
    decimal FinalPower,
    int TurnsSustained);

// GaldrInterruptedEvent.cs
public record GaldrInterruptedEvent(
    Guid CasterId,
    string CasterName,
    string SpellName,
    InterruptReason Reason,
    int TurnsLost,
    decimal PowerLost,
    int BacklashDamage,
    int StressInflicted);
```

---

## Logging Specification

### Log Levels by Operation

| Operation | Level | Trigger Condition |
|-----------|-------|-------------------|
| Service initialization | Debug | Always |
| Method entry | Debug | Always |
| Parameter details | Trace | Always |
| Validation failures | Warning | On validation fail |
| State changes | Trace | On state mutation |
| Galdr started | Information | On successful start |
| Galdr advanced | Information | Each turn sustained |
| Concentration check | Information | On damage received |
| Concentration broken | Warning | On failed check |
| Galdr interrupted | Information/Warning | On interruption |
| Backlash applied | Warning | On forced interrupt |
| Galdr completed | Information | On release |
| Event published | Debug | Always |

### Structured Logging Properties

```csharp
// Galdr start
_logger.LogInformation(
    "Galdr started: {CasterName} begins chanting {SpellName} ({TurnsRequired} turns)",
    caster.Name, spell.Name, spell.GaldrTurns);

// Concentration check
_logger.LogInformation(
    "Concentration check for {CasterName}: {Successes} successes vs {Threshold} threshold = {Result}",
    caster.Name, rollResult.Successes, threshold, success ? "MAINTAINED" : "BROKEN");

// Backlash
_logger.LogWarning(
    "Galdr backlash for {CasterName}: {BacklashDamage} damage, {StressInflicted} stress",
    caster.Name, backlashDamage, stressInflicted);

// Completion
_logger.LogInformation(
    "Galdr completed: {CasterName} releases {SpellName} with {FinalPower:F1} power!",
    caster.Name, spell.Name, finalPower);
```

---

## Unit Testing

### Test Class Structure

```csharp
namespace RuneAndRust.Tests.Services;

public class GaldrServiceTests
{
    private readonly Mock<ILogger<GaldrService>> _loggerMock;
    private readonly Mock<IEventBus> _eventBusMock;
    private readonly Mock<IDiceService> _diceServiceMock;
    private readonly Mock<IResonanceService> _resonanceServiceMock;
    private readonly Mock<IBacklashService> _backlashServiceMock;
    private readonly Mock<IStatusEffectService> _statusEffectServiceMock;
    private readonly Mock<IAetherService> _aetherServiceMock;
    private readonly GaldrService _sut;

    public GaldrServiceTests()
    {
        _loggerMock = new Mock<ILogger<GaldrService>>();
        _eventBusMock = new Mock<IEventBus>();
        _diceServiceMock = new Mock<IDiceService>();
        _resonanceServiceMock = new Mock<IResonanceService>();
        _backlashServiceMock = new Mock<IBacklashService>();
        _statusEffectServiceMock = new Mock<IStatusEffectService>();
        _aetherServiceMock = new Mock<IAetherService>();

        _sut = new GaldrService(
            _loggerMock.Object,
            _eventBusMock.Object,
            _diceServiceMock.Object,
            _resonanceServiceMock.Object,
            _backlashServiceMock.Object,
            _statusEffectServiceMock.Object,
            _aetherServiceMock.Object);
    }

    private static Character CreateMystic(string name = "TestMystic", int ap = 50)
    {
        return new Character
        {
            Id = Guid.NewGuid(),
            Name = name,
            Archetype = ArchetypeType.Mystic,
            CurrentAp = ap,
            MaxAp = 100,
            ReservedAp = 0,
            Attributes = new Dictionary<CharacterAttribute, int>
            {
                [CharacterAttribute.Will] = 4
            }
        };
    }

    private static Spell CreateGaldrSpell(string name = "TestGaldr", int turns = 3, int apCost = 20)
    {
        return new Spell
        {
            Id = Guid.NewGuid(),
            Name = name,
            IsGaldr = true,
            GaldrTurns = turns,
            ApCost = apCost,
            FluxCost = 15,
            BasePower = 50,
            PowerAccumulationRate = 0.20m
        };
    }

    private static Spell CreateInstantSpell(string name = "TestInstant")
    {
        return new Spell
        {
            Id = Guid.NewGuid(),
            Name = name,
            IsGaldr = false,
            ApCost = 10
        };
    }
}
```

### Test Categories

#### Category 1: StartGaldr Tests (7 tests)

```csharp
#region StartGaldr Tests

[Fact]
public void StartGaldr_WithValidInputs_InitializesGaldrState()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell(turns: 3);

    // Act
    var result = _sut.StartGaldr(caster, spell, targetId: null);

    // Assert
    result.Success.Should().BeTrue();
    caster.GaldrState.Should().NotBeNull();
    caster.GaldrState!.Phase.Should().Be(GaldrPhase.Weaving);
    caster.GaldrState.TurnsRemaining.Should().Be(3);
    caster.ReservedAp.Should().Be(spell.ApCost);
}

[Fact]
public void StartGaldr_ForNonMystic_ReturnsError()
{
    // Arrange
    var caster = new Character { Archetype = ArchetypeType.Warrior };
    var spell = CreateGaldrSpell();

    // Act
    var result = _sut.StartGaldr(caster, spell, null);

    // Assert
    result.Success.Should().BeFalse();
    result.Message.Should().Contain("Only Mystics");
}

[Fact]
public void StartGaldr_WithNonGaldrSpell_ReturnsError()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateInstantSpell();

    // Act
    var result = _sut.StartGaldr(caster, spell, null);

    // Assert
    result.Success.Should().BeFalse();
    result.Message.Should().Contain("cannot be chanted");
}

[Fact]
public void StartGaldr_WhenAlreadyChanting_ReturnsError()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    var result = _sut.StartGaldr(caster, spell, null);

    // Assert
    result.Success.Should().BeFalse();
    result.Message.Should().Contain("already sustaining");
}

[Fact]
public void StartGaldr_WhenSilenced_ReturnsError()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    _statusEffectServiceMock
        .Setup(s => s.HasEffect(caster, StatusEffectType.Silenced))
        .Returns(true);

    // Act
    var result = _sut.StartGaldr(caster, spell, null);

    // Assert
    result.Success.Should().BeFalse();
    result.Message.Should().Contain("silenced");
}

[Fact]
public void StartGaldr_WithInsufficientAp_ReturnsError()
{
    // Arrange
    var caster = CreateMystic(ap: 5);
    var spell = CreateGaldrSpell(apCost: 20);

    // Act
    var result = _sut.StartGaldr(caster, spell, null);

    // Assert
    result.Success.Should().BeFalse();
    result.Message.Should().Contain("Insufficient");
}

[Fact]
public void StartGaldr_PublishesGaldrStartedEvent()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();

    // Act
    _sut.StartGaldr(caster, spell, null);

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.Is<GaldrStartedEvent>(evt =>
            evt.CasterId == caster.Id &&
            evt.SpellName == spell.Name)),
        Times.Once);
}

#endregion
```

#### Category 2: AdvanceGaldr Tests (8 tests)

```csharp
#region AdvanceGaldr Tests

[Fact]
public void AdvanceGaldr_DecrementsTurnsRemaining()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell(turns: 3);
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    var result = _sut.AdvanceGaldr(caster);

    // Assert
    result.Success.Should().BeTrue();
    result.TurnsRemaining.Should().Be(2);
    result.TurnsSustained.Should().Be(1);
}

[Fact]
public void AdvanceGaldr_AccumulatesPower()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell(turns: 3);
    spell.PowerAccumulationRate = 0.25m;
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    _sut.AdvanceGaldr(caster);

    // Assert
    caster.GaldrState!.AccumulatedPower.Should().Be(1.25m);
}

[Fact]
public void AdvanceGaldr_TransitionsToSustainingPhase()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell(turns: 3);
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    _sut.AdvanceGaldr(caster);

    // Assert
    caster.GaldrState!.Phase.Should().Be(GaldrPhase.Sustaining);
}

[Fact]
public void AdvanceGaldr_TransitionsToReleasingOnFinalTurn()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell(turns: 2);
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsRemaining = 1; // One turn left

    // Act
    _sut.AdvanceGaldr(caster);

    // Assert
    caster.GaldrState!.Phase.Should().Be(GaldrPhase.Releasing);
    caster.GaldrState.IsReadyToRelease.Should().BeTrue();
}

[Fact]
public void AdvanceGaldr_WhenSilenced_TriggersInterruption()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    _statusEffectServiceMock
        .Setup(s => s.HasEffect(caster, StatusEffectType.Silenced))
        .Returns(true);

    // Act
    var result = _sut.AdvanceGaldr(caster);

    // Assert
    result.Success.Should().BeFalse();
    caster.GaldrState.Should().BeNull();
}

[Fact]
public void AdvanceGaldr_WithNoActiveGaldr_ReturnsError()
{
    // Arrange
    var caster = CreateMystic();

    // Act
    var result = _sut.AdvanceGaldr(caster);

    // Assert
    result.Success.Should().BeFalse();
    result.Message.Should().Contain("No active Galdr");
}

[Fact]
public void AdvanceGaldr_AppliesResonanceGain()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    _sut.AdvanceGaldr(caster);

    // Assert
    _resonanceServiceMock.Verify(
        r => r.ModifyResonance(caster, 3, It.IsAny<string>()),
        Times.Once);
}

[Fact]
public void AdvanceGaldr_PublishesGaldrAdvancedEvent()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    _sut.AdvanceGaldr(caster);

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.IsAny<GaldrAdvancedEvent>()),
        Times.Once);
}

#endregion
```

#### Category 3: CheckConcentration Tests (12 tests)

```csharp
#region CheckConcentration Tests

[Fact]
public void CheckConcentration_WithNoActiveGaldr_ReturnsNotApplicable()
{
    // Arrange
    var caster = CreateMystic();

    // Act
    var result = _sut.CheckConcentration(caster, 10);

    // Assert
    result.Should().Be(ConcentrationResult.NotApplicable);
}

[Theory]
[InlineData(10, 10)]  // Low damage, base DC applies
[InlineData(20, 10)]  // Damage/2 = 10, base DC applies
[InlineData(30, 15)]  // Damage/2 = 15 > base DC
[InlineData(50, 25)]  // Damage/2 = 25
public void CheckConcentration_CalculatesDCCorrectly(int damage, int expectedDC)
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    _diceServiceMock
        .Setup(d => d.Roll(It.IsAny<int>(), It.IsAny<string>()))
        .Returns(new DiceResult(5, 0, new[] { 8, 9, 10, 8, 9 })); // Always succeed

    // Act
    var result = _sut.CheckConcentration(caster, damage);

    // Assert
    result.DifficultyClass.Should().Be(expectedDC);
}

[Fact]
public void CheckConcentration_Success_MaintainsGaldr()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    _diceServiceMock
        .Setup(d => d.Roll(It.IsAny<int>(), It.IsAny<string>()))
        .Returns(new DiceResult(3, 0, new[] { 8, 9, 10 })); // 3 successes

    // Act
    var result = _sut.CheckConcentration(caster, 10); // DC 10, threshold 2

    // Assert
    result.Success.Should().BeTrue();
    result.ConcentrationMaintained.Should().BeTrue();
    caster.GaldrState.Should().NotBeNull();
}

[Fact]
public void CheckConcentration_Failure_InterruptsGaldr()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    _diceServiceMock
        .Setup(d => d.Roll(It.IsAny<int>(), It.IsAny<string>()))
        .Returns(new DiceResult(0, 1, new[] { 1, 3, 5 })); // 0 successes

    // Act
    var result = _sut.CheckConcentration(caster, 10);

    // Assert
    result.Success.Should().BeFalse();
    result.ConcentrationBroken.Should().BeTrue();
    caster.GaldrState.Should().BeNull(); // Interrupted
}

[Fact]
public void CheckConcentration_AppliesIronFocusBonus()
{
    // Arrange
    var caster = CreateMystic();
    caster.Traits = new List<string> { "Iron Focus" };
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    _diceServiceMock
        .Setup(d => d.Roll(It.IsAny<int>(), It.IsAny<string>()))
        .Returns(new DiceResult(3, 0, new[] { 8, 9, 10 }));

    // Act
    var result = _sut.CheckConcentration(caster, 10);

    // Assert
    result.Modifiers.Should().ContainKey("Iron Focus");
    result.Modifiers["Iron Focus"].Should().Be(2);
    result.DicePool.Should().Be(6); // 4 base + 2 Iron Focus
}

[Fact]
public void CheckConcentration_AppliesStressPenalty()
{
    // Arrange
    var caster = CreateMystic();
    caster.CurrentStress = 50; // Shaken tier
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    _diceServiceMock
        .Setup(d => d.Roll(It.IsAny<int>(), It.IsAny<string>()))
        .Returns(new DiceResult(2, 0, new[] { 8, 9 }));

    // Act
    var result = _sut.CheckConcentration(caster, 10);

    // Assert
    result.Modifiers.Should().ContainKey("Stress (Anxious)");
    result.Modifiers.Should().ContainKey("Stress (Shaken)");
    result.DicePool.Should().Be(2); // 4 base - 2 stress
}

[Fact]
public void CheckConcentration_AppliesResonanceBonus()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    _resonanceServiceMock
        .Setup(r => r.GetThreshold(caster))
        .Returns(ResonanceThreshold.Steady);

    _diceServiceMock
        .Setup(d => d.Roll(It.IsAny<int>(), It.IsAny<string>()))
        .Returns(new DiceResult(3, 0, new[] { 8, 9, 10 }));

    // Act
    var result = _sut.CheckConcentration(caster, 10);

    // Assert
    result.Modifiers.Should().ContainKey("Resonance (Steady)");
    result.DicePool.Should().Be(5); // 4 base + 1 resonance
}

[Fact]
public void CheckConcentration_MinimumPoolIsOne()
{
    // Arrange
    var caster = CreateMystic();
    caster.Attributes[CharacterAttribute.Will] = 1;
    caster.CurrentStress = 100; // Max stress penalties
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    _diceServiceMock
        .Setup(d => d.Roll(1, It.IsAny<string>())) // Should be called with 1
        .Returns(new DiceResult(0, 0, new[] { 5 }));

    // Act
    var result = _sut.CheckConcentration(caster, 10);

    // Assert
    result.DicePool.Should().Be(1);
}

#endregion
```

#### Category 4: InterruptGaldr Tests (8 tests)

```csharp
#region InterruptGaldr Tests

[Fact]
public void InterruptGaldr_ClearsGaldrState()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    _sut.InterruptGaldr(caster, InterruptReason.Movement);

    // Assert
    caster.GaldrState.Should().BeNull();
}

[Fact]
public void InterruptGaldr_RefundsReservedAp()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell(apCost: 20);
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.ReservedAp = 20;

    // Act
    _sut.InterruptGaldr(caster, InterruptReason.Movement);

    // Assert
    caster.ReservedAp.Should().Be(0);
}

[Theory]
[InlineData(1, 1)]  // 1 turn = 1d6
[InlineData(2, 2)]  // 2 turns = 2d6
[InlineData(3, 3)]  // 3 turns = 3d6
[InlineData(5, 4)]  // 5 turns = 4d6 (capped)
public void InterruptGaldr_CalculatesBacklashDiceCorrectly(int turnsSustained, int expectedDice)
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsSustained = turnsSustained;

    var rollCount = 0;
    _diceServiceMock
        .Setup(d => d.RollSingle(6, It.IsAny<string>()))
        .Returns(() => { rollCount++; return 3; });

    // Act
    _sut.InterruptGaldr(caster, InterruptReason.DamageFailed);

    // Assert
    rollCount.Should().Be(expectedDice);
}

[Fact]
public void InterruptGaldr_AppliesBacklashDamage()
{
    // Arrange
    var caster = CreateMystic();
    caster.CurrentHp = 50;
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsSustained = 2;

    _diceServiceMock
        .Setup(d => d.RollSingle(6, It.IsAny<string>()))
        .Returns(4); // 2d6 = 8 damage

    // Act
    var result = _sut.InterruptGaldr(caster, InterruptReason.DamageFailed);

    // Assert
    result.BacklashDamage.Should().Be(8);
    caster.CurrentHp.Should().Be(42); // 50 - 8
}

[Fact]
public void InterruptGaldr_VoluntaryHasNoBacklash()
{
    // Arrange
    var caster = CreateMystic();
    caster.CurrentHp = 50;
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsSustained = 3;

    // Act
    var result = _sut.InterruptGaldr(caster, InterruptReason.Voluntary);

    // Assert
    result.BacklashDamage.Should().Be(0);
    result.StressInflicted.Should().Be(0);
    caster.CurrentHp.Should().Be(50);
}

[Fact]
public void InterruptGaldr_PublishesInterruptedEvent()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    _sut.InterruptGaldr(caster, InterruptReason.Movement);

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.Is<GaldrInterruptedEvent>(evt =>
            evt.Reason == InterruptReason.Movement)),
        Times.Once);
}

[Fact]
public void InterruptGaldr_ReleasesPartialFlux()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell();
    spell.FluxCost = 20;
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);

    // Act
    _sut.InterruptGaldr(caster, InterruptReason.Movement);

    // Assert
    _aetherServiceMock.Verify(
        a => a.ModifyFlux(10, It.IsAny<string>()), // Half of 20
        Times.Once);
}

#endregion
```

#### Category 5: ReleaseGaldr Tests (6 tests)

```csharp
#region ReleaseGaldr Tests

[Fact]
public void ReleaseGaldr_WithReadyGaldr_Succeeds()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    var spell = CreateGaldrSpell(apCost: 20);
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsRemaining = 0;
    caster.ReservedAp = 20;

    _resonanceServiceMock
        .Setup(r => r.GetPotencyModifier(caster))
        .Returns(1.0m);

    // Act
    var result = _sut.ReleaseGaldr(caster);

    // Assert
    result.Success.Should().BeTrue();
    caster.GaldrState.Should().BeNull();
}

[Fact]
public void ReleaseGaldr_WhenNotReady_ReturnsError()
{
    // Arrange
    var caster = CreateMystic();
    var spell = CreateGaldrSpell(turns: 3);
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsRemaining = 2;

    // Act
    var result = _sut.ReleaseGaldr(caster);

    // Assert
    result.Success.Should().BeFalse();
    result.Message.Should().Contain("not yet complete");
}

[Fact]
public void ReleaseGaldr_CalculatesFinalPowerCorrectly()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    var spell = CreateGaldrSpell();
    spell.BasePower = 100;
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsRemaining = 0;
    caster.GaldrState.AccumulatedPower = 1.6m; // +60% from 3 turns
    caster.ReservedAp = spell.ApCost;

    _resonanceServiceMock
        .Setup(r => r.GetPotencyModifier(caster))
        .Returns(1.15m); // Bright threshold

    // Act
    var result = _sut.ReleaseGaldr(caster);

    // Assert
    // 100 * 1.6 * 1.15 = 184
    result.FinalPower.Should().Be(184m);
}

[Fact]
public void ReleaseGaldr_SpendsReservedAp()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    var spell = CreateGaldrSpell(apCost: 20);
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsRemaining = 0;
    caster.ReservedAp = 20;

    _resonanceServiceMock
        .Setup(r => r.GetPotencyModifier(caster))
        .Returns(1.0m);

    // Act
    _sut.ReleaseGaldr(caster);

    // Assert
    caster.ReservedAp.Should().Be(0);
    caster.CurrentAp.Should().Be(30); // 50 - 20
}

[Fact]
public void ReleaseGaldr_AppliesReducedFlux()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    var spell = CreateGaldrSpell();
    spell.FluxCost = 20;
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsRemaining = 0;
    caster.ReservedAp = spell.ApCost;

    _resonanceServiceMock
        .Setup(r => r.GetPotencyModifier(caster))
        .Returns(1.0m);

    // Act
    _sut.ReleaseGaldr(caster);

    // Assert
    _aetherServiceMock.Verify(
        a => a.ModifyFlux(15, It.IsAny<string>()), // 20 - 5 channeled reduction
        Times.Once);
}

[Fact]
public void ReleaseGaldr_PublishesCompletedEvent()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    var spell = CreateGaldrSpell();
    caster.GaldrState = GaldrState.Create(spell, null, 0, 0);
    caster.GaldrState.TurnsRemaining = 0;
    caster.ReservedAp = spell.ApCost;

    _resonanceServiceMock
        .Setup(r => r.GetPotencyModifier(caster))
        .Returns(1.0m);

    // Act
    _sut.ReleaseGaldr(caster);

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.IsAny<GaldrCompletedEvent>()),
        Times.Once);
}

#endregion
```

#### Category 6: Integration Tests (4 tests)

```csharp
#region Integration Tests

[Fact]
public void FullGaldrCycle_StartAdvanceRelease_CompletesSuccessfully()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    var spell = CreateGaldrSpell(turns: 2, apCost: 15);
    spell.BasePower = 100;

    _resonanceServiceMock
        .Setup(r => r.GetPotencyModifier(caster))
        .Returns(1.0m);

    // Act - Start
    var startResult = _sut.StartGaldr(caster, spell, null);
    startResult.Success.Should().BeTrue();
    caster.GaldrState!.Phase.Should().Be(GaldrPhase.Weaving);

    // Act - Advance (turn 1)
    var advanceResult1 = _sut.AdvanceGaldr(caster);
    advanceResult1.Success.Should().BeTrue();
    advanceResult1.TurnsRemaining.Should().Be(1);

    // Act - Advance (turn 2 - final)
    var advanceResult2 = _sut.AdvanceGaldr(caster);
    advanceResult2.Success.Should().BeTrue();
    advanceResult2.IsReadyToRelease.Should().BeTrue();

    // Act - Release
    var releaseResult = _sut.ReleaseGaldr(caster);
    releaseResult.Success.Should().BeTrue();
    releaseResult.FinalPower.Should().BeGreaterThan(100); // Accumulated power
    caster.GaldrState.Should().BeNull();
}

[Fact]
public void GaldrCycle_InterruptedByDamage_AppliesBacklash()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    caster.CurrentHp = 100;
    var spell = CreateGaldrSpell(turns: 3);

    _diceServiceMock
        .Setup(d => d.Roll(It.IsAny<int>(), It.IsAny<string>()))
        .Returns(new DiceResult(0, 1, new[] { 1, 2, 3 })); // Fail concentration

    _diceServiceMock
        .Setup(d => d.RollSingle(6, It.IsAny<string>()))
        .Returns(4);

    // Act - Start and advance
    _sut.StartGaldr(caster, spell, null);
    _sut.AdvanceGaldr(caster);
    caster.GaldrState!.TurnsSustained.Should().Be(1);

    // Act - Take damage, fail concentration
    var concResult = _sut.CheckConcentration(caster, 30);

    // Assert
    concResult.ConcentrationBroken.Should().BeTrue();
    caster.GaldrState.Should().BeNull();
    caster.CurrentHp.Should().BeLessThan(100); // Backlash applied
}

[Fact]
public void GaldrCycle_VoluntaryCancellation_NoBacklash()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    caster.CurrentHp = 100;
    var spell = CreateGaldrSpell(turns: 3, apCost: 20);
    caster.ReservedAp = 20;

    // Act
    _sut.StartGaldr(caster, spell, null);
    _sut.AdvanceGaldr(caster);
    var cancelResult = _sut.CancelGaldr(caster);

    // Assert
    cancelResult.Success.Should().BeTrue();
    caster.GaldrState.Should().BeNull();
    caster.CurrentHp.Should().Be(100); // No damage
    caster.ReservedAp.Should().Be(0); // AP refunded
}

[Fact]
public void GaldrCycle_MovementInterruption_AppliesBacklash()
{
    // Arrange
    var caster = CreateMystic(ap: 50);
    caster.CurrentHp = 100;
    var spell = CreateGaldrSpell(turns: 3);

    _diceServiceMock
        .Setup(d => d.RollSingle(6, It.IsAny<string>()))
        .Returns(5);

    // Act
    _sut.StartGaldr(caster, spell, null);
    _sut.AdvanceGaldr(caster);
    _sut.AdvanceGaldr(caster);
    caster.GaldrState!.TurnsSustained.Should().Be(2);

    var interruptResult = _sut.InterruptGaldr(caster, InterruptReason.Movement);

    // Assert
    interruptResult.WasInterrupted.Should().BeTrue();
    interruptResult.Reason.Should().Be(InterruptReason.Movement);
    interruptResult.BacklashDamage.Should().Be(10); // 2d6 = 10 (5+5)
    caster.CurrentHp.Should().Be(90);
}

#endregion
```

### Test Summary

| Category | Test Count | Coverage Focus |
|----------|------------|----------------|
| StartGaldr | 7 | Validation, state initialization, AP reservation |
| AdvanceGaldr | 8 | Turn countdown, power accumulation, phase transitions |
| CheckConcentration | 12 | DC calculation, modifiers, success/failure |
| InterruptGaldr | 8 | Backlash calculation, state clearing, event publishing |
| CancelGaldr | 4 | Voluntary cancellation, resonance refund |
| ReleaseGaldr | 6 | Power calculation, AP spending, effect execution |
| Integration | 4 | Full lifecycle scenarios |

**Total: 49 tests** (exceeds the estimated 38)

---

## Integration Points

### CombatService Integration

```csharp
// In CombatService.cs - After damage is applied
private void ProcessDamageReceived(Combatant target, int damage, Combatant source)
{
    // Existing damage processing...

    // Check Galdr concentration
    if (_galdrService.IsChanting(target.CharacterSource))
    {
        var concResult = _galdrService.CheckConcentration(target.CharacterSource, damage);
        if (concResult.ConcentrationBroken)
        {
            LogCombatEvent($"[yellow]{target.Name}'s concentration is BROKEN![/]");
        }
    }
}

// In CombatService.cs - Turn start processing
private void ProcessTurnStart(Combatant combatant)
{
    // Existing turn start processing...

    // Auto-advance Galdr if active
    if (combatant.CharacterSource != null &&
        _galdrService.IsChanting(combatant.CharacterSource))
    {
        var galdrState = _galdrService.GetActiveGaldr(combatant.CharacterSource);
        if (galdrState?.IsReadyToRelease == true)
        {
            // Auto-release on the final turn
            var releaseResult = _galdrService.ReleaseGaldr(combatant.CharacterSource);
            LogCombatEvent(releaseResult.Message);
        }
    }
}
```

### MagicService Integration

```csharp
// In MagicService.CastSpell()
public SpellCastResult CastSpell(Character caster, Spell spell, CastingMode mode, Guid? targetId)
{
    // Check if spell is a Galdr
    if (spell.IsGaldr)
    {
        // Delegate to GaldrService
        var galdrResult = _galdrService.StartGaldr(caster, spell, targetId);
        return new SpellCastResult
        {
            Success = galdrResult.Success,
            IsGaldr = true,
            TurnsRemaining = galdrResult.TurnsRequired,
            Message = galdrResult.Message
        };
    }

    // Continue with instant spell casting...
}
```

### CommandParser Extension

```csharp
// New commands for Galdr
case "chant" when args.Length > 0:
    var spellName = string.Join(" ", args);
    var spell = _spellRepository.GetByName(spellName);
    if (spell == null) return "Unknown spell.";
    if (!spell.IsGaldr) return $"{spell.Name} cannot be chanted as a Galdr.";
    var startResult = _galdrService.StartGaldr(player, spell, targetId);
    return startResult.Message;

case "continue":
    if (!_galdrService.IsChanting(player))
        return "You are not chanting a Galdr.";
    var advanceResult = _galdrService.AdvanceGaldr(player);
    return advanceResult.Message;

case "release":
    if (!_galdrService.IsChanting(player))
        return "You are not chanting a Galdr.";
    var galdr = _galdrService.GetActiveGaldr(player);
    if (galdr?.IsReadyToRelease != true)
        return "The Galdr is not yet ready to release.";
    var releaseResult = _galdrService.ReleaseGaldr(player);
    return releaseResult.Message;

case "cancel":
    if (!_galdrService.IsChanting(player))
        return "You are not chanting a Galdr.";
    var cancelResult = _galdrService.CancelGaldr(player);
    return cancelResult.Message;
```

---

## Domain 4 Compliance

### Forbidden Terms

| Forbidden | Compliant Alternative |
|-----------|----------------------|
| "+20% power per turn" | "The incantation builds in strength" |
| "DC 15 concentration check" | "The Aether tests your focus" |
| "2d6 backlash damage" | "The shattered spell tears at your soul" |
| "3 turns remaining" | "The chant nears its crescendo" |

### Compliant Narrative Examples

**Galdr Started (TUI):**
```
❌ "Starting 3-turn Galdr. AP reserved: 20. Resonance: +5."
✅ "You begin the incantation of Flame Pillar. The ancient syllables
    resonate through the Weave, building toward an inevitable release..."
```

**Concentration Check (Combat Log):**
```
❌ "Concentration check: DC 15, rolled 3 successes (threshold 3). Maintained."
✅ "Pain lances through you, but the words do not falter. The Aether
    holds—your focus remains unbroken."
```

**Interruption (Combat Log):**
```
❌ "Galdr interrupted. Backlash: 8 damage. Stress: +10."
✅ "The incantation shatters! Aetheric energy recoils through your
    veins—the spirits demand payment for broken promises."
```

---

## Changelog Template

```markdown
## [v0.4.4b] - YYYY-MM-DD

### Added
- **GaldrPhase enum** (`RuneAndRust.Core/Enums/GaldrPhase.cs`)
  - None, Weaving, Sustaining, Releasing phases

- **InterruptReason enum** (`RuneAndRust.Core/Enums/InterruptReason.cs`)
  - DamageFailed, Movement, Action, Silence, Voluntary

- **GaldrState model** (`RuneAndRust.Core/Models/Magic/GaldrState.cs`)
  - Tracks spell, target, phase, turns remaining, accumulated power
  - Factory method for clean initialization

- **Result records** (`RuneAndRust.Core/Models/Magic/`)
  - GaldrStartResult, GaldrAdvanceResult, GaldrReleaseResult
  - GaldrInterruptResult, GaldrCancelResult, ConcentrationResult

- **Galdr events** (`RuneAndRust.Core/Events/`)
  - GaldrStartedEvent, GaldrAdvancedEvent
  - GaldrCompletedEvent, GaldrInterruptedEvent

- **IGaldrService interface** (`RuneAndRust.Core/Interfaces/IGaldrService.cs`)
  - Contract for multi-turn chanted spell management

- **GaldrService implementation** (`RuneAndRust.Engine/Services/GaldrService.cs`)
  - Full lifecycle: Start, Advance, Release, Interrupt, Cancel
  - Concentration checks with WILL dice pool and modifiers
  - Backlash calculation on forced interruption

- **TUI Commands**
  - `chant [spell]` - Begin a Galdr incantation
  - `continue` - Sustain the active Galdr
  - `release` - Unleash a completed Galdr
  - `cancel` - Voluntarily end a Galdr without backlash

### Changed
- **Spell entity** - Added `IsGaldr`, `GaldrTurns`, `PowerAccumulationRate`
- **Character model** - Added `GaldrState`, `ReservedAp` properties
- **CombatService** - Integrated concentration checks on damage
- **MagicService** - Delegates Galdr spells to GaldrService

### Tests
- Added `GaldrServiceTests.cs` with 49 unit tests
  - StartGaldr: 7 tests
  - AdvanceGaldr: 8 tests
  - CheckConcentration: 12 tests
  - InterruptGaldr: 8 tests
  - CancelGaldr: 4 tests
  - ReleaseGaldr: 6 tests
  - Integration: 4 tests
- Code coverage: 92%+ for GaldrService

### Technical Notes
- Power accumulates at +20% per sustained turn (configurable per spell)
- Concentration DC = max(10, Damage/2), threshold = DC/5
- Backlash: 1d6 per turn sustained (max 4d6), stress: 5 per turn (max 20)
- Voluntary cancellation refunds 50% resonance, no backlash
- Channeled casting inherent: -5 Flux on release

### Dependencies
- Requires: v0.4.4a (ResonanceService), v0.4.3c (MagicService)
- Required by: v0.4.4e (Grimoire TUI integration)
```

---

## Summary

v0.4.4b "The Galdr" establishes the **multi-turn chanting system**—a high-risk, high-reward casting style for dedicated Mystics. This system:

1. **Enables multi-turn spellcasting** (2-5 turns) with power accumulation (+20% per turn)
2. **Implements concentration checks** (WILL-based) when damaged during chanting
3. **Applies backlash damage** (1d6 to 4d6) on forced interruption
4. **Supports voluntary cancellation** without backlash (50% resonance refund)
5. **Integrates with CombatService** for damage hooks and turn processing
6. **Reduces Flux cost** (-5) as inherent benefit of channeled casting

**Estimated Implementation Time:** 3-4 development sessions
**Test Coverage Target:** 80%+ (49 tests planned)
**Dependencies:** v0.4.4a (ResonanceService), v0.4.3c (MagicService), v0.4.3d (BacklashService)
