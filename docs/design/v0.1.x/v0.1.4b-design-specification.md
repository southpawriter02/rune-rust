# v0.1.4b Design Specification: Monster Repopulation

**Version:** 0.1.4b
**Phase Name:** Monster Repopulation
**Parent Version:** v0.1.4 (World Persistence & Evolution)
**Prerequisites:** v0.1.4a Complete (Persistent World State)
**Estimated Tests:** ~28 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Spawner Entity](#4-spawner-entity)
5. [SpawnerType Enum](#5-spawnertype-enum)
6. [RepopulationRule Value Object](#6-repopulationrule-value-object)
7. [RepopulationService](#7-repopulationservice)
8. [Room Entity Integration](#8-room-entity-integration)
9. [Respawn Timer Mechanics](#9-respawn-timer-mechanics)
10. [Spawner Destruction Mechanics](#10-spawner-destruction-mechanics)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement the monster repopulation system that brings dungeons to life through dynamic enemy respawning. This phase builds directly on v0.1.4a's persistent world state foundation, adding configurable respawn timers per room type, spawner rooms as repopulation sources, and the critical "clear all spawners = permanent clear" mechanic. Players experience meaningful progression: temporarily safe cleared rooms that eventually repopulate, with the strategic option to permanently secure areas by destroying spawner sources.

### 1.2 Current State

| Area | Current State (v0.1.4a) | Target State (v0.1.4b) |
|------|-------------------------|------------------------|
| Room clearing | Tracked with LastCleared | Respawn after timer expires |
| Respawn behavior | Non-permanent changes expire | Timer-based repopulation per room type |
| Spawner rooms | HasActiveSpawner placeholder | Full spawner entity with destruction |
| Permanent clearing | Manual flag only | Automatic when all spawners destroyed |
| Repopulation rules | Not configurable | JSON-configurable per room type |
| Monster sources | Not tracked | Spawner rooms, nests as sources |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `Spawner` |
| **Enums** | `SpawnerType`, `SpawnerState` |
| **Value Objects** | `RepopulationRule`, `RespawnTimer` |
| **Services** | `RepopulationService` (with `IRepopulationService` interface) |
| **Configuration** | `repopulation-rules.json`, `repopulation-rules-schema.json` |
| **Entity Updates** | `Room.Spawners`, `Room.RespawnTimer`, `RoomState.HasActiveSpawner` integration |
| **Tests** | ~28 new unit tests |

### 1.4 Architectural Significance

This version establishes the **repopulation pattern** that creates living dungeons:
- Timer-based respawning tied to room types
- Spawner-source relationships for monster origins
- Strategic permanent clearing through spawner destruction
- Foundation for faction-controlled repopulation (v0.1.4c)
- Integration with WorldStateService for persistence

---

## 2. Feature Overview

```
v0.1.4b Monster Repopulation
├── Spawner Entity
│   ├── Unique identification
│   ├── Spawner type (Nest, Portal, Altar, Hive)
│   ├── Spawner state (Active, Dormant, Destroyed)
│   ├── Monster types spawned
│   ├── Spawn rate configuration
│   ├── Health/destructibility
│   └── Room reference
├── SpawnerType Enum
│   ├── Nest (natural creature spawns)
│   ├── Portal (summoned/magical spawns)
│   ├── Altar (undead/ritual spawns)
│   └── Hive (swarm/colony spawns)
├── SpawnerState Enum
│   ├── Active (spawning monsters)
│   ├── Dormant (temporarily inactive)
│   └── Destroyed (permanently disabled)
├── RepopulationRule Value Object
│   ├── Room type reference
│   ├── Base respawn timer
│   ├── Timer scaling factor
│   ├── Max monsters per spawn
│   ├── Requires spawner flag
│   └── Description
├── RespawnTimer Value Object
│   ├── Start time
│   ├── Duration
│   ├── Time remaining
│   ├── Is expired flag
│   └── Reset capability
├── RepopulationService
│   ├── CheckRespawnEligibility(roomId)
│   ├── TriggerRespawn(roomId)
│   ├── GetRespawnTimer(roomId)
│   ├── SetRespawnTimer(roomId, duration)
│   ├── GetActiveSpawners(roomId)
│   ├── DestroySpawner(roomId, spawnerId)
│   ├── AreAllSpawnersDestroyed(roomId)
│   ├── SetPermanentlyClear(roomId)
│   ├── GetRepopulationRule(roomType)
│   └── ProcessRespawns() [tick-based]
├── Room Entity Updates
│   ├── Spawners collection
│   ├── RespawnTimer property
│   ├── IsPermanentlyCleared property
│   ├── AddSpawner(spawner) method
│   ├── RemoveSpawner(spawnerId) method
│   └── HasActiveSpawners computed property
└── Configuration
    ├── repopulation-rules.json (room type definitions)
    └── repopulation-rules-schema.json (validation)
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Respawn status affects displayed content and warnings                       │
│  ├── GameView shows respawn countdown for cleared rooms                     │
│  ├── Map displays spawner locations and status                              │
│  ├── Combat warnings when entering respawned room                           │
│  └── Victory messages note spawner destruction                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  RepopulationService                                                         │
│  ├── CheckRespawnEligibility(roomId)  ├── DestroySpawner(roomId, id)       │
│  ├── TriggerRespawn(roomId)           ├── AreAllSpawnersDestroyed(roomId)  │
│  ├── GetRespawnTimer(roomId)          ├── SetPermanentlyClear(roomId)      │
│  ├── SetRespawnTimer(roomId, dur)     ├── GetRepopulationRule(roomType)    │
│  ├── GetActiveSpawners(roomId)        └── ProcessRespawns()                │
│                                                                              │
│  Interfaces:                        WorldStateService (v0.1.4a)              │
│  └── IRepopulationService           └── Integration for persistence         │
│                                                                              │
│  Configuration:                     CombatService (Updated)                  │
│  └── RepopulationRulesConfigDto     ├── Checks spawners during combat       │
│                                     └── Triggers respawn timer on clear     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Entities:                       Value Objects:                              │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                │
│  │ Spawner                 │     │ RepopulationRule        │                │
│  │ ├── Id: Guid            │     │ ├── RoomType            │                │
│  │ ├── RoomId: Guid        │     │ ├── BaseRespawnMinutes  │                │
│  │ ├── SpawnerType         │     │ ├── TimerScalingFactor  │                │
│  │ ├── State: SpawnerState │     │ ├── MaxMonstersPerSpawn │                │
│  │ ├── MonsterTypes: List  │     │ ├── RequiresSpawner     │                │
│  │ ├── SpawnRate: int      │     │ └── Description         │                │
│  │ ├── MaxHealth: int      │     └─────────────────────────┘                │
│  │ ├── CurrentHealth: int  │     ┌─────────────────────────┐                │
│  │ └── Position: string    │     │ RespawnTimer            │                │
│  └─────────────────────────┘     │ ├── StartTime: DateTime │                │
│                                  │ ├── Duration: TimeSpan  │                │
│  Enums:                          │ ├── IsExpired: bool     │                │
│  ┌─────────────────────────┐     │ ├── TimeRemaining       │                │
│  │ SpawnerType             │     │ └── Reset(): void       │                │
│  │ ├── Nest                │     └─────────────────────────┘                │
│  │ ├── Portal              │                                                │
│  │ ├── Altar               │     Entities (Updated):                        │
│  │ └── Hive                │     ┌─────────────────────────┐                │
│  └─────────────────────────┘     │ Room                    │                │
│  ┌─────────────────────────┐     │ ├── Spawners: List      │                │
│  │ SpawnerState            │     │ ├── RespawnTimer        │                │
│  │ ├── Active              │     │ ├── IsPermanentlyCleared│                │
│  │ ├── Dormant             │     │ └── HasActiveSpawners   │                │
│  │ └── Destroyed           │     └─────────────────────────┘                │
│  └─────────────────────────┘                                                │
│                                  RoomState (v0.1.4a Updated):                │
│                                  └── HasActiveSpawner now functional        │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetRepopulationRules(): IReadOnlyList<RepopulationRule>                │
│  └── Loads and deserializes config/repopulation-rules.json                  │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/repopulation-rules.json                                         │
│  └── config/schemas/repopulation-rules-schema.json                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Respawn Flow Diagram

```
┌───────────────────────────────────────┐
│ Room cleared by player (CombatService)│
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ CombatService.OnRoomCleared(roomId)                           │
├───────────────────────────────────────────────────────────────┤
│ 1. WorldStateService.SetRoomCleared(roomId)                   │
│ 2. Check: room.HasActiveSpawners?                             │
└───────────────┬───────────────────────────────────────────────┘
                │
        ┌───────┴───────┐
        │               │
        ▼               ▼
┌───────────────┐ ┌───────────────────────────────────────────┐
│ No Spawners   │ │ Has Active Spawners                       │
├───────────────┤ ├───────────────────────────────────────────┤
│ Get rule for  │ │ RepopulationService.SetRespawnTimer(      │
│ room type     │ │     roomId,                               │
│               │ │     rule.BaseRespawnMinutes)              │
│ If requires   │ │                                           │
│ spawner:      │ │ Room.RespawnTimer = new RespawnTimer(     │
│ → Permanent   │ │     DateTime.UtcNow,                      │
│   clear       │ │     TimeSpan.FromMinutes(baseMinutes))    │
│               │ │                                           │
│ Else:         │ │ Log: "Room will respawn in {X} minutes"   │
│ → Set timer   │ │                                           │
└───────────────┘ └───────────────────────────────────────────┘
                                    │
                                    ▼
┌───────────────────────────────────────────────────────────────┐
│ Game tick / ProcessRespawns() called periodically             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ RepopulationService.ProcessRespawns()                         │
├───────────────────────────────────────────────────────────────┤
│ For each room with RespawnTimer:                              │
│   if (timer.IsExpired && room.HasActiveSpawners)              │
│   {                                                           │
│       TriggerRespawn(roomId);                                 │
│   }                                                           │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ RepopulationService.TriggerRespawn(roomId)                    │
├───────────────────────────────────────────────────────────────┤
│ 1. Get active spawners in room                                │
│ 2. For each spawner:                                          │
│    - Determine monster types to spawn                         │
│    - Calculate spawn count (up to MaxMonstersPerSpawn)        │
│    - Add monsters to room                                     │
│ 3. Reset room state to PartiallyCleared or Visited            │
│ 4. Clear the respawn timer                                    │
│ 5. Log respawn event                                          │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Spawner Destruction Flow

```
┌───────────────────────────────────────┐
│ Player targets spawner in combat      │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ CombatService.AttackSpawner(roomId, spawnerId, damage)        │
├───────────────────────────────────────────────────────────────┤
│ 1. Get spawner from room                                      │
│ 2. Apply damage: spawner.TakeDamage(damage)                   │
│ 3. Check: spawner.CurrentHealth <= 0?                         │
└───────────────┬───────────────────────────────────────────────┘
                │
        ┌───────┴───────┐
        │               │
        ▼               ▼
┌───────────────┐ ┌───────────────────────────────────────────┐
│ Not Destroyed │ │ Spawner Destroyed                         │
├───────────────┤ ├───────────────────────────────────────────┤
│ Continue      │ │ RepopulationService.DestroySpawner(       │
│ combat        │ │     roomId, spawnerId)                    │
│               │ │                                           │
│               │ │ spawner.State = SpawnerState.Destroyed    │
│               │ │                                           │
│               │ │ Log: "Spawner destroyed!"                 │
└───────────────┘ └───────────────────────────────────────────┘
                                    │
                                    ▼
┌───────────────────────────────────────────────────────────────┐
│ Check: AreAllSpawnersDestroyed(roomId)?                       │
└───────────────┬───────────────────────────────────────────────┘
                │
        ┌───────┴───────┐
        │               │
        ▼               ▼
┌───────────────┐ ┌───────────────────────────────────────────┐
│ Some Active   │ │ All Spawners Destroyed                    │
├───────────────┤ ├───────────────────────────────────────────┤
│ Room can      │ │ RepopulationService.SetPermanentlyClear(  │
│ still respawn │ │     roomId)                               │
│               │ │                                           │
│               │ │ room.IsPermanentlyCleared = true          │
│               │ │ room.RespawnTimer = null                  │
│               │ │                                           │
│               │ │ WorldStateService.SetRoomCleared(         │
│               │ │     roomId, isPermanent: true)            │
│               │ │                                           │
│               │ │ Log: "Room permanently secured!"          │
└───────────────┘ └───────────────────────────────────────────┘
```

### 3.4 Repopulation Rule Selection Flow

```
┌───────────────────────────────────────────────────────────────┐
│ Room needs respawn timer calculation                          │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ RepopulationService.GetRepopulationRule(room.RoomType)        │
├───────────────────────────────────────────────────────────────┤
│ var rules = _config.GetRepopulationRules();                   │
│ var rule = rules.FirstOrDefault(r => r.RoomType == roomType); │
│                                                               │
│ if (rule == default)                                          │
│     return RepopulationRule.Default;                          │
│                                                               │
│ return rule;                                                  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Calculate actual respawn time                                 │
├───────────────────────────────────────────────────────────────┤
│ baseMinutes = rule.BaseRespawnMinutes;                        │
│ clearCount = room.ClearCount;                                 │
│ scalingFactor = rule.TimerScalingFactor;                      │
│                                                               │
│ // Timer increases with each clear (diminishing returns)      │
│ actualMinutes = baseMinutes * (1 + (clearCount - 1)           │
│                                * scalingFactor);              │
│                                                               │
│ // Cap at reasonable maximum (e.g., 3x base)                  │
│ actualMinutes = Math.Min(actualMinutes, baseMinutes * 3);     │
└───────────────────────────────────────────────────────────────┘
```

---

## 4. Spawner Entity

### 4.1 Purpose

The `Spawner` entity represents a source point for monster repopulation within a room. Spawners can be nests, portals, altars, or hives, each producing different monster types. Spawners are destructible, and destroying all spawners in connected areas leads to permanent clearing.

### 4.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/Spawner.cs`

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents a monster spawning source within a room.
/// </summary>
/// <remarks>
/// Spawners are the origin points for monster repopulation. They can be
/// targeted and destroyed by players to permanently secure areas. Different
/// spawner types produce different monster categories and have varying
/// durability and spawn rates.
/// </remarks>
public class Spawner
{
    /// <summary>
    /// Gets the unique identifier for this spawner.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the ID of the room containing this spawner.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the type of spawner.
    /// </summary>
    /// <remarks>
    /// Determines the visual representation, monster types spawned,
    /// and destruction mechanics.
    /// </remarks>
    public SpawnerType SpawnerType { get; private set; }

    /// <summary>
    /// Gets the current state of the spawner.
    /// </summary>
    public SpawnerState State { get; private set; } = SpawnerState.Active;

    /// <summary>
    /// Gets the monster type IDs this spawner can produce.
    /// </summary>
    /// <remarks>
    /// References monster definitions by ID. Spawner selects randomly
    /// from available types when spawning.
    /// </remarks>
    public IReadOnlyList<string> MonsterTypeIds => _monsterTypeIds.AsReadOnly();
    private readonly List<string> _monsterTypeIds = new();

    /// <summary>
    /// Gets the number of monsters spawned per repopulation event.
    /// </summary>
    public int SpawnRate { get; private set; }

    /// <summary>
    /// Gets the maximum health of the spawner.
    /// </summary>
    public int MaxHealth { get; private set; }

    /// <summary>
    /// Gets the current health of the spawner.
    /// </summary>
    public int CurrentHealth { get; private set; }

    /// <summary>
    /// Gets the position description within the room.
    /// </summary>
    /// <remarks>
    /// Descriptive text like "in the corner", "against the far wall",
    /// "in the center of the room" for flavor text.
    /// </remarks>
    public string Position { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name for this spawner based on type.
    /// </summary>
    public string DisplayName => SpawnerType switch
    {
        SpawnerType.Nest => "Monster Nest",
        SpawnerType.Portal => "Summoning Portal",
        SpawnerType.Altar => "Dark Altar",
        SpawnerType.Hive => "Creature Hive",
        _ => "Spawner"
    };

    /// <summary>
    /// Gets whether this spawner is currently active and can spawn.
    /// </summary>
    public bool IsActive => State == SpawnerState.Active;

    /// <summary>
    /// Gets whether this spawner has been destroyed.
    /// </summary>
    public bool IsDestroyed => State == SpawnerState.Destroyed;

    /// <summary>
    /// Gets the health percentage remaining.
    /// </summary>
    public double HealthPercentage => MaxHealth > 0
        ? (double)CurrentHealth / MaxHealth * 100
        : 0;

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private Spawner() { }

    /// <summary>
    /// Creates a new spawner.
    /// </summary>
    /// <param name="roomId">The room containing this spawner.</param>
    /// <param name="spawnerType">The type of spawner.</param>
    /// <param name="monsterTypeIds">Monster types this spawner produces.</param>
    /// <param name="spawnRate">Monsters per spawn event.</param>
    /// <param name="maxHealth">Maximum health.</param>
    /// <param name="position">Position description in room.</param>
    /// <returns>A new Spawner instance.</returns>
    public static Spawner Create(
        Guid roomId,
        SpawnerType spawnerType,
        IEnumerable<string> monsterTypeIds,
        int spawnRate,
        int maxHealth,
        string position)
    {
        if (roomId == Guid.Empty)
            throw new ArgumentException("Room ID cannot be empty.", nameof(roomId));

        if (spawnRate < 1)
            throw new ArgumentException("Spawn rate must be at least 1.", nameof(spawnRate));

        if (maxHealth < 1)
            throw new ArgumentException("Max health must be at least 1.", nameof(maxHealth));

        var spawner = new Spawner
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            SpawnerType = spawnerType,
            SpawnRate = spawnRate,
            MaxHealth = maxHealth,
            CurrentHealth = maxHealth,
            Position = position ?? string.Empty,
            State = SpawnerState.Active
        };

        spawner._monsterTypeIds.AddRange(monsterTypeIds ?? Enumerable.Empty<string>());

        if (spawner._monsterTypeIds.Count == 0)
            throw new ArgumentException("Spawner must have at least one monster type.", nameof(monsterTypeIds));

        return spawner;
    }

    /// <summary>
    /// Applies damage to the spawner.
    /// </summary>
    /// <param name="damage">Amount of damage to apply.</param>
    /// <returns>True if the spawner was destroyed by this damage.</returns>
    public bool TakeDamage(int damage)
    {
        if (damage < 0)
            throw new ArgumentException("Damage cannot be negative.", nameof(damage));

        if (IsDestroyed)
            return false;

        CurrentHealth = Math.Max(0, CurrentHealth - damage);

        if (CurrentHealth <= 0)
        {
            State = SpawnerState.Destroyed;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Sets the spawner to dormant state.
    /// </summary>
    /// <remarks>
    /// Dormant spawners do not produce monsters but can be reactivated.
    /// Used for temporary disabling mechanics.
    /// </remarks>
    public void SetDormant()
    {
        if (!IsDestroyed)
        {
            State = SpawnerState.Dormant;
        }
    }

    /// <summary>
    /// Activates a dormant spawner.
    /// </summary>
    public void Activate()
    {
        if (State == SpawnerState.Dormant)
        {
            State = SpawnerState.Active;
        }
    }

    /// <summary>
    /// Selects a random monster type to spawn.
    /// </summary>
    /// <param name="random">Random number generator.</param>
    /// <returns>A monster type ID.</returns>
    public string SelectMonsterType(Random? random = null)
    {
        random ??= Random.Shared;
        var index = random.Next(_monsterTypeIds.Count);
        return _monsterTypeIds[index];
    }

    /// <summary>
    /// Gets a description of the spawner for display.
    /// </summary>
    public string GetDescription()
    {
        var stateDesc = State switch
        {
            SpawnerState.Active => "pulsing with dark energy",
            SpawnerState.Dormant => "temporarily dormant",
            SpawnerState.Destroyed => "reduced to rubble",
            _ => "present"
        };

        return $"A {DisplayName} {Position}, {stateDesc}. ({CurrentHealth}/{MaxHealth} HP)";
    }

    /// <summary>
    /// Gets a string representation of the spawner.
    /// </summary>
    public override string ToString() =>
        $"Spawner[{SpawnerType}] {State} ({CurrentHealth}/{MaxHealth} HP)";
}
```

### 4.4 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `Guid` | Unique identifier | Generated |
| `RoomId` | `Guid` | Room containing spawner | Required |
| `SpawnerType` | `SpawnerType` | Type of spawner | Required |
| `State` | `SpawnerState` | Current state | Active |
| `MonsterTypeIds` | `IReadOnlyList<string>` | Spawnable monster types | Required |
| `SpawnRate` | `int` | Monsters per spawn | Required |
| `MaxHealth` | `int` | Maximum HP | Required |
| `CurrentHealth` | `int` | Current HP | MaxHealth |
| `Position` | `string` | Position description | Empty |

---

## 5. SpawnerType Enum

### 5.1 Purpose

The `SpawnerType` enum categorizes spawners by their thematic nature, affecting which monsters they produce and how they appear to players.

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Enums/SpawnerType.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of monster spawning sources.
/// </summary>
/// <remarks>
/// Each spawner type has thematic implications for the monsters it produces
/// and the methods required to destroy it. Spawner type also affects
/// the visual descriptions and flavor text presented to players.
/// </remarks>
public enum SpawnerType
{
    /// <summary>
    /// A natural nest for creatures.
    /// </summary>
    /// <remarks>
    /// Produces natural creatures like rats, spiders, wolves.
    /// Typically found in caves, forests, or abandoned areas.
    /// Relatively easy to destroy.
    /// </remarks>
    Nest = 0,

    /// <summary>
    /// A magical portal summoning creatures.
    /// </summary>
    /// <remarks>
    /// Produces summoned or extraplanar creatures like demons, elementals.
    /// Found in magical locations or corrupted areas.
    /// Requires disrupting the magical energy to close.
    /// </remarks>
    Portal = 1,

    /// <summary>
    /// A dark altar raising undead.
    /// </summary>
    /// <remarks>
    /// Produces undead creatures like skeletons, zombies, wraiths.
    /// Found in crypts, temples, or cursed locations.
    /// May require consecration or holy damage to fully destroy.
    /// </remarks>
    Altar = 2,

    /// <summary>
    /// A colony hive producing swarms.
    /// </summary>
    /// <remarks>
    /// Produces swarm-type creatures like insects, vermin, or colonial beings.
    /// Found in natural or infested areas.
    /// Destroying the queen/core eliminates the hive.
    /// </remarks>
    Hive = 3
}
```

### 5.4 SpawnerState Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/SpawnerState.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// States a spawner can be in.
/// </summary>
/// <remarks>
/// Spawner state determines whether a spawner contributes to room
/// repopulation and how it appears to players.
/// </remarks>
public enum SpawnerState
{
    /// <summary>
    /// Spawner is active and will produce monsters.
    /// </summary>
    /// <remarks>
    /// Active spawners contribute to respawn calculations and
    /// will generate monsters when the room repopulates.
    /// </remarks>
    Active = 0,

    /// <summary>
    /// Spawner is temporarily inactive.
    /// </summary>
    /// <remarks>
    /// Dormant spawners do not produce monsters but can be
    /// reactivated. Used for temporary disabling effects.
    /// </remarks>
    Dormant = 1,

    /// <summary>
    /// Spawner has been permanently destroyed.
    /// </summary>
    /// <remarks>
    /// Destroyed spawners cannot be reactivated and do not
    /// contribute to repopulation. When all spawners in a
    /// room are destroyed, the room becomes permanently clear.
    /// </remarks>
    Destroyed = 2
}
```

### 5.5 Spawner Type Characteristics

| Type | Typical Monsters | Common Locations | Durability |
|------|------------------|------------------|------------|
| Nest | Rats, spiders, wolves | Caves, forests | Low |
| Portal | Demons, elementals | Magical areas | Medium |
| Altar | Undead, wraiths | Crypts, temples | Medium-High |
| Hive | Insects, swarms | Infested areas | Low-Medium |

---

## 6. RepopulationRule Value Object

### 6.1 Purpose

The `RepopulationRule` value object defines how repopulation behaves for a specific room type, including respawn timers, scaling factors, and whether a spawner is required.

### 6.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/RepopulationRule.cs`

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines repopulation behavior for a room type.
/// </summary>
/// <remarks>
/// Repopulation rules control how quickly rooms respawn monsters,
/// how that timer scales with repeated clearing, and whether
/// a spawner is required for repopulation to occur.
/// </remarks>
public readonly record struct RepopulationRule
{
    /// <summary>
    /// Gets the room type this rule applies to.
    /// </summary>
    public RoomType RoomType { get; init; }

    /// <summary>
    /// Gets the base respawn time in minutes.
    /// </summary>
    /// <remarks>
    /// This is the respawn time after the first clear.
    /// Subsequent clears may increase this based on scaling factor.
    /// </remarks>
    public int BaseRespawnMinutes { get; init; }

    /// <summary>
    /// Gets the timer scaling factor per additional clear.
    /// </summary>
    /// <remarks>
    /// Each time a room is cleared beyond the first, the respawn
    /// timer is multiplied by (1 + scalingFactor * (clearCount - 1)).
    /// A factor of 0.25 means 25% longer per additional clear.
    /// </remarks>
    public double TimerScalingFactor { get; init; }

    /// <summary>
    /// Gets the maximum monsters spawned per repopulation event.
    /// </summary>
    /// <remarks>
    /// Caps the total monsters that can spawn, regardless of
    /// how many spawners are in the room.
    /// </remarks>
    public int MaxMonstersPerSpawn { get; init; }

    /// <summary>
    /// Gets whether this room type requires a spawner to repopulate.
    /// </summary>
    /// <remarks>
    /// If true, rooms without active spawners will not repopulate.
    /// If false, rooms repopulate even without spawners (wandering monsters).
    /// </remarks>
    public bool RequiresSpawner { get; init; }

    /// <summary>
    /// Gets a description of this repopulation rule.
    /// </summary>
    public string Description { get; init; }

    /// <summary>
    /// Gets the default repopulation rule for unknown room types.
    /// </summary>
    public static RepopulationRule Default => new()
    {
        RoomType = RoomType.Standard,
        BaseRespawnMinutes = 30,
        TimerScalingFactor = 0.25,
        MaxMonstersPerSpawn = 3,
        RequiresSpawner = true,
        Description = "Default repopulation rule"
    };

    /// <summary>
    /// Creates a repopulation rule.
    /// </summary>
    public static RepopulationRule Create(
        RoomType roomType,
        int baseRespawnMinutes,
        double timerScalingFactor,
        int maxMonstersPerSpawn,
        bool requiresSpawner,
        string description)
    {
        if (baseRespawnMinutes < 1)
            throw new ArgumentException("Base respawn minutes must be at least 1.", nameof(baseRespawnMinutes));

        if (timerScalingFactor < 0)
            throw new ArgumentException("Timer scaling factor cannot be negative.", nameof(timerScalingFactor));

        if (maxMonstersPerSpawn < 1)
            throw new ArgumentException("Max monsters per spawn must be at least 1.", nameof(maxMonstersPerSpawn));

        return new RepopulationRule
        {
            RoomType = roomType,
            BaseRespawnMinutes = baseRespawnMinutes,
            TimerScalingFactor = timerScalingFactor,
            MaxMonstersPerSpawn = maxMonstersPerSpawn,
            RequiresSpawner = requiresSpawner,
            Description = description ?? string.Empty
        };
    }

    /// <summary>
    /// Calculates the actual respawn time based on clear count.
    /// </summary>
    /// <param name="clearCount">Number of times the room has been cleared.</param>
    /// <returns>Respawn time in minutes.</returns>
    public int CalculateRespawnMinutes(int clearCount)
    {
        if (clearCount < 1)
            return BaseRespawnMinutes;

        // Scale timer based on clear count (diminishing returns)
        var scaledMinutes = BaseRespawnMinutes * (1 + (clearCount - 1) * TimerScalingFactor);

        // Cap at 3x base time
        var maxMinutes = BaseRespawnMinutes * 3;

        return (int)Math.Min(scaledMinutes, maxMinutes);
    }

    /// <summary>
    /// Gets a string representation of the rule.
    /// </summary>
    public override string ToString() =>
        $"RepopulationRule[{RoomType}] Base: {BaseRespawnMinutes}min, Scaling: {TimerScalingFactor:P0}";
}
```

### 6.4 RespawnTimer Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/RespawnTimer.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a countdown timer for room respawning.
/// </summary>
/// <remarks>
/// Tracks when a room was cleared and how long until monsters
/// respawn. Provides computed properties for time remaining
/// and expiration status.
/// </remarks>
public readonly record struct RespawnTimer
{
    /// <summary>
    /// Gets when the timer started.
    /// </summary>
    public DateTime StartTime { get; init; }

    /// <summary>
    /// Gets the duration of the timer.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Gets when the timer expires.
    /// </summary>
    public DateTime ExpiresAt => StartTime + Duration;

    /// <summary>
    /// Gets whether the timer has expired.
    /// </summary>
    public bool IsExpired => DateTime.UtcNow >= ExpiresAt;

    /// <summary>
    /// Gets the time remaining until expiration.
    /// </summary>
    public TimeSpan TimeRemaining
    {
        get
        {
            var remaining = ExpiresAt - DateTime.UtcNow;
            return remaining > TimeSpan.Zero ? remaining : TimeSpan.Zero;
        }
    }

    /// <summary>
    /// Gets the percentage of time elapsed.
    /// </summary>
    public double PercentageElapsed
    {
        get
        {
            if (Duration <= TimeSpan.Zero)
                return 100;

            var elapsed = DateTime.UtcNow - StartTime;
            return Math.Min(100, elapsed / Duration * 100);
        }
    }

    /// <summary>
    /// Creates a new respawn timer.
    /// </summary>
    /// <param name="startTime">When the timer starts.</param>
    /// <param name="duration">How long until expiration.</param>
    /// <returns>A new RespawnTimer instance.</returns>
    public static RespawnTimer Create(DateTime startTime, TimeSpan duration)
    {
        if (duration < TimeSpan.Zero)
            throw new ArgumentException("Duration cannot be negative.", nameof(duration));

        return new RespawnTimer
        {
            StartTime = startTime,
            Duration = duration
        };
    }

    /// <summary>
    /// Creates a timer starting now with the specified duration in minutes.
    /// </summary>
    public static RespawnTimer FromMinutes(int minutes) =>
        Create(DateTime.UtcNow, TimeSpan.FromMinutes(minutes));

    /// <summary>
    /// Creates a new timer with the same duration, starting now.
    /// </summary>
    public RespawnTimer Reset() =>
        Create(DateTime.UtcNow, Duration);

    /// <summary>
    /// Gets a human-readable string of time remaining.
    /// </summary>
    public string GetTimeRemainingDisplay()
    {
        if (IsExpired)
            return "Respawning now";

        var remaining = TimeRemaining;

        if (remaining.TotalHours >= 1)
            return $"{(int)remaining.TotalHours}h {remaining.Minutes}m";

        if (remaining.TotalMinutes >= 1)
            return $"{(int)remaining.TotalMinutes}m {remaining.Seconds}s";

        return $"{remaining.Seconds}s";
    }

    /// <summary>
    /// Gets a string representation of the timer.
    /// </summary>
    public override string ToString() =>
        IsExpired
            ? $"RespawnTimer[Expired at {ExpiresAt:g}]"
            : $"RespawnTimer[{GetTimeRemainingDisplay()} remaining]";
}
```

---

## 7. RepopulationService

### 7.1 Purpose

The `RepopulationService` manages all aspects of monster repopulation, including timer management, spawner tracking, respawn triggering, and permanent clearing logic.

### 7.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/IRepopulationService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/RepopulationService.cs`

### 7.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing monster repopulation in dungeons.
/// </summary>
public interface IRepopulationService
{
    /// <summary>
    /// Checks if a room is eligible for respawning.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>True if the room can respawn monsters.</returns>
    bool CheckRespawnEligibility(Guid roomId);

    /// <summary>
    /// Triggers a respawn event for a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>The number of monsters spawned.</returns>
    int TriggerRespawn(Guid roomId);

    /// <summary>
    /// Gets the respawn timer for a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>The respawn timer, or null if no timer is active.</returns>
    RespawnTimer? GetRespawnTimer(Guid roomId);

    /// <summary>
    /// Sets a respawn timer for a room based on its type.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    void SetRespawnTimer(Guid roomId);

    /// <summary>
    /// Gets all active spawners in a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>Active spawners in the room.</returns>
    IReadOnlyList<Spawner> GetActiveSpawners(Guid roomId);

    /// <summary>
    /// Destroys a spawner in a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="spawnerId">The spawner identifier.</param>
    /// <returns>True if the spawner was destroyed.</returns>
    bool DestroySpawner(Guid roomId, Guid spawnerId);

    /// <summary>
    /// Checks if all spawners in a room have been destroyed.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>True if all spawners are destroyed.</returns>
    bool AreAllSpawnersDestroyed(Guid roomId);

    /// <summary>
    /// Marks a room as permanently cleared.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    void SetPermanentlyClear(Guid roomId);

    /// <summary>
    /// Gets the repopulation rule for a room type.
    /// </summary>
    /// <param name="roomType">The room type.</param>
    /// <returns>The applicable repopulation rule.</returns>
    RepopulationRule GetRepopulationRule(RoomType roomType);

    /// <summary>
    /// Processes all pending respawns across tracked rooms.
    /// </summary>
    /// <remarks>
    /// Should be called periodically (e.g., each game tick) to
    /// trigger respawns for rooms with expired timers.
    /// </remarks>
    /// <returns>List of room IDs that had respawns triggered.</returns>
    IReadOnlyList<Guid> ProcessRespawns();

    /// <summary>
    /// Gets the number of rooms with active respawn timers.
    /// </summary>
    int GetPendingRespawnCount();

    /// <summary>
    /// Registers a room for respawn tracking.
    /// </summary>
    /// <param name="room">The room to track.</param>
    void RegisterRoom(Room room);
}
```

### 7.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing monster repopulation in dungeons.
/// </summary>
public class RepopulationService : IRepopulationService
{
    private readonly IConfigurationProvider _config;
    private readonly IWorldStateService _worldStateService;
    private readonly ILogger<RepopulationService> _logger;

    private readonly Dictionary<Guid, Room> _trackedRooms = new();

    /// <summary>
    /// Initializes a new instance of the RepopulationService.
    /// </summary>
    public RepopulationService(
        IConfigurationProvider config,
        IWorldStateService worldStateService,
        ILogger<RepopulationService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _worldStateService = worldStateService ?? throw new ArgumentNullException(nameof(worldStateService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public void RegisterRoom(Room room)
    {
        if (room == null)
            throw new ArgumentNullException(nameof(room));

        _trackedRooms[room.Id] = room;
        _logger.LogDebug("Registered room {RoomId} for respawn tracking", room.Id);
    }

    /// <inheritdoc />
    public bool CheckRespawnEligibility(Guid roomId)
    {
        if (!_trackedRooms.TryGetValue(roomId, out var room))
        {
            _logger.LogWarning("Room {RoomId} not found for respawn eligibility check", roomId);
            return false;
        }

        // Permanently cleared rooms never respawn
        if (room.IsPermanentlyCleared)
        {
            _logger.LogDebug("Room {RoomId} is permanently cleared, not eligible for respawn", roomId);
            return false;
        }

        // Check if timer exists and is expired
        if (room.RespawnTimer == null)
        {
            _logger.LogDebug("Room {RoomId} has no respawn timer", roomId);
            return false;
        }

        if (!room.RespawnTimer.Value.IsExpired)
        {
            _logger.LogDebug(
                "Room {RoomId} respawn timer not expired ({TimeRemaining} remaining)",
                roomId,
                room.RespawnTimer.Value.GetTimeRemainingDisplay());
            return false;
        }

        // Check if spawner is required
        var rule = GetRepopulationRule(room.RoomType);
        if (rule.RequiresSpawner && !room.HasActiveSpawners)
        {
            _logger.LogDebug(
                "Room {RoomId} requires spawner but has none active",
                roomId);
            return false;
        }

        return true;
    }

    /// <inheritdoc />
    public int TriggerRespawn(Guid roomId)
    {
        if (!_trackedRooms.TryGetValue(roomId, out var room))
        {
            _logger.LogWarning("Room {RoomId} not found for respawn trigger", roomId);
            return 0;
        }

        if (!CheckRespawnEligibility(roomId))
        {
            _logger.LogDebug("Room {RoomId} not eligible for respawn", roomId);
            return 0;
        }

        var rule = GetRepopulationRule(room.RoomType);
        var activeSpawners = GetActiveSpawners(roomId);
        var totalSpawned = 0;

        foreach (var spawner in activeSpawners)
        {
            var toSpawn = Math.Min(spawner.SpawnRate, rule.MaxMonstersPerSpawn - totalSpawned);

            for (int i = 0; i < toSpawn && totalSpawned < rule.MaxMonstersPerSpawn; i++)
            {
                var monsterType = spawner.SelectMonsterType();
                // In full implementation, this would add actual monsters to the room
                // For now, we track the count
                totalSpawned++;

                _logger.LogDebug(
                    "Spawned {MonsterType} from {SpawnerType} in room {RoomId}",
                    monsterType,
                    spawner.SpawnerType,
                    roomId);
            }
        }

        // Reset room state
        var roomState = _worldStateService.GetRoomState(roomId);
        if (roomState.StateType == RoomStateType.Cleared ||
            roomState.StateType == RoomStateType.Exhausted)
        {
            // Room is no longer cleared
            room.ClearRespawnTimer();
        }

        _logger.LogInformation(
            "Respawned {MonsterCount} monsters in room {RoomId} from {SpawnerCount} spawners",
            totalSpawned,
            roomId,
            activeSpawners.Count);

        return totalSpawned;
    }

    /// <inheritdoc />
    public RespawnTimer? GetRespawnTimer(Guid roomId)
    {
        if (!_trackedRooms.TryGetValue(roomId, out var room))
            return null;

        return room.RespawnTimer;
    }

    /// <inheritdoc />
    public void SetRespawnTimer(Guid roomId)
    {
        if (!_trackedRooms.TryGetValue(roomId, out var room))
        {
            _logger.LogWarning("Room {RoomId} not found for setting respawn timer", roomId);
            return;
        }

        if (room.IsPermanentlyCleared)
        {
            _logger.LogDebug("Room {RoomId} is permanently cleared, not setting timer", roomId);
            return;
        }

        var rule = GetRepopulationRule(room.RoomType);

        // Don't set timer if spawner required but none active
        if (rule.RequiresSpawner && !room.HasActiveSpawners)
        {
            _logger.LogDebug(
                "Room {RoomId} requires spawner but has none, setting as permanently cleared",
                roomId);
            SetPermanentlyClear(roomId);
            return;
        }

        var clearCount = _worldStateService.GetRoomClearCount(roomId);
        var respawnMinutes = rule.CalculateRespawnMinutes(clearCount);
        var timer = RespawnTimer.FromMinutes(respawnMinutes);

        room.SetRespawnTimer(timer);

        _logger.LogInformation(
            "Set respawn timer for room {RoomId}: {Minutes} minutes (clear #{ClearCount})",
            roomId,
            respawnMinutes,
            clearCount);
    }

    /// <inheritdoc />
    public IReadOnlyList<Spawner> GetActiveSpawners(Guid roomId)
    {
        if (!_trackedRooms.TryGetValue(roomId, out var room))
            return Array.Empty<Spawner>();

        return room.Spawners
            .Where(s => s.IsActive)
            .ToList();
    }

    /// <inheritdoc />
    public bool DestroySpawner(Guid roomId, Guid spawnerId)
    {
        if (!_trackedRooms.TryGetValue(roomId, out var room))
        {
            _logger.LogWarning("Room {RoomId} not found for spawner destruction", roomId);
            return false;
        }

        var spawner = room.Spawners.FirstOrDefault(s => s.Id == spawnerId);
        if (spawner == null)
        {
            _logger.LogWarning(
                "Spawner {SpawnerId} not found in room {RoomId}",
                spawnerId,
                roomId);
            return false;
        }

        if (spawner.IsDestroyed)
        {
            _logger.LogDebug("Spawner {SpawnerId} is already destroyed", spawnerId);
            return false;
        }

        // Force destroy (bypass damage)
        while (!spawner.IsDestroyed)
        {
            spawner.TakeDamage(spawner.CurrentHealth);
        }

        _logger.LogInformation(
            "Destroyed {SpawnerType} spawner in room {RoomId}",
            spawner.SpawnerType,
            roomId);

        // Check if room should be permanently cleared
        if (AreAllSpawnersDestroyed(roomId))
        {
            var rule = GetRepopulationRule(room.RoomType);
            if (rule.RequiresSpawner)
            {
                SetPermanentlyClear(roomId);
            }
        }

        return true;
    }

    /// <inheritdoc />
    public bool AreAllSpawnersDestroyed(Guid roomId)
    {
        if (!_trackedRooms.TryGetValue(roomId, out var room))
            return true; // No room = no spawners

        if (room.Spawners.Count == 0)
            return true; // No spawners to destroy

        return room.Spawners.All(s => s.IsDestroyed);
    }

    /// <inheritdoc />
    public void SetPermanentlyClear(Guid roomId)
    {
        if (!_trackedRooms.TryGetValue(roomId, out var room))
        {
            _logger.LogWarning("Room {RoomId} not found for permanent clear", roomId);
            return;
        }

        room.SetPermanentlyCleared();
        _worldStateService.SetRoomCleared(roomId, isPermanent: true);

        _logger.LogInformation(
            "Room {RoomId} marked as permanently cleared",
            roomId);
    }

    /// <inheritdoc />
    public RepopulationRule GetRepopulationRule(RoomType roomType)
    {
        var rules = _config.GetRepopulationRules();
        var rule = rules.FirstOrDefault(r => r.RoomType == roomType);

        if (rule.Equals(default(RepopulationRule)))
        {
            _logger.LogDebug(
                "No repopulation rule found for {RoomType}, using default",
                roomType);
            return RepopulationRule.Default;
        }

        return rule;
    }

    /// <inheritdoc />
    public IReadOnlyList<Guid> ProcessRespawns()
    {
        var respawnedRooms = new List<Guid>();

        foreach (var roomId in _trackedRooms.Keys.ToList())
        {
            if (CheckRespawnEligibility(roomId))
            {
                var spawned = TriggerRespawn(roomId);
                if (spawned > 0)
                {
                    respawnedRooms.Add(roomId);
                }
            }
        }

        if (respawnedRooms.Count > 0)
        {
            _logger.LogInformation(
                "Processed respawns for {RoomCount} rooms",
                respawnedRooms.Count);
        }

        return respawnedRooms;
    }

    /// <inheritdoc />
    public int GetPendingRespawnCount()
    {
        return _trackedRooms.Values
            .Count(r => r.RespawnTimer.HasValue && !r.IsPermanentlyCleared);
    }
}
```

---

## 8. Room Entity Integration

### 8.1 Purpose

Extend the `Room` entity with spawner management, respawn timer tracking, and permanent clearing support.

### 8.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modification)

### 8.3 Changes

```csharp
// Add to Room.cs - after existing persistence properties from v0.1.4a

/// <summary>
/// Gets the spawners in this room.
/// </summary>
/// <remarks>
/// Spawners are the source points for monster repopulation.
/// Destroying all spawners in a room permanently clears it.
/// </remarks>
public IReadOnlyList<Spawner> Spawners => _spawners.AsReadOnly();
private readonly List<Spawner> _spawners = new();

/// <summary>
/// Gets the current respawn timer for this room.
/// </summary>
/// <remarks>
/// Null if no respawn is pending (either not cleared or permanently cleared).
/// </remarks>
public RespawnTimer? RespawnTimer { get; private set; }

/// <summary>
/// Gets whether this room is permanently cleared.
/// </summary>
/// <remarks>
/// Permanently cleared rooms never respawn monsters.
/// This occurs when all spawners are destroyed in a room that
/// requires spawners for repopulation.
/// </remarks>
public bool IsPermanentlyCleared { get; private set; }

/// <summary>
/// Gets whether this room has any active spawners.
/// </summary>
public bool HasActiveSpawners => _spawners.Any(s => s.IsActive);

/// <summary>
/// Gets the count of active spawners in this room.
/// </summary>
public int ActiveSpawnerCount => _spawners.Count(s => s.IsActive);

/// <summary>
/// Adds a spawner to this room.
/// </summary>
/// <param name="spawner">The spawner to add.</param>
public void AddSpawner(Spawner spawner)
{
    if (spawner == null)
        throw new ArgumentNullException(nameof(spawner));

    if (spawner.RoomId != Id)
        throw new ArgumentException("Spawner room ID does not match this room.", nameof(spawner));

    if (_spawners.Any(s => s.Id == spawner.Id))
        return; // Already added

    _spawners.Add(spawner);
}

/// <summary>
/// Removes a spawner from this room.
/// </summary>
/// <param name="spawnerId">The ID of the spawner to remove.</param>
/// <returns>True if the spawner was removed.</returns>
public bool RemoveSpawner(Guid spawnerId)
{
    var spawner = _spawners.FirstOrDefault(s => s.Id == spawnerId);
    if (spawner == null)
        return false;

    return _spawners.Remove(spawner);
}

/// <summary>
/// Gets a spawner by ID.
/// </summary>
/// <param name="spawnerId">The spawner ID.</param>
/// <returns>The spawner, or null if not found.</returns>
public Spawner? GetSpawner(Guid spawnerId)
{
    return _spawners.FirstOrDefault(s => s.Id == spawnerId);
}

/// <summary>
/// Sets the respawn timer for this room.
/// </summary>
/// <param name="timer">The respawn timer.</param>
public void SetRespawnTimer(RespawnTimer timer)
{
    if (IsPermanentlyCleared)
        return; // Cannot set timer on permanently cleared rooms

    RespawnTimer = timer;
}

/// <summary>
/// Clears the respawn timer.
/// </summary>
public void ClearRespawnTimer()
{
    RespawnTimer = null;
}

/// <summary>
/// Marks this room as permanently cleared.
/// </summary>
public void SetPermanentlyCleared()
{
    IsPermanentlyCleared = true;
    RespawnTimer = null;
}

/// <summary>
/// Gets a description of the spawner status in this room.
/// </summary>
public string GetSpawnerStatusDescription()
{
    if (_spawners.Count == 0)
        return "No spawners present.";

    var active = _spawners.Count(s => s.IsActive);
    var destroyed = _spawners.Count(s => s.IsDestroyed);
    var dormant = _spawners.Count(s => s.State == SpawnerState.Dormant);

    if (destroyed == _spawners.Count)
        return "All spawners destroyed. This area is permanently secured.";

    var parts = new List<string>();
    if (active > 0)
        parts.Add($"{active} active");
    if (dormant > 0)
        parts.Add($"{dormant} dormant");
    if (destroyed > 0)
        parts.Add($"{destroyed} destroyed");

    return $"Spawners: {string.Join(", ", parts)}.";
}
```

### 8.4 Data Model Change

```
MODIFY: Room
├── ADD: Spawners: IReadOnlyList<Spawner>
├── ADD: RespawnTimer: RespawnTimer?
├── ADD: IsPermanentlyCleared: bool (default: false)
├── ADD: HasActiveSpawners: bool (computed)
├── ADD: ActiveSpawnerCount: int (computed)
├── ADD: AddSpawner(spawner): void
├── ADD: RemoveSpawner(spawnerId): bool
├── ADD: GetSpawner(spawnerId): Spawner?
├── ADD: SetRespawnTimer(timer): void
├── ADD: ClearRespawnTimer(): void
├── ADD: SetPermanentlyCleared(): void
└── ADD: GetSpawnerStatusDescription(): string
```

---

## 9. Respawn Timer Mechanics

### 9.1 Timer Calculation

The respawn timer is calculated based on:
1. **Base time** from the repopulation rule for the room type
2. **Clear count scaling** - timer increases with repeated clears
3. **Maximum cap** - timer cannot exceed 3x base time

```
actualMinutes = baseMinutes * (1 + (clearCount - 1) * scalingFactor)
actualMinutes = min(actualMinutes, baseMinutes * 3)
```

### 9.2 Example Calculations

| Room Type | Base | Scaling | Clear #1 | Clear #2 | Clear #3 | Clear #4+ |
|-----------|------|---------|----------|----------|----------|-----------|
| Standard | 30m | 0.25 | 30m | 37m | 45m | 52m (cap: 90m) |
| Boss | 60m | 0.50 | 60m | 90m | 120m | 150m (cap: 180m) |
| Treasure | 45m | 0.20 | 45m | 54m | 63m | 72m (cap: 135m) |

### 9.3 Timer State Diagram

```
┌─────────────┐
│ Room Cleared│
└──────┬──────┘
       │
       ▼
┌──────────────────────┐
│ Has Active Spawners? │
├──────┬───────────────┤
│ Yes  │      No       │
│      │               │
▼      │               ▼
┌──────┴──────┐   ┌────────────────────┐
│ Set Timer   │   │ Requires Spawner?  │
│ (calculated)│   ├──────────┬─────────┤
└──────┬──────┘   │   Yes    │   No    │
       │          │          │         │
       ▼          ▼          ▼         │
┌──────────┐ ┌──────────┐ ┌──────────┐ │
│ Timer    │ │Permanent │ │Set Timer │◄┘
│ Counting │ │Clear     │ │(default) │
└──────┬───┘ └──────────┘ └──────────┘
       │
       ▼
┌──────────────┐
│Timer Expired?│
├──────┬───────┤
│ Yes  │  No   │
│      │       │
▼      ▼       │
┌──────┐ ┌─────┴─────┐
│Spawn │ │Wait       │
└──────┘ └───────────┘
```

---

## 10. Spawner Destruction Mechanics

### 10.1 Targeting Spawners

Spawners can be targeted during combat when:
- The room is not fully cleared (enemies still present for some spawner types)
- The player specifically targets the spawner
- The spawner is visible and reachable

### 10.2 Spawner Health by Type

| Type | Default Health | Notes |
|------|----------------|-------|
| Nest | 20 | Fragile, easy to destroy |
| Portal | 50 | Requires sustained damage |
| Altar | 75 | Durable, may resist certain damage |
| Hive | 40 | Contains queen/core |

### 10.3 Permanent Clear Trigger

```
Spawner destroyed
       │
       ▼
┌──────────────────────────┐
│ All spawners destroyed?  │
├──────────┬───────────────┤
│   Yes    │      No       │
│          │               │
▼          ▼               │
┌──────────────────────┐   │
│ Room requires spawner│   │
│ for repopulation?    │   │
├──────────┬───────────┤   │
│   Yes    │    No     │   │
│          │           │   │
▼          ▼           │   │
┌────────┐ ┌──────────┐│   │
│Permanent│ │ Can still││   │
│Clear    │ │ respawn  │◄───┘
└────────┘ └──────────┘
```

---

## 11. Configuration File Schemas

### 11.1 Repopulation Rules Configuration

**File:** `config/repopulation-rules.json`

```json
{
  "$schema": "schemas/repopulation-rules-schema.json",
  "rules": [
    {
      "roomType": "Standard",
      "baseRespawnMinutes": 30,
      "timerScalingFactor": 0.25,
      "maxMonstersPerSpawn": 4,
      "requiresSpawner": true,
      "description": "Standard rooms respawn from spawners every 30 minutes base"
    },
    {
      "roomType": "Boss",
      "baseRespawnMinutes": 60,
      "timerScalingFactor": 0.50,
      "maxMonstersPerSpawn": 1,
      "requiresSpawner": true,
      "description": "Boss rooms respawn slowly with scaling, single powerful enemy"
    },
    {
      "roomType": "Treasure",
      "baseRespawnMinutes": 45,
      "timerScalingFactor": 0.20,
      "maxMonstersPerSpawn": 3,
      "requiresSpawner": true,
      "description": "Treasure rooms have moderate respawn to protect valuables"
    },
    {
      "roomType": "Entrance",
      "baseRespawnMinutes": 60,
      "timerScalingFactor": 0.10,
      "maxMonstersPerSpawn": 2,
      "requiresSpawner": false,
      "description": "Entrance rooms can have wandering monsters even without spawners"
    },
    {
      "roomType": "Corridor",
      "baseRespawnMinutes": 20,
      "timerScalingFactor": 0.15,
      "maxMonstersPerSpawn": 2,
      "requiresSpawner": false,
      "description": "Corridors have quick respawn from wandering monsters"
    },
    {
      "roomType": "Safe",
      "baseRespawnMinutes": 0,
      "timerScalingFactor": 0,
      "maxMonstersPerSpawn": 0,
      "requiresSpawner": true,
      "description": "Safe rooms never respawn monsters"
    }
  ]
}
```

### 11.2 JSON Schema

**File:** `config/schemas/repopulation-rules-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "repopulation-rules-schema.json",
  "title": "Repopulation Rules Configuration",
  "description": "Schema for monster repopulation behavior rules",
  "type": "object",
  "required": ["rules"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "rules": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/repopulationRule"
      }
    }
  },
  "$defs": {
    "repopulationRule": {
      "type": "object",
      "required": ["roomType", "baseRespawnMinutes", "timerScalingFactor", "maxMonstersPerSpawn", "requiresSpawner", "description"],
      "properties": {
        "roomType": {
          "type": "string",
          "enum": [
            "Standard",
            "Boss",
            "Treasure",
            "Entrance",
            "Corridor",
            "Safe",
            "Secret",
            "Puzzle"
          ],
          "description": "The room type this rule applies to"
        },
        "baseRespawnMinutes": {
          "type": "integer",
          "minimum": 0,
          "description": "Base respawn time in minutes (0 = never respawns)"
        },
        "timerScalingFactor": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Percentage increase per additional clear (0.25 = 25%)"
        },
        "maxMonstersPerSpawn": {
          "type": "integer",
          "minimum": 0,
          "description": "Maximum monsters spawned per repopulation event"
        },
        "requiresSpawner": {
          "type": "boolean",
          "description": "Whether a spawner is required for repopulation"
        },
        "description": {
          "type": "string",
          "minLength": 1,
          "description": "Human-readable description of this rule"
        }
      }
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `RepopulationService` | Information | Respawn triggered, spawner destroyed, permanent clear |
| `RepopulationService` | Debug | Timer set, eligibility check, spawner selection |
| `RepopulationService` | Warning | Room not found, missing rule |
| `Spawner` | Debug | Damage taken, state changes |

### 12.2 Log Message Examples

```csharp
// Information
_logger.LogInformation(
    "Respawned {MonsterCount} monsters in room {RoomId} from {SpawnerCount} spawners",
    totalSpawned, roomId, activeSpawners.Count);

_logger.LogInformation(
    "Destroyed {SpawnerType} spawner in room {RoomId}",
    spawner.SpawnerType, roomId);

_logger.LogInformation(
    "Room {RoomId} marked as permanently cleared",
    roomId);

_logger.LogInformation(
    "Set respawn timer for room {RoomId}: {Minutes} minutes (clear #{ClearCount})",
    roomId, respawnMinutes, clearCount);

// Debug
_logger.LogDebug(
    "Spawned {MonsterType} from {SpawnerType} in room {RoomId}",
    monsterType, spawner.SpawnerType, roomId);

_logger.LogDebug(
    "Room {RoomId} respawn timer not expired ({TimeRemaining} remaining)",
    roomId, timer.GetTimeRemainingDisplay());

// Warning
_logger.LogWarning(
    "Room {RoomId} not found for respawn eligibility check",
    roomId);
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Spawner entity | ~6 |
| SpawnerType/SpawnerState | ~2 |
| RepopulationRule value object | ~4 |
| RespawnTimer value object | ~4 |
| RepopulationService | ~8 |
| Room integration | ~4 |
| **Total** | **~28** |

### 13.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `SpawnerTests.cs` | ~6 | Create, TakeDamage, Destroy, SelectMonsterType, SetDormant, Activate |
| `SpawnerTypeTests.cs` | ~2 | Enum values, state transitions |
| `RepopulationRuleTests.cs` | ~4 | Create, Default, CalculateRespawnMinutes, validation |
| `RespawnTimerTests.cs` | ~4 | Create, IsExpired, TimeRemaining, Reset |
| `RepopulationServiceTests.cs` | ~8 | CheckEligibility, TriggerRespawn, DestroySpawner, ProcessRespawns, SetPermanentlyClear |
| `RoomSpawnerTests.cs` | ~4 | AddSpawner, RemoveSpawner, HasActiveSpawners, SetPermanentlyCleared |

### 13.3 Test Categories

**Spawner Tests:**
```csharp
[Test]
public void Create_WithValidParameters_CreatesSpawner()

[Test]
public void Create_WithEmptyRoomId_ThrowsArgumentException()

[Test]
public void TakeDamage_ReducesHealth_AndDestroys_WhenZero()

[Test]
public void TakeDamage_OnDestroyedSpawner_ReturnsFalse()

[Test]
public void SelectMonsterType_ReturnsValidType_FromList()

[Test]
public void SetDormant_ChangesState_WhenNotDestroyed()
```

**RepopulationService Tests:**
```csharp
[Test]
public void CheckRespawnEligibility_ReturnsFalse_WhenPermanentlyCleared()

[Test]
public void CheckRespawnEligibility_ReturnsFalse_WhenTimerNotExpired()

[Test]
public void TriggerRespawn_SpawnsMonsters_FromActiveSpawners()

[Test]
public void DestroySpawner_SetsPermanentClear_WhenAllDestroyed()

[Test]
public void ProcessRespawns_TriggersRespawn_ForExpiredTimers()

[Test]
public void SetRespawnTimer_CalculatesCorrectly_WithClearCount()

[Test]
public void GetRepopulationRule_ReturnsDefault_WhenNoRuleFound()

[Test]
public void SetPermanentlyClear_ClearsTimer_AndMarksRoom()
```

---

## 14. Use Cases

### UC-001: Clear Room and Set Respawn Timer

**Actor:** Player
**Flow:** Player defeats all enemies → CombatService calls SetRoomCleared → RepopulationService.SetRespawnTimer(roomId) → Timer calculated based on room type and clear count → Player informed of respawn time

### UC-002: Room Respawns After Timer Expires

**Actor:** System
**Flow:** Game tick → ProcessRespawns() called → Check each room's timer → For expired timers, TriggerRespawn() → Monsters added from active spawners → Room state updated → Log respawn event

### UC-003: Destroy Spawner During Combat

**Actor:** Player
**Flow:** Player targets spawner → Attack damage applied → spawner.TakeDamage() → If health <= 0, spawner destroyed → Check if all spawners destroyed → If yes and requiresSpawner, set permanent clear

### UC-004: Permanently Clear Room

**Actor:** Player
**Flow:** Player destroys final spawner in room → AreAllSpawnersDestroyed() returns true → GetRepopulationRule().RequiresSpawner is true → SetPermanentlyClear(roomId) → Room will never respawn → Player notified of permanent clear

### UC-005: Return to Respawned Room

**Actor:** Player
**Flow:** Player returns to previously cleared room → Timer had expired → Room now has monsters → Combat warning displayed → Player must re-clear room

### UC-006: Query Respawn Status

**Actor:** Player (via map/status)
**Flow:** Player views room status → GetRespawnTimer(roomId) → If timer exists, display time remaining → If permanently cleared, display "Secured" → If no timer and not cleared, display enemy status

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `Spawner.cs` created
- [ ] `SpawnerType.cs` created
- [ ] `SpawnerState.cs` created
- [ ] `RepopulationRule.cs` created
- [ ] `RespawnTimer.cs` created
- [ ] `Room.cs` updated with spawner management

### Application Layer
- [ ] `IRepopulationService.cs` created
- [ ] `RepopulationService.cs` created

### Infrastructure Layer
- [ ] `IConfigurationProvider.cs` updated with GetRepopulationRules()
- [ ] `JsonConfigurationProvider.cs` updated to load repopulation rules

### Configuration Files
- [ ] `config/repopulation-rules.json` created with 6 room type definitions
- [ ] `config/schemas/repopulation-rules-schema.json` created

### Testing
- [ ] `SpawnerTests.cs` created (~6 tests)
- [ ] `SpawnerTypeTests.cs` created (~2 tests)
- [ ] `RepopulationRuleTests.cs` created (~4 tests)
- [ ] `RespawnTimerTests.cs` created (~4 tests)
- [ ] `RepopulationServiceTests.cs` created (~8 tests)
- [ ] `RoomSpawnerTests.cs` created (~4 tests)
- [ ] All ~28 tests passing

### Documentation
- [ ] XML documentation on all public members
- [ ] Code follows .editorconfig conventions

---

## 16. Acceptance Criteria

### Functional

- [ ] Spawner entity tracks type, state, health, and monster types
- [ ] Spawners can be damaged and destroyed
- [ ] RepopulationRule defines respawn behavior per room type
- [ ] RespawnTimer tracks countdown with expiration checking
- [ ] RepopulationService.SetRespawnTimer calculates correct time based on clear count
- [ ] RepopulationService.CheckRespawnEligibility considers timer, spawners, and permanent status
- [ ] RepopulationService.TriggerRespawn spawns monsters from active spawners
- [ ] RepopulationService.ProcessRespawns handles multiple rooms correctly
- [ ] DestroySpawner triggers permanent clear when all spawners destroyed (if required)
- [ ] SetPermanentlyClear marks room and clears timer
- [ ] Room.HasActiveSpawners correctly reflects spawner states
- [ ] Repopulation rules load from JSON configuration

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~28 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on public members
- [ ] Code follows .editorconfig conventions
- [ ] No hardcoded respawn times outside configuration

---

## 17. Dependencies

### 17.1 Prerequisites (v0.1.4a)

| Component | Purpose for v0.1.4b |
|-----------|---------------------|
| `RoomState` entity | Tracks cleared status for respawn decisions |
| `WorldStateService` | Integration for permanent clear recording |
| `PersistentChange` | RoomCleared change type for respawn tracking |
| `Room.LastCleared` | Used for respawn timer calculations |
| `Room.ClearCount` | Used for timer scaling calculations |
| `HasActiveSpawner` placeholder | Now implemented with full spawner system |

### 17.2 Provides to Future Phases

| Component | Used By |
|-----------|---------|
| `Spawner` entity | v0.1.4c (Faction-controlled spawners) |
| `RepopulationService` | v0.1.4c (Faction repopulation rules) |
| `SpawnerType` | v0.1.4c (Faction spawner preferences) |
| `RespawnTimer` | v0.1.4d (Evolution event timing) |
| `Room.IsPermanentlyCleared` | v0.1.4c (Faction territory loss) |

### 17.3 Dependency Diagram

```
v0.1.4a (Persistent World State)
    │
    ├── RoomState entity ─────────────────────────┐
    ├── WorldStateService ────────────────────────│
    ├── Room.LastCleared ─────────────────────────│
    ├── Room.ClearCount ──────────────────────────┤
    └── HasActiveSpawner placeholder ─────────────┘
                                                  │
                                                  ▼
v0.1.4b (Monster Repopulation)
    │
    ├── Spawner entity ───────────────────────────────────────────┐
    ├── SpawnerType, SpawnerState enums ──────────────────────────│
    ├── RepopulationRule, RespawnTimer value objects ─────────────│
    ├── RepopulationService ──────────────────────────────────────┤
    ├── Room.Spawners, Room.RespawnTimer ─────────────────────────│
    └── Room.IsPermanentlyCleared ────────────────────────────────┘
                                                                  │
                                                                  ▼
                                      ┌────────────────────────────┴────────────────────────┐
                                      │                                                      │
                                      ▼                                                      ▼
                              v0.1.4c (Faction Territory Control)         v0.1.4d (Evolution Events)
```

---

## 18. Future Considerations

### 18.1 Deferred to v0.1.4c

- **Faction-controlled spawners** - Spawners belong to factions
- **Territory-based respawn rates** - Factions control respawn speed in their territory
- **Cross-faction spawner conflicts** - Factions can destroy each other's spawners
- **Faction expansion through spawners** - New spawners placed as factions expand

### 18.2 Deferred to v0.1.4d

- **Evolution events affecting spawners** - Cave-ins destroy spawners, migrations create new ones
- **Seasonal spawner changes** - Some spawners more active in certain seasons
- **Time-based dormancy cycles** - Spawners go dormant during day/night cycles

### 18.3 Out of Scope (Future Versions)

- **Player-placed spawner traps** - Setting traps that attract monsters
- **Spawner upgrades/mutations** - Spawners becoming more powerful over time
- **Boss spawner mechanics** - Special spawners for boss encounters
- **Spawner interaction items** - Items that affect spawner behavior

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
