# v0.10.3b Design Specification: Combo Detection

**Version:** 0.10.3b
**Parent:** v0.10.3 (Combo System)
**Prerequisites:** v0.10.3a Complete (Combo Definitions)
**Status:** Design Complete
**Estimated Unit Tests:** ~12

---

## 1. Overview

### Purpose

Implement the combo tracking system that monitors ability usage, detects sequences matching combo definitions, and applies bonus effects when combos complete. The system tracks progress per combatant, enforces timing windows, validates target requirements, and provides UI hints for active combos.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | `IComboService` |
| **Services** | `ComboService` |
| **Tracking** | `ComboProgress` |
| **DTOs** | `ComboResult`, `ComboActionResult`, `ComboHint` |
| **Events** | `ComboStartedEvent`, `ComboProgressedEvent`, `ComboCompletedEvent`, `ComboFailedEvent` |
| **Tests** | ~12 unit tests |

---

## 2. Feature Overview

```
v0.10.3b Features
â”œâ”€â”€ IComboService Interface
â”‚   â”œâ”€â”€ OnAbilityUsed(user, abilityId, target)
â”‚   â”œâ”€â”€ GetActiveProgress(combatant)
â”‚   â”œâ”€â”€ GetAvailableCombos(combatant)
â”‚   â”œâ”€â”€ GetComboHints(combatant)
â”‚   â”œâ”€â”€ TickCombos(combatant)
â”‚   â””â”€â”€ ResetProgress(combatant)
â”‚
â”œâ”€â”€ ComboService Implementation
â”‚   â”œâ”€â”€ Track active progress per combatant
â”‚   â”œâ”€â”€ Check for new combo starts
â”‚   â”œâ”€â”€ Advance active combo progress
â”‚   â”œâ”€â”€ Detect combo completions
â”‚   â”œâ”€â”€ Apply bonus effects
â”‚   â”œâ”€â”€ Expire old progress on tick
â”‚   â””â”€â”€ Publish combo events
â”‚
â”œâ”€â”€ ComboProgress Class
â”‚   â”œâ”€â”€ ComboId
â”‚   â”œâ”€â”€ CurrentStep
â”‚   â”œâ”€â”€ WindowRemaining
â”‚   â”œâ”€â”€ LastTargetId
â”‚   â”œâ”€â”€ AdvanceStep()
â”‚   â””â”€â”€ DecrementWindow()
â”‚
â”œâ”€â”€ Result Types
â”‚   â”œâ”€â”€ ComboResult (actions, completedCombos)
â”‚   â”œâ”€â”€ ComboActionResult (started, progressed, completed)
â”‚   â””â”€â”€ ComboHint (next ability suggestion)
â”‚
â””â”€â”€ Events
    â”œâ”€â”€ ComboStartedEvent
    â”œâ”€â”€ ComboProgressedEvent
    â”œâ”€â”€ ComboCompletedEvent
    â””â”€â”€ ComboFailedEvent
```

---

## 3. Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMBO DETECTION ARCHITECTURE                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   Ability Used Event       â”‚
                      â”‚  (AbilityId, Target, User) â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚       IComboService        â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ + OnAbilityUsed(event)    â”‚
                      â”‚ + GetActiveProgress()     â”‚
                      â”‚ + GetAvailableCombos()    â”‚
                      â”‚ + GetComboHints()         â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚        ComboService        â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ - _comboProvider          â”‚
                      â”‚ - _activeProgress: Dict   â”‚
                      â”‚                           â”‚
                      â”‚ + CheckComboStart         â”‚
                      â”‚ + AdvanceComboProgress    â”‚
                      â”‚ + CheckComboComplete      â”‚
                      â”‚ + ApplyBonusEffects       â”‚
                      â”‚ + ExpireOldProgress       â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    COMBO PROGRESS TRACKING
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    Active Progress for Player "Hero":
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ComboId            â”‚ CurrentStep â”‚ WindowRemaining â”‚ TargetId  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ elemental-burst    â”‚ 2/3         â”‚ 2 turns         â”‚ Goblin-1  â”‚
    â”‚ warriors-onslaught â”‚ 1/3         â”‚ 2 turns         â”‚ Orc-2     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    DETECTION FLOW
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    Ability Used: "ice-shard" on "Goblin-1"
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 1. Check if starts any new combos   â”‚
    â”‚    â†’ "ice-shard" is step 1 of       â”‚
    â”‚      "frost-combo" âœ“                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 2. Check if advances active combos  â”‚
    â”‚    â†’ "elemental-burst" at step 2    â”‚
    â”‚    â†’ Matches! Advance to step 2/3   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 3. Check for combo completions      â”‚
    â”‚    â†’ "elemental-burst" at 3/3?      â”‚
    â”‚    â†’ No, still need "lightning"     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 4. Fire progress event              â”‚
    â”‚    â†’ ComboProgressedEvent           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. IComboService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IComboService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for tracking and detecting ability combos.
/// </summary>
public interface IComboService
{
    /// <summary>Called when an ability is used, checks for combo progress.</summary>
    /// <param name="user">The combatant using the ability.</param>
    /// <param name="abilityId">The ability used.</param>
    /// <param name="target">The target of the ability.</param>
    /// <returns>Result of combo processing.</returns>
    ComboResult OnAbilityUsed(ICombatant user, string abilityId, ICombatant? target);

    /// <summary>Gets active combo progress for a combatant.</summary>
    /// <param name="combatant">The combatant.</param>
    /// <returns>List of active combo progress.</returns>
    IReadOnlyList<ComboProgress> GetActiveProgress(ICombatant combatant);

    /// <summary>Gets combos available to a combatant based on class.</summary>
    /// <param name="combatant">The combatant.</param>
    /// <returns>Available combo definitions.</returns>
    IReadOnlyList<ComboDefinition> GetAvailableCombos(ICombatant combatant);

    /// <summary>Gets hints for next abilities to complete active combos.</summary>
    /// <param name="combatant">The combatant.</param>
    /// <returns>List of hints for next steps.</returns>
    IReadOnlyList<ComboHint> GetComboHints(ICombatant combatant);

    /// <summary>Called at turn start to expire old combo progress.</summary>
    /// <param name="combatant">The combatant whose turn is starting.</param>
    void TickCombos(ICombatant combatant);

    /// <summary>Resets all combo progress for a combatant.</summary>
    /// <param name="combatant">The combatant.</param>
    void ResetProgress(ICombatant combatant);

    /// <summary>Checks if any combos are in progress for a combatant.</summary>
    /// <param name="combatant">The combatant.</param>
    /// <returns>True if any combos are active.</returns>
    bool HasActiveProgress(ICombatant combatant);

    /// <summary>Gets total completed combos for a combatant in this combat.</summary>
    /// <param name="combatant">The combatant.</param>
    /// <returns>Count of completed combos.</returns>
    int GetCompletedComboCount(ICombatant combatant);
}
```

---

## 5. ComboService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/ComboService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class ComboService : IComboService
{
    private readonly IComboProvider _comboProvider;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IDamageService _damageService;
    private readonly IDiceService _diceService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<ComboService> _logger;

    // Track active combo progress per combatant
    private readonly Dictionary<Guid, List<ComboProgress>> _activeProgress = new();

    // Track completed combos per combatant
    private readonly Dictionary<Guid, int> _completedCombos = new();

    public ComboService(
        IComboProvider comboProvider,
        IBuffDebuffService buffDebuffService,
        IDamageService damageService,
        IDiceService diceService,
        IEventBus eventBus,
        ILogger<ComboService> logger)
    {
        _comboProvider = comboProvider;
        _buffDebuffService = buffDebuffService;
        _damageService = damageService;
        _diceService = diceService;
        _eventBus = eventBus;
        _logger = logger;
    }

    public ComboResult OnAbilityUsed(ICombatant user, string abilityId, ICombatant? target)
    {
        var results = new List<ComboActionResult>();
        var completedCombos = new List<ComboDefinition>();

        // Get or create progress list for user
        if (!_activeProgress.TryGetValue(user.Id, out var progressList))
        {
            progressList = new List<ComboProgress>();
            _activeProgress[user.Id] = progressList;
        }

        // 1. Check if this ability can start any new combos
        var availableCombos = GetAvailableCombos(user);
        foreach (var combo in availableCombos)
        {
            var firstStep = combo.GetStep(1);
            if (firstStep?.AbilityId.Equals(abilityId, StringComparison.OrdinalIgnoreCase) == true)
            {
                // Check if already tracking this combo
                if (!progressList.Any(p => p.ComboId == combo.ComboId))
                {
                    var newProgress = ComboProgress.Start(combo, target?.Id);
                    progressList.Add(newProgress);

                    _logger.LogDebug("{User} started combo {Combo} (step 1/{Total})",
                        user.Name, combo.Name, combo.StepCount);

                    _eventBus.Publish(new ComboStartedEvent(user.Id, combo.ComboId, combo.Name));
                    results.Add(ComboActionResult.Started(combo.ComboId, combo.Name));
                }
            }
        }

        // 2. Check if this advances any active combos
        foreach (var progress in progressList.ToList())
        {
            var combo = _comboProvider.GetCombo(progress.ComboId);
            if (combo is null) continue;

            var nextStep = combo.GetStep(progress.CurrentStep + 1);
            if (nextStep is null) continue;

            // Check if ability matches next step
            bool isSameTarget = target?.Id == progress.LastTargetId;
            bool isSelfTarget = target?.Id == user.Id;

            if (nextStep.Matches(abilityId, isSameTarget, isSelfTarget))
            {
                progress.AdvanceStep(target?.Id);

                _logger.LogDebug("{User} advanced {Combo} to step {Step}/{Total}",
                    user.Name, combo.Name, progress.CurrentStep, combo.StepCount);

                // Check if combo is complete
                if (progress.CurrentStep >= combo.StepCount)
                {
                    completedCombos.Add(combo);
                    ApplyBonusEffects(user, combo, target, progressList);
                    progressList.Remove(progress);

                    // Track completed count
                    _completedCombos.TryGetValue(user.Id, out var count);
                    _completedCombos[user.Id] = count + 1;

                    _logger.LogInformation("{User} completed combo {Combo}!",
                        user.Name, combo.Name);

                    _eventBus.Publish(new ComboCompletedEvent(
                        user.Id, combo.ComboId, combo.Name, combo.BonusEffects.Count));
                    results.Add(ComboActionResult.Completed(combo.ComboId, combo.Name));
                }
                else
                {
                    _eventBus.Publish(new ComboProgressedEvent(
                        user.Id, combo.ComboId, combo.Name, progress.CurrentStep, combo.StepCount));
                    results.Add(ComboActionResult.Progressed(
                        combo.ComboId, combo.Name, progress.CurrentStep, combo.StepCount));
                }
            }
        }

        return new ComboResult(results, completedCombos);
    }

    private void ApplyBonusEffects(
        ICombatant user,
        ComboDefinition combo,
        ICombatant? target,
        List<ComboProgress> progressList)
    {
        foreach (var bonus in combo.BonusEffects)
        {
            var effectTarget = bonus.Target switch
            {
                ComboBonusTarget.Self => user,
                ComboBonusTarget.LastTarget => target,
                _ => target
            };

            if (effectTarget is null && bonus.Target != ComboBonusTarget.Self) continue;

            switch (bonus.EffectType)
            {
                case ComboBonusType.ExtraDamage:
                    var damage = _diceService.Roll(bonus.Value);
                    _damageService.ApplyDamage(effectTarget!,
                        new DamageInstance(damage, bonus.DamageType ?? "physical"));
                    _logger.LogDebug("Combo bonus: {Damage} {Type} damage to {Target}",
                        damage, bonus.DamageType ?? "physical", effectTarget!.Name);
                    break;

                case ComboBonusType.DamageMultiplier:
                    // Applied during the final ability's damage calculation
                    // via a temporary modifier or event handler
                    _logger.LogDebug("Combo bonus: Ã—{Mult} damage modifier applied",
                        bonus.Value);
                    break;

                case ComboBonusType.ApplyStatus:
                    if (bonus.StatusEffectId is not null && effectTarget is not null)
                    {
                        _buffDebuffService.ApplyEffect(effectTarget, bonus.StatusEffectId, user);
                        _logger.LogDebug("Combo bonus: Applied {Status} to {Target}",
                            bonus.StatusEffectId, effectTarget.Name);
                    }
                    break;

                case ComboBonusType.Heal:
                    var heal = _diceService.Roll(bonus.Value);
                    user.Heal(heal);
                    _logger.LogDebug("Combo bonus: Healed {User} for {Amount}",
                        user.Name, heal);
                    break;

                case ComboBonusType.ResetCooldown:
                    user.ResetCooldown(bonus.Value);
                    _logger.LogDebug("Combo bonus: Reset cooldown for {Ability}",
                        bonus.Value);
                    break;

                case ComboBonusType.RefundResource:
                    if (int.TryParse(bonus.Value, out var refund))
                    {
                        user.RestoreResource(refund);
                        _logger.LogDebug("Combo bonus: Refunded {Amount} resource", refund);
                    }
                    break;

                case ComboBonusType.AreaEffect:
                    // Handled by ability system with expanded radius
                    _logger.LogDebug("Combo bonus: Expanded to {Radius} cell radius",
                        bonus.Value);
                    break;
            }
        }
    }

    public void TickCombos(ICombatant combatant)
    {
        if (!_activeProgress.TryGetValue(combatant.Id, out var progressList))
            return;

        foreach (var progress in progressList.ToList())
        {
            progress.DecrementWindow();

            if (progress.WindowRemaining <= 0)
            {
                var combo = _comboProvider.GetCombo(progress.ComboId);
                progressList.Remove(progress);

                _eventBus.Publish(new ComboFailedEvent(
                    combatant.Id, progress.ComboId, combo?.Name ?? progress.ComboId, "Window expired"));

                _logger.LogDebug("{User} combo {Combo} expired",
                    combatant.Name, progress.ComboId);
            }
        }
    }

    public IReadOnlyList<ComboProgress> GetActiveProgress(ICombatant combatant)
    {
        return _activeProgress.TryGetValue(combatant.Id, out var list)
            ? list.ToList()
            : [];
    }

    public IReadOnlyList<ComboDefinition> GetAvailableCombos(ICombatant combatant)
    {
        return _comboProvider.GetCombosForClass(combatant.ClassId);
    }

    public IReadOnlyList<ComboHint> GetComboHints(ICombatant combatant)
    {
        var hints = new List<ComboHint>();

        if (!_activeProgress.TryGetValue(combatant.Id, out var progressList))
            return hints;

        foreach (var progress in progressList)
        {
            var combo = _comboProvider.GetCombo(progress.ComboId);
            if (combo is null) continue;

            var nextStep = combo.GetStep(progress.CurrentStep + 1);
            if (nextStep is not null)
            {
                hints.Add(new ComboHint(
                    combo.ComboId,
                    combo.Name,
                    nextStep.AbilityId,
                    progress.CurrentStep,
                    combo.StepCount,
                    progress.WindowRemaining));
            }
        }

        return hints;
    }

    public void ResetProgress(ICombatant combatant)
    {
        if (_activeProgress.ContainsKey(combatant.Id))
        {
            _activeProgress[combatant.Id].Clear();
        }
    }

    public bool HasActiveProgress(ICombatant combatant)
    {
        return _activeProgress.TryGetValue(combatant.Id, out var list) && list.Any();
    }

    public int GetCompletedComboCount(ICombatant combatant)
    {
        return _completedCombos.TryGetValue(combatant.Id, out var count) ? count : 0;
    }
}
```

---

## 6. ComboProgress Class

**File:** `src/Core/RuneAndRust.Application/Tracking/ComboProgress.cs`

```csharp
namespace RuneAndRust.Application.Tracking;

/// <summary>
/// Tracks progress through a combo for a combatant.
/// </summary>
public class ComboProgress
{
    /// <summary>The combo being tracked.</summary>
    public string ComboId { get; private set; } = null!;

    /// <summary>Current step in the combo (1-indexed).</summary>
    public int CurrentStep { get; private set; }

    /// <summary>Turns remaining before combo expires.</summary>
    public int WindowRemaining { get; private set; }

    /// <summary>ID of the last target hit.</summary>
    public Guid? LastTargetId { get; private set; }

    /// <summary>When the combo was started.</summary>
    public DateTime StartedAt { get; private set; }

    /// <summary>All targets hit during this combo.</summary>
    public IReadOnlyList<Guid> AllTargetsHit { get; private set; } = [];

    private readonly List<Guid> _allTargetsHit = new();

    private ComboProgress() { }

    /// <summary>Creates a new combo progress starting at step 1.</summary>
    public static ComboProgress Start(ComboDefinition combo, Guid? targetId)
    {
        var progress = new ComboProgress
        {
            ComboId = combo.ComboId,
            CurrentStep = 1,
            WindowRemaining = combo.WindowTurns,
            LastTargetId = targetId,
            StartedAt = DateTime.UtcNow
        };

        if (targetId.HasValue)
        {
            progress._allTargetsHit.Add(targetId.Value);
            progress.AllTargetsHit = progress._allTargetsHit;
        }

        return progress;
    }

    /// <summary>Advances to the next step and records the target.</summary>
    public void AdvanceStep(Guid? targetId)
    {
        CurrentStep++;
        LastTargetId = targetId;

        if (targetId.HasValue && !_allTargetsHit.Contains(targetId.Value))
        {
            _allTargetsHit.Add(targetId.Value);
        }
    }

    /// <summary>Decrements the window remaining by 1 turn.</summary>
    public void DecrementWindow()
    {
        WindowRemaining--;
    }

    /// <summary>Gets progress as a fraction string.</summary>
    public string GetProgressString() => $"{CurrentStep}/{WindowRemaining} turns left";

    public override string ToString() => $"{ComboId}: Step {CurrentStep}, {WindowRemaining} turns left";
}
```

---

## 7. Result Types

**File:** `src/Core/RuneAndRust.Application/DTOs/ComboResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of processing an ability for combos.
/// </summary>
public record ComboResult(
    IReadOnlyList<ComboActionResult> Actions,
    IReadOnlyList<ComboDefinition> CompletedCombos)
{
    /// <summary>Whether any combo action occurred.</summary>
    public bool HasActions => Actions.Any();

    /// <summary>Whether any combo was completed.</summary>
    public bool HasCompletions => CompletedCombos.Any();

    /// <summary>Creates an empty result.</summary>
    public static ComboResult None => new([], []);
}
```

**File:** `src/Core/RuneAndRust.Application/DTOs/ComboActionResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of a single combo action.
/// </summary>
public record ComboActionResult(
    ComboActionType ActionType,
    string ComboId,
    string ComboName,
    int? CurrentStep,
    int? TotalSteps)
{
    public static ComboActionResult Started(string comboId, string name)
        => new(ComboActionType.Started, comboId, name, 1, null);

    public static ComboActionResult Progressed(string comboId, string name, int step, int total)
        => new(ComboActionType.Progressed, comboId, name, step, total);

    public static ComboActionResult Completed(string comboId, string name)
        => new(ComboActionType.Completed, comboId, name, null, null);

    public static ComboActionResult Failed(string comboId, string name, string reason)
        => new(ComboActionType.Failed, comboId, name, null, null);
}

/// <summary>
/// Types of combo actions.
/// </summary>
public enum ComboActionType
{
    /// <summary>A new combo was started.</summary>
    Started,

    /// <summary>An active combo progressed to the next step.</summary>
    Progressed,

    /// <summary>A combo was completed successfully.</summary>
    Completed,

    /// <summary>A combo failed (expired or broken).</summary>
    Failed
}
```

**File:** `src/Core/RuneAndRust.Application/DTOs/ComboHint.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// A hint for the next ability to complete an active combo.
/// </summary>
public record ComboHint(
    string ComboId,
    string ComboName,
    string NextAbilityId,
    int CurrentStep,
    int TotalSteps,
    int WindowRemaining)
{
    /// <summary>Gets progress as percentage.</summary>
    public int ProgressPercent => (int)((CurrentStep / (double)TotalSteps) * 100);

    /// <summary>Gets a display string for the hint.</summary>
    public string GetDisplayString()
        => $"{ComboName}: Use {NextAbilityId} ({CurrentStep}/{TotalSteps}) - {WindowRemaining} turns left";
}
```

---

## 8. Combo Events

**File:** `src/Core/RuneAndRust.Application/Events/ComboEvents.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>Published when a combo is started.</summary>
public record ComboStartedEvent(
    Guid CombatantId,
    string ComboId,
    string ComboName);

/// <summary>Published when a combo progresses to the next step.</summary>
public record ComboProgressedEvent(
    Guid CombatantId,
    string ComboId,
    string ComboName,
    int CurrentStep,
    int TotalSteps);

/// <summary>Published when a combo is completed.</summary>
public record ComboCompletedEvent(
    Guid CombatantId,
    string ComboId,
    string ComboName,
    int BonusEffectsApplied);

/// <summary>Published when a combo fails.</summary>
public record ComboFailedEvent(
    Guid CombatantId,
    string ComboId,
    string ComboName,
    string Reason);
```

---

## 9. AbilityService Integration

**Updates to:** `src/Core/RuneAndRust.Application/Services/AbilityService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public partial class AbilityService
{
    private readonly IComboService _comboService;

    /// <summary>Executes an ability and checks for combo progress.</summary>
    public AbilityResult UseAbility(ICombatant user, string abilityId, ICombatant? target)
    {
        // ... existing ability execution logic ...

        // Check for combo progress after ability executes
        var comboResult = _comboService.OnAbilityUsed(user, abilityId, target);

        if (comboResult.HasCompletions)
        {
            foreach (var combo in comboResult.CompletedCombos)
            {
                _logger.LogInformation("{User} completed combo: {Combo}!",
                    user.Name, combo.Name);
            }
        }

        // Include combo info in result
        return abilityResult with { ComboResult = comboResult };
    }
}
```

---

## 10. TurnManager Integration

**Updates to:** `src/Core/RuneAndRust.Application/Services/TurnManager.cs`

```csharp
namespace RuneAndRust.Application.Services;

public partial class TurnManager
{
    private readonly IComboService _comboService;

    /// <summary>Called at the start of a combatant's turn.</summary>
    private void OnTurnStart(ICombatant combatant)
    {
        // Tick combo windows
        _comboService.TickCombos(combatant);

        // ... existing turn start logic ...
    }
}
```

---

## 11. Detection Flow Visualization

```
COMBO DETECTION FLOW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    Player uses "lightning" on "Goblin-1"
                       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         OnAbilityUsed()              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 1. CHECK NEW COMBO STARTS                                       â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚    â”‚ For each available combo:                              â”‚   â”‚
    â”‚    â”‚   - Is "lightning" the first ability?                  â”‚   â”‚
    â”‚    â”‚   - elemental-burst: NO (starts with fire-bolt)        â”‚   â”‚
    â”‚    â”‚   - storm-caller: YES â†’ Start new progress             â”‚   â”‚
    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 2. CHECK ACTIVE COMBO PROGRESS                                  â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚    â”‚ Active: elemental-burst at step 2/3                    â”‚   â”‚
    â”‚    â”‚   - Next step expects "lightning"                      â”‚   â”‚
    â”‚    â”‚   - Ability matches: YES âœ“                             â”‚   â”‚
    â”‚    â”‚   - Target same as last: YES (Goblin-1) âœ“              â”‚   â”‚
    â”‚    â”‚   â†’ Advance to step 3/3                                â”‚   â”‚
    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 3. CHECK COMPLETION                                             â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚    â”‚ elemental-burst: step 3/3                              â”‚   â”‚
    â”‚    â”‚   â†’ COMPLETE! Apply bonus effects:                     â”‚   â”‚
    â”‚    â”‚     - Ã—2.0 damage multiplier                           â”‚   â”‚
    â”‚    â”‚     - Apply "elemental-overload" to Goblin-1           â”‚   â”‚
    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 4. PUBLISH EVENTS & RETURN RESULT                               â”‚
    â”‚    - ComboCompletedEvent(elemental-burst)                       â”‚
    â”‚    - ComboStartedEvent(storm-caller)                            â”‚
    â”‚    - Return ComboResult with actions                            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    UI COMBO HINTS
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  âš¡ COMBO PROGRESS                                               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  ğŸ”¥ Elemental Burst: 2/3                                        â”‚
    â”‚     Next: Use Lightning on same target (2 turns left)           â”‚
    â”‚     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 66%                                            â”‚
    â”‚                                                                 â”‚
    â”‚  âš” Storm Caller: 1/3                                            â”‚
    â”‚     Next: Use Wind Gust (3 turns left)                          â”‚
    â”‚     â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 33%                                            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 12. Unit Testing Requirements (~12 tests)

| Feature | Tests |
|---------|-------|
| OnAbilityUsed starts new combo | 1 |
| OnAbilityUsed advances existing combo | 1 |
| OnAbilityUsed detects completion | 1 |
| SameTarget requirement enforced | 1 |
| DifferentTarget requirement enforced | 1 |
| Self target requirement enforced | 1 |
| TickCombos decrements window | 1 |
| TickCombos expires old progress | 1 |
| ApplyBonusEffects ExtraDamage works | 1 |
| ApplyBonusEffects ApplyStatus works | 1 |
| GetComboHints returns next ability | 1 |
| ResetProgress clears all progress | 1 |

---

## 13. Acceptance Criteria

- [ ] OnAbilityUsed tracks new combo starts
- [ ] Sequence matching detects progress
- [ ] Window timing expires old progress
- [ ] SameTarget requirement enforced
- [ ] DifferentTarget requirement enforced
- [ ] Self target requirement enforced
- [ ] Combo completion detected correctly
- [ ] Bonus effects applied on complete
- [ ] ExtraDamage bonus works
- [ ] ApplyStatus bonus works
- [ ] Heal bonus works
- [ ] ResetCooldown bonus works
- [ ] GetComboHints shows next ability
- [ ] GetActiveProgress returns current progress
- [ ] ComboStartedEvent fires
- [ ] ComboProgressedEvent fires
- [ ] ComboCompletedEvent fires
- [ ] ComboFailedEvent fires on expiry
- [ ] ~12 unit tests pass

---

## 14. Dependencies

| From | Required |
|------|----------|
| v0.10.3a | `IComboProvider`, `ComboDefinition`, `ComboStep`, `ComboBonusEffect` |
| v0.10.0 | `IBuffDebuffService` for status effects |
| Application | `IDamageService`, `IDiceService`, `IEventBus` |

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
