# v0.2.0b Design Specification: Dialogue System

## Overview

**Version:** 0.2.0b
**Status:** Planning
**Focus:** Implement dialogue trees with branching conversations, conditions, skill checks, and outcomes
**Prerequisites:** v0.2.0a (NPC Foundation)
**Estimated Unit Tests:** ~35

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [Data Models](#5-data-models)
6. [Configuration Schemas](#6-configuration-schemas)
7. [Service Specifications](#7-service-specifications)
8. [Dialogue Command Flow](#8-dialogue-command-flow)
9. [User-Facing Changes](#9-user-facing-changes)
10. [Logging Requirements](#10-logging-requirements)
11. [Unit Test Specifications](#11-unit-test-specifications)
12. [Use Cases](#12-use-cases)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Deliverable Checklist](#14-deliverable-checklist)
15. [Dependencies](#15-dependencies)
16. [Future Considerations](#16-future-considerations)

---

## 1. Executive Summary

This version implements the full dialogue tree system, transforming the basic greeting-only NPC interaction from v0.2.0a into rich, branching conversations. Players navigate dialogue trees by selecting options, with conditions determining which options are available. Skill checks allow persuasion attempts, and dialogue outcomes create meaningful consequences for player choices.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Definitions** | DialogueNodeDefinition |
| **Value Objects** | DialogueOption, DialogueCondition, DialogueOutcome, DialogueState, DialogueContext, PersuasionCheck |
| **Enums** | ConditionType, ComparisonOperator, OutcomeType |
| **Services** | DialogueService (IDialogueService) |
| **Configuration** | dialogues.json, dialogues.schema.json |
| **Service Updates** | GameSessionService, NPCService |
| **Tests** | ~35 new unit tests |

### Architectural Significance

This version establishes the **dialogue interaction pattern** that enables:
- Branching narrative driven by player choice
- Condition-based content gating (inventory, stats, flags)
- Skill check integration with existing dice system
- Outcome system for item/gold exchange, flag setting, reputation changes
- Foundation for quest dialogue (v0.3.0) and shop interactions (v0.2.2)

---

## 2. Feature Overview

```
v0.2.0b Features
├── Dialogue Tree Structure
│   ├── DialogueNodeDefinition (config-loaded templates)
│   ├── DialogueOption (player choices with targets)
│   ├── DialogueCondition (availability rules)
│   └── DialogueOutcome (consequences)
├── Condition System
│   ├── ConditionType enum (HasItem, HasGold, etc.)
│   ├── ComparisonOperator enum (Equal, GreaterThan, etc.)
│   ├── Condition evaluation engine
│   └── DialogueContext for evaluation
├── Persuasion System
│   ├── PersuasionCheck value object
│   ├── Integration with DiceService
│   ├── Success/failure branching
│   └── Critical failure handling
├── Outcome System
│   ├── OutcomeType enum (GiveItem, SetFlag, etc.)
│   ├── Outcome application engine
│   └── Deferred outcomes (reputation, quests)
├── Dialogue State
│   ├── DialogueState tracking per conversation
│   ├── Current node tracking
│   ├── Choice history
│   └── One-time option tracking
└── Service Layer
    ├── DialogueService (tree navigation)
    ├── IDialogueService interface
    ├── Integration with NPCService
    └── GameSessionService updates
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         PRESENTATION LAYER                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌────────────────┐  │
│  │   InputHandler      │  │   DialogueView      │  │ IGameRenderer  │  │
│  │   (updated)         │  │   (new)             │  │ (updated)      │  │
│  │                     │  │                     │  │                │  │
│  │ - ParseDialogueCmd()│  │ - ShowDialogueNode()│  │ - RenderNode() │  │
│  │ - GetOptionChoice() │  │ - ShowOptions()     │  │ - RenderCheck()│  │
│  └─────────┬───────────┘  └─────────┬───────────┘  └───────┬────────┘  │
│            │                        │                      │           │
└────────────┼────────────────────────┼──────────────────────┼───────────┘
             │                        │                      │
             ▼                        ▼                      ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION LAYER                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      DialogueService                             │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + StartDialogue(npc, player) : DialogueResult                   │   │
│  │ + GetCurrentNode(stateId) : DialogueNodeDefinition?             │   │
│  │ + GetAvailableOptions(stateId, context) : IReadOnlyList<...>    │   │
│  │ + SelectOption(stateId, optionIndex) : DialogueResult           │   │
│  │ + AttemptPersuasion(stateId, optionIndex) : PersuasionResult    │   │
│  │ + EndDialogue(stateId) : void                                   │   │
│  │ + ApplyOutcomes(outcomes, player, npc) : void                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    GameSessionService (updated)                  │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + TryTalk(npcName?) : TalkResult        // from v0.2.0a         │   │
│  │ + SelectDialogueOption(index) : DialogueResult        // NEW    │   │
│  │ + AttemptDialoguePersuasion(index) : PersuasionResult // NEW    │   │
│  │ + EndCurrentDialogue() : void                         // NEW    │   │
│  │ + GetDialogueState() : DialogueState?                 // NEW    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    NPCService (from v0.2.0a)                     │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + TryTalkToNPC(...) : TalkResult                                │   │
│  │ + GetNPCsInRoom(...) : IReadOnlyList<NPC>                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           DOMAIN LAYER                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  DEFINITIONS                                                            │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │               DialogueNodeDefinition                            │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + Id: string                                                    │    │
│  │ + Speaker: string                                               │    │
│  │ + Text: string                                                  │    │
│  │ + Options: IReadOnlyList<DialogueOption>                        │    │
│  │ + IsTerminal: bool                                              │    │
│  │ + OnEnterOutcomes: IReadOnlyList<DialogueOutcome>               │    │
│  │ + Tags: IReadOnlyList<string>                                   │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  VALUE OBJECTS                                                          │
│  ┌──────────────────────┐  ┌──────────────────────┐                    │
│  │   DialogueOption     │  │  DialogueCondition   │                    │
│  ├──────────────────────┤  ├──────────────────────┤                    │
│  │ + Text: string       │  │ + Type: ConditionType│                    │
│  │ + TargetNodeId: str  │  │ + TargetId: string   │                    │
│  │ + Conditions: [...]  │  │ + Operator: ...      │                    │
│  │ + Outcomes: [...]    │  │ + Value: int         │                    │
│  │ + SkillCheck: ...?   │  │ + Negate: bool       │                    │
│  │ + OneTimeOnly: bool  │  │ + Evaluate(...): bool│                    │
│  │ + OptionId: string?  │  └──────────────────────┘                    │
│  │ + IsAvailable(...):  │                                              │
│  └──────────────────────┘  ┌──────────────────────┐                    │
│                            │  DialogueOutcome     │                    │
│  ┌──────────────────────┐  ├──────────────────────┤                    │
│  │   PersuasionCheck    │  │ + Type: OutcomeType  │                    │
│  ├──────────────────────┤  │ + TargetId: string   │                    │
│  │ + SkillId: string    │  │ + Value: int         │                    │
│  │ + DC: int            │  │ + Data: string?      │                    │
│  │ + FailureNodeId: str │  └──────────────────────┘                    │
│  │ + CritFailNodeId: s? │                                              │
│  └──────────────────────┘  ┌──────────────────────┐                    │
│                            │   DialogueState      │                    │
│  ┌──────────────────────┐  ├──────────────────────┤                    │
│  │   DialogueContext    │  │ + Id: Guid           │                    │
│  ├──────────────────────┤  │ + PlayerId: Guid     │                    │
│  │ + Player: Player     │  │ + NPCId: Guid        │                    │
│  │ + NPC: NPC           │  │ + CurrentNodeId: str │                    │
│  │ + DialogueFlags: ... │  │ + ChoicesMade: [str] │                    │
│  │ + HasItem(...)       │  │ + UsedOneTimeOpts:[] │                    │
│  │ + GetStat(...)       │  │ + IsActive: bool     │                    │
│  │ + HasFlag(...)       │  │ + StartedAt: DateTime│                    │
│  └──────────────────────┘  └──────────────────────┘                    │
│                                                                         │
│  ENUMS                                                                  │
│  ┌──────────────────────┐  ┌──────────────────────┐                    │
│  │    ConditionType     │  │ ComparisonOperator   │                    │
│  ├──────────────────────┤  ├──────────────────────┤                    │
│  │ HasItem              │  │ Equal                │                    │
│  │ HasGold              │  │ NotEqual             │                    │
│  │ PlayerLevel          │  │ GreaterThan          │                    │
│  │ StatCheck            │  │ LessThan             │                    │
│  │ FlagSet              │  │ GreaterOrEqual       │                    │
│  │ QuestState           │  │ LessOrEqual          │                    │
│  │ AttitudeAtLeast      │  └──────────────────────┘                    │
│  │ ReputationAtLeast    │                                              │
│  │ PreviousChoice       │  ┌──────────────────────┐                    │
│  └──────────────────────┘  │    OutcomeType       │                    │
│                            ├──────────────────────┤                    │
│  FROM v0.2.0a:             │ GiveItem             │                    │
│  ┌──────────────────────┐  │ TakeItem             │                    │
│  │         NPC          │  │ GiveGold             │                    │
│  │   (with dialogue)    │  │ TakeGold             │                    │
│  │ + RootDialogueId     │  │ SetFlag              │                    │
│  └──────────────────────┘  │ ClearFlag            │                    │
│                            │ ChangeAttitude       │                    │
│                            │ ChangeReputation     │                    │
│                            │ StartQuest           │                    │
│                            │ AdvanceQuest         │                    │
│                            │ UnlockDialogue       │                    │
│                            │ RecruitCompanion     │                    │
│                            │ TriggerCombat        │                    │
│                            └──────────────────────┘                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        INFRASTRUCTURE LAYER                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                IConfigurationProvider (updated)                  │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + LoadDialogueNodes() : IReadOnlyDictionary<string, ...>        │   │
│  │ + GetDialogueNode(string id) : DialogueNodeDefinition?          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Configuration Files:                                                   │
│  ├── config/dialogues.json                                             │
│  └── config/schemas/dialogues.schema.json                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Dialogue Navigation Flow

```
┌───────────────────┐
│  TalkResult from  │
│     v0.2.0a       │
│ (NPC.RootDialogue │
│   Id is set)      │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ DialogueService.  │
│ StartDialogue()   │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│  Create Dialogue  │
│  State for this   │
│  conversation     │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│  Load root node   │
│  from config      │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐      ┌───────────────────┐
│  Apply OnEnter    │─────▶│  Execute outcomes │
│  Outcomes         │      │  (flags, items)   │
└─────────┬─────────┘      └───────────────────┘
          │
          ▼
┌───────────────────┐
│  Build Dialogue   │
│  Context          │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ Evaluate Option   │
│ Conditions        │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│  Return Dialogue  │
│  Result with      │
│  available opts   │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│  DISPLAY NODE     │
│  + OPTIONS        │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│  Player selects   │
│  option (1-N)     │
└─────────┬─────────┘
          │
          ▼
┌───────────────────────────────────────────────────────────────┐
│                      OPTION PROCESSING                         │
├───────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐                                           │
│  │ Has SkillCheck? │                                           │
│  └────────┬────────┘                                           │
│           │                                                     │
│     ┌─────┴─────┐                                              │
│     │           │                                               │
│     ▼           ▼                                               │
│   YES          NO                                               │
│     │           │                                               │
│     ▼           │                                               │
│  ┌──────────────────┐                                          │
│  │ Roll Dice Check  │                                          │
│  │ via DiceService  │                                          │
│  └────────┬─────────┘                                          │
│           │                                                     │
│     ┌─────┴─────┐                                              │
│     │           │                                               │
│     ▼           ▼                                               │
│  SUCCESS     FAILURE                                            │
│     │           │                                               │
│     ▼           ▼                                               │
│  Target      Failure                                            │
│  NodeId      NodeId                                             │
│     │           │                                               │
│     └─────┬─────┘                                              │
│           │                                                     │
│           ▼                                                     │
│  ┌──────────────────┐                                          │
│  │ Record choice in │                                          │
│  │ DialogueState    │                                          │
│  └────────┬─────────┘                                          │
│           │                                                     │
│           ▼                                                     │
│  ┌──────────────────┐                                          │
│  │ Apply Option     │                                          │
│  │ Outcomes         │                                          │
│  └────────┬─────────┘                                          │
│           │                                                     │
│           ▼                                                     │
│  ┌──────────────────┐                                          │
│  │ Navigate to      │                                          │
│  │ target node      │                                          │
│  └────────┬─────────┘                                          │
│           │                                                     │
└───────────┼─────────────────────────────────────────────────────┘
            │
            ▼
┌───────────────────┐      ┌───────────────────┐
│  Is Terminal      │──YES▶│  End Dialogue     │
│  Node?            │      │  Return control   │
└─────────┬─────────┘      └───────────────────┘
          │
         NO
          │
          ▼
    (Loop back to
     Display Node)
```

### 3.3 Condition Evaluation Flow

```
┌───────────────────────────────────────────────────────────────────────┐
│                    DialogueContext                                     │
├───────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐           │
│  │     Player     │  │      NPC       │  │  DialogueFlags │           │
│  ├────────────────┤  ├────────────────┤  ├────────────────┤           │
│  │ Inventory      │  │ Attitude       │  │ global-flag-1  │           │
│  │ Gold           │  │ FactionId      │  │ quest-started  │           │
│  │ Level          │  │ Memory         │  │ seen-secret    │           │
│  │ Stats          │  │                │  │ ...            │           │
│  └────────────────┘  └────────────────┘  └────────────────┘           │
│                                                                        │
└───────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌───────────────────────────────────────────────────────────────────────┐
│                    DialogueCondition Evaluation                        │
├───────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  Condition: { Type: HasItem, TargetId: "iron-key", Value: 1 }         │
│                                                                        │
│  1. Switch on ConditionType                                            │
│     ┌───────────────────────────────────────────────────────────────┐ │
│     │ HasItem       → context.HasItem("iron-key", 1)                │ │
│     │ HasGold       → Compare(context.Gold, Value)                  │ │
│     │ PlayerLevel   → Compare(context.PlayerLevel, Value)           │ │
│     │ StatCheck     → Compare(context.GetStat(TargetId), Value)     │ │
│     │ FlagSet       → context.HasFlag(TargetId)                     │ │
│     │ QuestState    → context.GetQuestState(TargetId) == Value      │ │
│     │ AttitudeAtLeast → (int)context.NPCAttitude >= Value           │ │
│     │ ReputationAtLeast → Compare(context.GetReputation(...), Value)│ │
│     │ PreviousChoice → context.MadeChoice(TargetId)                 │ │
│     └───────────────────────────────────────────────────────────────┘ │
│                                                                        │
│  2. Apply ComparisonOperator (for numeric conditions)                  │
│     ┌───────────────────────────────────────────────────────────────┐ │
│     │ Equal         → actual == expected                            │ │
│     │ NotEqual      → actual != expected                            │ │
│     │ GreaterThan   → actual > expected                             │ │
│     │ LessThan      → actual < expected                             │ │
│     │ GreaterOrEqual→ actual >= expected                            │ │
│     │ LessOrEqual   → actual <= expected                            │ │
│     └───────────────────────────────────────────────────────────────┘ │
│                                                                        │
│  3. Apply Negate flag                                                  │
│     result = Negate ? !result : result                                 │
│                                                                        │
│  4. Return final bool                                                  │
│                                                                        │
└───────────────────────────────────────────────────────────────────────┘
```

---

## 4. User Stories

### US-2.0b-1: Navigate Dialogue Tree
**As a** player talking to an NPC
**I want to** select from multiple dialogue options
**So that** I can guide the conversation toward my goals

**Acceptance Criteria:**
- Options are numbered for easy selection
- Selecting an option navigates to the target node
- New node text and options are displayed
- Terminal nodes end the conversation

### US-2.0b-2: Conditional Dialogue Options
**As a** player with specific items or stats
**I want to** see dialogue options that reflect my capabilities
**So that** my choices and progression are meaningful

**Acceptance Criteria:**
- Options with unmet conditions are hidden
- Conditions can check inventory, gold, level, stats, flags
- Multiple conditions on one option are ANDed together
- Negated conditions work correctly

### US-2.0b-3: Persuasion Skill Checks
**As a** player attempting to convince an NPC
**I want to** make skill checks during dialogue
**So that** my character's abilities affect conversations

**Acceptance Criteria:**
- Persuasion options show skill and DC
- Rolling uses existing dice system
- Success navigates to target node
- Failure navigates to failure node
- Critical failure navigates to critical failure node (if defined)

### US-2.0b-4: Dialogue Consequences
**As a** player making dialogue choices
**I want to** choices have consequences
**So that** conversations feel meaningful

**Acceptance Criteria:**
- Outcomes can give/take items
- Outcomes can give/take gold
- Outcomes can set/clear flags
- Outcomes can change NPC attitude
- Multiple outcomes per option work correctly

### US-2.0b-5: One-Time Dialogue Options
**As a** player revisiting an NPC
**I want to** not see options I've already selected (when marked one-time)
**So that** conversations don't repeat unnaturally

**Acceptance Criteria:**
- One-time options disappear after selection
- State persists for the NPC-player pair
- Non-one-time options remain available

### US-2.0b-6: Configure Dialogues via JSON
**As a** game designer
**I want to** define dialogue trees in configuration files
**So that** I can create conversations without code changes

**Acceptance Criteria:**
- Dialogues defined in dialogues.json
- Schema validation catches errors
- All node properties are configurable
- References between nodes are validated

---

## 5. Data Models

### 5.1 DialogueNodeDefinition

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration template for a dialogue tree node.
/// </summary>
/// <remarks>
/// DialogueNodeDefinitions are loaded from JSON configuration and define
/// the structure of conversations. Each node contains NPC text and
/// player response options that lead to other nodes.
/// </remarks>
public class DialogueNodeDefinition
{
    /// <summary>
    /// Gets the unique identifier for this node.
    /// </summary>
    /// <example>"grimbold-main", "grimbold-shop", "grimbold-farewell"</example>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the speaker name for this node.
    /// </summary>
    /// <remarks>
    /// Usually the NPC's name, but can vary for narration or other speakers.
    /// Empty string indicates narration.
    /// </remarks>
    /// <example>"Grimbold", "Elara", ""</example>
    public string Speaker { get; init; } = string.Empty;

    /// <summary>
    /// Gets the dialogue text displayed at this node.
    /// </summary>
    /// <remarks>
    /// The NPC's spoken dialogue or narration text. Supports simple
    /// variable substitution for player name: {PlayerName}.
    /// </remarks>
    public string Text { get; init; } = string.Empty;

    /// <summary>
    /// Gets the available dialogue options from this node.
    /// </summary>
    /// <remarks>
    /// Empty list or null indicates a terminal node that ends dialogue.
    /// Options are filtered at runtime based on conditions.
    /// </remarks>
    public IReadOnlyList<DialogueOption> Options { get; init; } = [];

    /// <summary>
    /// Gets whether this is a terminal node that ends dialogue.
    /// </summary>
    /// <remarks>
    /// True if Options is empty or this is explicitly marked terminal.
    /// </remarks>
    public bool IsTerminal { get; init; }

    /// <summary>
    /// Gets outcomes triggered when entering this node.
    /// </summary>
    /// <remarks>
    /// Applied before displaying the node, regardless of how the
    /// player arrived. Used for rewards, flag setting, etc.
    /// </remarks>
    public IReadOnlyList<DialogueOutcome> OnEnterOutcomes { get; init; } = [];

    /// <summary>
    /// Gets tags for categorization and searching.
    /// </summary>
    /// <remarks>
    /// Used for filtering, analytics, and future dialogue triggers.
    /// </remarks>
    /// <example>["shop", "quest", "lore", "greeting"]</example>
    public IReadOnlyList<string> Tags { get; init; } = [];

    /// <summary>
    /// Private constructor for deserialization.
    /// </summary>
    private DialogueNodeDefinition() { }

    /// <summary>
    /// Creates a dialogue node definition from configuration.
    /// </summary>
    /// <param name="id">Unique identifier.</param>
    /// <param name="speaker">Speaker name.</param>
    /// <param name="text">Dialogue text.</param>
    /// <param name="options">Available options (optional).</param>
    /// <param name="isTerminal">Whether this ends dialogue (optional).</param>
    /// <param name="onEnterOutcomes">Entry outcomes (optional).</param>
    /// <param name="tags">Categorization tags (optional).</param>
    /// <returns>A new DialogueNodeDefinition instance.</returns>
    /// <exception cref="ArgumentException">Thrown if id or text is null/empty.</exception>
    public static DialogueNodeDefinition Create(
        string id,
        string speaker,
        string text,
        IEnumerable<DialogueOption>? options = null,
        bool? isTerminal = null,
        IEnumerable<DialogueOutcome>? onEnterOutcomes = null,
        IEnumerable<string>? tags = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(text);

        var optionsList = options?.ToList() ?? [];

        return new DialogueNodeDefinition
        {
            Id = id.ToLowerInvariant(),
            Speaker = speaker ?? string.Empty,
            Text = text,
            Options = optionsList,
            IsTerminal = isTerminal ?? optionsList.Count == 0,
            OnEnterOutcomes = onEnterOutcomes?.ToList() ?? [],
            Tags = tags?.Select(t => t.ToLowerInvariant()).ToList() ?? []
        };
    }

    /// <summary>
    /// Gets options available given current dialogue context.
    /// </summary>
    /// <param name="context">The dialogue context for condition evaluation.</param>
    /// <param name="usedOneTimeOptions">Option IDs already used.</param>
    /// <returns>Filtered list of available options.</returns>
    public IReadOnlyList<DialogueOption> GetAvailableOptions(
        DialogueContext context,
        IReadOnlySet<string> usedOneTimeOptions)
    {
        return Options
            .Where(o => o.IsAvailable(context))
            .Where(o => !o.OneTimeOnly ||
                        string.IsNullOrEmpty(o.OptionId) ||
                        !usedOneTimeOptions.Contains(o.OptionId))
            .ToList();
    }

    /// <summary>
    /// Substitutes variables in text.
    /// </summary>
    /// <param name="context">Context with variable values.</param>
    /// <returns>Text with substitutions applied.</returns>
    public string GetDisplayText(DialogueContext context)
    {
        return Text
            .Replace("{PlayerName}", context.Player.Name)
            .Replace("{NPCName}", context.NPC.Name);
    }
}
```

### 5.2 DialogueOption Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a player choice in dialogue.
/// </summary>
/// <remarks>
/// DialogueOptions are the branching points in dialogue trees. Each option
/// can have conditions that determine visibility, outcomes that trigger
/// when selected, and optional skill checks for persuasion attempts.
/// </remarks>
public readonly record struct DialogueOption
{
    /// <summary>
    /// Gets the optional unique identifier for this option.
    /// </summary>
    /// <remarks>
    /// Used for tracking one-time options and previous choice conditions.
    /// If null, the option cannot be referenced or tracked as one-time.
    /// </remarks>
    public string? OptionId { get; init; }

    /// <summary>
    /// Gets the display text for this option.
    /// </summary>
    /// <remarks>
    /// What the player sees. May include skill check notation like
    /// "[Persuade DC 12]" for options with skill checks.
    /// </remarks>
    /// <example>"What items do you have for sale?"</example>
    /// <example>"[Persuade DC 12] I'm sure we can come to an arrangement."</example>
    public string Text { get; init; }

    /// <summary>
    /// Gets the target node ID if this option is selected successfully.
    /// </summary>
    /// <remarks>
    /// For options with skill checks, this is the success target.
    /// The failure target is specified in the SkillCheck.
    /// </remarks>
    public string TargetNodeId { get; init; }

    /// <summary>
    /// Gets conditions required to show this option.
    /// </summary>
    /// <remarks>
    /// All conditions must be met (AND logic). Empty list means always available.
    /// </remarks>
    public IReadOnlyList<DialogueCondition> Conditions { get; init; }

    /// <summary>
    /// Gets outcomes triggered when selecting this option.
    /// </summary>
    /// <remarks>
    /// Applied after the option is selected but before navigation.
    /// For skill check options, only applied on success.
    /// </remarks>
    public IReadOnlyList<DialogueOutcome> Outcomes { get; init; }

    /// <summary>
    /// Gets the skill check required for this option, if any.
    /// </summary>
    /// <remarks>
    /// Null means no skill check. When present, the player must
    /// pass the check to proceed to TargetNodeId.
    /// </remarks>
    public PersuasionCheck? SkillCheck { get; init; }

    /// <summary>
    /// Gets whether this option can only be selected once.
    /// </summary>
    /// <remarks>
    /// Requires OptionId to be set. Once selected, the option
    /// will not appear in future conversations with this NPC.
    /// </remarks>
    public bool OneTimeOnly { get; init; }

    /// <summary>
    /// Checks if this option is available in the given context.
    /// </summary>
    /// <param name="context">The dialogue context for evaluation.</param>
    /// <returns>True if all conditions are met.</returns>
    public bool IsAvailable(DialogueContext context)
    {
        if (Conditions.Count == 0) return true;
        return Conditions.All(c => c.Evaluate(context));
    }

    /// <summary>
    /// Gets the display text with skill check notation.
    /// </summary>
    /// <returns>Text with skill check info if applicable.</returns>
    public string GetDisplayText()
    {
        if (SkillCheck is null) return Text;

        // Text should already include the notation, but verify
        if (Text.Contains("[") && Text.Contains("DC")) return Text;

        return $"[{SkillCheck.Value.SkillId} DC {SkillCheck.Value.DC}] {Text}";
    }
}
```

### 5.3 DialogueCondition Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a condition for dialogue option availability.
/// </summary>
/// <remarks>
/// Conditions are evaluated against DialogueContext to determine
/// if a dialogue option should be shown. Multiple conditions on
/// an option are ANDed together.
/// </remarks>
public readonly record struct DialogueCondition
{
    /// <summary>
    /// Gets the condition type.
    /// </summary>
    public ConditionType Type { get; init; }

    /// <summary>
    /// Gets the target identifier for the condition.
    /// </summary>
    /// <remarks>
    /// Interpretation depends on Type:
    /// - HasItem: Item definition ID
    /// - StatCheck: Stat name (attack, defense, etc.)
    /// - FlagSet: Flag name
    /// - QuestState: Quest ID
    /// - ReputationAtLeast: Faction ID
    /// - PreviousChoice: Option ID
    /// </remarks>
    public string TargetId { get; init; }

    /// <summary>
    /// Gets the comparison operator for numeric conditions.
    /// </summary>
    /// <remarks>
    /// Used by HasGold, PlayerLevel, StatCheck, QuestState,
    /// AttitudeAtLeast, ReputationAtLeast.
    /// </remarks>
    public ComparisonOperator Operator { get; init; }

    /// <summary>
    /// Gets the value to compare against.
    /// </summary>
    /// <remarks>
    /// Interpretation depends on Type:
    /// - HasItem: Minimum quantity
    /// - HasGold: Minimum gold
    /// - PlayerLevel: Level threshold
    /// - StatCheck: Stat value
    /// - QuestState: State value
    /// - AttitudeAtLeast: NPCAttitude int value
    /// - ReputationAtLeast: Reputation points
    /// </remarks>
    public int Value { get; init; }

    /// <summary>
    /// Gets whether to negate the result.
    /// </summary>
    /// <remarks>
    /// True inverts the condition. For example, Negate + HasItem
    /// becomes "does NOT have item".
    /// </remarks>
    public bool Negate { get; init; }

    /// <summary>
    /// Evaluates the condition against the given context.
    /// </summary>
    /// <param name="context">The dialogue context.</param>
    /// <returns>True if the condition is met.</returns>
    public bool Evaluate(DialogueContext context)
    {
        var result = Type switch
        {
            ConditionType.HasItem => context.HasItem(TargetId, Value),
            ConditionType.HasGold => Compare(context.Gold, Value),
            ConditionType.PlayerLevel => Compare(context.PlayerLevel, Value),
            ConditionType.StatCheck => Compare(context.GetStat(TargetId), Value),
            ConditionType.FlagSet => context.HasFlag(TargetId),
            ConditionType.QuestState => context.GetQuestState(TargetId) == Value,
            ConditionType.AttitudeAtLeast => (int)context.NPCAttitude >= Value,
            ConditionType.ReputationAtLeast => Compare(context.GetReputation(TargetId), Value),
            ConditionType.PreviousChoice => context.MadeChoice(TargetId),
            _ => false
        };

        return Negate ? !result : result;
    }

    /// <summary>
    /// Compares two values using the configured operator.
    /// </summary>
    private bool Compare(int actual, int expected)
    {
        return Operator switch
        {
            ComparisonOperator.Equal => actual == expected,
            ComparisonOperator.NotEqual => actual != expected,
            ComparisonOperator.GreaterThan => actual > expected,
            ComparisonOperator.LessThan => actual < expected,
            ComparisonOperator.GreaterOrEqual => actual >= expected,
            ComparisonOperator.LessOrEqual => actual <= expected,
            _ => false
        };
    }
}
```

### 5.4 ConditionType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of conditions for dialogue branching.
/// </summary>
/// <remarks>
/// Each condition type determines how TargetId and Value are interpreted
/// during evaluation against DialogueContext.
/// </remarks>
public enum ConditionType
{
    /// <summary>
    /// Player has item in inventory.
    /// </summary>
    /// <remarks>
    /// TargetId = item definition ID, Value = minimum quantity.
    /// </remarks>
    HasItem,

    /// <summary>
    /// Player has minimum gold.
    /// </summary>
    /// <remarks>
    /// TargetId unused, Value = minimum gold amount.
    /// Uses Operator for comparison.
    /// </remarks>
    HasGold,

    /// <summary>
    /// Player level check.
    /// </summary>
    /// <remarks>
    /// TargetId unused, Value = level threshold.
    /// Uses Operator for comparison.
    /// </remarks>
    PlayerLevel,

    /// <summary>
    /// Player stat value check.
    /// </summary>
    /// <remarks>
    /// TargetId = stat name (attack, defense, etc.), Value = threshold.
    /// Uses Operator for comparison.
    /// </remarks>
    StatCheck,

    /// <summary>
    /// Global dialogue flag is set.
    /// </summary>
    /// <remarks>
    /// TargetId = flag name, Value unused.
    /// Returns true if flag exists and is true.
    /// </remarks>
    FlagSet,

    /// <summary>
    /// Quest is in specific state.
    /// </summary>
    /// <remarks>
    /// TargetId = quest ID, Value = state value.
    /// State 0 typically means not started.
    /// </remarks>
    QuestState,

    /// <summary>
    /// NPC attitude is at least specified level.
    /// </summary>
    /// <remarks>
    /// TargetId unused, Value = NPCAttitude enum integer.
    /// (0=Friendly, 1=Neutral, 2=Wary, 3=Hostile)
    /// </remarks>
    AttitudeAtLeast,

    /// <summary>
    /// Faction reputation is at least specified value.
    /// </summary>
    /// <remarks>
    /// TargetId = faction ID, Value = reputation points.
    /// Uses Operator for comparison. Deferred to v0.2.0c.
    /// </remarks>
    ReputationAtLeast,

    /// <summary>
    /// Player made a previous dialogue choice.
    /// </summary>
    /// <remarks>
    /// TargetId = option ID from previous selection.
    /// Value unused. Returns true if choice was made.
    /// </remarks>
    PreviousChoice
}
```

### 5.5 ComparisonOperator Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Comparison operators for numeric dialogue conditions.
/// </summary>
public enum ComparisonOperator
{
    /// <summary>Value equals expected.</summary>
    Equal,

    /// <summary>Value does not equal expected.</summary>
    NotEqual,

    /// <summary>Value is greater than expected.</summary>
    GreaterThan,

    /// <summary>Value is less than expected.</summary>
    LessThan,

    /// <summary>Value is greater than or equal to expected.</summary>
    GreaterOrEqual,

    /// <summary>Value is less than or equal to expected.</summary>
    LessOrEqual
}
```

### 5.6 DialogueOutcome Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a consequence of a dialogue choice or node entry.
/// </summary>
/// <remarks>
/// Outcomes modify game state as a result of dialogue. They can
/// give/take items, modify gold, set flags, change attitudes, and more.
/// Some outcome types are deferred to future versions.
/// </remarks>
public readonly record struct DialogueOutcome
{
    /// <summary>
    /// Gets the outcome type.
    /// </summary>
    public OutcomeType Type { get; init; }

    /// <summary>
    /// Gets the target identifier for the outcome.
    /// </summary>
    /// <remarks>
    /// Interpretation depends on Type:
    /// - GiveItem/TakeItem: Item definition ID
    /// - SetFlag/ClearFlag: Flag name
    /// - ChangeReputation: Faction ID
    /// - StartQuest/AdvanceQuest: Quest ID
    /// - UnlockDialogue: Dialogue node ID
    /// - RecruitCompanion: NPC definition ID
    /// </remarks>
    public string TargetId { get; init; }

    /// <summary>
    /// Gets the numeric value for the outcome.
    /// </summary>
    /// <remarks>
    /// Interpretation depends on Type:
    /// - GiveItem/TakeItem: Quantity
    /// - GiveGold/TakeGold: Amount
    /// - ChangeAttitude: Attitude delta
    /// - ChangeReputation: Reputation delta
    /// - AdvanceQuest: New state value
    /// </remarks>
    public int Value { get; init; }

    /// <summary>
    /// Gets additional data for complex outcomes.
    /// </summary>
    /// <remarks>
    /// Used for:
    /// - TriggerCombat: Monster IDs (comma-separated)
    /// - Custom outcome data
    /// </remarks>
    public string? Data { get; init; }

    /// <summary>
    /// Checks if this outcome type is implemented in v0.2.0b.
    /// </summary>
    /// <returns>True if the outcome can be applied.</returns>
    public bool IsImplemented()
    {
        return Type switch
        {
            OutcomeType.GiveItem => true,
            OutcomeType.TakeItem => true,
            OutcomeType.GiveGold => true,
            OutcomeType.TakeGold => true,
            OutcomeType.SetFlag => true,
            OutcomeType.ClearFlag => true,
            OutcomeType.ChangeAttitude => true,
            // Deferred outcomes
            OutcomeType.ChangeReputation => false,  // v0.2.0c
            OutcomeType.StartQuest => false,        // v0.3.0
            OutcomeType.AdvanceQuest => false,      // v0.3.0
            OutcomeType.UnlockDialogue => true,
            OutcomeType.RecruitCompanion => false,  // v0.2.0d
            OutcomeType.TriggerCombat => true,
            _ => false
        };
    }
}
```

### 5.7 OutcomeType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of dialogue outcomes.
/// </summary>
/// <remarks>
/// Some outcome types are defined but implementation is deferred
/// to future versions. Check DialogueOutcome.IsImplemented().
/// </remarks>
public enum OutcomeType
{
    /// <summary>
    /// Give item to player.
    /// </summary>
    /// <remarks>TargetId = item ID, Value = quantity.</remarks>
    GiveItem,

    /// <summary>
    /// Take item from player.
    /// </summary>
    /// <remarks>TargetId = item ID, Value = quantity.</remarks>
    TakeItem,

    /// <summary>
    /// Give gold to player.
    /// </summary>
    /// <remarks>TargetId unused, Value = amount.</remarks>
    GiveGold,

    /// <summary>
    /// Take gold from player.
    /// </summary>
    /// <remarks>TargetId unused, Value = amount.</remarks>
    TakeGold,

    /// <summary>
    /// Set a global dialogue flag.
    /// </summary>
    /// <remarks>TargetId = flag name, Value unused.</remarks>
    SetFlag,

    /// <summary>
    /// Clear a global dialogue flag.
    /// </summary>
    /// <remarks>TargetId = flag name, Value unused.</remarks>
    ClearFlag,

    /// <summary>
    /// Change NPC attitude toward player.
    /// </summary>
    /// <remarks>
    /// TargetId unused (applies to current NPC), Value = delta.
    /// Positive values make more friendly, negative more hostile.
    /// </remarks>
    ChangeAttitude,

    /// <summary>
    /// Change faction reputation.
    /// </summary>
    /// <remarks>
    /// TargetId = faction ID, Value = delta.
    /// Deferred to v0.2.0c.
    /// </remarks>
    ChangeReputation,

    /// <summary>
    /// Start a quest.
    /// </summary>
    /// <remarks>
    /// TargetId = quest ID, Value unused.
    /// Deferred to v0.3.0.
    /// </remarks>
    StartQuest,

    /// <summary>
    /// Advance quest to new state.
    /// </summary>
    /// <remarks>
    /// TargetId = quest ID, Value = new state.
    /// Deferred to v0.3.0.
    /// </remarks>
    AdvanceQuest,

    /// <summary>
    /// Unlock a dialogue node for future conversations.
    /// </summary>
    /// <remarks>
    /// TargetId = dialogue node ID, Value unused.
    /// Makes node reachable via conditions.
    /// </remarks>
    UnlockDialogue,

    /// <summary>
    /// Recruit NPC as companion.
    /// </summary>
    /// <remarks>
    /// TargetId = NPC definition ID, Value unused.
    /// Deferred to v0.2.0d.
    /// </remarks>
    RecruitCompanion,

    /// <summary>
    /// Trigger combat encounter.
    /// </summary>
    /// <remarks>
    /// TargetId unused, Data = monster IDs (comma-separated).
    /// Ends dialogue and starts combat.
    /// </remarks>
    TriggerCombat
}
```

### 5.8 PersuasionCheck Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a skill check required for a dialogue option.
/// </summary>
/// <remarks>
/// Persuasion checks integrate with the existing dice system.
/// On failure, the dialogue navigates to an alternate node.
/// </remarks>
public readonly record struct PersuasionCheck
{
    /// <summary>
    /// Gets the skill ID to check.
    /// </summary>
    /// <remarks>
    /// Must match a SkillDefinition ID from configuration.
    /// Common values: "persuasion", "intimidation", "deception".
    /// </remarks>
    public string SkillId { get; init; }

    /// <summary>
    /// Gets the difficulty class.
    /// </summary>
    /// <remarks>
    /// The target number the roll must meet or exceed.
    /// Standard DCs: Easy=8, Moderate=12, Hard=15, Very Hard=18.
    /// </remarks>
    public int DC { get; init; }

    /// <summary>
    /// Gets the node ID on check failure.
    /// </summary>
    /// <remarks>
    /// Where dialogue navigates when the check fails.
    /// Required - persuasion always has a failure path.
    /// </remarks>
    public string FailureNodeId { get; init; }

    /// <summary>
    /// Gets the node ID on critical failure.
    /// </summary>
    /// <remarks>
    /// Optional. If null, critical failure uses FailureNodeId.
    /// Critical failure typically occurs when the roll is 5+ under DC.
    /// </remarks>
    public string? CriticalFailureNodeId { get; init; }

    /// <summary>
    /// Gets the display text for this check.
    /// </summary>
    /// <returns>Formatted skill check notation.</returns>
    public string GetDisplayText()
    {
        return $"[{SkillId} DC {DC}]";
    }

    /// <summary>
    /// Determines the result node based on check outcome.
    /// </summary>
    /// <param name="roll">The total roll value.</param>
    /// <param name="successNodeId">Target on success.</param>
    /// <returns>The node ID to navigate to.</returns>
    public string GetResultNodeId(int roll, string successNodeId)
    {
        if (roll >= DC)
        {
            return successNodeId;
        }

        // Critical failure if 5+ under DC
        if (roll <= DC - 5 && CriticalFailureNodeId is not null)
        {
            return CriticalFailureNodeId;
        }

        return FailureNodeId;
    }
}
```

### 5.9 DialogueState Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks the state of an active dialogue conversation.
/// </summary>
/// <remarks>
/// Created when dialogue starts and maintained throughout the
/// conversation. Tracks current position, choices made, and
/// one-time options used.
/// </remarks>
public class DialogueState
{
    /// <summary>
    /// Gets the unique identifier for this dialogue state.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the player ID in this conversation.
    /// </summary>
    public Guid PlayerId { get; private set; }

    /// <summary>
    /// Gets the NPC ID in this conversation.
    /// </summary>
    public Guid NPCId { get; private set; }

    /// <summary>
    /// Gets the root dialogue node ID.
    /// </summary>
    /// <remarks>
    /// The starting point of the dialogue tree.
    /// </remarks>
    public string RootNodeId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the current dialogue node ID.
    /// </summary>
    public string CurrentNodeId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the option IDs that have been selected in this conversation.
    /// </summary>
    /// <remarks>
    /// Used for PreviousChoice conditions and history tracking.
    /// </remarks>
    public IReadOnlyList<string> ChoicesMade { get; private set; } = [];

    /// <summary>
    /// Gets the one-time option IDs that have been used.
    /// </summary>
    /// <remarks>
    /// Persisted across conversations with this NPC.
    /// </remarks>
    public IReadOnlySet<string> UsedOneTimeOptions { get; private set; } = new HashSet<string>();

    /// <summary>
    /// Gets whether this dialogue is currently active.
    /// </summary>
    public bool IsActive { get; private set; }

    /// <summary>
    /// Gets when this dialogue started.
    /// </summary>
    public DateTime StartedAt { get; private set; }

    /// <summary>
    /// Private constructor for creation.
    /// </summary>
    private DialogueState() { }

    /// <summary>
    /// Creates a new dialogue state.
    /// </summary>
    /// <param name="playerId">Player ID.</param>
    /// <param name="npcId">NPC ID.</param>
    /// <param name="rootNodeId">Root dialogue node ID.</param>
    /// <param name="previouslyUsedOptions">Previously used one-time options.</param>
    /// <returns>A new dialogue state.</returns>
    public static DialogueState Create(
        Guid playerId,
        Guid npcId,
        string rootNodeId,
        IEnumerable<string>? previouslyUsedOptions = null)
    {
        return new DialogueState
        {
            Id = Guid.NewGuid(),
            PlayerId = playerId,
            NPCId = npcId,
            RootNodeId = rootNodeId,
            CurrentNodeId = rootNodeId,
            ChoicesMade = [],
            UsedOneTimeOptions = previouslyUsedOptions?.ToHashSet() ?? new HashSet<string>(),
            IsActive = true,
            StartedAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Navigates to a new node.
    /// </summary>
    /// <param name="nodeId">The target node ID.</param>
    public void NavigateTo(string nodeId)
    {
        CurrentNodeId = nodeId;
    }

    /// <summary>
    /// Records a choice selection.
    /// </summary>
    /// <param name="optionId">The selected option ID.</param>
    /// <param name="isOneTime">Whether this is a one-time option.</param>
    public void RecordChoice(string? optionId, bool isOneTime)
    {
        if (string.IsNullOrEmpty(optionId)) return;

        var choices = ChoicesMade.ToList();
        choices.Add(optionId);
        ChoicesMade = choices;

        if (isOneTime)
        {
            var used = UsedOneTimeOptions.ToHashSet();
            used.Add(optionId);
            UsedOneTimeOptions = used;
        }
    }

    /// <summary>
    /// Ends the dialogue.
    /// </summary>
    public void End()
    {
        IsActive = false;
    }

    /// <summary>
    /// Checks if a choice has been made in this conversation.
    /// </summary>
    /// <param name="optionId">The option ID to check.</param>
    /// <returns>True if the choice was made.</returns>
    public bool HasMadeChoice(string optionId)
    {
        return ChoicesMade.Contains(optionId);
    }
}
```

### 5.10 DialogueContext Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Provides context for dialogue condition evaluation.
/// </summary>
/// <remarks>
/// Built from Player, NPC, and game state to evaluate
/// dialogue conditions. Immutable snapshot of relevant data.
/// </remarks>
public class DialogueContext
{
    /// <summary>
    /// Gets the player in the dialogue.
    /// </summary>
    public Player Player { get; }

    /// <summary>
    /// Gets the NPC in the dialogue.
    /// </summary>
    public NPC NPC { get; }

    /// <summary>
    /// Gets the current dialogue flags.
    /// </summary>
    public IReadOnlyDictionary<string, bool> DialogueFlags { get; }

    /// <summary>
    /// Gets the current dialogue state.
    /// </summary>
    public DialogueState? State { get; }

    /// <summary>
    /// Gets the player's current gold.
    /// </summary>
    public int Gold => Player.Gold;

    /// <summary>
    /// Gets the player's current level.
    /// </summary>
    public int PlayerLevel => Player.Level;

    /// <summary>
    /// Gets the NPC's current attitude.
    /// </summary>
    public NPCAttitude NPCAttitude => NPC.Attitude;

    /// <summary>
    /// Creates a new dialogue context.
    /// </summary>
    /// <param name="player">The player.</param>
    /// <param name="npc">The NPC.</param>
    /// <param name="dialogueFlags">Current dialogue flags.</param>
    /// <param name="state">Current dialogue state (optional).</param>
    public DialogueContext(
        Player player,
        NPC npc,
        IReadOnlyDictionary<string, bool> dialogueFlags,
        DialogueState? state = null)
    {
        Player = player ?? throw new ArgumentNullException(nameof(player));
        NPC = npc ?? throw new ArgumentNullException(nameof(npc));
        DialogueFlags = dialogueFlags ?? new Dictionary<string, bool>();
        State = state;
    }

    /// <summary>
    /// Checks if the player has an item.
    /// </summary>
    /// <param name="itemId">The item definition ID.</param>
    /// <param name="quantity">Minimum quantity required.</param>
    /// <returns>True if the player has the item.</returns>
    public bool HasItem(string itemId, int quantity = 1)
    {
        return Player.Inventory.GetItemCount(itemId) >= quantity;
    }

    /// <summary>
    /// Gets a player stat value.
    /// </summary>
    /// <param name="statName">The stat name.</param>
    /// <returns>The stat value, or 0 if not found.</returns>
    public int GetStat(string statName)
    {
        return statName.ToLowerInvariant() switch
        {
            "attack" => Player.Stats.Attack,
            "defense" => Player.Stats.Defense,
            "maxhealth" or "max_health" => Player.Stats.MaxHealth,
            _ => 0
        };
    }

    /// <summary>
    /// Checks if a dialogue flag is set.
    /// </summary>
    /// <param name="flagName">The flag name.</param>
    /// <returns>True if the flag is set and true.</returns>
    public bool HasFlag(string flagName)
    {
        return DialogueFlags.TryGetValue(flagName, out var value) && value;
    }

    /// <summary>
    /// Gets a quest state value.
    /// </summary>
    /// <param name="questId">The quest ID.</param>
    /// <returns>The quest state, or 0 if not started.</returns>
    /// <remarks>Deferred to v0.3.0 - returns 0 for now.</remarks>
    public int GetQuestState(string questId)
    {
        // Quest system deferred to v0.3.0
        return 0;
    }

    /// <summary>
    /// Gets faction reputation.
    /// </summary>
    /// <param name="factionId">The faction ID.</param>
    /// <returns>Reputation value, or 0 if not tracked.</returns>
    /// <remarks>Deferred to v0.2.0c - returns 0 for now.</remarks>
    public int GetReputation(string factionId)
    {
        // Reputation system deferred to v0.2.0c
        return 0;
    }

    /// <summary>
    /// Checks if a previous choice was made.
    /// </summary>
    /// <param name="optionId">The option ID.</param>
    /// <returns>True if the choice was made.</returns>
    public bool MadeChoice(string optionId)
    {
        return State?.HasMadeChoice(optionId) ?? false;
    }
}
```

### 5.11 DialogueResult Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of a dialogue operation (start, select option, etc.).
/// </summary>
public readonly record struct DialogueResult
{
    /// <summary>
    /// Gets whether the operation succeeded.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the result type.
    /// </summary>
    public DialogueResultType Type { get; init; }

    /// <summary>
    /// Gets the current dialogue node (if active).
    /// </summary>
    public DialogueNodeDefinition? CurrentNode { get; init; }

    /// <summary>
    /// Gets available options at current node.
    /// </summary>
    public IReadOnlyList<DialogueOption> AvailableOptions { get; init; }

    /// <summary>
    /// Gets the dialogue state ID.
    /// </summary>
    public Guid? StateId { get; init; }

    /// <summary>
    /// Gets an error or status message.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets outcomes that were applied.
    /// </summary>
    public IReadOnlyList<DialogueOutcome> AppliedOutcomes { get; init; }

    /// <summary>
    /// Creates a successful dialogue result.
    /// </summary>
    public static DialogueResult Succeeded(
        Guid stateId,
        DialogueNodeDefinition node,
        IReadOnlyList<DialogueOption> options,
        IReadOnlyList<DialogueOutcome>? appliedOutcomes = null)
    {
        return new DialogueResult
        {
            Success = true,
            Type = DialogueResultType.NodeDisplayed,
            StateId = stateId,
            CurrentNode = node,
            AvailableOptions = options,
            AppliedOutcomes = appliedOutcomes ?? [],
            Message = string.Empty
        };
    }

    /// <summary>
    /// Creates a dialogue ended result.
    /// </summary>
    public static DialogueResult Ended(string message = "")
    {
        return new DialogueResult
        {
            Success = true,
            Type = DialogueResultType.DialogueEnded,
            Message = message,
            AvailableOptions = [],
            AppliedOutcomes = []
        };
    }

    /// <summary>
    /// Creates a failure result.
    /// </summary>
    public static DialogueResult Failed(DialogueResultType type, string message)
    {
        return new DialogueResult
        {
            Success = false,
            Type = type,
            Message = message,
            AvailableOptions = [],
            AppliedOutcomes = []
        };
    }

    /// <summary>
    /// Creates a result for no dialogue configured.
    /// </summary>
    public static DialogueResult NoDialogue(string npcName)
    {
        return Failed(
            DialogueResultType.NoDialogue,
            $"{npcName} has nothing more to say.");
    }

    /// <summary>
    /// Creates a result for invalid option.
    /// </summary>
    public static DialogueResult InvalidOption(int index)
    {
        return Failed(
            DialogueResultType.InvalidOption,
            $"Option {index} is not available.");
    }
}

/// <summary>
/// Types of dialogue results.
/// </summary>
public enum DialogueResultType
{
    /// <summary>Node displayed successfully.</summary>
    NodeDisplayed,

    /// <summary>Dialogue has ended.</summary>
    DialogueEnded,

    /// <summary>NPC has no dialogue configured.</summary>
    NoDialogue,

    /// <summary>Node not found.</summary>
    NodeNotFound,

    /// <summary>Invalid option selected.</summary>
    InvalidOption,

    /// <summary>No active dialogue.</summary>
    NoActiveDialogue
}
```

### 5.12 PersuasionResult Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of a persuasion skill check during dialogue.
/// </summary>
public readonly record struct PersuasionResult
{
    /// <summary>
    /// Gets whether the check succeeded.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the skill used.
    /// </summary>
    public string SkillId { get; init; }

    /// <summary>
    /// Gets the difficulty class.
    /// </summary>
    public int DC { get; init; }

    /// <summary>
    /// Gets the dice roll values.
    /// </summary>
    public IReadOnlyList<int> DiceRolls { get; init; }

    /// <summary>
    /// Gets any modifiers applied.
    /// </summary>
    public int Modifiers { get; init; }

    /// <summary>
    /// Gets the total roll result.
    /// </summary>
    public int Total { get; init; }

    /// <summary>
    /// Gets whether this was a critical failure.
    /// </summary>
    public bool IsCriticalFailure { get; init; }

    /// <summary>
    /// Gets the node navigated to.
    /// </summary>
    public string ResultNodeId { get; init; }

    /// <summary>
    /// Gets the dialogue result after the check.
    /// </summary>
    public DialogueResult DialogueResult { get; init; }

    /// <summary>
    /// Creates a persuasion result.
    /// </summary>
    public static PersuasionResult Create(
        string skillId,
        int dc,
        IReadOnlyList<int> diceRolls,
        int modifiers,
        int total,
        bool success,
        bool criticalFailure,
        string resultNodeId,
        DialogueResult dialogueResult)
    {
        return new PersuasionResult
        {
            SkillId = skillId,
            DC = dc,
            DiceRolls = diceRolls,
            Modifiers = modifiers,
            Total = total,
            Success = success,
            IsCriticalFailure = criticalFailure,
            ResultNodeId = resultNodeId,
            DialogueResult = dialogueResult
        };
    }

    /// <summary>
    /// Gets a formatted description of the roll.
    /// </summary>
    public string GetRollDescription()
    {
        var rollsStr = string.Join(" + ", DiceRolls);
        var modStr = Modifiers >= 0 ? $" + {Modifiers}" : $" - {Math.Abs(Modifiers)}";
        var resultStr = Success ? "Success!" : (IsCriticalFailure ? "Critical Failure!" : "Failed!");

        return $"Rolling {rollsStr}{modStr} = {Total} vs DC {DC}: {resultStr}";
    }
}
```

---

## 6. Configuration Schemas

### 6.1 dialogues.json

```json
{
  "$schema": "../schemas/dialogues.schema.json",
  "dialogues": {
    "grimbold-main": {
      "id": "grimbold-main",
      "speaker": "Grimbold",
      "text": "So, you're interested in my wares? I have many fine items, though some are... reserved for special customers.",
      "options": [
        {
          "text": "What items do you have for sale?",
          "targetNodeId": "grimbold-shop"
        },
        {
          "optionId": "grimbold-special-question",
          "text": "What do you mean by 'special customers'?",
          "targetNodeId": "grimbold-special",
          "conditions": [
            { "type": "AttitudeAtLeast", "operator": "GreaterOrEqual", "value": 1 }
          ]
        },
        {
          "optionId": "grimbold-persuade",
          "text": "[Persuade DC 12] I'm sure we can come to an arrangement.",
          "targetNodeId": "grimbold-persuaded",
          "skillCheck": {
            "skillId": "persuasion",
            "dc": 12,
            "failureNodeId": "grimbold-refuse"
          },
          "oneTimeOnly": true
        },
        {
          "text": "Goodbye.",
          "targetNodeId": "grimbold-farewell"
        }
      ],
      "tags": ["merchant", "greeting"]
    },
    "grimbold-shop": {
      "id": "grimbold-shop",
      "speaker": "Grimbold",
      "text": "Take a look around! Weapons, armor, potions - if it's useful in these depths, I probably have it.",
      "options": [
        {
          "text": "Let me see your wares.",
          "targetNodeId": "grimbold-shop-browse",
          "outcomes": [
            { "type": "SetFlag", "targetId": "visited-grimbold-shop" }
          ]
        },
        {
          "text": "I'll come back later.",
          "targetNodeId": "grimbold-main"
        }
      ],
      "tags": ["merchant", "shop"]
    },
    "grimbold-special": {
      "id": "grimbold-special",
      "speaker": "Grimbold",
      "text": "Ah, perceptive! Some items I only sell to... trusted individuals. Help me with a few tasks, and perhaps you'll earn that trust.",
      "options": [
        {
          "text": "What kind of tasks?",
          "targetNodeId": "grimbold-tasks"
        },
        {
          "text": "I'm not interested in errands.",
          "targetNodeId": "grimbold-main"
        }
      ],
      "tags": ["merchant", "quest-hook"]
    },
    "grimbold-persuaded": {
      "id": "grimbold-persuaded",
      "speaker": "Grimbold",
      "text": "*Grimbold strokes his beard thoughtfully* Hmm, there's something about you I like. Very well - I'll show you the special stock.",
      "onEnterOutcomes": [
        { "type": "ChangeAttitude", "value": 1 },
        { "type": "SetFlag", "targetId": "grimbold-persuaded" }
      ],
      "options": [
        {
          "text": "Show me what you've got.",
          "targetNodeId": "grimbold-special-shop"
        }
      ],
      "tags": ["merchant", "persuasion-success"]
    },
    "grimbold-refuse": {
      "id": "grimbold-refuse",
      "speaker": "Grimbold",
      "text": "*Grimbold narrows his eyes* Nice try, but you'll need to earn my trust the old-fashioned way. Come back when you've proven yourself.",
      "options": [
        {
          "text": "I understand.",
          "targetNodeId": "grimbold-main"
        }
      ],
      "tags": ["merchant", "persuasion-failure"]
    },
    "grimbold-farewell": {
      "id": "grimbold-farewell",
      "speaker": "Grimbold",
      "text": "Safe travels! Remember - Grimbold always has what you need!",
      "isTerminal": true,
      "tags": ["farewell"]
    },
    "elara-secrets": {
      "id": "elara-secrets",
      "speaker": "Elara",
      "text": "*Elara glances around nervously* Keep your voice down. These walls have ears, and not all of them are friendly.",
      "options": [
        {
          "text": "What do you know about this place?",
          "targetNodeId": "elara-lore",
          "conditions": [
            { "type": "AttitudeAtLeast", "operator": "GreaterOrEqual", "value": 2 }
          ]
        },
        {
          "optionId": "elara-key-question",
          "text": "I need to get through the iron door in the west corridor.",
          "targetNodeId": "elara-key-info",
          "conditions": [
            { "type": "FlagSet", "targetId": "seen-iron-door" }
          ],
          "oneTimeOnly": true
        },
        {
          "optionId": "elara-trade",
          "text": "I have information that might interest you.",
          "targetNodeId": "elara-trade",
          "conditions": [
            { "type": "FlagSet", "targetId": "found-secret-map" }
          ]
        },
        {
          "text": "Goodbye.",
          "targetNodeId": "elara-farewell"
        }
      ],
      "tags": ["informant", "greeting"]
    },
    "elara-key-info": {
      "id": "elara-key-info",
      "speaker": "Elara",
      "text": "Ah, the iron door. *She leans closer* The key is held by the overseer - a hulking brute in the lower chambers. But there's another way... if you're clever enough.",
      "onEnterOutcomes": [
        { "type": "SetFlag", "targetId": "learned-iron-door-secret" }
      ],
      "options": [
        {
          "text": "Tell me more about this other way.",
          "targetNodeId": "elara-secret-path"
        },
        {
          "text": "I'll take my chances with the overseer.",
          "targetNodeId": "elara-secrets"
        }
      ],
      "tags": ["informant", "hint"]
    },
    "elara-trade": {
      "id": "elara-trade",
      "speaker": "Elara",
      "text": "*Her eyes widen slightly* You found the map? Interesting. Very interesting. Perhaps we can help each other after all.",
      "onEnterOutcomes": [
        { "type": "ChangeAttitude", "value": 1 },
        { "type": "TakeItem", "targetId": "secret-map", "value": 1 },
        { "type": "GiveGold", "value": 50 }
      ],
      "options": [
        {
          "text": "What can you tell me now?",
          "targetNodeId": "elara-lore"
        }
      ],
      "tags": ["informant", "trade"]
    },
    "elara-farewell": {
      "id": "elara-farewell",
      "speaker": "Elara",
      "text": "*She melts back into the shadows* Watch your back, stranger.",
      "isTerminal": true,
      "tags": ["farewell"]
    }
  }
}
```

### 6.2 dialogues.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Dialogue Configuration",
  "description": "Defines dialogue trees for NPC conversations",
  "type": "object",
  "required": ["dialogues"],
  "properties": {
    "dialogues": {
      "type": "object",
      "description": "Map of dialogue node ID to definition",
      "additionalProperties": {
        "$ref": "#/definitions/dialogueNode"
      }
    }
  },
  "definitions": {
    "dialogueNode": {
      "type": "object",
      "required": ["id", "text"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier for this node"
        },
        "speaker": {
          "type": "string",
          "description": "Speaker name (empty for narration)"
        },
        "text": {
          "type": "string",
          "minLength": 1,
          "maxLength": 1000,
          "description": "Dialogue text with optional {PlayerName} substitution"
        },
        "options": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/dialogueOption"
          },
          "description": "Available player responses"
        },
        "isTerminal": {
          "type": "boolean",
          "default": false,
          "description": "Whether this node ends dialogue"
        },
        "onEnterOutcomes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/dialogueOutcome"
          },
          "description": "Outcomes applied when entering this node"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Tags for categorization"
        }
      }
    },
    "dialogueOption": {
      "type": "object",
      "required": ["text", "targetNodeId"],
      "properties": {
        "optionId": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Optional ID for tracking"
        },
        "text": {
          "type": "string",
          "minLength": 1,
          "maxLength": 200,
          "description": "Display text for the option"
        },
        "targetNodeId": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Node to navigate to on selection"
        },
        "conditions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/dialogueCondition"
          },
          "description": "Conditions required to show this option"
        },
        "outcomes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/dialogueOutcome"
          },
          "description": "Outcomes applied when selecting this option"
        },
        "skillCheck": {
          "$ref": "#/definitions/persuasionCheck"
        },
        "oneTimeOnly": {
          "type": "boolean",
          "default": false,
          "description": "If true, option disappears after selection"
        }
      }
    },
    "dialogueCondition": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "HasItem",
            "HasGold",
            "PlayerLevel",
            "StatCheck",
            "FlagSet",
            "QuestState",
            "AttitudeAtLeast",
            "ReputationAtLeast",
            "PreviousChoice"
          ],
          "description": "Type of condition"
        },
        "targetId": {
          "type": "string",
          "description": "Target for the condition (item ID, flag name, etc.)"
        },
        "operator": {
          "type": "string",
          "enum": [
            "Equal",
            "NotEqual",
            "GreaterThan",
            "LessThan",
            "GreaterOrEqual",
            "LessOrEqual"
          ],
          "default": "GreaterOrEqual",
          "description": "Comparison operator"
        },
        "value": {
          "type": "integer",
          "default": 1,
          "description": "Value to compare against"
        },
        "negate": {
          "type": "boolean",
          "default": false,
          "description": "Invert the condition result"
        }
      }
    },
    "dialogueOutcome": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "GiveItem",
            "TakeItem",
            "GiveGold",
            "TakeGold",
            "SetFlag",
            "ClearFlag",
            "ChangeAttitude",
            "ChangeReputation",
            "StartQuest",
            "AdvanceQuest",
            "UnlockDialogue",
            "RecruitCompanion",
            "TriggerCombat"
          ],
          "description": "Type of outcome"
        },
        "targetId": {
          "type": "string",
          "description": "Target for the outcome"
        },
        "value": {
          "type": "integer",
          "default": 1,
          "description": "Value for the outcome"
        },
        "data": {
          "type": "string",
          "description": "Additional data for complex outcomes"
        }
      }
    },
    "persuasionCheck": {
      "type": "object",
      "required": ["skillId", "dc", "failureNodeId"],
      "properties": {
        "skillId": {
          "type": "string",
          "description": "Skill to check (persuasion, intimidation, etc.)"
        },
        "dc": {
          "type": "integer",
          "minimum": 1,
          "maximum": 30,
          "description": "Difficulty class"
        },
        "failureNodeId": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Node on failure"
        },
        "criticalFailureNodeId": {
          "type": ["string", "null"],
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Node on critical failure (optional)"
        }
      }
    }
  }
}
```

---

## 7. Service Specifications

### 7.1 IDialogueService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides operations for dialogue tree navigation and management.
/// </summary>
public interface IDialogueService
{
    /// <summary>
    /// Starts a dialogue with an NPC.
    /// </summary>
    /// <param name="npc">The NPC to talk to.</param>
    /// <param name="player">The player initiating dialogue.</param>
    /// <returns>Result containing the root node and options.</returns>
    DialogueResult StartDialogue(NPC npc, Player player);

    /// <summary>
    /// Gets the current dialogue node for an active state.
    /// </summary>
    /// <param name="stateId">The dialogue state ID.</param>
    /// <returns>The current node, or null if not active.</returns>
    DialogueNodeDefinition? GetCurrentNode(Guid stateId);

    /// <summary>
    /// Gets available options for the current node.
    /// </summary>
    /// <param name="stateId">The dialogue state ID.</param>
    /// <returns>List of available options.</returns>
    IReadOnlyList<DialogueOption> GetAvailableOptions(Guid stateId);

    /// <summary>
    /// Selects a dialogue option.
    /// </summary>
    /// <param name="stateId">The dialogue state ID.</param>
    /// <param name="optionIndex">The option index (0-based).</param>
    /// <returns>Result containing the next node or error.</returns>
    DialogueResult SelectOption(Guid stateId, int optionIndex);

    /// <summary>
    /// Attempts a persuasion check for an option.
    /// </summary>
    /// <param name="stateId">The dialogue state ID.</param>
    /// <param name="optionIndex">The option index (0-based).</param>
    /// <returns>The persuasion result with roll details.</returns>
    PersuasionResult AttemptPersuasion(Guid stateId, int optionIndex);

    /// <summary>
    /// Ends the current dialogue.
    /// </summary>
    /// <param name="stateId">The dialogue state ID.</param>
    void EndDialogue(Guid stateId);

    /// <summary>
    /// Gets the current dialogue state for a player-NPC pair.
    /// </summary>
    /// <param name="playerId">The player ID.</param>
    /// <param name="npcId">The NPC ID.</param>
    /// <returns>The dialogue state, or null if no active dialogue.</returns>
    DialogueState? GetDialogueState(Guid playerId, Guid npcId);

    /// <summary>
    /// Gets a dialogue node definition by ID.
    /// </summary>
    /// <param name="nodeId">The node ID.</param>
    /// <returns>The node definition, or null if not found.</returns>
    DialogueNodeDefinition? GetDialogueNode(string nodeId);
}
```

### 7.2 DialogueService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages dialogue tree navigation and state.
/// </summary>
public class DialogueService : IDialogueService
{
    private readonly IGameConfigurationProvider _configProvider;
    private readonly IDiceService _diceService;
    private readonly ILogger<DialogueService> _logger;

    private readonly Dictionary<Guid, DialogueState> _activeDialogues = new();
    private readonly Dictionary<string, HashSet<string>> _usedOneTimeOptions = new();
    private readonly Dictionary<string, bool> _dialogueFlags = new();

    /// <summary>
    /// Initializes a new instance of DialogueService.
    /// </summary>
    public DialogueService(
        IGameConfigurationProvider configProvider,
        IDiceService diceService,
        ILogger<DialogueService> logger)
    {
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        var nodes = _configProvider.LoadDialogueNodes();
        _logger.LogInformation(
            "DialogueService initialized with {NodeCount} dialogue nodes",
            nodes.Count);
    }

    /// <inheritdoc/>
    public DialogueResult StartDialogue(NPC npc, Player player)
    {
        ArgumentNullException.ThrowIfNull(npc);
        ArgumentNullException.ThrowIfNull(player);

        _logger.LogDebug(
            "StartDialogue called for NPC {NPCName} by Player {PlayerName}",
            npc.Name, player.Name);

        if (string.IsNullOrEmpty(npc.RootDialogueId))
        {
            _logger.LogDebug("NPC {NPCName} has no dialogue configured", npc.Name);
            return DialogueResult.NoDialogue(npc.Name);
        }

        var rootNode = GetDialogueNode(npc.RootDialogueId);
        if (rootNode is null)
        {
            _logger.LogWarning(
                "Root dialogue node {NodeId} not found for NPC {NPCName}",
                npc.RootDialogueId, npc.Name);
            return DialogueResult.Failed(
                DialogueResultType.NodeNotFound,
                $"Dialogue configuration error for {npc.Name}.");
        }

        // Get previously used one-time options for this NPC
        var npcKey = $"{player.Id}:{npc.Id}";
        var usedOptions = _usedOneTimeOptions.GetValueOrDefault(npcKey, new HashSet<string>());

        // Create dialogue state
        var state = DialogueState.Create(player.Id, npc.Id, npc.RootDialogueId, usedOptions);
        _activeDialogues[state.Id] = state;

        // Apply on-enter outcomes
        var appliedOutcomes = ApplyOutcomes(rootNode.OnEnterOutcomes, player, npc);

        // Build context and get available options
        var context = new DialogueContext(player, npc, _dialogueFlags, state);
        var availableOptions = rootNode.GetAvailableOptions(context, state.UsedOneTimeOptions);

        _logger.LogInformation(
            "Started dialogue with {NPCName}, node: {NodeId}, options: {OptionCount}",
            npc.Name, rootNode.Id, availableOptions.Count);

        return DialogueResult.Succeeded(state.Id, rootNode, availableOptions, appliedOutcomes);
    }

    /// <inheritdoc/>
    public DialogueNodeDefinition? GetCurrentNode(Guid stateId)
    {
        if (!_activeDialogues.TryGetValue(stateId, out var state) || !state.IsActive)
        {
            return null;
        }

        return GetDialogueNode(state.CurrentNodeId);
    }

    /// <inheritdoc/>
    public IReadOnlyList<DialogueOption> GetAvailableOptions(Guid stateId)
    {
        if (!_activeDialogues.TryGetValue(stateId, out var state) || !state.IsActive)
        {
            return [];
        }

        var node = GetDialogueNode(state.CurrentNodeId);
        if (node is null) return [];

        // Need player and NPC for context - this is a limitation
        // In practice, caller should use SelectOption which has full context
        return node.Options;
    }

    /// <inheritdoc/>
    public DialogueResult SelectOption(Guid stateId, int optionIndex)
    {
        _logger.LogDebug(
            "SelectOption called for state {StateId}, option {OptionIndex}",
            stateId, optionIndex);

        if (!_activeDialogues.TryGetValue(stateId, out var state) || !state.IsActive)
        {
            return DialogueResult.Failed(
                DialogueResultType.NoActiveDialogue,
                "No active dialogue.");
        }

        var currentNode = GetDialogueNode(state.CurrentNodeId);
        if (currentNode is null)
        {
            return DialogueResult.Failed(
                DialogueResultType.NodeNotFound,
                "Current node not found.");
        }

        // Get available options (need context from stored player/NPC)
        // For now, use current options directly
        var options = currentNode.Options;

        if (optionIndex < 0 || optionIndex >= options.Count)
        {
            return DialogueResult.InvalidOption(optionIndex);
        }

        var selectedOption = options[optionIndex];

        // Check if option has a skill check
        if (selectedOption.SkillCheck is not null)
        {
            return DialogueResult.Failed(
                DialogueResultType.InvalidOption,
                "This option requires a skill check. Use AttemptPersuasion instead.");
        }

        // Record the choice
        state.RecordChoice(selectedOption.OptionId, selectedOption.OneTimeOnly);

        // Apply outcomes (simplified - would need player/NPC reference)
        var appliedOutcomes = selectedOption.Outcomes.ToList();

        // Navigate to target
        state.NavigateTo(selectedOption.TargetNodeId);

        var targetNode = GetDialogueNode(selectedOption.TargetNodeId);
        if (targetNode is null)
        {
            _logger.LogWarning(
                "Target node {NodeId} not found",
                selectedOption.TargetNodeId);
            return DialogueResult.Failed(
                DialogueResultType.NodeNotFound,
                "Next dialogue node not found.");
        }

        // Check if terminal
        if (targetNode.IsTerminal)
        {
            state.End();
            PersistUsedOptions(state);

            _logger.LogInformation(
                "Dialogue ended at terminal node {NodeId}",
                targetNode.Id);

            return DialogueResult.Ended(targetNode.Text);
        }

        // Apply on-enter outcomes of target node
        appliedOutcomes.AddRange(targetNode.OnEnterOutcomes);

        _logger.LogDebug(
            "Navigated to node {NodeId}",
            targetNode.Id);

        return DialogueResult.Succeeded(
            state.Id,
            targetNode,
            targetNode.Options,
            appliedOutcomes);
    }

    /// <inheritdoc/>
    public PersuasionResult AttemptPersuasion(Guid stateId, int optionIndex)
    {
        _logger.LogDebug(
            "AttemptPersuasion called for state {StateId}, option {OptionIndex}",
            stateId, optionIndex);

        if (!_activeDialogues.TryGetValue(stateId, out var state) || !state.IsActive)
        {
            var failedDialogue = DialogueResult.Failed(
                DialogueResultType.NoActiveDialogue,
                "No active dialogue.");

            return PersuasionResult.Create(
                "", 0, [], 0, 0, false, false, "", failedDialogue);
        }

        var currentNode = GetDialogueNode(state.CurrentNodeId);
        if (currentNode is null || optionIndex < 0 || optionIndex >= currentNode.Options.Count)
        {
            var failedDialogue = DialogueResult.InvalidOption(optionIndex);
            return PersuasionResult.Create(
                "", 0, [], 0, 0, false, false, "", failedDialogue);
        }

        var selectedOption = currentNode.Options[optionIndex];
        var skillCheck = selectedOption.SkillCheck;

        if (skillCheck is null)
        {
            var failedDialogue = DialogueResult.Failed(
                DialogueResultType.InvalidOption,
                "This option does not require a skill check.");
            return PersuasionResult.Create(
                "", 0, [], 0, 0, false, false, "", failedDialogue);
        }

        // Perform the dice roll
        var diceRolls = _diceService.Roll("2d6");
        var modifier = 0; // Would get from player skill in full implementation
        var total = diceRolls.Sum() + modifier;

        var success = total >= skillCheck.Value.DC;
        var criticalFailure = total <= skillCheck.Value.DC - 5;

        var resultNodeId = skillCheck.Value.GetResultNodeId(
            total,
            selectedOption.TargetNodeId);

        _logger.LogInformation(
            "Persuasion check: {SkillId} DC {DC}, rolled {Total} ({Rolls}+{Mod}) = {Result}",
            skillCheck.Value.SkillId,
            skillCheck.Value.DC,
            total,
            string.Join("+", diceRolls),
            modifier,
            success ? "Success" : (criticalFailure ? "Critical Failure" : "Failure"));

        // Record choice and navigate
        state.RecordChoice(selectedOption.OptionId, selectedOption.OneTimeOnly);
        state.NavigateTo(resultNodeId);

        var targetNode = GetDialogueNode(resultNodeId);
        DialogueResult dialogueResult;

        if (targetNode is null)
        {
            dialogueResult = DialogueResult.Failed(
                DialogueResultType.NodeNotFound,
                "Result node not found.");
        }
        else if (targetNode.IsTerminal)
        {
            state.End();
            PersistUsedOptions(state);
            dialogueResult = DialogueResult.Ended(targetNode.Text);
        }
        else
        {
            // Apply option outcomes on success only
            var outcomes = success ? selectedOption.Outcomes.ToList() : new List<DialogueOutcome>();
            outcomes.AddRange(targetNode.OnEnterOutcomes);

            dialogueResult = DialogueResult.Succeeded(
                state.Id,
                targetNode,
                targetNode.Options,
                outcomes);
        }

        return PersuasionResult.Create(
            skillCheck.Value.SkillId,
            skillCheck.Value.DC,
            diceRolls,
            modifier,
            total,
            success,
            criticalFailure,
            resultNodeId,
            dialogueResult);
    }

    /// <inheritdoc/>
    public void EndDialogue(Guid stateId)
    {
        if (_activeDialogues.TryGetValue(stateId, out var state))
        {
            state.End();
            PersistUsedOptions(state);
            _activeDialogues.Remove(stateId);

            _logger.LogDebug("Dialogue {StateId} ended by user", stateId);
        }
    }

    /// <inheritdoc/>
    public DialogueState? GetDialogueState(Guid playerId, Guid npcId)
    {
        return _activeDialogues.Values
            .FirstOrDefault(s => s.PlayerId == playerId && s.NPCId == npcId && s.IsActive);
    }

    /// <inheritdoc/>
    public DialogueNodeDefinition? GetDialogueNode(string nodeId)
    {
        return _configProvider.GetDialogueNode(nodeId);
    }

    /// <summary>
    /// Applies dialogue outcomes to game state.
    /// </summary>
    private List<DialogueOutcome> ApplyOutcomes(
        IReadOnlyList<DialogueOutcome> outcomes,
        Player player,
        NPC npc)
    {
        var applied = new List<DialogueOutcome>();

        foreach (var outcome in outcomes)
        {
            if (!outcome.IsImplemented())
            {
                _logger.LogDebug(
                    "Skipping unimplemented outcome type: {Type}",
                    outcome.Type);
                continue;
            }

            switch (outcome.Type)
            {
                case OutcomeType.SetFlag:
                    _dialogueFlags[outcome.TargetId] = true;
                    _logger.LogDebug("Set flag: {Flag}", outcome.TargetId);
                    break;

                case OutcomeType.ClearFlag:
                    _dialogueFlags[outcome.TargetId] = false;
                    _logger.LogDebug("Cleared flag: {Flag}", outcome.TargetId);
                    break;

                case OutcomeType.ChangeAttitude:
                    var currentAttitude = (int)npc.Attitude;
                    var newAttitude = Math.Clamp(currentAttitude + outcome.Value, 0, 3);
                    npc.SetAttitude((NPCAttitude)newAttitude);
                    _logger.LogDebug(
                        "Changed {NPCName} attitude by {Delta} to {NewAttitude}",
                        npc.Name, outcome.Value, npc.Attitude);
                    break;

                case OutcomeType.GiveGold:
                    player.AddGold(outcome.Value);
                    _logger.LogDebug("Gave {Amount} gold to player", outcome.Value);
                    break;

                case OutcomeType.TakeGold:
                    player.RemoveGold(outcome.Value);
                    _logger.LogDebug("Took {Amount} gold from player", outcome.Value);
                    break;

                // Item operations would need ItemService integration
                case OutcomeType.GiveItem:
                case OutcomeType.TakeItem:
                    _logger.LogDebug(
                        "Item outcome {Type}: {ItemId} x{Qty}",
                        outcome.Type, outcome.TargetId, outcome.Value);
                    break;

                case OutcomeType.UnlockDialogue:
                    _dialogueFlags[$"dialogue-unlocked:{outcome.TargetId}"] = true;
                    _logger.LogDebug("Unlocked dialogue: {NodeId}", outcome.TargetId);
                    break;

                case OutcomeType.TriggerCombat:
                    _logger.LogDebug("Combat trigger requested");
                    // Combat integration would be handled by caller
                    break;
            }

            applied.Add(outcome);
        }

        return applied;
    }

    /// <summary>
    /// Persists used one-time options.
    /// </summary>
    private void PersistUsedOptions(DialogueState state)
    {
        var key = $"{state.PlayerId}:{state.NPCId}";
        _usedOneTimeOptions[key] = state.UsedOneTimeOptions.ToHashSet();
    }
}
```

### 7.3 IConfigurationProvider Updates

```csharp
// Additions to IGameConfigurationProvider interface

/// <summary>
/// Loads all dialogue node definitions from configuration.
/// </summary>
/// <returns>Dictionary of node ID to definition.</returns>
IReadOnlyDictionary<string, DialogueNodeDefinition> LoadDialogueNodes();

/// <summary>
/// Gets a specific dialogue node by ID.
/// </summary>
/// <param name="nodeId">The node ID.</param>
/// <returns>The node definition, or null if not found.</returns>
DialogueNodeDefinition? GetDialogueNode(string nodeId);
```

### 7.4 GameSessionService Updates

```csharp
// Additions to GameSessionService

private readonly IDialogueService _dialogueService;
private Guid? _currentDialogueStateId;

/// <summary>
/// Selects a dialogue option in the current conversation.
/// </summary>
/// <param name="optionIndex">The option index (1-based for user input).</param>
/// <returns>The dialogue result.</returns>
public DialogueResult SelectDialogueOption(int optionIndex)
{
    EnsureGameStarted();

    if (!_currentDialogueStateId.HasValue)
    {
        return DialogueResult.Failed(
            DialogueResultType.NoActiveDialogue,
            "You're not in a conversation.");
    }

    // Convert from 1-based user input to 0-based index
    var result = _dialogueService.SelectOption(
        _currentDialogueStateId.Value,
        optionIndex - 1);

    if (result.Type == DialogueResultType.DialogueEnded)
    {
        _currentDialogueStateId = null;
    }

    return result;
}

/// <summary>
/// Attempts a persuasion check for a dialogue option.
/// </summary>
/// <param name="optionIndex">The option index (1-based for user input).</param>
/// <returns>The persuasion result.</returns>
public PersuasionResult AttemptDialoguePersuasion(int optionIndex)
{
    EnsureGameStarted();

    if (!_currentDialogueStateId.HasValue)
    {
        var failedResult = DialogueResult.Failed(
            DialogueResultType.NoActiveDialogue,
            "You're not in a conversation.");
        return PersuasionResult.Create(
            "", 0, [], 0, 0, false, false, "", failedResult);
    }

    var result = _dialogueService.AttemptPersuasion(
        _currentDialogueStateId.Value,
        optionIndex - 1);

    if (result.DialogueResult.Type == DialogueResultType.DialogueEnded)
    {
        _currentDialogueStateId = null;
    }

    return result;
}

/// <summary>
/// Ends the current dialogue.
/// </summary>
public void EndCurrentDialogue()
{
    if (_currentDialogueStateId.HasValue)
    {
        _dialogueService.EndDialogue(_currentDialogueStateId.Value);
        _currentDialogueStateId = null;
    }
}

/// <summary>
/// Gets the current dialogue state.
/// </summary>
public DialogueState? GetDialogueState()
{
    if (!_currentDialogueStateId.HasValue) return null;

    return _dialogueService.GetDialogueState(_player!.Id, /* current NPC ID */);
}

// Update TryTalk to start dialogue
public TalkResult TryTalk(string? npcName = null)
{
    EnsureGameStarted();

    var result = _npcService.TryTalkToNPC(_player!, _currentRoom!, npcName);

    if (result.Success && result.NPC is not null)
    {
        // Start dialogue if NPC has dialogue tree
        var dialogueResult = _dialogueService.StartDialogue(result.NPC, _player!);
        if (dialogueResult.Success)
        {
            _currentDialogueStateId = dialogueResult.StateId;
        }
    }

    return result;
}
```

---

## 8. Dialogue Command Flow

### 8.1 Input Handling

```csharp
// In InputHandler or CommandParser

/// <summary>
/// Parses a dialogue selection command.
/// </summary>
/// <param name="input">The raw input (e.g., "1", "2", "goodbye").</param>
/// <returns>Parsed command information.</returns>
public CommandInfo ParseDialogueCommand(string input)
{
    var trimmed = input.Trim();

    // Check for goodbye/exit
    if (trimmed.Equals("goodbye", StringComparison.OrdinalIgnoreCase) ||
        trimmed.Equals("bye", StringComparison.OrdinalIgnoreCase) ||
        trimmed.Equals("exit", StringComparison.OrdinalIgnoreCase))
    {
        return new CommandInfo
        {
            Command = CommandType.EndDialogue
        };
    }

    // Check for numeric option
    if (int.TryParse(trimmed, out var optionIndex))
    {
        return new CommandInfo
        {
            Command = CommandType.SelectDialogueOption,
            OptionIndex = optionIndex
        };
    }

    return CommandInfo.Invalid("Enter a number to select an option, or 'goodbye' to leave.");
}
```

### 8.2 Command Execution Flow

```
User Input: "talk" or "talk grimbold"
    │
    ▼
┌─────────────────┐
│ TryTalk() from  │
│ v0.2.0a         │
└────────┬────────┘
         │
    Success with NPC.RootDialogueId set
         │
         ▼
┌─────────────────┐
│ DialogueService │
│.StartDialogue() │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Display node +  │
│ numbered options│
└────────┬────────┘
         │
         ▼
User Input: "1" (or "2", "3", etc.)
         │
         ▼
┌─────────────────┐      ┌─────────────────┐
│ Has SkillCheck? │──YES▶│ AttemptPersuas- │
│                 │      │ ion()           │
└────────┬────────┘      └────────┬────────┘
         │                        │
        NO                        ▼
         │               ┌─────────────────┐
         ▼               │ Roll dice, get  │
┌─────────────────┐      │ result node     │
│ SelectOption()  │      └────────┬────────┘
└────────┬────────┘               │
         │                        │
         └────────────┬───────────┘
                      │
                      ▼
         ┌─────────────────┐
         │ Apply outcomes  │
         └────────┬────────┘
                  │
                  ▼
         ┌─────────────────┐
         │ Navigate to     │
         │ target node     │
         └────────┬────────┘
                  │
                  ▼
         ┌─────────────────┐      ┌─────────────────┐
         │ Is Terminal?    │──YES▶│ End dialogue    │
         └────────┬────────┘      │ Return control  │
                  │               └─────────────────┘
                 NO
                  │
                  ▼
         (Loop: Display node)
```

---

## 9. User-Facing Changes

### 9.1 Commands

```
> talk                    # Start dialogue (from v0.2.0a)
> 1                       # Select option 1
> 2                       # Select option 2
> 3                       # Select option 3 (or attempt persuasion)
> goodbye                 # End dialogue early
> bye                     # Alternative for goodbye
> exit                    # Alternative for goodbye
```

### 9.2 Output Examples

#### Initial Dialogue

```
> talk
╔════════════════════════════════════════════════════════════════════════╗
║                         GRIMBOLD THE TRADER                            ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  A stout dwarf with a braided beard sits behind a worn counter,       ║
║  eyeing you shrewdly.                                                  ║
║                                                                        ║
║  "So, you're interested in my wares? I have many fine items, though   ║
║  some are... reserved for special customers."                          ║
║                                                                        ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  [1] What items do you have for sale?                                  ║
║  [2] What do you mean by 'special customers'?                          ║
║  [3] [Persuade DC 12] I'm sure we can come to an arrangement.          ║
║  [4] Goodbye.                                                          ║
║                                                                        ║
╚════════════════════════════════════════════════════════════════════════╝
```

#### Successful Persuasion

```
> 3

╔════════════════════════════════════════════════════════════════════════╗
║                         SKILL CHECK                                    ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  Persuasion Check (DC 12)                                              ║
║                                                                        ║
║  Rolling 2d6 + 2 (Charisma)...                                         ║
║  Dice: [4] [5] = 9 + 2 = 11                                            ║
║                                                                        ║
║  Result: FAILED                                                        ║
║                                                                        ║
╚════════════════════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════════════════════╗
║                         GRIMBOLD THE TRADER                            ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  *Grimbold narrows his eyes*                                           ║
║                                                                        ║
║  "Nice try, but you'll need to earn my trust the old-fashioned way.   ║
║  Come back when you've proven yourself."                               ║
║                                                                        ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  [1] I understand.                                                     ║
║                                                                        ║
╚════════════════════════════════════════════════════════════════════════╝
```

#### Conditional Option Hidden

```
> talk elara

Elara: *glances around nervously* "Keep your voice down. These walls
have ears, and not all of them are friendly."

[1] I have information that might interest you.   [Requires: Found secret map]
[2] Goodbye.

(Option about the iron door is hidden because player hasn't set
"seen-iron-door" flag yet)
```

#### Terminal Node

```
> 4

╔════════════════════════════════════════════════════════════════════════╗
║                         GRIMBOLD THE TRADER                            ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  "Safe travels! Remember - Grimbold always has what you need!"         ║
║                                                                        ║
╚════════════════════════════════════════════════════════════════════════╝

[Dialogue ended]
```

---

## 10. Logging Requirements

### 10.1 Log Events

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Service Init | Information | "DialogueService initialized with {NodeCount} dialogue nodes" | NodeCount |
| Dialogue Started | Information | "Started dialogue with {NPCName}, node: {NodeId}, options: {OptionCount}" | NPCName, NodeId, OptionCount |
| No Dialogue | Debug | "NPC {NPCName} has no dialogue configured" | NPCName |
| Node Not Found | Warning | "Root dialogue node {NodeId} not found for NPC {NPCName}" | NodeId, NPCName |
| Option Selected | Debug | "SelectOption called for state {StateId}, option {OptionIndex}" | StateId, OptionIndex |
| Navigated | Debug | "Navigated to node {NodeId}" | NodeId |
| Dialogue Ended | Information | "Dialogue ended at terminal node {NodeId}" | NodeId |
| Persuasion Check | Information | "Persuasion check: {SkillId} DC {DC}, rolled {Total} = {Result}" | SkillId, DC, Total, Result |
| Flag Set | Debug | "Set flag: {Flag}" | Flag |
| Flag Cleared | Debug | "Cleared flag: {Flag}" | Flag |
| Attitude Changed | Debug | "Changed {NPCName} attitude by {Delta} to {NewAttitude}" | NPCName, Delta, NewAttitude |
| Gold Given | Debug | "Gave {Amount} gold to player" | Amount |
| Gold Taken | Debug | "Took {Amount} gold from player" | Amount |
| Dialogue Unlocked | Debug | "Unlocked dialogue: {NodeId}" | NodeId |
| Unimplemented Outcome | Debug | "Skipping unimplemented outcome type: {Type}" | Type |

### 10.2 Example Log Output

```
[2024-01-20 14:30:00 INF] DialogueService initialized with 12 dialogue nodes
[2024-01-20 14:32:15 DBG] StartDialogue called for NPC Grimbold by Player Astrid
[2024-01-20 14:32:15 INF] Started dialogue with Grimbold, node: grimbold-main, options: 4
[2024-01-20 14:32:20 DBG] SelectOption called for state a1b2c3d4-..., option 2
[2024-01-20 14:32:20 DBG] Navigated to node grimbold-persuade
[2024-01-20 14:32:20 INF] Persuasion check: persuasion DC 12, rolled 11 = Failure
[2024-01-20 14:32:20 DBG] Navigated to node grimbold-refuse
[2024-01-20 14:32:25 DBG] SelectOption called for state a1b2c3d4-..., option 0
[2024-01-20 14:32:25 DBG] Navigated to node grimbold-main
[2024-01-20 14:32:30 DBG] SelectOption called for state a1b2c3d4-..., option 3
[2024-01-20 14:32:30 INF] Dialogue ended at terminal node grimbold-farewell
```

---

## 11. Unit Test Specifications

### 11.1 DialogueNodeDefinition Tests (~6 tests)

```csharp
namespace RuneAndRust.Domain.Tests.Definitions;

[TestFixture]
public class DialogueNodeDefinitionTests
{
    [Test]
    public void Create_WithValidParameters_ReturnsNode()
    {
        var node = DialogueNodeDefinition.Create(
            "test-node",
            "Speaker",
            "Hello, traveler!");

        node.Should().NotBeNull();
        node.Id.Should().Be("test-node");
        node.Speaker.Should().Be("Speaker");
        node.Text.Should().Be("Hello, traveler!");
        node.IsTerminal.Should().BeTrue(); // No options = terminal
    }

    [Test]
    public void Create_WithOptions_IsNotTerminal()
    {
        var options = new[]
        {
            new DialogueOption { Text = "Reply", TargetNodeId = "next" }
        };

        var node = DialogueNodeDefinition.Create(
            "test-node",
            "Speaker",
            "Hello!",
            options);

        node.IsTerminal.Should().BeFalse();
        node.Options.Should().HaveCount(1);
    }

    [Test]
    public void Create_WithNullId_ThrowsArgumentException()
    {
        var act = () => DialogueNodeDefinition.Create(null!, "Speaker", "Text");

        act.Should().Throw<ArgumentException>();
    }

    [Test]
    public void Create_NormalizesIdToLowercase()
    {
        var node = DialogueNodeDefinition.Create("TEST-NODE", "Speaker", "Text");

        node.Id.Should().Be("test-node");
    }

    [Test]
    public void GetAvailableOptions_FiltersUnavailableOptions()
    {
        var options = new[]
        {
            new DialogueOption
            {
                Text = "Always available",
                TargetNodeId = "next",
                Conditions = []
            },
            new DialogueOption
            {
                Text = "Needs gold",
                TargetNodeId = "rich",
                Conditions = new[]
                {
                    new DialogueCondition
                    {
                        Type = ConditionType.HasGold,
                        Operator = ComparisonOperator.GreaterOrEqual,
                        Value = 1000
                    }
                }
            }
        };

        var node = DialogueNodeDefinition.Create("test", "Speaker", "Text", options);
        var context = CreateTestContext(gold: 50);

        var available = node.GetAvailableOptions(context, new HashSet<string>());

        available.Should().HaveCount(1);
        available[0].Text.Should().Be("Always available");
    }

    [Test]
    public void GetAvailableOptions_FiltersUsedOneTimeOptions()
    {
        var options = new[]
        {
            new DialogueOption
            {
                OptionId = "one-time",
                Text = "One time only",
                TargetNodeId = "next",
                OneTimeOnly = true,
                Conditions = []
            }
        };

        var node = DialogueNodeDefinition.Create("test", "Speaker", "Text", options);
        var context = CreateTestContext();
        var used = new HashSet<string> { "one-time" };

        var available = node.GetAvailableOptions(context, used);

        available.Should().BeEmpty();
    }

    private DialogueContext CreateTestContext(int gold = 0)
    {
        var player = Player.Create("Test", gold: gold);
        var npcDef = NPCDefinition.Create("test", "Test NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test");
        var npc = NPC.Create(npcDef);
        return new DialogueContext(player, npc, new Dictionary<string, bool>());
    }
}
```

### 11.2 DialogueCondition Tests (~8 tests)

```csharp
[TestFixture]
public class DialogueConditionTests
{
    private Player _player;
    private NPC _npc;
    private Dictionary<string, bool> _flags;

    [SetUp]
    public void Setup()
    {
        _player = Player.Create("Test", gold: 100);
        var npcDef = NPCDefinition.Create("test", "Test NPC", NPCType.Merchant,
            NPCAttitude.Neutral, "Hi", "Test");
        _npc = NPC.Create(npcDef);
        _flags = new Dictionary<string, bool>();
    }

    [Test]
    public void Evaluate_HasGold_WithSufficientGold_ReturnsTrue()
    {
        var condition = new DialogueCondition
        {
            Type = ConditionType.HasGold,
            Operator = ComparisonOperator.GreaterOrEqual,
            Value = 50
        };
        var context = new DialogueContext(_player, _npc, _flags);

        condition.Evaluate(context).Should().BeTrue();
    }

    [Test]
    public void Evaluate_HasGold_WithInsufficientGold_ReturnsFalse()
    {
        var condition = new DialogueCondition
        {
            Type = ConditionType.HasGold,
            Operator = ComparisonOperator.GreaterOrEqual,
            Value = 500
        };
        var context = new DialogueContext(_player, _npc, _flags);

        condition.Evaluate(context).Should().BeFalse();
    }

    [Test]
    public void Evaluate_FlagSet_WhenFlagExists_ReturnsTrue()
    {
        _flags["test-flag"] = true;
        var condition = new DialogueCondition
        {
            Type = ConditionType.FlagSet,
            TargetId = "test-flag"
        };
        var context = new DialogueContext(_player, _npc, _flags);

        condition.Evaluate(context).Should().BeTrue();
    }

    [Test]
    public void Evaluate_FlagSet_WhenFlagMissing_ReturnsFalse()
    {
        var condition = new DialogueCondition
        {
            Type = ConditionType.FlagSet,
            TargetId = "missing-flag"
        };
        var context = new DialogueContext(_player, _npc, _flags);

        condition.Evaluate(context).Should().BeFalse();
    }

    [Test]
    public void Evaluate_WithNegate_InvertsResult()
    {
        _flags["test-flag"] = true;
        var condition = new DialogueCondition
        {
            Type = ConditionType.FlagSet,
            TargetId = "test-flag",
            Negate = true
        };
        var context = new DialogueContext(_player, _npc, _flags);

        condition.Evaluate(context).Should().BeFalse();
    }

    [Test]
    public void Evaluate_AttitudeAtLeast_WithFriendlyNPC_ReturnsTrue()
    {
        _npc.SetAttitude(NPCAttitude.Friendly);
        var condition = new DialogueCondition
        {
            Type = ConditionType.AttitudeAtLeast,
            Value = (int)NPCAttitude.Neutral
        };
        var context = new DialogueContext(_player, _npc, _flags);

        condition.Evaluate(context).Should().BeTrue();
    }

    [Test]
    public void Evaluate_PlayerLevel_UsesOperatorCorrectly()
    {
        _player.GainExperience(1000); // Level up
        var condition = new DialogueCondition
        {
            Type = ConditionType.PlayerLevel,
            Operator = ComparisonOperator.GreaterThan,
            Value = 1
        };
        var context = new DialogueContext(_player, _npc, _flags);

        // Depends on leveling implementation
        condition.Evaluate(context).Should().BeTrue();
    }

    [Test]
    public void Evaluate_PreviousChoice_ChecksDialogueState()
    {
        var state = DialogueState.Create(Guid.NewGuid(), Guid.NewGuid(), "root");
        state.RecordChoice("previous-option", false);

        var condition = new DialogueCondition
        {
            Type = ConditionType.PreviousChoice,
            TargetId = "previous-option"
        };
        var context = new DialogueContext(_player, _npc, _flags, state);

        condition.Evaluate(context).Should().BeTrue();
    }
}
```

### 11.3 DialogueOption Tests (~4 tests)

```csharp
[TestFixture]
public class DialogueOptionTests
{
    [Test]
    public void IsAvailable_WithNoConditions_ReturnsTrue()
    {
        var option = new DialogueOption
        {
            Text = "Test",
            TargetNodeId = "next",
            Conditions = []
        };
        var context = CreateTestContext();

        option.IsAvailable(context).Should().BeTrue();
    }

    [Test]
    public void IsAvailable_WithMetConditions_ReturnsTrue()
    {
        var option = new DialogueOption
        {
            Text = "Test",
            TargetNodeId = "next",
            Conditions = new[]
            {
                new DialogueCondition
                {
                    Type = ConditionType.HasGold,
                    Operator = ComparisonOperator.GreaterOrEqual,
                    Value = 10
                }
            }
        };
        var context = CreateTestContext(gold: 100);

        option.IsAvailable(context).Should().BeTrue();
    }

    [Test]
    public void IsAvailable_WithUnmetConditions_ReturnsFalse()
    {
        var option = new DialogueOption
        {
            Text = "Test",
            TargetNodeId = "next",
            Conditions = new[]
            {
                new DialogueCondition
                {
                    Type = ConditionType.HasGold,
                    Operator = ComparisonOperator.GreaterOrEqual,
                    Value = 1000
                }
            }
        };
        var context = CreateTestContext(gold: 50);

        option.IsAvailable(context).Should().BeFalse();
    }

    [Test]
    public void IsAvailable_WithMultipleConditions_RequiresAll()
    {
        var option = new DialogueOption
        {
            Text = "Test",
            TargetNodeId = "next",
            Conditions = new[]
            {
                new DialogueCondition { Type = ConditionType.HasGold, Value = 10 },
                new DialogueCondition { Type = ConditionType.PlayerLevel, Value = 5 }
            }
        };
        var context = CreateTestContext(gold: 100); // Has gold but not level

        option.IsAvailable(context).Should().BeFalse();
    }

    private DialogueContext CreateTestContext(int gold = 0)
    {
        var player = Player.Create("Test", gold: gold);
        var npcDef = NPCDefinition.Create("test", "NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test");
        var npc = NPC.Create(npcDef);
        return new DialogueContext(player, npc, new Dictionary<string, bool>());
    }
}
```

### 11.4 PersuasionCheck Tests (~3 tests)

```csharp
[TestFixture]
public class PersuasionCheckTests
{
    [Test]
    public void GetResultNodeId_OnSuccess_ReturnsSuccessNode()
    {
        var check = new PersuasionCheck
        {
            SkillId = "persuasion",
            DC = 12,
            FailureNodeId = "fail"
        };

        var result = check.GetResultNodeId(14, "success");

        result.Should().Be("success");
    }

    [Test]
    public void GetResultNodeId_OnFailure_ReturnsFailureNode()
    {
        var check = new PersuasionCheck
        {
            SkillId = "persuasion",
            DC = 12,
            FailureNodeId = "fail"
        };

        var result = check.GetResultNodeId(10, "success");

        result.Should().Be("fail");
    }

    [Test]
    public void GetResultNodeId_OnCriticalFailure_ReturnsCriticalNode()
    {
        var check = new PersuasionCheck
        {
            SkillId = "persuasion",
            DC = 12,
            FailureNodeId = "fail",
            CriticalFailureNodeId = "crit-fail"
        };

        var result = check.GetResultNodeId(5, "success"); // 5+ under DC

        result.Should().Be("crit-fail");
    }
}
```

### 11.5 DialogueState Tests (~5 tests)

```csharp
[TestFixture]
public class DialogueStateTests
{
    [Test]
    public void Create_InitializesCorrectly()
    {
        var playerId = Guid.NewGuid();
        var npcId = Guid.NewGuid();

        var state = DialogueState.Create(playerId, npcId, "root-node");

        state.Id.Should().NotBe(Guid.Empty);
        state.PlayerId.Should().Be(playerId);
        state.NPCId.Should().Be(npcId);
        state.RootNodeId.Should().Be("root-node");
        state.CurrentNodeId.Should().Be("root-node");
        state.IsActive.Should().BeTrue();
        state.ChoicesMade.Should().BeEmpty();
    }

    [Test]
    public void NavigateTo_UpdatesCurrentNode()
    {
        var state = DialogueState.Create(Guid.NewGuid(), Guid.NewGuid(), "root");

        state.NavigateTo("next-node");

        state.CurrentNodeId.Should().Be("next-node");
    }

    [Test]
    public void RecordChoice_AddsToChoicesMade()
    {
        var state = DialogueState.Create(Guid.NewGuid(), Guid.NewGuid(), "root");

        state.RecordChoice("option-1", false);

        state.ChoicesMade.Should().Contain("option-1");
    }

    [Test]
    public void RecordChoice_OneTimeOption_AddsToUsedSet()
    {
        var state = DialogueState.Create(Guid.NewGuid(), Guid.NewGuid(), "root");

        state.RecordChoice("one-time-option", true);

        state.UsedOneTimeOptions.Should().Contain("one-time-option");
    }

    [Test]
    public void End_SetsInactive()
    {
        var state = DialogueState.Create(Guid.NewGuid(), Guid.NewGuid(), "root");

        state.End();

        state.IsActive.Should().BeFalse();
    }
}
```

### 11.6 DialogueService Tests (~9 tests)

```csharp
[TestFixture]
public class DialogueServiceTests
{
    private Mock<IGameConfigurationProvider> _configMock;
    private Mock<IDiceService> _diceMock;
    private Mock<ILogger<DialogueService>> _loggerMock;
    private DialogueService _service;

    [SetUp]
    public void Setup()
    {
        _configMock = new Mock<IGameConfigurationProvider>();
        _diceMock = new Mock<IDiceService>();
        _loggerMock = new Mock<ILogger<DialogueService>>();

        var nodes = new Dictionary<string, DialogueNodeDefinition>
        {
            ["test-root"] = DialogueNodeDefinition.Create(
                "test-root",
                "Speaker",
                "Hello!",
                new[] { new DialogueOption { Text = "Hi", TargetNodeId = "test-next" } }),
            ["test-next"] = DialogueNodeDefinition.Create(
                "test-next",
                "Speaker",
                "Goodbye!",
                isTerminal: true)
        };

        _configMock.Setup(x => x.LoadDialogueNodes()).Returns(nodes);
        _configMock.Setup(x => x.GetDialogueNode(It.IsAny<string>()))
            .Returns((string id) => nodes.GetValueOrDefault(id));

        _service = new DialogueService(
            _configMock.Object,
            _diceMock.Object,
            _loggerMock.Object);
    }

    [Test]
    public void StartDialogue_WithValidNPC_ReturnsSuccessResult()
    {
        var player = Player.Create("Test");
        var npcDef = NPCDefinition.Create("test", "Test NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test", rootDialogueId: "test-root");
        var npc = NPC.Create(npcDef);

        var result = _service.StartDialogue(npc, player);

        result.Success.Should().BeTrue();
        result.CurrentNode.Should().NotBeNull();
        result.CurrentNode!.Id.Should().Be("test-root");
        result.StateId.Should().NotBeNull();
    }

    [Test]
    public void StartDialogue_WithNoDialogue_ReturnsNoDialogueResult()
    {
        var player = Player.Create("Test");
        var npcDef = NPCDefinition.Create("test", "Test NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test"); // No rootDialogueId
        var npc = NPC.Create(npcDef);

        var result = _service.StartDialogue(npc, player);

        result.Success.Should().BeFalse();
        result.Type.Should().Be(DialogueResultType.NoDialogue);
    }

    [Test]
    public void SelectOption_NavigatesToTargetNode()
    {
        var player = Player.Create("Test");
        var npcDef = NPCDefinition.Create("test", "NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test", rootDialogueId: "test-root");
        var npc = NPC.Create(npcDef);

        var startResult = _service.StartDialogue(npc, player);
        var result = _service.SelectOption(startResult.StateId!.Value, 0);

        result.Success.Should().BeTrue();
        result.Type.Should().Be(DialogueResultType.DialogueEnded);
    }

    [Test]
    public void SelectOption_WithInvalidIndex_ReturnsInvalidOption()
    {
        var player = Player.Create("Test");
        var npcDef = NPCDefinition.Create("test", "NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test", rootDialogueId: "test-root");
        var npc = NPC.Create(npcDef);

        var startResult = _service.StartDialogue(npc, player);
        var result = _service.SelectOption(startResult.StateId!.Value, 99);

        result.Success.Should().BeFalse();
        result.Type.Should().Be(DialogueResultType.InvalidOption);
    }

    [Test]
    public void AttemptPersuasion_RollsDice()
    {
        // Setup node with skill check
        var checkOption = new DialogueOption
        {
            Text = "Persuade",
            TargetNodeId = "success",
            SkillCheck = new PersuasionCheck
            {
                SkillId = "persuasion",
                DC = 10,
                FailureNodeId = "fail"
            }
        };
        var node = DialogueNodeDefinition.Create(
            "check-node", "Speaker", "Text", new[] { checkOption });

        _configMock.Setup(x => x.GetDialogueNode("check-node")).Returns(node);
        _diceMock.Setup(x => x.Roll("2d6")).Returns(new[] { 6, 6 }); // High roll

        var player = Player.Create("Test");
        var npcDef = NPCDefinition.Create("test", "NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test", rootDialogueId: "check-node");
        var npc = NPC.Create(npcDef);

        var startResult = _service.StartDialogue(npc, player);
        var result = _service.AttemptPersuasion(startResult.StateId!.Value, 0);

        result.Success.Should().BeTrue();
        result.Total.Should().Be(12);
        _diceMock.Verify(x => x.Roll("2d6"), Times.Once);
    }

    [Test]
    public void EndDialogue_DeactivatesState()
    {
        var player = Player.Create("Test");
        var npcDef = NPCDefinition.Create("test", "NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test", rootDialogueId: "test-root");
        var npc = NPC.Create(npcDef);

        var startResult = _service.StartDialogue(npc, player);
        _service.EndDialogue(startResult.StateId!.Value);

        var state = _service.GetDialogueState(player.Id, npc.Id);
        state.Should().BeNull();
    }

    [Test]
    public void SelectOption_AtTerminalNode_EndsDialogue()
    {
        var player = Player.Create("Test");
        var npcDef = NPCDefinition.Create("test", "NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test", rootDialogueId: "test-root");
        var npc = NPC.Create(npcDef);

        var startResult = _service.StartDialogue(npc, player);
        var result = _service.SelectOption(startResult.StateId!.Value, 0);

        result.Type.Should().Be(DialogueResultType.DialogueEnded);
    }

    [Test]
    public void StartDialogue_AppliesOnEnterOutcomes()
    {
        var nodeWithOutcome = DialogueNodeDefinition.Create(
            "outcome-node",
            "Speaker",
            "Text",
            isTerminal: true,
            onEnterOutcomes: new[]
            {
                new DialogueOutcome { Type = OutcomeType.SetFlag, TargetId = "test-flag" }
            });

        _configMock.Setup(x => x.GetDialogueNode("outcome-node")).Returns(nodeWithOutcome);

        var player = Player.Create("Test");
        var npcDef = NPCDefinition.Create("test", "NPC", NPCType.Wanderer,
            NPCAttitude.Neutral, "Hi", "Test", rootDialogueId: "outcome-node");
        var npc = NPC.Create(npcDef);

        var result = _service.StartDialogue(npc, player);

        result.AppliedOutcomes.Should().ContainSingle()
            .Which.Type.Should().Be(OutcomeType.SetFlag);
    }

    [Test]
    public void GetDialogueNode_ReturnsNode()
    {
        var node = _service.GetDialogueNode("test-root");

        node.Should().NotBeNull();
        node!.Id.Should().Be("test-root");
    }
}
```

---

## 12. Use Cases

### UC-001: Start Dialogue with Dialogue Tree
**Actor:** Player
**Flow:** Talk to NPC → Load root node → Display text and options → Await selection

### UC-002: Navigate Dialogue
**Actor:** Player
**Flow:** View options → Select option → Apply outcomes → Navigate to target → Display new node

### UC-003: Attempt Persuasion
**Actor:** Player
**Flow:** Select persuasion option → Roll dice → Compare to DC → Navigate based on result

### UC-004: See Conditional Options
**Actor:** Player with specific state
**Flow:** View dialogue → Conditions evaluated → Available options shown → Hidden options not displayed

### UC-005: Use One-Time Option
**Actor:** Player
**Flow:** Select one-time option → Option recorded → Option hidden in future conversations

### UC-006: Receive Dialogue Outcome
**Actor:** Player making choice
**Flow:** Select option → Outcomes applied → Gold/items/flags changed → Continue dialogue

### UC-007: End Dialogue at Terminal
**Actor:** Player
**Flow:** Navigate to terminal node → Display farewell → Return to exploration

### UC-008: End Dialogue Early
**Actor:** Player
**Flow:** Type "goodbye" → Dialogue ended → Return to exploration

---

## 13. Acceptance Criteria

### AC-2.0b-1: Dialogue Node Definition
- [ ] DialogueNodeDefinition loads from JSON configuration
- [ ] Nodes have id, speaker, text, options, isTerminal, onEnterOutcomes, tags
- [ ] Nodes with no options are automatically terminal
- [ ] Text supports {PlayerName} variable substitution

### AC-2.0b-2: Dialogue Options
- [ ] DialogueOption has text, targetNodeId, conditions, outcomes, skillCheck
- [ ] OneTimeOnly options disappear after selection
- [ ] Options with unmet conditions are hidden
- [ ] Multiple conditions are ANDed together

### AC-2.0b-3: Condition System
- [ ] ConditionType covers all 9 types (HasItem, HasGold, etc.)
- [ ] ComparisonOperator supports all 6 operators
- [ ] Negate flag inverts condition result
- [ ] DialogueContext provides all necessary data

### AC-2.0b-4: Persuasion Checks
- [ ] PersuasionCheck specifies skillId, DC, failureNodeId
- [ ] Dice roll integrates with existing DiceService
- [ ] Success navigates to targetNodeId
- [ ] Failure navigates to failureNodeId
- [ ] Critical failure (5+ under DC) uses criticalFailureNodeId if set

### AC-2.0b-5: Outcome System
- [ ] OutcomeType covers all 13 types
- [ ] GiveItem, TakeItem, GiveGold, TakeGold are implemented
- [ ] SetFlag, ClearFlag are implemented
- [ ] ChangeAttitude modifies NPC attitude
- [ ] Deferred outcomes (reputation, quest, companion) are recognized but not applied

### AC-2.0b-6: Dialogue State
- [ ] DialogueState tracks current node, choices made, used one-time options
- [ ] State persists throughout conversation
- [ ] Used one-time options persist across conversations

### AC-2.0b-7: Service Integration
- [ ] DialogueService loads nodes from configuration
- [ ] StartDialogue creates state and returns root node
- [ ] SelectOption navigates and applies outcomes
- [ ] AttemptPersuasion performs dice roll
- [ ] EndDialogue cleans up state

### AC-2.0b-8: User Interface
- [ ] Options are numbered for selection
- [ ] Skill checks show skill and DC in option text
- [ ] Persuasion results show dice roll details
- [ ] Terminal nodes end dialogue cleanly

### AC-2.0b-9: Configuration
- [ ] dialogues.json defines all dialogue trees
- [ ] dialogues.schema.json validates configuration
- [ ] Invalid configuration produces clear errors

### AC-2.0b-10: Unit Tests
- [ ] ~35 unit tests implemented
- [ ] All tests pass
- [ ] Tests cover conditions, options, outcomes, service

---

## 14. Deliverable Checklist

### Domain Layer
- [ ] `Definitions/DialogueNodeDefinition.cs`
- [ ] `ValueObjects/DialogueOption.cs`
- [ ] `ValueObjects/DialogueCondition.cs`
- [ ] `ValueObjects/DialogueOutcome.cs`
- [ ] `ValueObjects/PersuasionCheck.cs`
- [ ] `ValueObjects/DialogueState.cs`
- [ ] `ValueObjects/DialogueContext.cs`
- [ ] `ValueObjects/DialogueResult.cs`
- [ ] `ValueObjects/PersuasionResult.cs`
- [ ] `Enums/ConditionType.cs`
- [ ] `Enums/ComparisonOperator.cs`
- [ ] `Enums/OutcomeType.cs`
- [ ] `Enums/DialogueResultType.cs`

### Application Layer
- [ ] `Interfaces/IDialogueService.cs`
- [ ] `Services/DialogueService.cs`
- [ ] `Services/GameSessionService.cs` updates
- [ ] `Interfaces/IGameConfigurationProvider.cs` updates

### Infrastructure Layer
- [ ] `Configuration/JsonConfigurationProvider.cs` updates (LoadDialogueNodes)

### Configuration Files
- [ ] `config/dialogues.json`
- [ ] `config/schemas/dialogues.schema.json`

### Presentation Layer
- [ ] Dialogue command handling
- [ ] Dialogue rendering updates
- [ ] Persuasion check display

### Tests
- [ ] `Domain.Tests/Definitions/DialogueNodeDefinitionTests.cs`
- [ ] `Domain.Tests/ValueObjects/DialogueConditionTests.cs`
- [ ] `Domain.Tests/ValueObjects/DialogueOptionTests.cs`
- [ ] `Domain.Tests/ValueObjects/PersuasionCheckTests.cs`
- [ ] `Domain.Tests/ValueObjects/DialogueStateTests.cs`
- [ ] `Application.Tests/Services/DialogueServiceTests.cs`

### Documentation
- [ ] XML documentation on all public members
- [ ] JSON schema documentation

---

## 15. Dependencies

### Required from v0.2.0a
- NPC entity with RootDialogueId
- NPCAttitude enum for attitude conditions
- TalkResult as dialogue entry point
- NPCService for NPC lookup

### Required from Previous Versions
- Player entity with Inventory, Gold, Level, Stats
- DiceService for persuasion rolls
- IGameConfigurationProvider for JSON loading
- Item entity for give/take outcomes

### Provided to v0.2.0c (Reputation & Memory)
- DialogueCondition.ReputationAtLeast (deferred implementation)
- DialogueOutcome.ChangeReputation (deferred implementation)
- DialogueContext for memory conditions

### Provided to v0.2.0d (Companions)
- DialogueOutcome.RecruitCompanion (deferred implementation)
- Dialogue as recruitment trigger

### Provided to v0.3.0 (Quests)
- DialogueCondition.QuestState (deferred implementation)
- DialogueOutcome.StartQuest (deferred implementation)
- DialogueOutcome.AdvanceQuest (deferred implementation)

---

## 16. Future Considerations

### Deferred to v0.2.0c
- **ReputationAtLeast conditions**: Full implementation of reputation checks
- **ChangeReputation outcomes**: Applying reputation changes

### Deferred to v0.2.0d
- **RecruitCompanion outcomes**: Companion recruitment through dialogue

### Deferred to v0.3.0
- **Quest conditions and outcomes**: QuestState, StartQuest, AdvanceQuest

### Deferred to v0.2.2
- **Shop integration**: Opening shop interface from dialogue

### Out of Scope
- **Voice acting/audio**: No audio integration
- **Animated dialogue**: No animation system
- **Procedural dialogue**: All dialogue is authored
- **AI-generated responses**: No dynamic text generation

---

*Document Version: 1.0*
*Last Updated: 2024-01-20*
*Author: Claude Code*
