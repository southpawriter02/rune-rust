# v0.1.5a Design Specification: Puzzle Placement System

**Version:** 0.1.5a
**Phase Name:** Puzzle Placement System
**Parent Version:** v0.1.5 (Procedural Puzzles & Secrets)
**Prerequisites:** v0.1.4d Complete (Environmental Storytelling & Dungeon Evolution)
**Estimated Tests:** ~22 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [PuzzleType Enum](#4-puzzletype-enum)
5. [PuzzleTemplate Entity](#5-puzzletemplate-entity)
6. [PuzzleSolution Value Object](#6-puzzlesolution-value-object)
7. [PuzzleClue Value Object](#7-puzzleclue-value-object)
8. [PuzzleInstance Entity](#8-puzzleinstance-entity)
9. [PuzzlePlacementService](#9-puzzleplacementservice)
10. [PuzzlePlacementContext Record](#10-puzzleplacementcontext-record)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement the puzzle template system and placement logic for procedural puzzle generation during dungeon creation. This phase defines puzzle types, generates solutions, and determines where puzzles are placed in the dungeon based on biome, architecture, and depth. This is **generation-only**—the actual player interaction mechanics (solving puzzles, attempt tracking, success/failure handling) are deferred to v0.4.0 (Interactive Environment & Puzzles).

### 1.2 Current State

| Area | Current State (v0.1.4d) | Target State (v0.1.5a) |
|------|-------------------------|------------------------|
| Puzzle types | Not defined | 6 puzzle types (Sequence, Combination, Riddle, Pattern, Matching, Tile) |
| Puzzle templates | None | JSON-configurable templates with difficulty, biome, and style filtering |
| Solution generation | N/A | Procedural solution generation based on template type |
| Puzzle placement | N/A | Context-aware placement during dungeon generation |
| Clue system | None | Clue templates with varying specificity |
| Difficulty scaling | N/A | Depth-based difficulty scaling |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `PuzzleTemplate`, `PuzzleInstance` |
| **Value Objects** | `PuzzleSolution`, `PuzzleClue` |
| **Enums** | `PuzzleType` |
| **Records** | `PuzzlePlacementContext` |
| **Services** | `PuzzlePlacementService` (with `IPuzzlePlacementService` interface) |
| **Configuration** | `puzzles.json`, `puzzles.schema.json` |
| **Tests** | ~22 new unit tests |

### 1.4 Architectural Significance

This version establishes the **procedural puzzle generation pattern** that will be extended throughout v0.1.5:
- Template-based content definition loaded from JSON
- Context-aware placement using biome, architectural style, and depth
- Weighted random selection with preference bonuses
- Difficulty scaling by dungeon depth
- Solution generation deferred from interaction (generation vs. gameplay separation)
- Foundation for secret rooms (v0.1.5b), traps (v0.1.5c), and treasure vaults (v0.1.5d)

### 1.5 Scope Boundaries

| In Scope (v0.1.5a - Generation) | Out of Scope (Deferred to v0.4.0 - Interaction) |
|--------------------------------|------------------------------------------------|
| PuzzleTemplate definitions | `solve` command |
| PuzzleInstance placement | Attempt tracking |
| PuzzleSolution generation | Success/failure handling |
| PuzzleClue assignment | Reward distribution |
| Difficulty scaling | Player-facing puzzle UI |
| Biome/style filtering | State persistence (solved/unsolved) |

---

## 2. Feature Overview

```
v0.1.5a Puzzle Placement System
├── PuzzleType Enum
│   ├── Sequence (lever order)
│   ├── Combination (lock digits)
│   ├── Riddle (word answer)
│   ├── Pattern (complete pattern)
│   ├── Matching (match elements)
│   └── Tile (arrange blocks)
├── PuzzleTemplate Entity
│   ├── Unique ID and display name
│   ├── Base difficulty (1-10)
│   ├── Depth range (min/max)
│   ├── Biome filtering (allowed biomes)
│   ├── Style filtering (architectural styles)
│   ├── Description template with placeholders
│   ├── Clue templates for hints
│   ├── Solution element pool
│   ├── Solution size range
│   ├── Passage blocking flag
│   ├── Maximum attempts
│   └── Placement weight for selection
├── PuzzleSolution Value Object
│   ├── Ordered elements (for sequence/combination)
│   ├── Single answer (for riddles)
│   └── Generation seed for reproducibility
├── PuzzleClue Value Object
│   ├── Clue text with placeholders
│   ├── Specificity level (0-1)
│   └── Location description
├── PuzzleInstance Entity
│   ├── Unique instance ID
│   ├── Room reference
│   ├── Template reference
│   ├── Generated description
│   ├── Generated solution
│   ├── Assigned clues
│   ├── Effective difficulty (scaled)
│   ├── Maximum attempts
│   ├── Passage blocking flag
│   ├── Blocked direction (if applicable)
│   └── Reward item IDs
├── PuzzlePlacementService
│   ├── GeneratePuzzle(context) - creates puzzle instance
│   ├── ShouldPlacePuzzle(context) - placement decision
│   ├── SelectTemplate(templates, context) - weighted selection
│   ├── GenerateSolution(template, context) - type-specific generation
│   ├── GenerateDescription(template, context) - placeholder replacement
│   └── GenerateClues(template, context, solution) - clue creation
├── PuzzlePlacementContext Record
│   ├── Room ID
│   ├── Dungeon depth
│   ├── Biome ID and name
│   ├── Architectural style ID
│   ├── World seed
│   └── Room type
└── Configuration
    ├── puzzles.json (template definitions)
    └── puzzles.schema.json (validation)
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Room descriptions include puzzle presence (v0.4.0 adds interaction)         │
│  ├── GameView displays puzzle descriptions                                  │
│  ├── Puzzle details shown when examining room                               │
│  └── Clues appear in room/adjacent room descriptions                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  PuzzlePlacementService                                                      │
│  ├── GeneratePuzzle(context)        ├── SelectTemplate(templates, context)  │
│  ├── ShouldPlacePuzzle(context)     ├── GenerateSolution(template, context) │
│  ├── GenerateDescription(...)       └── GenerateClues(...)                  │
│                                                                              │
│  Interfaces:                        Consumed By:                             │
│  └── IPuzzlePlacementService        ├── DungeonGeneratorService             │
│                                     └── VaultGenerationService (v0.1.5d)    │
│                                                                              │
│  Records:                           Dependencies:                            │
│  └── PuzzlePlacementContext         ├── IConfigurationProvider              │
│                                     ├── ISeededRandomService                │
│                                     └── ILogger<PuzzlePlacementService>     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Definitions (IDefinition):     Value Objects:                               │
│  ┌─────────────────────────┐    ┌─────────────────────────┐                 │
│  │ PuzzleTemplate          │    │ PuzzleSolution          │                 │
│  │ ├── Id: string          │    │ ├── Elements: List      │                 │
│  │ ├── Name: string        │    │ ├── Answer: string?     │                 │
│  │ ├── Type: PuzzleType    │    │ └── Seed: int           │                 │
│  │ ├── BaseDifficulty: int │    └─────────────────────────┘                 │
│  │ ├── MinDepth: int       │    ┌─────────────────────────┐                 │
│  │ ├── MaxDepth: int       │    │ PuzzleClue              │                 │
│  │ ├── AllowedBiomes       │    │ ├── Text: string        │                 │
│  │ ├── AllowedStyles       │    │ ├── Specificity: float  │                 │
│  │ ├── DescriptionTemplate │    │ └── Location: string    │                 │
│  │ ├── ClueTemplates       │    └─────────────────────────┘                 │
│  │ ├── SolutionElements    │                                                │
│  │ ├── MinSolutionSize     │    Enums:                                      │
│  │ ├── MaxSolutionSize     │    ┌─────────────────────────┐                 │
│  │ ├── BlocksPassage       │    │ PuzzleType              │                 │
│  │ ├── MaxAttempts         │    │ ├── Sequence            │                 │
│  │ └── PlacementWeight     │    │ ├── Combination         │                 │
│  └─────────────────────────┘    │ ├── Riddle              │                 │
│                                 │ ├── Pattern             │                 │
│  Entities (IEntity):            │ ├── Matching            │                 │
│  ┌─────────────────────────┐    │ └── Tile                │                 │
│  │ PuzzleInstance          │    └─────────────────────────┘                 │
│  │ ├── Id: Guid            │                                                │
│  │ ├── RoomId: Guid        │                                                │
│  │ ├── TemplateId: string  │                                                │
│  │ ├── Description: string │                                                │
│  │ ├── Solution            │                                                │
│  │ ├── Clues: List         │                                                │
│  │ ├── Difficulty: int     │                                                │
│  │ ├── MaxAttempts: int    │                                                │
│  │ ├── BlocksPassage: bool │                                                │
│  │ ├── BlockedDirection?   │                                                │
│  │ └── RewardIds: List     │                                                │
│  └─────────────────────────┘                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetPuzzleTemplates(): IReadOnlyList<PuzzleTemplate>                    │
│  └── Loads and deserializes config/puzzles.json                             │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/puzzles.json                                                    │
│  └── config/schemas/puzzles.schema.json                                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Puzzle Generation Flow

```
┌───────────────────────────────────────────────────────────────┐
│ Dungeon generation creates room with RoomType.Puzzle          │
│ or Treasure/Boss room requiring puzzle lock                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ PuzzlePlacementService.ShouldPlacePuzzle(context)             │
├───────────────────────────────────────────────────────────────┤
│ Checks room type:                                             │
│ ├── RoomType.Puzzle → always true                             │
│ ├── RoomType.Boss → 30% chance                                │
│ ├── RoomType.Treasure → 40% chance                            │
│ └── Others → false                                            │
└───────────────┬───────────────────────────────────────────────┘
                │ (if true)
                ▼
┌───────────────────────────────────────────────────────────────┐
│ PuzzlePlacementService.GeneratePuzzle(context)                │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Filter templates by context                           │
├───────────────────────────────────────────────────────────────┤
│ _configurationProvider.GetPuzzleTemplates()                   │
│     .Where(t => t.IsValidFor(depth, biomeId, styleId))        │
│                                                               │
│ IsValidFor checks:                                            │
│ ├── depth >= MinDepth                                         │
│ ├── depth <= MaxDepth (if MaxDepth > 0)                       │
│ ├── BiomeId in AllowedBiomes (if list not empty)              │
│ └── StyleId in AllowedStyles (if list not empty)              │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Select template (weighted random)                     │
├───────────────────────────────────────────────────────────────┤
│ SelectTemplate(templates, context)                            │
│ ├── Base weight = template.PlacementWeight                    │
│ ├── +50 if biome matches AllowedBiomes                        │
│ ├── +30 if style matches AllowedStyles                        │
│ └── Weighted random selection                                 │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Generate solution based on puzzle type                │
├───────────────────────────────────────────────────────────────┤
│ GenerateSolution(template, context)                           │
│ ├── Sequence: shuffle elements, take random count             │
│ ├── Combination: randomly select elements with repeats        │
│ ├── Riddle: randomly select single answer                     │
│ ├── Pattern: create repeating pattern                         │
│ └── Matching/Tile: similar to sequence                        │
│                                                               │
│ All solutions store generation seed for reproducibility       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: Generate description with placeholders                │
├───────────────────────────────────────────────────────────────┤
│ GenerateDescription(template, context)                        │
│ ├── Replace {biome} with context.BiomeName                    │
│ └── Additional placeholders as needed                         │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 5: Generate clues with solution hints                    │
├───────────────────────────────────────────────────────────────┤
│ GenerateClues(template, context, solution)                    │
│ ├── Select 2-4 clues from ClueTemplates                       │
│ ├── Replace {element} with random solution element            │
│ ├── Replace {position} with element position                  │
│ ├── First clue: vague (specificity = 0.25)                    │
│ └── Subsequent: specific (specificity = 0.75)                 │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 6: Calculate scaled difficulty                           │
├───────────────────────────────────────────────────────────────┤
│ template.GetScaledDifficulty(depth)                           │
│ ├── scaledDifficulty = BaseDifficulty + (depth / 3)           │
│ └── Cap at 10                                                 │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 7: Create PuzzleInstance                                 │
├───────────────────────────────────────────────────────────────┤
│ PuzzleInstance.Create(                                        │
│     roomId: context.RoomId,                                   │
│     template: selectedTemplate,                               │
│     description: generatedDescription,                        │
│     solution: generatedSolution,                              │
│     clues: generatedClues,                                    │
│     difficulty: scaledDifficulty                              │
│ )                                                             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Return PuzzleInstance to dungeon generator                    │
│ Instance stored with room for v0.4.0 interaction              │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Template Filtering Flow

```
┌───────────────────────────────────────────────────────────────┐
│ Context: Depth=5, BiomeId="natural-caves", StyleId="carved"   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Template Pool (from puzzles.json)                             │
├───────────────────────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ lever-sequence                                          │   │
│ │ ├── MinDepth: 1, MaxDepth: 0 (no limit)                │   │
│ │ ├── AllowedBiomes: [] (all)                            │   │
│ │ ├── AllowedStyles: ["carved-halls", "ancient-temple"]  │   │
│ │ └── PlacementWeight: 100                               │   │
│ │     → IsValidFor(5, "natural-caves", "carved")         │   │
│ │     → Style mismatch: EXCLUDED                          │   │
│ └─────────────────────────────────────────────────────────┘   │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ cave-riddle                                             │   │
│ │ ├── MinDepth: 3, MaxDepth: 0 (no limit)                │   │
│ │ ├── AllowedBiomes: ["natural-caves"]                   │   │
│ │ ├── AllowedStyles: [] (all)                            │   │
│ │ └── PlacementWeight: 60                                │   │
│ │     → IsValidFor(5, "natural-caves", "carved")         │   │
│ │     → Biome match, depth OK: INCLUDED                   │   │
│ │     → Weight: 60 + 50 (biome bonus) = 110              │   │
│ └─────────────────────────────────────────────────────────┘   │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ combination-lock                                        │   │
│ │ ├── MinDepth: 2, MaxDepth: 0 (no limit)                │   │
│ │ ├── AllowedBiomes: [] (all)                            │   │
│ │ ├── AllowedStyles: ["carved-halls", "ruined-structures"]│  │
│ │ └── PlacementWeight: 80                                │   │
│ │     → IsValidFor(5, "natural-caves", "carved")         │   │
│ │     → Style mismatch: EXCLUDED                          │   │
│ └─────────────────────────────────────────────────────────┘   │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ symbol-pattern                                          │   │
│ │ ├── MinDepth: 2, MaxDepth: 0 (no limit)                │   │
│ │ ├── AllowedBiomes: [] (all)                            │   │
│ │ ├── AllowedStyles: ["ancient-temple"]                  │   │
│ │ └── PlacementWeight: 70                                │   │
│ │     → IsValidFor(5, "natural-caves", "carved")         │   │
│ │     → Style mismatch: EXCLUDED                          │   │
│ └─────────────────────────────────────────────────────────┘   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Valid Templates: [cave-riddle]                                │
│ Selection: cave-riddle (only option, weight 110)              │
└───────────────────────────────────────────────────────────────┘
```

---

## 4. PuzzleType Enum

### 4.1 Purpose

The `PuzzleType` enum categorizes the types of procedurally generated puzzles. Each type has distinct solution generation logic and presentation style.

### 4.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Enums/PuzzleType.cs`

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of procedurally generated puzzles.
/// </summary>
/// <remarks>
/// Each puzzle type has distinct solution generation and presentation.
/// Interaction mechanics are implemented in v0.4.0.
/// </remarks>
public enum PuzzleType
{
    /// <summary>
    /// Player must complete a sequence in order (e.g., lever order).
    /// </summary>
    /// <remarks>
    /// Solution is an ordered list of elements. Player must activate
    /// elements in the correct order.
    /// </remarks>
    Sequence = 0,

    /// <summary>
    /// Player must enter a combination (e.g., lock digits).
    /// </summary>
    /// <remarks>
    /// Solution is a sequence of values that may repeat.
    /// Order matters but elements are entered all at once.
    /// </remarks>
    Combination = 1,

    /// <summary>
    /// Player must solve a riddle with a word answer.
    /// </summary>
    /// <remarks>
    /// Solution is a single word or phrase.
    /// Player types the answer.
    /// </remarks>
    Riddle = 2,

    /// <summary>
    /// Player must recognize and complete a pattern.
    /// </summary>
    /// <remarks>
    /// Solution is a repeating sequence. Player identifies
    /// the pattern and provides the missing elements.
    /// </remarks>
    Pattern = 3,

    /// <summary>
    /// Player must match symbols or elements.
    /// </summary>
    /// <remarks>
    /// Solution is a set of paired elements.
    /// Similar to memory/concentration games.
    /// </remarks>
    Matching = 4,

    /// <summary>
    /// Player must arrange tiles or blocks.
    /// </summary>
    /// <remarks>
    /// Solution is a specific arrangement of elements.
    /// Player moves/swaps elements to match target.
    /// </remarks>
    Tile = 5
}
```

### 4.4 Type Characteristics Summary

| Type | Solution Format | Player Action | Complexity |
|------|----------------|---------------|------------|
| Sequence | Ordered list | Activate in order | Medium |
| Combination | Value sequence | Enter all values | Low-Medium |
| Riddle | Single word | Type answer | Medium-High |
| Pattern | Repeating list | Complete pattern | Medium |
| Matching | Paired elements | Match pairs | Medium |
| Tile | Arrangement | Move/swap | High |

---

## 5. PuzzleTemplate Entity

### 5.1 Purpose

The `PuzzleTemplate` entity defines a puzzle template loaded from JSON configuration. It specifies the puzzle's characteristics, solution parameters, and placement rules.

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Definitions/PuzzleTemplate.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines a puzzle template for procedural generation.
/// </summary>
/// <remarks>
/// Templates specify puzzle characteristics including type, difficulty,
/// placement rules, and solution parameters. Loaded from puzzles.json.
/// </remarks>
public class PuzzleTemplate : IDefinition
{
    /// <summary>
    /// Gets the unique identifier (e.g., "lever-sequence").
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the puzzle type.
    /// </summary>
    public PuzzleType Type { get; private set; }

    /// <summary>
    /// Gets the base difficulty (1-10).
    /// </summary>
    /// <remarks>
    /// Scaled by depth during placement. Final difficulty
    /// is BaseDifficulty + (depth / 3), capped at 10.
    /// </remarks>
    public int BaseDifficulty { get; private set; }

    /// <summary>
    /// Gets the minimum dungeon depth for this puzzle.
    /// </summary>
    /// <remarks>
    /// Puzzle will not appear above this depth.
    /// </remarks>
    public int MinDepth { get; private set; }

    /// <summary>
    /// Gets the maximum dungeon depth (0 = no limit).
    /// </summary>
    /// <remarks>
    /// Puzzle will not appear below this depth.
    /// Value of 0 means no maximum limit.
    /// </remarks>
    public int MaxDepth { get; private set; }

    /// <summary>
    /// Gets biome IDs this puzzle can appear in (empty = all).
    /// </summary>
    /// <remarks>
    /// Empty list means the puzzle can appear in any biome.
    /// Non-empty list restricts placement to listed biomes.
    /// </remarks>
    public IReadOnlyList<string> AllowedBiomes { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets architectural styles this puzzle fits (empty = all).
    /// </summary>
    /// <remarks>
    /// Empty list means the puzzle fits any architectural style.
    /// Non-empty list restricts placement to listed styles.
    /// </remarks>
    public IReadOnlyList<string> AllowedStyles { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the description template with placeholders.
    /// </summary>
    /// <remarks>
    /// Supports placeholders like {biome} for dynamic text.
    /// </remarks>
    public string DescriptionTemplate { get; private set; } = string.Empty;

    /// <summary>
    /// Gets clue templates for this puzzle type.
    /// </summary>
    /// <remarks>
    /// Templates support {element} and {position} placeholders
    /// filled from the generated solution.
    /// </remarks>
    public IReadOnlyList<string> ClueTemplates { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the minimum solution length/count.
    /// </summary>
    public int MinSolutionSize { get; private set; }

    /// <summary>
    /// Gets the maximum solution length/count.
    /// </summary>
    public int MaxSolutionSize { get; private set; }

    /// <summary>
    /// Gets possible solution elements for this puzzle.
    /// </summary>
    /// <remarks>
    /// For sequences/combinations, elements are selected from this pool.
    /// For riddles, this is the list of possible answers.
    /// </remarks>
    public IReadOnlyList<string> SolutionElements { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether this puzzle blocks passage until solved.
    /// </summary>
    /// <remarks>
    /// If true, one exit from the room is blocked until
    /// the puzzle is solved.
    /// </remarks>
    public bool BlocksPassage { get; private set; }

    /// <summary>
    /// Gets the maximum solve attempts (0 = unlimited).
    /// </summary>
    /// <remarks>
    /// Used in v0.4.0 for attempt tracking.
    /// Value of 0 means unlimited attempts.
    /// </remarks>
    public int MaxAttempts { get; private set; }

    /// <summary>
    /// Gets the placement weight for random selection.
    /// </summary>
    /// <remarks>
    /// Higher weights increase selection probability.
    /// Base weight is modified by biome/style bonuses.
    /// </remarks>
    public int PlacementWeight { get; private set; }

    /// <summary>
    /// Private constructor for JSON deserialization.
    /// </summary>
    private PuzzleTemplate() { }

    /// <summary>
    /// Creates a puzzle template from configuration.
    /// </summary>
    /// <param name="id">Unique identifier.</param>
    /// <param name="name">Display name.</param>
    /// <param name="type">Puzzle type.</param>
    /// <param name="baseDifficulty">Base difficulty (1-10).</param>
    /// <param name="descriptionTemplate">Description template.</param>
    /// <param name="solutionElements">Possible solution elements.</param>
    /// <returns>A new PuzzleTemplate instance.</returns>
    /// <exception cref="ArgumentException">If id or name is null/empty.</exception>
    /// <exception cref="ArgumentOutOfRangeException">If baseDifficulty is not 1-10.</exception>
    public static PuzzleTemplate Create(
        string id,
        string name,
        PuzzleType type,
        int baseDifficulty,
        string descriptionTemplate,
        IEnumerable<string> solutionElements)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentOutOfRangeException.ThrowIfLessThan(baseDifficulty, 1);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(baseDifficulty, 10);

        return new PuzzleTemplate
        {
            Id = id,
            Name = name,
            Type = type,
            BaseDifficulty = baseDifficulty,
            DescriptionTemplate = descriptionTemplate,
            SolutionElements = solutionElements.ToList(),
            MinSolutionSize = 3,
            MaxSolutionSize = 6,
            PlacementWeight = 100
        };
    }

    /// <summary>
    /// Checks if this puzzle is valid for the given context.
    /// </summary>
    /// <param name="depth">The dungeon depth.</param>
    /// <param name="biomeId">The biome ID (null if none).</param>
    /// <param name="styleId">The architectural style ID (null if none).</param>
    /// <returns>True if the puzzle can be placed in this context.</returns>
    public bool IsValidFor(int depth, string? biomeId, string? styleId)
    {
        // Check depth constraints
        if (depth < MinDepth) return false;
        if (MaxDepth > 0 && depth > MaxDepth) return false;

        // Check biome constraints (empty list = all allowed)
        if (AllowedBiomes.Count > 0 && biomeId != null && !AllowedBiomes.Contains(biomeId))
            return false;

        // Check style constraints (empty list = all allowed)
        if (AllowedStyles.Count > 0 && styleId != null && !AllowedStyles.Contains(styleId))
            return false;

        return true;
    }

    /// <summary>
    /// Gets the effective difficulty scaled by depth.
    /// </summary>
    /// <param name="depth">The dungeon depth.</param>
    /// <returns>Scaled difficulty (1-10).</returns>
    public int GetScaledDifficulty(int depth)
    {
        var depthBonus = depth / 3;
        return Math.Min(BaseDifficulty + depthBonus, 10);
    }
}
```

### 5.4 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `string` | Unique identifier | Required |
| `Name` | `string` | Display name | Required |
| `Type` | `PuzzleType` | Puzzle category | Required |
| `BaseDifficulty` | `int` | Base difficulty (1-10) | Required |
| `MinDepth` | `int` | Minimum placement depth | 0 |
| `MaxDepth` | `int` | Maximum placement depth (0=no limit) | 0 |
| `AllowedBiomes` | `IReadOnlyList<string>` | Valid biomes (empty=all) | Empty |
| `AllowedStyles` | `IReadOnlyList<string>` | Valid styles (empty=all) | Empty |
| `DescriptionTemplate` | `string` | Description with placeholders | Required |
| `ClueTemplates` | `IReadOnlyList<string>` | Clue templates | Empty |
| `MinSolutionSize` | `int` | Minimum solution elements | 3 |
| `MaxSolutionSize` | `int` | Maximum solution elements | 6 |
| `SolutionElements` | `IReadOnlyList<string>` | Element pool for solutions | Required |
| `BlocksPassage` | `bool` | Blocks exit until solved | false |
| `MaxAttempts` | `int` | Max solve attempts (0=unlimited) | 0 |
| `PlacementWeight` | `int` | Selection weight | 100 |

---

## 6. PuzzleSolution Value Object

### 6.1 Purpose

The `PuzzleSolution` value object represents a generated puzzle solution. It stores the correct answer for later validation in v0.4.0 while being immutable and seed-reproducible.

### 6.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/PuzzleSolution.cs`

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a generated puzzle solution.
/// </summary>
/// <remarks>
/// Stores the correct answer for later validation in v0.4.0.
/// Solutions are immutable and store the generation seed for reproducibility.
/// </remarks>
public readonly record struct PuzzleSolution
{
    /// <summary>
    /// Gets the ordered solution elements (for sequence/combination puzzles).
    /// </summary>
    /// <remarks>
    /// For Sequence puzzles, order matters.
    /// For Combination puzzles, elements may repeat.
    /// For Pattern puzzles, contains the repeating pattern.
    /// Empty for Riddle puzzles.
    /// </remarks>
    public IReadOnlyList<string> Elements { get; init; }

    /// <summary>
    /// Gets the solution as a single answer (for riddles).
    /// </summary>
    /// <remarks>
    /// Used by Riddle puzzles. Null for other puzzle types.
    /// </remarks>
    public string? Answer { get; init; }

    /// <summary>
    /// Gets the seed used to generate this solution.
    /// </summary>
    /// <remarks>
    /// Stored for reproducibility. Same seed with same template
    /// produces the same solution.
    /// </remarks>
    public int Seed { get; init; }

    /// <summary>
    /// Creates a sequence-based solution.
    /// </summary>
    /// <param name="elements">The ordered solution elements.</param>
    /// <param name="seed">The generation seed.</param>
    /// <returns>A new PuzzleSolution with element-based answer.</returns>
    public static PuzzleSolution FromSequence(IEnumerable<string> elements, int seed)
    {
        return new PuzzleSolution
        {
            Elements = elements.ToList(),
            Answer = null,
            Seed = seed
        };
    }

    /// <summary>
    /// Creates an answer-based solution.
    /// </summary>
    /// <param name="answer">The single-word answer.</param>
    /// <param name="seed">The generation seed.</param>
    /// <returns>A new PuzzleSolution with single answer.</returns>
    public static PuzzleSolution FromAnswer(string answer, int seed)
    {
        return new PuzzleSolution
        {
            Elements = Array.Empty<string>(),
            Answer = answer,
            Seed = seed
        };
    }

    /// <summary>
    /// Gets whether this is an element-based solution.
    /// </summary>
    public bool IsElementBased => Elements.Count > 0;

    /// <summary>
    /// Gets whether this is an answer-based solution.
    /// </summary>
    public bool IsAnswerBased => !string.IsNullOrEmpty(Answer);

    /// <summary>
    /// Gets a string representation of the solution.
    /// </summary>
    public override string ToString()
    {
        if (IsAnswerBased)
            return $"Answer: {Answer} (seed: {Seed})";

        return $"Elements: [{string.Join(", ", Elements)}] (seed: {Seed})";
    }
}
```

### 6.4 Properties Summary

| Property | Type | Description |
|----------|------|-------------|
| `Elements` | `IReadOnlyList<string>` | Ordered elements for sequence/combination |
| `Answer` | `string?` | Single answer for riddles |
| `Seed` | `int` | Generation seed for reproducibility |
| `IsElementBased` | `bool` | True if solution uses elements (computed) |
| `IsAnswerBased` | `bool` | True if solution uses answer (computed) |

---

## 7. PuzzleClue Value Object

### 7.1 Purpose

The `PuzzleClue` value object represents a hint for solving a puzzle. Clues have varying specificity levels and location descriptions indicating where they can be found.

### 7.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/PuzzleClue.cs`

### 7.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a hint for solving a puzzle.
/// </summary>
/// <remarks>
/// Clue discovery mechanics are implemented in v0.4.0.
/// This version only generates and stores clue data.
/// </remarks>
public readonly record struct PuzzleClue
{
    /// <summary>
    /// Gets the clue text.
    /// </summary>
    /// <remarks>
    /// May contain partial solution information based on specificity.
    /// </remarks>
    public string Text { get; init; }

    /// <summary>
    /// Gets how much of the solution this clue reveals (0-1).
    /// </summary>
    /// <remarks>
    /// 0 = very vague hint, 1 = explicit solution reveal.
    /// Typical values: 0.25 (vague), 0.75 (specific).
    /// </remarks>
    public float Specificity { get; init; }

    /// <summary>
    /// Gets the location description where this clue can be found.
    /// </summary>
    /// <remarks>
    /// Used in v0.4.0 to place clue discoveries in the dungeon.
    /// </remarks>
    public string Location { get; init; }

    /// <summary>
    /// Creates a vague clue.
    /// </summary>
    /// <param name="text">The clue text.</param>
    /// <param name="location">Where the clue is found.</param>
    /// <returns>A PuzzleClue with low specificity (0.25).</returns>
    public static PuzzleClue CreateVague(string text, string location)
    {
        return new PuzzleClue
        {
            Text = text,
            Specificity = 0.25f,
            Location = location
        };
    }

    /// <summary>
    /// Creates a specific clue.
    /// </summary>
    /// <param name="text">The clue text.</param>
    /// <param name="location">Where the clue is found.</param>
    /// <returns>A PuzzleClue with high specificity (0.75).</returns>
    public static PuzzleClue CreateSpecific(string text, string location)
    {
        return new PuzzleClue
        {
            Text = text,
            Specificity = 0.75f,
            Location = location
        };
    }

    /// <summary>
    /// Creates a clue with custom specificity.
    /// </summary>
    /// <param name="text">The clue text.</param>
    /// <param name="location">Where the clue is found.</param>
    /// <param name="specificity">How revealing the clue is (0-1).</param>
    /// <returns>A PuzzleClue with the specified specificity.</returns>
    public static PuzzleClue Create(string text, string location, float specificity)
    {
        return new PuzzleClue
        {
            Text = text,
            Specificity = Math.Clamp(specificity, 0f, 1f),
            Location = location
        };
    }

    /// <summary>
    /// Gets whether this is a vague clue (specificity <= 0.3).
    /// </summary>
    public bool IsVague => Specificity <= 0.3f;

    /// <summary>
    /// Gets whether this is a specific clue (specificity >= 0.7).
    /// </summary>
    public bool IsSpecific => Specificity >= 0.7f;

    /// <summary>
    /// Gets a string representation of the clue.
    /// </summary>
    public override string ToString() =>
        $"[{Location}] ({Specificity:P0}): {Text}";
}
```

### 7.4 Properties Summary

| Property | Type | Description |
|----------|------|-------------|
| `Text` | `string` | The clue text |
| `Specificity` | `float` | Revelation level (0-1) |
| `Location` | `string` | Where the clue is found |
| `IsVague` | `bool` | True if specificity <= 0.3 (computed) |
| `IsSpecific` | `bool` | True if specificity >= 0.7 (computed) |

---

## 8. PuzzleInstance Entity

### 8.1 Purpose

The `PuzzleInstance` entity represents a placed puzzle instance in a dungeon room. It contains the generated description, solution, clues, and placement configuration.

### 8.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/PuzzleInstance.cs`

### 8.3 Implementation

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// A placed puzzle instance in a dungeon room.
/// </summary>
/// <remarks>
/// Interaction state (solved, attempts) is managed in v0.4.0.
/// This entity stores the generated puzzle data for placement.
/// </remarks>
public class PuzzleInstance : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the room containing this puzzle.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the template ID used to generate this puzzle.
    /// </summary>
    public string TemplateId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the puzzle description shown to player.
    /// </summary>
    /// <remarks>
    /// Generated from template with placeholders replaced.
    /// </remarks>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the generated solution.
    /// </summary>
    /// <remarks>
    /// Contains either element sequence or single answer
    /// depending on puzzle type.
    /// </remarks>
    public PuzzleSolution Solution { get; private set; }

    /// <summary>
    /// Gets the clues for this puzzle.
    /// </summary>
    /// <remarks>
    /// Clues with varying specificity generated from template.
    /// </remarks>
    public IReadOnlyList<PuzzleClue> Clues { get; private set; } = Array.Empty<PuzzleClue>();

    /// <summary>
    /// Gets the effective difficulty (DC for skill checks in v0.4.0).
    /// </summary>
    /// <remarks>
    /// Scaled from base difficulty by dungeon depth.
    /// </remarks>
    public int Difficulty { get; private set; }

    /// <summary>
    /// Gets the maximum allowed attempts (0 = unlimited).
    /// </summary>
    /// <remarks>
    /// Attempt tracking implemented in v0.4.0.
    /// </remarks>
    public int MaxAttempts { get; private set; }

    /// <summary>
    /// Gets whether the puzzle blocks an exit.
    /// </summary>
    public bool BlocksPassage { get; private set; }

    /// <summary>
    /// Gets the exit direction blocked (if any).
    /// </summary>
    /// <remarks>
    /// Set via SetBlockedDirection after room exit assignment.
    /// </remarks>
    public Direction? BlockedDirection { get; private set; }

    /// <summary>
    /// Gets reward item IDs for solving.
    /// </summary>
    /// <remarks>
    /// Set via SetRewards. Distributed in v0.4.0.
    /// </remarks>
    public IReadOnlyList<string> RewardIds { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private PuzzleInstance() { }

    /// <summary>
    /// Creates a puzzle instance from a template.
    /// </summary>
    /// <param name="roomId">The room containing the puzzle.</param>
    /// <param name="template">The template used for generation.</param>
    /// <param name="description">The generated description.</param>
    /// <param name="solution">The generated solution.</param>
    /// <param name="clues">The generated clues.</param>
    /// <param name="difficulty">The scaled difficulty.</param>
    /// <returns>A new PuzzleInstance.</returns>
    public static PuzzleInstance Create(
        Guid roomId,
        PuzzleTemplate template,
        string description,
        PuzzleSolution solution,
        IEnumerable<PuzzleClue> clues,
        int difficulty)
    {
        return new PuzzleInstance
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            TemplateId = template.Id,
            Description = description,
            Solution = solution,
            Clues = clues.ToList(),
            Difficulty = difficulty,
            MaxAttempts = template.MaxAttempts,
            BlocksPassage = template.BlocksPassage
        };
    }

    /// <summary>
    /// Sets the blocked direction for passage-blocking puzzles.
    /// </summary>
    /// <param name="direction">The direction blocked by this puzzle.</param>
    public void SetBlockedDirection(Direction direction)
    {
        if (!BlocksPassage) return;
        BlockedDirection = direction;
    }

    /// <summary>
    /// Sets the rewards for solving this puzzle.
    /// </summary>
    /// <param name="rewardIds">The reward item IDs.</param>
    public void SetRewards(IEnumerable<string> rewardIds)
    {
        RewardIds = rewardIds.ToList();
    }

    /// <summary>
    /// Gets a string representation of the puzzle instance.
    /// </summary>
    public override string ToString() =>
        $"Puzzle[{TemplateId}] in Room {RoomId} (Difficulty: {Difficulty})";
}
```

### 8.4 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `Guid` | Unique identifier | Generated |
| `RoomId` | `Guid` | Containing room | Required |
| `TemplateId` | `string` | Source template ID | Required |
| `Description` | `string` | Player-facing description | Required |
| `Solution` | `PuzzleSolution` | Generated solution | Required |
| `Clues` | `IReadOnlyList<PuzzleClue>` | Assigned clues | Empty |
| `Difficulty` | `int` | Scaled difficulty | Required |
| `MaxAttempts` | `int` | Max solve attempts (0=unlimited) | From template |
| `BlocksPassage` | `bool` | Blocks an exit | From template |
| `BlockedDirection` | `Direction?` | Which exit is blocked | null |
| `RewardIds` | `IReadOnlyList<string>` | Reward items | Empty |

---

## 9. PuzzlePlacementService

### 9.1 Purpose

The `PuzzlePlacementService` generates and places puzzles during dungeon generation. It handles template selection, solution generation, description creation, and clue assignment.

### 9.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/IPuzzlePlacementService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/PuzzlePlacementService.cs`

### 9.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Application.DTOs;
using RuneAndRust.Domain.Entities;

/// <summary>
/// Service for generating and placing puzzles during dungeon generation.
/// </summary>
/// <remarks>
/// Handles puzzle placement only. Puzzle solving mechanics
/// are implemented in v0.4.0.
/// </remarks>
public interface IPuzzlePlacementService
{
    /// <summary>
    /// Generates a puzzle for the given room context.
    /// </summary>
    /// <param name="context">The placement context with room information.</param>
    /// <returns>A generated puzzle instance, or null if no valid templates.</returns>
    PuzzleInstance? GeneratePuzzle(PuzzlePlacementContext context);

    /// <summary>
    /// Determines if a room should contain a puzzle.
    /// </summary>
    /// <param name="context">The placement context with room information.</param>
    /// <returns>True if a puzzle should be placed.</returns>
    bool ShouldPlacePuzzle(PuzzlePlacementContext context);
}
```

### 9.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.DTOs;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Generates and places puzzles during dungeon generation.
/// </summary>
/// <remarks>
/// Does not handle puzzle solving (see v0.4.0).
/// </remarks>
public class PuzzlePlacementService : IPuzzlePlacementService
{
    private readonly IConfigurationProvider _configurationProvider;
    private readonly ISeededRandomService _randomService;
    private readonly ILogger<PuzzlePlacementService> _logger;

    /// <summary>
    /// Initializes a new instance of PuzzlePlacementService.
    /// </summary>
    /// <param name="configurationProvider">Configuration provider for puzzle templates.</param>
    /// <param name="randomService">Seeded random service for reproducibility.</param>
    /// <param name="logger">Logger for diagnostic output.</param>
    public PuzzlePlacementService(
        IConfigurationProvider configurationProvider,
        ISeededRandomService randomService,
        ILogger<PuzzlePlacementService> logger)
    {
        _configurationProvider = configurationProvider ?? throw new ArgumentNullException(nameof(configurationProvider));
        _randomService = randomService ?? throw new ArgumentNullException(nameof(randomService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public PuzzleInstance? GeneratePuzzle(PuzzlePlacementContext context)
    {
        // Filter templates by context
        var templates = _configurationProvider.GetPuzzleTemplates()
            .Where(t => t.IsValidFor(context.Depth, context.BiomeId, context.ArchitecturalStyleId))
            .ToList();

        if (templates.Count == 0)
        {
            _logger.LogDebug(
                "No valid puzzle templates for depth {Depth}, biome {Biome}, style {Style}",
                context.Depth, context.BiomeId, context.ArchitecturalStyleId);
            return null;
        }

        // Select template using weighted random
        var template = SelectTemplate(templates, context);

        // Generate puzzle components
        var solution = GenerateSolution(template, context);
        var description = GenerateDescription(template, context);
        var clues = GenerateClues(template, context, solution);
        var difficulty = template.GetScaledDifficulty(context.Depth);

        // Create puzzle instance
        var puzzle = PuzzleInstance.Create(
            context.RoomId,
            template,
            description,
            solution,
            clues,
            difficulty);

        _logger.LogInformation(
            "Placed {Type} puzzle '{Template}' in room {RoomId} at depth {Depth} (difficulty: {Difficulty})",
            template.Type, template.Id, context.RoomId, context.Depth, difficulty);

        return puzzle;
    }

    /// <inheritdoc />
    public bool ShouldPlacePuzzle(PuzzlePlacementContext context)
    {
        // Puzzle rooms always get puzzles
        if (context.RoomType == RoomType.Puzzle)
            return true;

        // Boss rooms may have puzzle locks
        if (context.RoomType == RoomType.Boss)
            return _randomService.NextDouble() < 0.3;

        // Treasure rooms may have puzzle locks
        if (context.RoomType == RoomType.Treasure)
            return _randomService.NextDouble() < 0.4;

        return false;
    }

    /// <summary>
    /// Selects a template using weighted random selection.
    /// </summary>
    private PuzzleTemplate SelectTemplate(
        IList<PuzzleTemplate> templates,
        PuzzlePlacementContext context)
    {
        var totalWeight = templates.Sum(t => GetAdjustedWeight(t, context));
        var roll = _randomService.Next(0, totalWeight);
        var cumulative = 0;

        foreach (var template in templates)
        {
            cumulative += GetAdjustedWeight(template, context);
            if (roll < cumulative)
            {
                _logger.LogDebug(
                    "Selected template '{Template}' (weight: {Weight}, roll: {Roll}/{Total})",
                    template.Id, GetAdjustedWeight(template, context), roll, totalWeight);
                return template;
            }
        }

        // Fallback to first template
        return templates[0];
    }

    /// <summary>
    /// Gets the adjusted weight for a template considering context bonuses.
    /// </summary>
    private int GetAdjustedWeight(PuzzleTemplate template, PuzzlePlacementContext context)
    {
        var weight = template.PlacementWeight;

        // Prefer biome-matched puzzles (+50)
        if (template.AllowedBiomes.Count > 0 && context.BiomeId != null)
        {
            if (template.AllowedBiomes.Contains(context.BiomeId))
                weight += 50;
        }

        // Prefer style-matched puzzles (+30)
        if (template.AllowedStyles.Count > 0 && context.ArchitecturalStyleId != null)
        {
            if (template.AllowedStyles.Contains(context.ArchitecturalStyleId))
                weight += 30;
        }

        return weight;
    }

    /// <summary>
    /// Generates a solution based on puzzle type.
    /// </summary>
    private PuzzleSolution GenerateSolution(PuzzleTemplate template, PuzzlePlacementContext context)
    {
        var seed = context.WorldSeed ^ context.RoomId.GetHashCode();

        return template.Type switch
        {
            PuzzleType.Sequence => GenerateSequenceSolution(template, seed),
            PuzzleType.Combination => GenerateCombinationSolution(template, seed),
            PuzzleType.Riddle => GenerateRiddleSolution(template, seed),
            PuzzleType.Pattern => GeneratePatternSolution(template, seed),
            PuzzleType.Matching => GenerateSequenceSolution(template, seed), // Similar to sequence
            PuzzleType.Tile => GenerateSequenceSolution(template, seed), // Similar to sequence
            _ => GenerateSequenceSolution(template, seed)
        };
    }

    /// <summary>
    /// Generates a sequence solution by shuffling elements.
    /// </summary>
    private PuzzleSolution GenerateSequenceSolution(PuzzleTemplate template, int seed)
    {
        var length = _randomService.Next(template.MinSolutionSize, template.MaxSolutionSize + 1);
        var elements = _randomService.Shuffle(template.SolutionElements.ToList())
            .Take(length)
            .ToList();

        _logger.LogDebug("Generated sequence solution: [{Elements}]", string.Join(", ", elements));

        return PuzzleSolution.FromSequence(elements, seed);
    }

    /// <summary>
    /// Generates a combination solution allowing repeats.
    /// </summary>
    private PuzzleSolution GenerateCombinationSolution(PuzzleTemplate template, int seed)
    {
        var length = _randomService.Next(template.MinSolutionSize, template.MaxSolutionSize + 1);
        var elements = Enumerable.Range(0, length)
            .Select(_ => _randomService.SelectRandom(template.SolutionElements))
            .ToList();

        _logger.LogDebug("Generated combination solution: [{Elements}]", string.Join(", ", elements));

        return PuzzleSolution.FromSequence(elements, seed);
    }

    /// <summary>
    /// Generates a riddle solution by selecting a single answer.
    /// </summary>
    private PuzzleSolution GenerateRiddleSolution(PuzzleTemplate template, int seed)
    {
        var answer = _randomService.SelectRandom(template.SolutionElements);

        _logger.LogDebug("Generated riddle solution: {Answer}", answer);

        return PuzzleSolution.FromAnswer(answer, seed);
    }

    /// <summary>
    /// Generates a pattern solution with repetition.
    /// </summary>
    private PuzzleSolution GeneratePatternSolution(PuzzleTemplate template, int seed)
    {
        var patternLength = _randomService.Next(2, 4);
        var pattern = template.SolutionElements.Take(patternLength).ToList();
        var repetitions = _randomService.Next(2, 4);
        var elements = Enumerable.Range(0, repetitions)
            .SelectMany(_ => pattern)
            .ToList();

        _logger.LogDebug(
            "Generated pattern solution: [{Elements}] (pattern: [{Pattern}] x {Reps})",
            string.Join(", ", elements), string.Join(", ", pattern), repetitions);

        return PuzzleSolution.FromSequence(elements, seed);
    }

    /// <summary>
    /// Generates the puzzle description with placeholder replacement.
    /// </summary>
    private string GenerateDescription(PuzzleTemplate template, PuzzlePlacementContext context)
    {
        var description = template.DescriptionTemplate;

        // Replace placeholders
        description = description.Replace("{biome}", context.BiomeName ?? "dungeon");

        return description;
    }

    /// <summary>
    /// Generates clues with solution hints.
    /// </summary>
    private IEnumerable<PuzzleClue> GenerateClues(
        PuzzleTemplate template,
        PuzzlePlacementContext context,
        PuzzleSolution solution)
    {
        var clueCount = _randomService.Next(2, 4);
        var clues = new List<PuzzleClue>();

        for (var i = 0; i < clueCount && i < template.ClueTemplates.Count; i++)
        {
            var clueText = template.ClueTemplates[i];

            // Replace placeholders with solution information
            if (solution.Elements.Count > 0)
            {
                var revealIndex = _randomService.Next(0, solution.Elements.Count);
                clueText = clueText.Replace("{element}", solution.Elements[revealIndex]);
                clueText = clueText.Replace("{position}", (revealIndex + 1).ToString());
            }
            else if (!string.IsNullOrEmpty(solution.Answer))
            {
                // For riddles, hints might reference the answer obliquely
                clueText = clueText.Replace("{element}", solution.Answer[0].ToString());
            }

            var location = $"Nearby wall inscription ({i + 1})";

            // First clue is vague, subsequent clues are more specific
            clues.Add(i == 0
                ? PuzzleClue.CreateVague(clueText, location)
                : PuzzleClue.CreateSpecific(clueText, location));
        }

        _logger.LogDebug("Generated {Count} clues for puzzle", clues.Count);

        return clues;
    }
}
```

---

## 10. PuzzlePlacementContext Record

### 10.1 Purpose

The `PuzzlePlacementContext` record provides context information for puzzle placement decisions, including room details, biome, style, and world seed.

### 10.2 File Location

**File:** `src/Core/RuneAndRust.Application/DTOs/PuzzlePlacementContext.cs`

### 10.3 Implementation

```csharp
namespace RuneAndRust.Application.DTOs;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Context for puzzle placement during dungeon generation.
/// </summary>
/// <remarks>
/// Provides all information needed to select and generate
/// an appropriate puzzle for a room.
/// </remarks>
public record PuzzlePlacementContext
{
    /// <summary>
    /// Gets the room ID for the puzzle.
    /// </summary>
    public required Guid RoomId { get; init; }

    /// <summary>
    /// Gets the dungeon depth (Z coordinate).
    /// </summary>
    /// <remarks>
    /// Used for difficulty scaling and template filtering.
    /// </remarks>
    public required int Depth { get; init; }

    /// <summary>
    /// Gets the biome ID (if any).
    /// </summary>
    /// <remarks>
    /// Used for template filtering. Null if room has no biome.
    /// </remarks>
    public string? BiomeId { get; init; }

    /// <summary>
    /// Gets the biome display name.
    /// </summary>
    /// <remarks>
    /// Used for description placeholder replacement.
    /// </remarks>
    public string? BiomeName { get; init; }

    /// <summary>
    /// Gets the architectural style ID (if any).
    /// </summary>
    /// <remarks>
    /// Used for template filtering. Null if room has no style.
    /// </remarks>
    public string? ArchitecturalStyleId { get; init; }

    /// <summary>
    /// Gets the world seed for reproducibility.
    /// </summary>
    /// <remarks>
    /// Combined with room ID to generate unique but reproducible
    /// puzzle solutions.
    /// </remarks>
    public required int WorldSeed { get; init; }

    /// <summary>
    /// Gets the room type.
    /// </summary>
    /// <remarks>
    /// Used to determine puzzle placement probability.
    /// Puzzle rooms always get puzzles.
    /// </remarks>
    public RoomType? RoomType { get; init; }
}
```

### 10.4 Properties Summary

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `RoomId` | `Guid` | Yes | The room identifier |
| `Depth` | `int` | Yes | Dungeon depth for scaling |
| `BiomeId` | `string?` | No | Biome ID for filtering |
| `BiomeName` | `string?` | No | Biome name for descriptions |
| `ArchitecturalStyleId` | `string?` | No | Style ID for filtering |
| `WorldSeed` | `int` | Yes | Seed for reproducibility |
| `RoomType` | `RoomType?` | No | Room type for probability |

---

## 11. Configuration File Schemas

### 11.1 Puzzle Templates Configuration

**File:** `config/puzzles.json`

```json
{
  "$schema": "schemas/puzzles.schema.json",
  "puzzleTemplates": [
    {
      "id": "lever-sequence",
      "name": "Lever Sequence",
      "type": "Sequence",
      "baseDifficulty": 3,
      "minDepth": 1,
      "maxDepth": 0,
      "allowedBiomes": [],
      "allowedStyles": ["carved-halls", "ancient-temple"],
      "descriptionTemplate": "A row of ancient levers protrudes from the wall. Each is marked with a different symbol.",
      "clueTemplates": [
        "An old inscription reads: 'Begin with {element}'",
        "Scratched into the stone: 'The {position}th lever is {element}'",
        "A faded mural depicts the sequence..."
      ],
      "minSolutionSize": 3,
      "maxSolutionSize": 5,
      "solutionElements": ["sun", "moon", "star", "tree", "wave", "flame"],
      "blocksPassage": true,
      "maxAttempts": 5,
      "placementWeight": 100
    },
    {
      "id": "combination-lock",
      "name": "Combination Lock",
      "type": "Combination",
      "baseDifficulty": 4,
      "minDepth": 2,
      "maxDepth": 0,
      "allowedBiomes": [],
      "allowedStyles": ["carved-halls", "ruined-structures"],
      "descriptionTemplate": "A heavy door is secured by a combination lock with rotating dials.",
      "clueTemplates": [
        "A note reads: 'The first number is {element}'",
        "Worn grooves suggest {element} at position {position}",
        "Someone scratched numbers into the doorframe..."
      ],
      "minSolutionSize": 3,
      "maxSolutionSize": 4,
      "solutionElements": ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "blocksPassage": true,
      "maxAttempts": 0,
      "placementWeight": 80
    },
    {
      "id": "cave-riddle",
      "name": "Cave Spirit's Riddle",
      "type": "Riddle",
      "baseDifficulty": 5,
      "minDepth": 3,
      "maxDepth": 0,
      "allowedBiomes": ["natural-caves"],
      "allowedStyles": [],
      "descriptionTemplate": "A voice echoes from the darkness: 'Answer my riddle to pass...'",
      "clueTemplates": [
        "Think of something found in caves...",
        "The answer relates to this very place...",
        "The spirits whisper hints..."
      ],
      "minSolutionSize": 1,
      "maxSolutionSize": 1,
      "solutionElements": ["stone", "darkness", "water", "echo", "silence", "shadow"],
      "blocksPassage": true,
      "maxAttempts": 3,
      "placementWeight": 60
    },
    {
      "id": "symbol-pattern",
      "name": "Symbol Pattern",
      "type": "Pattern",
      "baseDifficulty": 4,
      "minDepth": 2,
      "maxDepth": 0,
      "allowedBiomes": [],
      "allowedStyles": ["ancient-temple"],
      "descriptionTemplate": "Tiles on the floor display a repeating pattern with some symbols missing.",
      "clueTemplates": [
        "The pattern repeats every few tiles",
        "Notice how {element} appears in the sequence...",
        "The sequence is clear if you look carefully"
      ],
      "minSolutionSize": 4,
      "maxSolutionSize": 8,
      "solutionElements": ["circle", "square", "triangle", "diamond"],
      "blocksPassage": false,
      "maxAttempts": 2,
      "placementWeight": 70
    }
  ]
}
```

### 11.2 JSON Schema

**File:** `config/schemas/puzzles.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "puzzles.schema.json",
  "title": "Puzzle Templates Configuration",
  "description": "Schema for puzzle template definitions",
  "type": "object",
  "required": ["puzzleTemplates"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "puzzleTemplates": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/puzzleTemplate"
      }
    }
  },
  "$defs": {
    "puzzleTemplate": {
      "type": "object",
      "required": [
        "id",
        "name",
        "type",
        "baseDifficulty",
        "descriptionTemplate",
        "solutionElements"
      ],
      "properties": {
        "id": {
          "type": "string",
          "minLength": 1,
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier using lowercase with hyphens"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Display name for the puzzle"
        },
        "type": {
          "type": "string",
          "enum": ["Sequence", "Combination", "Riddle", "Pattern", "Matching", "Tile"],
          "description": "Puzzle type determining solution format"
        },
        "baseDifficulty": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10,
          "description": "Base difficulty before depth scaling"
        },
        "minDepth": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Minimum dungeon depth for placement"
        },
        "maxDepth": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Maximum dungeon depth (0 = no limit)"
        },
        "allowedBiomes": {
          "type": "array",
          "items": { "type": "string" },
          "default": [],
          "description": "Biome IDs where puzzle can appear (empty = all)"
        },
        "allowedStyles": {
          "type": "array",
          "items": { "type": "string" },
          "default": [],
          "description": "Architectural style IDs (empty = all)"
        },
        "descriptionTemplate": {
          "type": "string",
          "minLength": 1,
          "description": "Description with {biome} placeholder support"
        },
        "clueTemplates": {
          "type": "array",
          "items": { "type": "string" },
          "default": [],
          "description": "Clue templates with {element} and {position} placeholders"
        },
        "minSolutionSize": {
          "type": "integer",
          "minimum": 1,
          "default": 3,
          "description": "Minimum solution element count"
        },
        "maxSolutionSize": {
          "type": "integer",
          "minimum": 1,
          "default": 6,
          "description": "Maximum solution element count"
        },
        "solutionElements": {
          "type": "array",
          "items": { "type": "string" },
          "minItems": 1,
          "description": "Pool of elements for solution generation"
        },
        "blocksPassage": {
          "type": "boolean",
          "default": false,
          "description": "Whether puzzle blocks an exit until solved"
        },
        "maxAttempts": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Maximum solve attempts (0 = unlimited)"
        },
        "placementWeight": {
          "type": "integer",
          "minimum": 1,
          "default": 100,
          "description": "Selection weight for random placement"
        }
      }
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `PuzzlePlacementService` | Information | Puzzle placed, template selected |
| `PuzzlePlacementService` | Debug | Template filtering, solution generation, clue generation, weight calculation |
| `PuzzlePlacementService` | Warning | No valid templates, fallback selection |
| `PuzzleTemplate` | Debug | Validation checks, difficulty scaling |

### 12.2 Log Message Examples

```csharp
// Information
_logger.LogInformation(
    "Placed {Type} puzzle '{Template}' in room {RoomId} at depth {Depth} (difficulty: {Difficulty})",
    template.Type, template.Id, context.RoomId, context.Depth, difficulty);

// Debug
_logger.LogDebug(
    "No valid puzzle templates for depth {Depth}, biome {Biome}, style {Style}",
    context.Depth, context.BiomeId, context.ArchitecturalStyleId);

_logger.LogDebug(
    "Selected template '{Template}' (weight: {Weight}, roll: {Roll}/{Total})",
    template.Id, weight, roll, totalWeight);

_logger.LogDebug("Generated sequence solution: [{Elements}]", string.Join(", ", elements));

_logger.LogDebug("Generated {Count} clues for puzzle", clues.Count);

// Warning
_logger.LogWarning(
    "Falling back to first template due to weight calculation issue");
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| PuzzleType enum | ~2 |
| PuzzleTemplate entity | ~4 |
| PuzzleSolution value object | ~3 |
| PuzzleClue value object | ~3 |
| PuzzleInstance entity | ~3 |
| PuzzlePlacementService | ~5 |
| Configuration loading | ~2 |
| **Total** | **~22** |

### 13.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `PuzzleTypeTests.cs` | ~2 | Enum values, count |
| `PuzzleTemplateTests.cs` | ~4 | Create, IsValidFor, GetScaledDifficulty, validation |
| `PuzzleSolutionTests.cs` | ~3 | FromSequence, FromAnswer, properties |
| `PuzzleClueTests.cs` | ~3 | CreateVague, CreateSpecific, Create |
| `PuzzleInstanceTests.cs` | ~3 | Create, SetBlockedDirection, SetRewards |
| `PuzzlePlacementServiceTests.cs` | ~5 | GeneratePuzzle, ShouldPlacePuzzle, template selection, solution generation |
| `PuzzleConfigurationTests.cs` | ~2 | JSON loading, schema validation |

### 13.3 Test Categories

**PuzzleTemplate Tests:**
```csharp
[Test]
public void Create_WithValidParameters_CreatesPuzzleTemplate()

[Test]
public void Create_WithInvalidDifficulty_ThrowsArgumentOutOfRangeException()

[Test]
public void IsValidFor_WhenDepthBelowMinimum_ReturnsFalse()

[Test]
public void GetScaledDifficulty_ScalesWithDepth_CapsAt10()
```

**PuzzlePlacementService Tests:**
```csharp
[Test]
public void GeneratePuzzle_WithValidContext_ReturnsPuzzleInstance()

[Test]
public void GeneratePuzzle_WithNoValidTemplates_ReturnsNull()

[Test]
public void ShouldPlacePuzzle_ForPuzzleRoom_ReturnsTrue()

[Test]
public void SelectTemplate_AppliesBiomeBonus_ToWeight()

[Test]
public void GenerateSolution_ForRiddle_ReturnsAnswerBasedSolution()
```

---

## 14. Use Cases

### UC-001: Generate Puzzle for Puzzle Room

**Actor:** DungeonGeneratorService
**Flow:** Room created with RoomType.Puzzle → DungeonGenerator creates PuzzlePlacementContext → Calls IPuzzlePlacementService.ShouldPlacePuzzle (returns true) → Calls GeneratePuzzle → PuzzleInstance returned and stored with room

### UC-002: Generate Puzzle Lock for Treasure Room

**Actor:** DungeonGeneratorService
**Flow:** Room created with RoomType.Treasure → DungeonGenerator creates context → ShouldPlacePuzzle returns true (40% chance) → GeneratePuzzle creates puzzle with BlocksPassage=true → Puzzle blocks treasure access

### UC-003: Filter Templates by Biome

**Actor:** PuzzlePlacementService
**Flow:** Context has BiomeId="natural-caves" → GetPuzzleTemplates() returns all templates → IsValidFor filters to biome-compatible templates → cave-riddle included (explicitly allowed), others filtered out

### UC-004: Scale Difficulty by Depth

**Actor:** PuzzlePlacementService
**Flow:** Template has BaseDifficulty=4, context.Depth=6 → GetScaledDifficulty(6) calculates 4 + (6/3) = 6 → PuzzleInstance created with Difficulty=6

### UC-005: Generate Sequence Solution

**Actor:** PuzzlePlacementService
**Flow:** Template.Type=Sequence with SolutionElements=["sun","moon","star"] → GenerateSequenceSolution shuffles elements → Takes 3-5 random elements in shuffled order → PuzzleSolution.FromSequence created

### UC-006: Generate Clues with Hints

**Actor:** PuzzlePlacementService
**Flow:** Solution has Elements=["moon","star","sun"] → GenerateClues selects 2-3 templates → Replaces {element} with random solution element → Replaces {position} with element position → Returns vague first clue, specific subsequent clues

---

## 15. Deliverable Checklist

### Domain Layer

- [ ] `PuzzleType.cs` created with 6 enum values
- [ ] `PuzzleTemplate.cs` created with IDefinition
- [ ] `PuzzleSolution.cs` created as value object
- [ ] `PuzzleClue.cs` created as value object
- [ ] `PuzzleInstance.cs` created with IEntity

### Application Layer

- [ ] `IPuzzlePlacementService.cs` created
- [ ] `PuzzlePlacementService.cs` created
- [ ] `PuzzlePlacementContext.cs` created as record

### Infrastructure Layer

- [ ] `IConfigurationProvider.cs` updated with GetPuzzleTemplates()
- [ ] `JsonConfigurationProvider.cs` updated to load puzzle templates

### Configuration Files

- [ ] `config/puzzles.json` created with 4 template definitions
- [ ] `config/schemas/puzzles.schema.json` created

### Testing

- [ ] `PuzzleTypeTests.cs` created (~2 tests)
- [ ] `PuzzleTemplateTests.cs` created (~4 tests)
- [ ] `PuzzleSolutionTests.cs` created (~3 tests)
- [ ] `PuzzleClueTests.cs` created (~3 tests)
- [ ] `PuzzleInstanceTests.cs` created (~3 tests)
- [ ] `PuzzlePlacementServiceTests.cs` created (~5 tests)
- [ ] `PuzzleConfigurationTests.cs` created (~2 tests)
- [ ] All ~22 tests passing

### Documentation

- [ ] XML documentation on all public members
- [ ] Code follows .editorconfig conventions

---

## 16. Acceptance Criteria

### Functional

- [ ] PuzzleType enum contains 6 types (Sequence, Combination, Riddle, Pattern, Matching, Tile)
- [ ] PuzzleTemplate loads from `puzzles.json` configuration
- [ ] PuzzleTemplate.IsValidFor correctly filters by depth, biome, and style
- [ ] PuzzleTemplate.GetScaledDifficulty returns BaseDifficulty + (depth/3), capped at 10
- [ ] PuzzleSolution.FromSequence creates element-based solution
- [ ] PuzzleSolution.FromAnswer creates answer-based solution
- [ ] PuzzleClue.CreateVague creates clue with specificity 0.25
- [ ] PuzzleClue.CreateSpecific creates clue with specificity 0.75
- [ ] PuzzleInstance.Create assembles all puzzle components
- [ ] PuzzlePlacementService.ShouldPlacePuzzle returns true for RoomType.Puzzle
- [ ] PuzzlePlacementService.ShouldPlacePuzzle returns true ~30% for RoomType.Boss
- [ ] PuzzlePlacementService.ShouldPlacePuzzle returns true ~40% for RoomType.Treasure
- [ ] PuzzlePlacementService.GeneratePuzzle returns null when no valid templates
- [ ] PuzzlePlacementService.GeneratePuzzle applies biome weight bonus (+50)
- [ ] PuzzlePlacementService.GeneratePuzzle applies style weight bonus (+30)
- [ ] Solution generation varies by puzzle type (Sequence, Combination, Riddle, Pattern)
- [ ] Clue generation replaces {element} and {position} placeholders

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~22 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on public members
- [ ] Code follows .editorconfig conventions
- [ ] No hardcoded puzzle data outside configuration

---

## 17. Dependencies

### 17.1 Prerequisites (v0.1.4d)

| Component | Purpose for v0.1.5a |
|-----------|---------------------|
| `Room` entity | Target for puzzle placement |
| `RoomType` enum | Determines placement probability |
| `Direction` enum | For blocked exit direction |
| `BiomeDefinition` | Biome ID for template filtering |
| `ArchitecturalStyle` | Style ID for template filtering |
| `IConfigurationProvider` | Pattern for loading puzzle templates |
| `ISeededRandomService` | Reproducible random for solution generation |

### 17.2 Provides to Future Phases

| Component | Used By |
|-----------|---------|
| `PuzzleTemplate` | v0.1.5d (VaultGenerationService puzzle locks) |
| `PuzzleInstance` | v0.1.5d (vault puzzle integration), v0.4.0 (interaction) |
| `PuzzlePlacementService` | v0.1.5d (VaultGenerationService) |
| `PuzzlePlacementContext` | v0.1.5d (vault context) |
| `IPuzzlePlacementService` | v0.1.5d, v0.4.0 |

### 17.3 Dependency Diagram

```
v0.1.4d (Environmental Storytelling & Dungeon Evolution)
    │
    ├── Room entity ─────────────────────────┐
    ├── RoomType enum ───────────────────────┤
    ├── Direction enum ──────────────────────┤
    ├── BiomeDefinition ─────────────────────┤
    ├── ArchitecturalStyle ──────────────────┤
    ├── IConfigurationProvider ──────────────┤
    └── ISeededRandomService ────────────────┘
                                             │
                                             ▼
v0.1.5a (Puzzle Placement System)
    │
    ├── PuzzleType ──────────────────────────────────────────────┐
    ├── PuzzleTemplate ──────────────────────────────────────────┤
    ├── PuzzleSolution ──────────────────────────────────────────┤
    ├── PuzzleClue ──────────────────────────────────────────────┤
    ├── PuzzleInstance ──────────────────────────────────────────┤
    ├── PuzzlePlacementContext ──────────────────────────────────┤
    └── IPuzzlePlacementService ─────────────────────────────────┘
                                                                 │
                    ┌────────────────────────────────────────────┤
                    │                                            │
                    ▼                                            ▼
        v0.1.5b (Secret Room Generation)            v0.1.5d (Treasure Vault Generation)
                    │                                            │
                    │         ┌──────────────────────────────────┘
                    │         │
                    ▼         ▼
        v0.1.5c (Trap Placement System)
                              │
                              ▼
        v0.4.0 (Interactive Environment & Puzzles)
            │
            └── Implements: solve command, attempt tracking,
                success/failure handling, reward distribution,
                state persistence (solved/unsolved)
```

---

## 18. Future Considerations

### 18.1 Deferred to v0.1.5b

- **SecretRoomTemplate** — Hidden area patterns
- **HiddenPassage** — Passage configuration connecting secret rooms
- **SecretPlacementService** — Secret room generation logic

### 18.2 Deferred to v0.1.5c

- **TrapDefinition** — Trap type configurations
- **TrapInstance** — Placed trap configuration
- **TrapPlacementService** — Trap placement logic

### 18.3 Deferred to v0.1.5d

- **TreasureRoomTemplate** — Vault designs
- **GuardianAssignment** — Guardian configuration
- **VaultGenerationService** — Integration with PuzzlePlacementService for puzzle-locked vaults

### 18.4 Deferred to v0.4.0 (Interaction)

- **Solve command** — Player-facing puzzle solving
- **Attempt tracking** — Counting solve attempts against MaxAttempts
- **Success/failure handling** — Consequences for solving or failing
- **Reward distribution** — Giving rewards when puzzles are solved
- **State persistence** — Tracking solved/unsolved state across sessions
- **Clue discovery mechanics** — Finding and revealing clues

### 18.5 Out of Scope (Future Versions)

- **Dynamic puzzle modification** — Puzzles that change based on player actions
- **Multi-room puzzles** — Puzzles spanning multiple rooms
- **Cooperative puzzles** — Puzzles requiring multiple players
- **Timed puzzles** — Puzzles with time limits

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
