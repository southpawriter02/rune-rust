# v0.3.11: The Archivist (Documentation & Help)

> **Status:** Planned
> **Milestone:** 4.6 - Documentation & Help
> **Theme:** Auto-generated documentation, reflection-based codex

## Overview

This milestone bridges the gap between static game data and player understanding. It introduces a Dynamic Knowledge Engine that reads the game's own code structure (Reflection) to populate the "Field Guide" and "Bestiary" automatically, ensuring the in-game documentation never drifts from the actual mechanics.

To manage the complexity of runtime reflection and external file generation, this version is split into two sub-versions:

| Phase | Codename | Focus |
|-------|----------|-------|
| A | The Living Guide | In-Game Wiki - Runtime generation of Field Guide entries from C# attributes |
| B | The Developer's Handbook | External Tools - CLI tools to generate Markdown documentation from code |

---

## Phase A: The Living Guide (In-Game Wiki)

**Goal:** Implement LibraryService to reflectively scan assemblies for types marked with `[GameDocument]`, auto-generating Codex and Field Guide entries. This ensures that if a developer adds a new Status Effect or Item, it automatically appears in the Journal without manual data entry.

### 1. Architecture & Data Flow

- **Metadata:** Use C# Attributes (`[GameDocument]`, `[FieldGuideEntry]`) to tag Enums, Entities, and Services with lore and mechanical descriptions.
- **Extraction:** On startup (async), LibraryService scans the RuneAndRust.Core assembly.
- **Conversion:** The service converts these types into transient CodexEntry objects.
- **Injection:** These transient entries are injected into the ICodexEntryRepository cache (in-memory only), making them viewable in the UI alongside database-persisted lore.

### 2. Logic Decision Trees

#### A. Dynamic Entry Generation Logic

**Input:** Type (e.g., `StatusEffectType.Bleeding`)

1. **Check Attribute:** Does the member have `[GameDocument(Title, Description)]`?
   - No: Skip.
   - Yes: Extract Title, Description, and Category (e.g., "Mechanics").
2. **Determine Unlock Status:**
   - Default: Unlocked immediately (Field Guide).
   - Conditional: Check DiscoveryCondition (e.g., "Has experienced Bleeding").
3. **Construct Entry:** Create CodexEntry object (ID = Deterministic GUID based on Type Name).
4. **Cache:** Add to `_transientEntries` dictionary.

#### B. Journal Query Logic (Extension)

**Input:** `JournalService.GetEntriesAsync(Category)`

1. **Fetch DB:** Retrieve persistent entries from database (Lore, Plot).
2. **Fetch System:** Retrieve transient entries from LibraryService (Mechanics, Statuses).
3. **Merge:** Combine lists.
4. **Sort:** Alphabetical by Title.
5. **Output:** ViewModel list.

### 3. Code Implementation

#### A. Core Layer (Attributes)

**File:** `RuneAndRust.Core/Attributes/GameDocumentAttribute.cs`

```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Field)]
public class GameDocumentAttribute : Attribute
{
    public string Title { get; }
    public string Description { get; }
    public EntryCategory Category { get; }

    public GameDocumentAttribute(string title, string description, EntryCategory category = EntryCategory.FieldGuide)
    {
        Title = title;
        Description = description;
        Category = category;
    }
}
```

#### B. Core Layer (Enum Decorator Example)

**File:** `RuneAndRust.Core/Enums/StatusEffectType.cs`

```csharp
public enum StatusEffectType
{
    [GameDocument("Bleeding", "A physical affliction causing damage over time...", EntryCategory.FieldGuide)]
    Bleeding = 0,
    // ...
}
```

#### C. Engine Layer (Service)

**File:** `RuneAndRust.Engine/Services/LibraryService.cs`

```csharp
public class LibraryService : ILibraryService
{
    public IEnumerable<CodexEntry> GenerateSystemEntries()
    {
        var entries = new List<CodexEntry>();
        // Reflection logic to scan Core assembly
        // Convert attributes to CodexEntry objects
        return entries;
    }
}
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Library | Scan Start | Info | "Starting dynamic documentation scan." | - |
| Library | Entry Found | Debug | "Generated system entry: {Title} ({Category})" | Title, Category |
| Library | Duplicate | Warning | "Duplicate system entry ID for {Title}. Skipping." | Title |

### 5. Testing Strategy

- **Unit Tests (LibraryServiceTests.cs):**
  - `Generate_FindsAttributedEnums`: Create a test enum with attributes, verify Service returns correct CodexEntry.
  - `Generate_IgnoresUndocumented`: Verify members without attributes are skipped.
  - `Generate_DeterministicIDs`: Verify the same enum always generates the same GUID.

### 6. Deliverable Checklist

- [ ] Core: Define GameDocumentAttribute.
- [ ] Engine: Implement LibraryService with Reflection logic.
- [ ] Data: Annotate StatusEffectType, Attribute, and ItemType enums with attributes.
- [ ] Engine: Update JournalService to merge LibraryService results with DB results.
- [ ] UI: Verify "Field Guide" tab populates with game mechanics.

---

## Phase B: The Developer's Handbook (External Docs)

**Goal:** Implement a CLI command (`docgen`) that exports the internal GameDocument data into physical Markdown files in the `/docs` directory. This ensures the external documentation (GitHub wiki/docs folder) stays synchronized with the code.

### 1. Architecture & Data Flow

- **Trigger:** Developer runs `dotnet run -- docgen` in the Terminal project.
- **Processing:** Reuses LibraryService (v0.3.11a) to gather data.
- **Generation:** DocGenService formats the data into Markdown tables and text.
- **Output:** Writes/Overwrites files in `docs/generated/`.

### 2. Workflows

#### A. The Documentation Pipeline

1. **Extract:** Call `LibraryService.GetAllEntries()`.
2. **Group:** Group entries by Category (FieldGuide, Bestiary, etc.).
3. **Format:**
   - Create Header (`# Auto-Generated Field Guide`).
   - Iterate Groups. Create Subheaders (`## Status Effects`).
   - Create Table (`| Name | Description |`).
4. **Write:** Save to `docs/generated/field-guide.md`.

### 3. Code Implementation

#### A. Engine Layer (Generator)

**File:** `RuneAndRust.Engine/Services/DocGenService.cs`

```csharp
public async Task GenerateMarkdownDocsAsync(string outputPath)
{
    var entries = _libraryService.GenerateSystemEntries();
    var sb = new StringBuilder();
    sb.AppendLine("# Auto-Generated Field Guide");
    // ... formatting logic ...
    await File.WriteAllTextAsync(Path.Combine(outputPath, "field-guide.md"), sb.ToString());
}
```

#### B. Terminal Layer (Command)

**File:** `RuneAndRust.Terminal/Program.cs` (Argument Parsing)

```csharp
if (args.Contains("docgen"))
{
    var generator = host.Services.GetRequiredService<DocGenService>();
    await generator.GenerateMarkdownDocsAsync("./docs/generated");
    return; // Exit after generation
}
```

### 4. Testing Strategy

- **Integration Test:**
  - Run DocGenService.
  - Assert file exists at path.
  - Assert file content contains known strings (e.g., "Bleeding").

### 5. Deliverable Checklist

- [ ] Engine: Implement DocGenService.
- [ ] Terminal: Add CLI argument parsing for docgen.
- [ ] Docs: Add `.gitignore` entry for `docs/generated/` (optional, if we don't want auto-docs in repo, but usually we do).

---

## Draft Changelog (v0.3.11)

```markdown
# v0.3.11 Changelog: The Archivist
**Release Date:** 2026-01-05

## Summary
This release implements the **Dynamic Knowledge Engine**, bridging the gap between code and documentation. The "Field Guide" in the Journal is now auto-populated from the game's source code, ensuring player information is never out of date. Additionally, a new developer tool allows exporting this data to external Markdown files.

## New Features
*   **The Living Guide:** The Journal's "Field Guide" tab now automatically lists all Status Effects, Attributes, and Item Types defined in the code.
*   **DocGen Tool:** Developers can run `dotnet run -- docgen` to update project documentation automatically.

## Technical Changes
*   Added `[GameDocument]` attribute for tagging enums and classes.
*   Implemented `LibraryService` using System.Reflection.
*   Updated `JournalService` to merge static DB entries with dynamic code entries.
```

---

## v0.3.11a: The Living Guide (In-Game Wiki) - Detailed Specification

Here is the comprehensive implementation plan for v0.3.11a: The Living Guide (In-Game Wiki).

This version implements the Dynamic Knowledge Engine, a system that uses C# Reflection to generate in-game documentation directly from the source code. This ensures the "Field Guide" is always synchronized with the actual game mechanics, eliminating the need to manually update lore text when code changes.

**Goal:** Implement LibraryService to scan the RuneAndRust.Core assembly for types and members decorated with `[GameDocument]`, convert them into transient CodexEntry objects, and merge them into the JournalService for display.

### 1. Architecture & Data Flow

**The Reflection Pipeline:**

1. **Startup:** GameService initializes.
2. **Scan:** LibraryService scans specific Enums (StatusEffectType, Attribute, BiomeType) and Classes using System.Reflection.
3. **Extraction:**
   - Locate members with `[GameDocument]`.
   - Extract Title, Description, Category.
   - Generate a deterministic GUID based on the Type and Member name.
4. **Instantiation:** Create transient CodexEntry objects (not saved to DB).
5. **Aggregation:** JournalService calls `LibraryService.GetEntries()` and merges these results with the database-persisted Lore entries when building the Journal UI.

### 2. Logic Decision Trees

#### A. Reflection Scan Logic

**Input:** Assembly to Scan

1. **Iterate Types:** Loop through all Enums and Classes in RuneAndRust.Core.
2. **Member Check:** For each member (Enum Value or Property):
   - Does it have `[GameDocument]` attribute?
     - No: Skip.
     - Yes: Proceed.
3. **Construct Entry:**
   - ID = UUID5(Namespace + TypeName + MemberName).
   - Category = Attribute.Category (e.g., "Mechanics", "Bestiary").
   - Title = Attribute.Title.
   - Text = Attribute.Description.
4. **Filter Secrets:**
   - Is `Attribute.IsSecret` true?
     - Yes: Mark entry as "Locked" (requires specific discovery trigger).
     - No: Mark entry as "Unlocked" (default Field Guide knowledge).

#### B. Journal Merge Logic

**Input:** `JournalService.GetDiscoveredEntriesAsync`

1. **Fetch DB:** Retrieve persistent entries from CodexEntryRepository.
2. **Fetch Code:** Retrieve transient entries from LibraryService.
3. **Merge:** Combined List = DB List + Code List.
4. **Sort:** Order by Category, then Title.
5. **Output:** Return to JournalScreenRenderer.

### 3. Code Implementation

#### A. Core Layer (Attribute Definition)

**File:** `RuneAndRust.Core/Attributes/GameDocumentAttribute.cs`

```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Field)]
public class GameDocumentAttribute : Attribute
{
    public string Title { get; }
    public string Description { get; }
    public EntryCategory Category { get; }
    public bool IsSecret { get; }

    public GameDocumentAttribute(
        string title,
        string description,
        EntryCategory category = EntryCategory.FieldGuide,
        bool isSecret = false)
    {
        Title = title;
        Description = description;
        Category = category;
        IsSecret = isSecret;
    }
}
```

#### B. Core Layer (Annotated Enum Example)

**File:** `RuneAndRust.Core/Enums/StatusEffectType.cs`

```csharp
public enum StatusEffectType
{
    [GameDocument(
        "Bleeding",
        "A physical affliction causing damage over time. Ignores Armor Soak. Cured by Bandages.",
        EntryCategory.FieldGuide)]
    Bleeding = 0,

    [GameDocument(
        "Corroded",
        "Acidic degradation of armor. Reduces Soak by 2 per stack. Cured by Alchemical Neutralizer.",
        EntryCategory.FieldGuide)]
    Corroded = 1
}
```

#### C. Engine Layer (Library Service)

**File:** `RuneAndRust.Engine/Services/LibraryService.cs`

```csharp
public class LibraryService : ILibraryService
{
    private readonly ILogger _logger;
    private List<CodexEntry> _cachedEntries;

    public IEnumerable<CodexEntry> GetSystemEntries()
    {
        if (_cachedEntries != null) return _cachedEntries;

        _cachedEntries = new List<CodexEntry>();
        var assembly = typeof(GameDocumentAttribute).Assembly;

        foreach (var type in assembly.GetTypes())
        {
            foreach (var member in type.GetMembers())
            {
                var attr = member.GetCustomAttribute<GameDocumentAttribute>();
                if (attr == null) continue;

                _cachedEntries.Add(new CodexEntry
                {
                    Id = GenerateDeterministicId(type.Name, member.Name),
                    Title = attr.Title,
                    Category = attr.Category,
                    FullText = attr.Description,
                    TotalFragments = 1, // System entries are always complete
                    // Unlock logic handled here if IsSecret is true
                });
            }
        }

        _logger.LogInformation("[Library] Generated {Count} system entries via reflection.", _cachedEntries.Count);
        return _cachedEntries;
    }

    private Guid GenerateDeterministicId(string type, string member)
    {
        // Simple hash generation for stable IDs across sessions
        var input = $"{type}:{member}";
        using var md5 = System.Security.Cryptography.MD5.Create();
        var hash = md5.ComputeHash(System.Text.Encoding.UTF8.GetBytes(input));
        return new Guid(hash);
    }
}
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Library | Scan Start | Trace | "[Library] Starting reflection scan of assembly {Assembly}." | Assembly |
| Library | Entry Gen | Trace | "[Library] Generated entry: {Title} ({Category})." | Title, Category |
| Library | Cache | Debug | "[Library] Caching {Count} system entries." | Count |
| Journal | Merge | Debug | "[Journal] Merged {DbCount} DB entries with {SysCount} System entries." | DbCount, SysCount |

### 5. Testing Strategy

#### Unit Tests (LibraryServiceTests.cs)

- **Discovery:**
  - Create a dummy enum with `[GameDocument]`.
  - Call `GetSystemEntries()`.
  - Assert result contains the dummy entry with correct Title/Description.
- **Stability:**
  - Call `GetSystemEntries()` twice.
  - Assert the ID returned is identical (Deterministic GUID).
- **Filtering:**
  - Create enum members without attributes.
  - Assert they do NOT appear in the list.

#### Integration Tests

- **UI Display:**
  - Mock JournalService.
  - Inject LibraryService.
  - Verify "Field Guide" tab lists "Bleeding" (from Enum) alongside standard entries.

### 6. Deliverable Checklist

- **Core:**
  - [ ] Define GameDocumentAttribute.
  - [ ] Annotate StatusEffectType enum.
  - [ ] Annotate Attribute enum (Might, Wits, etc.).
  - [ ] Annotate BiomeType enum.
- **Engine:**
  - [ ] Implement LibraryService with reflection logic.
  - [ ] Implement GenerateDeterministicId helper.
  - [ ] Update JournalService to inject ILibraryService and merge lists.
- **Tests:**
  - [ ] Verify reflection finds annotated types.
  - [ ] Verify descriptions match attribute text.

### 7. Draft Changelog (v0.3.11a)

```markdown
# v0.3.11a Changelog: The Living Guide
**Release Date:** 2026-01-05

## Summary
This release implements the **Dynamic Knowledge Engine**, allowing the game's documentation to auto-generate from the source code. The Journal's "Field Guide" tab now populates automatically with accurate data on Status Effects, Attributes, and Biomes, ensuring the in-game wiki never drifts from the actual mechanics.

## New Features
*   **Auto-Doc System:** The game now scans its own code at startup to generate Field Guide entries.
*   **Updated Field Guide:** Added auto-generated entries for all Status Effects (Bleeding, Stunned, etc.) and Core Attributes.

## Technical Changes
*   Added `[GameDocument]` attribute for tagging code elements.
*   Implemented `LibraryService` using System.Reflection.
*   Updated `JournalService` to aggregate dynamic and static lore.
```

---

## v0.3.11b: The Developer's Handbook (External Tools) - Detailed Specification

This version leverages the reflection work from v0.3.11a to create a pipeline that exports game data into static Markdown files. This ensures that the external wiki/documentation is always 1:1 consistent with the codebase.

**Goal:** Implement the DocGenService and a CLI command (`--docgen`) that utilizes LibraryService to serialize all `[GameDocument]` entities into formatted Markdown tables in the `/docs` directory.

### 1. Architecture & Data Flow

**The Documentation Pipeline:**

1. **Trigger:** Developer runs `dotnet run --project RuneAndRust.Terminal -- --docgen`.
2. **Detection:** Program.cs detects the `--docgen` argument.
3. **Extraction:** DocGenService calls `LibraryService.GetSystemEntries()`.
4. **Transformation:**
   - Group entries by EntryCategory.
   - Convert CodexEntry objects into Markdown Table rows.
5. **Output:**
   - Ensure output directory exists (`docs/generated`).
   - Write `field-guide.md`, `bestiary-data.md`, etc.
6. **Termination:** Application exits immediately (does not start game loop).

### 2. Logic Decision Trees

#### A. Generation Logic

**Input:** `List<CodexEntry>`

1. **Group Data:** Sort entries by Category.
2. **Iterate Categories:**
   - Create StringBuilder.
   - Append Header: `# {Category} Reference`.
   - Append Table Header: `| Name | Description | ID |`.
   - Iterate Entries:
     - Append Row: `| {Title} | {Text} | {Id} |`.
   - Write File: Save to `docs/generated/{category}.md`.
3. **Index Generation:** Create a README.md linking to all generated files.

#### B. CLI Interception Logic

**Input:** `args[]`

1. **Check:** Does args contain `"--docgen"`?
   - No: Proceed to `GameService.StartAsync()`.
   - Yes:
     1. Resolve DocGenService from DI.
     2. Execute `GenerateAllAsync()`.
     3. `Environment.Exit(0)`.

### 3. Deliverable Checklist

- **Engine:**
  - [ ] Implement DocGenService.
  - [ ] Implement Markdown formatting helpers (Table builder).
- **Terminal:**
  - [ ] Modify Program.cs to handle command-line arguments.
  - [ ] Register DocGenService in DI container.
- **Project:**
  - [ ] Create `docs/generated/` folder structure (gitkeep).
- **Tests:**
  - [ ] DocGen_CreatesFiles.
  - [ ] DocGen_ContentMatchesReflection.

### 4. Code Implementation

#### A. Engine Layer (Service)

**File:** `RuneAndRust.Engine/Services/DocGenService.cs`

```csharp
public class DocGenService
{
    private readonly ILibraryService _libraryService;
    private readonly ILogger _logger;

    public DocGenService(ILibraryService libraryService, ILogger logger)
    {
        _libraryService = libraryService;
        _logger = logger;
    }

    public async Task GenerateDocsAsync(string outputPath)
    {
        _logger.LogInformation("[DocGen] Starting documentation generation...");

        var entries = _libraryService.GetSystemEntries();
        var grouped = entries.GroupBy(e => e.Category);

        Directory.CreateDirectory(outputPath);

        foreach (var group in grouped)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"# Auto-Generated: {group.Key}");
            sb.AppendLine();
            sb.AppendLine("| Name | Description |");
            sb.AppendLine("| --- | --- |");

            foreach (var entry in group.OrderBy(e => e.Title))
            {
                // Escape pipes to prevent table breakage
                var safeDesc = entry.FullText.Replace("|", "\\|");
                sb.AppendLine($"| **{entry.Title}** | {safeDesc} |");
            }

            var filename = Path.Combine(outputPath, $"{group.Key.ToString().ToLower()}.md");
            await File.WriteAllTextAsync(filename, sb.ToString());
            _logger.LogInformation($"[DocGen] Wrote {filename} ({group.Count()} entries)");
        }

        _logger.LogInformation("[DocGen] Generation complete.");
    }
}
```

#### B. Terminal Layer (Entry Point)

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// ... DI setup ...

var app = host.Services.GetRequiredService<GameService>();

// CLI Argument Check
if (args.Contains("--docgen"))
{
    var docGen = host.Services.GetRequiredService<DocGenService>();
    // Output to solution root docs folder
    await docGen.GenerateDocsAsync("../../../docs/generated");
    return; // Exit without starting game
}

// Normal Startup
await app.StartAsync();
```

### 5. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| DocGen | Start | Info | "[DocGen] Starting generation to {Path}." | Path |
| DocGen | File Write | Info | "[DocGen] Wrote {Filename} ({Count} entries)." | Filename, Count |
| DocGen | Complete | Info | "[DocGen] Completed successfully." | - |
| DocGen | Error | Error | "[DocGen] Failed to write file: {Message}" | Message |

### 6. Testing Strategy

#### Integration Test (DocGenIntegrationTests.cs)

- **File_Creation:**
  - Arrange: Define a temporary output path.
  - Act: Call `GenerateDocsAsync(tempPath)`.
  - Assert: `Directory.GetFiles(tempPath)` is not empty.
- **Content_Validation:**
  - Arrange: Create a test Enum with `[GameDocument("TestItem", "TestDesc")]`.
  - Act: Run generation.
  - Assert: Read generated file; verify string `"| TestItem | TestDesc |"` exists.

### 7. Draft Changelog (v0.3.11b)

```markdown
# v0.3.11b Changelog: The Developer's Handbook
**Release Date:** 2026-01-05

## Summary
This release introduces the `docgen` CLI tool, automating the creation of external documentation. Developers can now run a single command to export all in-game entities, status effects, and mechanics into formatted Markdown files, ensuring the wiki stays synchronized with the code.

## New Features
*   **DocGen Tool:** Run with `--docgen` argument to generate documentation.
*   **Auto-Markdown:** Converts `[GameDocument]` attributes into Markdown tables.
*   **Categorized Output:** Automatically organizes files by EntryCategory (Mechanics, Bestiary, etc.).

## Technical Changes
*   Implemented `DocGenService` in Engine layer.
*   Updated `Program.cs` to intercept CLI arguments.
*   Added `docs/generated/` to project structure.
```
