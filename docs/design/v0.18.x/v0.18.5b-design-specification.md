# v0.18.5b Design Specification: Damage Integration

**Version:** 0.18.5b
**Parent:** v0.18.5 (Resource Integration / Trauma Economy Integration)
**Prerequisites:** v0.18.5a (TraumaEconomyState), All v0.18.0-4
**Status:** Design Complete
**Estimated Unit Tests:** ~5

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [DamageIntegrationResult Value Object](#5-damageintegrationresult-value-object)
6. [UnifiedDamageHandler Service](#6-unifieddamagehandler-service)
7. [Damage Integration Flow](#7-damage-integration-flow)
8. [Logging Specifications](#8-logging-specifications)
9. [Unit Testing Requirements](#9-unit-testing-requirements)
10. [Deliverable Checklist](#10-deliverable-checklist)
11. [Acceptance Criteria](#11-acceptance-criteria)
12. [Dependencies](#12-dependencies)
13. [Future Considerations](#13-future-considerations)

---

## 1. Executive Summary

This design specification defines the **unified damage processing layer** that coordinates damage effects across all trauma economy systems.

v0.18.5b establishes **Damage Integration** by defining:

- `DamageIntegrationResult` value object — comprehensive damage outcome
- `UnifiedDamageHandler` service — coordinates damage across all systems
- Stress generation from damage
- Specialization resource triggers (Rage gain, Momentum decay)
- Trauma check triggering on near-death events

### Key Deliverables

| Category            | Items                                          |
| ------------------- | ---------------------------------------------- |
| **Value Objects**   | `DamageIntegrationResult`                      |
| **Services**        | `UnifiedDamageHandler`                         |
| **Tests**           | ~5 unit tests                                  |

### Damage Flow Overview

```
Incoming Damage → Soak → Stress → Specialization → Trauma Check → Result
```

---

## 2. Feature Overview

```
v0.18.5b Features
└── Unified Damage Processing
    │
    ├── DamageIntegrationResult Value Object
    │   ├── DamageDealt & DamageAfterSoak
    │   ├── SoakApplied
    │   ├── StressGained & StressSource
    │   ├── CorruptionGained & CorruptionSource
    │   ├── RageGained (Berserker)
    │   ├── MomentumLost (Storm Blade)
    │   ├── CoherenceLost (Arcanist)
    │   ├── TraumaCheckTriggered
    │   ├── ThresholdsCrossed
    │   └── TransitionMessages
    │
    └── UnifiedDamageHandler Service
        ├── ProcessDamage() orchestration
        ├── CalculateSoak() with specialization bonus
        ├── CalculateStressGain() from damage
        ├── ApplySpecializationEffects()
        ├── TriggerTraumaCheckIfNeeded()
        └── BuildResultObject()
```

---

## 3. Architecture Diagrams

### 3.1 Damage Processing Pipeline

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      UNIFIED DAMAGE HANDLER                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│     ┌─────────────────────────────────────────────────────────────────┐ │
│     │  1. SOAK CALCULATION                                            │ │
│     ├─────────────────────────────────────────────────────────────────┤ │
│     │  • Base Soak = character armor/resistance                       │ │
│     │  • Berserker Bonus = RageState.CurrentRage × 0.1 (if active)   │ │
│     │  • Final Soak = Base + Berserker Bonus                         │ │
│     │  • Damage After Soak = max(1, Damage - Soak)                  │ │
│     └──────────────────┬──────────────────────────────────────────────┘ │
│                        │                                                 │
│     ┌──────────────────▼──────────────────────────────────────────────┐ │
│     │  2. STRESS GENERATION                                           │ │
│     ├───────────────────────────────────────────────────────────────┤ │
│     │  • Base Stress = floor(DamageAfterSoak / 10)                  │ │
│     │  • Critical Hit Bonus = +5 stress                             │ │
│     │  • Near-Death Bonus = +10 stress (if HP < 25%)                │ │
│     │  • Total Stress Gain = Base + Bonuses                         │ │
│     └──────────────────┬──────────────────────────────────────────────┘ │
│                        │                                                 │
│     ┌──────────────────▼──────────────────────────────────────────────┐ │
│     │  3. SPECIALIZATION EFFECTS                                      │ │
│     ├───────────────────────────────────────────────────────────────┤ │
│     │  Berserker:    Gain Rage from damage (if in combat)           │ │
│     │  Storm Blade:  Lose Momentum if critical hit (cascade)         │ │
│     │  Arcanist:     Lose Coherence if interrupted (if casting)      │ │
│     └──────────────────┬──────────────────────────────────────────────┘ │
│                        │                                                 │
│     ┌──────────────────▼──────────────────────────────────────────────┐ │
│     │  4. TRAUMA CHECK TRIGGER                                        │ │
│     ├───────────────────────────────────────────────────────────────┤ │
│     │  • Trigger on near-death (HP < 0 or <25% of max)              │ │
│     │  • Trigger on ally death (witnessed event)                    │ │
│     │  • Record trigger in result                                   │ │
│     └──────────────────┬──────────────────────────────────────────────┘ │
│                        │                                                 │
│     ┌──────────────────▼──────────────────────────────────────────────┐ │
│     │  5. BUILD RESULT OBJECT                                         │ │
│     ├───────────────────────────────────────────────────────────────┤ │
│     │  • Populate DamageIntegrationResult                           │ │
│     │  • Record all thresholds crossed                              │ │
│     │  • Generate transition messages                               │ │
│     │  • Return to caller                                           │ │
│     └──────────────────┬──────────────────────────────────────────────┘ │
│                        │                                                 │
│                        ▼                                                 │
│            DamageIntegrationResult returned                              │
│                                                                           │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Stress Gain Formula Flowchart

```
                  Incoming Damage
                        │
                        ▼
              ┌─────────────────────┐
              │  Calculate Soak     │
              │ (includes Rage bns) │
              └─────────┬───────────┘
                        │
                        ▼
              ┌─────────────────────────────┐
              │  Damage After Soak = max(1) │
              └─────────┬───────────────────┘
                        │
      ┌─────────────────┼─────────────────┐
      │                 │                 │
      ▼                 ▼                 ▼
   floor(Dmg/10)   Critical +5       Near-Death +10
      │                 │                 │
      └─────────────────┴─────────────────┘
                        │
                        ▼
            ┌──────────────────────────┐
            │  Total Stress Gain       │
            │  (apply to character)    │
            └──────────────────────────┘
```

### 3.3 Specialization Cascade Effects

```
                   Damage Taken
                        │
        ┌───────────────┼───────────────┐
        │               │               │
        ▼               ▼               ▼
   Berserker       Storm Blade      Arcanist
   (if in combat)  (if crit hit)    (if casting)
        │               │               │
        ▼               ▼               ▼
   Gain Rage       Lose Momentum   Lose Coherence
        │               │               │
        └───────────────┴───────────────┘
                        │
                        ▼
            Apply all effects to result
```

---

## 4. User Stories

### US-18.5b-1: Process Unified Damage

**As a** combat system
**I want to** process damage through all trauma economy systems at once
**So that** damage creates appropriate stress, specialization changes, and potential traumas

**Acceptance Criteria:**

- Damage is reduced by soak value
- Stress gain is calculated from damage
- Specialization resources respond to damage
- Result object contains all changes
- No individual service is called twice

### US-18.5b-2: Calculate Stress from Damage

**As a** stress system
**I want to** generate stress proportional to damage taken
**So that** dangerous situations meaningfully impact mental state

**Acceptance Criteria:**

- Base stress = floor(damage / 10)
- Critical hits grant +5 stress bonus
- Near-death (HP < 25% of max) grants +10 stress bonus
- Bonuses stack additively
- Result records stress source

### US-18.5b-3: Apply Specialization Damage Effects

**As a** specialization system
**I want to** allow Berserker/Storm Blade/Arcanist to respond to damage
**So that** each specialization has unique damage interactions

**Acceptance Criteria:**

- Berserker gains rage proportional to damage taken
- Storm Blade loses momentum on critical hits
- Arcanist loses coherence if interrupted while casting
- Effects recorded in result object
- Effects are optional (only apply if specialization present)

### US-18.5b-4: Trigger Trauma Checks Appropriately

**As a** trauma system
**I want to** initiate trauma checks on near-death or ally death
**So that** intense experiences create lasting psychological wounds

**Acceptance Criteria:**

- Near-death (damage reducing HP below threshold) triggers trauma check
- Ally death event triggers stress and trauma check for witnesses
- Trigger condition recorded in result
- Trauma IDs created if checks pass

---

## 5. DamageIntegrationResult Value Object

### 5.1 Purpose

Comprehensive record of all effects triggered by a damage event across all trauma economy systems.

### 5.2 Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DamageIntegrationResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Immutable value object representing the complete outcome of unified damage processing.
/// </summary>
/// <remarks>
/// <para>
/// Captures all effects triggered by a damage event across all trauma economy systems:
/// stress generation, specialization resource changes, trauma triggers, and threshold crossings.
/// </para>
/// <para>
/// Used for:
/// • Logging damage events
/// • Applying all effects to character state
/// • Generating combat messages
/// • Creating save/replay data
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = handler.ProcessDamage(characterId, 25, context);
/// logger.LogInformation("Damage result: {StressGained} stress, {TraumaCheckTriggered}",
///     result.StressGained, result.TraumaCheckTriggered);
/// </code>
/// </example>
public readonly record struct DamageIntegrationResult(
    int DamageDealt,
    int DamageAfterSoak,
    int SoakApplied,
    int StressGained,
    StressSource? StressSource,
    int? CorruptionGained,
    CorruptionSource? CorruptionSource,
    int? RageGained,
    int? MomentumLost,
    int? CoherenceLost,
    bool TraumaCheckTriggered,
    IReadOnlyList<string> ThresholdsCrossed,
    IReadOnlyList<string> TransitionMessages)
{
    #region Computed Properties

    /// <summary>
    /// Gets the total effective damage (after soak) as a percentage of character max HP.
    /// </summary>
    public double DamagePercentageOfMaxHp =>
        DamageAfterSoak / 100.0; // TODO: Inject MaxHp

    /// <summary>
    /// Gets whether this damage represents a critical hit.
    /// </summary>
    /// <remarks>
    /// Inferred by presence of critical stress bonus in messages.
    /// </remarks>
    public bool IsCriticalHit =>
        TransitionMessages.Any(m => m.Contains("critical", StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Gets whether this damage triggered a near-death event.
    /// </summary>
    public bool IsNearDeathEvent =>
        TransitionMessages.Any(m => m.Contains("near-death", StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Gets the total resource losses (rage, momentum, coherence combined).
    /// </summary>
    public int TotalResourceLoss =>
        (MomentumLost ?? 0) + (CoherenceLost ?? 0);

    #endregion

    #region Validation

    /// <summary>
    /// Validates result for consistency.
    /// </summary>
    public bool IsValid()
    {
        // Damage values should be non-negative
        if (DamageDealt < 0 || DamageAfterSoak < 0 || SoakApplied < 0)
            return false;

        // Soak can't exceed damage dealt
        if (SoakApplied > DamageDealt)
            return false;

        // Damage after soak should match calculation
        if (DamageAfterSoak != Math.Max(1, DamageDealt - SoakApplied))
            return false;

        // Stress gain should match damage after soak (roughly)
        if (StressGained < 0)
            return false;

        // Optional gains should be non-negative if present
        if (RageGained.HasValue && RageGained < 0)
            return false;
        if (MomentumLost.HasValue && MomentumLost < 0)
            return false;
        if (CoherenceLost.HasValue && CoherenceLost < 0)
            return false;

        return true;
    }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Creates a new DamageIntegrationResult from components.
    /// </summary>
    public static DamageIntegrationResult Create(
        int damageDealt,
        int damageAfterSoak,
        int soakApplied,
        int stressGained,
        StressSource? stressSource = null,
        int? corruptionGained = null,
        CorruptionSource? corruptionSource = null,
        int? rageGained = null,
        int? momentumLost = null,
        int? coherenceLost = null,
        bool traumaCheckTriggered = false,
        IReadOnlyList<string>? thresholdsCrossed = null,
        IReadOnlyList<string>? transitionMessages = null)
    {
        return new DamageIntegrationResult(
            DamageDealt: damageDealt,
            DamageAfterSoak: damageAfterSoak,
            SoakApplied: soakApplied,
            StressGained: stressGained,
            StressSource: stressSource ?? global::RuneAndRust.Domain.Enums.StressSource.PhysicalDamage,
            CorruptionGained: corruptionGained,
            CorruptionSource: corruptionSource,
            RageGained: rageGained,
            MomentumLost: momentumLost,
            CoherenceLost: coherenceLost,
            TraumaCheckTriggered: traumaCheckTriggered,
            ThresholdsCrossed: thresholdsCrossed ?? new List<string>().AsReadOnly(),
            TransitionMessages: transitionMessages ?? new List<string>().AsReadOnly()
        );
    }

    #endregion

    #region Display

    /// <inheritdoc/>
    public override string ToString() =>
        $"DamageResult: {DamageDealt} → {DamageAfterSoak} " +
        $"(Soak {SoakApplied}), +{StressGained} stress" +
        (TraumaCheckTriggered ? " [TRAUMA CHECK]" : "");

    #endregion
}
```

---

## 6. UnifiedDamageHandler Service

### 6.1 Purpose

Application service that orchestrates damage processing across all trauma economy systems.

### 6.2 Definition

**File:** `src/Application/RuneAndRust.Application/Services/UnifiedDamageHandler.cs`

```csharp
namespace RuneAndRust.Application.Services;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Domain.Enums;
using Microsoft.Extensions.Logging;

/// <summary>
/// Coordinates damage processing across all trauma economy systems.
/// </summary>
/// <remarks>
/// <para>
/// Orchestrates the complete damage flow:
/// 1. Calculate soak (including specialization bonuses)
/// 2. Apply stress generation formula
/// 3. Trigger specialization effects (Rage, Momentum, Coherence)
/// 4. Check for trauma triggers
/// 5. Aggregate result
/// </para>
/// </remarks>
public class UnifiedDamageHandler
{
    private readonly IStressService _stressService;
    private readonly ICorruptionService _corruptionService;
    private readonly IRageService? _rageService;
    private readonly IMomentumService? _momentumService;
    private readonly ICoherenceService? _coherenceService;
    private readonly ITraumaService _traumaService;
    private readonly ISpecializationProvider _specializationProvider;
    private readonly ILogger<UnifiedDamageHandler> _logger;

    public UnifiedDamageHandler(
        IStressService stressService,
        ICorruptionService corruptionService,
        ITraumaService traumaService,
        ISpecializationProvider specializationProvider,
        IRageService? rageService = null,
        IMomentumService? momentumService = null,
        ICoherenceService? coherenceService = null,
        ILogger<UnifiedDamageHandler>? logger = null)
    {
        _stressService = stressService;
        _corruptionService = corruptionService;
        _traumaService = traumaService;
        _specializationProvider = specializationProvider;
        _rageService = rageService;
        _momentumService = momentumService;
        _coherenceService = coherenceService;
        _logger = logger ?? NullLogger<UnifiedDamageHandler>.Instance;
    }

    /// <summary>
    /// Processes damage through all trauma economy systems.
    /// </summary>
    /// <param name="characterId">The character taking damage.</param>
    /// <param name="damage">Raw damage amount.</param>
    /// <param name="context">Additional damage context (critical, attacker, etc).</param>
    /// <returns>Complete damage integration result.</returns>
    public DamageIntegrationResult ProcessDamage(
        Guid characterId,
        int damage,
        DamageContext context)
    {
        _logger.LogDebug("Processing {Damage} damage for {CharacterId}", damage, characterId);

        // 1. Calculate soak
        var (baseSoak, bonusSoak) = CalculateSoak(characterId);
        var totalSoak = baseSoak + bonusSoak;
        var damageAfterSoak = Math.Max(1, damage - totalSoak);

        _logger.LogDebug("Soak: {BaseSoak} + {BonusSoak} = {Total}, Damage reduced to {Final}",
            baseSoak, bonusSoak, totalSoak, damageAfterSoak);

        // 2. Calculate stress gain
        var stressGain = CalculateStressGain(damageAfterSoak, context);

        _logger.LogDebug("Stress gain calculated: {StressGain}", stressGain);

        // 3. Apply specialization effects
        var (rageGained, momentumLost, coherenceLost) =
            ApplySpecializationEffects(characterId, damage, context);

        _logger.LogDebug("Specialization effects: Rage +{R}, Momentum -{M}, Coherence -{C}",
            rageGained ?? 0, momentumLost ?? 0, coherenceLost ?? 0);

        // 4. Check trauma trigger
        var traumaCheckTriggered = CheckTraumaTrigger(characterId, context, damageAfterSoak);

        _logger.LogDebug("Trauma check triggered: {Triggered}", traumaCheckTriggered);

        // 5. Build result
        var result = BuildResult(
            damage, damageAfterSoak, totalSoak, stressGain,
            rageGained, momentumLost, coherenceLost,
            traumaCheckTriggered, context);

        _logger.LogInformation("Damage processed: {@Result}", result);

        return result;
    }

    /// <summary>
    /// Calculates soak value including specialization bonuses.
    /// </summary>
    /// <remarks>
    /// Berserker adds 10% of current Rage to soak.
    /// </remarks>
    private (int baseSoak, int bonusSoak) CalculateSoak(Guid characterId)
    {
        var baseSoak = 5; // TODO: Pull from character armor/resistance

        var bonusSoak = 0;
        if (_rageService != null)
        {
            var rageState = _rageService.GetRage(characterId);
            if (rageState.IsActive)
            {
                bonusSoak = (int)(rageState.CurrentRage * 0.1);
            }
        }

        return (baseSoak, bonusSoak);
    }

    /// <summary>
    /// Calculates stress gain from damage.
    /// </summary>
    /// <remarks>
    /// Formula:
    /// • Base: floor(damage / 10)
    /// • Critical bonus: +5
    /// • Near-death bonus: +10 (if character would drop to < 25% HP)
    /// </remarks>
    private int CalculateStressGain(int damageAfterSoak, DamageContext context)
    {
        var baseStress = damageAfterSoak / 10;

        var bonusStress = 0;
        if (context.IsCriticalHit)
            bonusStress += 5;

        // Check for near-death
        var currentHp = 50; // TODO: Get from character
        var maxHp = 100;    // TODO: Get from character
        if (currentHp - damageAfterSoak < (maxHp * 0.25))
            bonusStress += 10;

        return baseStress + bonusStress;
    }

    /// <summary>
    /// Applies specialization-specific damage effects.
    /// </summary>
    private (int? rageGained, int? momentumLost, int? coherenceLost) ApplySpecializationEffects(
        Guid characterId,
        int damage,
        DamageContext context)
    {
        int? rageGained = null;
        int? momentumLost = null;
        int? coherenceLost = null;

        var specializationType = _specializationProvider.GetSpecializationType(characterId);

        if (specializationType == "rage" && _rageService != null)
        {
            // Berserker gains rage from damage
            rageGained = damage / 5; // 1 rage per 5 damage
        }

        if (specializationType == "momentum" && _momentumService != null)
        {
            // Storm Blade loses momentum on critical hits
            if (context.IsCriticalHit)
            {
                momentumLost = 20;
            }
        }

        if (specializationType == "coherence" && _coherenceService != null)
        {
            // Arcanist loses coherence if interrupted while casting
            if (context.IsInterrupt)
            {
                coherenceLost = 15;
            }
        }

        return (rageGained, momentumLost, coherenceLost);
    }

    /// <summary>
    /// Determines if damage should trigger a trauma check.
    /// </summary>
    private bool CheckTraumaTrigger(Guid characterId, DamageContext context, int finalDamage)
    {
        // Near-death event
        var currentHp = 50; // TODO: Get from character
        if (currentHp - finalDamage <= 0)
            return true;

        // Ally death witnessed
        if (context.IsAllyDeathEvent)
            return true;

        return false;
    }

    /// <summary>
    /// Builds the complete result object.
    /// </summary>
    private DamageIntegrationResult BuildResult(
        int damage,
        int damageAfterSoak,
        int soak,
        int stressGain,
        int? rageGained,
        int? momentumLost,
        int? coherenceLost,
        bool traumaCheckTriggered,
        DamageContext context)
    {
        var thresholds = new List<string>();
        var messages = new List<string>();

        // Generate messages
        messages.Add($"Took {damageAfterSoak} damage (soak {soak}).");

        if (context.IsCriticalHit)
        {
            messages.Add("Critical hit—mind reels from impact!");
            thresholds.Add("CriticalHit");
        }

        if (damageAfterSoak < 25 % 100) // Near-death
        {
            messages.Add("near-death grasp tightens...");
            thresholds.Add("NearDeath");
        }

        if (rageGained.HasValue)
        {
            messages.Add($"Fury surges (+{rageGained} rage).");
        }

        if (momentumLost.HasValue)
        {
            messages.Add($"Your momentum shatters! (-{momentumLost} momentum)");
            thresholds.Add("MomentumLost");
        }

        if (traumaCheckTriggered)
        {
            messages.Add("A scar is etched into your mind...");
            thresholds.Add("TraumaCheck");
        }

        return DamageIntegrationResult.Create(
            damageDealt: damage,
            damageAfterSoak: damageAfterSoak,
            soakApplied: soak,
            stressGained: stressGain,
            stressSource: context.IsCriticalHit ? StressSource.CriticalHit : StressSource.PhysicalDamage,
            rageGained: rageGained,
            momentumLost: momentumLost,
            coherenceLost: coherenceLost,
            traumaCheckTriggered: traumaCheckTriggered,
            thresholdsCrossed: thresholds.AsReadOnly(),
            transitionMessages: messages.AsReadOnly()
        );
    }
}

/// <summary>
/// Context information for damage events.
/// </summary>
public record DamageContext(
    bool IsCriticalHit = false,
    bool IsInterrupt = false,
    bool IsAllyDeathEvent = false,
    Guid? AttackerId = null);
```

---

## 7. Damage Integration Flow

### 7.1 Complete Damage Processing Sequence

| Step | Action | Source | Destination |
| ---- | ------ | ------ | ----------- |
| 1    | Calculate soak (base + Rage bonus) | Specialization | Result |
| 2    | Apply soak to damage | Math | Result |
| 3    | Calculate base stress (damage/10) | Formula | Result |
| 4    | Add critical bonus if applicable | DamageContext | Result |
| 5    | Add near-death bonus if applicable | Character HP | Result |
| 6    | Apply specialization effects | Specialization | Result |
| 7    | Check trauma trigger conditions | Character State | Result |
| 8    | Generate transition messages | All above | Result |
| 9    | Return comprehensive result | Handler | Caller |

### 7.2 Stress Bonuses (Stacking Rules)

- **Base Stress:** floor(DamageAfterSoak / 10)
- **Critical Bonus:** +5 (if critical hit)
- **Near-Death Bonus:** +10 (if HP would drop below 25% max)
- **Total:** Base + All Applicable Bonuses (additive, not multiplicative)

---

## 8. Logging Specifications

### 8.1 Application Layer Logging

| Event                         | Level       | Template                                                         |
| ----------------------------- | ----------- | ---------------------------------------------------------------- |
| Damage Processing Started     | Debug       | `"Processing {Damage} damage for {CharacterId}"`                 |
| Soak Calculated              | Debug       | `"Soak: {BaseSoak} + {BonusSoak} = {Total}"`                     |
| Stress Calculated             | Debug       | `"Stress gain: {Base} + {Bonuses} = {Total}"`                    |
| Specialization Effects        | Debug       | `"Effects: Rage +{R}, Momentum -{M}, Coherence -{C}"`            |
| Trauma Check Triggered        | Warning     | `"Trauma check triggered for {CharacterId}"`                     |
| Damage Processing Complete    | Information | `"Damage result: {StressGain} stress, Damage {After}/{Dealt}"`   |

---

## 9. Unit Testing Requirements

### 9.1 Test File Location

**File:** `tests/RuneAndRust.Application.UnitTests/Services/UnifiedDamageHandlerTests.cs`

### 9.2 Required Tests

| Test Name                                            | Description                         |
| ---------------------------------------------------- | ----------------------------------- |
| `ProcessDamage_BasicFlow_CalculatesAllComponents`    | All damage components calculated    |
| `CalculateStressGain_WithCritical_AddsBonus`         | Critical damage adds +5 stress      |
| `CalculateStressGain_NearDeath_AddsBonus`            | Near-death adds +10 stress          |
| `ApplySpecializationEffects_BerserkerRage_GainsRage` | Berserker gains rage appropriately   |
| `BuildResult_WithAllFactors_GeneratesMessages`      | Result messages generated correctly |

### 9.3 Example Test

```csharp
[TestFixture]
public class UnifiedDamageHandlerTests
{
    private UnifiedDamageHandler _handler;
    private IStressService _stressService;

    [SetUp]
    public void SetUp()
    {
        _stressService = Substitute.For<IStressService>();
        var corruptionService = Substitute.For<ICorruptionService>();
        var traumaService = Substitute.For<ITraumaService>();
        var specializationProvider = Substitute.For<ISpecializationProvider>();

        _handler = new UnifiedDamageHandler(
            _stressService,
            corruptionService,
            traumaService,
            specializationProvider
        );
    }

    [Test]
    public void ProcessDamage_WithCriticalHit_AddsStressBonus()
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var context = new DamageContext(IsCriticalHit: true);

        // Act
        var result = _handler.ProcessDamage(characterId, 50, context);

        // Assert
        result.StressGained.Should().Be(5 + 5); // base + critical bonus
        result.ThresholdsCrossed.Should().Contain("CriticalHit");
        result.TransitionMessages.Should().Contain(m => m.Contains("critical", StringComparison.OrdinalIgnoreCase));
    }

    [Test]
    public void ProcessDamage_ValidResult_PassesValidation()
    {
        // Arrange
        var context = new DamageContext();

        // Act
        var result = _handler.ProcessDamage(Guid.NewGuid(), 30, context);

        // Assert
        result.IsValid().Should().BeTrue();
    }
}
```

---

## 10. Deliverable Checklist

### 10.1 Domain Layer

- [ ] `src/Core/RuneAndRust.Domain/ValueObjects/DamageIntegrationResult.cs`
- [ ] `src/Core/RuneAndRust.Domain/Enums/DamageContext.cs` (if needed)

### 10.2 Application Layer

- [ ] `src/Application/RuneAndRust.Application/Services/UnifiedDamageHandler.cs`

### 10.3 Tests

- [ ] `tests/RuneAndRust.Application.UnitTests/Services/UnifiedDamageHandlerTests.cs`

### 10.4 Documentation

- [ ] Update scope breakdown (mark v0.18.5b complete)
- [ ] Create changelog for v0.18.5b

---

## 11. Acceptance Criteria

### 11.1 Build Verification

- [ ] Solution builds without errors
- [ ] Solution builds without warnings in new code

### 11.2 Test Verification

- [ ] All new unit tests pass
- [ ] All existing unit tests continue to pass

### 11.3 Functional Verification

- [ ] Damage correctly triggers stress gain (damage/10 formula)
- [ ] Critical hits grant +5 stress bonus
- [ ] Near-death events grant +10 stress bonus
- [ ] Soak is calculated and applied correctly
- [ ] Berserker gains rage from damage proportionally
- [ ] Storm Blade loses momentum on critical hits
- [ ] Arcanist loses coherence on interrupts
- [ ] Trauma checks triggered on near-death
- [ ] Trauma checks triggered on ally death
- [ ] DamageIntegrationResult validates correctly
- [ ] All transition messages generated appropriately
- [ ] Thresholds crossed recorded in result

---

## 12. Dependencies

### 12.1 Required Prerequisites

| Dependency                | Version | Status   | Notes                                  |
| ------------------------- | ------- | -------- | -------------------------------------- |
| TraumaEconomyState        | v0.18.5a | Required | Query character state                  |
| Psychic Stress System     | v0.18.0 | Required | Apply stress results                   |
| Specialization Resources  | v0.18.4 | Required | Rage, Momentum, Coherence effects      |
| Trauma System             | v0.18.3 | Required | Trigger trauma checks                  |

### 12.2 Provides to v0.18.5c-e

| Type                     | Usage                                      |
| ------------------------ | ------------------------------------------ |
| `DamageIntegrationResult`| Base damage result for logging             |
| `UnifiedDamageHandler`   | Used by orchestration service              |

---

## 13. Future Considerations

### 13.1 Extended Damage Types

- Psychic damage (direct stress without physical HP loss)
- Corruption damage (direct corruption without stress)
- Status effect damage (DOT effects)

### 13.2 Damage Modifications

- Vulnerability multipliers from status effects
- Resistance multipliers from abilities
- Environmental hazard damage

### 13.3 Party Effects

- Party members witness damage (shared trauma checks)
- Protective abilities reduce damage for allies
- Courage bonuses for group members

---

_This design specification provides the detailed blueprint for implementing v0.18.5b Damage Integration. It forms the foundation for unified damage processing across the trauma economy._

---

## Changelog

| Version | Date       | Changes                          |
| ------- | ---------- | -------------------------------- |
| 1.0     | 2026-01-28 | Initial design specification     |
