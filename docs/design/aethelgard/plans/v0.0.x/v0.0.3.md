Based on the "Walking Skeleton" roadmap and the Game Loop specifications, here is the comprehensive implementation plan for v0.0.3.
v0.0.3: The Loop (Input/Output Pipeline)
Goal: Transform the static application into an interactive state machine that accepts user input, parses commands, and updates game state until a quit condition is met.

## Table of Contents
- [1. Implementation Workflow](#1-implementation-workflow)
- [2. Code Implementation](#2-code-implementation)
- [3. Architecture Decision Tree](#3-architecture-decision-tree-v003)
- [4. Deliverable Checklist](#4-v003-deliverable-checklist)

1. Implementation Workflow
Execute these steps to establish the game loop and command processing pipeline.
	1	Define State: Create the GamePhase enum and update GameState to track it.
	2	Define Interfaces: Create IInputHandler and ICommandParser in Core.
	3	Implement Logic: Build the CommandParser in Engine to interpret strings.
	4	Implement Loop: Expand GameService to run a while loop dependent on state.
	5	Wire UI: Implement TerminalInputHandler to read System.Console.

2. Code Implementation
A. Core Layer (State & Contracts)
Define the phases of the game and the contract for handling input.
File: RuneAndRust.Core/Enums/GamePhase.cs
namespace RuneAndRust.Core.Enums;

public enum GamePhase
{
    MainMenu,
    Exploration,
    Combat,
    Quit
}
File: RuneAndRust.Core/Models/GameState.cs
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Models;

public class GameState
{
    public GamePhase Phase { get; set; } = GamePhase.MainMenu;
    // Future: Character data, seed, etc.
}
File: RuneAndRust.Core/Interfaces/IInputHandler.cs
namespace RuneAndRust.Core.Interfaces;

public interface IInputHandler
{
    string GetInput(string prompt);
}
B. Engine Layer (The Loop & Parser)
The Engine controls the flow. It parses raw strings into actions.
File: RuneAndRust.Engine/Services/CommandParser.cs
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Engine.Services;

public class CommandParser
{
    public void ParseAndExecute(string input, GameState state)
    {
        if (string.IsNullOrWhiteSpace(input)) return;

        var command = input.Trim().ToLower();

        // Basic State Machine Logic for v0.0.3
        switch (state.Phase)
        {
            case GamePhase.MainMenu:
                HandleMainMenu(command, state);
                break;
            case GamePhase.Exploration:
                HandleExploration(command, state);
                break;
        }
    }

    private void HandleMainMenu(string command, GameState state)
    {
        if (command == "start") state.Phase = GamePhase.Exploration;
        else if (command == "quit") state.Phase = GamePhase.Quit;
    }

    private void HandleExploration(string command, GameState state)
    {
        if (command == "quit") state.Phase = GamePhase.Quit;
        else if (command == "help") Console.WriteLine("Commands: quit, help");
        else Console.WriteLine($"Unknown command: {command}");
    }
}
File: RuneAndRust.Engine/Services/GameService.cs (Updated)
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Engine.Services;

public class GameService : IGameService
{
    private readonly ILogger<GameService> _logger;
    private readonly IInputHandler _inputHandler;
    private readonly CommandParser _parser;
    private readonly GameState _state;

    public GameService(ILogger<GameService> logger, IInputHandler inputHandler)
    {
        _logger = logger;
        _inputHandler = inputHandler;
        _parser = new CommandParser(); // Or inject via DI
        _state = new GameState();
    }

    public void Start()
    {
        _logger.LogInformation("Game Loop Started.");

        while (_state.Phase != GamePhase.Quit)
        {
            // 1. Render Prompt based on Phase
            string prompt = _state.Phase == GamePhase.MainMenu ? "[MENU] > " : "[EXPLORE] > ";

            // 2. Get Input
            string input = _inputHandler.GetInput(prompt);

            // 3. Process Input
            _parser.ParseAndExecute(input, _state);
        }

        _logger.LogInformation("Game Loop Ended.");
    }
}
C. Terminal Layer (UI Implementation)
Implement the input handler using the System Console.
File: RuneAndRust.Terminal/Services/TerminalInputHandler.cs
using RuneAndRust.Core.Interfaces;
using Spectre.Console; // Optional for prettier input

namespace RuneAndRust.Terminal.Services;

public class TerminalInputHandler : IInputHandler
{
    public string GetInput(string prompt)
    {
        // Use Spectre.Console for styled prompts
        return AnsiConsole.Ask<string>($"[green]{prompt}[/]");
    }
}
File: RuneAndRust.Terminal/Program.cs (DI Registration)
// Update ConfigureServices
services.AddSingleton<IInputHandler, TerminalInputHandler>();
// GameService is already registered from v0.0.1

3. Architecture Decision Tree (v0.0.3)
	•	Q: Why use IInputHandler instead of Console.ReadLine in the Engine?
	◦	A: To decouple the Engine from the Console. This allows us to swap the Terminal UI for a GUI (Avalonia) later without rewriting the game logic. The Engine just asks for "input," it doesn't care if it comes from a keyboard or a text box.
	•	Q: Where should the GameState live?
	◦	A: It should be a Singleton injected into the GameService. This persists the data as long as the application runs.
	•	Q: Should we implement the full Command Pattern (Command classes) yet?
	◦	A: No. For v0.0.3, a simple switch statement in CommandParser is sufficient to prove the loop works. We will refactor into specific ICommand classes (Move, Attack, Look) in v0.0.5 when complexity increases.

4. v0.0.3 Deliverable Checklist
	•	[ ] Core: GamePhase Enum and GameState class created.
	•	[ ] Core: IInputHandler interface defined.
	•	[ ] Terminal: TerminalInputHandler implemented using Spectre.Console.
	•	[ ] Engine: CommandParser logic implemented (handles "start" and "quit").
	•	[ ] Engine: GameService.Start() converted to a while loop.
	•	[ ] DI: IInputHandler registered in Program.cs.
	•	[ ] Verification: App runs -> Shows Menu Prompt -> Type "Start" -> Shows Explore Prompt -> Type "Quit" -> App closes gracefully.
This completes the Control Flow layer. The next step (v0.0.4) will add Persistence (Database) to save this state.
Ready to proceed to Persistence?
