> **Archived** - This plan has been consolidated. See the complete version at [v0.3.21](../v0.3.x/v0.3.21.md).

# v0.3.21a: The Preview (Save Metadata)
This sub-version upgrades the persistence layer from simple file slots to rich data snapshots. By storing lightweight metadata separately from the massive game state blob, we enable the UI to render detailed "save previews" (Health, Location, Level) without deserializing the entire world state.

Goal: Implement the SaveMetadata model, update the database schema to store it as JSONB, and refactor the SaveManagerto populate this snapshot during the save process.

1. Architecture & Data Flow
	•	Schema Evolution: The SaveGames table gains a Metadata column (JSONB). This allows structured, queryable access to save details without loading the heavy SerializedState string.
	•	Extraction Strategy: When SaveManager executes, it acts as a mapper, pulling high-level stats from the GameStatedomain object into the SaveMetadata DTO.
	•	Projection Query: The "Load Game" UI uses EF Core projection to fetch only the Metadata column, ensuring the menu remains responsive even with large save files.
Data Flow: The Snapshot Pipeline
	1	Trigger: User initiates Save (or Autosave trigger).
	2	Snapshot: SaveManager reads GameState.CurrentCharacter and GameState.CurrentRoom.
	3	Mapping:
	◦	Extract Vitals: HP, Stamina, Level, Archetype.
	◦	Extract Context: Location Name, Playtime, Difficulty.
	◦	Create SaveMetadata record.
	4	Persistence:
	◦	Serialize GameState -> SerializedState (Blob).
	◦	Attach SaveMetadata -> Metadata (JSONB).
	◦	SaveGameRepository writes to PostgreSQL.
	5	Visualization: The Load Menu reads the JSONB column to render a "Mini-Character Sheet" preview.

2. Logic Decision Trees
A. Metadata Extraction Logic Input: GameState
	1	Character Check: Is CurrentCharacter null?
	◦	Yes: Metadata = { Status: "Empty/Corrupt", Timestamp: Now }.
	◦	No:
	▪	Identity: Name, Archetype (Enum -> String), Level.
	▪	Vitals: CurrentHP / MaxHP (calculate ratio for UI bar).
	▪	Location: CurrentRoom?.Name ?? "Unknown".
	▪	Economy: Current Scrip, Legend count.
	2	Return: Populated SaveMetadata object.
B. Save Slot Rendering Logic Input: List (Projected)
	1	Iterate Slots:
	2	Check Metadata:
	◦	Null: Display "[Corrupt Slot]".
	◦	Valid:
	▪	Line 1: Slot # | {Name} | Lvl {Level} {Archetype}
	▪	Line 2: Loc: {Location}
	▪	Line 3: HP: [████░] | Last Played: {TimeAgo}

3. Code Implementation
A. Metadata Model File: RuneAndRust.Core/Models/SaveMetadata.cs
public record SaveMetadata(
    string CharacterName,
    string Archetype,
    int Level,
    int CurrentHp,
    int MaxHp,
    string LocationName,
    int Scrip,
    long LegendTotal,
    TimeSpan TotalPlaytime,
    DateTime Timestamp
)
{
    // Factory for empty slots
    public static SaveMetadata Empty() =>
        new("Empty", "None", 0, 0, 0, "Void", 0, 0, TimeSpan.Zero, DateTime.MinValue);
}
B. Entity Update File: RuneAndRust.Core/Entities/SaveGame.cs
public class SaveGame
{
    public Guid Id { get; set; }
    public int SlotNumber { get; set; }

    // Existing fields...

    // New JSONB Column
    public SaveMetadata Metadata { get; set; } = SaveMetadata.Empty();

    public string SerializedState { get; set; }
}
C. DbContext Configuration File: RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs
modelBuilder.Entity<SaveGame>(entity =>
{
    entity.Property(e => e.Metadata)
        .HasColumnType("jsonb")
        .HasConversion(
            v => JsonSerializer.Serialize(v, (JsonSerializerOptions)null),
            v => JsonSerializer.Deserialize<SaveMetadata>(v, (JsonSerializerOptions)null)
        );
});
D. SaveManager Population File: RuneAndRust.Engine/Services/SaveManager.cs
public async Task SaveGameAsync(int slot, GameState state)
{
    var character = state.CurrentCharacter;
    var room = state.CurrentRoom; // Assuming Room entity is hydrated in State

    var metadata = new SaveMetadata(
        CharacterName: character?.Name ?? "Unknown",
        Archetype: character?.Archetype.ToString() ?? "Survivor",
        Level: character?.Level ?? 1,
        CurrentHp: character?.CurrentHP ?? 0,
        MaxHp: character?.MaxHP ?? 1,
        LocationName: room?.Name ?? "Unknown Location",
        Scrip: character?.Inventory?.GetCurrencyAmount() ?? 0,
        LegendTotal: character?.Legend ?? 0,
        TotalPlaytime: state.TotalPlaytime, // Assumes time tracking exists
        Timestamp: DateTime.UtcNow
    );

    var save = new SaveGame
    {
        SlotNumber = slot,
        Metadata = metadata,
        SerializedState = JsonSerializer.Serialize(state), // Heavy lifting
        LastPlayed = DateTime.UtcNow
    };

    await _repository.SaveSlotAsync(save);
}

4. Deliverable Checklist (v0.3.21a)
	•	Core:
	◦	[ ] Define SaveMetadata record.
	◦	[ ] Update SaveGame entity with Metadata property.
	•	Persistence:
	◦	[ ] Configure EF Core JSONB mapping in DbContext.
	◦	[ ] Create Migration: AddSaveMetadata.
	◦	[ ] Update SaveGameRepository to include GetMetadataOnlyAsync() (Projection).
	•	Engine:
	◦	[ ] Update SaveManager to construct metadata from GameState.
	•	UI (Terminal):
	◦	[ ] Update LoadGame menu to use SaveMetadata for rendering slot details.
	•	Tests:
	◦	[ ] Test: Metadata is correctly serialized/deserialized.
	◦	[ ] Test: Repository projection fetches metadata without full state blob.

5. Logging Requirements
Reference: logging.md
System
Event
Level
Message Template
Properties
Persistence
Snapshot
Trace
"[Save] Metadata generated for {Char}: {Loc}, {HP} HP."
Char, Loc, HP
Persistence
DB Write
Debug
"[Save] Persisted slot {Slot}. Meta size: {Size}b."
Slot, Size

6. Testing Strategy
Unit Tests (SaveManagerTests.cs):
	•	Metadata_Extraction:
	◦	Setup: GameState with Character (50/100 HP, Location "The Pit").
	◦	Act: Call SaveGameAsync.
	◦	Assert: SaveGame.Metadata.LocationName == "The Pit", CurrentHp == 50.
	•	Null_Handling:
	◦	Setup: GameState with null character (e.g., pre-creation save).
	◦	Act: Save.
	◦	Assert: Metadata defaults are used ("Unknown", "Void").
Integration Tests (PersistenceTests.cs):
	•	JSONB_Persistence:
	◦	Act: Save game. Verify via SQL query that Metadata column contains valid JSON.
	•	Projection_Query:
	◦	Act: Call repo.GetMetadataOnlyAsync().
	◦	Assert: Returned objects have populated Metadata but null/empty SerializedState.

7. Draft Changelog (v0.3.21a)
# Changelog: v0.3.21a - The Preview

**Release Date:** 2026-02-XX

## Summary
The first phase of "The Steward" overhaul introduces rich metadata to the save system. Save files now carry a lightweight snapshot of the game state, allowing the Load Menu to display character vitals and location without parsing the entire save file.

## Changes
- **Core:** Added `SaveMetadata` model to capture character snapshot (HP, Level, Location).
- **Persistence:** Updated database schema to store Metadata as searchable JSONB.
- **Engine:** Refactored `SaveManager` to auto-populate metadata during save operations.
- **UI:** The Load Menu now displays a detailed preview of each save slot.