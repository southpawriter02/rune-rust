# v0.2.1: The Armory & The Affliction

> **Status:** Complete
> **Milestone:** 3 - The Warrior
> **Theme:** Equipment integration, Status Effects, and Combat UI

## Table of Contents
- [Overview](#overview)
- [Phase A: The Gear (Equipment Integration)](#phase-a-the-gear-equipment-integration)
- [Phase B: The Affliction (Status Effects)](#phase-b-the-affliction-status-effects)
- [Phase C: The Visuals (Combat UI Updates)](#phase-c-the-visuals-combat-ui-updates)
- [Testing Strategy](#testing-strategy)
- [Draft Changelog](#draft-changelog)

## Overview

This version connects the Inventory System (v0.1.2) to the Combat Engine (v0.2.0) and introduces temporal combat mechanics. The system now uses actual equipped items for damage/soak calculations and supports buffs, debuffs, and damage-over-time effects.

- **Phase A: The Gear** - Equipment stats integration and loot generation
- **Phase B: The Affliction** - Status effect lifecycle management
- **Phase C: The Visuals** - Combat UI for status icons and victory screen

---

## Phase A: The Gear (Equipment Integration)

**Goal:** Transition combat math from "Debug Mode" (fixed d6 damage) to "Live Mode" (variable damage from weapons, soak from armor).

### 1. Implementation Workflow

1. **Combatant Adapter Update:** Snapshot offensive/defensive stats from equipped items
2. **Resolution Logic:** Use Combatant.WeaponDie and Combatant.Soak
3. **Loot Hooks:** Trigger LootService on victory
4. **Reward State:** Return CombatResult object with XP and loot

### 2. Logic Decision Trees

**Weapon Selection:**
1. Check Two-Handed Slot -> Use if present
2. Check Main Hand Slot -> Use if present
3. Fallback -> Unarmed (d4)

**Armor Calculation:**
1. Initialize TotalSoak = 0
2. Sum SoakBonus from all equipped armor
3. Cache on Combatant

### 3. Code Implementation

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs`
```csharp
public partial class Combatant
{
    public int WeaponDamageDie { get; set; } = 4;
    public int WeaponAccuracyBonus { get; set; } = 0;
    public int ArmorSoak { get; set; } = 0;
    public string WeaponName { get; set; } = "Fists";

    public static Combatant FromCharacter(Character c)
    {
        var equippedItems = c.Inventory.Where(i => i.IsEquipped)
                                       .Select(i => i.Item)
                                       .OfType<Equipment>();

        combatant.ArmorSoak = equippedItems.Sum(e => e.SoakBonus);

        var weapon = equippedItems.FirstOrDefault(e => e.Slot == EquipmentSlot.TwoHand)
                  ?? equippedItems.FirstOrDefault(e => e.Slot == EquipmentSlot.MainHand);

        if (weapon != null)
        {
            combatant.WeaponDamageDie = weapon.DamageDie;
            combatant.WeaponName = weapon.Name;
        }

        return combatant;
    }
}
```

**File:** `RuneAndRust.Core/Models/Combat/CombatResult.cs`
```csharp
public record CombatResult(
    bool Victory,
    int XpEarned,
    List<Item> LootFound,
    string Summary
);
```

### 4. Deliverable Checklist (Phase A)

- [x] Update Combatant with WeaponDamageDie, ArmorSoak, WeaponName
- [x] Update Combatant.FromCharacter to snapshot equipment stats
- [x] Create CombatResult record
- [x] Refactor AttackResolutionService to use Combatant stats
- [x] Implement CombatService.EndCombat with loot generation

---

## Phase B: The Affliction (Status Effects)

**Goal:** Implement StatusEffectService to manage effect lifecycles (Application, Ticking, Expiration) with stacking rules.

### 1. Turn Lifecycle

1. **Turn Start:** ProcessTurnStart (DoT damage, check expiration)
2. **Action Check:** CanAct (Stunned = skip turn)
3. **Action Execution:** ApplyStatus on hit
4. **Stat Calculation:** GetStatModifiers for Defense/Soak
5. **Turn End:** ProcessTurnEnd (decrement durations)

### 2. Stacking Rules

| Effect | Behavior |
|--------|----------|
| Bleeding | Intensify (add stacks, cap at 5) |
| Poisoned | Intensify |
| Stunned | No Stack (refresh duration only) |
| Fortified | No Stack |

### 3. Code Implementation

**File:** `RuneAndRust.Core/Enums/StatusEffectType.cs`
```csharp
public enum StatusEffectType
{
    // Debuffs
    Bleeding = 0,    // Physical DoT, Ignores Soak
    Poisoned = 1,    // Poison DoT
    Stunned = 2,     // Skip Turn
    Vulnerable = 3,  // +Damage Taken

    // Buffs
    Fortified = 10,  // +Soak
    Hasted = 11,     // Extra Action
    Inspired = 12    // +Damage
}
```

**File:** `RuneAndRust.Engine/Services/StatusEffectService.cs`
```csharp
public class StatusEffectService : IStatusEffectService
{
    public void ApplyStatus(Combatant target, StatusEffectType type, int duration, Guid sourceId)
    {
        var existing = target.StatusEffects.FirstOrDefault(e => e.Type == type);
        if (existing != null)
            HandleStacking(existing, duration);
        else
            target.StatusEffects.Add(new ActiveStatusEffect(type, duration, sourceId));
    }

    public List<string> ProcessTurnStart(Combatant combatant)
    {
        var logs = new List<string>();
        foreach (var effect in combatant.StatusEffects)
        {
            if (effect.Type == StatusEffectType.Bleeding)
            {
                int dmg = _dice.RollSingle(6, "Bleed") * effect.Stacks;
                combatant.CurrentHp -= dmg;
                logs.Add($"{combatant.Name} bleeds for {dmg} damage.");
            }
        }
        return logs;
    }

    public bool CanAct(Combatant combatant) =>
        !combatant.StatusEffects.Any(e => e.Type == StatusEffectType.Stunned);
}
```

### 4. Logging Matrix

| Event | Level | Message Template |
|-------|-------|------------------|
| Applied | Info | "{Target} gained {Status} ({Duration} turns)." |
| Intensify | Verbose | "{Status} stack added to {Target}, now {StackCount}." |
| Tick | Verbose | "{Status} tick on {Target}: {Damage} damage." |
| Control | Info | "{Target} is {Status} and cannot act!" |

### 5. Deliverable Checklist (Phase B)

- [x] Create StatusEffectType Enum
- [x] Create ActiveStatusEffect Class
- [x] Update Combatant with List<ActiveStatusEffect>
- [x] Implement StatusEffectService (Apply, Tick, Remove)
- [x] Implement stacking logic for Bleeding (Intensify)
- [x] Implement control logic for Stunned (Block Action)
- [x] Update CombatService.NextTurn with ProcessTurnStart/CanAct

---

## Phase C: The Visuals (Combat UI Updates)

**Goal:** Display Status Effect icons and implement Victory Screen for loot/XP.

### 1. Implementation Workflow

1. **ViewModel Update:** Add StatusEffectView to CombatantView
2. **Renderer Update:** Draw status tags (ü©∏, ‚ö°, üõ°Ô∏è) in Turn Order
3. **Victory Screen:** Display loot table with quality colors

### 2. Status Icon Mapping

| Effect | Icon | Color |
|--------|------|-------|
| Bleeding | ü©∏ | red |
| Poisoned | ‚ò†Ô∏è | green |
| Stunned | ‚ö° | yellow |
| Fortified | üõ°Ô∏è | blue |

### 3. Code Implementation

**File:** `RuneAndRust.Core/ViewModels/CombatViewModel.cs`
```csharp
public record StatusEffectView(
    string Name,
    string Icon,
    string Color,
    int Stacks,
    int Duration
);

public record CombatantView(
    Guid Id,
    string Name,
    bool IsPlayer,
    bool IsActive,
    string HealthStatus,
    List<StatusEffectView> ActiveEffects,
    string InitiativeDisplay
);
```

**File:** `RuneAndRust.Terminal/Services/VictoryScreenRenderer.cs`
```csharp
public class VictoryScreenRenderer
{
    public void Render(CombatResult result)
    {
        AnsiConsole.Clear();

        var panel = new Panel(
            new Rows(
                new FigletText("VICTORY").Color(Color.Gold1),
                new Text($"XP Earned: {result.XpEarned}"),
                new Rule("Loot Recovered"),
                BuildLootTable(result.LootFound)
            )
        );

        AnsiConsole.Write(panel);
        Console.ReadKey(true);
    }

    private Table BuildLootTable(List<Item> loot)
    {
        // Color by Quality: Myth-Forged=gold, Optimized=purple, etc.
    }
}
```

### 4. Deliverable Checklist (Phase C)

- [x] Update CombatViewModel with StatusEffectView
- [x] Update CombatService mapping for effect views
- [x] Update CombatScreenRenderer with status icons
- [x] Create VictoryScreenRenderer
- [x] Wire VictoryScreen into GameService loop

---

## Testing Strategy

### Unit Tests

**EquipmentIntegrationTests.cs:**
- InventoryIntegration_CorrectlySetsWeaponDamage
- Combatant_FromCharacter_CalculatesSoakCorrectly

**StatusEffectServiceTests.cs:**
- ApplyStatus_NewEffect_AddsToList
- ApplyStatus_ExistingBleed_IncrementsStacks
- ProcessTurnStart_Bleeding_DealsDamage
- CanAct_Stunned_ReturnsFalse

**CombatViewModelTests.cs:**
- ViewModel_Mapping creates correct StatusEffectView

### Integration Tests

- Stun Loop: Apply -> NextTurn -> Verify skip
- Bleed Death: Apply -> Process -> Verify death from tick

---

## Draft Changelog

```markdown
# Changelog: v0.2.1 - The Armory & The Affliction

## Summary
Major update introducing persistent equipment, procedural loot, and the status
effect system. Combat is now fully data-driven.

## Features
- **Equipment Integration:** Combat calculates damage from equipped weapons and armor
- **Status Effects:** Added Bleeding, Poisoned, Stunned, and Fortified
  - Visual icons in TUI (ü©∏, ‚ò†Ô∏è, ‚ö°, üõ°Ô∏è)
  - Stacking, Refreshing, and Turn-Skipping mechanics
- **Loot System:** Enemies drop procedural loot based on Biome and Danger Level
- **Victory Screen:** Post-combat UI displays XP and looted items

## Technical
- Implemented StatusEffectService for temporal mechanics
- Updated Combatant to snapshot equipment stats
- Refactored AttackResolutionService for dynamic modifiers
```

---

*Next: v0.2.2 - The Bestiary (Enemy templates, AI behaviors, Elite traits)*
