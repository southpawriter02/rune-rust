## v0.15.0 - Dice Pool System Refactor

**Focus:** Align dice system implementation with SPEC-CORE-DICE specification (success-counting mechanic)

**Source Specification:** [dice-system.md](../../aethelgard/design/01-core/dice-system.md)

### Overview

This version refactors the dice pool system from a **total-based mechanic** (sum dice, compare to DC) to a **success-counting mechanic** (count 8-10 as successes, 1s as botches, compare net successes to DC). This fundamental change is required before implementing v0.15.1+ skill expansions, which depend on:

- Fumble detection (0 successes + ≥1 botch)
- Critical success thresholds (net ≥ 5)
- Degrees of success (margin above DC)
- Botch mechanics that reduce net successes

---

### Current vs. Target Implementation

| Aspect | Current Implementation | Target (Spec) |
|--------|------------------------|---------------|
| **Success Model** | Sum all dice, compare total to DC | Count dice showing 8, 9, 10 as successes |
| **Botch Model** | Natural 1 on first die = Critical Failure | All 1s subtract from success count |
| **Net Successes** | N/A (uses totals) | `Successes - Botches` |
| **Critical Success** | First die = 10 | Net Successes ≥ 5 |
| **Fumble** | First die = 1 | 0 Successes AND ≥1 Botch |
| **Degrees of Success** | Binary (pass/fail) | Marginal, Full, Exceptional, Critical |
| **RNG** | Basic `Random` | Seeded PRNG with context awareness |

---

### Deliverables Summary

| Category | Items | Estimated Tests |
|----------|-------|-----------------|
| Value Objects | 4 | 12 |
| Enums | 3 | 6 |
| Interfaces | 2 | 2 |
| Services | 3 | 15 |
| Integration | 2 | 5 |
| **Total** | **14** | **~40** |

---

### v0.15.0a - Core Dice Mechanics Refactor

#### DiceRollResult Value Object (Refactor)

**Current:**
```csharp
public record struct DiceRollResult
{
    public IReadOnlyList<int> IndividualRolls { get; init; }
    public int Total { get; init; }  // Sum of all dice
    public bool HasAdvantage { get; init; }
    // ...
}
```

**Target:**
```csharp
public record struct DiceRollResult
{
    public IReadOnlyList<int> IndividualRolls { get; init; }
    public int TotalSuccesses { get; init; }      // Count of 8, 9, 10
    public int TotalBotches { get; init; }        // Count of 1
    public int NetSuccesses { get; init; }        // Successes - Botches (min 0)
    public bool IsCriticalSuccess { get; init; }  // Net ≥ 5
    public bool IsFumble { get; init; }           // 0 Successes + ≥1 Botch
    public int RawTotal { get; init; }            // Sum (for damage rolls only)
}
```

#### Success Threshold Constants
```csharp
public static class DiceConstants
{
    public const int SuccessThreshold = 8;       // 8, 9, 10 = success
    public const int BotchValue = 1;             // 1 = botch
    public const int CriticalSuccessNet = 5;     // Net ≥ 5 = critical
    public const int MinimumPool = 1;            // Always roll at least 1d10
    public const float SuccessProbability = 0.30f;  // 30% per die
    public const float BotchProbability = 0.10f;    // 10% per die
}
```

#### DiceService Refactor

**Current Roll Logic:**
```csharp
var rolls = Enumerable.Range(0, numberOfDice)
    .Select(_ => _random.Next(1, 11))
    .ToList();
return new DiceRollResult { Total = rolls.Sum(), ... };
```

**Target Roll Logic:**
```csharp
public DiceRollResult Roll(int numberOfDice, string context = "")
{
    numberOfDice = Math.Max(DiceConstants.MinimumPool, numberOfDice);

    var rolls = Enumerable.Range(0, numberOfDice)
        .Select(_ => _randomProvider.Next(1, 11))
        .ToList();

    int successes = rolls.Count(r => r >= DiceConstants.SuccessThreshold);
    int botches = rolls.Count(r => r == DiceConstants.BotchValue);
    int netSuccesses = Math.Max(0, successes - botches);
    bool isFumble = successes == 0 && botches > 0;

    if (isFumble) netSuccesses = 0;

    return new DiceRollResult
    {
        IndividualRolls = rolls,
        TotalSuccesses = successes,
        TotalBotches = botches,
        NetSuccesses = netSuccesses,
        IsCriticalSuccess = netSuccesses >= DiceConstants.CriticalSuccessNet,
        IsFumble = isFumble,
        RawTotal = rolls.Sum()  // Preserved for damage calculations
    };
}
```

**Unit Tests (~8):**
- [ ] Roll returns correct number of dice results
- [ ] Successes counted correctly (8, 9, 10)
- [ ] Botches counted correctly (1)
- [ ] Net successes = successes - botches
- [ ] Net successes minimum is 0
- [ ] Fumble detected when 0 successes and ≥1 botch
- [ ] Critical success detected when net ≥ 5
- [ ] Minimum pool enforced (0 → 1d10)

---

### v0.15.0b - Seeded Random Provider

#### IRandomProvider Interface
```csharp
public interface IRandomProvider
{
    int Next(int minInclusive, int maxExclusive);
    int[] NextMany(int count, int minInclusive, int maxExclusive);
    void SetSeed(int seed);
    int GetCurrentSeed();
    void SaveState();
    void RestoreState();
}
```

#### RngContext Enum
```csharp
public enum RngContext
{
    Combat,       // Locked seed per encounter (deterministic)
    Exploration,  // Fresh seed on load (allows retry)
    Crafting,     // Locked seed per session
    Dialogue,     // Fresh seed on load
    Default       // Uses current context
}
```

#### SeededRandomProvider Implementation
```csharp
public class SeededRandomProvider : IRandomProvider
{
    private Random _random;
    private int _currentSeed;
    private int _savedSeed;
    private RngContext _currentContext;

    public SeededRandomProvider(int? initialSeed = null)
    {
        _currentSeed = initialSeed ?? (int)(DateTime.UtcNow.Ticks % int.MaxValue);
        _random = new Random(_currentSeed);
    }

    public void SetSeed(int seed)
    {
        _currentSeed = seed;
        _random = new Random(seed);
    }

    public int GetCurrentSeed() => _currentSeed;

    public void SaveState() => _savedSeed = _currentSeed;

    public void RestoreState() => SetSeed(_savedSeed);

    public int Next(int minInclusive, int maxExclusive)
    {
        return _random.Next(minInclusive, maxExclusive);
    }

    public int[] NextMany(int count, int minInclusive, int maxExclusive)
    {
        return Enumerable.Range(0, count)
            .Select(_ => _random.Next(minInclusive, maxExclusive))
            .ToArray();
    }
}
```

#### Context-Aware RNG Service
```csharp
public interface IRngContextService
{
    void EnterContext(RngContext context);
    void ExitContext();
    RngContext GetCurrentContext();
    void LockSeedForContext(RngContext context, int seed);
    void ReleaseSeedLock(RngContext context);
}
```

**Unit Tests (~6):**
- [ ] Same seed produces identical sequence
- [ ] Different seeds produce different sequences
- [ ] SaveState/RestoreState works correctly
- [ ] Combat context uses locked seed
- [ ] Exploration context allows fresh seed on load
- [ ] NextMany returns correct count

---

### v0.15.0c - Skill Check Refactor

#### SkillCheckResult Value Object (Refactor)

**Current:**
```csharp
public record SkillCheckResult
{
    public int TotalResult { get; init; }  // Sum-based
    public bool IsSuccess { get; init; }
    public SuccessLevel SuccessLevel { get; init; }
}
```

**Target:**
```csharp
public record SkillCheckResult
{
    public DiceRollResult DiceResult { get; init; }
    public int DifficultyClass { get; init; }
    public int NetSuccesses { get; init; }
    public int Margin { get; init; }           // Net - DC (can be negative)
    public SkillOutcome Outcome { get; init; }
    public bool IsFumble { get; init; }
    public bool IsCriticalSuccess { get; init; }
    public string SkillId { get; init; }
    public string CharacterId { get; init; }
}
```

#### SkillOutcome Enum (Expanded)
```csharp
public enum SkillOutcome
{
    CriticalFailure,    // Fumble (0 successes + ≥1 botch)
    Failure,            // Net < DC
    MarginalSuccess,    // Net = DC
    FullSuccess,        // Net = DC + 1 or 2
    ExceptionalSuccess, // Net = DC + 3 or 4
    CriticalSuccess     // Net ≥ DC + 5 OR Net ≥ 5
}
```

#### Outcome Classification Logic
```csharp
public static SkillOutcome ClassifyOutcome(int netSuccesses, int dc, bool isFumble)
{
    if (isFumble)
        return SkillOutcome.CriticalFailure;

    int margin = netSuccesses - dc;

    if (margin < 0)
        return SkillOutcome.Failure;
    if (margin == 0)
        return SkillOutcome.MarginalSuccess;
    if (margin <= 2)
        return SkillOutcome.FullSuccess;
    if (margin <= 4)
        return SkillOutcome.ExceptionalSuccess;

    return SkillOutcome.CriticalSuccess;
}
```

#### SkillCheckService Refactor
```csharp
public SkillCheckResult PerformCheck(
    string characterId,
    string skillId,
    int difficultyClass,
    SkillContext? context = null)
{
    // Calculate pool: Attribute + Skill Rank + Modifiers
    int basePool = GetAttributeValue(characterId, skillId);
    int skillRank = GetSkillRank(characterId, skillId);
    int modifiers = context?.TotalDiceModifier ?? 0;
    int totalPool = basePool + skillRank + modifiers;

    // Roll using new success-counting mechanic
    var diceResult = _diceService.Roll(totalPool, $"Skill:{skillId}");

    // Classify outcome
    var outcome = ClassifyOutcome(
        diceResult.NetSuccesses,
        difficultyClass,
        diceResult.IsFumble);

    return new SkillCheckResult
    {
        DiceResult = diceResult,
        DifficultyClass = difficultyClass,
        NetSuccesses = diceResult.NetSuccesses,
        Margin = diceResult.NetSuccesses - difficultyClass,
        Outcome = outcome,
        IsFumble = diceResult.IsFumble,
        IsCriticalSuccess = diceResult.IsCriticalSuccess,
        SkillId = skillId,
        CharacterId = characterId
    };
}
```

**Unit Tests (~8):**
- [ ] Skill check uses success-counting
- [ ] Outcome classification correct for each tier
- [ ] Fumble overrides other outcomes
- [ ] Marginal success at exactly DC
- [ ] Critical success at DC + 5
- [ ] Pool includes attribute + skill rank + modifiers
- [ ] Context modifiers applied correctly
- [ ] Negative margin = failure

---

### v0.15.0d - Contested & Extended Checks

#### ContestedCheckResult Value Object
```csharp
public record ContestedCheckResult
{
    public string InitiatorId { get; init; }
    public string DefenderId { get; init; }
    public DiceRollResult InitiatorRoll { get; init; }
    public DiceRollResult DefenderRoll { get; init; }
    public ContestedOutcome Outcome { get; init; }
    public int Margin { get; init; }  // Winner's net - loser's net
}
```

#### ContestedOutcome Enum
```csharp
public enum ContestedOutcome
{
    InitiatorWins,
    DefenderWins,
    Tie,              // Initiator gets minor advantage
    BothFumble,       // Mutual failure
    InitiatorFumble,  // Defender auto-wins
    DefenderFumble    // Initiator auto-wins
}
```

#### Contested Check Logic
```csharp
public ContestedCheckResult ResolveContestedCheck(
    string initiatorId,
    string defenderId,
    string initiatorSkill,
    string defenderSkill,
    SkillContext? initiatorContext = null,
    SkillContext? defenderContext = null)
{
    var initiatorRoll = RollForCharacter(initiatorId, initiatorSkill, initiatorContext);
    var defenderRoll = RollForCharacter(defenderId, defenderSkill, defenderContext);

    ContestedOutcome outcome;
    int margin;

    // Handle fumble cases first
    if (initiatorRoll.IsFumble && defenderRoll.IsFumble)
    {
        outcome = ContestedOutcome.BothFumble;
        margin = 0;
    }
    else if (initiatorRoll.IsFumble)
    {
        outcome = ContestedOutcome.DefenderWins;
        margin = defenderRoll.NetSuccesses;
    }
    else if (defenderRoll.IsFumble)
    {
        outcome = ContestedOutcome.InitiatorWins;
        margin = initiatorRoll.NetSuccesses;
    }
    else
    {
        // Compare net successes
        int diff = initiatorRoll.NetSuccesses - defenderRoll.NetSuccesses;

        if (diff > 0)
        {
            outcome = ContestedOutcome.InitiatorWins;
            margin = diff;
        }
        else if (diff < 0)
        {
            outcome = ContestedOutcome.DefenderWins;
            margin = -diff;
        }
        else
        {
            outcome = ContestedOutcome.Tie;
            margin = 0;
        }
    }

    return new ContestedCheckResult
    {
        InitiatorId = initiatorId,
        DefenderId = defenderId,
        InitiatorRoll = initiatorRoll,
        DefenderRoll = defenderRoll,
        Outcome = outcome,
        Margin = margin
    };
}
```

#### ExtendedCheckState Entity
```csharp
public class ExtendedCheckState
{
    public string CheckId { get; init; }
    public string CharacterId { get; init; }
    public string SkillId { get; init; }
    public int TargetSuccesses { get; init; }
    public int AccumulatedSuccesses { get; private set; }
    public int RoundsRemaining { get; private set; }
    public int MaxRounds { get; init; }
    public List<DiceRollResult> RoundResults { get; } = new();
    public ExtendedCheckStatus Status { get; private set; }
    public int ConsecutiveFumbles { get; private set; }

    public void ProcessRound(DiceRollResult result)
    {
        RoundResults.Add(result);
        RoundsRemaining--;

        if (result.IsFumble)
        {
            ConsecutiveFumbles++;
            AccumulatedSuccesses = Math.Max(0, AccumulatedSuccesses - 2);

            if (ConsecutiveFumbles >= 3)
            {
                Status = ExtendedCheckStatus.CatastrophicFailure;
                return;
            }
        }
        else
        {
            ConsecutiveFumbles = 0;
            AccumulatedSuccesses += result.NetSuccesses;
        }

        if (AccumulatedSuccesses >= TargetSuccesses)
            Status = ExtendedCheckStatus.Succeeded;
        else if (RoundsRemaining <= 0)
            Status = ExtendedCheckStatus.Failed;
    }
}
```

#### ExtendedCheckStatus Enum
```csharp
public enum ExtendedCheckStatus
{
    InProgress,
    Succeeded,
    Failed,
    CatastrophicFailure,  // 3 consecutive fumbles
    Abandoned
}
```

**Unit Tests (~8):**
- [ ] Contested check compares net successes
- [ ] Initiator fumble = defender auto-wins
- [ ] Both fumble = mutual failure
- [ ] Tie gives initiator minor advantage
- [ ] Margin calculated correctly
- [ ] Extended check accumulates successes
- [ ] Extended check fails when rounds exhausted
- [ ] Three consecutive fumbles = catastrophic failure

---

### v0.15.0e - Dice Roll Logging

#### DiceRollLog Record
```csharp
public record DiceRollLog
{
    public Guid RollId { get; init; }
    public DateTime Timestamp { get; init; }
    public int Seed { get; init; }
    public int PoolSize { get; init; }
    public IReadOnlyList<int> Results { get; init; }
    public int NetSuccesses { get; init; }
    public string Context { get; init; }  // "Combat:Attack", "Skill:Acrobatics"
    public Guid? ActorId { get; init; }
    public Guid? TargetId { get; init; }
    public bool IsFumble { get; init; }
    public bool IsCriticalSuccess { get; init; }
}
```

#### IDiceRollLogger Interface
```csharp
public interface IDiceRollLogger
{
    void LogRoll(DiceRollLog log);
    IReadOnlyList<DiceRollLog> GetRollHistory(int count = 100);
    IReadOnlyList<DiceRollLog> GetRollsByContext(string contextPrefix);
    void ClearHistory();
}
```

#### Roll Context Constants
```csharp
public static class RollContexts
{
    public const string CombatAttack = "Combat:Attack";
    public const string CombatDamage = "Combat:Damage";
    public const string CombatResolve = "Combat:Resolve";
    public const string SkillPrefix = "Skill:";
    public const string DialoguePrefix = "Dialogue:";
    public const string CraftingPrefix = "Crafting:";

    public static string Skill(string skillId) => $"{SkillPrefix}{skillId}";
    public static string Dialogue(string type) => $"{DialoguePrefix}{type}";
}
```

**Unit Tests (~4):**
- [ ] Rolls are logged with correct data
- [ ] Roll history retrievable
- [ ] Context filtering works
- [ ] Fumble/critical flags logged correctly

---

### v0.15.0f - Combat Integration

#### Combat Roll Updates

The combat system must be updated to use the new success-counting for attack rolls while preserving sum-based damage rolls.

**Attack Resolution:**
```csharp
public AttackResult ResolveAttack(string attackerId, string targetId, AttackContext context)
{
    // Attack roll uses success counting
    int attackPool = GetAttackPool(attackerId, context);
    var attackRoll = _diceService.Roll(attackPool, RollContexts.CombatAttack);

    // Determine hit quality by net successes
    HitQuality hitQuality = ClassifyHit(attackRoll.NetSuccesses);

    if (hitQuality == HitQuality.Miss)
        return AttackResult.Miss(attackRoll);

    // Damage roll uses sum-based (RawTotal)
    var damageRoll = _diceService.Roll(GetDamagePool(attackerId, context), RollContexts.CombatDamage);
    int baseDamage = damageRoll.RawTotal;

    // Apply hit quality modifiers
    int finalDamage = ApplyHitQualityModifier(baseDamage, hitQuality, attackRoll.IsCriticalSuccess);

    return new AttackResult
    {
        AttackRoll = attackRoll,
        DamageRoll = damageRoll,
        HitQuality = hitQuality,
        FinalDamage = finalDamage,
        IsCritical = attackRoll.IsCriticalSuccess
    };
}
```

#### HitQuality Enum
```csharp
public enum HitQuality
{
    Miss,           // 0 net successes
    GlancingHit,    // 1 net success (-2 damage dice)
    SolidHit,       // 2 net successes (full damage)
    StrongHit,      // 3-4 net successes (+1 bonus die)
    CriticalHit     // 5+ net successes (double dice, bypass armor)
}
```

#### Hit Quality Classification
```csharp
public static HitQuality ClassifyHit(int netSuccesses)
{
    return netSuccesses switch
    {
        0 => HitQuality.Miss,
        1 => HitQuality.GlancingHit,
        2 => HitQuality.SolidHit,
        3 or 4 => HitQuality.StrongHit,
        _ => HitQuality.CriticalHit
    };
}
```

**Unit Tests (~6):**
- [ ] Attack uses success-counting
- [ ] Damage uses sum-based
- [ ] Hit quality matches net successes
- [ ] Critical hit doubles damage dice
- [ ] Glancing hit reduces damage
- [ ] Fumble on attack is auto-miss

---

### Configuration Files

| File | Purpose |
|------|---------|
| `dice-system.json` | Thresholds, probabilities, constants |
| `rng-contexts.json` | Context-specific seeding rules |

#### dice-system.json
```json
{
  "$schema": "./schemas/dice-system.schema.json",
  "version": "1.0.0",
  "successThreshold": 8,
  "botchValue": 1,
  "criticalSuccessNet": 5,
  "minimumPool": 1,
  "probabilities": {
    "successPerDie": 0.30,
    "botchPerDie": 0.10,
    "neutralPerDie": 0.60
  },
  "hitQualityThresholds": {
    "miss": 0,
    "glancingHit": 1,
    "solidHit": 2,
    "strongHit": 3,
    "criticalHit": 5
  }
}
```

---

### Migration Strategy

#### Phase 1: Add New Components (Non-Breaking)
1. Add `IRandomProvider` and `SeededRandomProvider`
2. Add new `DiceRollResult` properties (keep `Total` temporarily)
3. Add `SkillOutcome` enum
4. Add logging infrastructure

#### Phase 2: Refactor Services
1. Update `DiceService` to count successes
2. Update `SkillCheckService` to use new mechanics
3. Update `CombatService` attack resolution

#### Phase 3: Update Tests
1. Update existing tests to expect new behavior
2. Add new tests for success-counting
3. Verify fumble/critical detection

#### Phase 4: Remove Legacy
1. Remove old `Total`-based comparisons
2. Remove old `SuccessLevel` enum (replace with `SkillOutcome`)
3. Clean up deprecated properties

---

### Dependencies

**Requires:**
- v0.4.x-v0.5.x: Existing dice and skill infrastructure
- v0.10.x: Status effect system (for fumble consequences)

**Provides to:**
- v0.15.1: Skill System Infrastructure (SkillContext, FumbleConsequence)
- v0.15.2-v0.15.5: All skill expansions depend on this mechanic
- Combat system: Hit quality based on net successes

---

### Acceptance Criteria

- [ ] DiceService counts successes (8-10) instead of summing
- [ ] Botches (1s) subtract from success count
- [ ] Net successes floor at 0
- [ ] Fumble detected when 0 successes AND ≥1 botch
- [ ] Critical success detected when net ≥ 5
- [ ] SkillOutcome classifies all 6 tiers correctly
- [ ] Contested checks compare net successes
- [ ] Extended checks accumulate across rounds
- [ ] Seeded RNG produces deterministic sequences
- [ ] Combat context uses locked seeds
- [ ] Dice rolls logged with context
- [ ] Combat attacks use success-counting
- [ ] Combat damage preserves sum-based rolls
- [ ] ~40 unit tests pass
- [ ] All existing skill checks continue to work
