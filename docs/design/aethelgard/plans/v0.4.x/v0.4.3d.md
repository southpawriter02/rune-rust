# v0.4.3d: The Backlash (Risk & Corruption)

> **Status:** Planned
> **Parent:** v0.4.3 - The Weaver (Magic Core System)
> **Theme:** The price of power—when the weave unravels, the caster pays in blood and sanity.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Component Specifications](#component-specifications)
5. [Code Implementation](#code-implementation)
6. [Logging Matrix](#logging-matrix)
7. [Unit Testing Specification](#unit-testing-specification)
8. [Integration Points](#integration-points)
9. [Deliverable Checklist](#deliverable-checklist)
10. [Workflow](#workflow)
11. [Changelog](#changelog)

---

## Overview

v0.4.3d introduces **The Backlash**—the consequence system that transforms spellcasting from a simple resource exchange into a calculated risk. When environmental Flux exceeds the Critical threshold (50), every spell becomes a gamble. Fail, and the arcane energies tear back through the caster.

### Design Philosophy

The Backlash system follows three core principles:

1. **Escalating Danger**: Risk scales linearly with Flux. At Flux 50, there's 0% risk. At Flux 100, there's 50% risk.
2. **Graduated Consequences**: Severity depends on how badly the roll fails—a near-miss yields Minor backlash, while catastrophic failures corrupt the soul.
3. **Permanent Stakes**: Corruption is the long-term cost. Each Catastrophic backlash inches the caster toward being "Lost"—unable to cast at all.

### Backlash vs TraumaService Comparison

| Aspect | TraumaService (Stress) | BacklashService (Magic) |
|--------|------------------------|-------------------------|
| **Trigger** | Traumatic events | High-Flux spellcasting |
| **Mitigation** | WILL dice pool | None (pure chance) |
| **Resource** | Stress (0-100) | Corruption (0-100) |
| **Threshold Event** | Breaking Point | Aether Sickness |
| **Permanent** | Trauma (conditional) | Corruption (cumulative) |
| **Recovery** | Rest reduces stress | Corruption never heals naturally |

### Core Mechanics Summary

| Mechanic | Formula | Description |
|----------|---------|-------------|
| **Risk Chance** | `CurrentFlux - 50` (0-50%) | Probability of backlash |
| **Severity** | `RiskChance - Roll` | How badly the roll failed |
| **Minor** | Failed by 1-10 | 1d6 damage to caster |
| **Major** | Failed by 11-25 | 2d6 damage + Aether Sickness (2 turns) |
| **Catastrophic** | Failed by 26+ | 3d6 damage + Aether Sickness (5 turns) + Corruption +1 |

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           MagicService                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ CastSpell(caster, target, spell)                                │   │
│  │     │                                                           │   │
│  │     ├─── 1. CanCast() validation                                │   │
│  │     │                                                           │   │
│  │     ├─── 2. ★ CheckBacklash() ★  ← NEW INTEGRATION POINT       │   │
│  │     │         │                                                 │   │
│  │     │         ├─── If backlash triggered:                       │   │
│  │     │         │       - Apply damage/status/corruption          │   │
│  │     │         │       - Return MagicResult.Backlash()           │   │
│  │     │         │                                                 │   │
│  │     │         └─── If no backlash:                              │   │
│  │     │               - Continue casting                          │   │
│  │     │                                                           │   │
│  │     ├─── 3. Deduct AP, Add Flux                                 │   │
│  │     ├─── 4. Execute spell effect                                │   │
│  │     └─── 5. Return MagicResult.Success()                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ calls
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                          BacklashService                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ CheckBacklash(caster)                                           │   │
│  │     │                                                           │   │
│  │     ├─── 1. Get current Flux from AetherService                 │   │
│  │     │                                                           │   │
│  │     ├─── 2. Calculate risk chance                               │   │
│  │     │         risk = Flux - CriticalThreshold (50)              │   │
│  │     │         if risk <= 0 → return NoBacklash                  │   │
│  │     │                                                           │   │
│  │     ├─── 3. Roll d100                                           │   │
│  │     │         if roll > risk → return NoBacklash                │   │
│  │     │                                                           │   │
│  │     ├─── 4. Determine severity                                  │   │
│  │     │         margin = risk - roll                              │   │
│  │     │         severity = MapToSeverity(margin)                  │   │
│  │     │                                                           │   │
│  │     └─── 5. Apply backlash effects                              │   │
│  │               - Roll and apply damage                           │   │
│  │               - Apply Aether Sickness (if Major/Catastrophic)   │   │
│  │               - Increment Corruption (if Catastrophic)          │   │
│  │               - Publish BacklashEvent                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ GetCorruptionLevel(character)                                   │   │
│  │     - Map corruption value to CorruptionLevel enum              │   │
│  │     - Return penalties for current level                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ ApplyCorruptionPenalties(caster)                                │   │
│  │     - Reduce MaxAP based on corruption level                    │   │
│  │     - Apply Will/Wits penalties                                 │   │
│  │     - Check if "Lost" (cannot cast)                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                        ┌───────────┴───────────┐
                        │                       │
                        ▼                       ▼
           ┌────────────────────┐  ┌────────────────────────┐
           │   AetherService    │  │  StatusEffectService   │
           │  (v0.4.3a)         │  │  (Existing)            │
           │                    │  │                        │
           │  - GetCurrentFlux()│  │  - ApplyEffect()       │
           │  - GetThreshold()  │  │  - HasEffect()         │
           └────────────────────┘  │  - GetStatModifiers()  │
                                   └────────────────────────┘
```

### Backlash Event Flow

```
                    SPELL CAST ATTEMPT
                           │
                           ▼
                 ┌─────────────────────┐
                 │ Get Current Flux    │
                 │ (via AetherService) │
                 └──────────┬──────────┘
                            │
                            ▼
                 ┌─────────────────────┐
                 │ Flux > 50 (Critical)│
                 └──────────┬──────────┘
                            │
              ┌─────────────┴─────────────┐
              │ NO                        │ YES
              ▼                           ▼
    ┌─────────────────┐         ┌─────────────────────┐
    │ No Risk         │         │ Calculate Risk      │
    │ Continue Cast   │         │ Risk = Flux - 50    │
    └─────────────────┘         │ (e.g., Flux 75 = 25%│
                                └──────────┬──────────┘
                                           │
                                           ▼
                                ┌─────────────────────┐
                                │ Roll d100           │
                                │ Roll vs Risk        │
                                └──────────┬──────────┘
                                           │
                     ┌─────────────────────┴─────────────────────┐
                     │ Roll > Risk                               │ Roll ≤ Risk
                     │ (SUCCESS - No Backlash)                   │ (BACKLASH!)
                     ▼                                           ▼
           ┌─────────────────┐                         ┌─────────────────────┐
           │ Continue Cast   │                         │ Calculate Severity  │
           │ (Flux still     │                         │ Margin = Risk - Roll│
           │  added)         │                         └──────────┬──────────┘
           └─────────────────┘                                    │
                                      ┌───────────────────────────┼───────────────────────────┐
                                      │                           │                           │
                                      ▼                           ▼                           ▼
                           ┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
                           │ Margin 1-10     │         │ Margin 11-25    │         │ Margin 26+      │
                           │ MINOR           │         │ MAJOR           │         │ CATASTROPHIC    │
                           │                 │         │                 │         │                 │
                           │ • 1d6 damage    │         │ • 2d6 damage    │         │ • 3d6 damage    │
                           │ • Message       │         │ • Aether Sick 2 │         │ • Aether Sick 5 │
                           │                 │         │ • Message       │         │ • Corruption +1 │
                           └─────────────────┘         └─────────────────┘         │ • Message       │
                                                                                   └─────────────────┘
                                                                                            │
                                                                                            ▼
                                                                                   ┌─────────────────┐
                                                                                   │ SPELL FIZZLES   │
                                                                                   │ AP still spent  │
                                                                                   │ No spell effect │
                                                                                   └─────────────────┘
```

### Data Model Relationships

```
┌──────────────────────────────────────────────────────────────────────────┐
│                              Character                                    │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │ + CurrentCorruption: int (0-100)  ← NEW PROPERTY                   │  │
│  │ + MaxAp: int (base value)                                          │  │
│  │ + EffectiveMaxAp: int (MaxAp × CorruptionMultiplier)               │  │
│  └────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│                          BacklashResult                                   │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │ + Triggered: bool           - Was backlash triggered?              │  │
│  │ + Severity: BacklashSeverity - None, Minor, Major, Catastrophic    │  │
│  │ + DamageDealt: int          - Damage rolled                        │  │
│  │ + AetherSicknessDuration: int - Turns of Aether Sickness (0 if none│  │
│  │ + CorruptionAdded: int      - Corruption gained (0 or 1)           │  │
│  │ + Message: string           - Narrative description                │  │
│  │ + RiskChance: int           - The risk percentage                  │  │
│  │ + Roll: int                 - The d100 roll                        │  │
│  └────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│                         CorruptionPenalties                               │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │ + Level: CorruptionLevel    - Current corruption tier              │  │
│  │ + MaxApMultiplier: double   - 1.0 → 0.0 based on tier              │  │
│  │ + WillPenalty: int          - 0 to -2                              │  │
│  │ + WitsPenalty: int          - 0 to -1                              │  │
│  │ + CanCastSpells: bool       - False if "Lost"                      │  │
│  │ + Description: string       - Domain 4 compliant tier description  │  │
│  └────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────┘
```

---

## Decision Trees

### 1. CheckBacklash Decision Tree

```
CheckBacklash(caster: Combatant)
│
├── INPUT: caster (the spellcaster)
│
├── STEP 1: Get Current Flux
│   ├── flux = _aetherService.GetCurrentFlux()
│   └── Log: "[Backlash] Checking backlash. Current Flux: {Flux}"
│
├── STEP 2: Calculate Risk
│   ├── risk = flux - CriticalThreshold (50)
│   │
│   ├── IF risk <= 0:
│   │   ├── Log: "[Backlash] Flux below critical. No risk."
│   │   └── RETURN BacklashResult.NoBacklash()
│   │
│   └── Log: "[Backlash] Risk chance: {Risk}%"
│
├── STEP 3: Roll for Backlash
│   ├── roll = _diceService.RollSingle(100, "Backlash Check")
│   │
│   ├── IF roll > risk:
│   │   ├── Log: "[Backlash] Roll {Roll} > Risk {Risk}. No backlash."
│   │   └── RETURN BacklashResult.NoBacklash(risk, roll)
│   │
│   └── Log: "[Backlash] BACKLASH TRIGGERED! Roll {Roll} ≤ Risk {Risk}"
│
├── STEP 4: Determine Severity
│   ├── margin = risk - roll
│   │
│   ├── severity = margin switch:
│   │   ├── 1-10   → BacklashSeverity.Minor
│   │   ├── 11-25  → BacklashSeverity.Major
│   │   └── 26+    → BacklashSeverity.Catastrophic
│   │
│   └── Log: "[Backlash] Severity: {Severity} (margin: {Margin})"
│
├── STEP 5: Apply Effects
│   ├── result = ApplyBacklash(caster, severity)
│   └── Log: "[Backlash] Applied: {Damage} damage, {Duration} turns sick"
│
└── RETURN result
```

### 2. ApplyBacklash Decision Tree

```
ApplyBacklash(caster: Combatant, severity: BacklashSeverity)
│
├── INPUT: caster, severity level
│
├── STEP 1: Determine Damage Dice
│   ├── dice = severity switch:
│   │   ├── Minor       → 1
│   │   ├── Major       → 2
│   │   └── Catastrophic → 3
│   │
│   └── Roll damage: damage = Sum(dice × d6)
│
├── STEP 2: Apply Damage to Caster
│   ├── caster.CurrentHp -= damage
│   ├── Log: "[Backlash] {Caster} takes {Damage} backlash damage"
│   │
│   └── IF caster.CurrentHp <= 0:
│       └── Log: "[Backlash] {Caster} knocked unconscious by backlash!"
│
├── STEP 3: Apply Aether Sickness (if Major or Catastrophic)
│   ├── IF severity >= Major:
│   │   ├── duration = severity switch:
│   │   │   ├── Major       → 2
│   │   │   └── Catastrophic → 5
│   │   │
│   │   ├── _statusEffects.ApplyEffect(caster, AetherSickness, duration, caster.Id)
│   │   └── Log: "[Backlash] Applied Aether Sickness for {Duration} turns"
│   │
│   └── ELSE: No status effect
│
├── STEP 4: Increment Corruption (if Catastrophic)
│   ├── IF severity == Catastrophic:
│   │   ├── AddCorruption(caster, 1, "Catastrophic Backlash")
│   │   └── Log: "[Backlash] CORRUPTION gained! Total: {Corruption}"
│   │
│   └── ELSE: No corruption
│
├── STEP 5: Build Narrative Message
│   ├── message = severity switch:
│   │   ├── Minor       → "The weave snaps back, stinging {Caster}!"
│   │   ├── Major       → "Arcane energies tear through {Caster}, leaving them reeling!"
│   │   └── Catastrophic → "Reality itself rejects the spell! {Caster} screams as corruption takes root!"
│   │
│   └── Include damage and duration in message
│
├── STEP 6: Publish BacklashEvent
│   ├── event = new BacklashEvent(caster.Id, severity, damage, ...)
│   └── _eventBus.Publish(event)
│
└── RETURN BacklashResult(triggered: true, severity, damage, duration, corruption, message)
```

### 3. GetCorruptionLevel Decision Tree

```
GetCorruptionLevel(character: Character)
│
├── INPUT: character with CurrentCorruption property
│
├── corruption = character.CurrentCorruption
│
├── SWITCH corruption:
│   │
│   ├── 0-9:    RETURN CorruptionLevel.Untouched
│   │           (No penalties - pristine soul)
│   │
│   ├── 10-24:  RETURN CorruptionLevel.Tainted
│   │           (-1 MaxAP)
│   │
│   ├── 25-49:  RETURN CorruptionLevel.Afflicted
│   │           (-2 MaxAP, -1 Will)
│   │
│   ├── 50-74:  RETURN CorruptionLevel.Blighted
│   │           (-3 MaxAP, -2 Will, -1 Wits)
│   │
│   └── 75-100: RETURN CorruptionLevel.Lost
│               (Cannot cast spells - soul consumed)
```

### 4. GetCorruptionPenalties Decision Tree

```
GetCorruptionPenalties(level: CorruptionLevel)
│
├── INPUT: corruption level enum
│
├── RETURN CorruptionPenalties with:
│   │
│   ├── Untouched (0-9):
│   │   ├── MaxApMultiplier: 1.0
│   │   ├── WillPenalty: 0
│   │   ├── WitsPenalty: 0
│   │   ├── CanCastSpells: true
│   │   └── Description: "Your soul remains untouched by the weave's corruption."
│   │
│   ├── Tainted (10-24):
│   │   ├── MaxApMultiplier: 0.9 (-1 effective AP for AP 10)
│   │   ├── WillPenalty: 0
│   │   ├── WitsPenalty: 0
│   │   ├── CanCastSpells: true
│   │   └── Description: "A faint darkness lingers at the edge of your vision."
│   │
│   ├── Afflicted (25-49):
│   │   ├── MaxApMultiplier: 0.8 (-2 effective AP for AP 10)
│   │   ├── WillPenalty: -1
│   │   ├── WitsPenalty: 0
│   │   ├── CanCastSpells: true
│   │   └── Description: "The corruption whispers in quiet moments."
│   │
│   ├── Blighted (50-74):
│   │   ├── MaxApMultiplier: 0.7 (-3 effective AP for AP 10)
│   │   ├── WillPenalty: -2
│   │   ├── WitsPenalty: -1
│   │   ├── CanCastSpells: true
│   │   └── Description: "Your flesh bears the marks of arcane scarring."
│   │
│   └── Lost (75-100):
│       ├── MaxApMultiplier: 0.0 (cannot use AP)
│       ├── WillPenalty: -2
│       ├── WitsPenalty: -1
│       ├── CanCastSpells: false
│       └── Description: "Your soul has been consumed. Magic no longer answers."
```

### 5. AddCorruption Decision Tree

```
AddCorruption(character: Character, amount: int, source: string)
│
├── INPUT: character, corruption amount, source description
│
├── STEP 1: Record Previous State
│   ├── previousCorruption = character.CurrentCorruption
│   └── previousLevel = GetCorruptionLevel(character)
│
├── STEP 2: Apply Corruption
│   ├── character.CurrentCorruption = Math.Clamp(
│   │       character.CurrentCorruption + amount, 0, 100)
│   │
│   └── Log: "[Corruption] {Character} gained {Amount} corruption from {Source}"
│
├── STEP 3: Check Level Transition
│   ├── newLevel = GetCorruptionLevel(character)
│   │
│   └── IF newLevel != previousLevel:
│       ├── Log: "[Corruption] TIER CHANGE: {Previous} → {New}"
│       ├── Display narrative message for tier transition
│       └── Publish CorruptionTierChangedEvent
│
├── STEP 4: Check for "Lost" State
│   └── IF newLevel == Lost:
│       ├── Log: "[Corruption] {Character} has been LOST to corruption!"
│       └── Trigger special narrative/game state
│
└── RETURN CorruptionResult(previous, new, levelChanged, isLost)
```

### 6. CanCast with Backlash Integration (MagicService Extension)

```
CastSpell(caster, target, spell) - MODIFIED
│
├── STEP 1: Existing CanCast validation
│   └── (All existing checks from v0.4.3c)
│
├── ★ STEP 2: Corruption Check (NEW)
│   ├── penalties = _backlashService.GetCorruptionPenalties(caster)
│   │
│   └── IF !penalties.CanCastSpells:
│       ├── Log: "[Magic] {Caster} is Lost - cannot cast"
│       └── RETURN MagicResult.Failure(CastFailureReason.SoulLost,
│                   "Your soul has been consumed. Magic no longer answers.")
│
├── ★ STEP 3: Backlash Check (NEW)
│   ├── backlashResult = _backlashService.CheckBacklash(caster)
│   │
│   └── IF backlashResult.Triggered:
│       ├── Log: "[Magic] Backlash triggered! Spell fizzles."
│       │
│       ├── Deduct AP (spell cost is lost)
│       ├── Add partial Flux (half of spell's FluxCost)
│       │
│       └── RETURN MagicResult.Backlash(
│               backlashResult.Message,
│               backlashResult.DamageDealt,
│               backlashResult.Severity)
│
├── STEP 4: Execute spell (existing logic)
│   └── (Continue with v0.4.3c implementation)
│
└── RETURN MagicResult.Success(...)
```

---

## Component Specifications

### 1. BacklashSeverity Enum

**File:** `RuneAndRust.Core/Enums/BacklashSeverity.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Severity levels for magical backlash when casting in high-Flux environments.
/// </summary>
public enum BacklashSeverity
{
    /// <summary>
    /// No backlash occurred - safe casting.
    /// </summary>
    None = 0,

    /// <summary>
    /// Minor backlash: 1d6 damage to caster.
    /// Triggered when fail margin is 1-10.
    /// </summary>
    Minor = 1,

    /// <summary>
    /// Major backlash: 2d6 damage + Aether Sickness (2 turns).
    /// Triggered when fail margin is 11-25.
    /// </summary>
    Major = 2,

    /// <summary>
    /// Catastrophic backlash: 3d6 damage + Aether Sickness (5 turns) + 1 Corruption.
    /// Triggered when fail margin is 26+.
    /// </summary>
    Catastrophic = 3
}
```

### 2. CorruptionLevel Enum

**File:** `RuneAndRust.Core/Enums/CorruptionLevel.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Corruption thresholds representing the caster's soul degradation.
/// Corruption accumulates from Catastrophic backlash and never heals naturally.
/// </summary>
public enum CorruptionLevel
{
    /// <summary>
    /// 0-9 corruption. No penalties. Soul remains pristine.
    /// </summary>
    Untouched = 0,

    /// <summary>
    /// 10-24 corruption. -1 MaxAP.
    /// A faint darkness lingers at the edge of vision.
    /// </summary>
    Tainted = 1,

    /// <summary>
    /// 25-49 corruption. -2 MaxAP, -1 Will.
    /// The corruption whispers in quiet moments.
    /// </summary>
    Afflicted = 2,

    /// <summary>
    /// 50-74 corruption. -3 MaxAP, -2 Will, -1 Wits.
    /// Flesh bears the marks of arcane scarring.
    /// </summary>
    Blighted = 3,

    /// <summary>
    /// 75-100 corruption. Cannot cast spells.
    /// Soul has been consumed by the weave.
    /// </summary>
    Lost = 4
}
```

### 3. BacklashResult Record

**File:** `RuneAndRust.Core/Models/Magic/BacklashResult.cs`

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Result of a backlash check during spellcasting.
/// </summary>
public record BacklashResult
{
    /// <summary>
    /// Whether backlash was triggered.
    /// </summary>
    public bool Triggered { get; init; }

    /// <summary>
    /// Severity of the backlash (None if not triggered).
    /// </summary>
    public BacklashSeverity Severity { get; init; }

    /// <summary>
    /// Damage dealt to the caster by backlash.
    /// </summary>
    public int DamageDealt { get; init; }

    /// <summary>
    /// Duration of Aether Sickness applied (0 if none).
    /// </summary>
    public int AetherSicknessDuration { get; init; }

    /// <summary>
    /// Corruption points added (0 or 1).
    /// </summary>
    public int CorruptionAdded { get; init; }

    /// <summary>
    /// Narrative message describing the backlash.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// The calculated risk percentage (Flux - 50).
    /// </summary>
    public int RiskChance { get; init; }

    /// <summary>
    /// The d100 roll result.
    /// </summary>
    public int Roll { get; init; }

    /// <summary>
    /// Factory: No backlash occurred.
    /// </summary>
    public static BacklashResult NoBacklash(int riskChance = 0, int roll = 0) => new()
    {
        Triggered = false,
        Severity = BacklashSeverity.None,
        DamageDealt = 0,
        AetherSicknessDuration = 0,
        CorruptionAdded = 0,
        Message = string.Empty,
        RiskChance = riskChance,
        Roll = roll
    };

    /// <summary>
    /// Factory: Backlash triggered.
    /// </summary>
    public static BacklashResult Backlash(
        BacklashSeverity severity,
        int damage,
        int sicknessDuration,
        int corruption,
        string message,
        int riskChance,
        int roll) => new()
    {
        Triggered = true,
        Severity = severity,
        DamageDealt = damage,
        AetherSicknessDuration = sicknessDuration,
        CorruptionAdded = corruption,
        Message = message,
        RiskChance = riskChance,
        Roll = roll
    };

    /// <summary>
    /// Computed: How badly the roll failed (risk - roll).
    /// </summary>
    public int FailMargin => RiskChance - Roll;
}
```

### 4. CorruptionPenalties Record

**File:** `RuneAndRust.Core/Models/Magic/CorruptionPenalties.cs`

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Penalties applied based on a character's corruption level.
/// </summary>
public record CorruptionPenalties
{
    /// <summary>
    /// The corruption level tier.
    /// </summary>
    public CorruptionLevel Level { get; init; }

    /// <summary>
    /// Raw corruption value (0-100).
    /// </summary>
    public int CorruptionValue { get; init; }

    /// <summary>
    /// Multiplier for MaxAP (1.0 = no penalty, 0.0 = cannot use AP).
    /// </summary>
    public double MaxApMultiplier { get; init; } = 1.0;

    /// <summary>
    /// Penalty to Will attribute (negative value).
    /// </summary>
    public int WillPenalty { get; init; }

    /// <summary>
    /// Penalty to Wits attribute (negative value).
    /// </summary>
    public int WitsPenalty { get; init; }

    /// <summary>
    /// Whether the character can still cast spells.
    /// </summary>
    public bool CanCastSpells { get; init; } = true;

    /// <summary>
    /// Domain 4 compliant description of the corruption state.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Computed: Effective MaxAP reduction for display (assumes base 10 AP).
    /// </summary>
    public int EffectiveApPenalty => (int)((1.0 - MaxApMultiplier) * 10);
}
```

### 5. BacklashEvent Record

**File:** `RuneAndRust.Core/Events/BacklashEvent.cs`

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Event published when magical backlash occurs.
/// </summary>
public record BacklashEvent(
    Guid CasterId,
    string CasterName,
    BacklashSeverity Severity,
    int DamageDealt,
    int AetherSicknessDuration,
    int CorruptionAdded,
    int RiskChance,
    int Roll,
    int CurrentFlux,
    string? SpellAttempted = null)
{
    /// <summary>
    /// Computed: Whether corruption was gained.
    /// </summary>
    public bool GainedCorruption => CorruptionAdded > 0;

    /// <summary>
    /// Computed: Severity display string.
    /// </summary>
    public string SeverityDisplay => Severity.ToString().ToUpper();
}
```

### 6. CorruptionChangedEvent Record

**File:** `RuneAndRust.Core/Events/CorruptionChangedEvent.cs`

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Event published when a character's corruption changes.
/// </summary>
public record CorruptionChangedEvent(
    Guid CharacterId,
    string CharacterName,
    int PreviousCorruption,
    int NewCorruption,
    CorruptionLevel PreviousLevel,
    CorruptionLevel NewLevel,
    string Source)
{
    /// <summary>
    /// Computed: Whether the corruption tier changed.
    /// </summary>
    public bool TierChanged => PreviousLevel != NewLevel;

    /// <summary>
    /// Computed: Whether the character became "Lost".
    /// </summary>
    public bool BecameLost => NewLevel == CorruptionLevel.Lost && PreviousLevel != CorruptionLevel.Lost;

    /// <summary>
    /// Computed: Corruption added.
    /// </summary>
    public int CorruptionAdded => NewCorruption - PreviousCorruption;
}
```

### 7. IBacklashService Interface

**File:** `RuneAndRust.Core/Interfaces/IBacklashService.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service contract for magical backlash mechanics.
/// Handles risk calculation, effect application, and corruption tracking.
/// </summary>
public interface IBacklashService
{
    /// <summary>
    /// Checks if backlash occurs and applies effects if triggered.
    /// Should be called BEFORE executing a spell when Flux > Critical.
    /// </summary>
    /// <param name="caster">The spellcaster to check.</param>
    /// <param name="spellName">Optional: Name of spell being attempted (for logging).</param>
    /// <returns>Result indicating if backlash occurred and its effects.</returns>
    BacklashResult CheckBacklash(Combatant caster, string? spellName = null);

    /// <summary>
    /// Gets the current backlash risk percentage based on Flux level.
    /// Risk = CurrentFlux - CriticalThreshold (50). Returns 0 if below critical.
    /// </summary>
    /// <returns>Risk percentage (0-50).</returns>
    int GetCurrentRisk();

    /// <summary>
    /// Determines if there is any backlash risk at current Flux level.
    /// </summary>
    /// <returns>True if Flux > CriticalThreshold.</returns>
    bool IsAtRisk();

    /// <summary>
    /// Gets the corruption level for a character.
    /// </summary>
    /// <param name="character">The character to check.</param>
    /// <returns>The corruption level tier.</returns>
    CorruptionLevel GetCorruptionLevel(Character character);

    /// <summary>
    /// Gets the corruption level for a combatant (via CharacterSource).
    /// </summary>
    /// <param name="combatant">The combatant to check.</param>
    /// <returns>The corruption level tier.</returns>
    CorruptionLevel GetCorruptionLevel(Combatant combatant);

    /// <summary>
    /// Gets all penalties associated with a corruption level.
    /// </summary>
    /// <param name="character">The character to check.</param>
    /// <returns>Penalties record with all modifiers.</returns>
    CorruptionPenalties GetCorruptionPenalties(Character character);

    /// <summary>
    /// Gets all penalties for a combatant (via CharacterSource).
    /// </summary>
    /// <param name="combatant">The combatant to check.</param>
    /// <returns>Penalties record with all modifiers.</returns>
    CorruptionPenalties GetCorruptionPenalties(Combatant combatant);

    /// <summary>
    /// Adds corruption to a character. Publishes CorruptionChangedEvent if tier changes.
    /// </summary>
    /// <param name="character">The character to corrupt.</param>
    /// <param name="amount">Amount of corruption to add.</param>
    /// <param name="source">Source of the corruption (for logging).</param>
    void AddCorruption(Character character, int amount, string source);

    /// <summary>
    /// Attempts to reduce corruption (rare, requires special items/rituals).
    /// </summary>
    /// <param name="character">The character to purify.</param>
    /// <param name="amount">Amount of corruption to remove.</param>
    /// <param name="source">Source of purification (for logging).</param>
    /// <returns>True if corruption was reduced.</returns>
    bool PurgeCorruption(Character character, int amount, string source);

    /// <summary>
    /// Checks if a character can cast spells based on corruption level.
    /// </summary>
    /// <param name="character">The character to check.</param>
    /// <returns>True if not "Lost".</returns>
    bool CanCastSpells(Character character);
}
```

---

## Code Implementation

### 1. StatusEffectType Extension (Aether Sickness)

Add to `StatusEffectType.cs`:

```csharp
// In the enum definition (around line 7-8):

/// <summary>
/// Aether Sickness: -2 Will, -1 Wits, blocks concentration spells.
/// Applied by Major or Catastrophic backlash.
/// </summary>
AetherSickness = 8,
```

Add to `ActiveStatusEffect.cs` helper methods:

```csharp
// In GetMaxStacks method (if it exists) or create new:
public static int GetMaxStacks(StatusEffectType type) => type switch
{
    StatusEffectType.Bleeding => 5,
    StatusEffectType.Poisoned => 5,
    StatusEffectType.Fortified => 5,
    StatusEffectType.AetherSickness => 1, // Non-stackable, refreshes duration
    _ => 1
};
```

### 2. BacklashService Implementation

**File:** `RuneAndRust.Engine/Services/BacklashService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Combat;
using RuneAndRust.Core.Models.Magic;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Manages magical backlash mechanics and corruption tracking.
/// The price of power—when the weave unravels.
/// </summary>
public class BacklashService : IBacklashService
{
    private readonly IAetherService _aetherService;
    private readonly IDiceService _diceService;
    private readonly IStatusEffectService _statusEffects;
    private readonly IEventBus _eventBus;
    private readonly ILogger<BacklashService> _logger;

    /// <summary>
    /// Flux level above which backlash risk begins.
    /// </summary>
    private const int CriticalThreshold = 50;

    /// <summary>
    /// Severity boundaries for fail margin.
    /// </summary>
    private const int MinorMaxMargin = 10;
    private const int MajorMaxMargin = 25;

    /// <summary>
    /// Corruption level thresholds.
    /// </summary>
    private const int TaintedThreshold = 10;
    private const int AfflictedThreshold = 25;
    private const int BlightedThreshold = 50;
    private const int LostThreshold = 75;

    public BacklashService(
        IAetherService aetherService,
        IDiceService diceService,
        IStatusEffectService statusEffects,
        IEventBus eventBus,
        ILogger<BacklashService> logger)
    {
        _aetherService = aetherService;
        _diceService = diceService;
        _statusEffects = statusEffects;
        _eventBus = eventBus;
        _logger = logger;

        _logger.LogDebug("[Backlash] BacklashService initialized");
    }

    /// <inheritdoc/>
    public BacklashResult CheckBacklash(Combatant caster, string? spellName = null)
    {
        var flux = _aetherService.GetCurrentFlux();
        _logger.LogDebug("[Backlash] Checking backlash for {Caster}. Flux: {Flux}, Spell: {Spell}",
            caster.Name, flux, spellName ?? "(unknown)");

        // Calculate risk
        var risk = GetCurrentRisk();

        if (risk <= 0)
        {
            _logger.LogDebug("[Backlash] Flux {Flux} below critical ({Threshold}). No risk.",
                flux, CriticalThreshold);
            return BacklashResult.NoBacklash();
        }

        _logger.LogInformation("[Backlash] {Caster} casting at {Risk}% risk (Flux: {Flux})",
            caster.Name, risk, flux);

        // Roll for backlash
        var roll = _diceService.RollSingle(100, $"Backlash check for {caster.Name}");

        if (roll > risk)
        {
            _logger.LogDebug("[Backlash] Roll {Roll} > Risk {Risk}. Safe cast.",
                roll, risk);
            return BacklashResult.NoBacklash(risk, roll);
        }

        // BACKLASH TRIGGERED
        _logger.LogWarning("[Backlash] BACKLASH! {Caster} rolled {Roll} ≤ {Risk}",
            caster.Name, roll, risk);

        // Determine severity
        var margin = risk - roll;
        var severity = DetermineSeverity(margin);

        _logger.LogInformation("[Backlash] Severity: {Severity} (margin: {Margin})",
            severity, margin);

        // Apply backlash effects
        var result = ApplyBacklashEffects(caster, severity, risk, roll, flux, spellName);

        return result;
    }

    /// <inheritdoc/>
    public int GetCurrentRisk()
    {
        var flux = _aetherService.GetCurrentFlux();
        return Math.Max(0, flux - CriticalThreshold);
    }

    /// <inheritdoc/>
    public bool IsAtRisk()
    {
        return GetCurrentRisk() > 0;
    }

    /// <inheritdoc/>
    public CorruptionLevel GetCorruptionLevel(Character character)
    {
        var corruption = character.CurrentCorruption;
        return MapCorruptionToLevel(corruption);
    }

    /// <inheritdoc/>
    public CorruptionLevel GetCorruptionLevel(Combatant combatant)
    {
        if (combatant.CharacterSource == null)
            return CorruptionLevel.Untouched;

        return GetCorruptionLevel(combatant.CharacterSource);
    }

    /// <inheritdoc/>
    public CorruptionPenalties GetCorruptionPenalties(Character character)
    {
        var level = GetCorruptionLevel(character);
        return BuildPenalties(level, character.CurrentCorruption);
    }

    /// <inheritdoc/>
    public CorruptionPenalties GetCorruptionPenalties(Combatant combatant)
    {
        if (combatant.CharacterSource == null)
            return BuildPenalties(CorruptionLevel.Untouched, 0);

        return GetCorruptionPenalties(combatant.CharacterSource);
    }

    /// <inheritdoc/>
    public void AddCorruption(Character character, int amount, string source)
    {
        var previousCorruption = character.CurrentCorruption;
        var previousLevel = GetCorruptionLevel(character);

        character.CurrentCorruption = Math.Clamp(
            character.CurrentCorruption + amount, 0, 100);

        var newLevel = GetCorruptionLevel(character);

        _logger.LogWarning("[Corruption] {Character} gained {Amount} corruption from {Source}. " +
            "Total: {Total} ({Level})",
            character.Name, amount, source, character.CurrentCorruption, newLevel);

        // Publish event
        var corruptionEvent = new CorruptionChangedEvent(
            character.Id,
            character.Name,
            previousCorruption,
            character.CurrentCorruption,
            previousLevel,
            newLevel,
            source);

        _eventBus.Publish(corruptionEvent);

        // Log tier change
        if (previousLevel != newLevel)
        {
            _logger.LogWarning("[Corruption] TIER CHANGE: {Character} is now {Level}",
                character.Name, newLevel);

            if (newLevel == CorruptionLevel.Lost)
            {
                _logger.LogError("[Corruption] {Character} has been LOST to corruption!",
                    character.Name);
            }
        }
    }

    /// <inheritdoc/>
    public bool PurgeCorruption(Character character, int amount, string source)
    {
        if (character.CurrentCorruption <= 0)
        {
            _logger.LogDebug("[Corruption] {Character} has no corruption to purge",
                character.Name);
            return false;
        }

        var previousCorruption = character.CurrentCorruption;
        var previousLevel = GetCorruptionLevel(character);

        character.CurrentCorruption = Math.Max(0, character.CurrentCorruption - amount);

        var newLevel = GetCorruptionLevel(character);

        _logger.LogInformation("[Corruption] {Character} purged {Amount} corruption via {Source}. " +
            "Total: {Total} ({Level})",
            character.Name, amount, source, character.CurrentCorruption, newLevel);

        // Publish event
        var corruptionEvent = new CorruptionChangedEvent(
            character.Id,
            character.Name,
            previousCorruption,
            character.CurrentCorruption,
            previousLevel,
            newLevel,
            source);

        _eventBus.Publish(corruptionEvent);

        return true;
    }

    /// <inheritdoc/>
    public bool CanCastSpells(Character character)
    {
        return GetCorruptionLevel(character) != CorruptionLevel.Lost;
    }

    #region Private Methods

    /// <summary>
    /// Maps fail margin to severity level.
    /// </summary>
    private static BacklashSeverity DetermineSeverity(int margin)
    {
        return margin switch
        {
            <= MinorMaxMargin => BacklashSeverity.Minor,     // 1-10
            <= MajorMaxMargin => BacklashSeverity.Major,     // 11-25
            _ => BacklashSeverity.Catastrophic               // 26+
        };
    }

    /// <summary>
    /// Applies backlash effects based on severity.
    /// </summary>
    private BacklashResult ApplyBacklashEffects(
        Combatant caster,
        BacklashSeverity severity,
        int risk,
        int roll,
        int flux,
        string? spellName)
    {
        // Determine damage dice
        var damageDice = severity switch
        {
            BacklashSeverity.Minor => 1,
            BacklashSeverity.Major => 2,
            BacklashSeverity.Catastrophic => 3,
            _ => 0
        };

        // Roll damage
        var damage = 0;
        for (var i = 0; i < damageDice; i++)
        {
            damage += _diceService.RollSingle(6, $"Backlash damage {i + 1}/{damageDice}");
        }

        // Apply damage
        caster.CurrentHp -= damage;
        _logger.LogWarning("[Backlash] {Caster} takes {Damage} backlash damage (HP: {Current}/{Max})",
            caster.Name, damage, caster.CurrentHp, caster.MaxHp);

        // Determine Aether Sickness duration
        var sicknessDuration = severity switch
        {
            BacklashSeverity.Major => 2,
            BacklashSeverity.Catastrophic => 5,
            _ => 0
        };

        // Apply Aether Sickness
        if (sicknessDuration > 0)
        {
            _statusEffects.ApplyEffect(caster, StatusEffectType.AetherSickness, sicknessDuration, caster.Id);
            _logger.LogWarning("[Backlash] {Caster} afflicted with Aether Sickness for {Duration} turns",
                caster.Name, sicknessDuration);
        }

        // Apply Corruption (Catastrophic only)
        var corruption = 0;
        if (severity == BacklashSeverity.Catastrophic && caster.CharacterSource != null)
        {
            corruption = 1;
            AddCorruption(caster.CharacterSource, corruption, "Catastrophic Backlash");
        }

        // Build narrative message
        var message = BuildBacklashMessage(caster, severity, damage, sicknessDuration, corruption);

        // Publish event
        var backlashEvent = new BacklashEvent(
            caster.Id,
            caster.Name,
            severity,
            damage,
            sicknessDuration,
            corruption,
            risk,
            roll,
            flux,
            spellName);

        _eventBus.Publish(backlashEvent);

        _logger.LogDebug("[Backlash] Published BacklashEvent: {Severity} for {Caster}",
            severity, caster.Name);

        // Check if caster died
        if (caster.CurrentHp <= 0)
        {
            _logger.LogError("[Backlash] {Caster} killed by backlash damage!",
                caster.Name);
        }

        return BacklashResult.Backlash(
            severity,
            damage,
            sicknessDuration,
            corruption,
            message,
            risk,
            roll);
    }

    /// <summary>
    /// Builds Domain 4 compliant narrative message.
    /// </summary>
    private static string BuildBacklashMessage(
        Combatant caster,
        BacklashSeverity severity,
        int damage,
        int sicknessDuration,
        int corruption)
    {
        var baseMessage = severity switch
        {
            BacklashSeverity.Minor =>
                $"The weave snaps back, stinging {caster.Name} for {damage} damage!",

            BacklashSeverity.Major =>
                $"Arcane energies tear through {caster.Name}, dealing {damage} damage " +
                $"and leaving them reeling with Aether Sickness!",

            BacklashSeverity.Catastrophic =>
                $"Reality itself rejects the spell! {caster.Name} screams as {damage} damage " +
                $"tears through their body. Corruption takes root in their soul!",

            _ => string.Empty
        };

        return baseMessage;
    }

    /// <summary>
    /// Maps corruption value to level enum.
    /// </summary>
    private static CorruptionLevel MapCorruptionToLevel(int corruption)
    {
        return corruption switch
        {
            >= LostThreshold => CorruptionLevel.Lost,          // 75-100
            >= BlightedThreshold => CorruptionLevel.Blighted,  // 50-74
            >= AfflictedThreshold => CorruptionLevel.Afflicted, // 25-49
            >= TaintedThreshold => CorruptionLevel.Tainted,    // 10-24
            _ => CorruptionLevel.Untouched                      // 0-9
        };
    }

    /// <summary>
    /// Builds penalties record for a corruption level.
    /// </summary>
    private static CorruptionPenalties BuildPenalties(CorruptionLevel level, int corruption)
    {
        return level switch
        {
            CorruptionLevel.Untouched => new CorruptionPenalties
            {
                Level = level,
                CorruptionValue = corruption,
                MaxApMultiplier = 1.0,
                WillPenalty = 0,
                WitsPenalty = 0,
                CanCastSpells = true,
                Description = "Your soul remains untouched by the weave's corruption."
            },

            CorruptionLevel.Tainted => new CorruptionPenalties
            {
                Level = level,
                CorruptionValue = corruption,
                MaxApMultiplier = 0.9,
                WillPenalty = 0,
                WitsPenalty = 0,
                CanCastSpells = true,
                Description = "A faint darkness lingers at the edge of your vision."
            },

            CorruptionLevel.Afflicted => new CorruptionPenalties
            {
                Level = level,
                CorruptionValue = corruption,
                MaxApMultiplier = 0.8,
                WillPenalty = -1,
                WitsPenalty = 0,
                CanCastSpells = true,
                Description = "The corruption whispers in quiet moments."
            },

            CorruptionLevel.Blighted => new CorruptionPenalties
            {
                Level = level,
                CorruptionValue = corruption,
                MaxApMultiplier = 0.7,
                WillPenalty = -2,
                WitsPenalty = -1,
                CanCastSpells = true,
                Description = "Your flesh bears the marks of arcane scarring."
            },

            CorruptionLevel.Lost => new CorruptionPenalties
            {
                Level = level,
                CorruptionValue = corruption,
                MaxApMultiplier = 0.0,
                WillPenalty = -2,
                WitsPenalty = -1,
                CanCastSpells = false,
                Description = "Your soul has been consumed. Magic no longer answers."
            },

            _ => new CorruptionPenalties
            {
                Level = CorruptionLevel.Untouched,
                CorruptionValue = corruption,
                CanCastSpells = true
            }
        };
    }

    #endregion
}
```

### 3. StatusEffectService Extension (Aether Sickness Modifiers)

Add to `StatusEffectService.cs`:

```csharp
/// <summary>
/// Gets attribute modifiers from active status effects.
/// </summary>
/// <param name="combatant">The combatant to check.</param>
/// <param name="attribute">The attribute to get modifiers for.</param>
/// <returns>Total modifier (negative for penalties).</returns>
public int GetAttributeModifier(Combatant combatant, CharacterAttribute attribute)
{
    var modifier = 0;

    // Aether Sickness: -2 Will, -1 Wits
    if (HasEffect(combatant, StatusEffectType.AetherSickness))
    {
        modifier += attribute switch
        {
            CharacterAttribute.Will => -2,
            CharacterAttribute.Wits => -1,
            _ => 0
        };
    }

    // Disoriented: -1 to all pools (existing)
    if (HasEffect(combatant, StatusEffectType.Disoriented))
    {
        modifier -= 1;
    }

    _logger.LogDebug("[StatusEffect] Attribute modifier for {Attribute}: {Modifier}",
        attribute, modifier);

    return modifier;
}

/// <summary>
/// Checks if a combatant can concentrate on spells.
/// Blocked by Aether Sickness.
/// </summary>
/// <param name="combatant">The combatant to check.</param>
/// <returns>True if concentration is allowed.</returns>
public bool CanConcentrate(Combatant combatant)
{
    // Aether Sickness blocks concentration
    if (HasEffect(combatant, StatusEffectType.AetherSickness))
    {
        _logger.LogDebug("[StatusEffect] {Combatant} cannot concentrate (Aether Sickness)",
            combatant.Name);
        return false;
    }

    return true;
}
```

### 4. MagicService Integration (Modified CastSpell)

Add to `MagicService.cs`:

```csharp
private readonly IBacklashService _backlashService;

// Add to constructor:
public MagicService(
    ISpellRepository spellRepository,
    IResourceService resourceService,
    IAetherService aetherService,
    IStatusEffectService statusEffects,
    EffectScriptExecutor effectExecutor,
    IBacklashService backlashService,  // NEW
    IEventBus eventBus,
    ILogger<MagicService> logger)
{
    // ... existing assignments ...
    _backlashService = backlashService;
}

/// <inheritdoc/>
public MagicResult CastSpell(Combatant caster, Combatant target, Spell spell)
{
    _logger.LogInformation("[Magic] {Caster} attempting to cast {Spell} on {Target}",
        caster.Name, spell.Name, target.Name);

    // 1. Validate
    var (canCast, reason) = CanCast(caster, target, spell);
    if (!canCast)
    {
        var failureMessage = GetFailureMessage(reason!.Value, caster, spell);
        _logger.LogDebug("[Magic] Cast failed: {Reason}", reason);
        return MagicResult.Failure(reason.Value, failureMessage);
    }

    // ★ 2. Check Corruption Level (NEW)
    var penalties = _backlashService.GetCorruptionPenalties(caster);
    if (!penalties.CanCastSpells)
    {
        _logger.LogWarning("[Magic] {Caster} is Lost - cannot cast spells", caster.Name);
        return MagicResult.Failure(
            CastFailureReason.SoulLost,
            "Your soul has been consumed. Magic no longer answers.");
    }

    // ★ 3. Check Backlash Risk (NEW)
    if (_backlashService.IsAtRisk())
    {
        var backlashResult = _backlashService.CheckBacklash(caster, spell.Name);

        if (backlashResult.Triggered)
        {
            _logger.LogWarning("[Magic] Backlash triggered! {Spell} fizzles.",
                spell.Name);

            // Deduct AP (spell cost is lost even on backlash)
            _resourceService.Deduct(caster, ResourceType.Aether, spell.ApCost);

            // Add partial Flux (half of spell's cost - the failed attempt still disturbs the weave)
            var partialFlux = spell.FluxCost / 2;
            _aetherService.ModifyFlux(partialFlux, $"Failed cast of {spell.Name} (backlash)");

            return MagicResult.Backlash(
                backlashResult.Message,
                backlashResult.DamageDealt,
                backlashResult.Severity,
                backlashResult.AetherSicknessDuration,
                backlashResult.CorruptionAdded,
                partialFlux);
        }

        _logger.LogDebug("[Magic] Backlash check passed. Continuing cast.");
    }

    // 4. Check for charged spell (existing logic)
    if (spell.ChargeTurns > 0 && !_statusEffects.HasEffect(caster, ChantingEffect))
    {
        return InitiateCharge(caster, spell);
    }

    // 5. Check for charged spell release (existing logic)
    if (spell.ChargeTurns > 0 &&
        _statusEffects.HasEffect(caster, ChantingEffect) &&
        caster.ChanneledAbilityId == spell.Id)
    {
        return ReleaseCharge(caster, target, spell);
    }

    // 6. Instant cast execution (existing logic)
    return ExecuteInstantCast(caster, target, spell);
}
```

### 5. MagicResult Extension (Backlash Factory)

Add to `MagicResult.cs`:

```csharp
/// <summary>
/// Backlash severity for failed casts.
/// </summary>
public BacklashSeverity? BacklashSeverity { get; init; }

/// <summary>
/// Duration of Aether Sickness applied (0 if none).
/// </summary>
public int AetherSicknessDuration { get; init; }

/// <summary>
/// Corruption gained from Catastrophic backlash.
/// </summary>
public int CorruptionGained { get; init; }

/// <summary>
/// Computed: Whether this was a backlash result.
/// </summary>
public bool WasBacklash => BacklashSeverity.HasValue && BacklashSeverity.Value != Core.Enums.BacklashSeverity.None;

/// <summary>
/// Factory: Backlash occurred (spell fizzled).
/// </summary>
public static MagicResult Backlash(
    string message,
    int damageToSelf,
    BacklashSeverity severity,
    int sicknessDuration,
    int corruptionGained,
    int fluxAdded) => new()
{
    Success = false,
    Message = message,
    TotalDamage = damageToSelf, // Note: damage to caster, not target
    FailureReason = CastFailureReason.Backlash,
    BacklashSeverity = severity,
    AetherSicknessDuration = sicknessDuration,
    CorruptionGained = corruptionGained,
    FluxAdded = fluxAdded
};
```

### 6. CastFailureReason Extension

Add to `CastFailureReason.cs`:

```csharp
/// <summary>
/// Backlash triggered - spell fizzled with consequences.
/// </summary>
Backlash = 10,

/// <summary>
/// Soul is Lost - cannot cast any spells.
/// </summary>
SoulLost = 11,
```

### 7. Character Entity Extension

Add to `Character.cs`:

```csharp
/// <summary>
/// Current corruption level (0-100).
/// Accumulated from Catastrophic backlash. Never heals naturally.
/// </summary>
public int CurrentCorruption { get; set; } = 0;
```

### 8. DI Registration (Program.cs)

```csharp
// Add after other service registrations:

// v0.4.3d: Backlash Service
services.AddSingleton<IBacklashService, BacklashService>();
```

---

## Logging Matrix

### BacklashService Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| Constructor | Initialized | Debug | `"[Backlash] BacklashService initialized"` | - |
| CheckBacklash | Checking | Debug | `"[Backlash] Checking backlash for {Caster}. Flux: {Flux}, Spell: {Spell}"` | Caster, Flux, Spell |
| CheckBacklash | BelowCritical | Debug | `"[Backlash] Flux {Flux} below critical ({Threshold}). No risk."` | Flux, Threshold |
| CheckBacklash | AtRisk | Info | `"[Backlash] {Caster} casting at {Risk}% risk (Flux: {Flux})"` | Caster, Risk, Flux |
| CheckBacklash | SafeCast | Debug | `"[Backlash] Roll {Roll} > Risk {Risk}. Safe cast."` | Roll, Risk |
| CheckBacklash | Triggered | Warning | `"[Backlash] BACKLASH! {Caster} rolled {Roll} ≤ {Risk}"` | Caster, Roll, Risk |
| CheckBacklash | Severity | Info | `"[Backlash] Severity: {Severity} (margin: {Margin})"` | Severity, Margin |
| ApplyBacklash | Damage | Warning | `"[Backlash] {Caster} takes {Damage} backlash damage (HP: {Current}/{Max})"` | Caster, Damage, Current, Max |
| ApplyBacklash | Sickness | Warning | `"[Backlash] {Caster} afflicted with Aether Sickness for {Duration} turns"` | Caster, Duration |
| ApplyBacklash | EventPublished | Debug | `"[Backlash] Published BacklashEvent: {Severity} for {Caster}"` | Severity, Caster |
| ApplyBacklash | Death | Error | `"[Backlash] {Caster} killed by backlash damage!"` | Caster |
| GetCurrentRisk | Calculating | Debug | `"[Backlash] Current risk: {Risk}% (Flux: {Flux})"` | Risk, Flux |
| AddCorruption | Added | Warning | `"[Corruption] {Character} gained {Amount} corruption from {Source}. Total: {Total} ({Level})"` | Character, Amount, Source, Total, Level |
| AddCorruption | TierChange | Warning | `"[Corruption] TIER CHANGE: {Character} is now {Level}"` | Character, Level |
| AddCorruption | Lost | Error | `"[Corruption] {Character} has been LOST to corruption!"` | Character |
| PurgeCorruption | Purged | Info | `"[Corruption] {Character} purged {Amount} corruption via {Source}. Total: {Total} ({Level})"` | Character, Amount, Source, Total, Level |
| PurgeCorruption | NoneToRemove | Debug | `"[Corruption] {Character} has no corruption to purge"` | Character |

### MagicService Logging (Backlash Integration)

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| CastSpell | SoulLost | Warning | `"[Magic] {Caster} is Lost - cannot cast spells"` | Caster |
| CastSpell | BacklashTriggered | Warning | `"[Magic] Backlash triggered! {Spell} fizzles."` | Spell |
| CastSpell | BacklashCheckPassed | Debug | `"[Magic] Backlash check passed. Continuing cast."` | - |

---

## Unit Testing Specification

### Test Class: BacklashServiceTests.cs

**File:** `RuneAndRust.Tests/Engine/Services/BacklashServiceTests.cs`

#### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| Risk Calculation | 8 | Various Flux levels, threshold edge cases |
| Trigger Detection | 8 | Roll vs risk comparisons |
| Severity Determination | 6 | All severity levels and boundaries |
| Effect Application | 10 | Damage, status, corruption increment |
| Corruption Levels | 8 | All thresholds, penalties, Lost state |
| Event Publishing | 4 | BacklashEvent, CorruptionChangedEvent |
| Integration | 4 | MagicService → BacklashService flow |

**Total: 48 tests**

#### Test Implementation

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using NSubstitute;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Combat;
using RuneAndRust.Core.Models.Magic;
using RuneAndRust.Engine.Services;
using Xunit;

namespace RuneAndRust.Tests.Engine.Services;

/// <summary>
/// Unit tests for BacklashService (v0.4.3d - The Backlash).
/// </summary>
public class BacklashServiceTests
{
    private readonly IAetherService _mockAetherService;
    private readonly IDiceService _mockDiceService;
    private readonly IStatusEffectService _mockStatusEffects;
    private readonly IEventBus _mockEventBus;
    private readonly ILogger<BacklashService> _mockLogger;
    private readonly BacklashService _sut;

    public BacklashServiceTests()
    {
        _mockAetherService = Substitute.For<IAetherService>();
        _mockDiceService = Substitute.For<IDiceService>();
        _mockStatusEffects = Substitute.For<IStatusEffectService>();
        _mockEventBus = Substitute.For<IEventBus>();
        _mockLogger = Substitute.For<ILogger<BacklashService>>();

        // Default: Flux at safe level
        _mockAetherService.GetCurrentFlux().Returns(25);

        // Default: Roll safe
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(75);

        _sut = new BacklashService(
            _mockAetherService,
            _mockDiceService,
            _mockStatusEffects,
            _mockEventBus,
            _mockLogger);
    }

    #region Risk Calculation Tests

    [Fact]
    public void GetCurrentRisk_ReturnsZero_WhenFluxBelowCritical()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(49);

        // Act
        var risk = _sut.GetCurrentRisk();

        // Assert
        risk.Should().Be(0);
    }

    [Fact]
    public void GetCurrentRisk_ReturnsZero_WhenFluxAtExactCritical()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(50);

        // Act
        var risk = _sut.GetCurrentRisk();

        // Assert
        risk.Should().Be(0);
    }

    [Fact]
    public void GetCurrentRisk_ReturnsCorrectRisk_WhenFluxAboveCritical()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(75);

        // Act
        var risk = _sut.GetCurrentRisk();

        // Assert
        risk.Should().Be(25);
    }

    [Fact]
    public void GetCurrentRisk_ReturnsMaxRisk_WhenFluxAtMaximum()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(100);

        // Act
        var risk = _sut.GetCurrentRisk();

        // Assert
        risk.Should().Be(50);
    }

    [Fact]
    public void IsAtRisk_ReturnsFalse_WhenFluxBelowCritical()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(40);

        // Act
        var atRisk = _sut.IsAtRisk();

        // Assert
        atRisk.Should().BeFalse();
    }

    [Fact]
    public void IsAtRisk_ReturnsTrue_WhenFluxAboveCritical()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(60);

        // Act
        var atRisk = _sut.IsAtRisk();

        // Assert
        atRisk.Should().BeTrue();
    }

    [Theory]
    [InlineData(51, 1)]
    [InlineData(60, 10)]
    [InlineData(80, 30)]
    [InlineData(99, 49)]
    public void GetCurrentRisk_ReturnsExpectedRisk_ForVariousFluxLevels(int flux, int expectedRisk)
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(flux);

        // Act
        var risk = _sut.GetCurrentRisk();

        // Assert
        risk.Should().Be(expectedRisk);
    }

    #endregion

    #region Trigger Detection Tests

    [Fact]
    public void CheckBacklash_ReturnsNoBacklash_WhenFluxBelowCritical()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(49);
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.Triggered.Should().BeFalse();
        result.Severity.Should().Be(BacklashSeverity.None);
    }

    [Fact]
    public void CheckBacklash_ReturnsNoBacklash_WhenRollExceedsRisk()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(70); // 20% risk
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(50); // Roll 50 > 20
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.Triggered.Should().BeFalse();
        result.RiskChance.Should().Be(20);
        result.Roll.Should().Be(50);
    }

    [Fact]
    public void CheckBacklash_TriggersBacklash_WhenRollEqualsRisk()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(70); // 20% risk
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(20); // Roll 20 == 20
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3); // Damage roll
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.Triggered.Should().BeTrue();
    }

    [Fact]
    public void CheckBacklash_TriggersBacklash_WhenRollBelowRisk()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(80); // 30% risk
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(15); // Roll 15 < 30
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(4); // Damage roll
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.Triggered.Should().BeTrue();
        result.FailMargin.Should().Be(15); // 30 - 15
    }

    [Fact]
    public void CheckBacklash_DoesNotCallDice_WhenFluxBelowCritical()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(40);
        var caster = CreateTestCombatant();

        // Act
        _sut.CheckBacklash(caster);

        // Assert
        _mockDiceService.DidNotReceive().RollSingle(100, Arg.Any<string>());
    }

    [Fact]
    public void CheckBacklash_RecordsRiskAndRoll_InResult()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(75); // 25% risk
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(60); // Safe roll
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.RiskChance.Should().Be(25);
        result.Roll.Should().Be(60);
    }

    #endregion

    #region Severity Determination Tests

    [Theory]
    [InlineData(30, 25, BacklashSeverity.Minor)]    // Margin 5 (1-10 = Minor)
    [InlineData(30, 20, BacklashSeverity.Minor)]    // Margin 10 (boundary)
    [InlineData(40, 25, BacklashSeverity.Major)]    // Margin 15 (11-25 = Major)
    [InlineData(40, 15, BacklashSeverity.Major)]    // Margin 25 (boundary)
    [InlineData(50, 10, BacklashSeverity.Catastrophic)] // Margin 40 (26+ = Catastrophic)
    public void CheckBacklash_DeterminesCorrectSeverity_FromMargin(
        int risk, int roll, BacklashSeverity expectedSeverity)
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(50 + risk);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(roll);
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3);
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.Severity.Should().Be(expectedSeverity);
    }

    [Fact]
    public void CheckBacklash_MinorSeverity_RollsOneDie()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(60); // 10% risk
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(5); // Margin 5 = Minor
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(4);
        var caster = CreateTestCombatant();

        // Act
        _sut.CheckBacklash(caster);

        // Assert
        _mockDiceService.Received(1).RollSingle(6, Arg.Is<string>(s => s.Contains("Backlash damage")));
    }

    [Fact]
    public void CheckBacklash_MajorSeverity_RollsTwoDice()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(80); // 30% risk
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(15); // Margin 15 = Major
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(4);
        var caster = CreateTestCombatant();

        // Act
        _sut.CheckBacklash(caster);

        // Assert
        _mockDiceService.Received(2).RollSingle(6, Arg.Is<string>(s => s.Contains("Backlash damage")));
    }

    [Fact]
    public void CheckBacklash_CatastrophicSeverity_RollsThreeDice()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(100); // 50% risk
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(10); // Margin 40 = Catastrophic
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(5);
        var caster = CreateTestCombatant();

        // Act
        _sut.CheckBacklash(caster);

        // Assert
        _mockDiceService.Received(3).RollSingle(6, Arg.Is<string>(s => s.Contains("Backlash damage")));
    }

    #endregion

    #region Effect Application Tests

    [Fact]
    public void CheckBacklash_AppliesDamage_ToCaster()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(60);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(5); // Trigger
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(4);
        var caster = CreateTestCombatant(hp: 50);

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.DamageDealt.Should().Be(4);
        caster.CurrentHp.Should().Be(46);
    }

    [Fact]
    public void CheckBacklash_MinorSeverity_DoesNotApplyAetherSickness()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(60);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(5); // Minor
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3);
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.AetherSicknessDuration.Should().Be(0);
        _mockStatusEffects.DidNotReceive().ApplyEffect(
            Arg.Any<Combatant>(), StatusEffectType.AetherSickness, Arg.Any<int>(), Arg.Any<Guid>());
    }

    [Fact]
    public void CheckBacklash_MajorSeverity_AppliesAetherSickness_For2Turns()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(80);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(15); // Major (margin 15)
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3);
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.AetherSicknessDuration.Should().Be(2);
        _mockStatusEffects.Received(1).ApplyEffect(
            caster, StatusEffectType.AetherSickness, 2, caster.Id);
    }

    [Fact]
    public void CheckBacklash_CatastrophicSeverity_AppliesAetherSickness_For5Turns()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(100);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(10); // Catastrophic (margin 40)
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3);
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.AetherSicknessDuration.Should().Be(5);
        _mockStatusEffects.Received(1).ApplyEffect(
            caster, StatusEffectType.AetherSickness, 5, caster.Id);
    }

    [Fact]
    public void CheckBacklash_MinorSeverity_DoesNotAddCorruption()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(60);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(5);
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3);
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.CorruptionAdded.Should().Be(0);
    }

    [Fact]
    public void CheckBacklash_MajorSeverity_DoesNotAddCorruption()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(80);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(15);
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3);
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.CorruptionAdded.Should().Be(0);
    }

    [Fact]
    public void CheckBacklash_CatastrophicSeverity_AddsOneCorruption()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(100);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(10);
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3);
        var caster = CreateTestCombatant();
        caster.CharacterSource = new Character { Id = Guid.NewGuid(), Name = "Test", CurrentCorruption = 0 };

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.CorruptionAdded.Should().Be(1);
        caster.CharacterSource.CurrentCorruption.Should().Be(1);
    }

    [Fact]
    public void CheckBacklash_ReturnsNarrativeMessage()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(60);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(5);
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(4);
        var caster = CreateTestCombatant();

        // Act
        var result = _sut.CheckBacklash(caster);

        // Assert
        result.Message.Should().Contain(caster.Name);
        result.Message.Should().Contain("4"); // Damage amount
    }

    #endregion

    #region Corruption Level Tests

    [Theory]
    [InlineData(0, CorruptionLevel.Untouched)]
    [InlineData(9, CorruptionLevel.Untouched)]
    [InlineData(10, CorruptionLevel.Tainted)]
    [InlineData(24, CorruptionLevel.Tainted)]
    [InlineData(25, CorruptionLevel.Afflicted)]
    [InlineData(49, CorruptionLevel.Afflicted)]
    [InlineData(50, CorruptionLevel.Blighted)]
    [InlineData(74, CorruptionLevel.Blighted)]
    [InlineData(75, CorruptionLevel.Lost)]
    [InlineData(100, CorruptionLevel.Lost)]
    public void GetCorruptionLevel_ReturnsCorrectLevel(int corruption, CorruptionLevel expected)
    {
        // Arrange
        var character = new Character { CurrentCorruption = corruption };

        // Act
        var level = _sut.GetCorruptionLevel(character);

        // Assert
        level.Should().Be(expected);
    }

    [Fact]
    public void GetCorruptionPenalties_ReturnsNoPenalties_WhenUntouched()
    {
        // Arrange
        var character = new Character { CurrentCorruption = 5 };

        // Act
        var penalties = _sut.GetCorruptionPenalties(character);

        // Assert
        penalties.Level.Should().Be(CorruptionLevel.Untouched);
        penalties.MaxApMultiplier.Should().Be(1.0);
        penalties.WillPenalty.Should().Be(0);
        penalties.WitsPenalty.Should().Be(0);
        penalties.CanCastSpells.Should().BeTrue();
    }

    [Fact]
    public void GetCorruptionPenalties_ReturnsCorrectPenalties_WhenBlighted()
    {
        // Arrange
        var character = new Character { CurrentCorruption = 60 };

        // Act
        var penalties = _sut.GetCorruptionPenalties(character);

        // Assert
        penalties.Level.Should().Be(CorruptionLevel.Blighted);
        penalties.MaxApMultiplier.Should().Be(0.7);
        penalties.WillPenalty.Should().Be(-2);
        penalties.WitsPenalty.Should().Be(-1);
        penalties.CanCastSpells.Should().BeTrue();
    }

    [Fact]
    public void GetCorruptionPenalties_BlocksCasting_WhenLost()
    {
        // Arrange
        var character = new Character { CurrentCorruption = 80 };

        // Act
        var penalties = _sut.GetCorruptionPenalties(character);

        // Assert
        penalties.Level.Should().Be(CorruptionLevel.Lost);
        penalties.CanCastSpells.Should().BeFalse();
    }

    [Fact]
    public void CanCastSpells_ReturnsFalse_WhenLost()
    {
        // Arrange
        var character = new Character { CurrentCorruption = 75 };

        // Act
        var canCast = _sut.CanCastSpells(character);

        // Assert
        canCast.Should().BeFalse();
    }

    [Fact]
    public void AddCorruption_PublishesEvent_OnTierChange()
    {
        // Arrange
        var character = new Character { Id = Guid.NewGuid(), Name = "Test", CurrentCorruption = 9 };

        // Act
        _sut.AddCorruption(character, 5, "Test Source");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<CorruptionChangedEvent>(e =>
            e.TierChanged &&
            e.PreviousLevel == CorruptionLevel.Untouched &&
            e.NewLevel == CorruptionLevel.Tainted));
    }

    [Fact]
    public void AddCorruption_ClampsTo100()
    {
        // Arrange
        var character = new Character { CurrentCorruption = 95 };

        // Act
        _sut.AddCorruption(character, 20, "Test");

        // Assert
        character.CurrentCorruption.Should().Be(100);
    }

    #endregion

    #region Event Publishing Tests

    [Fact]
    public void CheckBacklash_PublishesBacklashEvent_WhenTriggered()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(70);
        _mockDiceService.RollSingle(100, Arg.Any<string>()).Returns(10);
        _mockDiceService.RollSingle(6, Arg.Any<string>()).Returns(3);
        var caster = CreateTestCombatant();

        // Act
        _sut.CheckBacklash(caster, "Test Spell");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<BacklashEvent>(e =>
            e.CasterId == caster.Id &&
            e.SpellAttempted == "Test Spell"));
    }

    [Fact]
    public void CheckBacklash_DoesNotPublishEvent_WhenNoBacklash()
    {
        // Arrange
        _mockAetherService.GetCurrentFlux().Returns(40);
        var caster = CreateTestCombatant();

        // Act
        _sut.CheckBacklash(caster);

        // Assert
        _mockEventBus.DidNotReceive().Publish(Arg.Any<BacklashEvent>());
    }

    #endregion

    #region Helper Methods

    private static Combatant CreateTestCombatant(int hp = 50)
    {
        return new Combatant
        {
            Id = Guid.NewGuid(),
            Name = "Test Caster",
            IsPlayer = true,
            CurrentHp = hp,
            MaxHp = hp,
            CurrentAp = 10,
            MaxAp = 10
        };
    }

    #endregion
}
```

---

## Integration Points

### 1. AetherService Integration (v0.4.3a)

BacklashService queries Flux via:
```csharp
var flux = _aetherService.GetCurrentFlux();
var risk = flux - 50;
```

### 2. MagicService Integration (v0.4.3c)

MagicService calls BacklashService before executing spells:
```csharp
if (_backlashService.IsAtRisk())
{
    var backlashResult = _backlashService.CheckBacklash(caster, spell.Name);
    if (backlashResult.Triggered)
    {
        return MagicResult.Backlash(...);
    }
}
```

### 3. StatusEffectService Integration

Aether Sickness provides stat modifiers:
```csharp
// Called by attribute calculation
int modifier = _statusEffects.GetAttributeModifier(combatant, CharacterAttribute.Will);
// Returns -2 if AetherSickness active
```

### 4. TUI Integration (v0.4.3e - Future)

Combat HUD will display:
- Corruption level indicator
- Backlash risk warning when Flux > 50
- Aether Sickness status icon

---

## Deliverable Checklist

### Core Components

- [ ] **BacklashSeverity.cs** - Enum: None, Minor, Major, Catastrophic
- [ ] **CorruptionLevel.cs** - Enum: Untouched, Tainted, Afflicted, Blighted, Lost
- [ ] **BacklashResult.cs** - Result record with factory methods
- [ ] **CorruptionPenalties.cs** - Penalties record
- [ ] **BacklashEvent.cs** - Event for backlash occurrence
- [ ] **CorruptionChangedEvent.cs** - Event for corruption changes

### Service Layer

- [ ] **IBacklashService.cs** - Interface with 9 methods
- [ ] **BacklashService.cs** - Full implementation with logging

### Status Effect Extension

- [ ] **StatusEffectType.cs** - Add AetherSickness = 8
- [ ] **StatusEffectService.cs** - Add GetAttributeModifier(), CanConcentrate()

### Entity Extension

- [ ] **Character.cs** - Add CurrentCorruption property

### Integration

- [ ] **MagicService.cs** - Add backlash check before casting
- [ ] **MagicResult.cs** - Add Backlash() factory method
- [ ] **CastFailureReason.cs** - Add Backlash, SoulLost reasons
- [ ] **Program.cs** - Register IBacklashService

### Testing

- [ ] **BacklashServiceTests.cs** - 48 unit tests
  - [ ] Risk calculation tests (8)
  - [ ] Trigger detection tests (8)
  - [ ] Severity determination tests (6)
  - [ ] Effect application tests (10)
  - [ ] Corruption level tests (8)
  - [ ] Event publishing tests (4)
  - [ ] Integration tests (4)

---

## Workflow

### Implementation Order

```
1. CREATE Core Enums
   ├── BacklashSeverity.cs
   └── CorruptionLevel.cs

2. CREATE Core Models
   ├── BacklashResult.cs
   └── CorruptionPenalties.cs

3. CREATE Core Events
   ├── BacklashEvent.cs
   └── CorruptionChangedEvent.cs

4. EXTEND Existing Enums
   ├── StatusEffectType.cs (add AetherSickness)
   └── CastFailureReason.cs (add Backlash, SoulLost)

5. EXTEND Existing Entities
   └── Character.cs (add CurrentCorruption)

6. CREATE Core Interface
   └── IBacklashService.cs

7. EXTEND StatusEffectService
   ├── GetAttributeModifier()
   └── CanConcentrate()

8. CREATE Engine Service
   └── BacklashService.cs

9. CREATE Tests (TDD)
   └── BacklashServiceTests.cs

10. EXTEND MagicService
    ├── Add IBacklashService dependency
    ├── Corruption check in CastSpell
    └── Backlash check in CastSpell

11. EXTEND MagicResult
    └── Add Backlash() factory method

12. REGISTER in DI
    └── Program.cs modification

13. VERIFY
    ├── Run all tests
    ├── Manual backlash testing
    └── Verify corruption accumulation
```

### File Creation Order

| Order | File | Layer | Dependencies |
|-------|------|-------|--------------|
| 1 | BacklashSeverity.cs | Core/Enums | None |
| 2 | CorruptionLevel.cs | Core/Enums | None |
| 3 | BacklashResult.cs | Core/Models/Magic | BacklashSeverity |
| 4 | CorruptionPenalties.cs | Core/Models/Magic | CorruptionLevel |
| 5 | BacklashEvent.cs | Core/Events | BacklashSeverity |
| 6 | CorruptionChangedEvent.cs | Core/Events | CorruptionLevel |
| 7 | StatusEffectType.cs (modify) | Core/Enums | - |
| 8 | CastFailureReason.cs (modify) | Core/Enums | - |
| 9 | Character.cs (modify) | Core/Entities | - |
| 10 | IBacklashService.cs | Core/Interfaces | All above |
| 11 | StatusEffectService.cs (modify) | Engine/Services | StatusEffectType |
| 12 | BacklashService.cs | Engine/Services | All above + v0.4.3a |
| 13 | BacklashServiceTests.cs | Tests | All above |
| 14 | MagicService.cs (modify) | Engine/Services | BacklashService |
| 15 | MagicResult.cs (modify) | Core/Models/Magic | BacklashSeverity |
| 16 | Program.cs (modify) | Terminal | BacklashService |

---

## Changelog

```markdown
## v0.4.3d - The Backlash (Risk & Corruption)

**Release Date:** TBD

### Summary
Introduced the magical consequence system—backlash and corruption. Casting spells
in high-Flux environments now carries escalating risk, with failures causing damage,
Aether Sickness, and permanent soul corruption.

### Features
- **Backlash Mechanics**: Risk-based spell failure when Flux exceeds Critical (50).
- **Severity Tiers**: Minor (1d6), Major (2d6 + sickness), Catastrophic (3d6 + corruption).
- **Aether Sickness**: Status effect causing -2 Will, -1 Wits, blocks concentration.
- **Corruption System**: Permanent soul degradation tracked on Character entity.
- **Corruption Levels**: Untouched → Tainted → Afflicted → Blighted → Lost.
- **Lost State**: Characters with 75+ corruption cannot cast spells.

### Technical
- Implemented `IBacklashService` interface with 9 methods.
- Created `BacklashService` with risk calculation and effect application.
- Added `BacklashResult` record with NoBacklash/Backlash factory methods.
- Added `CorruptionPenalties` record for penalty calculation.
- Added `BacklashSeverity` enum (None, Minor, Major, Catastrophic).
- Added `CorruptionLevel` enum (Untouched, Tainted, Afflicted, Blighted, Lost).
- Extended `StatusEffectType` with AetherSickness.
- Extended `StatusEffectService` with attribute modifiers.
- Extended `Character` entity with CurrentCorruption property.
- Integrated backlash check into MagicService.CastSpell().

### Integration
- Queries Flux from `IAetherService` (v0.4.3a).
- Applies status via `IStatusEffectService`.
- Called by `MagicService.CastSpell()` (v0.4.3c).
- Publishes `BacklashEvent` and `CorruptionChangedEvent`.

### New Files
- `RuneAndRust.Core/Enums/BacklashSeverity.cs`
- `RuneAndRust.Core/Enums/CorruptionLevel.cs`
- `RuneAndRust.Core/Models/Magic/BacklashResult.cs`
- `RuneAndRust.Core/Models/Magic/CorruptionPenalties.cs`
- `RuneAndRust.Core/Events/BacklashEvent.cs`
- `RuneAndRust.Core/Events/CorruptionChangedEvent.cs`
- `RuneAndRust.Core/Interfaces/IBacklashService.cs`
- `RuneAndRust.Engine/Services/BacklashService.cs`
- `RuneAndRust.Tests/Engine/Services/BacklashServiceTests.cs`

### Modified Files
- `RuneAndRust.Core/Enums/StatusEffectType.cs` - Added AetherSickness
- `RuneAndRust.Core/Enums/CastFailureReason.cs` - Added Backlash, SoulLost
- `RuneAndRust.Core/Entities/Character.cs` - Added CurrentCorruption
- `RuneAndRust.Core/Models/Magic/MagicResult.cs` - Added Backlash factory
- `RuneAndRust.Engine/Services/StatusEffectService.cs` - Added attribute modifiers
- `RuneAndRust.Engine/Services/MagicService.cs` - Added backlash integration
- `RuneAndRust.Terminal/Program.cs` - Added DI registration

### Testing
- 48 new unit tests in `BacklashServiceTests.cs`
- Coverage: Risk, triggers, severity, effects, corruption, events, integration

### Risk Mechanics
```
Flux 51+: Risk = Flux - 50 (1-50%)
Roll d100 ≤ Risk: BACKLASH
Margin 1-10: Minor (1d6 damage)
Margin 11-25: Major (2d6 + Aether Sickness 2 turns)
Margin 26+: Catastrophic (3d6 + Aether Sickness 5 turns + 1 Corruption)
```

### Corruption Thresholds
```
0-9: Untouched (no penalties)
10-24: Tainted (-10% MaxAP)
25-49: Afflicted (-20% MaxAP, -1 Will)
50-74: Blighted (-30% MaxAP, -2 Will, -1 Wits)
75-100: Lost (cannot cast spells)
```

### Domain 4 Compliance
- Backlash messages use narrative tone without precision measurements.
- Corruption descriptions maintain archaeologist perspective.
- Severity thresholds hidden behind qualitative ranges.
```

---

## Next Steps

After v0.4.3d implementation:

1. **v0.4.3e (The Resonance)**: Seed starter spells, implement `spells` command, TUI integration with Flux/AP display and corruption indicator.
