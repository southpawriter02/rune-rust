# v0.0.10a Implementation Plan: Logging Infrastructure

**Version:** 0.0.10a
**Parent:** v0.0.10 (Documentation & Polish)
**Prerequisites:** v0.0.9 Complete (Monster Variety & Loot)
**Design Specification:** [v0.0.10a-design-specification.md](v0.0.10a-design-specification.md)
**Status:** Ready for Implementation
**Target Tests:** ~317 -> ~332 (+15 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Application Layer](#application-layer)
   - [Infrastructure Layer](#infrastructure-layer)
   - [Test Utilities](#test-utilities)
5. [Configuration](#configuration)
6. [Flow Diagrams](#flow-diagrams)
7. [Testing Strategy](#testing-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

This implementation phase standardizes and completes the structured logging infrastructure across all layers of the application. While logging is already partially implemented in several services (GameSessionService, CombatService, ClassService, AbilityService, ResourceService), this phase establishes consistent patterns, adds comprehensive logging to remaining services, implements operation correlation for request tracking, and creates reusable logging utilities.

### Scope

- **In Scope:**
  - Standardize logging patterns across all existing services
  - Add comprehensive logging to services with minimal/no logging
  - Create `IOperationScope` interface and `OperationScope` implementation for correlation
  - Create standardized `LogTemplates` for consistent message formatting
  - Create `PerformanceScope` for timing key operations
  - Create logging extension methods (`LoggerExtensions`)
  - Create test utilities (`TestLogger<T>`, `TestLoggerFactory`)
  - Enhance `appsettings.json` with comprehensive logging configuration
  - Document logging standards

- **Out of Scope:**
  - External logging services (Application Insights, Seq, etc.)
  - Log aggregation systems
  - Real-time log monitoring UI
  - Log retention policies (left to deployment configuration)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **Logging Framework** | Serilog via M.E.Logging | Already in use; provides structured logging and file sinks |
| **Correlation Approach** | `ILogger.BeginScope` | Native support, no external dependencies |
| **Test Strategy** | Custom `TestLogger<T>` | Enables verification of log output in unit tests |
| **Log Templates** | Static string constants | Compile-time checking, consistent messaging |

---

## Dependencies from Previous Phases

### Existing Logging Infrastructure

| Type | Location | Status |
|------|----------|--------|
| Serilog Configuration | `Program.cs` | Complete |
| `appsettings.json` | `Presentation.Tui/appsettings.json` | Partial (needs expansion) |
| ILogger<T> injection | Multiple services | Partial |
| Microsoft.Extensions.Logging | All projects | Available |

### Services with Existing Logging

| Service | Location | Logging Status |
|---------|----------|----------------|
| `GameSessionService` | Application/Services | Complete |
| `CombatService` | Domain/Services | Complete |
| `AbilityService` | Application/Services | Complete |
| `ResourceService` | Application/Services | Complete |
| `ClassService` | Application/Services | Partial (needs enhancement) |
| `DescriptorService` | Application/Services | Basic |
| `LexiconService` | Application/Services | Basic |
| `PlayerCreationService` | Application/Services | Basic |
| `InputValidationService` | Application/Services | Basic |
| `ItemEffectService` | Application/Services | Basic |

### Services Requiring Logging Addition

| Service | Location | Current State |
|---------|----------|---------------|
| `JsonConfigurationProvider` | Infrastructure/Configuration | Minimal |
| `InMemoryGameRepository` | Infrastructure/Repositories | Minimal |
| Views (Presentation) | Presentation.Tui/Views | Minimal |

---

## Current System Analysis

### Existing Logging Pattern

**Location:** `src/Core/RuneAndRust.Application/Services/ClassService.cs`

**Current Implementation:**
```csharp
public class ClassService
{
    private readonly ILogger<ClassService> _logger;

    public ClassService(..., ILogger<ClassService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        
        _logger.LogInformation(
            "ClassService initialized with {ArchetypeCount} archetypes and {ClassCount} classes",
            archetypeCount, classCount);
    }

    public IReadOnlyList<ArchetypeDto> GetAllArchetypes()
    {
        _logger.LogDebug("GetAllArchetypes called");
        // ...
    }
}
```

### Target Logging Pattern

**Enhanced with Templates and Correlation:**
```csharp
public class ClassService
{
    private readonly ILogger<ClassService> _logger;

    public ClassService(..., ILogger<ClassService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        
        _logger.LogInformation(
            LogTemplates.ServiceInitializedWithCount,
            nameof(ClassService), archetypeCount, "archetypes");
    }

    public void ApplyClassToPlayer(string classId, Player player)
    {
        using var scope = _logger.BeginPerformanceScope(
            $"ApplyClass:{classId}",
            warningThresholdMs: 100);
            
        _logger.LogPlayerAction(player, "selected class", classId);
        // ...
    }
}
```

---

## Detailed Implementation

### Application Layer

#### 1. LogTemplates.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Logging/LogTemplates.cs`

```csharp
namespace RuneAndRust.Application.Logging;

/// <summary>
/// Standard log message templates for consistent formatting across services.
/// </summary>
public static class LogTemplates
{
    // Service lifecycle
    public const string ServiceInitialized = "{ServiceName} initialized";
    public const string ServiceInitializedWithCount = "{ServiceName} initialized with {Count} {ItemType}";

    // Player actions
    public const string PlayerAction = "Player {PlayerName} {Action}";
    public const string PlayerActionWithTarget = "Player {PlayerName} {Action} {Target}";
    public const string PlayerActionResult = "Player {PlayerName} {Action}: {Result}";

    // Combat
    public const string CombatInitiated = "Combat initiated: {PlayerName} vs {MonsterName}";
    public const string CombatDamage = "{Attacker} dealt {Damage} damage to {Defender}";
    public const string CombatResult = "Combat resolved: {Outcome}";

    // State changes
    public const string StateChanged = "{EntityType} {EntityId} state changed: {OldState} -> {NewState}";
    public const string ResourceChanged = "{ResourceType} changed: {OldValue} -> {NewValue}";

    // Configuration
    public const string ConfigurationLoaded = "Loaded {Count} {ItemType} from {Source}";
    public const string ConfigurationNotFound = "Configuration file not found: {FilePath}. Using defaults.";
    public const string ConfigurationParseError = "Failed to parse configuration: {FilePath}";

    // Errors
    public const string OperationFailed = "{Operation} failed: {Reason}";
    public const string EntityNotFound = "{EntityType} not found: {EntityId}";
    public const string ValidationFailed = "Validation failed for {EntityType}: {Errors}";

    // Repository operations
    public const string RepositorySave = "Saved {EntityType} with ID {EntityId}";
    public const string RepositoryLoad = "Loaded {EntityType} with ID {EntityId}";
    public const string RepositoryDelete = "Deleted {EntityType} with ID {EntityId}";
    public const string RepositoryNotFound = "{EntityType} with ID {EntityId} not found in repository";
}
```

#### 2. IOperationScope.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IOperationScope.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides operation scope for correlation across service calls.
/// </summary>
public interface IOperationScope
{
    /// <summary>
    /// Gets the current operation identifier.
    /// </summary>
    string OperationId { get; }

    /// <summary>
    /// Gets the current session identifier.
    /// </summary>
    Guid? SessionId { get; }

    /// <summary>
    /// Creates a new child scope for a sub-operation.
    /// </summary>
    /// <param name="operationName">The name of the sub-operation.</param>
    /// <returns>A disposable scope.</returns>
    IDisposable BeginOperation(string operationName);
}
```

#### 3. OperationScope.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/OperationScope.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Provides operation scope for correlation across service calls.
/// </summary>
public class OperationScope : IOperationScope
{
    private readonly ILogger _logger;
    private readonly Stack<string> _operationStack = new();

    /// <inheritdoc />
    public string OperationId { get; }

    /// <inheritdoc />
    public Guid? SessionId { get; private set; }

    /// <summary>
    /// Creates a new operation scope.
    /// </summary>
    /// <param name="logger">The logger to use for scope creation.</param>
    /// <param name="sessionId">Optional session identifier.</param>
    public OperationScope(ILogger logger, Guid? sessionId = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        OperationId = Guid.NewGuid().ToString("N")[..8];
        SessionId = sessionId;
    }

    /// <summary>
    /// Sets the session ID for this scope.
    /// </summary>
    /// <param name="sessionId">The session identifier.</param>
    public void SetSessionId(Guid sessionId)
    {
        SessionId = sessionId;
    }

    /// <inheritdoc />
    public IDisposable BeginOperation(string operationName)
    {
        _operationStack.Push(operationName);

        return _logger.BeginScope(new Dictionary<string, object>
        {
            ["OperationId"] = OperationId,
            ["Operation"] = operationName,
            ["SessionId"] = SessionId ?? Guid.Empty,
            ["Depth"] = _operationStack.Count
        });
    }
}
```

#### 4. PerformanceScope.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Logging/PerformanceScope.cs`

```csharp
using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace RuneAndRust.Application.Logging;

/// <summary>
/// Provides automatic performance logging for operations.
/// </summary>
public class PerformanceScope : IDisposable
{
    private readonly ILogger _logger;
    private readonly string _operationName;
    private readonly Stopwatch _stopwatch;
    private readonly LogLevel _logLevel;
    private readonly long _warningThresholdMs;

    /// <summary>
    /// Creates a new performance scope.
    /// </summary>
    /// <param name="logger">The logger to use.</param>
    /// <param name="operationName">The name of the operation being measured.</param>
    /// <param name="logLevel">The log level for normal completion (default: Debug).</param>
    /// <param name="warningThresholdMs">Threshold in ms above which a warning is logged (default: 1000).</param>
    public PerformanceScope(
        ILogger logger,
        string operationName,
        LogLevel logLevel = LogLevel.Debug,
        long warningThresholdMs = 1000)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _operationName = operationName ?? throw new ArgumentNullException(nameof(operationName));
        _logLevel = logLevel;
        _warningThresholdMs = warningThresholdMs;
        _stopwatch = Stopwatch.StartNew();

        _logger.LogTrace("Starting operation: {Operation}", operationName);
    }

    /// <inheritdoc />
    public void Dispose()
    {
        _stopwatch.Stop();
        var elapsed = _stopwatch.ElapsedMilliseconds;

        if (elapsed > _warningThresholdMs)
        {
            _logger.LogWarning(
                "Operation {Operation} took {ElapsedMs}ms (threshold: {ThresholdMs}ms)",
                _operationName, elapsed, _warningThresholdMs);
        }
        else
        {
            _logger.Log(_logLevel,
                "Operation {Operation} completed in {ElapsedMs}ms",
                _operationName, elapsed);
        }
    }
}
```

#### 5. LoggerExtensions.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Logging/LoggerExtensions.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.Logging;

/// <summary>
/// Extension methods for common logging patterns.
/// </summary>
public static class LoggerExtensions
{
    /// <summary>
    /// Logs player action with context.
    /// </summary>
    public static void LogPlayerAction(
        this ILogger logger,
        Player player,
        string action,
        string? target = null,
        string? result = null)
    {
        if (target != null && result != null)
        {
            logger.LogInformation(
                LogTemplates.PlayerActionResult,
                player.Name, action, result);
        }
        else if (target != null)
        {
            logger.LogInformation(
                LogTemplates.PlayerActionWithTarget,
                player.Name, action, target);
        }
        else
        {
            logger.LogInformation(
                LogTemplates.PlayerAction,
                player.Name, action);
        }
    }

    /// <summary>
    /// Logs combat event with full context.
    /// </summary>
    public static void LogCombat(
        this ILogger logger,
        Player player,
        Monster monster,
        int damageDealt,
        int damageReceived,
        bool monsterDefeated,
        bool playerDefeated)
    {
        logger.LogInformation(
            "Combat: {PlayerName} vs {MonsterName} - " +
            "Dealt: {DamageDealt}, Received: {DamageReceived}, " +
            "MonsterDefeated: {MonsterDefeated}, PlayerDefeated: {PlayerDefeated}",
            player.Name, monster.Name,
            damageDealt, damageReceived,
            monsterDefeated, playerDefeated);
    }

    /// <summary>
    /// Logs state change with before/after values.
    /// </summary>
    public static void LogStateChange<T>(
        this ILogger logger,
        string entityType,
        object entityId,
        string propertyName,
        T oldValue,
        T newValue)
    {
        logger.LogInformation(
            "{EntityType} {EntityId} {PropertyName} changed: {OldValue} -> {NewValue}",
            entityType, entityId, propertyName, oldValue, newValue);
    }

    /// <summary>
    /// Creates a performance scope for the operation.
    /// </summary>
    public static PerformanceScope BeginPerformanceScope(
        this ILogger logger,
        string operationName,
        LogLevel logLevel = LogLevel.Debug,
        long warningThresholdMs = 1000)
    {
        return new PerformanceScope(logger, operationName, logLevel, warningThresholdMs);
    }

    /// <summary>
    /// Logs configuration loading with item count.
    /// </summary>
    public static void LogConfigurationLoaded(
        this ILogger logger,
        int count,
        string itemType,
        string source)
    {
        logger.LogInformation(
            LogTemplates.ConfigurationLoaded,
            count, itemType, source);
    }

    /// <summary>
    /// Logs entity not found scenario.
    /// </summary>
    public static void LogEntityNotFound(
        this ILogger logger,
        string entityType,
        object entityId)
    {
        logger.LogDebug(
            LogTemplates.EntityNotFound,
            entityType, entityId);
    }
}
```

### Infrastructure Layer

#### 6. Update JsonConfigurationProvider.cs (MODIFY)

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`

```csharp
// Add comprehensive logging throughout the provider:

// In constructor:
_logger.LogInformation(
    "JsonConfigurationProvider initialized with config path: {ConfigPath}",
    _configPath);

// In LoadConfiguration<T>:
private T LoadConfiguration<T>(string fileName) where T : new()
{
    var filePath = Path.Combine(_configPath, fileName);
    _logger.LogDebug("Loading configuration from: {FilePath}", filePath);

    if (!File.Exists(filePath))
    {
        _logger.LogWarning(
            LogTemplates.ConfigurationNotFound,
            filePath);
        return new T();
    }

    try
    {
        var json = File.ReadAllText(filePath);
        var config = JsonSerializer.Deserialize<T>(json, _jsonOptions);

        _logger.LogDebug(
            "Successfully loaded configuration: {FileName} ({Size} bytes)",
            fileName, json.Length);

        return config ?? new T();
    }
    catch (JsonException ex)
    {
        _logger.LogError(ex,
            LogTemplates.ConfigurationParseError,
            filePath);
        throw;
    }
}

// In GetMonsters():
_logger.LogConfigurationLoaded(_monsters.Count, "monster definitions", "monsters.json");

// Similar patterns for other Get* methods...
```

#### 7. Update InMemoryGameRepository.cs (MODIFY)

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Repositories/InMemoryGameRepository.cs`

Add logging for all CRUD operations:
- `SaveAsync`: Log save operation with session ID
- `GetByIdAsync`: Log load attempt and result
- `GetAllAsync`: Log retrieval count
- `DeleteAsync`: Log deletion

### Test Utilities

#### 8. TestLogger.cs (NEW)

**File:** `tests/RuneAndRust.TestUtilities/Logging/TestLogger.cs`

```csharp
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;

namespace RuneAndRust.TestUtilities.Logging;

/// <summary>
/// Logger implementation that captures log entries for testing.
/// </summary>
/// <typeparam name="T">The category type.</typeparam>
public class TestLogger<T> : ILogger<T>
{
    private readonly ConcurrentQueue<LogEntry> _entries = new();

    /// <summary>
    /// Gets all captured log entries.
    /// </summary>
    public IReadOnlyList<LogEntry> Entries => _entries.ToList();

    /// <summary>
    /// Gets entries at a specific log level.
    /// </summary>
    public IEnumerable<LogEntry> GetEntries(LogLevel level) =>
        _entries.Where(e => e.Level == level);

    /// <summary>
    /// Checks if any entry contains the specified message fragment.
    /// </summary>
    public bool ContainsMessage(string fragment) =>
        _entries.Any(e => e.Message.Contains(fragment, StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Checks if any entry at the specified level contains the message fragment.
    /// </summary>
    public bool ContainsMessage(LogLevel level, string fragment) =>
        _entries.Any(e => e.Level == level && 
            e.Message.Contains(fragment, StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Gets the count of entries at the specified level.
    /// </summary>
    public int GetCount(LogLevel level) => _entries.Count(e => e.Level == level);

    /// <summary>
    /// Clears all captured entries.
    /// </summary>
    public void Clear() => _entries.Clear();

    /// <inheritdoc />
    public IDisposable? BeginScope<TState>(TState state) where TState : notnull =>
        new TestScope();

    /// <inheritdoc />
    public bool IsEnabled(LogLevel logLevel) => true;

    /// <inheritdoc />
    public void Log<TState>(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception? exception,
        Func<TState, Exception?, string> formatter)
    {
        _entries.Enqueue(new LogEntry(
            logLevel,
            formatter(state, exception),
            exception,
            DateTime.UtcNow));
    }

    private sealed class TestScope : IDisposable
    {
        public void Dispose() { }
    }
}

/// <summary>
/// Represents a captured log entry.
/// </summary>
public record LogEntry(
    LogLevel Level,
    string Message,
    Exception? Exception,
    DateTime Timestamp);
```

#### 9. TestLoggerFactory.cs (NEW)

**File:** `tests/RuneAndRust.TestUtilities/Logging/TestLoggerFactory.cs`

```csharp
using Microsoft.Extensions.Logging;

namespace RuneAndRust.TestUtilities.Logging;

/// <summary>
/// Factory for creating test loggers.
/// </summary>
public class TestLoggerFactory : ILoggerFactory
{
    private readonly Dictionary<Type, object> _loggers = new();

    /// <summary>
    /// Gets a test logger for the specified type.
    /// </summary>
    public TestLogger<T> GetTestLogger<T>()
    {
        var type = typeof(T);
        if (!_loggers.TryGetValue(type, out var logger))
        {
            logger = new TestLogger<T>();
            _loggers[type] = logger;
        }
        return (TestLogger<T>)logger;
    }

    /// <inheritdoc />
    public ILogger CreateLogger(string categoryName) =>
        new TestLogger<object>();

    /// <inheritdoc />
    public void AddProvider(ILoggerProvider provider) { }

    /// <inheritdoc />
    public void Dispose() { }
}
```

---

## Configuration

### 10. Enhanced appsettings.json

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/appsettings.json`

```json
{
  "ConnectionStrings": {
    "GameDatabase": "Host=localhost;Port=5432;Database=runeandrust;Username=postgres;Password=postgres"
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft.EntityFrameworkCore": "Warning",
        "System": "Warning",
        "RuneAndRust.Domain": "Information",
        "RuneAndRust.Application": "Debug",
        "RuneAndRust.Infrastructure": "Information",
        "RuneAndRust.Presentation": "Information"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "theme": "Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console",
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/runeandrust-.log",
          "rollingInterval": "Day",
          "fileSizeLimitBytes": 10485760,
          "retainedFileCountLimit": 7,
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] [{SourceContext}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "Game": {
    "UseInMemoryDatabase": true
  }
}
```

---

## Flow Diagrams

### Logging Flow

```
Service Method Called
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BeginPerformanceScope()     â”‚ â”€â”€â”€ Starts timing
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LogDebug("Method entry")    â”‚ â”€â”€â”€ Trace/Debug level
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Business Logic              â”‚
â”‚  â””â”€â”€ LogInformation(...)    â”‚ â”€â”€â”€ Key operations
â”‚  â””â”€â”€ LogWarning(...)        â”‚ â”€â”€â”€ Handled issues
â”‚  â””â”€â”€ LogError(ex, ...)      â”‚ â”€â”€â”€ Failures
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PerformanceScope.Dispose()  â”‚ â”€â”€â”€ Logs elapsed time
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Operation Correlation Flow

```
GameSessionService.TryAttack()
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BeginScope(OperationId)     â”‚ â”€â”€â”€ Creates correlation ID
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â–¼                                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CombatService.Attack() â”‚          â”‚ ResourceService.Use()  â”‚
â”‚ [OperationId: abc123]  â”‚          â”‚ [OperationId: abc123]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                        â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
              All logs share OperationId
```

---

## Testing Strategy

### Test Files

#### 1. LoggingInfrastructureTests.cs (NEW)

**File:** `tests/RuneAndRust.Application.UnitTests/Logging/LoggingInfrastructureTests.cs`

Tests for core logging utilities:
- `TestLogger_CapturesLogEntries`
- `TestLogger_FiltersByLevel`
- `TestLogger_ContainsMessage_FindsFragment`
- `TestLogger_ContainsMessage_WithLevel_FiltersCorrectly`
- `TestLogger_Clear_RemovesAllEntries`

#### 2. PerformanceScopeTests.cs (NEW)

**File:** `tests/RuneAndRust.Application.UnitTests/Logging/PerformanceScopeTests.cs`

Tests for performance timing:
- `PerformanceScope_LogsElapsedTime_OnDispose`
- `PerformanceScope_WarnsOnSlowOperation_WhenThresholdExceeded`
- `PerformanceScope_LogsAtConfiguredLevel_WhenBelowThreshold`
- `PerformanceScope_LogsTrace_OnStart`

#### 3. OperationScopeTests.cs (NEW)

**File:** `tests/RuneAndRust.Application.UnitTests/Logging/OperationScopeTests.cs`

Tests for operation correlation:
- `OperationScope_GeneratesUniqueId`
- `OperationScope_TracksSessionId`
- `OperationScope_BeginOperation_CreatesLogScope`
- `OperationScope_NestedOperations_TrackDepth`

#### 4. LoggerExtensionsTests.cs (NEW)

**File:** `tests/RuneAndRust.Application.UnitTests/Logging/LoggerExtensionsTests.cs`

Tests for extension methods:
- `LogPlayerAction_LogsWithCorrectTemplate`
- `LogPlayerAction_WithTarget_IncludesTarget`
- `LogCombat_LogsAllFields`
- `LogStateChange_FormatsCorrectly`
- `BeginPerformanceScope_ReturnsPerformanceScope`
- `LogConfigurationLoaded_FormatsCorrectly`

---

## Implementation Checklist

> **Legend:** ğŸŸ¢ No dependencies | ğŸŸ¡ Has dependencies | ğŸ”´ Critical path
> **Complexity:** â­ Simple | â­â­ Moderate | â­â­â­ Complex

---

### Phase 1: Application Layer - Logging Utilities (Foundation)

#### 1.1 Create `LogTemplates.cs` ğŸŸ¢ â­

**File:** `src/Core/RuneAndRust.Application/Logging/LogTemplates.cs`

- [ ] Create `Logging/` directory in Application project
- [ ] Create new file with namespace `RuneAndRust.Application.Logging`
- [ ] Add XML documentation header
- [ ] **Define public static class `LogTemplates`:**
- [ ] **Service lifecycle templates:**
  - [ ] `ServiceInitialized` = `"{ServiceName} initialized"`
  - [ ] `ServiceInitializedWithCount` = `"{ServiceName} initialized with {Count} {ItemType}"`
- [ ] **Player action templates:**
  - [ ] `PlayerAction` = `"Player {PlayerName} {Action}"`
  - [ ] `PlayerActionWithTarget` = `"Player {PlayerName} {Action} {Target}"`
  - [ ] `PlayerActionResult` = `"Player {PlayerName} {Action}: {Result}"`
- [ ] **Combat templates:**
  - [ ] `CombatInitiated` = `"Combat initiated: {PlayerName} vs {MonsterName}"`
  - [ ] `CombatDamage` = `"{Attacker} dealt {Damage} damage to {Defender}"`
  - [ ] `CombatResult` = `"Combat resolved: {Outcome}"`
- [ ] **State change templates:**
  - [ ] `StateChanged` = `"{EntityType} {EntityId} state changed: {OldState} -> {NewState}"`
  - [ ] `ResourceChanged` = `"{ResourceType} changed: {OldValue} -> {NewValue}"`
- [ ] **Configuration templates:**
  - [ ] `ConfigurationLoaded` = `"Loaded {Count} {ItemType} from {Source}"`
  - [ ] `ConfigurationNotFound` = `"Configuration file not found: {FilePath}. Using defaults."`
  - [ ] `ConfigurationParseError` = `"Failed to parse configuration: {FilePath}"`
- [ ] **Error templates:**
  - [ ] `OperationFailed` = `"{Operation} failed: {Reason}"`
  - [ ] `EntityNotFound` = `"{EntityType} not found: {EntityId}"`
  - [ ] `ValidationFailed` = `"Validation failed for {EntityType}: {Errors}"`
- [ ] **Repository templates:**
  - [ ] `RepositorySave` = `"Saved {EntityType} with ID {EntityId}"`
  - [ ] `RepositoryLoad` = `"Loaded {EntityType} with ID {EntityId}"`
  - [ ] `RepositoryDelete` = `"Deleted {EntityType} with ID {EntityId}"`
  - [ ] `RepositoryNotFound` = `"{EntityType} with ID {EntityId} not found in repository"`

**Acceptance:** Templates compile and can be used in log statements.

---

#### 1.2 Create `PerformanceScope.cs` ğŸŸ¢ â­â­

**File:** `src/Core/RuneAndRust.Application/Logging/PerformanceScope.cs`

- [ ] Create new file in `Logging/` directory
- [ ] Add namespace `RuneAndRust.Application.Logging`
- [ ] Add using for `Microsoft.Extensions.Logging` and `System.Diagnostics`
- [ ] Add XML documentation header
- [ ] **Define `PerformanceScope` class implementing `IDisposable`:**
- [ ] **Private readonly fields:**
  - [ ] `ILogger _logger`
  - [ ] `string _operationName`
  - [ ] `Stopwatch _stopwatch`
  - [ ] `LogLevel _logLevel`
  - [ ] `long _warningThresholdMs`
- [ ] **Constructor:**
  - [ ] Parameters: `ILogger logger, string operationName, LogLevel logLevel = LogLevel.Debug, long warningThresholdMs = 1000`
  - [ ] Null check logger with `ArgumentNullException`
  - [ ] Null check operationName
  - [ ] Start stopwatch: `_stopwatch = Stopwatch.StartNew()`
  - [ ] Log trace: `"Starting operation: {Operation}"`
- [ ] **Implement `Dispose()`:**
  - [ ] Stop stopwatch
  - [ ] Get elapsed milliseconds
  - [ ] If elapsed > threshold: LogWarning with threshold info
  - [ ] Else: Log at configured level with elapsed time

**Acceptance:** `using (new PerformanceScope(...)) { }` logs timing on dispose.

---

#### 1.3 Create `LoggerExtensions.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Application/Logging/LoggerExtensions.cs`
**Depends on:** 1.1, 1.2

- [ ] Create new file in `Logging/` directory
- [ ] Add namespace `RuneAndRust.Application.Logging`
- [ ] Add usings for `Microsoft.Extensions.Logging`, `RuneAndRust.Domain.Entities`
- [ ] Add XML documentation header
- [ ] **Define public static class `LoggerExtensions`:**
- [ ] **`LogPlayerAction` extension method:**
  - [ ] Parameters: `ILogger logger, Player player, string action, string? target = null, string? result = null`
  - [ ] Branch logic for target/result combinations
  - [ ] Use `LogTemplates` for messages
- [ ] **`LogCombat` extension method:**
  - [ ] Parameters: `ILogger logger, Player player, Monster monster, int damageDealt, int damageReceived, bool monsterDefeated, bool playerDefeated`
  - [ ] Log comprehensive combat summary
- [ ] **`LogStateChange<T>` extension method:**
  - [ ] Parameters: `ILogger logger, string entityType, object entityId, string propertyName, T oldValue, T newValue`
  - [ ] Log state transition
- [ ] **`BeginPerformanceScope` extension method:**
  - [ ] Parameters: `ILogger logger, string operationName, LogLevel logLevel = LogLevel.Debug, long warningThresholdMs = 1000`
  - [ ] Return new `PerformanceScope`
- [ ] **`LogConfigurationLoaded` extension method:**
  - [ ] Parameters: `ILogger logger, int count, string itemType, string source`
  - [ ] Use `LogTemplates.ConfigurationLoaded`
- [ ] **`LogEntityNotFound` extension method:**
  - [ ] Parameters: `ILogger logger, string entityType, object entityId`
  - [ ] Use `LogTemplates.EntityNotFound`

**Acceptance:** Extension methods available on ILogger, compile without errors.

---

#### 1.4 Create `IOperationScope.cs` ğŸŸ¢ â­

**File:** `src/Core/RuneAndRust.Application/Interfaces/IOperationScope.cs`

- [ ] Create new file in `Interfaces/` directory
- [ ] Add namespace `RuneAndRust.Application.Interfaces`
- [ ] Add XML documentation header
- [ ] **Define `IOperationScope` interface:**
  - [ ] `string OperationId { get; }` - Current operation identifier
  - [ ] `Guid? SessionId { get; }` - Current session identifier
  - [ ] `IDisposable BeginOperation(string operationName)` - Create child scope

**Acceptance:** Interface compiles with full XML documentation.

---

#### 1.5 Create `OperationScope.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Application/Services/OperationScope.cs`
**Depends on:** 1.4

- [ ] Create new file in `Services/` directory
- [ ] Add namespace `RuneAndRust.Application.Services`
- [ ] Add usings for `Microsoft.Extensions.Logging` and `RuneAndRust.Application.Interfaces`
- [ ] Add XML documentation
- [ ] **Define `OperationScope` class implementing `IOperationScope`:**
- [ ] **Private fields:**
  - [ ] `readonly ILogger _logger`
  - [ ] `readonly Stack<string> _operationStack = new()`
- [ ] **Properties:**
  - [ ] `string OperationId { get; }` - Generated in constructor
  - [ ] `Guid? SessionId { get; private set; }`
- [ ] **Constructor:**
  - [ ] Parameters: `ILogger logger, Guid? sessionId = null`
  - [ ] Generate `OperationId = Guid.NewGuid().ToString("N")[..8]`
  - [ ] Null check logger
  - [ ] Store sessionId
- [ ] **`SetSessionId(Guid sessionId)` method:**
  - [ ] Update SessionId property
- [ ] **`BeginOperation(string operationName)` method:**
  - [ ] Push to operation stack
  - [ ] Return `_logger.BeginScope(...)` with OperationId, Operation, SessionId, Depth

**Acceptance:** Scope creates unique IDs and tracks operation depth.

---

### Phase 2: Test Utilities

#### 2.1 Create TestLogger.cs ğŸŸ¢ â­â­

**File:** `tests/RuneAndRust.TestUtilities/Logging/TestLogger.cs`

- [ ] Create `Logging/` directory in TestUtilities project
- [ ] Create new file with namespace `RuneAndRust.TestUtilities.Logging`
- [ ] Add using for `Microsoft.Extensions.Logging`, `System.Collections.Concurrent`
- [ ] Add XML documentation
- [ ] **Define `TestLogger<T>` class implementing `ILogger<T>`:**
- [ ] **Private field:**
  - [ ] `readonly ConcurrentQueue<LogEntry> _entries = new()`
- [ ] **Properties:**
  - [ ] `IReadOnlyList<LogEntry> Entries` - Convert queue to list
- [ ] **Query methods:**
  - [ ] `GetEntries(LogLevel level)` - Filter by level
  - [ ] `ContainsMessage(string fragment)` - Case-insensitive search
  - [ ] `ContainsMessage(LogLevel level, string fragment)` - Combined filter
  - [ ] `GetCount(LogLevel level)` - Count at level
  - [ ] `Clear()` - Clear all entries
- [ ] **ILogger implementation:**
  - [ ] `BeginScope<TState>` - Return dummy disposable
  - [ ] `IsEnabled(LogLevel)` - Return true
  - [ ] `Log<TState>` - Enqueue new LogEntry
- [ ] **Define `LogEntry` record:**
  - [ ] `LogLevel Level`
  - [ ] `string Message`
  - [ ] `Exception? Exception`
  - [ ] `DateTime Timestamp`

**Acceptance:** TestLogger captures all log calls and provides query methods.

---

#### 2.2 Create TestLoggerFactory.cs ğŸŸ¡ â­

**File:** `tests/RuneAndRust.TestUtilities/Logging/TestLoggerFactory.cs`
**Depends on:** 2.1

- [ ] Create new file in `Logging/` directory
- [ ] Add namespace `RuneAndRust.TestUtilities.Logging`
- [ ] Add using for `Microsoft.Extensions.Logging`
- [ ] Add XML documentation
- [ ] **Define `TestLoggerFactory` class implementing `ILoggerFactory`:**
- [ ] **Private field:**
  - [ ] `readonly Dictionary<Type, object> _loggers = new()`
- [ ] **Methods:**
  - [ ] `GetTestLogger<T>()` - Get or create TestLogger<T>
  - [ ] `CreateLogger(string)` - Return new TestLogger<object>
  - [ ] `AddProvider(ILoggerProvider)` - No-op
  - [ ] `Dispose()` - No-op

**Acceptance:** Factory creates and caches test loggers by type.

---

### Phase 3: Infrastructure Layer (Logging Enhancement)

#### 3.1 Update `JsonConfigurationProvider.cs` ğŸŸ¡ â­â­ ğŸ”´

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`
**Depends on:** 1.1, 1.3

- [ ] Add using for `RuneAndRust.Application.Logging`
- [ ] **Update constructor logging:**
  - [ ] Log initialization with config path
- [ ] **Update `LoadConfiguration<T>` method:**
  - [ ] Log Debug on entry with file path
  - [ ] Log Warning if file not found (use `LogTemplates.ConfigurationNotFound`)
  - [ ] Log Debug on success with file size
  - [ ] Log Error on parse failure (use `LogTemplates.ConfigurationParseError`)
- [ ] **Update all `Get*` methods to log:**
  - [ ] `GetClasses()` - Log count loaded
  - [ ] `GetArchetypes()` - Log count loaded
  - [ ] `GetAbilities()` - Log count loaded
  - [ ] `GetMonsters()` - Log count loaded (if implemented from v0.0.9a)
  - [ ] Use `LogConfigurationLoaded` extension where appropriate
- [ ] **Update all `GetById` methods:**
  - [ ] Log Debug on lookup
  - [ ] Log Debug if not found (use `LogEntityNotFound` extension)

**Acceptance:** Configuration loading produces comprehensive log output.

---

#### 3.2 Update `InMemoryGameRepository.cs` ğŸŸ¡ â­â­

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Repositories/InMemoryGameRepository.cs`
**Depends on:** 1.1, 1.3

- [ ] Add using for `RuneAndRust.Application.Logging`
- [ ] Ensure `ILogger<InMemoryGameRepository>` is injected
- [ ] **Update `SaveAsync`:**
  - [ ] Log Information on save (use `LogTemplates.RepositorySave`)
  - [ ] Include session ID in log
- [ ] **Update `GetByIdAsync`:**
  - [ ] Log Debug on load attempt
  - [ ] Log Information on success (use `LogTemplates.RepositoryLoad`)
  - [ ] Log Debug if not found (use `LogTemplates.RepositoryNotFound`)
- [ ] **Update `GetAllAsync`:**
  - [ ] Log Debug with count of sessions returned
- [ ] **Update `DeleteAsync`:**
  - [ ] Log Information on delete (use `LogTemplates.RepositoryDelete`)
  - [ ] Log Warning if not found

**Acceptance:** Repository operations produce appropriate log entries.

---

### Phase 4: Service Enhancement (Logging Standardization)

#### 4.1 Update `DescriptorService.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Application/Services/DescriptorService.cs`
**Depends on:** 1.1, 1.3

- [ ] Add using for `RuneAndRust.Application.Logging`
- [ ] Ensure `ILogger<DescriptorService>` is injected
- [ ] **Update constructor:**
  - [ ] Log initialization with descriptor count
- [ ] **Update lookup methods:**
  - [ ] Log Debug on descriptor lookup
  - [ ] Log Debug on cache hit/miss (if caching exists)
  - [ ] Use `LogEntityNotFound` for missing descriptors

**Acceptance:** Descriptor lookups are traced in logs.

---

#### 4.2 Update `LexiconService.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Application/Services/LexiconService.cs`
**Depends on:** 1.1, 1.3

- [ ] Add using for `RuneAndRust.Application.Logging`
- [ ] Ensure `ILogger<LexiconService>` is injected
- [ ] **Update constructor:**
  - [ ] Log initialization with term count
- [ ] **Update term resolution methods:**
  - [ ] Log Debug on term lookup
  - [ ] Log Debug when term resolved
  - [ ] Log Debug when term not found

**Acceptance:** Term resolution is traceable in logs.

---

#### 4.3 Update `PlayerCreationService.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Application/Services/PlayerCreationService.cs`
**Depends on:** 1.1, 1.3

- [ ] Add using for `RuneAndRust.Application.Logging`
- [ ] Ensure `ILogger<PlayerCreationService>` is injected
- [ ] **Update creation flow:**
  - [ ] Log Information on player creation start
  - [ ] Log Debug on each creation step (race, background, class)
  - [ ] Log Information on creation complete with player summary
  - [ ] Log Warning on validation failures

**Acceptance:** Player creation flow is fully logged.

---

#### 4.4 Update `InputValidationService.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Application/Services/InputValidationService.cs`
**Depends on:** 1.1, 1.3

- [ ] Add using for `RuneAndRust.Application.Logging`
- [ ] Ensure `ILogger<InputValidationService>` is injected
- [ ] **Update validation methods:**
  - [ ] Log Debug on validation attempt
  - [ ] Log Debug on validation success
  - [ ] Log Debug on validation failure with reasons

**Acceptance:** Input validation decisions are logged.

---

#### 4.5 Update `ItemEffectService.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Application/Services/ItemEffectService.cs`
**Depends on:** 1.1, 1.3

- [ ] Add using for `RuneAndRust.Application.Logging`
- [ ] Ensure `ILogger<ItemEffectService>` is injected
- [ ] **Update effect application:**
  - [ ] Log Information on effect application
  - [ ] Log Debug on effect details (healing amount, buff applied, etc.)
  - [ ] Use `LogStateChange` for stat modifications
  - [ ] Log Warning on failed effect application

**Acceptance:** Item effect applications are logged with before/after state.

---

### Phase 5: Configuration Enhancement

#### 5.1 Update `appsettings.json` ğŸŸ¢ â­â­

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/appsettings.json`

- [ ] **Expand Serilog MinimumLevel overrides:**
  - [ ] Add `"RuneAndRust.Domain": "Information"`
  - [ ] Add `"RuneAndRust.Application": "Debug"`
  - [ ] Add `"RuneAndRust.Infrastructure": "Information"`
  - [ ] Add `"RuneAndRust.Presentation": "Information"`
- [ ] **Add Console WriteTo sink:**
  - [ ] Add Name: "Console"
  - [ ] Configure outputTemplate with timestamp, level, message, properties
- [ ] **Enhance File WriteTo sink:**
  - [ ] Add fileSizeLimitBytes: 10485760 (10MB)
  - [ ] Add retainedFileCountLimit: 7
  - [ ] Update outputTemplate to include SourceContext
- [ ] **Add Enrich array:**
  - [ ] Add "FromLogContext"
  - [ ] Add "WithMachineName"
  - [ ] Add "WithThreadId"

**Acceptance:** Updated config enables comprehensive logging with proper filtering.

---

### Phase 6: Testing

#### 6.1 Create `LoggingInfrastructureTests.cs` ğŸŸ¡ â­â­

**File:** `tests/RuneAndRust.Application.UnitTests/Logging/LoggingInfrastructureTests.cs`
**Depends on:** 2.1

- [ ] Create `Logging/` directory in Application.UnitTests project
- [ ] Create new test file
- [ ] Add references to `RuneAndRust.TestUtilities`
- [ ] **Test cases (~5 tests):**
  - [ ] `TestLogger_CapturesLogEntries_WhenLogIsCalled`
  - [ ] `TestLogger_FiltersByLevel_ReturnsOnlyMatchingEntries`
  - [ ] `TestLogger_ContainsMessage_ReturnsTrueForExistingFragment`
  - [ ] `TestLogger_ContainsMessage_WithLevel_FiltersCorrectly`
  - [ ] `TestLogger_Clear_RemovesAllEntries`

**Acceptance:** All TestLogger tests pass.

---

#### 6.2 Create `PerformanceScopeTests.cs` ğŸŸ¡ â­â­

**File:** `tests/RuneAndRust.Application.UnitTests/Logging/PerformanceScopeTests.cs`
**Depends on:** 1.2, 2.1

- [ ] Create new test file
- [ ] **Test cases (~4 tests):**
  - [ ] `PerformanceScope_LogsElapsedTime_OnDispose`
  - [ ] `PerformanceScope_WarnsOnSlowOperation_WhenThresholdExceeded`
  - [ ] `PerformanceScope_LogsAtConfiguredLevel_WhenBelowThreshold`
  - [ ] `PerformanceScope_LogsTrace_OnStart`

**Acceptance:** Performance scope timing works correctly.

---

#### 6.3 Create `OperationScopeTests.cs` ğŸŸ¡ â­â­

**File:** `tests/RuneAndRust.Application.UnitTests/Logging/OperationScopeTests.cs`
**Depends on:** 1.5, 2.1

- [ ] Create new test file
- [ ] **Test cases (~4 tests):**
  - [ ] `OperationScope_GeneratesUniqueId_OnConstruction`
  - [ ] `OperationScope_TracksSessionId_WhenProvided`
  - [ ] `OperationScope_BeginOperation_CreatesLogScope`
  - [ ] `OperationScope_NestedOperations_IncrementDepth`
  - [ ] `OperationScope_SetSessionId_UpdatesProperty`

**Acceptance:** Operation correlation tracking works correctly.

---

#### 6.4 Create `LoggerExtensionsTests.cs` ğŸŸ¡ â­â­

**File:** `tests/RuneAndRust.Application.UnitTests/Logging/LoggerExtensionsTests.cs`
**Depends on:** 1.3, 2.1

- [ ] Create new test file
- [ ] **Test cases (~6 tests):**
  - [ ] `LogPlayerAction_LogsWithCorrectTemplate`
  - [ ] `LogPlayerAction_WithTarget_IncludesTarget`
  - [ ] `LogCombat_LogsAllCombatFields`
  - [ ] `LogStateChange_FormatsOldAndNewValues`
  - [ ] `BeginPerformanceScope_ReturnsPerformanceScope`
  - [ ] `LogConfigurationLoaded_FormatsWithAllParameters`

**Acceptance:** All extension method tests pass.

---

### Phase 7: DI Registration

#### 7.1 Update DI Container Registration ğŸŸ¡ â­

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/DependencyInjection.cs`
**Depends on:** 1.4, 1.5

- [ ] Add using for `RuneAndRust.Application.Interfaces`
- [ ] Add using for `RuneAndRust.Application.Services`
- [ ] **Register services:**
  - [ ] `services.AddScoped<IOperationScope, OperationScope>()` - Or use factory method if needed
- [ ] Verify all services have ILogger<T> injection (existing)

**Acceptance:** Application starts without DI resolution errors.

---

### Implementation Order Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 1: Application Layer - Logging Utilities              â”‚
â”‚  1.1 LogTemplates.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  1.2 PerformanceScope.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                   â”‚
â”‚  1.3 LoggerExtensions.cs â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ (depends on 1.1,  â”‚
â”‚  1.4 IOperationScope.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  1.2)             â”‚
â”‚  1.5 OperationScope.cs â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (depends on 1.4)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 2: Test Utilities                                     â”‚
â”‚  2.1 TestLogger.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  2.2 TestLoggerFactory.cs â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 3: Infrastructure Layer Enhancement                   â”‚
â”‚  3.1 JsonConfigurationProvider.cs (CRITICAL)                â”‚
â”‚  3.2 InMemoryGameRepository.cs                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 4: Service Enhancement (Parallel Available)           â”‚
â”‚  4.1 DescriptorService.cs                                   â”‚
â”‚  4.2 LexiconService.cs                                      â”‚
â”‚  4.3 PlayerCreationService.cs                               â”‚
â”‚  4.4 InputValidationService.cs                              â”‚
â”‚  4.5 ItemEffectService.cs                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 5: Configuration                                      â”‚
â”‚  5.1 appsettings.json                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 6: Testing (After Utilities Created)                  â”‚
â”‚  6.1 LoggingInfrastructureTests.cs                          â”‚
â”‚  6.2 PerformanceScopeTests.cs                               â”‚
â”‚  6.3 OperationScopeTests.cs                                 â”‚
â”‚  6.4 LoggerExtensionsTests.cs                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 7: DI Registration                                    â”‚
â”‚  7.1 DependencyInjection.cs                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Estimated Effort

| Phase | Tasks | Complexity | Est. Time |
|-------|-------|------------|-----------|
| Application Layer Utilities | 5 files | â­â­ | 2-3 hours |
| Test Utilities | 2 files | â­â­ | 1 hour |
| Infrastructure Enhancement | 2 files | â­â­ | 1-2 hours |
| Service Enhancement | 5 files | â­â­ | 2 hours |
| Configuration | 1 file | â­ | 30 min |
| Testing | 4 files | â­â­ | 2 hours |
| DI Registration | 1 file | â­ | 15 min |
| **Total** | **20 items** | | **8-11 hours** |

---

## Acceptance Criteria

1. **Consistent Logging Patterns**: All services use structured logging with semantic properties.
2. **Log Templates**: All services use standardized `LogTemplates` for consistent messaging.
3. **Performance Tracking**: Key operations can be timed using `PerformanceScope`.
4. **Operation Correlation**: Related operations can be traced via `OperationId`.
5. **Test Verification**: Logging behavior can be verified in unit tests using `TestLogger<T>`.
6. **Configurable Levels**: Log levels adjustable via `appsettings.json` without code changes.
7. **~15 New Tests**: All logging infrastructure tests pass.

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Logging performance overhead | Low | Medium | Use appropriate log levels, avoid hot paths |
| Breaking existing log consumers | Low | Low | Additive changes only, no log format changes |
| Test logger not capturing all calls | Low | Medium | Thorough testing of TestLogger itself |
| Serilog configuration complexity | Low | Low | Document config options, provide defaults |
| Missing log injection in services | Medium | Low | Compiler will catch missing dependencies |

---

## File Summary

### Files to Create (New)

| File | Purpose |
|------|---------|
| `src/Core/RuneAndRust.Application/Logging/LogTemplates.cs` | Standardized log message templates |
| `src/Core/RuneAndRust.Application/Logging/PerformanceScope.cs` | Operation timing utility |
| `src/Core/RuneAndRust.Application/Logging/LoggerExtensions.cs` | Logging extension methods |
| `src/Core/RuneAndRust.Application/Interfaces/IOperationScope.cs` | Operation correlation interface |
| `src/Core/RuneAndRust.Application/Services/OperationScope.cs` | Operation scope implementation |
| `tests/RuneAndRust.TestUtilities/Logging/TestLogger.cs` | Test logger for unit tests |
| `tests/RuneAndRust.TestUtilities/Logging/TestLoggerFactory.cs` | Test logger factory |
| `tests/RuneAndRust.Application.UnitTests/Logging/LoggingInfrastructureTests.cs` | Core logging tests |
| `tests/RuneAndRust.Application.UnitTests/Logging/PerformanceScopeTests.cs` | Performance scope tests |
| `tests/RuneAndRust.Application.UnitTests/Logging/OperationScopeTests.cs` | Operation scope tests |
| `tests/RuneAndRust.Application.UnitTests/Logging/LoggerExtensionsTests.cs` | Extension method tests |

### Files to Modify

| File | Changes |
|------|---------|
| `JsonConfigurationProvider.cs` | Add comprehensive logging |
| `InMemoryGameRepository.cs` | Add CRUD operation logging |
| `DescriptorService.cs` | Enhance with standardized logging |
| `LexiconService.cs` | Enhance with standardized logging |
| `PlayerCreationService.cs` | Enhance with standardized logging |
| `InputValidationService.cs` | Enhance with standardized logging |
| `ItemEffectService.cs` | Enhance with standardized logging |
| `appsettings.json` | Expand Serilog configuration |
| `DependencyInjection.cs` | Register IOperationScope |

### Test Files Summary

| File | Test Count |
|------|------------|
| `LoggingInfrastructureTests.cs` | ~5 |
| `PerformanceScopeTests.cs` | ~4 |
| `OperationScopeTests.cs` | ~4 |
| `LoggerExtensionsTests.cs` | ~6 |
| **Total** | **~15** |

---

## Provides to Future Phases

### To v0.0.10b (Unit Test Coverage)

| Type | Usage |
|------|-------|
| `TestLogger<T>` | Verify service logging in new tests |
| `TestLoggerFactory` | Create loggers for test fixtures |
| `LogTemplates` | Verify expected log messages |

### To v0.0.10c (XML Documentation)

| Type | Usage |
|------|-------|
| All logging utilities | Document with comprehensive XML docs |
| Extension methods | Include `<example>` tags |

### To v0.0.10d (Implementation Specifications)

| Type | Usage |
|------|-------|
| Logging patterns | Document as architectural decision |
| `LogTemplates` | Reference in API documentation |

---

*This implementation plan establishes consistent, testable logging patterns across the application, enabling observability and debugging while maintaining code quality. The utilities created here will be used extensively in subsequent testing and documentation phases.*
