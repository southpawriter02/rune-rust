# v0.0.7c Implementation Plan: Armor & Requirements

**Version:** 0.0.7c
**Parent:** v0.0.7 (Equipment System)
**Prerequisites:** v0.0.7a Complete (Core Equipment Infrastructure), v0.0.7b Complete (Weapon System)
**Status:** Ready for Implementation
**Target Tests:** ~224 -> ~236 (+12 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Implement armor types with defense bonuses and stat modifiers, plus equipment requirements based on player attributes and class. This phase completes the v0.0.7 Equipment System by making armor meaningful in combat and introducing prerequisites for equipping powerful items.

### Scope

**In Scope:**
- `ArmorType` enum (Light, Medium, Heavy)
- `StatModifiers` value object for general equipment stat bonuses
- `EquipmentRequirements` value object for attribute/class requirements
- `ArmorType?`, `DefenseBonus`, `StatModifiers`, `InitiativePenalty`, `Requirements` properties on `Item`
- `GetEffectiveStats()` and `GetEffectiveAttributes()` methods on `Player`
- Update `EquipmentService` with requirement validation
- `armor.json` configuration file with armor and accessory definitions
- `ArmorDto` and `EquipmentDisplayDto` for display
- Clear error messages for unmet requirements

**Out of Scope:**
- Damage resistance/immunity (v0.0.9)
- Set bonuses (future)
- Enchantments (future)
- Equipment durability (future)
- Multiple ring slots (future)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| StatModifiers vs WeaponBonuses | Separate types | WeaponBonuses includes AttackModifier; StatModifiers is general-purpose for any equipment |
| Requirements validation | In EquipmentService | Centralized validation, consistent error handling |
| Stat stacking | Additive | Simple mental model, all equipment bonuses add together |
| Initiative penalty | Stored on Item | Armor-specific penalty, summed from all equipment |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.7a (Core Equipment Infrastructure)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `EquipmentSlot` | `Domain/Enums/EquipmentSlot.cs` | Armor, Shield, Helmet, Boots, Ring, Amulet slots |
| `Player.Equipment` | `Domain/Entities/Player.cs` | Dictionary of equipped items |
| `Player.GetEquippedItem()` | `Domain/Entities/Player.cs` | Retrieve items for stat calculation |
| `Player.IsSlotOccupied()` | `Domain/Entities/Player.cs` | Check equipment state |
| `EquipmentService` | `Domain/Services/EquipmentService.cs` | Extended with requirement validation |
| `EquipResult` | `Domain/ValueObjects/EquipResult.cs` | Extended with RequirementsNotMet result |
| `Item.EquipmentSlot` | `Domain/Entities/Item.cs` | Nullable slot property |
| `Item.IsEquippable` | `Domain/Entities/Item.cs` | Check if item can be equipped |

### Dependencies from v0.0.7b (Weapon System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `WeaponBonuses` | `Domain/ValueObjects/WeaponBonuses.cs` | Combined with StatModifiers in GetEffectiveAttributes() |
| `Item.WeaponBonuses` | `Domain/Entities/Item.cs` | Weapon stat bonuses for attribute calculation |
| `Item.IsWeapon` | `Domain/Entities/Item.cs` | Pattern for IsArmor property |

---

## Current System Analysis

### Existing Player Entity

**Location:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

**Current State:**
- Has `Stats` property (MaxHealth, Attack, Defense) - base values only
- Has `Attributes` property (Might, Fortitude, Will, Wits, Finesse) - base values only
- Has `Equipment` dictionary from v0.0.7a
- No method to calculate effective stats with equipment bonuses
- No method to calculate effective attributes with equipment bonuses

**Current Stats Flow:**
```
Player.Stats
    └── Returns base Stats only
        └── No equipment bonuses applied
```

### New Effective Stats Flow

```
Player.GetEffectiveStats()
    ├── STEP 1: Start with base Stats
    │
    ├── STEP 2: Iterate Equipment dictionary
    │   ├── Sum all DefenseBonus values
    │   └── Sum all StatModifiers (including Defense, MaxHealth)
    │
    └── STEP 3: Return new Stats
        └── Defense = Base + DefenseBonus + StatModifiers.Defense
        └── MaxHealth = Base + StatModifiers.MaxHealth
```

### Existing EquipmentService

**Location:** `src/Core/RuneAndRust.Domain/Services/EquipmentService.cs` (from v0.0.7a)

**Current Flow:**
```
TryEquip(player, item)
    ├── Check item.IsEquippable
    ├── Check slot occupation
    ├── Handle swap if needed
    └── Return EquipResult
```

### New EquipmentService Flow (with Requirements)

```
TryEquip(player, item)
    ├── STEP 1: Check item.IsEquippable (existing)
    │
    ├── STEP 2: Check requirements (NEW)
    │   ├── CanEquip(player, item)
    │   │   ├── item.HasRequirements?
    │   │   └── item.Requirements.MeetsRequirements(player)?
    │   └── Return RequirementsNotMet if failed
    │
    ├── STEP 3: Check slot occupation (existing)
    │
    └── STEP 4: Equip and return result (existing)
```

---

## Detailed Implementation

### Domain Layer

#### 1. ArmorType.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/ArmorType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the type of armor, affecting defense bonuses and restrictions.
/// </summary>
/// <remarks>
/// Armor types represent a trade-off between protection and mobility:
/// <list type="bullet">
/// <item><description>Light: Low defense, no penalties, no requirements</description></item>
/// <item><description>Medium: Moderate defense, slight penalty, some requirements</description></item>
/// <item><description>Heavy: High defense, significant penalties, strict requirements</description></item>
/// </list>
/// </remarks>
public enum ArmorType
{
    /// <summary>Light armor (leather, cloth). Minimal protection, no restrictions.</summary>
    Light,

    /// <summary>Medium armor (chain, scale). Balanced protection with minor penalties.</summary>
    Medium,

    /// <summary>Heavy armor (plate, full mail). Maximum protection, significant penalties.</summary>
    Heavy
}
```

#### 2. StatModifiers.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/StatModifiers.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents stat modifiers provided by equipment when equipped.
/// </summary>
/// <remarks>
/// <para>
/// Unlike WeaponBonuses (which includes AttackModifier), StatModifiers is a general-purpose
/// value object for any equipment type. Multiple StatModifiers from different equipment
/// stack additively.
/// </para>
/// </remarks>
/// <param name="Might">Bonus to Might attribute.</param>
/// <param name="Fortitude">Bonus to Fortitude attribute.</param>
/// <param name="Will">Bonus to Will attribute.</param>
/// <param name="Wits">Bonus to Wits attribute.</param>
/// <param name="Finesse">Bonus to Finesse attribute.</param>
/// <param name="MaxHealth">Bonus to maximum health points.</param>
/// <param name="Defense">Bonus to defense (separate from armor defense bonus).</param>
public readonly record struct StatModifiers(
    int Might = 0,
    int Fortitude = 0,
    int Will = 0,
    int Wits = 0,
    int Finesse = 0,
    int MaxHealth = 0,
    int Defense = 0)
{
    /// <summary>
    /// Returns true if any modifier is non-zero.
    /// </summary>
    public bool HasModifiers => Might != 0 || Fortitude != 0 || Will != 0 ||
                                Wits != 0 || Finesse != 0 || MaxHealth != 0 || Defense != 0;

    /// <summary>
    /// Creates an empty modifiers instance.
    /// </summary>
    public static StatModifiers None => new();

    /// <summary>
    /// Combines two StatModifiers by adding their values.
    /// </summary>
    public static StatModifiers operator +(StatModifiers a, StatModifiers b) => new(
        Might: a.Might + b.Might,
        Fortitude: a.Fortitude + b.Fortitude,
        Will: a.Will + b.Will,
        Wits: a.Wits + b.Wits,
        Finesse: a.Finesse + b.Finesse,
        MaxHealth: a.MaxHealth + b.MaxHealth,
        Defense: a.Defense + b.Defense);

    /// <summary>
    /// Returns a display string of non-zero modifiers.
    /// </summary>
    public override string ToString()
    {
        var parts = new List<string>();
        if (Might != 0) parts.Add($"{FormatBonus(Might)} Might");
        if (Fortitude != 0) parts.Add($"{FormatBonus(Fortitude)} Fortitude");
        if (Will != 0) parts.Add($"{FormatBonus(Will)} Will");
        if (Wits != 0) parts.Add($"{FormatBonus(Wits)} Wits");
        if (Finesse != 0) parts.Add($"{FormatBonus(Finesse)} Finesse");
        if (MaxHealth != 0) parts.Add($"{FormatBonus(MaxHealth)} Max HP");
        if (Defense != 0) parts.Add($"{FormatBonus(Defense)} Defense");
        return parts.Count > 0 ? string.Join(", ", parts) : "None";
    }

    private static string FormatBonus(int value) => value > 0 ? $"+{value}" : value.ToString();
}
```

#### 3. EquipmentRequirements.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EquipmentRequirements.cs`

```csharp
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents requirements that must be met to equip an item.
/// </summary>
/// <remarks>
/// <para>
/// All specified requirements must be met. Null values indicate no requirement
/// for that attribute. Class requirements use class IDs from configuration.
/// </para>
/// </remarks>
/// <param name="MinMight">Minimum Might attribute required.</param>
/// <param name="MinFortitude">Minimum Fortitude attribute required.</param>
/// <param name="MinWill">Minimum Will attribute required.</param>
/// <param name="MinWits">Minimum Wits attribute required.</param>
/// <param name="MinFinesse">Minimum Finesse attribute required.</param>
/// <param name="RequiredClassIds">Class IDs that can equip this item. Null means any class.</param>
public readonly record struct EquipmentRequirements(
    int? MinMight = null,
    int? MinFortitude = null,
    int? MinWill = null,
    int? MinWits = null,
    int? MinFinesse = null,
    IReadOnlyList<string>? RequiredClassIds = null)
{
    /// <summary>
    /// Returns true if this item has any requirements.
    /// </summary>
    public bool HasRequirements => MinMight.HasValue || MinFortitude.HasValue ||
                                   MinWill.HasValue || MinWits.HasValue ||
                                   MinFinesse.HasValue || RequiredClassIds?.Count > 0;

    /// <summary>
    /// Creates a requirements instance with no requirements.
    /// </summary>
    public static EquipmentRequirements None => new();

    /// <summary>
    /// Creates requirements with Fortitude requirement only.
    /// </summary>
    public static EquipmentRequirements ForFortitude(int min) => new(MinFortitude: min);

    /// <summary>
    /// Creates requirements with Might requirement only.
    /// </summary>
    public static EquipmentRequirements ForMight(int min) => new(MinMight: min);

    /// <summary>
    /// Creates requirements with class restriction.
    /// </summary>
    public static EquipmentRequirements ForClasses(params string[] classIds) =>
        new(RequiredClassIds: classIds.ToList().AsReadOnly());

    /// <summary>
    /// Checks if a player meets these requirements.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>True if all requirements are met.</returns>
    public bool MeetsRequirements(Player player)
    {
        if (player == null) return false;

        if (MinMight.HasValue && player.Attributes.Might < MinMight.Value)
            return false;
        if (MinFortitude.HasValue && player.Attributes.Fortitude < MinFortitude.Value)
            return false;
        if (MinWill.HasValue && player.Attributes.Will < MinWill.Value)
            return false;
        if (MinWits.HasValue && player.Attributes.Wits < MinWits.Value)
            return false;
        if (MinFinesse.HasValue && player.Attributes.Finesse < MinFinesse.Value)
            return false;

        if (RequiredClassIds?.Count > 0)
        {
            if (string.IsNullOrEmpty(player.ClassId))
                return false;
            if (!RequiredClassIds.Contains(player.ClassId, StringComparer.OrdinalIgnoreCase))
                return false;
        }

        return true;
    }

    /// <summary>
    /// Gets a list of unmet requirements for a player.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>List of requirement descriptions that are not met.</returns>
    public IReadOnlyList<string> GetUnmetRequirements(Player player)
    {
        var unmet = new List<string>();

        if (player == null)
        {
            unmet.Add("No player specified");
            return unmet;
        }

        if (MinMight.HasValue && player.Attributes.Might < MinMight.Value)
            unmet.Add($"Might {MinMight.Value} required (you have {player.Attributes.Might})");
        if (MinFortitude.HasValue && player.Attributes.Fortitude < MinFortitude.Value)
            unmet.Add($"Fortitude {MinFortitude.Value} required (you have {player.Attributes.Fortitude})");
        if (MinWill.HasValue && player.Attributes.Will < MinWill.Value)
            unmet.Add($"Will {MinWill.Value} required (you have {player.Attributes.Will})");
        if (MinWits.HasValue && player.Attributes.Wits < MinWits.Value)
            unmet.Add($"Wits {MinWits.Value} required (you have {player.Attributes.Wits})");
        if (MinFinesse.HasValue && player.Attributes.Finesse < MinFinesse.Value)
            unmet.Add($"Finesse {MinFinesse.Value} required (you have {player.Attributes.Finesse})");

        if (RequiredClassIds?.Count > 0)
        {
            if (string.IsNullOrEmpty(player.ClassId) ||
                !RequiredClassIds.Contains(player.ClassId, StringComparer.OrdinalIgnoreCase))
            {
                var classes = string.Join(", ", RequiredClassIds);
                unmet.Add($"Class must be one of: {classes}");
            }
        }

        return unmet;
    }

    /// <summary>
    /// Returns a display string of all requirements.
    /// </summary>
    public override string ToString()
    {
        var parts = new List<string>();
        if (MinMight.HasValue) parts.Add($"Might {MinMight.Value}");
        if (MinFortitude.HasValue) parts.Add($"Fortitude {MinFortitude.Value}");
        if (MinWill.HasValue) parts.Add($"Will {MinWill.Value}");
        if (MinWits.HasValue) parts.Add($"Wits {MinWits.Value}");
        if (MinFinesse.HasValue) parts.Add($"Finesse {MinFinesse.Value}");
        if (RequiredClassIds?.Count > 0) parts.Add($"Class: {string.Join("/", RequiredClassIds)}");
        return parts.Count > 0 ? string.Join(", ", parts) : "None";
    }
}
```

#### 4. Item.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Item.cs`

**Add new properties after existing weapon properties:**

```csharp
// ===== Armor Properties =====

/// <summary>
/// Gets the type of armor this item is, or null if not armor.
/// </summary>
/// <remarks>
/// Armor type affects defense bonus amounts and any associated penalties.
/// Items with ArmorType should have appropriate EquipmentSlot (Armor, Shield, Helmet, Boots).
/// </remarks>
public ArmorType? ArmorType { get; private set; }

/// <summary>
/// Gets the defense bonus provided by this item when equipped.
/// </summary>
/// <remarks>
/// Defense bonus is added to the player's base defense. Stacks with other
/// equipped items' defense bonuses.
/// </remarks>
public int DefenseBonus { get; private set; }

/// <summary>
/// Gets the stat modifiers provided by this item when equipped.
/// </summary>
/// <remarks>
/// General-purpose stat modifiers that apply while equipped.
/// Separate from weapon-specific bonuses (WeaponBonuses).
/// </remarks>
public StatModifiers StatModifiers { get; private set; } = StatModifiers.None;

/// <summary>
/// Gets the initiative penalty from this item (typically heavy armor).
/// </summary>
/// <remarks>
/// Penalty is subtracted from initiative rolls, making the wearer act later in combat.
/// Should be 0 or negative.
/// </remarks>
public int InitiativePenalty { get; private set; }

/// <summary>
/// Gets the requirements to equip this item.
/// </summary>
/// <remarks>
/// If requirements are set, player must meet all conditions to equip the item.
/// Null or empty requirements mean anyone can equip.
/// </remarks>
public EquipmentRequirements Requirements { get; private set; } = EquipmentRequirements.None;

/// <summary>
/// Gets whether this item is armor.
/// </summary>
public bool IsArmor => ArmorType.HasValue;

/// <summary>
/// Gets whether this item has any requirements.
/// </summary>
public bool HasRequirements => Requirements.HasRequirements;

// ===== Updated Constructor =====

/// <summary>
/// Creates a new item with the specified properties.
/// </summary>
public Item(
    string name,
    string description,
    ItemType type,
    int value = 0,
    ItemEffect effect = ItemEffect.None,
    int effectValue = 0,
    int effectDuration = 0,
    EquipmentSlot? equipmentSlot = null,
    string? damageDice = null,
    WeaponType? weaponType = null,
    WeaponBonuses? weaponBonuses = null,
    ArmorType? armorType = null,             // NEW
    int defenseBonus = 0,                    // NEW
    StatModifiers? statModifiers = null,     // NEW
    int initiativePenalty = 0,               // NEW
    EquipmentRequirements? requirements = null) // NEW
{
    Id = Guid.NewGuid();
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Description = description ?? throw new ArgumentNullException(nameof(description));
    Type = type;
    Value = value;
    Effect = effect;
    EffectValue = effectValue;
    EffectDuration = effectDuration;
    EquipmentSlot = equipmentSlot;
    DamageDice = damageDice;
    WeaponType = weaponType;
    WeaponBonuses = weaponBonuses ?? WeaponBonuses.None;
    ArmorType = armorType;
    DefenseBonus = defenseBonus;
    StatModifiers = statModifiers ?? StatModifiers.None;
    InitiativePenalty = initiativePenalty;
    Requirements = requirements ?? EquipmentRequirements.None;
}

// ===== Armor Factory Methods =====

/// <summary>
/// Factory method to create leather armor.
/// </summary>
public static Item CreateLeatherArmor() => new(
    "Leather Armor",
    "Simple armor made of tanned leather. Provides basic protection.",
    ItemType.Armor,
    value: 30,
    equipmentSlot: Enums.EquipmentSlot.Armor,
    armorType: Enums.ArmorType.Light,
    defenseBonus: 2
);

/// <summary>
/// Factory method to create chain mail armor.
/// </summary>
public static Item CreateChainMail() => new(
    "Chain Mail",
    "Interlocking metal rings providing solid protection.",
    ItemType.Armor,
    value: 100,
    equipmentSlot: Enums.EquipmentSlot.Armor,
    armorType: Enums.ArmorType.Medium,
    defenseBonus: 4,
    initiativePenalty: -1,
    requirements: EquipmentRequirements.ForFortitude(12)
);

/// <summary>
/// Factory method to create plate armor.
/// </summary>
public static Item CreatePlateArmor() => new(
    "Plate Armor",
    "Full plate armor offering maximum protection at the cost of mobility.",
    ItemType.Armor,
    value: 500,
    equipmentSlot: Enums.EquipmentSlot.Armor,
    armorType: Enums.ArmorType.Heavy,
    defenseBonus: 6,
    initiativePenalty: -3,
    requirements: new EquipmentRequirements(MinFortitude: 14, MinMight: 12)
);

/// <summary>
/// Factory method to create a ring of strength.
/// </summary>
public static Item CreateRingOfStrength() => new(
    "Ring of Strength",
    "A silver ring that enhances the wearer's physical power.",
    ItemType.Misc,
    value: 200,
    equipmentSlot: Enums.EquipmentSlot.Ring,
    statModifiers: new StatModifiers(Might: 2)
);

/// <summary>
/// Factory method to create an amulet of vitality.
/// </summary>
public static Item CreateAmuletOfVitality() => new(
    "Amulet of Vitality",
    "A ruby amulet that bolsters the wearer's constitution.",
    ItemType.Misc,
    value: 250,
    equipmentSlot: Enums.EquipmentSlot.Amulet,
    statModifiers: new StatModifiers(Fortitude: 2, MaxHealth: 10)
);
```

#### 5. Player.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

**Add new methods for effective stats calculation:**

```csharp
// ===== Equipment Stat Methods =====

/// <summary>
/// Calculates the player's effective stats including equipment bonuses.
/// </summary>
/// <returns>Stats with all equipment bonuses applied.</returns>
/// <remarks>
/// Defense is calculated as: Base Defense + Sum of all DefenseBonus from equipment + StatModifiers.Defense
/// MaxHealth is calculated as: Base MaxHealth + Sum of all StatModifiers.MaxHealth
/// </remarks>
public Stats GetEffectiveStats()
{
    var totalDefenseBonus = 0;
    var totalStatModifiers = StatModifiers.None;

    foreach (var (slot, item) in Equipment)
    {
        totalDefenseBonus += item.DefenseBonus;
        totalStatModifiers += item.StatModifiers;
    }

    return new Stats(
        MaxHealth: Stats.MaxHealth + totalStatModifiers.MaxHealth,
        Attack: Stats.Attack,
        Defense: Stats.Defense + totalDefenseBonus + totalStatModifiers.Defense
    );
}

/// <summary>
/// Calculates the player's effective attributes including equipment bonuses.
/// </summary>
/// <returns>Attributes with all equipment bonuses applied.</returns>
/// <remarks>
/// Combines base attributes with:
/// - WeaponBonuses from equipped weapon
/// - StatModifiers from all equipped items
/// </remarks>
public PlayerAttributes GetEffectiveAttributes()
{
    var totalStatModifiers = StatModifiers.None;
    var weaponBonuses = WeaponBonuses.None;

    foreach (var (slot, item) in Equipment)
    {
        totalStatModifiers += item.StatModifiers;

        if (slot == EquipmentSlot.Weapon && item.IsWeapon)
        {
            weaponBonuses = item.WeaponBonuses;
        }
    }

    // Clamp values to valid range (1-30)
    return new PlayerAttributes(
        Math.Clamp(Attributes.Might + totalStatModifiers.Might + weaponBonuses.Might, 1, 30),
        Math.Clamp(Attributes.Fortitude + totalStatModifiers.Fortitude + weaponBonuses.Fortitude, 1, 30),
        Math.Clamp(Attributes.Will + totalStatModifiers.Will + weaponBonuses.Will, 1, 30),
        Math.Clamp(Attributes.Wits + totalStatModifiers.Wits + weaponBonuses.Wits, 1, 30),
        Math.Clamp(Attributes.Finesse + totalStatModifiers.Finesse + weaponBonuses.Finesse, 1, 30)
    );
}

/// <summary>
/// Gets the total initiative penalty from all equipped items.
/// </summary>
/// <returns>Total initiative penalty (should be 0 or negative).</returns>
public int GetTotalInitiativePenalty()
{
    var penalty = 0;
    foreach (var (_, item) in Equipment)
    {
        penalty += item.InitiativePenalty;
    }
    return penalty;
}

/// <summary>
/// Gets the total defense bonus from all equipped armor and items.
/// </summary>
/// <returns>Sum of all defense bonuses.</returns>
public int GetTotalDefenseBonus()
{
    var bonus = 0;
    foreach (var (_, item) in Equipment)
    {
        bonus += item.DefenseBonus;
        bonus += item.StatModifiers.Defense;
    }
    return bonus;
}
```

#### 6. EquipmentService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Services/EquipmentService.cs`

**Update to include requirement validation:**

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Service for managing player equipment operations.
/// </summary>
public class EquipmentService
{
    private readonly ILogger<EquipmentService> _logger;

    public EquipmentService(ILogger<EquipmentService> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Checks if a player can equip an item, considering requirements.
    /// </summary>
    /// <param name="player">The player attempting to equip.</param>
    /// <param name="item">The item to equip.</param>
    /// <returns>A tuple of (canEquip, unmetRequirements).</returns>
    public (bool CanEquip, IReadOnlyList<string> UnmetRequirements) CanEquip(Player player, Item item)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(item);

        // Check if item is equippable
        if (!item.IsEquippable)
        {
            return (false, new[] { $"The {item.Name} cannot be equipped." });
        }

        // Check requirements
        if (item.HasRequirements)
        {
            var unmet = item.Requirements.GetUnmetRequirements(player);
            if (unmet.Count > 0)
            {
                _logger.LogDebug(
                    "Player {Player} does not meet requirements for {Item}: {Requirements}",
                    player.Name, item.Name, string.Join(", ", unmet));
                return (false, unmet);
            }
        }

        return (true, Array.Empty<string>());
    }

    /// <summary>
    /// Attempts to equip a specific item from the player's inventory.
    /// </summary>
    public EquipResult TryEquip(Player player, Item item)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(item);

        _logger.LogDebug("Attempting to equip '{ItemName}' for player {Player}", item.Name, player.Name);

        // Check if item is equippable
        if (!item.IsEquippable)
        {
            _logger.LogDebug("Item '{ItemName}' is not equippable", item.Name);
            return EquipResult.NotEquippable(item);
        }

        // Check requirements (NEW)
        var (canEquip, unmetRequirements) = CanEquip(player, item);
        if (!canEquip)
        {
            _logger.LogDebug(
                "Player {Player} cannot equip {Item}: {Requirements}",
                player.Name, item.Name, string.Join(", ", unmetRequirements));
            return EquipResult.RequirementsNotMet(item, unmetRequirements);
        }

        var slot = item.EquipmentSlot!.Value;
        Item? replacedItem = null;

        // Check if slot is occupied
        if (player.IsSlotOccupied(slot))
        {
            var currentItem = player.GetEquippedItem(slot)!;

            if (player.Inventory.IsFull)
            {
                _logger.LogDebug("Cannot swap equipment - inventory is full");
                return EquipResult.InventoryFull();
            }

            player.Unequip(slot);
            player.Inventory.TryAdd(currentItem);
            replacedItem = currentItem;

            _logger.LogDebug("Unequipped '{OldItem}' to make room for '{NewItem}'",
                currentItem.Name, item.Name);
        }

        // Remove item from inventory and equip it
        player.Inventory.Remove(item);
        player.TryEquip(item);

        _logger.LogInformation("Player {Player} equipped '{Item}' to {Slot} slot",
            player.Name, item.Name, slot);

        return EquipResult.Equipped(item, replacedItem);
    }

    // ... existing methods (TryEquipByName, TryUnequip, TryParseSlot) ...
}
```

#### 7. EquipResult.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EquipResult.cs`

**Add RequirementsNotMet factory method:**

```csharp
// Add to existing EquipResult:

/// <summary>
/// Creates a failure result for unmet requirements.
/// </summary>
/// <param name="item">The item that couldn't be equipped.</param>
/// <param name="unmetRequirements">List of requirement descriptions.</param>
public static EquipResult RequirementsNotMet(Item item, IReadOnlyList<string> unmetRequirements)
{
    var message = $"You cannot equip {item.Name}.\nRequirements not met:\n" +
                  string.Join("\n", unmetRequirements.Select(r => $"  - {r}"));
    return new(false, message, null, null);
}
```

### Application Layer

#### 8. ArmorDto.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/DTOs/ArmorDto.cs`

```csharp
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying armor information.
/// </summary>
/// <param name="Name">The armor's display name.</param>
/// <param name="ArmorType">The type of armor (Light, Medium, Heavy).</param>
/// <param name="DefenseBonus">Defense bonus when equipped.</param>
/// <param name="InitiativePenalty">Initiative penalty when equipped.</param>
/// <param name="Description">The armor's description.</param>
/// <param name="StatBonuses">String representation of stat bonuses.</param>
/// <param name="Requirements">String representation of equip requirements.</param>
public record ArmorDto(
    string Name,
    string ArmorType,
    int DefenseBonus,
    int InitiativePenalty,
    string Description,
    string? StatBonuses = null,
    string? Requirements = null)
{
    /// <summary>
    /// Creates an ArmorDto from an Item.
    /// </summary>
    public static ArmorDto? FromItem(Item item)
    {
        if (!item.IsArmor || item.ArmorType == null)
            return null;

        return new ArmorDto(
            item.Name,
            item.ArmorType.Value.ToString(),
            item.DefenseBonus,
            item.InitiativePenalty,
            item.Description,
            item.StatModifiers.HasModifiers ? item.StatModifiers.ToString() : null,
            item.HasRequirements ? item.Requirements.ToString() : null);
    }
}
```

#### 9. EquipmentDisplayDto.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/DTOs/EquipmentDisplayDto.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for equipment display with stat summary.
/// </summary>
/// <param name="Slots">The equipment slots data.</param>
/// <param name="BaseDefense">Player's base defense value.</param>
/// <param name="TotalDefense">Total defense including equipment bonuses.</param>
/// <param name="InitiativePenalty">Total initiative penalty from equipment.</param>
/// <param name="AttributeBonuses">Formatted string of attribute bonuses.</param>
public record EquipmentDisplayDto(
    EquipmentSlotsDto Slots,
    int BaseDefense,
    int TotalDefense,
    int InitiativePenalty,
    string? AttributeBonuses = null);
```

### Configuration

#### 10. armor.json (NEW)

**File:** `config/armor.json`

```json
{
  "$schema": "armor.schema.json",
  "armor": [
    {
      "id": "cloth_robe",
      "name": "Cloth Robe",
      "description": "A simple cloth robe. Offers almost no protection.",
      "armorType": "Light",
      "slot": "Armor",
      "defenseBonus": 1,
      "initiativePenalty": 0,
      "value": 10
    },
    {
      "id": "leather_armor",
      "name": "Leather Armor",
      "description": "Simple armor made of tanned leather. Provides basic protection.",
      "armorType": "Light",
      "slot": "Armor",
      "defenseBonus": 2,
      "initiativePenalty": 0,
      "value": 30
    },
    {
      "id": "studded_leather",
      "name": "Studded Leather",
      "description": "Leather armor reinforced with metal studs.",
      "armorType": "Light",
      "slot": "Armor",
      "defenseBonus": 3,
      "initiativePenalty": 0,
      "value": 60
    },
    {
      "id": "chain_mail",
      "name": "Chain Mail",
      "description": "Interlocking metal rings providing solid protection.",
      "armorType": "Medium",
      "slot": "Armor",
      "defenseBonus": 4,
      "initiativePenalty": -1,
      "requirements": { "minFortitude": 12 },
      "value": 100
    },
    {
      "id": "scale_mail",
      "name": "Scale Mail",
      "description": "Overlapping metal scales on a leather backing.",
      "armorType": "Medium",
      "slot": "Armor",
      "defenseBonus": 5,
      "initiativePenalty": -2,
      "requirements": { "minFortitude": 13 },
      "value": 200
    },
    {
      "id": "plate_armor",
      "name": "Plate Armor",
      "description": "Full plate armor offering maximum protection at the cost of mobility.",
      "armorType": "Heavy",
      "slot": "Armor",
      "defenseBonus": 6,
      "initiativePenalty": -3,
      "requirements": { "minFortitude": 14, "minMight": 12 },
      "value": 500
    },
    {
      "id": "mithril_plate",
      "name": "Mithril Plate",
      "description": "Legendary armor forged from mithril. Strong as steel, light as cloth.",
      "armorType": "Heavy",
      "slot": "Armor",
      "defenseBonus": 7,
      "initiativePenalty": -1,
      "requirements": { "minFortitude": 12 },
      "value": 2000
    },
    {
      "id": "wooden_shield",
      "name": "Wooden Shield",
      "description": "A basic wooden shield. Better than nothing.",
      "armorType": "Light",
      "slot": "Shield",
      "defenseBonus": 1,
      "initiativePenalty": 0,
      "value": 15
    },
    {
      "id": "iron_shield",
      "name": "Iron Shield",
      "description": "A sturdy iron shield.",
      "armorType": "Medium",
      "slot": "Shield",
      "defenseBonus": 2,
      "initiativePenalty": 0,
      "requirements": { "minMight": 10 },
      "value": 50
    },
    {
      "id": "tower_shield",
      "name": "Tower Shield",
      "description": "A massive shield that covers most of the body.",
      "armorType": "Heavy",
      "slot": "Shield",
      "defenseBonus": 3,
      "initiativePenalty": -1,
      "requirements": { "minMight": 14, "minFortitude": 12 },
      "value": 150
    },
    {
      "id": "leather_helm",
      "name": "Leather Helm",
      "description": "A simple leather cap offering minimal head protection.",
      "armorType": "Light",
      "slot": "Helmet",
      "defenseBonus": 1,
      "initiativePenalty": 0,
      "value": 20
    },
    {
      "id": "iron_helmet",
      "name": "Iron Helmet",
      "description": "A solid iron helmet.",
      "armorType": "Medium",
      "slot": "Helmet",
      "defenseBonus": 2,
      "initiativePenalty": 0,
      "value": 40
    },
    {
      "id": "leather_boots",
      "name": "Leather Boots",
      "description": "Sturdy leather boots for travel.",
      "armorType": "Light",
      "slot": "Boots",
      "defenseBonus": 0,
      "initiativePenalty": 0,
      "statBonuses": { "finesse": 1 },
      "value": 25
    },
    {
      "id": "iron_boots",
      "name": "Iron Boots",
      "description": "Heavy iron boots. Protective but cumbersome.",
      "armorType": "Heavy",
      "slot": "Boots",
      "defenseBonus": 1,
      "initiativePenalty": -1,
      "requirements": { "minFortitude": 10 },
      "value": 60
    }
  ],
  "accessories": [
    {
      "id": "ring_of_strength",
      "name": "Ring of Strength",
      "description": "A silver ring that enhances the wearer's physical power.",
      "slot": "Ring",
      "statBonuses": { "might": 2 },
      "value": 200
    },
    {
      "id": "ring_of_protection",
      "name": "Ring of Protection",
      "description": "A gold ring enchanted to ward off harm.",
      "slot": "Ring",
      "statBonuses": { "defense": 1 },
      "value": 250
    },
    {
      "id": "amulet_of_vitality",
      "name": "Amulet of Vitality",
      "description": "A ruby amulet that bolsters the wearer's constitution.",
      "slot": "Amulet",
      "statBonuses": { "fortitude": 2, "maxHealth": 10 },
      "value": 250
    },
    {
      "id": "amulet_of_wisdom",
      "name": "Amulet of Wisdom",
      "description": "A sapphire amulet that sharpens the mind.",
      "slot": "Amulet",
      "statBonuses": { "will": 2, "wits": 1 },
      "value": 275
    }
  ]
}
```

---

## Flow Diagrams

### Equipment Requirement Validation Flow

```
TryEquip(player, item)
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 1: CHECK EQUIPPABLE                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  item.IsEquippable?                                                          │
│  ├── NO  → Return EquipResult.NotEquippable(item)                           │
│  └── YES → Continue                                                         │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 2: CHECK REQUIREMENTS (NEW)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  item.HasRequirements?                                                       │
│  ├── YES → item.Requirements.MeetsRequirements(player)?                     │
│  │         ├── NO  → Get unmet list, Return RequirementsNotMet              │
│  │         └── YES → Continue                                               │
│  └── NO  → Continue                                                         │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 3: HANDLE SLOT                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│  player.IsSlotOccupied(slot)?                                                │
│  ├── YES → Inventory full? → Return InventoryFull                           │
│  │         Swap: Unequip current, add to inventory                          │
│  └── NO  → Continue                                                         │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 4: EQUIP                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  Remove from inventory, TryEquip to player                                   │
│  Return EquipResult.Equipped(item, replacedItem)                            │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Effective Stats Calculation Flow

```
Player.GetEffectiveStats()
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 1: INITIALIZE                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  totalDefenseBonus = 0                                                       │
│  totalStatModifiers = StatModifiers.None                                    │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 2: ITERATE EQUIPMENT                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  foreach (slot, item) in Equipment:                                          │
│    totalDefenseBonus += item.DefenseBonus                                   │
│    totalStatModifiers += item.StatModifiers                                 │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 3: BUILD EFFECTIVE STATS                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  Return new Stats(                                                           │
│    MaxHealth: Base + StatModifiers.MaxHealth,                               │
│    Attack: Base (unchanged),                                                │
│    Defense: Base + DefenseBonus + StatModifiers.Defense                     │
│  )                                                                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Enums/
│   │   └── ArmorTypeTests.cs                    (2 tests)
│   ├── ValueObjects/
│   │   ├── StatModifiersTests.cs                (4 tests)
│   │   └── EquipmentRequirementsTests.cs        (5 tests)
│   ├── Entities/
│   │   └── PlayerEffectiveStatsTests.cs         (3 tests)
│   └── Services/
│       └── EquipmentServiceRequirementsTests.cs (3 tests)
```

### Test Files (~12 tests total)

#### ArmorTypeTests.cs (2 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Enums/ArmorTypeTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.UnitTests.Enums;

[TestFixture]
public class ArmorTypeTests
{
    [Test]
    public void ArmorType_ContainsAllExpectedValues()
    {
        // Assert
        Enum.GetValues<ArmorType>().Should().HaveCount(3);
        Enum.IsDefined(ArmorType.Light).Should().BeTrue();
        Enum.IsDefined(ArmorType.Medium).Should().BeTrue();
        Enum.IsDefined(ArmorType.Heavy).Should().BeTrue();
    }

    [Test]
    [TestCase("Light", ArmorType.Light)]
    [TestCase("medium", ArmorType.Medium)]
    [TestCase("HEAVY", ArmorType.Heavy)]
    public void TryParse_ValidArmorType_ReturnsTrue(string input, ArmorType expected)
    {
        // Act
        var success = Enum.TryParse<ArmorType>(input, ignoreCase: true, out var result);

        // Assert
        success.Should().BeTrue();
        result.Should().Be(expected);
    }
}
```

#### StatModifiersTests.cs (4 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/StatModifiersTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class StatModifiersTests
{
    [Test]
    public void None_HasNoModifiers()
    {
        // Act
        var modifiers = StatModifiers.None;

        // Assert
        modifiers.HasModifiers.Should().BeFalse();
        modifiers.Might.Should().Be(0);
        modifiers.Defense.Should().Be(0);
        modifiers.MaxHealth.Should().Be(0);
    }

    [Test]
    public void HasModifiers_WithNonZeroValue_ReturnsTrue()
    {
        // Arrange
        var modifiers = new StatModifiers(Might: 2);

        // Assert
        modifiers.HasModifiers.Should().BeTrue();
    }

    [Test]
    public void AdditionOperator_CombinesModifiers()
    {
        // Arrange
        var a = new StatModifiers(Might: 2, Defense: 1);
        var b = new StatModifiers(Might: 1, Fortitude: 3, MaxHealth: 10);

        // Act
        var result = a + b;

        // Assert
        result.Might.Should().Be(3);
        result.Fortitude.Should().Be(3);
        result.Defense.Should().Be(1);
        result.MaxHealth.Should().Be(10);
    }

    [Test]
    public void ToString_FormatsCorrectly()
    {
        // Arrange
        var modifiers = new StatModifiers(Might: 2, Defense: -1, MaxHealth: 10);

        // Act
        var result = modifiers.ToString();

        // Assert
        result.Should().Contain("+2 Might");
        result.Should().Contain("-1 Defense");
        result.Should().Contain("+10 Max HP");
    }
}
```

#### EquipmentRequirementsTests.cs (5 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/EquipmentRequirementsTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class EquipmentRequirementsTests
{
    private static Player CreateTestPlayer(int might = 10, int fortitude = 10, string? classId = null)
    {
        var attributes = new PlayerAttributes(might, fortitude, 8, 8, 8);
        var player = new Player("TestHero", "human", "soldier", attributes);
        if (classId != null)
            player.SetClass("warrior", classId);
        return player;
    }

    [Test]
    public void None_HasNoRequirements()
    {
        // Act
        var requirements = EquipmentRequirements.None;

        // Assert
        requirements.HasRequirements.Should().BeFalse();
    }

    [Test]
    public void MeetsRequirements_WhenMet_ReturnsTrue()
    {
        // Arrange
        var requirements = new EquipmentRequirements(MinFortitude: 10, MinMight: 8);
        var player = CreateTestPlayer(might: 10, fortitude: 12);

        // Act
        var result = requirements.MeetsRequirements(player);

        // Assert
        result.Should().BeTrue();
    }

    [Test]
    public void MeetsRequirements_WhenNotMet_ReturnsFalse()
    {
        // Arrange
        var requirements = new EquipmentRequirements(MinFortitude: 14, MinMight: 12);
        var player = CreateTestPlayer(might: 10, fortitude: 10);

        // Act
        var result = requirements.MeetsRequirements(player);

        // Assert
        result.Should().BeFalse();
    }

    [Test]
    public void GetUnmetRequirements_ReturnsDescriptiveList()
    {
        // Arrange
        var requirements = new EquipmentRequirements(MinFortitude: 14, MinMight: 12);
        var player = CreateTestPlayer(might: 10, fortitude: 10);

        // Act
        var unmet = requirements.GetUnmetRequirements(player);

        // Assert
        unmet.Should().HaveCount(2);
        unmet.Should().Contain(r => r.Contains("Fortitude 14"));
        unmet.Should().Contain(r => r.Contains("Might 12"));
    }

    [Test]
    public void ForClasses_CreatesClassRequirement()
    {
        // Arrange
        var requirements = EquipmentRequirements.ForClasses("warrior", "paladin");
        var matchingPlayer = CreateTestPlayer(classId: "warrior");
        var nonMatchingPlayer = CreateTestPlayer(classId: "mage");

        // Assert
        requirements.HasRequirements.Should().BeTrue();
        requirements.MeetsRequirements(matchingPlayer).Should().BeTrue();
        requirements.MeetsRequirements(nonMatchingPlayer).Should().BeFalse();
    }
}
```

#### PlayerEffectiveStatsTests.cs (3 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerEffectiveStatsTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Entities;

[TestFixture]
public class PlayerEffectiveStatsTests
{
    private static Player CreateTestPlayer()
    {
        return new Player("TestHero", new Stats(100, 10, 5));
    }

    [Test]
    public void GetEffectiveStats_WithArmor_IncludesDefenseBonus()
    {
        // Arrange
        var player = CreateTestPlayer();
        var armor = Item.CreateChainMail(); // DefenseBonus: 4
        player.TryEquip(armor);

        // Act
        var effectiveStats = player.GetEffectiveStats();

        // Assert
        effectiveStats.Defense.Should().Be(9); // 5 base + 4 armor
    }

    [Test]
    public void GetEffectiveAttributes_WithStatModifiers_IncludesBonuses()
    {
        // Arrange
        var player = CreateTestPlayer();
        var ring = Item.CreateRingOfStrength(); // +2 Might
        player.TryEquip(ring);

        // Act
        var effectiveAttributes = player.GetEffectiveAttributes();

        // Assert
        effectiveAttributes.Might.Should().Be(player.Attributes.Might + 2);
    }

    [Test]
    public void GetTotalInitiativePenalty_SumsAllPenalties()
    {
        // Arrange
        var player = CreateTestPlayer();
        var armor = Item.CreatePlateArmor(); // InitiativePenalty: -3
        player.TryEquip(armor);

        // Act
        var penalty = player.GetTotalInitiativePenalty();

        // Assert
        penalty.Should().Be(-3);
    }
}
```

#### EquipmentServiceRequirementsTests.cs (3 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Services/EquipmentServiceRequirementsTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Services;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Services;

[TestFixture]
public class EquipmentServiceRequirementsTests
{
    private EquipmentService _service = null!;
    private Mock<ILogger<EquipmentService>> _mockLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<EquipmentService>>();
        _service = new EquipmentService(_mockLogger.Object);
    }

    private static Player CreateTestPlayer(int fortitude = 10, int might = 10)
    {
        var attributes = new PlayerAttributes(might, fortitude, 8, 8, 8);
        return new Player("TestHero", "human", "soldier", attributes);
    }

    [Test]
    public void TryEquip_RequirementsMet_Succeeds()
    {
        // Arrange
        var player = CreateTestPlayer(fortitude: 14, might: 12);
        var armor = Item.CreatePlateArmor(); // Requires Fort 14, Might 12
        player.Inventory.TryAdd(armor);

        // Act
        var result = _service.TryEquip(player, armor);

        // Assert
        result.Success.Should().BeTrue();
    }

    [Test]
    public void TryEquip_RequirementsNotMet_Fails()
    {
        // Arrange
        var player = CreateTestPlayer(fortitude: 10, might: 10);
        var armor = Item.CreatePlateArmor(); // Requires Fort 14, Might 12
        player.Inventory.TryAdd(armor);

        // Act
        var result = _service.TryEquip(player, armor);

        // Assert
        result.Success.Should().BeFalse();
        result.Message.Should().Contain("Requirements not met");
    }

    [Test]
    public void CanEquip_ReturnsUnmetRequirements()
    {
        // Arrange
        var player = CreateTestPlayer(fortitude: 10, might: 10);
        var armor = Item.CreatePlateArmor();

        // Act
        var (canEquip, unmet) = _service.CanEquip(player, armor);

        // Assert
        canEquip.Should().BeFalse();
        unmet.Should().HaveCount(2);
    }
}
```

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Requirement check start | Debug | "Checking requirements for {Item} on {Player}" |
| Requirements met | Debug | "Player {Player} meets requirements for {Item}" |
| Requirements not met | Debug | "Player {Player} does not meet requirements for {Item}: {Unmet}" |
| Equip success | Information | "Player {Player} equipped '{Item}' to {Slot} slot" |
| Equip failure | Debug | "Cannot equip {Item}: {Reason}" |
| Stat calculation | Debug | "Calculated effective stats: Defense {Base}+{Bonus}={Total}" |

---

## Implementation Checklist

### Phase 1: Domain Layer - Enums & Value Objects
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/ArmorType.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/StatModifiers.cs`
  - [ ] Properties: Might, Fortitude, Will, Wits, Finesse, MaxHealth, Defense
  - [ ] HasModifiers computed property
  - [ ] None static property
  - [ ] Addition operator
  - [ ] ToString() formatting
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/EquipmentRequirements.cs`
  - [ ] Properties: MinMight, MinFortitude, MinWill, MinWits, MinFinesse, RequiredClassIds
  - [ ] HasRequirements computed property
  - [ ] MeetsRequirements(player) method
  - [ ] GetUnmetRequirements(player) method
  - [ ] Factory methods: None, ForFortitude, ForMight, ForClasses
  - [ ] ToString() formatting

### Phase 2: Domain Layer - Entity Modifications
- [ ] Modify `src/Core/RuneAndRust.Domain/Entities/Item.cs`
  - [ ] Add `ArmorType?` property
  - [ ] Add `DefenseBonus` property
  - [ ] Add `StatModifiers` property
  - [ ] Add `InitiativePenalty` property
  - [ ] Add `Requirements` property
  - [ ] Add `IsArmor` computed property
  - [ ] Add `HasRequirements` computed property
  - [ ] Update constructor with new parameters
  - [ ] Add `CreateLeatherArmor()` factory
  - [ ] Add `CreateChainMail()` factory
  - [ ] Add `CreatePlateArmor()` factory
  - [ ] Add `CreateRingOfStrength()` factory
  - [ ] Add `CreateAmuletOfVitality()` factory

### Phase 3: Domain Layer - Player Methods
- [ ] Modify `src/Core/RuneAndRust.Domain/Entities/Player.cs`
  - [ ] Add `GetEffectiveStats()` method
  - [ ] Add `GetEffectiveAttributes()` method
  - [ ] Add `GetTotalInitiativePenalty()` method
  - [ ] Add `GetTotalDefenseBonus()` method

### Phase 4: Domain Layer - Service Modifications
- [ ] Modify `src/Core/RuneAndRust.Domain/Services/EquipmentService.cs`
  - [ ] Add `CanEquip(player, item)` method
  - [ ] Update `TryEquip()` to check requirements
- [ ] Modify `src/Core/RuneAndRust.Domain/ValueObjects/EquipResult.cs`
  - [ ] Add `RequirementsNotMet()` factory method

### Phase 5: Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/ArmorDto.cs`
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/EquipmentDisplayDto.cs`

### Phase 6: Configuration
- [ ] Create `config/armor.json` with 14 armor pieces and 4 accessories

### Phase 7: Testing
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Enums/ArmorTypeTests.cs` (2 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/StatModifiersTests.cs` (4 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/EquipmentRequirementsTests.cs` (5 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerEffectiveStatsTests.cs` (3 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Services/EquipmentServiceRequirementsTests.cs` (3 tests)

### Phase 8: Validation
- [ ] All ~12 new tests pass
- [ ] All existing tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### ArmorType Enum
- [ ] Contains Light, Medium, Heavy values
- [ ] Can be parsed from strings (case-insensitive)

### StatModifiers Value Object
- [ ] `None` returns instance with all zeros
- [ ] `HasModifiers` correctly identifies non-zero values
- [ ] Addition operator combines modifiers correctly
- [ ] `ToString()` formats non-zero bonuses for display

### EquipmentRequirements Value Object
- [ ] `None` returns instance with no requirements
- [ ] `HasRequirements` correctly identifies when requirements exist
- [ ] `MeetsRequirements()` checks all attribute requirements
- [ ] `MeetsRequirements()` checks class requirements
- [ ] `GetUnmetRequirements()` returns descriptive list of failures
- [ ] Factory methods create appropriate requirements

### Item Entity
- [ ] Has `ArmorType?` property (nullable)
- [ ] Has `DefenseBonus` property (int)
- [ ] Has `StatModifiers` property
- [ ] Has `InitiativePenalty` property (int)
- [ ] Has `Requirements` property
- [ ] `IsArmor` returns true only for items with ArmorType
- [ ] `HasRequirements` correctly identifies items with requirements
- [ ] Factory methods create armor with correct properties

### Player Entity
- [ ] `GetEffectiveStats()` includes all defense bonuses
- [ ] `GetEffectiveStats()` includes StatModifiers.MaxHealth and Defense
- [ ] `GetEffectiveAttributes()` combines base + StatModifiers + WeaponBonuses
- [ ] `GetEffectiveAttributes()` clamps values to valid range (1-30)
- [ ] `GetTotalInitiativePenalty()` sums all equipment penalties
- [ ] `GetTotalDefenseBonus()` sums DefenseBonus and StatModifiers.Defense

### EquipmentService
- [ ] `CanEquip()` returns (false, unmet) when requirements not met
- [ ] `CanEquip()` returns (true, empty) when requirements met
- [ ] `TryEquip()` fails with clear message when requirements not met
- [ ] `TryEquip()` succeeds when requirements are met

### Configuration
- [ ] `armor.json` loads successfully
- [ ] All 14 armor pieces defined with correct properties
- [ ] All 4 accessories defined with correct properties

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| EquipmentSlot enum missing values | High | Low | Verify v0.0.7a added all needed slots (Armor, Shield, Helmet, Boots, Ring, Amulet) |
| Player.Equipment dictionary not implemented | High | Low | Prerequisite v0.0.7a must be complete |
| WeaponBonuses not available | Medium | Low | v0.0.7b prerequisite must be complete |
| Attribute clamping edge cases | Low | Medium | Tests verify boundary values |
| Stat stacking balance issues | Low | Medium | Values from design spec, adjustable via config |
| IReadOnlyList equality in requirements | Low | Low | Use Contains() for class ID comparison |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `src/Core/RuneAndRust.Domain/Enums/ArmorType.cs` | Armor type enum | ~20 |
| `src/Core/RuneAndRust.Domain/ValueObjects/StatModifiers.cs` | General stat modifiers | ~60 |
| `src/Core/RuneAndRust.Domain/ValueObjects/EquipmentRequirements.cs` | Equipment requirements | ~90 |
| `src/Core/RuneAndRust.Application/DTOs/ArmorDto.cs` | Armor display DTO | ~35 |
| `src/Core/RuneAndRust.Application/DTOs/EquipmentDisplayDto.cs` | Equipment summary DTO | ~15 |
| `config/armor.json` | Armor and accessory definitions | ~120 |
| `tests/.../Enums/ArmorTypeTests.cs` | Enum tests | ~35 |
| `tests/.../ValueObjects/StatModifiersTests.cs` | StatModifiers tests | ~60 |
| `tests/.../ValueObjects/EquipmentRequirementsTests.cs` | Requirements tests | ~80 |
| `tests/.../Entities/PlayerEffectiveStatsTests.cs` | Player stat calculation tests | ~60 |
| `tests/.../Services/EquipmentServiceRequirementsTests.cs` | Service requirement tests | ~70 |

### Files to Modify

| File | Changes |
|------|---------|
| `src/Core/RuneAndRust.Domain/Entities/Item.cs` | Add ArmorType, DefenseBonus, StatModifiers, InitiativePenalty, Requirements properties; add armor factory methods (~80 lines) |
| `src/Core/RuneAndRust.Domain/Entities/Player.cs` | Add GetEffectiveStats(), GetEffectiveAttributes(), GetTotalInitiativePenalty(), GetTotalDefenseBonus() methods (~50 lines) |
| `src/Core/RuneAndRust.Domain/Services/EquipmentService.cs` | Add CanEquip() method, update TryEquip() with requirement validation (~30 lines) |
| `src/Core/RuneAndRust.Domain/ValueObjects/EquipResult.cs` | Add RequirementsNotMet() factory method (~10 lines) |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| Unit Tests | ~224 | ~236 |
| ArmorType values | 0 | 3 |
| Armor factory methods | 0 | 5 |
| Accessory factory methods | 0 | 2 |
| Player stat methods | 0 | 4 |

---

## Next Steps

After completing this phase:

1. **v0.0.8 (Dungeon Generation)** - Procedural room/corridor generation
2. **v0.0.9 (Damage System)** - Damage types, resistances, elemental effects

---

*This implementation plan provides the detailed blueprint for v0.0.7c Armor & Requirements. It completes the v0.0.7 Equipment System by adding armor defense bonuses, general stat modifiers from all equipment, and equipment requirements based on attributes and class.*
