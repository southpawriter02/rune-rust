# v0.0.8c Design Specification: Progression Configuration

**Version:** 0.0.8c
**Parent:** v0.0.8 (Experience & Leveling)
**Prerequisites:** v0.0.8b Complete (Level-Up Mechanics)
**Status:** Design Complete

---

## Table of Contents

1. [Overview](#overview)
2. [Scope](#scope)
3. [Data Model](#data-model)
4. [Services](#services)
5. [Command Changes](#command-changes)
6. [Rendering Changes](#rendering-changes)
7. [Configuration](#configuration)
8. [Acceptance Criteria](#acceptance-criteria)
9. [Test Specifications](#test-specifications)
10. [Dependencies](#dependencies)

---

## Overview

### Purpose

Make the progression system fully configurable through JSON configuration, including terminology customization (e.g., "XP" → "Glory", "Level" → "Rank"), progression curves (linear, exponential, custom), class-specific stat bonuses, and per-level rewards. This phase transforms the hardcoded default values from v0.0.8a/b into a data-driven system that can be customized without code changes.

### Key Changes

| Area | Current State (v0.0.8b) | Target State (v0.0.8c) |
|------|------------------------|------------------------|
| XP Terminology | Hardcoded "XP" | Configurable (e.g., "Glory", "Essence") |
| Level Terminology | Hardcoded "Level" | Configurable (e.g., "Rank", "Tier") |
| XP Formula | Hardcoded `level * 100` | Configurable curves (linear, exponential, custom) |
| Stat Bonuses | Default +5 HP, +1 ATK, +1 DEF | Configurable per-level and per-class |
| Max Level | No cap | Configurable (default 20) |
| Level Rewards | None | Per-level custom rewards |
| Class Growth | Not differentiated | Class-specific stat multipliers via `GrowthRates` |

### Design Principles

1. **Build on v0.0.8b**: Extend existing `ProgressionService` and `StatModifiers` with config-driven values
2. **Follow Existing Patterns**: Use same configuration patterns as `ClassDefinition`, `AbilityDefinition`, etc.
3. **Sensible Defaults**: Game works without custom config using built-in defaults
4. **Validation**: Invalid configuration fails fast with clear error messages
5. **Class Integration**: Leverage existing `ClassDefinition.GrowthRates` for class-specific bonuses
6. **Display Consistency**: All UI uses configured terminology consistently

---

## Scope

### In Scope

- `ProgressionDefinition` entity loaded from `config/progression.json`
- `LevelDefinition` for per-level custom configuration
- `ProgressionCurve` enum (Linear, Exponential, Custom)
- Configurable terminology for XP and Level display names
- Configurable max level cap (default 20)
- Configurable base XP requirement and multiplier for progression curves
- Per-level stat bonus overrides
- Per-level custom reward descriptions
- Class-specific stat bonus integration via `ClassDefinition.GrowthRates`
- Update `ProgressionService` to use configuration
- Update `Player.GetExperienceForLevel()` and `GetLevelForExperience()` to use configuration
- Update `IGameConfigurationProvider` with progression configuration methods
- Update `JsonConfigurationProvider` to load `progression.json`
- Update renderers to use configured terminology
- Default progression configuration when no custom config exists

### Out of Scope (Future Phases)

- Skill point allocation system
- Prestige/Rebirth mechanics
- Multiple progression tracks
- Experience penalties/bonuses from equipment
- Level-down mechanics
- Per-class XP requirements

---

## Data Model

### New: ProgressionDefinition (Entity)

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines the progression system configuration for the game.
/// </summary>
/// <remarks>
/// Loaded from config/progression.json. Controls XP/Level terminology,
/// progression curves, stat bonuses per level, and max level cap.
/// </remarks>
public class ProgressionDefinition
{
    /// <summary>
    /// Gets the display name for experience points.
    /// </summary>
    /// <example>"XP", "Glory", "Essence", "Power"</example>
    public string ExperienceTerminology { get; init; } = "XP";

    /// <summary>
    /// Gets the display name for character levels.
    /// </summary>
    /// <example>"Level", "Rank", "Tier", "Grade"</example>
    public string LevelTerminology { get; init; } = "Level";

    /// <summary>
    /// Gets the maximum level a player can achieve.
    /// </summary>
    /// <remarks>
    /// Level-ups stop at this level. XP continues to accumulate.
    /// Set to 0 for no cap.
    /// </remarks>
    public int MaxLevel { get; init; } = 20;

    /// <summary>
    /// Gets the progression curve type.
    /// </summary>
    public ProgressionCurve CurveType { get; init; } = ProgressionCurve.Exponential;

    /// <summary>
    /// Gets the base XP required for level 2.
    /// </summary>
    /// <remarks>
    /// This is the foundation for all progression curve calculations.
    /// </remarks>
    public int BaseXpRequirement { get; init; } = 100;

    /// <summary>
    /// Gets the multiplier for exponential progression curves.
    /// </summary>
    /// <remarks>
    /// Each level requires (previous level XP * multiplier) XP.
    /// Only used when CurveType is Exponential.
    /// </remarks>
    public float XpMultiplier { get; init; } = 1.5f;

    /// <summary>
    /// Gets the default stat bonuses applied per level.
    /// </summary>
    /// <remarks>
    /// These values are applied unless a class has specific GrowthRates
    /// or a LevelDefinition has custom StatBonuses.
    /// </remarks>
    public StatBonusConfig DefaultStatBonuses { get; init; } = new();

    /// <summary>
    /// Gets custom level definitions for specific levels.
    /// </summary>
    /// <remarks>
    /// Allows overriding XP requirements, stat bonuses, and adding
    /// custom rewards for specific levels. Keyed by level number.
    /// </remarks>
    public IReadOnlyDictionary<int, LevelDefinition> LevelOverrides { get; init; } =
        new Dictionary<int, LevelDefinition>();

    /// <summary>
    /// Gets whether to heal the player to full on level-up.
    /// </summary>
    public bool HealOnLevelUp { get; init; } = true;

    /// <summary>
    /// Creates a default progression definition with standard values.
    /// </summary>
    public static ProgressionDefinition Default => new();

    /// <summary>
    /// Calculates the cumulative XP required to reach a specific level.
    /// </summary>
    /// <param name="level">The target level.</param>
    /// <returns>The total XP needed to reach that level.</returns>
    public int GetExperienceForLevel(int level)
    {
        if (level <= 1) return 0;
        if (MaxLevel > 0 && level > MaxLevel) level = MaxLevel;

        // Check for custom override first
        if (LevelOverrides.TryGetValue(level, out var customLevel) && customLevel.XpRequired.HasValue)
        {
            return customLevel.XpRequired.Value;
        }

        return CurveType switch
        {
            ProgressionCurve.Linear => CalculateLinearXp(level),
            ProgressionCurve.Exponential => CalculateExponentialXp(level),
            ProgressionCurve.Custom => GetCustomXpForLevel(level),
            _ => CalculateLinearXp(level)
        };
    }

    /// <summary>
    /// Gets what level corresponds to a given XP amount.
    /// </summary>
    /// <param name="experience">The experience points.</param>
    /// <returns>The level the player should be at.</returns>
    public int GetLevelForExperience(int experience)
    {
        var maxLevelToCheck = MaxLevel > 0 ? MaxLevel : 100; // Safety limit

        for (var level = maxLevelToCheck; level >= 1; level--)
        {
            if (experience >= GetExperienceForLevel(level))
            {
                return level;
            }
        }

        return 1;
    }

    /// <summary>
    /// Gets the stat bonuses for leveling up, considering class growth rates.
    /// </summary>
    /// <param name="level">The level being gained.</param>
    /// <param name="classGrowthRates">Optional class-specific growth rates.</param>
    /// <returns>The stat modifiers to apply.</returns>
    public StatModifiers GetStatBonusesForLevel(int level, StatModifiers? classGrowthRates = null)
    {
        // Check for level-specific override
        if (LevelOverrides.TryGetValue(level, out var levelDef) && levelDef.StatBonuses != null)
        {
            return levelDef.StatBonuses.ToStatModifiers();
        }

        // Use class growth rates if provided
        if (classGrowthRates.HasValue && classGrowthRates.Value.HasModifications)
        {
            return classGrowthRates.Value;
        }

        // Fall back to default stat bonuses
        return DefaultStatBonuses.ToStatModifiers();
    }

    private int CalculateLinearXp(int level)
    {
        // Linear: level * baseXp
        // Level 2 = 100, Level 3 = 200, Level 4 = 300...
        return (level - 1) * BaseXpRequirement;
    }

    private int CalculateExponentialXp(int level)
    {
        // Exponential: baseXp * (multiplier ^ (level - 2))
        // Level 2 = 100, Level 3 = 150, Level 4 = 225...
        if (level == 2) return BaseXpRequirement;

        var cumulative = 0;
        var xpForLevel = (float)BaseXpRequirement;

        for (var l = 2; l <= level; l++)
        {
            cumulative += (int)xpForLevel;
            xpForLevel *= XpMultiplier;
        }

        return cumulative;
    }

    private int GetCustomXpForLevel(int level)
    {
        // For custom curves, must be defined in LevelOverrides
        // Fall back to linear if not defined
        if (LevelOverrides.TryGetValue(level, out var levelDef) && levelDef.XpRequired.HasValue)
        {
            return levelDef.XpRequired.Value;
        }

        return CalculateLinearXp(level);
    }
}
```

### New: ProgressionCurve (Enum)

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the type of progression curve for XP requirements.
/// </summary>
public enum ProgressionCurve
{
    /// <summary>
    /// Linear progression: each level requires the same additional XP.
    /// Formula: (level - 1) * baseXpRequirement
    /// </summary>
    Linear,

    /// <summary>
    /// Exponential progression: each level requires more XP than the last.
    /// Formula: cumulative sum of (baseXp * multiplier^(level-2))
    /// </summary>
    Exponential,

    /// <summary>
    /// Custom progression: XP requirements are defined per-level in LevelOverrides.
    /// Falls back to linear for undefined levels.
    /// </summary>
    Custom
}
```

### New: LevelDefinition (Entity)

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines custom configuration for a specific level.
/// </summary>
/// <remarks>
/// Used in ProgressionDefinition.LevelOverrides to customize
/// individual levels with different XP requirements, stat bonuses,
/// or rewards.
/// </remarks>
public class LevelDefinition
{
    /// <summary>
    /// Gets the level number this definition applies to.
    /// </summary>
    public int Level { get; init; }

    /// <summary>
    /// Gets the cumulative XP required to reach this level.
    /// </summary>
    /// <remarks>
    /// If null, the XP is calculated from the progression curve.
    /// </remarks>
    public int? XpRequired { get; init; }

    /// <summary>
    /// Gets custom stat bonuses for this level.
    /// </summary>
    /// <remarks>
    /// If null, uses default stat bonuses or class growth rates.
    /// </remarks>
    public StatBonusConfig? StatBonuses { get; init; }

    /// <summary>
    /// Gets custom rewards granted at this level.
    /// </summary>
    /// <remarks>
    /// Descriptive text shown to the player. Actual reward logic
    /// would be implemented in future versions.
    /// </remarks>
    public IReadOnlyList<string> CustomRewards { get; init; } = [];

    /// <summary>
    /// Gets a milestone title granted at this level.
    /// </summary>
    /// <example>"Novice", "Apprentice", "Master"</example>
    public string? Title { get; init; }
}
```

### New: StatBonusConfig (Configuration Class)

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration class for stat bonuses, used in JSON deserialization.
/// </summary>
/// <remarks>
/// This is a mutable class for JSON binding. Use ToStatModifiers()
/// to convert to the immutable StatModifiers value object.
/// </remarks>
public class StatBonusConfig
{
    /// <summary>
    /// Gets or sets the max health bonus.
    /// </summary>
    public int MaxHealth { get; set; } = 5;

    /// <summary>
    /// Gets or sets the attack bonus.
    /// </summary>
    public int Attack { get; set; } = 1;

    /// <summary>
    /// Gets or sets the defense bonus.
    /// </summary>
    public int Defense { get; set; } = 1;

    /// <summary>
    /// Converts this configuration to a StatModifiers value object.
    /// </summary>
    /// <returns>An immutable StatModifiers instance.</returns>
    public StatModifiers ToStatModifiers() => new(MaxHealth, Attack, Defense);
}
```

### Modified: Player (Entity)

```csharp
// Update existing static methods in src/Core/RuneAndRust.Domain/Entities/Player.cs
// to use ProgressionDefinition instead of hardcoded values.

// These become instance-based or receive ProgressionDefinition parameter:

/// <summary>
/// Gets the cumulative XP required to reach the specified level.
/// </summary>
/// <param name="level">The target level.</param>
/// <param name="progression">The progression configuration to use.</param>
/// <returns>The cumulative XP required.</returns>
public static int GetExperienceForLevel(int level, ProgressionDefinition? progression = null)
{
    progression ??= ProgressionDefinition.Default;
    return progression.GetExperienceForLevel(level);
}

/// <summary>
/// Gets what level the player should be at for a given XP amount.
/// </summary>
/// <param name="experience">The experience amount.</param>
/// <param name="progression">The progression configuration to use.</param>
/// <returns>The level corresponding to that experience.</returns>
public static int GetLevelForExperience(int experience, ProgressionDefinition? progression = null)
{
    progression ??= ProgressionDefinition.Default;
    return progression.GetLevelForExperience(experience);
}

// ExperienceToNextLevel becomes:
/// <summary>
/// Gets the experience points required to reach the next level.
/// </summary>
/// <remarks>
/// Uses the default progression if no configuration is available.
/// </remarks>
public int ExperienceToNextLevel => GetExperienceToNextLevel(null);

/// <summary>
/// Gets the experience points required to reach the next level.
/// </summary>
/// <param name="progression">The progression configuration to use.</param>
/// <returns>XP needed for next level, or 0 if at max level.</returns>
public int GetExperienceToNextLevel(ProgressionDefinition? progression)
{
    progression ??= ProgressionDefinition.Default;

    if (progression.MaxLevel > 0 && Level >= progression.MaxLevel)
    {
        return 0; // At max level
    }

    return progression.GetExperienceForLevel(Level + 1);
}
```

---

## Services

### Modified: ProgressionService

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Service for managing player level progression.
/// </summary>
/// <remarks>
/// Handles level-up detection, stat increases, and ability unlocks.
/// Uses ProgressionDefinition for configurable progression rules.
/// </remarks>
public class ProgressionService
{
    private readonly ILogger<ProgressionService> _logger;
    private readonly ProgressionDefinition _progression;

    /// <summary>
    /// Creates a new ProgressionService instance.
    /// </summary>
    /// <param name="logger">The logger for progression operations.</param>
    /// <param name="progression">The progression configuration (null for defaults).</param>
    public ProgressionService(
        ILogger<ProgressionService> logger,
        ProgressionDefinition? progression = null)
    {
        _logger = logger;
        _progression = progression ?? ProgressionDefinition.Default;

        _logger.LogDebug(
            "ProgressionService initialized - MaxLevel: {MaxLevel}, Curve: {Curve}, " +
            "BaseXP: {BaseXP}, {XPTerm}/{LevelTerm} terminology",
            _progression.MaxLevel,
            _progression.CurveType,
            _progression.BaseXpRequirement,
            _progression.ExperienceTerminology,
            _progression.LevelTerminology);
    }

    /// <summary>
    /// Gets the progression configuration.
    /// </summary>
    public ProgressionDefinition Progression => _progression;

    /// <summary>
    /// Checks if the player should level up based on their current experience.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <param name="classGrowthRates">Optional class-specific growth rates.</param>
    /// <returns>A LevelUpResult if leveling up, or LevelUpResult.None if not.</returns>
    /// <exception cref="ArgumentNullException">Thrown when player is null.</exception>
    public LevelUpResult CheckForLevelUp(Player player, StatModifiers? classGrowthRates = null)
    {
        ArgumentNullException.ThrowIfNull(player);

        // Check max level cap
        if (_progression.MaxLevel > 0 && player.Level >= _progression.MaxLevel)
        {
            _logger.LogDebug(
                "Player {PlayerName} at max level {MaxLevel}",
                player.Name, _progression.MaxLevel);
            return LevelUpResult.None(player.Level);
        }

        var targetLevel = _progression.GetLevelForExperience(player.Experience);

        // Cap at max level
        if (_progression.MaxLevel > 0 && targetLevel > _progression.MaxLevel)
        {
            targetLevel = _progression.MaxLevel;
        }

        if (targetLevel <= player.Level)
        {
            _logger.LogDebug(
                "No level up - Player {PlayerName} at {LevelTerm} {Level} with {XP} {XPTerm}",
                player.Name, _progression.LevelTerminology, player.Level,
                player.Experience, _progression.ExperienceTerminology);
            return LevelUpResult.None(player.Level);
        }

        var levelsGained = targetLevel - player.Level;
        var statIncreases = GetStatIncreasesForLevels(player.Level, targetLevel, classGrowthRates);

        _logger.LogInformation(
            "{LevelTerm} up detected - Player {PlayerName}: {LevelTerm} {OldLevel} -> {NewLevel} " +
            "(+{HP} HP, +{ATK} ATK, +{DEF} DEF)",
            _progression.LevelTerminology, player.Name, _progression.LevelTerminology,
            player.Level, targetLevel,
            statIncreases.MaxHealth, statIncreases.Attack, statIncreases.Defense);

        return new LevelUpResult(
            player.Level,
            targetLevel,
            statIncreases,
            Array.Empty<string>()  // Abilities filled in by ApplyLevelUp
        );
    }

    /// <summary>
    /// Applies a level-up result to the player.
    /// </summary>
    /// <param name="player">The player to level up.</param>
    /// <param name="result">The level-up result to apply.</param>
    /// <param name="getAbilitiesAtLevel">Function to get abilities unlocked at a level.</param>
    /// <returns>The final LevelUpResult with unlocked abilities populated.</returns>
    public LevelUpResult ApplyLevelUp(
        Player player,
        LevelUpResult result,
        Func<int, IReadOnlyList<string>>? getAbilitiesAtLevel = null)
    {
        ArgumentNullException.ThrowIfNull(player);

        if (!result.DidLevelUp)
        {
            return result;
        }

        // Apply stat increases
        player.ApplyStatModifiers(result.StatIncreases, healToNewMax: _progression.HealOnLevelUp);

        // Update level
        player.SetLevel(result.NewLevel);

        // Check for newly unlocked abilities
        var unlockedAbilities = new List<string>();
        if (getAbilitiesAtLevel != null)
        {
            for (var level = result.OldLevel + 1; level <= result.NewLevel; level++)
            {
                var abilities = getAbilitiesAtLevel(level);
                unlockedAbilities.AddRange(abilities);
            }
        }

        _logger.LogInformation(
            "{LevelTerm} up applied - Player {PlayerName} is now {LevelTerm} {Level}. " +
            "Stats: HP={HP}, ATK={ATK}, DEF={DEF}. Abilities unlocked: {AbilityCount}",
            _progression.LevelTerminology, player.Name, _progression.LevelTerminology,
            player.Level,
            player.Stats.MaxHealth, player.Stats.Attack, player.Stats.Defense,
            unlockedAbilities.Count);

        return new LevelUpResult(
            result.OldLevel,
            result.NewLevel,
            result.StatIncreases,
            unlockedAbilities);
    }

    /// <summary>
    /// Checks for level-up and applies it in one operation.
    /// </summary>
    /// <param name="player">The player to check and potentially level up.</param>
    /// <param name="classGrowthRates">Optional class-specific growth rates.</param>
    /// <param name="getAbilitiesAtLevel">Function to get abilities unlocked at a level.</param>
    /// <returns>The LevelUpResult (DidLevelUp will be false if no level-up occurred).</returns>
    public LevelUpResult CheckAndApplyLevelUp(
        Player player,
        StatModifiers? classGrowthRates = null,
        Func<int, IReadOnlyList<string>>? getAbilitiesAtLevel = null)
    {
        var result = CheckForLevelUp(player, classGrowthRates);

        if (!result.DidLevelUp)
        {
            return result;
        }

        return ApplyLevelUp(player, result, getAbilitiesAtLevel);
    }

    /// <summary>
    /// Gets the cumulative stat increases for gaining multiple levels.
    /// </summary>
    /// <param name="fromLevel">The starting level.</param>
    /// <param name="toLevel">The ending level.</param>
    /// <param name="classGrowthRates">Optional class-specific growth rates.</param>
    /// <returns>The total stat increases.</returns>
    public StatModifiers GetStatIncreasesForLevels(
        int fromLevel,
        int toLevel,
        StatModifiers? classGrowthRates = null)
    {
        if (toLevel <= fromLevel)
        {
            return StatModifiers.Zero;
        }

        var total = StatModifiers.Zero;

        for (var level = fromLevel + 1; level <= toLevel; level++)
        {
            var bonuses = _progression.GetStatBonusesForLevel(level, classGrowthRates);
            total = total.Add(bonuses);
        }

        return total;
    }

    /// <summary>
    /// Gets the XP required for the next level.
    /// </summary>
    /// <param name="currentLevel">The current level.</param>
    /// <returns>The XP required to reach the next level.</returns>
    public int GetExperienceForNextLevel(int currentLevel)
    {
        if (_progression.MaxLevel > 0 && currentLevel >= _progression.MaxLevel)
        {
            return 0;
        }

        return _progression.GetExperienceForLevel(currentLevel + 1);
    }

    /// <summary>
    /// Gets the XP remaining until the next level.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>The XP needed to reach the next level.</returns>
    public int GetExperienceUntilNextLevel(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        if (_progression.MaxLevel > 0 && player.Level >= _progression.MaxLevel)
        {
            return 0;
        }

        var nextLevelXp = _progression.GetExperienceForLevel(player.Level + 1);
        return Math.Max(0, nextLevelXp - player.Experience);
    }

    /// <summary>
    /// Gets custom rewards for a specific level, if any.
    /// </summary>
    /// <param name="level">The level to check.</param>
    /// <returns>List of reward descriptions, or empty if none.</returns>
    public IReadOnlyList<string> GetCustomRewardsForLevel(int level)
    {
        if (_progression.LevelOverrides.TryGetValue(level, out var levelDef))
        {
            return levelDef.CustomRewards;
        }

        return Array.Empty<string>();
    }

    /// <summary>
    /// Gets the milestone title for a level, if any.
    /// </summary>
    /// <param name="level">The level to check.</param>
    /// <returns>The title or null if none defined.</returns>
    public string? GetTitleForLevel(int level)
    {
        if (_progression.LevelOverrides.TryGetValue(level, out var levelDef))
        {
            return levelDef.Title;
        }

        return null;
    }
}
```

### Modified: IGameConfigurationProvider

```csharp
// Add to existing IGameConfigurationProvider interface in
// src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs

/// <summary>
/// Gets the progression configuration.
/// </summary>
/// <returns>The progression definition, or default if not configured.</returns>
ProgressionDefinition GetProgressionConfiguration();
```

### Modified: JsonConfigurationProvider

```csharp
// Add to existing JsonConfigurationProvider in
// src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs

// Add field:
private ProgressionDefinition? _progression;

/// <inheritdoc/>
public ProgressionDefinition GetProgressionConfiguration()
{
    if (_progression != null) return _progression;

    var filePath = Path.Combine(_configPath, "progression.json");
    var config = LoadJsonFile<ProgressionJsonConfig>(filePath);
    _progression = config?.ToProgressionDefinition() ?? ProgressionDefinition.Default;

    _logger.LogDebug(
        "Loaded progression config - MaxLevel: {MaxLevel}, Curve: {Curve}, {XPTerm}/{LevelTerm}",
        _progression.MaxLevel,
        _progression.CurveType,
        _progression.ExperienceTerminology,
        _progression.LevelTerminology);

    return _progression;
}

// JSON config classes:
private class ProgressionJsonConfig
{
    public string ExperienceTerminology { get; set; } = "XP";
    public string LevelTerminology { get; set; } = "Level";
    public int MaxLevel { get; set; } = 20;
    public string CurveType { get; set; } = "Exponential";
    public int BaseXpRequirement { get; set; } = 100;
    public float XpMultiplier { get; set; } = 1.5f;
    public StatBonusJsonConfig? DefaultStatBonuses { get; set; }
    public List<LevelDefinitionJsonConfig>? Levels { get; set; }
    public bool HealOnLevelUp { get; set; } = true;

    public ProgressionDefinition ToProgressionDefinition()
    {
        var curveType = Enum.TryParse<ProgressionCurve>(CurveType, true, out var ct)
            ? ct : ProgressionCurve.Exponential;

        var levelOverrides = new Dictionary<int, LevelDefinition>();
        if (Levels != null)
        {
            foreach (var level in Levels)
            {
                levelOverrides[level.Level] = level.ToLevelDefinition();
            }
        }

        return new ProgressionDefinition
        {
            ExperienceTerminology = ExperienceTerminology,
            LevelTerminology = LevelTerminology,
            MaxLevel = MaxLevel,
            CurveType = curveType,
            BaseXpRequirement = BaseXpRequirement,
            XpMultiplier = XpMultiplier,
            DefaultStatBonuses = DefaultStatBonuses?.ToStatBonusConfig() ?? new StatBonusConfig(),
            LevelOverrides = levelOverrides,
            HealOnLevelUp = HealOnLevelUp
        };
    }
}

private class StatBonusJsonConfig
{
    public int MaxHealth { get; set; } = 5;
    public int Attack { get; set; } = 1;
    public int Defense { get; set; } = 1;

    public StatBonusConfig ToStatBonusConfig() => new()
    {
        MaxHealth = MaxHealth,
        Attack = Attack,
        Defense = Defense
    };
}

private class LevelDefinitionJsonConfig
{
    public int Level { get; set; }
    public int? XpRequired { get; set; }
    public StatBonusJsonConfig? StatBonuses { get; set; }
    public List<string>? CustomRewards { get; set; }
    public string? Title { get; set; }

    public LevelDefinition ToLevelDefinition() => new()
    {
        Level = Level,
        XpRequired = XpRequired,
        StatBonuses = StatBonuses?.ToStatBonusConfig(),
        CustomRewards = CustomRewards ?? [],
        Title = Title
    };
}
```

### Service Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                  CONFIGURABLE LEVEL-UP FLOW                                  │
└─────────────────────────────────────────────────────────────────────────────┘

    GameSessionService starts
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 1: LOAD CONFIGURATION                                │
├─────────────────────────────────────────────────────────────────────────────┤
│  IGameConfigurationProvider.GetProgressionConfiguration()                    │
│  ├── Load config/progression.json                                           │
│  ├── Parse terminology, curve type, max level, stat bonuses                 │
│  └── Return ProgressionDefinition (or Default if missing)                   │
└─────────────────────────────────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 2: CREATE PROGRESSION SERVICE                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  new ProgressionService(logger, progressionDefinition)                       │
│  ├── Store configuration                                                    │
│  └── Use configured values for all calculations                             │
└─────────────────────────────────────────────────────────────────────────────┘
            │
            ▼ (on XP gain)
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 3: CHECK FOR LEVEL UP                                │
├─────────────────────────────────────────────────────────────────────────────┤
│  ProgressionService.CheckForLevelUp(player, classGrowthRates)                │
│  ├── Check max level cap from config                                        │
│  ├── Calculate target level using config curve                              │
│  ├── Get stat bonuses from class GrowthRates or config defaults             │
│  └── Return LevelUpResult                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
            │
            ▼ (if DidLevelUp)
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 4: APPLY LEVEL UP                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│  ProgressionService.ApplyLevelUp(player, result, getAbilitiesAtLevel)        │
│  ├── Apply stat modifiers                                                   │
│  ├── Heal to max if config.HealOnLevelUp is true                            │
│  ├── Update player level                                                    │
│  ├── Collect unlocked abilities                                             │
│  └── Get custom rewards from LevelOverrides                                 │
└─────────────────────────────────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 5: RENDER WITH TERMINOLOGY                           │
├─────────────────────────────────────────────────────────────────────────────┤
│  SpectreGameRenderer.RenderLevelUpAsync(dto, progression)                    │
│  ├── Use progression.LevelTerminology for "Level" → "Rank"                  │
│  ├── Use progression.ExperienceTerminology for "XP" → "Glory"               │
│  ├── Display custom rewards if any                                          │
│  └── Show title if milestone level                                          │
└─────────────────────────────────────────────────────────────────────────────┘

                    Class Growth Rates Integration
                    ═══════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│  ClassDefinition (from classes.json)                                         │
│  ├── id: "shieldmaiden"                                                     │
│  ├── growthRates:                                                           │
│  │   ├── maxHealth: 12  (instead of default 5)                              │
│  │   ├── attack: 2      (instead of default 1)                              │
│  │   └── defense: 3     (instead of default 1)                              │
│  │                                                                          │
│  When player levels up:                                                      │
│  1. Get player's class from ClassService                                    │
│  2. Extract class.GrowthRates as StatModifiers                              │
│  3. Pass to ProgressionService.CheckForLevelUp(player, classGrowthRates)    │
│  4. Class growth rates override default stat bonuses                         │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Command Changes

### No New Commands

v0.0.8c does not introduce any new player commands. The configuration is loaded automatically at startup and affects all existing progression displays.

### Modified Display Formats

All progression-related output uses configured terminology:

**Status Command (Default terminology):**
```
> status

=== Hero (Level 3 Shieldmaiden) ===
HP: 124/124
XP: 380/500 (76%)
Attack: 14  Defense: 11
```

**Status Command (Custom terminology - Glory/Rank):**
```
> status

=== Hero (Rank 3 Shieldmaiden) ===
HP: 124/124
Glory: 380/500 (76%)
Attack: 14  Defense: 11
```

**Combat Victory (Custom terminology):**
```
> attack goblin

You attack the Goblin for 15 damage!
The Goblin has been defeated!

★ You gained 25 Glory!
Glory: 425/500 (85%)
```

---

## Rendering Changes

### Modified: ExperienceGainDto

```csharp
// Update in src/Core/RuneAndRust.Application/DTOs/ExperienceGainDto.cs

/// <summary>
/// DTO for displaying experience gain information to the UI.
/// </summary>
/// <param name="AmountGained">The XP amount gained.</param>
/// <param name="NewTotal">The player's new total XP.</param>
/// <param name="Source">Description of the XP source.</param>
/// <param name="CurrentLevel">The player's current level.</param>
/// <param name="ExperienceToNextLevel">XP needed for next level.</param>
/// <param name="ProgressPercent">Progress toward next level (0-100).</param>
/// <param name="ExperienceTerminology">The configured term for experience.</param>
/// <param name="LevelTerminology">The configured term for level.</param>
public record ExperienceGainDto(
    int AmountGained,
    int NewTotal,
    string Source,
    int CurrentLevel,
    int ExperienceToNextLevel,
    int ProgressPercent,
    string ExperienceTerminology = "XP",
    string LevelTerminology = "Level");
```

### Modified: LevelUpDto

```csharp
// Update in src/Core/RuneAndRust.Application/DTOs/LevelUpDto.cs

/// <summary>
/// DTO for displaying level-up information to the UI.
/// </summary>
public record LevelUpDto(
    int OldLevel,
    int NewLevel,
    int LevelsGained,
    int OldMaxHealth,
    int NewMaxHealth,
    int OldAttack,
    int NewAttack,
    int OldDefense,
    int NewDefense,
    IReadOnlyList<string> UnlockedAbilityNames,
    int XpToNextLevel,
    IReadOnlyList<string> CustomRewards,
    string? Title,
    string ExperienceTerminology = "XP",
    string LevelTerminology = "Level")
{
    /// <summary>
    /// Gets whether multiple levels were gained.
    /// </summary>
    public bool IsMultiLevel => LevelsGained > 1;

    /// <summary>
    /// Gets whether any abilities were unlocked.
    /// </summary>
    public bool HasUnlockedAbilities => UnlockedAbilityNames.Count > 0;

    /// <summary>
    /// Gets whether there are custom rewards for this level.
    /// </summary>
    public bool HasCustomRewards => CustomRewards.Count > 0;

    /// <summary>
    /// Gets whether a title was earned at this level.
    /// </summary>
    public bool HasTitle => !string.IsNullOrEmpty(Title);
}
```

### Modified: SpectreGameRenderer

```csharp
// Update in src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs

/// <inheritdoc />
public Task RenderExperienceGainAsync(ExperienceGainDto experienceGain, CancellationToken ct = default)
{
    AnsiConsole.WriteLine();
    AnsiConsole.MarkupLine(
        $"[yellow]★[/] You gained [green]{experienceGain.AmountGained} " +
        $"{experienceGain.ExperienceTerminology}[/]!");
    AnsiConsole.MarkupLine(
        $"[dim]{experienceGain.ExperienceTerminology}: " +
        $"{experienceGain.NewTotal}/{experienceGain.ExperienceToNextLevel} " +
        $"({experienceGain.ProgressPercent}%)[/]");
    AnsiConsole.WriteLine();

    return Task.CompletedTask;
}

/// <inheritdoc />
public Task RenderLevelUpAsync(LevelUpDto levelUp, CancellationToken ct = default)
{
    var panel = new Panel(BuildLevelUpContent(levelUp))
    {
        Border = BoxBorder.Double,
        BorderStyle = new Style(Color.Yellow),
        Padding = new Padding(2, 1),
        Header = new PanelHeader(
            $"[bold yellow]★ {levelUp.LevelTerminology.ToUpperInvariant()} UP! ★[/]",
            Justify.Center)
    };

    AnsiConsole.WriteLine();
    AnsiConsole.Write(panel);
    AnsiConsole.WriteLine();

    return Task.CompletedTask;
}

private static string BuildLevelUpContent(LevelUpDto levelUp)
{
    var sb = new StringBuilder();

    // Level announcement
    if (levelUp.IsMultiLevel)
    {
        sb.AppendLine($"[bold]You gained {levelUp.LevelsGained} {levelUp.LevelTerminology.ToLowerInvariant()}s![/]");
        sb.AppendLine($"[dim]{levelUp.LevelTerminology} {levelUp.OldLevel} → {levelUp.LevelTerminology} {levelUp.NewLevel}[/]");
    }
    else
    {
        sb.AppendLine($"[bold]You have reached {levelUp.LevelTerminology} {levelUp.NewLevel}![/]");
    }

    // Title earned
    if (levelUp.HasTitle)
    {
        sb.AppendLine();
        sb.AppendLine($"[bold cyan]Title Earned: {levelUp.Title}[/]");
    }

    sb.AppendLine();

    // Stat increases
    sb.AppendLine("[underline]Stat Increases:[/]");
    sb.AppendLine($"  Max Health: [dim]{levelUp.OldMaxHealth}[/] → [green]{levelUp.NewMaxHealth}[/] [dim](+{levelUp.NewMaxHealth - levelUp.OldMaxHealth})[/]");
    sb.AppendLine($"  Attack: [dim]{levelUp.OldAttack}[/] → [green]{levelUp.NewAttack}[/] [dim](+{levelUp.NewAttack - levelUp.OldAttack})[/]");
    sb.AppendLine($"  Defense: [dim]{levelUp.OldDefense}[/] → [green]{levelUp.NewDefense}[/] [dim](+{levelUp.NewDefense - levelUp.OldDefense})[/]");

    // Unlocked abilities
    if (levelUp.HasUnlockedAbilities)
    {
        sb.AppendLine();
        sb.AppendLine("[underline]New Abilities Unlocked:[/]");
        foreach (var ability in levelUp.UnlockedAbilityNames)
        {
            sb.AppendLine($"  [cyan]•[/] [bold]{ability}[/]");
        }
    }

    // Custom rewards
    if (levelUp.HasCustomRewards)
    {
        sb.AppendLine();
        sb.AppendLine("[underline]Rewards:[/]");
        foreach (var reward in levelUp.CustomRewards)
        {
            sb.AppendLine($"  [yellow]★[/] {reward}");
        }
    }

    // Next level info
    sb.AppendLine();
    if (levelUp.XpToNextLevel > 0)
    {
        sb.AppendLine($"[dim]Next {levelUp.LevelTerminology}: {levelUp.XpToNextLevel} {levelUp.ExperienceTerminology} needed ({levelUp.LevelTerminology} {levelUp.NewLevel + 1})[/]");
    }
    else
    {
        sb.AppendLine($"[bold gold1]Maximum {levelUp.LevelTerminology} Reached![/]");
    }

    return sb.ToString();
}

// Update status display to use terminology:
// In RenderPlayerStatusAsync, replace hardcoded "XP" and "Level":
AnsiConsole.MarkupLine(
    $"{progression.ExperienceTerminology}: [cyan]{player.Experience}[/]/" +
    $"[cyan]{xpToNext}[/] ([cyan]{progressPercent}%[/])");
```

### Display Examples

**Level-Up with Custom Rewards (Custom terminology):**
```
═══════════════════════════════════════════
           ★ RANK UP! ★
═══════════════════════════════════════════
You have reached Rank 5!

Title Earned: Veteran

Stat Increases:
  Max Health: 120 → 125 (+5)
  Attack: 14 → 15 (+1)
  Defense: 9 → 10 (+1)

New Abilities Unlocked:
  • Shield Wall

Rewards:
  ★ Unlock: Advanced Training
  ★ +10 starting gold on new characters

Next Rank: 500 Glory needed (Rank 6)
═══════════════════════════════════════════
```

**Max Level Reached:**
```
═══════════════════════════════════════════
           ★ LEVEL UP! ★
═══════════════════════════════════════════
You have reached Level 20!

Title Earned: Champion

Stat Increases:
  Max Health: 195 → 200 (+5)
  Attack: 29 → 30 (+1)
  Defense: 24 → 25 (+1)

Rewards:
  ★ Title: Champion of the Realm
  ★ Legendary ability slot unlocked

Maximum Level Reached!
═══════════════════════════════════════════
```

---

## Configuration

### Configuration File: config/progression.json

```json
{
    "experienceTerminology": "XP",
    "levelTerminology": "Level",
    "maxLevel": 20,
    "curveType": "Exponential",
    "baseXpRequirement": 100,
    "xpMultiplier": 1.5,
    "healOnLevelUp": true,
    "defaultStatBonuses": {
        "maxHealth": 5,
        "attack": 1,
        "defense": 1
    },
    "levels": [
        {
            "level": 5,
            "title": "Veteran",
            "customRewards": ["Unlock: Advanced Training"]
        },
        {
            "level": 10,
            "title": "Elite",
            "customRewards": ["Unlock: Mastery Skills", "+1 ability slot"]
        },
        {
            "level": 15,
            "title": "Master",
            "customRewards": ["Unlock: Epic abilities"]
        },
        {
            "level": 20,
            "title": "Champion",
            "customRewards": ["Title: Champion of the Realm", "Legendary ability slot unlocked"]
        }
    ]
}
```

### Alternative Configuration: Glory/Rank Theme

```json
{
    "experienceTerminology": "Glory",
    "levelTerminology": "Rank",
    "maxLevel": 10,
    "curveType": "Linear",
    "baseXpRequirement": 200,
    "xpMultiplier": 1.0,
    "healOnLevelUp": true,
    "defaultStatBonuses": {
        "maxHealth": 10,
        "attack": 2,
        "defense": 2
    },
    "levels": [
        {
            "level": 3,
            "title": "Blooded",
            "customRewards": ["Combat bonus: +5% damage"]
        },
        {
            "level": 5,
            "title": "Proven",
            "customRewards": ["Unlock: War cry ability"]
        },
        {
            "level": 7,
            "title": "Feared",
            "customRewards": ["Enemies may flee on sight"]
        },
        {
            "level": 10,
            "title": "Legendary",
            "customRewards": ["Title: Legend of the Realm", "Unlock: Ultimate ability"]
        }
    ]
}
```

### Custom Curve Configuration

```json
{
    "experienceTerminology": "XP",
    "levelTerminology": "Level",
    "maxLevel": 10,
    "curveType": "Custom",
    "baseXpRequirement": 100,
    "healOnLevelUp": true,
    "defaultStatBonuses": {
        "maxHealth": 5,
        "attack": 1,
        "defense": 1
    },
    "levels": [
        { "level": 2, "xpRequired": 100 },
        { "level": 3, "xpRequired": 300 },
        { "level": 4, "xpRequired": 600 },
        { "level": 5, "xpRequired": 1000, "title": "Adept" },
        { "level": 6, "xpRequired": 1500 },
        { "level": 7, "xpRequired": 2100 },
        { "level": 8, "xpRequired": 2800 },
        { "level": 9, "xpRequired": 3600 },
        { "level": 10, "xpRequired": 5000, "title": "Master", "customRewards": ["Max level achieved!"] }
    ]
}
```

### Default Values (When No Config File)

| Setting | Default Value | Notes |
|---------|---------------|-------|
| experienceTerminology | "XP" | Display name for experience |
| levelTerminology | "Level" | Display name for levels |
| maxLevel | 20 | Maximum achievable level |
| curveType | Exponential | XP curve type |
| baseXpRequirement | 100 | XP for level 2 |
| xpMultiplier | 1.5 | Exponential curve multiplier |
| healOnLevelUp | true | Restore HP on level-up |
| defaultStatBonuses.maxHealth | 5 | HP per level |
| defaultStatBonuses.attack | 1 | Attack per level |
| defaultStatBonuses.defense | 1 | Defense per level |

### Progression Curve Comparison

| Level | Linear (base=100) | Exponential (1.5x) | Custom Example |
|-------|-------------------|--------------------| ---------------|
| 1 | 0 | 0 | 0 |
| 2 | 100 | 100 | 100 |
| 3 | 200 | 250 | 300 |
| 4 | 300 | 475 | 600 |
| 5 | 400 | 812 | 1000 |
| 6 | 500 | 1,319 | 1500 |
| 7 | 600 | 2,078 | 2100 |
| 8 | 700 | 3,217 | 2800 |
| 9 | 800 | 4,926 | 3600 |
| 10 | 900 | 7,490 | 5000 |

---

## Acceptance Criteria

### ProgressionDefinition Entity

- [ ] Contains `ExperienceTerminology` property (default "XP")
- [ ] Contains `LevelTerminology` property (default "Level")
- [ ] Contains `MaxLevel` property (default 20)
- [ ] Contains `CurveType` property (default Exponential)
- [ ] Contains `BaseXpRequirement` property (default 100)
- [ ] Contains `XpMultiplier` property (default 1.5)
- [ ] Contains `DefaultStatBonuses` configuration
- [ ] Contains `LevelOverrides` dictionary
- [ ] Contains `HealOnLevelUp` property (default true)
- [ ] `GetExperienceForLevel()` calculates correct XP for Linear curve
- [ ] `GetExperienceForLevel()` calculates correct XP for Exponential curve
- [ ] `GetExperienceForLevel()` uses LevelOverrides for Custom curve
- [ ] `GetLevelForExperience()` returns correct level for given XP
- [ ] `GetStatBonusesForLevel()` returns level-specific bonuses if defined
- [ ] `GetStatBonusesForLevel()` returns class growth rates if provided
- [ ] `GetStatBonusesForLevel()` falls back to default bonuses
- [ ] `Default` static property returns sensible defaults

### ProgressionCurve Enum

- [ ] Contains `Linear` value
- [ ] Contains `Exponential` value
- [ ] Contains `Custom` value

### LevelDefinition Entity

- [ ] Contains `Level` property
- [ ] Contains nullable `XpRequired` property
- [ ] Contains nullable `StatBonuses` property
- [ ] Contains `CustomRewards` list
- [ ] Contains nullable `Title` property

### ProgressionService Updates

- [ ] Constructor accepts `ProgressionDefinition` parameter
- [ ] `Progression` property exposes configuration
- [ ] `CheckForLevelUp()` respects max level cap
- [ ] `CheckForLevelUp()` uses configured XP curve
- [ ] `CheckForLevelUp()` accepts class growth rates parameter
- [ ] `GetStatIncreasesForLevels()` uses class growth rates when provided
- [ ] `GetCustomRewardsForLevel()` returns rewards from LevelOverrides
- [ ] `GetTitleForLevel()` returns title from LevelOverrides
- [ ] Logging uses configured terminology

### IGameConfigurationProvider Updates

- [ ] `GetProgressionConfiguration()` method exists
- [ ] Returns default configuration when file missing

### JsonConfigurationProvider Updates

- [ ] Loads `config/progression.json`
- [ ] Parses all configuration properties correctly
- [ ] Converts JSON to `ProgressionDefinition`
- [ ] Returns default when file missing
- [ ] Handles invalid JSON gracefully

### DTO Updates

- [ ] `ExperienceGainDto` includes terminology properties
- [ ] `LevelUpDto` includes terminology, custom rewards, and title properties

### Display Updates

- [ ] Status uses configured XP terminology
- [ ] Status uses configured Level terminology
- [ ] XP gain uses configured terminology
- [ ] Level-up notification uses configured terminology
- [ ] Level-up shows custom rewards when present
- [ ] Level-up shows title when present
- [ ] Max level message displays when at cap

### Class Integration

- [ ] `ClassDefinition.GrowthRates` used for stat bonuses when available
- [ ] Class-specific growth rates override default bonuses

### General

- [ ] ~14 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings
- [ ] Game works without progression.json (uses defaults)

---

## Test Specifications

### Unit Tests (~14 tests)

#### ProgressionDefinitionTests.cs (~6 tests)

```csharp
[TestFixture]
public class ProgressionDefinitionTests
{
    [Test]
    public void Default_ReturnsExpectedValues()
    {
        var def = ProgressionDefinition.Default;

        Assert.That(def.ExperienceTerminology, Is.EqualTo("XP"));
        Assert.That(def.LevelTerminology, Is.EqualTo("Level"));
        Assert.That(def.MaxLevel, Is.EqualTo(20));
        Assert.That(def.CurveType, Is.EqualTo(ProgressionCurve.Exponential));
        Assert.That(def.BaseXpRequirement, Is.EqualTo(100));
    }

    [Test]
    public void GetExperienceForLevel_Linear_CalculatesCorrectly()
    {
        var def = new ProgressionDefinition
        {
            CurveType = ProgressionCurve.Linear,
            BaseXpRequirement = 100
        };

        Assert.That(def.GetExperienceForLevel(1), Is.EqualTo(0));
        Assert.That(def.GetExperienceForLevel(2), Is.EqualTo(100));
        Assert.That(def.GetExperienceForLevel(3), Is.EqualTo(200));
        Assert.That(def.GetExperienceForLevel(5), Is.EqualTo(400));
    }

    [Test]
    public void GetExperienceForLevel_Exponential_CalculatesCorrectly()
    {
        var def = new ProgressionDefinition
        {
            CurveType = ProgressionCurve.Exponential,
            BaseXpRequirement = 100,
            XpMultiplier = 1.5f
        };

        Assert.That(def.GetExperienceForLevel(1), Is.EqualTo(0));
        Assert.That(def.GetExperienceForLevel(2), Is.EqualTo(100));
        Assert.That(def.GetExperienceForLevel(3), Is.EqualTo(250)); // 100 + 150
    }

    [Test]
    public void GetExperienceForLevel_Custom_UsesOverrides()
    {
        var def = new ProgressionDefinition
        {
            CurveType = ProgressionCurve.Custom,
            LevelOverrides = new Dictionary<int, LevelDefinition>
            {
                [3] = new LevelDefinition { Level = 3, XpRequired = 500 },
                [5] = new LevelDefinition { Level = 5, XpRequired = 2000 }
            }
        };

        Assert.That(def.GetExperienceForLevel(3), Is.EqualTo(500));
        Assert.That(def.GetExperienceForLevel(5), Is.EqualTo(2000));
    }

    [Test]
    public void GetLevelForExperience_ReturnsCorrectLevel()
    {
        var def = new ProgressionDefinition
        {
            CurveType = ProgressionCurve.Linear,
            BaseXpRequirement = 100
        };

        Assert.That(def.GetLevelForExperience(0), Is.EqualTo(1));
        Assert.That(def.GetLevelForExperience(99), Is.EqualTo(1));
        Assert.That(def.GetLevelForExperience(100), Is.EqualTo(2));
        Assert.That(def.GetLevelForExperience(250), Is.EqualTo(3));
    }

    [Test]
    public void GetStatBonusesForLevel_UsesClassGrowthRates_WhenProvided()
    {
        var def = new ProgressionDefinition
        {
            DefaultStatBonuses = new StatBonusConfig { MaxHealth = 5, Attack = 1, Defense = 1 }
        };

        var classGrowth = new StatModifiers(12, 2, 3);

        var result = def.GetStatBonusesForLevel(2, classGrowth);

        Assert.That(result.MaxHealth, Is.EqualTo(12));
        Assert.That(result.Attack, Is.EqualTo(2));
        Assert.That(result.Defense, Is.EqualTo(3));
    }
}
```

#### ProgressionServiceConfigTests.cs (~4 tests)

```csharp
[TestFixture]
public class ProgressionServiceConfigTests
{
    private Player _player = null!;

    [SetUp]
    public void SetUp()
    {
        _player = new Player("TestPlayer", new Stats(100, 10, 5));
    }

    [Test]
    public void CheckForLevelUp_RespectsMaxLevel()
    {
        var progression = new ProgressionDefinition
        {
            MaxLevel = 5,
            CurveType = ProgressionCurve.Linear,
            BaseXpRequirement = 100
        };

        var service = new ProgressionService(
            NullLogger<ProgressionService>.Instance,
            progression);

        _player.SetLevel(5);
        _player.AddExperience(10000); // Way over max

        var result = service.CheckForLevelUp(_player);

        Assert.That(result.DidLevelUp, Is.False);
    }

    [Test]
    public void CheckForLevelUp_UsesConfiguredCurve()
    {
        var progression = new ProgressionDefinition
        {
            CurveType = ProgressionCurve.Linear,
            BaseXpRequirement = 200  // Different from default
        };

        var service = new ProgressionService(
            NullLogger<ProgressionService>.Instance,
            progression);

        _player.AddExperience(200);  // Level 2 with base=200

        var result = service.CheckForLevelUp(_player);

        Assert.That(result.DidLevelUp, Is.True);
        Assert.That(result.NewLevel, Is.EqualTo(2));
    }

    [Test]
    public void GetCustomRewardsForLevel_ReturnsRewards()
    {
        var progression = new ProgressionDefinition
        {
            LevelOverrides = new Dictionary<int, LevelDefinition>
            {
                [5] = new LevelDefinition
                {
                    Level = 5,
                    CustomRewards = ["Unlock: Training", "Bonus gold"]
                }
            }
        };

        var service = new ProgressionService(
            NullLogger<ProgressionService>.Instance,
            progression);

        var rewards = service.GetCustomRewardsForLevel(5);

        Assert.That(rewards, Has.Count.EqualTo(2));
        Assert.That(rewards[0], Is.EqualTo("Unlock: Training"));
    }

    [Test]
    public void GetTitleForLevel_ReturnsTitle()
    {
        var progression = new ProgressionDefinition
        {
            LevelOverrides = new Dictionary<int, LevelDefinition>
            {
                [10] = new LevelDefinition { Level = 10, Title = "Elite" }
            }
        };

        var service = new ProgressionService(
            NullLogger<ProgressionService>.Instance,
            progression);

        var title = service.GetTitleForLevel(10);

        Assert.That(title, Is.EqualTo("Elite"));
    }
}
```

#### JsonConfigurationProviderProgressionTests.cs (~4 tests)

```csharp
[TestFixture]
public class JsonConfigurationProviderProgressionTests
{
    private string _tempConfigPath = null!;
    private JsonConfigurationProvider _provider = null!;

    [SetUp]
    public void SetUp()
    {
        _tempConfigPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
        Directory.CreateDirectory(_tempConfigPath);
        _provider = new JsonConfigurationProvider(
            _tempConfigPath,
            NullLogger<JsonConfigurationProvider>.Instance);
    }

    [TearDown]
    public void TearDown()
    {
        if (Directory.Exists(_tempConfigPath))
        {
            Directory.Delete(_tempConfigPath, true);
        }
    }

    [Test]
    public void GetProgressionConfiguration_NoFile_ReturnsDefault()
    {
        var result = _provider.GetProgressionConfiguration();

        Assert.That(result.ExperienceTerminology, Is.EqualTo("XP"));
        Assert.That(result.LevelTerminology, Is.EqualTo("Level"));
        Assert.That(result.MaxLevel, Is.EqualTo(20));
    }

    [Test]
    public void GetProgressionConfiguration_LoadsCustomTerminology()
    {
        var json = @"{
            ""experienceTerminology"": ""Glory"",
            ""levelTerminology"": ""Rank"",
            ""maxLevel"": 10
        }";
        File.WriteAllText(Path.Combine(_tempConfigPath, "progression.json"), json);

        var result = _provider.GetProgressionConfiguration();

        Assert.That(result.ExperienceTerminology, Is.EqualTo("Glory"));
        Assert.That(result.LevelTerminology, Is.EqualTo("Rank"));
        Assert.That(result.MaxLevel, Is.EqualTo(10));
    }

    [Test]
    public void GetProgressionConfiguration_LoadsLevelOverrides()
    {
        var json = @"{
            ""levels"": [
                { ""level"": 5, ""title"": ""Veteran"", ""customRewards"": [""Bonus""] }
            ]
        }";
        File.WriteAllText(Path.Combine(_tempConfigPath, "progression.json"), json);

        var result = _provider.GetProgressionConfiguration();

        Assert.That(result.LevelOverrides, Contains.Key(5));
        Assert.That(result.LevelOverrides[5].Title, Is.EqualTo("Veteran"));
        Assert.That(result.LevelOverrides[5].CustomRewards, Has.Count.EqualTo(1));
    }

    [Test]
    public void GetProgressionConfiguration_ParsesCurveType()
    {
        var json = @"{ ""curveType"": ""Linear"" }";
        File.WriteAllText(Path.Combine(_tempConfigPath, "progression.json"), json);

        var result = _provider.GetProgressionConfiguration();

        Assert.That(result.CurveType, Is.EqualTo(ProgressionCurve.Linear));
    }
}
```

### Test Summary

| Test File | Test Count | Focus Areas |
|-----------|------------|-------------|
| `ProgressionDefinitionTests.cs` | ~6 | Curve calculations, stat bonuses, defaults |
| `ProgressionServiceConfigTests.cs` | ~4 | Max level, custom curves, rewards, titles |
| `JsonConfigurationProviderProgressionTests.cs` | ~4 | JSON loading, defaults, terminology |
| **Total** | **~14** | |

---

## Dependencies

### Required from v0.0.8b (Level-Up Mechanics)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `LevelUpResult` | `Domain/ValueObjects/LevelUpResult.cs` | Extended with custom rewards, title |
| `StatModifiers` | `Domain/ValueObjects/StatModifiers.cs` | Used for stat bonuses |
| `ProgressionService` | `Domain/Services/ProgressionService.cs` | Modified to use configuration |
| `LevelUpDto` | `Application/DTOs/LevelUpDto.cs` | Extended with terminology, rewards, title |
| `IGameRenderer.RenderLevelUpAsync()` | `Application/Interfaces/IGameRenderer.cs` | Updated to use terminology |

### Required from v0.0.8a (Core Experience System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Player.Experience` | `Domain/Entities/Player.cs` | XP tracking |
| `Player.Level` | `Domain/Entities/Player.cs` | Current level |
| `Player.GetExperienceForLevel()` | `Domain/Entities/Player.cs` | Modified to use configuration |
| `Player.GetLevelForExperience()` | `Domain/Entities/Player.cs` | Modified to use configuration |
| `ExperienceGainDto` | `Application/DTOs/ExperienceGainDto.cs` | Extended with terminology |
| `IGameRenderer.RenderExperienceGainAsync()` | `Application/Interfaces/IGameRenderer.cs` | Updated to use terminology |

### Required from Existing Infrastructure

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `IGameConfigurationProvider` | `Application/Interfaces/IConfigurationProvider.cs` | Extended with progression methods |
| `JsonConfigurationProvider` | `Infrastructure/Configuration/JsonConfigurationProvider.cs` | Extended to load progression.json |
| `ClassDefinition.GrowthRates` | `Domain/Definitions/ClassDefinition.cs` | Class-specific stat growth |
| `ClassService` | `Application/Services/ClassService.cs` | Get player's class for growth rates |

### Provides Foundation For

This phase completes the v0.0.8 Experience & Leveling feature. Future systems may build upon:

| Type | Potential Future Usage |
|------|------------------------|
| `ProgressionDefinition` | Extended for skill trees, prestige systems |
| `LevelDefinition` | Extended for skill points, attribute points |
| `GetCustomRewardsForLevel()` | Hook for automatic reward granting |
| Custom terminology | Extended to other game terms |

---

## Files Summary

### Files to Create (New)

| File | Purpose |
|------|---------|
| `src/Core/RuneAndRust.Domain/Definitions/ProgressionDefinition.cs` | Progression configuration entity |
| `src/Core/RuneAndRust.Domain/Definitions/LevelDefinition.cs` | Per-level configuration entity |
| `src/Core/RuneAndRust.Domain/Definitions/StatBonusConfig.cs` | Stat bonus configuration class |
| `src/Core/RuneAndRust.Domain/Enums/ProgressionCurve.cs` | Progression curve type enum |
| `config/progression.json` | Default progression configuration |
| `tests/RuneAndRust.Domain.UnitTests/Definitions/ProgressionDefinitionTests.cs` | Definition tests |
| `tests/RuneAndRust.Domain.UnitTests/Services/ProgressionServiceConfigTests.cs` | Service config tests |
| `tests/RuneAndRust.Infrastructure.UnitTests/Configuration/JsonConfigurationProviderProgressionTests.cs` | Config loading tests |

### Files to Modify

| File | Changes |
|------|---------|
| `src/Core/RuneAndRust.Domain/Services/ProgressionService.cs` | Add `ProgressionDefinition` support, custom rewards, titles |
| `src/Core/RuneAndRust.Domain/Entities/Player.cs` | Update `GetExperienceForLevel()` to accept config |
| `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs` | Add `GetProgressionConfiguration()` |
| `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs` | Add progression loading |
| `src/Core/RuneAndRust.Application/DTOs/ExperienceGainDto.cs` | Add terminology properties |
| `src/Core/RuneAndRust.Application/DTOs/LevelUpDto.cs` | Add terminology, rewards, title properties |
| `src/Core/RuneAndRust.Application/Services/GameSessionService.cs` | Use class growth rates, pass config to services |
| `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs` | Use terminology in all displays |
| DI Container | Register ProgressionDefinition loading |

### Test Files Summary

| File | Test Count |
|------|------------|
| `ProgressionDefinitionTests.cs` | ~6 |
| `ProgressionServiceConfigTests.cs` | ~4 |
| `JsonConfigurationProviderProgressionTests.cs` | ~4 |
| **Total** | **~14** |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking changes to existing progression | Medium | High | Default config maintains v0.0.8b behavior |
| Invalid JSON config crashes game | Low | High | Graceful fallback to defaults |
| Exponential curve overflow at high levels | Low | Low | Cap calculation at max level |
| Terminology change breaks save files | Low | Low | Terminology is display-only |
| Class growth rates missing | Low | Medium | Fall back to default stat bonuses |
| Custom curve levels not defined | Medium | Medium | Fall back to linear for missing levels |
| Performance impact from config loading | Low | Low | Config is cached after first load |

---

## Integration with Class System

The existing `ClassDefinition.GrowthRates` property integrates naturally with this phase:

```csharp
// In GameSessionService, when checking for level-up:
var playerClass = _classService.GetClassById(player.ClassId);
var classGrowthRates = playerClass?.GrowthRates;

var levelUpResult = _progressionService.CheckAndApplyLevelUp(
    player,
    classGrowthRates,  // Pass class-specific growth rates
    level => _abilityService.GetUnlockedAbilitiesAtLevel(player.ClassId, level)
);
```

This allows different classes to have distinctly different growth patterns:

| Class | HP/Level | ATK/Level | DEF/Level | Style |
|-------|----------|-----------|-----------|-------|
| Shieldmaiden | +12 | +2 | +3 | Tank - high HP/DEF |
| Shadow-Walker | +6 | +4 | +1 | DPS - high ATK |
| Galdr-Caster | +5 | +5 | +1 | Glass cannon |
| Blood-Priest | +8 | +2 | +2 | Balanced healer |

---

*This design specification provides the detailed blueprint for implementing v0.0.8c Progression Configuration. This phase transforms the hardcoded progression values from v0.0.8a/b into a fully configurable system, completing the v0.0.8 Experience & Leveling feature.*
