# v0.1.3c Design Specification: Landmark Rooms

**Version:** 0.1.3c
**Phase Name:** Landmark Rooms
**Parent Version:** v0.1.3 (Advanced Procedural Architecture)
**Prerequisites:** v0.1.3b Complete (Room Shapes & Features)
**Estimated Tests:** ~25 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [LandmarkRoom Entity](#4-landmarkroom-entity)
5. [LandmarkLayout Value Object](#5-landmarklayout-value-object)
6. [Supporting Value Objects](#6-supporting-value-objects)
7. [RoomSizeCategory Enum](#7-roomsizecategory-enum)
8. [LandmarkRoomService](#8-landmarkroomservice)
9. [Room Entity Integration](#9-room-entity-integration)
10. [DescriptorService Integration](#10-descriptorservice-integration)
11. [Data Model Changes](#11-data-model-changes)
12. [Configuration File Schemas](#12-configuration-file-schemas)
13. [Logging Specifications](#13-logging-specifications)
14. [Unit Testing Requirements](#14-unit-testing-requirements)
15. [Use Cases](#15-use-cases)
16. [Deliverable Checklist](#16-deliverable-checklist)
17. [Acceptance Criteria](#17-acceptance-criteria)
18. [Dependencies](#18-dependencies)
19. [Future Considerations](#19-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Create hand-crafted landmark rooms for special encounters. These curated designs serve as centerpieces for boss fights, puzzle chambers, and safe havens. Landmark rooms have fixed layouts with specific features, monster spawns, and loot placements, ensuring memorable and balanced encounters at key dungeon locations.

### 1.2 Current State

| Area | Current State (v0.1.3b) | Target State (v0.1.3c) |
|------|------------------------|------------------------|
| Special rooms | Procedurally generated | Curated landmark designs available |
| Boss arenas | Generic rooms with boss spawn | Purpose-built combat environments |
| Safe havens | Standard safe rooms | Themed sanctuaries with restoration |
| Puzzle chambers | No puzzle support | Dedicated puzzle room layouts |
| Feature placement | Style-based random | Fixed landmark specifications |
| Room uniqueness | All rooms procedural | Unique landmarks tracked per dungeon |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `LandmarkRoom` |
| **Value Objects** | `LandmarkLayout`, `LandmarkFeature`, `LandmarkSpawn`, `LandmarkLoot`, `TerrainZone` |
| **Enums** | `RoomSizeCategory` |
| **Services** | `LandmarkRoomService` (with `ILandmarkRoomService` interface) |
| **Configuration** | `landmark-rooms.json`, `landmark-rooms-schema.json` |
| **Entity Updates** | `Room.LandmarkId` property (optional reference) |
| **Service Updates** | `IConfigurationProvider.GetLandmarkRooms()` |
| **Tests** | ~25 new unit tests |

### 1.4 Architectural Significance

This version establishes the **curated content pattern** for the procedural generation system:
- Hand-crafted room designs loaded from JSON configuration
- Fixed feature, spawn, and loot placements for balanced encounters
- Unique landmark tracking preventing repetition within a dungeon
- Integration with architectural styles and room shapes from prior phases
- Foundation for future quest-specific rooms and narrative locations

---

## 2. Feature Overview

```
v0.1.3c Landmark Rooms
├── LandmarkRoom Entity
│   ├── Unique identification (Id)
│   ├── Display name and description
│   ├── Room type reference (Boss, Safe, Trap, Treasure)
│   ├── Required room shape
│   ├── Layout specification
│   ├── Compatible biomes list
│   ├── Compatible architectural styles
│   ├── Depth constraints (MinDepth, MaxDepth)
│   ├── Unique flag (one per dungeon)
│   ├── Selection weight
│   ├── Minimum difficulty requirement
│   ├── Fixed features array
│   ├── Fixed spawns array
│   ├── Fixed loot array
│   └── Tags for filtering
├── LandmarkLayout Value Object
│   ├── Size category (Small, Medium, Large, Grand, Massive)
│   ├── Fixed exit directions
│   ├── Allow additional exits flag
│   ├── Terrain zones array
│   ├── Central feature reference
│   ├── Special lighting description
│   └── Ambient effects array
├── LandmarkFeature Value Object
│   ├── Feature ID reference
│   ├── Position within room
│   └── Quantity placed
├── LandmarkSpawn Value Object
│   ├── Monster ID reference (or null for tier-based)
│   ├── Monster tier
│   ├── Spawn count
│   └── Is boss flag
├── LandmarkLoot Value Object
│   ├── Item ID reference (or null for tier-based)
│   ├── Quantity
│   ├── Container type
│   └── Guaranteed flag
├── TerrainZone Value Object
│   ├── Zone type (lava, water, pit, raised, pressure-plates)
│   ├── Position (center, perimeter, corners, floor-grid)
│   └── Coverage percentage
├── RoomSizeCategory Enum
│   ├── Small (3-5 tiles)
│   ├── Medium (6-9 tiles)
│   ├── Large (10-15 tiles)
│   ├── Grand (16-25 tiles)
│   └── Massive (26+ tiles)
├── LandmarkRoomService
│   ├── GetLandmark(landmarkId)
│   ├── GetAllLandmarks()
│   ├── GetLandmarksForType(roomType)
│   ├── GetValidLandmarks(type, biome, style, depth, difficulty)
│   ├── SelectLandmark(type, position, biome, style, difficulty)
│   ├── GenerateFromLandmark(landmark, position, biomeId)
│   ├── ResetUniqueLandmarks()
│   └── IsLandmarkUsed(landmarkId)
├── Room Entity Updates
│   ├── LandmarkId property (optional)
│   ├── SetLandmark(landmarkId) method
│   └── IsLandmark property (computed)
└── Configuration
    ├── landmark-rooms.json (5+ landmark definitions)
    └── landmark-rooms-schema.json (validation)
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Landmark rooms display unique descriptions and themed content               │
│  ├── GameView displays landmark-specific environment text                    │
│  ├── Map rendering shows landmark markers                                    │
│  └── Combat system uses landmark-defined spawn configurations               │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  LandmarkRoomService                                                         │
│  ├── GetLandmark(landmarkId)           ├── GenerateFromLandmark()           │
│  ├── GetAllLandmarks()                 ├── ResetUniqueLandmarks()           │
│  ├── GetLandmarksForType(roomType)     └── IsLandmarkUsed(landmarkId)       │
│  ├── GetValidLandmarks(...)                                                  │
│  └── SelectLandmark(...)               RoomGeneratorService (Updated)        │
│                                        └── Uses landmarks for special rooms  │
│  Interfaces:                                                                 │
│  └── ILandmarkRoomService              DescriptorService (Updated)           │
│                                        └── Landmark-aware descriptions       │
│  Configuration:                                                              │
│  └── LandmarkRoomConfigurationDto                                            │
│                                                                              │
│  State:                                                                      │
│  └── _usedUniqueLandmarks: HashSet<string> (tracks per-dungeon uniqueness)  │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Definitions:                   Value Objects:                               │
│  ┌─────────────────────────┐   ┌─────────────────────────┐                  │
│  │ LandmarkRoom            │   │ LandmarkLayout          │                  │
│  │ ├── Id: string          │   │ ├── Size: RoomSizeCategory                 │
│  │ ├── Name: string        │   │ ├── FixedExits: Direction[]               │
│  │ ├── Description: string │   │ ├── AllowAdditionalExits: bool            │
│  │ ├── RoomType: RoomType  │   │ ├── TerrainZones: TerrainZone[]           │
│  │ ├── Shape: RoomShape    │   │ ├── CentralFeature: string?               │
│  │ ├── Layout: LandmarkLayout  │ ├── SpecialLighting: string?              │
│  │ ├── CompatibleBiomes    │   │ └── AmbientEffects: string[]              │
│  │ ├── CompatibleStyles    │   └─────────────────────────┘                  │
│  │ ├── MinDepth: int       │                                                │
│  │ ├── MaxDepth: int?      │   ┌─────────────────────────┐                  │
│  │ ├── Unique: bool        │   │ LandmarkFeature         │                  │
│  │ ├── Weight: int         │   │ ├── FeatureId: string   │                  │
│  │ ├── MinDifficulty: int? │   │ ├── Position: string    │                  │
│  │ ├── Features: LandmarkFeature[] │ └── Quantity: int   │                  │
│  │ ├── Spawns: LandmarkSpawn[]     └─────────────────────┘                  │
│  │ ├── Loot: LandmarkLoot[]    ┌─────────────────────────┐                  │
│  │ └── Tags: string[]      │   │ LandmarkSpawn           │                  │
│  └─────────────────────────┘   │ ├── MonsterId: string?  │                  │
│                                │ ├── Tier: string        │                  │
│  Enums:                        │ ├── Count: int          │                  │
│  ┌─────────────────────────┐   │ └── IsBoss: bool        │                  │
│  │ RoomSizeCategory        │   └─────────────────────────┘                  │
│  │ ├── Small               │   ┌─────────────────────────┐                  │
│  │ ├── Medium              │   │ LandmarkLoot            │                  │
│  │ ├── Large               │   │ ├── ItemId: string?     │                  │
│  │ ├── Grand               │   │ ├── Quantity: int       │                  │
│  │ └── Massive             │   │ ├── ContainerType: string?                 │
│  └─────────────────────────┘   │ └── Guaranteed: bool    │                  │
│                                └─────────────────────────┘                  │
│  Entities (Updated):           ┌─────────────────────────┐                  │
│  ┌─────────────────────────┐   │ TerrainZone             │                  │
│  │ Room                    │   │ ├── ZoneType: string    │                  │
│  │ ├── LandmarkId: string? │   │ ├── Position: string    │                  │
│  │ ├── SetLandmark(id)     │   │ └── Coverage: float     │                  │
│  │ └── IsLandmark: bool    │   └─────────────────────────┘                  │
│  └─────────────────────────┘                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetLandmarkRooms(): IReadOnlyList<LandmarkRoom>                        │
│  └── Loads and deserializes config/landmark-rooms.json                      │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/landmark-rooms.json (5+ landmark definitions)                   │
│  └── config/schemas/landmark-rooms-schema.json (validation schema)          │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Landmark Selection Flow

```
┌───────────────────────────────────────────────────────────────┐
│ RoomGeneratorService needs to generate a Boss room            │
│ at Position (5, 3, 4) in biome "ancient-ruins"               │
│ with style "ancient-temples"                                  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ LandmarkRoomService.SelectLandmark(                           │
│   roomType: RoomType.Boss,                                    │
│   position: (5, 3, 4),                                        │
│   biomeId: "ancient-ruins",                                   │
│   styleId: "ancient-temples",                                 │
│   difficulty: 35)                                             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Get Valid Landmarks                                   │
├───────────────────────────────────────────────────────────────┤
│ GetValidLandmarks filters by:                                 │
│ ├── RoomType == Boss                                          │
│ │   ├── boss-arena-standard ✓                                 │
│ │   ├── boss-arena-volcanic ✓                                 │
│ │   └── (others filtered out)                                 │
│ ├── MinDepth <= 4                                             │
│ │   ├── boss-arena-standard (minDepth: 3) ✓                   │
│ │   └── boss-arena-volcanic (minDepth: 6) ✗                   │
│ ├── CompatibleBiomes includes "ancient-ruins"                 │
│ │   └── boss-arena-standard (empty = all) ✓                   │
│ ├── CompatibleStyles includes "ancient-temples"               │
│ │   └── boss-arena-standard ["carved-halls", "ancient-temples"] ✓
│ ├── Difficulty >= MinDifficulty                               │
│ │   └── boss-arena-standard (no min) ✓                        │
│ └── Not already used (if Unique)                              │
│     └── boss-arena-standard (unique: false) ✓                 │
│                                                               │
│ Valid landmarks: [boss-arena-standard]                        │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Weighted Random Selection                             │
├───────────────────────────────────────────────────────────────┤
│ SeededRandomService.SelectWeighted(position, landmarks)       │
│                                                               │
│ Landmark weights:                                             │
│ └── boss-arena-standard: 100                                  │
│                                                               │
│ Selected: boss-arena-standard                                 │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Track Unique Landmarks                                │
├───────────────────────────────────────────────────────────────┤
│ if (selected.Unique)                                          │
│     _usedUniqueLandmarks.Add(selected.Id)                     │
│                                                               │
│ boss-arena-standard is not unique, so not tracked             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Return: LandmarkRoom "boss-arena-standard"                    │
│ ├── Name: "Grand Arena"                                       │
│ ├── Shape: Circular                                           │
│ ├── Layout: Grand size, South exit, raised-platform center    │
│ ├── Features: 8 pillars (perimeter), 1 raised-platform        │
│ └── Spawns: 1 boss-tier monster                               │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Landmark Room Generation Flow

```
┌───────────────────────────────────────────────────────────────┐
│ LandmarkRoomService.GenerateFromLandmark(                     │
│   landmark: boss-arena-standard,                              │
│   position: (5, 3, 4),                                        │
│   biomeId: "ancient-ruins")                                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Create Base Room                                      │
├───────────────────────────────────────────────────────────────┤
│ Room.Create(                                                  │
│   name: "Grand Arena",                                        │
│   description: "A vast circular chamber designed for...",     │
│   position: (5, 3, 4))                                        │
│                                                               │
│ Room properties set:                                          │
│ ├── Id: [new GUID]                                            │
│ ├── Name: "Grand Arena"                                       │
│ ├── Description: [landmark description]                       │
│ └── Position: (5, 3, 4)                                       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Apply Landmark Properties                             │
├───────────────────────────────────────────────────────────────┤
│ room.SetRoomType(RoomType.Boss)                               │
│ room.SetShape(RoomShape.Circular)                             │
│ room.SetBiome("ancient-ruins")                                │
│ room.SetLandmark("boss-arena-standard")                       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Add Fixed Features                                    │
├───────────────────────────────────────────────────────────────┤
│ foreach (var feature in landmark.Features)                    │
│ {                                                             │
│     room.AddFeature(new RoomFeature                           │
│     {                                                         │
│         FeatureId = feature.FeatureId,                        │
│         Position = feature.Position,                          │
│         Quantity = feature.Quantity                           │
│     });                                                       │
│ }                                                             │
│                                                               │
│ Added features:                                               │
│ ├── RoomFeature { "pillar", "perimeter", 8 }                  │
│ └── RoomFeature { "raised-platform", "center", 1 }            │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: Add Fixed Exits                                       │
├───────────────────────────────────────────────────────────────┤
│ foreach (var direction in landmark.Layout.FixedExits)         │
│ {                                                             │
│     room.AddExit(direction, isHidden: false);                 │
│ }                                                             │
│                                                               │
│ Added exits:                                                  │
│ └── Exit { Direction.South, Hidden: false }                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Return: Fully configured Room                                 │
├───────────────────────────────────────────────────────────────┤
│ Room:                                                         │
│ ├── Name: "Grand Arena"                                       │
│ ├── Description: [landmark description]                       │
│ ├── Position: (5, 3, 4)                                       │
│ ├── RoomType: Boss                                            │
│ ├── Shape: Circular                                           │
│ ├── BiomeId: "ancient-ruins"                                  │
│ ├── LandmarkId: "boss-arena-standard"                         │
│ ├── StructuralFeatures:                                       │
│ │   ├── { "pillar", "perimeter", 8 }                          │
│ │   └── { "raised-platform", "center", 1 }                    │
│ └── Exits: [South]                                            │
│                                                               │
│ Note: Spawns and Loot are stored separately in landmark       │
│ definition and used by SpawnService and LootService           │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 Landmark Type Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         LANDMARK ROOM TYPES                                  │
├─────────────────┬───────────────────────────────────────────────────────────┤
│ Type            │ Purpose & Characteristics                                  │
├─────────────────┼───────────────────────────────────────────────────────────┤
│ Boss Arena      │ Purpose-built combat environments for major encounters    │
│                 │ ├── Grand or Massive size                                 │
│                 │ ├── Cover features (pillars, rocks)                       │
│                 │ ├── Tactical terrain (raised platforms, hazard zones)     │
│                 │ ├── Single entrance (prevents easy escape)                │
│                 │ └── Guaranteed boss-tier loot                             │
├─────────────────┼───────────────────────────────────────────────────────────┤
│ Safe Haven      │ Protected rest areas with restoration features            │
│                 │ ├── Medium size                                           │
│                 │ ├── Healing features (springs, shrines)                   │
│                 │ ├── No monster spawns                                     │
│                 │ ├── Peaceful ambient effects                              │
│                 │ └── May allow additional exits                            │
├─────────────────┼───────────────────────────────────────────────────────────┤
│ Puzzle Chamber  │ Interactive challenge rooms with environmental puzzles    │
│                 │ ├── Large size                                            │
│                 │ ├── Interactive features (pressure plates, levers)        │
│                 │ ├── Terrain zones defining puzzle mechanics               │
│                 │ ├── Locked exits until puzzle solved                      │
│                 │ └── Puzzle-completion reward loot                         │
├─────────────────┼───────────────────────────────────────────────────────────┤
│ Treasure Vault  │ High-reward rooms with guardian protection                │
│                 │ ├── Large size                                            │
│                 │ ├── Central treasure feature                              │
│                 │ ├── Elite monster guardians                               │
│                 │ ├── Single entrance                                       │
│                 │ └── Multiple guaranteed loot items                        │
└─────────────────┴───────────────────────────────────────────────────────────┘
```

---

## 4. LandmarkRoom Entity

### 4.1 Purpose

The `LandmarkRoom` entity represents a hand-crafted room design for special encounters. Each landmark defines a complete room specification including shape, features, spawns, and loot, ensuring consistent and balanced experiences at key dungeon locations.

### 4.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Definitions/LandmarkRoom.cs`

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a hand-crafted room design for special encounters.
/// </summary>
/// <remarks>
/// Landmark rooms serve as centerpieces for boss fights, puzzle chambers,
/// safe havens, and treasure vaults. They have fixed layouts with specific
/// features, spawns, and loot placements to ensure memorable encounters.
/// </remarks>
public class LandmarkRoom
{
    /// <summary>
    /// Gets the unique identifier (e.g., "boss-arena-dragon").
    /// </summary>
    /// <remarks>
    /// Uses kebab-case naming convention. Must be unique across all landmarks.
    /// </remarks>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name shown to players.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the full description shown when entering the room.
    /// </summary>
    /// <remarks>
    /// Should be evocative and thematic, describing the landmark's
    /// atmosphere and notable features.
    /// </remarks>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the room type this landmark creates.
    /// </summary>
    /// <remarks>
    /// Determines base room behavior: Boss, Safe, Trap, Treasure, Standard.
    /// </remarks>
    public RoomType RoomType { get; init; }

    /// <summary>
    /// Gets the required room shape for this landmark.
    /// </summary>
    /// <remarks>
    /// Landmarks require specific shapes to ensure proper feature placement
    /// and combat dynamics.
    /// </remarks>
    public RoomShape Shape { get; init; }

    /// <summary>
    /// Gets the layout specification for this landmark.
    /// </summary>
    /// <remarks>
    /// Defines size, exits, terrain zones, and ambient effects.
    /// </remarks>
    public LandmarkLayout Layout { get; init; } = default;

    /// <summary>
    /// Gets compatible biome IDs for this landmark.
    /// </summary>
    /// <remarks>
    /// Empty list means compatible with all biomes. Used to ensure
    /// thematic consistency (e.g., volcanic arenas only in volcanic biomes).
    /// </remarks>
    public IReadOnlyList<string> CompatibleBiomes { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets compatible architectural style IDs.
    /// </summary>
    /// <remarks>
    /// Empty list means compatible with all styles. Ensures landmarks
    /// fit the surrounding architecture.
    /// </remarks>
    public IReadOnlyList<string> CompatibleStyles { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the minimum depth where this landmark can appear.
    /// </summary>
    /// <remarks>
    /// Depth 0 is the dungeon entrance. Higher values are deeper.
    /// Boss arenas typically require deeper levels.
    /// </remarks>
    public int MinDepth { get; init; }

    /// <summary>
    /// Gets the maximum depth where this landmark can appear.
    /// </summary>
    /// <remarks>
    /// Null indicates no maximum depth limit.
    /// </remarks>
    public int? MaxDepth { get; init; }

    /// <summary>
    /// Gets whether this landmark can only appear once per dungeon.
    /// </summary>
    /// <remarks>
    /// Unique landmarks are tracked per dungeon generation to prevent
    /// repetition. Used for special encounters like named boss lairs.
    /// </remarks>
    public bool Unique { get; init; }

    /// <summary>
    /// Gets the selection weight for random landmark selection.
    /// </summary>
    /// <remarks>
    /// Higher weights increase selection probability. Default is 100.
    /// Rare landmarks can have lower weights.
    /// </remarks>
    public int Weight { get; init; } = 100;

    /// <summary>
    /// Gets the minimum difficulty rating required for this landmark.
    /// </summary>
    /// <remarks>
    /// Null means no minimum difficulty. Used to gate challenging
    /// content behind progression (e.g., difficulty 20+ for puzzle rooms).
    /// </remarks>
    public int? MinDifficulty { get; init; }

    /// <summary>
    /// Gets fixed structural features in this landmark.
    /// </summary>
    /// <remarks>
    /// Features are placed at specified positions with fixed quantities.
    /// Overrides procedural feature generation.
    /// </remarks>
    public IReadOnlyList<LandmarkFeature> Features { get; init; } = Array.Empty<LandmarkFeature>();

    /// <summary>
    /// Gets fixed monster spawns for this landmark.
    /// </summary>
    /// <remarks>
    /// Spawns define exact or tier-based monster placement.
    /// Boss flag indicates the primary encounter monster.
    /// </remarks>
    public IReadOnlyList<LandmarkSpawn> Spawns { get; init; } = Array.Empty<LandmarkSpawn>();

    /// <summary>
    /// Gets fixed loot placements for this landmark.
    /// </summary>
    /// <remarks>
    /// Loot can be specific items or tier-based. Guaranteed flag
    /// ensures the item always spawns.
    /// </remarks>
    public IReadOnlyList<LandmarkLoot> Loot { get; init; } = Array.Empty<LandmarkLoot>();

    /// <summary>
    /// Gets tags for filtering and categorization.
    /// </summary>
    /// <remarks>
    /// Tags enable filtering landmarks by characteristics
    /// (e.g., "boss", "puzzle", "sacred", "volcanic").
    /// </remarks>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Private constructor for EF Core and factory method.
    /// </summary>
    private LandmarkRoom() { }

    /// <summary>
    /// Creates a landmark room from configuration.
    /// </summary>
    /// <param name="id">Unique landmark identifier (kebab-case).</param>
    /// <param name="name">Display name.</param>
    /// <param name="description">Room description.</param>
    /// <param name="roomType">Type of room this creates.</param>
    /// <param name="shape">Required room shape.</param>
    /// <param name="layout">Layout specification.</param>
    /// <param name="compatibleBiomes">Compatible biome IDs (empty = all).</param>
    /// <param name="compatibleStyles">Compatible style IDs (empty = all).</param>
    /// <param name="minDepth">Minimum depth for appearance.</param>
    /// <param name="maxDepth">Maximum depth (null = unlimited).</param>
    /// <param name="unique">Whether landmark is unique per dungeon.</param>
    /// <param name="weight">Selection weight.</param>
    /// <param name="minDifficulty">Minimum difficulty requirement.</param>
    /// <param name="features">Fixed feature placements.</param>
    /// <param name="spawns">Fixed monster spawns.</param>
    /// <param name="loot">Fixed loot placements.</param>
    /// <param name="tags">Categorization tags.</param>
    /// <returns>A new LandmarkRoom instance.</returns>
    /// <exception cref="ArgumentException">Thrown when id or name is null/empty.</exception>
    public static LandmarkRoom Create(
        string id,
        string name,
        string description,
        RoomType roomType,
        RoomShape shape,
        LandmarkLayout layout,
        IEnumerable<string>? compatibleBiomes = null,
        IEnumerable<string>? compatibleStyles = null,
        int minDepth = 0,
        int? maxDepth = null,
        bool unique = false,
        int weight = 100,
        int? minDifficulty = null,
        IEnumerable<LandmarkFeature>? features = null,
        IEnumerable<LandmarkSpawn>? spawns = null,
        IEnumerable<LandmarkLoot>? loot = null,
        IEnumerable<string>? tags = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id, nameof(id));
        ArgumentException.ThrowIfNullOrWhiteSpace(name, nameof(name));

        if (minDepth < 0)
            throw new ArgumentOutOfRangeException(nameof(minDepth), "MinDepth cannot be negative.");

        if (maxDepth.HasValue && maxDepth.Value < minDepth)
            throw new ArgumentException("MaxDepth cannot be less than MinDepth.", nameof(maxDepth));

        if (weight <= 0)
            throw new ArgumentOutOfRangeException(nameof(weight), "Weight must be positive.");

        return new LandmarkRoom
        {
            Id = id,
            Name = name,
            Description = description ?? string.Empty,
            RoomType = roomType,
            Shape = shape,
            Layout = layout,
            CompatibleBiomes = compatibleBiomes?.ToList() ?? new List<string>(),
            CompatibleStyles = compatibleStyles?.ToList() ?? new List<string>(),
            MinDepth = minDepth,
            MaxDepth = maxDepth,
            Unique = unique,
            Weight = weight,
            MinDifficulty = minDifficulty,
            Features = features?.ToList() ?? new List<LandmarkFeature>(),
            Spawns = spawns?.ToList() ?? new List<LandmarkSpawn>(),
            Loot = loot?.ToList() ?? new List<LandmarkLoot>(),
            Tags = tags?.ToList() ?? new List<string>()
        };
    }

    /// <summary>
    /// Checks if this landmark is valid for a given depth.
    /// </summary>
    /// <param name="depth">The Z-level depth to check.</param>
    /// <returns>True if the landmark can appear at this depth.</returns>
    public bool IsValidForDepth(int depth)
    {
        if (depth < MinDepth)
            return false;

        if (MaxDepth.HasValue && depth > MaxDepth.Value)
            return false;

        return true;
    }

    /// <summary>
    /// Checks if this landmark is compatible with a biome.
    /// </summary>
    /// <param name="biomeId">The biome identifier to check.</param>
    /// <returns>True if the landmark is compatible with the biome.</returns>
    public bool IsCompatibleWithBiome(string biomeId)
    {
        if (!CompatibleBiomes.Any())
            return true;

        return CompatibleBiomes.Contains(biomeId, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Checks if this landmark is compatible with an architectural style.
    /// </summary>
    /// <param name="styleId">The style identifier to check.</param>
    /// <returns>True if the landmark is compatible with the style.</returns>
    public bool IsCompatibleWithStyle(string styleId)
    {
        if (!CompatibleStyles.Any())
            return true;

        return CompatibleStyles.Contains(styleId, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Checks if this landmark meets a difficulty requirement.
    /// </summary>
    /// <param name="difficulty">The current difficulty rating.</param>
    /// <returns>True if the difficulty meets or exceeds the minimum.</returns>
    public bool MeetsDifficultyRequirement(int difficulty)
    {
        if (!MinDifficulty.HasValue)
            return true;

        return difficulty >= MinDifficulty.Value;
    }

    /// <summary>
    /// Checks if this landmark has a specific tag.
    /// </summary>
    /// <param name="tag">The tag to check for.</param>
    /// <returns>True if the landmark has the tag.</returns>
    public bool HasTag(string tag)
    {
        return Tags.Contains(tag, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets a string representation of the landmark.
    /// </summary>
    public override string ToString() => $"Landmark[{Id}] {Name} ({RoomType}, {Shape})";
}
```

### 4.4 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `string` | Unique identifier (kebab-case) | Required |
| `Name` | `string` | Display name | Required |
| `Description` | `string` | Room description text | Empty |
| `RoomType` | `RoomType` | Type of room (Boss, Safe, etc.) | Required |
| `Shape` | `RoomShape` | Required geometric shape | Required |
| `Layout` | `LandmarkLayout` | Size, exits, terrain, effects | Required |
| `CompatibleBiomes` | `IReadOnlyList<string>` | Compatible biome IDs | Empty (all) |
| `CompatibleStyles` | `IReadOnlyList<string>` | Compatible style IDs | Empty (all) |
| `MinDepth` | `int` | Minimum Z-level | 0 |
| `MaxDepth` | `int?` | Maximum Z-level | null (unlimited) |
| `Unique` | `bool` | One per dungeon | false |
| `Weight` | `int` | Selection probability | 100 |
| `MinDifficulty` | `int?` | Difficulty requirement | null (none) |
| `Features` | `IReadOnlyList<LandmarkFeature>` | Fixed features | Empty |
| `Spawns` | `IReadOnlyList<LandmarkSpawn>` | Fixed monster spawns | Empty |
| `Loot` | `IReadOnlyList<LandmarkLoot>` | Fixed loot | Empty |
| `Tags` | `IReadOnlyList<string>` | Categorization tags | Empty |

---

## 5. LandmarkLayout Value Object

### 5.1 Purpose

The `LandmarkLayout` value object defines the structural specification for a landmark room, including size category, fixed exits, terrain zones, central features, and ambient effects.

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LandmarkLayout.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the layout specification for a landmark room.
/// </summary>
/// <remarks>
/// LandmarkLayout specifies the physical structure of a landmark including
/// size, exits, terrain zones, and ambient effects. This ensures consistent
/// landmark generation across different positions.
/// </remarks>
public readonly record struct LandmarkLayout
{
    /// <summary>
    /// Gets the size category for this landmark.
    /// </summary>
    /// <remarks>
    /// Determines the room's tile dimensions. Boss arenas are typically
    /// Grand or Massive; safe havens are Medium.
    /// </remarks>
    public RoomSizeCategory Size { get; init; }

    /// <summary>
    /// Gets fixed exit directions for this landmark.
    /// </summary>
    /// <remarks>
    /// These exits are always present. Boss arenas typically have
    /// only one exit to prevent easy escape.
    /// </remarks>
    public IReadOnlyList<Direction> FixedExits { get; init; }

    /// <summary>
    /// Gets whether additional exits beyond fixed exits are allowed.
    /// </summary>
    /// <remarks>
    /// False for boss arenas (single entrance). True for safe havens
    /// that may connect to multiple paths.
    /// </remarks>
    public bool AllowAdditionalExits { get; init; }

    /// <summary>
    /// Gets special terrain zones within the landmark.
    /// </summary>
    /// <remarks>
    /// Terrain zones define areas with special properties like
    /// lava pools, water features, pits, or pressure plates.
    /// </remarks>
    public IReadOnlyList<TerrainZone> TerrainZones { get; init; }

    /// <summary>
    /// Gets the central feature ID if one is required.
    /// </summary>
    /// <remarks>
    /// The central feature is placed at the room's center.
    /// Boss arenas may have a raised platform; temples have altars.
    /// </remarks>
    public string? CentralFeature { get; init; }

    /// <summary>
    /// Gets special lighting description for this landmark.
    /// </summary>
    /// <remarks>
    /// Overrides default lighting descriptors. Examples:
    /// "dramatic spotlight", "molten glow", "divine radiance".
    /// </remarks>
    public string? SpecialLighting { get; init; }

    /// <summary>
    /// Gets ambient effect identifiers active in this landmark.
    /// </summary>
    /// <remarks>
    /// Effects add atmosphere: "echoing", "peaceful", "volcanic-rumble".
    /// Used for description generation and potential gameplay effects.
    /// </remarks>
    public IReadOnlyList<string> AmbientEffects { get; init; }

    /// <summary>
    /// Creates a default layout (Medium, single South exit).
    /// </summary>
    public static LandmarkLayout Default => new()
    {
        Size = RoomSizeCategory.Medium,
        FixedExits = new[] { Direction.South },
        AllowAdditionalExits = true,
        TerrainZones = Array.Empty<TerrainZone>(),
        CentralFeature = null,
        SpecialLighting = null,
        AmbientEffects = Array.Empty<string>()
    };

    /// <summary>
    /// Creates a boss arena layout (Grand, single entrance, platform).
    /// </summary>
    public static LandmarkLayout BossArena => new()
    {
        Size = RoomSizeCategory.Grand,
        FixedExits = new[] { Direction.South },
        AllowAdditionalExits = false,
        TerrainZones = Array.Empty<TerrainZone>(),
        CentralFeature = "raised-platform",
        SpecialLighting = "dramatic spotlight",
        AmbientEffects = new[] { "echoing", "tension" }
    };

    /// <summary>
    /// Creates a safe haven layout (Medium, healing spring).
    /// </summary>
    public static LandmarkLayout SafeHaven => new()
    {
        Size = RoomSizeCategory.Medium,
        FixedExits = new[] { Direction.South },
        AllowAdditionalExits = true,
        TerrainZones = Array.Empty<TerrainZone>(),
        CentralFeature = "healing-spring",
        SpecialLighting = "divine radiance",
        AmbientEffects = new[] { "peaceful", "regenerating" }
    };

    /// <summary>
    /// Creates a puzzle chamber layout (Large, pressure plates).
    /// </summary>
    public static LandmarkLayout PuzzleChamber => new()
    {
        Size = RoomSizeCategory.Large,
        FixedExits = new[] { Direction.South, Direction.North },
        AllowAdditionalExits = false,
        TerrainZones = new[]
        {
            new TerrainZone { ZoneType = "pressure-plates", Position = "floor-grid", Coverage = 0.6f }
        },
        CentralFeature = null,
        SpecialLighting = "dim torch flicker",
        AmbientEffects = new[] { "ominous", "mechanical-tension" }
    };

    /// <summary>
    /// Checks if a direction is a fixed exit.
    /// </summary>
    /// <param name="direction">The direction to check.</param>
    /// <returns>True if the direction is a fixed exit.</returns>
    public bool HasFixedExit(Direction direction)
    {
        return FixedExits?.Contains(direction) ?? false;
    }

    /// <summary>
    /// Checks if the layout has any terrain zones.
    /// </summary>
    public bool HasTerrainZones => TerrainZones?.Any() ?? false;

    /// <summary>
    /// Checks if the layout has a central feature.
    /// </summary>
    public bool HasCentralFeature => !string.IsNullOrEmpty(CentralFeature);

    /// <summary>
    /// Checks if the layout has special lighting.
    /// </summary>
    public bool HasSpecialLighting => !string.IsNullOrEmpty(SpecialLighting);

    /// <summary>
    /// Checks if the layout has ambient effects.
    /// </summary>
    public bool HasAmbientEffects => AmbientEffects?.Any() ?? false;
}
```

---

## 6. Supporting Value Objects

### 6.1 LandmarkFeature

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LandmarkFeature.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// A fixed feature placement in a landmark room.
/// </summary>
/// <remarks>
/// LandmarkFeatures define specific structural features that are always
/// present in a landmark, placed at fixed positions with specified quantities.
/// </remarks>
public readonly record struct LandmarkFeature
{
    /// <summary>
    /// Gets the structural feature ID to place.
    /// </summary>
    /// <remarks>
    /// Must match a feature ID in the structural features configuration.
    /// </remarks>
    public string FeatureId { get; init; }

    /// <summary>
    /// Gets the position within the room.
    /// </summary>
    /// <remarks>
    /// Valid positions: "center", "perimeter", "corners", "north-wall",
    /// "south-wall", "east-wall", "west-wall", "scattered", "inner-ring".
    /// </remarks>
    public string Position { get; init; }

    /// <summary>
    /// Gets the quantity of features to place.
    /// </summary>
    /// <remarks>
    /// For perimeter positions, quantity often represents features at
    /// cardinal points (4) or intermediate points (8).
    /// </remarks>
    public int Quantity { get; init; }

    /// <summary>
    /// Creates a landmark feature specification.
    /// </summary>
    public static LandmarkFeature Create(string featureId, string position, int quantity = 1)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(featureId, nameof(featureId));
        ArgumentException.ThrowIfNullOrWhiteSpace(position, nameof(position));

        if (quantity <= 0)
            throw new ArgumentOutOfRangeException(nameof(quantity), "Quantity must be positive.");

        return new LandmarkFeature
        {
            FeatureId = featureId,
            Position = position,
            Quantity = quantity
        };
    }

    /// <summary>
    /// Gets a string representation of the feature placement.
    /// </summary>
    public override string ToString() => $"{Quantity}x {FeatureId} @ {Position}";
}
```

### 6.2 LandmarkSpawn

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LandmarkSpawn.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// A fixed monster spawn in a landmark room.
/// </summary>
/// <remarks>
/// LandmarkSpawns define monsters that appear in a landmark. Spawns can
/// specify exact monster IDs or use tier-based selection for variety.
/// </remarks>
public readonly record struct LandmarkSpawn
{
    /// <summary>
    /// Gets the specific monster ID to spawn.
    /// </summary>
    /// <remarks>
    /// Null indicates tier-based selection. Specific IDs ensure
    /// consistent named bosses or thematic encounters.
    /// </remarks>
    public string? MonsterId { get; init; }

    /// <summary>
    /// Gets the monster tier for selection.
    /// </summary>
    /// <remarks>
    /// Tier names: "minion", "standard", "elite", "boss".
    /// Used when MonsterId is null to select from tier pool.
    /// </remarks>
    public string Tier { get; init; }

    /// <summary>
    /// Gets the number of monsters to spawn.
    /// </summary>
    /// <remarks>
    /// Boss encounters typically have Count = 1.
    /// Elite guardians may have Count = 2-3.
    /// </remarks>
    public int Count { get; init; }

    /// <summary>
    /// Gets whether this spawn is the primary boss of the landmark.
    /// </summary>
    /// <remarks>
    /// Boss spawns are marked for special handling: guaranteed drops,
    /// combat music, achievement tracking.
    /// </remarks>
    public bool IsBoss { get; init; }

    /// <summary>
    /// Creates a landmark spawn specification.
    /// </summary>
    public static LandmarkSpawn Create(
        string tier,
        int count = 1,
        string? monsterId = null,
        bool isBoss = false)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(tier, nameof(tier));

        if (count <= 0)
            throw new ArgumentOutOfRangeException(nameof(count), "Count must be positive.");

        return new LandmarkSpawn
        {
            MonsterId = monsterId,
            Tier = tier,
            Count = count,
            IsBoss = isBoss
        };
    }

    /// <summary>
    /// Creates a boss spawn specification.
    /// </summary>
    public static LandmarkSpawn Boss(string? monsterId = null) => new()
    {
        MonsterId = monsterId,
        Tier = "boss",
        Count = 1,
        IsBoss = true
    };

    /// <summary>
    /// Creates an elite guard spawn specification.
    /// </summary>
    public static LandmarkSpawn EliteGuards(int count, string? monsterId = null) => new()
    {
        MonsterId = monsterId,
        Tier = "elite",
        Count = count,
        IsBoss = false
    };

    /// <summary>
    /// Gets a string representation of the spawn.
    /// </summary>
    public override string ToString() =>
        MonsterId != null
            ? $"{Count}x {MonsterId} ({Tier}){(IsBoss ? " [BOSS]" : "")}"
            : $"{Count}x {Tier}{(IsBoss ? " [BOSS]" : "")}";
}
```

### 6.3 LandmarkLoot

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LandmarkLoot.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Fixed loot in a landmark room.
/// </summary>
/// <remarks>
/// LandmarkLoot defines items that can be found in a landmark. Loot can
/// be specific items or tier-based, placed in containers or loose.
/// </remarks>
public readonly record struct LandmarkLoot
{
    /// <summary>
    /// Gets the specific item ID to place.
    /// </summary>
    /// <remarks>
    /// Null indicates tier-based selection from loot tables.
    /// Specific IDs ensure unique rewards for special landmarks.
    /// </remarks>
    public string? ItemId { get; init; }

    /// <summary>
    /// Gets the quantity of items.
    /// </summary>
    /// <remarks>
    /// For stackable items like gold, this is the stack size.
    /// For non-stackable items, this creates multiple instances.
    /// </remarks>
    public int Quantity { get; init; }

    /// <summary>
    /// Gets the container type for the loot.
    /// </summary>
    /// <remarks>
    /// Container types: "chest", "boss-chest", "puzzle-reward-chest",
    /// "treasure-chest", null (loose/dropped).
    /// </remarks>
    public string? ContainerType { get; init; }

    /// <summary>
    /// Gets whether this loot is guaranteed to appear.
    /// </summary>
    /// <remarks>
    /// Guaranteed loot always spawns. Non-guaranteed loot has a
    /// probability based on difficulty and RNG.
    /// </remarks>
    public bool Guaranteed { get; init; }

    /// <summary>
    /// Creates a landmark loot specification.
    /// </summary>
    public static LandmarkLoot Create(
        int quantity = 1,
        string? itemId = null,
        string? containerType = null,
        bool guaranteed = true)
    {
        if (quantity <= 0)
            throw new ArgumentOutOfRangeException(nameof(quantity), "Quantity must be positive.");

        return new LandmarkLoot
        {
            ItemId = itemId,
            Quantity = quantity,
            ContainerType = containerType,
            Guaranteed = guaranteed
        };
    }

    /// <summary>
    /// Creates guaranteed chest loot.
    /// </summary>
    public static LandmarkLoot Chest(string? itemId = null, int quantity = 1) => new()
    {
        ItemId = itemId,
        Quantity = quantity,
        ContainerType = "chest",
        Guaranteed = true
    };

    /// <summary>
    /// Creates a boss reward chest.
    /// </summary>
    public static LandmarkLoot BossChest(string? itemId = null) => new()
    {
        ItemId = itemId,
        Quantity = 1,
        ContainerType = "boss-chest",
        Guaranteed = true
    };

    /// <summary>
    /// Creates loose gold.
    /// </summary>
    public static LandmarkLoot Gold(int amount) => new()
    {
        ItemId = "gold",
        Quantity = amount,
        ContainerType = null,
        Guaranteed = true
    };

    /// <summary>
    /// Gets a string representation of the loot.
    /// </summary>
    public override string ToString() =>
        $"{Quantity}x {ItemId ?? "[tier-based]"}" +
        (ContainerType != null ? $" in {ContainerType}" : "") +
        (Guaranteed ? " [GUARANTEED]" : "");
}
```

### 6.4 TerrainZone

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TerrainZone.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// A special terrain zone within a landmark room.
/// </summary>
/// <remarks>
/// TerrainZones define areas with special properties like hazardous
/// terrain (lava, pits), interactive surfaces (pressure plates), or
/// tactical features (raised areas, water).
/// </remarks>
public readonly record struct TerrainZone
{
    /// <summary>
    /// Gets the terrain zone type.
    /// </summary>
    /// <remarks>
    /// Types: "lava", "water", "pit", "raised", "pressure-plates",
    /// "ice", "mud", "acid".
    /// </remarks>
    public string ZoneType { get; init; }

    /// <summary>
    /// Gets the position descriptor for zone placement.
    /// </summary>
    /// <remarks>
    /// Positions: "center", "perimeter", "corners", "floor-grid",
    /// "north-half", "south-half", "ring".
    /// </remarks>
    public string Position { get; init; }

    /// <summary>
    /// Gets the coverage percentage of the room (0.0-1.0).
    /// </summary>
    /// <remarks>
    /// 0.3 = 30% of room area. Used with position to calculate
    /// actual zone dimensions.
    /// </remarks>
    public float Coverage { get; init; }

    /// <summary>
    /// Creates a terrain zone specification.
    /// </summary>
    public static TerrainZone Create(string zoneType, string position, float coverage)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(zoneType, nameof(zoneType));
        ArgumentException.ThrowIfNullOrWhiteSpace(position, nameof(position));

        if (coverage < 0f || coverage > 1f)
            throw new ArgumentOutOfRangeException(nameof(coverage), "Coverage must be between 0.0 and 1.0.");

        return new TerrainZone
        {
            ZoneType = zoneType,
            Position = position,
            Coverage = coverage
        };
    }

    /// <summary>
    /// Creates a lava perimeter zone.
    /// </summary>
    public static TerrainZone LavaPerimeter(float coverage = 0.3f) => new()
    {
        ZoneType = "lava",
        Position = "perimeter",
        Coverage = coverage
    };

    /// <summary>
    /// Creates a pressure plate floor grid.
    /// </summary>
    public static TerrainZone PressurePlates(float coverage = 0.6f) => new()
    {
        ZoneType = "pressure-plates",
        Position = "floor-grid",
        Coverage = coverage
    };

    /// <summary>
    /// Creates a central water feature.
    /// </summary>
    public static TerrainZone CentralWater(float coverage = 0.15f) => new()
    {
        ZoneType = "water",
        Position = "center",
        Coverage = coverage
    };

    /// <summary>
    /// Gets a string representation of the terrain zone.
    /// </summary>
    public override string ToString() => $"{ZoneType} @ {Position} ({Coverage:P0})";
}
```

---

## 7. RoomSizeCategory Enum

### 7.1 Purpose

The `RoomSizeCategory` enum defines size categories for landmark rooms, providing a standardized way to specify room dimensions.

### 7.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Enums/RoomSizeCategory.cs`

### 7.3 Implementation

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Room size categories for landmark specification.
/// </summary>
/// <remarks>
/// Size categories provide a standardized way to define landmark
/// room dimensions without specifying exact tile counts. The actual
/// dimensions are determined during generation based on style rules.
/// </remarks>
public enum RoomSizeCategory
{
    /// <summary>
    /// Small room (3-5 tiles per side).
    /// </summary>
    /// <remarks>
    /// Suitable for small shrines, closets, or tight encounters.
    /// Limited space for features and combat maneuvering.
    /// </remarks>
    Small = 0,

    /// <summary>
    /// Medium room (6-9 tiles per side).
    /// </summary>
    /// <remarks>
    /// Standard room size. Suitable for safe havens, small
    /// treasure rooms, and minor encounters.
    /// </remarks>
    Medium = 1,

    /// <summary>
    /// Large room (10-15 tiles per side).
    /// </summary>
    /// <remarks>
    /// Spacious rooms for puzzle chambers, treasure vaults,
    /// and moderate combat encounters with room to maneuver.
    /// </remarks>
    Large = 2,

    /// <summary>
    /// Grand room (16-25 tiles per side).
    /// </summary>
    /// <remarks>
    /// Impressive chambers for boss arenas, grand halls,
    /// and major set-piece encounters.
    /// </remarks>
    Grand = 3,

    /// <summary>
    /// Massive room (26+ tiles per side).
    /// </summary>
    /// <remarks>
    /// Epic scale rooms for final bosses, throne rooms,
    /// and climactic encounters. Requires significant features
    /// to avoid feeling empty.
    /// </remarks>
    Massive = 4
}
```

### 7.4 Size Dimensions Table

| Category | Min Tiles | Max Tiles | Typical Use |
|----------|-----------|-----------|-------------|
| Small | 3 | 5 | Shrines, closets |
| Medium | 6 | 9 | Safe havens, small treasures |
| Large | 10 | 15 | Puzzle chambers, vaults |
| Grand | 16 | 25 | Boss arenas, grand halls |
| Massive | 26 | 40+ | Final bosses, throne rooms |

---

## 8. LandmarkRoomService

### 8.1 Purpose

The `LandmarkRoomService` provides landmark lookup, selection, and room generation. It tracks unique landmarks per dungeon and integrates with the seeded random service for reproducible selection.

### 8.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/ILandmarkRoomService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/LandmarkRoomService.cs`

### 8.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for landmark room lookup, selection, and generation.
/// </summary>
public interface ILandmarkRoomService
{
    /// <summary>
    /// Gets a landmark room definition by ID.
    /// </summary>
    /// <param name="landmarkId">The unique landmark identifier.</param>
    /// <returns>The landmark definition, or null if not found.</returns>
    LandmarkRoom? GetLandmark(string landmarkId);

    /// <summary>
    /// Gets all available landmark room definitions.
    /// </summary>
    /// <returns>A read-only list of all landmark definitions.</returns>
    IReadOnlyList<LandmarkRoom> GetAllLandmarks();

    /// <summary>
    /// Gets landmarks for a specific room type.
    /// </summary>
    /// <param name="roomType">The room type to filter by.</param>
    /// <returns>Landmarks that create this room type.</returns>
    IReadOnlyList<LandmarkRoom> GetLandmarksForType(RoomType roomType);

    /// <summary>
    /// Gets landmarks valid for a given context.
    /// </summary>
    /// <param name="roomType">The room type required.</param>
    /// <param name="biomeId">The biome to filter by.</param>
    /// <param name="styleId">The architectural style to filter by.</param>
    /// <param name="depth">The Z-level depth.</param>
    /// <param name="difficulty">The current difficulty rating.</param>
    /// <returns>Valid landmarks for this context.</returns>
    IReadOnlyList<LandmarkRoom> GetValidLandmarks(
        RoomType roomType,
        string biomeId,
        string styleId,
        int depth,
        int difficulty);

    /// <summary>
    /// Selects a landmark for a special room using weighted random.
    /// </summary>
    /// <param name="roomType">The room type required.</param>
    /// <param name="position">The 3D position for seeded random.</param>
    /// <param name="biomeId">The biome to filter by.</param>
    /// <param name="styleId">The architectural style to filter by.</param>
    /// <param name="difficulty">The current difficulty rating.</param>
    /// <returns>The selected landmark, or null if none available.</returns>
    LandmarkRoom? SelectLandmark(
        RoomType roomType,
        Position3D position,
        string biomeId,
        string styleId,
        int difficulty);

    /// <summary>
    /// Generates a room from a landmark definition.
    /// </summary>
    /// <param name="landmark">The landmark to generate from.</param>
    /// <param name="position">The room position.</param>
    /// <param name="biomeId">The biome to assign.</param>
    /// <returns>A fully configured room based on the landmark.</returns>
    Room GenerateFromLandmark(
        LandmarkRoom landmark,
        Position3D position,
        string biomeId);

    /// <summary>
    /// Resets unique landmark tracking for a new dungeon.
    /// </summary>
    /// <remarks>
    /// Call this when starting a new dungeon generation to allow
    /// unique landmarks to appear again.
    /// </remarks>
    void ResetUniqueLandmarks();

    /// <summary>
    /// Checks if a unique landmark has already been used.
    /// </summary>
    /// <param name="landmarkId">The landmark ID to check.</param>
    /// <returns>True if the landmark has been used in this dungeon.</returns>
    bool IsLandmarkUsed(string landmarkId);

    /// <summary>
    /// Gets landmarks matching specified tags.
    /// </summary>
    /// <param name="tags">Tags to match.</param>
    /// <param name="matchAll">True to require all tags, false for any.</param>
    /// <returns>Matching landmark definitions.</returns>
    IReadOnlyList<LandmarkRoom> GetLandmarksByTags(IEnumerable<string> tags, bool matchAll = false);
}
```

### 8.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for landmark room lookup, selection, and generation.
/// </summary>
public class LandmarkRoomService : ILandmarkRoomService
{
    private readonly IConfigurationProvider _config;
    private readonly IStructuralFeatureService _featureService;
    private readonly SeededRandomService _random;
    private readonly ILogger<LandmarkRoomService> _logger;

    private readonly HashSet<string> _usedUniqueLandmarks = new();

    /// <summary>
    /// Initializes a new instance of the LandmarkRoomService.
    /// </summary>
    public LandmarkRoomService(
        IConfigurationProvider config,
        IStructuralFeatureService featureService,
        SeededRandomService random,
        ILogger<LandmarkRoomService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _featureService = featureService ?? throw new ArgumentNullException(nameof(featureService));
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public LandmarkRoom? GetLandmark(string landmarkId)
    {
        if (string.IsNullOrWhiteSpace(landmarkId))
            return null;

        return _config.GetLandmarkRooms()
            .FirstOrDefault(l => l.Id.Equals(landmarkId, StringComparison.OrdinalIgnoreCase));
    }

    /// <inheritdoc />
    public IReadOnlyList<LandmarkRoom> GetAllLandmarks()
    {
        return _config.GetLandmarkRooms();
    }

    /// <inheritdoc />
    public IReadOnlyList<LandmarkRoom> GetLandmarksForType(RoomType roomType)
    {
        return _config.GetLandmarkRooms()
            .Where(l => l.RoomType == roomType)
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<LandmarkRoom> GetValidLandmarks(
        RoomType roomType,
        string biomeId,
        string styleId,
        int depth,
        int difficulty)
    {
        return _config.GetLandmarkRooms()
            .Where(l => l.RoomType == roomType)
            .Where(l => l.IsValidForDepth(depth))
            .Where(l => l.MeetsDifficultyRequirement(difficulty))
            .Where(l => l.IsCompatibleWithBiome(biomeId))
            .Where(l => l.IsCompatibleWithStyle(styleId))
            .Where(l => !l.Unique || !_usedUniqueLandmarks.Contains(l.Id))
            .ToList();
    }

    /// <inheritdoc />
    public LandmarkRoom? SelectLandmark(
        RoomType roomType,
        Position3D position,
        string biomeId,
        string styleId,
        int difficulty)
    {
        var valid = GetValidLandmarks(roomType, biomeId, styleId, position.Z, difficulty);

        if (!valid.Any())
        {
            _logger.LogDebug(
                "No valid landmarks for {RoomType} in biome {BiomeId} with style {StyleId} at depth {Depth}",
                roomType,
                biomeId,
                styleId,
                position.Z);
            return null;
        }

        // Use weighted selection
        var weightedLandmarks = valid.Select(l => (Item: l, Weight: l.Weight));
        var selected = _random.SelectWeighted(position, weightedLandmarks, "landmark_select");

        // Track unique landmarks
        if (selected.Unique)
        {
            _usedUniqueLandmarks.Add(selected.Id);
            _logger.LogDebug(
                "Unique landmark {LandmarkId} used, will not appear again this dungeon",
                selected.Id);
        }

        _logger.LogInformation(
            "Selected landmark {LandmarkId} ({LandmarkName}) for {RoomType} at position ({X}, {Y}, {Z})",
            selected.Id,
            selected.Name,
            roomType,
            position.X,
            position.Y,
            position.Z);

        return selected;
    }

    /// <inheritdoc />
    public Room GenerateFromLandmark(
        LandmarkRoom landmark,
        Position3D position,
        string biomeId)
    {
        ArgumentNullException.ThrowIfNull(landmark);

        // Create base room
        var room = Room.Create(
            landmark.Name,
            landmark.Description,
            position);

        // Apply landmark properties
        room.SetRoomType(landmark.RoomType);
        room.SetShape(landmark.Shape);
        room.SetBiome(biomeId);
        room.SetLandmark(landmark.Id);

        // Add fixed features
        foreach (var feature in landmark.Features)
        {
            room.AddFeature(new RoomFeature
            {
                FeatureId = feature.FeatureId,
                Position = feature.Position,
                Quantity = feature.Quantity
            });
        }

        // Add fixed exits
        foreach (var direction in landmark.Layout.FixedExits)
        {
            room.AddExit(direction, isHidden: false);
        }

        _logger.LogInformation(
            "Generated landmark room {LandmarkId} at ({X}, {Y}, {Z}) with {FeatureCount} features and {ExitCount} exits",
            landmark.Id,
            position.X,
            position.Y,
            position.Z,
            landmark.Features.Count,
            landmark.Layout.FixedExits.Count);

        return room;
    }

    /// <inheritdoc />
    public void ResetUniqueLandmarks()
    {
        var count = _usedUniqueLandmarks.Count;
        _usedUniqueLandmarks.Clear();

        _logger.LogDebug("Reset unique landmark tracking, cleared {Count} entries", count);
    }

    /// <inheritdoc />
    public bool IsLandmarkUsed(string landmarkId)
    {
        if (string.IsNullOrWhiteSpace(landmarkId))
            return false;

        return _usedUniqueLandmarks.Contains(landmarkId);
    }

    /// <inheritdoc />
    public IReadOnlyList<LandmarkRoom> GetLandmarksByTags(
        IEnumerable<string> tags,
        bool matchAll = false)
    {
        var tagList = tags.ToList();
        if (!tagList.Any())
            return Array.Empty<LandmarkRoom>();

        return _config.GetLandmarkRooms()
            .Where(l => matchAll
                ? tagList.All(t => l.HasTag(t))
                : tagList.Any(t => l.HasTag(t)))
            .ToList();
    }
}
```

---

## 9. Room Entity Integration

### 9.1 Purpose

Extend the `Room` entity to store an optional landmark reference, enabling landmark-specific behavior and description generation.

### 9.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modification)

### 9.3 Changes

```csharp
// Add to Room.cs

/// <summary>
/// Gets the landmark ID if this room was generated from a landmark.
/// </summary>
/// <remarks>
/// Null for procedurally generated rooms. Set when room is created
/// from a LandmarkRoom definition.
/// </remarks>
public string? LandmarkId { get; private set; }

/// <summary>
/// Gets whether this room is a landmark room.
/// </summary>
/// <remarks>
/// True if the room was generated from a landmark definition.
/// Landmark rooms have fixed layouts and special properties.
/// </remarks>
public bool IsLandmark => !string.IsNullOrEmpty(LandmarkId);

/// <summary>
/// Sets the landmark ID for this room.
/// </summary>
/// <param name="landmarkId">The landmark identifier.</param>
/// <exception cref="ArgumentException">Thrown when landmarkId is null or whitespace.</exception>
public void SetLandmark(string landmarkId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(landmarkId, nameof(landmarkId));
    LandmarkId = landmarkId;
}

/// <summary>
/// Clears the landmark assignment from this room.
/// </summary>
/// <remarks>
/// Used when converting a landmark room back to procedural.
/// </remarks>
public void ClearLandmark()
{
    LandmarkId = null;
}
```

### 9.4 Data Model Change

```
MODIFY: Room
├── ADD: LandmarkId: string? (default: null)
├── ADD: IsLandmark: bool (computed)
├── ADD: SetLandmark(landmarkId): void
└── ADD: ClearLandmark(): void
```

---

## 10. DescriptorService Integration

### 10.1 Purpose

Update the `DescriptorService` to support landmark-aware description generation, incorporating special lighting and ambient effects from landmark layouts.

### 10.2 File Location

**File:** `src/Core/RuneAndRust.Application/Services/DescriptorService.cs` (modification)

### 10.3 Changes

```csharp
// Add to DescriptorService

private readonly ILandmarkRoomService _landmarkService;

/// <summary>
/// Generates a room description with landmark enhancements if applicable.
/// </summary>
/// <param name="room">The room to describe.</param>
/// <param name="position">Position for seeded randomization.</param>
/// <returns>A formatted room description with landmark details.</returns>
public string GenerateLandmarkAwareDescription(Room room, Position3D position)
{
    // Start with base styled description
    var baseDescription = GenerateStyledRoomDescription(room, position);

    // If not a landmark, return base description
    if (!room.IsLandmark)
        return baseDescription;

    // Get landmark for additional details
    var landmark = _landmarkService.GetLandmark(room.LandmarkId!);
    if (landmark == null)
        return baseDescription;

    var description = new StringBuilder(baseDescription);

    // Add special lighting
    if (landmark.Layout.HasSpecialLighting)
    {
        description.Append($" {CapitalizeFirst(landmark.Layout.SpecialLighting!)} bathes the chamber.");
    }

    // Add ambient effects
    if (landmark.Layout.HasAmbientEffects)
    {
        var effects = landmark.Layout.AmbientEffects;
        if (effects.Count == 1)
        {
            description.Append($" A {effects[0]} atmosphere pervades.");
        }
        else if (effects.Count > 1)
        {
            var lastEffect = effects[effects.Count - 1];
            var otherEffects = string.Join(", ", effects.Take(effects.Count - 1));
            description.Append($" The atmosphere is {otherEffects} and {lastEffect}.");
        }
    }

    // Add terrain zone mentions
    if (landmark.Layout.HasTerrainZones)
    {
        foreach (var zone in landmark.Layout.TerrainZones)
        {
            var zoneDescription = GetTerrainZoneDescription(zone);
            if (!string.IsNullOrEmpty(zoneDescription))
            {
                description.Append($" {zoneDescription}");
            }
        }
    }

    return description.ToString().Trim();
}

/// <summary>
/// Gets a descriptive string for a terrain zone.
/// </summary>
private string GetTerrainZoneDescription(TerrainZone zone)
{
    return zone.ZoneType.ToLowerInvariant() switch
    {
        "lava" => zone.Coverage > 0.2f
            ? "Rivers of molten rock flow through the chamber."
            : "Pools of lava glow menacingly.",
        "water" => "Clear water fills a portion of the room.",
        "pit" => "Deep pits yawn dangerously in the floor.",
        "pressure-plates" => "Stone pressure plates pattern the floor.",
        "ice" => "Ice covers much of the ground, treacherous underfoot.",
        _ => string.Empty
    };
}
```

---

## 11. Data Model Changes

### 11.1 Summary

```
NEW: LandmarkRoom (Definition)
├── Id: string (unique identifier)
├── Name: string (display name)
├── Description: string (room description)
├── RoomType: RoomType (Boss, Safe, Trap, Treasure, Standard)
├── Shape: RoomShape (required shape)
├── Layout: LandmarkLayout
├── CompatibleBiomes: IReadOnlyList<string>
├── CompatibleStyles: IReadOnlyList<string>
├── MinDepth: int
├── MaxDepth: int?
├── Unique: bool
├── Weight: int
├── MinDifficulty: int?
├── Features: IReadOnlyList<LandmarkFeature>
├── Spawns: IReadOnlyList<LandmarkSpawn>
├── Loot: IReadOnlyList<LandmarkLoot>
├── Tags: IReadOnlyList<string>
├── IsValidForDepth(depth): bool
├── IsCompatibleWithBiome(biomeId): bool
├── IsCompatibleWithStyle(styleId): bool
├── MeetsDifficultyRequirement(difficulty): bool
└── HasTag(tag): bool

NEW: LandmarkLayout (Value Object)
├── Size: RoomSizeCategory
├── FixedExits: IReadOnlyList<Direction>
├── AllowAdditionalExits: bool
├── TerrainZones: IReadOnlyList<TerrainZone>
├── CentralFeature: string?
├── SpecialLighting: string?
├── AmbientEffects: IReadOnlyList<string>
├── HasFixedExit(direction): bool
├── HasTerrainZones: bool (computed)
├── HasCentralFeature: bool (computed)
├── HasSpecialLighting: bool (computed)
└── HasAmbientEffects: bool (computed)

NEW: LandmarkFeature (Value Object)
├── FeatureId: string
├── Position: string
└── Quantity: int

NEW: LandmarkSpawn (Value Object)
├── MonsterId: string?
├── Tier: string
├── Count: int
└── IsBoss: bool

NEW: LandmarkLoot (Value Object)
├── ItemId: string?
├── Quantity: int
├── ContainerType: string?
└── Guaranteed: bool

NEW: TerrainZone (Value Object)
├── ZoneType: string
├── Position: string
└── Coverage: float

NEW: RoomSizeCategory (Enum)
├── Small (0)
├── Medium (1)
├── Large (2)
├── Grand (3)
└── Massive (4)

MODIFY: Room
├── ADD: LandmarkId: string? (default: null)
├── ADD: IsLandmark: bool (computed)
├── ADD: SetLandmark(landmarkId): void
└── ADD: ClearLandmark(): void

MODIFY: IConfigurationProvider
└── ADD: GetLandmarkRooms(): IReadOnlyList<LandmarkRoom>
```

---

## 12. Configuration File Schemas

### 12.1 Landmark Rooms Configuration

**File:** `config/landmark-rooms.json`

```json
{
  "$schema": "schemas/landmark-rooms-schema.json",
  "landmarks": [
    {
      "id": "boss-arena-standard",
      "name": "Grand Arena",
      "description": "A vast circular chamber designed for epic confrontations. Pillars ring the perimeter, and a raised central platform commands attention.",
      "roomType": "Boss",
      "shape": "Circular",
      "layout": {
        "size": "Grand",
        "fixedExits": ["South"],
        "allowAdditionalExits": false,
        "centralFeature": "raised-platform",
        "terrainZones": [],
        "specialLighting": "dramatic spotlight",
        "ambientEffects": ["echoing", "tension"]
      },
      "compatibleBiomes": [],
      "compatibleStyles": ["carved-halls", "ancient-temples"],
      "minDepth": 3,
      "maxDepth": null,
      "unique": false,
      "weight": 100,
      "minDifficulty": null,
      "features": [
        { "featureId": "pillar", "position": "perimeter", "quantity": 8 },
        { "featureId": "raised-platform", "position": "center", "quantity": 1 }
      ],
      "spawns": [
        { "monsterId": null, "tier": "boss", "count": 1, "isBoss": true }
      ],
      "loot": [
        { "itemId": null, "quantity": 1, "containerType": "boss-chest", "guaranteed": true }
      ],
      "tags": ["boss", "arena", "combat"]
    },
    {
      "id": "boss-arena-volcanic",
      "name": "Magma Lord's Throne",
      "description": "A scorching chamber where rivers of lava flow around a central obsidian platform. Heat shimmers distort the air.",
      "roomType": "Boss",
      "shape": "Circular",
      "layout": {
        "size": "Grand",
        "fixedExits": ["North"],
        "allowAdditionalExits": false,
        "centralFeature": "obsidian-throne",
        "terrainZones": [
          { "zoneType": "lava", "position": "perimeter", "coverage": 0.3 }
        ],
        "specialLighting": "molten glow",
        "ambientEffects": ["heat-shimmer", "volcanic-rumble"]
      },
      "compatibleBiomes": ["volcanic-caverns"],
      "compatibleStyles": ["natural-caves"],
      "minDepth": 6,
      "maxDepth": null,
      "unique": true,
      "weight": 100,
      "minDifficulty": null,
      "features": [
        { "featureId": "lava-pool", "position": "perimeter", "quantity": 4 },
        { "featureId": "obsidian-pillar", "position": "inner-ring", "quantity": 4 }
      ],
      "spawns": [
        { "monsterId": "magma-lord", "tier": "boss", "count": 1, "isBoss": true }
      ],
      "loot": [
        { "itemId": "heart-of-the-mountain", "quantity": 1, "containerType": null, "guaranteed": true }
      ],
      "tags": ["boss", "volcanic", "fire", "unique"]
    },
    {
      "id": "safe-haven-shrine",
      "name": "Sacred Shrine",
      "description": "A peaceful sanctuary where divine light filters through crystal formations. A healing spring bubbles gently in the center.",
      "roomType": "Safe",
      "shape": "Circular",
      "layout": {
        "size": "Medium",
        "fixedExits": ["South"],
        "allowAdditionalExits": true,
        "centralFeature": "healing-spring",
        "terrainZones": [],
        "specialLighting": "divine radiance",
        "ambientEffects": ["peaceful", "regenerating"]
      },
      "compatibleBiomes": ["ancient-ruins", "catacombs"],
      "compatibleStyles": ["ancient-temples"],
      "minDepth": 2,
      "maxDepth": null,
      "unique": false,
      "weight": 80,
      "minDifficulty": null,
      "features": [
        { "featureId": "healing-spring", "position": "center", "quantity": 1 },
        { "featureId": "offering-altar", "position": "north-wall", "quantity": 1 }
      ],
      "spawns": [],
      "loot": [],
      "tags": ["safe", "healing", "sacred"]
    },
    {
      "id": "puzzle-chamber-pressure",
      "name": "Chamber of Weighted Stones",
      "description": "Ancient pressure plates pattern the floor. Statues stand in alcoves, their stone eyes seeming to watch your every move.",
      "roomType": "Trap",
      "shape": "Rectangular",
      "layout": {
        "size": "Large",
        "fixedExits": ["South", "North"],
        "allowAdditionalExits": false,
        "centralFeature": null,
        "terrainZones": [
          { "zoneType": "pressure-plates", "position": "floor-grid", "coverage": 0.6 }
        ],
        "specialLighting": "dim torch flicker",
        "ambientEffects": ["ominous", "mechanical-tension"]
      },
      "compatibleBiomes": ["ancient-ruins"],
      "compatibleStyles": ["ancient-temples", "carved-halls"],
      "minDepth": 3,
      "maxDepth": null,
      "unique": false,
      "weight": 70,
      "minDifficulty": 20,
      "features": [
        { "featureId": "alcove-statue", "position": "perimeter", "quantity": 4 },
        { "featureId": "pressure-plate", "position": "floor-grid", "quantity": 9 }
      ],
      "spawns": [],
      "loot": [
        { "itemId": null, "quantity": 1, "containerType": "puzzle-reward-chest", "guaranteed": true }
      ],
      "tags": ["puzzle", "trap", "pressure", "interactive"]
    },
    {
      "id": "treasure-vault-guarded",
      "name": "Guardian's Treasury",
      "description": "Gleaming treasures fill this chamber, but animated guardians stand eternal watch over the hoard.",
      "roomType": "Treasure",
      "shape": "Rectangular",
      "layout": {
        "size": "Large",
        "fixedExits": ["South"],
        "allowAdditionalExits": false,
        "centralFeature": "treasure-pile",
        "terrainZones": [],
        "specialLighting": "gold reflection",
        "ambientEffects": ["wealthy", "guarded"]
      },
      "compatibleBiomes": ["ancient-ruins", "catacombs"],
      "compatibleStyles": ["carved-halls", "ancient-temples"],
      "minDepth": 4,
      "maxDepth": null,
      "unique": false,
      "weight": 60,
      "minDifficulty": null,
      "features": [
        { "featureId": "treasure-pile", "position": "center", "quantity": 1 },
        { "featureId": "pillar", "position": "corners", "quantity": 4 }
      ],
      "spawns": [
        { "monsterId": "animated-armor", "tier": "elite", "count": 2, "isBoss": false }
      ],
      "loot": [
        { "itemId": null, "quantity": 3, "containerType": "treasure-chest", "guaranteed": true },
        { "itemId": "gold", "quantity": 500, "containerType": null, "guaranteed": true }
      ],
      "tags": ["treasure", "guarded", "wealthy"]
    }
  ]
}
```

### 12.2 JSON Schema

**File:** `config/schemas/landmark-rooms-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "landmark-rooms-schema.json",
  "title": "Landmark Rooms Definitions",
  "description": "Schema for hand-crafted landmark room configuration",
  "type": "object",
  "required": ["landmarks"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "landmarks": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/landmarkRoom"
      }
    }
  },
  "$defs": {
    "landmarkRoom": {
      "type": "object",
      "required": ["id", "name", "description", "roomType", "shape", "layout"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier in kebab-case"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Display name for the landmark"
        },
        "description": {
          "type": "string",
          "description": "Full room description"
        },
        "roomType": {
          "type": "string",
          "enum": ["Standard", "Boss", "Safe", "Trap", "Treasure", "Entrance", "Exit"],
          "description": "Type of room this landmark creates"
        },
        "shape": {
          "type": "string",
          "enum": ["Rectangular", "Circular", "LShaped", "Irregular", "TShaped", "Cross"],
          "description": "Required room shape"
        },
        "layout": {
          "$ref": "#/$defs/landmarkLayout"
        },
        "compatibleBiomes": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Compatible biome IDs (empty = all)"
        },
        "compatibleStyles": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Compatible architectural style IDs (empty = all)"
        },
        "minDepth": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Minimum Z-level for this landmark"
        },
        "maxDepth": {
          "type": ["integer", "null"],
          "minimum": 0,
          "description": "Maximum Z-level (null = unlimited)"
        },
        "unique": {
          "type": "boolean",
          "default": false,
          "description": "Whether this landmark can only appear once per dungeon"
        },
        "weight": {
          "type": "integer",
          "minimum": 1,
          "default": 100,
          "description": "Selection probability weight"
        },
        "minDifficulty": {
          "type": ["integer", "null"],
          "minimum": 0,
          "description": "Minimum difficulty requirement"
        },
        "features": {
          "type": "array",
          "items": { "$ref": "#/$defs/landmarkFeature" },
          "description": "Fixed structural features"
        },
        "spawns": {
          "type": "array",
          "items": { "$ref": "#/$defs/landmarkSpawn" },
          "description": "Fixed monster spawns"
        },
        "loot": {
          "type": "array",
          "items": { "$ref": "#/$defs/landmarkLoot" },
          "description": "Fixed loot placements"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Categorization tags"
        }
      }
    },
    "landmarkLayout": {
      "type": "object",
      "required": ["size", "fixedExits"],
      "properties": {
        "size": {
          "type": "string",
          "enum": ["Small", "Medium", "Large", "Grand", "Massive"],
          "description": "Room size category"
        },
        "fixedExits": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["North", "South", "East", "West", "Up", "Down"]
          },
          "description": "Required exit directions"
        },
        "allowAdditionalExits": {
          "type": "boolean",
          "default": true,
          "description": "Whether additional exits can be added"
        },
        "terrainZones": {
          "type": "array",
          "items": { "$ref": "#/$defs/terrainZone" },
          "description": "Special terrain areas"
        },
        "centralFeature": {
          "type": ["string", "null"],
          "description": "Feature ID for room center"
        },
        "specialLighting": {
          "type": ["string", "null"],
          "description": "Special lighting description"
        },
        "ambientEffects": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Ambient effect identifiers"
        }
      }
    },
    "landmarkFeature": {
      "type": "object",
      "required": ["featureId", "position", "quantity"],
      "properties": {
        "featureId": {
          "type": "string",
          "description": "Structural feature ID"
        },
        "position": {
          "type": "string",
          "description": "Position within room"
        },
        "quantity": {
          "type": "integer",
          "minimum": 1,
          "description": "Number of features to place"
        }
      }
    },
    "landmarkSpawn": {
      "type": "object",
      "required": ["tier", "count"],
      "properties": {
        "monsterId": {
          "type": ["string", "null"],
          "description": "Specific monster ID (null for tier-based)"
        },
        "tier": {
          "type": "string",
          "description": "Monster tier for selection"
        },
        "count": {
          "type": "integer",
          "minimum": 1,
          "description": "Number of monsters"
        },
        "isBoss": {
          "type": "boolean",
          "default": false,
          "description": "Whether this is the boss spawn"
        }
      }
    },
    "landmarkLoot": {
      "type": "object",
      "required": ["quantity"],
      "properties": {
        "itemId": {
          "type": ["string", "null"],
          "description": "Specific item ID (null for tier-based)"
        },
        "quantity": {
          "type": "integer",
          "minimum": 1,
          "description": "Item quantity"
        },
        "containerType": {
          "type": ["string", "null"],
          "description": "Container type for loot"
        },
        "guaranteed": {
          "type": "boolean",
          "default": true,
          "description": "Whether loot always appears"
        }
      }
    },
    "terrainZone": {
      "type": "object",
      "required": ["zoneType", "position", "coverage"],
      "properties": {
        "zoneType": {
          "type": "string",
          "description": "Terrain type (lava, water, pit, etc.)"
        },
        "position": {
          "type": "string",
          "description": "Zone position (center, perimeter, etc.)"
        },
        "coverage": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0,
          "description": "Percentage of room covered"
        }
      }
    }
  }
}
```

---

## 13. Logging Specifications

### 13.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `LandmarkRoomService` | Information | Landmark selected, room generated |
| `LandmarkRoomService` | Debug | Lookup, filtering, unique tracking |
| `LandmarkRoomService` | Warning | No valid landmarks found |
| `LandmarkRoomService` | Error | Configuration loading failure |
| `DescriptorService` | Debug | Landmark description enhancement |
| `Room` | Debug | Landmark assignment |

### 13.2 Log Message Examples

```csharp
// Information
_logger.LogInformation("Loaded {Count} landmark room definitions", landmarks.Count);
_logger.LogInformation(
    "Selected landmark {LandmarkId} ({LandmarkName}) for {RoomType} at position ({X}, {Y}, {Z})",
    selected.Id, selected.Name, roomType, position.X, position.Y, position.Z);
_logger.LogInformation(
    "Generated landmark room {LandmarkId} at ({X}, {Y}, {Z}) with {FeatureCount} features and {ExitCount} exits",
    landmark.Id, position.X, position.Y, position.Z, landmark.Features.Count, landmark.Layout.FixedExits.Count);

// Debug
_logger.LogDebug("Looking up landmark {LandmarkId}", landmarkId);
_logger.LogDebug(
    "Found {Count} valid landmarks for {RoomType} in biome {BiomeId}",
    valid.Count, roomType, biomeId);
_logger.LogDebug(
    "Unique landmark {LandmarkId} used, will not appear again this dungeon",
    selected.Id);
_logger.LogDebug("Reset unique landmark tracking, cleared {Count} entries", count);

// Warning
_logger.LogWarning(
    "No valid landmarks for {RoomType} in biome {BiomeId} with style {StyleId} at depth {Depth}",
    roomType, biomeId, styleId, depth);

// Error
_logger.LogError(ex, "Failed to load landmark room configuration from {Path}", configPath);
```

---

## 14. Unit Testing Requirements

### 14.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| LandmarkRoom entity | ~6 |
| LandmarkLayout value object | ~3 |
| Supporting value objects | ~4 |
| RoomSizeCategory enum | ~2 |
| LandmarkRoomService | ~7 |
| Room landmark integration | ~3 |
| **Total** | **~25** |

### 14.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `LandmarkRoomTests.cs` | ~6 | Create, validation, IsValidForDepth, IsCompatibleWithBiome, IsCompatibleWithStyle, HasTag |
| `LandmarkLayoutTests.cs` | ~3 | Default, HasFixedExit, computed properties |
| `LandmarkValueObjectTests.cs` | ~4 | LandmarkFeature, LandmarkSpawn, LandmarkLoot, TerrainZone creation |
| `LandmarkRoomServiceTests.cs` | ~7 | GetLandmark, GetValidLandmarks, SelectLandmark, GenerateFromLandmark, ResetUniqueLandmarks, unique tracking |
| `RoomLandmarkTests.cs` | ~3 | SetLandmark, IsLandmark, ClearLandmark |

### 14.3 Test Categories

**LandmarkRoom Tests:**
```csharp
[Test]
public void Create_WithValidParameters_CreatesLandmarkRoom()

[Test]
public void Create_WithNullId_ThrowsArgumentException()

[Test]
public void Create_WithNegativeMinDepth_ThrowsArgumentOutOfRangeException()

[Test]
public void IsValidForDepth_WithDepthInRange_ReturnsTrue()

[Test]
public void IsValidForDepth_WithDepthBelowMin_ReturnsFalse()

[Test]
public void IsCompatibleWithBiome_WithEmptyList_ReturnsTrue()

[Test]
public void IsCompatibleWithBiome_WithMatchingBiome_ReturnsTrue()

[Test]
public void IsCompatibleWithStyle_WithMatchingStyle_ReturnsTrue()

[Test]
public void MeetsDifficultyRequirement_WithSufficientDifficulty_ReturnsTrue()

[Test]
public void HasTag_WithMatchingTag_ReturnsTrue()
```

**LandmarkRoomService Tests:**
```csharp
[Test]
public void GetLandmark_WithExistingId_ReturnsLandmark()

[Test]
public void GetLandmark_WithNonExistingId_ReturnsNull()

[Test]
public void GetValidLandmarks_FiltersCorrectly()

[Test]
public void SelectLandmark_ReturnsValidLandmarkForContext()

[Test]
public void SelectLandmark_WithNoValidLandmarks_ReturnsNull()

[Test]
public void SelectLandmark_TracksUniqueLandmarks()

[Test]
public void GenerateFromLandmark_CreatesConfiguredRoom()

[Test]
public void ResetUniqueLandmarks_ClearsTracking()

[Test]
public void IsLandmarkUsed_ReturnsTrueForUsedUnique()
```

---

## 15. Use Cases

### UC-001: Generate Boss Arena

**Actor:** System (Room Generator)
**Flow:** RoomGeneratorService needs Boss room → LandmarkRoomService.SelectLandmark(Boss, position, biome, style, difficulty) → Landmark selected (boss-arena-standard) → GenerateFromLandmark creates configured room → Room has fixed features, shape, single exit

### UC-002: Generate Safe Haven

**Actor:** System (Room Generator)
**Flow:** RoomGeneratorService needs Safe room → LandmarkRoomService.SelectLandmark(Safe, ...) → Landmark selected (safe-haven-shrine) → Room generated with healing spring, divine lighting → Player can rest and heal

### UC-003: Prevent Duplicate Unique Landmarks

**Actor:** System (Room Generator)
**Flow:** First Boss room → SelectLandmark returns boss-arena-volcanic (unique) → _usedUniqueLandmarks.Add("boss-arena-volcanic") → Second Boss room in same biome → GetValidLandmarks excludes boss-arena-volcanic → Different landmark selected

### UC-004: Reset for New Dungeon

**Actor:** System (Dungeon Generator)
**Flow:** New dungeon generation starts → LandmarkRoomService.ResetUniqueLandmarks() → _usedUniqueLandmarks cleared → All unique landmarks available again

### UC-005: Display Landmark Description

**Actor:** Player
**Flow:** Player enters landmark room → DescriptorService.GenerateLandmarkAwareDescription(room) → Base styled description + special lighting + ambient effects + terrain zones → Full atmospheric description displayed

### UC-006: Filter Landmarks by Tags

**Actor:** System (Quest System)
**Flow:** Quest requires "sacred" location → LandmarkRoomService.GetLandmarksByTags(["sacred"]) → safe-haven-shrine returned → Quest objective placed in matching landmark

---

## 16. Deliverable Checklist

### Domain Layer
- [ ] `LandmarkRoom.cs` created
- [ ] `LandmarkLayout.cs` created
- [ ] `LandmarkFeature.cs` created
- [ ] `LandmarkSpawn.cs` created
- [ ] `LandmarkLoot.cs` created
- [ ] `TerrainZone.cs` created
- [ ] `RoomSizeCategory.cs` created
- [ ] `Room.cs` updated with LandmarkId

### Application Layer
- [ ] `ILandmarkRoomService.cs` created
- [ ] `LandmarkRoomService.cs` created
- [ ] `DescriptorService.cs` updated with landmark support

### Infrastructure Layer
- [ ] `IConfigurationProvider.cs` updated
- [ ] `JsonConfigurationProvider.cs` updated to load landmarks
- [ ] `LandmarkRoomConfigurationDto.cs` created

### Configuration Files
- [ ] `config/landmark-rooms.json` created with 5 landmarks
- [ ] `config/schemas/landmark-rooms-schema.json` created

### Testing
- [ ] `LandmarkRoomTests.cs` created (~6 tests)
- [ ] `LandmarkLayoutTests.cs` created (~3 tests)
- [ ] `LandmarkValueObjectTests.cs` created (~4 tests)
- [ ] `LandmarkRoomServiceTests.cs` created (~7 tests)
- [ ] `RoomLandmarkTests.cs` created (~3 tests)
- [ ] All ~25 tests passing

### Documentation
- [ ] XML documentation on all public members
- [ ] Code follows .editorconfig conventions

---

## 17. Acceptance Criteria

### Functional

- [ ] LandmarkRoom entity stores all landmark properties
- [ ] LandmarkLayout defines size, exits, terrain, effects
- [ ] LandmarkFeature, LandmarkSpawn, LandmarkLoot define fixed content
- [ ] TerrainZone defines special terrain areas
- [ ] RoomSizeCategory enum defines 5 size categories
- [ ] Landmarks load from JSON configuration
- [ ] LandmarkRoomService.GetLandmark returns definition by ID
- [ ] LandmarkRoomService.GetValidLandmarks filters by all criteria
- [ ] LandmarkRoomService.SelectLandmark uses weighted selection
- [ ] LandmarkRoomService.GenerateFromLandmark creates configured room
- [ ] Unique landmarks tracked and prevented from repeating
- [ ] ResetUniqueLandmarks clears tracking for new dungeon
- [ ] Room.LandmarkId stores assigned landmark
- [ ] Room.IsLandmark computed property works correctly
- [ ] DescriptorService generates landmark-enhanced descriptions
- [ ] Five default landmarks configured

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~25 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on public members
- [ ] Code follows .editorconfig conventions
- [ ] No hardcoded landmark content outside configuration

---

## 18. Dependencies

### 18.1 Prerequisites (v0.1.3b)

| Component | Purpose for v0.1.3c |
|-----------|---------------------|
| `RoomShape` | Required shape for landmarks |
| `ShapeDefinition` | Shape rules for exit placement |
| `StructuralFeature` | Feature IDs referenced by landmarks |
| `RoomFeature` | Feature placement value object |
| `Room.Shape` | Shape assignment for landmark rooms |
| `Room.StructuralFeatures` | Feature collection |
| `IStructuralFeatureService` | Feature lookup for validation |

### 18.2 Prerequisites (v0.1.3a)

| Component | Purpose for v0.1.3c |
|-----------|---------------------|
| `ArchitecturalStyle` | Style compatibility filtering |
| `ArchitecturalStyleService` | Style lookup |
| `Room.ArchitecturalStyleId` | Style context for selection |

### 18.3 Prerequisites (v0.1.2)

| Component | Purpose for v0.1.3c |
|-----------|---------------------|
| `BiomeDefinition` | Biome compatibility filtering |
| `BiomeService` | Biome lookup |
| `Room.BiomeId` | Biome assignment |
| `RoomType` | Room type filtering |
| `Direction` | Exit directions |
| `Position3D` | Room positioning |
| `SeededRandomService` | Reproducible selection |
| `DescriptorService` | Description generation |
| `IConfigurationProvider` | Configuration loading pattern |

### 18.4 Provides to Future Phases

| Component | Used By |
|-----------|---------|
| `LandmarkRoom` | v0.1.3d (Age affects landmark descriptions) |
| `LandmarkRoomService` | RoomGeneratorService integration |
| `Room.LandmarkId` | Save/load, quest systems |
| `RoomSizeCategory` | Room generation size hints |

### 18.5 Dependency Diagram

```
v0.1.2 (Dungeon Theming & Biomes)
    │
    ├── BiomeDefinition, BiomeService ──────────────────────────────┐
    ├── RoomType, Direction, Position3D ────────────────────────────┤
    ├── SeededRandomService, DescriptorService ─────────────────────┤
    └── IConfigurationProvider ─────────────────────────────────────┘
                                                                    │
v0.1.3a (Architectural Styles)                                      │
    │                                                               │
    ├── ArchitecturalStyle, ArchitecturalStyleService ──────────────┤
    └── Room.ArchitecturalStyleId ──────────────────────────────────┘
                                                                    │
v0.1.3b (Room Shapes & Features)                                    │
    │                                                               │
    ├── RoomShape, ShapeDefinition ─────────────────────────────────┤
    ├── StructuralFeature, RoomFeature ─────────────────────────────┤
    └── Room.Shape, Room.StructuralFeatures ────────────────────────┘
                                                                    │
                                                                    ▼
v0.1.3c (Landmark Rooms)
    │
    ├── LandmarkRoom ────────────────────────────────────────────────┐
    ├── LandmarkLayout, LandmarkFeature, LandmarkSpawn, LandmarkLoot│
    ├── TerrainZone, RoomSizeCategory ──────────────────────────────│
    ├── LandmarkRoomService ────────────────────────────────────────│
    └── Room.LandmarkId ────────────────────────────────────────────┘
                                                                    │
                                                                    ▼
                                                  v0.1.3d (Age & Coherence)
```

---

## 19. Future Considerations

### 19.1 Deferred to v0.1.3d

- **Age affects landmark descriptions** - DungeonAge overlays on landmark descriptions
- **Coherence validation** - Landmarks validated against structural coherence rules
- **Age-appropriate features** - Fresh vs ancient landmarks

### 19.2 Out of Scope (Future Versions)

- **Custom landmark creation UI** - Player/modder landmark editor
- **Dynamic landmarks** - Landmarks that change based on player actions
- **Quest-specific landmarks** - Landmarks tied to specific quests
- **Landmark chains** - Series of connected thematic landmarks
- **Procedural landmark generation** - Generating landmarks from rules
- **Landmark persistence** - Saving landmark state between sessions

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
