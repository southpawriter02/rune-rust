# v0.8.0c Design Specification: Keyboard Shortcuts

**Version:** 0.8.0c
**Parent:** v0.8.0 (Character & Settings)
**Prerequisites:** v0.8.0b Complete (Settings Window)
**Status:** Design Complete
**Estimated Unit Tests:** ~8

---

## Table of Contents

1. [Overview](#1-overview)
2. [Feature Overview](#2-feature-overview)
3. [Architecture](#3-architecture)
4. [Keyboard Shortcut Service](#4-keyboard-shortcut-service)
5. [Shortcut Overlay Window](#5-shortcut-overlay-window)
6. [Context Management](#6-context-management)
7. [Keybindings Configuration](#7-keybindings-configuration)
8. [Styles](#8-styles)
9. [Data Model Changes](#9-data-model-changes)
10. [Logging Specifications](#10-logging-specifications)
11. [Unit Testing Requirements](#11-unit-testing-requirements)
12. [Use Cases](#12-use-cases)
13. [Deliverable Checklist](#13-deliverable-checklist)
14. [Acceptance Criteria](#14-acceptance-criteria)
15. [Dependencies](#15-dependencies)
16. [Future Considerations](#16-future-considerations)

---

## 1. Overview

### Purpose

Implement a keyboard shortcut service that handles configurable keybindings with context-specific shortcuts (global, game, combat). The service intelligently prioritizes global bindings while respecting context boundaries. Includes a shortcut overlay (F1) that displays available bindings organized by context for quick reference.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | `IKeyboardShortcutService` |
| **Services** | `KeyboardShortcutService` |
| **Windows** | `ShortcutOverlayWindow` |
| **ViewModels** | `ShortcutOverlayViewModel` |
| **Configuration** | `keybindings.json`, schema |
| **Tests** | ~8 unit tests |

### Design Principles

1. **Context Awareness**: Shortcuts respect current game state
2. **Global Priority**: Global shortcuts work everywhere
3. **Configurability**: User-defined keybindings persist
4. **Conflict Prevention**: Detect and prevent duplicate bindings
5. **Discoverability**: F1 overlay shows all available shortcuts

---

## 2. Feature Overview

```
v0.8.0c Features
├── IKeyboardShortcutService Interface
│   ├── CurrentContext property
│   ├── ProcessKeyDown() method
│   ├── RegisterAction() method
│   ├── UnregisterAction() method
│   ├── GetBinding() method
│   ├── SetBinding() method
│   ├── ResetToDefaults() method
│   ├── GetBindingsForContext() method
│   └── HasConflict() method
│
├── KeyboardShortcutService Implementation
│   ├── Action registry
│   ├── Context-based binding lookup
│   ├── Global priority processing
│   ├── Default binding loader
│   └── JSON persistence
│
├── ShortcutContext Enum
│   ├── Global
│   ├── MainMenu
│   ├── Game
│   ├── Combat
│   ├── Dialogue
│   └── Puzzle
│
├── Context-Specific Shortcuts
│   ├── Global: F1, F5, F9, Escape
│   ├── Game: I, M, J, C, 1-9
│   └── Combat: A, M, B, D, Space, Tab
│
├── ShortcutOverlayWindow
│   ├── Context-grouped shortcut list
│   ├── Press any key to close
│   └── Styled consistent with theme
│
└── keybindings.json
    ├── Versioned schema
    ├── Global bindings section
    ├── Game bindings section
    └── Combat bindings section
```

---

## 3. Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       PRESENTATION LAYER                                │
├─────────────────────────────────────────────────────────────────────────┤
│  Windows/Views                                                          │
│  ├── GameWindow                                                         │
│  │    └── KeyDown event → KeyboardShortcutService.ProcessKeyDown()      │
│  └── ShortcutOverlayWindow                                              │
│       └── ShortcutOverlayViewModel                                      │
│            ├── GlobalShortcuts: ObservableCollection<ShortcutDisplay>   │
│            ├── GameShortcuts: ObservableCollection<ShortcutDisplay>     │
│            ├── CombatShortcuts: ObservableCollection<ShortcutDisplay>   │
│            └── CloseCommand                                             │
│                                                                         │
│  Services                                                               │
│  └── IKeyboardShortcutService                                           │
│       ├── CurrentContext: ShortcutContext                               │
│       ├── ProcessKeyDown(KeyEventArgs): bool                            │
│       ├── RegisterAction(actionId, action): void                        │
│       ├── UnregisterAction(actionId): void                              │
│       ├── GetBinding(actionId): KeyGesture?                             │
│       ├── SetBinding(actionId, gesture): void                           │
│       ├── ResetToDefaults(): void                                       │
│       ├── GetBindingsForContext(context): IReadOnlyDictionary           │
│       └── HasConflict(actionId, gesture): bool                          │
└────────────────────────────────────┬────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                            │
├─────────────────────────────────────────────────────────────────────────┤
│  KeybindingsRepository                                                  │
│  ├── LoadBindings(): KeybindingsConfig                                  │
│  └── SaveBindings(config): void                                         │
│                                                                         │
│  config/keybindings.json                                                │
│  └── Persisted user keybindings                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Key Event Processing Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    KEY EVENT PROCESSING FLOW                            │
└─────────────────────────────────────────────────────────────────────────┘

    User Presses Key
           │
           ▼
┌───────────────────┐
│   GameWindow      │
│   KeyDown Event   │
└────────┬──────────┘
         │
         ▼
┌───────────────────────────────────────────────────────────────────────┐
│              KeyboardShortcutService.ProcessKeyDown()                  │
├───────────────────────────────────────────────────────────────────────┤
│  1. Convert KeyEventArgs to KeyGesture                                │
│  2. Check Global bindings FIRST                                       │
│  3. If no global match, check CurrentContext bindings                 │
│  4. If match found, execute registered action                         │
│  5. Set e.Handled = true if processed                                 │
└───────────────────────────────────────────────────────────────────────┘
         │
         ├─── [F1] → Show ShortcutOverlayWindow
         │
         ├─── [F5] → Quick Save
         │
         ├─── [I] (Game context) → Toggle Inventory Panel
         │
         └─── [Space] (Combat context) → End Turn
```

---

## 4. Keyboard Shortcut Service

### IKeyboardShortcutService Interface

**File:** `src/Presentation/RuneAndRust.Avalonia/Services/IKeyboardShortcutService.cs`

```csharp
namespace RuneAndRust.Avalonia.Services;

/// <summary>
/// Manages keyboard shortcuts and keybindings with context-aware processing.
/// </summary>
/// <remarks>
/// Global shortcuts are always checked first. Context-specific shortcuts
/// are checked next based on the current game state.
/// </remarks>
public interface IKeyboardShortcutService
{
    /// <summary>
    /// Gets or sets the current shortcut context.
    /// </summary>
    /// <remarks>
    /// Updated by the game state manager when transitioning between modes.
    /// </remarks>
    ShortcutContext CurrentContext { get; set; }

    /// <summary>
    /// Processes a key press and executes the bound action if one exists.
    /// </summary>
    /// <param name="e">The key event arguments.</param>
    /// <returns>True if a shortcut was executed; otherwise, false.</returns>
    bool ProcessKeyDown(KeyEventArgs e);

    /// <summary>
    /// Registers an action to be invoked when its bound shortcut is pressed.
    /// </summary>
    /// <param name="actionId">The unique action identifier (e.g., "toggle-inventory").</param>
    /// <param name="action">The action to execute.</param>
    void RegisterAction(string actionId, Action action);

    /// <summary>
    /// Unregisters a previously registered action.
    /// </summary>
    /// <param name="actionId">The action identifier to unregister.</param>
    void UnregisterAction(string actionId);

    /// <summary>
    /// Gets the current keybinding for an action.
    /// </summary>
    /// <param name="actionId">The action identifier.</param>
    /// <returns>The bound key gesture, or null if not bound.</returns>
    KeyGesture? GetBinding(string actionId);

    /// <summary>
    /// Sets a custom keybinding for an action.
    /// </summary>
    /// <param name="actionId">The action identifier.</param>
    /// <param name="gesture">The new key gesture to bind.</param>
    /// <exception cref="InvalidOperationException">Thrown if binding would create a conflict.</exception>
    void SetBinding(string actionId, KeyGesture gesture);

    /// <summary>
    /// Resets all keybindings to their default values.
    /// </summary>
    void ResetToDefaults();

    /// <summary>
    /// Gets all bindings for a specific context.
    /// </summary>
    /// <param name="context">The shortcut context.</param>
    /// <returns>A dictionary mapping action IDs to their key gestures.</returns>
    IReadOnlyDictionary<string, KeyGesture> GetBindingsForContext(ShortcutContext context);

    /// <summary>
    /// Checks if setting a binding would create a conflict.
    /// </summary>
    /// <param name="actionId">The action to rebind.</param>
    /// <param name="gesture">The proposed new gesture.</param>
    /// <returns>True if another action already uses this gesture in the same context.</returns>
    bool HasConflict(string actionId, KeyGesture gesture);

    /// <summary>
    /// Gets all registered actions with their display names and current bindings.
    /// </summary>
    /// <returns>Collection of shortcut display information.</returns>
    IReadOnlyList<ShortcutDisplayInfo> GetAllShortcuts();
}
```

### ShortcutContext Enum

**File:** `src/Presentation/RuneAndRust.Avalonia/Services/ShortcutContext.cs`

```csharp
namespace RuneAndRust.Avalonia.Services;

/// <summary>
/// Defines the contexts in which keyboard shortcuts operate.
/// </summary>
/// <remarks>
/// Global shortcuts are always checked first, regardless of current context.
/// Context-specific shortcuts only apply when their context is active.
/// </remarks>
public enum ShortcutContext
{
    /// <summary>Global shortcuts available everywhere.</summary>
    Global,

    /// <summary>Main menu shortcuts.</summary>
    MainMenu,

    /// <summary>General game/exploration shortcuts.</summary>
    Game,

    /// <summary>Combat mode shortcuts.</summary>
    Combat,

    /// <summary>Dialogue/conversation shortcuts.</summary>
    Dialogue,

    /// <summary>Puzzle interaction shortcuts.</summary>
    Puzzle
}
```

### KeyboardShortcutService Implementation

**File:** `src/Presentation/RuneAndRust.Avalonia/Services/KeyboardShortcutService.cs`

```csharp
namespace RuneAndRust.Avalonia.Services;

public class KeyboardShortcutService : IKeyboardShortcutService
{
    private readonly Dictionary<string, Action> _actions = new();
    private readonly Dictionary<ShortcutContext, Dictionary<KeyGesture, string>> _bindings = new();
    private readonly Dictionary<string, (ShortcutContext Context, KeyGesture Gesture)> _actionBindings = new();
    private readonly Dictionary<string, string> _actionDisplayNames = new();
    private readonly ILogger<KeyboardShortcutService> _logger;

    public ShortcutContext CurrentContext { get; set; } = ShortcutContext.Game;

    public KeyboardShortcutService(ILogger<KeyboardShortcutService> logger)
    {
        _logger = logger;
        InitializeContexts();
        LoadDefaultBindings();
    }

    private void InitializeContexts()
    {
        foreach (ShortcutContext context in Enum.GetValues<ShortcutContext>())
        {
            _bindings[context] = new Dictionary<KeyGesture, string>(KeyGestureComparer.Instance);
        }
    }

    /// <inheritdoc />
    public bool ProcessKeyDown(KeyEventArgs e)
    {
        var gesture = new KeyGesture(e.Key, e.KeyModifiers);

        // Global bindings always checked first
        if (TryExecuteBinding(ShortcutContext.Global, gesture))
        {
            e.Handled = true;
            return true;
        }

        // Then check current context bindings
        if (TryExecuteBinding(CurrentContext, gesture))
        {
            e.Handled = true;
            return true;
        }

        return false;
    }

    private bool TryExecuteBinding(ShortcutContext context, KeyGesture gesture)
    {
        if (!_bindings.TryGetValue(context, out var contextBindings))
            return false;

        if (!contextBindings.TryGetValue(gesture, out var actionId))
            return false;

        if (!_actions.TryGetValue(actionId, out var action))
        {
            _logger.LogWarning("Action not registered: {ActionId}", actionId);
            return false;
        }

        _logger.LogDebug("Executing shortcut: {ActionId} ({Gesture}) in context {Context}",
            actionId, gesture, context);
        
        try
        {
            action();
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error executing shortcut action: {ActionId}", actionId);
            return false;
        }
    }

    /// <inheritdoc />
    public void RegisterAction(string actionId, Action action)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(actionId);
        ArgumentNullException.ThrowIfNull(action);

        _actions[actionId] = action;
        _logger.LogDebug("Registered action: {ActionId}", actionId);
    }

    /// <inheritdoc />
    public void UnregisterAction(string actionId)
    {
        if (_actions.Remove(actionId))
        {
            _logger.LogDebug("Unregistered action: {ActionId}", actionId);
        }
    }

    /// <inheritdoc />
    public KeyGesture? GetBinding(string actionId)
    {
        return _actionBindings.TryGetValue(actionId, out var binding)
            ? binding.Gesture
            : null;
    }

    /// <inheritdoc />
    public void SetBinding(string actionId, KeyGesture gesture)
    {
        if (HasConflict(actionId, gesture))
        {
            throw new InvalidOperationException(
                $"Key gesture {gesture} is already bound to another action in this context.");
        }

        // Remove old binding if exists
        if (_actionBindings.TryGetValue(actionId, out var oldBinding))
        {
            _bindings[oldBinding.Context].Remove(oldBinding.Gesture);
        }

        // Add new binding
        var context = GetContextForAction(actionId);
        _bindings[context][gesture] = actionId;
        _actionBindings[actionId] = (context, gesture);

        _logger.LogInformation("Binding updated: {ActionId} → {Gesture}", actionId, gesture);
    }

    /// <inheritdoc />
    public void ResetToDefaults()
    {
        foreach (var context in _bindings.Values)
            context.Clear();

        _actionBindings.Clear();
        LoadDefaultBindings();

        _logger.LogInformation("Keybindings reset to defaults");
    }

    /// <inheritdoc />
    public IReadOnlyDictionary<string, KeyGesture> GetBindingsForContext(ShortcutContext context)
    {
        var result = new Dictionary<string, KeyGesture>();
        
        if (_bindings.TryGetValue(context, out var contextBindings))
        {
            foreach (var (gesture, actionId) in contextBindings)
            {
                result[actionId] = gesture;
            }
        }

        return result;
    }

    /// <inheritdoc />
    public bool HasConflict(string actionId, KeyGesture gesture)
    {
        var context = GetContextForAction(actionId);

        if (!_bindings.TryGetValue(context, out var contextBindings))
            return false;

        if (!contextBindings.TryGetValue(gesture, out var existingAction))
            return false;

        // Not a conflict if it's the same action
        return existingAction != actionId;
    }

    /// <inheritdoc />
    public IReadOnlyList<ShortcutDisplayInfo> GetAllShortcuts()
    {
        var result = new List<ShortcutDisplayInfo>();

        foreach (var (actionId, (context, gesture)) in _actionBindings)
        {
            var displayName = _actionDisplayNames.GetValueOrDefault(actionId, actionId);
            result.Add(new ShortcutDisplayInfo(actionId, displayName, gesture, context));
        }

        return result.OrderBy(s => s.Context).ThenBy(s => s.DisplayName).ToList();
    }

    private ShortcutContext GetContextForAction(string actionId)
    {
        // Determine context from action prefix
        if (actionId.StartsWith("global-") || IsGlobalAction(actionId))
            return ShortcutContext.Global;
        if (actionId.StartsWith("combat-") || IsCombatAction(actionId))
            return ShortcutContext.Combat;
        if (actionId.StartsWith("dialogue-"))
            return ShortcutContext.Dialogue;

        return ShortcutContext.Game;
    }

    private static bool IsGlobalAction(string actionId) =>
        actionId is "show-help" or "quick-save" or "quick-load" or "close-window";

    private static bool IsCombatAction(string actionId) =>
        actionId is "attack-mode" or "move-mode" or "ability-menu" or "defend" 
            or "end-turn" or "next-target" or "previous-target";

    private void LoadDefaultBindings()
    {
        // Global shortcuts
        AddBinding(ShortcutContext.Global, Key.F1, KeyModifiers.None, "show-help", "Help / Shortcuts");
        AddBinding(ShortcutContext.Global, Key.F5, KeyModifiers.None, "quick-save", "Quick Save");
        AddBinding(ShortcutContext.Global, Key.F9, KeyModifiers.None, "quick-load", "Quick Load");
        AddBinding(ShortcutContext.Global, Key.Escape, KeyModifiers.None, "close-window", "Close Window");

        // Game context shortcuts
        AddBinding(ShortcutContext.Game, Key.I, KeyModifiers.None, "toggle-inventory", "Toggle Inventory");
        AddBinding(ShortcutContext.Game, Key.M, KeyModifiers.None, "toggle-map", "Toggle Map");
        AddBinding(ShortcutContext.Game, Key.J, KeyModifiers.None, "toggle-quest-log", "Toggle Quest Log");
        AddBinding(ShortcutContext.Game, Key.C, KeyModifiers.None, "toggle-character", "Toggle Character Sheet");
        AddBinding(ShortcutContext.Game, Key.D1, KeyModifiers.None, "quick-slot-1", "Quick Slot 1");
        AddBinding(ShortcutContext.Game, Key.D2, KeyModifiers.None, "quick-slot-2", "Quick Slot 2");
        AddBinding(ShortcutContext.Game, Key.D3, KeyModifiers.None, "quick-slot-3", "Quick Slot 3");
        AddBinding(ShortcutContext.Game, Key.D4, KeyModifiers.None, "quick-slot-4", "Quick Slot 4");
        AddBinding(ShortcutContext.Game, Key.D5, KeyModifiers.None, "quick-slot-5", "Quick Slot 5");
        AddBinding(ShortcutContext.Game, Key.D6, KeyModifiers.None, "quick-slot-6", "Quick Slot 6");
        AddBinding(ShortcutContext.Game, Key.D7, KeyModifiers.None, "quick-slot-7", "Quick Slot 7");
        AddBinding(ShortcutContext.Game, Key.D8, KeyModifiers.None, "quick-slot-8", "Quick Slot 8");
        AddBinding(ShortcutContext.Game, Key.D9, KeyModifiers.None, "quick-slot-9", "Quick Slot 9");

        // Combat context shortcuts
        AddBinding(ShortcutContext.Combat, Key.A, KeyModifiers.None, "attack-mode", "Attack Mode");
        AddBinding(ShortcutContext.Combat, Key.M, KeyModifiers.None, "move-mode", "Move Mode");
        AddBinding(ShortcutContext.Combat, Key.B, KeyModifiers.None, "ability-menu", "Ability Menu");
        AddBinding(ShortcutContext.Combat, Key.D, KeyModifiers.None, "defend", "Defend");
        AddBinding(ShortcutContext.Combat, Key.Space, KeyModifiers.None, "end-turn", "End Turn");
        AddBinding(ShortcutContext.Combat, Key.Tab, KeyModifiers.None, "next-target", "Next Target");
        AddBinding(ShortcutContext.Combat, Key.Tab, KeyModifiers.Shift, "previous-target", "Previous Target");

        _logger.LogDebug("Default bindings loaded: {Count} bindings", _actionBindings.Count);
    }

    private void AddBinding(ShortcutContext context, Key key, KeyModifiers modifiers, 
        string actionId, string displayName)
    {
        var gesture = new KeyGesture(key, modifiers);
        _bindings[context][gesture] = actionId;
        _actionBindings[actionId] = (context, gesture);
        _actionDisplayNames[actionId] = displayName;
    }
}

/// <summary>
/// Comparer for KeyGesture that handles equality properly.
/// </summary>
internal class KeyGestureComparer : IEqualityComparer<KeyGesture>
{
    public static readonly KeyGestureComparer Instance = new();

    public bool Equals(KeyGesture? x, KeyGesture? y)
    {
        if (x is null && y is null) return true;
        if (x is null || y is null) return false;
        return x.Key == y.Key && x.KeyModifiers == y.KeyModifiers;
    }

    public int GetHashCode(KeyGesture obj) =>
        HashCode.Combine(obj.Key, obj.KeyModifiers);
}
```

### ShortcutDisplayInfo Record

**File:** `src/Presentation/RuneAndRust.Avalonia/Services/ShortcutDisplayInfo.cs`

```csharp
namespace RuneAndRust.Avalonia.Services;

/// <summary>
/// Display information for a keyboard shortcut.
/// </summary>
/// <param name="ActionId">The unique action identifier.</param>
/// <param name="DisplayName">The user-friendly display name.</param>
/// <param name="Gesture">The bound key gesture.</param>
/// <param name="Context">The shortcut context.</param>
public record ShortcutDisplayInfo(
    string ActionId,
    string DisplayName,
    KeyGesture Gesture,
    ShortcutContext Context)
{
    /// <summary>
    /// Gets a formatted string representation of the key gesture.
    /// </summary>
    public string GestureText => FormatGesture(Gesture);

    private static string FormatGesture(KeyGesture gesture)
    {
        var parts = new List<string>();

        if (gesture.KeyModifiers.HasFlag(KeyModifiers.Control))
            parts.Add("Ctrl");
        if (gesture.KeyModifiers.HasFlag(KeyModifiers.Alt))
            parts.Add("Alt");
        if (gesture.KeyModifiers.HasFlag(KeyModifiers.Shift))
            parts.Add("Shift");

        parts.Add(FormatKey(gesture.Key));

        return string.Join("+", parts);
    }

    private static string FormatKey(Key key) => key switch
    {
        Key.D1 => "1",
        Key.D2 => "2",
        Key.D3 => "3",
        Key.D4 => "4",
        Key.D5 => "5",
        Key.D6 => "6",
        Key.D7 => "7",
        Key.D8 => "8",
        Key.D9 => "9",
        Key.D0 => "0",
        _ => key.ToString()
    };
}
```

---

## 5. Shortcut Overlay Window

### ShortcutOverlayWindow

**File:** `src/Presentation/RuneAndRust.Avalonia/Views/ShortcutOverlayWindow.axaml`

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:RuneAndRust.Avalonia.ViewModels"
        x:Class="RuneAndRust.Avalonia.Views.ShortcutOverlayWindow"
        x:DataType="vm:ShortcutOverlayViewModel"
        Title="Keyboard Shortcuts"
        Width="550" Height="500"
        WindowStartupLocation="CenterOwner"
        CanResize="False"
        ShowInTaskbar="False"
        KeyDown="OnKeyDown">
    
    <Grid RowDefinitions="Auto,*,Auto">
        
        <!-- Header -->
        <Border Grid.Row="0" Classes="overlay-header" Padding="24,16">
            <StackPanel HorizontalAlignment="Center">
                <TextBlock Text="KEYBOARD SHORTCUTS" Classes="title" />
                <TextBlock Text="Press any key to close" 
                           Classes="subtitle" 
                           HorizontalAlignment="Center"
                           Margin="0,4,0,0" />
            </StackPanel>
        </Border>
        
        <!-- Content -->
        <ScrollViewer Grid.Row="1" Padding="24">
            <StackPanel Spacing="24">
                
                <!-- Global Shortcuts -->
                <StackPanel IsVisible="{Binding HasGlobalShortcuts}">
                    <TextBlock Text="GLOBAL" Classes="section-header" />
                    <Border Classes="separator" />
                    <ItemsControl ItemsSource="{Binding GlobalShortcuts}"
                                  Margin="0,8,0,0">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="80,*" Margin="0,4">
                                    <TextBlock Grid.Column="0" 
                                               Text="{Binding GestureText}" 
                                               Classes="key-binding" />
                                    <TextBlock Grid.Column="1" 
                                               Text="{Binding DisplayName}" />
                                </Grid>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </StackPanel>
                
                <!-- Game Shortcuts -->
                <StackPanel IsVisible="{Binding HasGameShortcuts}">
                    <TextBlock Text="GAME" Classes="section-header" />
                    <Border Classes="separator" />
                    <ItemsControl ItemsSource="{Binding GameShortcuts}"
                                  Margin="0,8,0,0">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="80,*" Margin="0,4">
                                    <TextBlock Grid.Column="0" 
                                               Text="{Binding GestureText}" 
                                               Classes="key-binding" />
                                    <TextBlock Grid.Column="1" 
                                               Text="{Binding DisplayName}" />
                                </Grid>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </StackPanel>
                
                <!-- Combat Shortcuts -->
                <StackPanel IsVisible="{Binding HasCombatShortcuts}">
                    <TextBlock Text="COMBAT" Classes="section-header" />
                    <Border Classes="separator" />
                    <ItemsControl ItemsSource="{Binding CombatShortcuts}"
                                  Margin="0,8,0,0">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="80,*" Margin="0,4">
                                    <TextBlock Grid.Column="0" 
                                               Text="{Binding GestureText}" 
                                               Classes="key-binding" />
                                    <TextBlock Grid.Column="1" 
                                               Text="{Binding DisplayName}" />
                                </Grid>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </StackPanel>
                
            </StackPanel>
        </ScrollViewer>
        
        <!-- Footer hint -->
        <Border Grid.Row="2" Classes="overlay-footer" Padding="16,12">
            <TextBlock Text="Tip: Customize shortcuts in Settings → Controls"
                       Classes="muted"
                       HorizontalAlignment="Center" />
        </Border>
        
    </Grid>
</Window>
```

### ShortcutOverlayWindow Code-Behind

**File:** `src/Presentation/RuneAndRust.Avalonia/Views/ShortcutOverlayWindow.axaml.cs`

```csharp
namespace RuneAndRust.Avalonia.Views;

public partial class ShortcutOverlayWindow : Window
{
    public ShortcutOverlayWindow()
    {
        InitializeComponent();
    }

    private void OnKeyDown(object? sender, KeyEventArgs e)
    {
        // Close on any key press
        Close();
        e.Handled = true;
    }
}
```

### ShortcutOverlayViewModel

**File:** `src/Presentation/RuneAndRust.Avalonia/ViewModels/ShortcutOverlayViewModel.cs`

```csharp
namespace RuneAndRust.Avalonia.ViewModels;

public partial class ShortcutOverlayViewModel : ViewModelBase
{
    public ObservableCollection<ShortcutDisplayInfo> GlobalShortcuts { get; } = new();
    public ObservableCollection<ShortcutDisplayInfo> GameShortcuts { get; } = new();
    public ObservableCollection<ShortcutDisplayInfo> CombatShortcuts { get; } = new();

    public bool HasGlobalShortcuts => GlobalShortcuts.Count > 0;
    public bool HasGameShortcuts => GameShortcuts.Count > 0;
    public bool HasCombatShortcuts => CombatShortcuts.Count > 0;

    public ShortcutOverlayViewModel(IKeyboardShortcutService shortcutService)
    {
        var shortcuts = shortcutService.GetAllShortcuts();

        foreach (var shortcut in shortcuts)
        {
            var collection = shortcut.Context switch
            {
                ShortcutContext.Global => GlobalShortcuts,
                ShortcutContext.Combat => CombatShortcuts,
                _ => GameShortcuts
            };
            collection.Add(shortcut);
        }
    }

    // Design-time constructor
    public ShortcutOverlayViewModel()
    {
        // Sample data for designer
        GlobalShortcuts.Add(new ShortcutDisplayInfo("show-help", "Help / Shortcuts", 
            new KeyGesture(Key.F1), ShortcutContext.Global));
        GlobalShortcuts.Add(new ShortcutDisplayInfo("quick-save", "Quick Save", 
            new KeyGesture(Key.F5), ShortcutContext.Global));
        
        GameShortcuts.Add(new ShortcutDisplayInfo("toggle-inventory", "Toggle Inventory", 
            new KeyGesture(Key.I), ShortcutContext.Game));
        GameShortcuts.Add(new ShortcutDisplayInfo("toggle-map", "Toggle Map", 
            new KeyGesture(Key.M), ShortcutContext.Game));
        
        CombatShortcuts.Add(new ShortcutDisplayInfo("attack-mode", "Attack Mode", 
            new KeyGesture(Key.A), ShortcutContext.Combat));
        CombatShortcuts.Add(new ShortcutDisplayInfo("end-turn", "End Turn", 
            new KeyGesture(Key.Space), ShortcutContext.Combat));
    }
}
```

---

## 6. Context Management

### Context Detection

The `CurrentContext` property must be updated when game state changes:

```csharp
// In GameViewModel or similar coordinator
public partial class GameViewModel : ViewModelBase
{
    private readonly IKeyboardShortcutService _shortcuts;

    partial void OnCurrentModeChanged(GameMode value)
    {
        _shortcuts.CurrentContext = value switch
        {
            GameMode.Exploration => ShortcutContext.Game,
            GameMode.Combat => ShortcutContext.Combat,
            GameMode.Dialogue => ShortcutContext.Dialogue,
            GameMode.Puzzle => ShortcutContext.Puzzle,
            _ => ShortcutContext.Game
        };
    }
}
```

### GameWindow Integration

**File:** `src/Presentation/RuneAndRust.Avalonia/Views/GameWindow.axaml.cs` (addition)

```csharp
public partial class GameWindow : Window
{
    private readonly IKeyboardShortcutService _shortcutService;

    public GameWindow(IKeyboardShortcutService shortcutService)
    {
        InitializeComponent();
        _shortcutService = shortcutService;
        
        // Register global actions
        _shortcutService.RegisterAction("show-help", ShowShortcutOverlay);
        _shortcutService.RegisterAction("quick-save", QuickSave);
        _shortcutService.RegisterAction("quick-load", QuickLoad);
        _shortcutService.RegisterAction("close-window", CloseCurrentWindow);
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        // Let the shortcut service handle the key first
        if (_shortcutService.ProcessKeyDown(e))
            return;

        base.OnKeyDown(e);
    }

    private void ShowShortcutOverlay()
    {
        var overlay = new ShortcutOverlayWindow
        {
            DataContext = new ShortcutOverlayViewModel(_shortcutService)
        };
        overlay.ShowDialog(this);
    }

    private void QuickSave()
    {
        // Invoke quick save through game service
        (DataContext as GameViewModel)?.QuickSaveCommand.Execute(null);
    }

    private void QuickLoad()
    {
        // Invoke quick load through game service
        (DataContext as GameViewModel)?.QuickLoadCommand.Execute(null);
    }

    private void CloseCurrentWindow()
    {
        // Close any open overlay/dialog, or handle escape
        (DataContext as GameViewModel)?.HandleEscapeCommand.Execute(null);
    }
}
```

---

## 7. Keybindings Configuration

### keybindings.json

**File:** `config/keybindings.json`

```json
{
  "$schema": "./schemas/keybindings.schema.json",
  "version": "1.0",
  "bindings": {
    "global": {
      "show-help": "F1",
      "quick-save": "F5",
      "quick-load": "F9",
      "close-window": "Escape"
    },
    "game": {
      "toggle-inventory": "I",
      "toggle-map": "M",
      "toggle-quest-log": "J",
      "toggle-character": "C",
      "quick-slot-1": "1",
      "quick-slot-2": "2",
      "quick-slot-3": "3",
      "quick-slot-4": "4",
      "quick-slot-5": "5",
      "quick-slot-6": "6",
      "quick-slot-7": "7",
      "quick-slot-8": "8",
      "quick-slot-9": "9"
    },
    "combat": {
      "attack-mode": "A",
      "move-mode": "M",
      "ability-menu": "B",
      "defend": "D",
      "end-turn": "Space",
      "next-target": "Tab",
      "previous-target": "Shift+Tab"
    }
  }
}
```

### keybindings.schema.json

**File:** `config/schemas/keybindings.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Keybindings Configuration",
  "type": "object",
  "required": ["version", "bindings"],
  "properties": {
    "version": {
      "type": "string",
      "description": "Schema version for migration support"
    },
    "bindings": {
      "type": "object",
      "description": "Keybindings organized by context",
      "properties": {
        "global": {
          "type": "object",
          "description": "Shortcuts available in all contexts",
          "additionalProperties": {
            "type": "string",
            "description": "Key or key combination (e.g., 'F1', 'Ctrl+S', 'Shift+Tab')"
          }
        },
        "game": {
          "type": "object",
          "description": "Shortcuts available in game/exploration mode",
          "additionalProperties": {
            "type": "string"
          }
        },
        "combat": {
          "type": "object",
          "description": "Shortcuts available in combat mode",
          "additionalProperties": {
            "type": "string"
          }
        },
        "dialogue": {
          "type": "object",
          "description": "Shortcuts available in dialogue mode",
          "additionalProperties": {
            "type": "string"
          }
        },
        "puzzle": {
          "type": "object",
          "description": "Shortcuts available in puzzle mode",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    }
  }
}
```

---

## 8. Styles

**File:** `src/Presentation/RuneAndRust.Avalonia/Styles/ShortcutOverlayStyles.axaml`

```xml
<Styles xmlns="https://github.com/avaloniaui">
    
    <!-- Overlay Header -->
    <Style Selector="Border.overlay-header">
        <Setter Property="Background" Value="{StaticResource SurfaceDarkBrush}" />
        <Setter Property="BorderThickness" Value="0,0,0,1" />
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}" />
    </Style>
    
    <!-- Overlay Footer -->
    <Style Selector="Border.overlay-footer">
        <Setter Property="Background" Value="{StaticResource SurfaceDarkBrush}" />
        <Setter Property="BorderThickness" Value="0,1,0,0" />
        <Setter Property="BorderBrush" Value="{StaticResource BorderBrush}" />
    </Style>
    
    <!-- Section Headers -->
    <Style Selector="TextBlock.section-header">
        <Setter Property="FontSize" Value="14" />
        <Setter Property="FontWeight" Value="SemiBold" />
        <Setter Property="Foreground" Value="{StaticResource PrimaryBrush}" />
    </Style>
    
    <!-- Separator Lines -->
    <Style Selector="Border.separator">
        <Setter Property="Height" Value="1" />
        <Setter Property="Background" Value="{StaticResource BorderBrush}" />
        <Setter Property="Margin" Value="0,4,0,0" />
    </Style>
    
    <!-- Key Binding Text -->
    <Style Selector="TextBlock.key-binding">
        <Setter Property="FontFamily" Value="Consolas, Menlo, monospace" />
        <Setter Property="FontWeight" Value="SemiBold" />
        <Setter Property="Foreground" Value="{StaticResource AccentBrush}" />
    </Style>
    
    <!-- Title -->
    <Style Selector="TextBlock.title">
        <Setter Property="FontSize" Value="20" />
        <Setter Property="FontWeight" Value="Bold" />
    </Style>
    
    <!-- Subtitle -->
    <Style Selector="TextBlock.subtitle">
        <Setter Property="FontSize" Value="12" />
        <Setter Property="Foreground" Value="{StaticResource MutedBrush}" />
    </Style>
    
    <!-- Muted Text -->
    <Style Selector="TextBlock.muted">
        <Setter Property="FontSize" Value="11" />
        <Setter Property="Foreground" Value="{StaticResource MutedBrush}" />
    </Style>
    
</Styles>
```

---

## 9. Data Model Changes

### New Types

| Type | Layer | Description |
|------|-------|-------------|
| `ShortcutContext` | Presentation | Enum for context types |
| `ShortcutDisplayInfo` | Presentation | Display record for overlay |
| `IKeyboardShortcutService` | Presentation | Service interface |
| `KeyboardShortcutService` | Presentation | Service implementation |
| `ShortcutOverlayViewModel` | Presentation | Overlay view model |
| `KeyGestureComparer` | Presentation | Comparer for dictionary keys |

### Modified Types

| Type | Change |
|------|--------|
| `GameWindow` | Add key handler integration |
| `ServiceCollectionExtensions` | Register `IKeyboardShortcutService` |

---

## 10. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `KeyboardShortcutService` | Debug | Shortcut execution, binding lookups |
| `KeyboardShortcutService` | Information | Binding changes, reset to defaults |
| `KeyboardShortcutService` | Warning | Unregistered action invoked |
| `KeyboardShortcutService` | Error | Action execution failures |
| `ShortcutOverlayViewModel` | Debug | Overlay shown, shortcuts loaded |

### Log Message Examples

```
Debug: Executing shortcut: toggle-inventory (I) in context Game
Debug: Executing shortcut: show-help (F1) in context Global
Information: Binding updated: toggle-inventory → J
Information: Keybindings reset to defaults
Warning: Action not registered: undefined-action
Error: Error executing shortcut action: toggle-inventory - NullReferenceException
```

---

## 11. Unit Testing Requirements

| Feature | Tests |
|---------|-------|
| Global shortcut processing | 2 |
| Context-specific shortcuts | 2 |
| Conflict detection | 2 |
| Binding changes | 2 |
| **Total** | **~8** |

### Test Specifications

**File:** `tests/RuneAndRust.Avalonia.UnitTests/Services/KeyboardShortcutServiceTests.cs`

```csharp
[TestFixture]
public class KeyboardShortcutServiceTests
{
    [Test]
    public void ProcessKeyDown_GlobalShortcut_ExecutesRegardlessOfContext();

    [Test]
    public void ProcessKeyDown_GlobalShortcut_TakesPriorityOverContext();

    [Test]
    public void ProcessKeyDown_ContextShortcut_ExecutesWhenContextMatches();

    [Test]
    public void ProcessKeyDown_ContextShortcut_IgnoredWhenContextDiffers();

    [Test]
    public void HasConflict_SameGestureInContext_ReturnsTrue();

    [Test]
    public void HasConflict_DifferentGestureOrContext_ReturnsFalse();

    [Test]
    public void SetBinding_ValidGesture_UpdatesBinding();

    [Test]
    public void ResetToDefaults_RestoresAllDefaultBindings();
}
```

---

## 12. Use Cases

### UC-080c-001: Show Shortcut Help Overlay
**Actor:** Player
**Flow:** Player presses F1 → Overlay window appears → Player presses any key → Overlay closes

### UC-080c-002: Execute Game Shortcut
**Actor:** Player
**Flow:** Player is in Game context → Player presses I → Inventory panel toggles

### UC-080c-003: Execute Combat Shortcut
**Actor:** Player
**Flow:** Player is in Combat context → Player presses Space → Turn ends

### UC-080c-004: Global Shortcut Priority
**Actor:** Player
**Flow:** Player is in Combat context → Player presses F5 → Quick save executes (not combat action)

### UC-080c-005: Rebind Shortcut
**Actor:** Player
**Flow:** Settings → Controls → Click Rebind → Press new key → Binding updates

### UC-080c-006: Detect Binding Conflict
**Actor:** Player
**Flow:** Attempt to rebind action to already-used key → Warning displayed → Binding not changed

---

## 13. Deliverable Checklist

### Services
- [ ] `Services/IKeyboardShortcutService.cs` created
- [ ] `Services/KeyboardShortcutService.cs` created
- [ ] `Services/ShortcutContext.cs` created
- [ ] `Services/ShortcutDisplayInfo.cs` created

### Views
- [ ] `Views/ShortcutOverlayWindow.axaml` created
- [ ] `Views/ShortcutOverlayWindow.axaml.cs` created

### ViewModels
- [ ] `ViewModels/ShortcutOverlayViewModel.cs` created

### Styles
- [ ] `Styles/ShortcutOverlayStyles.axaml` created

### Configuration
- [ ] `config/keybindings.json` created
- [ ] `config/schemas/keybindings.schema.json` created

### Integration
- [ ] `GameWindow` KeyDown handler updated
- [ ] Service registered in DI container

### Testing
- [ ] ~8 unit tests implemented
- [ ] All tests passing

---

## 14. Acceptance Criteria

### Functional
- [ ] F1 opens shortcut overlay window
- [ ] Overlay displays all shortcuts grouped by context
- [ ] Any keypress closes the overlay
- [ ] Global shortcuts (F1, F5, F9, Escape) work in all contexts
- [ ] Game shortcuts (I, M, J, C, 1-9) work in Game context only
- [ ] Combat shortcuts (A, M, B, D, Space, Tab) work in Combat context only
- [ ] I key toggles inventory panel (when implemented)
- [ ] M key toggles map panel (when implemented)
- [ ] Custom keybindings persist across sessions
- [ ] Conflict detection prevents duplicate bindings in same context
- [ ] Reset to Defaults restores original bindings

### Quality
- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] ~8 unit tests pass
- [ ] XML documentation complete on all public types
- [ ] Configuration files validate against schemas

---

## 15. Dependencies

### Required from v0.8.0b
- Settings Window with Controls tab
- `ControlsSettingsTabViewModel` for keybinding display
- `KeybindingViewModel` model

### Required from v0.7.x
- `GameWindow` with KeyDown event support
- `BaseTheme` with style resources
- `NavigationService` for overlay management

### Provides to v0.9.0
- Full keyboard navigation foundation
- Shortcut overlay pattern
- Context-aware input handling

---

## 16. Future Considerations

### Deferred to v0.9.0
- **Keyboard-only Navigation**: Full tab-stop navigation
- **Focus Management**: Visible focus indicators
- **Arrow Key Navigation**: Menu and list traversal

### Deferred to Later Versions
- **Macro Recording**: Record and playback key sequences
- **Gamepad Support**: Controller button mappings
- **Accessibility Shortcuts**: Screen reader integration

### Out of Scope
- Voice commands
- Gesture recognition
- Multi-key chord sequences beyond modifier+key

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
