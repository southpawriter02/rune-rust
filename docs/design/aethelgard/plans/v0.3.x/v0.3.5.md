# v0.3.5: The HUD (Exploration View)

> **Status:** Planned
> **Milestone:** Milestone 4.5 - Interface Polish
> **Theme:** Persistent dashboard-style interface replacing the scrolling log

## Table of Contents
- [Overview](#overview)
- [Phase A: The Dashboard (Layout & Status)](#phase-a-the-dashboard-layout--status)
- [Phase B: The Cartographer (Minimap)](#phase-b-the-cartographer-minimap)
- [Phase C: The Surveyor (Room Rendering)](#phase-c-the-surveyor-room-rendering)
- [Testing Strategy](#testing-strategy)
- [Changelog (v0.3.5)](#changelog-v035)

## Overview

This milestone replaces the scrolling log of the early alpha with a persistent, dashboard-style interface. It uses `Spectre.Console.Layout` to maintain a static "Heads-Up Display" while updating content dynamically.

The HUD is implemented across three phases:

- **Phase A (v0.3.5a): The Dashboard** - Screen composition and persistent vitals
- **Phase B (v0.3.5b): The Cartographer** - Dynamic ASCII mapping and fog of war
- **Phase C (v0.3.5c): The Surveyor** - Rich text formatting and interaction highlighting

---

## Phase A: The Dashboard (Layout & Status)

**Goal:** Implement the `ExplorationLayout` engine and `StatusBar` widget to create a persistent, three-pane interface (Header, Body, Footer) that updates dynamically based on `GameState`.

### 1. Architecture & Data Flow

The UI architecture shifts from a linear "Print & Scroll" model to a State-Driven Rendering model.

**Components:**

- **ExplorationScreenRenderer:** The orchestrator. Holds the root Layout object.
- **StatusWidget:** Logic for converting Entity Stats (HP/Stamina) into UI Bars (Spectre ProgressBar or colored text).
- **MessageLogWidget:** A rolling buffer of the last N game messages to display in the footer.

**Data Flow:**

1. **Game Loop Trigger:** `GameService` calls `_renderer.Render(GameState)` at the start of the Input loop.
2. **State Extraction:** Renderer extracts `Player` (for Status) and `CurrentRoom` (for Header context).
3. **Widget Update:**
   - `StatusWidget` recalculates Bar width/color based on `CurrentHP / MaxHP`.
   - `MessageLogWidget` formats the recent event history.
4. **Composition:** Widgets are injected into specific Layout regions ("Header", "Footer").
5. **Draw:** `AnsiConsole.Write(rootLayout)` renders the complete frame.

### 2. Logic Decision Trees

#### A. Status Bar Coloring Logic

**Input:** ResourceType, Current, Max

1. **Calculate Percentage:** `Pct = (Current / Max) * 100`.
2. **Determine Color:**
   - **If HP:**
     - \> 75% → Green (Stable)
     - 50% - 75% → Yellow (Wounded)
     - 25% - 49% → Orange (Danger)
     - < 25% → Red (Critical/Pulse)
   - **If Stamina:**
     - \> 20% → Cyan (Active)
     - < 20% → Grey (Exhausted/Dim)
   - **If Stress:**
     - < 50% → Grey (Stable)
     - \> 80% → Purple (Fractured)
3. **Determine Label:**
   - Format string: `"{Value}/{Max} ({Percentage}%)"`

#### B. Layout Responsiveness Logic

**Input:** `Console.WindowWidth`

1. **Check Width:**
   - \> 120 chars: Use Wide Mode (Sidebar visible, Main panel expands).
   - < 120 chars: Use Compact Mode (Hide Sidebar/Minimap, stack info in Header).
2. **Adjust Ratios:**
   - Header: Fixed height (3 rows).
   - Footer: Fixed height (1 row input + 5 rows log).
   - Body: Remaining height.

### 3. Code Implementation

**File:** `RuneAndRust.Terminal/Services/ExplorationScreenRenderer.cs`

```csharp
using Spectre.Console;
using RuneAndRust.Core.Models;
using RuneAndRust.Core.Entities;

public class ExplorationScreenRenderer : IExplorationScreenRenderer
{
    private Layout _rootLayout;

    public ExplorationScreenRenderer()
    {
        _rootLayout = new Layout("Root")
            .SplitRows(
                new Layout("Header").Size(3),
                new Layout("Body").SplitColumns(
                    new Layout("Main").Ratio(7),
                    new Layout("Sidebar").Ratio(3)
                ),
                new Layout("Footer").Size(8)
            );
    }

    public void Render(GameState state)
    {
        _rootLayout["Header"].Update(CreateStatusBar(state.CurrentCharacter));

        var roomPanel = new Panel(state.CurrentRoom?.Description ?? "Unknown Location")
            .Header(state.CurrentRoom?.Name ?? "Void")
            .Border(BoxBorder.Rounded);
        _rootLayout["Main"].Update(roomPanel);

        AnsiConsole.Clear();
        AnsiConsole.Write(_rootLayout);
    }

    private Panel CreateStatusBar(Character player)
    {
        if (player == null) return new Panel("No Character Data");

        var hpColor = GetResourceColor(player.CurrentHp, player.MaxHp, isHealth: true);
        var stamColor = GetResourceColor(player.CurrentStamina, player.MaxStamina, isHealth: false);

        var grid = new Grid();
        grid.AddColumn(new GridColumn().NoWrap().PadRight(4));
        grid.AddColumn(new GridColumn().Width(20));
        grid.AddColumn(new GridColumn().Width(20));
        grid.AddColumn(new GridColumn().Width(20));

        grid.AddRow(
            new Text(player.Name, new Style(Color.Gold1, decoration: Decoration.Bold)),
            new ProgressBar() { Value = GetPct(player.CurrentHp, player.MaxHp), Color = hpColor },
            new ProgressBar() { Value = GetPct(player.CurrentStamina, player.MaxStamina), Color = stamColor },
            new Markup($"[purple]Stress: {player.PsychicStress}%[/]")
        );

        return new Panel(grid).Border(BoxBorder.None);
    }

    private double GetPct(int cur, int max) => max == 0 ? 0 : (double)cur / max * 100;

    private Color GetResourceColor(int cur, int max, bool isHealth)
    {
        var pct = GetPct(cur, max);
        if (isHealth)
        {
            if (pct <= 25) return Color.Red1;
            if (pct <= 50) return Color.Orange1;
            return Color.Green;
        }
        return pct < 20 ? Color.Grey : Color.Cyan1;
    }
}
```

**File:** `RuneAndRust.Engine/Services/GameService.cs` (Update)

```csharp
while (_state.Phase != GamePhase.Quit)
{
    if (_state.Phase == GamePhase.Exploration)
    {
        _explorationRenderer.Render(_state);
    }

    var input = _inputHandler.GetInput("Command");
}
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| RenderFrame | Trace | "Rendered Exploration UI. HP: {HP}/{MaxHP}" | HP, MaxHP |
| Resize | Info | "Terminal resized to {W}x{H}. Layout recalculated." | W, H |
| PhaseRender | Debug | "Rendering layout for Phase: {Phase}" | Phase |

### 5. Testing Requirements

**Unit Tests (ExplorationRendererTests.cs)**

- **Color Logic:**
  - `GetResourceColor_HealthCritical_ReturnsRed`: Input 10/100 → Assert `Color.Red1`.
  - `GetResourceColor_HealthHealthy_ReturnsGreen`: Input 90/100 → Assert `Color.Green`.
  - `GetResourceColor_StaminaExhausted_ReturnsGrey`: Input 0/50 → Assert `Color.Grey`.
- **Layout Construction:**
  - `Constructor_CreatesRootLayout`: Verify `_rootLayout` is not null.
  - `Render_NullCharacter_DoesNotThrow`: Verify robustness against null state.

**Visual QA (Manual)**

- **Resize Check:** Resize terminal window while game is running. Ensure bars resize dynamically without crashing.
- **Color Check:** Use debug commands to set HP to 1. Verify bar turns red.

### 6. Deliverable Checklist (Phase A)

- **Terminal:**
  - [ ] Implement `IExplorationScreenRenderer`.
  - [ ] Implement `ExplorationScreenRenderer` with Layout.
  - [ ] Implement `CreateStatusBar` with percentage logic.
  - [ ] Integrate Spectre.Console ProgressBar widget (or custom ASCII bar).
- **Engine:**
  - [ ] Inject `IExplorationScreenRenderer` into `GameService`.
  - [ ] Call `Render()` before `GetInput()` in the game loop.
- **Tests:**
  - [ ] Add unit tests for color/percentage logic.

---

## Phase B: The Cartographer (Minimap)

**Goal:** Implement the `MinimapWidget` to render a 3x3 or 5x5 grid of rooms relative to the player, handling Z-level context, Fog of War (FOW), and special room symbols (Stairs, Bosses, Settlements).

### 1. Architecture & Data Flow

The Minimap is a read-only visualization component driven by `GameState` and `IRoomRepository`.

**Components:**

- **MinimapRenderer:** Stateless helper class within the Terminal layer.
- **GameState Extension:** Needs to track `VisitedRoomIds` (HashSet) for FOW.
- **IRoomRepository Extension:** Efficient batch query for grid coordinates.

**Workflow:**

1. **Render Trigger:** `ExplorationScreenRenderer` calls `MinimapRenderer.Render(state)`.
2. **Context Building:**
   - Get Player Position (Px, Py, Pz).
   - Calculate grid bounds (e.g., X: [Px-1, Px+1], Y: [Py-1, Py+1]).
3. **Data Fetch:** Batch query `RoomRepository` for all rooms within bounds at Z == Pz.
4. **Grid Composition:**
   - Iterate grid coordinates Top-Left to Bottom-Right.
   - Symbol Resolution: Determine char based on Room Type + Visited Status.
   - Style Resolution: Determine color (Current = Cyan, Danger = Red, Visited = Grey).
5. **Output:** Return `Spectre.Console.Panel` containing the grid.

### 2. Logic Decision Trees

#### A. Tile Resolution Logic (Per Coordinate)

**Input:** Coordinate (Tx, Ty), PlayerPos, RoomData, VisitedList

1. **Is Player Position?** (Tx == Px && Ty == Py)
   - Yes: Return `@` (Cyan, Bold).
2. **Does Room Exist in DB?**
   - No: Return ` ` (Empty Space).
3. **Is Room Visited?** (Id in VisitedList)
   - No: Return `░` (Dim Grey - Fog).
4. **Room Type Check:**
   - Start/Settlement: Return `⌂` (Blue).
   - Boss Arena: Return `☠` (Red).
   - Stairs Up: Return `▲` (White).
   - Stairs Down: Return `▼` (White).
   - Standard: Return `O` (Grey).

### 3. Code Implementation

**File:** `RuneAndRust.Core/Models/GameState.cs`

```csharp
public class GameState
{
    // ... existing properties

    public HashSet<Guid> VisitedRoomIds { get; set; } = new();
}
```

**File:** `RuneAndRust.Core/Interfaces/IRoomRepository.cs`

```csharp
Task<IEnumerable<Room>> GetRoomsInGridAsync(int z, int minX, int maxX, int minY, int maxY);
```

**File:** `RuneAndRust.Terminal/Rendering/MinimapRenderer.cs`

```csharp
using Spectre.Console;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.ValueObjects;

public class MinimapRenderer
{
    private const int Radius = 1;

    public Panel Render(Coordinate center, List<Room> localMap, HashSet<Guid> visited)
    {
        var grid = new Grid();
        for (int i = 0; i < (Radius * 2) + 1; i++) grid.AddColumn();

        for (int y = center.Y + Radius; y >= center.Y - Radius; y--)
        {
            var rowItems = new List<IRenderable>();

            for (int x = center.X - Radius; x <= center.X + Radius; x++)
            {
                var room = localMap.FirstOrDefault(r => r.Position.X == x && r.Position.Y == y);
                rowItems.Add(ResolveTile(room, center, new Coordinate(x, y, center.Z), visited));
            }

            grid.AddRow(rowItems.ToArray());
        }

        return new Panel(grid).Header("[yellow]Sector Map[/]").Border(BoxBorder.Rounded);
    }

    private Markup ResolveTile(Room? room, Coordinate playerPos, Coordinate currentPos, HashSet<Guid> visited)
    {
        if (currentPos == playerPos) return new Markup("[cyan bold]@[/]");
        if (room == null) return new Markup("[grey15]·[/]");
        if (!visited.Contains(room.Id)) return new Markup("[grey30]░[/]");
        if (room.IsStartingRoom) return new Markup("[blue]⌂[/]");
        if (room.HasFeature(RoomFeature.RunicAnchor)) return new Markup("[gold1]♦[/]");

        bool hasUp = room.Exits.ContainsKey(Direction.Up);
        bool hasDown = room.Exits.ContainsKey(Direction.Down);

        if (hasUp && hasDown) return new Markup("[white]↕[/]");
        if (hasUp) return new Markup("[white]▲[/]");
        if (hasDown) return new Markup("[white]▼[/]");

        return new Markup("[grey]O[/]");
    }
}
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Render | Trace | "Rendering minimap centered at {Coords}. Fetched {Count} rooms." | Coords, Count |
| Visited | Debug | "Added Room {RoomId} to Visited List." | RoomId |
| Bounds | Trace | "Map Bounds: X[{MinX},{MaxX}] Y[{MinY},{MaxY}]" | MinX, MaxX... |

### 5. Testing Requirements

**Unit Tests (MinimapRendererTests.cs)**

- **Symbol_Priorities:**
  - `Render_PlayerAtHome_ShowsAtSymbol`: Player position overrides Room symbol.
  - `Render_UnvisitedBoss_ShowsFog`: Unvisited flag overrides Boss symbol.
- **Grid_Alignment:**
  - `Render_3x3_CenterIsPlayer`: Verify grid rows/cols index mapping.
  - `Render_YAxis_Inverted`: Ensure Y+ is rendered at the top of the grid (index 0).

**Integration Tests**

- **Fog_Persistence:**
  - Move N → Move S. Verify Room N is still visible (not fogged) in minimap.
- **Verticality:**
  - Move Up to Z+1. Verify minimap refreshes to show Z+1 rooms, not Z0 rooms.

### 6. Deliverable Checklist (Phase B)

- **Core:**
  - [ ] Add `VisitedRoomIds` to `GameState` model.
  - [ ] Update `GameState.Reset()` to clear visited list.
  - [ ] Add `GetRoomsInGridAsync` to `IRoomRepository`.
- **Engine:**
  - [ ] Update `NavigationService.MoveAsync` to add `nextRoom.Id` to `VisitedRoomIds`.
- **Terminal:**
  - [ ] Implement `MinimapRenderer`.
  - [ ] Integrate into `ExplorationScreenRenderer` (replace placeholder).
- **Visuals:**
  - [ ] Verify ASCII symbols work in target terminal (Windows Terminal/VS Code).

---

## Phase C: The Surveyor (Room Rendering)

**Goal:** Implement the `RoomRenderer` to generate a formatted visual representation of the current location, including dynamic descriptions, highlighted interactables, and entity lists.

### 1. Architecture & Data Flow

The `RoomRenderer` acts as a compositor, aggregating data from multiple services into a single UI panel.

**Components:**

- **RoomRenderer:** Terminal service responsible for building the central panel.
- **ExplorationViewModel Extension:** Updated to hold lists of visible entities.
- **GameService:** Orchestrates data fetching (Room, Objects, Enemies).

**Workflow:**

1. **State Refresh:** `GameService.BuildExplorationViewModelAsync` is called.
2. **Data Gathering:**
   - Fetch Room entity (Name, Description, Biome).
   - Fetch `InteractableObject` list for the room via `IInteractionService`.
   - Fetch Enemy list (if any) via `ICombatService`.
3. **ViewModel Population:** Lists are mapped to `ExplorationViewModel`.
4. **Rendering:** `ExplorationScreenRenderer` passes the VM to `RoomRenderer`.
5. **Composition:** `RoomRenderer` builds a Spectre Panel containing:
   - Header: Room Name (Colored by Biome).
   - Body: Flavor text (Grey/White).
   - Object List: Interactables (Gold/Cyan).
   - Entity List: Enemies (Red) or NPCs (Green).
   - Exits: Available directions (White).

### 2. Logic Decision Trees

#### A. Color Coding Logic

**Input:** Entity Type

1. **Enemy:** → Red (`[red]`) - Threat.
2. **Container/Loot:** → Gold (`[gold1]`) - Reward.
3. **Machinery/Device:** → Cyan (`[cyan]`) - Interaction.
4. **NPC:** → Green (`[green]`) - Social.
5. **Hazard:** → Orange (`[orange1]`) - Danger.
6. **Exit:** → White (`[bold white]`) - Navigation.

#### B. Entity List Formatting

**Input:** List of Objects

1. **Group by Type:** Separate Enemies from Objects.
2. **Format Objects:**
   - If Container: Show state (e.g., "Iron Chest (Open)").
   - If Examined: Show checkmark or detail level (e.g., "Console [Examined]").
3. **Format Enemies:**
   - If Alive: Show Name + Condition (e.g., "Rusted Servitor [Wounded]").
   - If Dead: Show "Corpse of..." (moved to Object list).

### 3. Code Implementation

**File:** `RuneAndRust.Core/ViewModels/ExplorationViewModel.cs`

```csharp
public record ExplorationViewModel(
    string RoomName,
    string RoomDescription,
    string BiomeColor,
    List<string> VisibleObjects,
    List<string> VisibleEnemies,
    List<string> Exits
);
```

**File:** `RuneAndRust.Terminal/Rendering/RoomRenderer.cs`

```csharp
using Spectre.Console;
using RuneAndRust.Core.ViewModels;

public static class RoomRenderer
{
    public static Panel Render(ExplorationViewModel vm)
    {
        var grid = new Grid().AddColumn();

        grid.AddRow(new Markup($"[{vm.BiomeColor}]{Markup.Escape(vm.RoomDescription)}[/]"));
        grid.AddRow(new Text(""));

        if (vm.VisibleEnemies.Any())
        {
            grid.AddRow(new Rule("[red]Threats[/]").LeftJustified());
            foreach (var enemy in vm.VisibleEnemies)
            {
                grid.AddRow(new Markup($" [red]![/] {enemy}"));
            }
            grid.AddRow(new Text(""));
        }

        if (vm.VisibleObjects.Any())
        {
            grid.AddRow(new Rule("[gold1]Visible Objects[/]").LeftJustified());
            foreach (var obj in vm.VisibleObjects)
            {
                grid.AddRow(new Markup($" [gold1]♦[/] {obj}"));
            }
            grid.AddRow(new Text(""));
        }

        var exitStr = string.Join("  ", vm.Exits.Select(e => $"[bold white][[{e}]][/]"));
        grid.AddRow(new Markup($"[grey]Exits:[/] {exitStr}"));

        return new Panel(grid)
            .Header($"[bold {vm.BiomeColor}]{Markup.Escape(vm.RoomName)}[/]")
            .Border(BoxBorder.Rounded)
            .Expand();
    }
}
```

**File:** `RuneAndRust.Engine/Services/GameService.cs` (Update)

```csharp
var objects = await _interactionService.GetVisibleObjectsAsync(room.Id);
var enemies = await _combatService.GetEnemiesInRoomAsync(room.Id);

var objectList = objects.Select(o =>
    o.IsContainer ? $"[gold1]{o.Name}[/]" : $"[cyan]{o.Name}[/]"
).ToList();

var enemyList = enemies.Select(e =>
    $"[red]{e.Name}[/] [grey]({e.HealthStatus})[/]"
).ToList();

string biomeColor = room.BiomeType switch {
    BiomeType.Industrial => "orange1",
    BiomeType.Organic => "green",
    BiomeType.Void => "purple",
    _ => "grey"
};
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Render | Trace | "Rendered room view: {Name} ({ObjCount} objects, {EnemyCount} enemies)." | Name, ObjCount, EnemyCount |
| ViewModel | Debug | "Building RoomView for RoomId {Id}. Found {Objs} objects." | Id, Objs |

### 5. Testing Requirements

**Unit Tests (RoomRendererTests.cs)**

- **Formatting:**
  - `Render_HighlightsEnemies_InRed`: Verify markup contains `[red]`.
  - `Render_HighlightsLoot_InGold`: Verify markup contains `[gold1]`.
  - `Render_DisplaysExits`: Verify exits string is formatted correctly.
- **Layout:**
  - `Render_EmptyRoom_ShowsDescriptionOnly`: Verify panels don't appear if lists are empty.
  - `Render_BiomeColor_AppliedToHeader`: Verify header matches input color.

**Integration Tests**

- **Dynamic Update:**
  - Action: `take iron-sword`.
  - Verify: Next Render cycle does not include "Iron Sword" in the Visible Objects list.
- **Death Update:**
  - Action: Kill enemy.
  - Verify: Enemy moves from "Threats" list to "Objects" list (as Corpse).

### 6. Deliverable Checklist (Phase C)

- **Core:**
  - [ ] Update `ExplorationViewModel` with list properties.
  - [ ] Update Room or InteractionService to return Biome data.
- **Terminal:**
  - [ ] Implement `RoomRenderer` class.
  - [ ] Integrate into `ExplorationScreenRenderer["Main"]`.
- **Engine:**
  - [ ] Update `GameService` to populate the new ViewModel lists.
  - [ ] Implement logic to format object strings (e.g., adding "(Open)" status).

---

## Testing Strategy

### Unit Tests

- **ExplorationRendererTests.cs:** Color logic, layout construction
- **MinimapRendererTests.cs:** Symbol priorities, grid alignment
- **RoomRendererTests.cs:** Formatting, entity highlighting

### Integration Tests

- **Full_Render_Cycle:** Run one full render pass with mocked GameState
- **Fog_Persistence:** Verify visited rooms remain visible
- **Dynamic Updates:** Verify UI reflects game state changes

---

## Changelog (v0.3.5)

**Release Date:** 2025-XX-XX

### Summary

Exploration has evolved. The "Heads-Up Display" update introduces a persistent dashboard layout. Players can now see their health, stamina, and location at a glance, along with a real-time minimap that tracks exploration progress.

### Features

- **Dashboard Layout:**
  - Top bar tracks HP, Stamina, and Stress in real-time.
  - Message log is now separated from the room view.
- **The Cartographer (Minimap):**
  - 3x3 Grid displays immediate surroundings.
  - Fog of War hides unvisited rooms.
  - Tracks "Up/Down" stairs.
- **Rich Room View:**
  - Interactable objects are now highlighted in the room description.
  - Separate list of visible items/enemies displayed below the description.
  - Biome-colored room headers and descriptions.

### Technical

- Implemented `Spectre.Console.Layout` for multi-pane rendering.
- Added `MinimapRenderer` with Fog of War logic.
- Created `RoomRenderer` for entity highlighting.
