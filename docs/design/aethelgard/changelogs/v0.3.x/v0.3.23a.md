# Changelog: v0.3.23a - The Gatekeeper (Input Abstraction)

**Version:** v0.3.23a
**Release Date:** 2025-12-27
**Total Tests:** 53 new tests
**Test Results:** All passing

---

## Table of Contents

- [Overview](#overview)
- [Key Metrics](#key-metrics)
- [Architecture Summary](#architecture-summary)
  - [Input Pipeline Diagram](#input-pipeline-diagram)
  - [Event Hierarchy](#event-hierarchy)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
  - [InputEvent Record Hierarchy](#inputevent-record-hierarchy)
  - [IInputService Interface](#iinputservice-interface)
  - [InputService Implementation](#inputservice-implementation)
  - [CommandToActionMapper Helper](#commandtoactionmapper-helper)
- [Consumer Refactoring Patterns](#consumer-refactoring-patterns)
  - [Pattern A: Blocking Modal Loop](#pattern-a-blocking-modal-loop)
  - [Pattern B: Non-Blocking Polling](#pattern-b-non-blocking-polling)
  - [Pattern C: Text Input](#pattern-c-text-input)
  - [Pattern D: Skip Detection](#pattern-d-skip-detection)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After Release](#directory-structure-after-release)
- [Architecture Decisions](#architecture-decisions)
- [Running Tests](#running-tests)
- [Console.ReadKey() Migration Map](#consolereadkey-migration-map)
- [Bugfixes (Pre-existing Issues)](#bugfixes-pre-existing-issues)
- [Next Steps](#next-steps)

---

## Overview

v0.3.23a "The Gatekeeper" introduces the first phase of the Input Refactoring milestone, establishing a centralized input abstraction layer that decouples game logic from raw `Console.ReadKey()` calls. This release replaces all 9 hardcoded console input locations with a standardized `IInputService` that converts keyboard input into semantic `InputEvent` objects mapped to the existing `GameAction` enum (introduced in v0.3.9c).

**Key Achievements:**
- Created `InputEvent` record hierarchy with `ActionEvent`, `RawKeyEvent`, `SystemEvent`, and `MouseEvent` subtypes
- Implemented `IInputService` interface with blocking and non-blocking input methods
- Built `CommandToActionMapper` to translate command strings ("north", "attack") to `GameAction` enum values
- Integrated with existing `IInputConfigurationService` for key binding lookup
- Refactored 4 consumer classes: `OptionsController`, `CreationWizard`, `DebugConsoleRenderer`, `TypewriterRenderer`

**Foundation For:**
- Key rebinding (already configured via `IInputConfigurationService`)
- Future macro support (v0.3.23b)
- GUI integration pathway (v0.3.23c)
- Testable input handling with mockable `IInputService`

---

## Key Metrics

| Metric | Value |
|--------|-------|
| New Files | 5 |
| Modified Files | 8 |
| New Unit Tests | 53 |
| Test Pass Rate | 100% |
| Console.ReadKey() Calls Replaced | 9 |
| New Lines (Services) | ~250 |
| New Lines (Tests) | ~200 |

---

## Architecture Summary

### Input Pipeline Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        INPUT PIPELINE                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  [Console.ReadKey()] ─────► [IInputService.ReadNext()]              │
│         │                            │                               │
│         ▼                            ▼                               │
│  ConsoleKeyInfo              ┌─────────────────┐                    │
│         │                    │ IInputConfig    │                    │
│         │                    │ Service         │                    │
│         │                    │ GetCommandFor   │                    │
│         │                    │ Key()           │                    │
│         │                    └────────┬────────┘                    │
│         │                             │                              │
│         ▼                             ▼                              │
│  ┌──────────────────────────────────────────────────────┐           │
│  │              INPUT EVENT RESOLUTION                   │           │
│  ├──────────────────────────────────────────────────────┤           │
│  │ 1. Is Global Hotkey? (~ for Debug Console)           │           │
│  │    ├─ Yes → SystemEvent(ToggleDebugConsole)          │           │
│  │    └─ No  → Continue                                  │           │
│  │                                                       │           │
│  │ 2. Is Key Mapped? (via IInputConfigurationService)   │           │
│  │    ├─ Yes → Parse command string to GameAction       │           │
│  │    │        └─ Success → ActionEvent(GameAction)     │           │
│  │    │        └─ Fail    → RawKeyEvent(key)            │           │
│  │    └─ No  → RawKeyEvent(key)                         │           │
│  └──────────────────────────────────────────────────────┘           │
│                              │                                       │
│                              ▼                                       │
│                       [InputEvent]                                   │
│                    ┌─────────┼─────────┐                            │
│                    ▼         ▼         ▼                            │
│             ActionEvent  RawKeyEvent  SystemEvent                   │
│             (GameAction) (KeyInfo)    (EventType)                   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### Event Hierarchy

```
InputEvent (abstract record)
├── ActionEvent(GameAction Action)     // Semantic game action (MoveNorth, Confirm, etc.)
│   └── SourceKey: ConsoleKey?         // Original key for debugging/rebind UI
├── RawKeyEvent(ConsoleKeyInfo KeyInfo) // Unmapped key for text input
│   ├── Character: char                // Printable character
│   └── IsPrintable: bool              // True if not control character
├── SystemEvent(SystemEventType)       // System-level events
│   └── ToggleDebugConsole             // Tilde (~) key
│   └── Screenshot                     // Future
└── MouseEvent(int X, int Y, bool IsLeftClick)  // v0.3.23c preparation
```

---

## New Files Created

### Core Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Core/Models/Input/InputEvent.cs` | Base record hierarchy defining all input event types with timestamp tracking. Includes `ActionEvent`, `RawKeyEvent`, `SystemEvent`, `MouseEvent` subtypes and `SystemEventType` enum. | 78 |
| `RuneAndRust.Core/Interfaces/IInputService.cs` | Input abstraction interface with blocking (`ReadNext`, `ReadNextFiltered`) and non-blocking (`IsInputAvailable`, `TryReadNext`) methods plus `ClearInputBuffer` for screen transitions. | 49 |

### Engine Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Engine/Services/InputService.cs` | Implementation of IInputService integrating with IInputConfigurationService for key binding resolution. Contains `ResolveKeyToEvent` logic and `DrainEscapeSequence` for mouse event filtering. | 157 |
| `RuneAndRust.Engine/Helpers/CommandToActionMapper.cs` | Static utility mapping 21 command strings to GameAction enum values with case-insensitive lookup. Provides `TryMapCommand` and `GetAllMappings` methods. | 65 |

### Test Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Tests/Engine/InputServiceTests.cs` | Unit tests for InputService behavior including event record construction, console integration verification, and IInputConfigurationService mock validation. 20 tests. | ~150 |
| `RuneAndRust.Tests/Engine/CommandToActionMapperTests.cs` | Unit tests for CommandToActionMapper covering all 21 command mappings, case insensitivity, invalid input handling, and GetAllMappings enumeration. 33 tests. | ~100 |

---

## Files Modified

| File | Change Summary |
|------|----------------|
| `RuneAndRust.Terminal/Program.cs` | Added DI registration for `IInputService` as Singleton after `IInputConfigurationService` (line 184). |
| `RuneAndRust.Terminal/Services/OptionsController.cs` | Injected `IInputService`, refactored `RunAsync()` main loop from `Console.ReadKey()` to `_inputService.ReadNext()` with pattern matching on `ActionEvent`/`RawKeyEvent`. Updated `HandleRebind()` to extract key info from `InputEvent`. Added `using RuneAndRust.Core.Models.Input`. |
| `RuneAndRust.Terminal/Services/CreationWizard.cs` | Injected `IInputService`, refactored `RunSelectionStepAsync<T>()` and `RunSimpleSelectionStepAsync<T>()` from `Console.KeyAvailable`/`Console.ReadKey()` to `_inputService.TryReadNext()` with pattern matching. Added `using RuneAndRust.Core.Models.Input`. |
| `RuneAndRust.Terminal/Rendering/DebugConsoleRenderer.cs` | Injected `IInputService`, refactored `Run()` modal loop from `Console.ReadKey()` to `_inputService.ReadNext()`. Added `SystemEvent` handling for tilde key toggle. Added `using RuneAndRust.Core.Models.Input`. |
| `RuneAndRust.Terminal/Rendering/TypewriterRenderer.cs` | Injected `IInputService`, refactored `PlaySequenceAsync()` from `Console.KeyAvailable`/`Console.ReadKey()` to `_inputService.IsInputAvailable()`/`ReadNext()`. Replaced `ConsoleInputHelper.WaitForKeyPress()` with `_inputService.ReadNext()`. |
| `RuneAndRust.Core/Interfaces/IInventoryService.cs` | Fixed pre-existing interface mismatch: removed `context` parameter from 6 method signatures to match implementation. |
| `RuneAndRust.Engine/Services/InventoryService.cs` | Fixed pre-existing implementation: changed `context` from parameter to local constant in 6 methods to match interface. |
| `RuneAndRust.Tests/Engine/SaveManagerSerializationTests.cs` | Fixed pre-existing test: added `Mock<IRoomRepository>` to constructor call to match updated `SaveManager` signature. |

---

## Code Implementation Details

### InputEvent Record Hierarchy

**File:** `RuneAndRust.Core/Models/Input/InputEvent.cs`

```csharp
namespace RuneAndRust.Core.Models.Input;

using RuneAndRust.Core.Enums;

/// <summary>
/// Base record for all input events in the system.
/// </summary>
public abstract record InputEvent
{
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Represents a semantic game action (e.g., MoveNorth, Attack, Confirm).
/// </summary>
public record ActionEvent(GameAction Action) : InputEvent
{
    public ConsoleKey? SourceKey { get; init; }
}

/// <summary>
/// Represents a raw key press that wasn't mapped to an action.
/// </summary>
public record RawKeyEvent(ConsoleKeyInfo KeyInfo) : InputEvent
{
    public char Character => KeyInfo.KeyChar;
    public bool IsPrintable => !char.IsControl(KeyInfo.KeyChar);
}

/// <summary>
/// Represents a system-level event (debug console toggle, screenshot, etc.).
/// </summary>
public record SystemEvent(SystemEventType EventType) : InputEvent;

public enum SystemEventType
{
    ToggleDebugConsole,
    Screenshot
}

/// <summary>
/// Represents a mouse interaction (v0.3.23c preparation).
/// </summary>
public record MouseEvent(int X, int Y, bool IsLeftClick) : InputEvent;
```

**Design Notes:**
- `record` types provide value equality and immutability
- `Timestamp` enables input latency tracking and replay systems
- `SourceKey` on `ActionEvent` preserves original key for rebind UI display
- `IsPrintable` helper simplifies text input handling

---

### IInputService Interface

**File:** `RuneAndRust.Core/Interfaces/IInputService.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

using RuneAndRust.Core.Models.Input;

public interface IInputService
{
    /// <summary>Reads the next input event, blocking until input is available.</summary>
    InputEvent ReadNext();

    /// <summary>Reads input with mouse escape sequence filtering.</summary>
    InputEvent ReadNextFiltered(bool filterMouseEvents = true);

    /// <summary>Checks if input is available without blocking.</summary>
    bool IsInputAvailable();

    /// <summary>Attempts to read input without blocking.</summary>
    bool TryReadNext(out InputEvent? inputEvent);

    /// <summary>Clears any pending input from the buffer.</summary>
    void ClearInputBuffer();
}
```

**Method Purposes:**
| Method | Use Case |
|--------|----------|
| `ReadNext()` | Blocking modal loops (OptionsController, DebugConsoleRenderer) |
| `ReadNextFiltered()` | Mouse-enabled contexts requiring escape sequence filtering |
| `IsInputAvailable()` | Skip detection (TypewriterRenderer) |
| `TryReadNext()` | Non-blocking polling in async loops (CreationWizard) |
| `ClearInputBuffer()` | Screen transitions to prevent input bleed |

---

### InputService Implementation

**File:** `RuneAndRust.Engine/Services/InputService.cs`

**Constants:**
```csharp
private const ConsoleKey DebugConsoleKey = ConsoleKey.Oem3; // Tilde (~)
```

**Key Resolution Logic:**
```csharp
private InputEvent ResolveKeyToEvent(ConsoleKeyInfo keyInfo)
{
    // 1. Check for system-level hotkeys
    if (keyInfo.Key == DebugConsoleKey)
    {
        _logger.LogTrace("[Input] System event: ToggleDebugConsole");
        return new SystemEvent(SystemEventType.ToggleDebugConsole);
    }

    // 2. Check for mapped actions via IInputConfigurationService
    var command = _config.GetCommandForKey(keyInfo.Key);

    if (command != null && CommandToActionMapper.TryMapCommand(command, out var action))
    {
        _logger.LogTrace("[Input] Mapped {Key} -> {Command} -> {Action}",
            keyInfo.Key, command, action);
        return new ActionEvent(action) { SourceKey = keyInfo.Key };
    }

    // 3. Fallback to raw key event
    _logger.LogTrace("[Input] Raw key: {Key} ('{Char}')",
        keyInfo.Key,
        char.IsControl(keyInfo.KeyChar) ? "\\0" : keyInfo.KeyChar.ToString());
    return new RawKeyEvent(keyInfo);
}
```

**Mouse Escape Sequence Filtering:**
```csharp
private void DrainEscapeSequence()
{
    Thread.Sleep(10); // Allow escape sequence to arrive
    while (Console.KeyAvailable)
    {
        Console.ReadKey(intercept: true);
    }
}
```

---

### CommandToActionMapper Helper

**File:** `RuneAndRust.Engine/Helpers/CommandToActionMapper.cs`

**Command Mapping Table (21 entries):**

| Category | Commands | GameAction Values |
|----------|----------|-------------------|
| Movement (6) | north, south, east, west, up, down | MoveNorth, MoveSouth, MoveEast, MoveWest, MoveUp, MoveDown |
| Core (4) | confirm, cancel, menu, help | Confirm, Cancel, Menu, Help |
| Navigation (4) | inventory, character, journal, bench | Inventory, Character, Journal, Crafting |
| Gameplay (4) | interact, look, search, wait | Interact, Look, Search, Wait |
| Combat (3) | attack, light, heavy | Attack, LightAttack, HeavyAttack |

**Implementation:**
```csharp
private static readonly Dictionary<string, GameAction> CommandMap =
    new(StringComparer.OrdinalIgnoreCase)
{
    { "north", GameAction.MoveNorth },
    { "south", GameAction.MoveSouth },
    // ... 19 more entries
};

public static bool TryMapCommand(string command, out GameAction action)
{
    return CommandMap.TryGetValue(command, out action);
}

public static IReadOnlyDictionary<string, GameAction> GetAllMappings() => CommandMap;
```

---

## Consumer Refactoring Patterns

### Pattern A: Blocking Modal Loop

**Used by:** `OptionsController.RunAsync()`, `DebugConsoleRenderer.Run()`

**Before:**
```csharp
var key = Console.ReadKey(intercept: true);
switch (key.Key)
{
    case ConsoleKey.UpArrow:
    case ConsoleKey.K:
        NavigateUp(vm);
        break;
    case ConsoleKey.Enter:
        HandleConfirm(vm);
        break;
    case ConsoleKey.Escape:
        return;
}
```

**After:**
```csharp
var inputEvent = _inputService.ReadNext();
switch (inputEvent)
{
    case ActionEvent { Action: GameAction.MoveNorth }:
        NavigateUp(vm);
        break;
    case ActionEvent { Action: GameAction.Confirm }:
        HandleConfirm(vm);
        break;
    case ActionEvent { Action: GameAction.Cancel }:
        return;

    // Raw key fallback for vim-style navigation
    case RawKeyEvent { KeyInfo.Key: ConsoleKey.UpArrow or ConsoleKey.K }:
        NavigateUp(vm);
        break;
    case RawKeyEvent { KeyInfo.Key: ConsoleKey.Enter }:
        HandleConfirm(vm);
        break;
    case RawKeyEvent { KeyInfo.Key: ConsoleKey.Escape }:
        return;
}
```

---

### Pattern B: Non-Blocking Polling

**Used by:** `CreationWizard.RunSelectionStepAsync<T>()`, `CreationWizard.RunSimpleSelectionStepAsync<T>()`

**Before:**
```csharp
if (Console.KeyAvailable)
{
    var key = Console.ReadKey(intercept: true);
    switch (key.Key)
    {
        case ConsoleKey.UpArrow:
            _selectedIndex = Math.Max(0, _selectedIndex - 1);
            break;
        // ...
    }
}
await Task.Delay(16); // ~60fps refresh
```

**After:**
```csharp
if (_inputService.TryReadNext(out var inputEvent))
{
    switch (inputEvent)
    {
        case ActionEvent { Action: GameAction.MoveNorth }:
            _selectedIndex = Math.Max(0, _selectedIndex - 1);
            break;
        case RawKeyEvent { KeyInfo.Key: ConsoleKey.UpArrow or ConsoleKey.K }:
            _selectedIndex = Math.Max(0, _selectedIndex - 1);
            break;
        // ...
    }
}
await Task.Delay(16); // ~60fps refresh
```

---

### Pattern C: Text Input

**Used by:** `DebugConsoleRenderer.Run()`

**Before:**
```csharp
default:
    if (!char.IsControl(key.KeyChar))
    {
        inputBuffer += key.KeyChar;
    }
    break;
```

**After:**
```csharp
case RawKeyEvent rawKey:
    switch (rawKey.KeyInfo.Key)
    {
        case ConsoleKey.Backspace:
            if (inputBuffer.Length > 0)
                inputBuffer = inputBuffer[..^1];
            break;
        default:
            if (rawKey.IsPrintable)
                inputBuffer += rawKey.Character;
            break;
    }
    break;
```

---

### Pattern D: Skip Detection

**Used by:** `TypewriterRenderer.PlaySequenceAsync()`

**Before:**
```csharp
if (Console.KeyAvailable)
{
    Console.ReadKey(intercept: true);
    skipped = true;
    break;
}
```

**After:**
```csharp
if (_inputService.IsInputAvailable())
{
    _inputService.ReadNext(); // Consume the skip input
    skipped = true;
    break;
}
```

---

## Logging Matrix

### InputService

| Event | Level | Template |
|-------|-------|----------|
| Service initialization | Debug | `"[Input] InputService initialized (v0.3.23a)"` |
| Key mapped to action | Trace | `"[Input] Mapped {Key} -> {Command} -> {Action}"` |
| Raw key captured | Trace | `"[Input] Raw key: {Key} ('{Char}')"` |
| System event detected | Trace | `"[Input] System event: {EventType}"` |
| Buffer cleared | Trace | `"[Input] Input buffer cleared ({Count} keys)"` |

---

## Test Coverage

**Summary:**
```
Total: 53 | Passed: 53 | Failed: 0 | Duration: 49ms
```

### CommandToActionMapperTests (33 tests)

| Test Category | Count | Description |
|---------------|-------|-------------|
| Valid command mapping | 21 | Each command string maps to correct GameAction (InlineData theory) |
| Case insensitivity | 5 | "NORTH", "North", "north" all map to MoveNorth |
| Invalid command handling | 6 | Empty, whitespace, unknown strings return false |
| GetAllMappings | 1 | Returns 21 entries as IReadOnlyDictionary |

### InputServiceTests (20 tests)

| Test Category | Count | Description |
|---------------|-------|-------------|
| Constructor logging | 1 | Verifies initialization message logged |
| ActionEvent properties | 2 | GameAction storage, optional SourceKey |
| RawKeyEvent properties | 2 | KeyInfo access, IsPrintable logic |
| SystemEvent properties | 1 | EventType storage |
| MouseEvent properties | 1 | Coordinate and click state |
| Console methods (no console) | 3 | Verifies InvalidOperationException in test environment |
| Config service integration | 3 | Mock verification of GetCommandForKey calls |
| CommandToActionMapper integration | 3 | Mapper usage within InputService |
| Debug console key | 1 | Documents Oem3 as tilde key |

---

## DI Registration

**Location:** `RuneAndRust.Terminal/Program.cs` (lines 180-184)

```csharp
// Register Input Configuration Service (v0.3.9c)
services.AddSingleton<IInputConfigurationService, InputConfigurationService>();

// Register Input Service (v0.3.23a - The Gatekeeper)
services.AddSingleton<IInputService, InputService>();
```

**Lifetime:**
- **Singleton** - Single instance shared across all game phases
- Depends on `IInputConfigurationService` (also Singleton) for key binding lookup
- Stateless service with no per-request data

---

## Verification Results

### Build Output

```
Build succeeded.

    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.73
```

### Test Output

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
VSTest version 17.14.1 (arm64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:    53, Skipped:     0, Total:    53, Duration: 49 ms
```

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Interfaces/
│   ├── IInputService.cs                    [NEW]
│   └── IInventoryService.cs                [MODIFIED]
└── Models/
    └── Input/
        └── InputEvent.cs                   [NEW]

RuneAndRust.Engine/
├── Helpers/
│   └── CommandToActionMapper.cs            [NEW]
└── Services/
    ├── InputService.cs                     [NEW]
    └── InventoryService.cs                 [MODIFIED]

RuneAndRust.Terminal/
├── Program.cs                              [MODIFIED]
├── Rendering/
│   ├── DebugConsoleRenderer.cs             [MODIFIED]
│   └── TypewriterRenderer.cs               [MODIFIED]
└── Services/
    ├── CreationWizard.cs                   [MODIFIED]
    └── OptionsController.cs                [MODIFIED]

RuneAndRust.Tests/
└── Engine/
    ├── CommandToActionMapperTests.cs       [NEW]
    ├── InputServiceTests.cs                [NEW]
    └── SaveManagerSerializationTests.cs    [MODIFIED]
```

---

## Architecture Decisions

### 1. Record Types for Input Events

**Decision:** Used C# 9 `record` types for all `InputEvent` subtypes.

**Rationale:**
- Value equality enables comparison without reference checking
- Immutability prevents mutation after creation
- With-expressions allow creating modified copies
- Pattern matching in switch expressions provides clean consumer code

---

### 2. Dual Handling (ActionEvent + RawKeyEvent Fallback)

**Decision:** Consumers handle both `ActionEvent` (mapped actions) and `RawKeyEvent` (unmapped keys) for the same logical operation.

**Rationale:**
- Users may have unmapped keys (fresh install, custom bindings)
- Vim-style keys (H/J/K/L) may not be bound in all configurations
- Fallback ensures functionality regardless of binding state
- Explicit pattern matching documents expected behavior

---

### 3. SystemEvent for Global Hotkeys

**Decision:** Created separate `SystemEvent` type for system-level hotkeys rather than including them in `ActionEvent`.

**Rationale:**
- System hotkeys bypass normal game logic (not context-dependent)
- Clearly separates game actions from meta-commands
- Enables expansion for future system keys (screenshot, pause, etc.)
- Debug console toggle is application-wide, not game-phase-specific

---

### 4. Singleton Lifetime for InputService

**Decision:** Registered `IInputService` as Singleton despite depending on `IInputConfigurationService`.

**Rationale:**
- `InputService` is stateless (no per-request data)
- `IInputConfigurationService` is also Singleton
- Single instance reduces allocation overhead
- Key bindings cached in memory, not re-read per call

---

### 5. CommandToActionMapper as Static Helper

**Decision:** Implemented `CommandToActionMapper` as a static class rather than an injectable service.

**Rationale:**
- Mapping table is compile-time constant (no runtime configuration)
- Static initialization ensures single allocation
- No dependencies requiring injection
- `TryMapCommand` follows TryParse pattern for familiarity

---

### 6. Preserving SourceKey on ActionEvent

**Decision:** Included optional `SourceKey` property on `ActionEvent` to track which physical key triggered the action.

**Rationale:**
- Rebind UI needs to display current key binding
- Debugging requires knowing physical key for reproduction
- Logging can show key→command→action chain
- Future macro recording needs original key sequence

---

## Running Tests

### Run All Input System Tests
```bash
dotnet test --filter "FullyQualifiedName~CommandToActionMapperTests|FullyQualifiedName~InputServiceTests"
```

### Run Specific Test
```bash
dotnet test --filter "FullyQualifiedName~TryMapCommand_ValidCommand_ReturnsTrueWithCorrectAction"
```

### Run All Tests with Verbose Output
```bash
dotnet test --filter "FullyQualifiedName~InputServiceTests" -v detailed
```

---

## Console.ReadKey() Migration Map

| File | Original Location | Replacement Method | Notes |
|------|-------------------|-------------------|-------|
| `OptionsController.cs` | Line 66 (main loop) | `_inputService.ReadNext()` | Blocking modal loop |
| `OptionsController.cs` | Line 467 (rebind) | `_inputService.ReadNext()` | Key capture for rebinding |
| `CreationWizard.cs` | Line 248 (lineage) | `_inputService.TryReadNext()` | Non-blocking polling |
| `CreationWizard.cs` | Line 306 (archetype) | `_inputService.TryReadNext()` | Non-blocking polling |
| `DebugConsoleRenderer.cs` | Line 49 (modal) | `_inputService.ReadNext()` | Blocking modal loop |
| `TypewriterRenderer.cs` | Line 43 (skip) | `_inputService.IsInputAvailable()` + `ReadNext()` | Skip detection |
| `TypewriterRenderer.cs` | Line 73 (wait) | `_inputService.ReadNext()` | Replaced `ConsoleInputHelper.WaitForKeyPress()` |

**Remaining Console.ReadKey() Locations (Future Refactoring):**
- `ConsoleInputHelper.cs` - Internal helper, may be deprecated
- `ConsoleInputHelper.WaitForKeyPress()` - Still used by `CreationWizard.DisplaySuccess()`

---

## Bugfixes (Pre-existing Issues)

### 1. IInventoryService Interface Mismatch

**Issue:** `IInventoryService` method signatures included `context` parameter, but `InventoryService` implementation used different signatures with default parameter values.

**Fix:** Removed `context` parameter from interface; changed implementation to use local `const string context` in each method.

**Files Modified:**
- `RuneAndRust.Core/Interfaces/IInventoryService.cs` (6 methods)
- `RuneAndRust.Engine/Services/InventoryService.cs` (6 methods)

### 2. SaveManager Test Constructor

**Issue:** `SaveManagerSerializationTests` constructor didn't include `IRoomRepository` mock after `SaveManager` constructor was updated.

**Fix:** Added `Mock<IRoomRepository>` to test fixture constructor.

**File Modified:**
- `RuneAndRust.Tests/Engine/SaveManagerSerializationTests.cs`

---

## Next Steps

### v0.3.23b - The Choreographer (Async Input & Macros)

- Add `ReadNextAsync()` and `TryReadNextAsync()` methods to `IInputService`
- Implement `InputMacro` record for stored input sequences
- Create `IMacroService` for recording and playback
- Add configurable input timeout for `TryReadNextAsync`

### v0.3.23c - The Dancer (Mouse Support)

- Implement mouse escape sequence parsing in `ReadNextFiltered()`
- Populate `MouseEvent` with X/Y coordinates and click state
- Add `OnMouseClick` and `OnMouseMove` event support
- Integrate with UI components for click handling

### v0.3.23d - The Architect (Input Testing)

- Create `MockInputService` for deterministic test input
- Build `ScriptedInputProvider` for integration tests
- Add input replay from recorded macros
- Implement input injection for automated testing

---

**End of Changelog v0.3.23a**
