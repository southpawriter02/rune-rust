# v0.3.22b: The Inspector (Analysis Engine) - Expanded Implementation Plan

## Overview

Gamify enemy information gathering by leveraging the existing Codex/DataCapture system. The more players know about an enemy (via Codex fragments), the more stats they can see during combat using the `inspect` command. This bridges the Combat system with the Knowledge system, rewarding exploration and study.

**Parent Plan:** [v0.3.22](./v0.3.22.md)
**Status:** Planned
**Dependencies:** `v0.1.3` (DataCapture/Codex system)

---

## Architecture Summary

### Key Design Decisions

1. **Knowledge Tier System** - Four progressive tiers based on Codex completion percentage
2. **Adept Archetype Bonus** - +1 tier bonus for Adept characters (scholar archetype)
3. **EnemyIntel DTO** - Masked/revealed data based on KnowledgeTier
4. **Modal Overlay Pattern** - Reuse existing combat screen overlay pattern from CombatScreenRenderer
5. **Integration with v0.1.3** - Leverage existing `ICodexEntryRepository` and `IDataCaptureService`

### Inspection Pipeline Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                     INSPECTION PIPELINE                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  [User: "inspect draugr"] ─────► [CommandParser.HandleCombat]       │
│         │                               │                            │
│         │                               ▼                            │
│         │                    ┌───────────────────────┐              │
│         │                    │ IAnalysisService      │              │
│         │                    │ .InspectAsync(target) │              │
│         │                    └──────────┬────────────┘              │
│         │                               │                            │
│         │                               ▼                            │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    ANALYSIS RESOLUTION                        │   │
│  ├──────────────────────────────────────────────────────────────┤   │
│  │ 1. Find Target Combatant by Name                             │   │
│  │    └─ Fuzzy match against CombatState.TurnOrder              │   │
│  │                                                               │   │
│  │ 2. Resolve CodexEntry for Enemy                              │   │
│  │    └─ Query ICodexEntryRepository.GetByTitleAsync()          │   │
│  │    └─ Match: Enemy.Name → CodexEntry.Title                   │   │
│  │                                                               │   │
│  │ 3. Calculate Knowledge Tier                                  │   │
│  │    ├─ Get Completion% via IDataCaptureService                │   │
│  │    ├─ Map % → KnowledgeTier (Unknown/Obscured/Known/Mastered)│   │
│  │    └─ Apply Adept Bonus (+1 tier if archetype == Adept)      │   │
│  │                                                               │   │
│  │ 4. Generate EnemyIntel DTO                                   │   │
│  │    └─ Mask fields based on KnowledgeTier                     │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                              │                                       │
│                              ▼                                       │
│                       [EnemyIntel]                                  │
│                    ┌─────────┴─────────┐                            │
│                    ▼                   ▼                            │
│           CombatViewModel      InspectWindowRenderer                │
│           .ActiveInspection    .Render(intel)                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Existing Infrastructure Analysis

### Codex/DataCapture System (v0.1.3)

| Component | Location | Purpose |
|-----------|----------|---------|
| `CodexEntry` | `Core/Entities/CodexEntry.cs` | Static lore entry with UnlockThresholds |
| `DataCapture` | `Core/Entities/DataCapture.cs` | Lore fragment with CodexEntryId |
| `ICodexEntryRepository` | `Core/Interfaces/ICodexEntryRepository.cs` | GetByTitleAsync, GetByCategoryAsync |
| `IDataCaptureService` | `Core/Interfaces/IDataCaptureService.cs` | GetCompletionPercentageAsync |
| `EntryCategory.Bestiary` | `Core/Enums/EntryCategory.cs` | Category for creature Codex entries |

### Combat System Components

| Component | Location | Purpose |
|-----------|----------|---------|
| `Combatant` | `Core/Models/Combat/Combatant.cs` | Combat wrapper with Name, EnemySource |
| `Enemy` | `Core/Entities/Enemy.cs` | Entity with Attributes, Tags, Abilities |
| `ICombatService` | `Core/Interfaces/ICombatService.cs` | Combat lifecycle management |
| `CombatViewModel` | `Core/ViewModels/CombatViewModel.cs` | Immutable combat state for UI |
| `CombatScreenRenderer` | `Terminal/Services/CombatScreenRenderer.cs` | Renders combat TUI |
| `CommandParser` | `Engine/Services/CommandParser.cs` | Handles `HandleCombat()` routing |

### Character Archetype System

| Archetype | Enum Value | Bonus |
|-----------|------------|-------|
| Warrior | 0 | +2 Sturdiness, +1 Might |
| Skirmisher | 1 | +2 Finesse, +1 Wits |
| **Adept** | **2** | **+2 Wits, +1 Will** (Knowledge bonus) |
| Mystic | 3 | +2 Will, +1 Sturdiness |

---

## Knowledge Tier System

### Tier Thresholds

| Tier | Completion % | Description |
|------|--------------|-------------|
| `Unknown` | 0-24% | Minimal information, entity unidentified |
| `Obscured` | 25-74% | Partial data, vague hints |
| `Known` | 75-99% | Detailed information, exact values |
| `Mastered` | 100% | Complete understanding, behavior hints |

### Field Visibility Matrix

| Field | Unknown | Obscured | Known | Mastered |
|-------|---------|----------|-------|----------|
| **Name** | "Unknown Entity" | Display name | Display name | Display name |
| **Description** | "???" | Short excerpt | Full text | Full text + lore |
| **HP Display** | "???" | Narrative ("Healthy") | Exact "45/100" | Exact + max |
| **Resistances** | Hidden | "Resistant to Fire?" | "Fire: 50%" | All values |
| **Abilities** | Hidden | Count only ("3 abilities") | Names listed | Names + costs |
| **Weaknesses** | Hidden | Hidden | Shown | Shown + severity |
| **Behavior** | Hidden | Hidden | Hidden | "Attacks lowest HP" |
| **Tags** | Hidden | Hidden | Shown | Shown |

### Adept Archetype Bonus

The **Adept** archetype (scholarly runic practitioner) receives a **+1 tier bonus** when using `inspect`:

```csharp
// In AnalysisService.DetermineTier()
if (character.Archetype == ArchetypeType.Adept)
{
    tier = (KnowledgeTier)Math.Min((int)tier + 1, (int)KnowledgeTier.Mastered);
}
```

This means:
- Adept at 0% completion → `Unknown` + 1 = `Obscured`
- Adept at 50% completion → `Obscured` + 1 = `Known`
- Adept at 75% completion → `Known` + 1 = `Mastered`
- Adept at 100% → Capped at `Mastered`

---

## Files to Create (6 new files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/KnowledgeTier.cs` | Enum: Unknown, Obscured, Known, Mastered |
| `RuneAndRust.Core/Models/Analysis/EnemyIntel.cs` | DTO with masked fields based on tier |
| `RuneAndRust.Core/Interfaces/IAnalysisService.cs` | Interface for inspection logic |
| `RuneAndRust.Engine/Services/AnalysisService.cs` | Implementation with masking logic |
| `RuneAndRust.Terminal/Rendering/InspectWindowRenderer.cs` | Spectre.Console modal overlay |
| `RuneAndRust.Tests/Engine/AnalysisServiceTests.cs` | Unit tests for tier calculation and masking |

## Files to Modify (5 existing files)

| File | Changes |
|------|---------|
| `RuneAndRust.Engine/Services/CommandParser.cs` | Add `inspect <target>` command in `HandleCombat()` |
| `RuneAndRust.Core/ViewModels/CombatViewModel.cs` | Add `EnemyIntel? ActiveInspection` property |
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | Check `ActiveInspection` and render overlay |
| `RuneAndRust.Terminal/Program.cs` | Register `IAnalysisService` in DI container |
| `RuneAndRust.Engine/Services/CombatService.cs` | Add method to clear `ActiveInspection` on turn change |

---

## Implementation Order

1. Create `KnowledgeTier` enum
2. Create `EnemyIntel` record
3. Create `IAnalysisService` interface
4. Implement `AnalysisService`
5. Create `InspectWindowRenderer`
6. Add `ActiveInspection` to `CombatViewModel`
7. Update `CombatScreenRenderer` to render overlay
8. Update `CommandParser` with `inspect` command
9. Register in DI (`Program.cs`)
10. Create unit tests
11. Build and verify all tests pass

---

## Detailed Code Specifications

### 1. KnowledgeTier Enum

**File:** `RuneAndRust.Core/Enums/KnowledgeTier.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Defines the player's knowledge level about an enemy based on Codex completion.
/// Higher tiers reveal more detailed information during combat inspection.
/// </summary>
/// <remarks>
/// See: SPEC-ANALYSIS-001 for Inspection & Analysis System design.
/// v0.3.22b: Initial implementation.
/// </remarks>
public enum KnowledgeTier
{
    /// <summary>
    /// 0-24% Codex completion. Minimal information available.
    /// Entity displays as "Unknown Entity" with hidden stats.
    /// </summary>
    Unknown = 0,

    /// <summary>
    /// 25-74% Codex completion. Partial information revealed.
    /// Name visible, HP shown narratively, resistance hints.
    /// </summary>
    Obscured = 1,

    /// <summary>
    /// 75-99% Codex completion. Detailed information available.
    /// Exact HP values, resistance percentages, ability names.
    /// </summary>
    Known = 2,

    /// <summary>
    /// 100% Codex completion. Complete mastery achieved.
    /// Full stats, behavior patterns, tactical recommendations.
    /// </summary>
    Mastered = 3
}
```

### 2. EnemyIntel Record

**File:** `RuneAndRust.Core/Models/Analysis/EnemyIntel.cs`

```csharp
namespace RuneAndRust.Core.Models.Analysis;

using RuneAndRust.Core.Enums;

/// <summary>
/// Data transfer object containing masked enemy information based on KnowledgeTier.
/// Generated by IAnalysisService.InspectAsync() for UI display.
/// </summary>
/// <remarks>
/// See: SPEC-ANALYSIS-001 for Inspection & Analysis System design.
/// v0.3.22b: Initial implementation.
/// </remarks>
/// <param name="TargetId">The Combatant ID being inspected.</param>
/// <param name="Name">Display name based on tier (may be "Unknown Entity").</param>
/// <param name="Description">Lore description from Codex entry (may be truncated/hidden).</param>
/// <param name="Tier">The resolved KnowledgeTier for this inspection.</param>
/// <param name="HpDisplay">Health display string based on tier ("???" / "Healthy" / "45/100").</param>
/// <param name="Resistances">List of resistance hints or values based on tier.</param>
/// <param name="Abilities">List of ability names/hints based on tier.</param>
/// <param name="Weaknesses">List of weaknesses (Known+ tiers only).</param>
/// <param name="BehaviorHint">AI behavior hint (Mastered tier only).</param>
/// <param name="Tags">Entity tags like "Mechanical", "Undying" (Known+ tiers).</param>
/// <param name="CodexProgress">Player's Codex completion percentage for this enemy.</param>
public record EnemyIntel(
    Guid TargetId,
    string Name,
    string Description,
    KnowledgeTier Tier,
    string HpDisplay,
    List<string> Resistances,
    List<string> Abilities,
    List<string> Weaknesses,
    string? BehaviorHint,
    List<string> Tags,
    int CodexProgress
)
{
    /// <summary>
    /// Creates an Unknown-tier intel for an enemy with no Codex data.
    /// </summary>
    public static EnemyIntel CreateUnknown(Guid targetId, int currentHp, int maxHp) => new(
        TargetId: targetId,
        Name: "Unknown Entity",
        Description: "You know nothing about this creature.",
        Tier: KnowledgeTier.Unknown,
        HpDisplay: "???",
        Resistances: new List<string>(),
        Abilities: new List<string>(),
        Weaknesses: new List<string>(),
        BehaviorHint: null,
        Tags: new List<string>(),
        CodexProgress: 0
    );

    /// <summary>
    /// Whether this inspection reveals the entity's exact HP values.
    /// </summary>
    public bool ShowsExactHp => Tier >= KnowledgeTier.Known;

    /// <summary>
    /// Whether this inspection reveals resistance values.
    /// </summary>
    public bool ShowsResistances => Tier >= KnowledgeTier.Obscured;

    /// <summary>
    /// Whether this inspection reveals ability names.
    /// </summary>
    public bool ShowsAbilities => Tier >= KnowledgeTier.Known;

    /// <summary>
    /// Whether this inspection reveals weaknesses.
    /// </summary>
    public bool ShowsWeaknesses => Tier >= KnowledgeTier.Known;

    /// <summary>
    /// Whether this inspection reveals behavior patterns.
    /// </summary>
    public bool ShowsBehavior => Tier >= KnowledgeTier.Mastered;
}
```

### 3. IAnalysisService Interface

**File:** `RuneAndRust.Core/Interfaces/IAnalysisService.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Models.Analysis;
using RuneAndRust.Core.Models.Combat;

/// <summary>
/// Service for analyzing enemies during combat based on Codex knowledge.
/// Bridges the Combat system with the Knowledge system (Codex/DataCapture).
/// </summary>
/// <remarks>
/// See: SPEC-ANALYSIS-001 for Inspection & Analysis System design.
/// v0.3.22b: Initial implementation.
/// </remarks>
public interface IAnalysisService
{
    /// <summary>
    /// Inspects a combat target and returns masked intel based on player knowledge.
    /// Uses the player's Codex completion percentage to determine data visibility.
    /// </summary>
    /// <param name="target">The combatant to inspect.</param>
    /// <param name="inspector">The character performing the inspection.</param>
    /// <returns>An EnemyIntel DTO with fields masked based on KnowledgeTier.</returns>
    Task<EnemyIntel> InspectAsync(Combatant target, Character inspector);

    /// <summary>
    /// Calculates the KnowledgeTier for a specific enemy type.
    /// Includes Adept archetype bonus if applicable.
    /// </summary>
    /// <param name="enemyName">The enemy type name to check.</param>
    /// <param name="inspector">The character whose knowledge to query.</param>
    /// <returns>The calculated KnowledgeTier.</returns>
    Task<KnowledgeTier> GetKnowledgeTierAsync(string enemyName, Character inspector);

    /// <summary>
    /// Gets the Codex completion percentage for a specific enemy type.
    /// </summary>
    /// <param name="enemyName">The enemy type name to check.</param>
    /// <param name="characterId">The character whose progress to query.</param>
    /// <returns>The completion percentage (0-100).</returns>
    Task<int> GetCompletionPercentageAsync(string enemyName, Guid characterId);
}
```

### 4. AnalysisService Implementation

**File:** `RuneAndRust.Engine/Services/AnalysisService.cs`

```csharp
namespace RuneAndRust.Engine.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Analysis;
using RuneAndRust.Core.Models.Combat;

/// <summary>
/// Analyzes enemies during combat by querying Codex knowledge.
/// Masks information based on the player's KnowledgeTier for that enemy type.
/// </summary>
/// <remarks>
/// See: SPEC-ANALYSIS-001 for Inspection & Analysis System design.
/// v0.3.22b: Initial implementation.
/// </remarks>
public class AnalysisService : IAnalysisService
{
    private readonly ILogger<AnalysisService> _logger;
    private readonly ICodexEntryRepository _codexRepository;
    private readonly IDataCaptureService _dataCaptureService;

    /// <summary>
    /// Initializes a new instance of the <see cref="AnalysisService"/> class.
    /// </summary>
    /// <param name="logger">The logger for traceability.</param>
    /// <param name="codexRepository">The Codex entry repository for enemy lore.</param>
    /// <param name="dataCaptureService">The data capture service for completion tracking.</param>
    public AnalysisService(
        ILogger<AnalysisService> logger,
        ICodexEntryRepository codexRepository,
        IDataCaptureService dataCaptureService)
    {
        _logger = logger;
        _codexRepository = codexRepository;
        _dataCaptureService = dataCaptureService;
    }

    /// <inheritdoc/>
    public async Task<EnemyIntel> InspectAsync(Combatant target, Character inspector)
    {
        _logger.LogDebug("[Analysis] Inspecting {TargetName} for Character {CharacterId}",
            target.Name, inspector.Id);

        // Player cannot be inspected
        if (target.IsPlayer)
        {
            _logger.LogWarning("[Analysis] Attempted to inspect player character.");
            return EnemyIntel.CreateUnknown(target.Id, target.CurrentHp, target.MaxHp);
        }

        // Get Codex entry for this enemy type
        var codexEntry = await _codexRepository.GetByTitleAsync(target.Name);

        // No Codex entry = Unknown tier
        if (codexEntry == null)
        {
            _logger.LogDebug("[Analysis] No Codex entry found for {EnemyName}. Returning Unknown tier.",
                target.Name);
            return CreateUnknownIntel(target);
        }

        // Calculate tier based on completion percentage
        var completionPct = await _dataCaptureService.GetCompletionPercentageAsync(codexEntry.Id, inspector.Id);
        var baseTier = DetermineTierFromPercentage(completionPct);

        // Apply Adept archetype bonus
        var finalTier = ApplyArchetypeBonus(baseTier, inspector);

        _logger.LogDebug("[Analysis] {EnemyName}: {Completion}% completion → {BaseTier} (Adept bonus: {HasBonus}) → {FinalTier}",
            target.Name, completionPct, baseTier, inspector.Archetype == ArchetypeType.Adept, finalTier);

        // Generate masked intel based on tier
        return GenerateIntel(target, codexEntry, finalTier, completionPct);
    }

    /// <inheritdoc/>
    public async Task<KnowledgeTier> GetKnowledgeTierAsync(string enemyName, Character inspector)
    {
        var codexEntry = await _codexRepository.GetByTitleAsync(enemyName);
        if (codexEntry == null)
        {
            return KnowledgeTier.Unknown;
        }

        var completionPct = await _dataCaptureService.GetCompletionPercentageAsync(codexEntry.Id, inspector.Id);
        var baseTier = DetermineTierFromPercentage(completionPct);
        return ApplyArchetypeBonus(baseTier, inspector);
    }

    /// <inheritdoc/>
    public async Task<int> GetCompletionPercentageAsync(string enemyName, Guid characterId)
    {
        var codexEntry = await _codexRepository.GetByTitleAsync(enemyName);
        if (codexEntry == null)
        {
            return 0;
        }

        return await _dataCaptureService.GetCompletionPercentageAsync(codexEntry.Id, characterId);
    }

    #region Private Methods

    /// <summary>
    /// Converts completion percentage to base KnowledgeTier.
    /// </summary>
    private static KnowledgeTier DetermineTierFromPercentage(int percentage) => percentage switch
    {
        >= 100 => KnowledgeTier.Mastered,
        >= 75 => KnowledgeTier.Known,
        >= 25 => KnowledgeTier.Obscured,
        _ => KnowledgeTier.Unknown
    };

    /// <summary>
    /// Applies Adept archetype bonus (+1 tier, capped at Mastered).
    /// </summary>
    private static KnowledgeTier ApplyArchetypeBonus(KnowledgeTier baseTier, Character inspector)
    {
        if (inspector.Archetype != ArchetypeType.Adept)
        {
            return baseTier;
        }

        // Adept gets +1 tier, capped at Mastered
        return (KnowledgeTier)Math.Min((int)baseTier + 1, (int)KnowledgeTier.Mastered);
    }

    /// <summary>
    /// Creates Unknown-tier intel for an enemy with no Codex data.
    /// </summary>
    private EnemyIntel CreateUnknownIntel(Combatant target)
    {
        return new EnemyIntel(
            TargetId: target.Id,
            Name: "Unknown Entity",
            Description: "You know nothing about this creature. Gather more fragments to learn its secrets.",
            Tier: KnowledgeTier.Unknown,
            HpDisplay: "???",
            Resistances: new List<string>(),
            Abilities: new List<string>(),
            Weaknesses: new List<string>(),
            BehaviorHint: null,
            Tags: new List<string>(),
            CodexProgress: 0
        );
    }

    /// <summary>
    /// Generates EnemyIntel with fields masked based on KnowledgeTier.
    /// </summary>
    private EnemyIntel GenerateIntel(Combatant target, CodexEntry codexEntry, KnowledgeTier tier, int completionPct)
    {
        var enemy = target.EnemySource;

        return new EnemyIntel(
            TargetId: target.Id,
            Name: tier >= KnowledgeTier.Obscured ? target.Name : "Unknown Entity",
            Description: GenerateDescription(codexEntry, tier),
            Tier: tier,
            HpDisplay: GenerateHpDisplay(target, tier),
            Resistances: GenerateResistances(enemy, tier),
            Abilities: GenerateAbilities(target, tier),
            Weaknesses: GenerateWeaknesses(enemy, codexEntry, tier),
            BehaviorHint: GenerateBehaviorHint(enemy, tier),
            Tags: tier >= KnowledgeTier.Known ? new List<string>(target.Tags) : new List<string>(),
            CodexProgress: completionPct
        );
    }

    /// <summary>
    /// Generates description text based on tier.
    /// </summary>
    private static string GenerateDescription(CodexEntry entry, KnowledgeTier tier) => tier switch
    {
        KnowledgeTier.Unknown => "You know nothing about this creature.",
        KnowledgeTier.Obscured => entry.FullText.Length > 100
            ? entry.FullText[..100] + "..."
            : entry.FullText,
        _ => entry.FullText
    };

    /// <summary>
    /// Generates HP display string based on tier.
    /// </summary>
    private static string GenerateHpDisplay(Combatant target, KnowledgeTier tier)
    {
        if (tier >= KnowledgeTier.Known)
        {
            return $"{target.CurrentHp}/{target.MaxHp}";
        }

        if (tier >= KnowledgeTier.Obscured)
        {
            var hpPercent = (float)target.CurrentHp / target.MaxHp * 100;
            return hpPercent switch
            {
                >= 75 => "Healthy",
                >= 50 => "Wounded",
                >= 25 => "Bloodied",
                _ => "Critical"
            };
        }

        return "???";
    }

    /// <summary>
    /// Generates resistance hints or values based on tier.
    /// </summary>
    private static List<string> GenerateResistances(Enemy? enemy, KnowledgeTier tier)
    {
        if (enemy == null || tier < KnowledgeTier.Obscured)
        {
            return new List<string>();
        }

        // TODO: When resistance system is implemented, pull actual values
        // For now, generate based on tags
        var resistances = new List<string>();

        if (enemy.Tags.Contains("Mechanical"))
        {
            resistances.Add(tier >= KnowledgeTier.Known ? "Bleed: Immune" : "Resistant to bleeding?");
        }

        if (enemy.Tags.Contains("Undying"))
        {
            resistances.Add(tier >= KnowledgeTier.Known ? "Poison: Immune" : "Resistant to toxins?");
        }

        if (enemy.Tags.Contains("Beast"))
        {
            resistances.Add(tier >= KnowledgeTier.Known ? "Fear: Immune" : "Fearless?");
        }

        return resistances;
    }

    /// <summary>
    /// Generates ability list based on tier.
    /// </summary>
    private static List<string> GenerateAbilities(Combatant target, KnowledgeTier tier)
    {
        if (tier < KnowledgeTier.Obscured || target.Abilities.Count == 0)
        {
            return new List<string>();
        }

        if (tier == KnowledgeTier.Obscured)
        {
            return new List<string> { $"{target.Abilities.Count} known abilities" };
        }

        // Known or Mastered: show ability names
        return target.Abilities.Select(a =>
        {
            if (tier >= KnowledgeTier.Mastered)
            {
                var cost = a.ApCost > 0 ? $"{a.ApCost} AP" : $"{a.StaminaCost} STA";
                return $"{a.Name} ({cost})";
            }
            return a.Name;
        }).ToList();
    }

    /// <summary>
    /// Generates weakness list based on tier and Codex thresholds.
    /// </summary>
    private static List<string> GenerateWeaknesses(Enemy? enemy, CodexEntry entry, KnowledgeTier tier)
    {
        if (tier < KnowledgeTier.Known)
        {
            return new List<string>();
        }

        var weaknesses = new List<string>();

        // Check Codex unlock thresholds for WEAKNESS_REVEALED
        if (entry.UnlockThresholds.Values.Contains("WEAKNESS_REVEALED"))
        {
            // TODO: Pull actual weakness data when implemented
            // For now, generate hints based on tags
            if (enemy?.Tags.Contains("Mechanical") == true)
            {
                weaknesses.Add("Vulnerable to Shock damage");
            }

            if (enemy?.Tags.Contains("Undying") == true)
            {
                weaknesses.Add("Vulnerable to Fire damage");
            }
        }

        return weaknesses;
    }

    /// <summary>
    /// Generates AI behavior hint for Mastered tier.
    /// </summary>
    private static string? GenerateBehaviorHint(Enemy? enemy, KnowledgeTier tier)
    {
        if (tier < KnowledgeTier.Mastered || enemy == null)
        {
            return null;
        }

        return enemy.Archetype switch
        {
            EnemyArchetype.DPS => "Prioritizes highest-threat targets.",
            EnemyArchetype.Tank => "Protects weaker allies. High durability.",
            EnemyArchetype.Support => "Buffs allies and debuffs enemies. Target first.",
            EnemyArchetype.Controller => "Uses crowd control abilities. Stay mobile.",
            _ => "Behavior patterns unknown."
        };
    }

    #endregion
}
```

### 5. InspectWindowRenderer

**File:** `RuneAndRust.Terminal/Rendering/InspectWindowRenderer.cs`

```csharp
namespace RuneAndRust.Terminal.Rendering;

using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Models.Analysis;
using Spectre.Console;

/// <summary>
/// Renders the inspection modal overlay during combat.
/// Displays EnemyIntel with styling based on KnowledgeTier.
/// </summary>
/// <remarks>
/// See: SPEC-ANALYSIS-001 for Inspection & Analysis System design.
/// v0.3.22b: Initial implementation.
/// </remarks>
public static class InspectWindowRenderer
{
    /// <summary>
    /// Renders an EnemyIntel object as a Spectre.Console Panel.
    /// </summary>
    /// <param name="intel">The enemy intel to render.</param>
    /// <returns>A Panel containing the formatted intel display.</returns>
    public static Panel Render(EnemyIntel intel)
    {
        var content = new List<string>();

        // Name and tier indicator
        var tierColor = GetTierColor(intel.Tier);
        var tierIcon = GetTierIcon(intel.Tier);
        content.Add($"[bold {tierColor}]{tierIcon} {intel.Name}[/]");
        content.Add($"[grey]Knowledge: {intel.Tier} ({intel.CodexProgress}%)[/]");
        content.Add("");

        // Description
        content.Add($"[italic]{Markup.Escape(intel.Description)}[/]");
        content.Add("");

        // HP Display
        content.Add($"[white]Health:[/] {FormatHpDisplay(intel)}");

        // Resistances
        if (intel.Resistances.Count > 0)
        {
            content.Add("");
            content.Add("[yellow]Resistances:[/]");
            foreach (var resistance in intel.Resistances)
            {
                content.Add($"  {GetResistanceIcon(intel.Tier)} {Markup.Escape(resistance)}");
            }
        }

        // Abilities
        if (intel.Abilities.Count > 0)
        {
            content.Add("");
            content.Add("[cyan]Abilities:[/]");
            foreach (var ability in intel.Abilities)
            {
                content.Add($"  {GetAbilityIcon(intel.Tier)} {Markup.Escape(ability)}");
            }
        }

        // Weaknesses
        if (intel.Weaknesses.Count > 0)
        {
            content.Add("");
            content.Add("[red]Weaknesses:[/]");
            foreach (var weakness in intel.Weaknesses)
            {
                content.Add($"  [red]![/] {Markup.Escape(weakness)}");
            }
        }

        // Tags
        if (intel.Tags.Count > 0)
        {
            content.Add("");
            content.Add($"[grey]Tags: {string.Join(", ", intel.Tags)}[/]");
        }

        // Behavior hint (Mastered only)
        if (intel.BehaviorHint != null)
        {
            content.Add("");
            content.Add($"[purple]Behavior: {Markup.Escape(intel.BehaviorHint)}[/]");
        }

        // Footer
        content.Add("");
        content.Add("[grey italic]Press any key to close...[/]");

        var panel = new Panel(string.Join("\n", content))
        {
            Header = new PanelHeader($"[bold]ANALYSIS: {intel.Name}[/]"),
            Border = intel.Tier >= KnowledgeTier.Known ? BoxBorder.Double : BoxBorder.Rounded,
            BorderStyle = new Style(GetTierConsoleColor(intel.Tier)),
            Padding = new Padding(2, 1),
            Width = 60
        };

        return panel;
    }

    #region Private Helpers

    private static string GetTierColor(KnowledgeTier tier) => tier switch
    {
        KnowledgeTier.Unknown => "grey",
        KnowledgeTier.Obscured => "yellow",
        KnowledgeTier.Known => "green",
        KnowledgeTier.Mastered => "purple",
        _ => "white"
    };

    private static Color GetTierConsoleColor(KnowledgeTier tier) => tier switch
    {
        KnowledgeTier.Unknown => Color.Grey,
        KnowledgeTier.Obscured => Color.Yellow,
        KnowledgeTier.Known => Color.Green,
        KnowledgeTier.Mastered => Color.Purple,
        _ => Color.White
    };

    private static string GetTierIcon(KnowledgeTier tier) => tier switch
    {
        KnowledgeTier.Unknown => "?",
        KnowledgeTier.Obscured => "~",
        KnowledgeTier.Known => "*",
        KnowledgeTier.Mastered => "+",
        _ => " "
    };

    private static string GetResistanceIcon(KnowledgeTier tier) =>
        tier >= KnowledgeTier.Known ? "[yellow]R[/]" : "[grey]?[/]";

    private static string GetAbilityIcon(KnowledgeTier tier) =>
        tier >= KnowledgeTier.Known ? "[cyan]>[/]" : "[grey]?[/]";

    private static string FormatHpDisplay(EnemyIntel intel)
    {
        if (intel.Tier >= KnowledgeTier.Known)
        {
            return $"[bold]{intel.HpDisplay}[/]";
        }

        if (intel.Tier >= KnowledgeTier.Obscured)
        {
            var color = intel.HpDisplay switch
            {
                "Healthy" => "green",
                "Wounded" => "yellow",
                "Bloodied" => "orange1",
                "Critical" => "red",
                _ => "white"
            };
            return $"[{color}]{intel.HpDisplay}[/]";
        }

        return "[grey]???[/]";
    }

    #endregion
}
```

### 6. CombatViewModel Update

**File:** `RuneAndRust.Core/ViewModels/CombatViewModel.cs` (add new parameter)

```csharp
// Add to the CombatViewModel record parameters:

/// <param name="ActiveInspection">The currently active inspection overlay (null if none).</param>
public record CombatViewModel(
    int RoundNumber,
    string ActiveCombatantName,
    List<CombatantView> TurnOrder,
    List<string> CombatLog,
    PlayerStatsView PlayerStats,
    List<AbilityView>? PlayerAbilities = null,
    // Row-grouped combatants for grid display (v0.3.6a)
    List<CombatantView>? PlayerFrontRow = null,
    List<CombatantView>? PlayerBackRow = null,
    List<CombatantView>? EnemyFrontRow = null,
    List<CombatantView>? EnemyBackRow = null,
    // Timeline projection (v0.3.6b)
    List<TimelineEntryView>? TimelineProjection = null,
    // Context help tips (v0.3.9c)
    List<HelpTip>? ContextTips = null,
    // Inspection overlay (v0.3.22b)
    EnemyIntel? ActiveInspection = null
);
```

### 7. CommandParser Update

**File:** `RuneAndRust.Engine/Services/CommandParser.cs`

Add to `HandleCombat()` method:

```csharp
// In HandleCombat(), add inspect command handling:

// Check for inspect command (v0.3.22b)
var inspectTarget = ExtractTarget(command, new[] { "inspect ", "analyze ", "scan " });
if (inspectTarget != null)
{
    return await ExecuteInspectCommand(inspectTarget);
}

// ... existing switch statement ...

// Add new private method:

/// <summary>
/// Executes the inspect command to analyze an enemy during combat.
/// v0.3.22b: The Inspector implementation.
/// </summary>
/// <param name="targetName">The name of the target to inspect.</param>
/// <returns>A ParseResult (always None as inspection renders inline).</returns>
private async Task<ParseResult> ExecuteInspectCommand(string targetName)
{
    if (_analysisService == null || _combatService == null)
    {
        _inputHandler.DisplayError("Analysis system not available.");
        return ParseResult.None;
    }

    if (_gameState.CurrentCharacter == null)
    {
        _inputHandler.DisplayError("No active character.");
        return ParseResult.None;
    }

    // Find target in combat
    var combatVm = _combatService.GetViewModel();
    if (combatVm == null)
    {
        _inputHandler.DisplayError("Not in combat.");
        return ParseResult.None;
    }

    // Find matching combatant by partial name
    var target = FindTargetCombatant(targetName);
    if (target == null)
    {
        _inputHandler.DisplayError($"Target not found: '{targetName}'");
        return ParseResult.None;
    }

    // Generate intel
    var intel = await _analysisService.InspectAsync(target, _gameState.CurrentCharacter);

    // Render inspection overlay
    var panel = InspectWindowRenderer.Render(intel);
    AnsiConsole.Write(panel);

    // Wait for key press to dismiss
    Console.ReadKey(intercept: true);

    return ParseResult.None;
}
```

---

## CombatScreenRenderer Integration

**File:** `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs`

Add overlay check in `Render()` method:

```csharp
/// <inheritdoc/>
public void Render(CombatViewModel vm)
{
    AnsiConsole.Clear();

    // Check for active inspection overlay (v0.3.22b)
    if (vm.ActiveInspection != null)
    {
        var inspectPanel = InspectWindowRenderer.Render(vm.ActiveInspection);
        AnsiConsole.Write(inspectPanel);
        return; // Don't render normal combat screen during inspection
    }

    // ... rest of existing render code ...
}
```

---

## Test Coverage (~15 tests)

### AnalysisServiceTests.cs

| Test Name | Description |
|-----------|-------------|
| `InspectAsync_NoCodexEntry_ReturnsUnknownTier` | Enemy with no Codex → Unknown |
| `InspectAsync_ZeroPercent_ReturnsUnknownTier` | 0% completion → Unknown |
| `InspectAsync_TwentyFivePercent_ReturnsObscuredTier` | 25% completion → Obscured |
| `InspectAsync_SeventyFivePercent_ReturnsKnownTier` | 75% completion → Known |
| `InspectAsync_OneHundredPercent_ReturnsMasteredTier` | 100% completion → Mastered |
| `InspectAsync_AdeptBonus_UpgradesTier` | Adept at 0% → Obscured |
| `InspectAsync_AdeptBonus_CapsAtMastered` | Adept at 100% → Mastered (not beyond) |
| `InspectAsync_PlayerTarget_ReturnsUnknown` | Cannot inspect player |
| `GetKnowledgeTierAsync_NoEntry_ReturnsUnknown` | Missing Codex → Unknown |
| `GetCompletionPercentageAsync_NoEntry_ReturnsZero` | Missing Codex → 0% |

### EnemyIntelTests.cs

| Test Name | Description |
|-----------|-------------|
| `ShowsExactHp_TrueForKnownAndMastered` | Known/Mastered show exact HP |
| `ShowsExactHp_FalseForUnknownAndObscured` | Unknown/Obscured hide exact HP |
| `CreateUnknown_ReturnsCorrectDefaults` | Factory method validation |
| `ShowsResistances_TrueForObscuredAndAbove` | Resistance visibility threshold |
| `ShowsBehavior_OnlyForMastered` | Behavior hint mastering requirement |

---

## Logging Matrix

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Analysis | Inspect Start | Debug | `[Analysis] Inspecting {TargetName} for Character {CharacterId}` | TargetName, CharacterId |
| Analysis | No Codex Entry | Debug | `[Analysis] No Codex entry found for {EnemyName}. Returning Unknown tier.` | EnemyName |
| Analysis | Tier Calculated | Debug | `[Analysis] {EnemyName}: {Completion}% completion → {BaseTier} (Adept bonus: {HasBonus}) → {FinalTier}` | EnemyName, Completion, BaseTier, HasBonus, FinalTier |
| Analysis | Player Target | Warning | `[Analysis] Attempted to inspect player character.` | - |
| Combat | Inspect Command | Debug | `[Combat] Inspect command for target: {Target}` | Target |
| Combat | Target Not Found | Debug | `[Combat] Inspect target not found: {TargetName}` | TargetName |

---

## Deliverable Checklist (v0.3.22b)

### Core Layer
- [ ] Create `RuneAndRust.Core/Enums/KnowledgeTier.cs`
- [ ] Create `RuneAndRust.Core/Models/Analysis/EnemyIntel.cs`
- [ ] Create `RuneAndRust.Core/Interfaces/IAnalysisService.cs`
- [ ] Update `RuneAndRust.Core/ViewModels/CombatViewModel.cs` with `ActiveInspection`

### Engine Layer
- [ ] Create `RuneAndRust.Engine/Services/AnalysisService.cs`
- [ ] Update `RuneAndRust.Engine/Services/CommandParser.cs` with `inspect` command

### Terminal Layer
- [ ] Create `RuneAndRust.Terminal/Rendering/InspectWindowRenderer.cs`
- [ ] Update `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` for overlay
- [ ] Register `IAnalysisService` in `Program.cs`

### Testing
- [ ] Create `RuneAndRust.Tests/Engine/AnalysisServiceTests.cs` (~10 tests)
- [ ] Create `RuneAndRust.Tests/Core/EnemyIntelTests.cs` (~5 tests)

---

## Critical Files Reference

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/CodexEntry.cs` | Codex entry with UnlockThresholds |
| `RuneAndRust.Core/Entities/DataCapture.cs` | Lore fragment entity |
| `RuneAndRust.Core/Entities/Enemy.cs` | Enemy entity with Attributes, Tags |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Combat wrapper with EnemySource |
| `RuneAndRust.Core/Interfaces/ICodexEntryRepository.cs` | GetByTitleAsync method |
| `RuneAndRust.Core/Interfaces/IDataCaptureService.cs` | GetCompletionPercentageAsync |
| `RuneAndRust.Core/Enums/ArchetypeType.cs` | Adept = 2 for bonus |
| `RuneAndRust.Engine/Services/CommandParser.cs` | HandleCombat() location |
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | Overlay integration point |
| `RuneAndRust.Terminal/Program.cs` | DI registration |

---

## Command Usage Examples

```
> inspect draugr
┌────────────────────────────────────────────────────────┐
│ ANALYSIS: Rusted Draugr                                │
├────────────────────────────────────────────────────────┤
│ * Rusted Draugr                                        │
│ Knowledge: Known (78%)                                 │
│                                                        │
│ An ancient warrior reanimated by residual Aether       │
│ corruption. The rust on its armor suggests centuries   │
│ of decay, yet it moves with terrible purpose...        │
│                                                        │
│ Health: 45/100                                         │
│                                                        │
│ Resistances:                                           │
│   R Bleed: Immune                                      │
│                                                        │
│ Abilities:                                             │
│   > Rusted Cleave                                      │
│   > Deathless Charge                                   │
│                                                        │
│ Weaknesses:                                            │
│   ! Vulnerable to Fire damage                          │
│                                                        │
│ Tags: Undying, Armored                                 │
│                                                        │
│ Press any key to close...                              │
└────────────────────────────────────────────────────────┘
```

---

## Future Extensions

### v0.3.22c Considerations
- Combat Forecast could use `IAnalysisService` to predict enemy actions
- Forecasts only available at `Known` tier or higher
- Adept bonus extends to forecast accuracy

### Passive Inspection
- Future: Auto-display tier icons next to enemy names in combat grid
- Icon: `?` (Unknown), `~` (Obscured), `*` (Known), `+` (Mastered)

### Data Capture Integration
- Defeating enemies could auto-generate DataCapture fragments
- Higher tier = higher quality fragments (Specialist vs Standard)

---

## Estimated Metrics

| Metric | Value |
|--------|-------|
| New Files | 6 |
| Modified Files | 5 |
| New Lines (Services) | ~350 |
| New Lines (Tests) | ~200 |
| New Unit Tests | ~15 |
| New Commands | 3 (inspect, analyze, scan) |

---

## Pre-Commit Checks

- [ ] Verify Codex dependencies (v0.1.3) are available
- [ ] Ensure `inspect` command doesn't crash on invalid target
- [ ] Test Adept archetype bonus correctly applies
- [ ] Verify panel rendering doesn't break on narrow terminals
- [ ] Confirm escape sequences don't leak in Spectre.Console markup

**End of Plan**
