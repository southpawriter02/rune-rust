# v0.30.5 Integration Guide
## CombatEngine & MovementService Integration for Niflheim

**Version:** v0.30.5
**Prerequisites:** v0.30.4 (Service Implementation Complete)
**Estimated Time:** 4-6 hours
**Status:** Ready for Implementation

---

## I. CombatEngine Integration

### **File**: `RuneAndRust.Engine/CombatEngine.cs`

### A. Add Biome Service Dependencies

**Location**: Constructor parameters (around line 20-30)

**Add to constructor**:
```csharp
private readonly NiflheimBiomeService? _niflheimBiomeService;
private readonly MuspelheimBiomeService? _muspelheimBiomeService;

public CombatEngine(
    DiceService diceService,
    SagaService sagaService,
    LootService lootService,
    EquipmentService equipmentService,
    HazardService hazardService,
    CurrencyService currencyService,
    AdvancedStatusEffectService statusEffectService,
    NiflheimBiomeService? niflheimBiomeService = null,      // NEW
    MuspelheimBiomeService? muspelheimBiomeService = null   // NEW
)
{
    _diceService = diceService;
    _sagaService = sagaService;
    _lootService = lootService;
    _equipmentService = equipmentService;
    _hazardService = hazardService;
    _currencyService = currencyService;
    _statusEffectService = statusEffectService;
    _niflheimBiomeService = niflheimBiomeService;           // NEW
    _muspelheimBiomeService = muspelheimBiomeService;       // NEW
    // ...existing initialization
}
```

**Update Program.cs** (line ~30):
```csharp
private static CombatEngine _combatEngine = new(
    _diceService,
    _sagaService,
    _lootService,
    _equipmentService,
    _hazardService,
    _currencyService,
    _statusEffectService,
    _niflheimBiomeService,      // NEW
    _muspelheimBiomeService     // NEW
);
```

---

### B. Apply Biome-Specific Ambient Conditions

**Location**: `InitializeCombat()` method (after line 86, before `return combatState`)

**Add before `return combatState;`**:
```csharp
        // v0.30: Apply biome-specific ambient conditions
        ApplyBiomeAmbientConditions(combatState);

        return combatState;
    }

    /// <summary>
    /// v0.30: Apply ambient conditions based on current room's biome
    /// </summary>
    private void ApplyBiomeAmbientConditions(CombatState combatState)
    {
        if (combatState.CurrentRoom == null)
        {
            return;
        }

        // Get biome name from room
        // NOTE: This assumes Room has a BiomeName property
        // If not, you may need to query from database or use room metadata
        string? biomeName = combatState.CurrentRoom.BiomeName
                         ?? combatState.CurrentRoom.GetMetadata("biome");

        if (string.IsNullOrEmpty(biomeName))
        {
            return;
        }

        // Apply Niflheim ambient condition: [Frigid Cold]
        if (biomeName.Equals("Niflheim", StringComparison.OrdinalIgnoreCase))
        {
            if (_niflheimBiomeService != null)
            {
                _log.Information("Applying [Frigid Cold] ambient condition to combat");

                var characters = new List<PlayerCharacter> { combatState.Player };
                _niflheimBiomeService.ApplyFrigidColdToCombat(characters, combatState.Enemies);

                combatState.AddLogEntry("‚ùÑÔ∏è [FRIGID COLD] - Ambient Condition Active");
                combatState.AddLogEntry("   All combatants are Vulnerable to Ice damage (+50%)");
                combatState.AddLogEntry("   Critical hits inflict [Slowed] for 2 turns");
                combatState.AddLogEntry("");
            }
        }
        // Apply Muspelheim ambient condition: [Intense Heat]
        else if (biomeName.Equals("Muspelheim", StringComparison.OrdinalIgnoreCase))
        {
            if (_muspelheimBiomeService != null)
            {
                _log.Information("Applying [Intense Heat] ambient condition to combat");

                combatState.AddLogEntry("üî• [INTENSE HEAT] - Ambient Condition Active");
                combatState.AddLogEntry("   STURDINESS checks (DC 12) at end of each turn");
                combatState.AddLogEntry("   Failure: 2d6 Fire damage");
                combatState.AddLogEntry("");
            }
        }
    }
```

---

### C. Amplify Ice Damage in [Frigid Cold]

**Location**: Damage application method (search for where Ice damage is applied)

**Find the damage calculation method** (likely `ApplyDamage` or similar):
```csharp
// Example integration point
public void ApplyDamage(Enemy target, int baseDamage, string damageType)
{
    int finalDamage = baseDamage;

    // v0.30: Amplify Ice damage in Niflheim ([Frigid Cold])
    if (damageType.Equals("Ice", StringComparison.OrdinalIgnoreCase))
    {
        if (IsInBiome("Niflheim") && _niflheimBiomeService != null)
        {
            finalDamage = _niflheimBiomeService.ApplyIceVulnerability(baseDamage);
            _log.Debug("Ice damage amplified by [Frigid Cold]: {Base} ‚Üí {Final}",
                baseDamage, finalDamage);
        }
    }

    // Apply final damage
    target.HP -= finalDamage;
}
```

**Helper method**:
```csharp
private bool IsInBiome(string biomeName)
{
    return _currentCombatState?.CurrentRoom?.BiomeName
        ?.Equals(biomeName, StringComparison.OrdinalIgnoreCase) ?? false;
}
```

---

### D. Apply [Slowed] on Critical Hits in [Frigid Cold]

**Location**: Critical hit processing (search for "critical hit" or "crit")

**Add to critical hit handling**:
```csharp
// Example integration
private void ProcessCriticalHit(CombatState combatState, Attack attack)
{
    // ...existing critical hit logic

    // v0.30: Apply [Slowed] in [Frigid Cold]
    if (IsInBiome("Niflheim") && _niflheimBiomeService != null)
    {
        if (attack.Target is PlayerCharacter playerTarget)
        {
            var slowResult = _niflheimBiomeService.ProcessCriticalHitSlow(
                playerTarget,
                attack.AttackerName
            );
            combatState.AddLogEntry(slowResult.Message);

            // TODO: Apply [Slowed] status when status system supports it
        }
    }
}
```

---

### E. Apply Psychic Stress at Combat End

**Location**: Combat end method (search for `EndCombat` or similar)

**Add before combat cleanup**:
```csharp
public void EndCombat(CombatState combatState)
{
    _log.Information("Combat ending");

    // v0.30: Apply environmental psychic stress in Niflheim
    if (IsInBiome("Niflheim") && _niflheimBiomeService != null)
    {
        var characters = new List<PlayerCharacter> { combatState.Player };
        var stressResults = _niflheimBiomeService.ProcessCombatEndStress(characters);

        foreach (var result in stressResults)
        {
            combatState.AddLogEntry(result.Message);
        }
    }

    // v0.29: Apply heat damage checks in Muspelheim
    if (IsInBiome("Muspelheim") && _muspelheimBiomeService != null)
    {
        // Muspelheim heat damage is applied at END of each turn
        // Not at combat end
    }

    // ...existing combat cleanup
}
```

---

### F. Process [Brittle] Mechanic

**Location**: Ice damage application

**Add Brittleness check after Ice damage**:
```csharp
// When Ice damage is applied to an enemy in Niflheim
if (IsInBiome("Niflheim") && _niflheimBiomeService != null)
{
    var brittleResult = _niflheimBiomeService.ApplyIceDamageToEnemy(
        targetEnemy,
        iceDamage,
        attackerName
    );

    combatState.AddLogEntry(brittleResult.Message);

    // Brittle is automatically applied by service if eligible
}
```

**When Physical damage is applied**:
```csharp
// When Physical damage is applied to an enemy
if (_niflheimBiomeService != null)
{
    var physResult = _niflheimBiomeService.ApplyPhysicalDamageToEnemy(
        targetEnemy,
        physicalDamage,
        attackerName
    );

    combatState.AddLogEntry(physResult.Message);
}
```

---

## II. MovementService Integration

### **File**: `RuneAndRust.Engine/AdvancedMovementService.cs` (or equivalent)

### A. Add Slippery Terrain Dependency

**Constructor**:
```csharp
private readonly SlipperyTerrainService? _slipperyTerrainService;

public AdvancedMovementService(
    SlipperyTerrainService? slipperyTerrainService = null
)
{
    _slipperyTerrainService = slipperyTerrainService;
}
```

**Update Program.cs**:
```csharp
private static AdvancedMovementService _advancedMovement = new(
    _slipperyTerrainService  // NEW
);
```

---

### B. Process Slippery Terrain Checks

**Location**: Movement processing method

**Add terrain check before movement**:
```csharp
public MovementResult ProcessMovement(
    PlayerCharacter character,
    GridPosition targetPosition,
    Room currentRoom)
{
    // v0.30: Check for [Slippery Terrain] in Niflheim
    if (IsInBiome(currentRoom, "Niflheim") && _slipperyTerrainService != null)
    {
        var terrainResult = _slipperyTerrainService.ProcessMovement(character);

        if (!terrainResult.CheckPassed)
        {
            // Character slipped and was knocked down
            return new MovementResult
            {
                Success = false,
                Message = terrainResult.Message,
                WasKnockedDown = true,
                DamageTaken = terrainResult.DamageDealt
            };
        }

        // Passed check, movement continues normally
    }

    // ...existing movement logic
}
```

**Helper**:
```csharp
private bool IsInBiome(Room room, string biomeName)
{
    return room.BiomeName?.Equals(biomeName, StringComparison.OrdinalIgnoreCase) ?? false;
}
```

---

### C. Amplify Forced Movement

**Location**: Forced movement ability processing

**When calculating forced movement distance**:
```csharp
public int CalculateForcedMovementDistance(
    int baseDistance,
    Room currentRoom)
{
    int finalDistance = baseDistance;

    // v0.30: Amplify forced movement on [Slippery Terrain]
    if (IsInBiome(currentRoom, "Niflheim") && _slipperyTerrainService != null)
    {
        finalDistance = _slipperyTerrainService.AmplifyForcedMovement(baseDistance);

        _log.Debug("Forced movement amplified on [Slippery Terrain]: {Base} ‚Üí {Final} tiles",
            baseDistance, finalDistance);
    }

    return finalDistance;
}
```

---

## III. Room Model Extension

### **File**: `RuneAndRust.Core/Room.cs`

**Add BiomeName property** (if not already present):
```csharp
public class Room
{
    // ...existing properties

    /// <summary>
    /// v0.30: Biome identifier for ambient condition application
    /// </summary>
    public string? BiomeName { get; set; }

    // ...existing properties
}
```

**Or add metadata getter**:
```csharp
public string? GetMetadata(string key)
{
    // Implementation depends on existing metadata system
    // Example: return _metadata.TryGetValue(key, out var value) ? value : null;
}
```

---

## IV. Testing Integration

### A. Manual Testing Checklist

**Niflheim Combat**:
- [ ] Enter Niflheim room
- [ ] Start combat
- [ ] Verify "[Frigid Cold] - Ambient Condition Active" message
- [ ] Apply Ice damage to enemy
- [ ] Verify damage is amplified by +50%
- [ ] Apply Ice damage to Ice-resistant enemy
- [ ] Verify [Brittle] is applied
- [ ] Apply Physical damage to Brittle enemy
- [ ] Verify +50% Physical damage bonus
- [ ] Land critical hit on player
- [ ] Verify [Slowed] is applied for 2 turns
- [ ] End combat
- [ ] Verify +5 Psychic Stress applied

**Niflheim Movement**:
- [ ] Enter Niflheim room
- [ ] Attempt movement with FINESSE < 12
- [ ] Verify FINESSE DC 12 check occurs
- [ ] Fail check
- [ ] Verify [Knocked Down] applied
- [ ] Verify 1d4 fall damage dealt
- [ ] Use forced movement ability
- [ ] Verify distance amplified by +1 tile

---

## V. Database Setup

### Execute SQL Files

**Before testing, ensure database is fully populated**:

```bash
cd /path/to/rune-rust

# Execute Niflheim SQL files
sqlite3 runeandrust.db < Data/v0.30.1_niflheim_schema.sql
sqlite3 runeandrust.db < Data/v0.30.2_environmental_hazards.sql
sqlite3 runeandrust.db < Data/v0.30.3_enemy_definitions.sql

# Verify data inserted
sqlite3 runeandrust.db "SELECT COUNT(*) FROM Biome_RoomTemplates WHERE biome_id = 5;"
# Expected: 8

sqlite3 runeandrust.db "SELECT COUNT(*) FROM Biome_EnvironmentalFeatures WHERE biome_id = 5;"
# Expected: 9

sqlite3 runeandrust.db "SELECT COUNT(*) FROM Biome_EnemySpawns WHERE biome_id = 5;"
# Expected: 7

sqlite3 runeandrust.db "SELECT COUNT(*) FROM Biome_ResourceDrops WHERE biome_id = 5;"
# Expected: 9
```

---

## VI. Integration Sequence

### Recommended Implementation Order:

1. **Database** (30 min)
   - Execute SQL files
   - Verify data loaded

2. **Room Model** (15 min)
   - Add BiomeName property
   - Test compilation

3. **CombatEngine - Phase 1** (1-2 hours)
   - Add dependencies
   - Apply ambient conditions
   - Test combat initialization

4. **CombatEngine - Phase 2** (1-2 hours)
   - Ice damage amplification
   - Critical hit slow
   - Brittleness mechanic
   - Test damage calculations

5. **CombatEngine - Phase 3** (30 min)
   - Psychic stress at combat end
   - Test full combat flow

6. **MovementService** (1-2 hours)
   - Add dependencies
   - Slippery terrain checks
   - Forced movement amplification
   - Test movement

7. **Integration Testing** (1-2 hours)
   - Full Niflheim playthrough
   - Verify all mechanics work together
   - Document any issues

**Total Estimated Time**: 6-9 hours

---

## VII. Troubleshooting

### Common Issues

**Issue**: "BiomeName not found on Room"
- **Solution**: Add BiomeName property to Room.cs or use metadata system

**Issue**: "NiflheimBiomeService is null"
- **Solution**: Ensure service is passed to CombatEngine constructor in Program.cs

**Issue**: "Ice damage not amplified"
- **Solution**: Check damage type string comparison (case-insensitive)

**Issue**: "[Brittle] not applying"
- **Solution**: Verify enemy has Ice Resistance > 0% in spawn_rules_json

**Issue**: "Slippery terrain check not triggering"
- **Solution**: Verify room.BiomeName == "Niflheim" (exact match)

---

## VIII. Code Review Checklist

Before committing integration:
- [ ] All biome services injected via DI
- [ ] Null checks on optional biome services
- [ ] Case-insensitive biome name comparisons
- [ ] Logging added for all biome-specific actions
- [ ] Combat log entries are user-friendly
- [ ] No hardcoded magic values (use service constants)
- [ ] Edge cases handled (null rooms, missing biome data)
- [ ] Compilation successful
- [ ] No breaking changes to existing code
- [ ] Unit tests pass (if applicable)

---

## IX. Performance Considerations

### Optimization Notes

1. **Biome Name Lookup**: Cache biome name in CombatState to avoid repeated lookups
2. **Service Null Checks**: Check once at combat start, store flag
3. **Logging**: Use Debug level for verbose mechanics, Information for key events
4. **Memory**: Brittleness service stores enemy resistance in memory - clear on combat end if needed

### Example Optimization:
```csharp
// In InitializeCombat
combatState.IsNiflheim = currentRoom?.BiomeName?.Equals("Niflheim") ?? false;
combatState.IsMuspelheim = currentRoom?.BiomeName?.Equals("Muspelheim") ?? false;

// Later
if (combatState.IsNiflheim && _niflheimBiomeService != null)
{
    // No repeated string comparison
}
```

---

## X. Next Steps After Integration

1. **Unit Tests**: Create tests for each integration point
2. **Balance Tuning**: Adjust damage values based on playtesting
3. **Documentation**: Update user-facing documentation
4. **Performance**: Profile combat with biome mechanics
5. **Edge Cases**: Test interactions with other systems (abilities, equipment, etc.)

---

**Implementation Guide Complete**
**Version**: v0.30.5
**Date**: 2025-11-16
**Status**: Ready for Development
