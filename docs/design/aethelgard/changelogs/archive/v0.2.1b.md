> **Archived** - This changelog has been consolidated. See the complete version at [v0.2.1](../v0.2.x/v0.2.1.md).

# Changelog: v0.2.1b - The Affliction (Status Effects)

**Release Date:** 2025-12-20
**Codename:** The Affliction
**Test Coverage:** 1327 tests passing
**Build Status:** SUCCESS

---

## Summary

This release implements a comprehensive status effect system for combat. The system supports damage-over-time effects (Bleeding, Poisoned), crowd control (Stunned), and stat modifiers (Vulnerable, Fortified). Effects integrate with the existing combat turn lifecycle and attack resolution system.

### Key Features
- **7 Status Effect Types**: 4 debuffs (Bleeding, Poisoned, Stunned, Vulnerable) and 3 buffs (Fortified, Hasted, Inspired)
- **Stacking System**: Intensify stacking for DoT effects (up to 5 stacks) vs duration refresh for control effects
- **Turn Lifecycle Integration**: DoT damage at turn start, stun skip, duration decrement at turn end
- **Combat Stat Modifiers**: Fortified adds soak, Vulnerable amplifies damage taken
- **UI Display**: Status effect icons in combat view

### Architectural Overview

```
┌─────────────────┐     ┌──────────────────────┐     ┌─────────────────────┐
│   CombatService │────▶│  StatusEffectService │────▶│   Combatant         │
│   (NextTurn)    │     │  (ProcessTurnStart)  │     │   .StatusEffects[]  │
└─────────────────┘     └──────────────────────┘     └─────────────────────┘
         │                        │
         │                        ▼
         │              ┌──────────────────────┐
         │              │   AttackResolution   │
         │              │   (GetSoakModifier)  │
         └─────────────▶└──────────────────────┘
```

---

## Files Created

| File Path | Description |
|-----------|-------------|
| `RuneAndRust.Core/Enums/StatusEffectType.cs` | Enum defining 7 status effect types (debuffs 0-99, buffs 100+) |
| `RuneAndRust.Core/Models/Combat/ActiveStatusEffect.cs` | Model tracking effect state: type, stacks, duration, source |
| `RuneAndRust.Core/Interfaces/IStatusEffectService.cs` | Service contract with 11 methods for effect lifecycle |
| `RuneAndRust.Engine/Services/StatusEffectService.cs` | Full implementation with Serilog logging |
| `RuneAndRust.Tests/Engine/StatusEffectServiceTests.cs` | 35 unit and integration tests |

---

## Files Modified

| File Path | Changes |
|-----------|---------|
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added `StatusEffects` list property for combat-volatile effect tracking |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `IStatusEffectService` dependency; integrated DoT damage, stun check, and duration processing into turn lifecycle; updated `MapToView` for effect display |
| `RuneAndRust.Engine/Services/AttackResolutionService.cs` | Added `IStatusEffectService` dependency; integrated soak modifier (Fortified) and damage multiplier (Vulnerable) into damage calculation |
| `RuneAndRust.Terminal/Program.cs` | Registered `IStatusEffectService` and `ILootService` in DI container |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added `IStatusEffectService` mock with default behavior |
| `RuneAndRust.Tests/Engine/AttackResolutionServiceTests.cs` | Added `IStatusEffectService` mock with default behavior |

---

## Code Implementation Details

### StatusEffectType Enum

```csharp
public enum StatusEffectType
{
    // Debuffs (0-99)
    Bleeding = 0,    // Physical DoT, ignores soak, stacks to 5
    Poisoned = 1,    // Poison DoT, applies soak, stacks to 5
    Stunned = 2,     // Skip turn, no stacking
    Vulnerable = 3,  // +50% damage taken

    // Buffs (100+)
    Fortified = 100, // +2 soak per stack
    Hasted = 101,    // Future: extra action
    Inspired = 102   // Future: +1 damage die
}
```

### ActiveStatusEffect Model

```csharp
public class ActiveStatusEffect
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public StatusEffectType Type { get; set; }
    public int Stacks { get; set; } = 1;
    public int DurationRemaining { get; set; }
    public Guid SourceId { get; set; }

    public static int GetMaxStacks(StatusEffectType type) => type switch
    {
        StatusEffectType.Bleeding => 5,
        StatusEffectType.Poisoned => 5,
        StatusEffectType.Fortified => 5,
        _ => 1
    };

    public static bool CanStack(StatusEffectType type) => type switch
    {
        StatusEffectType.Bleeding => true,
        StatusEffectType.Poisoned => true,
        StatusEffectType.Fortified => true,
        _ => false
    };
}
```

### IStatusEffectService Interface

```csharp
public interface IStatusEffectService
{
    void ApplyEffect(Combatant target, StatusEffectType type, int duration, Guid sourceId);
    void RemoveEffect(Combatant target, StatusEffectType type);
    void ClearAllEffects(Combatant target);
    int ProcessTurnStart(Combatant combatant);
    bool CanAct(Combatant combatant);
    void ProcessTurnEnd(Combatant combatant);
    int GetSoakModifier(Combatant combatant);
    float GetDamageMultiplier(Combatant combatant);
    IReadOnlyList<ActiveStatusEffect> GetActiveEffects(Combatant combatant);
    bool HasEffect(Combatant combatant, StatusEffectType type);
    int GetEffectStacks(Combatant combatant, StatusEffectType type);
}
```

### StatusEffectService Implementation Highlights

#### Effect Application with Stacking Logic

```csharp
public void ApplyEffect(Combatant target, StatusEffectType type, int duration, Guid sourceId)
{
    var existing = target.StatusEffects.FirstOrDefault(e => e.Type == type);

    if (existing != null)
    {
        if (ActiveStatusEffect.CanStack(type))
        {
            var maxStacks = ActiveStatusEffect.GetMaxStacks(type);
            if (existing.Stacks < maxStacks)
            {
                existing.Stacks++;
            }
            existing.DurationRemaining = duration;
        }
        else
        {
            existing.DurationRemaining = duration;
        }
    }
    else
    {
        target.StatusEffects.Add(new ActiveStatusEffect
        {
            Type = type,
            Stacks = 1,
            DurationRemaining = duration,
            SourceId = sourceId
        });
    }
}
```

#### DoT Processing at Turn Start

```csharp
public int ProcessTurnStart(Combatant combatant)
{
    var totalDamage = 0;

    // Bleeding: ignores soak
    var bleeding = combatant.StatusEffects.FirstOrDefault(e => e.Type == StatusEffectType.Bleeding);
    if (bleeding != null)
    {
        var damage = 0;
        for (var i = 0; i < bleeding.Stacks; i++)
        {
            damage += _dice.RollSingle(6, $"Bleeding Tick ({i + 1}/{bleeding.Stacks})");
        }
        totalDamage += damage;
    }

    // Poisoned: applies soak
    var poisoned = combatant.StatusEffects.FirstOrDefault(e => e.Type == StatusEffectType.Poisoned);
    if (poisoned != null)
    {
        var rawDamage = 0;
        for (var i = 0; i < poisoned.Stacks; i++)
        {
            rawDamage += _dice.RollSingle(6, $"Poison Tick ({i + 1}/{poisoned.Stacks})");
        }
        var soak = combatant.ArmorSoak + GetSoakModifier(combatant);
        var finalDamage = rawDamage > 0 ? Math.Max(1, rawDamage - soak) : 0;
        totalDamage += finalDamage;
    }

    return totalDamage;
}
```

### CombatService NextTurn Integration

```csharp
public void NextTurn()
{
    // ... existing validation and turn index logic ...

    var active = state.ActiveCombatant;
    if (active != null)
    {
        // Process turn start: apply DoT damage
        var dotDamage = _statusEffects.ProcessTurnStart(active);
        if (dotDamage > 0)
        {
            active.CurrentHp -= dotDamage;
            LogCombatEvent($"[yellow]{active.Name}[/] takes [red]{dotDamage}[/] damage from status effects!");

            if (active.CurrentHp <= 0)
            {
                LogCombatEvent($"[red]{active.Name}[/] has fallen to their wounds!");
                RemoveDefeatedCombatant(active);
                if (CheckVictoryCondition()) return;
                NextTurn();
                return;
            }
        }

        // Check if stunned
        if (!_statusEffects.CanAct(active))
        {
            LogCombatEvent($"[yellow]{active.Name}[/] is [purple]stunned[/] and loses their turn!");
            _statusEffects.ProcessTurnEnd(active);
            NextTurn();
            return;
        }
    }
}
```

### AttackResolutionService Damage Calculation

```csharp
// Apply damage multiplier from status effects (e.g., Vulnerable)
var damageMultiplier = _statusEffects.GetDamageMultiplier(defender);
var modifiedDamage = (int)(rawDamage * damageMultiplier);

// Calculate soak from defender's armor + status effects (e.g., Fortified)
var baseSoak = defender.ArmorSoak;
var soakModifier = _statusEffects.GetSoakModifier(defender);
var totalSoak = baseSoak + soakModifier;

// Final damage (minimum 1 on hit)
finalDamage = Math.Max(1, modifiedDamage - totalSoak);
```

### Combat UI Status Effect Display

```csharp
var effectIcons = string.Join(" ", combatant.StatusEffects.Select(e => e.Type switch
{
    StatusEffectType.Bleeding => $"[red]BLD×{e.Stacks}[/]",
    StatusEffectType.Poisoned => $"[green]PSN×{e.Stacks}[/]",
    StatusEffectType.Stunned => "[purple]STUN[/]",
    StatusEffectType.Vulnerable => "[orange1]VULN[/]",
    StatusEffectType.Fortified => $"[blue]FRT×{e.Stacks}[/]",
    StatusEffectType.Hasted => "[cyan]HAST[/]",
    StatusEffectType.Inspired => "[yellow]INSP[/]",
    _ => ""
}));
```

---

## Damage Calculation Examples

### Example 1: Bleeding DoT (3 Stacks)

```
Turn Start:
  Bleeding Stacks: 3
  Dice Rolls: d6=4, d6=3, d6=5
  Total Damage: 4 + 3 + 5 = 12 (ignores soak)
```

### Example 2: Poisoned DoT with Soak

```
Turn Start:
  Poisoned Stacks: 2
  Dice Rolls: d6=5, d6=4
  Raw Damage: 9
  Armor Soak: 3
  Final Damage: max(1, 9 - 3) = 6
```

### Example 3: Vulnerable Target Taking Attack

```
Attack Resolution:
  Raw Damage: 10
  Vulnerable Multiplier: 1.5
  Modified Damage: 10 × 1.5 = 15
  Defender Soak: 4
  Final Damage: max(1, 15 - 4) = 11
```

### Example 4: Fortified Defender

```
Attack Resolution:
  Raw Damage: 8
  Defender Armor Soak: 2
  Fortified Stacks: 3
  Fortified Bonus: 3 × 2 = +6
  Total Soak: 2 + 6 = 8
  Final Damage: max(1, 8 - 8) = 1 (minimum)
```

---

## Logging Matrix

| Event | Level | Template |
|-------|-------|----------|
| Effect applied | Information | `"Applied {Type} to {Target} (Stacks: {Stacks}, Duration: {Duration})"` |
| Effect stacked | Debug | `"Stacked {Type} on {Target}: {OldStacks} -> {NewStacks}"` |
| Effect refreshed | Debug | `"Refreshed {Type} duration on {Target}: {Duration} turns"` |
| DoT tick | Information | `"{Target} takes {Damage} {Type} damage (Stacks: {Stacks})"` |
| DoT soak applied | Debug | `"Poisoned damage reduced by soak: {Raw} - {Soak} = {Final}"` |
| Effect expired | Information | `"{Type} expired on {Target}"` |
| Turn skipped | Information | `"{Target} is stunned and loses their turn"` |
| Soak modifier | Debug | `"Soak modifier for {Target}: +{Modifier} from Fortified (×{Stacks})"` |
| Damage multiplier | Debug | `"Damage multiplier for {Target}: ×{Multiplier} from Vulnerable"` |

---

## Test Coverage

### StatusEffectServiceTests.cs (35 tests)

#### Apply Effect Tests
- `ApplyEffect_NewEffect_AddsToList`
- `ApplyEffect_StackableEffect_IncreasesStacks`
- `ApplyEffect_AtMaxStacks_RefreshesDurationOnly`
- `ApplyEffect_NonStackable_RefreshesDurationOnly`
- `ApplyEffect_DifferentTypes_AddsSeparateEffects`
- `ApplyEffect_Fortified_StacksCorrectly`

#### Remove Effect Tests
- `RemoveEffect_ExistingEffect_RemovesFromList`
- `RemoveEffect_NonExistentEffect_NoException`
- `ClearAllEffects_RemovesAllEffects`

#### DoT Processing Tests
- `ProcessTurnStart_Bleeding_DealsDamage`
- `ProcessTurnStart_BleedingMultiStack_MultipliesDamage`
- `ProcessTurnStart_Poisoned_AppliesSoak`
- `ProcessTurnStart_PoisonedWithHighSoak_MinimumOneDamage`
- `ProcessTurnStart_NoDoTEffects_ReturnsZero`
- `ProcessTurnStart_BleedingAndPoisoned_DealsCombinedDamage`

#### Can Act Tests
- `CanAct_WhenStunned_ReturnsFalse`
- `CanAct_WhenNotStunned_ReturnsTrue`
- `CanAct_NoEffects_ReturnsTrue`

#### Turn End Tests
- `ProcessTurnEnd_DecrementsAllDurations`
- `ProcessTurnEnd_RemovesExpiredEffects`
- `ProcessTurnEnd_AllEffectsExpire_ListBecomesEmpty`
- `ProcessTurnEnd_NoEffects_NoException`

#### Modifier Tests
- `GetSoakModifier_NoFortified_ReturnsZero`
- `GetSoakModifier_Fortified_ReturnsStackBonus`
- `GetSoakModifier_FortifiedMultiStack_ReturnsScaledBonus`
- `GetDamageMultiplier_NoVulnerable_ReturnsOne`
- `GetDamageMultiplier_Vulnerable_ReturnsOnePointFive`

#### Query Tests
- `HasEffect_WithEffect_ReturnsTrue`
- `HasEffect_WithoutEffect_ReturnsFalse`
- `GetEffectStacks_ExistingEffect_ReturnsStackCount`
- `GetEffectStacks_NoEffect_ReturnsZero`
- `GetActiveEffects_ReturnsReadOnlyList`

#### Integration Tests
- `Integration_StunLoop_ProcessesCorrectly`
- `Integration_BleedDeath_AccumulatesDamage`
- `Integration_FortifiedPoisoned_SoakApplies`

---

## DI Registration

```csharp
// Register Combat Services
services.AddSingleton<IInitiativeService, InitiativeService>();
services.AddSingleton<IStatusEffectService, StatusEffectService>();  // NEW
services.AddSingleton<IAttackResolutionService, AttackResolutionService>();
services.AddScoped<ILootService, LootService>();
services.AddSingleton<ICombatService, CombatService>();
services.AddSingleton<ICombatScreenRenderer, CombatScreenRenderer>();
```

---

## Breaking Changes

### Constructor Signature Changes

**CombatService** - Added `IStatusEffectService` parameter:
```csharp
// Before
public CombatService(GameState, IInitiativeService, IAttackResolutionService, ILootService, ILogger<CombatService>)

// After
public CombatService(GameState, IInitiativeService, IAttackResolutionService, ILootService, IStatusEffectService, ILogger<CombatService>)
```

**AttackResolutionService** - Added `IStatusEffectService` parameter:
```csharp
// Before
public AttackResolutionService(IDiceService, ILogger<AttackResolutionService>)

// After
public AttackResolutionService(IDiceService, IStatusEffectService, ILogger<AttackResolutionService>)
```

---

## Directory Structure Changes

```
RuneAndRust.Core/
├── Enums/
│   ├── StatusEffectType.cs          [NEW]
│   ├── AttackType.cs
│   └── AttackOutcome.cs
├── Models/Combat/
│   ├── ActiveStatusEffect.cs        [NEW]
│   ├── Combatant.cs                 [MODIFIED - StatusEffects list]
│   ├── CombatState.cs
│   ├── CombatResult.cs
│   └── AttackResult.cs
└── Interfaces/
    ├── IStatusEffectService.cs      [NEW]
    ├── ICombatService.cs
    └── IAttackResolutionService.cs

RuneAndRust.Engine/Services/
├── StatusEffectService.cs           [NEW]
├── CombatService.cs                 [MODIFIED - status integration]
└── AttackResolutionService.cs       [MODIFIED - modifier queries]

RuneAndRust.Tests/Engine/
├── StatusEffectServiceTests.cs      [NEW - 35 tests]
├── CombatServiceTests.cs            [MODIFIED - mock setup]
└── AttackResolutionServiceTests.cs  [MODIFIED - mock setup]
```

---

## Future Considerations

### Reserved Effect Types (Not Yet Implemented)
- **Hasted**: Extra action per turn
- **Inspired**: +1 bonus die to damage rolls

### Potential Expansions
- Effect immunity system (e.g., Skeleton vs Bleeding)
- Effect stacking from multiple sources
- Effect dispel/cleanse mechanics
- Status effect triggers from weapon enchantments

---

## Build Verification

```bash
$ dotnet build
Build succeeded.
63 Warning(s) - Pre-existing xUnit async warnings
0 Error(s)

$ dotnet test
Passed!  - Failed: 0, Passed: 1327, Skipped: 0, Total: 1327, Duration: 560 ms
```

---

**v0.2.1b Codename: The Affliction**
*"Wounds that fester, poisons that spread, and the cold grip of paralysis."*
