# Implementation Plan: v0.4.2c - The Voice (Dialogue Service & Effects)

**Status:** Ready for Implementation
**Theme:** "The Voice"
**Scope:** DialogueService for conversation flow, DialogueEffectExecutor for effect execution, dialogue events, session state management
**Depends On:** v0.4.2a (FactionService), v0.4.2b (Dialogue data models, conditions)

---

## Executive Summary

v0.4.2c implements the **Dialogue Runtime Engine** — the service layer that drives branching conversations and executes dialogue effects. This release transforms the static dialogue trees from v0.4.2b into interactive, stateful conversations that modify game state.

**Key Features:**
- **DialogueService:** StartDialogue, SelectOption, GetCurrentState, EndDialogue workflow
- **DialogueSession:** Stateful session tracking with visited nodes and local flags
- **DialogueEffectExecutor:** Polymorphic effect execution (ModifyReputation, GiveItem, SetFlag, etc.)
- **Dialogue Events:** `DialogueStartedEvent`, `DialogueOptionSelectedEvent`, `DialogueEndedEvent`
- **GameState Integration:** `CurrentDialogueSession` for active dialogue tracking

**Layers Touched:** Core (Models, Events, Interfaces), Engine (Services), Tests
**Patterns Used:** State machine, Effect executor, Event bus publishing, Session management
**Target Test Count:** 45 unit tests

---

## Table of Contents

1. [Decision Trees](#1-decision-trees)
2. [Deliverable Checklist](#2-deliverable-checklist)
3. [Model Definitions](#3-model-definitions)
4. [Event Definitions](#4-event-definitions)
5. [Interface Definitions](#5-interface-definitions)
6. [DialogueService Implementation](#6-dialogueservice-implementation)
7. [DialogueEffectExecutor Implementation](#7-dialogueeffectexecutor-implementation)
8. [GameState Extension](#8-gamestate-extension)
9. [DI Registration](#9-di-registration)
10. [Logging Matrix](#10-logging-matrix)
11. [Test Coverage Plan](#11-test-coverage-plan)
12. [Code Examples](#12-code-examples)
13. [Error Handling](#13-error-handling)
14. [Changelog Template](#14-changelog-template)
15. [Critical Files](#15-critical-files)
16. [Implementation Order](#16-implementation-order)
17. [Design Decisions](#17-design-decisions)
18. [Integration Points](#18-integration-points)

---

## 1. Decision Trees

### 1.1 StartDialogue Flow

```
StartDialogueAsync(characterId, npcTreeId)
                │
                ▼
    ┌───────────────────────────────┐
    │ Log entry at Info level       │
    │ "[Dialogue] Starting dialogue │
    │  with {NpcTreeId}"            │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Already in dialogue?          │
    │ (GameState.CurrentDialogue    │
    │  != null)                     │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Return Fail:    │  │ Load DialogueTree from        │
│ "Already in     │  │ repository by npcTreeId       │
│  dialogue"      │  └───────────────────────────────┘
└─────────────────┘              │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Tree exists?                  │
                    └───────────────────────────────┘
                                 │
                         ┌───────┴───────┐
                        No              Yes
                         │                │
                         ▼                ▼
                 ┌─────────────────┐  ┌───────────────────────────────┐
                 │ Return Fail:    │  │ Resolve root node from        │
                 │ "NPC not found" │  │ tree.RootNodeId               │
                 └─────────────────┘  └───────────────────────────────┘
                                                 │
                                                 ▼
                                    ┌───────────────────────────────┐
                                    │ Root node exists?             │
                                    └───────────────────────────────┘
                                                 │
                                         ┌───────┴───────┐
                                        No              Yes
                                         │                │
                                         ▼                ▼
                                 ┌─────────────────┐  ┌───────────────────────────────┐
                                 │ Return Fail:    │  │ Create DialogueSession:       │
                                 │ "Invalid tree"  │  │ - SessionId = NewGuid()       │
                                 └─────────────────┘  │ - CharacterId                 │
                                                      │ - TreeId                      │
                                                      │ - CurrentNodeId = rootNode.Id │
                                                      │ - VisitedNodeIds = [root]     │
                                                      │ - StartedAt = UtcNow          │
                                                      └───────────────────────────────┘
                                                                 │
                                                                 ▼
                                                    ┌───────────────────────────────┐
                                                    │ Set GameState.CurrentDialogue │
                                                    │ Session = session             │
                                                    └───────────────────────────────┘
                                                                 │
                                                                 ▼
                                                    ┌───────────────────────────────┐
                                                    │ Evaluate options for root node│
                                                    │ via IDialogueConditionEvaluator│
                                                    └───────────────────────────────┘
                                                                 │
                                                                 ▼
                                                    ┌───────────────────────────────┐
                                                    │ Build DialogueViewModel       │
                                                    │ (NPC info, text, options)     │
                                                    └───────────────────────────────┘
                                                                 │
                                                                 ▼
                                                    ┌───────────────────────────────┐
                                                    │ Publish DialogueStartedEvent  │
                                                    └───────────────────────────────┘
                                                                 │
                                                                 ▼
                                                    ┌───────────────────────────────┐
                                                    │ Log success at Info level     │
                                                    │ "[Dialogue] Started with      │
                                                    │  {NpcName}, node: {NodeId}"   │
                                                    └───────────────────────────────┘
                                                                 │
                                                                 ▼
                                                    ┌───────────────────────────────┐
                                                    │ Return DialogueStartResult    │
                                                    │ .Success(viewModel)           │
                                                    └───────────────────────────────┘
```

### 1.2 SelectOption Flow

```
SelectOptionAsync(optionId)
                │
                ▼
    ┌───────────────────────────────┐
    │ Log entry at Debug level      │
    │ "[Dialogue] SelectOption:     │
    │  {OptionId}"                  │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ In dialogue?                  │
    │ (session != null)             │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       No              Yes
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Return Fail:    │  │ Get current node from         │
│ "No active      │  │ session.CurrentNodeId         │
│  dialogue"      │  └───────────────────────────────┘
└─────────────────┘              │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Find option by optionId       │
                    │ in current node.Options       │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Option exists?                │
                    └───────────────────────────────┘
                                 │
                         ┌───────┴───────┐
                        No              Yes
                         │                │
                         ▼                ▼
                 ┌─────────────────┐  ┌───────────────────────────────┐
                 │ Return Fail:    │  │ Re-evaluate option conditions │
                 │ "Invalid option"│  │ (prevent race conditions)     │
                 └─────────────────┘  └───────────────────────────────┘
                                                 │
                                                 ▼
                                    ┌───────────────────────────────┐
                                    │ Option available?             │
                                    └───────────────────────────────┘
                                                 │
                                         ┌───────┴───────┐
                                        No              Yes
                                         │                │
                                         ▼                ▼
                                 ┌─────────────────┐  ┌───────────────────────────────┐
                                 │ Return Fail:    │  │ Execute effects via           │
                                 │ "Option locked" │  │ IDialogueEffectExecutor       │
                                 └─────────────────┘  └───────────────────────────────┘
                                                                 │
                                                                 ▼
                                                    ┌───────────────────────────────┐
                                                    │ Publish DialogueOption        │
                                                    │ SelectedEvent                 │
                                                    └───────────────────────────────┘
                                                                 │
                                                                 ▼
                                                    ┌───────────────────────────────┐
                                                    │ option.IsTerminal?            │
                                                    │ (NextNodeId == null)          │
                                                    └───────────────────────────────┘
                                                                 │
                                                         ┌───────┴───────┐
                                                        Yes              No
                                                         │                │
                                                         ▼                ▼
                                    ┌─────────────────────────────┐  ┌───────────────────────────────┐
                                    │ Call EndDialogueAsync()     │  │ Navigate to next node:        │
                                    │ internally                  │  │ - Resolve node by NextNodeId  │
                                    └─────────────────────────────┘  │ - Update session.CurrentNodeId│
                                                 │                   │ - Add to VisitedNodeIds       │
                                                 │                   └───────────────────────────────┘
                                                 │                               │
                                                 │                               ▼
                                                 │                  ┌───────────────────────────────┐
                                                 │                  │ Evaluate options for new node │
                                                 │                  └───────────────────────────────┘
                                                 │                               │
                                                 │                               ▼
                                                 │                  ┌───────────────────────────────┐
                                                 │                  │ Build DialogueViewModel       │
                                                 │                  │ for new node                  │
                                                 │                  └───────────────────────────────┘
                                                 │                               │
                                                 └───────────┬───────────────────┘
                                                             │
                                                             ▼
                                                ┌───────────────────────────────┐
                                                │ Return DialogueStepResult     │
                                                │ (IsComplete, ViewModel,       │
                                                │  EffectsExecuted)             │
                                                └───────────────────────────────┘
```

### 1.3 ExecuteEffects Flow

```
ExecuteEffectsAsync(character, effects)
                │
                ▼
    ┌───────────────────────────────┐
    │ Log entry at Debug level      │
    │ "[Dialogue] Executing {Count} │
    │  effects"                     │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ effects empty?               │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Return Empty    │  │ For each effect in effects:   │
│ Result          │  └───────────────────────────────┘
└─────────────────┘              │
                    ┌────────────┼────────────┬────────────┬────────────┐
                    │            │            │            │            │
             ModifyRep      GiveItem      SetFlag      StartQuest   (others)
                    │            │            │            │            │
                    ▼            ▼            ▼            ▼            ▼
           ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ...
           │ Call        │ │ Call        │ │ Update      │ │ Publish     │
           │ IFaction    │ │ IInventory  │ │ GameState   │ │ QuestStart  │
           │ Service.    │ │ Service.    │ │ .Flags      │ │ Event       │
           │ ModifyRep   │ │ AddItem     │ │ [key]=val   │ │ (future)    │
           └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘
                    │            │            │            │
                    ▼            ▼            ▼            ▼
           ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
           │ Log Info:   │ │ Log Info:   │ │ Log Info:   │ │ Log Info:   │
           │ "Rep +{N}   │ │ "Gave {Item}│ │ "Flag       │ │ "Quest      │
           │  with {Fac}"│ │  x{Qty}"    │ │  {Key}=     │ │  {QuestId}  │
           └─────────────┘ └─────────────┘ │  {Val}"     │ │  started"   │
                    │            │         └─────────────┘ └─────────────┘
                    └────────────┴─────────────┬─────────────────────────┘
                                               │
                                               ▼
                                  ┌───────────────────────────────┐
                                  │ Aggregate results into        │
                                  │ DialogueEffectResult          │
                                  └───────────────────────────────┘
                                               │
                                               ▼
                                  ┌───────────────────────────────┐
                                  │ Log summary at Info level     │
                                  │ "[Dialogue] Effects complete: │
                                  │  {Summary}"                   │
                                  └───────────────────────────────┘
                                               │
                                               ▼
                                  ┌───────────────────────────────┐
                                  │ Return DialogueEffectResult   │
                                  └───────────────────────────────┘
```

### 1.4 EndDialogue Flow

```
EndDialogueAsync(reason)
                │
                ▼
    ┌───────────────────────────────┐
    │ In dialogue?                  │
    │ (session != null)             │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       No              Yes
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Return Fail:    │  │ Capture session metadata:     │
│ "No active      │  │ - Duration = now - startedAt  │
│  dialogue"      │  │ - NodesVisited count          │
└─────────────────┘  │ - ChoicesMade count           │
                     └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Clear GameState.Current       │
                    │ DialogueSession = null        │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Publish DialogueEndedEvent    │
                    │ (SessionId, NpcId, Reason,    │
                    │  Duration, NodesVisited)      │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Log at Info level:            │
                    │ "[Dialogue] Ended with        │
                    │  {NpcName}, reason: {Reason}, │
                    │  duration: {Duration}s"       │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Return DialogueEndResult      │
                    │ .Success(summary)             │
                    └───────────────────────────────┘
```

### 1.5 GetCurrentState Flow

```
GetCurrentState()
                │
                ▼
    ┌───────────────────────────────┐
    │ session = GameState.          │
    │ CurrentDialogueSession        │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ session != null?              │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       No              Yes
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Return null     │  │ Build DialogueViewModel from  │
│                 │  │ cached session data           │
└─────────────────┘  └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Return viewModel              │
                    └───────────────────────────────┘
```

---

## 2. Deliverable Checklist

### New Files to Create

| Layer | File Path | Purpose |
|-------|-----------|---------|
| Core | `RuneAndRust.Core/Models/DialogueSession.cs` | Active dialogue session state |
| Core | `RuneAndRust.Core/Models/DialogueViewModel.cs` | DTO for UI rendering |
| Core | `RuneAndRust.Core/Models/DialogueOptionViewModel.cs` | Option DTO with visibility |
| Core | `RuneAndRust.Core/Models/DialogueStartResult.cs` | Result of StartDialogue |
| Core | `RuneAndRust.Core/Models/DialogueStepResult.cs` | Result of SelectOption |
| Core | `RuneAndRust.Core/Models/DialogueEndResult.cs` | Result of EndDialogue |
| Core | `RuneAndRust.Core/Models/DialogueEffectResult.cs` | Result of effect execution |
| Core | `RuneAndRust.Core/Enums/DialogueEndReason.cs` | Reason for dialogue ending |
| Core | `RuneAndRust.Core/Events/DialogueStartedEvent.cs` | Event when dialogue begins |
| Core | `RuneAndRust.Core/Events/DialogueOptionSelectedEvent.cs` | Event when option chosen |
| Core | `RuneAndRust.Core/Events/DialogueEndedEvent.cs` | Event when dialogue ends |
| Core | `RuneAndRust.Core/Interfaces/IDialogueService.cs` | Service interface |
| Core | `RuneAndRust.Core/Interfaces/IDialogueEffectExecutor.cs` | Effect executor interface |
| Engine | `RuneAndRust.Engine/Services/DialogueService.cs` | Service implementation |
| Engine | `RuneAndRust.Engine/Services/DialogueEffectExecutor.cs` | Effect executor implementation |
| Tests | `RuneAndRust.Tests/Engine/DialogueServiceTests.cs` | 30 unit tests |
| Tests | `RuneAndRust.Tests/Engine/DialogueEffectExecutorTests.cs` | 15 unit tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/GameState.cs` | Add `CurrentDialogueSession` and `GameFlags` properties |
| `RuneAndRust.Terminal/Program.cs` | Register `IDialogueService`, `IDialogueEffectExecutor` |

---

## 3. Model Definitions

### 3.1 DialogueSession

**File:** `RuneAndRust.Core/Models/DialogueSession.cs`

```csharp
using System.Text.Json.Serialization;

namespace RuneAndRust.Core.Models;

/// <summary>
/// Represents an active dialogue session between a character and NPC.
/// Tracks current position in dialogue tree and session-scoped state.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public class DialogueSession
{
    /// <summary>
    /// Unique identifier for this session.
    /// </summary>
    public Guid SessionId { get; set; } = Guid.NewGuid();

    /// <summary>
    /// The character engaged in dialogue.
    /// </summary>
    public Guid CharacterId { get; set; }

    /// <summary>
    /// The dialogue tree being traversed.
    /// </summary>
    public Guid TreeId { get; set; }

    /// <summary>
    /// String ID of the tree for lookups.
    /// </summary>
    public string TreeStringId { get; set; } = string.Empty;

    /// <summary>
    /// The NPC's display name.
    /// </summary>
    public string NpcName { get; set; } = string.Empty;

    /// <summary>
    /// The NPC's title (e.g., "Iron-Bane Elder").
    /// </summary>
    public string? NpcTitle { get; set; }

    /// <summary>
    /// Current node in the dialogue tree.
    /// </summary>
    public Guid CurrentNodeId { get; set; }

    /// <summary>
    /// String ID of current node for logging.
    /// </summary>
    public string CurrentNodeStringId { get; set; } = string.Empty;

    /// <summary>
    /// Nodes visited during this session (for branching logic).
    /// </summary>
    public HashSet<string> VisitedNodeIds { get; set; } = new();

    /// <summary>
    /// Options selected during this session (for analytics/logging).
    /// </summary>
    public List<DialogueChoiceRecord> ChoicesMade { get; set; } = new();

    /// <summary>
    /// Session-scoped flags (reset when dialogue ends).
    /// Used for within-conversation state tracking.
    /// </summary>
    public Dictionary<string, object> LocalFlags { get; set; } = new();

    /// <summary>
    /// When the dialogue started.
    /// </summary>
    public DateTime StartedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// How long the session has been active.
    /// </summary>
    [JsonIgnore]
    public TimeSpan Duration => DateTime.UtcNow - StartedAt;

    /// <summary>
    /// Number of nodes visited.
    /// </summary>
    [JsonIgnore]
    public int NodesVisitedCount => VisitedNodeIds.Count;
}

/// <summary>
/// Record of a choice made during dialogue.
/// </summary>
public record DialogueChoiceRecord(
    string NodeId,
    Guid OptionId,
    string OptionText,
    DateTime SelectedAt);
```

### 3.2 DialogueViewModel

**File:** `RuneAndRust.Core/Models/DialogueViewModel.cs`

```csharp
namespace RuneAndRust.Core.Models;

/// <summary>
/// View model representing the current dialogue state for UI rendering.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueViewModel(
    Guid SessionId,
    string NpcName,
    string? NpcTitle,
    string SpeakerName,
    string Text,
    bool IsTerminalNode,
    IReadOnlyList<DialogueOptionViewModel> Options)
{
    /// <summary>
    /// Whether any options are available (some may be locked).
    /// </summary>
    public bool HasAvailableOptions => Options.Any(o => o.IsAvailable);

    /// <summary>
    /// Count of visible options (includes locked but visible).
    /// </summary>
    public int VisibleOptionCount => Options.Count(o => o.IsVisible);
}
```

### 3.3 DialogueOptionViewModel

**File:** `RuneAndRust.Core/Models/DialogueOptionViewModel.cs`

```csharp
namespace RuneAndRust.Core.Models;

/// <summary>
/// View model for a single dialogue option with visibility and lock state.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueOptionViewModel(
    Guid OptionId,
    string Text,
    int DisplayOrder,
    bool IsVisible,
    bool IsAvailable,
    bool IsTerminal,
    string? LockHint,
    string? LockReason)
{
    /// <summary>
    /// Creates a visible and available option.
    /// </summary>
    public static DialogueOptionViewModel Available(
        Guid id, string text, int order, bool isTerminal) =>
        new(id, text, order, true, true, isTerminal, null, null);

    /// <summary>
    /// Creates a visible but locked option.
    /// </summary>
    public static DialogueOptionViewModel Locked(
        Guid id, string text, int order, bool isTerminal,
        string hint, string reason) =>
        new(id, text, order, true, false, isTerminal, hint, reason);

    /// <summary>
    /// Display text with lock indicator if locked.
    /// Example: "[WITS 6] I notice something is wrong..."
    /// </summary>
    public string DisplayText => IsAvailable
        ? Text
        : $"[LOCKED: {LockHint}] {Text}";
}
```

### 3.4 DialogueStartResult

**File:** `RuneAndRust.Core/Models/DialogueStartResult.cs`

```csharp
namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of starting a dialogue session.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueStartResult(
    bool IsSuccess,
    string? ErrorMessage,
    DialogueViewModel? ViewModel,
    Guid? SessionId)
{
    /// <summary>
    /// Creates a successful start result.
    /// </summary>
    public static DialogueStartResult Success(DialogueViewModel viewModel, Guid sessionId) =>
        new(true, null, viewModel, sessionId);

    /// <summary>
    /// Creates a failed start result.
    /// </summary>
    public static DialogueStartResult Fail(string error) =>
        new(false, error, null, null);
}
```

### 3.5 DialogueStepResult

**File:** `RuneAndRust.Core/Models/DialogueStepResult.cs`

```csharp
namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of selecting a dialogue option.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueStepResult(
    bool IsSuccess,
    string? ErrorMessage,
    bool IsDialogueComplete,
    DialogueViewModel? ViewModel,
    DialogueEffectResult? EffectsExecuted)
{
    /// <summary>
    /// Creates a successful step result (continuing dialogue).
    /// </summary>
    public static DialogueStepResult Continue(
        DialogueViewModel viewModel,
        DialogueEffectResult? effects = null) =>
        new(true, null, false, viewModel, effects);

    /// <summary>
    /// Creates a successful step result (dialogue ended).
    /// </summary>
    public static DialogueStepResult Complete(DialogueEffectResult? effects = null) =>
        new(true, null, true, null, effects);

    /// <summary>
    /// Creates a failed step result.
    /// </summary>
    public static DialogueStepResult Fail(string error) =>
        new(false, error, false, null, null);
}
```

### 3.6 DialogueEndResult

**File:** `RuneAndRust.Core/Models/DialogueEndResult.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of ending a dialogue session.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueEndResult(
    bool IsSuccess,
    string? ErrorMessage,
    Guid SessionId,
    string NpcName,
    DialogueEndReason Reason,
    TimeSpan Duration,
    int NodesVisited,
    int ChoicesMade)
{
    /// <summary>
    /// Creates a successful end result.
    /// </summary>
    public static DialogueEndResult Success(
        Guid sessionId, string npcName, DialogueEndReason reason,
        TimeSpan duration, int nodes, int choices) =>
        new(true, null, sessionId, npcName, reason, duration, nodes, choices);

    /// <summary>
    /// Creates a failed end result.
    /// </summary>
    public static DialogueEndResult Fail(string error) =>
        new(false, error, Guid.Empty, string.Empty,
            DialogueEndReason.Error, TimeSpan.Zero, 0, 0);
}
```

### 3.7 DialogueEffectResult

**File:** `RuneAndRust.Core/Models/DialogueEffectResult.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of executing dialogue effects.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueEffectResult(
    int EffectsExecuted,
    Dictionary<FactionType, int> ReputationChanges,
    List<string> ItemsGiven,
    List<string> ItemsRemoved,
    Dictionary<string, bool> FlagsSet,
    List<string> QuestsStarted,
    int HealingApplied,
    int XpGranted,
    List<string> Narratives)
{
    /// <summary>
    /// Empty result for when no effects are executed.
    /// </summary>
    public static DialogueEffectResult Empty => new(
        0, new(), new(), new(), new(), new(), 0, 0, new());

    /// <summary>
    /// Whether any effects were executed.
    /// </summary>
    public bool HasEffects => EffectsExecuted > 0;

    /// <summary>
    /// Combined narrative summary.
    /// </summary>
    public string CombinedNarrative => string.Join(" ", Narratives);
}
```

### 3.8 DialogueEndReason Enum

**File:** `RuneAndRust.Core/Enums/DialogueEndReason.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Reason for dialogue session ending.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public enum DialogueEndReason
{
    /// <summary>
    /// Player selected a terminal (goodbye) option.
    /// </summary>
    PlayerExit = 0,

    /// <summary>
    /// NPC ended the conversation (hostile, etc.).
    /// </summary>
    NpcExit = 1,

    /// <summary>
    /// Player pressed escape/cancel.
    /// </summary>
    PlayerCancel = 2,

    /// <summary>
    /// Combat or other event interrupted.
    /// </summary>
    Interrupted = 3,

    /// <summary>
    /// An error occurred.
    /// </summary>
    Error = 4
}
```

---

## 4. Event Definitions

### 4.1 DialogueStartedEvent

**File:** `RuneAndRust.Core/Events/DialogueStartedEvent.cs`

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Event published when a dialogue session begins.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueStartedEvent(
    Guid SessionId,
    Guid CharacterId,
    string CharacterName,
    Guid TreeId,
    string TreeStringId,
    string NpcName,
    string? NpcTitle,
    DateTime StartedAt);
```

### 4.2 DialogueOptionSelectedEvent

**File:** `RuneAndRust.Core/Events/DialogueOptionSelectedEvent.cs`

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Event published when a dialogue option is selected.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueOptionSelectedEvent(
    Guid SessionId,
    Guid OptionId,
    string OptionText,
    string FromNodeId,
    string? ToNodeId,
    bool IsTerminal,
    int EffectsExecutedCount,
    DateTime SelectedAt);
```

### 4.3 DialogueEndedEvent

**File:** `RuneAndRust.Core/Events/DialogueEndedEvent.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Events;

/// <summary>
/// Event published when a dialogue session ends.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public record DialogueEndedEvent(
    Guid SessionId,
    Guid CharacterId,
    string NpcName,
    DialogueEndReason Reason,
    TimeSpan Duration,
    int NodesVisited,
    int ChoicesMade,
    DateTime EndedAt);
```

---

## 5. Interface Definitions

### 5.1 IDialogueService

**File:** `RuneAndRust.Core/Interfaces/IDialogueService.cs`

```csharp
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for managing dialogue conversations.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public interface IDialogueService
{
    /// <summary>
    /// Starts a dialogue session with an NPC.
    /// </summary>
    /// <param name="character">The character initiating dialogue.</param>
    /// <param name="npcTreeId">The string ID of the dialogue tree (e.g., "npc_old_scavenger").</param>
    /// <returns>Result containing the initial dialogue state or error.</returns>
    Task<DialogueStartResult> StartDialogueAsync(Character character, string npcTreeId);

    /// <summary>
    /// Selects a dialogue option and advances the conversation.
    /// </summary>
    /// <param name="optionId">The ID of the option to select.</param>
    /// <returns>Result containing the next dialogue state or completion status.</returns>
    Task<DialogueStepResult> SelectOptionAsync(Guid optionId);

    /// <summary>
    /// Ends the current dialogue session.
    /// </summary>
    /// <param name="reason">Why the dialogue is ending.</param>
    /// <returns>Result containing session summary.</returns>
    Task<DialogueEndResult> EndDialogueAsync(DialogueEndReason reason);

    /// <summary>
    /// Gets the current dialogue state for UI rendering.
    /// Returns null if not in dialogue.
    /// </summary>
    DialogueViewModel? GetCurrentState();

    /// <summary>
    /// Whether a dialogue session is currently active.
    /// </summary>
    bool IsInDialogue { get; }

    /// <summary>
    /// Gets the current session if active.
    /// </summary>
    DialogueSession? CurrentSession { get; }

    /// <summary>
    /// Checks if dialogue is available with an NPC (not hostile, tree exists).
    /// </summary>
    /// <param name="character">The character.</param>
    /// <param name="npcTreeId">The NPC's dialogue tree ID.</param>
    /// <returns>True if dialogue can be initiated.</returns>
    Task<bool> IsDialogueAvailableAsync(Character character, string npcTreeId);
}
```

### 5.2 IDialogueEffectExecutor

**File:** `RuneAndRust.Core/Interfaces/IDialogueEffectExecutor.cs`

```csharp
using RuneAndRust.Core.Effects;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for executing dialogue effects when options are selected.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public interface IDialogueEffectExecutor
{
    /// <summary>
    /// Executes a list of dialogue effects.
    /// </summary>
    /// <param name="character">The character receiving effects.</param>
    /// <param name="effects">The effects to execute.</param>
    /// <param name="session">The current dialogue session for context.</param>
    /// <returns>Result containing all effect outcomes.</returns>
    Task<DialogueEffectResult> ExecuteEffectsAsync(
        Character character,
        IReadOnlyList<DialogueEffect> effects,
        DialogueSession session);

    /// <summary>
    /// Executes a single dialogue effect.
    /// </summary>
    Task<DialogueEffectResult> ExecuteEffectAsync(
        Character character,
        DialogueEffect effect,
        DialogueSession session);
}
```

---

## 6. DialogueService Implementation

**File:** `RuneAndRust.Engine/Services/DialogueService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Service for managing dialogue conversations.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public class DialogueService : IDialogueService
{
    private readonly IDialogueRepository _dialogueRepository;
    private readonly IDialogueConditionEvaluator _conditionEvaluator;
    private readonly IDialogueEffectExecutor _effectExecutor;
    private readonly IFactionService _factionService;
    private readonly IEventBus _eventBus;
    private readonly GameState _gameState;
    private readonly ILogger<DialogueService> _logger;

    public DialogueService(
        IDialogueRepository dialogueRepository,
        IDialogueConditionEvaluator conditionEvaluator,
        IDialogueEffectExecutor effectExecutor,
        IFactionService factionService,
        IEventBus eventBus,
        GameState gameState,
        ILogger<DialogueService> logger)
    {
        _dialogueRepository = dialogueRepository;
        _conditionEvaluator = conditionEvaluator;
        _effectExecutor = effectExecutor;
        _factionService = factionService;
        _eventBus = eventBus;
        _gameState = gameState;
        _logger = logger;

        _logger.LogTrace("[Dialogue] DialogueService initialized");
    }

    /// <inheritdoc/>
    public bool IsInDialogue => _gameState.CurrentDialogueSession != null;

    /// <inheritdoc/>
    public DialogueSession? CurrentSession => _gameState.CurrentDialogueSession;

    /// <inheritdoc/>
    public async Task<DialogueStartResult> StartDialogueAsync(
        Character character,
        string npcTreeId)
    {
        _logger.LogInformation("[Dialogue] Starting dialogue with '{TreeId}' for {CharName}",
            npcTreeId, character.Name);

        // Check if already in dialogue
        if (IsInDialogue)
        {
            _logger.LogWarning("[Dialogue] Attempted to start dialogue while already in dialogue");
            return DialogueStartResult.Fail("Already in dialogue. End current conversation first.");
        }

        // Load dialogue tree
        var tree = await _dialogueRepository.GetTreeByIdAsync(npcTreeId);
        if (tree == null)
        {
            _logger.LogWarning("[Dialogue] Dialogue tree not found: {TreeId}", npcTreeId);
            return DialogueStartResult.Fail($"NPC '{npcTreeId}' not found or has no dialogue.");
        }

        // Check faction disposition (refuse if Hated/Hostile for faction NPCs)
        if (tree.AssociatedFaction.HasValue)
        {
            var isAvailable = await IsDialogueAvailableAsync(character, npcTreeId);
            if (!isAvailable)
            {
                _logger.LogInformation("[Dialogue] NPC refuses dialogue due to hostile disposition");
                return DialogueStartResult.Fail($"{tree.NpcName} refuses to speak with you.");
            }
        }

        // Find root node
        var rootNode = tree.Nodes.FirstOrDefault(n => n.NodeId == tree.RootNodeId);
        if (rootNode == null)
        {
            _logger.LogError("[Dialogue] Root node '{RootNodeId}' not found in tree '{TreeId}'",
                tree.RootNodeId, npcTreeId);
            return DialogueStartResult.Fail("Dialogue tree is corrupted.");
        }

        // Create session
        var session = new DialogueSession
        {
            SessionId = Guid.NewGuid(),
            CharacterId = character.Id,
            TreeId = tree.Id,
            TreeStringId = tree.TreeId,
            NpcName = tree.NpcName,
            NpcTitle = tree.NpcTitle,
            CurrentNodeId = rootNode.Id,
            CurrentNodeStringId = rootNode.NodeId,
            VisitedNodeIds = new HashSet<string> { rootNode.NodeId },
            StartedAt = DateTime.UtcNow
        };

        // Store session in GameState
        _gameState.CurrentDialogueSession = session;

        // Evaluate options
        var optionResults = await _conditionEvaluator.EvaluateNodeOptionsAsync(character, rootNode);

        // Build view model
        var viewModel = BuildViewModel(session, rootNode, optionResults);

        // Publish event
        await _eventBus.PublishAsync(new DialogueStartedEvent(
            session.SessionId,
            character.Id,
            character.Name,
            tree.Id,
            tree.TreeId,
            tree.NpcName,
            tree.NpcTitle,
            session.StartedAt));

        _logger.LogInformation("[Dialogue] Started dialogue with {NpcName} at node '{NodeId}'",
            tree.NpcName, rootNode.NodeId);

        return DialogueStartResult.Success(viewModel, session.SessionId);
    }

    /// <inheritdoc/>
    public async Task<DialogueStepResult> SelectOptionAsync(Guid optionId)
    {
        _logger.LogDebug("[Dialogue] SelectOption: {OptionId}", optionId);

        // Validate session
        var session = _gameState.CurrentDialogueSession;
        if (session == null)
        {
            _logger.LogWarning("[Dialogue] SelectOption called with no active dialogue");
            return DialogueStepResult.Fail("No active dialogue session.");
        }

        var character = _gameState.CurrentCharacter;
        if (character == null)
        {
            return DialogueStepResult.Fail("No active character.");
        }

        // Get current node
        var currentNode = await _dialogueRepository.GetNodeAsync(session.TreeId, session.CurrentNodeStringId);
        if (currentNode == null)
        {
            _logger.LogError("[Dialogue] Current node not found: {NodeId}", session.CurrentNodeStringId);
            return DialogueStepResult.Fail("Dialogue state corrupted.");
        }

        // Find the selected option
        var option = currentNode.Options.FirstOrDefault(o => o.Id == optionId);
        if (option == null)
        {
            _logger.LogWarning("[Dialogue] Option not found: {OptionId}", optionId);
            return DialogueStepResult.Fail("Invalid option selected.");
        }

        // Re-evaluate option conditions (prevent race conditions)
        var optionVisibility = await _conditionEvaluator.EvaluateOptionAsync(character, option);
        if (!optionVisibility.IsAvailable)
        {
            _logger.LogWarning("[Dialogue] Option no longer available: {OptionId}", optionId);
            return DialogueStepResult.Fail("That option is no longer available.");
        }

        // Execute effects
        DialogueEffectResult? effectResult = null;
        if (option.HasEffects)
        {
            effectResult = await _effectExecutor.ExecuteEffectsAsync(
                character, option.Effects, session);
        }

        // Record choice
        session.ChoicesMade.Add(new DialogueChoiceRecord(
            session.CurrentNodeStringId,
            option.Id,
            option.Text,
            DateTime.UtcNow));

        // Publish option selected event
        await _eventBus.PublishAsync(new DialogueOptionSelectedEvent(
            session.SessionId,
            option.Id,
            option.Text,
            session.CurrentNodeStringId,
            option.NextNodeId,
            option.IsTerminal,
            effectResult?.EffectsExecuted ?? 0,
            DateTime.UtcNow));

        _logger.LogDebug("[Dialogue] Selected '{OptionText}' -> {NextNodeId}",
            TruncateText(option.Text, 30), option.NextNodeId ?? "END");

        // Handle terminal option
        if (option.IsTerminal)
        {
            await EndDialogueAsync(DialogueEndReason.PlayerExit);
            return DialogueStepResult.Complete(effectResult);
        }

        // Navigate to next node
        var nextNode = await _dialogueRepository.GetNodeAsync(session.TreeId, option.NextNodeId!);
        if (nextNode == null)
        {
            _logger.LogError("[Dialogue] Next node not found: {NodeId}", option.NextNodeId);
            await EndDialogueAsync(DialogueEndReason.Error);
            return DialogueStepResult.Fail("Dialogue tree is corrupted.");
        }

        // Update session state
        session.CurrentNodeId = nextNode.Id;
        session.CurrentNodeStringId = nextNode.NodeId;
        session.VisitedNodeIds.Add(nextNode.NodeId);

        // Evaluate new node options
        var optionResults = await _conditionEvaluator.EvaluateNodeOptionsAsync(character, nextNode);

        // Build view model
        var viewModel = BuildViewModel(session, nextNode, optionResults);

        return DialogueStepResult.Continue(viewModel, effectResult);
    }

    /// <inheritdoc/>
    public async Task<DialogueEndResult> EndDialogueAsync(DialogueEndReason reason)
    {
        var session = _gameState.CurrentDialogueSession;
        if (session == null)
        {
            _logger.LogWarning("[Dialogue] EndDialogue called with no active session");
            return DialogueEndResult.Fail("No active dialogue session.");
        }

        // Capture metrics before clearing
        var sessionId = session.SessionId;
        var npcName = session.NpcName;
        var duration = session.Duration;
        var nodesVisited = session.NodesVisitedCount;
        var choicesMade = session.ChoicesMade.Count;

        // Clear session
        _gameState.CurrentDialogueSession = null;

        // Publish event
        await _eventBus.PublishAsync(new DialogueEndedEvent(
            sessionId,
            session.CharacterId,
            npcName,
            reason,
            duration,
            nodesVisited,
            choicesMade,
            DateTime.UtcNow));

        _logger.LogInformation(
            "[Dialogue] Ended with {NpcName}, reason: {Reason}, duration: {Duration:F1}s, nodes: {Nodes}, choices: {Choices}",
            npcName, reason, duration.TotalSeconds, nodesVisited, choicesMade);

        return DialogueEndResult.Success(sessionId, npcName, reason, duration, nodesVisited, choicesMade);
    }

    /// <inheritdoc/>
    public DialogueViewModel? GetCurrentState()
    {
        // Note: This returns cached state from session. For real-time updates,
        // caller should re-evaluate via SelectOption/StartDialogue.
        var session = _gameState.CurrentDialogueSession;
        if (session == null)
        {
            return null;
        }

        // Return cached view model from session
        // In practice, this would be built from the current node
        // For now, return null to force explicit state building
        return null;
    }

    /// <inheritdoc/>
    public async Task<bool> IsDialogueAvailableAsync(Character character, string npcTreeId)
    {
        var tree = await _dialogueRepository.GetTreeByIdAsync(npcTreeId);
        if (tree == null)
        {
            return false;
        }

        // If NPC has no faction, dialogue is always available
        if (!tree.AssociatedFaction.HasValue)
        {
            return true;
        }

        // Check disposition
        var standing = await _factionService.GetFactionStandingAsync(
            character, tree.AssociatedFaction.Value);

        // Hated and Hostile refuse dialogue
        return standing.Disposition >= Disposition.Neutral;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Private Helpers
    // ═══════════════════════════════════════════════════════════════════════

    private DialogueViewModel BuildViewModel(
        DialogueSession session,
        DialogueNode node,
        IReadOnlyList<OptionVisibilityResult> optionResults)
    {
        var optionViewModels = new List<DialogueOptionViewModel>();

        foreach (var opt in node.Options.OrderBy(o => o.DisplayOrder))
        {
            var visibility = optionResults.FirstOrDefault(r => r.OptionId == opt.Id);

            if (visibility == null || !visibility.IsVisible)
            {
                continue; // Hidden options are excluded
            }

            if (visibility.IsAvailable)
            {
                optionViewModels.Add(DialogueOptionViewModel.Available(
                    opt.Id, opt.Text, opt.DisplayOrder, opt.IsTerminal));
            }
            else
            {
                optionViewModels.Add(DialogueOptionViewModel.Locked(
                    opt.Id, opt.Text, opt.DisplayOrder, opt.IsTerminal,
                    visibility.LockHint ?? "Locked",
                    visibility.LockReason ?? "Requirements not met"));
            }
        }

        return new DialogueViewModel(
            session.SessionId,
            session.NpcName,
            session.NpcTitle,
            node.SpeakerName,
            node.Text,
            node.IsTerminal,
            optionViewModels);
    }

    private static string TruncateText(string text, int maxLength)
    {
        if (text.Length <= maxLength) return text;
        return text[..(maxLength - 3)] + "...";
    }
}
```

---

## 7. DialogueEffectExecutor Implementation

**File:** `RuneAndRust.Engine/Services/DialogueEffectExecutor.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Effects;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Service for executing dialogue effects when options are selected.
/// Follows the pattern established by EffectScriptExecutor.
/// </summary>
/// <remarks>See: v0.4.2c (The Voice) for Dialogue Service implementation.</remarks>
public class DialogueEffectExecutor : IDialogueEffectExecutor
{
    private readonly IFactionService _factionService;
    private readonly IInventoryService _inventoryService;
    private readonly GameState _gameState;
    private readonly IEventBus _eventBus;
    private readonly ILogger<DialogueEffectExecutor> _logger;

    public DialogueEffectExecutor(
        IFactionService factionService,
        IInventoryService inventoryService,
        GameState gameState,
        IEventBus eventBus,
        ILogger<DialogueEffectExecutor> logger)
    {
        _factionService = factionService;
        _inventoryService = inventoryService;
        _gameState = gameState;
        _eventBus = eventBus;
        _logger = logger;

        _logger.LogTrace("[DialogueEffect] DialogueEffectExecutor initialized");
    }

    /// <inheritdoc/>
    public async Task<DialogueEffectResult> ExecuteEffectsAsync(
        Character character,
        IReadOnlyList<DialogueEffect> effects,
        DialogueSession session)
    {
        if (effects.Count == 0)
        {
            _logger.LogDebug("[DialogueEffect] No effects to execute");
            return DialogueEffectResult.Empty;
        }

        _logger.LogDebug("[DialogueEffect] Executing {Count} effects for {CharName}",
            effects.Count, character.Name);

        var reputationChanges = new Dictionary<FactionType, int>();
        var itemsGiven = new List<string>();
        var itemsRemoved = new List<string>();
        var flagsSet = new Dictionary<string, bool>();
        var questsStarted = new List<string>();
        var narratives = new List<string>();
        var totalHealing = 0;
        var totalXp = 0;
        var effectsExecuted = 0;

        foreach (var effect in effects)
        {
            try
            {
                var result = await ExecuteSingleEffectAsync(character, effect, session);

                // Merge results
                foreach (var kvp in result.ReputationChanges)
                {
                    if (!reputationChanges.ContainsKey(kvp.Key))
                        reputationChanges[kvp.Key] = 0;
                    reputationChanges[kvp.Key] += kvp.Value;
                }

                itemsGiven.AddRange(result.ItemsGiven);
                itemsRemoved.AddRange(result.ItemsRemoved);

                foreach (var kvp in result.FlagsSet)
                    flagsSet[kvp.Key] = kvp.Value;

                questsStarted.AddRange(result.QuestsStarted);
                narratives.AddRange(result.Narratives);
                totalHealing += result.HealingApplied;
                totalXp += result.XpGranted;
                effectsExecuted++;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "[DialogueEffect] Failed to execute effect: {Type}",
                    effect.Type);
                // Continue with other effects
            }
        }

        _logger.LogInformation(
            "[DialogueEffect] Executed {Count} effects. Rep changes: {RepCount}, Items: {ItemCount}, Flags: {FlagCount}",
            effectsExecuted, reputationChanges.Count, itemsGiven.Count + itemsRemoved.Count, flagsSet.Count);

        return new DialogueEffectResult(
            effectsExecuted,
            reputationChanges,
            itemsGiven,
            itemsRemoved,
            flagsSet,
            questsStarted,
            totalHealing,
            totalXp,
            narratives);
    }

    /// <inheritdoc/>
    public async Task<DialogueEffectResult> ExecuteEffectAsync(
        Character character,
        DialogueEffect effect,
        DialogueSession session)
    {
        return await ExecuteSingleEffectAsync(character, effect, session);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Private Effect Handlers
    // ═══════════════════════════════════════════════════════════════════════

    private async Task<DialogueEffectResult> ExecuteSingleEffectAsync(
        Character character,
        DialogueEffect effect,
        DialogueSession session)
    {
        _logger.LogDebug("[DialogueEffect] Executing {Type} effect", effect.Type);

        return effect switch
        {
            ModifyReputationEffect repEffect => await ExecuteModifyReputationAsync(character, repEffect),
            GiveItemEffect giveEffect => await ExecuteGiveItemAsync(character, giveEffect),
            SetFlagEffect flagEffect => ExecuteSetFlag(flagEffect, session),
            RemoveItemEffect removeEffect => await ExecuteRemoveItemAsync(character, removeEffect),
            HealEffect healEffect => ExecuteHeal(character, healEffect),
            GiveXpEffect xpEffect => ExecuteGiveXp(character, xpEffect),
            StartQuestEffect questEffect => await ExecuteStartQuestAsync(questEffect),
            _ => HandleUnknownEffect(effect)
        };
    }

    private async Task<DialogueEffectResult> ExecuteModifyReputationAsync(
        Character character,
        ModifyReputationEffect effect)
    {
        var result = await _factionService.ModifyReputationAsync(
            character, effect.Faction, effect.Amount, "Dialogue");

        _logger.LogInformation(
            "[DialogueEffect] ModifyReputation: {Amount:+#;-#;0} with {Faction} for {CharName}",
            effect.Amount, effect.Faction, character.Name);

        var narrative = effect.Amount > 0
            ? $"Your reputation with {effect.Faction} has improved."
            : $"Your reputation with {effect.Faction} has decreased.";

        return new DialogueEffectResult(
            1,
            new Dictionary<FactionType, int> { { effect.Faction, effect.Amount } },
            new(), new(), new(), new(), 0, 0,
            new List<string> { narrative });
    }

    private async Task<DialogueEffectResult> ExecuteGiveItemAsync(
        Character character,
        GiveItemEffect effect)
    {
        await _inventoryService.AddItemAsync(character.Id, effect.ItemId, effect.Quantity);

        _logger.LogInformation(
            "[DialogueEffect] GiveItem: {ItemName} x{Qty} to {CharName}",
            effect.ItemName, effect.Quantity, character.Name);

        var narrative = effect.Quantity > 1
            ? $"Received {effect.ItemName} x{effect.Quantity}."
            : $"Received {effect.ItemName}.";

        return new DialogueEffectResult(
            1, new(), new List<string> { effect.ItemName },
            new(), new(), new(), 0, 0,
            new List<string> { narrative });
    }

    private async Task<DialogueEffectResult> ExecuteRemoveItemAsync(
        Character character,
        RemoveItemEffect effect)
    {
        await _inventoryService.RemoveItemAsync(character.Id, effect.ItemId, effect.Quantity);

        _logger.LogInformation(
            "[DialogueEffect] RemoveItem: {ItemName} x{Qty} from {CharName}",
            effect.ItemName, effect.Quantity, character.Name);

        var narrative = effect.Quantity > 1
            ? $"Lost {effect.ItemName} x{effect.Quantity}."
            : $"Gave away {effect.ItemName}.";

        return new DialogueEffectResult(
            1, new(), new(), new List<string> { effect.ItemName },
            new(), new(), 0, 0,
            new List<string> { narrative });
    }

    private DialogueEffectResult ExecuteSetFlag(
        SetFlagEffect effect,
        DialogueSession session)
    {
        // Check if this is a session-local flag (prefixed with "local_")
        if (effect.FlagKey.StartsWith("local_", StringComparison.OrdinalIgnoreCase))
        {
            session.LocalFlags[effect.FlagKey] = effect.Value;
            _logger.LogDebug("[DialogueEffect] SetLocalFlag: {Key} = {Value}", effect.FlagKey, effect.Value);
        }
        else
        {
            // Global game flag
            _gameState.GameFlags[effect.FlagKey] = effect.Value;
            _logger.LogInformation("[DialogueEffect] SetGameFlag: {Key} = {Value}", effect.FlagKey, effect.Value);
        }

        return new DialogueEffectResult(
            1, new(), new(), new(),
            new Dictionary<string, bool> { { effect.FlagKey, effect.Value } },
            new(), 0, 0, new());
    }

    private DialogueEffectResult ExecuteHeal(Character character, HealEffect effect)
    {
        var actualHealing = Math.Min(effect.Amount, character.MaxHp - character.CurrentHp);
        character.CurrentHp += actualHealing;

        _logger.LogInformation(
            "[DialogueEffect] Heal: {Amount} HP to {CharName} (actual: {Actual})",
            effect.Amount, character.Name, actualHealing);

        var narrative = actualHealing > 0
            ? $"Healed for {actualHealing} HP."
            : "Already at full health.";

        return new DialogueEffectResult(
            1, new(), new(), new(), new(), new(),
            actualHealing, 0, new List<string> { narrative });
    }

    private DialogueEffectResult ExecuteGiveXp(Character character, GiveXpEffect effect)
    {
        character.LegendPoints += effect.Amount;

        _logger.LogInformation(
            "[DialogueEffect] GiveXP: {Amount} Legend to {CharName}",
            effect.Amount, character.Name);

        var narrative = $"Gained {effect.Amount} Legend.";

        return new DialogueEffectResult(
            1, new(), new(), new(), new(), new(),
            0, effect.Amount, new List<string> { narrative });
    }

    private async Task<DialogueEffectResult> ExecuteStartQuestAsync(StartQuestEffect effect)
    {
        // Quest system integration (v0.4.3 - future)
        // For now, publish an event that quest system can subscribe to

        _logger.LogInformation("[DialogueEffect] StartQuest: {QuestId}", effect.QuestId);

        // Placeholder: Quest system will subscribe to this
        // await _eventBus.PublishAsync(new QuestStartedEvent(effect.QuestId));

        return new DialogueEffectResult(
            1, new(), new(), new(), new(),
            new List<string> { effect.QuestId },
            0, 0, new List<string> { $"Quest started: {effect.QuestId}" });
    }

    private DialogueEffectResult HandleUnknownEffect(DialogueEffect effect)
    {
        _logger.LogWarning("[DialogueEffect] Unknown effect type: {Type}", effect.Type);
        return DialogueEffectResult.Empty;
    }
}
```

---

## 8. GameState Extension

**Add to:** `RuneAndRust.Core/Models/GameState.cs`

```csharp
// Add these properties to the GameState class:

/// <summary>
/// Gets or sets the current dialogue session (v0.4.2c).
/// Null when not in dialogue.
/// Not serialized to save files (transient state).
/// </summary>
[JsonIgnore]
public DialogueSession? CurrentDialogueSession { get; set; }

/// <summary>
/// Persistent game flags for tracking story/quest progress (v0.4.2c).
/// Unlike LocalFlags in DialogueSession, these persist across saves.
/// </summary>
public Dictionary<string, bool> GameFlags { get; set; } = new();

// Update the Reset() method to include:
CurrentDialogueSession = null;
GameFlags.Clear();

// Add helper method:
/// <summary>
/// Gets a game flag value, returning false if not set.
/// </summary>
public bool GetFlag(string key) =>
    GameFlags.TryGetValue(key, out var value) && value;
```

---

## 9. DI Registration

**Add to:** `RuneAndRust.Terminal/Program.cs`

```csharp
// ═══════════════════════════════════════════════════════════════════════════
// Dialogue System (v0.4.2c - The Voice)
// ═══════════════════════════════════════════════════════════════════════════
services.AddScoped<IDialogueService, DialogueService>();
services.AddScoped<IDialogueEffectExecutor, DialogueEffectExecutor>();
```

---

## 10. Logging Matrix

### DialogueService Logging

| Event | Level | Template |
|-------|-------|----------|
| Service initialized | Trace | `[Dialogue] DialogueService initialized` |
| StartDialogue entry | Info | `[Dialogue] Starting dialogue with '{TreeId}' for {CharName}` |
| Already in dialogue | Warn | `[Dialogue] Attempted to start dialogue while already in dialogue` |
| Tree not found | Warn | `[Dialogue] Dialogue tree not found: {TreeId}` |
| Root node not found | Error | `[Dialogue] Root node '{RootNodeId}' not found in tree '{TreeId}'` |
| Dialogue started | Info | `[Dialogue] Started dialogue with {NpcName} at node '{NodeId}'` |
| NPC refuses dialogue | Info | `[Dialogue] NPC refuses dialogue due to hostile disposition` |
| SelectOption entry | Debug | `[Dialogue] SelectOption: {OptionId}` |
| No active session | Warn | `[Dialogue] SelectOption called with no active dialogue` |
| Option not found | Warn | `[Dialogue] Option not found: {OptionId}` |
| Option no longer available | Warn | `[Dialogue] Option no longer available: {OptionId}` |
| Option selected | Debug | `[Dialogue] Selected '{OptionText}' -> {NextNodeId}` |
| Next node not found | Error | `[Dialogue] Next node not found: {NodeId}` |
| Dialogue ended | Info | `[Dialogue] Ended with {NpcName}, reason: {Reason}, duration: {Duration:F1}s, nodes: {Nodes}, choices: {Choices}` |

### DialogueEffectExecutor Logging

| Event | Level | Template |
|-------|-------|----------|
| Service initialized | Trace | `[DialogueEffect] DialogueEffectExecutor initialized` |
| No effects | Debug | `[DialogueEffect] No effects to execute` |
| Executing effects | Debug | `[DialogueEffect] Executing {Count} effects for {CharName}` |
| Effect type | Debug | `[DialogueEffect] Executing {Type} effect` |
| Effect failed | Error | `[DialogueEffect] Failed to execute effect: {Type}` |
| Effects complete | Info | `[DialogueEffect] Executed {Count} effects. Rep changes: {RepCount}, Items: {ItemCount}, Flags: {FlagCount}` |
| ModifyReputation | Info | `[DialogueEffect] ModifyReputation: {Amount:+#;-#;0} with {Faction} for {CharName}` |
| GiveItem | Info | `[DialogueEffect] GiveItem: {ItemName} x{Qty} to {CharName}` |
| RemoveItem | Info | `[DialogueEffect] RemoveItem: {ItemName} x{Qty} from {CharName}` |
| SetLocalFlag | Debug | `[DialogueEffect] SetLocalFlag: {Key} = {Value}` |
| SetGameFlag | Info | `[DialogueEffect] SetGameFlag: {Key} = {Value}` |
| Heal | Info | `[DialogueEffect] Heal: {Amount} HP to {CharName} (actual: {Actual})` |
| GiveXP | Info | `[DialogueEffect] GiveXP: {Amount} Legend to {CharName}` |
| StartQuest | Info | `[DialogueEffect] StartQuest: {QuestId}` |
| Unknown effect | Warn | `[DialogueEffect] Unknown effect type: {Type}` |

---

## 11. Test Coverage Plan

### Test Class Structure

**File 1:** `RuneAndRust.Tests/Engine/DialogueServiceTests.cs` (30 tests)
**File 2:** `RuneAndRust.Tests/Engine/DialogueEffectExecutorTests.cs` (15 tests)

### Test Inventory (45 tests)

#### DialogueService - StartDialogueAsync Tests (8 tests)

| Test Name | Description |
|-----------|-------------|
| `StartDialogueAsync_ReturnsSuccess_WhenTreeExists` | Happy path |
| `StartDialogueAsync_ReturnsFail_WhenAlreadyInDialogue` | Concurrent session blocked |
| `StartDialogueAsync_ReturnsFail_WhenTreeNotFound` | Missing tree |
| `StartDialogueAsync_ReturnsFail_WhenRootNodeMissing` | Corrupted tree |
| `StartDialogueAsync_CreatesSession_WithCorrectData` | Session populated |
| `StartDialogueAsync_EvaluatesRootNodeOptions` | Condition evaluator called |
| `StartDialogueAsync_PublishesDialogueStartedEvent` | Event bus called |
| `StartDialogueAsync_RefusesDialogue_WhenNpcHostile` | Faction check |

#### DialogueService - SelectOptionAsync Tests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `SelectOptionAsync_ReturnsSuccess_WhenOptionValid` | Happy path |
| `SelectOptionAsync_ReturnsFail_WhenNoActiveSession` | No session |
| `SelectOptionAsync_ReturnsFail_WhenOptionNotFound` | Invalid option ID |
| `SelectOptionAsync_ReturnsFail_WhenOptionLocked` | Conditions failed |
| `SelectOptionAsync_ExecutesEffects_WhenPresent` | Effect executor called |
| `SelectOptionAsync_NavigatesToNextNode` | Node transition |
| `SelectOptionAsync_EndsDialogue_WhenTerminalOption` | Terminal handling |
| `SelectOptionAsync_RecordsChoice_InSession` | Choice history |
| `SelectOptionAsync_PublishesOptionSelectedEvent` | Event bus called |
| `SelectOptionAsync_AddsNodeToVisited` | Visited tracking |

#### DialogueService - EndDialogueAsync Tests (5 tests)

| Test Name | Description |
|-----------|-------------|
| `EndDialogueAsync_ClearsSession` | Session removed |
| `EndDialogueAsync_PublishesDialogueEndedEvent` | Event bus called |
| `EndDialogueAsync_ReturnsCorrectMetrics` | Duration, counts |
| `EndDialogueAsync_ReturnsFail_WhenNoSession` | No active session |
| `EndDialogueAsync_IncludesReason_InEvent` | Reason propagated |

#### DialogueService - IsDialogueAvailableAsync Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `IsDialogueAvailableAsync_ReturnsTrue_WhenNoFaction` | No faction NPC |
| `IsDialogueAvailableAsync_ReturnsTrue_WhenNeutral` | Neutral disposition |
| `IsDialogueAvailableAsync_ReturnsFalse_WhenHostile` | Hostile blocked |
| `IsDialogueAvailableAsync_ReturnsFalse_WhenTreeMissing` | No tree |

#### DialogueService - GetCurrentState Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `GetCurrentState_ReturnsNull_WhenNoSession` | No active session |
| `IsInDialogue_ReturnsTrue_WhenSessionActive` | Property check |
| `CurrentSession_ReturnsSession_WhenActive` | Property check |

#### DialogueEffectExecutor - ExecuteEffectsAsync Tests (5 tests)

| Test Name | Description |
|-----------|-------------|
| `ExecuteEffectsAsync_ReturnsEmpty_WhenNoEffects` | Empty list |
| `ExecuteEffectsAsync_ExecutesAllEffects` | Multiple effects |
| `ExecuteEffectsAsync_AggregatesResults` | Merged results |
| `ExecuteEffectsAsync_ContinuesOnError` | Error resilience |
| `ExecuteEffectsAsync_LogsExecution` | Logging verification |

#### DialogueEffectExecutor - Individual Effect Tests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `ExecuteEffect_ModifyReputation_CallsFactionService` | Rep change |
| `ExecuteEffect_ModifyReputation_ReturnsNarrative` | Narrative generated |
| `ExecuteEffect_GiveItem_CallsInventoryService` | Item added |
| `ExecuteEffect_GiveItem_IncludesQuantity` | Quantity handling |
| `ExecuteEffect_RemoveItem_CallsInventoryService` | Item removed |
| `ExecuteEffect_SetFlag_UpdatesGameState` | Global flag |
| `ExecuteEffect_SetFlag_UpdatesLocalFlags_WhenPrefixed` | Local flag |
| `ExecuteEffect_Heal_ClampsToMaxHp` | Healing cap |
| `ExecuteEffect_GiveXp_IncreasesLegendPoints` | XP grant |
| `ExecuteEffect_UnknownType_ReturnsEmpty` | Unknown handling |

---

## 12. Code Examples

### 12.1 Test Example - StartDialogueAsync

```csharp
public class DialogueServiceTests
{
    private readonly Mock<IDialogueRepository> _mockRepo;
    private readonly Mock<IDialogueConditionEvaluator> _mockEvaluator;
    private readonly Mock<IDialogueEffectExecutor> _mockEffectExecutor;
    private readonly Mock<IFactionService> _mockFactionService;
    private readonly Mock<IEventBus> _mockEventBus;
    private readonly GameState _gameState;
    private readonly Mock<ILogger<DialogueService>> _mockLogger;
    private readonly DialogueService _sut;

    public DialogueServiceTests()
    {
        _mockRepo = new Mock<IDialogueRepository>();
        _mockEvaluator = new Mock<IDialogueConditionEvaluator>();
        _mockEffectExecutor = new Mock<IDialogueEffectExecutor>();
        _mockFactionService = new Mock<IFactionService>();
        _mockEventBus = new Mock<IEventBus>();
        _gameState = new GameState();
        _mockLogger = new Mock<ILogger<DialogueService>>();

        _sut = new DialogueService(
            _mockRepo.Object,
            _mockEvaluator.Object,
            _mockEffectExecutor.Object,
            _mockFactionService.Object,
            _mockEventBus.Object,
            _gameState,
            _mockLogger.Object);
    }

    [Fact]
    public async Task StartDialogueAsync_ReturnsSuccess_WhenTreeExists()
    {
        // Arrange
        var character = CreateTestCharacter();
        var tree = CreateTestTree();
        var rootNode = tree.Nodes.First();

        _mockRepo.Setup(r => r.GetTreeByIdAsync("npc_test"))
            .ReturnsAsync(tree);

        _mockEvaluator.Setup(e => e.EvaluateNodeOptionsAsync(character, rootNode))
            .ReturnsAsync(new List<OptionVisibilityResult>());

        // Act
        var result = await _sut.StartDialogueAsync(character, "npc_test");

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.ViewModel.Should().NotBeNull();
        result.ViewModel!.NpcName.Should().Be("Test NPC");
        result.SessionId.Should().NotBeEmpty();
        _gameState.CurrentDialogueSession.Should().NotBeNull();
    }

    [Fact]
    public async Task StartDialogueAsync_ReturnsFail_WhenAlreadyInDialogue()
    {
        // Arrange
        var character = CreateTestCharacter();
        _gameState.CurrentDialogueSession = new DialogueSession
        {
            SessionId = Guid.NewGuid()
        };

        // Act
        var result = await _sut.StartDialogueAsync(character, "npc_test");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.ErrorMessage.Should().Contain("Already in dialogue");
    }

    [Fact]
    public async Task StartDialogueAsync_PublishesDialogueStartedEvent()
    {
        // Arrange
        var character = CreateTestCharacter();
        var tree = CreateTestTree();
        var rootNode = tree.Nodes.First();

        _mockRepo.Setup(r => r.GetTreeByIdAsync("npc_test"))
            .ReturnsAsync(tree);

        _mockEvaluator.Setup(e => e.EvaluateNodeOptionsAsync(character, rootNode))
            .ReturnsAsync(new List<OptionVisibilityResult>());

        // Act
        await _sut.StartDialogueAsync(character, "npc_test");

        // Assert
        _mockEventBus.Verify(e => e.PublishAsync(
            It.Is<DialogueStartedEvent>(ev =>
                ev.NpcName == "Test NPC" &&
                ev.CharacterId == character.Id)),
            Times.Once);
    }

    private static Character CreateTestCharacter() => new()
    {
        Id = Guid.NewGuid(),
        Name = "Test Character"
    };

    private static DialogueTree CreateTestTree()
    {
        var treeId = Guid.NewGuid();
        var nodeId = Guid.NewGuid();

        return new DialogueTree
        {
            Id = treeId,
            TreeId = "npc_test",
            NpcName = "Test NPC",
            RootNodeId = "root",
            Nodes = new List<DialogueNode>
            {
                new()
                {
                    Id = nodeId,
                    TreeId = treeId,
                    NodeId = "root",
                    SpeakerName = "Test NPC",
                    Text = "Hello, traveler.",
                    Options = new List<DialogueOption>()
                }
            }
        };
    }
}
```

### 12.2 Test Example - ExecuteEffectsAsync

```csharp
public class DialogueEffectExecutorTests
{
    private readonly Mock<IFactionService> _mockFactionService;
    private readonly Mock<IInventoryService> _mockInventoryService;
    private readonly GameState _gameState;
    private readonly Mock<IEventBus> _mockEventBus;
    private readonly Mock<ILogger<DialogueEffectExecutor>> _mockLogger;
    private readonly DialogueEffectExecutor _sut;

    public DialogueEffectExecutorTests()
    {
        _mockFactionService = new Mock<IFactionService>();
        _mockInventoryService = new Mock<IInventoryService>();
        _gameState = new GameState();
        _mockEventBus = new Mock<IEventBus>();
        _mockLogger = new Mock<ILogger<DialogueEffectExecutor>>();

        _sut = new DialogueEffectExecutor(
            _mockFactionService.Object,
            _mockInventoryService.Object,
            _gameState,
            _mockEventBus.Object,
            _mockLogger.Object);
    }

    [Fact]
    public async Task ExecuteEffect_ModifyReputation_CallsFactionService()
    {
        // Arrange
        var character = CreateTestCharacter();
        var session = CreateTestSession();
        var effect = new ModifyReputationEffect
        {
            Faction = FactionType.IronBanes,
            Amount = 10
        };

        _mockFactionService.Setup(f => f.ModifyReputationAsync(
                character, FactionType.IronBanes, 10, "Dialogue"))
            .ReturnsAsync(new ReputationChangeResult(
                true, "Reputation increased",
                FactionType.IronBanes, 0, 10,
                Disposition.Neutral, Disposition.Friendly, true));

        // Act
        var result = await _sut.ExecuteEffectAsync(character, effect, session);

        // Assert
        result.EffectsExecuted.Should().Be(1);
        result.ReputationChanges.Should().ContainKey(FactionType.IronBanes);
        result.ReputationChanges[FactionType.IronBanes].Should().Be(10);
        result.Narratives.Should().Contain(n => n.Contains("improved"));
    }

    [Fact]
    public async Task ExecuteEffect_SetFlag_UpdatesLocalFlags_WhenPrefixed()
    {
        // Arrange
        var character = CreateTestCharacter();
        var session = CreateTestSession();
        var effect = new SetFlagEffect
        {
            FlagKey = "local_mentioned_artifact",
            Value = true
        };

        // Act
        var result = await _sut.ExecuteEffectAsync(character, effect, session);

        // Assert
        result.FlagsSet.Should().ContainKey("local_mentioned_artifact");
        session.LocalFlags.Should().ContainKey("local_mentioned_artifact");
        session.LocalFlags["local_mentioned_artifact"].Should().Be(true);
    }

    private static Character CreateTestCharacter() => new()
    {
        Id = Guid.NewGuid(),
        Name = "Test Character"
    };

    private static DialogueSession CreateTestSession() => new()
    {
        SessionId = Guid.NewGuid(),
        NpcName = "Test NPC"
    };
}
```

---

## 13. Error Handling

### Error Categories

| Category | Handling | Recovery |
|----------|----------|----------|
| **Session Errors** | Return Fail result | User must restart dialogue |
| **Tree/Node Not Found** | Return Fail result + log Error | Report to user, end dialogue |
| **Effect Execution Failure** | Log Error, continue | Other effects still execute |
| **Condition Evaluation Failure** | Log Warning, treat as failed | Option shown as locked |
| **Event Publishing Failure** | Log Error, continue | Dialogue continues |

### Error Responses

```csharp
// Session Errors
DialogueStartResult.Fail("Already in dialogue. End current conversation first.");
DialogueStartResult.Fail("NPC '{npcTreeId}' not found or has no dialogue.");
DialogueStartResult.Fail("Dialogue tree is corrupted.");

DialogueStepResult.Fail("No active dialogue session.");
DialogueStepResult.Fail("Invalid option selected.");
DialogueStepResult.Fail("That option is no longer available.");
DialogueStepResult.Fail("Dialogue tree is corrupted.");

DialogueEndResult.Fail("No active dialogue session.");
```

---

## 14. Changelog Template

```markdown
# Changelog: v0.4.2c - The Voice (Dialogue Service & Effects)

**Release Date:** [DATE]
**Total Tests:** [N] (45 new tests added)

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.2c](#directory-structure-after-v042c)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

Version 0.4.2c implements the **Dialogue Runtime Engine** — the service layer that drives
branching conversations and executes dialogue effects...

[Continue following CHANGELOG_GENERATION_RULES.md format]
```

---

## 15. Critical Files

### Files to Create (Priority Order)

| Priority | File | Purpose |
|----------|------|---------|
| 1 | `RuneAndRust.Core/Enums/DialogueEndReason.cs` | End reason enum |
| 2 | `RuneAndRust.Core/Models/DialogueSession.cs` | Session state |
| 3 | `RuneAndRust.Core/Models/DialogueOptionViewModel.cs` | Option DTO |
| 4 | `RuneAndRust.Core/Models/DialogueViewModel.cs` | View model |
| 5 | `RuneAndRust.Core/Models/DialogueStartResult.cs` | Start result |
| 6 | `RuneAndRust.Core/Models/DialogueStepResult.cs` | Step result |
| 7 | `RuneAndRust.Core/Models/DialogueEndResult.cs` | End result |
| 8 | `RuneAndRust.Core/Models/DialogueEffectResult.cs` | Effect result |
| 9 | `RuneAndRust.Core/Events/DialogueStartedEvent.cs` | Start event |
| 10 | `RuneAndRust.Core/Events/DialogueOptionSelectedEvent.cs` | Selection event |
| 11 | `RuneAndRust.Core/Events/DialogueEndedEvent.cs` | End event |
| 12 | `RuneAndRust.Core/Interfaces/IDialogueService.cs` | Service interface |
| 13 | `RuneAndRust.Core/Interfaces/IDialogueEffectExecutor.cs` | Executor interface |
| 14 | `RuneAndRust.Engine/Services/DialogueEffectExecutor.cs` | Effect executor |
| 15 | `RuneAndRust.Engine/Services/DialogueService.cs` | Dialogue service |
| 16 | `RuneAndRust.Tests/Engine/DialogueEffectExecutorTests.cs` | 15 tests |
| 17 | `RuneAndRust.Tests/Engine/DialogueServiceTests.cs` | 30 tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/GameState.cs` | Add `CurrentDialogueSession`, `GameFlags`, `GetFlag()` |
| `RuneAndRust.Terminal/Program.cs` | Register services |

---

## 16. Implementation Order

1. **Create Enum** (DialogueEndReason)
2. **Create Session Model** (DialogueSession, DialogueChoiceRecord)
3. **Create View Models** (DialogueViewModel, DialogueOptionViewModel)
4. **Create Result Records** (DialogueStartResult, DialogueStepResult, DialogueEndResult, DialogueEffectResult)
5. **Create Events** (DialogueStartedEvent, DialogueOptionSelectedEvent, DialogueEndedEvent)
6. **Create Interfaces** (IDialogueService, IDialogueEffectExecutor)
7. **Update GameState** (Add session, flags, helper)
8. **Create Effect Executor** (DialogueEffectExecutor)
9. **Create Dialogue Service** (DialogueService)
10. **Register in DI** (Program.cs)
11. **Write Unit Tests** (45 tests)
12. **Run Build and Tests**
13. **Generate Changelog**

---

## 17. Design Decisions

### Why Session in GameState vs. Separate Singleton?

**Problem:** Need to track active dialogue state across service calls.

**Decision:** Store `CurrentDialogueSession` in existing `GameState` singleton.

**Rationale:**
- Consistent with CombatState pattern (also in GameState)
- Single source of truth for game state
- Easy serialization control via `[JsonIgnore]`
- No additional singleton registration needed

### Why Re-evaluate Conditions on SelectOption?

**Problem:** Conditions might change between when options were shown and when selected.

**Decision:** Re-evaluate option conditions before executing.

**Rationale:**
- Prevents race conditions (e.g., reputation changed by another effect)
- Ensures player can't select now-invalid options
- Small performance cost is acceptable for correctness
- Matches pattern in CombatService for action validation

### Why Separate DialogueEffectExecutor?

**Problem:** Effect execution is complex and should be testable independently.

**Decision:** Dedicated `IDialogueEffectExecutor` service.

**Rationale:**
- Single Responsibility Principle
- Matches EffectScriptExecutor pattern
- Easier to mock in DialogueService tests
- Can be extended for new effect types without modifying DialogueService

### Why Local vs. Global Flags?

**Problem:** Some flags should persist (story progress), others should reset (within-conversation state).

**Decision:** Local flags prefixed with "local_" stored in session; others in GameState.

**Rationale:**
- Clear naming convention for designers
- Local flags auto-cleanup when dialogue ends
- Global flags persist to save files
- Flexible for different use cases

### Why Effect Execution Continues on Error?

**Problem:** If one effect fails, should others still execute?

**Decision:** Continue executing remaining effects, log the error.

**Rationale:**
- One bad effect shouldn't break the dialogue
- Effects are generally independent
- Matches EffectScriptExecutor behavior
- Error is logged for debugging

---

## 18. Integration Points

### With FactionService (v0.4.2a)

```csharp
// In DialogueService:
await _factionService.GetFactionStandingAsync(character, faction);
await _factionService.MeetsDispositionRequirementAsync(character, faction, minDisposition);

// In DialogueEffectExecutor:
await _factionService.ModifyReputationAsync(character, faction, amount, "Dialogue");
```

### With DialogueConditionEvaluator (v0.4.2b)

```csharp
// In DialogueService:
await _conditionEvaluator.EvaluateNodeOptionsAsync(character, node);
await _conditionEvaluator.EvaluateOptionAsync(character, option);
```

### With DialogueRepository (v0.4.2b)

```csharp
// In DialogueService:
await _dialogueRepository.GetTreeByIdAsync(npcTreeId);
await _dialogueRepository.GetNodeAsync(treeId, nodeId);
```

### With GameState

```csharp
// Session management:
_gameState.CurrentDialogueSession = session;
_gameState.CurrentDialogueSession = null;

// Flag management:
_gameState.GameFlags[key] = value;
_gameState.GetFlag(key);

// Character access:
_gameState.CurrentCharacter;
```

### With EventBus

```csharp
// Publishing:
await _eventBus.PublishAsync(new DialogueStartedEvent(...));
await _eventBus.PublishAsync(new DialogueOptionSelectedEvent(...));
await _eventBus.PublishAsync(new DialogueEndedEvent(...));
```

---

## Appendix A: Effect Type Quick Reference

| Effect Type | Handler Method | Dependencies |
|-------------|----------------|--------------|
| ModifyReputation | `ExecuteModifyReputationAsync` | IFactionService |
| GiveItem | `ExecuteGiveItemAsync` | IInventoryService |
| RemoveItem | `ExecuteRemoveItemAsync` | IInventoryService |
| SetFlag | `ExecuteSetFlag` | GameState, DialogueSession |
| Heal | `ExecuteHeal` | Character |
| GiveXP | `ExecuteGiveXp` | Character |
| StartQuest | `ExecuteStartQuestAsync` | (Future: IQuestService) |

---

## Appendix B: Session Lifecycle

```
┌─────────────────────────────────────────────────────────────────┐
│                     DIALOGUE SESSION LIFECYCLE                   │
└─────────────────────────────────────────────────────────────────┘

    ┌──────────────┐
    │ No Session   │
    │ (IsInDialogue│
    │  = false)    │
    └──────────────┘
           │
           │ StartDialogueAsync(character, npcTreeId)
           ▼
    ┌──────────────┐
    │ Session      │◄───────────────────────────────────┐
    │ Created      │                                    │
    │ (IsInDialogue│     SelectOptionAsync(optionId)   │
    │  = true)     │    (non-terminal option)          │
    └──────────────┘────────────────────────────────────┘
           │
           │ SelectOptionAsync(terminalOption)
           │ or EndDialogueAsync(reason)
           ▼
    ┌──────────────┐
    │ Session      │
    │ Cleared      │
    │ (IsInDialogue│
    │  = false)    │
    └──────────────┘
```

---

## Appendix C: Additional Effect Types (Future)

These effect types are defined in EffectType enum but not fully implemented in v0.4.2c:

| Effect Type | Implementation Status | Target Version |
|-------------|----------------------|----------------|
| TriggerCombat | Stub (event publish) | v0.4.4 |
| StartQuest | Stub (logging) | v0.4.3 |
| RemoveItem | Fully implemented | v0.4.2c |
| Heal | Fully implemented | v0.4.2c |
| GiveXP | Fully implemented | v0.4.2c |

The stubs exist so dialogue trees can be authored with these effects, and they will activate when the corresponding systems are implemented.
