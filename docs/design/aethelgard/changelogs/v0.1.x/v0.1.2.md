# Changelog: v0.1.2 - The Burden of Survival

**Versions:** v0.1.2a through v0.1.2c
**Release Dates:** December 18-19, 2025

## Table of Contents

- [Overview](#overview)
- [Part A: Foundation (December 18, 2025)](#part-a-foundation-december-18-2025)
  - [Summary](#summary)
  - [New Files Created](#new-files-created)
  - [Files Modified](#files-modified)
  - [Code Implementation Details](#code-implementation-details)
  - [Logging Matrix (v0.1.2a)](#logging-matrix-v012a)
  - [Complete Test Inventory (Part A)](#complete-test-inventory-part-a)
  - [Database Schema Additions (Part A)](#database-schema-additions-part-a)
  - [Part A Test Results](#part-a-test-results)
- [Part B: Player Interaction (December 19, 2025)](#part-b-player-interaction-december-19-2025)
  - [Summary](#summary-1)
  - [New Files Created](#new-files-created-1)
  - [Files Modified](#files-modified-1)
  - [Code Implementation Details](#code-implementation-details-1)
  - [Logging Matrix (Part B)](#logging-matrix-part-b)
  - [Part B Test Coverage](#part-b-test-coverage)
- [Part C: World Integration (December 19, 2025)](#part-c-world-integration-december-19-2025)
  - [Summary](#summary-2)
  - [New Files Created](#new-files-created-2)
  - [Files Modified](#files-modified-2)
  - [Code Implementation Details](#code-implementation-details-2)
  - [Logging Matrix (Part C)](#logging-matrix-part-c)
  - [Part C Test Coverage](#part-c-test-coverage)
- [AAM-VOICE Compliance](#aam-voice-compliance)
- [v0.1.2 Trilogy Complete](#v012-trilogy-complete)
- [Verification Results](#verification-results)
- [Test Summary](#test-summary)

---

## Overview

Version 0.1.2 implements the complete **inventory and item acquisition system** for Rune & Rust. This three-part release establishes the foundational data structures for items and equipment (Part A), implements player interaction with inventory management and burden mechanics (Part B), and completes the loop with procedural loot generation and world integration (Part C).

**Key Features:**
- TPH (Table-per-Hierarchy) item and equipment entities with quality tiers
- Full inventory service with burden calculation and equipment bonuses
- Procedural loot generation with biome-aware, danger-scaled item selection
- AAM-VOICE compliant item descriptions for 60+ item templates

---

## Part A: Foundation (December 18, 2025)

# Changelog: v0.1.2a - The Burden of Survival (Foundation)

**Release Date:** December 18, 2025
**Total Tests:** 962 (149 new tests for v0.1.2a)

---

## Summary

Version 0.1.2a establishes the **Inventory System Foundation** - a complete data model for items, equipment, and character inventories using Entity Framework Core's Table-per-Hierarchy (TPH) pattern. This release introduces the core persistence layer for item management, quality tiers, equipment mechanics, and weight-based encumbrance calculations.

Key architectural additions:
- **TPH Inheritance Pattern**: Item base entity with Equipment subtype sharing a single database table via discriminator column
- **Quality Tiers**: Five-tier craftsmanship system (JuryRigged → MythForged) affecting stats and rarity
- **Equipment System**: Seven equipment slots with attribute bonuses, requirements, and soak/damage mechanics
- **Join Table Pattern**: InventoryItem entity managing many-to-many character-item relationships with stacking support
- **Burden Mechanics**: Three-tier encumbrance system (Light, Heavy, Overburdened) based on carried weight
- **Repository Layer**: TPH-aware queries for items, equipment, and inventory operations

This sub-version provides the foundational data structures required for loot generation, trading, and equipment management in future releases.

---

## New Files Created

### Core Layer - Enums

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/QualityTier.cs` | Five craftsmanship tiers: JuryRigged(0), Scavenged(1), ClanForged(2), Optimized(3), MythForged(4) |
| `RuneAndRust.Core/Enums/EquipmentSlot.cs` | Seven equipment slots: MainHand, OffHand, Head, Body, Hands, Feet, Accessory |
| `RuneAndRust.Core/Enums/ItemType.cs` | Six item categories: Weapon, Armor, Consumable, Material, KeyItem, Junk |
| `RuneAndRust.Core/Enums/BurdenState.cs` | Three encumbrance states: Light(0), Heavy(1), Overburdened(2) |

### Core Layer - Entities

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/Item.cs` | TPH base entity with identity, description, physical properties, quality, stacking support |
| `RuneAndRust.Core/Entities/Equipment.cs` | TPH subtype extending Item with slot, bonuses, requirements, combat properties |
| `RuneAndRust.Core/Entities/InventoryItem.cs` | Join entity for character-item relationships with quantity, position, equipped state |

### Core Layer - Interfaces

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IItemRepository.cs` | TPH-aware item queries: GetByQuality, GetByType, GetEquipmentBySlot, GetByName |
| `RuneAndRust.Core/Interfaces/IInventoryRepository.cs` | Inventory operations: GetByCharacterId, GetEquippedItems, GetTotalWeight, FindByItemName |

### Persistence Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Repositories/ItemRepository.cs` | TPH-aware repository implementation with quality/type/slot filtering |
| `RuneAndRust.Persistence/Repositories/InventoryRepository.cs` | Join table operations with navigation property loading and weight calculations |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Core/QualityTierTests.cs` | Enum validation (8 tests) |
| `RuneAndRust.Tests/Core/EquipmentSlotTests.cs` | Enum validation (9 tests) |
| `RuneAndRust.Tests/Core/ItemTypeTests.cs` | Enum validation (8 tests) |
| `RuneAndRust.Tests/Core/BurdenStateTests.cs` | Enum validation (7 tests) |
| `RuneAndRust.Tests/Core/ItemTests.cs` | Entity properties, defaults, stacking (15 tests) |
| `RuneAndRust.Tests/Core/EquipmentTests.cs` | TPH inheritance, bonuses, requirements (18 tests) |
| `RuneAndRust.Tests/Core/InventoryItemTests.cs` | Join entity behavior, navigation properties (10 tests) |
| `RuneAndRust.Tests/Integration/ItemPersistenceTests.cs` | TPH CRUD, discriminator queries (20 tests) |
| `RuneAndRust.Tests/Integration/InventoryPersistenceTests.cs` | Join table operations, weight calculations (18 tests) |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Added `DbSet<Item>`, `DbSet<Equipment>`, `DbSet<InventoryItem>`; configured TPH with "ItemDiscriminator" column; added composite key and indexes for InventoryItems; configured JSON serialization for dictionaries |
| `RuneAndRust.Core/Entities/Character.cs` | Added `Inventory` navigation property (ICollection<InventoryItem>); added `EquipmentBonuses` dictionary; added `GetEffectiveAttribute()` method |
| `RuneAndRust.Core/Entities/InteractableObject.cs` | Added `HasBeenSearched` and `LootTier` properties for future loot integration |

---

## Code Implementation Details

### QualityTier Enum

Defines craftsmanship quality with exponential rarity scaling:

```csharp
public enum QualityTier
{
    /// <summary>
    /// Hastily repaired or barely functional equipment.
    /// Common in Safe zones. Lowest stats, prone to breakage.
    /// </summary>
    JuryRigged = 0,

    /// <summary>
    /// Standard salvaged goods recovered from ruins.
    /// The baseline tier found throughout the world.
    /// </summary>
    Scavenged = 1,

    /// <summary>
    /// Properly crafted by Dvergr smiths or equivalent artisans.
    /// Reliable quality with consistent performance.
    /// </summary>
    ClanForged = 2,

    /// <summary>
    /// Pre-Glitch technology or masterwork craftsmanship.
    /// Rare finds in dangerous areas. Superior stats.
    /// </summary>
    Optimized = 3,

    /// <summary>
    /// Legendary artifacts of unknown origin.
    /// Extraordinarily rare. Found only in Lethal zones.
    /// </summary>
    MythForged = 4
}
```

**Quality Progression:** JuryRigged (common) → Scavenged (baseline) → ClanForged (crafted) → Optimized (rare) → MythForged (legendary)

### EquipmentSlot Enum

Seven distinct equipment slots for character loadout:

```csharp
public enum EquipmentSlot
{
    MainHand = 0,    // Primary weapon hand
    OffHand = 1,     // Secondary hand (shields, off-hand weapons, torches)
    Head = 2,        // Helmets, hoods, masks
    Body = 3,        // Armor, robes, jackets
    Hands = 4,       // Gauntlets, gloves, bracers
    Feet = 5,        // Boots, greaves, sandals
    Accessory = 6    // Rings, amulets, belts
}
```

### ItemType Enum

Six functional categories determining item usage:

```csharp
public enum ItemType
{
    Weapon = 0,      // Offensive equipment
    Armor = 1,       // Defensive equipment
    Consumable = 2,  // Single-use items (potions, bandages)
    Material = 3,    // Crafting components
    KeyItem = 4,     // Quest-critical (cannot be dropped/sold)
    Junk = 5         // Salvage for Scrip only
}
```

### BurdenState Enum

Three-tier encumbrance system with movement penalties:

```csharp
public enum BurdenState
{
    /// <summary>
    /// Under 70% capacity. No penalties.
    /// Normal movement and full attribute access.
    /// </summary>
    Light = 0,

    /// <summary>
    /// Between 70% and 90% capacity.
    /// Applies -2 penalty to Finesse attribute.
    /// </summary>
    Heavy = 1,

    /// <summary>
    /// Over 90% capacity.
    /// Cannot move between rooms until weight is reduced.
    /// </summary>
    Overburdened = 2
}
```

**Burden Thresholds:**
- Light: 0-70% capacity (no penalty)
- Heavy: 70-90% capacity (-2 Finesse)
- Overburdened: 90%+ capacity (movement blocked)

### Item Entity (TPH Base)

Base entity for all items with physical properties and quality:

```csharp
public class Item
{
    // Identity
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;
    public ItemType ItemType { get; set; } = ItemType.Junk;

    // Description
    public string Description { get; set; } = string.Empty;
    public string? DetailedDescription { get; set; }

    // Physical Properties
    public int Weight { get; set; } = 0;           // In grams
    public int Value { get; set; } = 0;            // In Scrip

    // Quality
    public QualityTier Quality { get; set; } = QualityTier.Scavenged;

    // Stacking
    public bool IsStackable { get; set; } = false;
    public int MaxStackSize { get; set; } = 1;

    // Metadata
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime LastModified { get; set; } = DateTime.UtcNow;
}
```

**Key Behaviors:**
- Weight measured in grams for precision burden calculations
- Value represents Scrip (in-game currency)
- Default quality is Scavenged (tier 1)
- Non-stackable by default (MaxStackSize = 1)

### Equipment Entity (TPH Subtype)

Extends Item with combat properties and attribute modifiers:

```csharp
public class Equipment : Item
{
    // Equipment Properties
    public EquipmentSlot Slot { get; set; } = EquipmentSlot.MainHand;
    public Dictionary<CharacterAttribute, int> AttributeBonuses { get; set; } = new();

    // Combat Properties
    public int SoakBonus { get; set; } = 0;       // Damage reduction (armor)
    public int DamageDie { get; set; } = 0;       // Weapon damage die (0=non-weapon, 6=d6, 8=d8, etc.)

    // Requirements
    public Dictionary<CharacterAttribute, int> Requirements { get; set; } = new();

    // Helper Methods
    public int GetAttributeBonus(CharacterAttribute attribute);
    public bool MeetsRequirements(Character character);
}
```

**Key Behaviors:**
- `GetAttributeBonus()` returns 0 if attribute not in dictionary (TryGetValue pattern)
- `MeetsRequirements()` checks all requirements against character attributes
- `DamageDie` of 0 indicates non-weapon equipment
- `AttributeBonuses` and `Requirements` stored as JSONB in database

### InventoryItem Entity (Join Table)

Join entity managing character-item relationships:

```csharp
public class InventoryItem
{
    // Composite Primary Key
    public Guid CharacterId { get; set; }
    public Guid ItemId { get; set; }

    // Stack Properties
    public int Quantity { get; set; } = 1;
    public int SlotPosition { get; set; } = 0;    // UI ordering

    // Equipment State
    public bool IsEquipped { get; set; } = false;

    // Navigation Properties
    public Character Character { get; set; } = null!;
    public Item Item { get; set; } = null!;

    // Metadata
    public DateTime AddedAt { get; set; } = DateTime.UtcNow;
    public DateTime LastModified { get; set; } = DateTime.UtcNow;
}
```

**Key Behaviors:**
- Composite primary key (CharacterId, ItemId) prevents duplicate entries
- Quantity defaults to 1 for non-stackable items
- SlotPosition enables custom inventory sorting
- IsEquipped only valid for Equipment-type items
- Cascade delete on both Character and Item relationships

### Character Entity Extensions

Added inventory support and effective attribute calculation:

```csharp
// Navigation property for EF Core
public ICollection<InventoryItem> Inventory { get; set; } = new List<InventoryItem>();

// Equipment bonuses currently applied
public Dictionary<CharacterAttribute, int> EquipmentBonuses { get; set; } = new();

// Gets effective attribute including equipment bonuses
public int GetEffectiveAttribute(CharacterAttribute attribute)
{
    var baseValue = GetAttribute(attribute);
    var bonus = EquipmentBonuses.TryGetValue(attribute, out var equipBonus) ? equipBonus : 0;
    return baseValue + bonus;
}
```

**Key Behaviors:**
- `Inventory` collection loaded via navigation property
- `EquipmentBonuses` stored as JSONB in database
- `GetEffectiveAttribute()` combines base attribute + equipment bonus
- Returns base value if no equipment bonus exists

### IItemRepository Interface

TPH-aware repository contract for item operations:

```csharp
public interface IItemRepository : IRepository<Item>
{
    Task<IEnumerable<Item>> GetByQualityAsync(QualityTier quality);
    Task<IEnumerable<Item>> GetByTypeAsync(ItemType itemType);
    Task<Item?> GetByNameAsync(string name);

    // TPH-specific equipment queries
    Task<IEnumerable<Equipment>> GetAllEquipmentAsync();
    Task<IEnumerable<Equipment>> GetEquipmentBySlotAsync(EquipmentSlot slot);

    Task AddRangeAsync(IEnumerable<Item> items);
}
```

**Key Methods:**
- `GetByNameAsync()` uses case-insensitive, trimmed matching
- `GetAllEquipmentAsync()` queries `DbContext.Equipment` directly (TPH filtering)
- `GetEquipmentBySlotAsync()` filters Equipment subtype by slot
- All queries order results by Name alphabetically

### IInventoryRepository Interface

Inventory join table operations:

```csharp
public interface IInventoryRepository
{
    Task<IEnumerable<InventoryItem>> GetByCharacterIdAsync(Guid characterId);
    Task<IEnumerable<InventoryItem>> GetEquippedItemsAsync(Guid characterId);
    Task<InventoryItem?> GetEquippedInSlotAsync(Guid characterId, EquipmentSlot slot);
    Task<InventoryItem?> GetByCharacterAndItemAsync(Guid characterId, Guid itemId);
    Task<InventoryItem?> FindByItemNameAsync(Guid characterId, string itemName);

    // Weight and count calculations
    Task<int> GetTotalWeightAsync(Guid characterId);
    Task<int> GetItemCountAsync(Guid characterId);

    // CRUD operations
    Task AddAsync(InventoryItem inventoryItem);
    Task UpdateAsync(InventoryItem inventoryItem);
    Task RemoveAsync(Guid characterId, Guid itemId);
    Task ClearInventoryAsync(Guid characterId);
    Task SaveChangesAsync();
}
```

**Key Methods:**
- `GetTotalWeightAsync()` uses `SumAsync(ii => ii.Item.Weight * ii.Quantity)`
- `GetEquippedInSlotAsync()` casts Item to Equipment for slot filtering
- `FindByItemNameAsync()` performs case-insensitive search on Item.Name
- `ClearInventoryAsync()` removes all entries and calls SaveChangesAsync

### TPH Database Configuration

Entity Framework Core TPH setup in `RuneAndRustDbContext`:

```csharp
modelBuilder.Entity<Item>(entity =>
{
    entity.ToTable("Items");
    entity.HasKey(i => i.Id);

    // TPH discriminator column
    entity.HasDiscriminator<string>("ItemDiscriminator")
        .HasValue<Item>("Item")
        .HasValue<Equipment>("Equipment");

    // Indexes for efficient queries
    entity.HasIndex(i => i.Name);
    entity.HasIndex(i => i.Quality);
    entity.HasIndex(i => i.ItemType);
});

modelBuilder.Entity<Equipment>(entity =>
{
    entity.Property(e => e.Slot).IsRequired();

    // JSON storage for dictionaries
    entity.Property(e => e.AttributeBonuses)
        .HasColumnType("jsonb")
        .HasConversion(/* JSON serialization */);

    entity.Property(e => e.Requirements)
        .HasColumnType("jsonb")
        .HasConversion(/* JSON serialization */);

    entity.HasIndex(e => e.Slot);
});
```

**TPH Strategy:**
- Single "Items" table contains both Item and Equipment rows
- "ItemDiscriminator" column differentiates types ("Item" or "Equipment")
- Equipment-specific columns (Slot, AttributeBonuses, Requirements) null for base Items
- Indexes on Quality, ItemType, Slot for fast filtering

### InventoryItem Composite Key Configuration

```csharp
modelBuilder.Entity<InventoryItem>(entity =>
{
    entity.ToTable("InventoryItems");

    // Composite primary key
    entity.HasKey(ii => new { ii.CharacterId, ii.ItemId });

    // Relationships with cascade delete
    entity.HasOne(ii => ii.Character)
        .WithMany(c => c.Inventory)
        .HasForeignKey(ii => ii.CharacterId)
        .OnDelete(DeleteBehavior.Cascade);

    entity.HasOne(ii => ii.Item)
        .WithMany()
        .HasForeignKey(ii => ii.ItemId)
        .OnDelete(DeleteBehavior.Cascade);

    // Indexes
    entity.HasIndex(ii => ii.CharacterId);
    entity.HasIndex(ii => ii.IsEquipped);
});
```

---

## Logging Matrix (v0.1.2a)

### ItemRepository Logs

| Event | Level | Template |
|-------|-------|----------|
| Fetch by Quality | Debug | `"Fetching items with quality tier {Quality}"` |
| Retrieved by Quality | Debug | `"Retrieved {Count} items with quality tier {Quality}"` |
| Fetch by Type | Debug | `"Fetching items of type {ItemType}"` |
| Retrieved by Type | Debug | `"Retrieved {Count} items of type {ItemType}"` |
| Fetch Equipment by Slot | Debug | `"Fetching equipment for slot {Slot}"` |
| Retrieved Equipment by Slot | Debug | `"Retrieved {Count} equipment items for slot {Slot}"` |
| Search by Name | Debug | `"Searching for item by name '{ItemName}'"` |
| Item Not Found | Debug | `"Item '{ItemName}' not found"` |
| Item Found | Debug | `"Found item '{ItemName}' ({ItemId})"` |
| Fetch All Equipment | Debug | `"Fetching all equipment items"` |
| Retrieved All Equipment | Debug | `"Retrieved {Count} equipment items"` |
| Add Range | Debug | `"Adding {Count} items to database"` |
| Add Range Complete | Debug | `"Successfully added {Count} items to context"` |

### InventoryRepository Logs

| Event | Level | Template |
|-------|-------|----------|
| Fetch Inventory | Debug | `"Fetching inventory for character {CharacterId}"` |
| Retrieved Inventory | Debug | `"Retrieved {Count} inventory items for character {CharacterId}"` |
| Fetch Equipped Items | Debug | `"Fetching equipped items for character {CharacterId}"` |
| Retrieved Equipped Items | Debug | `"Retrieved {Count} equipped items for character {CharacterId}"` |
| Check Equipped in Slot | Debug | `"Checking equipped item in slot {Slot} for character {CharacterId}"` |
| No Item in Slot | Debug | `"No item equipped in slot {Slot} for character {CharacterId}"` |
| Found Equipped in Slot | Debug | `"Found equipped item '{ItemName}' in slot {Slot}"` |
| Fetch by Character and Item | Debug | `"Fetching inventory entry for character {CharacterId} and item {ItemId}"` |
| Entry Not Found | Debug | `"No inventory entry found for character {CharacterId} and item {ItemId}"` |
| Entry Found | Debug | `"Found inventory entry for item '{ItemName}'"` |
| Search by Item Name | Debug | `"Searching for item '{ItemName}' in inventory of character {CharacterId}"` |
| Item Not in Inventory | Debug | `"Item '{ItemName}' not found in inventory of character {CharacterId}"` |
| Item Found in Inventory | Debug | `"Found item '{ItemName}' in inventory"` |
| Calculate Total Weight | Debug | `"Calculating total inventory weight for character {CharacterId}"` |
| Total Weight Result | Debug | `"Total inventory weight for character {CharacterId}: {Weight}g"` |
| Count Slots | Debug | `"Counting inventory slots for character {CharacterId}"` |
| Slot Count Result | Debug | `"Character {CharacterId} has {Count} inventory slots used"` |
| Add Entry | Debug | `"Adding item {ItemId} to inventory of character {CharacterId}"` |
| Add Complete | Debug | `"Successfully added inventory entry to context"` |
| Update Entry | Debug | `"Updating inventory entry for character {CharacterId} and item {ItemId}"` |
| Update Complete | Debug | `"Successfully updated inventory entry in context"` |
| Remove Entry | Debug | `"Removing item {ItemId} from inventory of character {CharacterId}"` |
| Remove Complete | Debug | `"Successfully marked inventory entry for removal"` |
| Remove Non-Existent | Warning | `"Attempted to remove non-existent inventory entry for character {CharacterId} and item {ItemId}"` |
| Clear Inventory Start | Information | `"Clearing all inventory entries for character {CharacterId}"` |
| Clear Inventory Complete | Information | `"Cleared {Count} inventory entries for character {CharacterId}"` |
| Save Changes | Debug | `"Saving inventory changes to database"` |
| Save Changes Complete | Debug | `"Saved {ChangeCount} inventory changes to database"` |

---

## Complete Test Inventory (Part A)

### Core/QualityTierTests.cs (8 tests)

| Test Name | Description |
|-----------|-------------|
| `QualityTier_ShouldHaveExactlyFiveValues` | Validates exactly 5 quality tiers exist |
| `QualityTier_ShouldContain_JuryRigged` | JuryRigged value is defined |
| `QualityTier_ShouldContain_Scavenged` | Scavenged value is defined |
| `QualityTier_ShouldContain_ClanForged` | ClanForged value is defined |
| `QualityTier_ShouldContain_Optimized` | Optimized value is defined |
| `QualityTier_ShouldContain_MythForged` | MythForged value is defined |
| `QualityTier_EnumValues_ShouldBeSequential` | Values are 0,1,2,3,4 in sequence |
| `QualityTier_ToString_ReturnsExpectedName` | ToString returns correct names (5 theory cases) |
| `QualityTier_Order_ShouldRepresentIncreasingQuality` | Each tier value > previous tier value |

### Core/EquipmentSlotTests.cs (9 tests)

| Test Name | Description |
|-----------|-------------|
| `EquipmentSlot_ShouldHaveExactlySevenValues` | Validates exactly 7 equipment slots exist |
| `EquipmentSlot_ShouldContain_MainHand` | MainHand value is defined |
| `EquipmentSlot_ShouldContain_OffHand` | OffHand value is defined |
| `EquipmentSlot_ShouldContain_Head` | Head value is defined |
| `EquipmentSlot_ShouldContain_Body` | Body value is defined |
| `EquipmentSlot_ShouldContain_Hands` | Hands value is defined |
| `EquipmentSlot_ShouldContain_Feet` | Feet value is defined |
| `EquipmentSlot_ShouldContain_Accessory` | Accessory value is defined |
| `EquipmentSlot_EnumValues_ShouldBeSequential` | Values are 0,1,2,3,4,5,6 in sequence |
| `EquipmentSlot_ToString_ReturnsExpectedName` | ToString returns correct names (7 theory cases) |

### Core/ItemTypeTests.cs (8 tests)

| Test Name | Description |
|-----------|-------------|
| `ItemType_ShouldHaveExactlySixValues` | Validates exactly 6 item types exist |
| `ItemType_ShouldContain_Weapon` | Weapon value is defined |
| `ItemType_ShouldContain_Armor` | Armor value is defined |
| `ItemType_ShouldContain_Consumable` | Consumable value is defined |
| `ItemType_ShouldContain_Material` | Material value is defined |
| `ItemType_ShouldContain_KeyItem` | KeyItem value is defined |
| `ItemType_ShouldContain_Junk` | Junk value is defined |
| `ItemType_EnumValues_ShouldBeSequential` | Values are 0,1,2,3,4,5 in sequence |
| `ItemType_ToString_ReturnsExpectedName` | ToString returns correct names (6 theory cases) |

### Core/BurdenStateTests.cs (7 tests)

| Test Name | Description |
|-----------|-------------|
| `BurdenState_ShouldHaveExactlyThreeValues` | Validates exactly 3 burden states exist |
| `BurdenState_ShouldContain_Light` | Light value is defined |
| `BurdenState_ShouldContain_Heavy` | Heavy value is defined |
| `BurdenState_ShouldContain_Overburdened` | Overburdened value is defined |
| `BurdenState_EnumValues_ShouldBeSequential` | Values are 0,1,2 in sequence |
| `BurdenState_ToString_ReturnsExpectedName` | ToString returns correct names (3 theory cases) |
| `BurdenState_Order_ShouldRepresentIncreasingSeverity` | Each state value > previous state value |

### Core/ItemTests.cs (15 tests)

| Test Name | Description |
|-----------|-------------|
| `Item_NewInstance_ShouldHaveUniqueId` | Each instance has unique GUID |
| `Item_DefaultName_ShouldBeEmpty` | Name defaults to empty string |
| `Item_DefaultItemType_ShouldBeJunk` | ItemType defaults to Junk |
| `Item_DefaultDescription_ShouldBeEmpty` | Description defaults to empty string |
| `Item_DetailedDescription_ShouldBeNullByDefault` | DetailedDescription defaults to null |
| `Item_DefaultWeight_ShouldBeZero` | Weight defaults to 0 grams |
| `Item_DefaultValue_ShouldBeZero` | Value defaults to 0 Scrip |
| `Item_DefaultQuality_ShouldBeScavenged` | Quality defaults to Scavenged (tier 1) |
| `Item_DefaultIsStackable_ShouldBeFalse` | IsStackable defaults to false |
| `Item_DefaultMaxStackSize_ShouldBeOne` | MaxStackSize defaults to 1 |
| `Item_CreatedAt_ShouldBeSetOnCreation` | Timestamp set on instantiation |
| `Item_LastModified_ShouldBeSetOnCreation` | LastModified set on instantiation |
| `Item_CanSetAllProperties` | All properties are settable |
| `Item_Weight_CanBeSetToGramValue` | Weight accepts gram values |
| `Item_Stackable_CanBeConfigured` | Stacking properties work together |

### Core/EquipmentTests.cs (18 tests)

| Test Name | Description |
|-----------|-------------|
| `Equipment_InheritsFromItem` | Equipment is subclass of Item (TPH) |
| `Equipment_DefaultSlot_ShouldBeMainHand` | Slot defaults to MainHand |
| `Equipment_AttributeBonuses_ShouldBeEmptyDictionary` | AttributeBonuses initializes to empty dictionary |
| `Equipment_DefaultSoakBonus_ShouldBeZero` | SoakBonus defaults to 0 |
| `Equipment_DefaultDamageDie_ShouldBeZero` | DamageDie defaults to 0 (non-weapon) |
| `Equipment_Requirements_ShouldBeEmptyDictionary` | Requirements initializes to empty dictionary |
| `Equipment_CanAddAttributeBonuses` | Can add bonuses to dictionary |
| `Equipment_CanAddRequirements` | Can add requirements to dictionary |
| `Equipment_GetAttributeBonus_ExistingAttribute_ReturnsBonus` | GetAttributeBonus returns value for existing key |
| `Equipment_GetAttributeBonus_NonExistingAttribute_ReturnsZero` | GetAttributeBonus returns 0 for missing key |
| `Equipment_MeetsRequirements_AllMet_ReturnsTrue` | Returns true when all requirements satisfied |
| `Equipment_MeetsRequirements_OneFails_ReturnsFalse` | Returns false if any requirement not met |
| `Equipment_MeetsRequirements_NoRequirements_ReturnsTrue` | Returns true when requirements dictionary empty |
| `Equipment_Weapon_CanSetDamageDie` | Weapon damage die can be set (d6, d8, d10) |
| `Equipment_Armor_CanSetSoakBonus` | Armor soak bonus can be set |
| `Equipment_Slot_AcceptsAllSlotValues` | All EquipmentSlot values valid (7 theory cases) |
| `Equipment_InheritsItemProperties` | Inherits Name, Quality, Weight, etc. from Item |
| `Equipment_CompleteConfiguration_ShouldSetAllProperties` | Full equipment setup works |

### Core/InventoryItemTests.cs (10 tests)

| Test Name | Description |
|-----------|-------------|
| `InventoryItem_DefaultCharacterId_ShouldBeEmpty` | CharacterId defaults to empty GUID |
| `InventoryItem_DefaultItemId_ShouldBeEmpty` | ItemId defaults to empty GUID |
| `InventoryItem_DefaultQuantity_ShouldBeOne` | Quantity defaults to 1 |
| `InventoryItem_DefaultSlotPosition_ShouldBeZero` | SlotPosition defaults to 0 |
| `InventoryItem_DefaultIsEquipped_ShouldBeFalse` | IsEquipped defaults to false |
| `InventoryItem_CanSetAllProperties` | All properties are settable |
| `InventoryItem_NavigationProperties_CanBeSet` | Character and Item navigation properties work |
| `InventoryItem_AddedAt_ShouldBeSetOnCreation` | Timestamp set on instantiation |
| `InventoryItem_LastModified_ShouldBeSetOnCreation` | LastModified set on instantiation |
| `InventoryItem_Quantity_CanBeGreaterThanOne` | Quantity supports stacking |

### Integration/ItemPersistenceTests.cs (20 tests)

| Test Name | Description |
|-----------|-------------|
| `AddAsync_ShouldPersistItem` | Basic item add and retrieve |
| `AddAsync_ShouldPersistAllItemProperties` | All Item properties persist correctly |
| `UpdateAsync_ShouldModifyItem` | Item update persists changes |
| `DeleteAsync_ShouldRemoveItem` | Item deletion works |
| `GetByQualityAsync_ReturnsItemsOfQuality` | Quality filtering returns correct items |
| `GetByQualityAsync_NoMatches_ReturnsEmptyList` | Quality filter with no matches returns empty |
| `GetByTypeAsync_ReturnsItemsOfType` | ItemType filtering returns correct items |
| `GetByNameAsync_FindsExactMatch` | Name search finds exact match |
| `GetByNameAsync_CaseInsensitive` | Name search is case-insensitive |
| `GetByNameAsync_NotFound_ReturnsNull` | Missing item returns null |
| `AddAsync_ShouldPersistEquipment` | Equipment (TPH subtype) persists |
| `AddAsync_ShouldPersistEquipmentWithBonuses` | Equipment dictionaries (bonuses, requirements) persist as JSON |
| `GetAllEquipmentAsync_ReturnsOnlyEquipment` | Returns only Equipment rows via TPH discriminator |
| `GetEquipmentBySlotAsync_ReturnsEquipmentForSlot` | Slot filtering returns correct equipment |
| `AddRangeAsync_AddsMultipleItems` | Bulk add operation works |
| `Equipment_LoadedFromDatabase_HasCorrectDiscriminator` | TPH discriminator correctly identifies Equipment |
| `Equipment_AttributeBonuses_LoadFromJson` | JSONB AttributeBonuses deserialize correctly |
| `Equipment_Requirements_LoadFromJson` | JSONB Requirements deserialize correctly |
| `Item_CanBeRetrievedAsBaseType` | Base Item query includes both Item and Equipment |
| `Equipment_InheritedProperties_Persist` | Equipment inherits and persists Item properties |

### Integration/InventoryPersistenceTests.cs (18 tests)

| Test Name | Description |
|-----------|-------------|
| `AddAsync_ShouldPersistInventoryEntry` | Basic inventory entry add and retrieve |
| `AddAsync_ShouldPersistAllProperties` | All InventoryItem properties persist |
| `GetByCharacterIdAsync_ReturnsAllInventoryItems` | Character inventory query returns all items |
| `GetByCharacterIdAsync_IncludesItemNavigation` | Item navigation property loaded via Include |
| `GetByCharacterIdAsync_ReturnsOrderedBySlotPosition` | Results ordered by SlotPosition ascending |
| `GetByCharacterIdAsync_EmptyInventory_ReturnsEmptyList` | Empty inventory returns empty list |
| `GetEquippedItemsAsync_ReturnsOnlyEquipped` | Filters to IsEquipped = true entries |
| `GetEquippedInSlotAsync_ReturnsEquippedItem` | Finds equipped item in specific slot |
| `GetEquippedInSlotAsync_EmptySlot_ReturnsNull` | Empty slot returns null |
| `FindByItemNameAsync_FindsItem` | Case-insensitive item name search works |
| `FindByItemNameAsync_CaseInsensitive` | Name search ignores case |
| `FindByItemNameAsync_NotFound_ReturnsNull` | Missing item returns null |
| `GetTotalWeightAsync_CalculatesTotalWeight` | SumAsync(Weight * Quantity) calculation correct |
| `GetTotalWeightAsync_EmptyInventory_ReturnsZero` | Empty inventory returns 0 weight |
| `GetItemCountAsync_CountsSlots` | Counts distinct inventory entries |
| `UpdateAsync_ShouldModifyEntry` | Update persists changes |
| `RemoveAsync_ShouldRemoveEntry` | Delete by composite key works |
| `ClearInventoryAsync_RemovesAllEntries` | Character inventory cleared |
| `ClearInventoryAsync_DoesNotAffectOtherCharacters` | Clear isolated to single character |

---

## Database Schema Additions (Part A)

### Items Table (TPH)

```sql
CREATE TABLE "Items" (
    "Id" uuid NOT NULL PRIMARY KEY,
    "ItemDiscriminator" character varying(13) NOT NULL,  -- 'Item' or 'Equipment'
    "Name" character varying(100) NOT NULL,
    "ItemType" integer NOT NULL,
    "Description" character varying(500) NOT NULL,
    "DetailedDescription" character varying(1000),
    "Weight" integer NOT NULL,
    "Value" integer NOT NULL,
    "Quality" integer NOT NULL,
    "IsStackable" boolean NOT NULL,
    "MaxStackSize" integer NOT NULL,
    "CreatedAt" timestamp with time zone NOT NULL,
    "LastModified" timestamp with time zone NOT NULL,

    -- Equipment-specific columns (null for base Items)
    "Slot" integer,
    "SoakBonus" integer,
    "DamageDie" integer,
    "AttributeBonuses" jsonb,
    "Requirements" jsonb
);

CREATE INDEX "IX_Items_Name" ON "Items" ("Name");
CREATE INDEX "IX_Items_Quality" ON "Items" ("Quality");
CREATE INDEX "IX_Items_ItemType" ON "Items" ("ItemType");
CREATE INDEX "IX_Items_Slot" ON "Items" ("Slot");
```

### InventoryItems Table

```sql
CREATE TABLE "InventoryItems" (
    "CharacterId" uuid NOT NULL,
    "ItemId" uuid NOT NULL,
    "Quantity" integer NOT NULL,
    "SlotPosition" integer NOT NULL,
    "IsEquipped" boolean NOT NULL,
    "AddedAt" timestamp with time zone NOT NULL,
    "LastModified" timestamp with time zone NOT NULL,

    PRIMARY KEY ("CharacterId", "ItemId"),

    CONSTRAINT "FK_InventoryItems_Characters"
        FOREIGN KEY ("CharacterId")
        REFERENCES "Characters" ("Id")
        ON DELETE CASCADE,

    CONSTRAINT "FK_InventoryItems_Items"
        FOREIGN KEY ("ItemId")
        REFERENCES "Items" ("Id")
        ON DELETE CASCADE
);

CREATE INDEX "IX_InventoryItems_CharacterId" ON "InventoryItems" ("CharacterId");
CREATE INDEX "IX_InventoryItems_IsEquipped" ON "InventoryItems" ("IsEquipped");
```

### Characters Table Modifications

```sql
ALTER TABLE "Characters"
ADD COLUMN "EquipmentBonuses" jsonb NOT NULL DEFAULT '{}'::jsonb;
```

### InteractableObjects Table Modifications

```sql
ALTER TABLE "InteractableObjects"
ADD COLUMN "HasBeenSearched" boolean NOT NULL DEFAULT false,
ADD COLUMN "LootTier" integer NULL;
```

---

## Part A Test Results

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
Starting test execution, please wait...

Passed!  - Failed:     0
           Passed:   962
           Skipped:    0
           Total:    962
           Duration: 483 ms
```

**v0.1.2a Specific Tests:**
```
Passed!  - Failed:     0
           Passed:   149
           Skipped:    0
           Total:    149
           Duration: 470 ms
```

---

## Part B: Player Interaction (December 19, 2025)

# Changelog: v0.1.2b - The Burden of Survival (Player Interaction)

**Release Date:** 2025-12-19

---

## Summary

Version 0.1.2b implements the complete **inventory and equipment system** for player interaction with items. This release introduces the `InventoryService` to manage inventory operations, burden calculation with encumbrance mechanics, and equipment management with attribute bonus recalculation. The system enforces realistic carrying capacity limits based on the MIGHT attribute, applies Finesse penalties when heavily burdened, and prevents movement when overburdened. The `CommandParser` received extensive updates to support inventory commands (`inventory`, `equipment`, `equip`, `unequip`, `drop`), creating a comprehensive item management interface. This release completes the player interaction layer, bridging domain models with user-facing commands through robust service orchestration.

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/BurdenState.cs` | Defines encumbrance states (Light, Heavy, Overburdened) based on carried weight percentage |
| `RuneAndRust.Core/Interfaces/IInventoryService.cs` | Service contract for inventory operations including `InventoryResult` record type |
| `RuneAndRust.Core/Interfaces/IInventoryRepository.cs` | Repository contract for InventoryItem persistence and querying |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/InventoryService.cs` | Full inventory management implementation with burden calculation, equipment handling, and display formatting |

### Persistence Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Repositories/InventoryRepository.cs` | EF Core repository implementation for InventoryItem queries and persistence |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/InventoryServiceTests.cs` | Comprehensive test suite with 55 tests covering all inventory operations |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added inventory commands (`inventory`/`i`/`pack`, `equipment`/`gear`/`equipped`, `equip <item>`, `unequip <slot>`, `drop <item>`) and corresponding ParseResult flags |
| `RuneAndRust.Engine/Services/StatCalculationService.cs` | Updated `RecalculateDerivedStats` to use `GetEffectiveAttribute` for equipment bonuses; added initialization logic and ratio preservation for HP/Stamina |
| `RuneAndRust.Tests/Engine/CommandParserTests.cs` | Added 15 tests for inventory command parsing and validation |
| `RuneAndRust.Tests/Engine/StatCalculationServiceTests.cs` | Added 30 tests for derived stat calculations, equipment bonus integration, and archetype/lineage bonus methods |

---

## Code Implementation Details

### BurdenState Enum

```csharp
public enum BurdenState
{
    Light = 0,        // Under 70% capacity - no penalties
    Heavy = 1,        // 70-90% capacity - -2 Finesse penalty
    Overburdened = 2  // Over 90% capacity - cannot move
}
```

**Values:**
- `Light`: Normal movement, full attributes
- `Heavy`: -2 Finesse penalty applied to EquipmentBonuses
- `Overburdened`: Movement blocked (CanMoveAsync returns false)

### IInventoryService Interface

**Key Methods:**
```csharp
Task<InventoryResult> AddItemAsync(Character character, Item item, int quantity = 1);
Task<InventoryResult> RemoveItemAsync(Character character, string itemName, int quantity = 1);
Task<InventoryResult> DropItemAsync(Character character, string itemName);
Task<InventoryResult> EquipItemAsync(Character character, string itemName);
Task<InventoryResult> UnequipSlotAsync(Character character, EquipmentSlot slot);
Task<InventoryResult> UnequipItemAsync(Character character, string itemName);
Task<BurdenState> CalculateBurdenAsync(Character character);
int GetMaxCapacity(Character character);
Task<int> GetCurrentWeightAsync(Character character);
Task<bool> CanMoveAsync(Character character);
Task RecalculateEquipmentBonusesAsync(Character character);
Task<string> FormatInventoryDisplayAsync(Character character);
Task<string> FormatEquipmentDisplayAsync(Character character);
```

**InventoryResult Record:**
```csharp
public record InventoryResult(bool Success, string Message);
```

### InventoryService Implementation

**Constants:**
- `HeavyBurdenThreshold = 0.7` (70% of max capacity)
- `OverburdenedThreshold = 0.9` (90% of max capacity)
- `GramsPerMight = 10000` (capacity formula)

**Core Behaviors:**

**AddItemAsync:**
- Validates quantity > 0
- Checks for existing inventory entry
- Handles stackable items: increases quantity if within MaxStackSize
- Rejects non-stackable duplicates
- Creates new InventoryItem with next SlotPosition

**RemoveItemAsync:**
- Finds item by name (case-insensitive via repository)
- Decreases quantity or removes entry entirely
- Returns failure if insufficient quantity

**DropItemAsync:**
- Prevents dropping equipped items
- Prevents dropping KeyItem types
- Removes entire stack from inventory

**EquipItemAsync:**
- Validates item is Equipment type
- Checks equipment requirements via `MeetsRequirements()`
- Unequips any item currently in target slot
- Sets `IsEquipped = true`
- Calls `RecalculateEquipmentBonusesAsync`

**UnequipSlotAsync / UnequipItemAsync:**
- Sets `IsEquipped = false`
- Calls `RecalculateEquipmentBonusesAsync`

**CalculateBurdenAsync:**
- Formula: `ratio = currentWeight / maxCapacity`
- Returns `Overburdened` if ratio >= 0.9
- Returns `Heavy` if ratio >= 0.7
- Returns `Light` otherwise
- Logs warning if maxCapacity == 0

**GetMaxCapacity:**
- Formula: `effectiveMight × 10,000 grams`
- Uses `character.GetEffectiveAttribute(Might)` to include equipment bonuses

**RecalculateEquipmentBonusesAsync:**
- Clears existing EquipmentBonuses dictionary
- Iterates equipped items, summing AttributeBonuses
- Applies -2 Finesse penalty if burden state is Heavy
- Does NOT apply penalty if Overburdened (movement already blocked)

**FormatInventoryDisplayAsync:**
- Header: "=== PACK ==="
- Lists unequipped items with quantity and weight in kg
- Displays current/max weight in kg
- Shows burden state with penalty descriptions

**FormatEquipmentDisplayAsync:**
- Header: "=== EQUIPMENT ==="
- Lists all equipment slots (MainHand, OffHand, Head, Body, Hands, Legs, Feet, Neck, Finger1, Finger2)
- Shows equipped item name or "(empty)"

### CommandParser Updates

**New ParseResult Flags:**
```csharp
public bool RequiresInventory { get; set; }
public bool RequiresEquipment { get; set; }
public bool RequiresEquip { get; set; }
public string? EquipTarget { get; set; }
public bool RequiresUnequip { get; set; }
public string? UnequipTarget { get; set; }
public bool RequiresDrop { get; set; }
public string? DropTarget { get; set; }
```

**Command Mappings:**
- `inventory`, `i`, `pack` → `RequiresInventory = true`
- `equipment`, `gear`, `equipped` → `RequiresEquipment = true`
- `equip <item>`, `bind <item>` → `RequiresEquip = true`, `EquipTarget = <item>`
- `unequip <slot>`, `unbind <item>`, `remove <slot>` → `RequiresUnequip = true`, `UnequipTarget = <slot|item>`
- `drop <item>`, `discard <item>` → `RequiresDrop = true`, `DropTarget = <item>`

**Target Extraction:**
- Uses `ExtractTarget()` helper to parse command targets
- Converts targets to lowercase for case-insensitive matching
- Displays error if command lacks required target

**Help Text Updates:**
- Added "Inventory:" section with inventory/equipment/equip/unequip/drop commands
- Separated "objects"/"items" (room objects) from "inventory"/"i"/"pack" (player inventory)

### StatCalculationService Updates

**RecalculateDerivedStats Changes:**

1. **Equipment Bonus Integration:**
   - Changed from base attributes to `GetEffectiveAttribute()` calls
   - MaxHP uses effective Sturdiness
   - MaxStamina uses effective Finesse and Sturdiness
   - ActionPoints uses effective Wits

2. **Initialization Logic:**
   - Detects first-time calculation when `previousMax = 0`
   - Sets CurrentHP to MaxHP on initialization
   - Sets CurrentStamina to MaxStamina on initialization

3. **Ratio Preservation:**
   - Calculates HP/Stamina ratio before updating max values
   - Applies ratio to new max values when max changes
   - Ensures CurrentHP >= 1 after recalculation
   - Ensures CurrentStamina >= 0 after recalculation

**New Methods Tested:**
- `CalculateMaxHP(int sturdiness)` - Formula: `50 + (sturdiness × 10)`
- `CalculateMaxStamina(int finesse, int sturdiness)` - Formula: `20 + (finesse × 5) + (sturdiness × 3)`
- `CalculateActionPoints(int wits)` - Formula: `2 + (wits / 4)` (integer division)
- `GetArchetypeBonuses(ArchetypeType)` - Returns attribute bonuses for Warrior, Skirmisher, Adept, Mystic
- `GetLineageBonuses(LineageType)` - Returns attribute bonuses for Human, RuneMarked, IronBlooded, VargrKin

---

## Logging Matrix (Part B)

### InventoryService

| Event | Level | Template |
|-------|-------|----------|
| Add item start | Information | `"Adding {Quantity}x {ItemName} to {CharacterName}'s inventory"` |
| Invalid quantity | Warning | `"Invalid quantity {Quantity} for AddItemAsync"` |
| Stack exceeds max | Warning | `"Stack would exceed max size: {NewQuantity} > {MaxStack}"` |
| Update stack | Debug | `"Updated stack to {Quantity}x {ItemName}"` |
| Item not stackable | Warning | `"Item {ItemName} is not stackable and already in inventory"` |
| Add complete | Information | `"Added {Quantity}x {ItemName} to inventory"` |
| Remove start | Information | `"Removing {Quantity}x {ItemName} from {CharacterName}'s inventory"` |
| Item not found | Debug | `"Item {ItemName} not found in inventory"` |
| Insufficient quantity | Debug | `"Not enough {ItemName}: have {Have}, need {Need}"` |
| Remove complete | Information | `"Removed {Quantity}x {ItemName} from inventory"` |
| Drop start | Information | `"{CharacterName} dropping {ItemName}"` |
| Drop complete | Information | `"Dropped {ItemName}"` |
| Equip start | Information | `"{CharacterName} equipping {ItemName}"` |
| Unequip old item | Debug | `"Unequipped {OldItem} from {Slot}"` |
| Equip complete | Information | `"Equipped {ItemName} in {Slot}"` |
| Unequip slot start | Information | `"{CharacterName} unequipping slot {Slot}"` |
| Unequip slot complete | Information | `"Unequipped {ItemName} from {Slot}"` |
| Unequip item start | Information | `"{CharacterName} unequipping {ItemName}"` |
| Unequip item complete | Information | `"Unequipped {ItemName}"` |
| Max capacity zero | Warning | `"Max capacity is zero for {CharacterName}"` |
| Burden calculation | Debug | `"Burden calculation: {Current}g / {Max}g = {Ratio:P1}"` |
| Recalculate start | Debug | `"Recalculating equipment bonuses for {CharacterName}"` |
| Heavy burden penalty | Debug | `"Applied Heavy burden penalty: -2 Finesse"` |
| Recalculate complete | Information | `"Equipment bonuses recalculated: {BonusCount} attributes modified"` |

### StatCalculationService

| Event | Level | Template |
|-------|-------|----------|
| Recalculate start | Information | `"Recalculating derived stats for character {CharacterName}"` |
| Effective attributes | Debug | `"Effective attributes - Sturdiness: {Sturdiness}, Finesse: {Finesse}, Wits: {Wits}"` |
| Derived stats complete | Information | `"Derived stats calculated - MaxHP: {MaxHP}, MaxStamina: {MaxStamina}, ActionPoints: {ActionPoints}"` |
| Calculate MaxHP | Trace | `"Calculating MaxHP for Sturdiness {Sturdiness}"` |
| MaxHP result | Debug | `"MaxHP calculated: 50 + ({Sturdiness} * 10) = {Result}"` |
| Calculate MaxStamina | Trace | `"Calculating MaxStamina for Finesse {Finesse}, Sturdiness {Sturdiness}"` |
| MaxStamina result | Debug | `"MaxStamina calculated: 20 + ({Finesse} * 5) + ({Sturdiness} * 3) = {Result}"` |
| Calculate ActionPoints | Trace | `"Calculating ActionPoints for Wits {Wits}"` |
| ActionPoints result | Debug | `"ActionPoints calculated: 2 + ({Wits} / 4) = {Result}"` |

---

## Part B Test Coverage

### Summary
```
Total: 962 | Passed: 962 | Failed: 0 | Duration: 514ms
```

**New Tests Added:** 92 tests
- InventoryServiceTests: 55 tests
- StatCalculationServiceTests: 30 new tests
- CommandParserTests: 15 new tests
- Modified: 2 tests updated in existing suites

---

## Part C: World Integration (December 19, 2025)

# Changelog: v0.1.2c - The Burden of Survival (World Integration)

**Release Date:** 2025-12-19

---

## Summary

Version 0.1.2c completes the **v0.1.2 inventory trilogy** by implementing the **procedural loot generation system** and integrating it with the existing world interaction layer. This release introduces `LootService` for biome-aware, danger-scaled item generation using weighted random selection with WITS-based quality bonuses. A comprehensive `LootTables` static class provides AAM-VOICE compliant item templates across five quality tiers (JuryRigged through MythForged) for weapons, armor, consumables, materials, and junk items. The `InteractionService` receives significant updates to support container searching with automatic loot generation, while `CommandParser` gains new commands for looting containers (`loot`, `take/get`, `use`). This release establishes the complete item acquisition pipeline from world exploration to inventory storage, closing the loop between room traversal, object interaction, and the burden mechanics introduced in v0.1.2b.

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/LootResult.cs` | Record types for loot generation results (`LootResult`) and generation parameters (`LootGenerationContext`) |
| `RuneAndRust.Core/Interfaces/ILootService.cs` | Service contract for procedural loot generation with 7 public methods |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/LootTables.cs` | Static loot table definitions with 60+ AAM-VOICE compliant item templates and weighted distributions |
| `RuneAndRust.Engine/Services/LootService.cs` | Full loot generation implementation with biome weighting, quality tier rolls, and WITS bonus mechanics |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/LootServiceTests.cs` | 31 tests covering loot generation, container searching, quality rolls, and biome weightings |
| `RuneAndRust.Tests/Engine/LootTablesTests.cs` | 25 tests validating table completeness, weight distributions, and AAM-VOICE compliance |
| `RuneAndRust.Tests/Engine/InteractionServiceLootTests.cs` | 13 tests for loot-related InteractionService methods |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/GameState.cs` | Changed `CurrentCharacter` type from implicit Models.Character to explicit `Entities.Character` for inventory service compatibility |
| `RuneAndRust.Core/Entities/Room.cs` | Added `BiomeType` and `DangerLevel` properties for loot generation context |
| `RuneAndRust.Core/Interfaces/IInteractionService.cs` | Added `SearchContainerAsync`, `TakeItemAsync`, and `GetAvailableItemsAsync` methods |
| `RuneAndRust.Engine/Services/InteractionService.cs` | Extended constructor with `IRoomRepository`, `ILootService`, and optional `IInventoryService`; implemented container loot tracking and item taking |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added `take`/`get`/`grab`, `loot`/`search <target>`, and `use`/`consume`/`apply` commands with corresponding ParseResult flags |
| `RuneAndRust.Tests/Engine/InteractionServiceTests.cs` | Updated constructor calls to include new mock dependencies |
| `RuneAndRust.Tests/Core/GameStateTests.cs` | Updated to use `Entities.Character` instead of `Models.Character` |
| `RuneAndRust.Tests/Engine/SaveManagerTests.cs` | Updated to use `Entities.Character` instead of `Models.Character` |

---

## Code Implementation Details

### LootResult Record

```csharp
public record LootResult(
    bool Success,
    string Message,
    IReadOnlyList<Item> Items,
    int TotalValue,
    int TotalWeight)
{
    public static LootResult Found(string message, IReadOnlyList<Item> items);
    public static LootResult Empty(string message);
    public static LootResult Failure(string message);
}
```

**Factory Methods:**
- `Found()`: Creates successful result, auto-calculates `TotalValue` and `TotalWeight` from items
- `Empty()`: Creates unsuccessful result with empty item list (for already-searched containers)
- `Failure()`: Creates unsuccessful result for invalid operations (closed container, non-container, etc.)

### LootGenerationContext Record

```csharp
public record LootGenerationContext(
    BiomeType BiomeType,
    DangerLevel DangerLevel,
    QualityTier? LootTier,
    int WitsBonus = 0);
```

**Parameters:**
- `BiomeType`: Influences item type distribution (Organic favors consumables, Industrial favors materials, Void favors combat items)
- `DangerLevel`: Affects quality tier probabilities and item count ranges
- `LootTier`: Optional override from container's `LootTier` property
- `WitsBonus`: Character WITS attribute bonus for quality upgrade chance

### ILootService Interface

```csharp
public interface ILootService
{
    LootResult GenerateLoot(LootGenerationContext context);
    Task<LootResult> SearchContainerAsync(InteractableObject container, LootGenerationContext context);
    Dictionary<QualityTier, int> GetQualityWeights(DangerLevel dangerLevel);
    QualityTier RollQualityTier(DangerLevel dangerLevel, int witsBonus = 0);
    int RollItemCount(DangerLevel dangerLevel);
    Item GenerateItem(QualityTier quality, BiomeType biome, ItemType? preferredType = null);
}
```

### LootTables Static Class

**Quality Weights by Danger Level:**

| Danger Level | JuryRigged | Scavenged | ClanForged | Optimized | MythForged |
|--------------|------------|-----------|------------|-----------|------------|
| Safe         | 30%        | 60%       | 10%        | 0%        | 0%         |
| Unstable     | 20%        | 50%       | 25%        | 5%        | 0%         |
| Hostile      | 10%        | 35%       | 35%        | 18%       | 2%         |
| Lethal       | 5%         | 25%       | 40%        | 25%       | 5%         |

**Item Count Ranges by Danger Level:**

| Danger Level | Min | Max |
|--------------|-----|-----|
| Safe         | 1   | 2   |
| Unstable     | 1   | 3   |
| Hostile      | 2   | 4   |
| Lethal       | 2   | 5   |

**Biome Item Type Weights:**

| Biome      | Weapon | Armor | Consumable | Material | Junk |
|------------|--------|-------|------------|----------|------|
| Ruin       | 20%    | 15%   | 15%        | 25%      | 25%  |
| Industrial | 15%    | 20%   | 10%        | 35%      | 20%  |
| Organic    | 10%    | 10%   | 40%        | 25%      | 15%  |
| Void       | 25%    | 25%   | 10%        | 20%      | 20%  |

**Template Categories (60+ Items):**

| Category    | Templates per Tier | Total |
|-------------|-------------------|-------|
| Weapons     | 2-3 per tier      | 14    |
| Armor       | 2-3 per tier      | 14    |
| Consumables | 1-3 per tier      | 11    |
| Materials   | 2-3 per tier      | 13    |
| Junk        | 8 (universal)     | 8     |

**Sample Weapon Templates (AAM-VOICE Compliant):**

```csharp
// MythForged tier
new WeaponTemplate(
    "Glitch-Touched Blade",
    "The metal shifts between states, solid and something... else.",
    "Observers report the edge existing in multiple positions simultaneously. Contact produces unexpected wounds.",
    EquipmentSlot.MainHand, 12, 800, 500)
```

### LootService Implementation

**Constructor:**
- Standard constructor with `ILogger<LootService>` for production use
- Seeded constructor `LootService(ILogger, int seed)` for deterministic testing

**GenerateLoot Algorithm:**
1. Roll item count based on danger level (1-5 items)
2. For each item:
   a. Use container `LootTier` override OR roll quality tier
   b. Roll item type based on biome weights
   c. Generate item from appropriate template table
3. Build loot message listing all item names
4. Return `LootResult.Found()` with items and calculated totals

**RollQualityTier with WITS Bonus:**
```csharp
// Each WITS point adds 2% upgrade chance, capped at 20%
var upgradeChance = Math.Min(witsBonus * 2, 20);

if (upgradeChance > 0 && _random.Next(100) < upgradeChance)
{
    ShiftWeightsUp(weights); // Reduces JuryRigged/Scavenged, increases ClanForged/Optimized
}
```

**Value Scaling by Quality:**

| Quality Tier | Value Multiplier |
|--------------|------------------|
| JuryRigged   | 50%              |
| Scavenged    | 100% (base)      |
| ClanForged   | 150%             |
| Optimized    | 200%             |
| MythForged   | 300%             |

### InteractionService Updates

**New Constructor Parameters:**
```csharp
public InteractionService(
    ILogger<InteractionService> logger,
    IInteractableObjectRepository objectRepository,
    IRoomRepository roomRepository,         // NEW
    ILootService lootService,               // NEW
    IDiceService diceService,
    GameState gameState,
    IInventoryService? inventoryService = null)  // NEW (optional)
```

**Container Loot Tracking:**
```csharp
private readonly Dictionary<Guid, List<Item>> _containerLoot = new();
```
- Stores generated items keyed by container ID
- Items remain available for `TakeItemAsync` until taken
- Cleared when items are taken

**SearchContainerAsync Flow:**
1. Validate game state (player in room)
2. Find container by name
3. Validate container state (is container, is open, not already searched)
4. Build `LootGenerationContext` from room's biome/danger and player's WITS
5. Call `ILootService.SearchContainerAsync`
6. Store generated items in `_containerLoot`
7. Persist container's `HasBeenSearched = true`
8. Return loot result

**TakeItemAsync Flow:**
1. Validate game state
2. Find item in `_containerLoot` from any open container
3. Remove item from container loot tracking
4. Add to player inventory via `IInventoryService` (if available)
5. Return narrative confirmation

### CommandParser Updates

**New ParseResult Flags:**
```csharp
public bool RequiresTake { get; set; }
public string? TakeTarget { get; set; }
public bool RequiresLoot { get; set; }
public string? LootTarget { get; set; }
public bool RequiresUse { get; set; }
public string? UseTarget { get; set; }
```

**Command Mappings:**

| Command | Aliases | ParseResult |
|---------|---------|-------------|
| `take <item>` | `get <item>`, `grab <item>` | `RequiresTake = true`, `TakeTarget = <item>` |
| `loot <container>` | `search <container>` | `RequiresLoot = true`, `LootTarget = <container>` |
| `use <item>` | `consume <item>`, `apply <item>` | `RequiresUse = true`, `UseTarget = <item>` |

**Help Text Updates:**
```
Loot:
  loot <container> - Search an open container for items
  take <item>      - Take an item from a container
  get <item>       - Take an item from a container
  use <item>       - Use a consumable item
```

### Room Entity Updates

```csharp
/// <summary>
/// Gets or sets the biome type affecting atmosphere and loot tables.
/// </summary>
public BiomeType BiomeType { get; set; } = BiomeType.Ruin;

/// <summary>
/// Gets or sets the danger level affecting encounter and loot quality.
/// </summary>
public DangerLevel DangerLevel { get; set; } = DangerLevel.Safe;
```

### GameState Type Correction

```csharp
// Changed from implicit Models.Character to explicit Entities.Character
public Entities.Character? CurrentCharacter { get; set; }
```

This change ensures compatibility with `IInventoryService.AddItemAsync` which expects `Entities.Character` for its inventory management operations.

---

## Logging Matrix (Part C)

### LootService

| Event | Level | Template |
|-------|-------|----------|
| Generate loot start | Information | `"Generating loot for Biome={Biome}, Danger={Danger}, WitsBonus={Wits}"` |
| Item count roll | Debug | `"Rolling {ItemCount} items for loot"` |
| Item generated | Debug | `"Generated item: {ItemName} ({Quality} {Type})"` |
| Loot complete | Information | `"Loot generation complete: {ItemCount} items, {TotalValue} Scrip value"` |
| Search container start | Information | `"Searching container '{ContainerName}' for loot"` |
| Already searched | Debug | `"Container '{ContainerName}' has already been searched"` |
| Not a container | Debug | `"Object '{ObjectName}' is not a container"` |
| Container closed | Debug | `"Container '{ContainerName}' is closed"` |
| Search complete | Information | `"Container '{ContainerName}' searched, found {ItemCount} items"` |
| Missing weights | Warning | `"No quality weights defined for danger level {DangerLevel}, using Safe defaults"` |
| WITS upgrade | Debug | `"WITS bonus triggered quality upgrade"` |
| Quality roll | Debug | `"Quality roll {Roll} resulted in tier {Tier}"` |
| Quality default | Debug | `"Quality roll defaulted to Scavenged"` |
| Item count range | Trace | `"Item count roll: {Count} (range {Min}-{Max})"` |
| Missing item range | Warning | `"No item count range defined for danger level {DangerLevel}"` |
| Item generation | Trace | `"Generating {Quality} {ItemType} item for {Biome} biome"` |
| Missing biome weights | Warning | `"No item type weights for biome {Biome}, using Ruin defaults"` |

### InteractionService (New Events)

| Event | Level | Template |
|-------|-------|----------|
| Search container request | Information | `"Searching container '{ContainerName}' in room {RoomId}"` |
| Context built | Debug | `"Loot context: Biome={Biome}, Danger={Danger}, Wits={Wits}"` |
| Items stored | Debug | `"Stored {Count} items for container {ContainerId}"` |
| Search persisted | Information | `"Container '{ContainerName}' searched, found {ItemCount} items"` |
| Take item request | Information | `"Attempting to take item '{ItemName}'"` |
| Item found | Debug | `"Found item '{ItemName}' in container '{ContainerName}'"` |
| Item taken | Information | `"Player took item '{ItemName}' from '{ContainerName}'"` |
| Item not found | Debug | `"Item '{ItemName}' not found in any open container"` |
| Inventory add failed | Debug | `"Could not add item to inventory: {Message}"` |
| Available items query | Debug | `"Getting available items in current room"` |
| Available items result | Debug | `"Found {Count} available items"` |

---

## Part C Test Coverage

### Summary
```
Total: 1046 | Passed: 1046 | Failed: 0 | Duration: 550ms
```

**New Tests Added:** 69 tests
- LootServiceTests: 31 tests
- LootTablesTests: 25 tests
- InteractionServiceLootTests: 13 tests

**Modified Tests:** 8 tests
- GameStateTests: 6 tests updated for Entities.Character
- SaveManagerTests: 2 tests updated for Entities.Character

---

## AAM-VOICE Compliance

All item descriptions in `LootTables.cs` adhere to **Domain 4: Technology Constraints**:

**Forbidden (Layer 2 Diagnostic):**
- Precision measurements (meters, kg, celsius, percentages)
- Modern technical terms (API, bug, debug, glitch as common noun)
- Decimal values or exact counts

**Allowed (Lore-Compliant):**
- "Glitch" as proper noun (the in-universe cataclysm event)
- "pre-Glitch", "POST-Glitch" as temporal markers
- Qualitative descriptions ("several", "approximately", "appears to")
- Archaic/clinical tone appropriate for Jötun-Reader perspective

**Example Compliant Descriptions:**

```csharp
// Weapon - Qualitative damage assessment
"The blade bears the pitting of long exposure. Its grip, wrapped in salvaged cloth, offers uncertain purchase."

// Armor - No numeric soak values in description
"The interior padding has long since deteriorated. Visibility remains compromised."

// Consumable - Effects without numeric healing
"Application promotes tissue repair." (not "heals 50 HP")

// MythForged - Mysterious, observer perspective
"Observers report the edge existing in multiple positions simultaneously. Contact produces unexpected wounds."
```

---

## v0.1.2 Trilogy Complete

With v0.1.2c, the complete "Burden of Survival" feature set is now implemented:

| Version | Focus | Key Components |
|---------|-------|----------------|
| v0.1.2a | Foundation | Item/Equipment entities, InventoryItem, QualityTier enum, persistence layer |
| v0.1.2b | Player Interaction | InventoryService, burden calculation, equipment bonuses, inventory commands |
| v0.1.2c | World Integration | LootService, LootTables, container searching, take/loot commands |

**Complete Item Flow:**
1. Player explores room with containers (v0.1.1)
2. Player opens container (`open <container>`)
3. Player searches container (`loot <container>`) → LootService generates items
4. Player takes items (`take <item>`) → Items move to inventory
5. Inventory weight affects burden state (v0.1.2b)
6. Player can equip gear for attribute bonuses (v0.1.2b)

---

## Verification Results

### Build Output
```
Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.51
```

### Final Test Output
```
Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:  1046, Skipped:     0, Total:  1046, Duration: 550 ms
```

---

## Test Summary

| Part | New Tests | Total After |
|------|-----------|-------------|
| Part A (Foundation) | 149 | 962 |
| Part B (Player Interaction) | 92 | 962* |
| Part C (World Integration) | 69 | 1046 |
| **Total New Tests** | **310** | - |

*Part B ran concurrently with Part A changes
