# v0.4.1b Design Specification: Trap Mechanics

**Version:** 0.4.1b
**Phase Name:** Trap Mechanics
**Parent Version:** v0.4.1 (Traps & Environmental Hazards)
**Prerequisites:** v0.4.1a Complete (Core Trap System)
**Estimated Tests:** ~35 unit tests

---

## 1. Overview

### 1.1 Purpose

Implement the active mechanics for traps including detection via Perception skill checks, disarm attempts using skill checks, automatic triggering based on player actions, and trap effects (damage, status effects, alerts). This phase brings the trap system to full functionality using the foundation established in v0.4.1a.

### 1.2 Current State

The following infrastructure exists from prior versions:

| Component | Location | Status |
|-----------|----------|--------|
| `Trap` entity | `Domain/Entities/Trap.cs` | From v0.4.1a |
| `TrapState` enum | `Domain/Enums/TrapState.cs` | From v0.4.1a |
| `TriggerType` enum | `Domain/Enums/TriggerType.cs` | From v0.4.1a |
| `TrapDefinition` | `Domain/Definitions/TrapDefinition.cs` | From v0.4.1a |
| `TrapEffectDefinition` | `Domain/Definitions/TrapDefinition.cs` | From v0.4.1a (placeholder) |
| `ITrapService` | `Application/Interfaces/ITrapService.cs` | From v0.4.1a |
| `TrapService` | `Application/Services/TrapService.cs` | From v0.4.1a |
| `Room.Traps` collection | `Domain/Entities/Room.cs` | From v0.4.1a |
| `DiceService` | `Application/Services/DiceService.cs` | Complete |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Complete |
| `StatusEffectService` | `Application/Services/StatusEffectService.cs` | Complete |
| `InteractiveObject` entity | `Domain/Entities/InteractiveObject.cs` | From v0.4.0a |
| `InteractionService` | `Application/Services/InteractionService.cs` | From v0.4.0a/b/c |
| Perception skill | `Configuration/skills.json` | Complete (uses Wits) |

### 1.3 Scope

**In Scope:**
- Trap detection via Perception skill checks (`search` command)
- Passive perception check on room entry
- Trap disarm via skill checks (`disarm` command)
- Failed disarm consequences (trigger or damage)
- Automatic trap triggering on movement (Step traps)
- Automatic trap triggering on object interaction (Open/Touch traps)
- `TrapEffect` value object for damage and status application
- Trap damage calculation using DiceService
- Status effect application via StatusEffectService
- Alert effects (monster awareness, noise)
- Trapped container integration with InteractiveObject
- `TrapDisarmResult` value object
- Saving throws to reduce/avoid trap damage
- Detection and disarm DC display for detected traps
- Configuration updates for trap effects

**Out of Scope:**
- Environmental hazards (v0.4.1c)
- Hazard zones with ongoing effects (v0.4.1c)
- Dice saves for hazard damage (v0.4.1c - different from trap saves)
- Trap creation by players (future)
- Trap respawning on room reset (future)

### 1.4 Design Goals

1. **Skill Integration**: Detection and disarm use existing SkillCheckService
2. **Automatic Triggers**: Traps trigger seamlessly on player actions
3. **Meaningful Choices**: Players can search, avoid, or attempt to disarm
4. **Risk/Reward**: Failed disarm has consequences
5. **Effect Variety**: Support damage, status effects, and alerts
6. **Container Integration**: Trapped chests work with existing container system
7. **Testability**: Clean separation for comprehensive unit testing

---

## 2. Data Model

### 2.1 TrapEffect Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapEffect.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the effect that occurs when a trap is triggered.
/// </summary>
public class TrapEffect
{
    /// <summary>
    /// Gets the damage dice expression (e.g., "2d6").
    /// </summary>
    public string? DamageDice { get; private set; }

    /// <summary>
    /// Gets the damage type (e.g., "piercing", "fire").
    /// </summary>
    public string? DamageType { get; private set; }

    /// <summary>
    /// Gets the status effects applied by this trap.
    /// </summary>
    public IReadOnlyList<string> StatusEffects { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the duration in turns for status effects.
    /// </summary>
    public int StatusDuration { get; private set; } = 3;

    /// <summary>
    /// Gets the save DC to reduce or avoid the effect.
    /// </summary>
    public int? SaveDC { get; private set; }

    /// <summary>
    /// Gets the attribute used for the saving throw.
    /// </summary>
    public string? SaveAttribute { get; private set; }

    /// <summary>
    /// Gets whether a successful save halves damage (true) or negates it (false).
    /// </summary>
    public bool SaveHalvesDamage { get; private set; } = true;

    /// <summary>
    /// Gets the custom message displayed when the trap triggers.
    /// </summary>
    public string? TriggerMessage { get; private set; }

    /// <summary>
    /// Gets whether this trap alerts nearby monsters.
    /// </summary>
    public bool AlertsMonsters { get; private set; }

    /// <summary>
    /// Gets the alert radius in rooms (0 = current room only).
    /// </summary>
    public int AlertRadius { get; private set; }

    /// <summary>
    /// Gets whether this effect deals damage.
    /// </summary>
    public bool DealsDamage => !string.IsNullOrEmpty(DamageDice);

    /// <summary>
    /// Gets whether this effect applies status effects.
    /// </summary>
    public bool AppliesStatus => StatusEffects.Count > 0;

    /// <summary>
    /// Gets whether this effect has a saving throw.
    /// </summary>
    public bool HasSave => SaveDC.HasValue && !string.IsNullOrEmpty(SaveAttribute);

    private TrapEffect() { }

    /// <summary>
    /// Creates a trap effect from a definition.
    /// </summary>
    /// <param name="definition">The effect definition.</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect FromDefinition(TrapEffectDefinition definition)
    {
        ArgumentNullException.ThrowIfNull(definition);

        return new TrapEffect
        {
            DamageDice = definition.DamageDice,
            DamageType = definition.DamageType,
            StatusEffects = definition.StatusEffects?.ToList() ?? new List<string>(),
            StatusDuration = definition.StatusDuration > 0 ? definition.StatusDuration : 3,
            SaveDC = definition.SaveDC,
            SaveAttribute = definition.SaveType,
            SaveHalvesDamage = definition.SaveHalvesDamage,
            TriggerMessage = definition.TriggerMessage,
            AlertsMonsters = definition.AlertsMonsters,
            AlertRadius = definition.AlertRadius
        };
    }

    /// <summary>
    /// Creates a damage-only trap effect.
    /// </summary>
    /// <param name="damageDice">The damage dice expression.</param>
    /// <param name="damageType">The damage type.</param>
    /// <param name="saveDC">Optional save DC.</param>
    /// <param name="saveAttribute">Optional save attribute.</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect Damage(
        string damageDice,
        string damageType,
        int? saveDC = null,
        string? saveAttribute = null) => new()
    {
        DamageDice = damageDice,
        DamageType = damageType,
        SaveDC = saveDC,
        SaveAttribute = saveAttribute
    };

    /// <summary>
    /// Creates a status-only trap effect.
    /// </summary>
    /// <param name="statusEffects">The status effects to apply.</param>
    /// <param name="duration">The duration in turns.</param>
    /// <param name="saveDC">Optional save DC.</param>
    /// <param name="saveAttribute">Optional save attribute.</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect Status(
        IEnumerable<string> statusEffects,
        int duration = 3,
        int? saveDC = null,
        string? saveAttribute = null) => new()
    {
        StatusEffects = statusEffects.ToList(),
        StatusDuration = duration,
        SaveDC = saveDC,
        SaveAttribute = saveAttribute
    };

    /// <summary>
    /// Creates an alert-only trap effect.
    /// </summary>
    /// <param name="message">The alert message.</param>
    /// <param name="alertRadius">The radius in rooms.</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect Alert(string message, int alertRadius = 0) => new()
    {
        TriggerMessage = message,
        AlertsMonsters = true,
        AlertRadius = alertRadius
    };

    /// <summary>
    /// Creates a combined damage and status effect.
    /// </summary>
    /// <param name="damageDice">The damage dice expression.</param>
    /// <param name="damageType">The damage type.</param>
    /// <param name="statusEffects">The status effects to apply.</param>
    /// <param name="saveDC">The save DC.</param>
    /// <param name="saveAttribute">The save attribute.</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect DamageAndStatus(
        string damageDice,
        string damageType,
        IEnumerable<string> statusEffects,
        int saveDC,
        string saveAttribute) => new()
    {
        DamageDice = damageDice,
        DamageType = damageType,
        StatusEffects = statusEffects.ToList(),
        SaveDC = saveDC,
        SaveAttribute = saveAttribute
    };
}
```

### 2.2 TrapEffectResult Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapEffectResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of applying a trap's effect to a target.
/// </summary>
public readonly record struct TrapEffectResult
{
    /// <summary>
    /// Gets the total damage dealt.
    /// </summary>
    public int DamageDealt { get; init; }

    /// <summary>
    /// Gets the damage type.
    /// </summary>
    public string? DamageType { get; init; }

    /// <summary>
    /// Gets whether a save was attempted.
    /// </summary>
    public bool SaveAttempted { get; init; }

    /// <summary>
    /// Gets whether the save was successful.
    /// </summary>
    public bool SaveSucceeded { get; init; }

    /// <summary>
    /// Gets the save roll total.
    /// </summary>
    public int? SaveRoll { get; init; }

    /// <summary>
    /// Gets the save DC.
    /// </summary>
    public int? SaveDC { get; init; }

    /// <summary>
    /// Gets the status effects applied.
    /// </summary>
    public IReadOnlyList<string> StatusEffectsApplied { get; init; }

    /// <summary>
    /// Gets whether monsters were alerted.
    /// </summary>
    public bool MonstersAlerted { get; init; }

    /// <summary>
    /// Gets the message to display.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the individual damage dice rolls.
    /// </summary>
    public IReadOnlyList<int> DamageRolls { get; init; }

    /// <summary>
    /// Creates a result for damage dealt.
    /// </summary>
    public static TrapEffectResult DamageResult(
        int damage,
        string damageType,
        IEnumerable<int> rolls,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null) => new()
    {
        DamageDealt = damage,
        DamageType = damageType,
        DamageRolls = rolls.ToList(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        StatusEffectsApplied = Array.Empty<string>(),
        MonstersAlerted = false,
        Message = message
    };

    /// <summary>
    /// Creates a result for status effects applied.
    /// </summary>
    public static TrapEffectResult StatusResult(
        IEnumerable<string> effects,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null) => new()
    {
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        StatusEffectsApplied = effects.ToList(),
        MonstersAlerted = false,
        Message = message
    };

    /// <summary>
    /// Creates a result for an alert effect.
    /// </summary>
    public static TrapEffectResult AlertResult(string message) => new()
    {
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = false,
        SaveSucceeded = false,
        StatusEffectsApplied = Array.Empty<string>(),
        MonstersAlerted = true,
        Message = message
    };

    /// <summary>
    /// Creates a combined result.
    /// </summary>
    public static TrapEffectResult Combined(
        int damage,
        string? damageType,
        IEnumerable<int> rolls,
        IEnumerable<string> statusEffects,
        bool monstersAlerted,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null) => new()
    {
        DamageDealt = damage,
        DamageType = damageType,
        DamageRolls = rolls.ToList(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        StatusEffectsApplied = statusEffects.ToList(),
        MonstersAlerted = monstersAlerted,
        Message = message
    };

    /// <summary>
    /// Creates a result where the save completely negated the effect.
    /// </summary>
    public static TrapEffectResult SavedCompletely(int saveRoll, int saveDC, string message) => new()
    {
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = true,
        SaveSucceeded = true,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        StatusEffectsApplied = Array.Empty<string>(),
        MonstersAlerted = false,
        Message = message
    };
}
```

### 2.3 TrapDisarmResult Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapDisarmResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of attempting to disarm a trap.
/// </summary>
public readonly record struct TrapDisarmResult
{
    /// <summary>
    /// Gets whether the disarm was successful.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the message to display.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the skill check roll total.
    /// </summary>
    public int RollTotal { get; init; }

    /// <summary>
    /// Gets the disarm DC.
    /// </summary>
    public int DisarmDC { get; init; }

    /// <summary>
    /// Gets the individual dice rolls.
    /// </summary>
    public IReadOnlyList<int> Rolls { get; init; }

    /// <summary>
    /// Gets the skill modifier applied.
    /// </summary>
    public int SkillModifier { get; init; }

    /// <summary>
    /// Gets whether failure triggered the trap.
    /// </summary>
    public bool TriggeredTrap { get; init; }

    /// <summary>
    /// Gets the trap effect result if the trap was triggered.
    /// </summary>
    public TrapEffectResult? TrapEffect { get; init; }

    /// <summary>
    /// Gets whether the trap can be retried.
    /// </summary>
    public bool CanRetry { get; init; }

    /// <summary>
    /// Creates a successful disarm result.
    /// </summary>
    public static TrapDisarmResult Succeeded(
        int rollTotal,
        int disarmDC,
        IEnumerable<int> rolls,
        int modifier,
        string message) => new()
    {
        Success = true,
        Message = message,
        RollTotal = rollTotal,
        DisarmDC = disarmDC,
        Rolls = rolls.ToList(),
        SkillModifier = modifier,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = false
    };

    /// <summary>
    /// Creates a failed disarm result that didn't trigger the trap.
    /// </summary>
    public static TrapDisarmResult FailedSafely(
        int rollTotal,
        int disarmDC,
        IEnumerable<int> rolls,
        int modifier,
        string message) => new()
    {
        Success = false,
        Message = message,
        RollTotal = rollTotal,
        DisarmDC = disarmDC,
        Rolls = rolls.ToList(),
        SkillModifier = modifier,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = true
    };

    /// <summary>
    /// Creates a failed disarm result that triggered the trap.
    /// </summary>
    public static TrapDisarmResult FailedAndTriggered(
        int rollTotal,
        int disarmDC,
        IEnumerable<int> rolls,
        int modifier,
        TrapEffectResult effect,
        string message) => new()
    {
        Success = false,
        Message = message,
        RollTotal = rollTotal,
        DisarmDC = disarmDC,
        Rolls = rolls.ToList(),
        SkillModifier = modifier,
        TriggeredTrap = true,
        TrapEffect = effect,
        CanRetry = false
    };

    /// <summary>
    /// Creates a result for when the trap cannot be disarmed.
    /// </summary>
    public static TrapDisarmResult CannotDisarm(string trapName) => new()
    {
        Success = false,
        Message = $"The {trapName} cannot be disarmed.",
        RollTotal = 0,
        DisarmDC = 0,
        Rolls = Array.Empty<int>(),
        SkillModifier = 0,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = false
    };

    /// <summary>
    /// Creates a result for when the trap is not detected.
    /// </summary>
    public static TrapDisarmResult NotDetected() => new()
    {
        Success = false,
        Message = "You don't see any trap to disarm here.",
        RollTotal = 0,
        DisarmDC = 0,
        Rolls = Array.Empty<int>(),
        SkillModifier = 0,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = false
    };

    /// <summary>
    /// Creates a result for when the trap is already disarmed.
    /// </summary>
    public static TrapDisarmResult AlreadyDisarmed(string trapName) => new()
    {
        Success = false,
        Message = $"The {trapName} has already been disarmed.",
        RollTotal = 0,
        DisarmDC = 0,
        Rolls = Array.Empty<int>(),
        SkillModifier = 0,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = false
    };
}
```

### 2.4 TrapEffectDefinition Updates

**File:** `src/Core/RuneAndRust.Domain/Definitions/TrapDefinition.cs`

Update the placeholder TrapEffectDefinition:

```csharp
/// <summary>
/// Configuration for trap effects.
/// </summary>
public class TrapEffectDefinition
{
    /// <summary>
    /// Gets or sets the damage dice expression (e.g., "2d6").
    /// </summary>
    public string? DamageDice { get; set; }

    /// <summary>
    /// Gets or sets the damage type (e.g., "piercing", "fire").
    /// </summary>
    public string? DamageType { get; set; }

    /// <summary>
    /// Gets or sets status effects applied by the trap.
    /// </summary>
    public List<string> StatusEffects { get; set; } = new();

    /// <summary>
    /// Gets or sets the duration of status effects in turns.
    /// </summary>
    public int StatusDuration { get; set; } = 3;

    /// <summary>
    /// Gets or sets the save DC to reduce/avoid damage.
    /// </summary>
    public int? SaveDC { get; set; }

    /// <summary>
    /// Gets or sets the save type (attribute name, e.g., "Agility", "Fortitude").
    /// </summary>
    public string? SaveType { get; set; }

    /// <summary>
    /// Gets or sets whether a successful save halves damage (true) or negates it (false).
    /// </summary>
    public bool SaveHalvesDamage { get; set; } = true;

    /// <summary>
    /// Gets or sets a message displayed when the trap triggers.
    /// </summary>
    public string? TriggerMessage { get; set; }

    /// <summary>
    /// Gets or sets whether this trap alerts nearby monsters.
    /// </summary>
    public bool AlertsMonsters { get; set; }

    /// <summary>
    /// Gets or sets the alert radius in rooms (0 = current room only).
    /// </summary>
    public int AlertRadius { get; set; }
}
```

### 2.5 Trap Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Trap.cs`

Add the following property and update FromDefinition:

```csharp
// Add property:

/// <summary>
/// Gets the effect that occurs when this trap triggers.
/// </summary>
public TrapEffect? Effect { get; private set; }

/// <summary>
/// Gets whether this trap has an effect configured.
/// </summary>
public bool HasEffect => Effect != null;

// Add method:

/// <summary>
/// Sets the trap effect.
/// </summary>
/// <param name="effect">The effect to set.</param>
public void SetEffect(TrapEffect effect)
{
    Effect = effect;
}

// Update FromDefinition to include effect:

public static Trap FromDefinition(TrapDefinition definition)
{
    ArgumentNullException.ThrowIfNull(definition);

    var trap = new Trap
    {
        Id = Guid.NewGuid(),
        DefinitionId = definition.Id,
        Name = definition.Name,
        Description = definition.Description,
        TriggerType = definition.TriggerType,
        DetectionDC = definition.DetectionDC,
        DisarmDC = definition.DisarmDC,
        CanBeDisarmed = definition.CanBeDisarmed,
        Resets = definition.Resets,
        ResetDelay = definition.Resets ? definition.ResetDelay : -1,
        AttachedObjectId = definition.AttachedObjectId,
        Keywords = definition.Keywords.ToList()
    };

    // Set effect if configured
    if (definition.Effect != null)
    {
        trap.Effect = TrapEffect.FromDefinition(definition.Effect);
    }

    return trap;
}
```

### 2.6 InteractiveObject Updates for Trapped Containers

**File:** `src/Core/RuneAndRust.Domain/Entities/InteractiveObject.cs`

Add trap attachment support:

```csharp
// Add property:

/// <summary>
/// Gets the ID of a trap attached to this object (for trapped containers/doors).
/// </summary>
public string? AttachedTrapId { get; private set; }

/// <summary>
/// Gets whether this object has an attached trap.
/// </summary>
public bool HasAttachedTrap => !string.IsNullOrEmpty(AttachedTrapId);

// Add method:

/// <summary>
/// Attaches a trap to this object.
/// </summary>
/// <param name="trapDefinitionId">The trap definition ID to attach.</param>
public void AttachTrap(string trapDefinitionId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(trapDefinitionId);
    AttachedTrapId = trapDefinitionId;
}

/// <summary>
/// Removes any attached trap from this object.
/// </summary>
public void RemoveAttachedTrap()
{
    AttachedTrapId = null;
}
```

---

## 3. Services

### 3.1 ITrapService Interface Updates

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITrapService.cs`

Add new methods:

```csharp
// Add to interface:

/// <summary>
/// Attempts to detect hidden traps in a room using a Perception check.
/// </summary>
/// <param name="room">The room to search.</param>
/// <param name="player">The player searching.</param>
/// <returns>The detection result.</returns>
TrapDetectionResult SearchForTraps(Room room, Player player);

/// <summary>
/// Performs a passive perception check when entering a room.
/// </summary>
/// <param name="room">The room being entered.</param>
/// <param name="player">The player entering.</param>
/// <returns>The detection result (only includes automatically detected traps).</returns>
TrapDetectionResult PassivePerceptionCheck(Room room, Player player);

/// <summary>
/// Attempts to disarm a detected trap.
/// </summary>
/// <param name="trap">The trap to disarm.</param>
/// <param name="player">The player attempting to disarm.</param>
/// <returns>The disarm result.</returns>
TrapDisarmResult AttemptDisarm(Trap trap, Player player);

/// <summary>
/// Applies a trap's effect to a target.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <param name="player">The player affected.</param>
/// <returns>The effect result.</returns>
TrapEffectResult ApplyTrapEffect(Trap trap, Player player);

/// <summary>
/// Checks for and triggers traps when a player enters a room.
/// </summary>
/// <param name="room">The room being entered.</param>
/// <param name="player">The player entering.</param>
/// <returns>The trigger result if a trap was triggered, null otherwise.</returns>
(TrapTriggerResult Trigger, TrapEffectResult? Effect)? CheckEntryTraps(Room room, Player player);

/// <summary>
/// Checks for and triggers traps when opening an object.
/// </summary>
/// <param name="room">The room containing the object.</param>
/// <param name="objectId">The object being opened.</param>
/// <param name="player">The player opening the object.</param>
/// <returns>The trigger result if a trap was triggered, null otherwise.</returns>
(TrapTriggerResult Trigger, TrapEffectResult? Effect)? CheckOpenTraps(Room room, string objectId, Player player);

/// <summary>
/// Gets the passive perception score for a player.
/// </summary>
/// <param name="player">The player.</param>
/// <returns>The passive perception score.</returns>
int GetPassivePerception(Player player);
```

### 3.2 TrapService Implementation Updates

**File:** `src/Core/RuneAndRust.Application/Services/TrapService.cs`

Add new implementations:

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using System.Text;

/// <summary>
/// Service for managing traps and their interactions.
/// </summary>
public class TrapService : ITrapService
{
    private readonly ILogger<TrapService> _logger;
    private readonly IDiceService _diceService;
    private readonly ISkillCheckService _skillCheckService;
    private readonly IStatusEffectService _statusEffectService;

    // Passive perception is 10 + Wits modifier
    private const int PassivePerceptionBase = 10;

    // Threshold below DC where failed disarm triggers trap (5 or more below)
    private const int DisarmTriggerThreshold = 5;

    /// <summary>
    /// Creates a new trap service.
    /// </summary>
    public TrapService(
        ILogger<TrapService> logger,
        IDiceService diceService,
        ISkillCheckService skillCheckService,
        IStatusEffectService statusEffectService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _skillCheckService = skillCheckService ?? throw new ArgumentNullException(nameof(skillCheckService));
        _statusEffectService = statusEffectService ?? throw new ArgumentNullException(nameof(statusEffectService));
    }

    /// <inheritdoc />
    public TrapDetectionResult SearchForTraps(Room room, Player player)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentNullException.ThrowIfNull(player);

        var hiddenTraps = room.GetHiddenTraps().ToList();
        if (!hiddenTraps.Any())
        {
            return TrapDetectionResult.NoHiddenTraps();
        }

        // Perform Perception skill check
        var checkResult = _skillCheckService.PerformCheck(
            player,
            "Perception",
            0); // No fixed DC - we compare against each trap

        var detectedNames = new List<string>();
        var remainingHidden = 0;

        foreach (var trap in hiddenTraps)
        {
            if (checkResult.Total >= trap.DetectionDC)
            {
                trap.Detect();
                detectedNames.Add(trap.Name);
                _logger.LogInformation(
                    "Player detected {TrapName} (rolled {Roll} vs DC {DC})",
                    trap.Name, checkResult.Total, trap.DetectionDC);
            }
            else
            {
                remainingHidden++;
                _logger.LogDebug(
                    "Player failed to detect {TrapName} (rolled {Roll} vs DC {DC})",
                    trap.Name, checkResult.Total, trap.DetectionDC);
            }
        }

        if (detectedNames.Any())
        {
            var message = BuildDetectionMessage(checkResult, detectedNames);
            return TrapDetectionResult.Detected(detectedNames, message, remainingHidden);
        }

        var failMessage = $"Perception Check: [{string.Join(",", checkResult.Rolls)}] + {checkResult.Modifier} = {checkResult.Total}\n" +
                          "You search carefully but don't find any traps.";
        return TrapDetectionResult.NoneDetected(failMessage, remainingHidden);
    }

    /// <inheritdoc />
    public TrapDetectionResult PassivePerceptionCheck(Room room, Player player)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentNullException.ThrowIfNull(player);

        var hiddenTraps = room.GetHiddenTraps().ToList();
        if (!hiddenTraps.Any())
        {
            return TrapDetectionResult.NoHiddenTraps();
        }

        var passivePerception = GetPassivePerception(player);
        var detectedNames = new List<string>();

        foreach (var trap in hiddenTraps)
        {
            // Passive perception only detects traps with DC <= passive score
            if (passivePerception >= trap.DetectionDC)
            {
                trap.Detect();
                detectedNames.Add(trap.Name);
                _logger.LogInformation(
                    "Passive perception detected {TrapName} (passive {Passive} vs DC {DC})",
                    trap.Name, passivePerception, trap.DetectionDC);
            }
        }

        if (detectedNames.Any())
        {
            var message = $"Your keen senses notice danger!\nYou spot: {string.Join(", ", detectedNames)}";
            return TrapDetectionResult.Detected(detectedNames, message, hiddenTraps.Count - detectedNames.Count);
        }

        // Don't tell player about hidden traps they missed passively
        return TrapDetectionResult.NoneDetected(string.Empty, hiddenTraps.Count);
    }

    /// <inheritdoc />
    public int GetPassivePerception(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        // Passive Perception = 10 + Wits modifier + any perception bonuses
        var witsModifier = player.GetAttributeModifier("Wits");
        var perceptionBonus = player.GetSkillBonus("Perception");

        return PassivePerceptionBase + witsModifier + perceptionBonus;
    }

    /// <inheritdoc />
    public TrapDisarmResult AttemptDisarm(Trap trap, Player player)
    {
        ArgumentNullException.ThrowIfNull(trap);
        ArgumentNullException.ThrowIfNull(player);

        if (trap.State != TrapState.Detected)
        {
            if (trap.State == TrapState.Hidden)
                return TrapDisarmResult.NotDetected();
            if (trap.State == TrapState.Disarmed)
                return TrapDisarmResult.AlreadyDisarmed(trap.Name);
            if (trap.State == TrapState.Triggered)
                return TrapDisarmResult.AlreadyDisarmed(trap.Name) with
                {
                    Message = $"The {trap.Name} has already been triggered."
                };
        }

        if (!trap.CanBeDisarmed)
        {
            return TrapDisarmResult.CannotDisarm(trap.Name);
        }

        // Perform skill check - use Finesse-based "Disable Device" or similar
        var checkResult = _skillCheckService.PerformCheck(
            player,
            "DisableDevice", // Or "Lockpicking" - uses Finesse
            trap.DisarmDC);

        var rollInfo = $"[{string.Join(",", checkResult.Rolls)}] + {checkResult.Modifier} = {checkResult.Total} vs DC {trap.DisarmDC}";

        if (checkResult.Success)
        {
            trap.Disarm();
            _logger.LogInformation(
                "Player successfully disarmed {TrapName} ({RollInfo})",
                trap.Name, rollInfo);

            return TrapDisarmResult.Succeeded(
                checkResult.Total,
                trap.DisarmDC,
                checkResult.Rolls,
                checkResult.Modifier,
                $"Disarm Check: {rollInfo}\n\nYou carefully disarm the {trap.Name}.");
        }

        // Failed - check if we triggered the trap
        var failedBy = trap.DisarmDC - checkResult.Total;

        if (failedBy >= DisarmTriggerThreshold)
        {
            // Critically failed - trigger the trap
            trap.Trigger();
            var effectResult = ApplyTrapEffectInternal(trap, player);

            _logger.LogInformation(
                "Player critically failed disarm on {TrapName}, triggering it ({RollInfo})",
                trap.Name, rollInfo);

            return TrapDisarmResult.FailedAndTriggered(
                checkResult.Total,
                trap.DisarmDC,
                checkResult.Rolls,
                checkResult.Modifier,
                effectResult,
                $"Disarm Check: {rollInfo}\n\nYour hand slips and you trigger the {trap.Name}!\n\n{effectResult.Message}");
        }

        // Failed but didn't trigger
        _logger.LogInformation(
            "Player failed to disarm {TrapName} but didn't trigger it ({RollInfo})",
            trap.Name, rollInfo);

        return TrapDisarmResult.FailedSafely(
            checkResult.Total,
            trap.DisarmDC,
            checkResult.Rolls,
            checkResult.Modifier,
            $"Disarm Check: {rollInfo}\n\nYou fail to disarm the {trap.Name}, but manage to avoid triggering it.");
    }

    /// <inheritdoc />
    public TrapEffectResult ApplyTrapEffect(Trap trap, Player player)
    {
        ArgumentNullException.ThrowIfNull(trap);
        ArgumentNullException.ThrowIfNull(player);

        return ApplyTrapEffectInternal(trap, player);
    }

    private TrapEffectResult ApplyTrapEffectInternal(Trap trap, Player player)
    {
        if (trap.Effect == null)
        {
            // No effect configured - just a message
            return TrapEffectResult.AlertResult($"The {trap.Name} activates!");
        }

        var effect = trap.Effect;
        var messageBuilder = new StringBuilder();
        var totalDamage = 0;
        var damageRolls = new List<int>();
        var appliedEffects = new List<string>();
        var saveAttempted = false;
        var saveSucceeded = false;
        int? saveRoll = null;

        // Add trigger message
        if (!string.IsNullOrEmpty(effect.TriggerMessage))
        {
            messageBuilder.AppendLine(effect.TriggerMessage);
        }
        else
        {
            messageBuilder.AppendLine($"The {trap.Name} activates!");
        }

        // Handle saving throw
        if (effect.HasSave)
        {
            saveAttempted = true;
            var saveResult = PerformSavingThrow(player, effect.SaveAttribute!, effect.SaveDC!.Value);
            saveRoll = saveResult.Total;
            saveSucceeded = saveResult.Success;

            messageBuilder.AppendLine();
            messageBuilder.AppendLine($"Saving Throw ({effect.SaveAttribute}): [{string.Join(",", saveResult.Rolls)}] + {saveResult.Modifier} = {saveResult.Total} vs DC {effect.SaveDC}");

            if (saveSucceeded)
            {
                if (effect.SaveHalvesDamage && effect.DealsDamage)
                {
                    messageBuilder.AppendLine("Save successful! Damage halved.");
                }
                else
                {
                    messageBuilder.AppendLine("Save successful! You avoid the effect.");
                    return TrapEffectResult.SavedCompletely(saveResult.Total, effect.SaveDC!.Value, messageBuilder.ToString().TrimEnd());
                }
            }
            else
            {
                messageBuilder.AppendLine("Save failed!");
            }
        }

        // Apply damage
        if (effect.DealsDamage)
        {
            var damageResult = _diceService.Roll(effect.DamageDice!);
            damageRolls.AddRange(damageResult.Rolls);
            totalDamage = damageResult.Total;

            // Halve damage on successful save
            if (saveSucceeded && effect.SaveHalvesDamage)
            {
                totalDamage /= 2;
            }

            // Apply damage to player
            player.TakeDamage(totalDamage, effect.DamageType);

            messageBuilder.AppendLine();
            messageBuilder.AppendLine($"Damage: [{string.Join(",", damageResult.Rolls)}] = {damageResult.Total}{(saveSucceeded ? " / 2 = " + totalDamage : "")} {effect.DamageType} damage");

            _logger.LogInformation(
                "Trap {TrapName} dealt {Damage} {DamageType} damage to player",
                trap.Name, totalDamage, effect.DamageType);
        }

        // Apply status effects (only if save failed or no save)
        if (effect.AppliesStatus && !saveSucceeded)
        {
            foreach (var statusEffect in effect.StatusEffects)
            {
                _statusEffectService.ApplyEffect(player, statusEffect, effect.StatusDuration);
                appliedEffects.Add(statusEffect);
            }

            if (appliedEffects.Any())
            {
                messageBuilder.AppendLine();
                messageBuilder.AppendLine($"You are afflicted with: {string.Join(", ", appliedEffects)}");
            }
        }

        // Handle monster alert
        if (effect.AlertsMonsters)
        {
            messageBuilder.AppendLine();
            messageBuilder.AppendLine("The noise alerts nearby creatures!");
        }

        return TrapEffectResult.Combined(
            totalDamage,
            effect.DamageType,
            damageRolls,
            appliedEffects,
            effect.AlertsMonsters,
            messageBuilder.ToString().TrimEnd(),
            saveAttempted,
            saveSucceeded,
            saveRoll,
            effect.SaveDC);
    }

    /// <inheritdoc />
    public (TrapTriggerResult Trigger, TrapEffectResult? Effect)? CheckEntryTraps(Room room, Player player)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentNullException.ThrowIfNull(player);

        // Check for Step and Proximity traps
        var stepTraps = room.GetTrapsByTriggerType(TriggerType.Step)
            .Concat(room.GetTrapsByTriggerType(TriggerType.Proximity))
            .Where(t => t.IsActive)
            .ToList();

        foreach (var trap in stepTraps)
        {
            // Hidden traps trigger automatically
            // Detected traps can be avoided (player knows about them)
            if (trap.State == TrapState.Hidden)
            {
                var triggerResult = TriggerTrap(trap);
                var effectResult = ApplyTrapEffectInternal(trap, player);

                return (triggerResult, effectResult);
            }
        }

        return null;
    }

    /// <inheritdoc />
    public (TrapTriggerResult Trigger, TrapEffectResult? Effect)? CheckOpenTraps(Room room, string objectId, Player player)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentException.ThrowIfNullOrWhiteSpace(objectId);
        ArgumentNullException.ThrowIfNull(player);

        var trap = room.GetTrapAttachedTo(objectId);

        if (trap != null && trap.IsActive)
        {
            // Detected traps still trigger on open unless disarmed
            var triggerResult = TriggerTrap(trap);
            var effectResult = ApplyTrapEffectInternal(trap, player);

            return (triggerResult, effectResult);
        }

        return null;
    }

    private SkillCheckResult PerformSavingThrow(Player player, string attribute, int dc)
    {
        // Saving throw is d20 + attribute modifier vs DC
        var modifier = player.GetAttributeModifier(attribute);
        var roll = _diceService.Roll("1d20");

        return new SkillCheckResult
        {
            Total = roll.Total + modifier,
            Rolls = roll.Rolls.ToList(),
            Modifier = modifier,
            DC = dc,
            Success = roll.Total + modifier >= dc
        };
    }

    private string BuildDetectionMessage(SkillCheckResult checkResult, List<string> detectedNames)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"Perception Check: [{string.Join(",", checkResult.Rolls)}] + {checkResult.Modifier} = {checkResult.Total}");
        sb.AppendLine();
        sb.AppendLine("You spot danger!");

        foreach (var name in detectedNames)
        {
            sb.AppendLine($"  - {name}");
        }

        return sb.ToString().TrimEnd();
    }

    // ... existing methods from v0.4.1a remain unchanged ...
}
```

### 3.3 IInteractionService Updates for Trapped Containers

**File:** `src/Core/RuneAndRust.Application/Interfaces/IInteractionService.cs`

Add trap checking to open:

```csharp
// Update Open method signature to include trap service:

/// <summary>
/// Opens an interactive object, checking for traps.
/// </summary>
/// <param name="obj">The object to open.</param>
/// <param name="room">The room containing the object.</param>
/// <param name="player">The player opening the object.</param>
/// <param name="trapService">The trap service for trap checking.</param>
/// <returns>The result of the interaction, including any trap effects.</returns>
InteractionResult Open(InteractiveObject obj, Room room, Player player, ITrapService trapService);
```

### 3.4 InteractionService Updates for Trapped Containers

**File:** `src/Core/RuneAndRust.Application/Services/InteractionService.cs`

Update the Open method:

```csharp
/// <inheritdoc />
public InteractionResult Open(InteractiveObject obj, Room room, Player player, ITrapService trapService)
{
    ArgumentNullException.ThrowIfNull(obj);
    ArgumentNullException.ThrowIfNull(room);
    ArgumentNullException.ThrowIfNull(player);
    ArgumentNullException.ThrowIfNull(trapService);

    if (obj.State == ObjectState.Open)
    {
        return InteractionResult.Failed(
            InteractionType.Open,
            $"The {obj.Name} is already open.");
    }

    if (obj.State == ObjectState.Locked)
    {
        return InteractionResult.Failed(
            InteractionType.Open,
            $"The {obj.Name} is locked.",
            "Object is locked");
    }

    // Check for attached trap before opening
    if (obj.HasAttachedTrap)
    {
        var trapResult = trapService.CheckOpenTraps(room, obj.DefinitionId, player);
        if (trapResult != null)
        {
            // Trap triggered - open the object but include trap effect in result
            obj.TrySetState(ObjectState.Open);

            var openMessage = GetOpenMessage(obj);
            var combinedMessage = $"{trapResult.Value.Trigger.Message}\n\n{trapResult.Value.Effect?.Message}\n\n{openMessage}";

            return InteractionResult.Succeeded(
                InteractionType.Open,
                combinedMessage,
                ObjectState.Open,
                stateChanged: true);
        }
    }

    if (!obj.TrySetState(ObjectState.Open))
    {
        return InteractionResult.Failed(
            InteractionType.Open,
            $"The {obj.Name} cannot be opened.",
            "State change not allowed");
    }

    _logger.LogInformation("Opened {ObjectName}", obj.Name);

    var message = GetOpenMessage(obj);
    return InteractionResult.Succeeded(
        InteractionType.Open,
        message,
        ObjectState.Open,
        stateChanged: true);
}
```

---

## 4. Command Integration

### 4.1 Search Command (NEW)

```
> search
> search for traps
```

**Command Processing:**

```csharp
private string ProcessSearchCommand(string[] args, Room currentRoom, Player player)
{
    // Search for traps in the room
    var result = _trapService.SearchForTraps(currentRoom, player);

    return result.Message;
}
```

### 4.2 Disarm Command (NEW)

```
> disarm <trap>
> disarm trap
```

**Command Processing:**

```csharp
private string ProcessDisarmCommand(string[] args, Room currentRoom, Player player)
{
    if (args.Length == 0)
    {
        return "Disarm what? Try 'disarm <trap>'.";
    }

    var keyword = string.Join(" ", args);
    var trap = _trapService.FindTrap(currentRoom, keyword);

    if (trap == null)
    {
        return $"You don't see any '{keyword}' here.";
    }

    var result = _trapService.AttemptDisarm(trap, player);

    // If trap was triggered and dealt damage, update player state
    if (result.TriggeredTrap && result.TrapEffect.HasValue)
    {
        // Damage already applied in service
        // Check if player died
        if (player.IsDead)
        {
            return result.Message + "\n\nYou have died!";
        }
    }

    return result.Message;
}
```

### 4.3 Room Entry Integration

Update movement logic to check for traps:

```csharp
public MoveResult TryMove(Direction direction, Room currentRoom, Room newRoom, Player player)
{
    // ... existing movement validation ...

    // Check for entry traps in new room
    var trapResult = _trapService.CheckEntryTraps(newRoom, player);

    if (trapResult != null)
    {
        var (trigger, effect) = trapResult.Value;

        // Player triggered a trap on entry
        var message = $"You enter the {newRoom.Name}.\n\n{trigger.Message}";

        if (effect != null)
        {
            message += $"\n\n{effect.Value.Message}";
        }

        // Check if player died
        if (player.IsDead)
        {
            message += "\n\nYou have died!";
        }

        return MoveResult.SucceededWithTrap(newRoom, message);
    }

    // Also run passive perception for hidden traps
    var detectionResult = _trapService.PassivePerceptionCheck(newRoom, player);

    if (detectionResult.DetectedAny)
    {
        return MoveResult.SucceededWithDetection(newRoom, detectionResult.Message);
    }

    return MoveResult.Succeeded(newRoom);
}
```

### 4.4 Examine Trap Updates

Update examine to show detection and disarm DCs for detected traps:

```csharp
/// <inheritdoc />
public string ExamineTrap(Trap trap)
{
    ArgumentNullException.ThrowIfNull(trap);

    if (!trap.IsVisible)
    {
        return "You don't see any trap there.";
    }

    var sb = new StringBuilder();
    sb.AppendLine(trap.Name);
    sb.AppendLine(trap.Description);
    sb.AppendLine();
    sb.AppendLine($"Status: {trap.GetStateDescription()}");
    sb.AppendLine($"Trigger: {GetTriggerTypeDescription(trap.TriggerType)}");

    if (trap.State == TrapState.Detected)
    {
        sb.AppendLine();
        sb.AppendLine($"Detection DC: {trap.DetectionDC}");
        sb.AppendLine($"Disarm DC: {trap.DisarmDC}");

        if (trap.CanBeDisarmed)
        {
            sb.AppendLine("This trap can be disarmed with the 'disarm' command.");
        }
        else
        {
            sb.AppendLine("This trap cannot be disarmed - it can only be avoided.");
        }
    }

    if (trap.Effect != null)
    {
        sb.AppendLine();
        if (trap.Effect.DealsDamage)
        {
            sb.AppendLine($"Damage: {trap.Effect.DamageDice} {trap.Effect.DamageType}");
        }
        if (trap.Effect.AppliesStatus)
        {
            sb.AppendLine($"Effects: {string.Join(", ", trap.Effect.StatusEffects)}");
        }
        if (trap.Effect.HasSave)
        {
            sb.AppendLine($"Save: {trap.Effect.SaveAttribute} DC {trap.Effect.SaveDC}");
        }
    }

    if (trap.IsPendingReset)
    {
        sb.AppendLine();
        sb.AppendLine($"The trap is resetting ({trap.TurnsUntilReset} turns remaining).");
    }

    _logger.LogDebug("Examined trap {TrapName}", trap.Name);

    return sb.ToString().TrimEnd();
}
```

---

## 5. Configuration Updates

### 5.1 Updated Trap Configuration Schema

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/schemas/traps.schema.json`

Update the trapEffect definition:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Traps Configuration",
  "description": "Configuration for traps in the game world",
  "type": "object",
  "properties": {
    "traps": {
      "type": "array",
      "description": "List of trap definitions",
      "items": {
        "$ref": "#/definitions/trapDefinition"
      }
    }
  },
  "definitions": {
    "trapDefinition": {
      "type": "object",
      "required": ["id", "name", "triggerType"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for this trap definition"
        },
        "name": {
          "type": "string",
          "description": "Display name of the trap"
        },
        "description": {
          "type": "string",
          "description": "Description shown when examining the trap"
        },
        "triggerType": {
          "type": "string",
          "description": "How the trap is triggered",
          "enum": ["Step", "Touch", "Open", "Proximity", "Tripwire"]
        },
        "detectionDC": {
          "type": "integer",
          "description": "Difficulty class to detect the trap",
          "minimum": 1,
          "default": 10
        },
        "disarmDC": {
          "type": "integer",
          "description": "Difficulty class to disarm the trap",
          "minimum": 1,
          "default": 12
        },
        "canBeDisarmed": {
          "type": "boolean",
          "description": "Whether the trap can be disarmed",
          "default": true
        },
        "resets": {
          "type": "boolean",
          "description": "Whether the trap resets after triggering",
          "default": false
        },
        "resetDelay": {
          "type": "integer",
          "description": "Turns until the trap resets",
          "minimum": 1,
          "default": 3
        },
        "attachedObjectId": {
          "type": "string",
          "description": "ID of object this trap is attached to (for Open triggers)"
        },
        "keywords": {
          "type": "array",
          "description": "Keywords for referencing the trap",
          "items": {
            "type": "string"
          }
        },
        "effect": {
          "$ref": "#/definitions/trapEffect"
        }
      }
    },
    "trapEffect": {
      "type": "object",
      "description": "Effect configuration for the trap",
      "properties": {
        "damageDice": {
          "type": "string",
          "description": "Damage dice expression (e.g., '2d6')"
        },
        "damageType": {
          "type": "string",
          "description": "Type of damage (e.g., 'piercing', 'fire')"
        },
        "statusEffects": {
          "type": "array",
          "description": "Status effects applied by the trap",
          "items": {
            "type": "string"
          }
        },
        "statusDuration": {
          "type": "integer",
          "description": "Duration of status effects in turns",
          "minimum": 1,
          "default": 3
        },
        "saveDC": {
          "type": "integer",
          "description": "Save DC to reduce/avoid damage",
          "minimum": 1
        },
        "saveType": {
          "type": "string",
          "description": "Attribute used for saving throw (e.g., 'Agility', 'Fortitude')"
        },
        "saveHalvesDamage": {
          "type": "boolean",
          "description": "Whether successful save halves damage (true) or negates it (false)",
          "default": true
        },
        "triggerMessage": {
          "type": "string",
          "description": "Custom message when trap triggers"
        },
        "alertsMonsters": {
          "type": "boolean",
          "description": "Whether this trap alerts nearby monsters",
          "default": false
        },
        "alertRadius": {
          "type": "integer",
          "description": "Alert radius in rooms (0 = current room only)",
          "minimum": 0,
          "default": 0
        }
      }
    }
  }
}
```

### 5.2 Interactive Objects Schema Update for Trapped Containers

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/schemas/interactive-objects.schema.json`

Add trap attachment property:

```json
{
  "attachedTrapId": {
    "type": "string",
    "description": "ID of trap attached to this object (triggers on open)"
  }
}
```

### 5.3 Sample Trapped Container Configuration

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/interactive-objects.json`

Add trapped container definitions:

```json
{
  "id": "trapped-chest",
  "name": "Suspicious Chest",
  "objectType": "Chest",
  "defaultState": "Closed",
  "allowedInteractions": ["Open", "Close", "Examine", "Search", "Take", "Put"],
  "isContainer": true,
  "containerCapacity": 10,
  "keywords": ["chest", "suspicious chest", "trapped chest"],
  "attachedTrapId": "chest-needle-trap"
},
{
  "id": "trapped-door",
  "name": "Warded Door",
  "objectType": "Door",
  "defaultState": "Closed",
  "allowedInteractions": ["Open", "Close", "Examine"],
  "blocksPassage": true,
  "blockedDirection": "North",
  "keywords": ["door", "warded door"],
  "attachedTrapId": "touch-shock"
}
```

---

## 6. User Experience

### 6.1 Searching for Traps

```
> search

Perception Check: [14, 8] + 3 = 17

You spot danger!
  - Dart Trap
  - Pit Trap
```

### 6.2 Examining a Detected Trap

```
> examine dart trap

Dart Trap
A pressure plate connected to a hidden dart launcher in the wall.
Stepping on it will trigger a volley of poisoned darts.

Status: detected
Trigger: Pressure plate - triggers when stepped on

Detection DC: 12
Disarm DC: 14
This trap can be disarmed with the 'disarm' command.

Damage: 2d6 piercing
Effects: poisoned
Save: Agility DC 12
```

### 6.3 Successful Disarm

```
> disarm dart trap

Disarm Check: [15, 12] + 4 = 19 vs DC 14

You carefully disarm the Dart Trap.
```

### 6.4 Failed Disarm (Safe)

```
> disarm dart trap

Disarm Check: [6, 4] + 4 = 10 vs DC 14

You fail to disarm the Dart Trap, but manage to avoid triggering it.
```

### 6.5 Failed Disarm (Triggered)

```
> disarm dart trap

Disarm Check: [3, 2] + 4 = 7 vs DC 14

Your hand slips and you trigger the Dart Trap!

Darts shoot from the wall!

Saving Throw (Agility): [11] + 2 = 13 vs DC 12
Save successful! Damage halved.

Damage: [4, 3] = 7 / 2 = 3 piercing damage

You are afflicted with: poisoned
```

### 6.6 Triggering a Hidden Trap on Entry

```
> north

You enter the Ancient Vault.

*CLICK* You step on the Dart Trap!

Darts shoot from the wall!

Saving Throw (Agility): [8] + 2 = 10 vs DC 12
Save failed!

Damage: [5, 4] = 9 piercing damage

You are afflicted with: poisoned

---

Ancient Vault
Dust-covered stone walls surround a chamber that hasn't been disturbed for centuries.

You notice the following dangers:
  Dart Trap [TRIGGERED - resetting]

Exits: south
```

### 6.7 Opening a Trapped Container

```
> open chest

Opening triggers the Needle Trap!

A needle pricks your finger as you open the chest!

Saving Throw (Fortitude): [6] + 1 = 7 vs DC 10
Save failed!

Damage: [3] = 3 piercing damage

You are afflicted with: poisoned

You lift the lid of the Suspicious Chest.

Inside you find:
  - Gold Ring
  - 25 gold
```

### 6.8 Passive Detection on Room Entry

```
> east

You enter the Trapped Corridor.

Your keen senses notice danger!
You spot: Tripwire Alarm

---

Trapped Corridor
A narrow passage with suspicious shadows along the walls.

You notice the following dangers:
  Tripwire Alarm [DETECTED]

Exits: west, east
```

---

## 7. Acceptance Criteria

### 7.1 Functional Requirements

- [ ] `search` command performs Perception check against hidden trap DCs
- [ ] Successful search reveals traps with DC <= roll total
- [ ] Passive perception check runs on room entry
- [ ] Passive perception only detects traps with DC <= passive score
- [ ] `disarm` command performs skill check against disarm DC
- [ ] Successful disarm transitions trap to Disarmed state
- [ ] Failed disarm by 5+ triggers the trap
- [ ] Failed disarm by less than 5 allows retry
- [ ] Step/Proximity traps trigger on room entry if hidden
- [ ] Open traps trigger when attached object is opened
- [ ] Detected traps don't trigger on entry (player avoids)
- [ ] Trap effects deal damage via DiceService
- [ ] Trap effects apply status via StatusEffectService
- [ ] Saving throws reduce or negate trap effects
- [ ] Alert effects mark monsters as aware
- [ ] Trapped containers work with existing container system
- [ ] Examine shows DC values for detected traps
- [ ] `TrapEffect` value object handles all effect types
- [ ] `TrapDisarmResult` captures all disarm outcomes
- [ ] `TrapEffectResult` captures damage, saves, and status
- [ ] ~35 unit tests pass

### 7.2 Non-Functional Requirements

- [ ] Services follow DI patterns
- [ ] Logging follows established patterns
- [ ] Configuration is JSON-driven
- [ ] Integration with existing skill system is seamless
- [ ] All public methods have XML documentation

---

## 8. Test Specifications

### 8.1 TrapEffect Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `FromDefinition_CreatesCorrectEffect` | Definition mapping |
| `Damage_CreatessDamageOnlyEffect` | Damage factory |
| `Status_CreatesStatusOnlyEffect` | Status factory |
| `Alert_CreatesAlertOnlyEffect` | Alert factory |
| `DamageAndStatus_CreatesCombinedEffect` | Combined factory |

### 8.2 TrapEffectResult Tests (~4 tests)

| Test Name | Description |
|-----------|-------------|
| `DamageResult_CapturessAllFields` | Damage result creation |
| `StatusResult_CapturessAllFields` | Status result creation |
| `SavedCompletely_ZeroDamage` | Complete save result |
| `Combined_AllFieldsPopulated` | Combined result |

### 8.3 TrapDisarmResult Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `Succeeded_HasCorrectValues` | Success result |
| `FailedSafely_AllowsRetry` | Safe failure |
| `FailedAndTriggered_IncludesEffect` | Triggered failure |
| `CannotDisarm_HasCorrectMessage` | Cannot disarm |
| `NotDetected_HasCorrectMessage` | Not detected |

### 8.4 TrapService Detection Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `SearchForTraps_WithHiddenTraps_PerformsCheck` | Search performs check |
| `SearchForTraps_SuccessfulRoll_DetectsTraps` | Detection on success |
| `SearchForTraps_FailedRoll_DoesNotDetect` | No detection on fail |
| `PassivePerceptionCheck_HighPassive_DetectsEasyTraps` | Passive detection |
| `PassivePerceptionCheck_LowPassive_MissesTraps` | Passive miss |
| `GetPassivePerception_CalculatesCorrectly` | Passive calculation |

### 8.5 TrapService Disarm Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `AttemptDisarm_SuccessfulCheck_DisarmsTrap` | Successful disarm |
| `AttemptDisarm_FailedCheck_AllowsRetry` | Safe failure |
| `AttemptDisarm_CriticalFailure_TriggersTrap` | Triggers on crit fail |
| `AttemptDisarm_HiddenTrap_ReturnsNotDetected` | Cannot disarm hidden |
| `AttemptDisarm_AlreadyDisarmed_ReturnsAlready` | Already disarmed |
| `AttemptDisarm_CannotDisarm_ReturnsCannot` | Cannot disarm type |

### 8.6 TrapService Effect Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `ApplyTrapEffect_WithDamage_DealsDamage` | Damage application |
| `ApplyTrapEffect_WithSave_RollsSave` | Save roll |
| `ApplyTrapEffect_SuccessfulSave_HalvesDamage` | Save halves |
| `ApplyTrapEffect_SuccessfulSave_NegatesStatus` | Save negates status |
| `ApplyTrapEffect_WithStatus_AppliesEffects` | Status application |

### 8.7 Integration Tests (~4 tests)

| Test Name | Description |
|-----------|-------------|
| `CheckEntryTraps_HiddenTrap_Triggers` | Entry trigger |
| `CheckEntryTraps_DetectedTrap_DoesNotTrigger` | Detected avoidance |
| `CheckOpenTraps_AttachedTrap_Triggers` | Open trigger |
| `OpenContainer_WithTrap_TriggersAndOpens` | Container trap |

---

## 9. Dependencies

### 9.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| Trap entity | v0.4.1a | Complete | Core entity |
| TrapState enum | v0.4.1a | Complete | State management |
| TriggerType enum | v0.4.1a | Complete | Trigger types |
| TrapDefinition | v0.4.1a | Complete | Configuration |
| ITrapService | v0.4.1a | Complete | Needs extension |
| TrapService | v0.4.1a | Complete | Needs extension |
| Room.Traps | v0.4.1a | Complete | Collection |
| DiceService | v0.0.x | Complete | Damage rolls |
| SkillCheckService | v0.0.x | Complete | Detection/disarm |
| StatusEffectService | v0.0.x | Complete | Effect application |
| InteractiveObject | v0.4.0a | Complete | Needs trap property |
| InteractionService | v0.4.0a/b/c | Complete | Needs trap integration |

### 9.2 External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Microsoft.Extensions.Logging | 9.0.x | Logging |
| System.Text.Json | 9.0.x | Configuration parsing |

---

## 10. Files Summary

### 10.1 New Files

| File | Purpose |
|------|---------|
| `Domain/ValueObjects/TrapEffect.cs` | Effect value object |
| `Domain/ValueObjects/TrapEffectResult.cs` | Effect result |
| `Domain/ValueObjects/TrapDisarmResult.cs` | Disarm result |
| `Tests/TrapEffectTests.cs` | Effect tests |
| `Tests/TrapEffectResultTests.cs` | Effect result tests |
| `Tests/TrapDisarmResultTests.cs` | Disarm result tests |
| `Tests/TrapServiceDetectionTests.cs` | Detection tests |
| `Tests/TrapServiceDisarmTests.cs` | Disarm tests |
| `Tests/TrapServiceEffectTests.cs` | Effect tests |
| `Tests/TrapIntegrationTests.cs` | Integration tests |

### 10.2 Modified Files

| File | Changes |
|------|---------|
| `Domain/Entities/Trap.cs` | Add Effect property, update FromDefinition |
| `Domain/Entities/InteractiveObject.cs` | Add AttachedTrapId property |
| `Domain/Definitions/TrapDefinition.cs` | Update TrapEffectDefinition |
| `Application/Interfaces/ITrapService.cs` | Add detection/disarm/effect methods |
| `Application/Services/TrapService.cs` | Implement detection/disarm/effect |
| `Application/Interfaces/IInteractionService.cs` | Update Open signature |
| `Application/Services/InteractionService.cs` | Add trap checking to Open |
| `Application/Services/GameSessionService.cs` | Add search/disarm commands, entry traps |
| `Configuration/schemas/traps.schema.json` | Update effect schema |
| `Configuration/schemas/interactive-objects.schema.json` | Add attachedTrapId |
| `Configuration/interactive-objects.json` | Add trapped containers |

---

## 11. Future Considerations

### 11.1 v0.4.1c Preparation

The following will extend this foundation:
- HazardZone entity for area effects
- HazardDefinition for persistent dangers
- Ongoing damage/effects per turn
- Dice saves specifically for hazard damage
- Environmental hazard types (fire, poison gas, ice, spikes)

### 11.2 Integration Points

- **Combat System**: Trap damage uses same damage pipeline as combat
- **Status Effects**: Trap status effects use existing StatusEffectService
- **Skill System**: Detection uses Perception, disarm uses Finesse-based skill
- **Container System**: Trapped containers integrate with v0.4.0b containers

### 11.3 Monster Alert System

The AlertsMonsters flag and AlertRadius provide hooks for future monster AI:
- Monsters in alert radius become aware of player
- Can trigger patrol changes or combat initiation
- Foundation for stealth/noise mechanics

---

*This design specification extends the trap system with full mechanics including skill-based detection, risk/reward disarm attempts, varied effects with saving throws, and seamless integration with the existing container and interaction systems.*
