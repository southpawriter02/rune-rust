# v0.3.19: The Bard (Audio System)

This milestone introduces the audio framework to Rune & Rust through a three-part implementation. The system decouples the intent to make a sound from the method of playback, connects gameplay events to audio feedback, and generates procedural environmental soundscapes. By using the Provider Pattern and EventBus integration, the game can switch between primitive Console Beeps (for the TUI) and complex Audio Engines (for the future GUI) without changing game logic.

---

## v0.3.19a: The Instrument (Audio Infrastructure)

This sub-version establishes the infrastructure for auditory feedback. It decouples the intent to make a sound from the method of playback, allowing the game to switch between primitive Console Beeps (for the TUI) and complex Audio Engines (for the future GUI) without changing game logic.

**Goal:** Define the IAudioService contract, implement the data models for sound cues, and create a cross-platform ConsoleAudioProvider that respects global settings.

### 1. Architecture & Data Flow

The system uses the Provider Pattern. The Game Engine requests a sound by ID (e.g., "UI_CLICK"), and the AudioService resolves it to a SoundCue. The service checks settings (Volume), then delegates execution to the registered IAudioProvider.

**Data Flow: The Playback Pipeline**
1. **Request:** Game Logic calls AudioService.PlayAsync(SoundCue).
2. **Validation:** Service checks GameSettings.MasterVolume.
   - If 0 (Mute), return immediately.
3. **Dispatch:** Service calls IAudioProvider.PlayAsync(cue).
4. **Execution (Terminal):** ConsoleAudioProvider wraps System.Console.Beep() in a background task to prevent blocking the UI thread.

### 2. Logic Decision Trees

#### A. Playback Logic
**Input:** SoundCue (Frequency, Duration), MasterVolume

1. **Volume Check:** Is MasterVolume > 0?
   - No: Log "Skipped (Muted)". Stop.
2. **Platform Check:** Is the OS Windows? (Console.Beep support varies on *nix).
   - No: Log "Skipped (Platform)". Stop (unless using ANSI bell).
3. **Execution:**
   - Wrap Console.Beep(Frequency, Duration) in Task.Run.
   - Note: Console.Beep is blocking; async wrapper is mandatory to keep TUI responsive.

#### B. Cue Selection Logic
**Input:** SoundType (e.g., UI, Combat)

1. **UI Sound:** Use High Pitch (800-1200Hz), Short Duration (50-100ms).
2. **Combat Hit:** Use Mid Pitch (300-500Hz), Medium Duration (150ms).
3. **Ambience:** (Placeholder for v0.3.19c) Ignore for Console Provider (Beeps cannot loop effectively).

### 3. Code Implementation

#### A. Core Models (Data Definitions)
**File:** `RuneAndRust.Core/Models/SoundCue.cs`

```csharp
public enum SoundCategory { UI, Combat, Ambience, Alert }

public record SoundCue(
    string Id,
    SoundCategory Category,
    int Frequency,   // In Hertz (e.g., 440)
    int DurationMs,  // In Milliseconds
    float VolumeMultiplier = 1.0f
)
{
    // Pre-configured static cues for consistency
    public static SoundCue UiClick => new("ui_click", SoundCategory.UI, 1000, 50);
    public static SoundCue Error => new("ui_error", SoundCategory.UI, 200, 300);
}
```

#### B. Service Interface
**File:** `RuneAndRust.Core/Interfaces/IAudioService.cs`

```csharp
public interface IAudioService
{
    Task PlayAsync(SoundCue cue);
    Task PlaySystemCueAsync(string cueId); // Lookup wrapper
    bool IsMuted { get; }
}

public interface IAudioProvider
{
    Task PlayAsync(SoundCue cue, int masterVolume);
}
```

#### C. Terminal Provider Implementation
**File:** `RuneAndRust.Terminal/Services/ConsoleAudioProvider.cs`

```csharp
public class ConsoleAudioProvider : IAudioProvider
{
    public async Task PlayAsync(SoundCue cue, int masterVolume)
    {
        // Console.Beep doesn't support volume amplitude,
        // so we treat masterVolume as a simple on/off gate here,
        // or potentially scale duration for emphasis.

        if (OperatingSystem.IsWindows())
        {
            // Fire and forget to prevent UI blocking
            await Task.Run(() =>
            {
                try
                {
                    Console.Beep(cue.Frequency, cue.DurationMs);
                }
                catch
                {
                    // Swallow hardware errors (no speakers, etc)
                }
            });
        }
        else
        {
            // Fallback for *nix/Mac (Standard Bell)
            Console.Write("\a");
        }
    }
}
```

### 4. Deliverable Checklist (v0.3.19a)

- **Core:**
  - [ ] Define SoundCategory enum.
  - [ ] Define SoundCue record.
  - [ ] Define IAudioService and IAudioProvider interfaces.
- **Engine:**
  - [ ] Implement AudioService.
  - [ ] Integrate GameSettings.MasterVolume check [Source 3389].
- **Terminal:**
  - [ ] Implement ConsoleAudioProvider with Windows/Linux differentiation.
  - [ ] Register services in Program.cs.
- **Tests:**
  - [ ] Verify mute logic works.
  - [ ] Verify provider is called when volume is up.

### 5. Logging Requirements

Reference: logging.md

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Audio | Play Request | Trace | "[Audio] Requesting cue: {CueId} ({Freq}Hz/{Dur}ms)" | CueId, Freq, Dur |
| Audio | Muted | Trace | "[Audio] Skipped {CueId} (MasterVolume: 0)" | CueId |
| Audio | Execution | Debug | "[Audio] Provider executing {CueId}" | CueId |

---

## v0.3.19b: The Score (Event Wiring)

This sub-version connects the "silent" game logic to the audio infrastructure built in v0.3.19a. By subscribing to the EventBus (established in v0.1.3a), we ensure that gameplay systems (Combat, Inventory, UI) remain decoupled from audio implementation; they simply broadcast that an event happened, and the audio system decides if a sound should play [Source 155, 5394].

**Goal:** Implement the AudioEventListener service to subscribe to domain events and map them to SoundCue definitions via a SoundRegistry.

### 1. Architecture & Data Flow

- **The Listener Pattern:** AudioEventListener is a background service that listens to EventBus. It does not contain game logic; it only translates Events into Cues.
- **The Registry:** A static catalog (SoundRegistry) that acts as a configuration file for which sounds correspond to which events (e.g., EntityDamaged -> SoundCue.Hit).
- **Context Awareness:** The listener checks event payload data (e.g., IsCritical, DamageType) to select specific variations (Heavy Hit vs. Light Hit).

**Data Flow: The Feedback Loop**
1. **Trigger:** CombatService publishes EntityDamagedEvent [Source 2206].
2. **Interception:** AudioEventListener receives the event.
3. **Lookup:** Listener queries SoundRegistry.GetCueForDamage(event.DamageType, event.IsCritical).
4. **Action:** Listener calls _audioService.PlayAsync(cue) [Source 5403].
5. **Output:** ConsoleAudioProvider plays the system beep.

### 2. Logic Decision Trees

#### A. Combat Event Processing Logic
**Input:** EntityDamagedEvent

1. **Check Magnitude:** Is damage > 0?
   - No: Stop (Miss/Block handled by separate event).
2. **Check Critical:** Is IsCritical == true?
   - Yes: Select SoundRegistry.Combat_Crit (High Pitch, Long Decay).
3. **Check Lethal:** Is Target.CurrentHP <= 0?
   - Yes: Queue SoundRegistry.Combat_Kill (Descending Pitch) after the hit sound.
4. **Default:** Select SoundRegistry.Combat_Hit (Medium Pitch).

#### B. UI Event Processing Logic
**Input:** InputEvent (Key Press)

1. **Context:** Is the player in a Menu or Gameplay?
   - Menu: SoundRegistry.UI_Blip.
2. **Validation:** Did the command fail (e.g., "Cannot move there")?
   - Yes: SoundRegistry.UI_Error (Low Buzz).
   - No: SoundRegistry.UI_Click (High Click).

### 3. Code Implementation

#### A. The Sound Registry
**File:** `RuneAndRust.Engine/Data/SoundRegistry.cs`

Purpose: Centralized definition of all audible cues.

```csharp
using RuneAndRust.Core.Models;

public static class SoundRegistry
{
    // UI Cues
    public static readonly SoundCue UiNav = new("ui_nav", SoundCategory.UI, 800, 50);
    public static readonly SoundCue UiSelect = new("ui_sel", SoundCategory.UI, 1200, 100);
    public static readonly SoundCue UiError = new("ui_err", SoundCategory.UI, 150, 300);

    // Combat Cues
    public static readonly SoundCue AttackLight = new("atk_lgt", SoundCategory.Combat, 400, 100);
    public static readonly SoundCue AttackHeavy = new("atk_hvy", SoundCategory.Combat, 300, 250);
    public static readonly SoundCue Crit = new("atk_crit", SoundCategory.Combat, 2000, 400); // High pitch notification

    public static SoundCue GetDamageCue(bool isCritical, int damageAmount)
    {
        if (isCritical) return Crit;
        return damageAmount > 10 ? AttackHeavy : AttackLight;
    }
}
```

#### B. The Event Listener
**File:** `RuneAndRust.Engine/Services/AudioEventListener.cs`

Purpose: Bridges the EventBus and AudioService.

```csharp
public class AudioEventListener
{
    private readonly IAudioService _audio;
    private readonly IEventBus _bus;

    public AudioEventListener(IAudioService audio, IEventBus bus)
    {
        _audio = audio;
        _bus = bus;
    }

    public void SubscribeAll()
    {
        // Subscribe to Core Events
        _bus.Subscribe<EntityDamagedEvent>(OnDamaged);
        _bus.Subscribe<EntityDeathEvent>(OnDeath);
        _bus.Subscribe<ItemLootedEvent>(OnLoot);
    }

    private void OnDamaged(EntityDamagedEvent e)
    {
        var cue = SoundRegistry.GetDamageCue(e.IsCritical, e.Amount);
        // Fire and forget - do not await in event handler
        _ = _audio.PlayAsync(cue);
    }

    private void OnDeath(EntityDeathEvent e)
    {
        // Distinct sound for enemy vs player
        var cue = e.IsPlayer ? SoundRegistry.UiError : SoundRegistry.UiSelect;
        _ = _audio.PlayAsync(cue);
    }

    private void OnLoot(ItemLootedEvent e)
    {
        // Higher pitch for better loot?
        _ = _audio.PlayAsync(SoundRegistry.UiSelect);
    }
}
```

### 4. Deliverable Checklist (v0.3.19b)

- **Engine:**
  - [ ] Implement SoundRegistry with static SoundCue definitions [Source 5395].
  - [ ] Implement AudioEventListener class.
  - [ ] Register AudioEventListener in Program.cs and call SubscribeAll() on startup.
- **Integration:**
  - [ ] Verify CombatService publishes EntityDamagedEvent.
  - [ ] Verify InventoryService publishes ItemLootedEvent.
- **Terminal:**
  - [ ] Update TerminalInputHandler to trigger UiNav sounds on keypress (optional: usually best handled locally in the UI layer for latency reasons).

### 5. Logging Requirements

Reference: logging.md

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Audio | Mapping | Verbose | "[Audio] Mapped event {Event} to cue {CueId}." | Event, CueId |
| Audio | Fallback | Warning | "[Audio] No cue found for event {Event}. Playing default." | Event |

---

## v0.3.19c: The Ambience (Procedural Soundscape)

This sub-version brings the dungeon to life by implementing a background audio layer. Since the TUI relies on Console.Beep, we cannot play true "loops." Instead, we will implement a Procedural Soundscape Generator that triggers periodic "stings" (short tones) simulating environmental noise (e.g., distant machinery, dripping water) based on the current Biome.

**Goal:** Implement the AmbienceService to generate periodic, biome-specific audio cues that enhance immersion without overwhelming the player or blocking input.

### 1. Architecture & Data Flow

- **Ambience Service:** A background service (hosted or ticked by GameLoop) that tracks time since the last environmental sound.
- **Biome Profiles:** A mapping logic that translates BiomeType into audio parameters (Pitch Range, Duration Range, Interval).
  - The Roots (Industrial): Low frequency, long duration (Rumbles).
  - Niflheim (Ice): High frequency, short duration (Chimes/Cracking).
  - Organic: Mid-frequency, variable (Rustling).
- **Settings Integration:** Hooks into GameSettings to allow toggling Ambience on/off specifically, separate from Master Volume.

**Data Flow: The Soundscape Loop**
1. **Tick:** AmbienceService wakes up (e.g., every 1 second).
2. **Validation:** Checks GameSettings.AmbienceEnabled and GameState.Phase (must be Exploration).
3. **Cooldown:** Checks if LastSoundTime + RandomInterval < Now.
4. **Selection:** Reads CurrentRoom.BiomeType.
5. **Generation:** Creates a randomized SoundCue based on the Biome's profile.
6. **Playback:** Sends cue to IAudioService.PlayAsync (Low Priority).

### 2. Logic Decision Trees

#### A. Ambience Tick Logic
**Input:** CurrentTime, CurrentRoom

1. **Pre-Flight:** Is AmbienceEnabled? Is Game Paused?
   - No: Stop/Reset Timer.
2. **Timer Check:** Has NextCueTime elapsed?
   - No: Return.
3. **Biome Lookup:** Switch CurrentRoom.BiomeType:
   - Industrial: Freq 100-300Hz (Rumble).
   - Void: Freq 50-80Hz (Deep Drone) OR 10000Hz+ (Eerie whine - skipped for Beep safety).
   - Ruin: Freq 400-600Hz (Wind).
4. **Execute:** Play Sound.
5. **Reschedule:** Set NextCueTime = Now + Random(5s, 15s).

#### B. Profile Generation Logic
**Input:** BiomeType

- **Profile: Industrial (The Roots)**
  - Frequency: Random(100, 250) Hz.
  - Duration: Random(300, 800) ms.
  - Description: "Distant Machinery".
- **Profile: Ice (Niflheim)**
  - Frequency: Random(1200, 2000) Hz.
  - Duration: Random(50, 100) ms.
  - Description: "Ice cracking".

### 3. Code Implementation

#### A. Ambience Settings Extension
**File:** `RuneAndRust.Core/Settings/GameSettings.cs`

```csharp
public static class GameSettings
{
    // ... existing settings
    public static bool AmbienceEnabled { get; set; } = true;
}
```

#### B. Ambience Service
**File:** `RuneAndRust.Engine/Services/AmbienceService.cs`

```csharp
public class AmbienceService : IDisposable
{
    private readonly IAudioService _audio;
    private readonly GameState _gameState;
    private readonly Random _rng = new();
    private DateTime _nextCueTime;
    private bool _isRunning;

    public AmbienceService(IAudioService audio, GameState gameState)
    {
        _audio = audio;
        _gameState = gameState;
        ScheduleNextCue();
    }

    public async Task UpdateAsync()
    {
        if (!GameSettings.AmbienceEnabled || _gameState.Phase != GamePhase.Exploration) return;

        if (DateTime.UtcNow >= _nextCueTime)
        {
            await PlayBiomeCue();
            ScheduleNextCue();
        }
    }

    private async Task PlayBiomeCue()
    {
        if (_gameState.CurrentRoom == null) return;

        var (freqMin, freqMax, durMin, durMax) = GetProfile(_gameState.CurrentRoom.BiomeType);

        var cue = new SoundCue(
            "ambience_proc",
            SoundCategory.Ambience,
            _rng.Next(freqMin, freqMax),
            _rng.Next(durMin, durMax)
        );

        await _audio.PlayAsync(cue);
    }

    private (int fMin, int fMax, int dMin, int dMax) GetProfile(BiomeType biome)
    {
        return biome switch
        {
            BiomeType.Industrial => (100, 300, 500, 1000), // Low rumbles
            BiomeType.Void => (200, 250, 1000, 2000),      // Long drones
            BiomeType.Organic => (600, 900, 50, 150),      // Skittering/Rustling
            _ => (400, 600, 200, 400)                      // Standard wind
        };
    }

    private void ScheduleNextCue()
    {
        // Random delay between 5 and 15 seconds
        _nextCueTime = DateTime.UtcNow.AddSeconds(_rng.Next(5, 15));
    }

    public void Dispose() { /* Cleanup if using Timers */ }
}
```

### 4. Deliverable Checklist (v0.3.19c)

- **Core:**
  - [ ] Add AmbienceEnabled to GameSettings.
  - [ ] Add Ambience to SoundCategory enum (if not present).
- **Engine:**
  - [ ] Implement AmbienceService.
  - [ ] Integrate AmbienceService.UpdateAsync() into GameLoop (or run as background Task).
  - [ ] Define frequency profiles for all 5 BiomeTypes.
- **Terminal:**
  - [ ] Add "Toggle Ambience" option to the Options Menu (v0.3.10b integration).
- **Tests:**
  - [ ] Verify AmbienceEnabled = false prevents playback.
  - [ ] Verify Biome switch changes frequency ranges.

### 5. Logging Requirements

Reference: logging.md

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Ambience | Cue Generated | Verbose | "[Audio] Generated ambience for {Biome}: {Freq}Hz / {Dur}ms." | Biome, Freq, Dur |
| Ambience | Disabled | Debug | "[Audio] Ambience tick skipped (Disabled/Wrong Phase)." | - |

---

## Testing Strategy

### Unit Tests

#### AudioServiceTests.cs (v0.3.19a)
- **Play_RespectsMute:**
  - Set GameSettings.MasterVolume = 0.
  - Call PlayAsync(SoundCue.UiClick).
  - Assert: MockProvider.Verify(x => x.PlayAsync(...), Times.Never).
- **Play_PassesCue:**
  - Set Volume = 100.
  - Call PlayAsync(SoundCue.UiClick).
  - Assert: MockProvider.Verify(x => x.PlayAsync(SoundCue.UiClick, 100), Times.Once).

#### AudioEventListenerTests.cs (v0.3.19b)
- **Damage_Triggers_Sound:**
  - Mock IAudioService and IEventBus.
  - Simulate EntityDamagedEvent (Normal).
  - Assert audio.PlayAsync called with SoundRegistry.AttackLight.
- **Crit_Triggers_Different_Sound:**
  - Simulate EntityDamagedEvent (IsCritical = true).
  - Assert audio.PlayAsync called with SoundRegistry.Crit.

#### AmbienceServiceTests.cs (v0.3.19c)
- **Respects_Settings:**
  - Set GameSettings.AmbienceEnabled = false.
  - Force UpdateAsync past cooldown.
  - Assert IAudioService.PlayAsync never called.
- **Biome_Profile_Selection:**
  - Set Room Biome to Industrial.
  - Force Update.
  - Assert PlayAsync called with Freq between 100-300Hz.
- **Phase_Restriction:**
  - Set Phase to Combat.
  - Force Update.
  - Assert PlayAsync never called (Ambience silences during combat to prioritize combat cues).

### Manual QA

#### v0.3.19a - Terminal Test
- Run application.
- Triggers are not wired yet, so temporary injection in MainMenuController is needed.
- Navigating menu should produce Beeps (if wired temporarily).

#### v0.3.19b - Audio Latency Check
- Start combat. Perform a hit. Ensure the beep occurs immediately with the log message, not seconds later. (If latent, check Task.Run usage in Provider).

#### v0.3.19b - Spam Check
- Use a multi-hit ability (e.g., Whirlwind). Ensure the audio does not "queue up" 5 beeps in a row that play for 3 seconds after the turn ends. (Debounce logic might be needed in v0.3.19c).

#### v0.3.19c - Stress Test
- Leave the game running in an Industrial room. Listen for periodic low rumbles (every ~10s).

#### v0.3.19c - Transition
- Move from Industrial to Organic. Verify sound "texture" changes (Rumbles -> Skittering).

---

## Draft Changelog (v0.3.19)

```markdown
# Changelog: v0.3.19 - The Bard

**Release Date:** 2026-02-XX

## Summary
"The Bard" update introduces the audio framework to Rune & Rust. The game now provides auditory feedback for interactions, combat events, and environmental atmosphere, utilizing a cross-platform provider system that respects accessibility settings.

## Changes
- **Core:** Added `SoundCue` model and `IAudioService` interface.
- **Engine:** Implemented `AudioService` with Master Volume filtering.
- **Engine:** Implemented `AudioEventListener` to listen for game events.
- **Data:** Created `SoundRegistry` mapping game events (Hit, Crit, Loot) to specific sound frequencies and durations.
- **Terminal:** Implemented `ConsoleAudioProvider` using system beeps for TUI feedback.
- **System:** Added platform detection to handle audio differences between Windows and Linux/macOS.
- **Combat:** Taking damage now triggers dynamic sound cues based on damage intensity and critical status. Wired Attack, Damage, and Death events to distinct sound cues (High pitch for Criticals, low thud for Blocks).
- **UI:** Basic navigation sounds added to menus.
- **Atmosphere:** Added `AmbienceService` which generates procedural background audio based on the current Biome (e.g., machinery rumbles for The Roots, crystalline chimes for Niflheim).
- **Settings:** Integrated Master Volume and Ambience Toggles into the Options menu.
```
