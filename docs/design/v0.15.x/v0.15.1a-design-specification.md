# v0.15.1a Design Specification: Skill Context & Modifiers

**Version:** 0.15.1a
**Theme:** Skill Context & Modifiers
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0 Complete (Dice Pool Refactor with success-counting, fumble detection, critical success, degrees of success)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [SkillContext Value Object](#4-skillcontext-value-object)
5. [EquipmentModifier Value Object](#5-equipmentmodifier-value-object)
6. [SituationalModifier Value Object](#6-situationalmodifier-value-object)
7. [EnvironmentModifier Value Object](#7-environmentmodifier-value-object)
8. [TargetModifier Value Object](#8-targetmodifier-value-object)
9. [ModifierCategory Enum](#9-modifiercategory-enum)
10. [ISkillContextBuilder Interface](#10-iskillcontextbuilder-interface)
11. [SkillContextBuilder Implementation](#11-skillcontextbuilder-implementation)
12. [SkillCheckService Integration](#12-skillcheckservice-integration)
13. [Data Model Changes](#13-data-model-changes)
14. [Configuration](#14-configuration)
15. [Commands](#15-commands)
16. [User-Facing Changes](#16-user-facing-changes)
17. [Logging Specifications](#17-logging-specifications)
18. [Unit Testing Requirements](#18-unit-testing-requirements)
19. [Use Cases](#19-use-cases)
20. [Deliverable Checklist](#20-deliverable-checklist)
21. [Acceptance Criteria](#21-acceptance-criteria)
22. [Future Considerations](#22-future-considerations)
23. [Implementation Notes](#23-implementation-notes)
24. [Document Metadata](#24-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.1a, the Skill Context & Modifiers phase. This part introduces a structured system for aggregating and applying contextual modifiers to skill checks. The `SkillContext` value object serves as a container for all factors that influence a skill check, including:

1. **Equipment Modifiers**: Bonuses or penalties from tools, gear, and weapons (e.g., Tinker's Toolkit +2d10 for lockpicking).

2. **Situational Modifiers**: Temporary conditions like time pressure, familiarity with the task, or assistance from others.

3. **Environment Modifiers**: Physical conditions including surface type (stable, wet, compromised), lighting level, and corruption tier.

4. **Target Modifiers**: Factors related to the target of the check, such as NPC disposition (friendly to hostile), suspicion level, or resistance.

This infrastructure is foundational for all skill system expansions in v0.15.2-v0.15.5, enabling contextually-aware skill checks that respond dynamically to the game state.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Modifier Aggregation** | Ad-hoc parameter passing | Structured `SkillContext` container |
| **Equipment Effects** | `additionalBonusDice` parameter | `EquipmentModifier` value objects with metadata |
| **Environmental Factors** | Not systematically tracked | `EnvironmentModifier` with surface, lighting, corruption |
| **Target Factors** | Not tracked | `TargetModifier` with disposition, suspicion |
| **Situational Bonuses** | Implicit in bonus dice | Explicit `SituationalModifier` with source/duration |
| **Modifier Visibility** | Not exposed to user | `ToDescription()` for human-readable breakdown |
| **Status Effect Integration** | Separate handling | `AppliedStatuses` list in context |

### 1.3 Scope

**In Scope:**
- Define `SkillContext` value object as modifier container
- Define `EquipmentModifier` value object with tool/gear bonuses
- Define `SituationalModifier` value object for temporary conditions
- Define `EnvironmentModifier` value object for physical conditions
- Define `TargetModifier` value object for target-related factors
- Define `ModifierCategory` enum for classification
- Create `ISkillContextBuilder` interface for fluent construction
- Implement `SkillContextBuilder` for building contexts
- Integrate `SkillContext` into `SkillCheckService`
- Unit tests for modifier aggregation (~8 tests)

**Out of Scope:**
- Outcome classification expansion - v0.15.1b
- Fumble consequence tracking - v0.15.1b
- Master rank abilities - v0.15.1c
- Cooperative and chained checks - v0.15.1d
- Trauma economy integration - v0.15.1e
- Specialization bonus hooks - v0.15.1e
- Voice guidance integration - v0.15.1e
- Skill-specific modifiers (climbing surfaces, lock types) - v0.15.2-v0.15.5

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Value Objects | 5 | `SkillContext`, `EquipmentModifier`, `SituationalModifier`, `EnvironmentModifier`, `TargetModifier` |
| Enums | 1 | `ModifierCategory` |
| Interfaces | 1 | `ISkillContextBuilder` |
| Services | 1 | `SkillContextBuilder` |
| Unit Tests | ~8 | Modifier aggregation, calculation, stacking, description formatting |

---

## 2. Dependencies

### 2.1 Required from v0.15.0a (Core Dice Mechanics)

| Component | Location | Usage in v0.15.1a |
|-----------|----------|-------------------|
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Provides `NetSuccesses` for modified checks |
| `DiceConstants` | `Domain/Constants/DiceConstants.cs` | Threshold values referenced in modifier descriptions |

### 2.2 Required from v0.15.0c (Skill Check Refactor)

| Component | Location | Usage in v0.15.1a |
|-----------|----------|-------------------|
| `SkillCheckResult` | `Domain/ValueObjects/SkillCheckResult.cs` | Receives context modifiers |
| `SkillOutcome` | `Domain/Enums/SkillOutcome.cs` | Outcome classification (6-tier) |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Modified to accept `SkillContext` |

### 2.3 Required from v0.10.x (Status Effect System)

| Component | Location | Usage in v0.15.1a |
|-----------|----------|-------------------|
| `StatusEffectId` | `Domain/Enums/StatusEffectId.cs` | Referenced in `AppliedStatuses` |
| `StatusEffectType` | `Domain/Enums/StatusEffectType.cs` | Categorization for status effects |

### 2.4 Current SkillCheckService Signature (to be modified)

```csharp
// Current method signature
public SkillCheckResult PerformCheckWithDC(
    Player player,
    string skillId,
    int difficultyClass,
    string difficultyName = "Custom",
    AdvantageType advantageType = AdvantageType.Normal,
    int additionalBonusDice = 0)  // <-- To be replaced with SkillContext
```

### 2.5 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.1b | `FumbleConsequence` | Uses `SkillContext` for consequence severity |
| v0.15.1c | `MasterAbility` | Modifies `SkillContext` for auto-succeed checks |
| v0.15.1d | `CooperativeCheckResult` | Builds contexts for multiple participants |
| v0.15.2 | Acrobatics | Uses `EnvironmentModifier.SurfaceType` for climbing |
| v0.15.3 | Rhetoric | Uses `TargetModifier.Disposition` for persuasion |
| v0.15.4 | System Bypass | Uses `EquipmentModifier` for tools |
| v0.15.5 | Wasteland Survival | Uses `EnvironmentModifier` for terrain |

---

## 3. Architecture Diagrams

### 3.1 Skill Context Aggregation Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SKILL CONTEXT AGGREGATION FLOW                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SKILL CHECK REQUEST                                                        │
│  Player: "Pick this lock"                                                   │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                 GATHER MODIFIERS FROM GAME STATE                    │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ├──────────────────────────────────────────────────────────┐      │
│           │                                                          │      │
│           ▼                                                          ▼      │
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐ │
│  │ EQUIPMENT MODIFIERS │  │ SITUATION MODIFIERS │  │ ENVIRONMENT MODS   │ │
│  ├─────────────────────┤  ├─────────────────────┤  ├─────────────────────┤ │
│  │                     │  │                     │  │                     │ │
│  │ Tinker's Toolkit    │  │ Time Pressure       │  │ Surface: Stable     │ │
│  │   Dice: +2d10       │  │   Dice: -1d10       │  │   Dice: +1d10       │ │
│  │   DC: 0             │  │   DC: 0             │  │   DC: 0             │ │
│  │                     │  │                     │  │                     │ │
│  │ Magnifying Glass    │  │ Familiar Lock Type  │  │ Lighting: Dim       │ │
│  │   Dice: +1d10       │  │   Dice: +1d10       │  │   Dice: 0           │ │
│  │   DC: 0             │  │   DC: 0             │  │   DC: +1            │ │
│  │                     │  │                     │  │                     │ │
│  └─────────────────────┘  └─────────────────────┘  │ Corruption: Normal  │ │
│           │                         │              │   Dice: 0           │ │
│           │                         │              │   DC: 0             │ │
│           │                         │              │                     │ │
│           │                         │              └─────────────────────┘ │
│           │                         │                        │              │
│           └──────────────┬──────────┴────────────────────────┘              │
│                          │                                                   │
│                          ▼                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         SKILL CONTEXT                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  EquipmentModifiers: [Tinker's Toolkit +2d10, Magnifying Glass +1d10]│   │
│  │  SituationalModifiers: [Time Pressure -1d10, Familiar +1d10]        │    │
│  │  EnvironmentModifiers: [Stable +1d10, Dim DC+1]                     │    │
│  │  TargetModifiers: []  (not applicable for lockpicking)              │    │
│  │                                                                      │    │
│  │  ──────────────────────────────────────────────                     │    │
│  │  TotalDiceModifier: +2 +1 -1 +1 +1 = +4d10                          │    │
│  │  TotalDcModifier: 0 + 0 + 0 + 1 = +1                                │    │
│  │  AppliedStatuses: []                                                 │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                          │                                                   │
│                          ▼                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLY TO SKILL CHECK                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Base Dice Pool: 3d10 (from skill + attribute)                      │    │
│  │  Context Modifier: +4d10                                             │    │
│  │  Final Dice Pool: 7d10                                               │    │
│  │                                                                      │    │
│  │  Base DC: 2 (Moderate lock)                                          │    │
│  │  Context Modifier: +1                                                │    │
│  │  Final DC: 3                                                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Modifier Category Hierarchy

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       MODIFIER CATEGORY HIERARCHY                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ISkillModifier (base interface)                                            │
│  ├── DiceModifier: int (bonus/penalty to dice pool)                         │
│  ├── DcModifier: int (bonus/penalty to difficulty class)                    │
│  ├── Category: ModifierCategory                                             │
│  └── Description: string                                                    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                     EQUIPMENT MODIFIERS                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Category: ModifierCategory.Equipment                               │    │
│  │                                                                      │    │
│  │  EquipmentId: string         (reference to inventory item)          │    │
│  │  EquipmentCategory: EquipmentCategory (Tool, Weapon, Armor)         │    │
│  │  RequiredForCheck: bool      (can't attempt without this?)          │    │
│  │                                                                      │    │
│  │  Examples:                                                           │    │
│  │  ├── Tinker's Toolkit      +2d10   (System Bypass checks)           │    │
│  │  ├── Lockpicks (Basic)     +0d10   (enables lockpicking)            │    │
│  │  ├── Lockpicks (Quality)   +1d10   (better picks)                   │    │
│  │  ├── Climbing Gear         +1d10   (climbing checks)                │    │
│  │  ├── Magnifying Glass      +1d10   (examination checks)             │    │
│  │  └── Compass (Working)     +1d10   (navigation checks)              │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                   SITUATIONAL MODIFIERS                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Category: ModifierCategory.Situational                             │    │
│  │                                                                      │    │
│  │  Source: string              (what caused this modifier)            │    │
│  │  Duration: ModifierDuration  (Instant, Round, Scene, Persistent)    │    │
│  │  IsStackable: bool           (can multiple instances apply?)        │    │
│  │                                                                      │    │
│  │  Examples:                                                           │    │
│  │  ├── Time Pressure          -1d10   (rushed attempt)                │    │
│  │  ├── Taking Time            +1d10   (extra time spent)              │    │
│  │  ├── Familiarity            +1d10   (done this before)              │    │
│  │  ├── Distracted             -1d10   (combat/danger nearby)          │    │
│  │  ├── Assisted               +Nd10   (helper bonus)                  │    │
│  │  └── Fatigued               -2d10   (exhaustion penalty)            │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                   ENVIRONMENT MODIFIERS                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Category: ModifierCategory.Environment                             │    │
│  │                                                                      │    │
│  │  SurfaceType: SurfaceType    (Stable, Wet, Compromised, Collapsing) │    │
│  │  LightingLevel: LightingLevel (Bright, Normal, Dim, Dark)           │    │
│  │  CorruptionTier: CorruptionTier (Normal, Glitched, Blighted, Res.)  │    │
│  │  WeatherCondition: WeatherType (optional, for outdoor)              │    │
│  │                                                                      │    │
│  │  Examples:                                                           │    │
│  │  ├── Stable Surface         +1d10   (climbing)                      │    │
│  │  ├── Wet Surface            -1d10   (climbing)                      │    │
│  │  ├── Compromised Surface    -2d10   (climbing)                      │    │
│  │  ├── Collapsing Surface     -3d10   (climbing)                      │    │
│  │  ├── Dim Lighting           DC +1   (perception, lockpicking)       │    │
│  │  ├── Dark Lighting          DC +2   (visual tasks)                  │    │
│  │  ├── Glitched Corruption    DC +2   (all checks in area)            │    │
│  │  └── Blighted Corruption    DC +4   (all checks in area)            │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      TARGET MODIFIERS                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Category: ModifierCategory.Target                                  │    │
│  │                                                                      │    │
│  │  TargetId: string?           (NPC, device, or object ID)            │    │
│  │  Disposition: Disposition    (Friendly, Neutral, Suspicious, Hostile)│   │
│  │  SuspicionLevel: int         (0-10 scale for deception checks)      │    │
│  │  ResistanceLevel: int        (target's opposed stat/will)           │    │
│  │                                                                      │    │
│  │  Examples:                                                           │    │
│  │  ├── Friendly Disposition   +2d10   (persuasion)                    │    │
│  │  ├── Neutral Disposition    +0d10   (persuasion)                    │    │
│  │  ├── Suspicious Disposition -2d10   (persuasion)                    │    │
│  │  ├── Hostile Disposition    -2d10   (persuasion, impossible for some)│   │
│  │  ├── Suspicious (+4 DC)     DC +4   (deception if target wary)      │    │
│  │  ├── Weaker Target          +1d10   (intimidation)                  │    │
│  │  └── Stronger Target        -1d10   (intimidation)                  │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 SkillContext Builder Pattern

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      SKILL CONTEXT BUILDER PATTERN                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  FLUENT BUILDER USAGE:                                                      │
│                                                                              │
│  var context = new SkillContextBuilder()                                    │
│      .WithEquipment("tinkers-toolkit", dice: 2, description: "Toolkit")     │
│      .WithEquipment("magnifying-glass", dice: 1, description: "Glass")      │
│      .WithSituation("time-pressure", dice: -1, source: "Combat nearby")     │
│      .WithEnvironment(SurfaceType.Stable, LightingLevel.Dim)                │
│      .WithCorruption(CorruptionTier.Normal)                                 │
│      .WithAppliedStatus(StatusEffectId.Alert)                               │
│      .Build();                                                               │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  BUILDER STEPS:                                                     │    │
│  │                                                                      │    │
│  │  1. Create builder                                                  │    │
│  │     ┌─────────────────────────────────┐                             │    │
│  │     │ new SkillContextBuilder()       │                             │    │
│  │     │                                 │                             │    │
│  │     │ _equipmentMods = []             │                             │    │
│  │     │ _situationalMods = []           │                             │    │
│  │     │ _environmentMods = []           │                             │    │
│  │     │ _targetMods = []                │                             │    │
│  │     │ _statuses = []                  │                             │    │
│  │     └─────────────────────────────────┘                             │    │
│  │                         │                                            │    │
│  │                         ▼                                            │    │
│  │  2. Chain modifier methods (fluent)                                 │    │
│  │     ┌─────────────────────────────────┐                             │    │
│  │     │ .WithEquipment(...)             │ → adds to _equipmentMods    │    │
│  │     │ .WithSituation(...)             │ → adds to _situationalMods  │    │
│  │     │ .WithEnvironment(...)           │ → adds to _environmentMods  │    │
│  │     │ .WithTarget(...)                │ → adds to _targetMods       │    │
│  │     │ .WithAppliedStatus(...)         │ → adds to _statuses         │    │
│  │     └─────────────────────────────────┘                             │    │
│  │                         │                                            │    │
│  │                         ▼                                            │    │
│  │  3. Build final context                                             │    │
│  │     ┌─────────────────────────────────┐                             │    │
│  │     │ .Build()                        │                             │    │
│  │     │                                 │                             │    │
│  │     │ - Create immutable SkillContext │                             │    │
│  │     │ - Calculate TotalDiceModifier   │                             │    │
│  │     │ - Calculate TotalDcModifier     │                             │    │
│  │     │ - Return frozen context         │                             │    │
│  │     └─────────────────────────────────┘                             │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  RESULT: Immutable SkillContext ready for SkillCheckService                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  ValueObjects/                                                       │    │
│  │  ├── SkillContext.cs           ←── NEW (modifier container)         │    │
│  │  ├── EquipmentModifier.cs      ←── NEW (equipment bonuses)          │    │
│  │  ├── SituationalModifier.cs    ←── NEW (situational factors)        │    │
│  │  ├── EnvironmentModifier.cs    ←── NEW (environment factors)        │    │
│  │  └── TargetModifier.cs         ←── NEW (target factors)             │    │
│  │                                                                      │    │
│  │  Enums/                                                              │    │
│  │  ├── ModifierCategory.cs       ←── NEW (modifier classification)    │    │
│  │  ├── SurfaceType.cs            ←── NEW (climbing surfaces)          │    │
│  │  ├── LightingLevel.cs          ←── NEW (lighting conditions)        │    │
│  │  ├── CorruptionTier.cs         ←── EXISTING (reused)                │    │
│  │  └── Disposition.cs            ←── NEW (NPC disposition)            │    │
│  │                                                                      │    │
│  │  Interfaces/                                                         │    │
│  │  └── ISkillModifier.cs         ←── NEW (base modifier interface)    │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Interfaces/                                                         │    │
│  │  └── ISkillContextBuilder.cs   ←── NEW (builder interface)          │    │
│  │                                                                      │    │
│  │  Services/                                                           │    │
│  │  ├── SkillContextBuilder.cs    ←── NEW (fluent builder)             │    │
│  │  └── SkillCheckService.cs      ←── MODIFIED (accepts SkillContext)  │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  DEPENDENCY INJECTION                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  services.AddTransient<ISkillContextBuilder, SkillContextBuilder>();│    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. SkillContext Value Object

### 4.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SkillContext.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Container for all contextual modifiers affecting a skill check.
/// </summary>
/// <remarks>
/// <para>
/// Aggregates modifiers from four categories:
/// <list type="bullet">
///   <item><description>Equipment: Tools, gear, weapons</description></item>
///   <item><description>Situational: Time pressure, familiarity, assistance</description></item>
///   <item><description>Environment: Surface, lighting, corruption</description></item>
///   <item><description>Target: NPC disposition, suspicion, resistance</description></item>
/// </list>
/// </para>
/// <para>
/// The context calculates total dice pool and DC adjustments that are applied
/// by <see cref="SkillCheckService"/> when performing the check.
/// </para>
/// </remarks>
public sealed class SkillContext
{
    /// <summary>
    /// Equipment modifiers from tools, gear, and weapons.
    /// </summary>
    public IReadOnlyList<EquipmentModifier> EquipmentModifiers { get; }

    /// <summary>
    /// Situational modifiers from temporary conditions.
    /// </summary>
    public IReadOnlyList<SituationalModifier> SituationalModifiers { get; }

    /// <summary>
    /// Environment modifiers from physical conditions.
    /// </summary>
    public IReadOnlyList<EnvironmentModifier> EnvironmentModifiers { get; }

    /// <summary>
    /// Target modifiers from target-related factors.
    /// </summary>
    public IReadOnlyList<TargetModifier> TargetModifiers { get; }

    /// <summary>
    /// Total dice pool modification (sum of all dice modifiers).
    /// </summary>
    /// <remarks>
    /// Positive values add dice to the pool, negative values remove dice.
    /// The final pool size is clamped to minimum 1 die.
    /// </remarks>
    public int TotalDiceModifier { get; }

    /// <summary>
    /// Total difficulty class modification (sum of all DC modifiers).
    /// </summary>
    /// <remarks>
    /// Positive values increase difficulty, negative values decrease it.
    /// The final DC is clamped to minimum 0.
    /// </remarks>
    public int TotalDcModifier { get; }

    /// <summary>
    /// Status effects to apply based on check outcome.
    /// </summary>
    /// <remarks>
    /// These statuses may be applied on success, failure, or specific outcomes
    /// depending on the skill check type.
    /// </remarks>
    public IReadOnlyList<StatusEffectId> AppliedStatuses { get; }

    /// <summary>
    /// Gets whether this context has any modifiers.
    /// </summary>
    public bool HasModifiers =>
        EquipmentModifiers.Count > 0 ||
        SituationalModifiers.Count > 0 ||
        EnvironmentModifiers.Count > 0 ||
        TargetModifiers.Count > 0;

    /// <summary>
    /// Gets the total count of all modifiers.
    /// </summary>
    public int ModifierCount =>
        EquipmentModifiers.Count +
        SituationalModifiers.Count +
        EnvironmentModifiers.Count +
        TargetModifiers.Count;

    /// <summary>
    /// Creates a new skill context with the specified modifiers.
    /// </summary>
    internal SkillContext(
        IReadOnlyList<EquipmentModifier> equipmentModifiers,
        IReadOnlyList<SituationalModifier> situationalModifiers,
        IReadOnlyList<EnvironmentModifier> environmentModifiers,
        IReadOnlyList<TargetModifier> targetModifiers,
        IReadOnlyList<StatusEffectId> appliedStatuses)
    {
        EquipmentModifiers = equipmentModifiers;
        SituationalModifiers = situationalModifiers;
        EnvironmentModifiers = environmentModifiers;
        TargetModifiers = targetModifiers;
        AppliedStatuses = appliedStatuses;

        TotalDiceModifier = CalculateTotalDiceModifier();
        TotalDcModifier = CalculateTotalDcModifier();
    }

    /// <summary>
    /// Creates an empty skill context with no modifiers.
    /// </summary>
    public static SkillContext Empty { get; } = new SkillContext(
        Array.Empty<EquipmentModifier>(),
        Array.Empty<SituationalModifier>(),
        Array.Empty<EnvironmentModifier>(),
        Array.Empty<TargetModifier>(),
        Array.Empty<StatusEffectId>());

    /// <summary>
    /// Calculates the total dice modifier from all sources.
    /// </summary>
    private int CalculateTotalDiceModifier()
    {
        var total = 0;

        foreach (var mod in EquipmentModifiers)
            total += mod.DiceModifier;

        foreach (var mod in SituationalModifiers)
            total += mod.DiceModifier;

        foreach (var mod in EnvironmentModifiers)
            total += mod.DiceModifier;

        foreach (var mod in TargetModifiers)
            total += mod.DiceModifier;

        return total;
    }

    /// <summary>
    /// Calculates the total DC modifier from all sources.
    /// </summary>
    private int CalculateTotalDcModifier()
    {
        var total = 0;

        foreach (var mod in EquipmentModifiers)
            total += mod.DcModifier;

        foreach (var mod in SituationalModifiers)
            total += mod.DcModifier;

        foreach (var mod in EnvironmentModifiers)
            total += mod.DcModifier;

        foreach (var mod in TargetModifiers)
            total += mod.DcModifier;

        return total;
    }

    /// <summary>
    /// Gets all modifiers as a flat list for iteration.
    /// </summary>
    /// <returns>All modifiers from all categories.</returns>
    public IEnumerable<ISkillModifier> GetAllModifiers()
    {
        foreach (var mod in EquipmentModifiers)
            yield return mod;

        foreach (var mod in SituationalModifiers)
            yield return mod;

        foreach (var mod in EnvironmentModifiers)
            yield return mod;

        foreach (var mod in TargetModifiers)
            yield return mod;
    }

    /// <summary>
    /// Gets modifiers by category.
    /// </summary>
    /// <param name="category">The category to filter by.</param>
    /// <returns>Modifiers in the specified category.</returns>
    public IEnumerable<ISkillModifier> GetModifiersByCategory(ModifierCategory category)
    {
        return category switch
        {
            ModifierCategory.Equipment => EquipmentModifiers.Cast<ISkillModifier>(),
            ModifierCategory.Situational => SituationalModifiers.Cast<ISkillModifier>(),
            ModifierCategory.Environment => EnvironmentModifiers.Cast<ISkillModifier>(),
            ModifierCategory.Target => TargetModifiers.Cast<ISkillModifier>(),
            _ => Enumerable.Empty<ISkillModifier>()
        };
    }

    /// <summary>
    /// Returns a human-readable breakdown of all modifiers.
    /// </summary>
    /// <returns>Formatted modifier description string.</returns>
    /// <example>
    /// "Equipment: Tinker's Toolkit (+2d10), Magnifying Glass (+1d10)
    ///  Situational: Time Pressure (-1d10)
    ///  Environment: Stable Surface (+1d10), Dim Lighting (DC +1)
    ///  Total: +3d10, DC +1"
    /// </example>
    public string ToDescription()
    {
        if (!HasModifiers)
            return "No modifiers";

        var lines = new List<string>();

        if (EquipmentModifiers.Count > 0)
        {
            var descriptions = EquipmentModifiers.Select(m => m.ToShortDescription());
            lines.Add($"Equipment: {string.Join(", ", descriptions)}");
        }

        if (SituationalModifiers.Count > 0)
        {
            var descriptions = SituationalModifiers.Select(m => m.ToShortDescription());
            lines.Add($"Situational: {string.Join(", ", descriptions)}");
        }

        if (EnvironmentModifiers.Count > 0)
        {
            var descriptions = EnvironmentModifiers.Select(m => m.ToShortDescription());
            lines.Add($"Environment: {string.Join(", ", descriptions)}");
        }

        if (TargetModifiers.Count > 0)
        {
            var descriptions = TargetModifiers.Select(m => m.ToShortDescription());
            lines.Add($"Target: {string.Join(", ", descriptions)}");
        }

        var totalDice = TotalDiceModifier >= 0 ? $"+{TotalDiceModifier}d10" : $"{TotalDiceModifier}d10";
        var totalDc = TotalDcModifier != 0
            ? (TotalDcModifier > 0 ? $", DC +{TotalDcModifier}" : $", DC {TotalDcModifier}")
            : "";

        lines.Add($"Total: {totalDice}{totalDc}");

        return string.Join("\n", lines);
    }

    /// <summary>
    /// Returns a compact single-line summary.
    /// </summary>
    /// <example>
    /// "+3d10, DC +1 (4 modifiers)"
    /// </example>
    public override string ToString()
    {
        if (!HasModifiers)
            return "No modifiers";

        var dice = TotalDiceModifier >= 0 ? $"+{TotalDiceModifier}d10" : $"{TotalDiceModifier}d10";
        var dc = TotalDcModifier != 0
            ? (TotalDcModifier > 0 ? $", DC +{TotalDcModifier}" : $", DC {TotalDcModifier}")
            : "";

        return $"{dice}{dc} ({ModifierCount} modifier{(ModifierCount != 1 ? "s" : "")})";
    }
}
```

### 4.2 Property Summary Table

| Property | Type | Description |
|----------|------|-------------|
| `EquipmentModifiers` | `IReadOnlyList<EquipmentModifier>` | Tool/gear modifiers |
| `SituationalModifiers` | `IReadOnlyList<SituationalModifier>` | Temporary condition modifiers |
| `EnvironmentModifiers` | `IReadOnlyList<EnvironmentModifier>` | Physical condition modifiers |
| `TargetModifiers` | `IReadOnlyList<TargetModifier>` | Target-related modifiers |
| `TotalDiceModifier` | `int` | Sum of all dice pool adjustments |
| `TotalDcModifier` | `int` | Sum of all DC adjustments |
| `AppliedStatuses` | `IReadOnlyList<StatusEffectId>` | Status effects to apply |
| `HasModifiers` | `bool` | Whether any modifiers exist |
| `ModifierCount` | `int` | Total count of all modifiers |

---

## 5. EquipmentModifier Value Object

### 5.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EquipmentModifier.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a modifier from equipped tools, gear, or weapons.
/// </summary>
/// <remarks>
/// <para>
/// Equipment modifiers provide bonuses or penalties based on:
/// <list type="bullet">
///   <item><description>Tool quality (basic lockpicks vs. quality lockpicks)</description></item>
///   <item><description>Tool appropriateness (correct tool for the job)</description></item>
///   <item><description>Equipment condition (damaged equipment may give penalties)</description></item>
/// </list>
/// </para>
/// <para>
/// Some checks require specific equipment to attempt (e.g., lockpicking requires picks).
/// This is indicated by <see cref="RequiredForCheck"/>.
/// </para>
/// </remarks>
/// <param name="EquipmentId">Unique identifier of the equipment item.</param>
/// <param name="EquipmentName">Display name of the equipment.</param>
/// <param name="DiceModifier">Bonus or penalty to dice pool.</param>
/// <param name="DcModifier">Bonus or penalty to difficulty class.</param>
/// <param name="EquipmentCategory">Category of equipment (Tool, Weapon, Armor, Accessory).</param>
/// <param name="RequiredForCheck">Whether this equipment is required to attempt the check.</param>
/// <param name="Description">Optional flavor text for UI display.</param>
public readonly record struct EquipmentModifier(
    string EquipmentId,
    string EquipmentName,
    int DiceModifier,
    int DcModifier,
    EquipmentCategory EquipmentCategory,
    bool RequiredForCheck = false,
    string? Description = null) : ISkillModifier
{
    /// <summary>
    /// Gets the modifier category.
    /// </summary>
    public ModifierCategory Category => ModifierCategory.Equipment;

    /// <summary>
    /// Creates a tool modifier with dice bonus.
    /// </summary>
    /// <param name="equipmentId">Equipment identifier.</param>
    /// <param name="name">Equipment name.</param>
    /// <param name="diceBonus">Dice pool bonus.</param>
    /// <param name="required">Whether required to attempt.</param>
    /// <returns>A new equipment modifier.</returns>
    public static EquipmentModifier Tool(string equipmentId, string name, int diceBonus, bool required = false)
    {
        return new EquipmentModifier(
            equipmentId,
            name,
            diceBonus,
            DcModifier: 0,
            EquipmentCategory.Tool,
            required);
    }

    /// <summary>
    /// Returns a short description for UI display.
    /// </summary>
    /// <example>
    /// "Tinker's Toolkit (+2d10)"
    /// "Magnifying Glass (+1d10)"
    /// "Damaged Lockpicks (-1d10)"
    /// </example>
    public string ToShortDescription()
    {
        var parts = new List<string> { EquipmentName };

        if (DiceModifier != 0)
        {
            var diceStr = DiceModifier > 0 ? $"+{DiceModifier}d10" : $"{DiceModifier}d10";
            parts.Add($"({diceStr})");
        }

        if (DcModifier != 0)
        {
            var dcStr = DcModifier > 0 ? $"DC +{DcModifier}" : $"DC {DcModifier}";
            parts.Add($"({dcStr})");
        }

        if (RequiredForCheck)
            parts.Add("[Required]");

        return string.Join(" ", parts);
    }

    /// <inheritdoc/>
    public override string ToString() => ToShortDescription();
}

/// <summary>
/// Categories of equipment that can provide skill modifiers.
/// </summary>
public enum EquipmentCategory
{
    /// <summary>
    /// Tools and utility items (lockpicks, toolkit, compass).
    /// </summary>
    Tool,

    /// <summary>
    /// Weapons that may affect certain checks.
    /// </summary>
    Weapon,

    /// <summary>
    /// Armor that may affect certain checks (stealth, acrobatics).
    /// </summary>
    Armor,

    /// <summary>
    /// Accessories and miscellaneous gear.
    /// </summary>
    Accessory
}
```

---

## 6. SituationalModifier Value Object

### 6.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SituationalModifier.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a modifier from temporary or situational conditions.
/// </summary>
/// <remarks>
/// <para>
/// Situational modifiers include:
/// <list type="bullet">
///   <item><description>Time pressure (rushed vs. taking extra time)</description></item>
///   <item><description>Familiarity with the task</description></item>
///   <item><description>Distraction from combat or danger</description></item>
///   <item><description>Assistance from other characters</description></item>
///   <item><description>Fatigue or injury penalties</description></item>
/// </list>
/// </para>
/// <para>
/// Situational modifiers have a duration and may or may not stack with
/// other modifiers of the same type.
/// </para>
/// </remarks>
/// <param name="ModifierId">Unique identifier for this modifier type.</param>
/// <param name="Name">Display name for the modifier.</param>
/// <param name="DiceModifier">Bonus or penalty to dice pool.</param>
/// <param name="DcModifier">Bonus or penalty to difficulty class.</param>
/// <param name="Source">What caused this modifier (for logging/display).</param>
/// <param name="Duration">How long this modifier persists.</param>
/// <param name="IsStackable">Whether multiple instances can apply.</param>
/// <param name="Description">Optional flavor text.</param>
public readonly record struct SituationalModifier(
    string ModifierId,
    string Name,
    int DiceModifier,
    int DcModifier,
    string Source,
    ModifierDuration Duration = ModifierDuration.Instant,
    bool IsStackable = false,
    string? Description = null) : ISkillModifier
{
    /// <summary>
    /// Gets the modifier category.
    /// </summary>
    public ModifierCategory Category => ModifierCategory.Situational;

    /// <summary>
    /// Creates a time pressure modifier (rushed attempt).
    /// </summary>
    public static SituationalModifier TimePressure(string source = "Combat nearby")
    {
        return new SituationalModifier(
            "time-pressure",
            "Time Pressure",
            DiceModifier: -1,
            DcModifier: 0,
            source,
            ModifierDuration.Scene);
    }

    /// <summary>
    /// Creates a taking-time modifier (extra care).
    /// </summary>
    public static SituationalModifier TakingTime(string source = "Taking extra time")
    {
        return new SituationalModifier(
            "taking-time",
            "Taking Time",
            DiceModifier: 1,
            DcModifier: 0,
            source,
            ModifierDuration.Instant);
    }

    /// <summary>
    /// Creates a familiarity modifier.
    /// </summary>
    public static SituationalModifier Familiarity(string taskDescription)
    {
        return new SituationalModifier(
            "familiarity",
            "Familiarity",
            DiceModifier: 1,
            DcModifier: 0,
            $"Familiar with {taskDescription}",
            ModifierDuration.Persistent);
    }

    /// <summary>
    /// Creates a distraction modifier.
    /// </summary>
    public static SituationalModifier Distracted(string distractionSource)
    {
        return new SituationalModifier(
            "distracted",
            "Distracted",
            DiceModifier: -1,
            DcModifier: 0,
            distractionSource,
            ModifierDuration.Scene);
    }

    /// <summary>
    /// Creates an assistance modifier from helpers.
    /// </summary>
    /// <param name="helperCount">Number of characters assisting.</param>
    /// <param name="helperName">Name of primary helper (for description).</param>
    public static SituationalModifier Assisted(int helperCount, string helperName)
    {
        var diceBonus = Math.Min(helperCount, 3); // Cap at +3d10 from assistance
        return new SituationalModifier(
            "assisted",
            "Assisted",
            DiceModifier: diceBonus,
            DcModifier: 0,
            $"Assisted by {helperName}{(helperCount > 1 ? $" (+{helperCount - 1} others)" : "")}",
            ModifierDuration.Instant,
            IsStackable: false);
    }

    /// <summary>
    /// Creates a fatigue modifier.
    /// </summary>
    public static SituationalModifier Fatigued()
    {
        return new SituationalModifier(
            "fatigued",
            "Fatigued",
            DiceModifier: -2,
            DcModifier: 0,
            "Exhaustion",
            ModifierDuration.Persistent);
    }

    /// <summary>
    /// Returns a short description for UI display.
    /// </summary>
    public string ToShortDescription()
    {
        var parts = new List<string> { Name };

        if (DiceModifier != 0)
        {
            var diceStr = DiceModifier > 0 ? $"+{DiceModifier}d10" : $"{DiceModifier}d10";
            parts.Add($"({diceStr})");
        }

        if (DcModifier != 0)
        {
            var dcStr = DcModifier > 0 ? $"DC +{DcModifier}" : $"DC {DcModifier}";
            parts.Add($"({dcStr})");
        }

        return string.Join(" ", parts);
    }

    /// <inheritdoc/>
    public override string ToString() => ToShortDescription();
}

/// <summary>
/// Duration of a situational modifier.
/// </summary>
public enum ModifierDuration
{
    /// <summary>
    /// Applies to a single check only.
    /// </summary>
    Instant,

    /// <summary>
    /// Applies for one combat round.
    /// </summary>
    Round,

    /// <summary>
    /// Applies for the current scene or encounter.
    /// </summary>
    Scene,

    /// <summary>
    /// Applies until explicitly removed.
    /// </summary>
    Persistent
}
```

---

## 7. EnvironmentModifier Value Object

### 7.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EnvironmentModifier.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a modifier from environmental or physical conditions.
/// </summary>
/// <remarks>
/// <para>
/// Environment modifiers include:
/// <list type="bullet">
///   <item><description>Surface type (stable, wet, compromised, collapsing)</description></item>
///   <item><description>Lighting level (bright, normal, dim, dark)</description></item>
///   <item><description>Corruption tier (normal, glitched, blighted, resonance)</description></item>
///   <item><description>Weather conditions (for outdoor areas)</description></item>
/// </list>
/// </para>
/// <para>
/// Environment modifiers are typically determined by the current room or area
/// and apply to relevant skill checks automatically.
/// </para>
/// </remarks>
/// <param name="ModifierId">Unique identifier for this modifier.</param>
/// <param name="Name">Display name for the modifier.</param>
/// <param name="DiceModifier">Bonus or penalty to dice pool.</param>
/// <param name="DcModifier">Bonus or penalty to difficulty class.</param>
/// <param name="SurfaceType">Surface condition (for climbing, stealth).</param>
/// <param name="LightingLevel">Lighting condition (for visual tasks).</param>
/// <param name="CorruptionTier">Corruption level of the area.</param>
/// <param name="Description">Optional flavor text.</param>
public readonly record struct EnvironmentModifier(
    string ModifierId,
    string Name,
    int DiceModifier,
    int DcModifier,
    SurfaceType? SurfaceType = null,
    LightingLevel? LightingLevel = null,
    CorruptionTier? CorruptionTier = null,
    string? Description = null) : ISkillModifier
{
    /// <summary>
    /// Gets the modifier category.
    /// </summary>
    public ModifierCategory Category => ModifierCategory.Environment;

    /// <summary>
    /// Creates a surface modifier for climbing and movement checks.
    /// </summary>
    public static EnvironmentModifier FromSurface(SurfaceType surface)
    {
        var (dice, name) = surface switch
        {
            Domain.Enums.SurfaceType.Stable => (1, "Stable Surface"),
            Domain.Enums.SurfaceType.Wet => (-1, "Wet Surface"),
            Domain.Enums.SurfaceType.Compromised => (-2, "Compromised Surface"),
            Domain.Enums.SurfaceType.Collapsing => (-3, "Collapsing Surface"),
            _ => (0, "Normal Surface")
        };

        return new EnvironmentModifier(
            $"surface-{surface.ToString().ToLowerInvariant()}",
            name,
            DiceModifier: dice,
            DcModifier: 0,
            SurfaceType: surface);
    }

    /// <summary>
    /// Creates a lighting modifier for visual tasks.
    /// </summary>
    public static EnvironmentModifier FromLighting(LightingLevel lighting)
    {
        var (dc, name) = lighting switch
        {
            Domain.Enums.LightingLevel.Bright => (-1, "Bright Lighting"),
            Domain.Enums.LightingLevel.Normal => (0, "Normal Lighting"),
            Domain.Enums.LightingLevel.Dim => (1, "Dim Lighting"),
            Domain.Enums.LightingLevel.Dark => (2, "Dark"),
            _ => (0, "Normal Lighting")
        };

        return new EnvironmentModifier(
            $"lighting-{lighting.ToString().ToLowerInvariant()}",
            name,
            DiceModifier: 0,
            DcModifier: dc,
            LightingLevel: lighting);
    }

    /// <summary>
    /// Creates a corruption modifier for checks in corrupted areas.
    /// </summary>
    public static EnvironmentModifier FromCorruption(CorruptionTier tier)
    {
        var (dc, name) = tier switch
        {
            Domain.Enums.CorruptionTier.Normal => (0, "Normal Area"),
            Domain.Enums.CorruptionTier.Glitched => (2, "Glitched Area"),
            Domain.Enums.CorruptionTier.Blighted => (4, "Blighted Area"),
            Domain.Enums.CorruptionTier.Resonance => (6, "Resonance Zone"),
            _ => (0, "Normal Area")
        };

        // Skip if no effect
        if (dc == 0)
            return new EnvironmentModifier("corruption-normal", name, 0, 0, CorruptionTier: tier);

        return new EnvironmentModifier(
            $"corruption-{tier.ToString().ToLowerInvariant()}",
            name,
            DiceModifier: 0,
            DcModifier: dc,
            CorruptionTier: tier,
            Description: "Corruption interferes with actions");
    }

    /// <summary>
    /// Returns a short description for UI display.
    /// </summary>
    public string ToShortDescription()
    {
        var parts = new List<string> { Name };

        if (DiceModifier != 0)
        {
            var diceStr = DiceModifier > 0 ? $"+{DiceModifier}d10" : $"{DiceModifier}d10";
            parts.Add($"({diceStr})");
        }

        if (DcModifier != 0)
        {
            var dcStr = DcModifier > 0 ? $"DC +{DcModifier}" : $"DC {DcModifier}";
            parts.Add($"({dcStr})");
        }

        return string.Join(" ", parts);
    }

    /// <inheritdoc/>
    public override string ToString() => ToShortDescription();
}

/// <summary>
/// Types of surfaces for climbing and movement checks.
/// </summary>
public enum SurfaceType
{
    /// <summary>
    /// Stable, well-maintained surface. +1d10 to climbing.
    /// </summary>
    Stable,

    /// <summary>
    /// Normal surface with no special conditions.
    /// </summary>
    Normal,

    /// <summary>
    /// Wet or slippery surface. -1d10 to climbing.
    /// </summary>
    Wet,

    /// <summary>
    /// Damaged or unstable surface. -2d10 to climbing.
    /// </summary>
    Compromised,

    /// <summary>
    /// Actively falling apart. -3d10 to climbing.
    /// </summary>
    Collapsing
}

/// <summary>
/// Lighting conditions affecting visual tasks.
/// </summary>
public enum LightingLevel
{
    /// <summary>
    /// Excellent visibility. DC -1 for visual tasks.
    /// </summary>
    Bright,

    /// <summary>
    /// Standard lighting. No modifier.
    /// </summary>
    Normal,

    /// <summary>
    /// Reduced visibility. DC +1 for visual tasks.
    /// </summary>
    Dim,

    /// <summary>
    /// Very low or no light. DC +2 for visual tasks.
    /// </summary>
    Dark
}

/// <summary>
/// Corruption tiers affecting all checks in an area.
/// </summary>
public enum CorruptionTier
{
    /// <summary>
    /// No corruption. No modifier.
    /// </summary>
    Normal,

    /// <summary>
    /// Mild corruption. DC +2 to all checks.
    /// </summary>
    Glitched,

    /// <summary>
    /// Significant corruption. DC +4 to all checks.
    /// </summary>
    Blighted,

    /// <summary>
    /// Severe corruption. DC +6 to all checks.
    /// </summary>
    Resonance
}
```

---

## 8. TargetModifier Value Object

### 8.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TargetModifier.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a modifier based on the target of a skill check.
/// </summary>
/// <remarks>
/// <para>
/// Target modifiers include:
/// <list type="bullet">
///   <item><description>Disposition (friendly to hostile)</description></item>
///   <item><description>Suspicion level (for deception checks)</description></item>
///   <item><description>Resistance level (target's opposed ability)</description></item>
///   <item><description>Relative strength (for intimidation)</description></item>
/// </list>
/// </para>
/// <para>
/// Target modifiers are primarily used for social skill checks (Rhetoric)
/// but may also apply to some combat maneuvers.
/// </para>
/// </remarks>
/// <param name="ModifierId">Unique identifier for this modifier.</param>
/// <param name="Name">Display name for the modifier.</param>
/// <param name="DiceModifier">Bonus or penalty to dice pool.</param>
/// <param name="DcModifier">Bonus or penalty to difficulty class.</param>
/// <param name="TargetId">Optional ID of the target NPC or entity.</param>
/// <param name="Disposition">Target's disposition toward the actor.</param>
/// <param name="SuspicionLevel">Target's suspicion level (0-10).</param>
/// <param name="ResistanceLevel">Target's resistance rating.</param>
/// <param name="Description">Optional flavor text.</param>
public readonly record struct TargetModifier(
    string ModifierId,
    string Name,
    int DiceModifier,
    int DcModifier,
    string? TargetId = null,
    Disposition? Disposition = null,
    int? SuspicionLevel = null,
    int? ResistanceLevel = null,
    string? Description = null) : ISkillModifier
{
    /// <summary>
    /// Gets the modifier category.
    /// </summary>
    public ModifierCategory Category => ModifierCategory.Target;

    /// <summary>
    /// Creates a disposition modifier for persuasion and social checks.
    /// </summary>
    public static TargetModifier FromDisposition(Disposition disposition, string? targetId = null)
    {
        var (dice, name) = disposition switch
        {
            Domain.Enums.Disposition.Friendly => (2, "Friendly Disposition"),
            Domain.Enums.Disposition.Neutral => (0, "Neutral Disposition"),
            Domain.Enums.Disposition.Suspicious => (-2, "Suspicious Disposition"),
            Domain.Enums.Disposition.Hostile => (-2, "Hostile Disposition"),
            _ => (0, "Unknown Disposition")
        };

        return new TargetModifier(
            $"disposition-{disposition.ToString().ToLowerInvariant()}",
            name,
            DiceModifier: dice,
            DcModifier: 0,
            TargetId: targetId,
            Disposition: disposition);
    }

    /// <summary>
    /// Creates a suspicion modifier for deception checks.
    /// </summary>
    /// <param name="level">Suspicion level (0-10, where 0 = trusting, 10 = extremely suspicious).</param>
    public static TargetModifier FromSuspicion(int level, string? targetId = null)
    {
        var clampedLevel = Math.Clamp(level, 0, 10);

        // Suspicion adds to DC: level 0-3 = +0, 4-6 = +2, 7-9 = +4, 10 = +6
        var dcMod = clampedLevel switch
        {
            <= 3 => 0,
            <= 6 => 2,
            <= 9 => 4,
            _ => 6
        };

        var name = clampedLevel switch
        {
            <= 3 => "Trusting Target",
            <= 6 => "Wary Target",
            <= 9 => "Suspicious Target",
            _ => "Extremely Suspicious"
        };

        return new TargetModifier(
            $"suspicion-{clampedLevel}",
            name,
            DiceModifier: 0,
            DcModifier: dcMod,
            TargetId: targetId,
            SuspicionLevel: clampedLevel);
    }

    /// <summary>
    /// Creates a relative strength modifier for intimidation checks.
    /// </summary>
    /// <param name="targetIsStronger">Whether the target appears stronger than the actor.</param>
    public static TargetModifier FromRelativeStrength(bool targetIsStronger, string? targetId = null)
    {
        return new TargetModifier(
            targetIsStronger ? "stronger-target" : "weaker-target",
            targetIsStronger ? "Stronger Target" : "Weaker Target",
            DiceModifier: targetIsStronger ? -1 : 1,
            DcModifier: 0,
            TargetId: targetId,
            Description: targetIsStronger ? "Target is more imposing" : "Target seems weaker");
    }

    /// <summary>
    /// Creates a resistance modifier based on target's opposed attribute.
    /// </summary>
    /// <param name="resistanceValue">Target's relevant attribute or resistance value.</param>
    public static TargetModifier FromResistance(int resistanceValue, string? targetId = null)
    {
        // High resistance adds to DC
        var dcMod = resistanceValue switch
        {
            <= 1 => -1,   // Very low resistance
            <= 3 => 0,    // Normal resistance
            <= 5 => 1,    // Above average
            <= 7 => 2,    // High resistance
            _ => 3        // Very high resistance
        };

        return new TargetModifier(
            $"resistance-{resistanceValue}",
            $"Target Resistance ({resistanceValue})",
            DiceModifier: 0,
            DcModifier: dcMod,
            TargetId: targetId,
            ResistanceLevel: resistanceValue);
    }

    /// <summary>
    /// Returns a short description for UI display.
    /// </summary>
    public string ToShortDescription()
    {
        var parts = new List<string> { Name };

        if (DiceModifier != 0)
        {
            var diceStr = DiceModifier > 0 ? $"+{DiceModifier}d10" : $"{DiceModifier}d10";
            parts.Add($"({diceStr})");
        }

        if (DcModifier != 0)
        {
            var dcStr = DcModifier > 0 ? $"DC +{DcModifier}" : $"DC {DcModifier}";
            parts.Add($"({dcStr})");
        }

        return string.Join(" ", parts);
    }

    /// <inheritdoc/>
    public override string ToString() => ToShortDescription();
}

/// <summary>
/// NPC disposition toward the player character.
/// </summary>
public enum Disposition
{
    /// <summary>
    /// Friendly and receptive. +2d10 to persuasion.
    /// </summary>
    Friendly,

    /// <summary>
    /// Neutral, no strong feelings. No modifier.
    /// </summary>
    Neutral,

    /// <summary>
    /// Wary or distrustful. -2d10 to persuasion.
    /// </summary>
    Suspicious,

    /// <summary>
    /// Actively opposed. -2d10 to persuasion, some approaches impossible.
    /// </summary>
    Hostile
}
```

---

## 9. ModifierCategory Enum

### 9.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/ModifierCategory.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categories of skill check modifiers.
/// </summary>
/// <remarks>
/// <para>
/// Used to classify and organize modifiers within a <see cref="SkillContext"/>.
/// Each category has different sources and persistence characteristics:
/// <list type="bullet">
///   <item><description>Equipment: From inventory items, persists until unequipped</description></item>
///   <item><description>Situational: From temporary conditions, varies in duration</description></item>
///   <item><description>Environment: From physical surroundings, changes with location</description></item>
///   <item><description>Target: From target characteristics, specific to interaction</description></item>
/// </list>
/// </para>
/// </remarks>
public enum ModifierCategory
{
    /// <summary>
    /// Modifiers from equipped tools, gear, and weapons.
    /// </summary>
    /// <remarks>
    /// Examples: Tinker's Toolkit, Climbing Gear, Lockpicks
    /// </remarks>
    Equipment = 0,

    /// <summary>
    /// Modifiers from temporary or situational conditions.
    /// </summary>
    /// <remarks>
    /// Examples: Time Pressure, Familiarity, Assistance, Fatigue
    /// </remarks>
    Situational = 1,

    /// <summary>
    /// Modifiers from environmental or physical conditions.
    /// </summary>
    /// <remarks>
    /// Examples: Surface Type, Lighting Level, Corruption Tier
    /// </remarks>
    Environment = 2,

    /// <summary>
    /// Modifiers based on the target of the skill check.
    /// </summary>
    /// <remarks>
    /// Examples: Disposition, Suspicion Level, Relative Strength
    /// </remarks>
    Target = 3
}
```

---

## 10. ISkillContextBuilder Interface

### 10.1 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/ISkillContextBuilder.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Builder interface for constructing <see cref="SkillContext"/> objects.
/// </summary>
/// <remarks>
/// <para>
/// Provides a fluent API for adding modifiers from various sources:
/// <list type="bullet">
///   <item><description>Equipment modifiers via <see cref="WithEquipment"/></description></item>
///   <item><description>Situational modifiers via <see cref="WithSituation"/></description></item>
///   <item><description>Environment modifiers via <see cref="WithEnvironment"/></description></item>
///   <item><description>Target modifiers via <see cref="WithTarget"/></description></item>
/// </list>
/// </para>
/// <para>
/// Call <see cref="Build"/> to create the immutable <see cref="SkillContext"/>.
/// </para>
/// </remarks>
public interface ISkillContextBuilder
{
    /// <summary>
    /// Adds an equipment modifier.
    /// </summary>
    /// <param name="equipmentId">Equipment item identifier.</param>
    /// <param name="name">Equipment display name.</param>
    /// <param name="diceModifier">Dice pool bonus/penalty.</param>
    /// <param name="dcModifier">DC bonus/penalty.</param>
    /// <param name="category">Equipment category.</param>
    /// <param name="required">Whether required to attempt check.</param>
    /// <returns>The builder for chaining.</returns>
    ISkillContextBuilder WithEquipment(
        string equipmentId,
        string name,
        int diceModifier = 0,
        int dcModifier = 0,
        EquipmentCategory category = EquipmentCategory.Tool,
        bool required = false);

    /// <summary>
    /// Adds an equipment modifier from an existing value object.
    /// </summary>
    ISkillContextBuilder WithEquipment(EquipmentModifier modifier);

    /// <summary>
    /// Adds a situational modifier.
    /// </summary>
    /// <param name="modifierId">Modifier identifier.</param>
    /// <param name="name">Display name.</param>
    /// <param name="diceModifier">Dice pool bonus/penalty.</param>
    /// <param name="dcModifier">DC bonus/penalty.</param>
    /// <param name="source">Source of the modifier.</param>
    /// <param name="duration">How long modifier persists.</param>
    /// <returns>The builder for chaining.</returns>
    ISkillContextBuilder WithSituation(
        string modifierId,
        string name,
        int diceModifier = 0,
        int dcModifier = 0,
        string? source = null,
        ModifierDuration duration = ModifierDuration.Instant);

    /// <summary>
    /// Adds a situational modifier from an existing value object.
    /// </summary>
    ISkillContextBuilder WithSituation(SituationalModifier modifier);

    /// <summary>
    /// Adds environment modifiers for surface and lighting.
    /// </summary>
    /// <param name="surface">Surface type (for climbing, stealth).</param>
    /// <param name="lighting">Lighting level (for visual tasks).</param>
    /// <returns>The builder for chaining.</returns>
    ISkillContextBuilder WithEnvironment(
        SurfaceType? surface = null,
        LightingLevel? lighting = null);

    /// <summary>
    /// Adds a corruption modifier.
    /// </summary>
    /// <param name="tier">Corruption tier of the area.</param>
    /// <returns>The builder for chaining.</returns>
    ISkillContextBuilder WithCorruption(CorruptionTier tier);

    /// <summary>
    /// Adds an environment modifier from an existing value object.
    /// </summary>
    ISkillContextBuilder WithEnvironment(EnvironmentModifier modifier);

    /// <summary>
    /// Adds a target disposition modifier.
    /// </summary>
    /// <param name="disposition">Target's disposition.</param>
    /// <param name="targetId">Optional target ID.</param>
    /// <returns>The builder for chaining.</returns>
    ISkillContextBuilder WithTargetDisposition(Disposition disposition, string? targetId = null);

    /// <summary>
    /// Adds a target suspicion modifier.
    /// </summary>
    /// <param name="suspicionLevel">Suspicion level (0-10).</param>
    /// <param name="targetId">Optional target ID.</param>
    /// <returns>The builder for chaining.</returns>
    ISkillContextBuilder WithTargetSuspicion(int suspicionLevel, string? targetId = null);

    /// <summary>
    /// Adds a target modifier from an existing value object.
    /// </summary>
    ISkillContextBuilder WithTarget(TargetModifier modifier);

    /// <summary>
    /// Adds a status effect to be applied based on check outcome.
    /// </summary>
    /// <param name="statusId">Status effect identifier.</param>
    /// <returns>The builder for chaining.</returns>
    ISkillContextBuilder WithAppliedStatus(StatusEffectId statusId);

    /// <summary>
    /// Builds the immutable skill context.
    /// </summary>
    /// <returns>A new <see cref="SkillContext"/> with all added modifiers.</returns>
    SkillContext Build();

    /// <summary>
    /// Resets the builder to its initial empty state.
    /// </summary>
    /// <returns>The builder for chaining.</returns>
    ISkillContextBuilder Reset();
}
```

---

## 11. SkillContextBuilder Implementation

### 11.1 Service Definition

**File:** `src/Core/RuneAndRust.Application/Services/SkillContextBuilder.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Fluent builder for constructing <see cref="SkillContext"/> objects.
/// </summary>
/// <remarks>
/// <para>
/// Provides a chainable API for adding modifiers from various sources.
/// The builder is reusable after calling <see cref="Build"/> or <see cref="Reset"/>.
/// </para>
/// <para>
/// Example usage:
/// <code>
/// var context = builder
///     .WithEquipment("toolkit", "Tinker's Toolkit", diceModifier: 2)
///     .WithSituation(SituationalModifier.TimePressure("Combat"))
///     .WithEnvironment(SurfaceType.Stable, LightingLevel.Dim)
///     .Build();
/// </code>
/// </para>
/// </remarks>
public class SkillContextBuilder : ISkillContextBuilder
{
    private readonly ILogger<SkillContextBuilder> _logger;
    private readonly List<EquipmentModifier> _equipmentModifiers = new();
    private readonly List<SituationalModifier> _situationalModifiers = new();
    private readonly List<EnvironmentModifier> _environmentModifiers = new();
    private readonly List<TargetModifier> _targetModifiers = new();
    private readonly List<StatusEffectId> _appliedStatuses = new();

    /// <summary>
    /// Creates a new skill context builder.
    /// </summary>
    public SkillContextBuilder(ILogger<SkillContextBuilder> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithEquipment(
        string equipmentId,
        string name,
        int diceModifier = 0,
        int dcModifier = 0,
        EquipmentCategory category = EquipmentCategory.Tool,
        bool required = false)
    {
        var modifier = new EquipmentModifier(
            equipmentId, name, diceModifier, dcModifier, category, required);

        return WithEquipment(modifier);
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithEquipment(EquipmentModifier modifier)
    {
        _equipmentModifiers.Add(modifier);
        _logger.LogDebug("Added equipment modifier: {Modifier}", modifier.ToShortDescription());
        return this;
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithSituation(
        string modifierId,
        string name,
        int diceModifier = 0,
        int dcModifier = 0,
        string? source = null,
        ModifierDuration duration = ModifierDuration.Instant)
    {
        var modifier = new SituationalModifier(
            modifierId, name, diceModifier, dcModifier,
            source ?? name, duration);

        return WithSituation(modifier);
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithSituation(SituationalModifier modifier)
    {
        // Check for stackability
        if (!modifier.IsStackable)
        {
            var existing = _situationalModifiers.FindIndex(m => m.ModifierId == modifier.ModifierId);
            if (existing >= 0)
            {
                _logger.LogDebug(
                    "Non-stackable modifier {Id} already exists, skipping duplicate",
                    modifier.ModifierId);
                return this;
            }
        }

        _situationalModifiers.Add(modifier);
        _logger.LogDebug("Added situational modifier: {Modifier}", modifier.ToShortDescription());
        return this;
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithEnvironment(
        SurfaceType? surface = null,
        LightingLevel? lighting = null)
    {
        if (surface.HasValue && surface != SurfaceType.Normal)
        {
            WithEnvironment(EnvironmentModifier.FromSurface(surface.Value));
        }

        if (lighting.HasValue && lighting != LightingLevel.Normal)
        {
            WithEnvironment(EnvironmentModifier.FromLighting(lighting.Value));
        }

        return this;
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithCorruption(CorruptionTier tier)
    {
        if (tier != CorruptionTier.Normal)
        {
            WithEnvironment(EnvironmentModifier.FromCorruption(tier));
        }

        return this;
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithEnvironment(EnvironmentModifier modifier)
    {
        // Environment modifiers of the same type should not stack
        var existingIndex = _environmentModifiers.FindIndex(m =>
            m.SurfaceType == modifier.SurfaceType && modifier.SurfaceType.HasValue ||
            m.LightingLevel == modifier.LightingLevel && modifier.LightingLevel.HasValue ||
            m.CorruptionTier == modifier.CorruptionTier && modifier.CorruptionTier.HasValue);

        if (existingIndex >= 0)
        {
            _logger.LogDebug(
                "Replacing existing environment modifier with: {Modifier}",
                modifier.ToShortDescription());
            _environmentModifiers[existingIndex] = modifier;
        }
        else
        {
            _environmentModifiers.Add(modifier);
            _logger.LogDebug("Added environment modifier: {Modifier}", modifier.ToShortDescription());
        }

        return this;
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithTargetDisposition(Disposition disposition, string? targetId = null)
    {
        return WithTarget(TargetModifier.FromDisposition(disposition, targetId));
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithTargetSuspicion(int suspicionLevel, string? targetId = null)
    {
        return WithTarget(TargetModifier.FromSuspicion(suspicionLevel, targetId));
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithTarget(TargetModifier modifier)
    {
        _targetModifiers.Add(modifier);
        _logger.LogDebug("Added target modifier: {Modifier}", modifier.ToShortDescription());
        return this;
    }

    /// <inheritdoc/>
    public ISkillContextBuilder WithAppliedStatus(StatusEffectId statusId)
    {
        if (!_appliedStatuses.Contains(statusId))
        {
            _appliedStatuses.Add(statusId);
            _logger.LogDebug("Added status to apply: {Status}", statusId);
        }

        return this;
    }

    /// <inheritdoc/>
    public SkillContext Build()
    {
        var context = new SkillContext(
            _equipmentModifiers.ToList().AsReadOnly(),
            _situationalModifiers.ToList().AsReadOnly(),
            _environmentModifiers.ToList().AsReadOnly(),
            _targetModifiers.ToList().AsReadOnly(),
            _appliedStatuses.ToList().AsReadOnly());

        _logger.LogDebug(
            "Built SkillContext: {Dice} dice, {Dc} DC ({Count} modifiers)",
            context.TotalDiceModifier,
            context.TotalDcModifier,
            context.ModifierCount);

        // Auto-reset after build for reuse
        Reset();

        return context;
    }

    /// <inheritdoc/>
    public ISkillContextBuilder Reset()
    {
        _equipmentModifiers.Clear();
        _situationalModifiers.Clear();
        _environmentModifiers.Clear();
        _targetModifiers.Clear();
        _appliedStatuses.Clear();

        return this;
    }
}
```

---

## 12. SkillCheckService Integration

### 12.1 Updated SkillCheckService

The `SkillCheckService` must be modified to accept `SkillContext`. Key changes:

**File:** `src/Core/RuneAndRust.Application/Services/SkillCheckService.cs`

```csharp
// Add new method overload that accepts SkillContext

/// <summary>
/// Performs a skill check with full context modifiers.
/// </summary>
/// <param name="player">The player making the check.</param>
/// <param name="skillId">The skill identifier.</param>
/// <param name="difficultyClass">Base difficulty class.</param>
/// <param name="difficultyName">Difficulty name for display.</param>
/// <param name="context">Skill context with all modifiers.</param>
/// <param name="advantageType">Advantage or disadvantage.</param>
/// <returns>The complete skill check result.</returns>
public SkillCheckResult PerformCheckWithContext(
    Player player,
    string skillId,
    int difficultyClass,
    string difficultyName,
    SkillContext context,
    AdvantageType advantageType = AdvantageType.Normal)
{
    ArgumentNullException.ThrowIfNull(player);
    ArgumentException.ThrowIfNullOrWhiteSpace(skillId, nameof(skillId));
    ArgumentNullException.ThrowIfNull(context);

    if (difficultyClass < 0)
        throw new ArgumentOutOfRangeException(nameof(difficultyClass), "Difficulty class must be non-negative");

    _logger.LogDebug(
        "Performing skill check with context: Player={Player}, Skill={Skill}, BaseDC={DC}, Context={Context}",
        player.Name, skillId, difficultyClass, context);

    var skill = _configProvider.GetSkillById(skillId)
        ?? throw new ArgumentException($"Unknown skill: {skillId}", nameof(skillId));

    var attributeBonus = CalculateAttributeBonus(player, skill);
    var otherBonus = CalculateOtherBonus(player, skill, 0);

    // Apply context modifiers
    var contextDiceBonus = context.TotalDiceModifier;
    var contextDcMod = context.TotalDcModifier;

    // Build dice pool: base pool + attribute bonus + other bonuses + context
    var baseDiceCount = GetBaseDiceCount(skill);
    var totalDice = baseDiceCount + attributeBonus + otherBonus + contextDiceBonus;
    var finalPoolSize = Math.Max(1, totalDice);  // Minimum 1 die
    var dicePool = new DicePool(finalPoolSize, DiceType.D10);

    // Apply DC modification
    var finalDc = Math.Max(0, difficultyClass + contextDcMod);
    var finalDcName = contextDcMod != 0
        ? $"{difficultyName} (modified)"
        : difficultyName;

    _logger.LogDebug(
        "Final check parameters: Pool={Pool} (base {Base} + attr {Attr} + context {Context}), DC={DC} (base {BaseDC} + context {ContextDC})",
        finalPoolSize, baseDiceCount, attributeBonus, contextDiceBonus,
        finalDc, difficultyClass, contextDcMod);

    var rollResult = _diceService.Roll(dicePool, advantageType);

    var result = new SkillCheckResult(
        skill.Id,
        skill.Name,
        rollResult,
        attributeBonus,
        otherBonus + contextDiceBonus,  // Include context bonus in "other"
        finalDc,
        finalDcName);

    LogCheckResult(result, context);
    return result;
}

/// <summary>
/// Logs the check result with context information.
/// </summary>
private void LogCheckResult(SkillCheckResult result, SkillContext? context)
{
    var level = result.IsCritical ? LogLevel.Information : LogLevel.Debug;

    _logger.Log(level,
        "Skill check complete: Skill={Skill} Net={Net} ({Successes}S-{Botches}B) DC={DC} Outcome={Outcome} Margin={Margin}",
        result.SkillName,
        result.NetSuccesses,
        result.DiceResult.TotalSuccesses,
        result.DiceResult.TotalBotches,
        result.DifficultyClass,
        result.Outcome,
        result.Margin);

    if (context?.HasModifiers == true)
    {
        _logger.LogDebug("Applied modifiers:\n{Modifiers}", context.ToDescription());
    }

    if (result.IsFumble)
        _logger.LogInformation("FUMBLE on {Skill}!", result.SkillName);
    else if (result.IsCriticalSuccess)
        _logger.LogInformation("CRITICAL SUCCESS on {Skill}!", result.SkillName);
}
```

### 12.2 Method Signature Changes

| Method | Before | After |
|--------|--------|-------|
| `PerformCheckWithDC` | `additionalBonusDice` parameter | Preserved for backward compatibility |
| `PerformCheckWithContext` | N/A (new) | Accepts `SkillContext` parameter |

### 12.3 Backward Compatibility

The existing `PerformCheckWithDC` method with `additionalBonusDice` parameter is preserved. The new `PerformCheckWithContext` method provides the full context-aware functionality.

---

## 13. Data Model Changes

### 13.1 New Types Summary

| Type | Layer | File | Description |
|------|-------|------|-------------|
| `SkillContext` | Domain | `ValueObjects/SkillContext.cs` | Modifier container |
| `EquipmentModifier` | Domain | `ValueObjects/EquipmentModifier.cs` | Equipment bonuses |
| `SituationalModifier` | Domain | `ValueObjects/SituationalModifier.cs` | Situational factors |
| `EnvironmentModifier` | Domain | `ValueObjects/EnvironmentModifier.cs` | Environment factors |
| `TargetModifier` | Domain | `ValueObjects/TargetModifier.cs` | Target factors |
| `ModifierCategory` | Domain | `Enums/ModifierCategory.cs` | Modifier classification |
| `EquipmentCategory` | Domain | `Enums/EquipmentCategory.cs` | Equipment types |
| `SurfaceType` | Domain | `Enums/SurfaceType.cs` | Surface conditions |
| `LightingLevel` | Domain | `Enums/LightingLevel.cs` | Lighting conditions |
| `ModifierDuration` | Domain | `Enums/ModifierDuration.cs` | Modifier persistence |
| `Disposition` | Domain | `Enums/Disposition.cs` | NPC disposition |
| `ISkillModifier` | Domain | `Interfaces/ISkillModifier.cs` | Base modifier interface |
| `ISkillContextBuilder` | Application | `Interfaces/ISkillContextBuilder.cs` | Builder interface |
| `SkillContextBuilder` | Application | `Services/SkillContextBuilder.cs` | Builder implementation |

### 13.2 Modified Types Summary

| Type | Layer | File | Changes |
|------|-------|------|---------|
| `SkillCheckService` | Application | `Services/SkillCheckService.cs` | Added `PerformCheckWithContext` method |

### 13.3 ISkillModifier Base Interface

**File:** `src/Core/RuneAndRust.Domain/Interfaces/ISkillModifier.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.Interfaces;

/// <summary>
/// Base interface for all skill check modifiers.
/// </summary>
public interface ISkillModifier
{
    /// <summary>
    /// Bonus or penalty to dice pool.
    /// </summary>
    int DiceModifier { get; }

    /// <summary>
    /// Bonus or penalty to difficulty class.
    /// </summary>
    int DcModifier { get; }

    /// <summary>
    /// Category of this modifier.
    /// </summary>
    ModifierCategory Category { get; }

    /// <summary>
    /// Returns a short description for UI display.
    /// </summary>
    string ToShortDescription();
}
```

---

## 14. Configuration

### 14.1 equipment-modifiers.json

**File:** `config/equipment-modifiers.json`

```json
{
  "$schema": "./schemas/equipment-modifiers.schema.json",
  "equipmentModifiers": [
    {
      "equipmentId": "tinkers-toolkit",
      "name": "Tinker's Toolkit",
      "diceModifier": 2,
      "dcModifier": 0,
      "category": "Tool",
      "skills": ["system-bypass", "lockpicking", "trap-disarm"],
      "description": "A comprehensive toolkit for bypassing mechanical and electronic systems."
    },
    {
      "equipmentId": "lockpicks-basic",
      "name": "Basic Lockpicks",
      "diceModifier": 0,
      "dcModifier": 0,
      "category": "Tool",
      "skills": ["lockpicking"],
      "requiredForCheck": true,
      "description": "Simple lockpicking tools. Required for lockpicking attempts."
    },
    {
      "equipmentId": "lockpicks-quality",
      "name": "Quality Lockpicks",
      "diceModifier": 1,
      "dcModifier": 0,
      "category": "Tool",
      "skills": ["lockpicking"],
      "requiredForCheck": true,
      "description": "Well-crafted lockpicks that improve success chances."
    },
    {
      "equipmentId": "climbing-gear",
      "name": "Climbing Gear",
      "diceModifier": 1,
      "dcModifier": 0,
      "category": "Tool",
      "skills": ["acrobatics-climb"],
      "description": "Ropes, pitons, and carabiners for safer climbing."
    },
    {
      "equipmentId": "magnifying-glass",
      "name": "Magnifying Glass",
      "diceModifier": 1,
      "dcModifier": 0,
      "category": "Tool",
      "skills": ["examination", "perception"],
      "description": "Aids in detailed examination of small objects."
    },
    {
      "equipmentId": "compass-working",
      "name": "Working Compass",
      "diceModifier": 1,
      "dcModifier": 0,
      "category": "Tool",
      "skills": ["navigation"],
      "description": "A functional compass that aids navigation."
    },
    {
      "equipmentId": "compass-damaged",
      "name": "Damaged Compass",
      "diceModifier": -1,
      "dcModifier": 0,
      "category": "Tool",
      "skills": ["navigation"],
      "description": "A malfunctioning compass that may mislead."
    }
  ]
}
```

### 14.2 Configuration Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `equipmentId` | string | Yes | Unique identifier |
| `name` | string | Yes | Display name |
| `diceModifier` | int | Yes | Dice pool bonus/penalty |
| `dcModifier` | int | Yes | DC bonus/penalty |
| `category` | string | Yes | Equipment category |
| `skills` | string[] | Yes | Applicable skill IDs |
| `requiredForCheck` | bool | No | Whether required to attempt |
| `description` | string | No | Flavor text |

---

## 15. Commands

### 15.1 No New Commands

v0.15.1a does not introduce new user commands. The `check` command will automatically use empty context for backward compatibility.

### 15.2 Future Command Enhancements (Deferred)

Future versions may add context display to skill check output:
```
> check lockpicking moderate
Lockpicking: 4 net (5S - 1B) vs DC 3 (Moderate, modified) → Full Success [margin: +1]
Modifiers: Tinker's Toolkit (+2d10), Dim Lighting (DC +1)
```

This is **out of scope** for v0.15.1a.

---

## 16. User-Facing Changes

### 16.1 No Visible Changes

v0.15.1a operates primarily as infrastructure. Users will not see immediate changes unless calling code explicitly provides `SkillContext`.

### 16.2 Future Integration Points

Once integrated with game systems (v0.15.2+), users will see:
- Equipment bonuses reflected in skill checks
- Environmental conditions affecting difficulty
- NPC disposition influencing social checks

---

## 17. Logging Specifications

### 17.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `SkillContextBuilder` | Debug | Modifier added, context built |
| `SkillCheckService` | Debug | Check parameters with context |
| `SkillCheckService` | Information | Critical/fumble results |

### 17.2 Log Message Formats

```
[Debug] Added equipment modifier: Tinker's Toolkit (+2d10)
[Debug] Added situational modifier: Time Pressure (-1d10)
[Debug] Added environment modifier: Stable Surface (+1d10)
[Debug] Built SkillContext: +3 dice, +1 DC (4 modifiers)
[Debug] Performing skill check with context: Player=Hero, Skill=lockpicking, BaseDC=2, Context=+3d10, DC +1 (4 modifiers)
[Debug] Final check parameters: Pool=7 (base 3 + attr 1 + context 3), DC=3 (base 2 + context 1)
[Debug] Applied modifiers:
Equipment: Tinker's Toolkit (+2d10), Magnifying Glass (+1d10)
Situational: Time Pressure (-1d10)
Environment: Stable Surface (+1d10), Dim Lighting (DC +1)
Total: +3d10, DC +1
```

---

## 18. Unit Testing Requirements

### 18.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| SkillContext calculation | 2 |
| Equipment modifiers | 1 |
| Situational modifiers | 1 |
| Environment modifiers | 1 |
| Target modifiers | 1 |
| Builder pattern | 1 |
| Description formatting | 1 |
| **Total** | **~8** |

### 18.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/SkillContextTests.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class SkillContextTests
{
    [Test]
    public void TotalDiceModifier_SumsAllCategories()
    {
        // Arrange
        var equipment = new List<EquipmentModifier>
        {
            EquipmentModifier.Tool("toolkit", "Toolkit", diceBonus: 2)
        };
        var situational = new List<SituationalModifier>
        {
            SituationalModifier.TimePressure()  // -1d10
        };
        var environment = new List<EnvironmentModifier>
        {
            EnvironmentModifier.FromSurface(SurfaceType.Stable)  // +1d10
        };
        var target = new List<TargetModifier>();

        // Act
        var context = new SkillContext(
            equipment, situational, environment, target,
            Array.Empty<StatusEffectId>());

        // Assert: 2 - 1 + 1 = 2
        Assert.That(context.TotalDiceModifier, Is.EqualTo(2));
    }

    [Test]
    public void TotalDcModifier_SumsAllCategories()
    {
        // Arrange
        var equipment = new List<EquipmentModifier>();
        var situational = new List<SituationalModifier>();
        var environment = new List<EnvironmentModifier>
        {
            EnvironmentModifier.FromLighting(LightingLevel.Dim),       // DC +1
            EnvironmentModifier.FromCorruption(CorruptionTier.Glitched) // DC +2
        };
        var target = new List<TargetModifier>
        {
            TargetModifier.FromSuspicion(5)  // DC +2
        };

        // Act
        var context = new SkillContext(
            equipment, situational, environment, target,
            Array.Empty<StatusEffectId>());

        // Assert: 1 + 2 + 2 = 5
        Assert.That(context.TotalDcModifier, Is.EqualTo(5));
    }

    [Test]
    public void Empty_HasNoModifiers()
    {
        // Act
        var context = SkillContext.Empty;

        // Assert
        Assert.That(context.HasModifiers, Is.False);
        Assert.That(context.TotalDiceModifier, Is.EqualTo(0));
        Assert.That(context.TotalDcModifier, Is.EqualTo(0));
    }

    [Test]
    public void EquipmentModifier_ToShortDescription_FormatsCorrectly()
    {
        // Arrange
        var modifier = EquipmentModifier.Tool("toolkit", "Tinker's Toolkit", diceBonus: 2);

        // Act
        var description = modifier.ToShortDescription();

        // Assert
        Assert.That(description, Does.Contain("Tinker's Toolkit"));
        Assert.That(description, Does.Contain("+2d10"));
    }

    [Test]
    public void SituationalModifier_NonStackable_PreventsDoubles()
    {
        // This tests the builder behavior for non-stackable modifiers
        var mod1 = SituationalModifier.TimePressure("Source 1");
        var mod2 = SituationalModifier.TimePressure("Source 2");

        // Both have same ModifierId and IsStackable = false
        Assert.That(mod1.ModifierId, Is.EqualTo(mod2.ModifierId));
        Assert.That(mod1.IsStackable, Is.False);
    }

    [Test]
    public void EnvironmentModifier_FromSurface_CreatesCorrectModifier()
    {
        // Act
        var stable = EnvironmentModifier.FromSurface(SurfaceType.Stable);
        var compromised = EnvironmentModifier.FromSurface(SurfaceType.Compromised);

        // Assert
        Assert.That(stable.DiceModifier, Is.EqualTo(1));
        Assert.That(compromised.DiceModifier, Is.EqualTo(-2));
    }

    [Test]
    public void TargetModifier_FromDisposition_CreatesCorrectModifier()
    {
        // Act
        var friendly = TargetModifier.FromDisposition(Disposition.Friendly);
        var hostile = TargetModifier.FromDisposition(Disposition.Hostile);

        // Assert
        Assert.That(friendly.DiceModifier, Is.EqualTo(2));
        Assert.That(hostile.DiceModifier, Is.EqualTo(-2));
    }

    [Test]
    public void ToDescription_FormatsAllModifiers()
    {
        // Arrange
        var equipment = new List<EquipmentModifier>
        {
            EquipmentModifier.Tool("toolkit", "Toolkit", diceBonus: 2)
        };
        var situational = new List<SituationalModifier>();
        var environment = new List<EnvironmentModifier>
        {
            EnvironmentModifier.FromLighting(LightingLevel.Dim)
        };
        var target = new List<TargetModifier>();

        var context = new SkillContext(
            equipment, situational, environment, target,
            Array.Empty<StatusEffectId>());

        // Act
        var description = context.ToDescription();

        // Assert
        Assert.That(description, Does.Contain("Equipment:"));
        Assert.That(description, Does.Contain("Toolkit"));
        Assert.That(description, Does.Contain("Environment:"));
        Assert.That(description, Does.Contain("Dim Lighting"));
        Assert.That(description, Does.Contain("Total:"));
    }
}
```

**File:** `tests/RuneAndRust.Application.UnitTests/Services/SkillContextBuilderTests.cs`

```csharp
using Microsoft.Extensions.Logging;
using Moq;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class SkillContextBuilderTests
{
    private Mock<ILogger<SkillContextBuilder>> _mockLogger = null!;
    private SkillContextBuilder _builder = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<SkillContextBuilder>>();
        _builder = new SkillContextBuilder(_mockLogger.Object);
    }

    [Test]
    public void Build_CreatesContextWithAllModifiers()
    {
        // Act
        var context = _builder
            .WithEquipment("toolkit", "Toolkit", diceModifier: 2)
            .WithSituation("time-pressure", "Time Pressure", diceModifier: -1)
            .WithEnvironment(SurfaceType.Stable, LightingLevel.Dim)
            .WithTargetDisposition(Disposition.Friendly)
            .Build();

        // Assert
        Assert.That(context.EquipmentModifiers, Has.Count.EqualTo(1));
        Assert.That(context.SituationalModifiers, Has.Count.EqualTo(1));
        Assert.That(context.EnvironmentModifiers, Has.Count.EqualTo(2)); // Surface + Lighting
        Assert.That(context.TargetModifiers, Has.Count.EqualTo(1));
    }

    [Test]
    public void Build_ResetsBuilderAutomatically()
    {
        // Arrange: Build first context
        _builder.WithEquipment("toolkit", "Toolkit", diceModifier: 2);
        var context1 = _builder.Build();

        // Act: Build second context without re-adding
        var context2 = _builder.Build();

        // Assert
        Assert.That(context1.EquipmentModifiers, Has.Count.EqualTo(1));
        Assert.That(context2.EquipmentModifiers, Has.Count.EqualTo(0)); // Empty after auto-reset
    }

    [Test]
    public void WithSituation_PreventsDuplicateNonStackable()
    {
        // Act
        var context = _builder
            .WithSituation(SituationalModifier.TimePressure("Source 1"))
            .WithSituation(SituationalModifier.TimePressure("Source 2"))
            .Build();

        // Assert: Only one should be added
        Assert.That(context.SituationalModifiers, Has.Count.EqualTo(1));
    }
}
```

---

## 19. Use Cases

### 19.1 UC-151a-001: Build Context for Lockpicking Check

**Actor:** SkillCheckService (via caller)
**Flow:** Gather modifiers → Build context → Apply to check → Return result

**Details:**
1. Player attempts to pick a lock
2. System queries player inventory for relevant equipment
3. System checks room for lighting and corruption
4. System checks if player is in combat (time pressure)
5. SkillContextBuilder aggregates all modifiers
6. SkillCheckService performs check with modified pool and DC
7. Result reflects all contextual factors

### 19.2 UC-151a-002: Build Context for Social Check

**Actor:** SkillCheckService (via DialogueService)
**Flow:** Query NPC disposition → Build context → Apply to persuasion check

**Details:**
1. Player attempts to persuade an NPC
2. System queries NPC's disposition toward player
3. System checks NPC's suspicion level (if deception)
4. System checks for any relevant equipment (cultural artifacts?)
5. SkillContextBuilder creates context with target modifiers
6. SkillCheckService performs check with disposition bonus/penalty
7. Result determines conversation outcome

### 19.3 UC-151a-003: Display Modifier Breakdown

**Actor:** UI/Renderer
**Flow:** Get context description → Display to player

**Details:**
1. Skill check completes with modifiers
2. UI calls `context.ToDescription()`
3. Formatted breakdown displayed to player
4. Player understands why roll was modified

### 19.4 UC-151a-004: Empty Context for Simple Check

**Actor:** Legacy Code
**Flow:** Use `SkillContext.Empty` for backward compatibility

**Details:**
1. Existing code calls `PerformCheckWithDC` without context
2. Service internally uses `SkillContext.Empty`
3. No modifiers applied, behaves as before
4. Backward compatibility maintained

---

## 20. Deliverable Checklist

### 20.1 Domain Layer

- [ ] `SkillContext.cs` created in `Domain/ValueObjects/`
- [ ] `EquipmentModifier.cs` created in `Domain/ValueObjects/`
- [ ] `SituationalModifier.cs` created in `Domain/ValueObjects/`
- [ ] `EnvironmentModifier.cs` created in `Domain/ValueObjects/`
- [ ] `TargetModifier.cs` created in `Domain/ValueObjects/`
- [ ] `ModifierCategory.cs` created in `Domain/Enums/`
- [ ] `EquipmentCategory.cs` created in `Domain/Enums/` (or in EquipmentModifier file)
- [ ] `SurfaceType.cs` created in `Domain/Enums/` (or in EnvironmentModifier file)
- [ ] `LightingLevel.cs` created in `Domain/Enums/` (or in EnvironmentModifier file)
- [ ] `ModifierDuration.cs` created in `Domain/Enums/` (or in SituationalModifier file)
- [ ] `Disposition.cs` created in `Domain/Enums/` (or in TargetModifier file)
- [ ] `ISkillModifier.cs` created in `Domain/Interfaces/`

### 20.2 Application Layer

- [ ] `ISkillContextBuilder.cs` created in `Application/Interfaces/`
- [ ] `SkillContextBuilder.cs` created in `Application/Services/`
- [ ] `SkillCheckService.cs` modified with `PerformCheckWithContext`

### 20.3 Configuration

- [ ] `equipment-modifiers.json` created in `config/`
- [ ] Schema file created (optional)

### 20.4 Unit Tests

- [ ] `SkillContextTests.cs` created (~5 tests)
- [ ] `SkillContextBuilderTests.cs` created (~3 tests)
- [ ] All ~8 tests passing

### 20.5 Documentation

- [ ] This design specification complete
- [ ] Code XML documentation complete

---

## 21. Acceptance Criteria

### 21.1 Functional

- [ ] SkillContext correctly aggregates equipment modifiers
- [ ] SkillContext correctly aggregates situational modifiers
- [ ] SkillContext correctly aggregates environment modifiers
- [ ] SkillContext correctly aggregates target modifiers
- [ ] TotalDiceModifier sums all dice bonuses/penalties
- [ ] TotalDcModifier sums all DC bonuses/penalties
- [ ] Non-stackable situational modifiers prevent duplicates
- [ ] Environment modifiers replace same-type existing modifiers
- [ ] SkillContextBuilder creates valid contexts
- [ ] SkillCheckService applies context to dice pool
- [ ] SkillCheckService applies context to difficulty class
- [ ] ToDescription returns readable modifier breakdown
- [ ] SkillContext.Empty provides zero modifiers
- [ ] Backward compatibility maintained with existing check methods

### 21.2 Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~8 new unit tests pass
- [ ] All existing skill check tests pass
- [ ] XML documentation complete on all public members

---

## 22. Future Considerations

### 22.1 Deferred to v0.15.1b (Outcome Classification)

- `SkillOutcome` enum expansion
- `FumbleConsequence` entity
- `FumbleType` enum

### 22.2 Deferred to v0.15.1c (Master Abilities)

- `MasterAbility` entity
- `MasterAbilityType` enum
- Auto-succeed threshold logic

### 22.3 Deferred to v0.15.1d (Extended Check Mechanics)

- `IExtendedSkillCheckService` interface
- `CooperativeCheckResult` value object
- `ChainedCheckState` entity

### 22.4 Deferred to v0.15.1e (Integration Points)

- Trauma economy integration
- Specialization bonus hooks
- Voice guidance integration

### 22.5 Deferred to v0.15.2+ (Skill-Specific Modifiers)

- Climbing surface modifiers (Acrobatics)
- Lock type modifiers (System Bypass)
- Terrain modifiers (Wasteland Survival)
- Cultural protocol modifiers (Rhetoric)

---

## 23. Implementation Notes

### 23.1 Immutability

All modifier value objects are immutable (readonly record structs). The `SkillContext` is created once and cannot be modified after construction. This prevents accidental mutation and ensures thread safety.

### 23.2 Builder Reset Behavior

The `SkillContextBuilder` automatically resets after `Build()` is called. This allows the same builder instance to be reused for multiple contexts. Call `Reset()` explicitly if needed before building a new context.

### 23.3 Modifier Stacking Rules

- **Equipment**: All stack (you can benefit from multiple tools)
- **Situational**: Non-stackable by default (can't be rushed twice)
- **Environment**: Same-type replaces (only one surface condition)
- **Target**: All stack (disposition + suspicion + resistance)

### 23.4 Minimum Values

- **Dice Pool**: Clamped to minimum 1 die (can't have 0 or negative dice)
- **Difficulty Class**: Clamped to minimum 0 (trivial checks)

### 23.5 Testing Strategy

Use unit tests to verify modifier calculation in isolation. Integration tests with `SkillCheckService` ensure modifiers properly affect check outcomes.

---

## 24. Document Metadata

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*

---

*This design specification provides the detailed blueprint for implementing v0.15.1a Skill Context & Modifiers. This establishes the infrastructure for contextually-aware skill checks, supporting all skill system expansions in v0.15.2-v0.15.5.*
