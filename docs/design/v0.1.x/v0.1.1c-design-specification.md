# v0.1.1c Design Specification: Difficulty & Content Scaling

**Version:** 0.1.1c
**Phase Name:** Difficulty & Content Scaling
**Parent Version:** v0.1.1 (Template-Based Generation)
**Prerequisites:** v0.1.1b Complete (Seeded Generation)
**Estimated Tests:** ~25 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [DifficultyRating Value Object](#4-difficultyrating-value-object)
5. [ContentPlacementService](#5-contentplacementservice)
6. [Scaling Rules Configuration](#6-scaling-rules-configuration)
7. [Monster Tier Selection](#7-monster-tier-selection)
8. [Monster Level Scaling](#8-monster-level-scaling)
9. [Loot Quality Scaling](#9-loot-quality-scaling)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement comprehensive difficulty scaling based on dungeon depth and distance from start, creating a content placement system that selects appropriate monsters and items based on calculated difficulty ratings. This ensures players encounter progressively challenging content as they explore deeper into the dungeon, with special room types providing enhanced rewards and challenges.

### 1.2 Current State

| Area | Current State (v0.1.1b) | Target State (v0.1.1c) |
|------|-------------------------|------------------------|
| Room difficulty | Implicit (all equal) | Calculated `DifficultyRating` |
| Monster selection | Random tier selection | Difficulty-based tier selection |
| Monster levels | Fixed by definition | Depth-scaled level bonuses |
| Loot quality | Fixed drop rates | Difficulty-scaled quality multipliers |
| Room type effects | Type defined only | Type modifies difficulty and rewards |
| Content placement | Template-driven | Difficulty-aware service |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Value Objects** | `DifficultyRating` |
| **Services** | `ContentPlacementService`, `IContentPlacementService` |
| **Configuration** | `scaling-rules.json`, `ScalingRulesConfiguration` |
| **Entity Updates** | `Room.DifficultyRating` property |
| **Tests** | ~25 new unit tests |

### 1.4 Architectural Significance

This version establishes the **difficulty scaling pattern** that ensures:
- Deeper exploration yields harder challenges
- Risk/reward balance through difficulty-based loot scaling
- Room type significance via modifier multipliers
- Configurable scaling formulas for balance tuning

---

## 2. Feature Overview

```
v0.1.1c Difficulty & Content Scaling
├── DifficultyRating Value Object
│   ├── Level (1-100 base difficulty)
│   ├── DepthFactor (Z-level contribution)
│   ├── DistanceFactor (distance from start)
│   ├── RoomTypeModifier (type-based multiplier)
│   ├── EffectiveLevel (after modifiers)
│   ├── SuggestedMonsterTier
│   ├── LootQualityMultiplier
│   └── MonsterLevelBonus
├── ContentPlacementService
│   ├── FillMonsterSlot()
│   ├── FillItemSlot()
│   ├── SelectTierForDifficulty()
│   ├── GenerateItemForDifficulty()
│   └── SeededRandom integration
├── Scaling Rules Configuration
│   ├── BaseDifficulty
│   ├── DepthMultiplier
│   ├── DistanceMultiplier
│   ├── Room type modifiers
│   ├── Monster level scaling
│   └── Loot quality scaling
├── Monster Tier Selection
│   ├── Difficulty-based tier weights
│   ├── Constraint filtering (min/max tier)
│   └── Weighted selection with seeded random
├── Monster Level Scaling
│   ├── Per-depth level bonus
│   ├── Per-distance bonus
│   └── Applied to base stats
├── Loot Quality Scaling
│   ├── Base quality chance
│   ├── Quality per difficulty
│   ├── Rarity weight adjustments
│   └── Room type bonuses
└── Room Entity Updates
    └── DifficultyRating property
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  No direct changes - difficulty affects content through generation           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  ContentPlacementService                RoomGeneratorService (existing)      │
│  ├── FillMonsterSlot()                  ├── Uses ContentPlacementService    │
│  ├── FillItemSlot()                     └── Calculates DifficultyRating     │
│  ├── SelectTierForDifficulty()                                               │
│  └── GenerateItemForDifficulty()       SeededRandomService (from v0.1.1b)   │
│                                        ├── Used for deterministic selection  │
│  ScalingRulesConfiguration             └── Position-based sub-seeds          │
│  ├── BaseDifficulty                                                          │
│  ├── DepthMultiplier                   Interfaces:                           │
│  ├── DistanceMultiplier                └── IContentPlacementService          │
│  └── RoomTypeModifiers                                                       │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Entities (Updated):                Value Objects (New):                     │
│  ┌─────────────────────────────┐   ┌────────────────────────────────────┐   │
│  │ Room                        │   │ DifficultyRating                   │   │
│  │ └── DifficultyRating (new)  │   │ ├── Level: int (1-100)             │   │
│  └─────────────────────────────┘   │ ├── DepthFactor: int               │   │
│                                    │ ├── DistanceFactor: int            │   │
│  Existing (from prior versions):   │ ├── RoomTypeModifier: float        │   │
│  ├── RoomType enum (v0.1.0c)       │ ├── EffectiveLevel: int            │   │
│  ├── Position3D (v0.1.0a)          │ ├── SuggestedMonsterTier: string   │   │
│  └── TemplateSlot (v0.1.1a)        │ ├── LootQualityMultiplier: float   │   │
│                                    │ └── MonsterLevelBonus: int          │   │
│                                    └────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  └── GetScalingRulesConfiguration()                                          │
│      └── Loads config/scaling-rules.json                                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Difficulty Calculation Flow

```
┌───────────────────────────────────────┐
│ Room Generation at Position (X, Y, Z) │
│ with RoomType                         │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ DifficultyRating.Calculate(position, startPosition, roomType) │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│ Step 1: Calculate depth contribution                          │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ depthContribution = position.Z × rules.DepthMultiplier  │  │
│ │ Example: Z=3 × 8.0 = 24                                 │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 2: Calculate distance contribution                       │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ distance = |X-startX| + |Y-startY| + |Z-startZ|         │  │
│ │ distanceContribution = distance × rules.DistanceMultiplier │
│ │ Example: distance=5 × 2.0 = 10                          │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 3: Calculate base level                                  │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ baseLevel = BaseDifficulty + depthContribution + distanceContribution │
│ │ Example: 5 + 24 + 10 = 39                               │  │
│ │ Clamped to range [1, 100]                               │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 4: Apply room type modifier                              │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ typeModifier = roomType switch {                        │  │
│ │   Treasure => 1.5,  Boss => 2.0,  Trap => 1.2,         │  │
│ │   Safe => 0.0,  Shrine => 1.1,  Standard => 1.0        │  │
│ │ }                                                       │  │
│ │ EffectiveLevel = baseLevel × typeModifier               │  │
│ │ Example: 39 × 1.0 = 39  (Standard room)                │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 5: Derive scaling values                                 │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ SuggestedMonsterTier: Level 39 → "named"                │  │
│ │ LootQualityMultiplier: 1.0 + (39 × 0.02) = 1.78        │  │
│ │ MonsterLevelBonus: 39 / 10 = 3                          │  │
│ └─────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Content Placement Flow

```
┌───────────────────────────────────────┐
│ Template Slot: Monster Slot           │
│ IsRequired: false                     │
│ FillProbability: 0.35                 │
│ MinQuantity: 1, MaxQuantity: 2        │
│ Constraints: { "maxTier": "elite" }   │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ ContentPlacementService.FillMonsterSlot(slot, difficulty, pos)│
├───────────────────────────────────────────────────────────────┤
│                                                               │
│ Step 1: Check if slot should be filled                        │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ fillRoll = seededRandom.NextFloatForPosition(pos, "fill")│  │
│ │ if (!slot.IsRequired && fillRoll > 0.35) → yield break  │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 2: Determine quantity                                    │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ quantity = seededRandom.NextForPosition(pos, 1, 3, "qty")│  │
│ │ Example: quantity = 2                                   │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 3: Select tier based on difficulty                       │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ Filter tiers by constraints (maxTier: elite)            │  │
│ │ Adjust weights by difficulty level                      │  │
│ │ Higher difficulty → higher tier more likely             │  │
│ │ seededRandom.SelectWeighted(pos, weightedTiers)         │  │
│ │ Example: Selected "named" tier                          │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 4: Generate monsters with level bonus                    │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ for i in 0..quantity:                                   │  │
│ │   monster = monsterService.CreateMonsterForBiome(       │  │
│ │     biome, tier, difficulty.MonsterLevelBonus)          │  │
│ │   yield return monster                                  │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
└───────────────────────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Result: 2 Named-tier monsters with +3 level bonus             │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 Tier Selection Weights

```
Base Tier Weights (from tiers.json):
┌─────────────────────────────────────────┐
│ common: 70  │ named: 20  │ elite: 8     │
└─────────────────────────────────────────┘

Difficulty Adjustment Formula:
adjustedWeight = baseWeight × (1 + effectiveLevel × 0.01 × sortOrder)

Example at Difficulty Level 50:
┌─────────────────────────────────────────────────────────────────────────┐
│ Tier    │ SortOrder │ Base │ Calculation                    │ Adjusted │
├─────────────────────────────────────────────────────────────────────────┤
│ common  │ 0         │ 70   │ 70 × (1 + 50×0.01×0) = 70×1.0 │ 70       │
│ named   │ 1         │ 20   │ 20 × (1 + 50×0.01×1) = 20×1.5 │ 30       │
│ elite   │ 2         │ 8    │ 8 × (1 + 50×0.01×2) = 8×2.0   │ 16       │
├─────────────────────────────────────────────────────────────────────────┤
│ TOTAL                                                        │ 116      │
├─────────────────────────────────────────────────────────────────────────┤
│ Effective Probabilities:                                                │
│ common: 70/116 = 60.3%                                                  │
│ named:  30/116 = 25.9%                                                  │
│ elite:  16/116 = 13.8%                                                  │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. DifficultyRating Value Object

### 4.1 Purpose

Calculate and represent the difficulty of a room based on its position relative to the dungeon start, enabling difficulty-aware content placement.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DifficultyRating.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the difficulty rating of a room or area.
/// </summary>
/// <remarks>
/// Difficulty is calculated from multiple factors:
/// - Depth (Z-level): Deeper = harder
/// - Distance from start: Farther = harder
/// - Room type: Special rooms modify difficulty
///
/// The effective level determines monster tiers, level bonuses, and loot quality.
/// </remarks>
public readonly record struct DifficultyRating
{
    /// <summary>
    /// Gets the base difficulty level (1-100).
    /// </summary>
    /// <remarks>
    /// Calculated from depth and distance contributions before room type modifier.
    /// </remarks>
    public int Level { get; init; }

    /// <summary>
    /// Gets the depth contribution (Z-level).
    /// </summary>
    public int DepthFactor { get; init; }

    /// <summary>
    /// Gets the distance contribution (Manhattan distance from start).
    /// </summary>
    public int DistanceFactor { get; init; }

    /// <summary>
    /// Gets the room type modifier.
    /// </summary>
    /// <remarks>
    /// Multiplier applied to base level:
    /// - Treasure: 1.5x (harder guardians)
    /// - Boss: 2.0x (challenging encounters)
    /// - Trap: 1.2x (dangerous)
    /// - Safe: 0.0x (no combat)
    /// - Shrine: 1.1x (slightly harder)
    /// - Standard: 1.0x (no modifier)
    /// </remarks>
    public float RoomTypeModifier { get; init; }

    /// <summary>
    /// Gets the effective difficulty after all modifiers.
    /// </summary>
    public int EffectiveLevel => RoomTypeModifier > 0
        ? Math.Clamp((int)(Level * RoomTypeModifier), 1, 100)
        : 0;

    /// <summary>
    /// Gets the suggested monster tier based on effective difficulty.
    /// </summary>
    /// <remarks>
    /// Tier thresholds:
    /// - Level 1-14: common
    /// - Level 15-34: named
    /// - Level 35-59: elite
    /// - Level 60+: boss
    /// </remarks>
    public string SuggestedMonsterTier => EffectiveLevel switch
    {
        0 => "none",
        < 15 => "common",
        < 35 => "named",
        < 60 => "elite",
        _ => "boss"
    };

    /// <summary>
    /// Gets the loot quality multiplier.
    /// </summary>
    /// <remarks>
    /// Formula: 1.0 + (EffectiveLevel × 0.02)
    /// - Level 1: 1.02x
    /// - Level 50: 2.0x
    /// - Level 100: 3.0x
    /// </remarks>
    public float LootQualityMultiplier => 1.0f + (EffectiveLevel * 0.02f);

    /// <summary>
    /// Gets the monster level bonus added to base monster level.
    /// </summary>
    /// <remarks>
    /// Formula: EffectiveLevel / 10
    /// - Level 10-19: +1
    /// - Level 20-29: +2
    /// - Level 50-59: +5
    /// </remarks>
    public int MonsterLevelBonus => EffectiveLevel / 10;

    /// <summary>
    /// Gets whether this is a combat-enabled room.
    /// </summary>
    public bool HasCombat => RoomTypeModifier > 0;

    /// <summary>
    /// Creates a default difficulty rating for the starting area.
    /// </summary>
    public static DifficultyRating Starting => new()
    {
        Level = 1,
        DepthFactor = 0,
        DistanceFactor = 0,
        RoomTypeModifier = 1.0f
    };

    /// <summary>
    /// Calculates difficulty from position and room type.
    /// </summary>
    /// <param name="position">The room's 3D position.</param>
    /// <param name="startPosition">The dungeon starting position.</param>
    /// <param name="roomType">The type of room.</param>
    /// <param name="rules">The scaling rules configuration.</param>
    /// <returns>A calculated DifficultyRating.</returns>
    public static DifficultyRating Calculate(
        Position3D position,
        Position3D startPosition,
        RoomType roomType,
        ScalingRules rules)
    {
        var depth = Math.Abs(position.Z);
        var distance = ManhattanDistance(position, startPosition);

        var depthContribution = (int)(depth * rules.DepthMultiplier);
        var distanceContribution = (int)(distance * rules.DistanceMultiplier);
        var baseLevel = rules.BaseDifficulty + depthContribution + distanceContribution;

        var typeModifier = GetRoomTypeModifier(roomType, rules);

        return new DifficultyRating
        {
            Level = Math.Clamp(baseLevel, 1, 100),
            DepthFactor = depth,
            DistanceFactor = distance,
            RoomTypeModifier = typeModifier
        };
    }

    /// <summary>
    /// Gets the room type modifier from rules.
    /// </summary>
    private static float GetRoomTypeModifier(RoomType roomType, ScalingRules rules) =>
        roomType switch
        {
            RoomType.Treasure => rules.TreasureRoomModifier,
            RoomType.Boss => rules.BossRoomModifier,
            RoomType.Trap => rules.TrapRoomModifier,
            RoomType.Safe => 0.0f, // No combat in safe rooms
            RoomType.Shrine => rules.ShrineRoomModifier,
            _ => 1.0f
        };

    /// <summary>
    /// Calculates Manhattan distance between two 3D positions.
    /// </summary>
    private static int ManhattanDistance(Position3D a, Position3D b) =>
        Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y) + Math.Abs(a.Z - b.Z);

    /// <inheritdoc/>
    public override string ToString() =>
        $"Difficulty[Level={Level}, Effective={EffectiveLevel}, Tier={SuggestedMonsterTier}]";
}

/// <summary>
/// Configuration rules for difficulty scaling.
/// </summary>
/// <remarks>
/// Loaded from scaling-rules.json and used by DifficultyRating.Calculate().
/// </remarks>
public class ScalingRules
{
    /// <summary>
    /// Base difficulty level for starting area.
    /// </summary>
    public int BaseDifficulty { get; init; } = 5;

    /// <summary>
    /// Difficulty increase per Z-level depth.
    /// </summary>
    public float DepthMultiplier { get; init; } = 8.0f;

    /// <summary>
    /// Difficulty increase per unit of Manhattan distance.
    /// </summary>
    public float DistanceMultiplier { get; init; } = 2.0f;

    /// <summary>
    /// Difficulty modifier for Treasure rooms.
    /// </summary>
    public float TreasureRoomModifier { get; init; } = 1.5f;

    /// <summary>
    /// Difficulty modifier for Boss rooms.
    /// </summary>
    public float BossRoomModifier { get; init; } = 2.0f;

    /// <summary>
    /// Difficulty modifier for Trap rooms.
    /// </summary>
    public float TrapRoomModifier { get; init; } = 1.2f;

    /// <summary>
    /// Difficulty modifier for Shrine rooms.
    /// </summary>
    public float ShrineRoomModifier { get; init; } = 1.1f;

    /// <summary>
    /// Monster level scaling configuration.
    /// </summary>
    public MonsterLevelScaling MonsterLevelScaling { get; init; } = new();

    /// <summary>
    /// Loot quality scaling configuration.
    /// </summary>
    public LootScaling LootScaling { get; init; } = new();
}

/// <summary>
/// Monster level scaling rules.
/// </summary>
public class MonsterLevelScaling
{
    /// <summary>
    /// Level bonus per depth level.
    /// </summary>
    public int PerDepthLevel { get; init; } = 1;

    /// <summary>
    /// Level bonus per distance unit.
    /// </summary>
    public float PerDistanceUnit { get; init; } = 0.5f;
}

/// <summary>
/// Loot quality scaling rules.
/// </summary>
public class LootScaling
{
    /// <summary>
    /// Base chance for quality loot.
    /// </summary>
    public float BaseQualityChance { get; init; } = 0.1f;

    /// <summary>
    /// Additional quality chance per difficulty level.
    /// </summary>
    public float QualityPerDifficulty { get; init; } = 0.005f;

    /// <summary>
    /// Rarity weights for loot selection.
    /// </summary>
    public Dictionary<string, int> RarityWeights { get; init; } = new()
    {
        ["common"] = 70,
        ["uncommon"] = 20,
        ["rare"] = 8,
        ["epic"] = 2
    };
}
```

---

## 5. ContentPlacementService

### 5.1 Purpose

Fill template slots with appropriate content based on difficulty rating, ensuring monsters and items scale appropriately with room difficulty.

### 5.2 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IContentPlacementService.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for placing monsters and items based on difficulty.
/// </summary>
public interface IContentPlacementService
{
    /// <summary>
    /// Fills a template slot with appropriate monster content.
    /// </summary>
    /// <param name="slot">The template slot to fill.</param>
    /// <param name="difficulty">The room's difficulty rating.</param>
    /// <param name="position">The room position for seeded random.</param>
    /// <param name="environment">The environment context.</param>
    /// <returns>Generated monsters, or empty if slot not filled.</returns>
    IEnumerable<Monster> FillMonsterSlot(
        TemplateSlot slot,
        DifficultyRating difficulty,
        Position3D position,
        EnvironmentContext environment);

    /// <summary>
    /// Fills a template slot with appropriate item content.
    /// </summary>
    /// <param name="slot">The template slot to fill.</param>
    /// <param name="difficulty">The room's difficulty rating.</param>
    /// <param name="position">The room position for seeded random.</param>
    /// <param name="environment">The environment context.</param>
    /// <returns>Generated items, or empty if slot not filled.</returns>
    IEnumerable<Item> FillItemSlot(
        TemplateSlot slot,
        DifficultyRating difficulty,
        Position3D position,
        EnvironmentContext environment);

    /// <summary>
    /// Calculates the difficulty rating for a room.
    /// </summary>
    /// <param name="position">The room position.</param>
    /// <param name="startPosition">The dungeon start position.</param>
    /// <param name="roomType">The room type.</param>
    /// <returns>The calculated difficulty rating.</returns>
    DifficultyRating CalculateDifficulty(
        Position3D position,
        Position3D startPosition,
        RoomType roomType);
}
```

### 5.3 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/ContentPlacementService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for placing monsters and items based on difficulty.
/// </summary>
public class ContentPlacementService : IContentPlacementService
{
    private readonly IMonsterService _monsterService;
    private readonly ITierService _tierService;
    private readonly ILootService _lootService;
    private readonly ISeededRandomService _random;
    private readonly ScalingRules _rules;
    private readonly ILogger<ContentPlacementService> _logger;

    public ContentPlacementService(
        IMonsterService monsterService,
        ITierService tierService,
        ILootService lootService,
        ISeededRandomService random,
        ScalingRules rules,
        ILogger<ContentPlacementService> logger)
    {
        _monsterService = monsterService ?? throw new ArgumentNullException(nameof(monsterService));
        _tierService = tierService ?? throw new ArgumentNullException(nameof(tierService));
        _lootService = lootService ?? throw new ArgumentNullException(nameof(lootService));
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _rules = rules ?? throw new ArgumentNullException(nameof(rules));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        _logger.LogDebug("ContentPlacementService initialized");
    }

    /// <inheritdoc/>
    public IEnumerable<Monster> FillMonsterSlot(
        TemplateSlot slot,
        DifficultyRating difficulty,
        Position3D position,
        EnvironmentContext environment)
    {
        // Safe rooms never have monsters
        if (!difficulty.HasCombat)
        {
            _logger.LogDebug("Skipping monster slot for non-combat room at {Position}", position);
            yield break;
        }

        // Check if slot should be filled
        var fillRoll = _random.NextFloatForPosition(position, "monster_fill");
        if (!slot.IsRequired && fillRoll > slot.FillProbability)
        {
            _logger.LogDebug(
                "Monster slot not filled: roll {Roll:F2} > probability {Prob:F2}",
                fillRoll, slot.FillProbability);
            yield break;
        }

        // Determine quantity
        var quantity = _random.NextForPosition(
            position,
            slot.MinQuantity,
            slot.MaxQuantity + 1,
            "monster_quantity");

        _logger.LogDebug(
            "Filling monster slot: quantity={Quantity}, difficulty={Difficulty}",
            quantity, difficulty.EffectiveLevel);

        // Select tier based on difficulty
        var tier = SelectTierForDifficulty(difficulty, slot.Constraints, position);

        // Generate monsters
        var biome = environment.Biome ?? "dungeon";
        for (int i = 0; i < quantity; i++)
        {
            var monster = _monsterService.CreateMonsterForBiome(
                biome,
                tier.Id,
                difficulty.MonsterLevelBonus);

            if (monster != null)
            {
                _logger.LogDebug(
                    "Created monster: {Name} (tier={Tier}, levelBonus={Bonus})",
                    monster.Name, tier.Id, difficulty.MonsterLevelBonus);
                yield return monster;
            }
        }
    }

    /// <inheritdoc/>
    public IEnumerable<Item> FillItemSlot(
        TemplateSlot slot,
        DifficultyRating difficulty,
        Position3D position,
        EnvironmentContext environment)
    {
        // Check if slot should be filled
        var fillRoll = _random.NextFloatForPosition(position, "item_fill");
        if (!slot.IsRequired && fillRoll > slot.FillProbability)
        {
            _logger.LogDebug(
                "Item slot not filled: roll {Roll:F2} > probability {Prob:F2}",
                fillRoll, slot.FillProbability);
            yield break;
        }

        // Determine quantity
        var quantity = _random.NextForPosition(
            position,
            slot.MinQuantity,
            slot.MaxQuantity + 1,
            "item_quantity");

        _logger.LogDebug(
            "Filling item slot: quantity={Quantity}, qualityMult={QualityMult:F2}",
            quantity, difficulty.LootQualityMultiplier);

        // Generate items with quality scaling
        for (int i = 0; i < quantity; i++)
        {
            var item = GenerateItemForDifficulty(difficulty, slot.Constraints, position, i);
            if (item != null)
            {
                _logger.LogDebug("Created item: {Name}", item.Name);
                yield return item;
            }
        }
    }

    /// <inheritdoc/>
    public DifficultyRating CalculateDifficulty(
        Position3D position,
        Position3D startPosition,
        RoomType roomType)
    {
        return DifficultyRating.Calculate(position, startPosition, roomType, _rules);
    }

    /// <summary>
    /// Selects a tier based on difficulty and constraints.
    /// </summary>
    private TierDefinition SelectTierForDifficulty(
        DifficultyRating difficulty,
        IReadOnlyDictionary<string, string> constraints,
        Position3D position)
    {
        var availableTiers = _tierService.GetAllTiers()
            .Where(t => t.SpawnWeight > 0)
            .ToList();

        // Apply max tier constraint
        if (constraints.TryGetValue("maxTier", out var maxTier))
        {
            var maxTierDef = _tierService.GetTier(maxTier);
            if (maxTierDef != null)
            {
                availableTiers = availableTiers
                    .Where(t => t.SortOrder <= maxTierDef.SortOrder)
                    .ToList();
            }
        }

        // Apply min tier constraint
        if (constraints.TryGetValue("minTier", out var minTier))
        {
            var minTierDef = _tierService.GetTier(minTier);
            if (minTierDef != null)
            {
                availableTiers = availableTiers
                    .Where(t => t.SortOrder >= minTierDef.SortOrder)
                    .ToList();
            }
        }

        if (availableTiers.Count == 0)
        {
            _logger.LogWarning("No available tiers after filtering, using default");
            return TierDefinition.Common;
        }

        // Adjust weights based on difficulty
        var weightedTiers = availableTiers.Select(t =>
        {
            var adjustedWeight = t.SpawnWeight;

            // Higher difficulty = higher tiers more likely
            if (t.SortOrder > 0)
            {
                var difficultyBonus = 1.0f + (difficulty.EffectiveLevel * 0.01f * t.SortOrder);
                adjustedWeight = (int)(adjustedWeight * difficultyBonus);
            }

            return (item: t, weight: adjustedWeight);
        }).ToList();

        var selected = _random.SelectWeighted(position, weightedTiers, "tier_select");

        _logger.LogDebug(
            "Selected tier {Tier} for difficulty {Difficulty}",
            selected.Id, difficulty.EffectiveLevel);

        return selected;
    }

    /// <summary>
    /// Generates an item based on difficulty and constraints.
    /// </summary>
    private Item? GenerateItemForDifficulty(
        DifficultyRating difficulty,
        IReadOnlyDictionary<string, string> constraints,
        Position3D position,
        int index)
    {
        // Determine rarity based on difficulty
        var rarity = SelectRarityForDifficulty(difficulty, position, index);

        // Get item type constraint
        var typeConstraint = constraints.TryGetValue("types", out var types)
            ? types.Split(',').Select(t => t.Trim()).ToList()
            : null;

        // For now, create basic items - this would integrate with an item service
        // The actual implementation would query available items by rarity and type
        return CreateItemByRarity(rarity, typeConstraint, position, index);
    }

    /// <summary>
    /// Selects item rarity based on difficulty.
    /// </summary>
    private string SelectRarityForDifficulty(DifficultyRating difficulty, Position3D position, int index)
    {
        var scaling = _rules.LootScaling;
        var qualityBoost = difficulty.LootQualityMultiplier - 1.0f;

        // Adjust rarity weights based on difficulty
        var adjustedWeights = scaling.RarityWeights.Select(kv =>
        {
            var weight = kv.Value;

            // Boost higher rarities based on difficulty
            if (kv.Key != "common")
            {
                var boost = 1.0f + (qualityBoost * GetRarityMultiplier(kv.Key));
                weight = (int)(weight * boost);
            }

            return (item: kv.Key, weight);
        }).ToList();

        return _random.SelectWeighted(position, adjustedWeights, $"rarity_select_{index}");
    }

    /// <summary>
    /// Gets the boost multiplier for a rarity.
    /// </summary>
    private static float GetRarityMultiplier(string rarity) => rarity switch
    {
        "uncommon" => 1.0f,
        "rare" => 2.0f,
        "epic" => 4.0f,
        "legendary" => 8.0f,
        _ => 0.5f
    };

    /// <summary>
    /// Creates an item by rarity (placeholder for item service integration).
    /// </summary>
    private Item? CreateItemByRarity(string rarity, List<string>? types, Position3D position, int index)
    {
        // This is a placeholder - actual implementation would use an ItemService
        // to select from available items matching rarity and type constraints
        _logger.LogDebug("Creating {Rarity} item at {Position}", rarity, position);

        // Return a basic health potion as placeholder
        // Real implementation would query item definitions by rarity
        return Item.CreateHealthPotion();
    }
}
```

---

## 6. Scaling Rules Configuration

### 6.1 Purpose

Provide configurable scaling formulas that can be tuned for game balance without code changes.

### 6.2 Configuration Class

**File:** `src/Core/RuneAndRust.Application/Configuration/ScalingRulesConfiguration.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration wrapper for scaling rules loaded from JSON.
/// </summary>
public class ScalingRulesConfiguration
{
    /// <summary>
    /// Schema version for configuration validation.
    /// </summary>
    public string Version { get; init; } = "1.0";

    /// <summary>
    /// The scaling rules.
    /// </summary>
    public ScalingRules ScalingRules { get; init; } = new();

    /// <summary>
    /// Special room spawn chances during generation.
    /// </summary>
    public SpecialRoomChances SpecialRoomChances { get; init; } = new();
}

/// <summary>
/// Spawn chances for special room types.
/// </summary>
public class SpecialRoomChances
{
    /// <summary>
    /// Chance for Treasure room.
    /// </summary>
    public float Treasure { get; init; } = 0.08f;

    /// <summary>
    /// Chance for Boss room.
    /// </summary>
    public float Boss { get; init; } = 0.03f;

    /// <summary>
    /// Chance for Trap room.
    /// </summary>
    public float Trap { get; init; } = 0.12f;

    /// <summary>
    /// Chance for Safe room.
    /// </summary>
    public float Safe { get; init; } = 0.05f;

    /// <summary>
    /// Chance for Shrine room.
    /// </summary>
    public float Shrine { get; init; } = 0.04f;
}
```

### 6.3 JSON Configuration

**File:** `config/scaling-rules.json`

```json
{
  "$schema": "schemas/scaling-rules.schema.json",
  "version": "1.0",
  "scalingRules": {
    "baseDifficulty": 5,
    "depthMultiplier": 8.0,
    "distanceMultiplier": 2.0,
    "treasureRoomModifier": 1.5,
    "bossRoomModifier": 2.0,
    "trapRoomModifier": 1.2,
    "shrineRoomModifier": 1.1,
    "monsterLevelScaling": {
      "perDepthLevel": 1,
      "perDistanceUnit": 0.5
    },
    "lootScaling": {
      "baseQualityChance": 0.1,
      "qualityPerDifficulty": 0.005,
      "rarityWeights": {
        "common": 70,
        "uncommon": 20,
        "rare": 8,
        "epic": 2
      }
    }
  },
  "specialRoomChances": {
    "treasure": 0.08,
    "boss": 0.03,
    "trap": 0.12,
    "safe": 0.05,
    "shrine": 0.04
  }
}
```

---

## 7. Monster Tier Selection

### 7.1 Purpose

Select appropriate monster tiers based on room difficulty, ensuring harder rooms have more challenging enemies.

### 7.2 Selection Algorithm

The tier selection process:

1. **Filter by constraints**: Apply minTier/maxTier from slot constraints
2. **Adjust weights**: Higher difficulty increases likelihood of higher tiers
3. **Seeded selection**: Use position-based seed for deterministic results

### 7.3 Tier Probability Examples

| Difficulty Level | common | named | elite |
|-----------------|--------|-------|-------|
| 10 | 67.3% | 21.2% | 11.5% |
| 25 | 63.6% | 23.6% | 12.7% |
| 50 | 60.3% | 25.9% | 13.8% |
| 75 | 57.4% | 27.9% | 14.7% |
| 100 | 54.7% | 29.7% | 15.6% |

---

## 8. Monster Level Scaling

### 8.1 Purpose

Add level bonuses to monsters based on room difficulty, making deeper monsters statistically stronger.

### 8.2 Level Bonus Calculation

```
MonsterLevelBonus = EffectiveLevel / 10

Examples:
- Difficulty 15 → +1 level bonus
- Difficulty 39 → +3 level bonus
- Difficulty 75 → +7 level bonus
```

### 8.3 Impact on Monster Stats

The level bonus affects base monster stats:
- Health: +10% per level
- Attack: +5% per level
- Defense: +3% per level

---

## 9. Loot Quality Scaling

### 9.1 Purpose

Scale loot quality with room difficulty, rewarding players for tackling harder content.

### 9.2 Quality Multiplier

```
LootQualityMultiplier = 1.0 + (EffectiveLevel × 0.02)

Examples:
- Difficulty 10: 1.0 + (10 × 0.02) = 1.2x
- Difficulty 50: 1.0 + (50 × 0.02) = 2.0x
- Difficulty 100: 1.0 + (100 × 0.02) = 3.0x
```

### 9.3 Rarity Probability Adjustment

Higher difficulty increases chances for rare items:

| Rarity | Base Weight | Diff 50 Adjusted | Diff 100 Adjusted |
|--------|-------------|------------------|-------------------|
| common | 70 | 70 | 70 |
| uncommon | 20 | 40 | 60 |
| rare | 8 | 24 | 40 |
| epic | 2 | 10 | 18 |

---

## 10. Data Model Changes

### 10.1 New Value Objects

| Value Object | Layer | Description |
|--------------|-------|-------------|
| `DifficultyRating` | Domain | Room difficulty calculation |
| `ScalingRules` | Domain | Scaling formula configuration |
| `MonsterLevelScaling` | Domain | Monster level scaling rules |
| `LootScaling` | Domain | Loot quality scaling rules |

### 10.2 Entity Updates

| Entity | Property | Type | Description |
|--------|----------|------|-------------|
| `Room` | `DifficultyRating` | `DifficultyRating` | Calculated difficulty for this room |

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (addition)

```csharp
/// <summary>
/// Gets or sets the difficulty rating for this room.
/// </summary>
/// <remarks>
/// Calculated during room generation based on position, room type,
/// and scaling rules. Used for monster tier selection and loot quality.
/// </remarks>
public DifficultyRating DifficultyRating { get; private set; }

/// <summary>
/// Sets the difficulty rating for this room.
/// </summary>
/// <param name="rating">The calculated difficulty rating.</param>
public void SetDifficultyRating(DifficultyRating rating)
{
    DifficultyRating = rating;
}
```

### 10.3 New Services

| Service | Layer | Description |
|---------|-------|-------------|
| `ContentPlacementService` | Application | Difficulty-aware content placement |
| `IContentPlacementService` | Application | Interface for content placement |

---

## 11. Configuration File Schemas

### 11.1 Scaling Rules Schema

**File:** `config/schemas/scaling-rules.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "scaling-rules.schema.json",
  "title": "Scaling Rules Configuration",
  "description": "Schema for difficulty and content scaling rules",
  "type": "object",
  "required": ["version", "scalingRules"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+$"
    },
    "scalingRules": {
      "type": "object",
      "required": ["baseDifficulty", "depthMultiplier", "distanceMultiplier"],
      "properties": {
        "baseDifficulty": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Base difficulty level for starting area"
        },
        "depthMultiplier": {
          "type": "number",
          "minimum": 0,
          "description": "Difficulty increase per Z-level"
        },
        "distanceMultiplier": {
          "type": "number",
          "minimum": 0,
          "description": "Difficulty increase per distance unit"
        },
        "treasureRoomModifier": {
          "type": "number",
          "minimum": 0,
          "default": 1.5,
          "description": "Difficulty multiplier for Treasure rooms"
        },
        "bossRoomModifier": {
          "type": "number",
          "minimum": 0,
          "default": 2.0,
          "description": "Difficulty multiplier for Boss rooms"
        },
        "trapRoomModifier": {
          "type": "number",
          "minimum": 0,
          "default": 1.2,
          "description": "Difficulty multiplier for Trap rooms"
        },
        "shrineRoomModifier": {
          "type": "number",
          "minimum": 0,
          "default": 1.1,
          "description": "Difficulty multiplier for Shrine rooms"
        },
        "monsterLevelScaling": {
          "type": "object",
          "properties": {
            "perDepthLevel": {
              "type": "integer",
              "minimum": 0,
              "description": "Level bonus per depth level"
            },
            "perDistanceUnit": {
              "type": "number",
              "minimum": 0,
              "description": "Level bonus per distance unit"
            }
          }
        },
        "lootScaling": {
          "type": "object",
          "properties": {
            "baseQualityChance": {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "description": "Base chance for quality loot"
            },
            "qualityPerDifficulty": {
              "type": "number",
              "minimum": 0,
              "description": "Quality chance increase per difficulty"
            },
            "rarityWeights": {
              "type": "object",
              "additionalProperties": {
                "type": "integer",
                "minimum": 0
              },
              "description": "Base rarity weights for loot"
            }
          }
        }
      }
    },
    "specialRoomChances": {
      "type": "object",
      "properties": {
        "treasure": { "type": "number", "minimum": 0, "maximum": 1 },
        "boss": { "type": "number", "minimum": 0, "maximum": 1 },
        "trap": { "type": "number", "minimum": 0, "maximum": 1 },
        "safe": { "type": "number", "minimum": 0, "maximum": 1 },
        "shrine": { "type": "number", "minimum": 0, "maximum": 1 }
      },
      "description": "Spawn chances for special room types"
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `ContentPlacementService` | Information | Slot filling summary |
| `ContentPlacementService` | Debug | Individual monster/item creation |
| `ContentPlacementService` | Debug | Tier selection, rarity selection |
| `ContentPlacementService` | Warning | No available tiers after filtering |
| `DifficultyRating` | Debug | Difficulty calculation details |

### 12.2 Log Message Examples

```
// Information
[ContentPlacementService] Filled monster slot at (3,-1,2): 2 monsters, tier=named

// Debug
[ContentPlacementService] ContentPlacementService initialized
[ContentPlacementService] Filling monster slot: quantity=2, difficulty=39
[ContentPlacementService] Selected tier named for difficulty 39
[ContentPlacementService] Created monster: Grok the Goblin (tier=named, levelBonus=3)
[ContentPlacementService] Creating rare item at (3,-1,2)

// Warning
[ContentPlacementService] No available tiers after filtering, using default
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| DifficultyRating calculation | 8 |
| ContentPlacementService monster filling | 6 |
| ContentPlacementService item filling | 5 |
| Tier selection | 4 |
| Configuration loading | 2 |
| **Total** | **~25** |

### 13.2 Test Categories

#### DifficultyRating Tests

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/DifficultyRatingTests.cs`

1. `Calculate_AtStartPosition_ReturnsBaseDifficulty`
2. `Calculate_DeeperPosition_ReturnsHigherDifficulty`
3. `Calculate_FartherPosition_ReturnsHigherDifficulty`
4. `Calculate_TreasureRoom_AppliesModifier`
5. `Calculate_SafeRoom_ReturnsZeroEffective`
6. `EffectiveLevel_ClampedTo100Maximum`
7. `SuggestedMonsterTier_ReturnsCorrectTierForLevel`
8. `LootQualityMultiplier_ScalesWithLevel`

#### ContentPlacementService Monster Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/ContentPlacementServiceMonsterTests.cs`

1. `FillMonsterSlot_RequiredSlot_AlwaysFills`
2. `FillMonsterSlot_OptionalSlot_RespectsProbability`
3. `FillMonsterSlot_SafeRoom_NeverFills`
4. `FillMonsterSlot_QuantityInRange`
5. `FillMonsterSlot_AppliesLevelBonus`
6. `FillMonsterSlot_RespectsMaxTierConstraint`

#### ContentPlacementService Item Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/ContentPlacementServiceItemTests.cs`

1. `FillItemSlot_RequiredSlot_AlwaysFills`
2. `FillItemSlot_OptionalSlot_RespectsProbability`
3. `FillItemSlot_QuantityInRange`
4. `FillItemSlot_HigherDifficulty_BetterRarity`
5. `FillItemSlot_RespectsTypeConstraint`

#### Tier Selection Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/ContentPlacementServiceTierTests.cs`

1. `SelectTier_HigherDifficulty_HigherTiersMoreLikely`
2. `SelectTier_RespectsMinTierConstraint`
3. `SelectTier_RespectsMaxTierConstraint`
4. `SelectTier_NoValidTiers_ReturnsDefault`

#### Configuration Tests

**File:** `tests/RuneAndRust.Infrastructure.UnitTests/Configuration/ScalingRulesConfigurationTests.cs`

1. `LoadFromJson_ValidFile_ReturnsConfiguration`
2. `LoadFromJson_MissingFile_ReturnsDefaults`

---

## 14. Use Cases

### UC-001: Calculate Room Difficulty
**Actor:** RoomGeneratorService (System)
**Flow:** Determine position → Get start position → Get room type → Call DifficultyRating.Calculate() → Store on room

### UC-002: Fill Monster Slot
**Actor:** RoomGeneratorService (System)
**Flow:** Get template slot → Get room difficulty → Call ContentPlacementService.FillMonsterSlot() → Add monsters to room

### UC-003: Fill Item Slot
**Actor:** RoomGeneratorService (System)
**Flow:** Get template slot → Get room difficulty → Call ContentPlacementService.FillItemSlot() → Add items to room

### UC-004: Select Monster Tier
**Actor:** ContentPlacementService (System)
**Flow:** Get available tiers → Apply constraints → Adjust weights by difficulty → Seeded weighted selection

### UC-005: Generate Scaled Item
**Actor:** ContentPlacementService (System)
**Flow:** Calculate quality multiplier → Select rarity with adjusted weights → Generate item of selected rarity

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `DifficultyRating` value object created
- [ ] `ScalingRules` class created
- [ ] `MonsterLevelScaling` class created
- [ ] `LootScaling` class created
- [ ] `Room.DifficultyRating` property added
- [ ] `Room.SetDifficultyRating()` method added

### Application Layer
- [ ] `IContentPlacementService` interface defined
- [ ] `ContentPlacementService` implementation complete
- [ ] `ScalingRulesConfiguration` class created
- [ ] `SpecialRoomChances` class created

### Configuration
- [ ] `config/scaling-rules.json` created
- [ ] `config/schemas/scaling-rules.schema.json` created
- [ ] JSON validates against schema

### Infrastructure
- [ ] `JsonConfigurationProvider` loads scaling rules
- [ ] DI registration for ContentPlacementService
- [ ] DI registration for ScalingRules

### Testing
- [ ] ~25 unit tests implemented
- [ ] All tests passing
- [ ] Test coverage for all scaling scenarios

---

## 16. Acceptance Criteria

### Functional
- [ ] DifficultyRating calculates from position and room type
- [ ] Deeper rooms have higher difficulty (Z-level scaling)
- [ ] Farther rooms have higher difficulty (distance scaling)
- [ ] Room types modify difficulty appropriately
- [ ] ContentPlacementService fills template slots
- [ ] Monster tier selection respects difficulty
- [ ] Monster tier selection respects min/max constraints
- [ ] Monster levels scale with depth (MonsterLevelBonus)
- [ ] Loot quality scales with difficulty (LootQualityMultiplier)
- [ ] Scaling rules load from JSON configuration
- [ ] Safe rooms have zero combat (RoomTypeModifier = 0)
- [ ] Seeded random ensures deterministic content

### Quality
- [ ] Build succeeds with 0 errors and 0 warnings
- [ ] All ~25 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete for all public APIs
- [ ] Logging follows specified patterns

---

## 17. Dependencies

### Requires (from prior versions)
- v0.1.1b: `SeededRandomService`, `ISeededRandomService`
- v0.1.1a: `TemplateSlot`, `RoomTemplate`
- v0.1.0c: `RoomType` enum
- v0.1.0a: `Position3D` value object
- v0.0.11a: `EnvironmentContext`
- v0.0.9c: `TierService`, `ITierService`, `TierDefinition`
- v0.0.9d: `LootService`, `ILootService`
- v0.0.x: `MonsterService`, `IMonsterService`

### Provides (for future versions)
- `DifficultyRating` for v0.1.1d branch generation
- `ContentPlacementService` for all procedural content
- Scaling infrastructure for difficulty balancing

---

## 18. Future Considerations

### Deferred to v0.1.1d: Branch Generation
- Branch path difficulty variance
- Dead end difficulty penalties
- Loop difficulty considerations

### Deferred to Future Versions
- Dynamic difficulty adjustment based on player performance
- Difficulty presets (Easy, Normal, Hard)
- Per-biome difficulty modifiers
- Elite/Boss encounter minimum difficulty thresholds

### Out of Scope
- Real-time difficulty scaling during combat
- Player-selected difficulty modes
- Difficulty-based XP scaling

---

*Document Version: 1.0*
*Last Updated: 2026-01-08*
*Author: Claude*
