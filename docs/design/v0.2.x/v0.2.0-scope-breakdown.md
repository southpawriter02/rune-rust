# v0.2.0 NPCs & Dialogue - Scope Breakdown

**Version:** 0.2.0
**Theme:** NPCs & Dialogue
**Prerequisites:** v0.1.5 Complete (Procedural Puzzles & Secrets)
**Total Estimated Tests:** ~120 new tests

---

## Executive Summary

The NPCs & Dialogue version introduces non-combat interactions to the dungeon, transforming it from a purely hostile environment into a living world with friendly characters, branching conversations, and social dynamics. Players can talk to NPCs, navigate dialogue trees with meaningful choices, build relationships through reputation, and eventually recruit companions to fight alongside them.

Key focus areas:
- **NPC Entity**: Foundation for friendly dungeon characters with attitudes and memory
- **Talk Command & Dialogue Trees**: Branching conversations with choices and conditions
- **Dialogue Outcomes**: Choices that affect relationships and unlock options
- **NPC Types & Attitudes**: Merchants, quest givers, companions with dynamic dispositions
- **Faction/Reputation**: Social standing that influences NPC behavior
- **NPC Companions**: Recruitable allies with equipment and combat capabilities

The work is divided into **four sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.2.0a | NPC Foundation | NPC entity, attitudes, talk command, basic dialogue | ~30 |
| v0.2.0b | Dialogue System | Dialogue trees, conditions, branching logic, outcomes | ~35 |
| v0.2.0c | Reputation & Memory | Faction/reputation system, NPC memory, attitude changes | ~30 |
| v0.2.0d | Companions | NPC recruitment, companion management, combat integration | ~25 |

---

## Existing Infrastructure

### Already Implemented (from previous versions)

| Feature | Location | Notes |
|---------|----------|-------|
| Room entity | `Domain/Entities/Room.cs` | Container for NPCs |
| Player entity | `Domain/Entities/Player.cs` | Dialogue participant |
| CombatEncounter | `Domain/Entities/CombatEncounter.cs` | Combat participation |
| Combatant | `Domain/Entities/Combatant.cs` | Combat representation |
| DicePool | `Domain/ValueObjects/DicePool.cs` | Persuasion checks |
| SkillDefinition | `Domain/Definitions/SkillDefinition.cs` | Social skills |
| SkillCheckResult | `Domain/ValueObjects/SkillCheckResult.cs` | Check outcomes |
| Item entity | `Domain/Entities/Item.cs` | Companion equipment |
| EquipmentService | `Domain/Services/EquipmentService.cs` | Companion equipping |
| GameSessionService | `Application/Services/GameSessionService.cs` | Command processing |
| IConfigurationProvider | `Application/Interfaces/IConfigurationProvider.cs` | JSON loading |

### Needs Implementation (v0.2.0)

| Feature | Phase | Notes |
|---------|-------|-------|
| NPC entity | v0.2.0a | Core NPC representation |
| NPCDefinition | v0.2.0a | NPC templates from JSON |
| NPCAttitude enum | v0.2.0a | Relationship states |
| NPCType enum | v0.2.0a | NPC role categories |
| DialogueNode | v0.2.0b | Dialogue tree structure |
| DialogueOption | v0.2.0b | Player choices |
| DialogueCondition | v0.2.0b | Branching logic |
| DialogueOutcome | v0.2.0b | Choice consequences |
| FactionDefinition | v0.2.0c | Group identity |
| ReputationLevel | v0.2.0c | Standing thresholds |
| NPCMemory | v0.2.0c | Interaction history |
| Companion entity | v0.2.0d | Recruitable allies |
| CompanionService | v0.2.0d | Companion management |

---

## Feature Analysis & Categorization

### NPC Foundation Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| NPC entity | High | Room | **v0.2.0a** |
| NPCDefinition configuration | Medium | IConfigurationProvider | **v0.2.0a** |
| NPCType enum | Low | None | **v0.2.0a** |
| NPCAttitude enum | Low | None | **v0.2.0a** |
| Talk command | Medium | NPC, GameSessionService | **v0.2.0a** |
| Room.NPCs collection | Medium | Room, NPC | **v0.2.0a** |
| Basic dialogue display | Medium | NPC, IGameRenderer | **v0.2.0a** |

### Dialogue System Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| DialogueNode entity | High | NPC | **v0.2.0b** |
| DialogueOption value object | Medium | DialogueNode | **v0.2.0b** |
| DialogueCondition value object | Medium | DialogueOption | **v0.2.0b** |
| DialogueOutcome value object | Medium | DialogueOption | **v0.2.0b** |
| Dialogue tree navigation | High | DialogueNode | **v0.2.0b** |
| DialogueService | High | All dialogue entities | **v0.2.0b** |
| Persuasion checks | Medium | DicePool, SkillDefinition | **v0.2.0b** |
| Condition evaluation | High | DialogueCondition | **v0.2.0b** |

### Reputation Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| FactionDefinition entity | High | None | **v0.2.0c** |
| ReputationLevel enum | Low | None | **v0.2.0c** |
| ReputationService | High | FactionDefinition | **v0.2.0c** |
| NPCMemory value object | Medium | NPC | **v0.2.0c** |
| Attitude change mechanics | Medium | NPCAttitude, Reputation | **v0.2.0c** |
| Player.Reputation tracking | Medium | Player, FactionDefinition | **v0.2.0c** |
| Memory-based dialogue | Medium | NPCMemory, DialogueCondition | **v0.2.0c** |

### Companion Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| Companion entity | High | NPC, Combatant | **v0.2.0d** |
| CompanionService | High | Companion | **v0.2.0d** |
| Recruitment dialogue | Medium | DialogueOutcome | **v0.2.0d** |
| Companion equipment | Medium | Item, EquipmentService | **v0.2.0d** |
| Companion combat integration | High | CombatEncounter | **v0.2.0d** |
| Companion commands | Medium | CompanionService | **v0.2.0d** |

---

## Phase Definitions

---

## v0.2.0a: NPC Foundation

### Overview

Establish the core NPC system including the entity model, type classification, attitude tracking, and the talk command. This phase enables players to encounter and interact with friendly characters in the dungeon through basic dialogue.

### Scope

**In Scope:**
- `NPC` entity with identity, type, and attitude
- `NPCDefinition` configuration for NPC templates
- `NPCType` enum (Merchant, QuestGiver, Informant, Companion, Wanderer)
- `NPCAttitude` enum (Friendly, Neutral, Wary, Hostile)
- `talk` command to initiate dialogue
- Room modification to contain NPCs
- Basic dialogue display (greeting text)
- NPC appearance in room descriptions

**Out of Scope:**
- Dialogue trees and branching (v0.2.0b)
- Persuasion checks (v0.2.0b)
- Faction and reputation (v0.2.0c)
- NPC memory (v0.2.0c)
- Companion recruitment (v0.2.0d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `NPC` |
| Definitions | 1 | `NPCDefinition` |
| Enums | 2 | `NPCType`, `NPCAttitude` |
| Value Objects | 1 | `NPCAppearance` |
| Commands | 1 | `talk` |
| Configuration | 1 | `npcs.json` |
| Room Updates | 1 | Add `NPCs` collection |
| Unit Tests | ~30 | Entity, service, command tests |

### NPC Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a non-player character in the dungeon.
/// </summary>
public class NPC : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the NPC's definition ID for configuration lookup.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's type/role.
    /// </summary>
    public NPCType Type { get; private set; }

    /// <summary>
    /// Gets the NPC's current attitude toward the player.
    /// </summary>
    public NPCAttitude Attitude { get; private set; }

    /// <summary>
    /// Gets the NPC's base attitude (before modifiers).
    /// </summary>
    public NPCAttitude BaseAttitude { get; private set; }

    /// <summary>
    /// Gets the room this NPC is currently in.
    /// </summary>
    public Guid? CurrentRoomId { get; private set; }

    /// <summary>
    /// Gets the NPC's greeting dialogue.
    /// </summary>
    public string Greeting { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's description.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's appearance details.
    /// </summary>
    public NPCAppearance Appearance { get; private set; } = NPCAppearance.Default;

    /// <summary>
    /// Gets whether this NPC is currently available for interaction.
    /// </summary>
    public bool IsAvailable { get; private set; } = true;

    /// <summary>
    /// Gets the root dialogue node ID for this NPC.
    /// </summary>
    public string? RootDialogueId { get; private set; }

    private NPC() { /* EF Core */ }

    /// <summary>
    /// Creates a new NPC from a definition.
    /// </summary>
    public static NPC Create(
        NPCDefinition definition,
        Guid? roomId = null)
    {
        ArgumentNullException.ThrowIfNull(definition);

        return new NPC
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.Id,
            Name = definition.Name,
            Type = definition.Type,
            Attitude = definition.DefaultAttitude,
            BaseAttitude = definition.DefaultAttitude,
            CurrentRoomId = roomId,
            Greeting = definition.Greeting,
            Description = definition.Description,
            Appearance = definition.Appearance,
            RootDialogueId = definition.RootDialogueId,
            IsAvailable = true
        };
    }

    /// <summary>
    /// Changes the NPC's current attitude.
    /// </summary>
    public void SetAttitude(NPCAttitude attitude)
    {
        Attitude = attitude;
    }

    /// <summary>
    /// Moves the NPC to a different room.
    /// </summary>
    public void MoveTo(Guid roomId)
    {
        CurrentRoomId = roomId;
    }

    /// <summary>
    /// Sets the NPC's availability for interaction.
    /// </summary>
    public void SetAvailability(bool isAvailable)
    {
        IsAvailable = isAvailable;
    }

    /// <summary>
    /// Checks if the NPC is willing to talk based on attitude.
    /// </summary>
    public bool WillTalk()
    {
        return Attitude != NPCAttitude.Hostile && IsAvailable;
    }
}
```

### NPCType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the functional role of an NPC.
/// </summary>
public enum NPCType
{
    /// <summary>NPC that buys and sells items.</summary>
    Merchant,

    /// <summary>NPC that provides quests or objectives.</summary>
    QuestGiver,

    /// <summary>NPC that provides information and hints.</summary>
    Informant,

    /// <summary>NPC that can be recruited as a companion.</summary>
    Companion,

    /// <summary>NPC that wanders with no specific role.</summary>
    Wanderer
}
```

### NPCAttitude Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents an NPC's disposition toward the player.
/// </summary>
public enum NPCAttitude
{
    /// <summary>NPC is helpful and offers good prices/options.</summary>
    Friendly,

    /// <summary>NPC is indifferent, standard interactions.</summary>
    Neutral,

    /// <summary>NPC is suspicious, limited dialogue options.</summary>
    Wary,

    /// <summary>NPC refuses to interact or may attack.</summary>
    Hostile
}
```

### NPCAppearance Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Describes an NPC's visual appearance.
/// </summary>
public readonly record struct NPCAppearance
{
    /// <summary>
    /// Gets the race or species.
    /// </summary>
    public string Race { get; init; }

    /// <summary>
    /// Gets notable physical features.
    /// </summary>
    public string Features { get; init; }

    /// <summary>
    /// Gets clothing or armor description.
    /// </summary>
    public string Attire { get; init; }

    /// <summary>
    /// Gets a default appearance.
    /// </summary>
    public static NPCAppearance Default => new()
    {
        Race = "Human",
        Features = "unremarkable features",
        Attire = "simple clothing"
    };
}
```

### NPCDefinition

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration template for creating NPCs.
/// </summary>
public class NPCDefinition
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's type/role.
    /// </summary>
    public NPCType Type { get; private set; }

    /// <summary>
    /// Gets the NPC's default attitude.
    /// </summary>
    public NPCAttitude DefaultAttitude { get; private set; }

    /// <summary>
    /// Gets the greeting dialogue text.
    /// </summary>
    public string Greeting { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's description.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's appearance.
    /// </summary>
    public NPCAppearance Appearance { get; private set; }

    /// <summary>
    /// Gets the root dialogue node ID.
    /// </summary>
    public string? RootDialogueId { get; private set; }

    /// <summary>
    /// Gets the faction this NPC belongs to.
    /// </summary>
    public string? FactionId { get; private set; }

    private NPCDefinition() { }

    /// <summary>
    /// Creates an NPC definition from configuration.
    /// </summary>
    public static NPCDefinition Create(
        string id,
        string name,
        NPCType type,
        NPCAttitude defaultAttitude,
        string greeting,
        string description,
        NPCAppearance? appearance = null,
        string? rootDialogueId = null,
        string? factionId = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new NPCDefinition
        {
            Id = id,
            Name = name,
            Type = type,
            DefaultAttitude = defaultAttitude,
            Greeting = greeting,
            Description = description,
            Appearance = appearance ?? NPCAppearance.Default,
            RootDialogueId = rootDialogueId,
            FactionId = factionId
        };
    }
}
```

### Room Modification

```
MODIFY: Room
├── ADD: NPCs: IReadOnlyList<NPC>
├── ADD: AddNPC(NPC npc): void
├── ADD: RemoveNPC(Guid npcId): bool
└── ADD: GetNPC(string nameOrId): NPC?
```

### User-Facing Changes

**Commands:**
```
> talk                    # Talk to the only NPC in the room
> talk <npc>              # Talk to a specific NPC by name
> look                    # Room description now shows NPCs
```

**Output Example:**
```
You are in a dusty merchant's alcove. Wooden shelves line the walls,
filled with various wares.

You see: Grimbold the Trader

Exits: north, south

> talk
Grimbold looks up from his ledger. "Ah, a customer! Welcome, welcome.
What brings you to my humble shop in these dangerous depths?"

[Dialogue options will be available in v0.2.0b]
```

### Configuration Example

```json
{
  "$schema": "../schemas/npcs.schema.json",
  "npcs": [
    {
      "id": "grimbold-trader",
      "name": "Grimbold the Trader",
      "type": "Merchant",
      "defaultAttitude": "Neutral",
      "greeting": "Ah, a customer! Welcome, welcome. What brings you to my humble shop?",
      "description": "A stout dwarf with a braided beard sits behind a worn counter.",
      "appearance": {
        "race": "Dwarf",
        "features": "braided gray beard, shrewd eyes",
        "attire": "leather apron over chainmail"
      },
      "rootDialogueId": "grimbold-main",
      "factionId": "merchant-guild"
    },
    {
      "id": "elara-wanderer",
      "name": "Elara",
      "type": "Informant",
      "defaultAttitude": "Wary",
      "greeting": "Keep your voice down. These walls have ears.",
      "description": "A cloaked figure leans against the wall, watching you carefully.",
      "appearance": {
        "race": "Elf",
        "features": "sharp features, alert eyes",
        "attire": "dark traveling cloak"
      },
      "rootDialogueId": "elara-secrets"
    }
  ]
}
```

### Acceptance Criteria

- [ ] NPC entity can be created from NPCDefinition
- [ ] NPCType enum covers all specified types
- [ ] NPCAttitude enum reflects relationship states
- [ ] `talk` command initiates dialogue with NPC
- [ ] `talk <name>` targets specific NPC when multiple present
- [ ] Room descriptions include NPC names
- [ ] NPC greeting displays on successful talk
- [ ] Hostile NPCs refuse dialogue
- [ ] NPCs can be configured via JSON
- [ ] ~30 unit tests pass

---

## v0.2.0b: Dialogue System

### Overview

Implement the full dialogue tree system with branching conversations, conditional options, persuasion checks, and dialogue outcomes. This enables rich, non-linear conversations where player choices matter.

### Scope

**In Scope:**
- `DialogueNode` entity for conversation nodes
- `DialogueOption` value object for player choices
- `DialogueCondition` value object for branching logic
- `DialogueOutcome` value object for consequences
- `DialogueService` for tree navigation
- Persuasion skill checks in dialogue
- Condition evaluation engine
- Dialogue state tracking per NPC

**Out of Scope:**
- Faction/reputation conditions (v0.2.0c)
- Memory-based conditions (v0.2.0c)
- Companion recruitment outcomes (v0.2.0d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `DialogueNode` |
| Value Objects | 4 | `DialogueOption`, `DialogueCondition`, `DialogueOutcome`, `DialogueState` |
| Enums | 3 | `ConditionType`, `OutcomeType`, `DialogueTag` |
| Services | 1 | `DialogueService` |
| Configuration | 1 | `dialogues.json` |
| Unit Tests | ~35 | Dialogue navigation, condition, outcome tests |

### DialogueNode Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a node in a dialogue tree.
/// </summary>
public class DialogueNode : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the node's string ID for configuration reference.
    /// </summary>
    public string NodeId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the NPC's dialogue text at this node.
    /// </summary>
    public string Text { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the speaker name (usually NPC name, but can vary).
    /// </summary>
    public string Speaker { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the available dialogue options from this node.
    /// </summary>
    public IReadOnlyList<DialogueOption> Options { get; private set; } = Array.Empty<DialogueOption>();

    /// <summary>
    /// Gets tags for categorization and searching.
    /// </summary>
    public IReadOnlyList<DialogueTag> Tags { get; private set; } = Array.Empty<DialogueTag>();

    /// <summary>
    /// Gets whether this is a terminal node (ends conversation).
    /// </summary>
    public bool IsTerminal { get; private set; }

    /// <summary>
    /// Gets outcomes that trigger when reaching this node.
    /// </summary>
    public IReadOnlyList<DialogueOutcome> OnEnterOutcomes { get; private set; } = Array.Empty<DialogueOutcome>();

    private DialogueNode() { }

    /// <summary>
    /// Creates a dialogue node from configuration.
    /// </summary>
    public static DialogueNode Create(
        string nodeId,
        string text,
        string speaker,
        IEnumerable<DialogueOption>? options = null,
        IEnumerable<DialogueTag>? tags = null,
        bool isTerminal = false,
        IEnumerable<DialogueOutcome>? onEnterOutcomes = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(nodeId);
        ArgumentException.ThrowIfNullOrWhiteSpace(text);

        return new DialogueNode
        {
            Id = Guid.NewGuid(),
            NodeId = nodeId,
            Text = text,
            Speaker = speaker,
            Options = options?.ToList() ?? new List<DialogueOption>(),
            Tags = tags?.ToList() ?? new List<DialogueTag>(),
            IsTerminal = isTerminal || !(options?.Any() ?? false),
            OnEnterOutcomes = onEnterOutcomes?.ToList() ?? new List<DialogueOutcome>()
        };
    }

    /// <summary>
    /// Gets options available given current conditions.
    /// </summary>
    public IEnumerable<DialogueOption> GetAvailableOptions(DialogueContext context)
    {
        return Options.Where(o => o.IsAvailable(context));
    }
}
```

### DialogueOption Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a player choice in dialogue.
/// </summary>
public readonly record struct DialogueOption
{
    /// <summary>
    /// Gets the option's display text.
    /// </summary>
    public string Text { get; init; }

    /// <summary>
    /// Gets the target node ID if selected.
    /// </summary>
    public string TargetNodeId { get; init; }

    /// <summary>
    /// Gets conditions required to show this option.
    /// </summary>
    public IReadOnlyList<DialogueCondition> Conditions { get; init; }

    /// <summary>
    /// Gets outcomes triggered when selecting this option.
    /// </summary>
    public IReadOnlyList<DialogueOutcome> Outcomes { get; init; }

    /// <summary>
    /// Gets the required skill check, if any.
    /// </summary>
    public PersuasionCheck? SkillCheck { get; init; }

    /// <summary>
    /// Gets whether this option is only shown once.
    /// </summary>
    public bool OneTimeOnly { get; init; }

    /// <summary>
    /// Checks if this option is available in the given context.
    /// </summary>
    public bool IsAvailable(DialogueContext context)
    {
        if (Conditions.Count == 0) return true;
        return Conditions.All(c => c.Evaluate(context));
    }
}

/// <summary>
/// Represents a skill check required for a dialogue option.
/// </summary>
public readonly record struct PersuasionCheck
{
    /// <summary>
    /// Gets the skill ID to check.
    /// </summary>
    public string SkillId { get; init; }

    /// <summary>
    /// Gets the difficulty class.
    /// </summary>
    public int DC { get; init; }

    /// <summary>
    /// Gets the node ID on failure.
    /// </summary>
    public string FailureNodeId { get; init; }

    /// <summary>
    /// Gets the node ID on critical failure.
    /// </summary>
    public string? CriticalFailureNodeId { get; init; }
}
```

### DialogueCondition Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a condition for dialogue branching.
/// </summary>
public readonly record struct DialogueCondition
{
    /// <summary>
    /// Gets the condition type.
    /// </summary>
    public ConditionType Type { get; init; }

    /// <summary>
    /// Gets the target ID (item, quest, flag, etc.).
    /// </summary>
    public string TargetId { get; init; }

    /// <summary>
    /// Gets the comparison operator.
    /// </summary>
    public ComparisonOperator Operator { get; init; }

    /// <summary>
    /// Gets the value to compare against.
    /// </summary>
    public int Value { get; init; }

    /// <summary>
    /// Gets whether to negate the result.
    /// </summary>
    public bool Negate { get; init; }

    /// <summary>
    /// Evaluates the condition in the given context.
    /// </summary>
    public bool Evaluate(DialogueContext context)
    {
        var result = Type switch
        {
            ConditionType.HasItem => context.HasItem(TargetId, Value),
            ConditionType.HasGold => Compare(context.Gold, Value),
            ConditionType.PlayerLevel => Compare(context.PlayerLevel, Value),
            ConditionType.StatCheck => Compare(context.GetStat(TargetId), Value),
            ConditionType.FlagSet => context.HasFlag(TargetId),
            ConditionType.QuestState => context.GetQuestState(TargetId) == Value,
            ConditionType.AttitudeAtLeast => (int)context.NPCAttitude >= Value,
            ConditionType.ReputationAtLeast => Compare(context.GetReputation(TargetId), Value),
            ConditionType.PreviousChoice => context.MadeChoice(TargetId),
            _ => false
        };

        return Negate ? !result : result;
    }

    private bool Compare(int actual, int expected)
    {
        return Operator switch
        {
            ComparisonOperator.Equal => actual == expected,
            ComparisonOperator.NotEqual => actual != expected,
            ComparisonOperator.GreaterThan => actual > expected,
            ComparisonOperator.LessThan => actual < expected,
            ComparisonOperator.GreaterOrEqual => actual >= expected,
            ComparisonOperator.LessOrEqual => actual <= expected,
            _ => false
        };
    }
}
```

### ConditionType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of conditions for dialogue branching.
/// </summary>
public enum ConditionType
{
    /// <summary>Player has item in inventory.</summary>
    HasItem,

    /// <summary>Player has minimum gold.</summary>
    HasGold,

    /// <summary>Player level check.</summary>
    PlayerLevel,

    /// <summary>Player stat check.</summary>
    StatCheck,

    /// <summary>Global flag is set.</summary>
    FlagSet,

    /// <summary>Quest is in specific state.</summary>
    QuestState,

    /// <summary>NPC attitude is at least value.</summary>
    AttitudeAtLeast,

    /// <summary>Faction reputation is at least value.</summary>
    ReputationAtLeast,

    /// <summary>Player made a previous dialogue choice.</summary>
    PreviousChoice
}

/// <summary>
/// Comparison operators for conditions.
/// </summary>
public enum ComparisonOperator
{
    Equal,
    NotEqual,
    GreaterThan,
    LessThan,
    GreaterOrEqual,
    LessOrEqual
}
```

### DialogueOutcome Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a consequence of a dialogue choice.
/// </summary>
public readonly record struct DialogueOutcome
{
    /// <summary>
    /// Gets the outcome type.
    /// </summary>
    public OutcomeType Type { get; init; }

    /// <summary>
    /// Gets the target ID (item, faction, flag, etc.).
    /// </summary>
    public string TargetId { get; init; }

    /// <summary>
    /// Gets the value for the outcome.
    /// </summary>
    public int Value { get; init; }

    /// <summary>
    /// Gets additional data for complex outcomes.
    /// </summary>
    public string? Data { get; init; }
}

/// <summary>
/// Types of dialogue outcomes.
/// </summary>
public enum OutcomeType
{
    /// <summary>Give item to player.</summary>
    GiveItem,

    /// <summary>Take item from player.</summary>
    TakeItem,

    /// <summary>Give gold to player.</summary>
    GiveGold,

    /// <summary>Take gold from player.</summary>
    TakeGold,

    /// <summary>Set a global flag.</summary>
    SetFlag,

    /// <summary>Clear a global flag.</summary>
    ClearFlag,

    /// <summary>Change NPC attitude.</summary>
    ChangeAttitude,

    /// <summary>Change faction reputation.</summary>
    ChangeReputation,

    /// <summary>Start a quest.</summary>
    StartQuest,

    /// <summary>Advance quest state.</summary>
    AdvanceQuest,

    /// <summary>Unlock dialogue option.</summary>
    UnlockDialogue,

    /// <summary>Recruit companion.</summary>
    RecruitCompanion,

    /// <summary>Trigger combat.</summary>
    TriggerCombat
}
```

### DialogueService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages dialogue tree navigation and state.
/// </summary>
public interface IDialogueService
{
    /// <summary>
    /// Starts a dialogue with an NPC.
    /// </summary>
    DialogueResult StartDialogue(NPC npc, Player player);

    /// <summary>
    /// Selects a dialogue option.
    /// </summary>
    DialogueResult SelectOption(Guid dialogueStateId, int optionIndex);

    /// <summary>
    /// Gets the current dialogue state.
    /// </summary>
    DialogueState? GetCurrentState(Guid playerId, Guid npcId);

    /// <summary>
    /// Ends the current dialogue.
    /// </summary>
    void EndDialogue(Guid dialogueStateId);

    /// <summary>
    /// Processes a persuasion check for a dialogue option.
    /// </summary>
    PersuasionResult AttemptPersuasion(
        Guid dialogueStateId,
        int optionIndex,
        Player player);
}
```

### User-Facing Changes

**Commands:**
```
> talk                    # Start dialogue, shows first node
> 1                       # Select option 1
> 2                       # Select option 2
> [Persuade]              # Attempt persuasion check
> goodbye                 # End dialogue early
```

**Output Example:**
```
Grimbold: "So, you're interested in my wares? I have many fine items,
though some are... reserved for special customers."

[1] What items do you have for sale?
[2] What do you mean by 'special customers'?
[3] [Persuade DC 12] I'm sure we can come to an arrangement.
[4] Goodbye.

> 3
[Persuasion Check: DC 12]
Rolling 2d6 + Charisma (2)...
Rolled: 4, 5 = 9 + 2 = 11
Failed!

Grimbold narrows his eyes. "Nice try, but you'll need to earn my trust
the old-fashioned way. Come back when you've proven yourself."
```

### Configuration Example

```json
{
  "dialogues": {
    "grimbold-main": {
      "nodeId": "grimbold-main",
      "speaker": "Grimbold",
      "text": "So, you're interested in my wares? I have many fine items, though some are... reserved for special customers.",
      "options": [
        {
          "text": "What items do you have for sale?",
          "targetNodeId": "grimbold-shop"
        },
        {
          "text": "What do you mean by 'special customers'?",
          "targetNodeId": "grimbold-special",
          "conditions": [
            { "type": "AttitudeAtLeast", "value": 1 }
          ]
        },
        {
          "text": "[Persuade DC 12] I'm sure we can come to an arrangement.",
          "targetNodeId": "grimbold-persuaded",
          "skillCheck": {
            "skillId": "persuasion",
            "dc": 12,
            "failureNodeId": "grimbold-refuse"
          }
        },
        {
          "text": "Goodbye.",
          "targetNodeId": "grimbold-farewell"
        }
      ]
    }
  }
}
```

### Acceptance Criteria

- [ ] DialogueNode can be created and navigated
- [ ] DialogueOption conditions evaluate correctly
- [ ] Multiple condition types function (HasItem, HasGold, etc.)
- [ ] Persuasion checks integrate with dice system
- [ ] Dialogue outcomes execute (give/take items, set flags, etc.)
- [ ] Dialogue state persists during conversation
- [ ] One-time options don't repeat after selection
- [ ] Terminal nodes end dialogue properly
- [ ] Dialogue can be configured via JSON
- [ ] ~35 unit tests pass

---

## v0.2.0c: Reputation & Memory

### Overview

Add faction reputation tracking and NPC memory to create persistent social dynamics. NPCs remember past interactions and react differently based on the player's standing with their community.

### Scope

**In Scope:**
- `FactionDefinition` entity for group identity
- `ReputationLevel` enum for standing thresholds
- `ReputationService` for reputation management
- `NPCMemory` value object for interaction history
- Player reputation tracking per faction
- Attitude changes based on reputation
- Memory-based dialogue conditions
- Reputation gain/loss from dialogue outcomes

**Out of Scope:**
- Companion recruitment (v0.2.0d)
- Cross-faction relationships (future version)
- Reputation decay over time (future version)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Definitions | 1 | `FactionDefinition` |
| Value Objects | 2 | `ReputationStanding`, `NPCMemory` |
| Enums | 1 | `ReputationLevel` |
| Services | 1 | `ReputationService` |
| Player Updates | 1 | Add reputation tracking |
| NPC Updates | 1 | Add memory tracking |
| Configuration | 1 | `factions.json` |
| Unit Tests | ~30 | Reputation, memory, attitude tests |

### FactionDefinition

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a faction that NPCs can belong to.
/// </summary>
public class FactionDefinition
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the faction's display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the faction's description.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the starting reputation with this faction.
    /// </summary>
    public int DefaultReputation { get; private set; }

    /// <summary>
    /// Gets reputation thresholds for each level.
    /// </summary>
    public IReadOnlyDictionary<ReputationLevel, int> Thresholds { get; private set; }
        = new Dictionary<ReputationLevel, int>();

    /// <summary>
    /// Gets allied faction IDs.
    /// </summary>
    public IReadOnlyList<string> Allies { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets enemy faction IDs.
    /// </summary>
    public IReadOnlyList<string> Enemies { get; private set; } = Array.Empty<string>();

    private FactionDefinition() { }

    /// <summary>
    /// Creates a faction definition.
    /// </summary>
    public static FactionDefinition Create(
        string id,
        string name,
        string description,
        int defaultReputation = 0,
        Dictionary<ReputationLevel, int>? thresholds = null,
        IEnumerable<string>? allies = null,
        IEnumerable<string>? enemies = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new FactionDefinition
        {
            Id = id,
            Name = name,
            Description = description,
            DefaultReputation = defaultReputation,
            Thresholds = thresholds ?? GetDefaultThresholds(),
            Allies = allies?.ToList() ?? new List<string>(),
            Enemies = enemies?.ToList() ?? new List<string>()
        };
    }

    /// <summary>
    /// Gets the reputation level for a given value.
    /// </summary>
    public ReputationLevel GetLevel(int reputation)
    {
        if (reputation >= Thresholds[ReputationLevel.Exalted]) return ReputationLevel.Exalted;
        if (reputation >= Thresholds[ReputationLevel.Revered]) return ReputationLevel.Revered;
        if (reputation >= Thresholds[ReputationLevel.Honored]) return ReputationLevel.Honored;
        if (reputation >= Thresholds[ReputationLevel.Friendly]) return ReputationLevel.Friendly;
        if (reputation >= Thresholds[ReputationLevel.Neutral]) return ReputationLevel.Neutral;
        if (reputation >= Thresholds[ReputationLevel.Unfriendly]) return ReputationLevel.Unfriendly;
        if (reputation >= Thresholds[ReputationLevel.Hostile]) return ReputationLevel.Hostile;
        return ReputationLevel.Hated;
    }

    private static Dictionary<ReputationLevel, int> GetDefaultThresholds() => new()
    {
        [ReputationLevel.Hated] = int.MinValue,
        [ReputationLevel.Hostile] = -1000,
        [ReputationLevel.Unfriendly] = -500,
        [ReputationLevel.Neutral] = 0,
        [ReputationLevel.Friendly] = 500,
        [ReputationLevel.Honored] = 1000,
        [ReputationLevel.Revered] = 2000,
        [ReputationLevel.Exalted] = 3000
    };
}
```

### ReputationLevel Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents standing levels with a faction.
/// </summary>
public enum ReputationLevel
{
    /// <summary>Maximum hostility, attacked on sight.</summary>
    Hated = -4,

    /// <summary>NPCs refuse interaction, may attack.</summary>
    Hostile = -3,

    /// <summary>Limited dialogue, poor prices.</summary>
    Unfriendly = -2,

    /// <summary>Standard interactions.</summary>
    Neutral = 0,

    /// <summary>Slightly better prices, more options.</summary>
    Friendly = 1,

    /// <summary>Good prices, special dialogue.</summary>
    Honored = 2,

    /// <summary>Very good prices, unique items.</summary>
    Revered = 3,

    /// <summary>Best prices, all options available.</summary>
    Exalted = 4
}
```

### NPCMemory Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks an NPC's memory of player interactions.
/// </summary>
public class NPCMemory
{
    /// <summary>
    /// Gets the player ID this memory belongs to.
    /// </summary>
    public Guid PlayerId { get; private set; }

    /// <summary>
    /// Gets the number of times the player has talked to this NPC.
    /// </summary>
    public int InteractionCount { get; private set; }

    /// <summary>
    /// Gets the last interaction timestamp.
    /// </summary>
    public DateTime? LastInteraction { get; private set; }

    /// <summary>
    /// Gets dialogue choices the player has made.
    /// </summary>
    public IReadOnlyList<string> ChoicesMade { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets custom memory flags.
    /// </summary>
    public IReadOnlyDictionary<string, string> Flags { get; private set; }
        = new Dictionary<string, string>();

    /// <summary>
    /// Gets whether the player has been hostile to this NPC.
    /// </summary>
    public bool WasHostile { get; private set; }

    /// <summary>
    /// Gets whether the player has helped this NPC.
    /// </summary>
    public bool WasHelpful { get; private set; }

    private NPCMemory() { }

    /// <summary>
    /// Creates a new memory instance for a player.
    /// </summary>
    public static NPCMemory Create(Guid playerId)
    {
        return new NPCMemory
        {
            PlayerId = playerId,
            InteractionCount = 0
        };
    }

    /// <summary>
    /// Records an interaction.
    /// </summary>
    public void RecordInteraction()
    {
        InteractionCount++;
        LastInteraction = DateTime.UtcNow;
    }

    /// <summary>
    /// Records a dialogue choice.
    /// </summary>
    public void RecordChoice(string choiceId)
    {
        var choices = ChoicesMade.ToList();
        if (!choices.Contains(choiceId))
        {
            choices.Add(choiceId);
            ChoicesMade = choices;
        }
    }

    /// <summary>
    /// Sets a memory flag.
    /// </summary>
    public void SetFlag(string key, string value)
    {
        var flags = new Dictionary<string, string>(Flags)
        {
            [key] = value
        };
        Flags = flags;
    }

    /// <summary>
    /// Records hostile behavior.
    /// </summary>
    public void MarkHostile() => WasHostile = true;

    /// <summary>
    /// Records helpful behavior.
    /// </summary>
    public void MarkHelpful() => WasHelpful = true;
}
```

### Player Modification

```
MODIFY: Player
├── ADD: Reputation: Dictionary<string, int> (factionId -> value)
├── ADD: GetReputation(string factionId): int
├── ADD: ModifyReputation(string factionId, int delta): void
└── ADD: GetReputationLevel(FactionDefinition faction): ReputationLevel
```

### NPC Modification

```
MODIFY: NPC
├── ADD: Memory: Dictionary<Guid, NPCMemory> (playerId -> memory)
├── ADD: GetMemory(Guid playerId): NPCMemory
├── ADD: UpdateAttitudeFromReputation(int reputation, FactionDefinition faction): void
└── ADD: RememberChoice(Guid playerId, string choiceId): void
```

### User-Facing Changes

**Commands:**
```
> reputation              # View faction standings
> reputation <faction>    # View specific faction standing
```

**Output Example:**
```
> reputation
Your Reputation:

Merchant Guild: Friendly (750/1000 to Honored)
  ████████░░ 75%

Thieves' Syndicate: Unfriendly (-350/-500 to Neutral)
  ███░░░░░░░ 30%

Adventurer's League: Neutral (0/500 to Friendly)
  ░░░░░░░░░░ 0%

---

> talk grimbold
Grimbold smiles as you approach. "Ah, my favorite customer returns!
For you, I have some special items set aside."

[The Merchant Guild's reputation unlocked new dialogue options]
```

### Configuration Example

```json
{
  "$schema": "../schemas/factions.schema.json",
  "factions": [
    {
      "id": "merchant-guild",
      "name": "Merchant Guild",
      "description": "A network of traders and shopkeepers.",
      "defaultReputation": 0,
      "thresholds": {
        "hated": -2000,
        "hostile": -1000,
        "unfriendly": -500,
        "neutral": 0,
        "friendly": 500,
        "honored": 1000,
        "revered": 2000,
        "exalted": 3000
      },
      "allies": ["adventurers-league"],
      "enemies": ["thieves-syndicate"]
    },
    {
      "id": "thieves-syndicate",
      "name": "Thieves' Syndicate",
      "description": "A shadowy network operating in the dungeon depths.",
      "defaultReputation": -200,
      "enemies": ["merchant-guild"]
    }
  ]
}
```

### Acceptance Criteria

- [ ] FactionDefinition can be loaded from configuration
- [ ] ReputationLevel correctly maps from numeric values
- [ ] Player reputation tracks per faction
- [ ] Reputation changes propagate to allied/enemy factions
- [ ] NPCMemory records interactions and choices
- [ ] NPC attitude updates based on faction reputation
- [ ] Memory-based dialogue conditions work
- [ ] `reputation` command displays standings
- [ ] First-time vs returning dialogue differs
- [ ] ~30 unit tests pass

---

## v0.2.0d: Companions

### Overview

Enable players to recruit NPCs as companions who fight alongside them in combat. Companions can be equipped, given orders, and level up with the player.

### Scope

**In Scope:**
- `Companion` entity extending NPC for party members
- `CompanionService` for management and orders
- Recruitment through dialogue outcomes
- Companion equipment system
- Combat integration (companions as combatants)
- Basic companion commands (follow, wait, dismiss)
- Companion display in party status

**Out of Scope:**
- Companion AI customization (future version)
- Companion skill trees (future version)
- Romance/deep relationship systems (future version)
- Multiple companion management (future version - limit to 1 for v0.2.0)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `Companion` |
| Value Objects | 2 | `CompanionStats`, `CompanionOrder` |
| Enums | 1 | `CompanionState` |
| Services | 1 | `CompanionService` |
| Commands | 4 | `party`, `order`, `equip companion`, `dismiss` |
| Combat Updates | 1 | Companion as combatant |
| Unit Tests | ~25 | Companion management, combat integration tests |

### Companion Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a recruited NPC companion.
/// </summary>
public class Companion : IEntity, IEffectTarget
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the underlying NPC.
    /// </summary>
    public NPC NPC { get; private set; } = null!;

    /// <summary>
    /// Gets the owning player ID.
    /// </summary>
    public Guid PlayerId { get; private set; }

    /// <summary>
    /// Gets the companion's current state.
    /// </summary>
    public CompanionState State { get; private set; }

    /// <summary>
    /// Gets the companion's combat stats.
    /// </summary>
    public CompanionStats Stats { get; private set; } = null!;

    /// <summary>
    /// Gets the companion's current health.
    /// </summary>
    public int CurrentHealth { get; private set; }

    /// <summary>
    /// Gets the companion's maximum health.
    /// </summary>
    public int MaxHealth => Stats.MaxHealth;

    /// <summary>
    /// Gets the companion's equipped items.
    /// </summary>
    public IReadOnlyDictionary<EquipmentSlot, Item> Equipment { get; private set; }
        = new Dictionary<EquipmentSlot, Item>();

    /// <summary>
    /// Gets the current order given to this companion.
    /// </summary>
    public CompanionOrder CurrentOrder { get; private set; }

    /// <summary>
    /// Gets the companion's level.
    /// </summary>
    public int Level { get; private set; }

    /// <summary>
    /// Gets active status effects on this companion.
    /// </summary>
    public IReadOnlyList<ActiveStatusEffect> StatusEffects { get; private set; }
        = Array.Empty<ActiveStatusEffect>();

    private Companion() { }

    /// <summary>
    /// Recruits an NPC as a companion.
    /// </summary>
    public static Companion Recruit(NPC npc, Guid playerId, CompanionStats baseStats)
    {
        ArgumentNullException.ThrowIfNull(npc);

        var companion = new Companion
        {
            Id = Guid.NewGuid(),
            NPC = npc,
            PlayerId = playerId,
            State = CompanionState.Following,
            Stats = baseStats,
            Level = 1,
            CurrentOrder = CompanionOrder.Default
        };

        companion.CurrentHealth = companion.MaxHealth;
        npc.SetAvailability(false);

        return companion;
    }

    /// <summary>
    /// Takes damage, reducing health.
    /// </summary>
    public int TakeDamage(int amount)
    {
        var actual = Math.Min(amount, CurrentHealth);
        CurrentHealth -= actual;
        return actual;
    }

    /// <summary>
    /// Heals the companion.
    /// </summary>
    public int Heal(int amount)
    {
        var actual = Math.Min(amount, MaxHealth - CurrentHealth);
        CurrentHealth += actual;
        return actual;
    }

    /// <summary>
    /// Sets the companion's current order.
    /// </summary>
    public void SetOrder(CompanionOrder order)
    {
        CurrentOrder = order;
    }

    /// <summary>
    /// Sets the companion's state.
    /// </summary>
    public void SetState(CompanionState state)
    {
        State = state;
    }

    /// <summary>
    /// Equips an item to the companion.
    /// </summary>
    public EquipResult Equip(Item item, EquipmentSlot slot)
    {
        if (!item.IsEquippable)
            return EquipResult.Failure("Item cannot be equipped.");

        var equipment = new Dictionary<EquipmentSlot, Item>(Equipment);
        Item? previousItem = null;

        if (equipment.TryGetValue(slot, out var existing))
        {
            previousItem = existing;
        }

        equipment[slot] = item;
        Equipment = equipment;

        return EquipResult.Success(item, previousItem);
    }

    /// <summary>
    /// Unequips an item from a slot.
    /// </summary>
    public Item? Unequip(EquipmentSlot slot)
    {
        var equipment = new Dictionary<EquipmentSlot, Item>(Equipment);

        if (!equipment.TryGetValue(slot, out var item))
            return null;

        equipment.Remove(slot);
        Equipment = equipment;

        return item;
    }

    /// <summary>
    /// Dismisses the companion, returning them to NPC state.
    /// </summary>
    public void Dismiss()
    {
        State = CompanionState.Dismissed;
        NPC.SetAvailability(true);
    }

    /// <summary>
    /// Checks if the companion is alive.
    /// </summary>
    public bool IsAlive => CurrentHealth > 0;

    /// <summary>
    /// Checks if the companion is active and following.
    /// </summary>
    public bool IsActive => State == CompanionState.Following && IsAlive;
}
```

### CompanionState Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the current state of a companion.
/// </summary>
public enum CompanionState
{
    /// <summary>Following and active with the player.</summary>
    Following,

    /// <summary>Waiting at a location.</summary>
    Waiting,

    /// <summary>Knocked out in combat.</summary>
    Unconscious,

    /// <summary>Permanently dismissed.</summary>
    Dismissed
}
```

### CompanionStats Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Combat statistics for a companion.
/// </summary>
public readonly record struct CompanionStats
{
    /// <summary>
    /// Gets the maximum health.
    /// </summary>
    public int MaxHealth { get; init; }

    /// <summary>
    /// Gets the base attack damage.
    /// </summary>
    public int Attack { get; init; }

    /// <summary>
    /// Gets the base defense.
    /// </summary>
    public int Defense { get; init; }

    /// <summary>
    /// Gets the initiative modifier.
    /// </summary>
    public int Initiative { get; init; }

    /// <summary>
    /// Gets the accuracy modifier.
    /// </summary>
    public int Accuracy { get; init; }

    /// <summary>
    /// Creates default companion stats.
    /// </summary>
    public static CompanionStats Default => new()
    {
        MaxHealth = 30,
        Attack = 5,
        Defense = 3,
        Initiative = 0,
        Accuracy = 0
    };

    /// <summary>
    /// Scales stats by level.
    /// </summary>
    public CompanionStats ScaleToLevel(int level)
    {
        var multiplier = 1 + ((level - 1) * 0.1);
        return new CompanionStats
        {
            MaxHealth = (int)(MaxHealth * multiplier),
            Attack = (int)(Attack * multiplier),
            Defense = (int)(Defense * multiplier),
            Initiative = Initiative,
            Accuracy = Accuracy
        };
    }
}
```

### CompanionOrder Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents an order given to a companion.
/// </summary>
public readonly record struct CompanionOrder
{
    /// <summary>
    /// Gets the order type.
    /// </summary>
    public CompanionOrderType Type { get; init; }

    /// <summary>
    /// Gets the target ID if applicable.
    /// </summary>
    public Guid? TargetId { get; init; }

    /// <summary>
    /// Gets additional parameters.
    /// </summary>
    public string? Parameters { get; init; }

    /// <summary>
    /// Gets the default order (attack enemies).
    /// </summary>
    public static CompanionOrder Default => new()
    {
        Type = CompanionOrderType.AttackTarget
    };

    /// <summary>
    /// Creates a defend order.
    /// </summary>
    public static CompanionOrder Defend() => new()
    {
        Type = CompanionOrderType.Defend
    };

    /// <summary>
    /// Creates a focus target order.
    /// </summary>
    public static CompanionOrder Focus(Guid targetId) => new()
    {
        Type = CompanionOrderType.FocusTarget,
        TargetId = targetId
    };
}

/// <summary>
/// Types of orders companions can follow.
/// </summary>
public enum CompanionOrderType
{
    /// <summary>Attack the nearest enemy.</summary>
    AttackTarget,

    /// <summary>Focus on defending the player.</summary>
    Defend,

    /// <summary>Focus attacks on a specific target.</summary>
    FocusTarget,

    /// <summary>Use abilities freely.</summary>
    UseAbilities,

    /// <summary>Stay back and avoid combat.</summary>
    StayBack
}
```

### CompanionService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages companion recruitment, orders, and integration.
/// </summary>
public interface ICompanionService
{
    /// <summary>
    /// Recruits an NPC as a companion.
    /// </summary>
    Companion? RecruitCompanion(NPC npc, Player player);

    /// <summary>
    /// Dismisses a companion.
    /// </summary>
    void DismissCompanion(Companion companion);

    /// <summary>
    /// Gets the player's active companion.
    /// </summary>
    Companion? GetActiveCompanion(Guid playerId);

    /// <summary>
    /// Issues an order to a companion.
    /// </summary>
    void IssueOrder(Companion companion, CompanionOrder order);

    /// <summary>
    /// Equips an item on a companion.
    /// </summary>
    EquipResult EquipCompanion(Companion companion, Item item, EquipmentSlot slot);

    /// <summary>
    /// Gets the companion's combat action based on current order.
    /// </summary>
    AIDecision GetCompanionAction(Companion companion, AIContext context);

    /// <summary>
    /// Processes end-of-combat for companion.
    /// </summary>
    void ProcessCombatEnd(Companion companion, bool victory);
}
```

### CombatEncounter Modification

```
MODIFY: CombatEncounter
├── ADD: CompanionCombatants: IReadOnlyList<Combatant>
├── ADD: AddCompanion(Companion companion): void
└── ADD: IsCompanionTurn(): bool
```

### User-Facing Changes

**Commands:**
```
> party                   # View party status
> order <type>            # Give companion an order
> order defend            # Order companion to defend
> order attack <target>   # Order companion to focus target
> equip companion <item>  # Equip item on companion
> dismiss                 # Dismiss current companion
```

**Output Example:**
```
> party
Your Party:

[You] Level 5 Warrior
Health: 45/50  Stamina: 8/10

[Companion] Torvin the Guard
Health: 38/40  State: Following
Order: Attack Target
Equipment: Iron Sword, Leather Armor

---

=== COMBAT ===
Round 3

Enemies:
- Goblin Warrior (12/20 HP)
- Goblin Archer (8/15 HP)

> order attack archer
You signal Torvin to focus on the Goblin Archer.

Torvin's Turn:
Torvin attacks the Goblin Archer for 8 damage!
The Goblin Archer has 0 HP remaining and is defeated!
```

### Acceptance Criteria

- [ ] Companion can be recruited through dialogue outcome
- [ ] Only one companion allowed at a time
- [ ] Companion appears in party status
- [ ] Companion can be equipped with items
- [ ] Companion participates in combat
- [ ] Companion follows order system
- [ ] Companion can be dismissed
- [ ] Unconscious companions recover after combat
- [ ] Companion stats scale with player level
- [ ] ~25 unit tests pass

---

## Dependencies & Prerequisites

```
v0.1.5 (Procedural Puzzles & Secrets) - REQUIRED
    │
    └── Provides: Room templates, dungeon structure
                                    │
                                    ▼
v0.2.0 (NPCs & Dialogue)
    │
    ├── v0.2.0a: NPC Foundation ─────────────────────┐
    │       Dependencies: Room, Player, Dice System   │
    │                                                 │
    ├── v0.2.0b: Dialogue System ────────────────────┤
    │       Dependencies: v0.2.0a (NPC entity)        │
    │                                                 │
    ├── v0.2.0c: Reputation & Memory ────────────────┤
    │       Dependencies: v0.2.0a, v0.2.0b            │
    │                                                 │
    └── v0.2.0d: Companions ─────────────────────────┘
            Dependencies: v0.2.0a, v0.2.0b, v0.2.0c
                          Combat System
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.2.0a | ~10 | ~5 | ~30 | Medium |
| v0.2.0b | ~8 | ~4 | ~35 | High |
| v0.2.0c | ~7 | ~5 | ~30 | Medium-High |
| v0.2.0d | ~6 | ~6 | ~25 | High |
| **Total** | **~31** | **~20** | **~120** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Dialogue tree complexity | High | Medium | Keep initial trees simple, expand later |
| Combat integration issues | High | Medium | Thorough testing of companion combatants |
| Save/load state growth | Medium | Low | Efficient serialization, lazy loading |
| Performance with large dialogues | Medium | Low | Index dialogue nodes, cache lookups |
| Scope creep into merchant system | Medium | Medium | Defer shop mechanics to v0.2.2 |

---

## Design Decisions (Confirmed)

### NPC Architecture

| Decision | Value | Notes |
|----------|-------|-------|
| **NPC Storage** | Room.NPCs collection | NPCs belong to rooms, can move |
| **Attitude System** | 4-level enum | Friendly/Neutral/Wary/Hostile |
| **Companion Limit** | 1 active | Simplifies combat, expandable later |

### Dialogue System

| Decision | Value | Notes |
|----------|-------|-------|
| **Dialogue Structure** | Node-based tree | Each node has text and options |
| **Condition Evaluation** | Synchronous | No async conditions |
| **Persuasion Integration** | Existing dice system | Reuses SkillCheckResult |

### Reputation System

| Decision | Value | Notes |
|----------|-------|-------|
| **Reputation Range** | Integer (-∞ to +∞) | Mapped to levels via thresholds |
| **Faction Spillover** | 50% to allies, -25% to enemies | Configurable per faction |
| **Memory Persistence** | Per-NPC per-Player | Stored on NPC entity |

---

## Integration Points

### From v0.1.5
- Room entity for NPC placement
- Dungeon generation hooks for NPC spawning

### To v0.2.1 (Codex & Lore)
- NPC dialogue can unlock codex entries
- Informant NPCs provide lore information

### To v0.2.2 (Merchant System)
- Merchant NPC type enabled but shop logic deferred
- Reputation affects prices (foundation ready)

### To v0.3.0 (Quests)
- QuestGiver NPC type ready
- Dialogue outcomes can start quests

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.2.0a Design Spec** - Create detailed design specification
3. **Implement v0.2.0a** - Build NPC foundation
4. **v0.2.0b Design Spec** - Dialogue system details
5. **Implement v0.2.0b** - Build dialogue trees
6. **Repeat for v0.2.0c, v0.2.0d**

---

*This scope breakdown provides a structured approach to implementing v0.2.0 NPCs & Dialogue. Each sub-phase builds on the previous, allowing for incremental development and testing while establishing the foundation for social interactions in the dungeon.*
