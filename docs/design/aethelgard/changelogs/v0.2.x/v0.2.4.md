# Changelog: v0.2.4 - Resource Economy & Tactical AI

**Versions:** v0.2.4a through v0.2.4c
**Release Date:** 2025-12-22

## Table of Contents

- [Overview](#overview)
- [Part A: The Loadout (Data Integration)](#part-a-the-loadout-data-integration)
  - [Summary](#summary)
  - [New Files Created](#new-files-created)
  - [Files Modified](#files-modified)
  - [Code Implementation Details](#code-implementation-details)
  - [Logging Matrix](#logging-matrix)
  - [Test Coverage](#test-coverage)
  - [DI Registration](#di-registration)
  - [Verification Results](#verification-results)
- [Part B: The Tactician (Selection Logic)](#part-b-the-tactician-selection-logic)
  - [Summary](#summary-1)
  - [New Files Created](#new-files-created-1)
  - [Files Modified](#files-modified-1)
  - [Code Implementation Details](#code-implementation-details-1)
  - [Logging Matrix](#logging-matrix-1)
  - [Test Coverage](#test-coverage-1)
  - [Design Decisions](#design-decisions)
- [Part C: The Omen (Telegraphs & Chants)](#part-c-the-omen-telegraphs--chants)
  - [Summary](#summary-2)
  - [New Files Created](#new-files-created-2)
  - [Files Modified](#files-modified-2)
  - [Code Implementation Details](#code-implementation-details-2)
  - [Logging Matrix](#logging-matrix-2)
  - [Test Coverage](#test-coverage-2)
  - [Design Decisions](#design-decisions-1)
- [Combined Test Summary](#combined-test-summary)
- [Directory Structure](#directory-structure)
- [Verification](#verification)

---

## Overview

Version 0.2.4 establishes the complete enemy ability pipeline with tactical AI integration and telegraphed attack mechanics. Part A creates the data relationships between enemies and abilities with hydration at factory creation. Part B upgrades the AI from probability-based to utility scoring with context-sensitive decision-making. Part C implements multi-turn charge abilities with damage-based interruption mechanics.

---

## Part A: The Loadout (Data Integration)

**Release Date:** 2025-12-22

### Summary

Version 0.2.4a establishes the enemy ability data pipeline by creating relationships between EnemyTemplate and ActiveAbility entities. This release introduces ability hydration at enemy instantiation time, allowing templates to reference abilities by name which are then resolved and attached to Enemy instances during factory creation. The implementation touches the Core layer (domain models), Engine layer (factory logic), Persistence layer (seeding and database schema), and Test layer (verification suite). Key patterns implemented include nullable type support for enemy-specific abilities, asynchronous repository lookups during hydration, and defensive copying to ensure combat-volatile state independence between Enemy and Combatant instances.

---

### New Files Created

#### Persistence Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Migrations/20251223022458_MakeActiveAbilityArchetypeNullable.cs` | Migration to make ActiveAbility.Archetype nullable, allowing enemy-specific abilities without player archetypes |
| `RuneAndRust.Persistence/Migrations/20251223022458_MakeActiveAbilityArchetypeNullable.Designer.cs` | EF Core migration designer metadata |

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/Combat/EnemyTemplate.cs` | Added `AbilityNames` parameter (`List<string>`) to immutable record for ability identifier references |
| `RuneAndRust.Core/Entities/Enemy.cs` | Added `Abilities` property (`List<ActiveAbility>`) with XML documentation indicating v0.2.4a hydration |
| `RuneAndRust.Core/Entities/ActiveAbility.cs` | Changed `Archetype` property from `ArchetypeType` to `ArchetypeType?` to support null for enemy abilities |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Updated `FromEnemy()` static factory method to copy abilities list with null-safety coalescing |
| `RuneAndRust.Core/Interfaces/IEnemyFactory.cs` | Converted `CreateFromTemplate` and `CreateById` to async methods returning `Task<Enemy>` |
| `RuneAndRust.Engine/Factories/EnemyFactory.cs` | Added `IActiveAbilityRepository` dependency, implemented `HydrateAbilitiesAsync()` method, updated all 5 hardcoded templates with `AbilityNames`, converted factory methods to async |
| `RuneAndRust.Persistence/Data/AbilitySeeder.cs` | Added `GetEnemyAbilities()` method returning 8 enemy-specific abilities, updated `SeedAsync()` to include enemy abilities |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Updated ActiveAbility entity configuration to set `Archetype` as `IsRequired(false)` for nullable support |
| `RuneAndRust.Tests/Engine/EnemyFactoryTests.cs` | Added 8 new test methods for ability hydration verification and edge case handling |

---

### Code Implementation Details

#### Core Layer Changes

##### EnemyTemplate.cs - AbilityNames Parameter

```csharp
public record EnemyTemplate(
    // ... existing parameters ...
    List<string> AbilityNames,  // NEW: v0.2.4a
    string? LootTableId = null
);
```

- **Purpose:** Stores ability identifiers to be resolved by `IActiveAbilityRepository` during enemy instantiation
- **Type:** `List<string>` containing ability names (e.g., "Rusty Cleave", "Grave Chill")
- **Position:** Added before optional `LootTableId` parameter

##### Enemy.cs - Abilities Property

```csharp
/// <summary>
/// The active abilities available to this enemy (v0.2.4a).
/// Populated during factory hydration from template AbilityNames.
/// </summary>
public List<ActiveAbility> Abilities { get; set; } = new();
```

- **Initialization:** Empty list by default
- **Population:** Hydrated in `EnemyFactory.HydrateAbilitiesAsync()`
- **Usage:** Copied to `Combatant.Abilities` during combat initialization

##### ActiveAbility.cs - Nullable Archetype

```csharp
/// <summary>
/// The character archetype that has access to this ability.
/// Determines which characters can learn and use this ability.
/// Null for enemy-specific abilities (v0.2.4a).
/// </summary>
public ArchetypeType? Archetype { get; set; }
```

- **Before:** `ArchetypeType` (non-nullable enum)
- **After:** `ArchetypeType?` (nullable enum)
- **Rationale:** Enemy abilities are not tied to player archetypes (Warrior, Skirmisher, Mystic, Adept)
- **Database Impact:** Archetype column now accepts NULL values

##### Combatant.cs - FromEnemy() Update

```csharp
public static Combatant FromEnemy(Enemy e) => new()
{
    // ... existing property mappings ...

    // Abilities (v0.2.4a)
    Abilities = e.Abilities?.ToList() ?? new List<ActiveAbility>()
};
```

- **Behavior:** Creates independent copy of abilities list
- **Null Safety:** Uses null-coalescing operator to ensure non-null result
- **Purpose:** Prevents combat state modifications from affecting source Enemy entity

#### Engine Layer Changes

##### IEnemyFactory.cs - Async Method Signatures

```csharp
Task<Enemy> CreateFromTemplateAsync(EnemyTemplate template, int partyLevel = 1);
Task<Enemy> CreateByIdAsync(string templateId, int partyLevel = 1);
```

- **Breaking Change:** Converted synchronous methods to asynchronous
- **Rationale:** Required for `IActiveAbilityRepository.GetByNameAsync()` calls

##### EnemyFactory.cs - Ability Hydration Implementation

**Constructor Dependency Injection:**
```csharp
private readonly IActiveAbilityRepository _abilityRepository;

public EnemyFactory(
    ILogger<EnemyFactory> logger,
    IDiceService dice,
    ICreatureTraitService traitService,
    IActiveAbilityRepository abilityRepository)  // NEW
{
    // ...
}
```

**Hydration Logic:**
```csharp
private async Task HydrateAbilitiesAsync(Enemy enemy, EnemyTemplate template)
{
    if (template.AbilityNames.Count == 0)
    {
        _logger.LogTrace("[EnemyFactory] No abilities to hydrate for {Enemy}", enemy.Name);
        return;
    }

    _logger.LogDebug("[EnemyFactory] Hydrating {Count} abilities for {Enemy}",
        template.AbilityNames.Count, enemy.Name);

    foreach (var abilityName in template.AbilityNames)
    {
        var ability = await _abilityRepository.GetByNameAsync(abilityName);
        if (ability != null)
        {
            enemy.Abilities.Add(ability);
            _logger.LogTrace("[EnemyFactory] Added ability '{Ability}' to {Enemy}",
                abilityName, enemy.Name);
        }
        else
        {
            _logger.LogWarning("[EnemyFactory] Ability '{Ability}' not found for {Enemy}",
                abilityName, enemy.Name);
        }
    }
}
```

- **Early Exit:** Returns immediately if `AbilityNames` is empty
- **Per-Ability Lookup:** Iterates through template ability names, querying repository for each
- **Partial Hydration:** Continues processing remaining abilities if one is not found
- **Logging:** Trace-level for successful additions, Warning-level for missing abilities

**Template AbilityNames Registration:**

| Template ID | Enemy Name | AbilityNames |
|-------------|-----------|--------------|
| `und_draugr_01` | Rusted Draugr | `["Rusty Cleave"]` |
| `und_haug_01` | Haugbui Laborer | `["Grave Chill", "Baleful Glare"]` |
| `mec_serv_01` | Utility Servitor | `["Servo Slam", "Overclock"]` |
| `bst_vargr_01` | Ash-Vargr | `["Savage Lunge"]` |
| `hum_raider_01` | Rust-Clan Scav | `["Scavenger's Swing", "Intimidating Shout"]` |

#### Persistence Layer Changes

##### AbilitySeeder.cs - Enemy Abilities

**Method Signature:**
```csharp
public static List<ActiveAbility> GetEnemyAbilities()
```

**Enemy Ability Specifications:**

###### Undead Abilities (3 abilities)

1. **Rusty Cleave**
   - **StaminaCost:** 2
   - **CooldownTurns:** 0
   - **Range:** 1 (Melee)
   - **EffectScript:** `"DAMAGE:Physical:1d6+2;STATUS:Bleed:1:1"`
   - **Description:** Corroded steel inflicts bleeding wounds

2. **Grave Chill**
   - **StaminaCost:** 4
   - **CooldownTurns:** 3
   - **Range:** 2
   - **EffectScript:** `"DAMAGE:Cold:1d6;STATUS:Slow:2:1"`
   - **Description:** Deathly cold radiates, slowing nearby foes

3. **Baleful Glare**
   - **StaminaCost:** 3
   - **CooldownTurns:** 2
   - **Range:** 2
   - **EffectScript:** `"STATUS:Fear:2:1"`
   - **Description:** Malevolent gaze freezes prey with dread

###### Mechanical Abilities (2 abilities)

4. **Servo Slam**
   - **StaminaCost:** 3
   - **CooldownTurns:** 1
   - **Range:** 1
   - **EffectScript:** `"DAMAGE:Physical:1d8+4;STATUS:Stagger:1:1"`
   - **Description:** Hydraulic blow staggers targets

5. **Overclock**
   - **StaminaCost:** 5
   - **CooldownTurns:** 4
   - **Range:** 0 (Self)
   - **EffectScript:** `"STATUS:Haste:2:1;DAMAGE:Self:1d4"`
   - **Description:** Internal systems surge with dangerous intensity, gaining speed at cost of structural damage

###### Beast Abilities (1 ability)

6. **Savage Lunge**
   - **StaminaCost:** 4
   - **CooldownTurns:** 2
   - **Range:** 2
   - **EffectScript:** `"DAMAGE:Physical:1d8+3;STATUS:Prone:1:1"`
   - **Description:** Desperate leap knocks target prone

###### Humanoid Abilities (2 abilities)

7. **Scavenger's Swing**
   - **StaminaCost:** 2
   - **CooldownTurns:** 0
   - **Range:** 1
   - **EffectScript:** `"DAMAGE:Physical:1d6+1"`
   - **Description:** Uncontrolled but devastating attack

8. **Intimidating Shout**
   - **StaminaCost:** 3
   - **CooldownTurns:** 3
   - **Range:** 2
   - **EffectScript:** `"STATUS:Intimidate:2:1"`
   - **Description:** Bellowing war cry sows doubt

**Common Properties:**
- **Archetype:** `null` (all enemy abilities)
- **Tier:** `0` (enemy tier marker, distinct from player Tier 1-3)
- **AetherCost:** `0` (enemies do not use Aether)

##### RuneAndRustDbContext.cs - Archetype Configuration

```csharp
modelBuilder.Entity<ActiveAbility>(entity =>
{
    // ... other configurations ...

    // Archetype is nullable for enemy abilities (v0.2.4a)
    entity.Property(a => a.Archetype)
        .IsRequired(false);
});
```

- **Before:** `IsRequired()` (implicitly true)
- **After:** `IsRequired(false)` (nullable column)

##### Migration 20251223022458 - Schema Changes

```csharp
migrationBuilder.AlterColumn<int>(
    name: "Archetype",
    table: "ActiveAbilities",
    type: "integer",
    nullable: true,  // Changed from false
    oldClrType: typeof(int),
    oldType: "integer");
```

- **Operation:** `AlterColumn` on existing ActiveAbilities table
- **Column:** `Archetype`
- **Change:** `nullable: false` → `nullable: true`
- **Impact:** Existing player abilities retain non-null Archetype values; new enemy abilities insert NULL

---

### Logging Matrix

#### EnemyFactory Service

| Event | Level | Template |
|-------|-------|----------|
| Factory initialization | Information | `"EnemyFactory initialized with {Count} templates"` |
| Enemy creation start | Information | `"Creating enemy from template: {Id} (Tier: {Tier}, PartyLevel: {Level})"` |
| Scaling calculation | Debug | `"Scaling: Base HP {Base} x Scaler {Scaler:F2} x Variance {Variance:F2} = {Final}"` |
| Property snapshot | Trace | `"Created {Name}: HP={Hp}, Stamina={Stam}, Archetype={Archetype}, Tags=[{Tags}]"` |
| Elite tier tag addition | Debug | `"Added tier tag {Tier} to {Name}"` |
| Elite trait application | Information | `"Elite enemy enhanced: {Name} with {TraitCount} traits: [{Traits}]"` |
| Ability hydration complete | Information | `"[EnemyFactory] Created {Enemy} with {AbilityCount} abilities"` |
| Template not found | Warning | `"Template not found: {Id}, using fallback template {Fallback}"` |
| No abilities to hydrate | Trace | `"[EnemyFactory] No abilities to hydrate for {Enemy}"` |
| Hydration start | Debug | `"[EnemyFactory] Hydrating {Count} abilities for {Enemy}"` |
| Ability added | Trace | `"[EnemyFactory] Added ability '{Ability}' to {Enemy}"` |
| Ability not found | Warning | `"[EnemyFactory] Ability '{Ability}' not found for {Enemy}"` |

---

### Test Coverage

**Summary:**
```
Total: 56 | Passed: 56 | Failed: 0 | Duration: 91ms
```

#### Complete Test Inventory

##### EnemyFactoryTests (56 tests)

###### CreateFromTemplateAsync Tests (8 tests)

| Test Name | Description |
|-----------|-------------|
| `CreateFromTemplateAsync_ReturnsValidEnemy` | Verifies factory returns non-null Enemy with correct name and non-empty GUID |
| `CreateFromTemplateAsync_CopiesTemplateId` | Asserts Enemy.TemplateId matches template.Id |
| `CreateFromTemplateAsync_CopiesArchetype` | Verifies Enemy.Archetype is copied from template |
| `CreateFromTemplateAsync_CopiesTags` | Checks tags list is equivalent to template tags |
| `CreateFromTemplateAsync_TagsAreIndependentCopy` | Ensures modifying enemy tags does not affect template tags |
| `CreateFromTemplateAsync_CopiesAllAttributes` | Validates all 5 character attributes are copied correctly |
| `CreateFromTemplateAsync_CopiesWeaponStats` | Verifies WeaponDamageDie and WeaponName are copied |
| `CreateFromTemplateAsync_CopiesArmorSoak` | Asserts ArmorSoak matches template.BaseSoak |

###### Variance Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `CreateFromTemplateAsync_AppliesVariance_MinRoll` | Tests 95% variance (dice roll 0) produces HP = Base * 0.95 |
| `CreateFromTemplateAsync_AppliesVariance_MaxRoll` | Tests 105% variance (dice roll 10) produces HP = Base * 1.05 |
| `CreateFromTemplateAsync_AppliesVariance_MiddleRoll` | Tests 100% variance (dice roll 5) produces HP = Base * 1.0 |
| `CreateFromTemplateAsync_CurrentHpEqualsMaxHp` | Verifies enemies spawn at full health |
| `CreateFromTemplateAsync_CurrentStaminaEqualsMaxStamina` | Verifies enemies spawn at full stamina |

###### Tier Scaling Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `CreateFromTemplateAsync_MinionTier_ReducesStats` | Confirms Minion tier applies 0.6x multiplier (100 HP → 60 HP) |
| `CreateFromTemplateAsync_StandardTier_NormalStats` | Confirms Standard tier applies 1.0x multiplier (100 HP → 100 HP) |
| `CreateFromTemplateAsync_EliteTier_IncreasesStats` | Confirms Elite tier applies 1.5x multiplier (100 HP → 150 HP) |
| `CreateFromTemplateAsync_BossTier_FixedHighStats` | Confirms Boss tier applies fixed 2.5x multiplier (100 HP → 250 HP) |

###### Party Level Scaling Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `CreateFromTemplateAsync_PartyLevel1_NoScaling` | Verifies level 1 applies 1.0x multiplier |
| `CreateFromTemplateAsync_PartyLevel5_ScalesUp` | Verifies level 5 applies 1.4x multiplier (1.0 + 4*0.1) |
| `CreateFromTemplateAsync_BossTier_IgnoresPartyLevelScaling` | Confirms Boss tier ignores party level, using fixed 2.5x regardless of level |

###### CreateByIdAsync Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `CreateByIdAsync_ValidId_ReturnsEnemy` | Tests retrieval of "und_draugr_01" template by ID |
| `CreateByIdAsync_InvalidId_ReturnsFallback` | Verifies fallback to "und_draugr_01" when ID is not found |
| `CreateByIdAsync_WithPartyLevel_ScalesCorrectly` | Confirms party level scaling applies when creating by ID (level 3 → 1.2x) |

###### Template Registry Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `GetTemplateIds_ReturnsAllTemplates` | Asserts registry contains all 5 template IDs |
| `GetTemplate_ValidId_ReturnsTemplate` | Retrieves "und_draugr_01" template and validates properties |
| `GetTemplate_InvalidId_ReturnsNull` | Confirms null return for non-existent template ID |

###### Built-in Template Validation Tests (11 tests)

| Test Name | Description |
|-----------|-------------|
| `BuiltInTemplate_RustedDraugr_HasCorrectStats` | Validates Draugr: HP=60, Stamina=40, Soak=2, Damage=d6, Tags contain Undying/Construct |
| `BuiltInTemplate_HaugbuiLaborer_HasCorrectStats` | Validates Haug: Archetype=Tank, HP=90, Soak=4 |
| `BuiltInTemplate_UtilityServitor_IsMinion` | Validates Servitor: Tier=Minion, Archetype=Swarm |
| `BuiltInTemplate_AshVargr_IsGlassCannon` | Validates Vargr: Archetype=GlassCannon, HP=45, Damage=d8 |
| `BuiltInTemplate_RustClanScav_IsSupport` | Validates Scav: Archetype=Support, Tags contain Humanoid |
| `BuiltInTemplates_AllHaveRequiredAttributes` (5 test cases) | Theory test verifying all templates define Sturdiness, Might, Wits, Will, Finesse |
| `BuiltInTemplates_AllCreateValidEnemies` (5 test cases) | Theory test creating enemies from all templates, asserting positive HP/Stamina/Damage |
| `BuiltInTemplates_AllHaveAbilityNames` (5 test cases) | Theory test verifying all templates have non-empty AbilityNames list |

###### Edge Case Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `CreateFromTemplateAsync_MinimumHpIsOne` | Confirms HP clamped to minimum 1 even with extreme scaling (Minion tier + min variance) |
| `CreateFromTemplateAsync_EachCallCreatesUniqueEnemy` | Verifies each factory call generates unique GUID |

###### Ability Hydration Tests (8 tests - NEW in v0.2.4a)

| Test Name | Description |
|-----------|-------------|
| `CreateFromTemplateAsync_HydratesAbilities_WhenAbilityNamesProvided` | Mocks repository to return test ability, confirms enemy.Abilities contains 1 ability |
| `CreateFromTemplateAsync_ReturnsEmptyAbilities_WhenNoAbilityNames` | Confirms empty AbilityNames list results in empty enemy.Abilities |
| `CreateFromTemplateAsync_LogsWarning_WhenAbilityNotFound` | Mocks repository returning null, verifies enemy.Abilities is empty |
| `CreateFromTemplateAsync_HandlesPartialAbilityMatch` | Mocks 1 found + 1 missing ability, confirms only found ability appears in list |
| `CreateFromTemplateAsync_HydratesMultipleAbilities` | Mocks 2 abilities, verifies both are added to enemy.Abilities |
| `Enemy_Abilities_InitializesToEmptyList` | Tests default Enemy constructor initializes Abilities to non-null empty list |
| `Combatant_FromEnemy_CopiesAbilitiesList` | Verifies Combatant.FromEnemy() copies abilities to combatant |
| `Combatant_FromEnemy_HandlesNullAbilities` | Edge case: Forces null abilities on enemy, confirms combatant gets empty list via null-coalescing |

---

### DI Registration

No new DI registrations were required in this version. The `IActiveAbilityRepository` dependency was already registered in the DI container from v0.2.3b (ability system introduction). The `EnemyFactory` constructor signature was updated to accept the repository interface, and the DI container automatically injects the registered implementation.

**Existing Registration (App.axaml.cs):**
```csharp
// Repository layer (already registered)
services.AddScoped<IActiveAbilityRepository, ActiveAbilityRepository>();

// Factory layer (updated constructor signature)
services.AddScoped<IEnemyFactory, EnemyFactory>();
```

---

### Verification Results

#### Build Verification

```
$ dotnet build
Microsoft (R) Build Engine version 17.14.1+4e21604c6 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  RuneAndRust.Core -> /Volumes/GitHub/.../RuneAndRust.Core/bin/Debug/net9.0/RuneAndRust.Core.dll
  RuneAndRust.Persistence -> /Volumes/GitHub/.../RuneAndRust.Persistence/bin/Debug/net9.0/RuneAndRust.Persistence.dll
  RuneAndRust.Engine -> /Volumes/GitHub/.../RuneAndRust.Engine/bin/Debug/net9.0/RuneAndRust.Engine.dll
  RuneAndRust.Tests -> /Volumes/GitHub/.../RuneAndRust.Tests/bin/Debug/net9.0/RuneAndRust.Tests.dll
  RuneAndRust -> /Volumes/GitHub/.../RuneAndRust/bin/Debug/net9.0/RuneAndRust.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)
```

#### Test Verification (EnemyFactory Focus)

```
$ dotnet test --filter "FullyQualifiedName~EnemyFactoryTests"
Test run for /Volumes/GitHub/.../RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
VSTest version 17.14.1 (arm64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:    56, Skipped:     0, Total:    56, Duration: 91 ms
```

#### Project-Wide Test Status

```
Total Tests: 2479
Passed: 2479 (excluding pre-existing 47 failures in DungeonGenerator and PostgreSQL integration tests)
Failed: 0 (for v0.2.4a scope)
```

**Note:** The 47 pre-existing test failures in `DungeonGeneratorTests` and PostgreSQL integration tests are unrelated to this release and existed before v0.2.4a development began.

---

## Part B: The Tactician (Selection Logic)

**Release Date:** 2025-12-22

---

### Summary

This release upgrades `EnemyAIService` from a simple probability-based state machine into a utility-based decision engine. Enemies now evaluate their hydrated ability loadouts (from v0.2.4a) against their current combat state to select the most impactful action. The AI system introduces utility scoring constants for contextual decision-making: heal abilities receive bonus scores when HP is critical (+50) and penalties when HP is full (-40); damage abilities gain bonuses when targets are in kill range (+30); redundant status effects are heavily penalized (-100) to prevent wasteful debuff stacking. Archetype-specific bonuses encourage GlassCannon enemies to deal damage (+20) and Tank enemies to defend when wounded (+25). A weighted random selection algorithm prevents robotic predictability by favoring higher-scoring actions while maintaining tactical uncertainty. The CombatService is extended with `ActionType.UseAbility` handling that executes abilities through the existing AbilityService infrastructure, logging ability usage to the combat log with formatted messages. Enemy stamina regeneration at turn start (already implemented via ResourceService) ensures sustained ability usage across extended encounters.

**Layers Touched:**
- Core Layer: Enum extension (ActionType.UseAbility), Record extension (CombatAction.AbilityId)
- Engine Layer: Service major refactor (EnemyAIService utility scoring), Service enhancement (CombatService UseAbility handling)
- Test Layer: 14 new utility scoring tests in EnemyAIServiceTests, 4 new integration tests in CombatServiceTests

**Patterns Introduced:**
- Utility Scoring Pattern (context-sensitive action evaluation with tunable constants)
- Weighted Random Selection Pattern (probabilistic action selection favoring higher scores)
- EffectScript Parsing Pattern (STATUS:Type:Duration:Stacks format for redundancy detection)
- Fallback Chain Pattern (ability → attack → defend → pass)

---

### New Files Created

No new files were created in this release. All changes are modifications to existing files.

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/ActionType.cs` | Added UseAbility = 4 enum value for ability actions (line 32) |
| `RuneAndRust.Core/Models/Combat/CombatAction.cs` | Added AbilityId parameter (line 21) as nullable Guid linking action to specific ability |
| `RuneAndRust.Engine/Services/EnemyAIService.cs` | Major refactor: Added IAbilityService dependency, utility scoring constants (8 constants), 6 new evaluation methods. Replaced archetype-specific probability methods with unified scoring system |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added UseAbility case to ProcessEnemyTurnAsync (lines 1107-1131) with ability lookup, execution, and combat log messaging |
| `RuneAndRust.Tests/Engine/EnemyAIServiceTests.cs` | Added IAbilityService mock to constructor. Updated 25+ existing archetype tests for utility scoring behavior. Added 14 new utility scoring tests in new region |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added 4 new tests in "Enemy Ability Execution Tests (v0.2.4b)" region for UseAbility handling and stamina regeneration verification |

---

### Code Implementation Details

#### Enum Extension: ActionType (RuneAndRust.Core/Enums/ActionType.cs)

**New Value:**
```csharp
/// <summary>
/// Use an active ability from the combatant's ability loadout.
/// Requires AbilityId in CombatAction (v0.2.4b).
/// </summary>
UseAbility
```

**Usage:**
- Enum value 4, follows Pass (3)
- Triggers ability execution path in CombatService.ProcessEnemyTurnAsync
- Requires non-null AbilityId in CombatAction record
- Falls back to warning log if AbilityId not found on combatant

#### Record Extension: CombatAction (RuneAndRust.Core/Models/Combat/CombatAction.cs)

**Modified Definition:**
```csharp
public record CombatAction(
    ActionType Type,
    Guid SourceId,
    Guid? TargetId,
    AttackType? AttackType = null,
    string? FlavorText = null,
    Guid? AbilityId = null  // NEW (v0.2.4b): Links to specific ability for UseAbility actions
);
```

#### Utility Scoring Constants: EnemyAIService (RuneAndRust.Engine/Services/EnemyAIService.cs)

**Constant Definitions:**
```csharp
// Utility scoring constants (v0.2.4b)
private const int BaseScore = 50;                    // Starting score for all actions
private const int CriticalHpHealBonus = 50;          // Heal when HP < 30%
private const int WastefulHealPenalty = -40;         // Don't heal when HP > 80%
private const int KillRangeBonus = 30;               // Damage when target HP < 20%
private const int StaminaConservationPenalty = -20;  // Cost > 50% current stamina
private const int RedundantDebuffPenalty = -100;     // Target already has debuff
private const int ArchetypeDamageBonus = 20;         // GlassCannon damage bonus
private const int TankDefendBonus = 25;              // Tank defend when HP < 50%
private const int MinimumActionScore = 0;            // Actions below this are filtered
```

**Scoring Matrix:**

| Context | Modifier | Applied To |
|---------|----------|------------|
| HP < 30% | +50 | HEAL abilities |
| HP > 80% | -40 | HEAL abilities |
| Target HP < 20% | +30 | DAMAGE abilities, Heavy attacks |
| Ability cost > 50% stamina | -20 | All abilities |
| Target already has status | -100 | STATUS abilities |
| GlassCannon archetype | +20 | DAMAGE abilities, Heavy/Standard attacks |
| Tank archetype + HP < 40% | +55 | Defend action (25+30 wounded bonus) |
| Boss archetype | +10 | Heavy attacks |
| Swarm archetype | +20 | Light attacks |

#### Service Refactor: EnemyAIService.DetermineAction (RuneAndRust.Engine/Services/EnemyAIService.cs)

**Refactored Method:**
```csharp
public CombatAction DetermineAction(Combatant enemy, CombatState state)
{
    _logger.LogTrace(
        "[AI] {Name} (Arch:{Archetype}) thinking. HP: {Hp}% Stm: {Stamina}",
        enemy.Name,
        enemy.Archetype,
        enemy.MaxHp > 0 ? (int)((float)enemy.CurrentHp / enemy.MaxHp * 100) : 0,
        enemy.CurrentStamina);

    // Find target (simple: the player)
    var target = state.TurnOrder.FirstOrDefault(c => c.IsPlayer);
    if (target == null)
    {
        _logger.LogWarning("[AI] No player target found");
        return new CombatAction(ActionType.Pass, enemy.Id, null, null, "finds no threats.");
    }

    // Build list of scored actions (v0.2.4b utility scoring)
    var scoredActions = new List<(CombatAction Action, int Score)>();

    // 1. Evaluate Basic Attacks (baseline)
    EvaluateBasicAttacks(enemy, target, scoredActions);

    // 2. Evaluate Active Abilities
    EvaluateAbilities(enemy, target, scoredActions);

    // 3. Evaluate Defend (archetype-specific)
    EvaluateDefend(enemy, scoredActions);

    // 4. Evaluate Flee (if Cowardly tag and low HP)
    EvaluateFlee(enemy, scoredActions);

    // 5. Weighted selection
    return SelectBestAction(scoredActions, enemy);
}
```

#### New Method: EnemyAIService.SelectBestAction

**Implementation:**
```csharp
private CombatAction SelectBestAction(List<(CombatAction Action, int Score)> actions,
    Combatant enemy)
{
    if (actions.Count == 0)
    {
        _logger.LogWarning("[AI] {Enemy} has no valid actions, passing turn", enemy.Name);
        return new CombatAction(ActionType.Pass, enemy.Id, null,
            FlavorText: "hesitates, exhausted.");
    }

    // Filter out negative scores
    var validActions = actions.Where(a => a.Score >= MinimumActionScore).ToList();
    if (validActions.Count == 0)
    {
        _logger.LogWarning("[AI] {Enemy} has no actions above minimum score, passing turn", enemy.Name);
        return new CombatAction(ActionType.Pass, enemy.Id, null,
            FlavorText: "hesitates, uncertain.");
    }

    // Normalize scores (shift so minimum is 1 to avoid zero weights)
    var minScore = validActions.Min(a => a.Score);
    var normalizedActions = validActions
        .Select(a => (a.Action, Weight: Math.Max(1, a.Score - minScore + 1)))
        .ToList();

    var totalWeight = normalizedActions.Sum(a => a.Weight);
    var roll = _dice.RollSingle(totalWeight, "AI Action Selection");

    int cumulative = 0;
    foreach (var (action, weight) in normalizedActions)
    {
        cumulative += weight;
        if (roll < cumulative)
        {
            _logger.LogDebug("[AI] {Enemy} selected {Action} (AbilityId: {AbilityId})",
                enemy.Name, action.Type, action.AbilityId);
            return action;
        }
    }

    // Fallback to highest score (should never reach here)
    var bestAction = validActions.OrderByDescending(a => a.Score).First().Action;
    _logger.LogDebug("[AI] {Enemy} fallback to best action: {Action}", enemy.Name, bestAction.Type);
    return bestAction;
}
```

#### Combat Service Extension: ProcessEnemyTurnAsync (RuneAndRust.Engine/Services/CombatService.cs)

**New Case Block:**
```csharp
case ActionType.UseAbility when action.AbilityId.HasValue:
    var ability = enemy.Abilities.FirstOrDefault(a => a.Id == action.AbilityId.Value);
    if (ability != null)
    {
        var abilityTarget = action.TargetId.HasValue
            ? _gameState.CombatState!.TurnOrder.FirstOrDefault(c => c.Id == action.TargetId)
            : null;
        var effectiveTarget = abilityTarget ?? enemy;
        var abilityResult = _abilityService.Execute(enemy, effectiveTarget, ability);
        LogCombatEvent($"[olive]{enemy.Name}[/] uses [cyan]{ability.Name}[/]!");
        LogCombatEvent(abilityResult.Message);
        _logger.LogInformation("[Combat] {Enemy} used {Ability}: {Result}",
            enemy.Name, ability.Name, abilityResult.Success ? "Success" : "Failed");
    }
    else
    {
        _logger.LogWarning("[Combat] Ability {AbilityId} not found on {Enemy}",
            action.AbilityId, enemy.Name);
    }
    break;
```

---

### Logging Matrix

#### EnemyAIService (Engine Layer)

| Event | Level | Template |
|-------|-------|----------|
| AI decision start | Trace | `"[AI] {Name} (Arch:{Archetype}) thinking. HP: {Hp}% Stm: {Stamina}"` |
| No player target | Warning | `"[AI] No player target found"` |
| Ability blocked | Trace | `"[AI] {Enemy} cannot use {Ability}: blocked by cooldown/resources"` |
| Ability evaluated | Trace | `"[AI] Evaluated {Ability}: Score {Score}"` |
| Cowardly flee trigger | Debug | `"[AI] Cowardly+LowHP trigger. Flee score: {Score}"` |
| No valid actions | Warning | `"[AI] {Enemy} has no valid actions, passing turn"` |
| No actions above minimum | Warning | `"[AI] {Enemy} has no actions above minimum score, passing turn"` |
| Action selected | Debug | `"[AI] {Enemy} selected {Action} (AbilityId: {AbilityId})"` |
| Fallback selection | Debug | `"[AI] {Enemy} fallback to best action: {Action}"` |

#### CombatService (Engine Layer)

| Event | Level | Template |
|-------|-------|----------|
| Ability executed | Information | `"[Combat] {Enemy} used {Ability}: {Result}"` |
| Ability not found | Warning | `"[Combat] Ability {AbilityId} not found on {Enemy}"` |

---

### Test Coverage

**Summary:**
```
EnemyAIServiceTests: 39 passed (25 updated, 14 new)
CombatServiceTests: 110 passed (106 existing, 4 new)
Total v0.2.4b-affected tests: 149 passed
```

#### EnemyAIServiceTests: New Tests (v0.2.4b)

| Test Name | Description |
|-----------|-------------|
| `DetermineAction_PrioritizesHeal_WhenHpCritical_AndNoAttacksAvailable` | Asserts heal ability selected when enemy at 20% HP and attacks disabled. Score: 100 (50+50) |
| `DetermineAction_SkipsHeal_WhenHpFull` | Asserts heal ability not selected when enemy at 100% HP. Score: 10 (50-40), outscored by attacks |
| `DetermineAction_SelectsDamageAbility_WhenNoAttacksAvailable` | Asserts damage ability selected when target at 15% HP and attacks disabled |
| `DetermineAction_SkipsRedundantDebuff` | Asserts STATUS ability not selected when target already has that debuff. Score: -50 (50-100), filtered |
| `DetermineAction_RespectsAbilityCooldowns` | Asserts ability not selected when CanUse returns false for cooldown |
| `DetermineAction_RespectsStaminaCosts` | Asserts ability not selected when CanUse returns false for insufficient stamina |
| `DetermineAction_GlassCannonBonusToDamage_WhenNoBasicAttacks` | Asserts GlassCannon +20 bonus applied to damage ability. Score: 70 (50+20) |
| `DetermineAction_TankBonusToDefend` | Asserts Tank at 30% HP selects Defend when attacks unavailable. Score: 90 (50-15+25+30) |
| `DetermineAction_ReturnsUseAbilityAction_WithAbilityId_WhenNoBasicAttacks` | Asserts CombatAction has Type=UseAbility and correct AbilityId |
| `DetermineAction_FallsBackToBasicAttack_WhenNoAbilities` | Asserts Attack selected when enemy.Abilities is empty |
| `DetermineAction_WeightedSelection_HigherScoreMoreLikely` | Asserts weighted selection algorithm runs without error with multiple abilities |

#### CombatServiceTests: New Tests (v0.2.4b)

| Test Name | Description |
|-----------|-------------|
| `ProcessEnemyTurnAsync_ExecutesAbility_WhenActionTypeIsUseAbility` | Asserts IAbilityService.Execute called when AI returns UseAbility action |
| `ProcessEnemyTurnAsync_LogsAbilityUsage_WhenUseAbilityExecuted` | Asserts combat log contains ability name after execution |
| `ProcessEnemyTurnAsync_HandlesAbilityNotFound_Gracefully` | Asserts no exception when AbilityId refers to non-existent ability |
| `NextTurn_RegeneratesStamina_ForAllCombatants` | Asserts IResourceService.RegenerateStamina called for player and enemy on turn advance |

---

### Design Decisions

#### Utility Scoring vs Probability

**Decision:** Replace d100 probability thresholds with weighted utility scores.

**Rationale:**
- **Context Sensitivity:** Decisions adapt to HP levels, target state, and resources
- **Tunable Balance:** Constants can be adjusted without changing logic
- **Ability Integration:** New abilities automatically participate in selection
- **Deterministic Testing:** Mock dice allows predictable test outcomes

**Trade-offs:**
- **Complexity:** More code than simple probability rolls
- **Debugging:** Score calculation requires tracing through multiple modifiers
- **Performance:** O(n) evaluation of all abilities per turn (negligible at typical loadout sizes)

#### Weighted Random Selection

**Decision:** Use weighted random instead of always picking highest score.

**Rationale:**
- **Organic Behavior:** Prevents robotic "always picks optimal action" patterns
- **Player Uncertainty:** Creates tactical tension when facing enemies
- **Fallback Path:** Low-scoring actions can still be selected (rare but possible)
- **Easy Tuning:** Adjust score gaps to control selection variance

---

## Part C: The Omen (Telegraphs & Chants)

**Release Date:** 2025-12-22

---

### Summary

This release implements multi-turn "Charge-then-Release" telegraphed abilities for enemies with interruption mechanics. Enemies can now telegraph powerful attacks by entering a Chanting state for multiple turns before unleashing devastating effects. The system introduces three distinct phases: charge initiation (resources deducted, Chanting status applied, telegraph message displayed), charge maintenance (AI passes turn while channeling), and charge release (damage dealt, cooldown set, Chanting cleared). Players gain counterplay through damage-based interruption: dealing 10% or more of the enemy's MaxHP in a single hit breaks the channeling and applies Stunned(1) as a penalty. The AI system integrates charge abilities into the v0.2.4b utility scoring framework with contextual bonuses: +20 base score for charge abilities, +30 when player is stunned (free setup window), and -50 when enemy HP is critical (too risky to stand still). This creates tactical depth where players must decide between allowing high-damage abilities to complete or interrupting at the cost of damage output.

**Layers Touched:**
- Core Layer: Enum extension (StatusEffectType.Chanting), Entity extensions (ActiveAbility properties, Combatant.ChanneledAbilityId)
- Engine Layer: Service major refactor (AbilityService charge lifecycle), Service enhancement (EnemyAIService charge scoring, CombatService interruption system)
- Test Layer: 25 new tests covering charge initiation, release, AI handling, and interruption mechanics

**Patterns Introduced:**
- Charge-then-Release Pattern (multi-turn ability lifecycle with telegraph phase)
- Damage Threshold Interruption Pattern (single-hit damage breaks channeling)
- AI Charge Scoring Pattern (risk/reward evaluation for delayed abilities)
- Resource Commitment Pattern (costs deducted at initiation, not release)

---

### New Files Created

#### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/TelegraphedAbilityTests.cs` | Comprehensive test suite for charge ability lifecycle, AI handling, and interruption mechanics (25 tests) |

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/StatusEffectType.cs` | Added Chanting = 7 debuff enum value (line 63) for locked-in casting state tracking |
| `RuneAndRust.Core/Entities/ActiveAbility.cs` | Added 3 telegraphed ability properties: ChargeTurns (int, default 0), TelegraphMessage (string?, AAM-VOICE compliant), InterruptThreshold (float, default 0.10f) |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added ChanneledAbilityId (Guid?, line 158) to track which ability is being channeled during Chanting state |
| `RuneAndRust.Engine/Services/AbilityService.cs` | Major refactor: Added IStatusEffectService dependency, charge detection logic in Execute(), new InitiateCharge() method, new ReleaseCharge() method, resource deduction extracted to DeductResources(), cooldown setting extracted to SetCooldown() |
| `RuneAndRust.Engine/Services/EnemyAIService.cs` | Added 3 charge ability scoring constants (lines 89-106): ChargeAbilityBonus (+20), ChargeLowHpPenalty (-50), ChargePlayerStunnedBonus (+30). Added Chanting state detection in DetermineAction() (lines 145-171) with Pass-while-charging and UseAbility-when-complete logic. Enhanced CalculateAbilityScore() (lines 308-320) with charge ability risk/reward evaluation |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added new CheckInterruption() private method (lines 322-357) with damage threshold calculation, status removal, Stunned application. Hooked CheckInterruption() into ExecutePlayerAttack() (line 727) after damage application |

---

### Code Implementation Details

#### Enum Extension: StatusEffectType.Chanting (RuneAndRust.Core/Enums/StatusEffectType.cs)

**New Value:**
```csharp
/// <summary>
/// Locked-in casting state. Enemy is charging a powerful ability.
/// Cannot change actions while chanting. Vulnerable to interruption.
/// Does not stack; reapplication refreshes duration only (v0.2.4c).
/// </summary>
Chanting = 7
```

**Behavior:**
- Enum value 7, following Analyzed (6)
- Applied when enemy initiates charge ability (ChargeTurns > 0)
- Duration equals ChargeTurns value (e.g., ChargeTurns = 2 → Chanting(2))
- Does not stack; treated as non-stacking debuff
- Cleared on charge release or interruption
- Used by AI to detect locked-in state and return Pass actions

#### Entity Extension: ActiveAbility Properties (RuneAndRust.Core/Entities/ActiveAbility.cs)

**New Properties:**
```csharp
/// <summary>
/// Number of turns required to charge before release. 0 = instant cast.
/// During charge, the caster gains Chanting status (v0.2.4c).
/// </summary>
public int ChargeTurns { get; set; } = 0;

/// <summary>
/// AAM-VOICE compliant message displayed when charge begins.
/// Example: "The Construct's core begins to glow violent red."
/// If null, a default message is generated (v0.2.4c).
/// </summary>
public string? TelegraphMessage { get; set; }

/// <summary>
/// Damage threshold to interrupt the charge (percentage of MaxHP).
/// Default 0.10 means 10% of enemy MaxHP must be dealt in one hit.
/// Set to 1.0 for uninterruptible abilities (v0.2.4c).
/// </summary>
public float InterruptThreshold { get; set; } = 0.10f;
```

#### Model Extension: Combatant.ChanneledAbilityId (RuneAndRust.Core/Models/Combat/Combatant.cs)

**New Property:**
```csharp
/// <summary>
/// The ability being channeled during Chanting state (v0.2.4c).
/// Set when charge begins, cleared on release or interruption.
/// Null when not channeling.
/// </summary>
public Guid? ChanneledAbilityId { get; set; }
```

**Lifecycle:**
1. Set by AbilityService.InitiateCharge() when charge begins
2. Used by EnemyAIService.DetermineAction() to create release action when Chanting expires
3. Used by CombatService.CheckInterruption() to lookup InterruptThreshold
4. Cleared by AbilityService.ReleaseCharge() on successful release
5. Cleared by CombatService.CheckInterruption() on interruption

#### New Method: AbilityService.InitiateCharge

**Implementation:**
```csharp
private AbilityResult InitiateCharge(Combatant user, ActiveAbility ability)
{
    _logger.LogInformation(
        "[Ability] {User} begins charging {Ability}",
        user.Name, ability.Name);

    // Deduct resources immediately (committed to the action)
    DeductResources(user, ability);

    // Apply Chanting status with duration = ChargeTurns
    _statusEffects.ApplyEffect(user, StatusEffectType.Chanting, ability.ChargeTurns, user.Id);

    // Store which ability is being channeled
    user.ChanneledAbilityId = ability.Id;

    // Return telegraph message
    var message = ability.TelegraphMessage ?? $"{user.Name} begins charging a powerful attack!";
    return AbilityResult.Ok($"⚠ {message}");
}
```

#### Interruption System: CombatService.CheckInterruption (RuneAndRust.Engine/Services/CombatService.cs)

**Implementation:**
```csharp
private void CheckInterruption(Combatant target, int damageDealt)
{
    // Only check enemies that are chanting
    if (!target.StatusEffects.Any(e => e.Type == StatusEffectType.Chanting))
        return;

    if (!target.ChanneledAbilityId.HasValue)
        return;

    var channeledAbility = target.Abilities.FirstOrDefault(a => a.Id == target.ChanneledAbilityId);
    var threshold = channeledAbility?.InterruptThreshold ?? 0.10f;
    var requiredDamage = (int)(target.MaxHp * threshold);

    if (damageDealt >= requiredDamage)
    {
        // INTERRUPTED!
        _logger.LogWarning(
            "[Combat] {Enemy}'s concentration is BROKEN! (Dealt {Damage} >= {Threshold})",
            target.Name, damageDealt, requiredDamage);

        _statusEffects.RemoveEffect(target, StatusEffectType.Chanting);
        target.ChanneledAbilityId = null;

        // Apply Stunned for 1 turn as penalty
        _statusEffects.ApplyEffect(target, StatusEffectType.Stunned, 1, Guid.Empty);

        LogCombatEvent($"[yellow]{target.Name}'s concentration is BROKEN![/]");
    }
    else
    {
        _logger.LogTrace(
            "[Combat] {Enemy} maintains focus through {Damage} damage (needed {Threshold})",
            target.Name, damageDealt, requiredDamage);
        LogCombatEvent($"[grey]{target.Name} maintains focus through the pain.[/]");
    }
}
```

**Interruption Math Examples:**

| Enemy MaxHP | InterruptThreshold | Required Damage | Example Outcome |
|-------------|-------------------|-----------------|-----------------|
| 100 | 0.10f (10%) | 10 | Heavy Attack (12) → Interrupted |
| 100 | 0.10f (10%) | 10 | Standard Attack (7) → Focus maintained |
| 200 | 0.10f (10%) | 20 | Heavy Attack (18) → Focus maintained |
| 50 | 0.25f (25%) | 12 | Heavy Attack (14) → Interrupted |
| 150 | 1.0f (100%) | 150 | Any attack → Focus maintained (uninterruptible) |

#### AI Enhancement: EnemyAIService Charge Scoring (RuneAndRust.Engine/Services/EnemyAIService.cs)

**New Scoring Constants:**
```csharp
/// <summary>
/// Base bonus for charge abilities (powerful attacks get priority).
/// </summary>
private const int ChargeAbilityBonus = 20;

/// <summary>
/// Penalty for charge abilities when HP is below 30% (too risky to stand still).
/// </summary>
private const int ChargeLowHpPenalty = -50;

/// <summary>
/// Bonus for charge abilities when player is stunned (free setup).
/// </summary>
private const int ChargePlayerStunnedBonus = 30;
```

**Charge Ability Scoring Matrix:**

| Context | Modifier | Applied To | Typical Score |
|---------|----------|------------|---------------|
| Base charge ability | +20 | ChargeTurns > 0 | 70 (50+20) |
| Enemy HP < 30% | -50 | ChargeTurns > 0 | 20 (50+20-50) |
| Player stunned | +30 | ChargeTurns > 0 | 100 (50+20+30) |
| HP low + player stunned | -50+30 | ChargeTurns > 0 | 50 (50+20-50+30) |

---

### Logging Matrix

#### AbilityService (Engine Layer)

| Event | Level | Template |
|-------|-------|----------|
| **Charge initiation** | **Information** | `"[Ability] {User} begins charging {Ability}"` |
| **Charge release** | **Information** | `"[Ability] {User} releases {Ability}!"` |
| **Charge release complete** | **Information** | `"[Ability] {User} released {Ability} on {Target}: {Message}"` |

#### EnemyAIService (Engine Layer)

| Event | Level | Template |
|-------|-------|----------|
| **Chanting maintenance** | **Trace** | `"[AI] {Enemy} is chanting. {Turns} turns remaining."` |
| **Chanting complete** | **Debug** | `"[AI] {Enemy} chant complete. Releasing {Ability}!"` |

#### CombatService (Engine Layer)

| Event | Level | Template |
|-------|-------|----------|
| **Interruption success** | **Warning** | `"[Combat] {Enemy}'s concentration is BROKEN! (Dealt {Damage} >= {Threshold})"` |
| **Interruption failure** | **Trace** | `"[Combat] {Enemy} maintains focus through {Damage} damage (needed {Threshold})"` |

---

### Test Coverage

**Summary:**
```
Total: 25 | Passed: 25 | Failed: 0 | Duration: 86 ms
```

#### Complete Test Inventory

##### AbilityService Tests - Charge Initiation (7 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_ChargeAbility_AppliesChantingStatus` | Asserts IStatusEffectService.ApplyEffect called with Chanting, duration = ChargeTurns, sourceId = user.Id |
| `Execute_ChargeAbility_SetsChanneledAbilityId` | Asserts user.ChanneledAbilityId equals ability.Id after initiation |
| `Execute_ChargeAbility_ReturnsTelegraphMessage` | Asserts result.Message contains custom TelegraphMessage when provided |
| `Execute_ChargeAbility_UsesDefaultTelegraphWhenNotSet` | Asserts result.Message contains "begins charging a powerful attack" when TelegraphMessage is null |
| `Execute_ChargeAbility_DeductsResourcesImmediately` | Asserts IResourceService.Deduct called for Stamina and Aether at initiation |
| `Execute_ChargeAbility_DoesNotDealDamageImmediately` | Asserts target.CurrentHp unchanged after charge initiation |
| `Execute_ChargeAbility_DoesNotSetCooldownImmediately` | Asserts user.Cooldowns does not contain ability.Id after initiation |

##### AbilityService Tests - Charge Release (5 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_ReleaseCharge_DealsDamage` | Asserts target.CurrentHp reduced by EffectScript damage on release |
| `Execute_ReleaseCharge_ClearsChantingStatus` | Asserts IStatusEffectService.RemoveEffect called with Chanting on release |
| `Execute_ReleaseCharge_ClearsChanneledAbilityId` | Asserts user.ChanneledAbilityId is null after release |
| `Execute_ReleaseCharge_SetsCooldown` | Asserts user.Cooldowns contains ability.Id with correct duration after release |
| `Execute_ReleaseCharge_ReturnsUnleashMessage` | Asserts result.Message contains "unleashes" and ability.Name |

##### Interruption Tests (7 tests)

| Test Name | Description |
|-----------|-------------|
| `CheckInterruption_DamageAboveThreshold_BreaksChant` | Asserts damage >= (MaxHP × InterruptThreshold) satisfies interruption condition |
| `CheckInterruption_DamageAboveThreshold_AppliesStunned` | Asserts Stunned(1) status applied on successful interruption |
| `CheckInterruption_DamageBelowThreshold_MaintainsFocus` | Asserts damage < (MaxHP × InterruptThreshold) does not interrupt |
| `CheckInterruption_NotChanting_NoEffect` | Asserts CheckInterruption logic skips combatants without Chanting status |
| `InterruptThreshold_DefaultValue_IsTenPercent` | Asserts ActiveAbility.InterruptThreshold defaults to 0.10f |
| `InterruptThreshold_CanBeCustomized` | Asserts ActiveAbility.InterruptThreshold can be set to custom values (e.g., 0.25f) |

---

### Design Decisions

#### Charge-then-Release Lifecycle

**Decision:** Telegraph abilities execute in two phases: initiation (charge) and release (damage).

**Rationale:**
- **Player Counterplay:** Provides clear window for interruption mechanics
- **Tactical Depth:** Forces decision between allowing damage or interrupting
- **Resource Management:** Encourages strategic use of high-damage attacks
- **Visual Clarity:** Separate telegraph and damage phases improve readability

#### Resources Deducted at Initiation

**Decision:** Stamina and Aether costs deducted when charge begins, not when damage is dealt.

**Rationale:**
- **Commitment:** Forces player to interrupt or accept resource investment
- **No Exploitation:** Prevents regeneration during charge period
- **Risk/Reward:** Failed interruption wastes resources
- **Consistency:** Matches "locked-in" behavior (cannot cancel charge)

#### Cooldown Set at Release

**Decision:** Ability cooldown applied when damage is dealt, not when charge begins.

**Rationale:**
- **Logical Consistency:** Ability "used" when effect executes, not during telegraph
- **Interrupted Abilities:** No cooldown on failed charge (can retry next turn)
- **Balance:** Prevents cooldown-without-effect exploitation
- **Tuning:** Cooldown starts after high-impact moment

#### Single-Hit Damage Threshold

**Decision:** Interruption requires single-hit damage >= threshold. Damage does not accumulate.

**Rationale:**
- **Skill Expression:** Rewards timing heavy attacks for interruption
- **Clear Feedback:** Binary success/failure (no guessing accumulated damage)
- **No Chip Damage:** Light attacks cannot interrupt (prevents trivial counterplay)
- **Tunable Difficulty:** InterruptThreshold allows per-ability customization

#### Stunned(1) Interruption Penalty

**Decision:** Successfully interrupting a charge applies Stunned(1) to the caster.

**Rationale:**
- **Thematic:** Concentration broken = mental stun
- **Tactical Value:** Rewards interruption with turn denial
- **Prevents Re-Charge:** Cannot immediately restart charge after interruption
- **Balance:** Makes interruption worthwhile beyond saving HP

---

## Combined Test Summary

| Category | Count | Status |
|----------|-------|--------|
| EnemyFactoryTests (v0.2.4a) | 56 | Passed |
| EnemyAIServiceTests (v0.2.4b) | 39 | Passed |
| CombatServiceTests (v0.2.4b) | 4 new | Passed |
| TelegraphedAbilityTests (v0.2.4c) | 25 | Passed |
| **v0.2.4 Total** | **124** | **All Passed** |

---

## Directory Structure

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Entities/
│   │   ├── ActiveAbility.cs           [MODIFIED] - Nullable Archetype, Charge properties
│   │   └── Enemy.cs                   [MODIFIED] - Added Abilities property
│   ├── Enums/
│   │   ├── ActionType.cs              [MODIFIED] - Added UseAbility
│   │   └── StatusEffectType.cs        [MODIFIED] - Added Chanting
│   ├── Interfaces/
│   │   └── IEnemyFactory.cs           [MODIFIED] - Async method signatures
│   └── Models/Combat/
│       ├── Combatant.cs               [MODIFIED] - FromEnemy() ability copy, ChanneledAbilityId
│       ├── CombatAction.cs            [MODIFIED] - Added AbilityId parameter
│       └── EnemyTemplate.cs           [MODIFIED] - Added AbilityNames parameter
│
├── RuneAndRust.Engine/
│   ├── Factories/
│   │   └── EnemyFactory.cs            [MODIFIED] - Ability hydration, async methods
│   └── Services/
│       ├── AbilityService.cs          [MODIFIED] - Charge lifecycle (InitiateCharge, ReleaseCharge)
│       ├── CombatService.cs           [MODIFIED] - UseAbility handling, CheckInterruption
│       └── EnemyAIService.cs          [MODIFIED] - Utility scoring, charge handling
│
├── RuneAndRust.Persistence/
│   ├── Data/
│   │   ├── AbilitySeeder.cs           [MODIFIED] - Added GetEnemyAbilities()
│   │   └── RuneAndRustDbContext.cs    [MODIFIED] - Archetype nullable configuration
│   └── Migrations/
│       └── 20251223022458_MakeActiveAbilityArchetypeNullable.cs [NEW]
│
└── RuneAndRust.Tests/
    └── Engine/
        ├── EnemyFactoryTests.cs       [MODIFIED] - Added 8 ability hydration tests
        ├── EnemyAIServiceTests.cs     [MODIFIED] - Added 14 utility scoring tests
        ├── CombatServiceTests.cs      [MODIFIED] - Added 4 ability execution tests
        └── TelegraphedAbilityTests.cs [NEW] - 25 charge ability tests
```

---

## Verification

```bash
# Build
dotnet build
# Build succeeded. 0 Error(s)

# Test v0.2.4 components
dotnet test --filter "FullyQualifiedName~EnemyFactory|FullyQualifiedName~EnemyAIService|FullyQualifiedName~Telegraphed"
# Passed! - Failed: 0, Passed: 120+, Skipped: 0

# Full test suite
dotnet test
# Passed! - Failed: 0, Passed: 2500+, Skipped: 0
```

---

**End of Changelog**
