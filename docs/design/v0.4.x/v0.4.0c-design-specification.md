# v0.4.0c Design Specification: Activation & Destruction

**Version:** 0.4.0c
**Phase Name:** Activation & Destruction
**Parent Version:** v0.4.0 (Interactive Objects Foundation)
**Prerequisites:** v0.4.0b Complete (Containers & Locks)
**Estimated Tests:** ~25 unit tests

---

## 1. Overview

### 1.1 Purpose

Implement activation mechanisms (levers, buttons) that trigger linked effects on other objects, and add destructible object support allowing players to break barriers, crates, and other objects through combat.

### 1.2 Current State

The following infrastructure exists from prior versions:

| Component | Location | Status |
|-----------|----------|--------|
| `InteractiveObject` entity | `Domain/Entities/InteractiveObject.cs` | From v0.4.0a |
| `InteractionService` | `Application/Services/InteractionService.cs` | From v0.4.0a/b |
| `InteractionType` enum | `Domain/Enums/InteractionType.cs` | From v0.4.0a |
| `ObjectState` enum | `Domain/Enums/ObjectState.cs` | Complete (includes Active, Inactive, Broken, Destroyed) |
| `InteractiveObjectType` enum | `Domain/Enums/InteractiveObjectType.cs` | Expanded in v0.4.0a (includes Lever, Button) |
| `ContainerInventory` | `Domain/ValueObjects/ContainerInventory.cs` | From v0.4.0b |
| `LockDefinition` | `Domain/ValueObjects/LockDefinition.cs` | From v0.4.0b |
| `CombatService` | `Domain/Services/CombatService.cs` | Complete (dice-based combat) |
| `DiceService` | `Application/Services/DiceService.cs` | Complete |
| `Room` entity | `Domain/Entities/Room.cs` | Has Interactables collection |

### 1.3 Scope

**In Scope:**
- `ObjectEffect` value object for linked effects
- `EffectType` enum for effect categories
- `DestructibleProperties` value object for breakable objects
- Lever toggle mechanics (Active/Inactive with linked effects)
- Button momentary activation (auto-reset after delay)
- Effect triggering when source object changes state
- Effect types: Open, Close, Unlock, Lock, Toggle, Activate, Deactivate, Reveal, Message
- Destructible object HP tracking
- Attack command targeting interactive objects
- Damage application with vulnerabilities/resistances/immunities
- Destroyed barriers no longer block passage
- Destroyed containers drop loot to room
- `break <object>` command (alias for attack on destructible)
- InteractionService updates for activation/destruction
- Configuration for effects and destructible properties

**Out of Scope:**
- Trapped containers (v0.4.1)
- Pressure plates (v0.4.1)
- Timed sequences (v0.4.1)
- Chain reactions (effect triggering further effects) (v0.4.1)

### 1.4 Design Goals

1. **Linked Effects**: Objects can affect other objects when their state changes
2. **Combat Integration**: Destructible objects use existing CombatService patterns
3. **Damage System Parity**: Vulnerabilities, resistances, immunities mirror monster damage types
4. **Auto-Reset**: Buttons automatically reset after configurable delay
5. **Feedback**: Clear messages when effects trigger
6. **Testability**: Clean separation for comprehensive unit testing

---

## 2. Data Model

### 2.1 EffectType Enum (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/EffectType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of effects that can be triggered by interactive objects.
/// </summary>
public enum EffectType
{
    /// <summary>Opens the target object.</summary>
    OpenTarget,

    /// <summary>Closes the target object.</summary>
    CloseTarget,

    /// <summary>Unlocks the target object.</summary>
    UnlockTarget,

    /// <summary>Locks the target object.</summary>
    LockTarget,

    /// <summary>Toggles the target between open/closed or active/inactive.</summary>
    ToggleTarget,

    /// <summary>Activates the target object.</summary>
    ActivateTarget,

    /// <summary>Deactivates the target object.</summary>
    DeactivateTarget,

    /// <summary>Destroys/breaks the target object.</summary>
    DestroyTarget,

    /// <summary>Reveals a hidden object.</summary>
    RevealTarget,

    /// <summary>Displays a message (no state change).</summary>
    Message
}
```

### 2.2 ObjectEffect Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ObjectEffect.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines an effect that occurs when an interactive object changes state.
/// </summary>
public readonly record struct ObjectEffect
{
    /// <summary>
    /// Gets the effect type.
    /// </summary>
    public EffectType Type { get; init; }

    /// <summary>
    /// Gets the target object ID affected by this effect.
    /// </summary>
    public string TargetObjectId { get; init; }

    /// <summary>
    /// Gets the triggering state (effect happens when source enters this state).
    /// </summary>
    public ObjectState TriggerOnState { get; init; }

    /// <summary>
    /// Gets the delay in turns before the effect triggers (0 = immediate).
    /// </summary>
    public int DelayTurns { get; init; }

    /// <summary>
    /// Gets the message displayed when this effect triggers.
    /// </summary>
    public string? EffectMessage { get; init; }

    /// <summary>
    /// Gets whether this effect triggers immediately (no delay).
    /// </summary>
    public bool IsImmediate => DelayTurns == 0;

    /// <summary>
    /// Creates an immediate open effect.
    /// </summary>
    /// <param name="targetId">The target object ID.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <param name="message">Optional message to display.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect OpenTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.OpenTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates an immediate close effect.
    /// </summary>
    /// <param name="targetId">The target object ID.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <param name="message">Optional message to display.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect CloseTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.CloseTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates an unlock effect.
    /// </summary>
    /// <param name="targetId">The target object ID.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <param name="message">Optional message to display.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect UnlockTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.UnlockTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates a lock effect.
    /// </summary>
    /// <param name="targetId">The target object ID.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <param name="message">Optional message to display.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect LockTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.LockTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates a toggle effect.
    /// </summary>
    /// <param name="targetId">The target object ID.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <param name="message">Optional message to display.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect ToggleTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.ToggleTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates an activate effect.
    /// </summary>
    /// <param name="targetId">The target object ID.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <param name="message">Optional message to display.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect ActivateTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.ActivateTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates a deactivate effect.
    /// </summary>
    /// <param name="targetId">The target object ID.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <param name="message">Optional message to display.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect DeactivateTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.DeactivateTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates a reveal effect.
    /// </summary>
    /// <param name="targetId">The target object ID.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <param name="message">Optional message to display.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect RevealTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.RevealTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates a message-only effect (no state change).
    /// </summary>
    /// <param name="message">The message to display.</param>
    /// <param name="triggerOn">The state that triggers this effect.</param>
    /// <returns>A new ObjectEffect.</returns>
    public static ObjectEffect MessageOnly(string message, ObjectState triggerOn) => new()
    {
        Type = EffectType.Message,
        TargetObjectId = string.Empty,
        TriggerOnState = triggerOn,
        DelayTurns = 0,
        EffectMessage = message
    };

    /// <summary>
    /// Creates a delayed effect.
    /// </summary>
    /// <param name="baseEffect">The base effect to delay.</param>
    /// <param name="delayTurns">Number of turns to delay.</param>
    /// <returns>A new ObjectEffect with the specified delay.</returns>
    public static ObjectEffect Delayed(ObjectEffect baseEffect, int delayTurns) => baseEffect with
    {
        DelayTurns = delayTurns
    };
}
```

### 2.3 DestructibleProperties Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DestructibleProperties.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Properties for objects that can be destroyed through damage.
/// </summary>
public class DestructibleProperties
{
    /// <summary>
    /// Gets the maximum hit points of this object.
    /// </summary>
    public int MaxHP { get; private set; }

    /// <summary>
    /// Gets the current hit points.
    /// </summary>
    public int CurrentHP { get; private set; }

    /// <summary>
    /// Gets whether this object is destroyed.
    /// </summary>
    public bool IsDestroyed => CurrentHP <= 0;

    /// <summary>
    /// Gets the defense/armor of this object.
    /// </summary>
    public int Defense { get; private set; }

    /// <summary>
    /// Gets damage type vulnerabilities (deal extra damage).
    /// </summary>
    public IReadOnlyList<string> Vulnerabilities { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets damage type resistances (deal reduced damage).
    /// </summary>
    public IReadOnlyList<string> Resistances { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets damage type immunities (deal no damage).
    /// </summary>
    public IReadOnlyList<string> Immunities { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the loot table ID for items dropped when destroyed.
    /// </summary>
    public string? LootTableId { get; private set; }

    /// <summary>
    /// Gets the percentage of HP remaining.
    /// </summary>
    public double HealthPercentage => MaxHP > 0 ? (double)CurrentHP / MaxHP * 100 : 0;

    private DestructibleProperties() { }

    /// <summary>
    /// Creates destructible properties.
    /// </summary>
    /// <param name="maxHP">Maximum hit points.</param>
    /// <param name="defense">Defense value (reduces incoming damage).</param>
    /// <param name="vulnerabilities">Damage types that deal double damage.</param>
    /// <param name="resistances">Damage types that deal half damage.</param>
    /// <param name="immunities">Damage types that deal no damage.</param>
    /// <param name="lootTableId">Optional loot table for drops.</param>
    /// <returns>A new DestructibleProperties.</returns>
    /// <exception cref="ArgumentException">Thrown when maxHP is not positive.</exception>
    public static DestructibleProperties Create(
        int maxHP,
        int defense = 0,
        IEnumerable<string>? vulnerabilities = null,
        IEnumerable<string>? resistances = null,
        IEnumerable<string>? immunities = null,
        string? lootTableId = null)
    {
        if (maxHP <= 0)
            throw new ArgumentException("MaxHP must be positive.", nameof(maxHP));

        return new DestructibleProperties
        {
            MaxHP = maxHP,
            CurrentHP = maxHP,
            Defense = Math.Max(0, defense),
            Vulnerabilities = vulnerabilities?.ToList() ?? Array.Empty<string>(),
            Resistances = resistances?.ToList() ?? Array.Empty<string>(),
            Immunities = immunities?.ToList() ?? Array.Empty<string>(),
            LootTableId = lootTableId
        };
    }

    /// <summary>
    /// Creates weak destructible properties (low HP, no defenses).
    /// </summary>
    /// <param name="maxHP">Maximum hit points (default 10).</param>
    /// <param name="lootTableId">Optional loot table.</param>
    /// <returns>A new DestructibleProperties.</returns>
    public static DestructibleProperties Weak(int maxHP = 10, string? lootTableId = null) =>
        Create(maxHP, defense: 0, lootTableId: lootTableId);

    /// <summary>
    /// Creates sturdy destructible properties (higher HP, some defense).
    /// </summary>
    /// <param name="maxHP">Maximum hit points (default 25).</param>
    /// <param name="defense">Defense value (default 2).</param>
    /// <param name="lootTableId">Optional loot table.</param>
    /// <returns>A new DestructibleProperties.</returns>
    public static DestructibleProperties Sturdy(int maxHP = 25, int defense = 2, string? lootTableId = null) =>
        Create(maxHP, defense, lootTableId: lootTableId);

    /// <summary>
    /// Applies damage to this object.
    /// </summary>
    /// <param name="amount">The base damage amount.</param>
    /// <param name="damageType">Optional damage type for vulnerability/resistance checks.</param>
    /// <returns>The actual damage dealt after modifications.</returns>
    public int TakeDamage(int amount, string? damageType = null)
    {
        if (IsDestroyed) return 0;
        if (amount <= 0) return 0;

        var finalDamage = amount;

        // Apply damage type modifiers
        if (!string.IsNullOrEmpty(damageType))
        {
            // Check immunity first (no damage)
            if (Immunities.Contains(damageType, StringComparer.OrdinalIgnoreCase))
                return 0;

            // Check resistance (half damage, rounded down)
            if (Resistances.Contains(damageType, StringComparer.OrdinalIgnoreCase))
                finalDamage = amount / 2;

            // Check vulnerability (double damage)
            if (Vulnerabilities.Contains(damageType, StringComparer.OrdinalIgnoreCase))
                finalDamage = amount * 2;
        }

        // Apply defense reduction (minimum 1 damage if any got through)
        finalDamage = Math.Max(0, finalDamage - Defense);
        if (finalDamage == 0 && amount > 0)
            finalDamage = 1; // Minimum 1 damage if attack would deal any

        CurrentHP = Math.Max(0, CurrentHP - finalDamage);

        return finalDamage;
    }

    /// <summary>
    /// Resets HP to maximum (for respawning objects).
    /// </summary>
    public void Repair()
    {
        CurrentHP = MaxHP;
    }

    /// <summary>
    /// Gets a description of the object's condition.
    /// </summary>
    /// <returns>A string describing the current health state.</returns>
    public string GetConditionDescription()
    {
        if (IsDestroyed)
            return "destroyed";

        var percent = HealthPercentage;
        return percent switch
        {
            >= 90 => "pristine",
            >= 75 => "slightly damaged",
            >= 50 => "damaged",
            >= 25 => "heavily damaged",
            > 0 => "nearly destroyed",
            _ => "destroyed"
        };
    }
}
```

### 2.4 EffectTriggerResult Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EffectTriggerResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the result of triggering an object effect.
/// </summary>
public readonly record struct EffectTriggerResult
{
    /// <summary>
    /// Gets whether the effect was successfully applied.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the effect that was triggered.
    /// </summary>
    public ObjectEffect Effect { get; init; }

    /// <summary>
    /// Gets the ID of the target object.
    /// </summary>
    public string TargetObjectId { get; init; }

    /// <summary>
    /// Gets the message to display to the player.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the new state of the target object (if changed).
    /// </summary>
    public ObjectState? NewTargetState { get; init; }

    /// <summary>
    /// Creates a successful effect result.
    /// </summary>
    public static EffectTriggerResult Succeeded(
        ObjectEffect effect,
        string message,
        ObjectState? newState = null) => new()
    {
        Success = true,
        Effect = effect,
        TargetObjectId = effect.TargetObjectId,
        Message = message,
        NewTargetState = newState
    };

    /// <summary>
    /// Creates a failed effect result.
    /// </summary>
    public static EffectTriggerResult Failed(
        ObjectEffect effect,
        string message) => new()
    {
        Success = false,
        Effect = effect,
        TargetObjectId = effect.TargetObjectId,
        Message = message
    };

    /// <summary>
    /// Creates a result for when the target object wasn't found.
    /// </summary>
    public static EffectTriggerResult TargetNotFound(ObjectEffect effect) =>
        Failed(effect, $"Effect target '{effect.TargetObjectId}' not found.");
}
```

### 2.5 ObjectDamageResult Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ObjectDamageResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Entities;

/// <summary>
/// Represents the result of damaging an interactive object.
/// </summary>
public readonly record struct ObjectDamageResult
{
    /// <summary>
    /// Gets whether the attack was successful.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the message to display to the player.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the damage dealt.
    /// </summary>
    public int DamageDealt { get; init; }

    /// <summary>
    /// Gets whether the object was destroyed.
    /// </summary>
    public bool WasDestroyed { get; init; }

    /// <summary>
    /// Gets items dropped from destruction (if any).
    /// </summary>
    public IReadOnlyList<Item> DroppedItems { get; init; }

    /// <summary>
    /// Gets whether passage was cleared by the destruction.
    /// </summary>
    public bool PassageCleared { get; init; }

    /// <summary>
    /// Creates a successful damage result.
    /// </summary>
    public static ObjectDamageResult Hit(
        string message,
        int damage,
        bool destroyed = false,
        IEnumerable<Item>? droppedItems = null,
        bool passageCleared = false) => new()
    {
        Success = true,
        Message = message,
        DamageDealt = damage,
        WasDestroyed = destroyed,
        DroppedItems = droppedItems?.ToList() ?? Array.Empty<Item>(),
        PassageCleared = passageCleared
    };

    /// <summary>
    /// Creates a result for immune damage.
    /// </summary>
    public static ObjectDamageResult Immune(string objectName, string damageType) => new()
    {
        Success = true, // Attack succeeded, just did no damage
        Message = $"The {objectName} is immune to {damageType} damage!",
        DamageDealt = 0,
        WasDestroyed = false,
        DroppedItems = Array.Empty<Item>(),
        PassageCleared = false
    };

    /// <summary>
    /// Creates a failed result (object not destructible).
    /// </summary>
    public static ObjectDamageResult NotDestructible(string objectName) => new()
    {
        Success = false,
        Message = $"The {objectName} cannot be destroyed.",
        DamageDealt = 0,
        WasDestroyed = false,
        DroppedItems = Array.Empty<Item>(),
        PassageCleared = false
    };

    /// <summary>
    /// Creates a result for already destroyed objects.
    /// </summary>
    public static ObjectDamageResult AlreadyDestroyed(string objectName) => new()
    {
        Success = false,
        Message = $"The {objectName} is already destroyed.",
        DamageDealt = 0,
        WasDestroyed = false,
        DroppedItems = Array.Empty<Item>(),
        PassageCleared = false
    };
}
```

### 2.6 InteractiveObject Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/InteractiveObject.cs`

Add the following properties and methods:

```csharp
// Add private fields:
private readonly List<ObjectEffect> _effects = new();
private int _turnsUntilReset = -1; // -1 means no pending reset

// Add properties:

/// <summary>
/// Gets the effects that trigger when this object changes state.
/// </summary>
public IReadOnlyList<ObjectEffect> Effects => _effects;

/// <summary>
/// Gets whether this object has any linked effects.
/// </summary>
public bool HasEffects => _effects.Count > 0;

/// <summary>
/// Gets the destructible properties (null for indestructible objects).
/// </summary>
public DestructibleProperties? Destructible { get; private set; }

/// <summary>
/// Gets whether this object can be destroyed.
/// </summary>
public bool IsDestructible => Destructible != null;

/// <summary>
/// Gets whether this object is currently destroyed.
/// </summary>
public bool IsDestroyed => Destructible?.IsDestroyed == true ||
                           State == ObjectState.Destroyed ||
                           State == ObjectState.Broken;

/// <summary>
/// Gets whether this object is a button (auto-resets after activation).
/// </summary>
public bool IsButton { get; private set; }

/// <summary>
/// Gets the delay in turns before a button resets (0 = instant).
/// </summary>
public int ResetDelay { get; private set; }

/// <summary>
/// Gets whether this object has a pending reset (for buttons).
/// </summary>
public bool HasPendingReset => _turnsUntilReset >= 0;

/// <summary>
/// Gets the turns remaining until reset.
/// </summary>
public int TurnsUntilReset => _turnsUntilReset;

// Add methods:

/// <summary>
/// Adds an effect to this object.
/// </summary>
/// <param name="effect">The effect to add.</param>
public void AddEffect(ObjectEffect effect)
{
    _effects.Add(effect);
}

/// <summary>
/// Sets up this object's effects.
/// </summary>
/// <param name="effects">The effects to add.</param>
public void SetEffects(IEnumerable<ObjectEffect> effects)
{
    _effects.Clear();
    _effects.AddRange(effects);
}

/// <summary>
/// Sets up this object as destructible.
/// </summary>
/// <param name="properties">The destructible properties.</param>
public void SetDestructible(DestructibleProperties properties)
{
    Destructible = properties ?? throw new ArgumentNullException(nameof(properties));
}

/// <summary>
/// Sets up this object as a button with auto-reset.
/// </summary>
/// <param name="resetDelay">Turns until reset (0 = immediate on next turn tick).</param>
public void SetAsButton(int resetDelay = 3)
{
    IsButton = true;
    ResetDelay = Math.Max(0, resetDelay);
}

/// <summary>
/// Gets effects that trigger when this object enters the specified state.
/// </summary>
/// <param name="newState">The state being entered.</param>
/// <returns>Effects that trigger on this state.</returns>
public IEnumerable<ObjectEffect> GetTriggeredEffects(ObjectState newState)
{
    return _effects.Where(e => e.TriggerOnState == newState);
}

/// <summary>
/// Activates this object (for levers and buttons).
/// </summary>
/// <returns>True if activation succeeded.</returns>
public bool Activate()
{
    if (!CanInteract) return false;
    if (State == ObjectState.Active) return false;

    State = ObjectState.Active;

    // For buttons, start the reset timer
    if (IsButton)
    {
        _turnsUntilReset = ResetDelay;
    }

    return true;
}

/// <summary>
/// Deactivates this object (for levers).
/// </summary>
/// <returns>True if deactivation succeeded.</returns>
public bool Deactivate()
{
    if (!CanInteract) return false;
    if (State != ObjectState.Active) return false;

    State = ObjectState.Inactive;
    return true;
}

/// <summary>
/// Toggles this object between active and inactive states.
/// </summary>
/// <returns>The new state, or null if toggle failed.</returns>
public ObjectState? Toggle()
{
    if (!CanInteract) return null;

    if (State == ObjectState.Active)
    {
        State = ObjectState.Inactive;
        return ObjectState.Inactive;
    }
    else if (State == ObjectState.Inactive || State == ObjectState.Down)
    {
        State = ObjectState.Active;
        if (IsButton)
        {
            _turnsUntilReset = ResetDelay;
        }
        return ObjectState.Active;
    }

    return null;
}

/// <summary>
/// Processes a turn tick for this object (handles button reset).
/// </summary>
/// <returns>True if the object reset this turn.</returns>
public bool ProcessTurnTick()
{
    if (!HasPendingReset) return false;

    _turnsUntilReset--;

    if (_turnsUntilReset < 0)
    {
        _turnsUntilReset = -1;
        State = ObjectState.Inactive;
        return true;
    }

    return false;
}

/// <summary>
/// Applies damage to this object.
/// </summary>
/// <param name="amount">The damage amount.</param>
/// <param name="damageType">Optional damage type.</param>
/// <returns>The actual damage dealt.</returns>
public int TakeDamage(int amount, string? damageType = null)
{
    if (!IsDestructible) return 0;
    if (IsDestroyed) return 0;

    var damage = Destructible!.TakeDamage(amount, damageType);

    if (Destructible.IsDestroyed)
    {
        State = ObjectState.Destroyed;
    }

    return damage;
}

/// <summary>
/// Marks this object as destroyed.
/// </summary>
public void Destroy()
{
    State = ObjectState.Destroyed;
}

// Update FromDefinition to handle effects and destructible:

/// <summary>
/// Creates an interactive object from a definition.
/// </summary>
public static InteractiveObject FromDefinition(InteractiveObjectDefinition definition)
{
    ArgumentNullException.ThrowIfNull(definition);

    var obj = new InteractiveObject
    {
        Id = Guid.NewGuid(),
        DefinitionId = definition.Id,
        Name = definition.Name,
        ObjectType = definition.ObjectType,
        State = definition.DefaultState,
        DefaultState = definition.DefaultState,
        AllowedInteractions = definition.AllowedInteractions.ToList(),
        BlocksPassage = definition.BlocksPassage,
        BlockedDirection = definition.BlockedDirection,
        Keywords = definition.Keywords.ToList(),
        IsVisible = definition.IsVisible
    };

    // Set up container if applicable (from v0.4.0b)
    if (definition.IsContainer && definition.ContainerCapacity > 0)
    {
        obj.SetupAsContainer(definition.ContainerCapacity);
    }

    // Set up lock if applicable (from v0.4.0b)
    if (definition.Lock != null && definition.Lock.Value.HasLock)
    {
        obj.SetLock(definition.Lock.Value);
    }

    // Set up effects if applicable (v0.4.0c)
    if (definition.Effects != null && definition.Effects.Count > 0)
    {
        obj.SetEffects(definition.Effects);
    }

    // Set up destructible if applicable (v0.4.0c)
    if (definition.Destructible != null)
    {
        obj.SetDestructible(definition.Destructible);
    }

    // Set up button behavior (v0.4.0c)
    if (definition.IsButton)
    {
        obj.SetAsButton(definition.ResetDelay);
    }

    return obj;
}
```

### 2.7 InteractiveObjectDefinition Updates

**File:** `src/Core/RuneAndRust.Domain/Definitions/InteractiveObjectDefinition.cs`

Add properties for effects and destructible configuration:

```csharp
// Add properties:

/// <summary>
/// Gets or sets effects that trigger when this object changes state.
/// </summary>
public List<ObjectEffect> Effects { get; set; } = new();

/// <summary>
/// Gets or sets the destructible properties for this object.
/// </summary>
public DestructibleProperties? Destructible { get; set; }

/// <summary>
/// Gets or sets whether this object is a button (auto-resets).
/// </summary>
public bool IsButton { get; set; }

/// <summary>
/// Gets or sets the reset delay in turns for buttons.
/// </summary>
public int ResetDelay { get; set; } = 3;
```

---

## 3. Services

### 3.1 IInteractionService Updates

**File:** `src/Core/RuneAndRust.Application/Interfaces/IInteractionService.cs`

Add new methods:

```csharp
// Add to interface:

/// <summary>
/// Activates an interactive object (lever, button).
/// </summary>
/// <param name="obj">The object to activate.</param>
/// <param name="room">The room containing the object (for effect resolution).</param>
/// <returns>The interaction result with triggered effects.</returns>
InteractionResult Activate(InteractiveObject obj, Room room);

/// <summary>
/// Deactivates an interactive object (lever).
/// </summary>
/// <param name="obj">The object to deactivate.</param>
/// <param name="room">The room containing the object (for effect resolution).</param>
/// <returns>The interaction result with triggered effects.</returns>
InteractionResult Deactivate(InteractiveObject obj, Room room);

/// <summary>
/// Attacks a destructible object.
/// </summary>
/// <param name="obj">The object to attack.</param>
/// <param name="damage">The damage to deal.</param>
/// <param name="damageType">Optional damage type.</param>
/// <param name="room">The room containing the object.</param>
/// <returns>The damage result.</returns>
ObjectDamageResult AttackObject(InteractiveObject obj, int damage, string? damageType, Room room);

/// <summary>
/// Processes turn tick for all objects in a room (button resets).
/// </summary>
/// <param name="room">The room to process.</param>
/// <returns>List of reset messages.</returns>
IEnumerable<string> ProcessRoomTurnTick(Room room);

/// <summary>
/// Gets effects that should trigger for a state change.
/// </summary>
/// <param name="obj">The object changing state.</param>
/// <param name="newState">The new state.</param>
/// <returns>The effects to trigger.</returns>
IEnumerable<ObjectEffect> GetPendingEffects(InteractiveObject obj, ObjectState newState);

/// <summary>
/// Resolves an effect on its target object.
/// </summary>
/// <param name="effect">The effect to resolve.</param>
/// <param name="room">The room containing target objects.</param>
/// <returns>The result of applying the effect.</returns>
EffectTriggerResult ResolveEffect(ObjectEffect effect, Room room);
```

### 3.2 InteractionService Updates

**File:** `src/Core/RuneAndRust.Application/Services/InteractionService.cs`

Add implementations:

```csharp
// Update PerformInteraction to handle Activate/Deactivate:

public InteractionResult PerformInteraction(InteractiveObject obj, InteractionType type)
{
    ArgumentNullException.ThrowIfNull(obj);

    _logger.LogDebug("Performing {InteractionType} on {ObjectName}", type, obj.Name);

    if (!obj.CanInteract)
    {
        return InteractionResult.CannotInteract(obj.Name);
    }

    if (!obj.CanPerformInteraction(type))
    {
        return InteractionResult.NotAllowed(type, obj.Name);
    }

    return type switch
    {
        InteractionType.Open => Open(obj),
        InteractionType.Close => Close(obj),
        InteractionType.Examine => Examine(obj),
        InteractionType.Activate => ActivateInternal(obj),
        InteractionType.Deactivate => DeactivateInternal(obj),
        InteractionType.Break => BreakInternal(obj),
        _ => InteractionResult.NotAllowed(type, obj.Name)
    };
}

// Internal activate (without room for effects)
private InteractionResult ActivateInternal(InteractiveObject obj)
{
    if (obj.State == ObjectState.Active)
    {
        return InteractionResult.Failed(
            InteractionType.Activate,
            $"The {obj.Name} is already activated.");
    }

    if (!obj.Activate())
    {
        return InteractionResult.Failed(
            InteractionType.Activate,
            $"The {obj.Name} cannot be activated.");
    }

    var message = GetActivationMessage(obj);
    return InteractionResult.Succeeded(
        InteractionType.Activate,
        message,
        ObjectState.Active,
        stateChanged: true);
}

// Internal deactivate (without room for effects)
private InteractionResult DeactivateInternal(InteractiveObject obj)
{
    if (obj.State != ObjectState.Active)
    {
        return InteractionResult.Failed(
            InteractionType.Deactivate,
            $"The {obj.Name} is not activated.");
    }

    if (!obj.Deactivate())
    {
        return InteractionResult.Failed(
            InteractionType.Deactivate,
            $"The {obj.Name} cannot be deactivated.");
    }

    var message = GetDeactivationMessage(obj);
    return InteractionResult.Succeeded(
        InteractionType.Deactivate,
        message,
        ObjectState.Inactive,
        stateChanged: true);
}

// Internal break (without room context)
private InteractionResult BreakInternal(InteractiveObject obj)
{
    if (!obj.IsDestructible)
    {
        return InteractionResult.Failed(
            InteractionType.Break,
            $"The {obj.Name} cannot be broken.");
    }

    if (obj.IsDestroyed)
    {
        return InteractionResult.Failed(
            InteractionType.Break,
            $"The {obj.Name} is already destroyed.");
    }

    // Just mark as broken (actual damage is done via AttackObject)
    return InteractionResult.Succeeded(
        InteractionType.Break,
        $"You need to attack the {obj.Name} to break it.");
}

// Add new public methods:

/// <inheritdoc />
public InteractionResult Activate(InteractiveObject obj, Room room)
{
    ArgumentNullException.ThrowIfNull(obj);
    ArgumentNullException.ThrowIfNull(room);

    _logger.LogDebug("Activating {ObjectName}", obj.Name);

    var result = ActivateInternal(obj);

    if (result.Success && result.StateChanged)
    {
        // Resolve triggered effects
        var effectMessages = ResolveEffectsForState(obj, ObjectState.Active, room);
        if (effectMessages.Any())
        {
            var combinedMessage = result.Message + "\n\n" + string.Join("\n", effectMessages);
            return result with { Message = combinedMessage };
        }
    }

    return result;
}

/// <inheritdoc />
public InteractionResult Deactivate(InteractiveObject obj, Room room)
{
    ArgumentNullException.ThrowIfNull(obj);
    ArgumentNullException.ThrowIfNull(room);

    _logger.LogDebug("Deactivating {ObjectName}", obj.Name);

    var result = DeactivateInternal(obj);

    if (result.Success && result.StateChanged)
    {
        // Resolve triggered effects
        var effectMessages = ResolveEffectsForState(obj, ObjectState.Inactive, room);
        if (effectMessages.Any())
        {
            var combinedMessage = result.Message + "\n\n" + string.Join("\n", effectMessages);
            return result with { Message = combinedMessage };
        }
    }

    return result;
}

/// <inheritdoc />
public ObjectDamageResult AttackObject(InteractiveObject obj, int damage, string? damageType, Room room)
{
    ArgumentNullException.ThrowIfNull(obj);
    ArgumentNullException.ThrowIfNull(room);

    _logger.LogDebug("Attacking {ObjectName} for {Damage} {DamageType} damage",
        obj.Name, damage, damageType ?? "untyped");

    if (!obj.IsDestructible)
    {
        return ObjectDamageResult.NotDestructible(obj.Name);
    }

    if (obj.IsDestroyed)
    {
        return ObjectDamageResult.AlreadyDestroyed(obj.Name);
    }

    var actualDamage = obj.TakeDamage(damage, damageType);

    // Check for immunity
    if (actualDamage == 0 && damage > 0 && !string.IsNullOrEmpty(damageType))
    {
        return ObjectDamageResult.Immune(obj.Name, damageType);
    }

    var wasBlocking = obj.IsCurrentlyBlocking;
    var destroyed = obj.IsDestroyed;
    var droppedItems = new List<Item>();
    var passageCleared = false;

    if (destroyed)
    {
        _logger.LogInformation("{ObjectName} was destroyed", obj.Name);

        // Clear passage if it was blocking
        if (wasBlocking)
        {
            passageCleared = true;
        }

        // Drop container contents if it was a container
        if (obj.IsContainer && obj.ContainerInventory != null)
        {
            var items = obj.ContainerInventory.TakeAll().ToList();
            droppedItems.AddRange(items);
            // Items would be added to room in caller
        }
    }

    var message = GetDamageMessage(obj, actualDamage, destroyed, damageType);
    if (droppedItems.Any())
    {
        message += "\n\nYou find:\n" + string.Join("\n", droppedItems.Select(i => $"  - {i.Name}"));
    }
    if (passageCleared && obj.BlockedDirection.HasValue)
    {
        message += $"\n\nThe path to the {obj.BlockedDirection.Value.ToString().ToLowerInvariant()} is now clear.";
    }

    return ObjectDamageResult.Hit(message, actualDamage, destroyed, droppedItems, passageCleared);
}

/// <inheritdoc />
public IEnumerable<string> ProcessRoomTurnTick(Room room)
{
    ArgumentNullException.ThrowIfNull(room);

    var messages = new List<string>();

    foreach (var obj in room.Interactables)
    {
        if (obj.ProcessTurnTick())
        {
            var resetMessage = GetButtonResetMessage(obj);
            messages.Add(resetMessage);

            _logger.LogDebug("{ObjectName} reset to inactive", obj.Name);

            // Trigger effects for returning to inactive
            var effectMessages = ResolveEffectsForState(obj, ObjectState.Inactive, room);
            messages.AddRange(effectMessages);
        }
    }

    return messages;
}

/// <inheritdoc />
public IEnumerable<ObjectEffect> GetPendingEffects(InteractiveObject obj, ObjectState newState)
{
    return obj.GetTriggeredEffects(newState);
}

/// <inheritdoc />
public EffectTriggerResult ResolveEffect(ObjectEffect effect, Room room)
{
    ArgumentNullException.ThrowIfNull(room);

    // Message-only effects
    if (effect.Type == EffectType.Message)
    {
        return EffectTriggerResult.Succeeded(effect, effect.EffectMessage ?? "Something happens.");
    }

    // Find target object by definition ID
    var target = room.Interactables.FirstOrDefault(i =>
        i.DefinitionId.Equals(effect.TargetObjectId, StringComparison.OrdinalIgnoreCase));

    if (target == null)
    {
        _logger.LogWarning("Effect target '{TargetId}' not found in room", effect.TargetObjectId);
        return EffectTriggerResult.TargetNotFound(effect);
    }

    return ApplyEffectToTarget(effect, target);
}

private EffectTriggerResult ApplyEffectToTarget(ObjectEffect effect, InteractiveObject target)
{
    var message = effect.EffectMessage ?? GetDefaultEffectMessage(effect, target);

    switch (effect.Type)
    {
        case EffectType.OpenTarget:
            if (target.State == ObjectState.Open)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is already open.");
            if (target.State == ObjectState.Locked)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is locked.");
            target.TrySetState(ObjectState.Open);
            return EffectTriggerResult.Succeeded(effect, message, ObjectState.Open);

        case EffectType.CloseTarget:
            if (target.State == ObjectState.Closed)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is already closed.");
            target.TrySetState(ObjectState.Closed);
            return EffectTriggerResult.Succeeded(effect, message, ObjectState.Closed);

        case EffectType.UnlockTarget:
            if (!target.IsLocked)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is not locked.");
            target.Unlock();
            return EffectTriggerResult.Succeeded(effect, message, ObjectState.Closed);

        case EffectType.LockTarget:
            if (target.IsLocked)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is already locked.");
            if (!target.HasLock)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} has no lock.");
            target.TryLock();
            return EffectTriggerResult.Succeeded(effect, message, ObjectState.Locked);

        case EffectType.ToggleTarget:
            var newState = target.Toggle();
            if (newState == null)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} cannot be toggled.");
            return EffectTriggerResult.Succeeded(effect, message, newState);

        case EffectType.ActivateTarget:
            if (target.State == ObjectState.Active)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is already active.");
            target.Activate();
            return EffectTriggerResult.Succeeded(effect, message, ObjectState.Active);

        case EffectType.DeactivateTarget:
            if (target.State != ObjectState.Active)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is not active.");
            target.Deactivate();
            return EffectTriggerResult.Succeeded(effect, message, ObjectState.Inactive);

        case EffectType.DestroyTarget:
            if (target.IsDestroyed)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is already destroyed.");
            target.Destroy();
            return EffectTriggerResult.Succeeded(effect, message, ObjectState.Destroyed);

        case EffectType.RevealTarget:
            if (target.IsVisible)
                return EffectTriggerResult.Failed(effect, $"The {target.Name} is already visible.");
            target.SetVisibility(true);
            return EffectTriggerResult.Succeeded(effect, message);

        default:
            return EffectTriggerResult.Failed(effect, $"Unknown effect type: {effect.Type}");
    }
}

private List<string> ResolveEffectsForState(InteractiveObject obj, ObjectState newState, Room room)
{
    var messages = new List<string>();
    var effects = obj.GetTriggeredEffects(newState);

    foreach (var effect in effects.Where(e => e.IsImmediate))
    {
        var result = ResolveEffect(effect, room);
        if (result.Success && !string.IsNullOrEmpty(result.Message))
        {
            messages.Add(result.Message);
        }
    }

    return messages;
}

private string GetDefaultEffectMessage(ObjectEffect effect, InteractiveObject target)
{
    return effect.Type switch
    {
        EffectType.OpenTarget => $"The {target.Name} opens.",
        EffectType.CloseTarget => $"The {target.Name} closes.",
        EffectType.UnlockTarget => $"You hear a click as the {target.Name} unlocks.",
        EffectType.LockTarget => $"The {target.Name} locks.",
        EffectType.ToggleTarget => $"The {target.Name} changes state.",
        EffectType.ActivateTarget => $"The {target.Name} activates.",
        EffectType.DeactivateTarget => $"The {target.Name} deactivates.",
        EffectType.DestroyTarget => $"The {target.Name} is destroyed!",
        EffectType.RevealTarget => $"A hidden {target.Name} is revealed!",
        _ => "Something happens."
    };
}

private string GetActivationMessage(InteractiveObject obj)
{
    return obj.ObjectType switch
    {
        InteractiveObjectType.Lever => $"You pull the {obj.Name}. With a grinding of gears, something shifts.",
        InteractiveObjectType.Button => $"You press the {obj.Name}. It clicks and holds.",
        _ => $"You activate the {obj.Name}."
    };
}

private string GetDeactivationMessage(InteractiveObject obj)
{
    return obj.ObjectType switch
    {
        InteractiveObjectType.Lever => $"You push the {obj.Name} back. The mechanism reverses.",
        _ => $"You deactivate the {obj.Name}."
    };
}

private string GetButtonResetMessage(InteractiveObject obj)
{
    return $"The {obj.Name} resets with a soft click.";
}

private string GetDamageMessage(InteractiveObject obj, int damage, bool destroyed, string? damageType)
{
    var typeDesc = string.IsNullOrEmpty(damageType) ? "" : $" {damageType}";

    if (destroyed)
    {
        return obj.ObjectType switch
        {
            InteractiveObjectType.Web => $"You slash through the {obj.Name}! It tears apart and collapses.",
            InteractiveObjectType.Crate => $"You smash the {obj.Name}! It splinters apart.",
            InteractiveObjectType.Barrel => $"You bash the {obj.Name}! It breaks open.",
            InteractiveObjectType.Barrier => $"You break through the {obj.Name}! The way is clear.",
            _ => $"You destroy the {obj.Name}!"
        };
    }

    var condition = obj.Destructible?.GetConditionDescription() ?? "damaged";
    return $"You strike the {obj.Name} for {damage}{typeDesc} damage! It looks {condition}.";
}
```

---

## 4. Command Integration

### 4.1 Interact Command Update

Update the interact command to use room context for effects:

```csharp
private InteractionResult ProcessInteractCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Examine,
            "Interact with what? Try 'interact <object>'.");
    }

    var keyword = string.Join(" ", args);
    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Examine,
            $"You don't see any '{keyword}' here.");
    }

    // Get default interaction
    var defaultInteraction = obj.GetDefaultInteraction();

    if (defaultInteraction == null)
    {
        return _interactionService.Examine(obj);
    }

    // For activation interactions, use the room-aware methods
    return defaultInteraction.Value switch
    {
        InteractionType.Activate => _interactionService.Activate(obj, currentRoom),
        InteractionType.Deactivate => _interactionService.Deactivate(obj, currentRoom),
        _ => _interactionService.PerformInteraction(obj, defaultInteraction.Value)
    };
}
```

### 4.2 Attack Command (Object Targeting)

```
> attack <object>
> break <object>
```

**Command Processing:**

```csharp
private InteractionResult ProcessAttackCommand(string[] args, Room currentRoom, Player player, IDiceService diceService)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Break,
            "Attack what? Try 'attack <target>'.");
    }

    var keyword = string.Join(" ", args);

    // First check for interactive objects
    var obj = _interactionService.FindObject(currentRoom, keyword);
    if (obj != null && obj.IsDestructible)
    {
        return ProcessObjectAttack(obj, currentRoom, player, diceService);
    }

    // Check for monsters (existing combat flow)
    var monster = currentRoom.GetMonsterByKeyword(keyword);
    if (monster != null)
    {
        return ProcessMonsterAttack(monster, player, diceService);
    }

    // Object exists but isn't destructible
    if (obj != null)
    {
        return InteractionResult.Failed(
            InteractionType.Break,
            $"You can't attack the {obj.Name}.");
    }

    return InteractionResult.Failed(
        InteractionType.Break,
        $"You don't see any '{keyword}' here.");
}

private InteractionResult ProcessObjectAttack(InteractiveObject obj, Room room, Player player, IDiceService diceService)
{
    // Use player's weapon damage
    var damageDice = _combatService.GetPlayerDamageDice(player);
    var damageRoll = diceService.Roll(damageDice);
    var baseDamage = damageRoll.Total + player.Attributes.Might;

    // Get damage type from weapon (if any)
    var weapon = player.GetEquippedItem(EquipmentSlot.Weapon);
    var damageType = weapon?.WeaponType?.ToString().ToLowerInvariant();

    var result = _interactionService.AttackObject(obj, baseDamage, damageType, room);

    // Add items to room if destroyed
    if (result.WasDestroyed && result.DroppedItems.Any())
    {
        foreach (var item in result.DroppedItems)
        {
            room.AddItem(item);
        }
    }

    // Build message with dice info
    var weaponName = _combatService.GetPlayerWeaponName(player);
    var rollInfo = $"You strike the {obj.Name} with your {weaponName}!\n" +
                   $"Damage: [{string.Join(",", damageRoll.Rolls)}] + {player.Attributes.Might} = {baseDamage}\n\n";

    return InteractionResult.Succeeded(
        InteractionType.Break,
        rollInfo + result.Message,
        result.WasDestroyed ? ObjectState.Destroyed : null,
        result.WasDestroyed);
}
```

### 4.3 Break Command (Alias)

```
> break <object>
```

**Command Processing:**

```csharp
private InteractionResult ProcessBreakCommand(string[] args, Room currentRoom, Player player, IDiceService diceService)
{
    // Break is just an alias for attack on destructible objects
    return ProcessAttackCommand(args, currentRoom, player, diceService);
}
```

### 4.4 Pull/Push Commands (Lever Aliases)

```
> pull <lever>
> push <lever>
```

**Command Processing:**

```csharp
private InteractionResult ProcessPullCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Activate,
            "Pull what? Try 'pull <lever>'.");
    }

    var keyword = string.Join(" ", args);
    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Activate,
            $"You don't see any '{keyword}' here.");
    }

    if (obj.ObjectType != InteractiveObjectType.Lever)
    {
        return InteractionResult.Failed(
            InteractionType.Activate,
            $"You can't pull the {obj.Name}.");
    }

    // Pull activates a lever
    return _interactionService.Activate(obj, currentRoom);
}

private InteractionResult ProcessPushCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Deactivate,
            "Push what? Try 'push <lever>' or 'push <button>'.");
    }

    var keyword = string.Join(" ", args);
    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Deactivate,
            $"You don't see any '{keyword}' here.");
    }

    // Push can activate buttons or deactivate levers
    if (obj.ObjectType == InteractiveObjectType.Button)
    {
        return _interactionService.Activate(obj, currentRoom);
    }

    if (obj.ObjectType == InteractiveObjectType.Lever)
    {
        return _interactionService.Deactivate(obj, currentRoom);
    }

    return InteractionResult.Failed(
        InteractionType.Deactivate,
        $"You can't push the {obj.Name}.");
}
```

---

## 5. Configuration

### 5.1 Updated Interactive Objects Configuration

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/interactive-objects.json`

Add lever, button, and destructible objects:

```json
{
  "$schema": "./schemas/interactive-objects.schema.json",
  "interactiveObjects": [
    {
      "id": "wall-lever",
      "name": "Rusty Wall Lever",
      "objectType": "Lever",
      "defaultState": "Inactive",
      "allowedInteractions": ["Activate", "Deactivate", "Examine"],
      "keywords": ["lever", "wall lever", "rusty lever", "switch"],
      "effects": [
        {
          "type": "UnlockTarget",
          "targetObjectId": "vault-door",
          "triggerOnState": "Active",
          "message": "You hear a click as the vault door unlocks."
        },
        {
          "type": "LockTarget",
          "targetObjectId": "vault-door",
          "triggerOnState": "Inactive",
          "message": "The vault door locks again."
        }
      ]
    },
    {
      "id": "floor-lever",
      "name": "Floor Lever",
      "objectType": "Lever",
      "defaultState": "Down",
      "allowedInteractions": ["Activate", "Deactivate", "Examine"],
      "keywords": ["lever", "floor lever"],
      "effects": [
        {
          "type": "OpenTarget",
          "targetObjectId": "hidden-door",
          "triggerOnState": "Active",
          "message": "A section of wall slides open, revealing a hidden passage!"
        },
        {
          "type": "CloseTarget",
          "targetObjectId": "hidden-door",
          "triggerOnState": "Inactive",
          "message": "The hidden passage slides closed."
        }
      ]
    },
    {
      "id": "stone-button",
      "name": "Stone Button",
      "objectType": "Button",
      "defaultState": "Inactive",
      "allowedInteractions": ["Activate", "Examine"],
      "keywords": ["button", "stone button"],
      "isButton": true,
      "resetDelay": 3,
      "effects": [
        {
          "type": "OpenTarget",
          "targetObjectId": "secret-passage",
          "triggerOnState": "Active",
          "message": "A hidden passage slides open!"
        },
        {
          "type": "CloseTarget",
          "targetObjectId": "secret-passage",
          "triggerOnState": "Inactive",
          "message": "The passage slides closed."
        }
      ]
    },
    {
      "id": "pressure-plate-button",
      "name": "Pressure Plate",
      "objectType": "Button",
      "defaultState": "Inactive",
      "allowedInteractions": ["Activate", "Examine"],
      "keywords": ["plate", "pressure plate"],
      "isButton": true,
      "resetDelay": 1,
      "effects": [
        {
          "type": "Message",
          "triggerOnState": "Active",
          "message": "You hear a click beneath your feet..."
        }
      ]
    },
    {
      "id": "spider-web-barrier",
      "name": "Giant Spider Web",
      "objectType": "Web",
      "defaultState": "Normal",
      "allowedInteractions": ["Break", "Examine"],
      "blocksPassage": true,
      "blockedDirection": "North",
      "keywords": ["web", "spider web", "cobweb"],
      "destructible": {
        "maxHP": 15,
        "defense": 0,
        "vulnerabilities": ["fire", "slashing"],
        "resistances": ["bludgeoning"],
        "immunities": ["poison"]
      }
    },
    {
      "id": "wooden-barricade",
      "name": "Wooden Barricade",
      "objectType": "Barrier",
      "defaultState": "Normal",
      "allowedInteractions": ["Break", "Examine"],
      "blocksPassage": true,
      "blockedDirection": "East",
      "keywords": ["barricade", "wooden barricade", "boards"],
      "destructible": {
        "maxHP": 25,
        "defense": 2,
        "vulnerabilities": ["fire"],
        "resistances": []
      }
    },
    {
      "id": "destructible-crate",
      "name": "Wooden Crate",
      "objectType": "Crate",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Break", "Examine", "Search", "Take", "Put"],
      "isContainer": true,
      "containerCapacity": 5,
      "keywords": ["crate", "wooden crate", "box"],
      "destructible": {
        "maxHP": 10,
        "defense": 0,
        "vulnerabilities": ["fire"],
        "lootTableId": "crate-loot-common"
      }
    },
    {
      "id": "reinforced-crate",
      "name": "Reinforced Crate",
      "objectType": "Crate",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Break", "Examine", "Search", "Take", "Put"],
      "isContainer": true,
      "containerCapacity": 8,
      "keywords": ["crate", "reinforced crate", "iron crate"],
      "destructible": {
        "maxHP": 30,
        "defense": 4,
        "resistances": ["fire"],
        "lootTableId": "crate-loot-rare"
      }
    },
    {
      "id": "hidden-door",
      "name": "Hidden Stone Door",
      "objectType": "Door",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine"],
      "blocksPassage": true,
      "blockedDirection": "North",
      "keywords": ["door", "hidden door", "stone door", "passage"],
      "isVisible": false
    },
    {
      "id": "secret-passage",
      "name": "Secret Passage",
      "objectType": "Door",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine"],
      "blocksPassage": true,
      "blockedDirection": "East",
      "keywords": ["passage", "secret passage"],
      "isVisible": false
    }
  ]
}
```

### 5.2 Updated Interactive Objects Schema

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/schemas/interactive-objects.schema.json`

Add effect and destructible properties:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Interactive Objects Configuration",
  "description": "Configuration for interactive objects in the game world",
  "type": "object",
  "properties": {
    "interactiveObjects": {
      "type": "array",
      "description": "List of interactive object definitions",
      "items": {
        "$ref": "#/definitions/interactiveObjectDefinition"
      }
    }
  },
  "definitions": {
    "interactiveObjectDefinition": {
      "type": "object",
      "required": ["id", "name", "objectType"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for this object definition"
        },
        "name": {
          "type": "string",
          "description": "Display name of the object"
        },
        "objectType": {
          "type": "string",
          "description": "Type of interactive object",
          "enum": ["Door", "Chest", "Lever", "Statue", "Altar", "LightSource", "Inscription", "WaterFeature", "Crate", "Barrel", "Button", "Web", "Barrier"]
        },
        "defaultState": {
          "type": "string",
          "description": "Default state of the object",
          "enum": ["Normal", "Open", "Closed", "Locked", "Active", "Inactive", "Up", "Down", "Lit", "Unlit"],
          "default": "Normal"
        },
        "allowedInteractions": {
          "type": "array",
          "description": "Interactions allowed on this object",
          "items": {
            "type": "string",
            "enum": ["Open", "Close", "Unlock", "Lock", "Activate", "Deactivate", "Break", "Search", "Examine", "Take", "Put"]
          }
        },
        "blocksPassage": {
          "type": "boolean",
          "description": "Whether this object blocks passage when closed/locked",
          "default": false
        },
        "blockedDirection": {
          "type": "string",
          "description": "Direction this object blocks",
          "enum": ["North", "South", "East", "West", "Up", "Down"]
        },
        "keywords": {
          "type": "array",
          "description": "Keywords that can be used to reference this object",
          "items": {
            "type": "string"
          }
        },
        "isVisible": {
          "type": "boolean",
          "description": "Whether this object is visible by default",
          "default": true
        },
        "isContainer": {
          "type": "boolean",
          "description": "Whether this object is a container",
          "default": false
        },
        "containerCapacity": {
          "type": "integer",
          "description": "Maximum items the container can hold",
          "minimum": 1,
          "default": 10
        },
        "lock": {
          "$ref": "#/definitions/lockDefinition"
        },
        "contents": {
          "type": "array",
          "description": "Initial contents of the container",
          "items": {
            "$ref": "#/definitions/containerContent"
          }
        },
        "effects": {
          "type": "array",
          "description": "Effects triggered by state changes",
          "items": {
            "$ref": "#/definitions/objectEffect"
          }
        },
        "isButton": {
          "type": "boolean",
          "description": "Whether this object auto-resets after activation",
          "default": false
        },
        "resetDelay": {
          "type": "integer",
          "description": "Turns until button resets",
          "minimum": 0,
          "default": 3
        },
        "destructible": {
          "$ref": "#/definitions/destructibleProperties"
        }
      }
    },
    "objectEffect": {
      "type": "object",
      "required": ["type", "triggerOnState"],
      "properties": {
        "type": {
          "type": "string",
          "description": "Effect type",
          "enum": ["OpenTarget", "CloseTarget", "UnlockTarget", "LockTarget", "ToggleTarget", "ActivateTarget", "DeactivateTarget", "DestroyTarget", "RevealTarget", "Message"]
        },
        "targetObjectId": {
          "type": "string",
          "description": "Target object definition ID"
        },
        "triggerOnState": {
          "type": "string",
          "description": "State that triggers this effect",
          "enum": ["Normal", "Open", "Closed", "Locked", "Active", "Inactive", "Up", "Down", "Lit", "Unlit", "Broken", "Destroyed"]
        },
        "delayTurns": {
          "type": "integer",
          "description": "Turns before effect triggers",
          "minimum": 0,
          "default": 0
        },
        "message": {
          "type": "string",
          "description": "Message displayed when effect triggers"
        }
      }
    },
    "destructibleProperties": {
      "type": "object",
      "required": ["maxHP"],
      "properties": {
        "maxHP": {
          "type": "integer",
          "description": "Maximum hit points",
          "minimum": 1
        },
        "defense": {
          "type": "integer",
          "description": "Defense value",
          "minimum": 0,
          "default": 0
        },
        "vulnerabilities": {
          "type": "array",
          "description": "Damage types that deal double damage",
          "items": {
            "type": "string"
          }
        },
        "resistances": {
          "type": "array",
          "description": "Damage types that deal half damage",
          "items": {
            "type": "string"
          }
        },
        "immunities": {
          "type": "array",
          "description": "Damage types that deal no damage",
          "items": {
            "type": "string"
          }
        },
        "lootTableId": {
          "type": "string",
          "description": "Loot table for drops when destroyed"
        }
      }
    },
    "lockDefinition": {
      "type": "object",
      "properties": {
        "lockId": {
          "type": "string",
          "description": "Unique identifier for this lock"
        },
        "requiredKeyId": {
          "type": "string",
          "description": "The key ID required to open this lock"
        },
        "isLockpickable": {
          "type": "boolean",
          "description": "Whether this lock can be picked",
          "default": true
        },
        "lockpickDC": {
          "type": "integer",
          "description": "Difficulty class for lockpicking",
          "minimum": 1,
          "default": 10
        },
        "keyConsumedOnUse": {
          "type": "boolean",
          "description": "Whether the key is consumed when used",
          "default": false
        },
        "canRelock": {
          "type": "boolean",
          "description": "Whether the lock can be relocked",
          "default": true
        }
      }
    },
    "containerContent": {
      "type": "object",
      "required": ["itemId"],
      "properties": {
        "itemId": {
          "type": "string",
          "description": "Item definition ID"
        },
        "quantity": {
          "type": "integer",
          "description": "Number of this item",
          "minimum": 1,
          "default": 1
        }
      }
    }
  }
}
```

---

## 6. User Experience

### 6.1 Lever Interaction Examples

**Activating a Lever:**
```
> pull lever

You pull the Rusty Wall Lever. With a grinding of gears, something shifts.

You hear a click as the vault door unlocks.
```

**Deactivating a Lever:**
```
> push lever

You push the Rusty Wall Lever back. The mechanism reverses.

The vault door locks again.
```

**Default Interaction:**
```
> interact lever

You pull the Rusty Wall Lever. With a grinding of gears, something shifts.

You hear a click as the vault door unlocks.

---

> interact lever

You push the Rusty Wall Lever back. The mechanism reverses.

The vault door locks again.
```

### 6.2 Button Interaction Examples

**Pressing a Button:**
```
> push button

You press the Stone Button. It clicks and holds.

A hidden passage slides open!

---

[After 3 turns]
The Stone Button resets with a soft click.
The passage slides closed.
```

### 6.3 Destructible Object Examples

**Attacking a Web:**
```
> attack web

You strike the Giant Spider Web with your Iron Sword!
Damage: [5] + 2 = 7

You strike the Giant Spider Web for 14 slashing damage! It looks heavily damaged.

> attack web

You strike the Giant Spider Web with your Iron Sword!
Damage: [4] + 2 = 6

You slash through the Giant Spider Web! It tears apart and collapses.

The path to the north is now clear.
```

**Attacking with Wrong Damage Type:**
```
> attack web

You strike the Giant Spider Web with your Wooden Club!
Damage: [6] + 2 = 8

You strike the Giant Spider Web for 4 bludgeoning damage! It looks slightly damaged.
```

**Immune Damage Type:**
```
> cast poison spray at web

The Giant Spider Web is immune to poison damage!
```

**Destroying a Container:**
```
> attack crate

You strike the Wooden Crate with your fists!
Damage: [3] + 2 = 5

You strike the Wooden Crate for 5 damage! It looks damaged.

> attack crate

You strike the Wooden Crate with your fists!
Damage: [4] + 2 = 6

You smash the Wooden Crate! It splinters apart.

You find:
  - Torch
  - 10 gold
```

### 6.4 Room Description with Destructibles

```
You are in the Webbed Corridor. Thick spider webs
cover the walls and block the path forward.

You notice:
  Giant Spider Web (blocking north) [Destructible]
  Wooden Crate (closed) [Destructible]
  Rusty Wall Lever (inactive)

Exits: south
```

---

## 7. Acceptance Criteria

### 7.1 Functional Requirements

- [ ] EffectType enum contains all effect types
- [ ] ObjectEffect value object stores effect configuration
- [ ] ObjectEffect has factory methods for all effect types
- [ ] DestructibleProperties tracks HP, defense, and damage modifiers
- [ ] DestructibleProperties.TakeDamage applies vulnerabilities (2x damage)
- [ ] DestructibleProperties.TakeDamage applies resistances (0.5x damage)
- [ ] DestructibleProperties.TakeDamage applies immunities (0 damage)
- [ ] DestructibleProperties.TakeDamage applies defense (damage reduction)
- [ ] Levers toggle between Active/Inactive states
- [ ] Lever activation triggers associated effects
- [ ] Lever deactivation triggers associated effects
- [ ] Buttons activate when pressed
- [ ] Buttons auto-reset after configured delay
- [ ] Button reset triggers deactivation effects
- [ ] Effects correctly modify target object states
- [ ] Effect messages display to player
- [ ] Attack command works on destructible objects
- [ ] Break command is alias for attack on destructibles
- [ ] Pull command activates levers
- [ ] Push command activates buttons or deactivates levers
- [ ] Destroyed objects change to Destroyed state
- [ ] Destroyed barriers no longer block passage
- [ ] Destroyed containers drop contents to room
- [ ] Configuration supports effect and destructible definitions
- [ ] ~25 unit tests pass

### 7.2 Non-Functional Requirements

- [ ] Value objects are immutable where appropriate
- [ ] Services follow DI patterns
- [ ] Logging follows established patterns
- [ ] Configuration is JSON-driven

---

## 8. Test Specifications

### 8.1 ObjectEffect Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `OpenTarget_CreatesCorrectEffect` | Factory method |
| `UnlockTarget_CreatesCorrectEffect` | Factory method |
| `Delayed_AddsDelay` | Delay factory |
| `IsImmediate_WhenZeroDelay_ReturnsTrue` | Immediate check |
| `MessageOnly_HasNoTarget` | Message-only effect |

### 8.2 DestructibleProperties Tests (~8 tests)

| Test Name | Description |
|-----------|-------------|
| `Create_WithValidHP_ReturnsProperties` | Valid creation |
| `Create_WithZeroHP_ThrowsException` | Zero HP rejected |
| `TakeDamage_ReducesHP` | Basic damage |
| `TakeDamage_WhenImmune_ReturnsZero` | Immunity check |
| `TakeDamage_WhenVulnerable_DoublessDamage` | Vulnerability check |
| `TakeDamage_WhenResistant_HalvesDamage` | Resistance check |
| `TakeDamage_AppliesDefense` | Defense reduction |
| `IsDestroyed_WhenHPZero_ReturnsTrue` | Destruction check |

### 8.3 InteractiveObject Activation Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `Activate_WhenInactive_SetsActive` | Activation |
| `Activate_WhenAlreadyActive_ReturnsFalse` | Already active |
| `Deactivate_WhenActive_SetsInactive` | Deactivation |
| `Toggle_SwitchesState` | Toggle behavior |
| `ProcessTurnTick_ResetsButton` | Button reset |
| `GetTriggeredEffects_ReturnsMatchingEffects` | Effect retrieval |

### 8.4 InteractionService Activation Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `Activate_TriggersEffects` | Effect triggering |
| `Deactivate_TriggersEffects` | Deactivation effects |
| `ResolveEffect_OpenTarget_OpensObject` | Open effect |
| `ResolveEffect_UnlockTarget_UnlocksObject` | Unlock effect |
| `ResolveEffect_TargetNotFound_ReturnsFailed` | Missing target |
| `ProcessRoomTurnTick_ResetsButtons` | Room tick processing |

### 8.5 InteractionService Destruction Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `AttackObject_DealssDamage` | Damage dealing |
| `AttackObject_NotDestructible_ReturnsFailed` | Non-destructible |
| `AttackObject_Destroyed_DropsItems` | Item dropping |
| `AttackObject_WasBlocking_ClearsPassage` | Passage clearing |
| `AttackObject_Immune_ReturnsZeroDamage` | Immunity handling |

---

## 9. Dependencies

### 9.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| InteractiveObject entity | v0.4.0a | Complete | Base entity |
| InteractionService | v0.4.0a/b | Complete | Needs updates |
| InteractionType enum | v0.4.0a | Complete | Has Activate, Break |
| ObjectState enum | v0.0.x | Complete | Has Active, Inactive, Destroyed |
| InteractiveObjectType enum | v0.4.0a | Expanded | Has Lever, Button, Web, Barrier |
| ContainerInventory | v0.4.0b | Complete | For destroyed containers |
| LockDefinition | v0.4.0b | Complete | For lock effects |
| CombatService | v0.0.x | Complete | For damage integration |
| DiceService | v0.0.x | Complete | For damage rolls |
| Room entity | v0.4.0a | Modified | Has Interactables |

### 9.2 External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Microsoft.Extensions.Logging | 9.0.x | Logging |
| System.Text.Json | 9.0.x | Configuration parsing |

---

## 10. Files Summary

### 10.1 New Files

| File | Purpose |
|------|---------|
| `Domain/Enums/EffectType.cs` | Effect types enum |
| `Domain/ValueObjects/ObjectEffect.cs` | Effect value object |
| `Domain/ValueObjects/DestructibleProperties.cs` | Destructible properties |
| `Domain/ValueObjects/EffectTriggerResult.cs` | Effect result |
| `Domain/ValueObjects/ObjectDamageResult.cs` | Damage result |
| `Tests/ObjectEffectTests.cs` | Effect tests |
| `Tests/DestructiblePropertiesTests.cs` | Destructible tests |
| `Tests/InteractionServiceActivationTests.cs` | Activation tests |
| `Tests/InteractionServiceDestructionTests.cs` | Destruction tests |

### 10.2 Modified Files

| File | Changes |
|------|---------|
| `Domain/Entities/InteractiveObject.cs` | Add effects, destructible, button properties and methods |
| `Domain/Definitions/InteractiveObjectDefinition.cs` | Add effects, destructible, button config |
| `Application/Interfaces/IInteractionService.cs` | Add activation/destruction methods |
| `Application/Services/InteractionService.cs` | Implement activation/destruction methods |
| `Application/Services/GameSessionService.cs` | Add attack/break/pull/push commands |
| `Configuration/interactive-objects.json` | Add lever/button/destructible objects |
| `Configuration/schemas/interactive-objects.schema.json` | Add effect/destructible schema |

---

## 11. Future Considerations

### 11.1 v0.4.1 Preparation

The following will extend this foundation:
- Trapped containers (trigger on open)
- Pressure plates (auto-activate when stepped on)
- Timed sequences (effects in order)
- Effect chains (effects triggering further effects)

### 11.2 Integration Points

- **Damage Types**: Coordinate with weapon types from v0.0.7
- **Loot Tables**: Reference loot system for destruction drops
- **Quest Integration**: Effects can trigger quest objectives

---

*This design specification extends the interactive object system with activation mechanics (levers and buttons with linked effects) and destructible objects that can be broken through combat, integrating with the existing combat service for damage resolution.*
