> **Archived** - This changelog has been consolidated. See the complete version at [v0.3.18](../v0.3.x/v0.3.18.md).

# Changelog: v0.3.18a - The Garbage Collector (Memory Management Infrastructure)

**Version:** v0.3.18a
**Release Date:** 2025-12-25
**Total Tests:** 35 new tests
**Test Results:** All passing

---

## Table of Contents

- [Overview](#overview)
- [Key Metrics](#key-metrics)
- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
  - [ITextBufferPool Interface](#itextbufferpool-interface)
  - [IListPool Interface](#ilistpool-interface)
  - [Coordinate Value Object](#coordinate-value-object)
- [Architecture Decisions](#architecture-decisions)
- [Test Coverage](#test-coverage)
  - [TextBufferPoolTests (12 tests)](#textbufferpooltests-12-tests)
  - [ListPoolTests (17 tests)](#listpooltests-17-tests)
  - [CoordinateTests - Struct Verification (6 tests)](#coordinatetests---struct-verification-6-tests)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After Release](#directory-structure-after-release)
- [Running Tests](#running-tests)
- [Usage Examples](#usage-examples)
- [Next Steps](#next-steps)

---

## Overview

v0.3.18a "The Garbage Collector" establishes the memory management infrastructure for reducing GC pressure during high-frequency operations like rendering and coordinate manipulation. This release focuses on foundational work:

1. **Coordinate Struct Conversion** - Converted `Coordinate` from `record` (reference type) to `readonly record struct` (value type) for stack allocation
2. **Object Pooling Infrastructure** - Implemented `TextBufferPool` and `ListPool<T>` using Microsoft.Extensions.ObjectPool
3. **EF Core Compatibility** - Resolved struct mapping issues with backing field approach

This is a **minimal/focused** release that establishes patterns for future optimization work. Full renderer integration (MinimapRenderer, CombatGridRenderer, TimelineRenderer) is deferred to v0.3.18b.

---

## Key Metrics

| Metric | Value |
|--------|-------|
| New Files | 4 |
| Modified Files | 7 |
| New Tests | 35 |
| Test Pass Rate | 100% |
| NuGet Packages Added | 1 (Microsoft.Extensions.ObjectPool) |

---

## Summary

v0.3.18a introduces object pooling infrastructure and value type optimization to reduce GC pressure during gameplay. The `Coordinate` value object, used extensively throughout navigation and spatial queries, has been converted from a heap-allocated reference type to a stack-allocated value type. This eliminates per-operation heap allocations for coordinate creation during movement, collision detection, and minimap rendering.

The pooling infrastructure provides thread-safe object reuse for `StringBuilder` and `List<T>` instances commonly allocated during rendering operations. Using Microsoft.Extensions.ObjectPool ensures proper object lifecycle management with automatic clearing on return.

A critical implementation challenge arose when EF Core's `ComplexProperty` and `OwnsOne` mapping strategies failed to translate LINQ queries with the InMemory provider for struct types. The solution employs explicit backing fields (`PositionX`, `PositionY`, `PositionZ`) on the `Room` entity, with a computed `Position` property for convenient access. All repository LINQ queries were updated to use the backing fields directly, ensuring both PostgreSQL and InMemory providers work correctly.

Key architectural patterns introduced: Value type semantics for high-frequency value objects, thread-safe pooling with automatic reset, and backing field mapping for EF Core struct compatibility.

---

## New Files Created

### Engine Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Engine/Performance/TextBufferPool.cs` | StringBuilder pooling service using Microsoft.Extensions.ObjectPool. Provides `Rent()`, `Return()`, and `GetStringAndReturn()` methods for reducing heap allocations during string-heavy rendering operations. Thread-safe with automatic clearing on return. | 65 |
| `RuneAndRust.Engine/Performance/ListPool.cs` | Generic List<T> pooling service with `ListPooledObjectPolicy<T>` for automatic clearing. Enables reuse of list instances during collection-heavy operations like building renderable element lists. | 69 |

### Test Layer

| File | Purpose | Tests |
|------|---------|-------|
| `RuneAndRust.Tests/Engine/Performance/TextBufferPoolTests.cs` | Unit tests validating StringBuilder pooling behavior including rent/return semantics, content clearing, concurrent access safety, and high-volume operations. | 12 |
| `RuneAndRust.Tests/Engine/Performance/ListPoolTests.cs` | Unit tests validating List<T> pooling with various generic types (string, int, Guid, complex objects), content clearing on return, and thread safety. | 17 |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/ValueObjects/Coordinate.cs` | Changed from `public record Coordinate(int X, int Y, int Z)` to `public readonly record struct Coordinate(int X, int Y, int Z)`. Added `Origin` static property and `Offset()` method. XML comments updated with v0.3.18a notation. |
| `RuneAndRust.Core/Entities/Room.cs` | Added `PositionX`, `PositionY`, `PositionZ` backing field properties (lines 46-56). Modified `Position` property to use backing fields as getter/setter (lines 32-41). Added XML comments documenting EF Core compatibility pattern. |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Updated Room entity mapping (lines 164-171) to use `entity.Property(r => r.PositionX/Y/Z).IsRequired()` and `entity.Ignore(r => r.Position)`. Removed `ComplexProperty`/`OwnsOne` mapping attempts. Added comment explaining struct support approach. |
| `RuneAndRust.Persistence/Repositories/RoomRepository.cs` | Updated all LINQ queries to use backing fields instead of `Position` property. Methods affected: `GetByPositionAsync()` (lines 40-43), `PositionExistsAsync()` (lines 82-85), `GetAllRoomsAsync()` (lines 98-101), `GetRoomsInGridAsync()` (lines 140-143). Added v0.3.18a comments. |
| `RuneAndRust.Terminal/Program.cs` | Added DI registration for `ITextBufferPool` as Singleton (lines 220-221). Comment notes v0.3.18a introduction. |
| `RuneAndRust.Engine/RuneAndRust.Engine.csproj` | Added `<PackageReference Include="Microsoft.Extensions.ObjectPool" Version="9.0.0" />` (line 9). |
| `RuneAndRust.Tests/Core/CoordinateTests.cs` | Added 6 new tests in "Value Type Tests (v0.3.18a)" region (lines 288-376) validating struct behavior: `IsValueType`, `IsReadOnlyRecordStruct`, `DefaultValue_IsOrigin`, `CanBeUsedInArrayWithoutBoxing`, `WithExpression_StillWorksAsStruct`, `PassByValue_DoesNotModifyOriginal`. |

---

## Code Implementation Details

### ITextBufferPool Interface

**Properties:** None

**Methods:**
```csharp
StringBuilder Rent()
void Return(StringBuilder sb)
string GetStringAndReturn(StringBuilder sb)
```

**Behaviors:**
- `Rent()` returns an empty StringBuilder instance from the pool
- `Return()` returns a StringBuilder to the pool; it will be cleared before next rental
- `GetStringAndReturn()` extracts the string content, returns the builder to the pool, and returns the string
- Thread-safe via Microsoft.Extensions.ObjectPool's internal synchronization
- Default pool sizing: initial capacity 100, max retained 4096 (per DefaultObjectPoolProvider)

---

### IListPool Interface

**Generic Type Parameter:** `T` - The type of elements in the list

**Methods:**
```csharp
List<T> Rent()
void Return(List<T> list)
```

**Behaviors:**
- `Rent()` returns an empty `List<T>` instance from the pool
- `Return()` clears the list and returns it to the pool for reuse
- Clearing ensures no stale data leaks between rentals
- Thread-safe via Microsoft.Extensions.ObjectPool's internal synchronization
- Default pool sizing: max 16 retained instances per processor (per DefaultObjectPoolProvider)

**ListPooledObjectPolicy<T>:**
```csharp
internal class ListPooledObjectPolicy<T> : PooledObjectPolicy<List<T>>
{
    public override List<T> Create() => new();
    public override bool Return(List<T> obj)
    {
        obj.Clear();
        return true;
    }
}
```

---

### Coordinate Value Object

**Declaration:**
```csharp
public readonly record struct Coordinate(int X, int Y, int Z)
```

**Properties:**
- `int X` - East-West position (East is positive)
- `int Y` - North-South position (North is positive)
- `int Z` - Vertical position (Up is positive)

**Static Members:**
- `Coordinate Origin` - Returns `new Coordinate(0, 0, 0)`

**Methods:**
- `Coordinate Offset(int deltaX, int deltaY, int deltaZ)` - Returns a new coordinate offset by the specified amounts
- `string ToString()` - Returns `"(X, Y, Z)"` format

**Behaviors:**
- Stack-allocated (no heap allocation overhead for temporary coordinates)
- Value equality semantics preserved from record type
- `with` expressions supported (record struct feature)
- Default value is `(0, 0, 0)` - equivalent to `Origin`
- Immutable (readonly struct)

---

## Architecture Decisions

### 1. readonly record struct for Coordinate

**Decision:** Converted `Coordinate` from `record` (reference type) to `readonly record struct` (value type).

**Rationale:**
- Coordinates are created frequently during navigation, rendering, and spatial queries
- Reference types require heap allocation and eventual GC collection
- Value types are stack-allocated, avoiding GC pressure entirely
- The `readonly` modifier ensures immutability is enforced by the compiler
- Record struct preserves `with` expression syntax and value equality semantics
- No breaking changes to consumers - all existing code continues to work

---

### 2. Backing Fields for EF Core Struct Mapping

**Decision:** Added explicit `PositionX`, `PositionY`, `PositionZ` properties to `Room` entity instead of using EF Core's `ComplexProperty` or `OwnsOne` mapping.

**Rationale:**
- **Initial Attempt (ComplexProperty):** EF Core 9's `ComplexProperty` for struct value objects failed with InMemory provider - LINQ translation of `Position.X` threw "Translation of member 'Position' failed"
- **Second Attempt (OwnsOne):** EF Core's `OwnsOne` for owned types generated CS1061 errors when applied to struct types
- **Solution:** Direct property mapping with backing fields. The `Position` computed property provides convenient access while individual backing fields enable LINQ translation
- This pattern works with both PostgreSQL and InMemory providers
- Repository queries updated to use `r.PositionX`, `r.PositionY`, `r.PositionZ` in LINQ

**Code Pattern:**
```csharp
// Room.cs
public Coordinate Position
{
    get => new(PositionX, PositionY, PositionZ);
    set
    {
        PositionX = value.X;
        PositionY = value.Y;
        PositionZ = value.Z;
    }
}

public int PositionX { get; set; }
public int PositionY { get; set; }
public int PositionZ { get; set; }

// DbContext mapping
entity.Property(r => r.PositionX).IsRequired();
entity.Property(r => r.PositionY).IsRequired();
entity.Property(r => r.PositionZ).IsRequired();
entity.Ignore(r => r.Position);
```

---

### 3. Singleton Lifetime for Pool Services

**Decision:** Registered `ITextBufferPool` and `IListPool<T>` as Singleton services.

**Rationale:**
- Object pools are designed for application-lifetime reuse
- Creating new pools per-scope would defeat the purpose of pooling
- Microsoft.Extensions.ObjectPool is thread-safe by design
- Singleton ensures pooled instances persist across game phases
- No state dependencies that would require Scoped lifetime

---

### 4. Microsoft.Extensions.ObjectPool Library

**Decision:** Used official Microsoft.Extensions.ObjectPool instead of custom pooling implementation.

**Rationale:**
- Battle-tested, production-ready implementation
- Thread-safe by design
- Integrates with .NET ecosystem (used by ASP.NET Core, Kestrel)
- Built-in `CreateStringBuilderPool()` convenience method
- `PooledObjectPolicy<T>` pattern enables custom reset behavior
- Maintained as part of .NET runtime
- Version 9.0.0 aligns with .NET 9 target framework

---

### 5. Minimal Integration Scope (v0.3.18a)

**Decision:** v0.3.18a focuses on infrastructure only; renderer integration is deferred to v0.3.18b.

**Rationale:**
- Separates infrastructure (pool services, struct conversion) from integration (renderer refactoring)
- Enables testing pool infrastructure in isolation
- Reduces release scope and risk
- Allows verification that struct conversion doesn't break existing tests before adding more changes
- Deferred work: MinimapRenderer, CombatGridRenderer, TimelineRenderer pooled buffer usage

---

## Test Coverage

**Summary:**
```
Total: 35 | Passed: 35 | Failed: 0
```

### TextBufferPoolTests (12 tests)

| Test Name | Description |
|-----------|-------------|
| Rent_ReturnsNonNullStringBuilder | Verifies that `Rent()` returns a non-null StringBuilder instance |
| Rent_ReturnsEmptyStringBuilder | Confirms rented StringBuilder has Length = 0 |
| Rent_MultipleCalls_ReturnsDifferentInstances | Asserts that concurrent `Rent()` calls return distinct instances |
| Return_ClearsContent_ForReuse | Adds content to rented builder, returns it, rents again - verifies content is cleared |
| Return_AllowsReuseOfSameInstance | Confirms pool accepts returned builders and allows subsequent rental |
| GetStringAndReturn_ReturnsCorrectString | Appends "Hello, World!" and verifies extracted string matches |
| GetStringAndReturn_ReturnsBuilderToPool | Confirms builder is returned to pool after string extraction |
| GetStringAndReturn_WithEmptyBuilder_ReturnsEmptyString | Tests edge case of extracting from empty builder |
| GetStringAndReturn_WithComplexContent_PreservesFormatting | Tests multi-line content with `AppendLine()` preserves formatting |
| Pool_HandlesHighVolumeRentReturn | Rents 100 builders, fills with content, returns all - verifies pool handles volume |
| Pool_HandlesConcurrentAccess | Spawns 10 threads with 50 operations each - verifies thread safety |

### ListPoolTests (17 tests)

| Test Name | Description |
|-----------|-------------|
| Rent_ReturnsNonNullList | Verifies `Rent()` returns non-null List<T> instance |
| Rent_ReturnsEmptyList | Confirms rented list has Count = 0 |
| Rent_MultipleCalls_ReturnsDifferentInstances | Asserts concurrent `Rent()` calls return distinct instances |
| Return_ClearsList_ForReuse | Adds items to list, returns, rents again - verifies content cleared |
| Return_DoesNotRetainOldItems | Adds 5 items, returns list, rents new - confirms no item leakage |
| Pool_WorksWithComplexTypes | Tests pooling with custom `TestComplexType` class containing Id and Name |
| Pool_WorksWithValueTypes | Tests pooling `List<Guid>` with value type elements |
| Pool_WorksWithNullableReferenceTypes | Tests pooling `List<string?>` with null values |
| Pool_HandlesHighVolumeRentReturn | Rents 100 lists with varying sizes, returns all - verifies high volume handling |
| Pool_HandlesConcurrentAccess | Spawns 10 threads with 50 operations each - verifies thread safety |
| Pool_MaintainsCapacityAcrossRentals | Adds 1000 items to expand capacity, returns, rents again - verifies capacity may be retained |
| Rent_AfterManyReturns_StillReturnsEmptyList | Performs 10 rent/return cycles, final rent should be empty |
| Pool_HandlesEmptyListReturn | Returns a list that was never modified - verifies empty return is accepted |

### CoordinateTests - Struct Verification (6 tests)

| Test Name | Description |
|-----------|-------------|
| Coordinate_IsValueType | Asserts `typeof(Coordinate).IsValueType` is true (struct verification) |
| Coordinate_IsReadOnlyRecordStruct | Verifies value type status and record semantics (ToString contains X, Y, Z) |
| Coordinate_DefaultValue_IsOrigin | Confirms `default(Coordinate)` equals `Coordinate.Origin` (0, 0, 0) |
| Coordinate_CanBeUsedInArrayWithoutBoxing | Creates 1000-element Coordinate array, fills and verifies - no boxing occurs |
| Coordinate_WithExpression_StillWorksAsStruct | Tests `original with { X = 100 }` syntax works correctly |
| Coordinate_PassByValue_DoesNotModifyOriginal | Passes coordinate to method that reassigns - original unchanged (value semantics) |

---

## DI Registration

**Location:** `RuneAndRust.Terminal/Program.cs` (lines 220-221)

```csharp
// Register Performance Pools (v0.3.18a - The Garbage Collector)
services.AddSingleton<ITextBufferPool, TextBufferPool>();
```

**Lifetime:** Singleton

**Rationale:**
- Object pools must persist for application lifetime to provide value
- Thread-safe implementation supports concurrent access from multiple services
- No per-request state requiring Scoped lifetime

**Note:** `IListPool<T>` is not registered in DI for v0.3.18a as no consumers are integrated yet. Full DI registration will be added in v0.3.18b when renderer integration occurs.

---

## Verification Results

### Build Output

```
Build succeeded.

    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:02.14
```

### Test Output

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
VSTest version 17.14.1 (arm64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:   101, Skipped:     0, Total:   101
```

**Note:** 101 tests includes all v0.3.18a-related tests (Coordinate, pools, Room persistence) plus existing test suite.

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   └── Room.cs                              [MODIFIED]
└── ValueObjects/
    └── Coordinate.cs                        [MODIFIED]

RuneAndRust.Engine/
├── Performance/
│   ├── TextBufferPool.cs                    [NEW]
│   └── ListPool.cs                          [NEW]
└── RuneAndRust.Engine.csproj                [MODIFIED]

RuneAndRust.Persistence/
├── Data/
│   └── RuneAndRustDbContext.cs              [MODIFIED]
└── Repositories/
    └── RoomRepository.cs                    [MODIFIED]

RuneAndRust.Terminal/
└── Program.cs                               [MODIFIED]

RuneAndRust.Tests/
├── Core/
│   └── CoordinateTests.cs                   [MODIFIED]
└── Engine/
    └── Performance/
        ├── TextBufferPoolTests.cs           [NEW]
        └── ListPoolTests.cs                 [NEW]
```

---

## Running Tests

### Run All v0.3.18a Tests

```bash
dotnet test --filter "FullyQualifiedName~TextBufferPoolTests|FullyQualifiedName~ListPoolTests|FullyQualifiedName~CoordinateTests"
```

### Run Pool Tests Only

```bash
dotnet test --filter "FullyQualifiedName~Performance"
```

### Run Coordinate Struct Tests Only

```bash
dotnet test --filter "FullyQualifiedName~Coordinate_IsValueType|FullyQualifiedName~Coordinate_DefaultValue|FullyQualifiedName~Coordinate_PassByValue"
```

### Run Specific Test

```bash
dotnet test --filter "FullyQualifiedName~Pool_HandlesConcurrentAccess"
```

---

## Usage Examples

### TextBufferPool Usage

```csharp
public class SomeRenderer
{
    private readonly ITextBufferPool _pool;

    public SomeRenderer(ITextBufferPool pool)
    {
        _pool = pool;
    }

    public string RenderContent()
    {
        // Rent a StringBuilder from the pool
        var sb = _pool.Rent();

        sb.AppendLine("Header");
        sb.AppendLine("Content line 1");
        sb.AppendLine("Content line 2");

        // Extract string and return builder to pool in one operation
        return _pool.GetStringAndReturn(sb);
    }
}
```

### ListPool Usage

```csharp
public class SomeCollector
{
    private readonly IListPool<string> _pool;

    public SomeCollector(IListPool<string> pool)
    {
        _pool = pool;
    }

    public void ProcessItems()
    {
        // Rent a list from the pool
        var items = _pool.Rent();

        try
        {
            items.Add("Item 1");
            items.Add("Item 2");

            foreach (var item in items)
            {
                Console.WriteLine(item);
            }
        }
        finally
        {
            // Always return to pool (list will be cleared automatically)
            _pool.Return(items);
        }
    }
}
```

### Coordinate Struct Benefits

```csharp
// Before (record class) - each call allocates on heap
Coordinate pos1 = new(1, 2, 3);  // Heap allocation
Coordinate pos2 = pos1.Offset(1, 0, 0);  // Heap allocation

// After (readonly record struct) - stack allocated
Coordinate pos1 = new(1, 2, 3);  // Stack allocated
Coordinate pos2 = pos1.Offset(1, 0, 0);  // Stack allocated
// No GC pressure!

// 'with' expressions still work
var moved = pos1 with { X = pos1.X + 1 };

// Default is Origin
Coordinate defaultPos = default;  // (0, 0, 0)
```

---

## Next Steps

### v0.3.18b - The Garbage Collector (Renderer Integration)

- **MinimapRenderer:** Integrate IListPool<IRenderable> for element collection
- **CombatGridRenderer:** Use ITextBufferPool for grid string building
- **TimelineRenderer:** Pool allocation optimization for turn display
- **Performance Metrics:** Add optional allocation tracking for debugging
- **Benchmark Suite:** Create allocation benchmark tests to measure improvement

### v0.3.19 - Future Optimization Candidates

- **Event Pooling:** Pool combat/exploration event objects
- **String Interning:** Intern frequently-used strings (direction names, common messages)
- **Span<T> Usage:** Replace string operations with Span<char> where appropriate
- **Memory<T> Buffers:** Consider ArrayPool<T> for larger buffers

---

**End of Changelog v0.3.18a**
