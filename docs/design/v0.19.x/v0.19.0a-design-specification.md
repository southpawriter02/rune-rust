# v0.19.0a Design Specification: Core Biome Infrastructure

**Version:** 0.19.0a
**Parent:** v0.19.0 (Core Biome Infrastructure)
**Prerequisites:** v0.18.x Complete (Advanced Character Creation), v0.6.x (Dice System)
**Status:** Design Complete
**Estimated Unit Tests:** ~20

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [RealmId Enum](#5-realmid-enum)
6. [BiomeCompatibility Enum](#6-biomecompatibility-enum)
7. [EnvironmentalConditionType Enum](#7-environmentalconditiontype-enum)
8. [VerticalZone Enum](#8-verticalzone-enum)
9. [BiomeProperties Value Object](#9-biomeproperties-value-object)
10. [AdjacencyRule Value Object](#10-adjacencyrule-value-object)
11. [BiomeDefinition Entity](#11-biomedefinition-entity)
12. [BiomeZone Entity](#12-biomezone-entity)
13. [EnvironmentalCondition Entity](#13-environmentalcondition-entity)
14. [IBiomeProvider Interface](#14-ibipomeprovider-interface)
15. [IBiomeAdjacencyService Interface](#15-ibiomeadjacencyservice-interface)
16. [IEnvironmentalConditionService Interface](#16-ienvironmentalconditionservice-interface)
17. [BiomeProvider Implementation](#17-biomeprovider-implementation)
18. [BiomeAdjacencyService Implementation](#18-biomeadjacencyservice-implementation)
19. [EnvironmentalDamageResult Record](#19-environmentaldamageresult-record)
20. [Configuration Files](#20-configuration-files)
21. [Logging Specifications](#21-logging-specifications)
22. [Unit Testing Requirements](#22-unit-testing-requirements)
23. [Deliverable Checklist](#23-deliverable-checklist)
24. [Acceptance Criteria](#24-acceptance-criteria)
25. [Dependencies](#25-dependencies)
26. [Future Considerations](#26-future-considerations)

---

## 1. Executive Summary

This design specification defines the **Core Biome Infrastructure** for the Nine Realms system — the foundational framework that defines Aethelgard's geography, environmental hazards, and thematic zones.

v0.19.0a establishes the complete building blocks for all subsequent realm implementations (v0.19.1–v0.19.6):

- **4 Domain Enums** — RealmId, BiomeCompatibility, EnvironmentalConditionType, VerticalZone
- **2 Value Objects** — BiomeProperties, AdjacencyRule
- **3 Domain Entities** — BiomeDefinition, BiomeZone, EnvironmentalCondition
- **3 Application Interfaces** — IBiomeProvider, IBiomeAdjacencyService, IEnvironmentalConditionService
- **2 Service Implementations** — BiomeProvider, BiomeAdjacencyService
- **3 Configuration Files** — biomes.json, biomes.schema.json, adjacency_matrix.json

### Key Deliverables

| Category | Count | Details |
|----------|-------|---------|
| **Domain Enums** | 4 | RealmId, BiomeCompatibility, EnvironmentalConditionType, VerticalZone |
| **Value Objects** | 2 | BiomeProperties, AdjacencyRule |
| **Domain Entities** | 3 | BiomeDefinition, BiomeZone, EnvironmentalCondition |
| **Application Interfaces** | 3 | IBiomeProvider, IBiomeAdjacencyService, IEnvironmentalConditionService |
| **Application Services** | 2 | BiomeProvider, BiomeAdjacencyService |
| **DTOs** | 1 | EnvironmentalDamageResult |
| **Configuration** | 3 | biomes.json, biomes.schema.json, adjacency_matrix.json |
| **Unit Tests** | ~20 | |

### Nine Realms Overview

| Realm | Deck | Pre-Glitch Function | Post-Glitch State | Primary Hazard |
|-------|------|---------------------|-------------------|----------------|
| **Asgard** | 01 | Primary Administration | The Shattered Spire | CPS Exposure |
| **Alfheim** | 02 | Aetheric Research | The Glimmering Wound | Reality Flux |
| **Vanaheim** | 03 | Bio-Engineering | The Overgrown Laboratory | Mutagenic Spores |
| **Midgard** | 04 | Civilian Habitation | The Tamed Ruin | None (temperate) |
| **Niflheim** | 05 | Cryogenic Preservation | The Frozen Tomb | Extreme Cold |
| **Svartalfheim** | 06 | Manufacturing | The Dvergr Forges | Total Darkness |
| **Jötunheim** | 07 | Heavy Industry | The Industrial Graveyard | Giant Scale |
| **Muspelheim** | 08 | Power Generation | The Eternal Meltdown | Intense Heat |
| **Helheim** | 09 | Waste Reclamation | The Gangrenous Gut | Toxic Atmosphere |

---

## 2. Feature Overview

```
v0.19.0a Features
└── Core Biome Infrastructure
    │
    ├── Domain Layer (Enums)
    │   ├── RealmId (9 canonical realms)
    │   │   ├── Asgard = 1 (Deck 01)
    │   │   ├── Alfheim = 2 (Deck 02)
    │   │   ├── Vanaheim = 3 (Deck 03)
    │   │   ├── Midgard = 4 (Deck 04)
    │   │   ├── Niflheim = 5 (Deck 05)
    │   │   ├── Svartalfheim = 6 (Deck 06)
    │   │   ├── Jötunheim = 7 (Deck 07)
    │   │   ├── Muspelheim = 8 (Deck 08)
    │   │   └── Helheim = 9 (Deck 09)
    │   │
    │   ├── BiomeCompatibility
    │   │   ├── Compatible — Direct neighbor allowed
    │   │   ├── RequiresTransition — 1-3 transition rooms needed
    │   │   └── Incompatible — Cannot neighbor (needs buffer)
    │   │
    │   ├── EnvironmentalConditionType (9 hazard types)
    │   │   ├── None, IntenseHeat, ExtremeCold
    │   │   ├── ToxicAtmosphere, MutagenicSpores, RealityFlux
    │   │   └── CpsExposure, TotalDarkness, GiantScale
    │   │
    │   └── VerticalZone (8 Z-levels)
    │       ├── DeepRoots (-3) through Orbital (+4)
    │       └── Maps realm verticality constraints
    │
    ├── Domain Layer (Value Objects)
    │   ├── BiomeProperties
    │   │   ├── TemperatureCelsius, AethericIntensity
    │   │   ├── HumidityPercent, LightLevel
    │   │   └── ScaleFactor, CorrosionRate
    │   │
    │   └── AdjacencyRule
    │       ├── RealmA, RealmB
    │       ├── Compatibility
    │       └── TransitionRooms, TransitionTheme
    │
    ├── Domain Layer (Entities)
    │   ├── BiomeDefinition
    │   │   ├── Id, Name, Subtitle, DeckNumber
    │   │   ├── PreGlitchFunction, PostGlitchState
    │   │   ├── BaseProperties, PrimaryCondition
    │   │   └── Zones, FlavorQuote, ColorPalette
    │   │
    │   ├── BiomeZone
    │   │   ├── Id, Name, ParentRealm
    │   │   ├── OverrideProperties, OverrideCondition
    │   │   └── ConditionDcModifier, DamageOverride
    │   │
    │   └── EnvironmentalCondition
    │       ├── Type, DisplayName, CheckAttribute
    │       ├── BaseDc, DamageDice, DamageType
    │       └── Frequency, Description, Mitigations
    │
    ├── Application Layer (Interfaces)
    │   ├── IBiomeProvider — Biome definition access
    │   ├── IBiomeAdjacencyService — Adjacency validation
    │   └── IEnvironmentalConditionService — Hazard application
    │
    ├── Application Layer (Services)
    │   ├── BiomeProvider — JSON config loading
    │   └── BiomeAdjacencyService — Adjacency matrix validation
    │
    └── Configuration
        ├── biomes.json — Realm definitions
        ├── biomes.schema.json — JSON Schema validation
        └── adjacency_matrix.json — Realm adjacency rules
```

---

## 3. Architecture Diagrams

### 3.1 Domain Layer Structure

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              DOMAIN LAYER                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                           ENUMERATIONS                              │     │
│  ├────────────────┬────────────────┬────────────────┬─────────────────┤     │
│  │    RealmId     │  Biome         │  Environmental │  VerticalZone   │     │
│  │    (9 values)  │  Compatibility │  ConditionType │   (8 values)    │     │
│  ├────────────────┼────────────────┼────────────────┼─────────────────┤     │
│  │ Asgard     = 1 │ Compatible     │ None           │ DeepRoots   =-3 │     │
│  │ Alfheim    = 2 │ RequiresTrans. │ IntenseHeat    │ LowerRoots  =-2 │     │
│  │ Vanaheim   = 3 │ Incompatible   │ ExtremeCold    │ UpperRoots  =-1 │     │
│  │ Midgard    = 4 │                │ ToxicAtmosphere│ GroundLevel = 0 │     │
│  │ Niflheim   = 5 │                │ MutagenicSpores│ LowerTrunk  =+1 │     │
│  │ Svartalfheim=6 │                │ RealityFlux    │ UpperTrunk  =+2 │     │
│  │ Jötunheim  = 7 │                │ CpsExposure    │ Canopy      =+3 │     │
│  │ Muspelheim = 8 │                │ TotalDarkness  │ Orbital     =+4 │     │
│  │ Helheim    = 9 │                │ GiantScale     │                 │     │
│  └────────────────┴────────────────┴────────────────┴─────────────────┘     │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                         VALUE OBJECTS                               │     │
│  ├────────────────────────────────┬───────────────────────────────────┤     │
│  │       BiomeProperties          │         AdjacencyRule             │     │
│  ├────────────────────────────────┼───────────────────────────────────┤     │
│  │ + TemperatureCelsius: int      │ + RealmA: RealmId                 │     │
│  │ + AethericIntensity: float     │ + RealmB: RealmId                 │     │
│  │ + HumidityPercent: int         │ + Compatibility: BiomeCompat.     │     │
│  │ + LightLevel: float            │ + MinTransitionRooms: int         │     │
│  │ + ScaleFactor: float           │ + MaxTransitionRooms: int         │     │
│  │ + CorrosionRate: float         │ + TransitionTheme: string?        │     │
│  └────────────────────────────────┴───────────────────────────────────┘     │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                            ENTITIES                                 │     │
│  ├──────────────────────┬───────────────────┬─────────────────────────┤     │
│  │   BiomeDefinition    │    BiomeZone      │ EnvironmentalCondition  │     │
│  ├──────────────────────┼───────────────────┼─────────────────────────┤     │
│  │ + Id: RealmId        │ + Id: string      │ + Type: ConditionType   │     │
│  │ + Name: string       │ + Name: string    │ + DisplayName: string   │     │
│  │ + Subtitle: string   │ + ParentRealm     │ + CheckAttribute: string│     │
│  │ + DeckNumber: int    │ + OverrideProps   │ + BaseDc: int           │     │
│  │ + PreGlitchFunction  │ + OverrideCond.   │ + DamageDice: string    │     │
│  │ + PostGlitchState    │ + DcModifier      │ + DamageType: string    │     │
│  │ + BaseProperties     │ + DamageOverride  │ + Frequency: string     │     │
│  │ + PrimaryCondition   │ + MinVerticalZone │ + Description: string   │     │
│  │ + Zones: List        │ + MaxVerticalZone │ + Mitigations: List     │     │
│  │ + FlavorQuote        │                   │                         │     │
│  │ + ColorPalette       │                   │                         │     │
│  └──────────────────────┴───────────────────┴─────────────────────────┘     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Application Layer Structure

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                          INTERFACES                                 │     │
│  ├──────────────────────┬───────────────────┬─────────────────────────┤     │
│  │    IBiomeProvider    │ IBiomeAdjacency   │ IEnvironmental          │     │
│  │                      │ Service           │ ConditionService        │     │
│  ├──────────────────────┼───────────────────┼─────────────────────────┤     │
│  │ GetAllBiomes()       │ CanBiomesNeighbor │ GetActiveCondition()    │     │
│  │ GetBiome(id)         │ GetCompatibility  │ CalculateEffectiveDc()  │     │
│  │ GetZonesForRealm(id) │ GetTransitionRoom │ ApplyEnvironmentalDmg() │     │
│  │ GetZone(id, zoneId)  │ GetTransitionTheme│ HasMitigation()         │     │
│  │ GetEnvCondition(type)│ GetAdjacentRealms │                         │     │
│  │                      │ ValidateRealmConf │                         │     │
│  └──────────────────────┴───────────────────┴─────────────────────────┘     │
│                              │                      │                        │
│                              ▼                      ▼                        │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                       IMPLEMENTATIONS                               │     │
│  ├──────────────────────────────────┬─────────────────────────────────┤     │
│  │         BiomeProvider            │      BiomeAdjacencyService      │     │
│  ├──────────────────────────────────┼─────────────────────────────────┤     │
│  │ - _biomes: Dictionary            │ - _adjacencyRules: List         │     │
│  │ - _conditions: Dictionary        │ - _adjacencyMatrix: Dictionary  │     │
│  │ - _configPath: string            │ - _incompatiblePairs: HashSet   │     │
│  │                                  │                                 │     │
│  │ + LoadConfiguration()            │ + LoadAdjacencyMatrix()         │     │
│  │ + GetAllBiomes() → List          │ + BuildAdjacencyLookup()        │     │
│  │ + GetBiome(id) → BiomeDefinition │ + GetKey(a, b) → string         │     │
│  └──────────────────────────────────┴─────────────────────────────────┘     │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                            DTOs                                     │     │
│  ├────────────────────────────────────────────────────────────────────┤     │
│  │                   EnvironmentalDamageResult                         │     │
│  ├────────────────────────────────────────────────────────────────────┤     │
│  │ + CharacterId: Guid            + CheckPassed: bool                 │     │
│  │ + ConditionType: ConditionType + CheckRoll: int                    │     │
│  │ + CheckDc: int                 + DamageDealt: int                  │     │
│  │ + DamageType: string           + MitigationApplied: bool           │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Biome Adjacency Matrix

```
┌────────────────────────────────────────────────────────────────────────────┐
│                      BIOME ADJACENCY MATRIX (9 Realms)                      │
└────────────────────────────────────────────────────────────────────────────┘

              Mid   Van   Alf   Asg   Nif   Mus   Jöt   Sva   Hel
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
  Midgard  │  —  │  ✓  │  T  │  T* │  T  │  T  │  T  │  T  │  —  │
           ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  Vanaheim │  ✓  │  —  │  T  │  —  │  T  │  ✗  │  T  │  T  │  T  │
           ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  Alfheim  │  T  │  T  │  —  │  T  │  T  │  T  │  T  │  T  │  —  │
           ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  Asgard   │  T* │  —  │  T  │  —  │  —  │  —  │  —  │  —  │  —  │
           ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  Niflheim │  T  │  T  │  T  │  —  │  —  │  ✗  │  T  │  T  │  T  │
           ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  Muspelheim│  T  │  ✗  │  T  │  —  │  ✗  │  —  │  T  │  ✓  │  ✓  │
           ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  Jötunheim │  T  │  T  │  T  │  —  │  T  │  T  │  —  │  T  │  T  │
           ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  Svartalfheim│ T │  T  │  T  │  —  │  T  │  ✓  │  T  │  —  │  ✓  │
           ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  Helheim  │  —  │  T  │  —  │  —  │  T  │  ✓  │  T  │  ✓  │  —  │
           └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

LEGEND:
  ✓  = Compatible (can directly neighbor)
  T  = RequiresTransition (1-3 transition rooms)
  T* = Special transition (via Asgardian Scar)
  ✗  = Incompatible (cannot neighbor, needs buffer)
  —  = No logical connection / same realm

CRITICAL INCOMPATIBILITIES:
  • Muspelheim ↔ Niflheim  (Fire/Ice contradiction)
  • Muspelheim ↔ Vanaheim  (Fire/Bio contradiction)
```

### 3.4 Environmental Condition Application Flow

```
┌────────────────────────────────────────────────────────────────────────────┐
│                   ENVIRONMENTAL CONDITION APPLICATION FLOW                  │
└────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────┐
    │  Character enters zone  │
    │  (new room / turn start)│
    └───────────┬─────────────┘
                │
                ▼
    ┌─────────────────────────┐
    │  Get Zone's Active      │
    │  Environmental Condition│
    └───────────┬─────────────┘
                │
        ┌───────┴───────┐
        │               │
        ▼               ▼
┌───────────────┐ ┌───────────────┐
│ Condition =   │ │ Condition !=  │
│ None          │ │ None          │
│               │ │               │
│ No hazard     │ │ Continue      │
│ applied       │ │ processing    │
└───────────────┘ └───────┬───────┘
                          │
                          ▼
    ┌─────────────────────────────────┐
    │  Check for Character Mitigations │
    │  (Equipment, Abilities, etc.)    │
    └───────────────┬─────────────────┘
                    │
            ┌───────┴───────┐
            │               │
            ▼               ▼
    ┌───────────────┐ ┌───────────────┐
    │ Has full      │ │ No/Partial    │
    │ mitigation    │ │ mitigation    │
    │               │ │               │
    │ Condition     │ │ Roll          │
    │ bypassed      │ │ resistance    │
    │               │ │ check         │
    └───────────────┘ └───────┬───────┘
                              │
                              ▼
    ┌─────────────────────────────────┐
    │  Calculate Effective DC          │
    │  = BaseDC + Zone.DcModifier      │
    └───────────────┬─────────────────┘
                    │
                    ▼
    ┌─────────────────────────────────┐
    │  Roll [CheckAttribute] vs DC     │
    │  (e.g., STURDINESS vs DC 12)     │
    └───────────────┬─────────────────┘
                    │
            ┌───────┴───────┐
            │               │
            ▼               ▼
    ┌───────────────┐ ┌───────────────┐
    │ Check PASSED  │ │ Check FAILED  │
    │               │ │               │
    │ No damage     │ │ Apply damage  │
    │ taken         │ │ (DamageDice)  │
    └───────────────┘ └───────┬───────┘
                              │
                              ▼
    ┌─────────────────────────────────┐
    │  Return EnvironmentalDamageResult│
    │  with all outcome details        │
    └─────────────────────────────────┘
```

### 3.5 Zone DC Modifier Decision Tree

```
┌────────────────────────────────────────────────────────────────────────────┐
│                      ZONE DC MODIFIER DECISION TREE                         │
│                           (Example: Muspelheim)                             │
└────────────────────────────────────────────────────────────────────────────┘

                    ┌────────────────────────┐
                    │  Character in Zone     │
                    │  with IntenseHeat      │
                    └───────────┬────────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
        ▼                       ▼                       ▼
┌───────────────┐       ┌───────────────┐       ┌───────────────┐
│ Hearth        │       │ Standard Zone │       │ Hazard Zone   │
│ Interior      │       │ (Slag Wastes) │       │ (Forge Core)  │
│               │       │               │       │               │
│ DC Mod: -6    │       │ DC Mod: +2    │       │ DC Mod: +8    │
│ Damage: 1d6   │       │ Damage: 2d8   │       │ Damage: 4d6   │
└───────┬───────┘       └───────┬───────┘       └───────┬───────┘
        │                       │                       │
        ▼                       ▼                       ▼
┌───────────────┐       ┌───────────────┐       ┌───────────────┐
│ Effective DC  │       │ Effective DC  │       │ Effective DC  │
│ = 12 - 6 = 6  │       │ = 12 + 2 = 14 │       │ = 12 + 8 = 20 │
│               │       │               │       │               │
│ Survivable    │       │ Challenging   │       │ Deadly        │
└───────────────┘       └───────────────┘       └───────────────┘
```

---

## 4. User Stories

### US-19.0a-1: Load Biome Definitions from Configuration

**As a** game system developer
**I want to** load all realm definitions from a JSON configuration file
**So that** biome data can be modified without code changes

**Acceptance Criteria:**

- All 9 realms load from biomes.json
- Missing required fields cause validation errors
- Invalid realm IDs are rejected
- Biome zones are correctly nested under parent realms

### US-19.0a-2: Retrieve Biome by Realm ID

**As a** dungeon generation system
**I want to** retrieve a specific biome definition by RealmId
**So that** I can apply realm-appropriate theming to generated sectors

**Acceptance Criteria:**

- GetBiome returns correct BiomeDefinition for valid RealmId
- GetBiome returns null for invalid/unknown realm
- All BiomeDefinition properties are populated

### US-19.0a-3: Validate Realm Adjacency

**As a** sector layout validator
**I want to** check if two realms can neighbor each other
**So that** invalid biome combinations are prevented

**Acceptance Criteria:**

- CanBiomesNeighbor returns false for Muspelheim↔Niflheim
- CanBiomesNeighbor returns false for Muspelheim↔Vanaheim
- CanBiomesNeighbor returns true for Compatible pairs
- CanBiomesNeighbor returns true for RequiresTransition pairs

### US-19.0a-4: Get Transition Room Requirements

**As a** dungeon corridor generator
**I want to** get the required transition room count between realms
**So that** appropriate transition zones can be generated

**Acceptance Criteria:**

- GetTransitionRoomCount returns (0, 0) for Compatible
- GetTransitionRoomCount returns (1, 3) for RequiresTransition
- GetTransitionRoomCount throws for Incompatible pairs

### US-19.0a-5: Retrieve Environmental Condition Details

**As a** combat hazard system
**I want to** get the environmental condition definition for a realm
**So that** appropriate damage and checks can be applied

**Acceptance Criteria:**

- GetEnvironmentalCondition returns correct condition for type
- Condition includes CheckAttribute, BaseDc, DamageDice
- Mitigations list populated for applicable conditions

### US-19.0a-6: Calculate Zone-Modified DC

**As an** environmental damage calculator
**I want to** get the effective DC for a condition in a specific zone
**So that** zone-specific difficulty is applied

**Acceptance Criteria:**

- CalculateEffectiveDc applies zone DC modifier
- Returns BaseDc when zone is null
- Returns BaseDc + modifier when zone has modifier

---

## 5. RealmId Enum

### 5.1 Purpose

Identifies the nine canonical realms of Aethelgard, each corresponding to a Deck of the YGGDRASIL Network.

### 5.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/RealmId.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Identifies the nine canonical realms of Aethelgard.
/// </summary>
/// <remarks>
/// <para>
/// Each realm corresponds to a Deck of the YGGDRASIL Network — the
/// world-machine that maintains Aethelgard. The Decks were engineered
/// environments serving specific functions before the Glitch.
/// </para>
/// <para>
/// Realm-to-Deck Mapping:
/// <list type="bullet">
/// <item>Deck 01 — Asgard (Primary Administration)</item>
/// <item>Deck 02 — Alfheim (Aetheric Research)</item>
/// <item>Deck 03 — Vanaheim (Bio-Engineering)</item>
/// <item>Deck 04 — Midgard (Civilian Habitation)</item>
/// <item>Deck 05 — Niflheim (Cryogenic Preservation)</item>
/// <item>Deck 06 — Svartalfheim (Manufacturing)</item>
/// <item>Deck 07 — Jötunheim (Heavy Industry)</item>
/// <item>Deck 08 — Muspelheim (Power Generation)</item>
/// <item>Deck 09 — Helheim (Waste Reclamation)</item>
/// </list>
/// </para>
/// </remarks>
public enum RealmId
{
    /// <summary>
    /// Deck 01 — Primary Administration.
    /// </summary>
    /// <remarks>
    /// <para>The Shattered Spire. Once the command center of YGGDRASIL,
    /// now a cognitive death zone haunted by the fragmented O.D.I.N. AI.</para>
    /// <para>Primary Hazard: CPS Exposure (Genius Loci, Heimdallr Signal)</para>
    /// </remarks>
    Asgard = 1,

    /// <summary>
    /// Deck 02 — Aetheric Research.
    /// </summary>
    /// <remarks>
    /// <para>The Glimmering Wound. Reality research labs where the
    /// boundaries between dimensions have become unstable.</para>
    /// <para>Primary Hazard: Reality Flux (Glimmer corruption)</para>
    /// </remarks>
    Alfheim = 2,

    /// <summary>
    /// Deck 03 — Bio-Engineering.
    /// </summary>
    /// <remarks>
    /// <para>The Overgrown Laboratory. Agricultural and genetic engineering
    /// facilities now overrun by weaponized flora.</para>
    /// <para>Primary Hazard: Mutagenic Spores (Golden Plague corruption)</para>
    /// </remarks>
    Vanaheim = 3,

    /// <summary>
    /// Deck 04 — Civilian Habitation.
    /// </summary>
    /// <remarks>
    /// <para>The Tamed Ruin. Agricultural heartland and most populous realm.
    /// Foundation of post-Glitch civilization.</para>
    /// <para>Primary Hazard: None (temperate, territorial fauna)</para>
    /// </remarks>
    Midgard = 4,

    /// <summary>
    /// Deck 05 — Cryogenic Preservation.
    /// </summary>
    /// <remarks>
    /// <para>The Frozen Tomb. Cryogenic storage facilities where the cooling
    /// systems have catastrophically failed... or succeeded too well.</para>
    /// <para>Primary Hazard: Extreme Cold (Ice-Debt, thermal drain)</para>
    /// </remarks>
    Niflheim = 5,

    /// <summary>
    /// Deck 06 — Manufacturing.
    /// </summary>
    /// <remarks>
    /// <para>The Dvergr Forges. Subterranean manufacturing complex now
    /// home to the Dvergr craftsmen and their forge-cities.</para>
    /// <para>Primary Hazard: Total Darkness (light dependency)</para>
    /// </remarks>
    Svartalfheim = 6,

    /// <summary>
    /// Deck 07 — Heavy Industry.
    /// </summary>
    /// <remarks>
    /// <para>The Industrial Graveyard. Massive heavy industry facilities
    /// built to giant scale, now abandoned and decaying.</para>
    /// <para>Primary Hazard: Giant Scale (fall damage, traversal checks)</para>
    /// </remarks>
    Jotunheim = 7,

    /// <summary>
    /// Deck 08 — Power Generation.
    /// </summary>
    /// <remarks>
    /// <para>The Eternal Meltdown. Geothermal power plants in permanent
    /// thermal catastrophe, watched over by the Surtr AI.</para>
    /// <para>Primary Hazard: Intense Heat (STURDINESS checks, fire damage)</para>
    /// </remarks>
    Muspelheim = 8,

    /// <summary>
    /// Deck 09 — Waste Reclamation.
    /// </summary>
    /// <remarks>
    /// <para>The Gangrenous Gut. Waste processing facilities that have
    /// become a toxic cascade, source of world-wide contamination.</para>
    /// <para>Primary Hazard: Toxic Atmosphere (environmental seal required)</para>
    /// </remarks>
    Helheim = 9
}
```

---

## 6. BiomeCompatibility Enum

### 6.1 Purpose

Defines the adjacency compatibility classifications between biomes for dungeon generation and sector layout validation.

### 6.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/BiomeCompatibility.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines adjacency compatibility between biomes.
/// </summary>
/// <remarks>
/// <para>
/// Biome compatibility determines how realms can neighbor each other
/// in dungeon generation. This ensures thematic consistency and prevents
/// jarring environmental transitions.
/// </para>
/// <para>
/// Compatibility Levels:
/// <list type="bullet">
/// <item>Compatible: Biomes can directly neighbor without transition</item>
/// <item>RequiresTransition: 1-3 transition rooms required between biomes</item>
/// <item>Incompatible: Biomes cannot neighbor; requires neutral buffer zone</item>
/// </list>
/// </para>
/// <para>
/// Critical Incompatibilities:
/// <list type="bullet">
/// <item>Muspelheim ↔ Niflheim (Fire/Ice contradiction)</item>
/// <item>Muspelheim ↔ Vanaheim (Fire/Bio contradiction)</item>
/// </list>
/// </para>
/// </remarks>
public enum BiomeCompatibility
{
    /// <summary>
    /// Biomes can directly neighbor without transition rooms.
    /// </summary>
    /// <remarks>
    /// Examples: Midgard↔Vanaheim, Svartalfheim↔Muspelheim, Svartalfheim↔Helheim
    /// </remarks>
    Compatible = 0,

    /// <summary>
    /// Biomes require 1-3 transition rooms when neighboring.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Transition rooms blend the environmental properties of both biomes,
    /// providing gradual shift in temperature, lighting, and hazards.
    /// </para>
    /// <para>
    /// Examples: Midgard↔Alfheim, Niflheim↔Jötunheim, most cross-realm pairs
    /// </para>
    /// </remarks>
    RequiresTransition = 1,

    /// <summary>
    /// Biomes cannot neighbor directly; requires neutral buffer zone.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Incompatible biomes have fundamentally contradictory environmental
    /// properties that cannot be blended. A neutral zone (like Svartalfheim)
    /// must separate them.
    /// </para>
    /// <para>
    /// Examples: Muspelheim↔Niflheim (Fire/Ice), Muspelheim↔Vanaheim (Fire/Bio)
    /// </para>
    /// </remarks>
    Incompatible = 2
}
```

---

## 7. EnvironmentalConditionType Enum

### 7.1 Purpose

Defines the types of ambient environmental hazards that can be applied per realm or zone.

### 7.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/EnvironmentalConditionType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of ambient environmental hazards applied per realm.
/// </summary>
/// <remarks>
/// <para>
/// Environmental conditions represent persistent hazards that affect
/// characters based on their location. Each realm has a primary condition,
/// and individual zones may override or modify the condition.
/// </para>
/// <para>
/// Condition Mechanics:
/// <list type="bullet">
/// <item>Check Attribute: Which attribute resists the condition (usually STURDINESS)</item>
/// <item>Base DC: Default difficulty for resistance checks</item>
/// <item>Damage: Dice rolled on failed check</item>
/// <item>Frequency: How often checks are required (per turn, per hour, etc.)</item>
/// </list>
/// </para>
/// </remarks>
public enum EnvironmentalConditionType
{
    /// <summary>
    /// No ambient hazard (temperate realms like Midgard).
    /// </summary>
    None = 0,

    /// <summary>
    /// Extreme heat requiring STURDINESS checks (Muspelheim).
    /// </summary>
    /// <remarks>
    /// Base DC: 12, Damage: 2d6 Fire per turn.
    /// Mitigations: Fire Resistance, cooling equipment, Hearth shelter.
    /// </remarks>
    IntenseHeat = 1,

    /// <summary>
    /// Extreme cold requiring STURDINESS checks (Niflheim).
    /// </summary>
    /// <remarks>
    /// Base DC: 12, Damage: 2d6 Cold per turn.
    /// Mitigations: Cold Resistance, thermal gear, Ice-Marrow consumption.
    /// </remarks>
    ExtremeCold = 2,

    /// <summary>
    /// Toxic atmosphere requiring environmental seal (Helheim).
    /// </summary>
    /// <remarks>
    /// Base DC: 14, Damage: 2d8 Poison per turn.
    /// Mitigations: Full environmental seal, filtration mask, Poison Resistance.
    /// </remarks>
    ToxicAtmosphere = 3,

    /// <summary>
    /// Mutagenic spores causing Corruption accumulation (Vanaheim).
    /// </summary>
    /// <remarks>
    /// Base DC: 12, Effect: +1d4 Corruption per hour (not damage).
    /// Mitigations: Sealed suit, filtration, Golden Plague immunity.
    /// </remarks>
    MutagenicSpores = 4,

    /// <summary>
    /// Reality distortion causing Stress and navigation hazards (Alfheim).
    /// </summary>
    /// <remarks>
    /// Base DC: 10, Effect: +1d6 Stress per hour, navigation disadvantage.
    /// Mitigations: Glimmer resistance, AETHERIC skill, reality anchors.
    /// </remarks>
    RealityFlux = 5,

    /// <summary>
    /// Cognitive paradox exposure causing CPS accumulation (Asgard).
    /// </summary>
    /// <remarks>
    /// Base DC: 14, Effect: +1d8 Stress per turn in Exclusion Zone.
    /// Mitigations: None effective; minimize exposure time.
    /// </remarks>
    CpsExposure = 6,

    /// <summary>
    /// Absolute darkness requiring light sources (Svartalfheim Black Veins).
    /// </summary>
    /// <remarks>
    /// No damage check; instead, all actions have disadvantage without light.
    /// Mitigations: Light sources, darkvision equipment, Dvergr guides.
    /// </remarks>
    TotalDarkness = 7,

    /// <summary>
    /// Giant-scale terrain with traversal hazards (Jötunheim).
    /// </summary>
    /// <remarks>
    /// No periodic damage; instead, increased fall damage (×2) and
    /// AGILITY checks for traversal on giant-scale structures.
    /// Mitigations: Climbing gear, flight, size-changing abilities.
    /// </remarks>
    GiantScale = 8
}
```

---

## 8. VerticalZone Enum

### 8.1 Purpose

Defines the vertical layer classification system for biome placement, mapping Z-levels to thematic zones.

### 8.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/VerticalZone.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Vertical layer classification for biome placement.
/// </summary>
/// <remarks>
/// <para>
/// YGGDRASIL's structure follows a tree metaphor with Roots (below),
/// Trunk (surface), and Canopy (above). Each realm occupies specific
/// vertical zones based on its original function.
/// </para>
/// <para>
/// Zone Distribution:
/// <list type="bullet">
/// <item>Deep Realms: Muspelheim (Z=-3), Helheim (Z=-3 to -4)</item>
/// <item>Middle Realms: Svartalfheim (Z=-1 to -2), Niflheim (Z=-1 to +1)</item>
/// <item>Surface: Midgard (Z=0 to +1), Jötunheim (Z=-2 to +2)</item>
/// <item>Upper: Vanaheim (Z=-1 to +2), Alfheim (Z=+1 to +3)</item>
/// <item>Orbital: Asgard (Z=+3 and above)</item>
/// </list>
/// </para>
/// </remarks>
public enum VerticalZone
{
    /// <summary>
    /// Z = -3. Deepest dungeon layers.
    /// </summary>
    /// <remarks>
    /// Home to Muspelheim's Surtr Core and Helheim's Sunken Sectors.
    /// Extremely hazardous; maximum environmental danger.
    /// </remarks>
    DeepRoots = -3,

    /// <summary>
    /// Z = -2. Lower subterranean layers.
    /// </summary>
    /// <remarks>
    /// Svartalfheim's Black Veins, Muspelheim's Slag Wastes.
    /// Dangerous but navigable with preparation.
    /// </remarks>
    LowerRoots = -2,

    /// <summary>
    /// Z = -1. Upper subterranean layers.
    /// </summary>
    /// <remarks>
    /// Svartalfheim's Guild-Lands, Vanaheim's Under-growth.
    /// Moderate hazards, established settlements possible.
    /// </remarks>
    UpperRoots = -1,

    /// <summary>
    /// Z = 0. Ground/entry level.
    /// </summary>
    /// <remarks>
    /// Midgard's agricultural lands, most Hold settlements.
    /// Safest general zone; starting area for most adventures.
    /// </remarks>
    GroundLevel = 0,

    /// <summary>
    /// Z = +1. Lower surface structures.
    /// </summary>
    /// <remarks>
    /// Midgard's upper regions, Alfheim's lower reaches.
    /// Generally safe with standard hazards.
    /// </remarks>
    LowerTrunk = 1,

    /// <summary>
    /// Z = +2. Upper surface structures.
    /// </summary>
    /// <remarks>
    /// Vanaheim's Canopy Sea, Jötunheim's upper structures.
    /// Increased exposure, environmental extremes.
    /// </remarks>
    UpperTrunk = 2,

    /// <summary>
    /// Z = +3. Highest surface exposure.
    /// </summary>
    /// <remarks>
    /// Alfheim's upper reality distortion zones.
    /// Maximum Glimmer exposure, difficult navigation.
    /// </remarks>
    Canopy = 3,

    /// <summary>
    /// Z = +4 and above. Orbital structures (Asgard only).
    /// </summary>
    /// <remarks>
    /// Asgard's Shattered Spire remains in degraded orbit.
    /// CPS Exposure at maximum; Heimdallr Signal death zone.
    /// </remarks>
    Orbital = 4
}
```

---

## 9. BiomeProperties Value Object

### 9.1 Purpose

Encapsulates the environmental baseline properties for a biome, including temperature, humidity, light levels, and hazard factors.

### 9.2 Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/BiomeProperties.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Environmental baseline properties for a biome.
/// </summary>
/// <remarks>
/// <para>
/// BiomeProperties define the physical characteristics of a realm that
/// affect gameplay, equipment, and character survival. These values
/// serve as defaults that can be overridden by specific zones.
/// </para>
/// <para>
/// Property Ranges:
/// <list type="bullet">
/// <item>Temperature: -273°C (absolute zero) to 1500°C (molten rock)</item>
/// <item>AethericIntensity: 0.0 (mundane) to 1.0 (reality breakdown)</item>
/// <item>Humidity: 0% (desert) to 100% (submerged)</item>
/// <item>LightLevel: 0.0 (absolute dark) to 1.0 (blinding)</item>
/// <item>ScaleFactor: 0.5 (halfling-sized) to 3.0 (giant-sized)</item>
/// <item>CorrosionRate: 0.0 (pristine) to 1.0 (instant decay)</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var muspelheimProps = new BiomeProperties
/// {
///     TemperatureCelsius = 800,
///     AethericIntensity = 0.4f,
///     HumidityPercent = 5,
///     LightLevel = 0.8f,
///     ScaleFactor = 1.0f,
///     CorrosionRate = 0.3f
/// };
/// </code>
/// </example>
public sealed record BiomeProperties
{
    /// <summary>
    /// Base temperature in Celsius.
    /// </summary>
    /// <remarks>
    /// Affects heat/cold damage thresholds and equipment behavior.
    /// Examples: Midgard=18°C, Muspelheim=800°C, Niflheim=-80°C
    /// </remarks>
    public required int TemperatureCelsius { get; init; }

    /// <summary>
    /// Aetheric intensity (0.0-1.0). Higher values indicate more magic/paradox activity.
    /// </summary>
    /// <remarks>
    /// Affects spell effectiveness, Glimmer accumulation, and reality stability.
    /// Examples: Midgard=0.3, Alfheim=0.9, Svartalfheim=0.2
    /// </remarks>
    public required float AethericIntensity { get; init; }

    /// <summary>
    /// Humidity percentage (0-100).
    /// </summary>
    /// <remarks>
    /// Affects rust/corrosion, visibility, and certain creature types.
    /// Examples: Midgard=60%, Muspelheim=5%, Vanaheim=95%
    /// </remarks>
    public required int HumidityPercent { get; init; }

    /// <summary>
    /// Ambient light level (0.0-1.0). 0 = absolute darkness, 1 = blinding.
    /// </summary>
    /// <remarks>
    /// Affects visibility, stealth, and light-dependent hazards.
    /// Examples: Midgard=0.7, Svartalfheim=0.0, Muspelheim=0.8
    /// </remarks>
    public required float LightLevel { get; init; }

    /// <summary>
    /// Scale factor for architecture. 1.0 = human-sized, 3.0 = giant-sized.
    /// </summary>
    /// <remarks>
    /// Affects traversal difficulty, fall damage multipliers, and stealth.
    /// Examples: Midgard=1.0, Jötunheim=3.0, Svartalfheim=0.8
    /// </remarks>
    public required float ScaleFactor { get; init; }

    /// <summary>
    /// Equipment corrosion rate (0.0-1.0).
    /// </summary>
    /// <remarks>
    /// Affects equipment degradation speed in this environment.
    /// Examples: Midgard=0.2, Helheim=0.8, Niflheim=0.1
    /// </remarks>
    public required float CorrosionRate { get; init; }

    /// <summary>
    /// Gets whether this biome is considered thermally extreme.
    /// </summary>
    public bool IsThermalExtreme => TemperatureCelsius > 50 || TemperatureCelsius < -20;

    /// <summary>
    /// Gets whether this biome has significant aetheric activity.
    /// </summary>
    public bool HasSignificantAether => AethericIntensity > 0.5f;

    /// <summary>
    /// Gets whether this biome is effectively dark.
    /// </summary>
    public bool IsDark => LightLevel < 0.1f;

    /// <summary>
    /// Gets whether this biome has giant-scale architecture.
    /// </summary>
    public bool IsGiantScale => ScaleFactor > 1.5f;

    /// <summary>
    /// Creates default properties for a temperate realm (Midgard baseline).
    /// </summary>
    public static BiomeProperties Temperate() => new()
    {
        TemperatureCelsius = 18,
        AethericIntensity = 0.3f,
        HumidityPercent = 60,
        LightLevel = 0.7f,
        ScaleFactor = 1.0f,
        CorrosionRate = 0.2f
    };

    /// <inheritdoc/>
    public override string ToString() =>
        $"BiomeProps[T={TemperatureCelsius}°C, Aether={AethericIntensity:P0}, " +
        $"Humid={HumidityPercent}%, Light={LightLevel:P0}, Scale={ScaleFactor}x]";
}
```

---

## 10. AdjacencyRule Value Object

### 10.1 Purpose

Defines the adjacency relationship between two realms, including compatibility classification and transition requirements.

### 10.2 Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AdjacencyRule.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines adjacency relationship between two realms.
/// </summary>
/// <remarks>
/// <para>
/// AdjacencyRule determines how two realms can border each other in
/// dungeon generation. Rules are bidirectional (A→B equals B→A).
/// </para>
/// <para>
/// Transition Requirements:
/// <list type="bullet">
/// <item>Compatible: 0 transition rooms required</item>
/// <item>RequiresTransition: 1-3 transition rooms required</item>
/// <item>Incompatible: Cannot directly border; needs buffer realm</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var fireIceRule = new AdjacencyRule
/// {
///     RealmA = RealmId.Muspelheim,
///     RealmB = RealmId.Niflheim,
///     Compatibility = BiomeCompatibility.Incompatible
/// };
/// </code>
/// </example>
public sealed record AdjacencyRule
{
    /// <summary>
    /// First realm in the relationship.
    /// </summary>
    public required RealmId RealmA { get; init; }

    /// <summary>
    /// Second realm in the relationship.
    /// </summary>
    public required RealmId RealmB { get; init; }

    /// <summary>
    /// Compatibility classification.
    /// </summary>
    public required BiomeCompatibility Compatibility { get; init; }

    /// <summary>
    /// Minimum transition rooms if RequiresTransition.
    /// </summary>
    /// <remarks>
    /// Only applicable when Compatibility is RequiresTransition.
    /// Default: 0 for Compatible, 1 for RequiresTransition.
    /// </remarks>
    public int MinTransitionRooms { get; init; } = 0;

    /// <summary>
    /// Maximum transition rooms if RequiresTransition.
    /// </summary>
    /// <remarks>
    /// Only applicable when Compatibility is RequiresTransition.
    /// Default: 0 for Compatible, 3 for RequiresTransition.
    /// </remarks>
    public int MaxTransitionRooms { get; init; } = 0;

    /// <summary>
    /// Descriptive theme for transition zone.
    /// </summary>
    /// <remarks>
    /// Used for narrative flavor in transition room descriptions.
    /// Example: "Volcanic heat fades into geothermal stability..."
    /// </remarks>
    public string? TransitionTheme { get; init; }

    /// <summary>
    /// Gets whether this rule allows direct neighboring.
    /// </summary>
    public bool AllowsNeighboring => Compatibility != BiomeCompatibility.Incompatible;

    /// <summary>
    /// Gets whether transition rooms are required.
    /// </summary>
    public bool RequiresTransitionRooms => Compatibility == BiomeCompatibility.RequiresTransition;

    /// <summary>
    /// Checks if this rule applies to the given realm pair (bidirectional).
    /// </summary>
    /// <param name="a">First realm to check.</param>
    /// <param name="b">Second realm to check.</param>
    /// <returns>True if this rule governs the pair.</returns>
    public bool AppliesTo(RealmId a, RealmId b) =>
        (RealmA == a && RealmB == b) || (RealmA == b && RealmB == a);

    /// <summary>
    /// Gets a normalized key for this realm pair (for dictionary lookup).
    /// </summary>
    /// <remarks>
    /// Key is always ordered with smaller RealmId first for consistency.
    /// </remarks>
    public string GetKey() => GetKey(RealmA, RealmB);

    /// <summary>
    /// Gets a normalized key for any realm pair.
    /// </summary>
    public static string GetKey(RealmId a, RealmId b)
    {
        var first = (int)a < (int)b ? a : b;
        var second = (int)a < (int)b ? b : a;
        return $"{first}:{second}";
    }

    /// <inheritdoc/>
    public override string ToString() =>
        $"Adjacency[{RealmA}↔{RealmB}]: {Compatibility}" +
        (RequiresTransitionRooms ? $" ({MinTransitionRooms}-{MaxTransitionRooms} rooms)" : "");
}
```

---

## 11. BiomeDefinition Entity

### 11.1 Purpose

Core entity representing a realm/biome in Aethelgard, containing all properties, zones, and metadata for the realm.

### 11.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/BiomeDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Core definition for a realm/biome in Aethelgard.
/// </summary>
/// <remarks>
/// <para>
/// BiomeDefinition represents one of the nine canonical realms of Aethelgard.
/// Each realm has unique environmental properties, hazards, and thematic elements
/// derived from its pre-Glitch function in the YGGDRASIL Network.
/// </para>
/// <para>
/// Key Components:
/// <list type="bullet">
/// <item>Identity: RealmId, Name, Subtitle, DeckNumber</item>
/// <item>Lore: PreGlitchFunction, PostGlitchState, FlavorQuote</item>
/// <item>Environment: BaseProperties, PrimaryCondition, VerticalZone range</item>
/// <item>Structure: Zones (sub-biomes with override properties)</item>
/// <item>Presentation: ColorPalette for UI theming</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var midgard = new BiomeDefinition
/// {
///     Id = RealmId.Midgard,
///     Name = "Midgard",
///     Subtitle = "The Tamed Ruin",
///     DeckNumber = 4,
///     PreGlitchFunction = "Civilian Habitation &amp; Agricultural Production",
///     PostGlitchState = "Agricultural heartland; most populous realm",
///     BaseProperties = BiomeProperties.Temperate(),
///     PrimaryCondition = EnvironmentalConditionType.None,
///     MinVerticalZone = VerticalZone.GroundLevel,
///     MaxVerticalZone = VerticalZone.LowerTrunk,
///     FlavorQuote = "The Wall is the soul of the Hold."
/// };
/// </code>
/// </example>
public sealed class BiomeDefinition
{
    /// <summary>
    /// Unique realm identifier.
    /// </summary>
    public required RealmId Id { get; init; }

    /// <summary>
    /// Display name (e.g., "Midgard").
    /// </summary>
    public required string Name { get; init; }

    /// <summary>
    /// Thematic subtitle (e.g., "The Tamed Ruin").
    /// </summary>
    public required string Subtitle { get; init; }

    /// <summary>
    /// Deck designation in YGGDRASIL Network (1-9).
    /// </summary>
    public required int DeckNumber { get; init; }

    /// <summary>
    /// Pre-Glitch function description.
    /// </summary>
    /// <remarks>
    /// Describes what this Deck was designed to do before the catastrophe.
    /// Example: "Civilian Habitation &amp; Agricultural Production"
    /// </remarks>
    public required string PreGlitchFunction { get; init; }

    /// <summary>
    /// Post-Glitch state description.
    /// </summary>
    /// <remarks>
    /// Describes the current state of the realm after the Glitch.
    /// Example: "Agricultural heartland; most populous realm"
    /// </remarks>
    public required string PostGlitchState { get; init; }

    /// <summary>
    /// Environmental baseline properties.
    /// </summary>
    public required BiomeProperties BaseProperties { get; init; }

    /// <summary>
    /// Primary environmental hazard type.
    /// </summary>
    /// <remarks>
    /// The default environmental condition for this realm.
    /// Individual zones may override this condition.
    /// </remarks>
    public required EnvironmentalConditionType PrimaryCondition { get; init; }

    /// <summary>
    /// Vertical zone range (minimum Z-level).
    /// </summary>
    public required VerticalZone MinVerticalZone { get; init; }

    /// <summary>
    /// Vertical zone range (maximum Z-level).
    /// </summary>
    public required VerticalZone MaxVerticalZone { get; init; }

    /// <summary>
    /// Sub-biome zones within this realm.
    /// </summary>
    /// <remarks>
    /// Zones represent distinct areas within a realm with potentially
    /// different properties or hazard modifiers.
    /// </remarks>
    public IReadOnlyList<BiomeZone> Zones { get; init; } = [];

    /// <summary>
    /// Flavor quote for thematic display.
    /// </summary>
    /// <remarks>
    /// A representative quote that captures the essence of this realm.
    /// Example: "The Wall is the soul of the Hold."
    /// </remarks>
    public string? FlavorQuote { get; init; }

    /// <summary>
    /// Thematic color palette (CSS-style).
    /// </summary>
    /// <remarks>
    /// Used for UI theming when displaying this realm.
    /// Format: "primary-secondary-accent" colors.
    /// Example: "green-brown-grey-amber" for Midgard
    /// </remarks>
    public string? ColorPalette { get; init; }

    /// <summary>
    /// Gets whether this realm has environmental hazards.
    /// </summary>
    public bool HasEnvironmentalHazard => PrimaryCondition != EnvironmentalConditionType.None;

    /// <summary>
    /// Gets the full display name with subtitle.
    /// </summary>
    public string FullName => $"{Name} — {Subtitle}";

    /// <summary>
    /// Gets a zone by its ID, or null if not found.
    /// </summary>
    /// <param name="zoneId">The zone identifier.</param>
    /// <returns>The matching zone, or null.</returns>
    public BiomeZone? GetZone(string zoneId) =>
        Zones.FirstOrDefault(z => z.Id.Equals(zoneId, StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Gets the effective properties for a specific zone.
    /// </summary>
    /// <param name="zoneId">The zone identifier (null for base realm).</param>
    /// <returns>Zone override properties if available, otherwise base properties.</returns>
    public BiomeProperties GetEffectiveProperties(string? zoneId)
    {
        if (string.IsNullOrEmpty(zoneId))
            return BaseProperties;

        var zone = GetZone(zoneId);
        return zone?.OverrideProperties ?? BaseProperties;
    }

    /// <summary>
    /// Gets the effective environmental condition for a specific zone.
    /// </summary>
    /// <param name="zoneId">The zone identifier (null for base realm).</param>
    /// <returns>Zone override condition if available, otherwise primary condition.</returns>
    public EnvironmentalConditionType GetEffectiveCondition(string? zoneId)
    {
        if (string.IsNullOrEmpty(zoneId))
            return PrimaryCondition;

        var zone = GetZone(zoneId);
        return zone?.OverrideCondition ?? PrimaryCondition;
    }

    /// <inheritdoc/>
    public override string ToString() =>
        $"Biome[{Id}]: {FullName} (Deck {DeckNumber:D2})";
}
```

---

## 12. BiomeZone Entity

### 12.1 Purpose

Represents a sub-biome zone within a realm, allowing for property overrides and DC modifiers for specific areas.

### 12.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/BiomeZone.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Sub-biome zone within a realm (e.g., Greatwood within Midgard).
/// </summary>
/// <remarks>
/// <para>
/// BiomeZone represents a distinct area within a realm that may have
/// different environmental properties, hazard difficulties, or thematic
/// elements compared to the parent realm's baseline.
/// </para>
/// <para>
/// Zone Properties:
/// <list type="bullet">
/// <item>OverrideProperties: Completely replace parent realm's base properties</item>
/// <item>OverrideCondition: Different environmental hazard type</item>
/// <item>ConditionDcModifier: Adjust hazard difficulty (-6 to +8)</item>
/// <item>DamageOverride: Different damage dice for the zone's hazard</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var forgeCore = new BiomeZone
/// {
///     Id = "forge-core",
///     Name = "Surtr's Forge Core",
///     ParentRealm = RealmId.Muspelheim,
///     ConditionDcModifier = +8,
///     DamageOverride = "4d6",
///     MinVerticalZone = VerticalZone.DeepRoots,
///     MaxVerticalZone = VerticalZone.DeepRoots
/// };
/// </code>
/// </example>
public sealed class BiomeZone
{
    /// <summary>
    /// Unique zone identifier within the realm.
    /// </summary>
    /// <remarks>
    /// Typically kebab-case format: "greatwood", "forge-core", etc.
    /// </remarks>
    public required string Id { get; init; }

    /// <summary>
    /// Display name (e.g., "The Greatwood").
    /// </summary>
    public required string Name { get; init; }

    /// <summary>
    /// Parent realm.
    /// </summary>
    public required RealmId ParentRealm { get; init; }

    /// <summary>
    /// Override properties for this zone (null = use parent).
    /// </summary>
    /// <remarks>
    /// When set, completely replaces the parent realm's base properties
    /// for characters in this zone.
    /// </remarks>
    public BiomeProperties? OverrideProperties { get; init; }

    /// <summary>
    /// Zone-specific environmental condition override.
    /// </summary>
    /// <remarks>
    /// When set, replaces the parent realm's primary condition.
    /// Example: Hearth interiors might have None instead of IntenseHeat.
    /// </remarks>
    public EnvironmentalConditionType? OverrideCondition { get; init; }

    /// <summary>
    /// DC modifier for environmental checks in this zone.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Modifies the base DC of environmental condition checks.
    /// Range: -6 (very safe) to +8 (extremely dangerous).
    /// </para>
    /// <para>
    /// Examples:
    /// <list type="bullet">
    /// <item>Hearth Interior: -6 (DC 6 instead of 12)</item>
    /// <item>Slag Wastes: +2 (DC 14)</item>
    /// <item>Forge Core: +8 (DC 20)</item>
    /// </list>
    /// </para>
    /// </remarks>
    public int ConditionDcModifier { get; init; } = 0;

    /// <summary>
    /// Damage dice override for environmental effects.
    /// </summary>
    /// <remarks>
    /// When set, replaces the base damage dice for environmental checks.
    /// Format: "XdY" (e.g., "4d6" for Forge Core).
    /// </remarks>
    public string? DamageOverride { get; init; }

    /// <summary>
    /// Vertical zone range (minimum).
    /// </summary>
    /// <remarks>
    /// Constrains which Z-levels this zone can appear on.
    /// Null means inherits from parent realm.
    /// </remarks>
    public VerticalZone? MinVerticalZone { get; init; }

    /// <summary>
    /// Vertical zone range (maximum).
    /// </summary>
    public VerticalZone? MaxVerticalZone { get; init; }

    /// <summary>
    /// Gets whether this zone has overridden properties.
    /// </summary>
    public bool HasOverrideProperties => OverrideProperties is not null;

    /// <summary>
    /// Gets whether this zone has an overridden environmental condition.
    /// </summary>
    public bool HasOverrideCondition => OverrideCondition.HasValue;

    /// <summary>
    /// Gets whether this zone modifies the environmental DC.
    /// </summary>
    public bool HasDcModifier => ConditionDcModifier != 0;

    /// <summary>
    /// Gets whether this zone modifies environmental damage.
    /// </summary>
    public bool HasDamageOverride => !string.IsNullOrEmpty(DamageOverride);

    /// <summary>
    /// Gets the effective DC modifier description.
    /// </summary>
    public string DcModifierDescription => ConditionDcModifier switch
    {
        < -4 => "Very Safe",
        < 0 => "Safer",
        0 => "Standard",
        <= 4 => "Dangerous",
        _ => "Extremely Dangerous"
    };

    /// <inheritdoc/>
    public override string ToString() =>
        $"Zone[{ParentRealm}/{Id}]: {Name}" +
        (HasDcModifier ? $" (DC {(ConditionDcModifier >= 0 ? "+" : "")}{ConditionDcModifier})" : "");
}
```

---

## 13. EnvironmentalCondition Entity

### 13.1 Purpose

Defines an active environmental hazard with its mechanical effects, damage values, and mitigation options.

### 13.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/EnvironmentalCondition.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Active environmental hazard applied to characters.
/// </summary>
/// <remarks>
/// <para>
/// EnvironmentalCondition defines the mechanical effects of realm hazards.
/// Each condition specifies how often checks occur, what attribute resists it,
/// the base difficulty, and damage on failure.
/// </para>
/// <para>
/// Condition Components:
/// <list type="bullet">
/// <item>CheckAttribute: Which character attribute resists (usually STURDINESS)</item>
/// <item>BaseDc: Default difficulty (typically 12, modified by zones)</item>
/// <item>DamageDice: Damage rolled on failed check (e.g., "2d6")</item>
/// <item>Frequency: How often checks are required (per turn, per hour)</item>
/// <item>Mitigations: Equipment or abilities that reduce or negate effects</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var intenseHeat = new EnvironmentalCondition
/// {
///     Type = EnvironmentalConditionType.IntenseHeat,
///     DisplayName = "Intense Heat",
///     CheckAttribute = "STURDINESS",
///     BaseDc = 12,
///     DamageDice = "2d6",
///     DamageType = "Fire",
///     Frequency = "Per Turn",
///     Description = "The ambient temperature is dangerously high...",
///     Mitigations = ["Fire Resistance", "Cooling equipment", "Hearth shelter"]
/// };
/// </code>
/// </example>
public sealed class EnvironmentalCondition
{
    /// <summary>
    /// Condition type.
    /// </summary>
    public required EnvironmentalConditionType Type { get; init; }

    /// <summary>
    /// Display name for UI.
    /// </summary>
    public required string DisplayName { get; init; }

    /// <summary>
    /// Attribute used for resistance check.
    /// </summary>
    /// <remarks>
    /// The character attribute rolled against the DC.
    /// Common values: "STURDINESS", "WILL", "AGILITY"
    /// </remarks>
    public required string CheckAttribute { get; init; }

    /// <summary>
    /// Base DC for resistance check.
    /// </summary>
    /// <remarks>
    /// The default difficulty before zone modifiers.
    /// Standard: 12, Harsh: 14, Extreme: 16+
    /// </remarks>
    public required int BaseDc { get; init; }

    /// <summary>
    /// Damage dice on failed check (e.g., "2d6").
    /// </summary>
    public required string DamageDice { get; init; }

    /// <summary>
    /// Damage type (e.g., "Fire", "Cold", "Poison").
    /// </summary>
    /// <remarks>
    /// Used for resistance calculations and damage type-specific effects.
    /// </remarks>
    public required string DamageType { get; init; }

    /// <summary>
    /// Check frequency (e.g., "Per Turn", "Per Hour").
    /// </summary>
    /// <remarks>
    /// Determines how often resistance checks are required.
    /// Combat: "Per Turn" or "Per Round"
    /// Exploration: "Per Hour" or "Per Watch"
    /// </remarks>
    public required string Frequency { get; init; }

    /// <summary>
    /// Description for environmental storytelling.
    /// </summary>
    public required string Description { get; init; }

    /// <summary>
    /// Mitigation methods (equipment, abilities).
    /// </summary>
    /// <remarks>
    /// List of ways characters can reduce or negate this condition.
    /// Examples: "Fire Resistance", "Environmental seal", "Cooling equipment"
    /// </remarks>
    public IReadOnlyList<string> Mitigations { get; init; } = [];

    /// <summary>
    /// Gets whether this condition deals damage.
    /// </summary>
    public bool DealsDamage => !string.IsNullOrEmpty(DamageDice) && DamageDice != "0";

    /// <summary>
    /// Gets whether this condition has mitigations available.
    /// </summary>
    public bool HasMitigations => Mitigations.Count > 0;

    /// <summary>
    /// Gets whether checks are required every turn (combat frequency).
    /// </summary>
    public bool IsPerTurn => Frequency.Contains("Turn", StringComparison.OrdinalIgnoreCase);

    /// <summary>
    /// Gets the display string for the check.
    /// </summary>
    public string CheckDisplay => $"{CheckAttribute} DC {BaseDc}";

    /// <inheritdoc/>
    public override string ToString() =>
        $"Condition[{Type}]: {DisplayName} — {CheckDisplay}, {DamageDice} {DamageType} ({Frequency})";
}
```

---

## 14. IBiomeProvider Interface

### 14.1 Purpose

Provides access to biome definitions loaded from configuration.

### 14.2 Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IBiomeProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Provides access to biome definitions.
/// </summary>
/// <remarks>
/// <para>
/// IBiomeProvider abstracts the loading and retrieval of biome data,
/// allowing the application to access realm definitions without
/// knowledge of the underlying storage mechanism.
/// </para>
/// <para>
/// Usage:
/// <code>
/// var midgard = biomeProvider.GetBiome(RealmId.Midgard);
/// var zones = biomeProvider.GetZonesForRealm(RealmId.Muspelheim);
/// var heatCondition = biomeProvider.GetEnvironmentalCondition(EnvironmentalConditionType.IntenseHeat);
/// </code>
/// </para>
/// </remarks>
public interface IBiomeProvider
{
    /// <summary>
    /// Gets all biome definitions.
    /// </summary>
    /// <returns>List of all loaded biome definitions.</returns>
    IReadOnlyList<BiomeDefinition> GetAllBiomes();

    /// <summary>
    /// Gets a specific biome by realm ID.
    /// </summary>
    /// <param name="realmId">The realm identifier.</param>
    /// <returns>The biome definition, or null if not found.</returns>
    BiomeDefinition? GetBiome(RealmId realmId);

    /// <summary>
    /// Gets all zones for a specific realm.
    /// </summary>
    /// <param name="realmId">The realm identifier.</param>
    /// <returns>List of zones within the realm, or empty list if realm not found.</returns>
    IReadOnlyList<BiomeZone> GetZonesForRealm(RealmId realmId);

    /// <summary>
    /// Gets a specific zone by ID.
    /// </summary>
    /// <param name="realmId">The realm identifier.</param>
    /// <param name="zoneId">The zone identifier within the realm.</param>
    /// <returns>The zone, or null if not found.</returns>
    BiomeZone? GetZone(RealmId realmId, string zoneId);

    /// <summary>
    /// Gets the environmental condition definition for a type.
    /// </summary>
    /// <param name="type">The condition type.</param>
    /// <returns>The condition definition, or null if not found.</returns>
    EnvironmentalCondition? GetEnvironmentalCondition(EnvironmentalConditionType type);
}
```

---

## 15. IBiomeAdjacencyService Interface

### 15.1 Purpose

Validates and queries biome adjacency relationships for dungeon generation.

### 15.2 Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IBiomeAdjacencyService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Validates and queries biome adjacency relationships.
/// </summary>
/// <remarks>
/// <para>
/// IBiomeAdjacencyService enforces the rules about which realms can
/// neighbor each other in dungeon generation. It prevents invalid
/// combinations (like Fire/Ice) and determines transition requirements.
/// </para>
/// <para>
/// Key Operations:
/// <list type="bullet">
/// <item>CanBiomesNeighbor: Quick compatibility check</item>
/// <item>GetCompatibility: Detailed compatibility classification</item>
/// <item>GetTransitionRoomCount: Required transition buffer</item>
/// <item>ValidateRealmConfiguration: Validate entire sector layout</item>
/// </list>
/// </para>
/// </remarks>
public interface IBiomeAdjacencyService
{
    /// <summary>
    /// Checks if two realms can be adjacent.
    /// </summary>
    /// <param name="realmA">First realm.</param>
    /// <param name="realmB">Second realm.</param>
    /// <returns>True if realms can neighbor (Compatible or RequiresTransition).</returns>
    bool CanBiomesNeighbor(RealmId realmA, RealmId realmB);

    /// <summary>
    /// Gets the compatibility classification for two realms.
    /// </summary>
    /// <param name="realmA">First realm.</param>
    /// <param name="realmB">Second realm.</param>
    /// <returns>The compatibility level between the realms.</returns>
    BiomeCompatibility GetCompatibility(RealmId realmA, RealmId realmB);

    /// <summary>
    /// Gets required transition room count for two realms.
    /// </summary>
    /// <param name="realmA">First realm.</param>
    /// <param name="realmB">Second realm.</param>
    /// <returns>Tuple of (minimum, maximum) transition rooms required.</returns>
    /// <exception cref="InvalidOperationException">If realms are incompatible.</exception>
    (int Min, int Max) GetTransitionRoomCount(RealmId realmA, RealmId realmB);

    /// <summary>
    /// Gets the transition theme description for two realms.
    /// </summary>
    /// <param name="fromRealm">Source realm.</param>
    /// <param name="toRealm">Destination realm.</param>
    /// <returns>Narrative description of the transition, or null.</returns>
    string? GetTransitionTheme(RealmId fromRealm, RealmId toRealm);

    /// <summary>
    /// Gets all realms adjacent to the specified realm.
    /// </summary>
    /// <param name="realmId">The realm to query.</param>
    /// <returns>List of realms that can neighbor the specified realm.</returns>
    IReadOnlyList<RealmId> GetAdjacentRealms(RealmId realmId);

    /// <summary>
    /// Validates that a realm configuration doesn't violate adjacency rules.
    /// </summary>
    /// <param name="adjacentPairs">Collection of adjacent realm pairs.</param>
    /// <returns>True if all pairs are valid neighbors.</returns>
    bool ValidateRealmConfiguration(IEnumerable<(RealmId, RealmId)> adjacentPairs);
}
```

---

## 16. IEnvironmentalConditionService Interface

### 16.1 Purpose

Applies environmental effects to characters based on their location.

### 16.2 Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IEnvironmentalConditionService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Applies environmental effects to characters.
/// </summary>
/// <remarks>
/// <para>
/// IEnvironmentalConditionService handles the application of ambient
/// environmental hazards based on character location. It calculates
/// effective DCs, applies damage, and checks for mitigations.
/// </para>
/// </remarks>
public interface IEnvironmentalConditionService
{
    /// <summary>
    /// Gets the active environmental condition for a biome zone.
    /// </summary>
    /// <param name="realm">The realm.</param>
    /// <param name="zoneId">The zone within the realm (null for base realm).</param>
    /// <returns>The active condition, or null if no hazard.</returns>
    EnvironmentalCondition? GetActiveCondition(RealmId realm, string? zoneId = null);

    /// <summary>
    /// Calculates the effective DC for a condition in a zone.
    /// </summary>
    /// <param name="condition">The environmental condition.</param>
    /// <param name="zone">The specific zone (null for base DC).</param>
    /// <returns>The effective DC after zone modifiers.</returns>
    int CalculateEffectiveDc(EnvironmentalCondition condition, BiomeZone? zone);

    /// <summary>
    /// Applies environmental damage to a character.
    /// </summary>
    /// <param name="characterId">Target character.</param>
    /// <param name="condition">The environmental condition.</param>
    /// <param name="dcModifier">Additional DC modifier (default 0).</param>
    /// <returns>Result of the environmental damage application.</returns>
    EnvironmentalDamageResult ApplyEnvironmentalDamage(
        Guid characterId,
        EnvironmentalCondition condition,
        int dcModifier = 0);

    /// <summary>
    /// Checks if a character has mitigation for a condition.
    /// </summary>
    /// <param name="characterId">Character to check.</param>
    /// <param name="condition">The environmental condition.</param>
    /// <returns>True if character has full or partial mitigation.</returns>
    bool HasMitigation(Guid characterId, EnvironmentalCondition condition);
}
```

---

## 17. BiomeProvider Implementation

### 17.1 Purpose

Loads biome definitions from JSON configuration and provides access to them.

### 17.2 Definition

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Services/BiomeProvider.cs`

```csharp
namespace RuneAndRust.Infrastructure.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using System.Text.Json;

/// <summary>
/// Provides access to biome definitions loaded from JSON configuration.
/// </summary>
public sealed class BiomeProvider : IBiomeProvider
{
    private readonly Dictionary<RealmId, BiomeDefinition> _biomes;
    private readonly Dictionary<EnvironmentalConditionType, EnvironmentalCondition> _conditions;
    private readonly ILogger<BiomeProvider> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="BiomeProvider"/> class.
    /// </summary>
    /// <param name="configProvider">Configuration provider for loading JSON.</param>
    /// <param name="logger">Logger for biome operations.</param>
    public BiomeProvider(IConfigurationProvider configProvider, ILogger<BiomeProvider> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        // Load configuration
        var config = configProvider.LoadConfig<BiomeConfiguration>("biomes.json")
            ?? throw new InvalidOperationException("Failed to load biomes.json");

        // Index biomes by RealmId
        _biomes = config.Biomes.ToDictionary(b => b.Id);

        // Index conditions by type
        _conditions = config.EnvironmentalConditions.ToDictionary(c => c.Type);

        _logger.LogInformation(
            "BiomeProvider initialized: {BiomeCount} biomes, {ConditionCount} conditions",
            _biomes.Count, _conditions.Count);
    }

    /// <inheritdoc/>
    public IReadOnlyList<BiomeDefinition> GetAllBiomes() =>
        _biomes.Values.ToList();

    /// <inheritdoc/>
    public BiomeDefinition? GetBiome(RealmId realmId) =>
        _biomes.GetValueOrDefault(realmId);

    /// <inheritdoc/>
    public IReadOnlyList<BiomeZone> GetZonesForRealm(RealmId realmId) =>
        GetBiome(realmId)?.Zones ?? [];

    /// <inheritdoc/>
    public BiomeZone? GetZone(RealmId realmId, string zoneId) =>
        GetBiome(realmId)?.GetZone(zoneId);

    /// <inheritdoc/>
    public EnvironmentalCondition? GetEnvironmentalCondition(EnvironmentalConditionType type) =>
        _conditions.GetValueOrDefault(type);
}

/// <summary>
/// Root configuration object for biomes.json.
/// </summary>
internal sealed class BiomeConfiguration
{
    public List<BiomeDefinition> Biomes { get; init; } = [];
    public List<EnvironmentalCondition> EnvironmentalConditions { get; init; } = [];
}
```

---

## 18. BiomeAdjacencyService Implementation

### 18.1 Purpose

Validates realm adjacency rules loaded from configuration.

### 18.2 Definition

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Services/BiomeAdjacencyService.cs`

```csharp
namespace RuneAndRust.Infrastructure.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Validates and queries biome adjacency relationships.
/// </summary>
public sealed class BiomeAdjacencyService : IBiomeAdjacencyService
{
    private readonly Dictionary<string, AdjacencyRule> _rules;
    private readonly HashSet<string> _incompatiblePairs;
    private readonly ILogger<BiomeAdjacencyService> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="BiomeAdjacencyService"/> class.
    /// </summary>
    public BiomeAdjacencyService(
        IConfigurationProvider configProvider,
        ILogger<BiomeAdjacencyService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        var rules = configProvider.LoadConfig<List<AdjacencyRule>>("adjacency_matrix.json")
            ?? GetDefaultRules();

        // Index rules by normalized key
        _rules = rules.ToDictionary(r => r.GetKey());

        // Pre-compute incompatible pairs for fast lookup
        _incompatiblePairs = rules
            .Where(r => r.Compatibility == BiomeCompatibility.Incompatible)
            .Select(r => r.GetKey())
            .ToHashSet();

        _logger.LogInformation(
            "BiomeAdjacencyService initialized: {RuleCount} rules, {IncompatibleCount} incompatible pairs",
            _rules.Count, _incompatiblePairs.Count);
    }

    /// <inheritdoc/>
    public bool CanBiomesNeighbor(RealmId realmA, RealmId realmB)
    {
        if (realmA == realmB) return false;

        var key = AdjacencyRule.GetKey(realmA, realmB);
        return !_incompatiblePairs.Contains(key);
    }

    /// <inheritdoc/>
    public BiomeCompatibility GetCompatibility(RealmId realmA, RealmId realmB)
    {
        if (realmA == realmB)
            return BiomeCompatibility.Compatible; // Same realm is trivially compatible

        var key = AdjacencyRule.GetKey(realmA, realmB);

        if (_rules.TryGetValue(key, out var rule))
            return rule.Compatibility;

        // Default: RequiresTransition for undefined pairs
        return BiomeCompatibility.RequiresTransition;
    }

    /// <inheritdoc/>
    public (int Min, int Max) GetTransitionRoomCount(RealmId realmA, RealmId realmB)
    {
        var compatibility = GetCompatibility(realmA, realmB);

        return compatibility switch
        {
            BiomeCompatibility.Compatible => (0, 0),
            BiomeCompatibility.RequiresTransition => GetTransitionRange(realmA, realmB),
            BiomeCompatibility.Incompatible => throw new InvalidOperationException(
                $"Cannot get transition rooms for incompatible realms: {realmA} and {realmB}"),
            _ => (1, 3)
        };
    }

    /// <inheritdoc/>
    public string? GetTransitionTheme(RealmId fromRealm, RealmId toRealm)
    {
        var key = AdjacencyRule.GetKey(fromRealm, toRealm);
        return _rules.GetValueOrDefault(key)?.TransitionTheme;
    }

    /// <inheritdoc/>
    public IReadOnlyList<RealmId> GetAdjacentRealms(RealmId realmId)
    {
        return Enum.GetValues<RealmId>()
            .Where(r => r != realmId && CanBiomesNeighbor(realmId, r))
            .ToList();
    }

    /// <inheritdoc/>
    public bool ValidateRealmConfiguration(IEnumerable<(RealmId, RealmId)> adjacentPairs)
    {
        foreach (var (a, b) in adjacentPairs)
        {
            if (!CanBiomesNeighbor(a, b))
            {
                _logger.LogWarning(
                    "Invalid realm configuration: {RealmA} cannot neighbor {RealmB}",
                    a, b);
                return false;
            }
        }
        return true;
    }

    private (int Min, int Max) GetTransitionRange(RealmId realmA, RealmId realmB)
    {
        var key = AdjacencyRule.GetKey(realmA, realmB);

        if (_rules.TryGetValue(key, out var rule) && rule.RequiresTransitionRooms)
            return (rule.MinTransitionRooms, rule.MaxTransitionRooms);

        return (1, 3); // Default transition range
    }

    private static List<AdjacencyRule> GetDefaultRules()
    {
        return new List<AdjacencyRule>
        {
            // Critical incompatibilities
            new()
            {
                RealmA = RealmId.Muspelheim,
                RealmB = RealmId.Niflheim,
                Compatibility = BiomeCompatibility.Incompatible
            },
            new()
            {
                RealmA = RealmId.Muspelheim,
                RealmB = RealmId.Vanaheim,
                Compatibility = BiomeCompatibility.Incompatible
            },

            // Compatible pairs
            new()
            {
                RealmA = RealmId.Midgard,
                RealmB = RealmId.Vanaheim,
                Compatibility = BiomeCompatibility.Compatible,
                TransitionTheme = "River ferries upstream... canopy shadows deepen..."
            },
            new()
            {
                RealmA = RealmId.Svartalfheim,
                RealmB = RealmId.Muspelheim,
                Compatibility = BiomeCompatibility.Compatible,
                TransitionTheme = "Volcanic heat fades into geothermal stability..."
            },
            new()
            {
                RealmA = RealmId.Svartalfheim,
                RealmB = RealmId.Helheim,
                Compatibility = BiomeCompatibility.Compatible,
                TransitionTheme = "Elevators descend... decontamination airlocks seal..."
            }
        };
    }
}
```

---

## 19. EnvironmentalDamageResult Record

### 19.1 Purpose

Encapsulates the complete result of applying environmental damage to a character.

### 19.2 Definition

**File:** `src/Core/RuneAndRust.Application/DTOs/EnvironmentalDamageResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Result of applying environmental damage to a character.
/// </summary>
/// <remarks>
/// <para>
/// This record captures all details of an environmental damage application,
/// including the resistance check outcome, damage dealt, and whether
/// mitigations were applied.
/// </para>
/// </remarks>
/// <param name="CharacterId">Target character ID.</param>
/// <param name="ConditionType">The environmental condition that triggered damage.</param>
/// <param name="CheckPassed">Whether the resistance check succeeded.</param>
/// <param name="CheckRoll">The resistance check roll value.</param>
/// <param name="CheckDc">The resistance check DC.</param>
/// <param name="DamageDealt">Damage dealt (0 if check passed).</param>
/// <param name="DamageType">Type of damage applied.</param>
/// <param name="MitigationApplied">Whether character had mitigation.</param>
public sealed record EnvironmentalDamageResult(
    Guid CharacterId,
    EnvironmentalConditionType ConditionType,
    bool CheckPassed,
    int CheckRoll,
    int CheckDc,
    int DamageDealt,
    string DamageType,
    bool MitigationApplied)
{
    /// <summary>
    /// Gets whether damage was actually dealt.
    /// </summary>
    public bool DamageWasDealt => DamageDealt > 0;

    /// <summary>
    /// Gets the margin of success/failure on the check.
    /// </summary>
    public int CheckMargin => CheckRoll - CheckDc;

    /// <summary>
    /// Creates a result for a passed check (no damage).
    /// </summary>
    public static EnvironmentalDamageResult Passed(
        Guid characterId,
        EnvironmentalConditionType conditionType,
        int checkRoll,
        int checkDc,
        string damageType,
        bool mitigationApplied = false) => new(
            characterId, conditionType, true, checkRoll, checkDc,
            0, damageType, mitigationApplied);

    /// <summary>
    /// Creates a result for a failed check (damage dealt).
    /// </summary>
    public static EnvironmentalDamageResult Failed(
        Guid characterId,
        EnvironmentalConditionType conditionType,
        int checkRoll,
        int checkDc,
        int damageDealt,
        string damageType,
        bool mitigationApplied = false) => new(
            characterId, conditionType, false, checkRoll, checkDc,
            damageDealt, damageType, mitigationApplied);

    /// <inheritdoc/>
    public override string ToString() =>
        CheckPassed
            ? $"EnvDamage[{ConditionType}]: Check PASSED (rolled {CheckRoll} vs DC {CheckDc})"
            : $"EnvDamage[{ConditionType}]: {DamageDealt} {DamageType} (rolled {CheckRoll} vs DC {CheckDc})";
}
```

---

## 20. Configuration Files

### 20.1 biomes.json (Starter Template)

**File:** `config/biomes.json`

See the complete JSON configuration in the scope breakdown document. Key structure:

```json
{
    "$schema": "./schemas/biomes.schema.json",
    "biomes": [
        {
            "id": "Midgard",
            "name": "Midgard",
            "subtitle": "The Tamed Ruin",
            "deckNumber": 4,
            "preGlitchFunction": "Civilian Habitation & Agricultural Production",
            "postGlitchState": "Agricultural heartland; most populous realm",
            "baseProperties": {
                "temperatureCelsius": 18,
                "aethericIntensity": 0.3,
                "humidityPercent": 60,
                "lightLevel": 0.7,
                "scaleFactor": 1.0,
                "corrosionRate": 0.2
            },
            "primaryCondition": "None",
            "minVerticalZone": 0,
            "maxVerticalZone": 1,
            "zones": [],
            "flavorQuote": "The Wall is the soul of the Hold.",
            "colorPalette": "green-brown-grey-amber"
        }
    ],
    "environmentalConditions": [
        {
            "type": "IntenseHeat",
            "displayName": "Intense Heat",
            "checkAttribute": "STURDINESS",
            "baseDc": 12,
            "damageDice": "2d6",
            "damageType": "Fire",
            "frequency": "Per Turn",
            "description": "Extreme heat causing burns and exhaustion.",
            "mitigations": ["Fire Resistance", "Cooling equipment"]
        }
    ],
    "adjacencyRules": [
        {
            "realmA": "Muspelheim",
            "realmB": "Niflheim",
            "compatibility": "Incompatible"
        }
    ]
}
```

---

## 21. Logging Specifications

### 21.1 BiomeProvider Logging

| Event | Level | Template |
|-------|-------|----------|
| Initialization | Information | `"BiomeProvider initialized: {BiomeCount} biomes, {ConditionCount} conditions"` |
| Biome not found | Warning | `"Biome not found for realm: {RealmId}"` |
| Configuration error | Error | `"Failed to load biome configuration: {Error}"` |

### 21.2 BiomeAdjacencyService Logging

| Event | Level | Template |
|-------|-------|----------|
| Initialization | Information | `"BiomeAdjacencyService initialized: {RuleCount} rules, {IncompatibleCount} incompatible"` |
| Invalid adjacency | Warning | `"Invalid realm configuration: {RealmA} cannot neighbor {RealmB}"` |
| Adjacency check | Debug | `"Adjacency check: {RealmA} ↔ {RealmB} = {Compatibility}"` |

### 21.3 EnvironmentalConditionService Logging

| Event | Level | Template |
|-------|-------|----------|
| Damage applied | Information | `"Environmental damage: {CharacterId} took {Damage} {DamageType} from {ConditionType}"` |
| Check passed | Debug | `"Environmental check passed: {CharacterId} in {ConditionType} (rolled {Roll} vs DC {Dc})"` |
| Mitigation active | Debug | `"Mitigation active: {CharacterId} has protection against {ConditionType}"` |

---

## 22. Unit Testing Requirements

### 22.1 BiomeProvider Tests (~6 tests)

**File:** `tests/RuneAndRust.Infrastructure.UnitTests/Services/BiomeProviderTests.cs`

| Test Name | Description |
|-----------|-------------|
| `GetAllBiomes_ReturnsNineRealms` | Verifies all 9 realms are loaded |
| `GetBiome_ValidId_ReturnsBiome` | Retrieves specific biome by RealmId |
| `GetBiome_InvalidId_ReturnsNull` | Returns null for invalid realm |
| `GetZonesForRealm_ValidRealm_ReturnsZones` | Retrieves zones for a realm |
| `GetEnvironmentalCondition_ValidType_ReturnsCondition` | Retrieves condition definition |
| `LoadBiomes_InvalidJson_ThrowsValidationException` | Validates JSON schema |

### 22.2 BiomeAdjacencyService Tests (~8 tests)

**File:** `tests/RuneAndRust.Infrastructure.UnitTests/Services/BiomeAdjacencyServiceTests.cs`

| Test Name | Description |
|-----------|-------------|
| `CanBiomesNeighbor_Compatible_ReturnsTrue` | Midgard + Vanaheim = true |
| `CanBiomesNeighbor_RequiresTransition_ReturnsTrue` | Midgard + Alfheim = true |
| `CanBiomesNeighbor_Incompatible_ReturnsFalse` | Muspelheim + Niflheim = false |
| `GetCompatibility_MuspelheimNiflheim_ReturnsIncompatible` | Fire/Ice incompatibility |
| `GetCompatibility_MuspelheimVanaheim_ReturnsIncompatible` | Fire/Bio incompatibility |
| `GetTransitionRoomCount_RequiresTransition_ReturnsRange` | Returns (min, max) tuple |
| `GetAdjacentRealms_Midgard_ReturnsExpectedList` | Lists all Midgard neighbors |
| `ValidateRealmConfiguration_ValidPairs_ReturnsTrue` | Validates sector layout |

### 22.3 EnvironmentalConditionService Tests (~6 tests)

**File:** `tests/RuneAndRust.Infrastructure.UnitTests/Services/EnvironmentalConditionServiceTests.cs`

| Test Name | Description |
|-----------|-------------|
| `GetActiveCondition_Muspelheim_ReturnsIntenseHeat` | Returns realm's primary condition |
| `GetActiveCondition_ZoneOverride_ReturnsOverride` | Zone conditions override realm |
| `CalculateEffectiveDc_BaseZone_ReturnsBaseDc` | DC 12 for standard zone |
| `CalculateEffectiveDc_ModifiedZone_AppliesModifier` | DC 12 + 4 = 16 for Forge Core |
| `ApplyEnvironmentalDamage_CheckFailed_ReturnsDamage` | Applies damage on failed check |
| `ApplyEnvironmentalDamage_HasMitigation_ReducesDamage` | Mitigation reduces effects |

### 22.4 Example Test

```csharp
[TestFixture]
public class BiomeAdjacencyServiceTests
{
    private BiomeAdjacencyService _sut;
    private Mock<IConfigurationProvider> _mockConfig;
    private Mock<ILogger<BiomeAdjacencyService>> _mockLogger;

    [SetUp]
    public void SetUp()
    {
        _mockConfig = new Mock<IConfigurationProvider>();
        _mockLogger = new Mock<ILogger<BiomeAdjacencyService>>();

        _mockConfig.Setup(c => c.LoadConfig<List<AdjacencyRule>>(It.IsAny<string>()))
            .Returns((List<AdjacencyRule>?)null); // Use defaults

        _sut = new BiomeAdjacencyService(_mockConfig.Object, _mockLogger.Object);
    }

    [Test]
    public void CanBiomesNeighbor_MuspelheimNiflheim_ReturnsFalse()
    {
        // Arrange & Act
        var result = _sut.CanBiomesNeighbor(RealmId.Muspelheim, RealmId.Niflheim);

        // Assert
        result.Should().BeFalse("Fire and Ice realms cannot directly neighbor");
    }

    [Test]
    public void CanBiomesNeighbor_MuspelheimVanaheim_ReturnsFalse()
    {
        // Arrange & Act
        var result = _sut.CanBiomesNeighbor(RealmId.Muspelheim, RealmId.Vanaheim);

        // Assert
        result.Should().BeFalse("Fire and Bio realms cannot directly neighbor");
    }

    [Test]
    public void GetCompatibility_MidgardVanaheim_ReturnsCompatible()
    {
        // Arrange & Act
        var result = _sut.GetCompatibility(RealmId.Midgard, RealmId.Vanaheim);

        // Assert
        result.Should().Be(BiomeCompatibility.Compatible);
    }

    [Test]
    public void GetTransitionRoomCount_RequiresTransition_ReturnsRange()
    {
        // Arrange & Act
        var (min, max) = _sut.GetTransitionRoomCount(RealmId.Midgard, RealmId.Alfheim);

        // Assert
        min.Should().BeGreaterOrEqualTo(1);
        max.Should().BeLessOrEqualTo(3);
    }

    [Test]
    public void GetTransitionRoomCount_Incompatible_ThrowsException()
    {
        // Arrange & Act
        var act = () => _sut.GetTransitionRoomCount(RealmId.Muspelheim, RealmId.Niflheim);

        // Assert
        act.Should().Throw<InvalidOperationException>()
            .WithMessage("*incompatible*");
    }

    [Test]
    public void ValidateRealmConfiguration_ValidPairs_ReturnsTrue()
    {
        // Arrange
        var pairs = new[]
        {
            (RealmId.Midgard, RealmId.Vanaheim),
            (RealmId.Svartalfheim, RealmId.Muspelheim),
            (RealmId.Svartalfheim, RealmId.Helheim)
        };

        // Act
        var result = _sut.ValidateRealmConfiguration(pairs);

        // Assert
        result.Should().BeTrue();
    }

    [Test]
    public void ValidateRealmConfiguration_InvalidPairs_ReturnsFalse()
    {
        // Arrange
        var pairs = new[]
        {
            (RealmId.Midgard, RealmId.Vanaheim),
            (RealmId.Muspelheim, RealmId.Niflheim) // Invalid!
        };

        // Act
        var result = _sut.ValidateRealmConfiguration(pairs);

        // Assert
        result.Should().BeFalse();
    }
}
```

---

## 23. Deliverable Checklist

### 23.1 Domain Layer

- [ ] `src/Core/RuneAndRust.Domain/Enums/RealmId.cs`
- [ ] `src/Core/RuneAndRust.Domain/Enums/BiomeCompatibility.cs`
- [ ] `src/Core/RuneAndRust.Domain/Enums/EnvironmentalConditionType.cs`
- [ ] `src/Core/RuneAndRust.Domain/Enums/VerticalZone.cs`
- [ ] `src/Core/RuneAndRust.Domain/ValueObjects/BiomeProperties.cs`
- [ ] `src/Core/RuneAndRust.Domain/ValueObjects/AdjacencyRule.cs`
- [ ] `src/Core/RuneAndRust.Domain/Entities/BiomeDefinition.cs`
- [ ] `src/Core/RuneAndRust.Domain/Entities/BiomeZone.cs`
- [ ] `src/Core/RuneAndRust.Domain/Entities/EnvironmentalCondition.cs`

### 23.2 Application Layer

- [ ] `src/Core/RuneAndRust.Application/Interfaces/IBiomeProvider.cs`
- [ ] `src/Core/RuneAndRust.Application/Interfaces/IBiomeAdjacencyService.cs`
- [ ] `src/Core/RuneAndRust.Application/Interfaces/IEnvironmentalConditionService.cs`
- [ ] `src/Core/RuneAndRust.Application/DTOs/EnvironmentalDamageResult.cs`

### 23.3 Infrastructure Layer

- [ ] `src/Infrastructure/RuneAndRust.Infrastructure/Services/BiomeProvider.cs`
- [ ] `src/Infrastructure/RuneAndRust.Infrastructure/Services/BiomeAdjacencyService.cs`

### 23.4 Configuration

- [ ] `config/biomes.json`
- [ ] `config/schemas/biomes.schema.json`
- [ ] `config/adjacency_matrix.json`

### 23.5 Tests

- [ ] `tests/RuneAndRust.Infrastructure.UnitTests/Services/BiomeProviderTests.cs`
- [ ] `tests/RuneAndRust.Infrastructure.UnitTests/Services/BiomeAdjacencyServiceTests.cs`
- [ ] `tests/RuneAndRust.Infrastructure.UnitTests/Services/EnvironmentalConditionServiceTests.cs`

### 23.6 Documentation

- [ ] Update `docs/design/v0.19.x/v0.19.0-scope-breakdown.md` (mark complete)
- [ ] Create `docs/changelogs/v0.19.0a-changelog.md`

---

## 24. Acceptance Criteria

### 24.1 Build Verification

- [ ] Solution builds without errors
- [ ] Solution builds without warnings in new code

### 24.2 Test Verification

- [ ] All ~20 new unit tests pass
- [ ] All existing unit tests continue to pass

### 24.3 Functional Verification

- [ ] All 9 RealmId enum values defined with correct deck numbers
- [ ] BiomeDefinition stores all required properties from design docs
- [ ] BiomeZone supports property overrides and DC modifiers
- [ ] EnvironmentalCondition defines all hazard types with mechanics
- [ ] IBiomeProvider loads and retrieves biome definitions
- [ ] IBiomeAdjacencyService validates adjacency rules correctly
- [ ] Muspelheim↔Niflheim adjacency returns Incompatible
- [ ] Muspelheim↔Vanaheim adjacency returns Incompatible
- [ ] JSON schema validates biome configuration files
- [ ] All public members have XML documentation

---

## 25. Dependencies

### 25.1 Required Prerequisites

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| Character Stats | v0.18.x | Required | For environmental check attributes |
| Dice System | v0.6.x | Required | For damage rolls |
| Status Effect Service | v0.10.x | Required | For condition application |

### 25.2 Provides to Later Phases

| Item | Consumer | Purpose |
|------|----------|---------|
| RealmId | v0.19.1-v0.19.6 | Realm identification |
| BiomeDefinition | v0.19.1-v0.19.6 | Realm data structure |
| IBiomeProvider | Room generation | Biome retrieval |
| IBiomeAdjacencyService | Sector layout | Adjacency validation |
| IEnvironmentalConditionService | Combat system | Hazard application |

---

## 26. Future Considerations

### 26.1 v0.19.1 (Midgard Implementation)

- Populate Midgard biome with all four sub-biomes
- Define territorial hazards for Greatwood, Scar, Mires, Fjords
- Implement faction spawn pools for Midgard

### 26.2 v0.19.2 (Svartalfheim & Helheim)

- Light-based hazard system for Total Darkness
- Toxic atmosphere mechanics for Helheim
- Vertical strata implementation

### 26.3 v0.19.6 (Biome Integration)

- Cross-biome transition room generation
- Environmental property interpolation
- Travel time calculations between realms

---

*Document Version: 1.0*
*Last Updated: 2026-01-28*
*Author: Claude (AI Assistant)*
