# v0.18.5e Design Specification: ITraumaEconomyService & Config

**Version:** 0.18.5e
**Parent:** v0.18.5 (Resource Integration / Trauma Economy Integration)
**Prerequisites:** v0.18.5a-d (All prior integration phases), All v0.18.0-4
**Status:** Design Complete
**Estimated Unit Tests:** ~3

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [ITraumaEconomyService Interface](#5-itraumaeconomyservice-interface)
6. [TraumaEconomyService Implementation](#6-traumaeconomyservice-implementation)
7. [Configuration Schema](#7-configuration-schema)
8. [JSON Configuration File](#8-json-configuration-file)
9. [Dependency Injection Setup](#9-dependency-injection-setup)
10. [Logging Specifications](#10-logging-specifications)
11. [Unit Testing Requirements](#11-unit-testing-requirements)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Dependencies](#14-dependencies)
15. [Future Considerations](#15-future-considerations)

---

## 1. Executive Summary

This design specification defines the **unified service layer and configuration** that provides a single interface for all trauma economy operations.

v0.18.5e establishes the **Orchestration Service** by defining:

- `ITraumaEconomyService` interface — unified contract
- `TraumaEconomyService` implementation — orchestrates all handlers
- `trauma-economy.json` configuration — centralized settings
- Dependency injection registration — wires all components

### Key Deliverables

| Category              | Items                                        |
| --------------------- | -------------------------------------------- |
| **Interfaces**        | `ITraumaEconomyService`                      |
| **Services**          | `TraumaEconomyService`                       |
| **Configuration**     | `trauma-economy.json`                        |
| **DI Extensions**     | `ServiceCollectionExtensions` for registration |
| **Tests**             | ~3 unit tests                                |

### Service Architecture Overview

```
ITraumaEconomyService (contract)
    ↓
TraumaEconomyService (orchestrator)
    ├─ UnifiedDamageHandler
    ├─ UnifiedRestHandler
    ├─ UnifiedTurnHandler
    ├─ TraumaEconomyState
    └─ All v0.18.0-4 services
```

---

## 2. Feature Overview

```
v0.18.5e Features
└── Unified Service Layer & Configuration
    │
    ├── ITraumaEconomyService Interface
    │   ├── State Access
    │   │   ├── GetState(characterId)
    │   │   └── CreateSnapshot(characterId)
    │   │
    │   ├── Unified Operations
    │   │   ├── ProcessDamage(characterId, damage, context)
    │   │   ├── ProcessRest(characterId, restType, partyContext)
    │   │   ├── ProcessTurnStart(characterId, isInCombat)
    │   │   └── ProcessTurnEnd(characterId, isInCombat)
    │   │
    │   └── Query Methods
    │       ├── GetEffectiveMaxHp()
    │       ├── GetEffectiveMaxAp()
    │       ├── GetTotalDefensePenalty()
    │       ├── GetTotalSkillPenalty()
    │       ├── IsInCriticalState()
    │       ├── IsInTerminalState()
    │       └── GetActiveWarnings()
    │
    ├── TraumaEconomyService Implementation
    │   ├── Dependency injection constructor
    │   ├── All interface methods
    │   ├── Logging for all operations
    │   └── Configuration loading
    │
    └── trauma-economy.json Configuration
        ├── Integration settings
        ├── Damage formulas
        ├── Rest mechanics
        ├── Turn effects
        ├── Warning messages
        └── Threshold values
```

---

## 3. Architecture Diagrams

### 3.1 Service Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      TRAUMA ECONOMY SERVICE LAYER                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐│
│  │                  ITraumaEconomyService (Interface)                    ││
│  ├─────────────────────────────────────────────────────────────────────┤│
│  │  + GetState(characterId) : TraumaEconomyState                       ││
│  │  + CreateSnapshot(characterId) : TraumaEconomySnapshot              ││
│  │  + ProcessDamage(...) : DamageIntegrationResult                     ││
│  │  + ProcessRest(...) : RestIntegrationResult                         ││
│  │  + ProcessTurnStart(...) : TurnIntegrationResult                    ││
│  │  + ProcessTurnEnd(...) : TurnIntegrationResult                      ││
│  │  + GetEffectiveMaxHp/Ap() : int                                     ││
│  │  + IsInCriticalState() : bool                                       ││
│  │  + GetActiveWarnings() : IReadOnlyList<string>                      ││
│  └─────────────────────────────────────────────────────────────────────┘│
│                               ▲                                           │
│                               │                                           │
│  ┌────────────────────────────┴─────────────────────────────────────────┐│
│  │               TraumaEconomyService (Implementation)                    ││
│  ├──────────────────────────────────────────────────────────────────────┤│
│  │                                                                        ││
│  │  Dependencies:                                                         ││
│  │  • IStressService                                                     ││
│  │  • ICorruptionService                                                 ││
│  │  • ICpsService (v0.18.2d)                                            ││
│  │  • ITraumaService                                                     ││
│  │  • IRageService                                                       ││
│  │  • IMomentumService                                                   ││
│  │  • ICoherenceService                                                  ││
│  │  • ISpecializationProvider                                            ││
│  │  • IDiceService                                                       ││
│  │  • UnifiedDamageHandler                                              ││
│  │  • UnifiedRestHandler                                                ││
│  │  • UnifiedTurnHandler                                                ││
│  │  • ITraumaEconomyConfig                                              ││
│  │  • ILogger<TraumaEconomyService>                                     ││
│  │                                                                        ││
│  │  Methods:                                                             ││
│  │  - GetState() → Aggregates all sub-systems                          ││
│  │  - ProcessDamage() → Delegates to UnifiedDamageHandler              ││
│  │  - ProcessRest() → Delegates to UnifiedRestHandler                  ││
│  │  - ProcessTurnStart/End() → Delegates to UnifiedTurnHandler         ││
│  │  - Query methods → Compute from aggregated state                    ││
│  │                                                                        ││
│  └────────────────────────────────────────────────────────────────────┬─┘│
│                                                                         │  │
└─────────────────────────────────────────────────────────────────────────┘  │
                                                                             │
                ┌────────────────────────────────────────┐                   │
                │                                        │                   │
                ▼                                        ▼                   ▼
         ┌─────────────────┐                  ┌────────────────────────────┐
         │    Handlers     │                  │  Configuration (JSON)       │
         ├─────────────────┤                  ├────────────────────────────┤
         │ • Damage        │                  │ • Damage formulas          │
         │ • Rest          │                  │ • Rest mechanics           │
         │ • Turn          │                  │ • Turn effects             │
         └─────────────────┘                  │ • Thresholds               │
                                              │ • Warning messages         │
                                              └────────────────────────────┘
```

### 3.2 Service Integration Flow

```
         API/Handler
            │
            ▼
┌─────────────────────────────────────────┐
│  ITraumaEconomyService.ProcessDamage()  │
└──────────┬──────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────┐
│ TraumaEconomyService.ProcessDamage()    │
├─────────────────────────────────────────┤
│ 1. Load config from JSON                │
│ 2. Delegate to UnifiedDamageHandler     │
│ 3. Log result                           │
│ 4. Return DamageIntegrationResult       │
└──────────┬──────────────────────────────┘
           │
      ┌────┴────┬───────────────┬──────────┐
      │          │               │          │
      ▼          ▼               ▼          ▼
   Stress    Corruption      Specialization  Trauma
   Service    Service        Services        Service
      │          │               │          │
      └────┬─────┴───────────────┴──────────┘
           │
           ▼
    Character State Updated
```

---

## 4. User Stories

### US-18.5e-1: Unified Service Interface

**As a** game system
**I want to** interact with trauma economy through a single unified interface
**So that** I don't need to know about individual sub-systems

**Acceptance Criteria:**

- ITraumaEconomyService provides complete interface
- All operations available through single service
- No direct calls needed to sub-services
- Interface is stable and well-documented
- Service is testable and mockable

### US-18.5e-2: Configuration Management

**As a** game designer
**I want to** adjust trauma economy mechanics through configuration
**So that** I can tune game balance without code changes

**Acceptance Criteria:**

- All numeric values configurable via JSON
- Configuration loads at startup
- Configuration validated on load
- Invalid config produces clear error
- Default config bundled with code

### US-18.5e-3: Dependency Injection

**As a** application startup
**I want to** register all trauma economy services automatically
**So that** setup is consistent and minimal

**Acceptance Criteria:**

- Extension method provides one-line registration
- All sub-services registered
- Handlers registered
- Configuration service registered
- Service lifetimes appropriate (singleton for config, etc)

### US-18.5e-4: Query System State

**As a** UI or gameplay system
**I want to** query derived trauma economy state
**So that** I can display and respond to unified information

**Acceptance Criteria:**

- GetState() returns fully populated TraumaEconomyState
- Queries return computed properties
- Query results are consistent
- Query methods fast and efficient

---

## 5. ITraumaEconomyService Interface

### 5.1 Purpose

Public contract that defines all trauma economy operations available to game systems.

### 5.2 Definition

**File:** `src/Application/RuneAndRust.Application/Services/ITraumaEconomyService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Unified service contract for trauma economy operations.
/// </summary>
/// <remarks>
/// <para>
/// Provides a single interface for all trauma economy interactions:
/// • State querying (GetState, GetSnapshots)
/// • Unified operations (damage, rest, turns)
/// • Derived properties (effective HP, penalties, warnings)
/// </para>
/// <para>
/// Implementations should:
/// • Load configuration from trauma-economy.json
/// • Delegate to appropriate sub-handlers
/// • Log all operations
/// • Ensure consistency across systems
/// </para>
/// </remarks>
public interface ITraumaEconomyService
{
    /// <summary>
    /// Gets the complete current trauma economy state for a character.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>Fully populated TraumaEconomyState.</returns>
    TraumaEconomyState GetState(Guid characterId);

    /// <summary>
    /// Creates a point-in-time snapshot of trauma economy state.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>Immutable snapshot.</returns>
    TraumaEconomySnapshot CreateSnapshot(Guid characterId);

    /// <summary>
    /// Processes damage through all trauma economy systems.
    /// </summary>
    /// <param name="characterId">The character taking damage.</param>
    /// <param name="damage">The damage amount.</param>
    /// <param name="context">Damage context (critical, source, etc).</param>
    /// <returns>Complete damage integration result.</returns>
    DamageIntegrationResult ProcessDamage(
        Guid characterId,
        int damage,
        DamageContext context);

    /// <summary>
    /// Processes rest through all trauma economy systems.
    /// </summary>
    /// <param name="characterId">The character resting.</param>
    /// <param name="restType">The type of rest.</param>
    /// <param name="partyContext">Optional party context for group effects.</param>
    /// <returns>Complete rest integration result.</returns>
    RestIntegrationResult ProcessRest(
        Guid characterId,
        RestType restType,
        PartyContext? partyContext = null);

    /// <summary>
    /// Processes turn start for a character.
    /// </summary>
    /// <param name="characterId">The character.</param>
    /// <param name="turnNumber">The turn number.</param>
    /// <param name="isInCombat">Whether character is in combat.</param>
    /// <returns>Complete turn integration result.</returns>
    TurnIntegrationResult ProcessTurnStart(
        Guid characterId,
        int turnNumber,
        bool isInCombat);

    /// <summary>
    /// Processes turn end for a character.
    /// </summary>
    /// <param name="characterId">The character.</param>
    /// <param name="turnNumber">The turn number.</param>
    /// <param name="isInCombat">Whether character is in combat.</param>
    /// <param name="environmentalStress">Optional environmental stress this turn.</param>
    /// <returns>Complete turn integration result.</returns>
    TurnIntegrationResult ProcessTurnEnd(
        Guid characterId,
        int turnNumber,
        bool isInCombat,
        int? environmentalStress = null);

    // ========== Query Methods ==========

    /// <summary>
    /// Gets the effective maximum hit points (after corruption penalty).
    /// </summary>
    int GetEffectiveMaxHp(Guid characterId);

    /// <summary>
    /// Gets the effective maximum action points (after corruption penalty).
    /// </summary>
    int GetEffectiveMaxAp(Guid characterId);

    /// <summary>
    /// Gets the total defense penalty from stress and other sources.
    /// </summary>
    int GetTotalDefensePenalty(Guid characterId);

    /// <summary>
    /// Gets the total skill penalty from stress, CPS, and other sources.
    /// </summary>
    int GetTotalSkillPenalty(Guid characterId);

    /// <summary>
    /// Gets whether the character is in critical state (any system ≥ 80).
    /// </summary>
    bool IsInCriticalState(Guid characterId);

    /// <summary>
    /// Gets whether the character is in terminal state (any system ≥ 100).
    /// </summary>
    bool IsInTerminalState(Guid characterId);

    /// <summary>
    /// Gets all active warning messages for the character.
    /// </summary>
    IReadOnlyList<string> GetActiveWarnings(Guid characterId);

    /// <summary>
    /// Gets the highest system percentage (0-1) for UI display.
    /// </summary>
    double GetHighestSystemPercentage(Guid characterId);
}

/// <summary>
/// Context for damage events.
/// </summary>
public record DamageContext(
    bool IsCriticalHit = false,
    bool IsInterrupt = false,
    bool IsAllyDeathEvent = false,
    Guid? AttackerId = null);

/// <summary>
/// Context for party-wide effects.
/// </summary>
public record PartyContext(
    IReadOnlyList<Guid> Members);
```

---

## 6. TraumaEconomyService Implementation

### 6.1 Purpose

Implementation of ITraumaEconomyService that orchestrates all handlers and sub-services.

### 6.2 Definition

**File:** `src/Application/RuneAndRust.Application/Services/TraumaEconomyService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Domain.Enums;
using Microsoft.Extensions.Logging;

/// <summary>
/// Orchestrates all trauma economy operations.
/// </summary>
/// <remarks>
/// <para>
/// Implements ITraumaEconomyService by:
/// • Aggregating state from all sub-systems
/// • Delegating to specialized handlers (Damage, Rest, Turn)
/// • Loading configuration on demand
/// • Logging all operations
/// </para>
/// </remarks>
public class TraumaEconomyService : ITraumaEconomyService
{
    private readonly IStressService _stressService;
    private readonly ICorruptionService _corruptionService;
    private readonly ICpsService _cpsService;
    private readonly ITraumaService _traumaService;
    private readonly IRageService? _rageService;
    private readonly IMomentumService? _momentumService;
    private readonly ICoherenceService? _coherenceService;
    private readonly ISpecializationProvider _specializationProvider;
    private readonly IDiceService _diceService;
    private readonly ITraumaEconomyConfiguration _configuration;
    private readonly UnifiedDamageHandler _damageHandler;
    private readonly UnifiedRestHandler _restHandler;
    private readonly UnifiedTurnHandler _turnHandler;
    private readonly ILogger<TraumaEconomyService> _logger;

    public TraumaEconomyService(
        IStressService stressService,
        ICorruptionService corruptionService,
        ICpsService cpsService,
        ITraumaService traumaService,
        ISpecializationProvider specializationProvider,
        IDiceService diceService,
        ITraumaEconomyConfiguration configuration,
        UnifiedDamageHandler damageHandler,
        UnifiedRestHandler restHandler,
        UnifiedTurnHandler turnHandler,
        IRageService? rageService = null,
        IMomentumService? momentumService = null,
        ICoherenceService? coherenceService = null,
        ILogger<TraumaEconomyService>? logger = null)
    {
        _stressService = stressService;
        _corruptionService = corruptionService;
        _cpsService = cpsService;
        _traumaService = traumaService;
        _specializationProvider = specializationProvider;
        _diceService = diceService;
        _configuration = configuration;
        _damageHandler = damageHandler;
        _restHandler = restHandler;
        _turnHandler = turnHandler;
        _rageService = rageService;
        _momentumService = momentumService;
        _coherenceService = coherenceService;
        _logger = logger ?? NullLogger<TraumaEconomyService>.Instance;
    }

    /// <inheritdoc/>
    public TraumaEconomyState GetState(Guid characterId)
    {
        _logger.LogDebug("Aggregating trauma economy state for {CharacterId}", characterId);

        try
        {
            var stressState = _stressService.GetStress(characterId);
            var corruptionState = _corruptionService.GetCorruption(characterId);
            var cpsState = CpsState.Create(stressState.CurrentStress);
            var traumas = _traumaService.GetTraumas(characterId);
            var specializationType = _specializationProvider.GetSpecializationType(characterId);

            object? specializationResource = null;
            if (specializationType == "rage" && _rageService != null)
                specializationResource = _rageService.GetRage(characterId);
            else if (specializationType == "momentum" && _momentumService != null)
                specializationResource = _momentumService.GetMomentum(characterId);
            else if (specializationType == "coherence" && _coherenceService != null)
                specializationResource = _coherenceService.GetCoherence(characterId);

            var state = TraumaEconomyState.Create(
                characterId,
                stressState,
                corruptionState,
                cpsState,
                traumas,
                specializationResource,
                specializationType
            );

            _logger.LogDebug("State aggregated: {@State}", state);
            return state;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error aggregating trauma economy state for {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public TraumaEconomySnapshot CreateSnapshot(Guid characterId)
    {
        _logger.LogDebug("Creating snapshot for {CharacterId}", characterId);

        var state = GetState(characterId);
        var snapshot = TraumaEconomySnapshot.Create(state);

        _logger.LogDebug("Snapshot created: {@Snapshot}", snapshot);
        return snapshot;
    }

    /// <inheritdoc/>
    public DamageIntegrationResult ProcessDamage(
        Guid characterId,
        int damage,
        DamageContext context)
    {
        _logger.LogDebug("Processing damage: {CharacterId} takes {Damage}", characterId, damage);

        try
        {
            var result = _damageHandler.ProcessDamage(characterId, damage, context);
            _logger.LogInformation("Damage processed: {@Result}", result);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing damage for {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public RestIntegrationResult ProcessRest(
        Guid characterId,
        RestType restType,
        PartyContext? partyContext = null)
    {
        _logger.LogDebug("Processing {RestType} rest for {CharacterId}", restType, characterId);

        try
        {
            var result = _restHandler.ProcessRest(characterId, restType, partyContext);
            _logger.LogInformation("Rest processed: {@Result}", result);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing rest for {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public TurnIntegrationResult ProcessTurnStart(
        Guid characterId,
        int turnNumber,
        bool isInCombat)
    {
        _logger.LogDebug("Processing turn start: {CharacterId} turn {Turn}", characterId, turnNumber);

        try
        {
            var result = _turnHandler.ProcessTurnStart(characterId, turnNumber, isInCombat);
            _logger.LogInformation("Turn start processed: {@Result}", result);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing turn start for {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public TurnIntegrationResult ProcessTurnEnd(
        Guid characterId,
        int turnNumber,
        bool isInCombat,
        int? environmentalStress = null)
    {
        _logger.LogDebug("Processing turn end: {CharacterId} turn {Turn}", characterId, turnNumber);

        try
        {
            var result = _turnHandler.ProcessTurnEnd(characterId, turnNumber, isInCombat, environmentalStress);
            _logger.LogInformation("Turn end processed: {@Result}", result);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing turn end for {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public int GetEffectiveMaxHp(Guid characterId) =>
        GetState(characterId).EffectiveMaxHp;

    /// <inheritdoc/>
    public int GetEffectiveMaxAp(Guid characterId) =>
        GetState(characterId).EffectiveMaxAp;

    /// <inheritdoc/>
    public int GetTotalDefensePenalty(Guid characterId) =>
        GetState(characterId).TotalDefensePenalty;

    /// <inheritdoc/>
    public int GetTotalSkillPenalty(Guid characterId) =>
        GetState(characterId).TotalSkillPenalty;

    /// <inheritdoc/>
    public bool IsInCriticalState(Guid characterId) =>
        GetState(characterId).IsCriticalState;

    /// <inheritdoc/>
    public bool IsInTerminalState(Guid characterId) =>
        GetState(characterId).IsTerminalState;

    /// <inheritdoc/>
    public IReadOnlyList<string> GetActiveWarnings(Guid characterId) =>
        GetState(characterId).ActiveWarnings;

    /// <inheritdoc/>
    public double GetHighestSystemPercentage(Guid characterId) =>
        GetState(characterId).GetHighestSystemPercentage();
}
```

---

## 7. Configuration Schema

### 7.1 Configuration Structure

The configuration is organized into logical sections:

```
{
  "version": "1.0",
  "integration": {
    "damageToStress": { ... },
    "restRecovery": { ... },
    "turnEffects": { ... },
    "thresholds": { ... }
  },
  "warningMessages": { ... }
}
```

### 7.2 Configuration Interface

**File:** `src/Application/RuneAndRust.Application/Configuration/ITraumaEconomyConfiguration.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration contract for trauma economy settings.
/// </summary>
public interface ITraumaEconomyConfiguration
{
    // Damage Integration
    bool DamageToStressEnabled { get; }
    string DamageToStressFormula { get; }
    int CriticalStressBonus { get; }
    int NearDeathStressBonus { get; }
    double NearDeathThreshold { get; }
    int AllyDownStress { get; }

    // Rest Recovery
    int ShortRestRageReset { get; }
    int ShortRestMomentumReset { get; }
    string ShortRestStressFormula { get; }

    int LongRestCoherenceRestore { get; }
    bool LongRestCpsCanImprove { get; }

    int SanctuaryRestBonusStage { get; }

    // Turn Effects
    int RageDecayOutOfCombat { get; }
    int MomentumDecayIdle { get; }
    int ApotheosisStressCostPerTurn { get; }
    int ApotheosisForceExitAt { get; }

    // Thresholds
    int CriticalWarningThreshold { get; }
    int TerminalTriggerThreshold { get; }

    // Warning Messages
    string StressHighMessage { get; }
    string CorruptionHighMessage { get; }
    string CpsDangerousMessage { get; }
    string MultipleSystemsCriticalMessage { get; }
}
```

---

## 8. JSON Configuration File

### 8.1 Default Configuration

**File:** `config/trauma-economy.json`

```json
{
  "version": "1.0",
  "description": "Trauma Economy Integration Configuration",
  "integration": {
    "damageToStress": {
      "enabled": true,
      "formula": "floor(damage / 10)",
      "criticalBonus": 5,
      "nearDeathBonus": 10,
      "nearDeathThreshold": 0.25,
      "allyDownStress": 15
    },
    "restRecovery": {
      "shortRest": {
        "stressFormula": "5d4 + will",
        "rageReset": true,
        "momentumReset": true,
        "coherenceGain": 0
      },
      "longRest": {
        "stressRecovery": "full",
        "rageReset": true,
        "momentumReset": true,
        "coherenceReset": 50,
        "cpsCanImprove": true
      },
      "sanctuary": {
        "stressRecovery": "full",
        "cpsImprovementBonus": 1,
        "traumaCheckDCReduction": 1
      }
    },
    "turnEffects": {
      "rageDecayOutOfCombat": 10,
      "momentumDecayIdle": 15,
      "coherenceMeditationGain": 5,
      "apotheosisStressCostPerTurn": 10,
      "apotheosisForceExitAt": 100
    },
    "thresholds": {
      "stressWarning": 70,
      "stressCritical": 80,
      "stressTerminal": 100,
      "corruptionWarning": 70,
      "corruptionCritical": 80,
      "corruptionTerminal": 100,
      "cpsPanicTable": 60,
      "multipleSystemsWarning": 80
    }
  },
  "warningMessages": {
    "stressHigh": "Your mind strains under the weight of reality.",
    "stressCritical": "Your sanity fractures under the weight of reality.",
    "stressTerminal": "Your mind spirals toward total collapse.",
    "corruptionHigh": "The Blight's touch grows stronger.",
    "corruptionCritical": "Corruption ravages your form.",
    "corruptionTerminal": "The Blight consumes your very essence.",
    "cpsDangerous": "Reality's edges begin to blur.",
    "cpsPanicActive": "Your grip on reality is slipping—Panic Table active.",
    "multipleSystemsCritical": "Your body and mind fail in tandem.",
    "traumaWarning": "You carry unhealed trauma.",
    "nearTerminal": "Your existence hangs by a thread."
  },
  "specialization": {
    "berserker": {
      "rageSoakBonus": 0.1,
      "rageDamageGain": 0.2,
      "partyBonusStressReduction": 10
    },
    "stormBlade": {
      "momentumDecayRate": 15,
      "criticalMomentumLoss": 20
    },
    "arcanist": {
      "apotheosisEnabled": true,
      "coherenceRemeditation": 5
    }
  }
}
```

### 8.2 Configuration Loading

**File:** `src/Application/RuneAndRust.Application/Configuration/TraumaEconomyConfiguration.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

using Microsoft.Extensions.Configuration;

/// <summary>
/// Loads trauma economy configuration from JSON.
/// </summary>
public class TraumaEconomyConfiguration : ITraumaEconomyConfiguration
{
    private readonly IConfiguration _configuration;

    public TraumaEconomyConfiguration(IConfiguration configuration)
    {
        _configuration = configuration;
        Validate();
    }

    // Damage Integration Properties
    public bool DamageToStressEnabled =>
        _configuration.GetValue("integration:damageToStress:enabled", true);

    public string DamageToStressFormula =>
        _configuration.GetValue("integration:damageToStress:formula", "floor(damage / 10)");

    public int CriticalStressBonus =>
        _configuration.GetValue("integration:damageToStress:criticalBonus", 5);

    public int NearDeathStressBonus =>
        _configuration.GetValue("integration:damageToStress:nearDeathBonus", 10);

    public double NearDeathThreshold =>
        _configuration.GetValue("integration:damageToStress:nearDeathThreshold", 0.25);

    public int AllyDownStress =>
        _configuration.GetValue("integration:damageToStress:allyDownStress", 15);

    // Rest Recovery Properties
    public int ShortRestRageReset =>
        _configuration.GetValue("integration:restRecovery:shortRest:rageReset", 1) > 0 ? 1 : 0;

    public int ShortRestMomentumReset =>
        _configuration.GetValue("integration:restRecovery:shortRest:momentumReset", 1) > 0 ? 1 : 0;

    public string ShortRestStressFormula =>
        _configuration.GetValue("integration:restRecovery:shortRest:stressFormula", "5d4 + will");

    public int LongRestCoherenceRestore =>
        _configuration.GetValue("integration:restRecovery:longRest:coherenceReset", 50);

    public bool LongRestCpsCanImprove =>
        _configuration.GetValue("integration:restRecovery:longRest:cpsCanImprove", true);

    public int SanctuaryRestBonusStage =>
        _configuration.GetValue("integration:restRecovery:sanctuary:cpsImprovementBonus", 1);

    // Turn Effects Properties
    public int RageDecayOutOfCombat =>
        _configuration.GetValue("integration:turnEffects:rageDecayOutOfCombat", 10);

    public int MomentumDecayIdle =>
        _configuration.GetValue("integration:turnEffects:momentumDecayIdle", 15);

    public int ApotheosisStressCostPerTurn =>
        _configuration.GetValue("integration:turnEffects:apotheosisStressCostPerTurn", 10);

    public int ApotheosisForceExitAt =>
        _configuration.GetValue("integration:turnEffects:apotheosisForceExitAt", 100);

    // Thresholds Properties
    public int CriticalWarningThreshold =>
        _configuration.GetValue("integration:thresholds:criticalWarning", 80);

    public int TerminalTriggerThreshold =>
        _configuration.GetValue("integration:thresholds:terminalTrigger", 100);

    // Warning Messages
    public string StressHighMessage =>
        _configuration.GetValue("warningMessages:stressHigh", "Your mind strains under the weight of reality.");

    public string CorruptionHighMessage =>
        _configuration.GetValue("warningMessages:corruptionHigh", "The Blight's touch grows stronger.");

    public string CpsDangerousMessage =>
        _configuration.GetValue("warningMessages:cpsDangerous", "Reality's edges begin to blur.");

    public string MultipleSystemsCriticalMessage =>
        _configuration.GetValue("warningMessages:multipleSystemsCritical", "Your body and mind fail in tandem.");

    private void Validate()
    {
        // TODO: Validate configuration values are within acceptable ranges
        if (CriticalWarningThreshold < 0 || CriticalWarningThreshold > 100)
            throw new InvalidOperationException("Critical warning threshold must be 0-100");

        if (TerminalTriggerThreshold < 0 || TerminalTriggerThreshold > 100)
            throw new InvalidOperationException("Terminal trigger threshold must be 0-100");

        if (TerminalTriggerThreshold <= CriticalWarningThreshold)
            throw new InvalidOperationException("Terminal threshold must be higher than critical");
    }
}
```

---

## 9. Dependency Injection Setup

### 9.1 Service Registration Extension

**File:** `src/Application/RuneAndRust.Application/Extensions/ServiceCollectionExtensions.cs`

```csharp
namespace RuneAndRust.Application.Extensions;

using RuneAndRust.Application.Configuration;
using RuneAndRust.Application.Services;
using Microsoft.Extensions.DependencyInjection;

/// <summary>
/// Extension methods for registering trauma economy services.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds trauma economy services to the service collection.
    /// </summary>
    /// <remarks>
    /// Registers:
    /// • ITraumaEconomyService singleton
    /// • ITraumaEconomyConfiguration singleton
    /// • All integration handlers
    /// • All required sub-services (assumed already registered)
    /// </remarks>
    public static IServiceCollection AddTraumaEconomy(this IServiceCollection services)
    {
        // Configuration
        services.AddSingleton<ITraumaEconomyConfiguration, TraumaEconomyConfiguration>();

        // Handlers
        services.AddScoped<UnifiedDamageHandler>();
        services.AddScoped<UnifiedRestHandler>();
        services.AddScoped<UnifiedTurnHandler>();

        // Main Service
        services.AddScoped<ITraumaEconomyService, TraumaEconomyService>();

        return services;
    }
}
```

### 9.2 Startup Configuration

```csharp
// In Program.cs or Startup.cs:

public void ConfigureServices(IServiceCollection services)
{
    // ... other services ...

    // Register all v0.18.0-4 services first
    services.AddStressSystem();
    services.AddCorruptionSystem();
    services.AddCpsSystem();
    services.AddTraumaSystem();
    services.AddSpecializationSystem();
    services.AddRageSystem();
    services.AddMomentumSystem();
    services.AddCoherenceSystem();
    services.AddDiceSystem();

    // Then register trauma economy integration
    services.AddTraumaEconomy();

    // Load configuration from file
    var config = new ConfigurationBuilder()
        .AddJsonFile("config/trauma-economy.json", optional: false, reloadOnChange: false)
        .Build();
    services.Configure<TraumaEconomyConfiguration>(config.GetSection("trauma-economy"));
}
```

---

## 10. Logging Specifications

### 10.1 Service Layer Logging

| Event                          | Level       | Template                                             |
| ------------------------------ | ----------- | ---------------------------------------------------- |
| State Aggregation Started      | Debug       | `"Aggregating state for {CharacterId}"`              |
| State Aggregation Complete     | Debug       | `"State aggregated: {@State}"`                        |
| Snapshot Created               | Debug       | `"Snapshot created: {@Snapshot}"`                    |
| Damage Processing Started      | Debug       | `"Processing damage: {CharacterId} takes {Damage}"`  |
| Damage Processing Complete     | Information | `"Damage processed: {@Result}"`                      |
| Rest Processing Started        | Debug       | `"Processing {RestType} rest for {CharacterId}"`     |
| Rest Processing Complete       | Information | `"Rest processed: {@Result}"`                        |
| Turn Start Processing Complete | Information | `"Turn start processed: {@Result}"`                  |
| Turn End Processing Complete   | Information | `"Turn end processed: {@Result}"`                    |
| Service Error                  | Error       | `"Error in trauma economy service: {Exception}"`     |

---

## 11. Unit Testing Requirements

### 11.1 Test File Location

**File:** `tests/RuneAndRust.Application.UnitTests/Services/TraumaEconomyServiceTests.cs`

### 11.2 Required Tests

| Test Name                                     | Description                      |
| --------------------------------------------- | -------------------------------- |
| `GetState_WithValidCharacter_ReturnsPopulated` | State aggregation works          |
| `ProcessDamage_DelegatesToHandler_ReturnsResult` | Damage delegated correctly        |
| `GetActiveWarnings_WithCriticalSystem_ReturnsMessages` | Query methods functional  |

### 11.3 Example Test

```csharp
[TestFixture]
public class TraumaEconomyServiceTests
{
    private TraumaEconomyService _service;
    private IStressService _stressService;
    private ICorruptionService _corruptionService;

    [SetUp]
    public void SetUp()
    {
        _stressService = Substitute.For<IStressService>();
        _corruptionService = Substitute.For<ICorruptionService>();
        var cpsService = Substitute.For<ICpsService>();
        var traumaService = Substitute.For<ITraumaService>();
        var specProvider = Substitute.For<ISpecializationProvider>();
        var diceService = Substitute.For<IDiceService>();
        var config = Substitute.For<ITraumaEconomyConfiguration>();
        var damageHandler = Substitute.For<UnifiedDamageHandler>();
        var restHandler = Substitute.For<UnifiedRestHandler>();
        var turnHandler = Substitute.For<UnifiedTurnHandler>();

        var stressState = StressState.Create(50);
        _stressService.GetStress(Arg.Any<Guid>()).Returns(stressState);

        var corruptionState = CorruptionState.Create(30);
        _corruptionService.GetCorruption(Arg.Any<Guid>()).Returns(corruptionState);

        traumaService.GetTraumas(Arg.Any<Guid>()).Returns(new List<CharacterTrauma>().AsReadOnly());

        _service = new TraumaEconomyService(
            _stressService,
            _corruptionService,
            cpsService,
            traumaService,
            specProvider,
            diceService,
            config,
            damageHandler,
            restHandler,
            turnHandler
        );
    }

    [Test]
    public void GetState_ReturnsPopulatedState()
    {
        // Act
        var state = _service.GetState(Guid.NewGuid());

        // Assert
        state.Should().NotBeNull();
        state.StressState.CurrentStress.Should().Be(50);
        state.CorruptionState.CurrentCorruption.Should().Be(30);
    }

    [Test]
    public void GetActiveWarnings_WithHighStress_ReturnsWarnings()
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var stressState = StressState.Create(85);
        _stressService.GetStress(characterId).Returns(stressState);

        // Act
        var warnings = _service.GetActiveWarnings(characterId);

        // Assert
        warnings.Should().NotBeEmpty();
    }
}
```

---

## 12. Deliverable Checklist

### 12.1 Application Layer

- [ ] `src/Application/RuneAndRust.Application/Services/ITraumaEconomyService.cs`
- [ ] `src/Application/RuneAndRust.Application/Services/TraumaEconomyService.cs`
- [ ] `src/Application/RuneAndRust.Application/Configuration/ITraumaEconomyConfiguration.cs`
- [ ] `src/Application/RuneAndRust.Application/Configuration/TraumaEconomyConfiguration.cs`
- [ ] `src/Application/RuneAndRust.Application/Extensions/ServiceCollectionExtensions.cs`

### 12.2 Configuration Files

- [ ] `config/trauma-economy.json` (bundled with application)
- [ ] `config/trauma-economy.schema.json` (JSON schema for validation)

### 12.3 Tests

- [ ] `tests/RuneAndRust.Application.UnitTests/Services/TraumaEconomyServiceTests.cs`
- [ ] `tests/RuneAndRust.Application.UnitTests/Configuration/TraumaEconomyConfigurationTests.cs`

### 12.4 Documentation

- [ ] Update scope breakdown (mark v0.18.5e complete, mark v0.18.5 complete)
- [ ] Create changelog for v0.18.5e
- [ ] Create overall v0.18.5 release notes

---

## 13. Acceptance Criteria

### 13.1 Build Verification

- [ ] Solution builds without errors
- [ ] Solution builds without warnings in new code

### 13.2 Test Verification

- [ ] All new unit tests pass
- [ ] All existing unit tests continue to pass
- [ ] Code coverage adequate for service layer (>80%)

### 13.3 Functional Verification

- [ ] ITraumaEconomyService provides unified interface
- [ ] GetState() returns fully populated TraumaEconomyState
- [ ] ProcessDamage() delegates to UnifiedDamageHandler
- [ ] ProcessRest() delegates to UnifiedRestHandler
- [ ] ProcessTurnStart/End() delegate to UnifiedTurnHandler
- [ ] All query methods return correct values
- [ ] Configuration loads from JSON file
- [ ] Configuration validates on load
- [ ] Invalid configuration produces clear error
- [ ] DI extension registers all services
- [ ] Service lifetimes correct (singletons for config, scoped for services)

### 13.4 Configuration Verification

- [ ] trauma-economy.json is valid JSON
- [ ] All required properties present in config
- [ ] Default values reasonable and tested
- [ ] Configuration schema documents structure

---

## 14. Dependencies

### 14.1 Required Prerequisites

| Dependency                | Version | Status   | Notes                                  |
| ------------------------- | ------- | -------- | -------------------------------------- |
| v0.18.5a (State)          | v0.18.5a | Required | TraumaEconomyState aggregation         |
| v0.18.5b (Damage)         | v0.18.5b | Required | Damage integration handler             |
| v0.18.5c (Rest)           | v0.18.5c | Required | Rest integration handler               |
| v0.18.5d (Turn)           | v0.18.5d | Required | Turn integration handler               |
| All v0.18.0-4             | v0.18.x  | Required | Core trauma economy systems            |

### 14.2 Provides to Future Versions

| Type                     | Usage                                      |
| ------------------------ | ------------------------------------------ |
| `ITraumaEconomyService`  | Single entry point for trauma economy ops  |
| `ITraumaEconomyConfig`   | Configuration for all systems              |

---

## 15. Future Considerations

### 15.1 Extended Configuration

- Dynamic configuration reloading
- Per-specialization configuration overrides
- Difficulty-based configuration scaling

### 15.2 Advanced Features

- Trauma economy API for external tools
- Save/load integration for trauma state
- Migration tools for configuration updates

### 15.3 Performance Optimization

- Caching of aggregated state
- Lazy loading of specialization resources
- Configuration schema caching

---

_This design specification provides the detailed blueprint for implementing v0.18.5e ITraumaEconomyService & Configuration. Together with v0.18.5a-d, it completes the unified trauma economy integration system._

---

## Changelog

| Version | Date       | Changes                          |
| ------- | ---------- | -------------------------------- |
| 1.0     | 2026-01-28 | Initial design specification     |

---

## v0.18.5 Integration Complete

With v0.18.5a through v0.18.5e, the Trauma Economy Integration is complete. All trauma economy systems (Stress, Corruption, CPS, Trauma, Specialization) are now unified under a single orchestration layer providing:

- **Unified State Aggregation** (v0.18.5a)
- **Unified Damage Processing** (v0.18.5b)
- **Unified Rest Processing** (v0.18.5c)
- **Unified Turn-Based Processing** (v0.18.5d)
- **Unified Service Interface & Configuration** (v0.18.5e)

Next version (v0.18.6) will begin specialized system enhancements and performance optimizations.
