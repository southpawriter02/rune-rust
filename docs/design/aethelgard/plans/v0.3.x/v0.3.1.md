# Version 0.3.1: The Crafting Bench

**Status:** Complete
**Milestone:** Milestone 4 - Core Systems Layer
**Theme:** Resource Economy & Item Creation

## Table of Contents
- [Overview](#overview)
- [Phase A: The Blueprint (Core Engine)](#phase-a-the-blueprint-core-engine)
- [Phase B: The Tinkerer (Bodging & Medicine)](#phase-b-the-tinkerer-bodging--medicine)
- [Phase C: The Alchemist (Alchemy & Runeforging)](#phase-c-the-alchemist-alchemy--runeforging)
- [Changelog (v0.3.1)](#changelog-v031)

## Overview

This milestone implements the Crafting System defined in SPEC-CRAFTING, introducing the four primary trades: Bodging, Alchemy, Runeforging, and Field Medicine. It transitions the game from a scavenger hunt into a survival economy where players convert raw salvage into useful tools.

The Crafting Bench is implemented across three phases:

- **Phase A (v0.3.1a): The Blueprint** - Core crafting engine, recipe registry, and base logic
- **Phase B (v0.3.1b): The Tinkerer** - Bodging (repairs) and Field Medicine (consumables)
- **Phase C (v0.3.1c): The Alchemist** - Alchemy (potions) and Runeforging (enchantments)

---

## Phase A: The Blueprint (Core Engine)

**Goal:** Implement the CraftingService, RecipeRegistry, and the fundamental Input/Output loop (Ingredients + Skill Roll = Result).

### Architecture & Data Flow

The crafting system operates as a transaction engine. It must ensure that ingredients are consumed only if the craft is attempted, and outputs are generated only if the attempt succeeds.

**Workflow: The Crafting Pipeline**

1. **Initiation:** Player issues `craft [RecipeName]`.
2. **Lookup:** RecipeRegistry retrieves the definition (Inputs, Output, DC, Trade).
3. **Validation (Pre-Flight):**
   - Knowledge: Does player know this recipe?
   - Inventory: Does player have Input.Quantity of Input.ItemId?
   - Requirements: Are required tools/stations present? (e.g., Mortar & Pestle).
4. **Resolution:**
   - Calculate Dice Pool: WITS + Skill Rank + Tool Bonus + Specialization Bonus.
   - Roll vs Recipe.BaseDC.
   - Determine CraftingOutcome (Failure, Success, Masterwork, Catastrophe).
5. **Transaction:**
   - Always: Remove Ingredients.
   - If Success: Add Recipe.OutputId to Inventory.
   - If Masterwork: Add Recipe.OutputId with Quality = Optimized.
   - If Catastrophe: Trigger side effect (Damage/Stress).
6. **Feedback:** Return CraftingResult to UI.

### Logic Decision Trees

#### A. Crafting Resolution Logic
**Input:** NetSuccesses (Successes - Botches), Recipe DC

1. **Is NetSuccesses < 0 (Botch)?**
   - Result: Catastrophe.
   - Effect: Lose materials. Trigger TraumaService.ApplyStress.
2. **Is NetSuccesses < DC?**
   - Result: Failure.
   - Effect: Lose materials. (Future: Scrap-Tinker saves 50%).
3. **Is NetSuccesses >= DC + 5?**
   - Result: Masterwork.
   - Effect: Create Item. Set Item Quality to Optimized (Tier 3).
4. **Is NetSuccesses >= DC?**
   - Result: Success.
   - Effect: Create Item (Standard Quality).

#### B. Recipe Lookup Logic
**Input:** User String "shiv"

1. **Exact Match:** Is there a recipe named "Shiv"? → Return.
2. **Fuzzy Match:** Is there a recipe containing "Shiv"? → Return first match.
3. **Output Match:** Is there a recipe that produces an item named "Shiv"? → Return.
4. **Failure:** Return null.

### Code Implementation

#### A. Core Layer (Models & Enums)

**File:** `RuneAndRust.Core/Enums/CraftingTrade.cs`

```csharp
public enum CraftingTrade
{
    Bodging = 0,       // WITS - Repairs, Scrap
    Alchemy = 1,       // WITS - Potions, Poisons
    Runeforging = 2,   // WITS + WILL - Inscriptions (High Risk)
    FieldMedicine = 3  // WITS - Healing Items
}
```

**File:** `RuneAndRust.Core/Entities/Recipe.cs`

```csharp
public class Recipe
{
    public Guid Id { get; set; }
    public string Name { get; set; } // e.g., "Improvised Shiv"
    public CraftingTrade Trade { get; set; }
    public int BaseDc { get; set; }

    // Inputs (What we consume)
    public Dictionary<Guid, int> Ingredients { get; set; } = new();

    // Output (What we make)
    public Guid OutputItemId { get; set; }
    public int OutputQuantity { get; set; } = 1;

    // Requirements
    public List<string> RequiredKeywords { get; set; } = new(); // e.g., "Fire", "Workbench"
}
```

#### B. Engine Layer (Crafting Service)

**File:** `RuneAndRust.Engine/Services/CraftingService.cs`

```csharp
public class CraftingService : ICraftingService
{
    private readonly IInventoryService _inventory;
    private readonly IDiceService _dice;
    private readonly IRecipeRepository _recipes;
    private readonly ILogger _logger;

    public async Task<CraftingResult> CraftItemAsync(Character character, string recipeName)
    {
        // 1. Lookup
        var recipe = await _recipes.GetByNameAsync(recipeName);
        if (recipe == null) return CraftingResult.NotFound(recipeName);

        // 2. Validation
        if (!await _inventory.HasIngredientsAsync(character, recipe.Ingredients))
        {
            return CraftingResult.MissingIngredients(recipe.Ingredients);
        }

        // 3. Roll
        var wits = character.GetAttribute(Attribute.Wits);
        // Note: Future versions will add Skill/Tool bonuses here
        var roll = _dice.Roll(wits, $"Crafting: {recipe.Name}");

        // 4. Determine Outcome
        var outcome = CalculateOutcome(roll, recipe.BaseDc);

        // 5. Transaction
        // Always consume ingredients on attempt (unless spec override)
        await _inventory.RemoveIngredientsAsync(character, recipe.Ingredients);

        if (outcome == CraftingOutcome.Success || outcome == CraftingOutcome.Masterwork)
        {
            var quality = outcome == CraftingOutcome.Masterwork ? QualityTier.Optimized : QualityTier.Scavenged;
            await _inventory.AddItemAsync(character, recipe.OutputItemId, recipe.OutputQuantity, quality);

            _logger.LogInformation("{Name} crafted {Recipe} ({Quality}).", character.Name, recipe.Name, outcome);
            return CraftingResult.Success(recipe.Name, outcome);
        }

        _logger.LogWarning("{Name} failed to craft {Recipe}. Materials lost.", character.Name, recipe.Name);
        return CraftingResult.Failure(recipe.Name, outcome);
    }

    private CraftingOutcome CalculateOutcome(DiceResult roll, int dc)
    {
        if (roll.NetSuccesses <= -1) return CraftingOutcome.Catastrophe;
        if (roll.NetSuccesses >= dc + 5) return CraftingOutcome.Masterwork;
        if (roll.NetSuccesses >= dc) return CraftingOutcome.Success;
        return CraftingOutcome.Failure;
    }
}
```

### Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Crafting | Start | Debug | "{Name} attempting to craft {Recipe} (DC {DC})." | Name, Recipe, DC |
| Crafting | Validation Fail | Info | "{Name} missing ingredients for {Recipe}." | Name, Recipe |
| Crafting | Success | Info | "{Name} successfully crafted {Item} ({Quality})." | Name, Item, Quality |
| Crafting | Masterwork | Info | "*** MASTERWORK *** {Name} crafted {Item} with exceptional skill." | Name, Item |
| Crafting | Failure | Info | "{Name} failed craft {Recipe}. Ingredients consumed." | Name, Recipe |
| Crafting | Catastrophe | Warning | "{Name} suffered CRAFTING CATASTROPHE on {Recipe}!" | Name, Recipe |

### Testing Requirements

#### Unit Tests (CraftingServiceTests.cs)

- **Lookup:**
  - `Craft_UnknownRecipe_ReturnsNotFound`: Verify passing "laser gun" returns error.
- **Validation:**
  - `Craft_MissingIngredients_ReturnsFailure`: Character has 0 scrap, recipe needs 1. Verify fail.
  - `Craft_SufficientIngredients_PassesValidation`: Character has 5 scrap, recipe needs 1. Proceed.
- **Mechanics:**
  - `CalculateOutcome_NetSuccessEqualsDC_ReturnsSuccess`: Roll 3 vs DC 3.
  - `CalculateOutcome_NetSuccessBelowDC_ReturnsFailure`: Roll 2 vs DC 3.
  - `CalculateOutcome_NetSuccessHigh_ReturnsMasterwork`: Roll 8 vs DC 3 (+5 margin).
  - `CalculateOutcome_Botch_ReturnsCatastrophe`: Net -1.
- **Transaction:**
  - `Craft_Success_AddsItem_RemovesIngredients`: Verify inventory counts change correctly.
  - `Craft_Failure_RemovesIngredients_AddsNothing`: Verify ingredients lost, no item gained.

#### Integration Tests

- **End-to-End Crafting:**
  1. Seed "Scrap Metal" into Player Inventory.
  2. Seed "Shiv Recipe" (Requires 1 Scrap, DC 2).
  3. Set Player WITS to 10 (Ensure success).
  4. Call CraftItemAsync.
  5. Assert: Scrap count decremented, Shiv count incremented.

### Deliverable Checklist (Phase A)

- **Core:**
  - [ ] Define CraftingTrade and CraftingOutcome enums.
  - [ ] Define Recipe entity.
  - [ ] Define ICraftingService and IRecipeRepository.
- **Persistence:**
  - [ ] Create RecipeRepository (In-memory or seeded DB).
  - [ ] Seed initial "Test Recipe" (e.g., Scrap Bandage).
- **Engine:**
  - [ ] Implement CraftingService.
  - [ ] Inject IInventoryService and IDiceService.
  - [ ] Implement CraftingResult return logic.
- **Terminal:**
  - [ ] Update CommandParser to accept `craft <name>`.
  - [ ] Create CraftingScreenRenderer (basic list of recipes).

---

## Phase B: The Tinkerer (Bodging & Medicine)

**Goal:** Implement the logic for repairing equipment, salvaging items for scrap, and crafting medical supplies with environmental constraints.

### Architecture & Data Flow

We introduce IBodgingService to handle non-recipe crafting actions (Repair/Salvage) and extend CraftingService to support location validation.

**Workflow: The Repair Cycle**

1. **Input:** Player types `repair iron sword`.
2. **Validation:** BodgingService checks:
   - Is item Equipment?
   - Is CurrentDurability < MaxDurability?
   - Does player have required Scrap? (1 per 5 durability points).
3. **Resolution:** DiceService rolls WITS vs DC (8 + damage severity).
4. **Outcome:**
   - Success: Durability restored. Scrap consumed.
   - Failure: Scrap consumed. No repair.
   - Catastrophe: Max Durability reduced (permanent damage).
5. **Output:** Update Inventory, Log result.

**Workflow: The Salvage Cycle**

1. **Input:** `salvage rusted helm`.
2. **Execution:** Destroy item → Calculate Yield (Weight × Quality Mod) → Add Scrap to inventory.

### Logic Decision Trees

#### A. Repair Logic
**Input:** Character, Item

1. **Calculations:**
   - Damage = MaxDurability - Current.
   - Cost = Ceiling(Damage / 5) Scrap.
   - DC = 8 + (Damage / 5).
2. **Resource Check:** Inventory.Scrap >= Cost?
   - No: Return Failure ("Need {Cost} Scrap").
3. **Roll WITS:**
   - **Net Successes >= 0:**
     - CurrentDurability = MaxDurability.
     - Remove Cost Scrap.
     - Log: "Repaired."
   - **Net Successes < 0 (Botch):**
     - MaxDurability -= 5.
     - Remove Cost Scrap.
     - Log: "Catastrophe! Item permanently damaged."

#### B. Field Medicine Location Check
**Input:** Recipe

1. **Check Recipe Tags:** Does recipe require [Clean] or [Heat]?
2. **Check Room:**
   - If [Heat]: Does Room.Features contain Campfire or Stove?
   - If [Clean]: Is Room.Cleanliness > Dirty?
3. **Result:** Allow/Deny craft.

### Code Implementation

#### A. Core Layer (Entity Updates)

**File:** `RuneAndRust.Core/Entities/Equipment.cs`

```csharp
public class Equipment : Item
{
    // Existing properties...
    public int MaxDurability { get; set; } = 100;
    public int CurrentDurability { get; set; } = 100;

    public bool IsBroken => CurrentDurability <= 0;
}
```

#### B. Engine Layer (Bodging Service)

**File:** `RuneAndRust.Engine/Services/BodgingService.cs`

```csharp
public class BodgingService : IBodgingService
{
    // ... Dependencies: IDiceService, IInventoryService ...

    public async Task<CraftingResult> RepairItemAsync(Character character, Guid itemId)
    {
        var item = await _inventory.GetEquipment(character, itemId);
        if (item.CurrentDurability >= item.MaxDurability)
            return CraftingResult.Failure("Item is already pristine.");

        int damage = item.MaxDurability - item.CurrentDurability;
        int scrapCost = (int)Math.Ceiling(damage / 5.0);

        if (!await _inventory.HasItemAsync(character, "Scrap", scrapCost))
            return CraftingResult.Failure($"Requires {scrapCost} Scrap.");

        // Consume Scrap immediately
        await _inventory.RemoveItemAsync(character, "Scrap", scrapCost);

        // Roll WITS (Bodging)
        var roll = _dice.Roll(character.GetAttribute(Attribute.Wits), "Repair");
        int dc = 8 + (damage / 5);

        if (roll.NetSuccesses >= 0)
        {
            item.CurrentDurability = item.MaxDurability;
            return CraftingResult.Success($"Repaired {item.Name} fully.");
        }
        else if (roll.IsFumble)
        {
            item.MaxDurability = Math.Max(0, item.MaxDurability - 10);
            return CraftingResult.Catastrophe($"Slip! {item.Name} max durability reduced.");
        }

        return CraftingResult.Failure("Repair failed. Scrap wasted.");
    }

    public async Task<int> SalvageItemAsync(Character character, Guid itemId)
    {
        var item = await _inventory.GetItem(character, itemId);

        // Yield based on weight and quality
        int baseYield = item.Weight / 100; // 1 scrap per 100g
        int qualityMod = (int)item.Quality + 1;
        int totalScrap = Math.Max(1, baseYield * qualityMod);

        await _inventory.RemoveItemAsync(character, itemId);
        await _inventory.AddItemAsync(character, "Scrap", totalScrap);

        return totalScrap;
    }
}
```

### Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Bodging | Repair Success | Info | "{Name} repaired {Item}. Cost: {Scrap}." | Name, Item, Scrap |
| Bodging | Repair Catastrophe | Warning | "{Name} DAMAGED {Item} during repair. MaxDur: {Old}->{New}." | Item, Old, New |
| Bodging | Salvage | Info | "{Name} salvaged {Item} for {Count} Scrap." | Item, Count |
| Medicine | Location Fail | Debug | "{Name} cannot craft {Recipe}: requires {Feature}." | Recipe, Feature |

### Testing Requirements

#### Unit Tests (BodgingServiceTests.cs)

- **Repair:**
  - `Repair_RestoresToMax`: Durability 50/100 → 100/100 on success.
  - `Repair_ConsumesScrap`: Verify inventory deduction.
  - `Repair_Fumble_ReducesMax`: Botch roll → MaxDurability decreases.
  - `Repair_CalculatesDC`: Verify DC scales with damage severity (Base 8).
- **Salvage:**
  - `Salvage_RemovesItem_AddsScrap`: Verify swap.
  - `Salvage_Yield_ScalesWithQuality`: Quality 2 yields more than Quality 0.

#### Integration Tests

- **Field Medicine:**
  - `Crafting_Blocked_WithoutCampfire`: Attempt "Brew Antidote" in wilderness → Fail.
  - `Crafting_Allowed_WithCampfire`: Add "Campfire" to Room.Features → Attempt → Success.

### Deliverable Checklist (Phase B)

- **Core:**
  - [ ] Update Equipment entity with MaxDurability/CurrentDurability.
  - [ ] Define IBodgingService.
- **Engine:**
  - [ ] Implement BodgingService.RepairItemAsync.
  - [ ] Implement BodgingService.SalvageItemAsync.
  - [ ] Update CraftingService to check Room.Features for Medicine recipes.
- **Data:**
  - [ ] Seed "Scrap" item (Material).
  - [ ] Seed Bodging Recipes (Shiv, Lockpick).
  - [ ] Seed Field Medicine Recipes (Bandage, Poultice).
- **Terminal:**
  - [ ] Add `repair <item>` command.
  - [ ] Add `salvage <item>` command.

---

## Phase C: The Alchemist (Alchemy & Runeforging)

**Goal:** Implement the logic for brewing consumables, inscribing equipment with persistent runic buffs, and handling the "Catastrophe" and "Corruption" failure states associated with these volatile trades.

### Architecture & Data Flow

We extend the CraftingService to handle trade-specific side effects. While Bodging is purely physical, Alchemy and Runeforging interact with the Trauma System and Item Property System.

**Workflow: The Runeforging Cycle**

1. **Input:** Player types `forge thurisaz on iron-sword`.
2. **Validation:**
   - Recipe check: "Thurisaz Inscription".
   - Material check: 1x Runeink, 1x Weapon.
   - Skill Check: WITS + WILL (Mental fortitude required to channel the pattern).
3. **Resolution:** DiceService rolls against DC.
4. **Outcome Switch:**
   - Success: Weapon gains ItemProperty (e.g., "+1 Dmg").
   - Failure: Ink lost.
   - Botch (Catastrophe): Ink lost. +5 Corruption applied to Crafter via TraumaService.
5. **Output:** Modified Item returned to inventory.

**Workflow: The Alchemy Cycle**

1. **Input:** `brew healing-draught`.
2. **Resolution:** WITS roll.
3. **Outcome Switch:**
   - Masterwork (Net +5): Output Quality = MythForged (Max potency).
   - Botch: Explosion. Player takes Fire damage. No item created.

### Logic Decision Trees

#### A. Runeforging Outcome Logic
**Input:** NetSuccesses, Character, Recipe

1. **Is NetSuccesses >= 5? (Masterwork)**
   - Apply RuneProperty to Item.
   - Set Property Magnitude = 1.5x (if applicable).
   - Log: "The rune settles perfectly."
2. **Is NetSuccesses >= 0? (Success)**
   - Apply RuneProperty to Item.
   - Log: "Inscription complete."
3. **Is NetSuccesses < 0? (Botch)**
   - Trigger TraumaService.AddCorruption(2).
   - Apply [Stunned] (Mental Shock).
   - Log: "The pattern collapses! The Blight pushes back."

#### B. Alchemy Catastrophe Logic
**Input:** Recipe, Character

1. **Identify Catastrophe Type:** Look up Recipe.CatastropheType (Explosive, Toxic, Corrosive).
2. **Apply Effect:**
   - Explosive: Deal 2d6 Fire Damage to Crafter.
   - Toxic: Apply [Poisoned] (3 Stacks).
   - Corrosive: Reduce Armor Durability by 10.
3. **Destroy Ingredients:** Remove all inputs.

### Code Implementation

#### A. Core Layer (Crafting Extensions)

**File:** `RuneAndRust.Core/Models/Crafting/CraftingResult.cs` (Update)

```csharp
public record CraftingResult(
    // ... existing props ...
    int CorruptionIncurred,
    int DamageTaken,
    string CatastropheMessage
);
```

#### B. Engine Layer (Service Extension)

**File:** `RuneAndRust.Engine/Services/CraftingService.cs` (Update)

```csharp
public class CraftingService : ICraftingService
{
    private readonly ITraumaService _trauma;
    private readonly IEquipmentService _equipment; // For modifying items

    // ... Constructor ...

    private async Task<CraftingResult> ProcessRuneforging(Character char, Recipe recipe, DiceResult roll, Guid targetItemId)
    {
        if (roll.IsFumble)
        {
            // Domain 3: Runeforging risks Corruption
            int corruptionAmount = 2; // Base amount
            _trauma.AddCorruption(char, corruptionAmount, "Runic Backfire");

            return new CraftingResult(
                Success: false,
                Message: "The rune screams and shatters! You feel the Blight seep in.",
                CorruptionIncurred: corruptionAmount
            );
        }

        if (roll.NetSuccesses >= 0)
        {
            // Apply the rune to the actual item entity
            var runeProperty = recipe.OutputProperties.First(); // e.g., "Thurisaz: +1 Dmg"
            await _equipment.AddPropertyToItemAsync(targetItemId, runeProperty);

            return new CraftingResult(Success: true, Message: "Inscription successful.");
        }

        return new CraftingResult(Success: false, Message: "The ink runs. The pattern fails.");
    }

    private CraftingResult ProcessAlchemyCatastrophe(Character char, Recipe recipe)
    {
        // Simple damage logic for v0.3.1c
        int damage = _dice.Roll(2, 6).Total; // 2d6
        char.CurrentHp = Math.Max(0, char.CurrentHp - damage);

        return new CraftingResult(
            Success: false,
            Message: $"The mixture boils violently and explodes! You take {damage} damage.",
            DamageTaken: damage
        );
    }
}
```

### Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Runeforging | Inscribe | Info | "{Name} inscribed {Rune} on {Item}." | Name, Rune, Item |
| Runeforging | Corruption | Warning | "Runic Backfire! {Name} gained {Amount} Corruption." | Name, Amount |
| Alchemy | Brew | Info | "{Name} brewed {Potion} ({Quality})." | Name, Potion, Quality |
| Alchemy | Explosion | Error | "Alchemy Catastrophe! {Name} took {Dmg} damage." | Name, Dmg |

### Testing Requirements

#### Unit Tests (CraftingServiceTests.cs)

- **Runeforging:**
  - `Inscribe_Success_AddsPropertyToItem`: Verify Item.Properties contains "Thurisaz".
  - `Inscribe_Botch_AddsCorruption`: Verify TraumaService.AddCorruption was called.
  - `Inscribe_Botch_DoesNotAddProperty`: Verify Item is unchanged.
- **Alchemy:**
  - `Brew_Masterwork_CreatesMythForged`: Net success +5 results in Tier 4 item.
  - `Brew_Botch_DamagesPlayer`: HP decreases on catastrophe.

#### Integration Tests

- **End-to-End Inscription:**
  1. Add "Iron Sword" and "Runeink" to inventory.
  2. Call CraftItemAsync("recipe_rune_thurisaz", target: swordId).
  3. Assert Inventory contains "Iron Sword" (Modified) and 0 "Runeink".

### Deliverable Checklist (Phase C)

- **Core:**
  - [ ] Add ItemProperty class (Name, Description, StatModifiers).
  - [ ] Update Item entity to hold List<ItemProperty>.
- **Engine:**
  - [ ] Update CraftingService to handle CraftingTrade.Alchemy logic.
  - [ ] Update CraftingService to handle CraftingTrade.Runeforging logic.
  - [ ] Inject ITraumaService into CraftingService.
- **Data:**
  - [ ] Seed Alchemy Recipes: Healing Draught, Volatile Fire-Flask.
  - [ ] Seed Runeforging Recipes: Rune of Thurisaz (+Damage), Rune of Algiz (+Soak).
- **UI:**
  - [ ] Add `forge <rune> on <item>` command syntax.
  - [ ] Add `brew <potion>` command syntax.

---

## Changelog (v0.3.1)

**Release Date:** 2025-XX-XX

### Summary
The Crafting System is now live, allowing players to create items, repair gear, and brew potions. This update transforms "Junk" items into valuable "Scrap" and introduces the risk/reward mechanics of Runeforging.

### Features
- **Four Crafting Trades:**
  - **Bodging:** Repair gear and create improvised tools from Scrap.
  - **Field Medicine:** Craft bandages and poultices (requires campfire/safe zone).
  - **Alchemy:** Brew potions. Careful: fumbles cause explosions.
  - **Runeforging:** Inscribe gear with buffs. Failure causes **Corruption**.
- **Quality System:** High WITS rolls can produce **Masterwork** (Optimized) items with better stats.
- **Salvage:** Use `salvage <item>` to break down useless gear into Scrap.
- **Repair:** Use `repair <item>` to restore durability using Scrap.

### Technical
- Implemented `CraftingService` and `RecipeRegistry`.
- Integrated `TraumaService` for crafting penalties.
- Added `durability` tracking to Equipment.
