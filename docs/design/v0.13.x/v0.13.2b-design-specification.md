# v0.13.2b Design Specification: Node Display & States

**Version:** 0.13.2b
**Parent:** v0.13.2 (Ability Tree UI)
**Prerequisites:** v0.13.2a Complete (Tree Visualization), v0.10.2a Complete (Ability Trees)
**Status:** Design Complete
**Estimated Unit Tests:** ~6

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Tree Node Renderer Component](#4-tree-node-renderer-component)
   - 4.1 [TreeNodeRenderer Class](#41-treenoderenderer-class)
   - 4.2 [State Determination Logic](#42-state-determination-logic)
   - 4.3 [Node Highlighting](#43-node-highlighting)
5. [Node State Renderer](#5-node-state-renderer)
   - 5.1 [NodeStateRenderer Class](#51-nodestaterenderer-class)
   - 5.2 [State Indicators](#52-state-indicators)
   - 5.3 [State Colors](#53-state-colors)
6. [Progress Indicator Display](#6-progress-indicator-display)
   - 6.1 [Rank Progress](#61-rank-progress)
   - 6.2 [Progress Formatting](#62-progress-formatting)
7. [Data Model Changes](#7-data-model-changes)
8. [Configuration File Schemas](#8-configuration-file-schemas)
9. [AbilityTreeView Integration](#9-abilitytreeview-integration)
10. [Logging Specifications](#10-logging-specifications)
11. [Unit Testing Requirements](#11-unit-testing-requirements)
12. [Use Cases](#12-use-cases)
13. [Deliverable Checklist](#13-deliverable-checklist)
14. [Acceptance Criteria](#14-acceptance-criteria)
15. [Dependencies](#15-dependencies)
16. [Future Considerations](#16-future-considerations)

---

## 1. Executive Summary

This version implements node state rendering for the ability tree display, showing locked, available, and unlocked states for each ability node. Nodes display visual indicators based on the player's progress, including state-specific colors and symbols. The component integrates with the existing AbilityTreeView from v0.13.2a to enhance node boxes with state information.

### Key Deliverables

| Category | Items |
|----------|-------|
| **UI Components** | `TreeNodeRenderer` |
| **Renderers** | `NodeStateRenderer` |
| **DTOs** | `NodeStateDisplayDto`, `NodeRankDisplayDto` |
| **View Updates** | `AbilityTreeView` integration |
| **Configuration** | `node-state-display.json` |
| **Tests** | ~6 unit tests |

### Architectural Significance

This version establishes the **Node State Display Pattern** that will be used for ability node visualization:
- Node states are determined from PlayerAbilityProgress data
- Visual indicators use consistent symbols: `[x]` unlocked, `( )` available, `[L]` locked
- State colors provide immediate visual feedback on node status
- Progress toward multi-rank nodes is displayed within the node box
- The pattern supports future extension for tooltips and interactions (v0.13.2c-d)

---

## 2. Feature Overview

```
v0.13.2b Features
├── TreeNodeRenderer (UI Component)
│   ├── RenderNode(AbilityTreeNode, NodeState)
│   ├── GetNodeState(AbilityTreeNode, PlayerAbilityProgress)
│   ├── SetNodeHighlight(AbilityTreeNode, bool)
│   └── GetNodeBounds(AbilityTreeNode)
│
├── NodeStateRenderer (Renderer)
│   ├── GetStateIndicator(NodeState)
│   ├── GetStateColor(NodeState)
│   ├── FormatNodeContent(AbilityTreeNode, NodeState)
│   └── GetProgressIndicator(int, int)
│
├── Node State Indicators
│   ├── Unlocked: [x] (Green)
│   ├── Available: ( ) (Yellow)
│   └── Locked: [L] (Gray)
│
├── Node State Colors
│   ├── Unlocked Color (Green)
│   ├── Available Color (Yellow)
│   ├── Locked Color (DarkGray)
│   └── Selected Overlay (White)
│
└── AbilityTreeView Integration
    ├── Node State DTO Creation
    ├── Render With States
    └── Highlight Selected Node
```

### Scope Verification

| Feature | Source | Included |
|---------|--------|----------|
| Locked node state indicator | v0.13.2-scope-breakdown.md | Yes |
| Available node state indicator | v0.13.2-scope-breakdown.md | Yes |
| Unlocked node state indicator | v0.13.2-scope-breakdown.md | Yes |
| Node state color coding | v0.13.2-scope-breakdown.md | Yes |
| Progress toward unlocking | v0.13.2-scope-breakdown.md | Yes |
| Prerequisite lines | v0.13.2-scope-breakdown.md | No (v0.13.2c) |
| Tooltips | v0.13.2-scope-breakdown.md | No (v0.13.2d) |

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          PRESENTATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────┐      ┌─────────────────────────┐               │
│  │    AbilityTreeView      │      │    TreeNodeRenderer     │               │
│  │    (v0.13.2a)           │◄────▶│    (NEW)                │               │
│  ├─────────────────────────┤      ├─────────────────────────┤               │
│  │ - RenderTree()          │      │ - RenderNode()          │               │
│  │ - RenderTiers()         │      │ - GetNodeState()        │               │
│  │ - RenderNodesWithState()│      │ - SetNodeHighlight()    │               │
│  └─────────────────────────┘      │ - GetNodeBounds()       │               │
│                                    └───────────┬─────────────┘               │
│                                                │                             │
│  ┌─────────────────────────┐                   │                             │
│  │   TreeLayoutRenderer    │                   │                             │
│  │   (v0.13.2a)            │                   │                             │
│  ├─────────────────────────┤                   │                             │
│  │ - CalculateNodePositions│                   │                             │
│  │ - FormatNodeBox()       │                   │                             │
│  └─────────────────────────┘                   │                             │
│                                                │                             │
│  ┌─────────────────────────────────────────────┴───────────────────────────┐ │
│  │                     NodeStateRenderer (NEW)                              │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │ - GetStateIndicator()     - FormatNodeContent()                         │ │
│  │ - GetStateColor()         - GetProgressIndicator()                      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          APPLICATION LAYER                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    IAbilityTreeProvider (existing v0.10.2a)         │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + GetTreeForClass(classId) : AbilityTreeDefinition?                 │    │
│  │ + FindNode(nodeId) : AbilityTreeNode?                               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    ITalentPointService (existing v0.10.2b)          │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + GetUnspentPoints(player) : int                                    │    │
│  │ + GetTotalPointsSpent(player) : int                                 │    │
│  │ + GetNodeRank(player, nodeId) : int                                 │    │
│  │ + GetAllocationsForTree(player, treeId) : IReadOnlyList<...>        │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    IPrerequisiteValidator (existing v0.10.2c)       │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + CanUnlock(player, nodeId) : PrerequisiteResult                    │    │
│  │ + GetPrerequisitesForNode(nodeId) : IReadOnlyList<NodePrerequisite> │    │
│  │ + ArePrerequisitesMet(player, nodeId) : bool                        │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN LAYER                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────┐      ┌─────────────────────────┐               │
│  │    AbilityTreeNode      │      │  PlayerAbilityProgress  │               │
│  │   (existing v0.10.2a)   │      │   (existing v0.10.2a)   │               │
│  ├─────────────────────────┤      ├─────────────────────────┤               │
│  │ + NodeId: string        │      │ + PlayerId: Guid        │               │
│  │ + Name: string          │      │ + UnlockedNodeIds: set  │               │
│  │ + Tier: int             │      │ + NodeRanks: dict       │               │
│  │ + PointCost: int        │      │ + TotalPointsSpent: int │               │
│  │ + MaxRank: int          │      │ + HasUnlocked(nodeId)   │               │
│  │ + PrerequisiteNodeIds   │      │ + GetRank(nodeId): int  │               │
│  └─────────────────────────┘      └─────────────────────────┘               │
│                                                                              │
│  ┌─────────────────────────┐      ┌─────────────────────────┐               │
│  │    TalentAllocation     │      │    NodePrerequisite     │               │
│  │   (existing v0.10.2a)   │      │   (existing v0.10.2a)   │               │
│  ├─────────────────────────┤      ├─────────────────────────┤               │
│  │ + NodeId: string        │      │ + RequiredNodeId: string│               │
│  │ + AllocatedRank: int    │      │ + RequiredRank: int     │               │
│  │ + TreeId: string        │      │ + RequiredTier: int     │               │
│  │ + AllocatedAt: DateTime │      └─────────────────────────┘               │
│  └─────────────────────────┘                                                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 State Determination Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    NODE STATE DETERMINATION FLOW                             │
└─────────────────────────────────────────────────────────────────────────────┘

    AbilityTreeNode + PlayerAbilityProgress Input
           │
           ▼
┌─────────────────────────┐
│  Check if Unlocked      │
│  progress.HasUnlocked() │
└───────────┬─────────────┘
            │
            ├─── Yes ──────► NodeState.Unlocked
            │
            │ No
            ▼
┌─────────────────────────┐
│  Check Prerequisites    │
│  validator.ArePrereqs   │
│  Met(player, nodeId)    │
└───────────┬─────────────┘
            │
            ├─── Yes ──────┬──► Check Tier Requirement
            │              │
            │              ▼
            │    ┌─────────────────────────┐
            │    │ tier <= player.level /  │
            │    │ pointsPerLevel + 1      │
            │    └───────────┬─────────────┘
            │                │
            │                ├─── Yes ──┬─► Check Point Cost
            │                │          │
            │                │          ▼
            │                │ ┌─────────────────────────┐
            │                │ │ unspentPoints >=        │
            │                │ │ node.PointCost          │
            │                │ └───────────┬─────────────┘
            │                │             │
            │                │             ├─── Yes ──► NodeState.Available
            │                │             │
            │                │             │ No
            │                │             ▼
            │                │       NodeState.Locked
            │                │       (insufficient points)
            │                │
            │                │ No
            │                ▼
            │          NodeState.Locked
            │          (tier not reached)
            │
            │ No
            ▼
      NodeState.Locked
      (prerequisites not met)
```

### 3.3 Node Rendering Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    NODE STATE RENDERING FLOW                                 │
└─────────────────────────────────────────────────────────────────────────────┘

    RenderNode(node, nodeState) Called
           │
           ▼
┌─────────────────────────┐
│  Get Node Position      │
│  from _nodePositions    │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────┐
│  NodeStateRenderer.GetStateIndicator(nodeState)             │
│                                                              │
│  NodeState.Unlocked  → "[x]"                                │
│  NodeState.Available → "( )"                                │
│  NodeState.Locked    → "[L]"                                │
└───────────┬─────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────┐
│  NodeStateRenderer.GetStateColor(nodeState)                 │
│                                                              │
│  NodeState.Unlocked  → Green                                │
│  NodeState.Available → Yellow                               │
│  NodeState.Locked    → DarkGray                             │
└───────────┬─────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────┐
│  NodeStateRenderer.FormatNodeContent(node, nodeState)       │
│                                                              │
│  Combines:                                                   │
│  - State indicator                                           │
│  - Node name                                                 │
│  - Rank progress (if applicable)                            │
└───────────┬─────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Write to Terminal                                           │
│                                                              │
│  ┌─────────┐                                                │
│  │ [x]Power│  ← State indicator + name                      │
│  │  Strike │                                                │
│  └─────────┘                                                │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. Tree Node Renderer Component

### 4.1 TreeNodeRenderer Class

**Purpose:** Renders individual ability nodes with their current state and handles node highlighting.

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/UI/TreeNodeRenderer.cs`

```csharp
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Presentation.Tui.Renderers;
using RuneAndRust.Presentation.Tui.Services;
using RuneAndRust.Presentation.Tui.DTOs;
using RuneAndRust.Presentation.Tui.Configuration;

namespace RuneAndRust.Presentation.Tui.UI;

/// <summary>
/// Renders individual ability tree nodes with state-specific styling.
/// </summary>
/// <remarks>
/// The tree node renderer determines and displays the unlock state of each
/// node (locked, available, unlocked) with appropriate visual indicators
/// and colors. Integrates with AbilityTreeView for complete tree display.
/// </remarks>
public class TreeNodeRenderer
{
    private readonly NodeStateRenderer _stateRenderer;
    private readonly ITerminalService _terminalService;
    private readonly ITalentPointService _talentPointService;
    private readonly IPrerequisiteValidator _prerequisiteValidator;
    private readonly NodeStateDisplayConfig _config;
    private readonly ILogger<TreeNodeRenderer> _logger;

    private Dictionary<string, NodeScreenPosition> _nodePositions = new();
    private HashSet<string> _highlightedNodes = new();

    /// <summary>
    /// Creates a new instance of the TreeNodeRenderer.
    /// </summary>
    /// <param name="stateRenderer">The renderer for state-specific formatting.</param>
    /// <param name="terminalService">The terminal output service.</param>
    /// <param name="talentPointService">Service for talent point queries.</param>
    /// <param name="prerequisiteValidator">Service for prerequisite validation.</param>
    /// <param name="config">Configuration for state display settings.</param>
    /// <param name="logger">Logger for diagnostic output.</param>
    public TreeNodeRenderer(
        NodeStateRenderer stateRenderer,
        ITerminalService terminalService,
        ITalentPointService talentPointService,
        IPrerequisiteValidator prerequisiteValidator,
        NodeStateDisplayConfig config,
        ILogger<TreeNodeRenderer> logger)
    {
        _stateRenderer = stateRenderer ?? throw new ArgumentNullException(nameof(stateRenderer));
        _terminalService = terminalService ?? throw new ArgumentNullException(nameof(terminalService));
        _talentPointService = talentPointService ?? throw new ArgumentNullException(nameof(talentPointService));
        _prerequisiteValidator = prerequisiteValidator ?? throw new ArgumentNullException(nameof(prerequisiteValidator));
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Sets the node positions for rendering.
    /// </summary>
    /// <param name="positions">Dictionary mapping node IDs to screen positions.</param>
    public void SetNodePositions(Dictionary<string, NodeScreenPosition> positions)
    {
        _nodePositions = positions ?? throw new ArgumentNullException(nameof(positions));
    }

    /// <summary>
    /// Renders a node with its current state.
    /// </summary>
    /// <param name="node">The node layout data.</param>
    /// <param name="state">The current state of the node.</param>
    public void RenderNode(NodeLayoutDto node, NodeState state)
    {
        if (!_nodePositions.TryGetValue(node.NodeId, out var position))
        {
            _logger.LogWarning("No position found for node {NodeId}", node.NodeId);
            return;
        }

        var isHighlighted = _highlightedNodes.Contains(node.NodeId);
        var color = isHighlighted
            ? _config.Colors.HighlightedNodeColor
            : _stateRenderer.GetStateColor(state);

        var content = _stateRenderer.FormatNodeContent(node, state, _config.NodeWidth, _config.NodeHeight);
        var lines = content.Split('\n');

        for (var i = 0; i < lines.Length; i++)
        {
            _terminalService.WriteColoredAt(
                position.X,
                position.Y + i,
                lines[i],
                color);
        }

        _logger.LogDebug(
            "Rendered node {NodeId} at ({X}, {Y}) with state {State}",
            node.NodeId, position.X, position.Y, state);
    }

    /// <summary>
    /// Determines the state of a node based on player progress.
    /// </summary>
    /// <param name="node">The ability tree node.</param>
    /// <param name="progress">The player's ability progress.</param>
    /// <param name="unspentPoints">The player's unspent talent points.</param>
    /// <returns>The current state of the node.</returns>
    public NodeState GetNodeState(
        AbilityTreeNode node,
        PlayerAbilityProgress progress,
        int unspentPoints)
    {
        // Check if already unlocked (any rank)
        if (progress.HasUnlocked(node.NodeId))
        {
            return NodeState.Unlocked;
        }

        // Check if prerequisites are met
        if (!_prerequisiteValidator.ArePrerequisitesMet(progress.PlayerId, node.NodeId))
        {
            return NodeState.Locked;
        }

        // Check if player has enough points
        if (unspentPoints < node.PointCost)
        {
            return NodeState.Locked;
        }

        // All requirements met - node is available
        return NodeState.Available;
    }

    /// <summary>
    /// Sets the highlight state for a node.
    /// </summary>
    /// <param name="nodeId">The node identifier.</param>
    /// <param name="highlighted">Whether the node should be highlighted.</param>
    public void SetNodeHighlight(string nodeId, bool highlighted)
    {
        if (highlighted)
        {
            _highlightedNodes.Add(nodeId);
        }
        else
        {
            _highlightedNodes.Remove(nodeId);
        }

        _logger.LogDebug("Node {NodeId} highlight set to {Highlighted}", nodeId, highlighted);
    }

    /// <summary>
    /// Clears all node highlights.
    /// </summary>
    public void ClearHighlights()
    {
        _highlightedNodes.Clear();
        _logger.LogDebug("Cleared all node highlights");
    }

    /// <summary>
    /// Gets the screen bounds for a node.
    /// </summary>
    /// <param name="nodeId">The node identifier.</param>
    /// <returns>The node bounds rectangle, or null if not found.</returns>
    public NodeBounds? GetNodeBounds(string nodeId)
    {
        if (!_nodePositions.TryGetValue(nodeId, out var position))
        {
            return null;
        }

        return new NodeBounds(
            position.X,
            position.Y,
            _config.NodeWidth,
            _config.NodeHeight);
    }
}
```

### 4.2 State Determination Logic

**Purpose:** Determine the unlock state of a node based on player progress and prerequisites.

The state determination follows a priority order:
1. **Unlocked**: Player has already invested points in this node
2. **Available**: All prerequisites met AND sufficient unspent points
3. **Locked**: Prerequisites not met OR insufficient points

**State Determination Rules:**

```csharp
/// <summary>
/// Determines node state with detailed reason tracking.
/// </summary>
/// <param name="node">The ability tree node.</param>
/// <param name="progress">The player's ability progress.</param>
/// <param name="unspentPoints">The player's unspent talent points.</param>
/// <returns>A tuple of state and reason.</returns>
public (NodeState State, string Reason) GetNodeStateWithReason(
    AbilityTreeNode node,
    PlayerAbilityProgress progress,
    int unspentPoints)
{
    // Priority 1: Already unlocked
    if (progress.HasUnlocked(node.NodeId))
    {
        var currentRank = progress.GetRank(node.NodeId);
        if (currentRank >= node.MaxRank)
        {
            return (NodeState.Unlocked, "Fully unlocked");
        }
        return (NodeState.Unlocked, $"Rank {currentRank}/{node.MaxRank}");
    }

    // Priority 2: Check prerequisites
    if (!_prerequisiteValidator.ArePrerequisitesMet(progress.PlayerId, node.NodeId))
    {
        var prereqs = _prerequisiteValidator.GetPrerequisitesForNode(node.NodeId);
        var unmetPrereq = prereqs.FirstOrDefault(p =>
            !progress.HasUnlocked(p.RequiredNodeId) ||
            progress.GetRank(p.RequiredNodeId) < p.RequiredRank);

        return (NodeState.Locked, unmetPrereq != null
            ? $"Requires {unmetPrereq.RequiredNodeId}"
            : "Prerequisites not met");
    }

    // Priority 3: Check point cost
    if (unspentPoints < node.PointCost)
    {
        return (NodeState.Locked, $"Need {node.PointCost} points (have {unspentPoints})");
    }

    // All requirements met
    return (NodeState.Available, "Ready to unlock");
}
```

### 4.3 Node Highlighting

**Purpose:** Provide visual feedback for the currently selected node.

Node highlighting overrides the state color with a highlight color to indicate selection:

**Highlight Behavior:**
- Only one node can be highlighted at a time
- Highlight persists until explicitly cleared or moved
- Highlight color takes precedence over state color
- Border style changes to double-line for highlighted nodes (optional)

**Highlight Visual:**

```
Normal Node:              Highlighted Node:
┌─────────┐              ╔═════════╗
│ [x]Power│              ║ [x]Power║
│  Strike │              ║  Strike ║
└─────────┘              ╚═════════╝
```

---

## 5. Node State Renderer

### 5.1 NodeStateRenderer Class

**Purpose:** Handles state-specific formatting including indicators, colors, and content layout.

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Renderers/NodeStateRenderer.cs`

```csharp
using RuneAndRust.Presentation.Tui.DTOs;
using RuneAndRust.Presentation.Tui.Configuration;

namespace RuneAndRust.Presentation.Tui.Renderers;

/// <summary>
/// Renders state-specific visual elements for ability tree nodes.
/// </summary>
/// <remarks>
/// Provides consistent state indicators, colors, and content formatting
/// for locked, available, and unlocked node states.
/// </remarks>
public class NodeStateRenderer
{
    private readonly NodeStateDisplayConfig _config;

    /// <summary>
    /// Creates a new instance of the NodeStateRenderer.
    /// </summary>
    /// <param name="config">Configuration for state display settings.</param>
    public NodeStateRenderer(NodeStateDisplayConfig config)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
    }

    /// <summary>
    /// Gets the visual indicator for a node state.
    /// </summary>
    /// <param name="state">The node state.</param>
    /// <returns>The state indicator string.</returns>
    /// <remarks>
    /// Returns one of:
    /// - "[x]" for unlocked nodes
    /// - "( )" for available nodes
    /// - "[L]" for locked nodes
    /// </remarks>
    public string GetStateIndicator(NodeState state)
    {
        return state switch
        {
            NodeState.Unlocked => _config.Indicators.UnlockedIndicator,
            NodeState.Available => _config.Indicators.AvailableIndicator,
            NodeState.Locked => _config.Indicators.LockedIndicator,
            _ => _config.Indicators.LockedIndicator
        };
    }

    /// <summary>
    /// Gets the color for a node state.
    /// </summary>
    /// <param name="state">The node state.</param>
    /// <returns>The console color for the state.</returns>
    public ConsoleColor GetStateColor(NodeState state)
    {
        return state switch
        {
            NodeState.Unlocked => _config.Colors.UnlockedColor,
            NodeState.Available => _config.Colors.AvailableColor,
            NodeState.Locked => _config.Colors.LockedColor,
            _ => _config.Colors.LockedColor
        };
    }

    /// <summary>
    /// Formats the complete node content with state indicator and name.
    /// </summary>
    /// <param name="node">The node layout data.</param>
    /// <param name="state">The current node state.</param>
    /// <param name="width">The node box width.</param>
    /// <param name="height">The node box height.</param>
    /// <returns>The formatted node box content.</returns>
    public string FormatNodeContent(
        NodeLayoutDto node,
        NodeState state,
        int width,
        int height)
    {
        var innerWidth = width - 2; // Account for borders
        var indicator = GetStateIndicator(state);

        // Build top border
        var topBorder = $"┌{new string('─', innerWidth)}┐";
        var bottomBorder = $"└{new string('─', innerWidth)}┘";

        // Build content lines
        var contentLines = new List<string>();
        var contentHeight = height - 2; // Account for borders

        // First content line: indicator + name start
        var indicatorLine = FormatIndicatorLine(indicator, node.NodeName, innerWidth);
        contentLines.Add(indicatorLine);

        // Additional lines for name continuation if needed
        var remainingName = GetRemainingNamePart(node.NodeName, innerWidth - indicator.Length - 1);
        if (!string.IsNullOrEmpty(remainingName))
        {
            contentLines.Add(FormatCenteredLine(remainingName, innerWidth));
        }

        // Pad remaining content height
        while (contentLines.Count < contentHeight)
        {
            contentLines.Add(FormatCenteredLine(string.Empty, innerWidth));
        }

        // Build complete box
        var lines = new List<string> { topBorder };
        lines.AddRange(contentLines.Take(contentHeight).Select(line => $"│{line}│"));
        lines.Add(bottomBorder);

        return string.Join("\n", lines);
    }

    /// <summary>
    /// Gets a progress indicator string for multi-rank nodes.
    /// </summary>
    /// <param name="currentRank">The current rank achieved.</param>
    /// <param name="maxRank">The maximum rank possible.</param>
    /// <returns>The progress indicator string.</returns>
    public string GetProgressIndicator(int currentRank, int maxRank)
    {
        if (maxRank <= 1)
        {
            return string.Empty;
        }

        return $"{currentRank}/{maxRank}";
    }

    #region Private Helper Methods

    private string FormatIndicatorLine(string indicator, string nodeName, int width)
    {
        // Format: " [x]Name " or " [x]Na.. " if truncated
        var availableWidth = width - indicator.Length - 2; // Space before indicator and after name
        var displayName = nodeName.Length <= availableWidth
            ? nodeName
            : nodeName.Substring(0, availableWidth);

        var combined = $" {indicator}{displayName}";
        return combined.PadRight(width);
    }

    private string FormatCenteredLine(string content, int width)
    {
        if (content.Length >= width)
        {
            return content.Substring(0, width);
        }

        var padding = (width - content.Length) / 2;
        return content.PadLeft(padding + content.Length).PadRight(width);
    }

    private string GetRemainingNamePart(string fullName, int firstLineCapacity)
    {
        if (fullName.Length <= firstLineCapacity)
        {
            return string.Empty;
        }

        // Try to split at word boundary
        var words = fullName.Split(' ');
        var firstLine = new List<string>();
        var currentLength = 0;

        foreach (var word in words)
        {
            if (currentLength + word.Length + (firstLine.Count > 0 ? 1 : 0) <= firstLineCapacity)
            {
                firstLine.Add(word);
                currentLength += word.Length + (firstLine.Count > 1 ? 1 : 0);
            }
            else
            {
                break;
            }
        }

        var firstLineText = string.Join(" ", firstLine);
        return fullName.Length > firstLineText.Length
            ? fullName.Substring(firstLineText.Length).TrimStart()
            : string.Empty;
    }

    #endregion
}
```

### 5.2 State Indicators

**Purpose:** Provide clear visual symbols for each node state.

| State | Indicator | Description |
|-------|-----------|-------------|
| Unlocked | `[x]` | Check mark indicates node is unlocked |
| Available | `( )` | Open circle indicates node can be unlocked |
| Locked | `[L]` | Lock symbol indicates node cannot be unlocked yet |

**Indicator Placement:**

```
┌─────────┐
│ [x]Power│  ← Indicator at start of first content line
│  Strike │
└─────────┘
```

**Multi-Rank Nodes:**

```
┌─────────┐
│ [x]Power│
│Strike 2/3│  ← Rank progress shown below name
└─────────┘
```

### 5.3 State Colors

**Purpose:** Provide color coding for immediate state recognition.

| State | Color | Rationale |
|-------|-------|-----------|
| Unlocked | Green | Positive/complete association |
| Available | Yellow | Attention/action-ready association |
| Locked | DarkGray | Unavailable/inactive association |
| Highlighted | White | High contrast for selection |

**Color Application:**
- Colors apply to the entire node box (border and content)
- Highlighted state overrides state color
- Colors are configurable via `node-state-display.json`

---

## 6. Progress Indicator Display

### 6.1 Rank Progress

**Purpose:** Display progress for nodes with multiple ranks.

Some ability nodes can be unlocked multiple times (ranks) to increase their effect. The progress indicator shows the current rank versus maximum rank.

**Rank Progress Display:**

```
Single-Rank Node (MaxRank = 1):
┌─────────┐
│ [x]Power│
│  Strike │       ← No rank display
└─────────┘

Multi-Rank Node (MaxRank = 3, Current = 2):
┌─────────┐
│ [x]Iron │
│Skin  2/3│       ← Rank progress display
└─────────┘
```

**Progress Rules:**
- Single-rank nodes (MaxRank = 1) do not display progress
- Multi-rank nodes show `CurrentRank/MaxRank`
- Progress appears on the second content line
- Fully ranked nodes still show max progress (e.g., "3/3")

### 6.2 Progress Formatting

**Purpose:** Format the rank progress indicator consistently.

**File:** (continuation of NodeStateRenderer)

```csharp
/// <summary>
/// Formats the complete node content including rank progress for multi-rank nodes.
/// </summary>
/// <param name="node">The node layout data with rank information.</param>
/// <param name="state">The current node state.</param>
/// <param name="width">The node box width.</param>
/// <param name="height">The node box height.</param>
/// <returns>The formatted node box content.</returns>
public string FormatNodeContentWithProgress(
    NodeStateDisplayDto node,
    int width,
    int height)
{
    var innerWidth = width - 2;
    var indicator = GetStateIndicator(node.State);

    var topBorder = $"┌{new string('─', innerWidth)}┐";
    var bottomBorder = $"└{new string('─', innerWidth)}┘";

    var contentLines = new List<string>();
    var contentHeight = height - 2;

    // First line: indicator + name
    var indicatorLine = FormatIndicatorLine(indicator, node.NodeName, innerWidth);
    contentLines.Add(indicatorLine);

    // Second line: name continuation or rank progress
    if (node.MaxRank > 1)
    {
        // Show remaining name and progress
        var remainingName = GetRemainingNamePart(node.NodeName, innerWidth - indicator.Length - 1);
        var progress = GetProgressIndicator(node.CurrentRank, node.MaxRank);

        if (!string.IsNullOrEmpty(remainingName))
        {
            // Combine remaining name with progress
            var combined = $"{remainingName} {progress}".Trim();
            contentLines.Add(FormatCenteredLine(combined, innerWidth));
        }
        else
        {
            // Just show progress
            contentLines.Add(FormatCenteredLine(progress, innerWidth));
        }
    }
    else
    {
        // Single-rank: show remaining name or empty
        var remainingName = GetRemainingNamePart(node.NodeName, innerWidth - indicator.Length - 1);
        contentLines.Add(FormatCenteredLine(remainingName, innerWidth));
    }

    // Pad to content height
    while (contentLines.Count < contentHeight)
    {
        contentLines.Add(FormatCenteredLine(string.Empty, innerWidth));
    }

    var lines = new List<string> { topBorder };
    lines.AddRange(contentLines.Take(contentHeight).Select(line => $"│{line}│"));
    lines.Add(bottomBorder);

    return string.Join("\n", lines);
}
```

---

## 7. Data Model Changes

### 7.1 New Enums

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/DTOs/NodeState.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.DTOs;

/// <summary>
/// Represents the unlock state of an ability tree node.
/// </summary>
public enum NodeState
{
    /// <summary>
    /// Node is locked and cannot be unlocked yet.
    /// Prerequisites are not met or insufficient points.
    /// </summary>
    Locked,

    /// <summary>
    /// Node is available to be unlocked.
    /// All prerequisites are met and player has sufficient points.
    /// </summary>
    Available,

    /// <summary>
    /// Node has been unlocked (at least rank 1).
    /// </summary>
    Unlocked
}
```

### 7.2 New DTOs

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/DTOs/NodeStateDtos.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.DTOs;

/// <summary>
/// Data transfer object for node state display information.
/// </summary>
/// <param name="NodeId">The unique node identifier.</param>
/// <param name="NodeName">The display name of the node.</param>
/// <param name="State">The current unlock state.</param>
/// <param name="CurrentRank">The player's current rank in this node (0 if not unlocked).</param>
/// <param name="MaxRank">The maximum rank achievable.</param>
/// <param name="PointCost">The talent point cost to unlock/upgrade.</param>
/// <param name="Tier">The tier number of the node.</param>
/// <param name="BranchId">The branch this node belongs to.</param>
public record NodeStateDisplayDto(
    string NodeId,
    string NodeName,
    NodeState State,
    int CurrentRank,
    int MaxRank,
    int PointCost,
    int Tier,
    string BranchId);

/// <summary>
/// Data transfer object for node rank display.
/// </summary>
/// <param name="CurrentRank">The current rank achieved.</param>
/// <param name="MaxRank">The maximum rank possible.</param>
/// <param name="IsMaxRank">Whether current rank equals max rank.</param>
public record NodeRankDisplayDto(
    int CurrentRank,
    int MaxRank,
    bool IsMaxRank)
{
    /// <summary>
    /// Gets a formatted progress string.
    /// </summary>
    public string ProgressString => MaxRank > 1 ? $"{CurrentRank}/{MaxRank}" : string.Empty;
}

/// <summary>
/// Represents the screen bounds of a rendered node.
/// </summary>
/// <param name="X">The X coordinate of the top-left corner.</param>
/// <param name="Y">The Y coordinate of the top-left corner.</param>
/// <param name="Width">The width of the node box.</param>
/// <param name="Height">The height of the node box.</param>
public record NodeBounds(int X, int Y, int Width, int Height);
```

### 7.3 Configuration Classes

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/NodeStateDisplayConfig.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.Configuration;

/// <summary>
/// Configuration for node state display settings.
/// </summary>
public class NodeStateDisplayConfig
{
    /// <summary>
    /// Width of each node box.
    /// </summary>
    public int NodeWidth { get; set; } = 11;

    /// <summary>
    /// Height of each node box.
    /// </summary>
    public int NodeHeight { get; set; } = 3;

    /// <summary>
    /// State indicator configuration.
    /// </summary>
    public NodeStateIndicators Indicators { get; set; } = new();

    /// <summary>
    /// State color configuration.
    /// </summary>
    public NodeStateColors Colors { get; set; } = new();
}

/// <summary>
/// Configuration for state indicator symbols.
/// </summary>
public class NodeStateIndicators
{
    /// <summary>Indicator for unlocked nodes.</summary>
    public string UnlockedIndicator { get; set; } = "[x]";

    /// <summary>Indicator for available nodes.</summary>
    public string AvailableIndicator { get; set; } = "( )";

    /// <summary>Indicator for locked nodes.</summary>
    public string LockedIndicator { get; set; } = "[L]";
}

/// <summary>
/// Configuration for state-specific colors.
/// </summary>
public class NodeStateColors
{
    /// <summary>Color for unlocked nodes.</summary>
    public ConsoleColor UnlockedColor { get; set; } = ConsoleColor.Green;

    /// <summary>Color for available nodes.</summary>
    public ConsoleColor AvailableColor { get; set; } = ConsoleColor.Yellow;

    /// <summary>Color for locked nodes.</summary>
    public ConsoleColor LockedColor { get; set; } = ConsoleColor.DarkGray;

    /// <summary>Color for highlighted/selected nodes.</summary>
    public ConsoleColor HighlightedNodeColor { get; set; } = ConsoleColor.White;
}
```

---

## 8. Configuration File Schemas

### 8.1 node-state-display.json

**File:** `config/node-state-display.json`

```json
{
  "$schema": "./schemas/node-state-display.schema.json",
  "nodeWidth": 11,
  "nodeHeight": 3,
  "indicators": {
    "unlockedIndicator": "[x]",
    "availableIndicator": "( )",
    "lockedIndicator": "[L]"
  },
  "colors": {
    "unlockedColor": "Green",
    "availableColor": "Yellow",
    "lockedColor": "DarkGray",
    "highlightedNodeColor": "White"
  }
}
```

### 8.2 node-state-display.schema.json

**File:** `config/schemas/node-state-display.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "node-state-display.schema.json",
  "title": "Node State Display Configuration",
  "description": "Configuration for ability tree node state display",
  "type": "object",
  "properties": {
    "nodeWidth": {
      "type": "integer",
      "description": "Width of each node box",
      "minimum": 7,
      "maximum": 20,
      "default": 11
    },
    "nodeHeight": {
      "type": "integer",
      "description": "Height of each node box",
      "minimum": 3,
      "maximum": 7,
      "default": 3
    },
    "indicators": {
      "type": "object",
      "description": "State indicator symbols",
      "properties": {
        "unlockedIndicator": {
          "type": "string",
          "description": "Indicator for unlocked nodes",
          "minLength": 1,
          "maxLength": 5,
          "default": "[x]"
        },
        "availableIndicator": {
          "type": "string",
          "description": "Indicator for available nodes",
          "minLength": 1,
          "maxLength": 5,
          "default": "( )"
        },
        "lockedIndicator": {
          "type": "string",
          "description": "Indicator for locked nodes",
          "minLength": 1,
          "maxLength": 5,
          "default": "[L]"
        }
      },
      "additionalProperties": false
    },
    "colors": {
      "type": "object",
      "description": "State color configuration",
      "properties": {
        "unlockedColor": {
          "$ref": "#/$defs/consoleColor",
          "default": "Green"
        },
        "availableColor": {
          "$ref": "#/$defs/consoleColor",
          "default": "Yellow"
        },
        "lockedColor": {
          "$ref": "#/$defs/consoleColor",
          "default": "DarkGray"
        },
        "highlightedNodeColor": {
          "$ref": "#/$defs/consoleColor",
          "default": "White"
        }
      },
      "additionalProperties": false
    }
  },
  "$defs": {
    "consoleColor": {
      "type": "string",
      "enum": [
        "Black", "DarkBlue", "DarkGreen", "DarkCyan",
        "DarkRed", "DarkMagenta", "DarkYellow", "Gray",
        "DarkGray", "Blue", "Green", "Cyan",
        "Red", "Magenta", "Yellow", "White"
      ]
    }
  },
  "additionalProperties": false
}
```

---

## 9. AbilityTreeView Integration

### 9.1 Integration Points

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/UI/AbilityTreeView.cs` (modifications)

```csharp
// Add to AbilityTreeView class

private readonly TreeNodeRenderer _nodeRenderer;

/// <summary>
/// Renders nodes with their current states.
/// </summary>
/// <param name="nodeStates">Dictionary mapping node IDs to their state DTOs.</param>
public void RenderNodesWithState(Dictionary<string, NodeStateDisplayDto> nodeStates)
{
    _nodeRenderer.SetNodePositions(_nodePositions);

    foreach (var (nodeId, stateDto) in nodeStates)
    {
        var nodeLayout = FindNodeLayout(nodeId);
        if (nodeLayout == null)
        {
            _logger.LogWarning("Cannot render state for unknown node {NodeId}", nodeId);
            continue;
        }

        _nodeRenderer.RenderNode(nodeLayout, stateDto.State);
    }

    _logger.LogDebug("Rendered {NodeCount} nodes with state", nodeStates.Count);
}

/// <summary>
/// Updates the selection highlight when navigation changes.
/// </summary>
/// <param name="previousNodeId">The previously selected node ID.</param>
/// <param name="newNodeId">The newly selected node ID.</param>
/// <param name="nodeStates">The current node states for re-rendering.</param>
public void UpdateSelectionHighlight(
    string? previousNodeId,
    string newNodeId,
    Dictionary<string, NodeStateDisplayDto> nodeStates)
{
    // Clear previous highlight
    if (previousNodeId != null)
    {
        _nodeRenderer.SetNodeHighlight(previousNodeId, false);
        if (nodeStates.TryGetValue(previousNodeId, out var prevState))
        {
            var prevLayout = FindNodeLayout(previousNodeId);
            if (prevLayout != null)
            {
                _nodeRenderer.RenderNode(prevLayout, prevState.State);
            }
        }
    }

    // Set new highlight
    _nodeRenderer.SetNodeHighlight(newNodeId, true);
    if (nodeStates.TryGetValue(newNodeId, out var newState))
    {
        var newLayout = FindNodeLayout(newNodeId);
        if (newLayout != null)
        {
            _nodeRenderer.RenderNode(newLayout, newState.State);
        }
    }
}

private NodeLayoutDto? FindNodeLayout(string nodeId)
{
    if (_currentTree == null) return null;

    foreach (var tier in _currentTree.Tiers)
    {
        var node = tier.Nodes.FirstOrDefault(n => n.NodeId == nodeId);
        if (node != null) return node;
    }

    return null;
}
```

### 9.2 CharacterView Updates

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Views/CharacterView.cs` (modifications)

```csharp
// Add to CharacterView class

/// <summary>
/// Creates node state DTOs for all nodes in the tree.
/// </summary>
/// <param name="tree">The ability tree definition.</param>
/// <param name="progress">The player's ability progress.</param>
/// <param name="unspentPoints">The player's unspent talent points.</param>
/// <returns>Dictionary mapping node IDs to state DTOs.</returns>
private Dictionary<string, NodeStateDisplayDto> CreateNodeStatesDtos(
    AbilityTreeDefinition tree,
    PlayerAbilityProgress progress,
    int unspentPoints)
{
    var nodeStates = new Dictionary<string, NodeStateDisplayDto>();

    foreach (var node in tree.GetAllNodes())
    {
        var state = _nodeRenderer.GetNodeState(node, progress, unspentPoints);
        var currentRank = progress.GetRank(node.NodeId);
        var branchId = GetBranchForNode(tree, node);

        nodeStates[node.NodeId] = new NodeStateDisplayDto(
            NodeId: node.NodeId,
            NodeName: node.Name,
            State: state,
            CurrentRank: currentRank,
            MaxRank: node.MaxRank,
            PointCost: node.PointCost,
            Tier: node.Tier,
            BranchId: branchId);
    }

    return nodeStates;
}

/// <summary>
/// Handles ability tree tab with full state rendering.
/// </summary>
private void HandleAbilityTreeTabWithStates()
{
    var player = _gameState.CurrentPlayer;
    if (player == null)
    {
        _logger.LogWarning("Cannot show ability tree - no current player");
        return;
    }

    var tree = _abilityTreeProvider.GetTreeForClass(player.ClassId);
    if (tree == null)
    {
        _logger.LogWarning("No ability tree found for class {ClassId}", player.ClassId);
        return;
    }

    var progress = _talentPointService.GetProgressForPlayer(player.Id);
    var unspentPoints = _talentPointService.GetUnspentPoints(player);

    // Create tree display DTO
    var treeDto = CreateTreeDisplayDto(tree);

    // Render the tree structure
    _abilityTreeView.RenderTree(treeDto);

    // Create and render node states
    var nodeStates = CreateNodeStatesDtos(tree, progress, unspentPoints);
    _abilityTreeView.RenderNodesWithState(nodeStates);

    _logger.LogDebug(
        "Rendered ability tree with states: {Unlocked} unlocked, {Available} available, {Locked} locked",
        nodeStates.Count(kv => kv.Value.State == NodeState.Unlocked),
        nodeStates.Count(kv => kv.Value.State == NodeState.Available),
        nodeStates.Count(kv => kv.Value.State == NodeState.Locked));
}
```

### 9.3 State Legend Display

**Purpose:** Display a legend explaining the state indicators.

```
Legend: [x] Unlocked   ( ) Available   [L] Locked
```

**Integration in AbilityTreeView:**

```csharp
/// <summary>
/// Renders the state legend below the tree display.
/// </summary>
private void RenderStateLegend()
{
    var legendY = _config.StartY + _config.TotalHeight - 2;
    var legend = "Legend: [x] Unlocked   ( ) Available   [L] Locked";

    _terminalService.WriteAt(_config.StartX + _config.Padding, legendY, legend);
}
```

---

## 10. Logging Specifications

### 10.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `TreeNodeRenderer` | Information | Node state batch rendered |
| `TreeNodeRenderer` | Debug | Individual node renders, state determinations |
| `TreeNodeRenderer` | Warning | Node position not found, invalid state |
| `NodeStateRenderer` | Debug | Indicator/color lookups, content formatting |
| `CharacterView` | Information | Tree with states displayed |
| `CharacterView` | Debug | Node states created, counts logged |
| `CharacterView` | Warning | Progress not found for player |

### 10.2 Log Message Examples

```
[INF] TreeNodeRenderer: Rendered 9 nodes with states
[DBG] TreeNodeRenderer: Rendered node power-strike at (10, 12) with state Unlocked
[DBG] TreeNodeRenderer: Node iron-skin state determined: Available (prerequisites met, 3 points available)
[WRN] TreeNodeRenderer: No position found for node unknown-node-id
[DBG] NodeStateRenderer: GetStateIndicator(Unlocked) = "[x]"
[DBG] NodeStateRenderer: GetStateColor(Available) = Yellow
[INF] CharacterView: Displayed ability tree with states: 4 unlocked, 2 available, 3 locked
[DBG] CharacterView: Created node states for 9 nodes in warrior-tree
[WRN] CharacterView: No ability progress found for player abc-123
```

---

## 11. Unit Testing Requirements

### 11.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| NodeStateRenderer | ~3 |
| TreeNodeRenderer | ~2 |
| State Determination | ~1 |
| **Total** | **~6** |

### 11.2 Test Specifications

**File:** `tests/RuneAndRust.Presentation.Tui.Tests/Renderers/NodeStateRendererTests.cs`

```csharp
[TestFixture]
public class NodeStateRendererTests
{
    private NodeStateRenderer _renderer;
    private NodeStateDisplayConfig _config;

    [SetUp]
    public void Setup()
    {
        _config = new NodeStateDisplayConfig();
        _renderer = new NodeStateRenderer(_config);
    }

    [Test]
    [TestCase(NodeState.Unlocked, "[x]")]
    [TestCase(NodeState.Available, "( )")]
    [TestCase(NodeState.Locked, "[L]")]
    public void GetStateIndicator_WithState_ReturnsCorrectIndicator(
        NodeState state, string expectedIndicator)
    {
        // Act
        var result = _renderer.GetStateIndicator(state);

        // Assert
        Assert.That(result, Is.EqualTo(expectedIndicator));
    }

    [Test]
    [TestCase(NodeState.Unlocked, ConsoleColor.Green)]
    [TestCase(NodeState.Available, ConsoleColor.Yellow)]
    [TestCase(NodeState.Locked, ConsoleColor.DarkGray)]
    public void GetStateColor_WithState_ReturnsCorrectColor(
        NodeState state, ConsoleColor expectedColor)
    {
        // Act
        var result = _renderer.GetStateColor(state);

        // Assert
        Assert.That(result, Is.EqualTo(expectedColor));
    }

    [Test]
    public void FormatNodeContent_WithUnlockedState_ContainsCheckIndicator()
    {
        // Arrange
        var node = new NodeLayoutDto(
            NodeId: "power-strike",
            NodeName: "Power Strike",
            Tier: 1,
            DefinitionX: 0,
            DefinitionY: 0,
            BranchId: "berserker");

        // Act
        var result = _renderer.FormatNodeContent(node, NodeState.Unlocked, 11, 3);

        // Assert
        Assert.That(result, Does.Contain("[x]"));
        Assert.That(result, Does.Contain("Power"));
    }
}
```

**File:** `tests/RuneAndRust.Presentation.Tui.Tests/UI/TreeNodeRendererTests.cs`

```csharp
[TestFixture]
public class TreeNodeRendererTests
{
    private Mock<NodeStateRenderer> _mockStateRenderer;
    private Mock<ITerminalService> _mockTerminal;
    private Mock<ITalentPointService> _mockTalentService;
    private Mock<IPrerequisiteValidator> _mockPrereqValidator;
    private Mock<ILogger<TreeNodeRenderer>> _mockLogger;
    private NodeStateDisplayConfig _config;
    private TreeNodeRenderer _renderer;

    [SetUp]
    public void Setup()
    {
        _config = new NodeStateDisplayConfig();
        _mockStateRenderer = new Mock<NodeStateRenderer>(_config);
        _mockTerminal = new Mock<ITerminalService>();
        _mockTalentService = new Mock<ITalentPointService>();
        _mockPrereqValidator = new Mock<IPrerequisiteValidator>();
        _mockLogger = new Mock<ILogger<TreeNodeRenderer>>();

        _renderer = new TreeNodeRenderer(
            _mockStateRenderer.Object,
            _mockTerminal.Object,
            _mockTalentService.Object,
            _mockPrereqValidator.Object,
            _config,
            _mockLogger.Object);
    }

    [Test]
    public void RenderNode_WithValidPosition_WritesToTerminal()
    {
        // Arrange
        var node = new NodeLayoutDto(
            NodeId: "power-strike",
            NodeName: "Power Strike",
            Tier: 1,
            DefinitionX: 0,
            DefinitionY: 0,
            BranchId: "berserker");

        var positions = new Dictionary<string, NodeScreenPosition>
        {
            { "power-strike", new NodeScreenPosition(10, 12) }
        };

        _renderer.SetNodePositions(positions);

        _mockStateRenderer.Setup(r => r.GetStateColor(It.IsAny<NodeState>()))
            .Returns(ConsoleColor.Green);
        _mockStateRenderer.Setup(r => r.FormatNodeContent(
            It.IsAny<NodeLayoutDto>(), It.IsAny<NodeState>(), It.IsAny<int>(), It.IsAny<int>()))
            .Returns("┌─────────┐\n│ [x]Power│\n└─────────┘");

        // Act
        _renderer.RenderNode(node, NodeState.Unlocked);

        // Assert
        _mockTerminal.Verify(t => t.WriteColoredAt(
            10, It.IsAny<int>(), It.IsAny<string>(), ConsoleColor.Green), Times.AtLeastOnce);
    }

    [Test]
    public void SetNodeHighlight_WithTrue_AddsToHighlightedSet()
    {
        // Arrange
        var nodeId = "power-strike";

        // Act
        _renderer.SetNodeHighlight(nodeId, true);
        _renderer.SetNodeHighlight(nodeId, false);

        // Assert - no exception thrown, method executes
        Assert.Pass("Highlight toggling succeeded without error");
    }
}
```

**File:** `tests/RuneAndRust.Presentation.Tui.Tests/UI/NodeStateDeterminationTests.cs`

```csharp
[TestFixture]
public class NodeStateDeterminationTests
{
    private Mock<IPrerequisiteValidator> _mockPrereqValidator;
    private TreeNodeRenderer _renderer;

    [SetUp]
    public void Setup()
    {
        var config = new NodeStateDisplayConfig();
        var stateRenderer = new NodeStateRenderer(config);
        var mockTerminal = new Mock<ITerminalService>();
        var mockTalentService = new Mock<ITalentPointService>();
        _mockPrereqValidator = new Mock<IPrerequisiteValidator>();
        var mockLogger = new Mock<ILogger<TreeNodeRenderer>>();

        _renderer = new TreeNodeRenderer(
            stateRenderer,
            mockTerminal.Object,
            mockTalentService.Object,
            _mockPrereqValidator.Object,
            config,
            mockLogger.Object);
    }

    [Test]
    public void GetNodeState_WhenNodeUnlocked_ReturnsUnlocked()
    {
        // Arrange
        var node = CreateTestNode("power-strike", 1, 2);
        var progress = CreateProgressWithUnlockedNode("power-strike");

        // Act
        var result = _renderer.GetNodeState(node, progress, 5);

        // Assert
        Assert.That(result, Is.EqualTo(NodeState.Unlocked));
    }

    [Test]
    public void GetNodeState_WhenPrerequisitesNotMet_ReturnsLocked()
    {
        // Arrange
        var node = CreateTestNode("cleave", 2, 2);
        var progress = CreateEmptyProgress();

        _mockPrereqValidator.Setup(v => v.ArePrerequisitesMet(It.IsAny<Guid>(), "cleave"))
            .Returns(false);

        // Act
        var result = _renderer.GetNodeState(node, progress, 5);

        // Assert
        Assert.That(result, Is.EqualTo(NodeState.Locked));
    }

    [Test]
    public void GetNodeState_WhenPrerequisitesMetAndHasPoints_ReturnsAvailable()
    {
        // Arrange
        var node = CreateTestNode("cleave", 2, 2);
        var progress = CreateEmptyProgress();

        _mockPrereqValidator.Setup(v => v.ArePrerequisitesMet(It.IsAny<Guid>(), "cleave"))
            .Returns(true);

        // Act
        var result = _renderer.GetNodeState(node, progress, 5);

        // Assert
        Assert.That(result, Is.EqualTo(NodeState.Available));
    }

    [Test]
    public void GetNodeState_WhenPrerequisitesMetButInsufficientPoints_ReturnsLocked()
    {
        // Arrange
        var node = CreateTestNode("cleave", 2, 2);
        var progress = CreateEmptyProgress();

        _mockPrereqValidator.Setup(v => v.ArePrerequisitesMet(It.IsAny<Guid>(), "cleave"))
            .Returns(true);

        // Act
        var result = _renderer.GetNodeState(node, progress, 1); // Only 1 point, need 2

        // Assert
        Assert.That(result, Is.EqualTo(NodeState.Locked));
    }

    #region Test Helpers

    private static AbilityTreeNode CreateTestNode(string nodeId, int tier, int pointCost)
    {
        return AbilityTreeNode.Create(
            nodeId: nodeId,
            name: nodeId.Replace("-", " "),
            description: "Test node",
            tier: tier,
            pointCost: pointCost,
            maxRank: 1,
            position: new NodePosition(0, 0),
            prerequisiteNodeIds: new List<string>());
    }

    private static PlayerAbilityProgress CreateProgressWithUnlockedNode(string nodeId)
    {
        var progress = PlayerAbilityProgress.Create(Guid.NewGuid());
        progress.UnlockNode(nodeId);
        return progress;
    }

    private static PlayerAbilityProgress CreateEmptyProgress()
    {
        return PlayerAbilityProgress.Create(Guid.NewGuid());
    }

    #endregion
}
```

---

## 12. Use Cases

### UC-001: View Node States in Tree

**Actor:** Player
**Flow:** Open character view → Select abilities tab → Tree displays → All nodes show state indicators → Unlocked nodes show `[x]` in green → Available nodes show `( )` in yellow → Locked nodes show `[L]` in gray

### UC-002: Identify Available Nodes

**Actor:** Player
**Flow:** View ability tree → Scan for yellow nodes with `( )` indicator → Identify nodes ready to unlock → See point cost in tooltip (v0.13.2d) → Make unlock decision

### UC-003: Track Progress on Multi-Rank Node

**Actor:** Player
**Flow:** View tree with multi-rank node → See `2/3` progress indicator → Understand current rank vs maximum → Plan next point allocation

### UC-004: Navigate Between Nodes with State Feedback

**Actor:** Player
**Flow:** Navigate to locked node → See gray color and `[L]` indicator → Navigate to available node → See yellow color change and `( )` indicator → Navigate to unlocked node → See green color and `[x]` indicator

### UC-005: View State Legend

**Actor:** Player
**Flow:** View ability tree → See legend at bottom → Understand indicator meanings → Reference legend while exploring tree

---

## 13. Deliverable Checklist

### UI Components
- [ ] `TreeNodeRenderer` class implemented
- [ ] `RenderNode()` method renders node with state
- [ ] `GetNodeState()` method determines node state
- [ ] `SetNodeHighlight()` method toggles highlight
- [ ] `GetNodeBounds()` method returns node bounds

### Renderers
- [ ] `NodeStateRenderer` class implemented
- [ ] `GetStateIndicator()` returns correct symbols
- [ ] `GetStateColor()` returns correct colors
- [ ] `FormatNodeContent()` formats complete node box
- [ ] `GetProgressIndicator()` formats rank progress

### DTOs
- [ ] `NodeState` enum created
- [ ] `NodeStateDisplayDto` record created
- [ ] `NodeRankDisplayDto` record created
- [ ] `NodeBounds` record created

### Configuration
- [ ] `NodeStateDisplayConfig` class created
- [ ] `NodeStateIndicators` class created
- [ ] `NodeStateColors` class created
- [ ] `config/node-state-display.json` created
- [ ] `config/schemas/node-state-display.schema.json` created

### View Integration
- [ ] `AbilityTreeView` updated with `RenderNodesWithState()`
- [ ] `AbilityTreeView` updated with `UpdateSelectionHighlight()`
- [ ] `CharacterView` creates node state DTOs
- [ ] State legend displayed below tree

### Testing
- [ ] ~6 unit tests implemented
- [ ] All tests passing

---

## 14. Acceptance Criteria

### Functional
- [ ] Unlocked nodes show check mark indicator `[x]`
- [ ] Available nodes show circle indicator `( )`
- [ ] Locked nodes show lock indicator `[L]`
- [ ] Node colors match state (green/yellow/gray)
- [ ] State indicators render correctly in node boxes
- [ ] Multi-rank nodes display progress (e.g., "2/3")
- [ ] Selected node highlights with distinct color
- [ ] State legend displays below tree

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~6 unit tests pass
- [ ] Configuration file validates against schema
- [ ] XML documentation complete on all public members
- [ ] No hardcoded values (all configurable)

---

## 15. Dependencies

### Required from v0.13.2a

| Type | Location | Usage in v0.13.2b |
|------|----------|-------------------|
| `AbilityTreeView` | `Presentation.Tui/UI/` | Integration point for state rendering |
| `TreeLayoutRenderer` | `Presentation.Tui/Renderers/` | Node position calculations |
| `NodeLayoutDto` | `Presentation.Tui/DTOs/` | Node display information |
| `NodeScreenPosition` | `Presentation.Tui/DTOs/` | Screen coordinates |
| `AbilityTreeDisplayConfig` | `Presentation.Tui/Configuration/` | Shared layout settings |

### Required from v0.10.2a

| Type | Location | Usage in v0.13.2b |
|------|----------|-------------------|
| `AbilityTreeNode` | `Domain/Definitions/` | Node properties |
| `PlayerAbilityProgress` | `Domain/Entities/` | Player unlock status |
| `ITalentPointService` | `Application/Interfaces/` | Unspent points query |
| `IPrerequisiteValidator` | `Application/Interfaces/` | Prerequisite checking |

### Provides to v0.13.2c

| Type | Usage |
|------|-------|
| `TreeNodeRenderer` | Node bounds for line routing |
| `NodeState` enum | Line state determination |
| `NodeStateDisplayDto` | State information for line colors |

### Provides to v0.13.2d

| Type | Usage |
|------|-------|
| `TreeNodeRenderer` | Selected node for tooltip |
| `NodeState` enum | Tooltip content varies by state |
| `NodeStateDisplayDto` | Tooltip displays rank progress |

---

## 16. Future Considerations

### Deferred to v0.13.2c
- **Prerequisite Lines**: Visual connections between dependent nodes
- **Line States**: Satisfied/unsatisfied line rendering based on NodeState

### Deferred to v0.13.2d
- **Node Tooltips**: Detailed ability information on selection
- **Unlock Action**: Spending talent points to unlock available nodes
- **Talent Point Display**: Available/spent point counter

### Out of Scope
- **State Persistence**: Node states are calculated dynamically, not persisted
- **Animation**: State change animations (flash on unlock, etc.)
- **Sound Effects**: Audio feedback for state changes
- **Talent Point Allocation Logic**: Handled by ITalentPointService

---

*Document Version: 1.0*
*Last Updated: 2026-01-16*
*Author: Claude (AI Assistant)*
