# v0.18.3e Design Specification: TraumaService & Config

**Version:** 0.18.3e
**Parent:** v0.18.3 (Trauma System)
**Prerequisites:** v0.18.3a-d (All previous trauma phases)
**Status:** Design Complete
**Estimated Unit Tests:** ~5

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [TraumaService Implementation](#5-traumaservice-implementation)
6. [TraumaConfiguration](#6-traumaconfiguration)
7. [traumas.json Structure](#7-traumasjson-structure)
8. [Database Schema](#8-database-schema)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Deliverable Checklist](#11-deliverable-checklist)
12. [Acceptance Criteria](#12-acceptance-criteria)
13. [Dependencies](#13-dependencies)
14. [Future Considerations](#14-future-considerations)

---

## 1. Executive Summary

This design specification defines the core trauma logic and JSON configuration system for trauma definitions.

v0.18.3e establishes the **Service Implementation & Configuration Layer** for Trauma by defining:

- `TraumaService` class implementing `ITraumaService`
- `TraumaConfiguration` record for config file structure
- `traumas.json` with 10 base trauma definitions
- Database schema for trauma persistence
- Caching and lookup mechanisms

### Key Deliverables

| Category          | Items                     |
| ----------------- | ------------------------- |
| **Services**      | `TraumaService`           |
| **Configuration** | `TraumaConfiguration`, `traumas.json` |
| **Database**      | character_traumas table, indexes |
| **Tests**         | ~5 unit tests             |

### Trauma Catalog

| ID | Name | Type | Retirement? | Stackable |
| --- | --- | --- | --- | --- |
| survivors-guilt | Survivor's Guilt | Emotional | Yes | No |
| combat-flashbacks | Combat Flashbacks | Cognitive | No | Yes |
| paranoid-ideation | Paranoid Ideation | Cognitive | No | Yes |
| chronic-pain | Chronic Pain | Physical | No | Yes |
| night-terrors | Night Terrors | Emotional | No | Yes |
| touch-aversion | Touch Aversion | Social | No | No |
| reality-doubt | Reality Doubt | Existential | Yes (5+) | Yes |
| machine-affinity | Machine Affinity | Corruption | Yes | No |
| hollow-resonance | Hollow Resonance | Corruption | Yes (3+) | Yes |
| death-wish | Death Wish | Emotional | Yes | No |

---

## 2. Feature Overview

```
v0.18.3e Features
└── Trauma Service Implementation & Configuration
    │
    ├── TraumaService Implementation
    │   ├── Query Methods
    │   │   ├── GetTraumasAsync
    │   │   ├── GetTraumaDefinitionAsync (cached)
    │   │   ├── HasTraumaAsync
    │   │   ├── GetTraumaCountAsync
    │   │   ├── GetTraumaStackCountAsync
    │   │   └── GetActiveEffectsAsync
    │   │
    │   ├── Mutation Methods
    │   │   ├── AcquireTraumaAsync
    │   │   └── CheckRetirementConditionAsync
    │   │
    │   └── Check Methods
    │       └── PerformTraumaCheckAsync
    │
    ├── Configuration Loading
    │   ├── TraumaConfiguration record
    │   ├── traumas.json loading
    │   └── Definition caching
    │
    ├── Database Persistence
    │   ├── ITraumaRepository interface
    │   └── character_traumas table
    │
    └── Dependencies
        ├── ITraumaCheckService
        ├── ITraumaRepository
        ├── ICharacterRepository
        ├── IDiceService
        └── ILogger<TraumaService>
```

---

## 3. Architecture Diagrams

### 3.1 TraumaService Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         ITraumaService                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │            TraumaService (Implementation)                       │    │
│  ├─────────────────────────────────────────────────────────────────┤    │
│  │                                                                 │    │
│  │  Dependencies:                                                  │    │
│  │  + ITraumaCheckService _checkService                           │    │
│  │  + ITraumaRepository _traumaRepository                         │    │
│  │  + ICharacterRepository _characterRepository                   │    │
│  │  + IConfigurationProvider _configProvider                      │    │
│  │  + ILogger<TraumaService> _logger                              │    │
│  │                                                                 │    │
│  │  Data:                                                          │    │
│  │  + Dictionary<string, TraumaDefinition> _traumaDefinitions     │    │
│  │    (cached after load)                                         │    │
│  │                                                                 │    │
│  │  Methods:                                                       │    │
│  │  + GetTraumasAsync(...)                                         │    │
│  │  + GetTraumaDefinitionAsync(...)                               │    │
│  │  + HasTraumaAsync(...)                                         │    │
│  │  + GetTraumaCountAsync(...)                                    │    │
│  │  + GetTraumaStackCountAsync(...)                               │    │
│  │  + AcquireTraumaAsync(...)                                     │    │
│  │  + CheckRetirementConditionAsync(...)                          │    │
│  │  + GetActiveEffectsAsync(...)                                  │    │
│  │  + PerformTraumaCheckAsync(...)                                │    │
│  │  - LoadTraumaDefinitions(...)                                  │    │
│  │  - SelectRandomTrauma(...)                                     │    │
│  │                                                                 │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
         │                    │                    │
         ▼                    ▼                    ▼
    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
    │Repositories │  │  Services   │  │Configuration│
    │             │  │             │  │             │
    │ITraumaRepo  │  │ICheckService│  │traumas.json │
    │ICharRepo    │  │IDiceService │  │             │
    └─────────────┘  └─────────────┘  └─────────────┘
         │                    │                    │
         ▼                    ▼                    ▼
    ┌─────────────────────────────────────────────────┐
    │         Database / External Services            │
    └─────────────────────────────────────────────────┘
```

### 3.2 Configuration Loading Flow

```
┌─────────────────────────────────────────┐
│ TraumaService Initialization            │
└─────────────────┬───────────────────────┘
                  │
                  ▼
        ┌──────────────────────┐
        │ LoadTraumaDefinitions │
        │ (on first request)    │
        └──────────┬───────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │ Read traumas.json    │
        └──────────┬───────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │ Validate against     │
        │ JSON Schema          │
        └──────────┬───────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │ Parse each trauma:   │
        │ - TraumaType enum    │
        │ - TraumaEffects      │
        │ - TraumaTriggers     │
        └──────────┬───────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │ Create TraumaDefn    │
        │ instances            │
        └──────────┬───────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │ Cache in _traumas    │
        │ dictionary           │
        └──────────────────────┘
```

### 3.3 AcquireTrauma Flow with Retirement Check

```
┌──────────────────────────────────────┐
│ AcquireTraumaAsync(charId, traumaId) │
└────────────────┬─────────────────────┘
                 │
                 ▼
        ┌────────────────────┐
        │ Load TraumaDefn    │
        └────────┬───────────┘
                 │
                 ▼
        ┌────────────────────┐
        │ Get Char Traumas   │
        │ from database      │
        └────────┬───────────┘
                 │
                 ▼
        ┌────────────────────┐
        │ Has trauma?        │
        └────┬───────┬──────┘
             │       │
          [YES]    [NO]
             │       │
             ▼       ▼
        Check      Create New
        stackable  CharacterTrauma
             │       │
        ┌────┴──────┴─────┐
        │                 │
        ▼                 ▼
     Increment      Initialize
     StackCount     StackCount=1
        │                 │
        └────┬────────┬──┘
             │        │
             ▼        ▼
        Save to database
             │
             ▼
        Return TraumaAcquisitionResult
             │
             ├─→ Check IsRetirementTrauma
             │       │
             │       ├─→ NO: Return result
             │       │
             │       └─→ YES: Check retirement
             │               │
             │               ▼
             │        CheckRetirementCondition
             │               │
             │               ▼
             │        Return result with
             │        TriggersRetirementCheck
             │        = true
             │
             ▼
        End AcquireTrauma
```

---

## 4. User Stories

### US-18.3e-1: Load Trauma Definitions from Configuration

**As a** content manager
**I want to** define traumas in JSON files
**So that** new traumas can be added without rebuilding

**Acceptance Criteria:**

- traumas.json loads on service initialization
- Definitions are cached after load
- Invalid JSON raises helpful error
- Missing required fields raise validation error

### US-18.3e-2: Persist Character Traumas to Database

**As a** persistence layer
**I want to** store character trauma instances
**So that** trauma state survives session boundaries

**Acceptance Criteria:**

- CharacterTrauma instances save to database
- UNIQUE constraint prevents duplicate traumas
- Stack counts persist correctly
- AcquiredAt and ManagedSince timestamps persist

### US-18.3e-3: Query Traumas from Database

**As a** application logic
**I want to** retrieve character traumas from database
**So that** trauma effects can be applied

**Acceptance Criteria:**

- GetTraumasAsync queries database correctly
- Results are ordered by AcquiredAt
- Filtering by IsActive works
- Query performance is acceptable

### US-18.3e-4: Coordinate Trauma Checks with Acquisition

**As a** check system
**I want to** automatically acquire trauma on failed checks
**So that** mechanics flow seamlessly

**Acceptance Criteria:**

- PerformTraumaCheckAsync combines check + acquisition
- Retirement checks trigger automatically
- Results include all metadata for display

---

## 5. TraumaService Implementation

### 5.1 Purpose

Core implementation of ITraumaService with database persistence and configuration loading.

### 5.2 Class Definition

**File:** `src/Core/RuneAndRust.Application/Services/TraumaService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Services.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Records;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Infrastructure.Persistence.Repositories;

/// <summary>
/// Service for managing character traumas and trauma mechanics.
/// </summary>
/// <remarks>
/// <para>
/// TraumaService coordinates:
/// - Trauma definition loading from traumas.json
/// - Per-character trauma tracking via repository
/// - Trauma acquisition and stacking
/// - Retirement condition evaluation
/// - Trauma effect application
/// - Check coordination with ITraumaCheckService
/// </para>
/// <para>
/// Caches TraumaDefinitions after initial load to minimize file I/O.
/// All database operations go through ITraumaRepository and ICharacterRepository.
/// </para>
/// </remarks>
public class TraumaService : ITraumaService
{
    private readonly ITraumaCheckService _checkService;
    private readonly ITraumaRepository _traumaRepository;
    private readonly ICharacterRepository _characterRepository;
    private readonly IConfigurationProvider _configProvider;
    private readonly ILogger<TraumaService> _logger;

    private Dictionary<string, TraumaDefinition> _traumaDefinitions = new();
    private bool _definitionsLoaded = false;

    /// <summary>
    /// Creates a new TraumaService.
    /// </summary>
    public TraumaService(
        ITraumaCheckService checkService,
        ITraumaRepository traumaRepository,
        ICharacterRepository characterRepository,
        IConfigurationProvider configProvider,
        ILogger<TraumaService> logger)
    {
        _checkService = checkService ?? throw new ArgumentNullException(nameof(checkService));
        _traumaRepository = traumaRepository ?? throw new ArgumentNullException(nameof(traumaRepository));
        _characterRepository = characterRepository ?? throw new ArgumentNullException(nameof(characterRepository));
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<IReadOnlyList<CharacterTrauma>> GetTraumasAsync(Guid characterId)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));

        try
        {
            _logger.LogDebug("Getting traumas for character {CharacterId}", characterId);
            var traumas = await _traumaRepository.GetByCharacterIdAsync(characterId);
            return traumas.OrderBy(t => t.AcquiredAt).ToList().AsReadOnly();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting traumas for character {CharacterId}", characterId);
            throw;
        }
    }

    public async Task<TraumaDefinition> GetTraumaDefinitionAsync(string traumaId)
    {
        if (string.IsNullOrWhiteSpace(traumaId))
            throw new ArgumentException("TraumaId cannot be empty", nameof(traumaId));

        try
        {
            // Load definitions on first call
            if (!_definitionsLoaded)
            {
                await LoadTraumaDefinitionsAsync();
            }

            if (!_traumaDefinitions.TryGetValue(traumaId, out var definition))
            {
                _logger.LogWarning("Trauma definition not found: {TraumaId}", traumaId);
                throw new KeyNotFoundException($"Trauma '{traumaId}' not found in definitions");
            }

            return definition;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting trauma definition {TraumaId}", traumaId);
            throw;
        }
    }

    public async Task<bool> HasTraumaAsync(Guid characterId, string traumaId)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));
        if (string.IsNullOrWhiteSpace(traumaId))
            throw new ArgumentException("TraumaId cannot be empty", nameof(traumaId));

        try
        {
            var trauma = await _traumaRepository.GetByCharacterAndTraumaIdAsync(characterId, traumaId);
            return trauma != null && trauma.IsActive;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking trauma {TraumaId} for character {CharacterId}", traumaId, characterId);
            throw;
        }
    }

    public async Task<int> GetTraumaCountAsync(Guid characterId)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));

        try
        {
            var traumas = await GetTraumasAsync(characterId);
            return traumas.Count(t => t.IsActive);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting trauma count for character {CharacterId}", characterId);
            throw;
        }
    }

    public async Task<int> GetTraumaStackCountAsync(Guid characterId, string traumaId)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));
        if (string.IsNullOrWhiteSpace(traumaId))
            throw new ArgumentException("TraumaId cannot be empty", nameof(traumaId));

        try
        {
            var trauma = await _traumaRepository.GetByCharacterAndTraumaIdAsync(characterId, traumaId);
            return trauma?.StackCount ?? 0;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting stack count for {TraumaId} on {CharacterId}", traumaId, characterId);
            throw;
        }
    }

    public async Task<IReadOnlyList<TraumaEffect>> GetActiveEffectsAsync(Guid characterId)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));

        try
        {
            var traumas = await GetTraumasAsync(characterId);
            var activeTraumas = traumas.Where(t => t.IsActive).ToList();

            var effects = new List<TraumaEffect>();
            foreach (var trauma in activeTraumas)
            {
                var definition = await GetTraumaDefinitionAsync(trauma.TraumaDefinitionId);
                effects.AddRange(definition.Effects);
            }

            return effects.AsReadOnly();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting active effects for character {CharacterId}", characterId);
            throw;
        }
    }

    public async Task<TraumaAcquisitionResult> AcquireTraumaAsync(
        Guid characterId,
        string traumaId,
        string source)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));
        if (string.IsNullOrWhiteSpace(traumaId))
            throw new ArgumentException("TraumaId cannot be empty", nameof(traumaId));
        if (string.IsNullOrWhiteSpace(source))
            throw new ArgumentException("Source cannot be empty", nameof(source));

        try
        {
            // Load definition
            var definition = await GetTraumaDefinitionAsync(traumaId);

            // Verify character exists
            var character = await _characterRepository.GetByIdAsync(characterId);
            if (character == null)
                throw new KeyNotFoundException($"Character '{characterId}' not found");

            // Check if character already has this trauma
            var existingTrauma = await _traumaRepository.GetByCharacterAndTraumaIdAsync(characterId, traumaId);

            TraumaAcquisitionResult result;

            if (existingTrauma == null)
            {
                // New trauma
                var newTrauma = CharacterTrauma.Create(
                    characterId: characterId,
                    traumaDefinitionId: traumaId,
                    source: source,
                    acquiredAt: DateTime.UtcNow
                );

                await _traumaRepository.AddAsync(newTrauma);
                await _traumaRepository.SaveChangesAsync();

                _logger.LogInformation(
                    "Trauma acquired: {CharacterId} {TraumaId} from {Source}",
                    characterId, traumaId, source
                );

                result = TraumaAcquisitionResult.CreateNew(
                    traumaId: traumaId,
                    traumaName: definition.Name,
                    source: source,
                    triggersRetirementCheck: definition.IsRetirementTrauma
                );
            }
            else if (definition.IsStackable)
            {
                // Stack existing
                existingTrauma.IncrementStackCount();
                await _traumaRepository.UpdateAsync(existingTrauma);
                await _traumaRepository.SaveChangesAsync();

                _logger.LogWarning(
                    "Trauma stacked: {CharacterId} {TraumaId} x{StackCount}",
                    characterId, traumaId, existingTrauma.StackCount
                );

                bool triggersRetirement = definition.IsRetirementTrauma &&
                    definition.RetirementCondition?.Contains($"{existingTrauma.StackCount}+") == true;

                result = TraumaAcquisitionResult.CreateStacked(
                    traumaId: traumaId,
                    traumaName: definition.Name,
                    source: source,
                    newStackCount: existingTrauma.StackCount,
                    triggersRetirementCheck: triggersRetirement
                );
            }
            else
            {
                // Non-stackable and already has it
                _logger.LogDebug(
                    "Attempted to stack non-stackable trauma: {CharacterId} {TraumaId}",
                    characterId, traumaId
                );

                result = TraumaAcquisitionResult.CreateFailure(
                    traumaId: traumaId,
                    traumaName: definition.Name,
                    source: source
                );
            }

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error acquiring trauma {TraumaId} for {CharacterId}", traumaId, characterId);
            throw;
        }
    }

    public async Task<RetirementCheckResult> CheckRetirementConditionAsync(Guid characterId)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));

        try
        {
            var traumas = await GetTraumasAsync(characterId);

            var immediateRetirementTraumas = new List<string>();
            var stackingRetirementTraumas = new List<string>();
            var moderateStackedTraumas = new List<string>();

            foreach (var trauma in traumas.Where(t => t.IsActive))
            {
                var definition = await GetTraumaDefinitionAsync(trauma.TraumaDefinitionId);

                if (definition.IsRetirementTrauma)
                {
                    if (definition.RetirementCondition == "On acquisition")
                    {
                        immediateRetirementTraumas.Add(trauma.TraumaDefinitionId);
                    }
                    else if (definition.RetirementCondition?.Contains("+") == true)
                    {
                        // Parse "5+" or "3+" condition
                        var parts = definition.RetirementCondition.Split('+');
                        if (int.TryParse(parts[0], out int threshold) && trauma.StackCount >= threshold)
                        {
                            stackingRetirementTraumas.Add(trauma.TraumaDefinitionId);
                        }
                    }
                }

                if (trauma.StackCount > 1)
                {
                    moderateStackedTraumas.Add(trauma.TraumaDefinitionId);
                }
            }

            var allRetirementTraumas = immediateRetirementTraumas.Concat(stackingRetirementTraumas).ToList();

            if (immediateRetirementTraumas.Count > 0)
            {
                return RetirementCheckResult.CreateMustRetire(
                    characterId: characterId,
                    retirementReason: $"Severe trauma forces immediate retirement",
                    traumasCausingRetirement: allRetirementTraumas
                );
            }

            if (stackingRetirementTraumas.Count > 0)
            {
                return RetirementCheckResult.CreateMustRetire(
                    characterId: characterId,
                    retirementReason: $"Critical trauma stacking forces retirement",
                    traumasCausingRetirement: allRetirementTraumas
                );
            }

            if (moderateStackedTraumas.Count >= 3)
            {
                return RetirementCheckResult.CreateOptional(
                    characterId: characterId,
                    traumasCausingRetirement: moderateStackedTraumas
                );
            }

            return RetirementCheckResult.CreateNoRetirement(characterId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking retirement condition for {CharacterId}", characterId);
            throw;
        }
    }

    public async Task<TraumaCheckResult> PerformTraumaCheckAsync(
        Guid characterId,
        TraumaCheckTrigger trigger)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));

        try
        {
            // Perform check using ITraumaCheckService
            var checkResult = await _checkService.PerformTraumaCheckAsync(characterId, trigger);

            // If failed, acquire trauma
            if (!checkResult.Passed && !string.IsNullOrEmpty(checkResult.TraumaAcquired))
            {
                var acquisitionResult = await AcquireTraumaAsync(
                    characterId: characterId,
                    traumaId: checkResult.TraumaAcquired,
                    source: trigger.ToString()
                );

                _logger.LogWarning(
                    "Trauma check failed: {CharacterId} {Trigger} → {Trauma}",
                    characterId, trigger, checkResult.TraumaAcquired
                );
            }
            else if (checkResult.Passed)
            {
                _logger.LogInformation(
                    "Trauma check passed: {CharacterId} {Trigger}",
                    characterId, trigger
                );
            }

            return checkResult;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error performing trauma check for {CharacterId}", characterId);
            throw;
        }
    }

    private async Task LoadTraumaDefinitionsAsync()
    {
        try
        {
            var config = await _configProvider.GetConfigurationAsync<TraumaConfiguration>("traumas");

            if (config?.Traumas == null || config.Traumas.Count == 0)
                throw new InvalidOperationException("No traumas found in configuration");

            foreach (var traumaConfig in config.Traumas)
            {
                var effects = traumaConfig.Effects?.Select(e =>
                    TraumaEffect.Create(
                        effectType: e.EffectType,
                        target: e.Target,
                        value: e.Value,
                        condition: e.Condition,
                        description: e.Description
                    )
                ).ToList() ?? new List<TraumaEffect>();

                var triggers = traumaConfig.Triggers?.Select(t =>
                    TraumaTrigger.Create(
                        triggerType: t.TriggerType,
                        condition: t.Condition,
                        checkRequired: t.CheckRequired,
                        checkDifficulty: t.CheckDifficulty
                    )
                ).ToList() ?? new List<TraumaTrigger>();

                var definition = TraumaDefinition.Create(
                    traumaId: traumaConfig.Id,
                    name: traumaConfig.Name,
                    type: Enum.Parse<TraumaType>(traumaConfig.Type),
                    description: traumaConfig.Description,
                    flavorText: traumaConfig.FlavorText,
                    isRetirementTrauma: traumaConfig.IsRetirementTrauma,
                    retirementCondition: traumaConfig.RetirementCondition,
                    isStackable: traumaConfig.IsStackable,
                    acquisitionSources: traumaConfig.AcquisitionSources ?? new List<string>(),
                    triggers: triggers,
                    effects: effects
                );

                _traumaDefinitions[traumaConfig.Id] = definition;
            }

            _definitionsLoaded = true;
            _logger.LogInformation("Loaded {TraumaCount} trauma definitions", _traumaDefinitions.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading trauma definitions");
            throw;
        }
    }
}
```

---

## 6. TraumaConfiguration

### 6.1 Purpose

Configuration record structure for deserializing traumas.json.

### 6.2 Definition

**File:** `src/Core/RuneAndRust.Application/Configuration/TraumaConfiguration.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration structure for trauma definitions.
/// </summary>
public record TraumaConfiguration
{
    /// <summary>Gets the version of the configuration format.</summary>
    public string Version { get; init; }

    /// <summary>Gets the list of trauma definitions.</summary>
    public IReadOnlyList<TraumaConfigEntry> Traumas { get; init; }
}

/// <summary>
/// Single trauma definition from configuration.
/// </summary>
public record TraumaConfigEntry
{
    /// <summary>Gets the unique identifier for this trauma.</summary>
    public string Id { get; init; }

    /// <summary>Gets the display name.</summary>
    public string Name { get; init; }

    /// <summary>Gets the trauma type (Cognitive, Emotional, etc.).</summary>
    public string Type { get; init; }

    /// <summary>Gets the mechanical description.</summary>
    public string Description { get; init; }

    /// <summary>Gets the narrative flavor text.</summary>
    public string FlavorText { get; init; }

    /// <summary>Gets whether this is a retirement trauma.</summary>
    public bool IsRetirementTrauma { get; init; }

    /// <summary>Gets the retirement condition description.</summary>
    public string? RetirementCondition { get; init; }

    /// <summary>Gets whether this trauma can stack.</summary>
    public bool IsStackable { get; init; }

    /// <summary>Gets the acquisition sources/triggers.</summary>
    public IReadOnlyList<string> AcquisitionSources { get; init; }

    /// <summary>Gets the triggers for this trauma.</summary>
    public IReadOnlyList<TraumaConfigTrigger> Triggers { get; init; }

    /// <summary>Gets the mechanical effects.</summary>
    public IReadOnlyList<TraumaConfigEffect> Effects { get; init; }
}

/// <summary>
/// Effect definition from configuration.
/// </summary>
public record TraumaConfigEffect
{
    /// <summary>Gets the effect type.</summary>
    public string EffectType { get; init; }

    /// <summary>Gets the effect target.</summary>
    public string Target { get; init; }

    /// <summary>Gets the numeric value (if applicable).</summary>
    public int? Value { get; init; }

    /// <summary>Gets the activation condition (if any).</summary>
    public string? Condition { get; init; }

    /// <summary>Gets the description.</summary>
    public string Description { get; init; }
}

/// <summary>
/// Trigger definition from configuration.
/// </summary>
public record TraumaConfigTrigger
{
    /// <summary>Gets the trigger type.</summary>
    public string TriggerType { get; init; }

    /// <summary>Gets the specific condition (if any).</summary>
    public string? Condition { get; init; }

    /// <summary>Gets whether a check is required.</summary>
    public bool CheckRequired { get; init; }

    /// <summary>Gets the check difficulty (if required).</summary>
    public int? CheckDifficulty { get; init; }
}
```

---

## 7. traumas.json Structure

### 7.1 File Location

`config/traumas.json` (in application root)

### 7.2 JSON Schema

**File:** `config/schemas/traumas.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Trauma Definitions Schema",
  "type": "object",
  "required": ["version", "traumas"],
  "properties": {
    "version": {
      "type": "string",
      "description": "Configuration version",
      "pattern": "^\\d+\\.\\d+$"
    },
    "traumas": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id", "name", "type", "description", "flavorText", "isRetirementTrauma", "isStackable"],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique trauma identifier",
            "pattern": "^[a-z-]+$"
          },
          "name": {
            "type": "string",
            "description": "Display name"
          },
          "type": {
            "type": "string",
            "enum": ["Cognitive", "Emotional", "Physical", "Social", "Existential", "Corruption"]
          },
          "description": {
            "type": "string",
            "description": "Mechanical description"
          },
          "flavorText": {
            "type": "string",
            "description": "Narrative flavor text"
          },
          "isRetirementTrauma": {
            "type": "boolean"
          },
          "retirementCondition": {
            "type": ["string", "null"]
          },
          "isStackable": {
            "type": "boolean"
          },
          "acquisitionSources": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "triggers": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["triggerType"],
              "properties": {
                "triggerType": {
                  "type": "string"
                },
                "condition": {
                  "type": ["string", "null"]
                },
                "checkRequired": {
                  "type": "boolean"
                },
                "checkDifficulty": {
                  "type": ["integer", "null"]
                }
              }
            }
          },
          "effects": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["effectType", "target", "description"],
              "properties": {
                "effectType": {
                  "type": "string"
                },
                "target": {
                  "type": "string"
                },
                "value": {
                  "type": ["integer", "null"]
                },
                "condition": {
                  "type": ["string", "null"]
                },
                "description": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    }
  }
}
```

### 7.3 Sample traumas.json

**File:** `config/traumas.json`

```json
{
  "version": "1.0",
  "traumas": [
    {
      "id": "survivors-guilt",
      "name": "Survivor's Guilt",
      "type": "Emotional",
      "description": "You carry the weight of those who didn't make it.",
      "flavorText": "Why them? Why not me?",
      "isRetirementTrauma": true,
      "retirementCondition": "On acquisition",
      "isStackable": false,
      "acquisitionSources": ["AllyDeath", "PartyWipe"],
      "triggers": [
        {
          "triggerType": "OnRest",
          "checkRequired": true,
          "checkDifficulty": 2
        }
      ],
      "effects": [
        {
          "effectType": "Disadvantage",
          "target": "morale-checks",
          "description": "Disadvantage on morale checks when allies are in danger"
        },
        {
          "effectType": "StressIncrease",
          "value": 5,
          "condition": "OnAllyTakeCriticalHit",
          "description": "+5 stress when ally takes critical damage"
        }
      ]
    },
    {
      "id": "combat-flashbacks",
      "name": "Combat Flashbacks",
      "type": "Cognitive",
      "description": "Intrusive memories of past combat situations.",
      "flavorText": "The sounds, the sights... they won't go away.",
      "isRetirementTrauma": false,
      "retirementCondition": null,
      "isStackable": true,
      "acquisitionSources": ["CombatEvents", "NearDeathExperience"],
      "triggers": [
        {
          "triggerType": "InCombat",
          "checkRequired": true,
          "checkDifficulty": 1
        }
      ],
      "effects": [
        {
          "effectType": "Disadvantage",
          "target": "concentration-checks",
          "description": "Disadvantage on concentration checks during combat"
        },
        {
          "effectType": "Penalty",
          "target": "initiative",
          "value": -1,
          "description": "-1 to initiative rolls"
        }
      ]
    },
    {
      "id": "paranoid-ideation",
      "name": "Paranoid Ideation",
      "type": "Cognitive",
      "description": "Pervasive and intrusive paranoid thoughts.",
      "flavorText": "They're watching. They're always watching.",
      "isRetirementTrauma": false,
      "retirementCondition": null,
      "isStackable": true,
      "acquisitionSources": ["DeceptionEvent", "Betrayal"],
      "triggers": [
        {
          "triggerType": "OnMeetNewNPC",
          "checkRequired": false
        }
      ],
      "effects": [
        {
          "effectType": "Penalty",
          "target": "insight-checks",
          "value": -2,
          "description": "-2 penalty to Insight checks"
        },
        {
          "effectType": "Disadvantage",
          "target": "trust-rolls",
          "description": "Disadvantage on checks to trust NPCs"
        }
      ]
    },
    {
      "id": "chronic-pain",
      "name": "Chronic Pain",
      "type": "Physical",
      "description": "Persistent physical pain from old injuries.",
      "flavorText": "Every movement reminds you of what you've endured.",
      "isRetirementTrauma": false,
      "retirementCondition": null,
      "isStackable": true,
      "acquisitionSources": ["SevereInjury", "NearDeathExperience"],
      "triggers": [],
      "effects": [
        {
          "effectType": "Penalty",
          "target": "physical-activities",
          "value": -1,
          "description": "-1 penalty to Athletics and physical checks"
        },
        {
          "effectType": "Penalty",
          "target": "movement-speed",
          "value": -5,
          "description": "-5 ft movement speed"
        }
      ]
    },
    {
      "id": "night-terrors",
      "name": "Night Terrors",
      "type": "Emotional",
      "description": "Nightmares and terror from your subconscious.",
      "flavorText": "Sleep is no longer refuge.",
      "isRetirementTrauma": false,
      "retirementCondition": null,
      "isStackable": true,
      "acquisitionSources": ["HorrorEvent", "TraumaticExperience"],
      "triggers": [
        {
          "triggerType": "OnRest",
          "checkRequired": true,
          "checkDifficulty": 2
        }
      ],
      "effects": [
        {
          "effectType": "StressIncrease",
          "value": 3,
          "condition": "OnRest",
          "description": "+3 stress during rest periods"
        },
        {
          "effectType": "Penalty",
          "target": "perception-checks",
          "value": -1,
          "condition": "AfterRest",
          "description": "-1 penalty to Perception after rest"
        }
      ]
    },
    {
      "id": "touch-aversion",
      "name": "Touch Aversion",
      "type": "Social",
      "description": "Cannot tolerate being touched by others.",
      "flavorText": "The thought of contact makes your skin crawl.",
      "isRetirementTrauma": false,
      "retirementCondition": null,
      "isStackable": false,
      "acquisitionSources": ["ViolentAssault", "TraumaticContact"],
      "triggers": [],
      "effects": [
        {
          "effectType": "Disadvantage",
          "target": "social-checks",
          "description": "Disadvantage on social checks involving physical contact"
        },
        {
          "effectType": "Penalty",
          "target": "healing-acceptance",
          "value": -2,
          "description": "-2 penalty to accepting healing touch from others"
        }
      ]
    },
    {
      "id": "reality-doubt",
      "name": "Reality Doubt",
      "type": "Existential",
      "description": "You question the nature of reality itself.",
      "flavorText": "Is any of this real? Do I even exist?",
      "isRetirementTrauma": true,
      "retirementCondition": "5+ instances",
      "isStackable": true,
      "acquisitionSources": ["ParadoxExposure", "RuinMadnessExposure"],
      "triggers": [
        {
          "triggerType": "NearParadox",
          "checkRequired": true,
          "checkDifficulty": 2
        }
      ],
      "effects": [
        {
          "effectType": "Disadvantage",
          "target": "perception-checks",
          "description": "Disadvantage on Perception checks (reality doesn't seem reliable)"
        },
        {
          "effectType": "Custom",
          "target": "reality-verification",
          "description": "Must verify reality of ambiguous perceptions"
        }
      ]
    },
    {
      "id": "machine-affinity",
      "name": "[MACHINE AFFINITY]",
      "type": "Corruption",
      "description": "You feel kinship with the machine ghosts.",
      "flavorText": "{ERROR: ORGANIC DESIGNATION DEPRECATED}",
      "isRetirementTrauma": true,
      "retirementCondition": "On acquisition",
      "isStackable": false,
      "acquisitionSources": ["CorruptionThreshold75", "ForlornContact"],
      "triggers": [
        {
          "triggerType": "NearForlorn",
          "checkRequired": false
        }
      ],
      "effects": [
        {
          "effectType": "Bonus",
          "target": "tech-checks",
          "value": 2,
          "description": "+2 bonus to all Technology checks"
        },
        {
          "effectType": "Penalty",
          "target": "social-checks",
          "value": -3,
          "description": "-3 penalty to Social checks with uninfected"
        }
      ]
    },
    {
      "id": "hollow-resonance",
      "name": "Hollow Resonance",
      "type": "Corruption",
      "description": "Your essence echoes with empty frequencies.",
      "flavorText": "You are becoming something... else.",
      "isRetirementTrauma": true,
      "retirementCondition": "3+ instances",
      "isStackable": true,
      "acquisitionSources": ["CorruptionThreshold50", "RuinExplosure"],
      "triggers": [
        {
          "triggerType": "CorruptionThreshold",
          "condition": "every20points",
          "checkRequired": false
        }
      ],
      "effects": [
        {
          "effectType": "Penalty",
          "target": "humanity-checks",
          "value": -2,
          "description": "-2 penalty to maintaining humanity"
        },
        {
          "effectType": "Custom",
          "target": "entity-attraction",
          "description": "Attracts corrupted entities' attention"
        }
      ]
    },
    {
      "id": "death-wish",
      "name": "Death Wish",
      "type": "Emotional",
      "description": "You no longer fear death—you welcome it.",
      "flavorText": "Perhaps it would be better if this all just... ended.",
      "isRetirementTrauma": true,
      "retirementCondition": "On acquisition",
      "isStackable": false,
      "acquisitionSources": ["HollowShellSurvival", "DepthDespair"],
      "triggers": [],
      "effects": [
        {
          "effectType": "Bonus",
          "target": "desperate-actions",
          "value": 1,
          "description": "+1 to desperate or suicidal actions"
        },
        {
          "effectType": "Disadvantage",
          "target": "self-preservation",
          "description": "Disadvantage on checks to preserve yourself"
        }
      ]
    }
  ]
}
```

---

## 8. Database Schema

### 8.1 Character Traumas Table

```sql
CREATE TABLE IF NOT EXISTS character_traumas (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    trauma_definition_id VARCHAR(50) NOT NULL,
    acquired_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    source VARCHAR(100) NOT NULL,
    stack_count INT NOT NULL DEFAULT 1
        CHECK (stack_count >= 1),
    is_active BOOLEAN NOT NULL DEFAULT true,
    managed_since TIMESTAMP,
    notes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_character_trauma
        UNIQUE (character_id, trauma_definition_id)
);

-- Indexes for query performance
CREATE INDEX idx_character_traumas_char_id
    ON character_traumas(character_id);

CREATE INDEX idx_character_traumas_trauma_id
    ON character_traumas(trauma_definition_id);

CREATE INDEX idx_character_traumas_acquired_at
    ON character_traumas(acquired_at DESC);

CREATE INDEX idx_character_traumas_is_active
    ON character_traumas(is_active)
    WHERE is_active = true;
```

### 8.2 Migration SQL (Flyway)

**File:** `src/Infrastructure/RuneAndRust.Infrastructure.Persistence/Migrations/V[version]__AddTraumaSystem.sql`

```sql
-- Create trauma tables
CREATE TABLE IF NOT EXISTS character_traumas (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    trauma_definition_id VARCHAR(50) NOT NULL,
    acquired_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    source VARCHAR(100) NOT NULL,
    stack_count INT NOT NULL DEFAULT 1
        CHECK (stack_count >= 1),
    is_active BOOLEAN NOT NULL DEFAULT true,
    managed_since TIMESTAMP,
    notes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_character_trauma
        UNIQUE (character_id, trauma_definition_id)
);

-- Add indexes
CREATE INDEX idx_character_traumas_char_id
    ON character_traumas(character_id);

CREATE INDEX idx_character_traumas_trauma_id
    ON character_traumas(trauma_definition_id);

CREATE INDEX idx_character_traumas_acquired_at
    ON character_traumas(acquired_at DESC);

CREATE INDEX idx_character_traumas_is_active
    ON character_traumas(is_active)
    WHERE is_active = true;
```

---

## 9. Logging Specifications

### 9.1 Service Logging (TraumaService)

| Event                    | Level       | Template                                                       |
| ------------------------ | ----------- | -------------------------------------------------------------- |
| Get Traumas              | Debug       | `"Getting traumas for character {CharacterId}"`                |
| Trauma Acquired (New)    | Information | `"Trauma acquired: {CharacterId} {TraumaId} from {Source}"`    |
| Trauma Stacked           | Warning     | `"Trauma stacked: {CharacterId} {TraumaId} x{StackCount}"`     |
| Trauma Stack Failed      | Debug       | `"Attempted to stack non-stackable trauma: {CharacterId} {TraumaId}"` |
| Retirement Check         | Warning     | `"Retirement check triggered: {CharacterId}"`                  |
| Mandatory Retirement     | Error       | `"Character must retire: {CharacterId} ({Reason})"`            |
| Trauma Check Failed      | Warning     | `"Trauma check failed: {CharacterId} {Trigger} → {Trauma}"`    |
| Trauma Check Passed      | Information | `"Trauma check passed: {CharacterId} {Trigger}"`               |
| Definitions Loaded       | Information | `"Loaded {TraumaCount} trauma definitions"`                    |
| Loading Error            | Error       | `"Error loading trauma definitions"`                           |

---

## 10. Unit Testing Requirements

### 10.1 Test File Locations

**Files:**
- `tests/RuneAndRust.Application.UnitTests/Services/TraumaServiceTests.cs`

### 10.2 Required Tests

| Test Name | Description |
| --- | --- |
| `GetTraumas_ReturnsAllTraumasOrderedByAcquisition` | Verify query and ordering |
| `AcquireTrauma_NewTrauma_CreatesAndPersists` | Verify new acquisition |
| `AcquireTrauma_StackableTrauma_IncrementsStack` | Verify stacking |
| `CheckRetirementCondition_ImmediateTrauma_ReturnsMustRetire` | Verify immediate retirement |
| `CheckRetirementCondition_Accumulation_ReturnsOptional` | Verify optional retirement |

### 10.3 Example Test

```csharp
[TestFixture]
public class TraumaServiceTests
{
    private TraumaService _service;
    private Mock<ITraumaCheckService> _checkService;
    private Mock<ITraumaRepository> _traumaRepository;
    private Mock<ICharacterRepository> _characterRepository;
    private Mock<IConfigurationProvider> _configProvider;
    private Guid _characterId;

    [SetUp]
    public void Setup()
    {
        _checkService = new Mock<ITraumaCheckService>();
        _traumaRepository = new Mock<ITraumaRepository>();
        _characterRepository = new Mock<ICharacterRepository>();
        _configProvider = new Mock<IConfigurationProvider>();
        _characterId = Guid.NewGuid();

        _service = new TraumaService(
            _checkService.Object,
            _traumaRepository.Object,
            _characterRepository.Object,
            _configProvider.Object,
            NullLogger<TraumaService>.Instance
        );
    }

    [Test]
    public async Task AcquireTrauma_NewTrauma_CreatesAndPersists()
    {
        // Arrange
        var character = CreateMockCharacter(_characterId);
        var traumaDefinition = CreateMockTraumaDefinition("survivors-guilt");

        _characterRepository.Setup(r => r.GetByIdAsync(_characterId))
            .ReturnsAsync(character);
        _traumaRepository.Setup(r => r.GetByCharacterAndTraumaIdAsync(_characterId, "survivors-guilt"))
            .ReturnsAsync((CharacterTrauma)null);
        _configProvider.Setup(c => c.GetConfigurationAsync<TraumaConfiguration>("traumas"))
            .ReturnsAsync(new TraumaConfiguration { Traumas = new[] { traumaDefinition } });

        // Act
        var result = await _service.AcquireTraumaAsync(
            _characterId,
            "survivors-guilt",
            "AllyDeath"
        );

        // Assert
        result.Success.Should().BeTrue();
        result.IsNewTrauma.Should().BeTrue();
        result.NewStackCount.Should().Be(1);
        _traumaRepository.Verify(r => r.AddAsync(It.IsAny<CharacterTrauma>()), Times.Once);
    }
}
```

---

## 11. Deliverable Checklist

### 11.1 Application Layer

- [ ] `src/Core/RuneAndRust.Application/Services/TraumaService.cs`
- [ ] `src/Core/RuneAndRust.Application/Configuration/TraumaConfiguration.cs`
- [ ] `src/Core/RuneAndRust.Application/Services/Interfaces/ITraumaRepository.cs`

### 11.2 Configuration Files

- [ ] `config/traumas.json` (10 base traumas)
- [ ] `config/schemas/traumas.schema.json`

### 11.3 Database

- [ ] `src/Infrastructure/RuneAndRust.Infrastructure.Persistence/Migrations/V[version]__AddTraumaSystem.sql`
- [ ] `src/Infrastructure/RuneAndRust.Infrastructure.Persistence/Repositories/TraumaRepository.cs`

### 11.4 Tests

- [ ] `tests/RuneAndRust.Application.UnitTests/Services/TraumaServiceTests.cs`

### 11.5 Documentation

- [ ] Update `docs/design/v0.18.x/v0.18.3-scope-breakdown.md` (mark v0.18.3 complete)
- [ ] Create `docs/changelogs/v0.18.3-changelog.md` (comprehensive summary)

---

## 12. Acceptance Criteria

### 12.1 Build Verification

- [ ] Solution builds without errors
- [ ] Solution builds without warnings in new code

### 12.2 Test Verification

- [ ] All new unit tests pass (~5 tests)
- [ ] All existing unit tests continue to pass

### 12.3 Functional Verification

- [ ] TraumaService loads definitions from traumas.json on first call
- [ ] Definitions are cached after loading
- [ ] AcquireTraumaAsync creates new traumas correctly
- [ ] AcquireTraumaAsync increments stack for stackable traumas
- [ ] AcquireTraumaAsync fails for non-stackable duplicates
- [ ] CheckRetirementConditionAsync evaluates all conditions
- [ ] GetActiveEffectsAsync returns correct trauma effects
- [ ] PerformTraumaCheckAsync acquires trauma on failed check
- [ ] Database queries return correct results
- [ ] traumas.json validates against schema
- [ ] All 10 base traumas load correctly

### 12.4 Performance Verification

- [ ] Definition loading completes in < 1 second
- [ ] GetTraumasAsync query < 100ms for average character
- [ ] Trauma acquisition completes in < 500ms

---

## 13. Dependencies

### 13.1 Required Prerequisites

| Dependency                | Version | Usage                            |
| ------------------------- | ------- | -------------------------------- |
| Trauma Enums & Definitions | v0.18.3a | TraumaType, TraumaDefinition    |
| CharacterTrauma Entity    | v0.18.3b | Persistence entity              |
| Trauma Check System       | v0.18.3c | ITraumaCheckService for checks  |
| ITraumaService Interface  | v0.18.3d | Contract to implement           |
| Dice System               | v0.6.x  | IDiceService for checks         |
| Configuration System      | v0.x.x  | Load traumas.json               |
| Database (PostgreSQL)     | 12+     | Trauma persistence              |

### 13.2 Provides to Application Layer

| Type | Usage |
| --- | --- |
| `ITraumaService` | Combat, rest, events for trauma mechanics |
| `TraumaService` | Dependency injection registration |
| `ITraumaRepository` | Data access for traumas |

### 13.3 Consumed by Game Systems

| Consumer | Methods |
| --- | --- |
| Combat System | PerformTraumaCheckAsync, GetActiveEffectsAsync |
| Character UI | GetTraumasAsync, GetTraumaCountAsync |
| Rest System | PerformTraumaCheckAsync |
| Event Systems | AcquireTraumaAsync, CheckRetirementConditionAsync |
| Character Retirement | CheckRetirementConditionAsync |

---

## 14. Future Considerations

### 14.1 v0.18.5 (Trauma Integration)

- Integration with combat event system
- Integration with rest mechanics
- Trauma check triggering on specific game events
- Trauma effect application to character rolls

### 14.2 v0.19.x (Trauma UI)

- Visual trauma indicators in character sheet
- Trauma history timeline
- Trauma effect tooltips
- Retirement decision interface

### 14.3 v0.22.x (Trauma Therapy)

- Therapy and recovery service
- Trauma management/suppression mechanics
- Recovery progress tracking
- Interaction with ManagedSince timestamp

### 14.4 Future Enhancements

- Weighted random trauma selection (by category fit)
- Custom modifier system (traits affecting checks)
- Trauma streaming (multiple checks from single event)
- Trauma interaction matrix (conflicting/synergistic traumas)
- NPC trauma tracking and effects
- Dialogue changes based on character traumas

---

*This design specification provides the complete blueprint for implementing v0.18.3e. The TraumaService layer completes the Trauma System with production-ready implementation.*

---

## Changelog

| Version | Date       | Changes                        |
| ------- | ---------- | ------------------------------ |
| 1.0     | 2026-01-28 | Initial design specification   |
