> **Archived** - This changelog has been consolidated. See the complete version at [v0.2.3](../v0.2.x/v0.2.3.md).

# v0.2.3b Changelog: The Engine (Ability Logic)

**Release Date:** 2025-12-20
**Milestone:** v0.2.3 - The Hero's Toolkit (2 of 3)
**Test Count:** 1509 tests (39 new)

---

## Summary

This release implements the **AbilityService** to parse and execute data-driven abilities using an **EffectScript** system. Players can now define abilities with stamina/aether costs, cooldown tracking, and multi-effect execution through semicolon-delimited command strings. The EffectScript parser supports three core commands: DAMAGE (dice-based damage with type-specific armor interactions), HEAL (flat restoration clamped to MaxHP), and STATUS (status effect application with configurable duration and stacks). This implementation completes the second layer of v0.2.3's hero toolkit, building on v0.2.3a's resource management foundation and preparing for v0.2.3c's ability database integration.

---

## New Features

### EffectScript Parsing System

Abilities are defined using a semicolon-separated command syntax that allows chaining multiple effects:

| Command | Format | Example | Behavior |
|---------|--------|---------|----------|
| DAMAGE  | `DAMAGE:Type:Dice` | `DAMAGE:Physical:2d6` | Rolls dice, applies vulnerability multiplier, Physical damage is reduced by armor soak |
| HEAL    | `HEAL:Amount` | `HEAL:15` | Restores flat HP amount, clamped to MaxHP |
| STATUS  | `STATUS:Type:Duration:Stacks` | `STATUS:Bleeding:3:2` | Applies status effect with optional stack count (defaults to 1) |

**Example Multi-Effect Ability:**
```
EffectScript: "DAMAGE:Physical:3d6;STATUS:Bleeding:2:1"
```
This ability deals 3d6 physical damage (subject to armor soak) and applies 1 stack of Bleeding for 2 turns.

### Damage Type Interactions

Physical damage is reduced by armor soak, while non-physical damage types (Fire, Cold, Poison, etc.) bypass armor:

- **Physical Damage:** `FinalDamage = max(0, (RolledDamage * VulnerabilityMultiplier) - ArmorSoak)`
- **Non-Physical Damage:** `FinalDamage = RolledDamage * VulnerabilityMultiplier`

This creates tactical depth where heavily armored enemies are vulnerable to magical attacks.

### Cooldown Management

Abilities with `CooldownTurns > 0` are tracked per-combatant in a `Dictionary<Guid, int>`:

- **On Use:** Cooldown value is set to the ability's `CooldownTurns`
- **Turn Start:** All cooldowns are decremented by 1 via `ProcessCooldowns()`
- **Ready State:** Cooldowns reaching 0 are removed from the dictionary

### Resource Integration

The AbilityService validates and deducts costs through the ResourceService:

- **Stamina Cost:** Standard action cost for physical abilities
- **Aether Cost:** Magical abilities with Mystic Overcast support (HP-to-AP conversion at 2:1 ratio)
- **Validation Order:** Cooldown check → Stamina check → Aether check

---

## New Files

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/ActiveAbility.cs` | Ability definition entity with costs, cooldowns, range, and EffectScript |
| `RuneAndRust.Core/Models/Combat/AbilityResult.cs` | Execution result record containing success status, narrative message, and effect totals |
| `RuneAndRust.Core/Interfaces/IAbilityService.cs` | Service contract for ability validation, execution, and cooldown processing |
| `RuneAndRust.Engine/Services/AbilityService.cs` | EffectScript parser with DAMAGE, HEAL, and STATUS command implementations |
| `RuneAndRust.Tests/Engine/AbilityServiceTests.cs` | 39 unit tests covering all execution paths and edge cases |

---

## Modified Files

| File | Changes |
|------|---------|
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added `Cooldowns` property (`Dictionary<Guid, int>`) for per-ability cooldown tracking |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `IAbilityService` dependency; integrated `ProcessCooldowns()` call in `NextTurn()` |
| `RuneAndRust.Terminal/Program.cs` | Registered `IAbilityService` as Singleton in DI container |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added `IAbilityService` mock to CombatService constructor calls |

---

## Code Implementation Details

### ActiveAbility Entity

```csharp
public class ActiveAbility
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;        // "Power Strike", "Flame Bolt"
    public string Description { get; set; } = string.Empty; // AAM-VOICE compliant flavor text
    public int StaminaCost { get; set; }                    // 0 for free abilities
    public int AetherCost { get; set; }                     // 0 for non-magical abilities
    public int CooldownTurns { get; set; }                  // 0 for no cooldown
    public int Range { get; set; } = 1;                     // 0=Self, 1=Melee, >1=Ranged
    public string EffectScript { get; set; } = string.Empty; // Semicolon-separated commands
}
```

**Key Behaviors:**
- `Id` is auto-generated GUID for cooldown dictionary key
- `Range` property exists but is not yet validated (future feature)
- `EffectScript` is parsed at execution time, not at ability creation

### AbilityResult Record

```csharp
public record AbilityResult(
    bool Success,
    string Message,
    int TotalDamage = 0,
    int TotalHealing = 0,
    List<string>? StatusesApplied = null)
{
    public static AbilityResult Failure(string reason);
    public static AbilityResult Ok(string message, int damage = 0, int healing = 0, List<string>? statuses = null);
}
```

**Key Behaviors:**
- Immutable record type for clean return semantics
- `TotalDamage` and `TotalHealing` aggregate across all commands in a multi-effect script
- `StatusesApplied` contains status effect names (e.g., "Bleeding", "Poisoned") for UI display
- `Message` is a narrative string for combat log integration (e.g., "Hero uses Power Strike on Goblin! Deals 12 physical damage.")

### IAbilityService Interface

```csharp
public interface IAbilityService
{
    bool CanUse(Combatant user, ActiveAbility ability);
    AbilityResult Execute(Combatant user, Combatant target, ActiveAbility ability);
    void ProcessCooldowns(Combatant combatant);
    int GetCooldownRemaining(Combatant combatant, Guid abilityId);
}
```

**Key Behaviors:**
- `CanUse()` performs non-destructive validation (cooldown, resources)
- `Execute()` deducts resources, sets cooldown, then parses EffectScript
- `ProcessCooldowns()` decrements all cooldowns by 1 and removes expired entries
- `GetCooldownRemaining()` returns 0 if ability is ready, else remaining turns

### AbilityService Implementation

**Constructor Dependencies:**
```csharp
public AbilityService(
    IResourceService resourceService,
    IStatusEffectService statusEffectService,
    IDiceService diceService,
    ILogger<AbilityService> logger)
```

**DAMAGE Command Execution:**
- Parses dice notation using regex pattern `(\d+)d(\d+)` (e.g., "2d6" → count=2, sides=6)
- Rolls dice via `IDiceService.RollSingle()` in a loop
- Applies vulnerability multiplier from `IStatusEffectService.GetDamageMultiplier(target)`
- Physical damage is reduced by `target.ArmorSoak + IStatusEffectService.GetSoakModifier(target)`
- Non-physical damage bypasses soak entirely
- Damage is clamped to 0 minimum (cannot heal via negative damage)

**HEAL Command Execution:**
- Parses flat integer amount from command parameter
- Applies healing: `target.CurrentHp += amount`
- Clamped to MaxHP: `actualHealing = min(amount, MaxHp - CurrentHp)`
- Returns actual healing done (0 if target is already at full HP)

**STATUS Command Execution:**
- Parses `StatusEffectType` enum from string (case-insensitive)
- Defaults to 1 stack if stack parameter is omitted
- Applies effect via `IStatusEffectService.ApplyEffect()` in a loop for multiple stacks
- Unknown status types are logged and skipped (no failure)

**Cooldown Processing:**
- Iterates through `Combatant.Cooldowns` dictionary
- Decrements each value by 1
- Collects expired ability IDs (value ≤ 0) and removes them after iteration
- Empty cooldown dictionary is handled gracefully (no-op)

### Combatant Model Extension

```csharp
public Dictionary<Guid, int> Cooldowns { get; set; } = new();
```

**Key Behaviors:**
- Key is `ActiveAbility.Id` (GUID)
- Value is remaining turns until ability is ready
- Initialized as empty dictionary (not null)
- Combat-volatile: cleared when combat ends

---

## Logging Matrix

### AbilityService Logs

| Event | Level | Template |
|-------|-------|----------|
| Service Init | Information | `"AbilityService initialized"` |
| Can Use Check | Debug | `"[Ability] {User} checking if can use {Ability}"` |
| On Cooldown | Debug | `"[Ability] {User} cannot use {Ability}: on cooldown ({Remaining} turns)"` |
| Insufficient Stamina | Debug | `"[Ability] {User} cannot use {Ability}: insufficient stamina ({Cost} required, {Current} available)"` |
| Insufficient Aether | Debug | `"[Ability] {User} cannot use {Ability}: insufficient aether ({Cost} required, {Current} available)"` |
| Ability Ready | Debug | `"[Ability] {User} can use {Ability}"` |
| Execution Start | Information | `"[Ability] {User} uses {Ability} on {Target}"` |
| Execution Failure | Warning | `"[Ability] {User} failed to use {Ability}: {Reason}"` |
| Cooldown Set | Debug | `"[Ability] {User} ability {Ability} on cooldown: {Turns} turns"` |
| Empty EffectScript | Warning | `"[Ability] {Ability} has no EffectScript"` |
| Parsing EffectScript | Debug | `"[Ability] Parsing EffectScript: {Script}"` |
| Executing Command | Debug | `"[Ability] Executing command: {Command}"` |
| Unknown Command | Warning | `"[Ability] Unknown command type: {CommandType}"` |
| DAMAGE Applied | Information | `"[Ability] DAMAGE: {User} deals {Damage} {Type} damage to {Target} (rolled {Roll}, soak applied)"` |
| HEAL Applied | Information | `"[Ability] HEAL: {Target} healed for {Amount} HP (actual: {Actual})"` |
| STATUS Applied | Information | `"[Ability] STATUS: Applied {Type} to {Target} (Duration: {Duration}, Stacks: {Stacks})"` |
| Execution Complete | Information | `"[Ability] {User} used {Ability} on {Target}: {Message}"` |
| Cooldowns Processed | Trace | `"[Ability] Processing cooldowns for {Combatant}: {Count} active"` |
| Cooldown Expired | Debug | `"[Ability] {Combatant} ability {AbilityId} cooldown expired"` |
| Cooldown Decremented | Trace | `"[Ability] Decremented {AbilityId} cooldown to {Remaining}"` |
| Invalid Dice Notation | Warning | `"[Ability] Invalid dice notation: {Notation}"` |
| DAMAGE Missing Params | Warning | `"[Ability] DAMAGE command missing parameters: {Parts}"` |
| HEAL Missing Params | Warning | `"[Ability] HEAL command missing amount parameter"` |
| HEAL Invalid Amount | Warning | `"[Ability] HEAL command has invalid amount: {Amount}"` |
| STATUS Missing Params | Warning | `"[Ability] STATUS command missing parameters: {Parts}"` |
| Unknown Status Type | Warning | `"[Ability] Unknown status effect type: {Type}"` |
| STATUS Invalid Duration | Warning | `"[Ability] STATUS command has invalid duration: {Duration}"` |

---

## Test Coverage

### Summary

**Total Tests:** 1509 (up from 1470 in v0.2.3a)
**New Tests:** 39
**Test Class:** `AbilityServiceTests`
**Test Duration:** 554ms (entire test suite)
**Pass Rate:** 100% (0 failures)

### Complete Test Inventory

#### CanUse Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `CanUse_OnCooldown_ReturnsFalse` | Ability with remaining cooldown turns cannot be used |
| `CanUse_InsufficientStamina_ReturnsFalse` | Validates stamina cost via ResourceService |
| `CanUse_InsufficientAether_ReturnsFalse` | Validates aether cost via ResourceService |
| `CanUse_AllConditionsMet_ReturnsTrue` | Ability is usable when cooldown and resources are available |
| `CanUse_ZeroCooldownRemaining_ReturnsTrue` | Expired cooldown (value=0) does not block usage |
| `CanUse_NoCosts_ReturnsTrue` | Free abilities (0 stamina, 0 aether) always pass cost check |

#### Execute Tests - Resource Handling (4 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_DeductsStaminaCost` | Verifies ResourceService.Deduct() is called with stamina cost |
| `Execute_DeductsAetherCost` | Verifies ResourceService.Deduct() is called with aether cost |
| `Execute_SetsCooldown` | Cooldown value is set in Cooldowns dictionary after execution |
| `Execute_CannotUse_ReturnsFailure` | Execution aborts and returns failure result if CanUse() fails |

#### Execute Tests - DAMAGE Command (7 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_DamageScript_RollsDice` | DiceService.RollSingle() is called correct number of times for dice notation |
| `Execute_DamageScript_AppliesDamageToTarget` | Target.CurrentHp is reduced by rolled damage amount |
| `Execute_PhysicalDamage_AppliesArmorSoak` | Physical damage subtracts target's ArmorSoak before applying |
| `Execute_NonPhysicalDamage_IgnoresArmorSoak` | Non-physical damage types (Fire, Cold, etc.) bypass armor |
| `Execute_DamageScript_AppliesVulnerabilityMultiplier` | Damage is multiplied by StatusEffectService.GetDamageMultiplier() |
| `Execute_DamageScript_ReturnsDamageAmount` | AbilityResult.TotalDamage reflects final damage dealt |
| `Execute_DamageCannotGoNegative` | Damage is clamped to 0 when soak exceeds rolled damage |

#### Execute Tests - HEAL Command (4 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_HealScript_RestoresHp` | Target.CurrentHp is increased by healing amount |
| `Execute_HealScript_ClampsToMaxHp` | Healing cannot exceed target's MaxHp |
| `Execute_HealScript_ReturnsHealingAmount` | AbilityResult.TotalHealing reflects amount healed |
| `Execute_HealScript_ReturnsActualHealingWhenClamped` | TotalHealing is actual amount healed, not requested amount |

#### Execute Tests - STATUS Command (4 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_StatusScript_AppliesEffect` | StatusEffectService.ApplyEffect() is called with correct parameters |
| `Execute_StatusScript_AppliesMultipleStacks` | ApplyEffect() is called N times for N stacks |
| `Execute_StatusScript_ReturnsStatusApplied` | AbilityResult.StatusesApplied contains status effect name |
| `Execute_StatusScript_DefaultsToOneStack` | Omitting stack parameter defaults to 1 stack application |

#### Execute Tests - Combined Scripts (3 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_CombinedScript_AppliesAllEffects` | Multi-command EffectScript executes all commands in sequence |
| `Execute_CombinedScript_DamageAndHeal` | Damage and healing are both applied and summed correctly |
| `Execute_ReturnsSuccessWithMessage` | AbilityResult.Message contains user name, ability name, and target name |

#### ProcessCooldowns Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `ProcessCooldowns_DecrementsValues` | Cooldown values are decremented by 1 |
| `ProcessCooldowns_RemovesExpired` | Cooldowns reaching 0 are removed from dictionary |
| `ProcessCooldowns_HandlesMultipleCooldowns` | Multiple cooldowns are processed independently in one call |
| `ProcessCooldowns_EmptyCooldowns_DoesNothing` | Empty cooldown dictionary does not throw exception |

#### GetCooldownRemaining Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetCooldownRemaining_ReturnsRemainingTurns` | Returns correct cooldown value from dictionary |
| `GetCooldownRemaining_NotOnCooldown_ReturnsZero` | Returns 0 if ability ID is not in Cooldowns dictionary |

#### Edge Cases (5 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_EmptyEffectScript_ReturnsSuccessWithMessage` | Empty EffectScript produces success result with "nothing happens" message |
| `Execute_InvalidDiceNotation_HandleGracefully` | Invalid dice notation (e.g., "invalid") is logged and skipped without exception |
| `Execute_UnknownCommand_IgnoresAndContinues` | Unknown command types are logged and skipped, execution continues |
| `Execute_UnknownStatusEffect_DoesNotApply` | Invalid StatusEffectType names are logged and skipped |
| `Execute_SelfTarget_Works` | Abilities targeting user (self-heal, self-buff) execute correctly |

---

## DI Registration

### Program.cs (RuneAndRust.Terminal)

```csharp
// Line 82 - Combat Services section
services.AddSingleton<IAbilityService, AbilityService>();
```

**Lifetime:** Singleton (no mutable state, thread-safe)
**Registration Order:** After `IResourceService`, before `ICombatService`

### CombatService Constructor (Breaking Change)

**Before (v0.2.3a):**
```csharp
public CombatService(
    GameState gameState,
    IInitiativeService initiative,
    IAttackResolutionService attackResolution,
    ILootService lootService,
    IStatusEffectService statusEffects,
    IEnemyAIService aiService,
    ICreatureTraitService traitService,
    IResourceService resourceService,
    ILogger<CombatService> logger)
```

**After (v0.2.3b):**
```csharp
public CombatService(
    GameState gameState,
    IInitiativeService initiative,
    IAttackResolutionService attackResolution,
    ILootService lootService,
    IStatusEffectService statusEffects,
    IEnemyAIService aiService,
    ICreatureTraitService traitService,
    IResourceService resourceService,
    IAbilityService abilityService,  // NEW
    ILogger<CombatService> logger)
```

### CombatService Integration

Cooldowns are processed at the start of each combatant's turn:

```csharp
// Line 187-188 in CombatService.NextTurn()
// Process ability cooldowns at turn start (v0.2.3b)
_abilityService.ProcessCooldowns(active);
```

**Execution Order:**
1. Status effect tick damage/expiration
2. Creature trait triggers
3. Ability cooldown processing (NEW in v0.2.3b)
4. Stamina regeneration
5. Defending stance reset
6. Turn begins

---

## Architecture

### Service Dependency Graph

```
┌─────────────────────────────────────────────────────────────────┐
│                        AbilityService                           │
│  - EffectScript Parser                                          │
│  - Cooldown Manager                                             │
│  - Narrative Generator                                          │
└─────────────────────────────────────────────────────────────────┘
       │                    │                    │
       ▼                    ▼                    ▼
┌─────────────┐   ┌──────────────────┐   ┌────────────────────┐
│ ResourceSvc │   │ StatusEffectSvc  │   │   DiceService      │
│ - CanAfford │   │ - ApplyEffect    │   │   - RollSingle     │
│ - Deduct    │   │ - GetMultiplier  │   │                    │
└─────────────┘   │ - GetSoakMod     │   └────────────────────┘
                  └──────────────────┘

       ▲
       │
┌─────────────────────────────────────────────────────────────────┐
│                        CombatService                             │
│  - NextTurn() calls ProcessCooldowns()                          │
│  - Future: PlayerAction() will call Execute()                   │
└─────────────────────────────────────────────────────────────────┘
```

### EffectScript Execution Flow

```
Execute(user, target, ability)
    │
    ├─ 1. Validate: CanUse(user, ability)
    │     ├─ Check: Cooldown remaining?
    │     ├─ Check: ResourceService.CanAfford(Stamina)?
    │     └─ Check: ResourceService.CanAfford(Aether)?
    │
    ├─ 2. Deduct Resources
    │     ├─ ResourceService.Deduct(Stamina, cost)
    │     └─ ResourceService.Deduct(Aether, cost)
    │
    ├─ 3. Set Cooldown
    │     └─ user.Cooldowns[abilityId] = cooldownTurns
    │
    ├─ 4. Parse EffectScript
    │     └─ Split by ';' → foreach command:
    │           ├─ DAMAGE:Type:Dice
    │           │     ├─ Parse dice notation with regex
    │           │     ├─ Roll dice (loop: RollSingle)
    │           │     ├─ Apply vulnerability multiplier
    │           │     ├─ If Physical: subtract soak
    │           │     └─ target.CurrentHp -= damage
    │           │
    │           ├─ HEAL:Amount
    │           │     ├─ Parse integer amount
    │           │     ├─ Calculate: min(amount, MaxHp - CurrentHp)
    │           │     └─ target.CurrentHp += actual
    │           │
    │           └─ STATUS:Type:Duration:Stacks
    │                 ├─ Parse StatusEffectType enum
    │                 ├─ Parse duration (int)
    │                 ├─ Parse stacks (int, default 1)
    │                 └─ Loop: ApplyEffect(type, duration) × stacks
    │
    └─ 5. Build Narrative
          ├─ Construct message: "{User} uses {Ability} on {Target}!"
          ├─ Append command narratives
          └─ Return AbilityResult(Success, Message, TotalDamage, TotalHealing, Statuses)
```

### Cooldown Processing Flow (Turn Start)

```
CombatService.NextTurn()
    │
    ├─ Determine active combatant
    │
    ├─ Process status effects
    │
    ├─ ProcessCooldowns(active)
    │     │
    │     ├─ foreach (abilityId, remainingTurns) in Cooldowns:
    │     │     ├─ newValue = remainingTurns - 1
    │     │     ├─ if newValue <= 0:
    │     │     │     └─ Mark for removal (expired)
    │     │     └─ else:
    │     │           └─ Cooldowns[abilityId] = newValue
    │     │
    │     └─ foreach (expired abilityId):
    │           └─ Cooldowns.Remove(abilityId)
    │
    ├─ Regenerate stamina
    │
    └─ Reset defending stance
```

---

## Known Limitations

1. **No UI Integration:** Abilities are not yet exposed in combat commands. Player cannot use abilities in v0.2.3b.
2. **No Ability Database:** Abilities must be manually instantiated. Character ability loadout is not persisted.
3. **Range Validation Not Implemented:** `ActiveAbility.Range` property exists but is not checked during execution.
4. **No Target Validation:** Abilities can target dead combatants or invalid targets.
5. **No Self-Only Flag:** Self-buff abilities can incorrectly target enemies.
6. **EffectScript Errors Are Silent:** Invalid commands are logged but execution continues. No feedback to player about partial failures.
7. **No Dice Roll Display:** Damage calculations show final result but not individual die rolls.

---

## Migration Notes

### For Developers

If you have custom `CombatService` instantiations, you must now provide an `IAbilityService`:

```csharp
// Update your DI registration
services.AddSingleton<IAbilityService, AbilityService>();
```

### For Tests

Existing `CombatService` tests need to mock `IAbilityService`:

```csharp
private readonly Mock<IAbilityService> _mockAbilityService = new Mock<IAbilityService>();

// Add to constructor
_mockAbilityService.Setup(a => a.ProcessCooldowns(It.IsAny<Combatant>()));

_sut = new CombatService(
    _gameState,
    _mockInitiative.Object,
    _mockAttackResolution.Object,
    _mockLootService.Object,
    _mockStatusEffects.Object,
    _mockAIService.Object,
    _mockTraitService.Object,
    _mockResourceService.Object,
    _mockAbilityService.Object,  // NEW
    _mockLogger.Object);
```

### Combatant Initialization

The `Cooldowns` dictionary is automatically initialized as empty in the Combatant constructor. No migration needed for existing combatants.

---

## Verification Results

### Build Output

```
Build succeeded.
    0 Warning(s)
    0 Error(s)
```

### Test Output

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
VSTest version 17.14.1 (arm64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:  1509, Skipped:     0, Total:  1509, Duration: 554 ms
```

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   ├── ActiveAbility.cs         [NEW]
│   ├── Character.cs
│   ├── Enemy.cs
│   └── ...
├── Enums/
│   ├── AttackOutcome.cs         [NEW - v0.2.3a pre-work]
│   ├── AttackType.cs            [NEW - v0.2.3a pre-work]
│   ├── ResourceType.cs
│   └── ...
├── Interfaces/
│   ├── IAbilityService.cs       [NEW]
│   ├── IAttackResolutionService.cs [NEW - v0.2.3a pre-work]
│   ├── IResourceService.cs
│   └── ...
├── Models/Combat/
│   ├── AbilityResult.cs         [NEW]
│   ├── AttackResult.cs          [NEW - v0.2.3a pre-work]
│   ├── Combatant.cs             [MODIFIED - added Cooldowns property]
│   └── ...

RuneAndRust.Engine/Services/
├── AbilityService.cs            [NEW]
├── AttackResolutionService.cs   [NEW - v0.2.3a pre-work]
├── CombatService.cs             [MODIFIED - added IAbilityService dependency]
├── ResourceService.cs
└── ...

RuneAndRust.Terminal/
├── Program.cs                   [MODIFIED - registered IAbilityService]
└── ...

RuneAndRust.Tests/Engine/
├── AbilityServiceTests.cs       [NEW - 39 tests]
├── AttackResolutionServiceTests.cs [NEW - v0.2.3a pre-work]
├── CombatServiceTests.cs        [MODIFIED - added IAbilityService mock]
├── ResourceServiceTests.cs
└── ...
```

---

## Running Tests

### Full Test Suite
```bash
dotnet test
```

### AbilityService Tests Only
```bash
dotnet test --filter "FullyQualifiedName~AbilityServiceTests"
```

### Specific Test Method
```bash
dotnet test --filter "FullyQualifiedName~AbilityServiceTests.Execute_DamageScript_AppliesDamageToTarget"
```

### List All Tests
```bash
dotnet test --list-tests | grep AbilityServiceTests
```

---

## Next Steps (v0.2.3c)

- Create `ActiveAbility` database table with migration script
- Seed starter abilities for Warrior, Scout, and Mystic archetypes
- Add `CharacterAbilities` junction table for many-to-many relationship
- Integrate ability selection into character creation flow
- Expose "use ability" command in combat UI (`use [ability name] on [target]`)
- Display available abilities with cooldown status in combat screen
- Add ability tooltips showing costs, cooldown, and effects
- Implement ability unlock/progression system

---

## Contributors

- Implementation: Claude Opus 4.5
