# v0.10.1c Design Specification: Environmental Combat

**Version:** 0.10.1c
**Parent:** v0.10.1 (Combat Actions)
**Prerequisites:** v0.10.1b Complete (Combat Stances)
**Status:** Design Complete
**Estimated Unit Tests:** ~13

---

## 1. Overview

### Purpose

Implement environmental combat interactions including push abilities that move targets, knockback on critical hits, and hazard interactions when pushed into dangerous terrain. This adds tactical depth through battlefield manipulation, allowing players to gain positional advantages by pushing enemies into hazards or off key positions.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | `IEnvironmentalCombatService`, `IHazardProvider` |
| **Services** | `EnvironmentalCombatService`, `HazardProvider` |
| **Enums** | `HazardType` |
| **DTOs** | `PushResult`, `HazardDamageResult`, `HazardDefinition` |
| **Events** | `EntityPushedEvent`, `EntityKnockedBackEvent`, `HazardDamageEvent` |
| **Configuration** | `hazards.json` |
| **Tests** | ~13 unit tests |

---

## 2. Feature Overview

```
v0.10.1c Features
â”œâ”€â”€ HazardType Enum
â”‚   â”œâ”€â”€ Lava (3d6 fire, burning)
â”‚   â”œâ”€â”€ Spikes (2d6 piercing, bleeding)
â”‚   â”œâ”€â”€ Pit (2d6 bludgeoning, prone)
â”‚   â””â”€â”€ Acid (2d4 acid, armor degradation)
â”‚
â”œâ”€â”€ IEnvironmentalCombatService Interface
â”‚   â”œâ”€â”€ Push(pusher, target, direction, distance)
â”‚   â”œâ”€â”€ Knockback(target, sourcePosition, distance)
â”‚   â”œâ”€â”€ IsHazard(position)
â”‚   â”œâ”€â”€ GetHazardType(position)
â”‚   â”œâ”€â”€ ApplyHazardDamage(target, position)
â”‚   â”œâ”€â”€ TickHazards(combatants)
â”‚   â””â”€â”€ ProcessCriticalKnockback(attackResult)
â”‚
â”œâ”€â”€ Push Mechanics
â”‚   â”œâ”€â”€ Opposed STR check (pusher vs target)
â”‚   â”œâ”€â”€ Move 1-2 cells in direction
â”‚   â”œâ”€â”€ Blocked by walls/entities
â”‚   â””â”€â”€ Triggers hazard on entry
â”‚
â”œâ”€â”€ Knockback Mechanics
â”‚   â”œâ”€â”€ No opposed check (forced movement)
â”‚   â”œâ”€â”€ Direction away from source
â”‚   â”œâ”€â”€ 1 cell on critical hit
â”‚   â””â”€â”€ Triggers hazard on entry
â”‚
â”œâ”€â”€ Hazard System
â”‚   â”œâ”€â”€ HazardDefinition with damage dice
â”‚   â”œâ”€â”€ Damage on enter
â”‚   â”œâ”€â”€ Damage per turn (for some)
â”‚   â”œâ”€â”€ Status effect application
â”‚   â””â”€â”€ HazardProvider for config
â”‚
â””â”€â”€ Configuration (hazards.json)
    â”œâ”€â”€ Lava, Spikes, Pit, Acid
    â””â”€â”€ Damage dice, types, effects
```

---

## 3. Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ENVIRONMENTAL COMBAT ARCHITECTURE                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      Combat System         â”‚
                      â”‚   (Abilities, Critical)    â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                       â–¼                       â–¼
     [Push Ability]          [Critical Hit]          [Forced Movement]
              â”‚                       â”‚                       â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ IEnvironmentalCombatServiceâ”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ + Push(target, direction) â”‚
                      â”‚ + Knockback(target, from) â”‚
                      â”‚ + CheckHazard(position)   â”‚
                      â”‚ + ApplyHazardDamage()     â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ EnvironmentalCombatService â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ - CalculatePushPath       â”‚
                      â”‚ - CheckCollisions         â”‚
                      â”‚ - TriggerHazardEffect     â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    PUSH ABILITY
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Before:                          After:
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”               â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚ M â”‚   â”‚ ğŸ”¥â”‚               â”‚   â”‚   â”‚ M â”‚ ğŸ”¥â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤     PUSH      â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ @ â”‚   â”‚   â”‚   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚ @ â”‚   â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   (2 cells)   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚   â”‚               â”‚   â”‚   â”‚   â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜               â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    
    @ = Player   M = Monster   ğŸ”¥ = Lava (hazard)
```

---

## 4. HazardType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/HazardType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of environmental hazards on the combat grid.
/// </summary>
public enum HazardType
{
    /// <summary>Molten lava dealing fire damage each turn.</summary>
    Lava,

    /// <summary>Sharp spikes dealing piercing damage on entry.</summary>
    Spikes,

    /// <summary>A deep pit causing fall damage and prone.</summary>
    Pit,

    /// <summary>Corrosive acid dealing acid damage and degrading armor.</summary>
    Acid
}
```

---

## 5. HazardDefinition DTO

**File:** `src/Core/RuneAndRust.Application/DTOs/HazardDefinition.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Defines a hazard type and its effects.
/// </summary>
public record HazardDefinition
{
    /// <summary>The hazard type.</summary>
    public HazardType Type { get; init; }

    /// <summary>Display name.</summary>
    public string Name { get; init; } = null!;

    /// <summary>Description.</summary>
    public string Description { get; init; } = null!;

    /// <summary>Dice notation for damage.</summary>
    public string DamageDice { get; init; } = null!;

    /// <summary>Damage type (fire, piercing, etc.).</summary>
    public string DamageType { get; init; } = null!;

    /// <summary>Status effect to apply (if any).</summary>
    public string? StatusEffectId { get; init; }

    /// <summary>Whether damage is dealt on entry.</summary>
    public bool DamageOnEnter { get; init; }

    /// <summary>Whether damage is dealt each turn while in hazard.</summary>
    public bool DamagePerTurn { get; init; }

    /// <summary>Whether target needs to spend action to escape (pit).</summary>
    public bool RequiresClimbOut { get; init; }

    /// <summary>Whether the hazard degrades armor (acid).</summary>
    public bool DegradesArmor { get; init; }

    /// <summary>Icon path.</summary>
    public string? IconPath { get; init; }
}
```

---

## 6. PushResult Record

**File:** `src/Core/RuneAndRust.Application/DTOs/PushResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of a push or knockback attempt.
/// </summary>
public record PushResult
{
    public bool WasPushed { get; init; }
    public bool WasResisted { get; init; }
    public bool WasBlocked { get; init; }
    public bool HitHazard { get; init; }
    public GridPosition StartPosition { get; init; }
    public GridPosition EndPosition { get; init; }
    public int CellsMoved { get; init; }
    public int? PusherRoll { get; init; }
    public int? TargetRoll { get; init; }
    public HazardDamageResult? HazardDamage { get; init; }

    public static PushResult Success(GridPosition start, GridPosition end, int cellsMoved)
        => new()
        {
            WasPushed = true,
            StartPosition = start,
            EndPosition = end,
            CellsMoved = cellsMoved
        };

    public static PushResult Resisted(int pusherRoll, int targetRoll)
        => new()
        {
            WasResisted = true,
            PusherRoll = pusherRoll,
            TargetRoll = targetRoll
        };

    public static PushResult Blocked(GridPosition position)
        => new()
        {
            WasBlocked = true,
            StartPosition = position,
            EndPosition = position,
            CellsMoved = 0
        };

    public static PushResult PushedIntoHazard(
        GridPosition start,
        GridPosition end,
        int cellsMoved,
        HazardDamageResult hazardDamage)
        => new()
        {
            WasPushed = true,
            HitHazard = true,
            StartPosition = start,
            EndPosition = end,
            CellsMoved = cellsMoved,
            HazardDamage = hazardDamage
        };
}
```

---

## 7. HazardDamageResult Record

**File:** `src/Core/RuneAndRust.Application/DTOs/HazardDamageResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of hazard damage application.
/// </summary>
public record HazardDamageResult
{
    public bool DamageTaken { get; init; }
    public HazardType? HazardType { get; init; }
    public int Damage { get; init; }
    public string? DamageType { get; init; }
    public string? StatusEffectApplied { get; init; }
    public bool RequiresClimbAction { get; init; }

    public static HazardDamageResult NoHazard()
        => new() { DamageTaken = false };

    public static HazardDamageResult DamageApplied(
        HazardType hazardType,
        int damage,
        string? statusEffect = null,
        bool requiresClimb = false)
        => new()
        {
            DamageTaken = true,
            HazardType = hazardType,
            Damage = damage,
            StatusEffectApplied = statusEffect,
            RequiresClimbAction = requiresClimb
        };
}
```

---

## 8. IHazardProvider Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IHazardProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides hazard definitions from configuration.
/// </summary>
public interface IHazardProvider
{
    /// <summary>Gets a hazard definition by type.</summary>
    HazardDefinition? GetHazard(HazardType type);

    /// <summary>Gets all hazard definitions.</summary>
    IReadOnlyList<HazardDefinition> GetAllHazards();
}
```

---

## 9. IEnvironmentalCombatService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IEnvironmentalCombatService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for environmental combat interactions.
/// </summary>
public interface IEnvironmentalCombatService
{
    /// <summary>Pushes a target in a direction.</summary>
    /// <param name="pusher">The entity doing the pushing.</param>
    /// <param name="target">The entity being pushed.</param>
    /// <param name="direction">Direction to push.</param>
    /// <param name="distance">Number of cells to push.</param>
    /// <returns>Result of the push attempt.</returns>
    PushResult Push(ICombatant pusher, ICombatant target, Direction direction, int distance = 1);

    /// <summary>Knocks back a target away from a source position.</summary>
    /// <param name="target">The entity being knocked back.</param>
    /// <param name="sourcePosition">Position to knock back from.</param>
    /// <param name="distance">Number of cells.</param>
    /// <returns>Result of the knockback.</returns>
    PushResult Knockback(ICombatant target, GridPosition sourcePosition, int distance = 1);

    /// <summary>Checks if a position contains a hazard.</summary>
    bool IsHazard(GridPosition position);

    /// <summary>Gets the hazard type at a position.</summary>
    HazardType? GetHazardType(GridPosition position);

    /// <summary>Applies hazard damage to an entity at a position.</summary>
    HazardDamageResult ApplyHazardDamage(ICombatant target, GridPosition position);

    /// <summary>Processes hazards for all entities at turn start.</summary>
    void TickHazards(IEnumerable<ICombatant> combatants);

    /// <summary>Applies knockback on critical hit.</summary>
    void ProcessCriticalKnockback(AttackResult attackResult);

    /// <summary>Gets the direction from source to target.</summary>
    Direction GetDirectionToward(GridPosition from, GridPosition to);

    /// <summary>Gets the direction away from source.</summary>
    Direction GetDirectionAway(GridPosition current, GridPosition source);
}
```

---

## 10. EnvironmentalCombatService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/EnvironmentalCombatService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class EnvironmentalCombatService : IEnvironmentalCombatService
{
    private readonly ICombatGrid _grid;
    private readonly IDamageService _damageService;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IDiceService _diceService;
    private readonly IEventBus _eventBus;
    private readonly IHazardProvider _hazardProvider;
    private readonly ILogger<EnvironmentalCombatService> _logger;

    public EnvironmentalCombatService(
        ICombatGrid grid,
        IDamageService damageService,
        IBuffDebuffService buffDebuffService,
        IDiceService diceService,
        IEventBus eventBus,
        IHazardProvider hazardProvider,
        ILogger<EnvironmentalCombatService> logger)
    {
        _grid = grid;
        _damageService = damageService;
        _buffDebuffService = buffDebuffService;
        _diceService = diceService;
        _eventBus = eventBus;
        _hazardProvider = hazardProvider;
        _logger = logger;
    }

    public PushResult Push(ICombatant pusher, ICombatant target, Direction direction, int distance = 1)
    {
        // Opposed STR check
        var pusherRoll = _diceService.Roll("1d20") + pusher.GetModifier("strength");
        var targetRoll = _diceService.Roll("1d20") + target.GetModifier("strength");

        if (targetRoll >= pusherRoll)
        {
            _logger.LogInformation("{Target} resisted push from {Pusher} ({TargetRoll} vs {PusherRoll})",
                target.Name, pusher.Name, targetRoll, pusherRoll);
            _eventBus.Publish(new PushResistedEvent(pusher.Id, target.Id, pusherRoll, targetRoll));
            return PushResult.Resisted(pusherRoll, targetRoll);
        }

        return ExecutePush(target, direction, distance, pusher.Id);
    }

    public PushResult Knockback(ICombatant target, GridPosition sourcePosition, int distance = 1)
    {
        // Calculate direction away from source
        var direction = GetDirectionAway(target.Position, sourcePosition);

        // No opposed check for knockback (forced movement)
        return ExecutePush(target, direction, distance, null);
    }

    private PushResult ExecutePush(ICombatant target, Direction direction, int distance, Guid? pusherId)
    {
        var startPosition = target.Position;
        var finalPosition = startPosition;
        var cellsMoved = 0;
        var hazardEncountered = false;
        HazardType? hazardType = null;

        for (int i = 0; i < distance; i++)
        {
            var nextPosition = finalPosition.Move(direction);

            // Check for walls or blocking entities
            if (!_grid.IsPassable(nextPosition))
            {
                _logger.LogDebug("Push blocked at {Position} by obstacle", nextPosition);
                break;
            }

            finalPosition = nextPosition;
            cellsMoved++;

            // Check for hazard
            if (IsHazard(finalPosition))
            {
                hazardEncountered = true;
                hazardType = GetHazardType(finalPosition);
                _logger.LogDebug("Target pushed into hazard at {Position}", finalPosition);
                break; // Stop on hazard
            }
        }

        if (cellsMoved == 0)
        {
            return PushResult.Blocked(startPosition);
        }

        // Move the target
        target.SetPosition(finalPosition);

        _logger.LogInformation("{Target} pushed {Cells} cells from {Start} to {End}",
            target.Name, cellsMoved, startPosition, finalPosition);

        if (pusherId.HasValue)
        {
            _eventBus.Publish(new EntityPushedEvent(target.Id, startPosition, finalPosition, pusherId.Value));
        }
        else
        {
            _eventBus.Publish(new EntityKnockedBackEvent(target.Id, startPosition, finalPosition));
        }

        // Apply hazard damage if pushed into hazard
        if (hazardEncountered)
        {
            var hazardResult = ApplyHazardDamage(target, finalPosition);
            return PushResult.PushedIntoHazard(startPosition, finalPosition, cellsMoved, hazardResult);
        }

        return PushResult.Success(startPosition, finalPosition, cellsMoved);
    }

    public bool IsHazard(GridPosition position)
    {
        var terrain = _grid.GetTerrain(position);
        return terrain?.IsHazard == true;
    }

    public HazardType? GetHazardType(GridPosition position)
    {
        var terrain = _grid.GetTerrain(position);
        return terrain?.HazardType;
    }

    public HazardDamageResult ApplyHazardDamage(ICombatant target, GridPosition position)
    {
        var hazardType = GetHazardType(position);
        if (hazardType is null)
        {
            return HazardDamageResult.NoHazard();
        }

        var hazardDef = _hazardProvider.GetHazard(hazardType.Value);
        if (hazardDef is null)
        {
            _logger.LogWarning("No hazard definition for {HazardType}", hazardType);
            return HazardDamageResult.NoHazard();
        }

        var damage = _diceService.Roll(hazardDef.DamageDice);

        _damageService.ApplyDamage(target, damage, hazardDef.DamageType);

        _logger.LogInformation("{Target} took {Damage} {Type} damage from {Hazard}",
            target.Name, damage, hazardDef.DamageType, hazardDef.Name);

        // Apply status effect if any
        if (hazardDef.StatusEffectId is not null)
        {
            _buffDebuffService.ApplyEffect(target, hazardDef.StatusEffectId);
            _logger.LogDebug("Applied {Effect} to {Target} from hazard", hazardDef.StatusEffectId, target.Name);
        }

        _eventBus.Publish(new HazardDamageEvent(target.Id, hazardType.Value, damage, hazardDef.DamageType));

        return HazardDamageResult.DamageApplied(
            hazardType.Value,
            damage,
            hazardDef.StatusEffectId,
            hazardDef.RequiresClimbOut);
    }

    public void TickHazards(IEnumerable<ICombatant> combatants)
    {
        foreach (var combatant in combatants)
        {
            if (!combatant.IsAlive) continue;

            var hazardType = GetHazardType(combatant.Position);
            if (hazardType is null) continue;

            var hazardDef = _hazardProvider.GetHazard(hazardType.Value);
            if (hazardDef?.DamagePerTurn == true)
            {
                ApplyHazardDamage(combatant, combatant.Position);
            }
        }
    }

    public void ProcessCriticalKnockback(AttackResult attackResult)
    {
        if (!attackResult.IsCritical || attackResult.Target is null || attackResult.Attacker is null)
        {
            return;
        }

        _logger.LogInformation("Critical hit! Knockback triggered on {Target}", attackResult.Target.Name);
        Knockback(attackResult.Target, attackResult.Attacker.Position, distance: 1);
    }

    public Direction GetDirectionToward(GridPosition from, GridPosition to)
    {
        var dx = to.X - from.X;
        var dy = to.Y - from.Y;

        // Prioritize cardinal directions
        if (Math.Abs(dx) >= Math.Abs(dy))
        {
            return dx > 0 ? Direction.East : Direction.West;
        }
        return dy > 0 ? Direction.South : Direction.North;
    }

    public Direction GetDirectionAway(GridPosition current, GridPosition source)
    {
        // Opposite of direction toward
        var toward = GetDirectionToward(current, source);
        return toward switch
        {
            Direction.North => Direction.South,
            Direction.South => Direction.North,
            Direction.East => Direction.West,
            Direction.West => Direction.East,
            _ => Direction.North
        };
    }
}
```

---

## 11. HazardProvider Implementation

**File:** `src/Core/RuneAndRust.Infrastructure/Providers/HazardProvider.cs`

```csharp
namespace RuneAndRust.Infrastructure.Providers;

public class HazardProvider : IHazardProvider
{
    private readonly Dictionary<HazardType, HazardDefinition> _hazards;
    private readonly ILogger<HazardProvider> _logger;

    public HazardProvider(IConfigurationProvider configProvider, ILogger<HazardProvider> logger)
    {
        _logger = logger;
        _hazards = LoadHazards(configProvider);
    }

    private Dictionary<HazardType, HazardDefinition> LoadHazards(IConfigurationProvider configProvider)
    {
        var hazards = new Dictionary<HazardType, HazardDefinition>();
        var config = configProvider.GetSection<HazardsConfig>("hazards.json");

        foreach (var hazardData in config.Hazards)
        {
            if (Enum.TryParse<HazardType>(hazardData.Type, out var hazardType))
            {
                var definition = new HazardDefinition
                {
                    Type = hazardType,
                    Name = hazardData.Name,
                    Description = hazardData.Description,
                    DamageDice = hazardData.DamageDice,
                    DamageType = hazardData.DamageType,
                    StatusEffectId = hazardData.StatusEffectId,
                    DamageOnEnter = hazardData.DamageOnEnter,
                    DamagePerTurn = hazardData.DamagePerTurn,
                    RequiresClimbOut = hazardData.RequiresClimbOut,
                    DegradesArmor = hazardData.DegradesArmor,
                    IconPath = hazardData.Icon
                };

                hazards[hazardType] = definition;
                _logger.LogDebug("Loaded hazard: {Name} ({Type})", definition.Name, hazardType);
            }
        }

        _logger.LogInformation("Loaded {Count} hazard definitions", hazards.Count);
        return hazards;
    }

    public HazardDefinition? GetHazard(HazardType type)
    {
        return _hazards.GetValueOrDefault(type);
    }

    public IReadOnlyList<HazardDefinition> GetAllHazards()
    {
        return _hazards.Values.ToList();
    }
}
```

---

## 12. Environmental Combat Events

**File:** `src/Core/RuneAndRust.Application/Events/EnvironmentalCombatEvents.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>Published when an entity is pushed.</summary>
public record EntityPushedEvent(
    Guid TargetId,
    GridPosition StartPosition,
    GridPosition EndPosition,
    Guid PusherId);

/// <summary>Published when an entity is knocked back.</summary>
public record EntityKnockedBackEvent(
    Guid TargetId,
    GridPosition StartPosition,
    GridPosition EndPosition);

/// <summary>Published when a push is resisted.</summary>
public record PushResistedEvent(
    Guid PusherId,
    Guid TargetId,
    int PusherRoll,
    int TargetRoll);

/// <summary>Published when an entity takes hazard damage.</summary>
public record HazardDamageEvent(
    Guid TargetId,
    HazardType HazardType,
    int Damage,
    string DamageType);

/// <summary>Published when an entity enters a pit.</summary>
public record EntityFellInPitEvent(
    Guid TargetId,
    GridPosition PitPosition);
```

---

## 13. Configuration File

**File:** `config/hazards.json`

```json
{
  "$schema": "./schemas/hazards.schema.json",
  "hazards": [
    {
      "type": "Lava",
      "name": "Lava",
      "description": "Molten rock dealing fire damage. Burns those who stand within.",
      "damageDice": "3d6",
      "damageType": "fire",
      "statusEffectId": "burning",
      "damageOnEnter": true,
      "damagePerTurn": true,
      "requiresClimbOut": false,
      "degradesArmor": false,
      "icon": "icons/hazards/lava.png"
    },
    {
      "type": "Spikes",
      "name": "Spike Trap",
      "description": "Sharp spikes that impale those who step on them.",
      "damageDice": "2d6",
      "damageType": "piercing",
      "statusEffectId": "bleeding",
      "damageOnEnter": true,
      "damagePerTurn": false,
      "requiresClimbOut": false,
      "degradesArmor": false,
      "icon": "icons/hazards/spikes.png"
    },
    {
      "type": "Pit",
      "name": "Pit",
      "description": "A deep pit that causes fall damage and leaves victims prone.",
      "damageDice": "2d6",
      "damageType": "bludgeoning",
      "statusEffectId": "prone",
      "damageOnEnter": true,
      "damagePerTurn": false,
      "requiresClimbOut": true,
      "degradesArmor": false,
      "icon": "icons/hazards/pit.png"
    },
    {
      "type": "Acid",
      "name": "Acid Pool",
      "description": "Corrosive acid that damages health and degrades armor over time.",
      "damageDice": "2d4",
      "damageType": "acid",
      "statusEffectId": null,
      "damageOnEnter": true,
      "damagePerTurn": true,
      "requiresClimbOut": false,
      "degradesArmor": true,
      "icon": "icons/hazards/acid.png"
    }
  ]
}
```

---

## 14. Push and Knockback Flow Visualization

```
PUSH FLOW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Player uses Push ability on Goblin (2 cells East)
              â”‚
              â–¼
  Opposed STR Check
  â”œâ”€â”€ Player: 1d20+3 (STR) = 15
  â””â”€â”€ Goblin: 1d20+0 (STR) = 8
              â”‚
              â”œâ”€â”€ Goblin roll >= Player roll? NO â†’ Push succeeds
              â”‚
              â–¼
  Calculate Push Path (2 cells East)
              â”‚
  Cell 1: â”€â”€â”€â–¶ Check passable? YES â†’ Move
  Cell 2: â”€â”€â”€â–¶ Check passable? YES â†’ Check hazard? 
              â”‚                           â”‚
              â”‚                           â”œâ”€â”€ No hazard â†’ Move
              â”‚                           â””â”€â”€ Hazard! â†’ Stop + Damage
              â”‚
              â–¼
  Final Position: (5, 2) in Lava
              â”‚
              â–¼
  Apply Hazard Damage
  â”œâ”€â”€ Roll 3d6 = 11 fire damage
  â”œâ”€â”€ Apply "burning" status
  â””â”€â”€ Publish HazardDamageEvent
              â”‚
              â–¼
  PushResult.PushedIntoHazard(start, end, 2, hazardResult)


CRITICAL KNOCKBACK FLOW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  [AttackResult: Critical Hit!]
              â”‚
              â–¼
  ProcessCriticalKnockback(attackResult)
              â”‚
              â”œâ”€â”€ IsCritical? YES
              â”œâ”€â”€ Target exists? YES
              â”‚
              â–¼
  Calculate direction away from attacker
              â”‚
              â”œâ”€â”€ Attacker at (2, 2)
              â”œâ”€â”€ Target at (3, 2)
              â””â”€â”€ Direction = East
              â”‚
              â–¼
  Knockback(target, (2,2), distance: 1)
              â”‚
              â””â”€â”€ No STR check for knockback
              â”‚
              â–¼
  Target moves 1 cell East to (4, 2)


HAZARD SUMMARY:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Hazard  â”‚ Damage   â”‚ Type        â”‚ Per Turn?  â”‚ Effect   â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ ğŸ”¥ Lava â”‚ 3d6      â”‚ Fire        â”‚ YES        â”‚ Burning  â”‚
  â”‚ âš¡ Spikeâ”‚ 2d6      â”‚ Piercing    â”‚ NO         â”‚ Bleeding â”‚
  â”‚ â¬› Pit  â”‚ 2d6      â”‚ Bludgeoning â”‚ NO         â”‚ Prone*   â”‚
  â”‚ ğŸ’§ Acid â”‚ 2d4      â”‚ Acid        â”‚ YES        â”‚ Armor-   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  * Pit requires action to climb out
```

---

## 15. Unit Testing Requirements (~13 tests)

| Feature | Tests |
|---------|-------|
| Push moves target in direction | 1 |
| Push with opposed STR check | 1 |
| Push resisted when target wins | 1 |
| Push blocked by walls | 1 |
| Push blocked by entities | 1 |
| Knockback calculates away direction | 1 |
| Knockback no STR check | 1 |
| Critical hit triggers knockback | 1 |
| IsHazard detects hazards | 1 |
| Hazard damage applied correctly | 1 |
| Hazard status effect applied | 1 |
| TickHazards damages per-turn hazards | 1 |
| Push into hazard triggers damage | 1 |

---

## 16. Acceptance Criteria

- [ ] Push moves target in specified direction
- [ ] Push uses opposed STR check
- [ ] Target wins tie on STR check
- [ ] Push blocked by walls and entities
- [ ] Push can move 1-2 cells based on ability
- [ ] Knockback moves target away from source
- [ ] Knockback has no opposed check
- [ ] Critical hits trigger 1-cell knockback
- [ ] Hazard positions detected correctly
- [ ] Lava deals 3d6 fire damage and burning
- [ ] Spikes deal 2d6 piercing on entry only
- [ ] Pit deals 2d6 bludgeoning, applies prone, requires climb
- [ ] Acid deals 2d4 acid per turn
- [ ] Pushed into hazard triggers damage
- [ ] TickHazards processes per-turn damage
- [ ] All events published correctly
- [ ] ~13 unit tests pass

---

## 17. Dependencies

| From | Required |
|------|----------|
| v0.10.1a/b | Combat actions, stances |
| v0.10.0 | `IBuffDebuffService` for status effects |
| Domain | `ICombatGrid`, `GridPosition`, `Direction` |
| Application | `IDamageService`, `IDiceService`, `IEventBus` |

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
