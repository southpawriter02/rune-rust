# v0.7.3b Design Specification: Grid Interaction

**Version:** 0.7.3b
**Parent:** v0.7.3 (Combat Integration)
**Prerequisites:** v0.7.3a Complete (Combat Grid Display)
**Status:** Design Complete
**Estimated Unit Tests:** ~8

---

## Table of Contents

1. [Overview](#1-overview)
2. [Feature Overview](#2-feature-overview)
3. [Architecture](#3-architecture)
4. [Grid Interaction Service Interface](#4-grid-interaction-service-interface)
5. [Grid Interaction Service Implementation](#5-grid-interaction-service-implementation)
6. [Interaction Modes](#6-interaction-modes)
7. [Range Highlighting](#7-range-highlighting)
8. [Grid Panel Integration](#8-grid-panel-integration)
9. [Data Model Changes](#9-data-model-changes)
10. [Logging Specifications](#10-logging-specifications)
11. [Unit Testing Requirements](#11-unit-testing-requirements)
12. [Use Cases](#12-use-cases)
13. [Deliverable Checklist](#13-deliverable-checklist)
14. [Acceptance Criteria](#14-acceptance-criteria)
15. [Dependencies](#15-dependencies)
16. [Future Considerations](#16-future-considerations)

---

## 1. Overview

### Purpose

This phase implements click-based interaction with the combat grid for movement and targeting. Players can click on cells to move their character, click on enemies to attack, and preview ability areas of effect. The system supports different interaction modes (movement, attack, ability) with visual range highlighting and provides cancellation via right-click or Escape.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | `IGridInteractionService` |
| **Services** | `GridInteractionService` |
| **Records** | `HighlightedCell`, `TargetingResult` |
| **Enums** | `GridInteractionMode` |
| **Event Handlers** | Cell click, cell hover, cancel actions |
| **Tests** | ~8 unit tests |

### Design Principles

1. **Modal Interaction**: Clear modes for movement, attack, ability
2. **Visual Feedback**: Highlighted cells show valid targets
3. **Intuitive Controls**: Left-click to confirm, right-click/Escape to cancel
4. **Immediate Response**: Highlighting updates immediately on mode entry

---

## 2. Feature Overview

```
v0.7.3b Features
├── Grid Interaction Service
│   ├── IGridInteractionService interface
│   │   ├── CurrentMode property
│   │   ├── EnterMovementMode(combatant)
│   │   ├── EnterAttackMode(combatant, range)
│   │   ├── EnterAbilityMode(combatant, ability)
│   │   ├── CancelTargeting()
│   │   ├── HandleCellClick(position)
│   │   ├── HandleCellHover(position)
│   │   ├── GetHighlightedCells()
│   │   └── Events (OnTargetingComplete, OnHighlightsChanged)
│   │
│   └── GridInteractionService implementation
│       ├── Valid target calculation
│       ├── Mode state management
│       └── Action execution
│
├── Interaction Modes
│   ├── None (default, no targeting)
│   ├── Movement (blue highlights, click to move)
│   ├── Attack (red highlights, click enemy to attack)
│   └── Ability (purple highlights, AoE preview)
│
├── Range Highlighting
│   ├── Movement range (blue, reachable cells)
│   ├── Attack range (red, cells with enemies)
│   ├── Ability AoE (purple, effect area)
│   └── Hover highlight (white, current cell)
│
├── Click Handling
│   ├── Left-click on valid cell → execute action
│   ├── Left-click on invalid cell → feedback
│   ├── Right-click → cancel targeting
│   └── Escape key → cancel targeting
│
└── Cell Interaction
    ├── Hover tooltip (cell info, entity info)
    └── Pointer feedback (cursor change)
```

---

## 3. Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       PRESENTATION LAYER                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  SERVICES                                                               │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                  IGridInteractionService                           │ │
│  ├───────────────────────────────────────────────────────────────────┤ │
│  │ + CurrentMode: GridInteractionMode                                │ │
│  │ + EnterMovementMode(combatant): void                              │ │
│  │ + EnterAttackMode(combatant, range): void                         │ │
│  │ + EnterAbilityMode(combatant, ability): void                      │ │
│  │ + CancelTargeting(): void                                         │ │
│  │ + HandleCellClick(position): void                                 │ │
│  │ + HandleCellHover(position): void                                 │ │
│  │ + GetHighlightedCells(): IReadOnlyList<HighlightedCell>           │ │
│  │ + OnTargetingComplete: event Action<TargetingResult>              │ │
│  │ + OnHighlightsChanged: event Action                               │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                   │                                    │
│                                   ▼                                    │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                   GridInteractionService                           │ │
│  ├───────────────────────────────────────────────────────────────────┤ │
│  │ - _currentMode: GridInteractionMode                               │ │
│  │ - _activeEntity: Combatant?                                       │ │
│  │ - _activeAbility: AbilityDefinition?                              │ │
│  │ - _validTargets: HashSet<GridPosition>                            │ │
│  │ - _hoveredCell: GridPosition?                                     │ │
│  │                                                                   │ │
│  │ + EnterMovementMode(): calculates reachable cells                 │ │
│  │ + EnterAttackMode(): calculates enemies in range                  │ │
│  │ + EnterAbilityMode(): calculates valid ability targets            │ │
│  │ + HandleCellClick(): validates and executes action                │ │
│  │ + HandleCellHover(): updates hover highlight                      │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                   │                                    │
│                                   │ Updates                            │
│                                   ▼                                    │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │              CombatGridPanelViewModel (from v0.7.3a)               │ │
│  ├───────────────────────────────────────────────────────────────────┤ │
│  │ + Subscribes to OnHighlightsChanged                               │ │
│  │ + Updates GridCellViewModel.IsHighlighted                         │ │
│  │ + Updates GridCellViewModel.HighlightType                         │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
└────────────────────────────────────┬────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION LAYER                               │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌────────────────────────────────────────────────────────────────────┐│
│  │                        ICombatService                              ││
│  ├────────────────────────────────────────────────────────────────────┤│
│  │ + MoveEntity(combatant, position): void                            ││
│  │ + Attack(attacker, target): void                                   ││
│  │ + UseAbility(caster, ability, position): void                      ││
│  │ + GetEntityAt(position): Combatant?                                ││
│  │ + GetEnemiesInRange(combatant, range): IReadOnlyList<Combatant>    ││
│  └────────────────────────────────────────────────────────────────────┘│
│  ┌────────────────────────────────────────────────────────────────────┐│
│  │                      IMovementService                              ││
│  ├────────────────────────────────────────────────────────────────────┤│
│  │ + GetReachablePositions(start, movement): IEnumerable<GridPosition>││
│  └────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────┘
```

### Interaction Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    GRID INTERACTION FLOW                                │
└─────────────────────────────────────────────────────────────────────────┘

    Player clicks "Move" button (from v0.7.3c)
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│            GridInteractionService.EnterMovementMode()                   │
├─────────────────────────────────────────────────────────────────────────┤
│  1. Set CurrentMode = Movement                                         │
│  2. Calculate reachable cells via IMovementService                     │
│  3. Store valid targets in _validTargets                               │
│  4. Raise OnHighlightsChanged event                                    │
└─────────────────────────────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│              CombatGridPanelViewModel handles event                     │
├─────────────────────────────────────────────────────────────────────────┤
│  1. Call GetHighlightedCells()                                         │
│  2. Update each GridCellViewModel with highlight state                 │
│  3. UI reflects highlighted cells                                      │
└─────────────────────────────────────────────────────────────────────────┘
            │
            ▼
    User clicks on highlighted cell
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│            GridInteractionService.HandleCellClick()                     │
├─────────────────────────────────────────────────────────────────────────┤
│  1. Check if position is in _validTargets                              │
│  2. If invalid: provide feedback, return                               │
│  3. If valid: execute action (CombatService.MoveEntity)                │
│  4. Call CancelTargeting() to reset state                              │
│  5. Raise OnTargetingComplete event                                    │
└─────────────────────────────────────────────────────────────────────────┘
            │
            ▼
    Action complete, mode returns to None
```

---

## 4. Grid Interaction Service Interface

**File:** `src/Presentation/RuneAndRust.Avalonia/Services/IGridInteractionService.cs`

```csharp
namespace RuneAndRust.Avalonia.Services;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Handles grid-based interaction for combat targeting.
/// </summary>
public interface IGridInteractionService
{
    /// <summary>
    /// Gets the current interaction mode.
    /// </summary>
    GridInteractionMode CurrentMode { get; }

    /// <summary>
    /// Gets whether targeting is currently active.
    /// </summary>
    bool IsTargeting { get; }

    /// <summary>
    /// Enters movement targeting mode.
    /// </summary>
    /// <param name="mover">The entity that will move.</param>
    void EnterMovementMode(Combatant mover);

    /// <summary>
    /// Enters attack targeting mode.
    /// </summary>
    /// <param name="attacker">The attacking entity.</param>
    /// <param name="range">The attack range in cells.</param>
    void EnterAttackMode(Combatant attacker, int range);

    /// <summary>
    /// Enters ability targeting mode.
    /// </summary>
    /// <param name="caster">The entity using the ability.</param>
    /// <param name="ability">The ability being used.</param>
    void EnterAbilityMode(Combatant caster, AbilityDefinition ability);

    /// <summary>
    /// Cancels current targeting mode.
    /// </summary>
    void CancelTargeting();

    /// <summary>
    /// Handles a cell click.
    /// </summary>
    /// <param name="position">The clicked cell position.</param>
    void HandleCellClick(GridPosition position);

    /// <summary>
    /// Handles cell hover.
    /// </summary>
    /// <param name="position">The hovered cell position.</param>
    void HandleCellHover(GridPosition position);

    /// <summary>
    /// Gets the currently highlighted cells.
    /// </summary>
    IReadOnlyList<HighlightedCell> GetHighlightedCells();

    /// <summary>
    /// Gets info about the currently hovered cell.
    /// </summary>
    HoverInfo? GetHoverInfo();

    /// <summary>
    /// Raised when targeting completes (success or failure).
    /// </summary>
    event Action<TargetingResult>? OnTargetingComplete;

    /// <summary>
    /// Raised when highlighted cells change.
    /// </summary>
    event Action? OnHighlightsChanged;

    /// <summary>
    /// Raised when hover state changes.
    /// </summary>
    event Action<HoverInfo?>? OnHoverChanged;
}

/// <summary>
/// Interaction modes for the combat grid.
/// </summary>
public enum GridInteractionMode
{
    /// <summary>No active targeting.</summary>
    None,

    /// <summary>Selecting movement destination.</summary>
    Movement,

    /// <summary>Selecting attack target.</summary>
    Attack,

    /// <summary>Selecting ability target.</summary>
    Ability
}

/// <summary>
/// A highlighted cell with its highlight type.
/// </summary>
public record HighlightedCell(GridPosition Position, HighlightType Type);

/// <summary>
/// Result of a targeting action.
/// </summary>
public record TargetingResult(
    GridInteractionMode Mode,
    GridPosition Target,
    bool Success,
    string? Message = null);

/// <summary>
/// Information about the hovered cell.
/// </summary>
public record HoverInfo(
    GridPosition Position,
    string CellLabel,
    string? EntityName,
    int? EntityHealth,
    int? EntityMaxHealth,
    bool IsValidTarget);
```

---

## 5. Grid Interaction Service Implementation

**File:** `src/Presentation/RuneAndRust.Avalonia/Services/GridInteractionService.cs`

```csharp
namespace RuneAndRust.Avalonia.Services;

using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;
using Serilog;

/// <summary>
/// Implementation of grid interaction for combat targeting.
/// </summary>
public class GridInteractionService : IGridInteractionService
{
    private readonly ICombatService _combatService;
    private readonly IMovementService _movementService;

    private GridInteractionMode _currentMode = GridInteractionMode.None;
    private Combatant? _activeEntity;
    private AbilityDefinition? _activeAbility;
    private int _activeRange;
    private HashSet<GridPosition> _validTargets = new();
    private GridPosition? _hoveredPosition;

    public GridInteractionMode CurrentMode => _currentMode;
    public bool IsTargeting => _currentMode != GridInteractionMode.None;

    public event Action<TargetingResult>? OnTargetingComplete;
    public event Action? OnHighlightsChanged;
    public event Action<HoverInfo?>? OnHoverChanged;

    public GridInteractionService(
        ICombatService combatService,
        IMovementService movementService)
    {
        _combatService = combatService;
        _movementService = movementService;
    }

    public void EnterMovementMode(Combatant mover)
    {
        _currentMode = GridInteractionMode.Movement;
        _activeEntity = mover;

        // Calculate valid movement positions
        _validTargets = _movementService
            .GetReachablePositions(mover.Position, mover.RemainingMovement)
            .ToHashSet();

        OnHighlightsChanged?.Invoke();
        Log.Debug("Entered movement mode for {Entity}, {Count} reachable cells",
            mover.Name, _validTargets.Count);
    }

    public void EnterAttackMode(Combatant attacker, int range)
    {
        _currentMode = GridInteractionMode.Attack;
        _activeEntity = attacker;
        _activeRange = range;

        // Calculate valid attack positions (cells with enemies in range)
        _validTargets = _combatService
            .GetEnemiesInRange(attacker, range)
            .Select(e => e.Position)
            .ToHashSet();

        OnHighlightsChanged?.Invoke();
        Log.Debug("Entered attack mode for {Entity}, range {Range}, {Count} targets",
            attacker.Name, range, _validTargets.Count);
    }

    public void EnterAbilityMode(Combatant caster, AbilityDefinition ability)
    {
        _currentMode = GridInteractionMode.Ability;
        _activeEntity = caster;
        _activeAbility = ability;

        // Calculate valid ability target positions
        _validTargets = CalculateAbilityTargets(caster, ability);

        OnHighlightsChanged?.Invoke();
        Log.Debug("Entered ability mode for {Entity}, ability {Ability}, {Count} targets",
            caster.Name, ability.Name, _validTargets.Count);
    }

    public void CancelTargeting()
    {
        var previousMode = _currentMode;
        
        _currentMode = GridInteractionMode.None;
        _activeEntity = null;
        _activeAbility = null;
        _activeRange = 0;
        _validTargets.Clear();

        OnHighlightsChanged?.Invoke();
        
        if (previousMode != GridInteractionMode.None)
        {
            Log.Debug("Cancelled targeting for mode {Mode}", previousMode);
        }
    }

    public void HandleCellClick(GridPosition position)
    {
        if (_currentMode == GridInteractionMode.None)
            return;

        if (!_validTargets.Contains(position))
        {
            Log.Debug("Invalid target position: {Position}", position);
            var result = new TargetingResult(_currentMode, position, false, "Invalid target");
            OnTargetingComplete?.Invoke(result);
            return;
        }

        // Execute action based on mode
        var success = ExecuteAction(position);
        
        var targetingResult = new TargetingResult(
            _currentMode, 
            position, 
            success,
            success ? null : "Action failed");

        CancelTargeting();
        OnTargetingComplete?.Invoke(targetingResult);
    }

    public void HandleCellHover(GridPosition position)
    {
        if (_hoveredPosition == position)
            return;

        _hoveredPosition = position;
        
        var info = CreateHoverInfo(position);
        OnHoverChanged?.Invoke(info);
    }

    public IReadOnlyList<HighlightedCell> GetHighlightedCells()
    {
        var highlightType = _currentMode switch
        {
            GridInteractionMode.Movement => HighlightType.Movement,
            GridInteractionMode.Attack => HighlightType.Attack,
            GridInteractionMode.Ability => HighlightType.Ability,
            _ => HighlightType.None
        };

        var result = _validTargets
            .Select(p => new HighlightedCell(p, highlightType))
            .ToList();

        // Add hover highlight if hovering over a valid target
        if (_hoveredPosition.HasValue && IsTargeting)
        {
            if (!_validTargets.Contains(_hoveredPosition.Value))
            {
                result.Add(new HighlightedCell(_hoveredPosition.Value, HighlightType.Hover));
            }
        }

        return result;
    }

    public HoverInfo? GetHoverInfo()
    {
        return _hoveredPosition.HasValue 
            ? CreateHoverInfo(_hoveredPosition.Value) 
            : null;
    }

    private bool ExecuteAction(GridPosition position)
    {
        if (_activeEntity is null)
            return false;

        try
        {
            switch (_currentMode)
            {
                case GridInteractionMode.Movement:
                    _combatService.MoveEntity(_activeEntity, position);
                    Log.Information("{Entity} moved to {Position}", 
                        _activeEntity.Name, position);
                    return true;

                case GridInteractionMode.Attack:
                    var target = _combatService.GetEntityAt(position);
                    if (target is null)
                        return false;
                    _combatService.Attack(_activeEntity, target);
                    Log.Information("{Entity} attacked {Target}", 
                        _activeEntity.Name, target.Name);
                    return true;

                case GridInteractionMode.Ability:
                    if (_activeAbility is null)
                        return false;
                    _combatService.UseAbility(_activeEntity, _activeAbility, position);
                    Log.Information("{Entity} used {Ability} at {Position}", 
                        _activeEntity.Name, _activeAbility.Name, position);
                    return true;

                default:
                    return false;
            }
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Failed to execute {Mode} action", _currentMode);
            return false;
        }
    }

    private HashSet<GridPosition> CalculateAbilityTargets(
        Combatant caster, 
        AbilityDefinition ability)
    {
        var targets = new HashSet<GridPosition>();
        var range = ability.Range;

        // Get all positions within ability range
        for (int dx = -range; dx <= range; dx++)
        {
            for (int dy = -range; dy <= range; dy++)
            {
                var pos = new GridPosition(
                    caster.Position.X + dx, 
                    caster.Position.Y + dy);

                // Check if within range (Manhattan or Euclidean based on ability)
                var distance = Math.Abs(dx) + Math.Abs(dy);
                if (distance <= range && IsValidAbilityTarget(pos, ability))
                {
                    targets.Add(pos);
                }
            }
        }

        return targets;
    }

    private bool IsValidAbilityTarget(GridPosition position, AbilityDefinition ability)
    {
        // Check if position is on the grid
        var grid = _combatService.CurrentGrid;
        if (!grid.IsValidPosition(position))
            return false;

        // Check targeting type
        var cell = grid.GetCell(position);
        return ability.TargetType switch
        {
            TargetType.Enemy => cell.Occupant?.Faction == Faction.Enemy,
            TargetType.Ally => cell.Occupant?.Faction == Faction.Player || 
                               cell.Occupant?.Faction == Faction.Ally,
            TargetType.Self => cell.Occupant == _activeEntity,
            TargetType.Empty => cell.Occupant is null && cell.IsWalkable,
            TargetType.Any => true,
            _ => true
        };
    }

    private HoverInfo CreateHoverInfo(GridPosition position)
    {
        var label = $"{(char)('A' + position.Y)}{position.X + 1}";
        var entity = _combatService.GetEntityAt(position);
        var isValid = _validTargets.Contains(position);

        return new HoverInfo(
            Position: position,
            CellLabel: label,
            EntityName: entity?.Name,
            EntityHealth: entity?.Health,
            EntityMaxHealth: entity?.MaxHealth,
            IsValidTarget: isValid);
    }
}
```

---

## 6. Interaction Modes

### Mode Visual Reference

```
MOVEMENT MODE (After clicking "Move" button):
┌─────────────────────────────────────────────────────────────────────────┐
│       1     2     3     4     5     6     7     8                       │
│    ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐                    │
│  A │  ░  │  ░  │  █  │  █  │  ░  │  ░  │  ░  │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  B │  ░  │  ░  │ ▓▓▓ │ ▓▓▓ │ ▓▓▓ │  ░  │  ░  │  ░  │  ▓ = Reachable    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤      (4 movement)  │
│  C │  ░  │ ▓▓▓ │ [S] │ ▓▓▓ │ ▓▓▓ │ ▓▓▓ │  ░  │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  D │  ░  │ ▓▓▓ │ ▓▓▓ │ ▓▓▓ │ [@] │ ▓▓▓ │ ▓▓▓ │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  E │  ░  │  ~  │  ~  │ ▓▓▓ │ ▓▓▓ │ ▓▓▓ │  ░  │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  F │  ░  │  ░  │  ~  │  ░  │ ▓▓▓ │ [G] │  ░  │  ░  │                    │
│    └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘                    │
│                                                                          │
│  [Click a blue cell to move]                    [Right-click to cancel]  │
└─────────────────────────────────────────────────────────────────────────┘


ATTACK MODE (After clicking "Attack" button):
┌─────────────────────────────────────────────────────────────────────────┐
│       1     2     3     4     5     6     7     8                       │
│    ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐                    │
│  A │  ░  │  ░  │  █  │  █  │  ░  │  ░  │  ░  │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  B │  ░  │  ░  │  ░  │  ░  │  ░  │  ░  │  ░  │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  C │  ░  │  ░  │ [S] │  ░  │  ░  │  ░  │  ░  │  ░  │  Skeleton in range │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤   (melee: 1 cell)  │
│  D │  ░  │  ░  │ ███ │ ███ │ [@] │ ███ │  ░  │  ░  │  █ = Attack range  │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  E │  ░  │  ~  │  ~  │ ███ │ ███ │ ███ │  ░  │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  F │  ░  │  ░  │  ~  │  ░  │  ░  │ [G] │  ░  │  ░  │  Goblin out of     │
│    └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘   range            │
│                                                                          │
│  [Click an enemy in red to attack]              [Right-click to cancel]  │
└─────────────────────────────────────────────────────────────────────────┘


ABILITY AoE PREVIEW (After selecting ability):
┌─────────────────────────────────────────────────────────────────────────┐
│       1     2     3     4     5     6     7     8                       │
│    ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐                    │
│  A │  ░  │  ░  │  █  │  █  │  ░  │  ░  │  ░  │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤                    │
│  B │  ░  │ ◊◊◊ │ ◊◊◊ │ ◊◊◊ │  ░  │  ░  │  ░  │  ░  │  ◊ = AoE effect   │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤      area          │
│  C │  ░  │ ◊◊◊ │ [S] │ ◊◊◊ │  ░  │  ░  │  ░  │  ░  │                    │
│    ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤  Fireball 3x3      │
│  D │  ░  │ ◊◊◊ │ ◊◊◊ │ ◊◊◊ │ [@] │  ░  │  ░  │  ░  │                    │
│    └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘                    │
│                                                                          │
│  [Click to confirm Fireball at C3]              [Right-click to cancel]  │
└─────────────────────────────────────────────────────────────────────────┘
```

### Mode State Machine

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     INTERACTION MODE STATE MACHINE                      │
└─────────────────────────────────────────────────────────────────────────┘

                              ┌────────┐
                              │  NONE  │◄─────────────────────────────────┐
                              │        │                                  │
                              └────┬───┘                                  │
                                   │                                      │
          ┌────────────────────────┼────────────────────────┐             │
          │                        │                        │             │
          ▼                        ▼                        ▼             │
    ┌───────────┐            ┌───────────┐            ┌───────────┐       │
    │ MOVEMENT  │            │  ATTACK   │            │  ABILITY  │       │
    │           │            │           │            │           │       │
    │ Blue      │            │ Red       │            │ Purple    │       │
    │ highlights│            │ highlights│            │ highlights│       │
    └─────┬─────┘            └─────┬─────┘            └─────┬─────┘       │
          │                        │                        │             │
          └────────────────────────┼────────────────────────┘             │
                                   │                                      │
                    ┌──────────────┼──────────────┐                       │
                    │              │              │                       │
              Left-click     Right-click     Escape key                   │
              on valid       anywhere        pressed                      │
              target                                                      │
                    │              │              │                       │
                    ▼              ▼              ▼                       │
              ┌──────────┐  ┌──────────┐  ┌──────────┐                    │
              │ EXECUTE  │  │ CANCEL   │  │ CANCEL   │                    │
              │ action   │  │ (silent) │  │ (silent) │                    │
              └────┬─────┘  └────┬─────┘  └────┬─────┘                    │
                   │             │             │                          │
                   └─────────────┴─────────────┴──────────────────────────┘
```

---

## 7. Range Highlighting

### Highlight Types

| Type | Color | Alpha | Usage |
|------|-------|-------|-------|
| **Movement** | Blue (#0080FF) | 50% | Reachable cells |
| **Attack** | Red (#FF0000) | 50% | Enemies in weapon range |
| **Ability** | Purple (#8000FF) | 50% | Valid ability targets / AoE preview |
| **Hover** | White (#FFFFFF) | 25% | Currently hovered cell |

### Highlight Type Enum Update

**File:** `src/Presentation/RuneAndRust.Avalonia/Controls/GridCellControl.cs` (update)

```csharp
/// <summary>
/// Types of cell highlighting.
/// </summary>
public enum HighlightType
{
    /// <summary>No highlight.</summary>
    None,

    /// <summary>Movement range (blue).</summary>
    Movement,

    /// <summary>Attack range (red).</summary>
    Attack,

    /// <summary>Ability range/AoE (purple).</summary>
    Ability,

    /// <summary>Hover state (white).</summary>
    Hover
}
```

---

## 8. Grid Panel Integration

### CombatGridPanel Updates

**File:** `src/Presentation/RuneAndRust.Avalonia/Controls/CombatGridPanel.axaml` (additions)

```xml
<!-- Add to GridContainer Grid -->
<Grid Grid.Row="1" Grid.Column="1" 
      x:Name="GridContainer"
      PointerMoved="OnGridPointerMoved">
    
    <!-- Cells layer - update with click handler -->
    <ItemsControl ItemsSource="{Binding FlatCells}">
        <ItemsControl.ItemsPanel>
            <ItemsPanelTemplate>
                <UniformGrid Rows="{Binding GridHeight}" 
                             Columns="{Binding GridWidth}" />
            </ItemsPanelTemplate>
        </ItemsControl.ItemsPanel>
        <ItemsControl.ItemTemplate>
            <DataTemplate DataType="vm:GridCellViewModel">
                <ctrl:GridCellControl 
                    CellType="{Binding CellType}"
                    IsHighlighted="{Binding IsHighlighted}"
                    HighlightType="{Binding HighlightType}"
                    HasEntity="{Binding HasEntity}"
                    ToolTip.Tip="{Binding Tooltip}"
                    PointerPressed="OnCellPointerPressed" />
            </DataTemplate>
        </ItemsControl.ItemTemplate>
    </ItemsControl>
    
    <!-- ... existing token canvas ... -->
</Grid>

<!-- Status bar at bottom -->
<Border Grid.Row="2" Classes="panel-footer" Margin="0,8,0,0" Padding="8">
    <Grid ColumnDefinitions="*,Auto">
        <!-- Existing legend on left -->
        <WrapPanel Grid.Column="0">
            <!-- ... legend items ... -->
        </WrapPanel>
        
        <!-- Targeting hint on right -->
        <TextBlock Grid.Column="1"
                   Text="{Binding TargetingHint}"
                   Classes="muted"
                   IsVisible="{Binding IsTargeting}"
                   VerticalAlignment="Center" />
    </Grid>
</Border>
```

**File:** `src/Presentation/RuneAndRust.Avalonia/Controls/CombatGridPanel.axaml.cs` (additions)

```csharp
public partial class CombatGridPanel : UserControl
{
    private IGridInteractionService? _interactionService;

    public CombatGridPanel()
    {
        InitializeComponent();
    }

    protected override void OnDataContextChanged(EventArgs e)
    {
        base.OnDataContextChanged(e);
        
        if (DataContext is CombatGridPanelViewModel vm)
        {
            _interactionService = vm.InteractionService;
        }
    }

    private void OnCellPointerPressed(object? sender, PointerPressedEventArgs e)
    {
        if (sender is not GridCellControl cell)
            return;

        if (cell.DataContext is not GridCellViewModel cellVm)
            return;

        var props = e.GetCurrentPoint(cell).Properties;
        
        if (props.IsRightButtonPressed)
        {
            // Right-click cancels targeting
            _interactionService?.CancelTargeting();
            e.Handled = true;
        }
        else if (props.IsLeftButtonPressed)
        {
            // Left-click attempts action
            _interactionService?.HandleCellClick(cellVm.Position);
            e.Handled = true;
        }
    }

    private void OnGridPointerMoved(object? sender, PointerEventArgs e)
    {
        // Calculate which cell is being hovered based on pointer position
        var position = e.GetPosition(GridContainer);
        var cellWidth = GridContainer.Bounds.Width / 
            ((DataContext as CombatGridPanelViewModel)?.GridWidth ?? 8);
        var cellHeight = GridContainer.Bounds.Height / 
            ((DataContext as CombatGridPanelViewModel)?.GridHeight ?? 8);

        var col = (int)(position.X / cellWidth);
        var row = (int)(position.Y / cellHeight);

        var gridPos = new GridPosition(col, row);
        _interactionService?.HandleCellHover(gridPos);
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        if (e.Key == Key.Escape && _interactionService?.IsTargeting == true)
        {
            _interactionService.CancelTargeting();
            e.Handled = true;
        }
    }
}
```

### CombatGridPanelViewModel Updates

**File:** `src/Presentation/RuneAndRust.Avalonia/ViewModels/CombatGridPanelViewModel.cs` (additions)

```csharp
public partial class CombatGridPanelViewModel : ViewModelBase
{
    private readonly IGridInteractionService? _interactionService;

    [ObservableProperty]
    private bool _isTargeting;

    [ObservableProperty]
    private string _targetingHint = string.Empty;

    /// <summary>
    /// Gets the interaction service for the view.
    /// </summary>
    public IGridInteractionService? InteractionService => _interactionService;

    public CombatGridPanelViewModel(
        IGameSessionService gameSession,
        ICombatService combatService,
        IGridInteractionService interactionService)
    {
        _gameSession = gameSession;
        _combatService = combatService;
        _interactionService = interactionService;

        // Subscribe to interaction events
        _interactionService.OnHighlightsChanged += RefreshHighlights;
        _interactionService.OnTargetingComplete += HandleTargetingComplete;
        
        // ... existing subscriptions ...
    }

    private void RefreshHighlights()
    {
        if (_interactionService is null)
            return;

        // Clear all highlights
        foreach (var cell in FlatCells)
        {
            cell.IsHighlighted = false;
            cell.HighlightType = HighlightType.None;
        }

        // Apply current highlights
        var highlights = _interactionService.GetHighlightedCells();
        foreach (var highlight in highlights)
        {
            var cell = GetCellAt(highlight.Position);
            if (cell is not null)
            {
                cell.IsHighlighted = true;
                cell.HighlightType = highlight.Type;
            }
        }

        // Update targeting state
        IsTargeting = _interactionService.IsTargeting;
        TargetingHint = _interactionService.CurrentMode switch
        {
            GridInteractionMode.Movement => "Click to move • Right-click to cancel",
            GridInteractionMode.Attack => "Click enemy to attack • Right-click to cancel",
            GridInteractionMode.Ability => "Click target • Right-click to cancel",
            _ => string.Empty
        };
    }

    private void HandleTargetingComplete(TargetingResult result)
    {
        Log.Debug("Targeting complete: {Mode} at {Position}, Success: {Success}",
            result.Mode, result.Target, result.Success);
        
        RefreshHighlights();
    }

    private GridCellViewModel? GetCellAt(GridPosition position)
    {
        var index = position.Y * GridWidth + position.X;
        return index >= 0 && index < FlatCells.Count ? FlatCells[index] : null;
    }
}
```

---

## 9. Data Model Changes

### New Types

| Type | Layer | Description |
|------|-------|-------------|
| `IGridInteractionService` | Presentation | Interaction interface |
| `GridInteractionService` | Presentation | Interaction implementation |
| `GridInteractionMode` | Presentation | Mode enum |
| `HighlightedCell` | Presentation | Highlighted cell record |
| `TargetingResult` | Presentation | Targeting result record |
| `HoverInfo` | Presentation | Hover info record |

### DI Registration

**File:** `src/Presentation/RuneAndRust.Avalonia/App.axaml.cs` (additions)

```csharp
services.AddSingleton<IGridInteractionService, GridInteractionService>();
```

---

## 10. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `GridInteractionService` | Debug | Mode entry, target count, cancel |
| `GridInteractionService` | Information | Action execution (move, attack, ability) |
| `GridInteractionService` | Debug | Invalid target click |
| `CombatGridPanelViewModel` | Debug | Targeting complete |

---

## 11. Unit Testing Requirements

### Test Count by Feature

| Feature | Test Count |
|---------|------------|
| GridInteractionService modes | ~4 |
| HandleCellClick | ~2 |
| Highlight generation | ~2 |
| **Total** | **~8** |

### Test Specifications

**File:** `tests/RuneAndRust.Avalonia.UnitTests/Services/GridInteractionServiceTests.cs`

```csharp
[TestFixture]
public class GridInteractionServiceTests
{
    private Mock<ICombatService> _combatServiceMock;
    private Mock<IMovementService> _movementServiceMock;
    private GridInteractionService _service;

    [SetUp]
    public void Setup()
    {
        _combatServiceMock = new Mock<ICombatService>();
        _movementServiceMock = new Mock<IMovementService>();
        _service = new GridInteractionService(
            _combatServiceMock.Object,
            _movementServiceMock.Object);
    }

    [Test]
    public void EnterMovementMode_SetsCorrectState()
    {
        // Arrange
        var combatant = CreateTestCombatant();
        _movementServiceMock.Setup(x => x.GetReachablePositions(It.IsAny<GridPosition>(), It.IsAny<int>()))
            .Returns(new[] { new GridPosition(1, 1), new GridPosition(2, 2) });

        // Act
        _service.EnterMovementMode(combatant);

        // Assert
        _service.CurrentMode.Should().Be(GridInteractionMode.Movement);
        _service.IsTargeting.Should().BeTrue();
    }

    [Test]
    public void EnterAttackMode_CalculatesEnemiesInRange()
    {
        // Arrange
        var attacker = CreateTestCombatant();
        var enemy = CreateTestCombatant(x: 1, y: 0);
        _combatServiceMock.Setup(x => x.GetEnemiesInRange(attacker, 1))
            .Returns(new[] { enemy });

        // Act
        _service.EnterAttackMode(attacker, 1);

        // Assert
        _service.CurrentMode.Should().Be(GridInteractionMode.Attack);
        _service.GetHighlightedCells().Should().HaveCount(1);
    }

    [Test]
    public void CancelTargeting_ClearsState()
    {
        // Arrange
        var combatant = CreateTestCombatant();
        _service.EnterMovementMode(combatant);

        // Act
        _service.CancelTargeting();

        // Assert
        _service.CurrentMode.Should().Be(GridInteractionMode.None);
        _service.IsTargeting.Should().BeFalse();
        _service.GetHighlightedCells().Should().BeEmpty();
    }

    [Test]
    public void HandleCellClick_OnValidTarget_ExecutesAction()
    {
        // Arrange
        var combatant = CreateTestCombatant();
        var targetPos = new GridPosition(1, 1);
        _movementServiceMock.Setup(x => x.GetReachablePositions(It.IsAny<GridPosition>(), It.IsAny<int>()))
            .Returns(new[] { targetPos });
        
        _service.EnterMovementMode(combatant);
        TargetingResult? result = null;
        _service.OnTargetingComplete += r => result = r;

        // Act
        _service.HandleCellClick(targetPos);

        // Assert
        _combatServiceMock.Verify(x => x.MoveEntity(combatant, targetPos), Times.Once);
        result.Should().NotBeNull();
        result!.Success.Should().BeTrue();
    }

    [Test]
    public void HandleCellClick_OnInvalidTarget_DoesNotExecute()
    {
        // Arrange
        var combatant = CreateTestCombatant();
        var validPos = new GridPosition(1, 1);
        var invalidPos = new GridPosition(5, 5);
        _movementServiceMock.Setup(x => x.GetReachablePositions(It.IsAny<GridPosition>(), It.IsAny<int>()))
            .Returns(new[] { validPos });
        
        _service.EnterMovementMode(combatant);
        TargetingResult? result = null;
        _service.OnTargetingComplete += r => result = r;

        // Act
        _service.HandleCellClick(invalidPos);

        // Assert
        _combatServiceMock.Verify(x => x.MoveEntity(It.IsAny<Combatant>(), It.IsAny<GridPosition>()), Times.Never);
        result.Should().NotBeNull();
        result!.Success.Should().BeFalse();
    }

    [Test]
    public void GetHighlightedCells_ReturnsCorrectType()
    {
        // Arrange
        var combatant = CreateTestCombatant();
        _movementServiceMock.Setup(x => x.GetReachablePositions(It.IsAny<GridPosition>(), It.IsAny<int>()))
            .Returns(new[] { new GridPosition(1, 1) });

        // Act
        _service.EnterMovementMode(combatant);
        var highlights = _service.GetHighlightedCells();

        // Assert
        highlights.Should().HaveCount(1);
        highlights[0].Type.Should().Be(HighlightType.Movement);
    }

    private static Combatant CreateTestCombatant(int x = 0, int y = 0)
    {
        // Create test combatant at position
        return new MockCombatant("Test", x, y);
    }
}
```

---

## 12. Use Cases

### UC-073b-001: Move via Grid Click
**Actor:** Player
**Flow:** Click Move button → Blue cells highlight → Click destination → Character moves

### UC-073b-002: Attack via Grid Click
**Actor:** Player
**Flow:** Click Attack button → Red cells highlight enemies → Click enemy → Attack executes

### UC-073b-003: Use Ability via Grid Click
**Actor:** Player
**Flow:** Select ability → Purple cells show range → Click target → Ability executes

### UC-073b-004: Cancel Targeting (Right-click)
**Actor:** Player
**Flow:** Enter targeting mode → Right-click anywhere → Mode cancels, highlights clear

### UC-073b-005: Cancel Targeting (Escape)
**Actor:** Player
**Flow:** Enter targeting mode → Press Escape → Mode cancels, highlights clear

### UC-073b-006: Invalid Target Feedback
**Actor:** Player
**Flow:** Enter movement mode → Click wall cell → Feedback shown, no action

### UC-073b-007: Hover Information
**Actor:** Player
**Flow:** Hover over cell → Tooltip shows cell info / entity name + HP

---

## 13. Deliverable Checklist

### Interfaces
- [ ] `Services/IGridInteractionService.cs` created

### Services
- [ ] `Services/GridInteractionService.cs` created

### Integration
- [ ] `CombatGridPanel` updated with click handlers
- [ ] `CombatGridPanelViewModel` updated with interaction support
- [ ] DI registration for `IGridInteractionService`

### Testing
- [ ] ~8 unit tests implemented
- [ ] All tests passing

---

## 14. Acceptance Criteria

### Mode Entry
- [ ] EnterMovementMode calculates reachable cells
- [ ] EnterAttackMode calculates enemies in range
- [ ] EnterAbilityMode calculates valid targets

### Click Handling
- [ ] Click on cell detected correctly
- [ ] Valid target click executes action
- [ ] Invalid target click shows feedback
- [ ] Right-click cancels targeting
- [ ] Escape key cancels targeting

### Highlighting
- [ ] Movement mode shows blue highlights
- [ ] Attack mode shows red highlights
- [ ] Ability mode shows purple highlights
- [ ] Hover shows white highlight

### Feedback
- [ ] Targeting hint displays during targeting
- [ ] Cursor changes over valid targets
- [ ] Hover tooltip shows cell/entity info

### Quality
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings
- [ ] ~8 unit tests pass
- [ ] Interaction integrates with combat grid

---

## 15. Dependencies

### Required from v0.7.3a

| Type | Location | Usage |
|------|----------|-------|
| `CombatGridPanel` | `Controls/CombatGridPanel.axaml` | Click event host |
| `GridCellControl` | `Controls/GridCellControl.cs` | Click detection |
| `GridCellViewModel` | `ViewModels/GridCellViewModel.cs` | Highlight binding |
| `HighlightType` | `Controls/GridCellControl.cs` | Highlight type enum |

### Required from Application Layer

| Type | Location | Usage |
|------|----------|-------|
| `ICombatService` | Application layer | Action execution |
| `IMovementService` | Application layer | Movement calculation |
| `Combatant` | Domain layer | Entity data |
| `GridPosition` | Domain layer | Position data |

### Provides to v0.7.3c

| Type | Usage |
|------|-------|
| `IGridInteractionService` | Action button integration |
| Mode entry methods | Button click handlers |

---

## 16. Future Considerations

### Deferred to v0.7.3c
- **Action buttons**: Move/Attack/Ability buttons that trigger modes
- **Combatant list**: Entity list with targeting

### Deferred to v0.8.0
- **Path preview**: Show movement path before clicking
- **Damage preview**: Show estimated damage on hover
- **Multi-target abilities**: Select multiple targets

### Out of Scope
- **Drag movement**: Drag to move (click only)
- **Context menus**: Right-click menus on grid cells

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: Assistant*
