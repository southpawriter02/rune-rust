# v0.5.2c Design Specification: Display & Integration

**Version:** 0.5.2c
**Phase Name:** Display & Integration
**Parent Version:** v0.5.2 (Terrain & Cover)
**Prerequisites:** v0.5.2b Complete (Cover System)
**Estimated Tests:** ~25 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [GridRenderer Updates](#4-gridrenderer-updates)
5. [CombatService Cover Integration](#5-combatservice-cover-integration)
6. [MovementService Display Updates](#6-movementservice-display-updates)
7. [Room Configuration Updates](#7-room-configuration-updates)
8. [Grid Initialization](#8-grid-initialization)
9. [User-Facing Commands](#9-user-facing-commands)
10. [Data Model Changes](#10-data-model-changes)
11. [Logging Specifications](#11-logging-specifications)
12. [Unit Testing Requirements](#12-unit-testing-requirements)
13. [Use Cases](#13-use-cases)
14. [Deliverable Checklist](#14-deliverable-checklist)
15. [Acceptance Criteria](#15-acceptance-criteria)
16. [Dependencies](#16-dependencies)
17. [Future Considerations](#17-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification implements terrain and cover display on the ASCII grid and integrates these systems with combat. The grid shows terrain types and cover objects with distinct symbols, combat calculations include cover defense bonuses, and movement displays terrain costs. This phase completes the Terrain & Cover version by connecting all components.

Key mechanics:
- **Terrain Display**: ASCII symbols for different terrain types
- **Cover Display**: ASCII symbols for cover objects
- **Combat Integration**: Cover bonuses in defense calculations
- **Movement Display**: Terrain costs in movement messages
- **Room Configuration**: Terrain and cover layouts per room

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **GridRenderer Updates** | Terrain/cover rendering, dynamic legend |
| **CombatService Updates** | Cover in defense calculation |
| **MovementService Updates** | Terrain cost display |
| **RoomConfiguration Updates** | Terrain/cover layout support |
| **Grid Initialization Updates** | Load terrain/cover from room config |
| **Tests** | ~25 unit tests |

### 1.3 Architectural Significance

This version completes the **Terrain & Cover System**:

- **Visual Representation**: Players see environmental features clearly
- **Tactical Information**: Cover status and terrain costs visible
- **Combat Feedback**: Attack results show cover effects
- **Configuration-Driven**: Room layouts define terrain/cover placement

---

## 2. Feature Overview

```
v0.5.2c Display & Integration
├── GridRenderer Updates
│   ├── RenderCell(cell, cover): prioritized display
│   ├── GetTerrainChar(type): terrain symbols
│   ├── RenderLegend(grid): dynamic terrain/cover legend
│   ├── GetUniqueTerrainTypes(grid)
│   ├── GetUniqueCoverTypes(grid)
│   └── RenderCombatantList(grid): include cover status
├── CombatService Cover Integration
│   ├── ProcessAttack includes cover check
│   ├── Full cover blocks attack
│   ├── Partial cover adds to defense
│   └── Attack result shows cover info
├── MovementService Display Updates
│   ├── Movement result shows terrain type
│   ├── Movement result shows cost multiplier
│   └── Hazard damage shows in result
├── Room Configuration
│   ├── terrain[] for terrain layout
│   └── cover[] for cover layout
└── Grid Initialization
    ├── ApplyRoomTerrain(roomConfig)
    └── ApplyRoomCover(roomConfig)
```

### 2.1 Scope Alignment

**In Scope:**
- Terrain ASCII symbols on grid
- Cover ASCII symbols on grid
- Combined terrain/cover legend
- Combat defense calculation with cover
- Attack display showing cover info
- Movement display showing terrain costs
- Hazard damage in movement messages
- Grid render options for terrain/cover
- Room terrain layout configuration
- Combat grid initialization with terrain/cover

**Out of Scope:**
- Flanking (v0.5.3)
- Area effects (v0.5.3)

---

## 3. Architecture Diagrams

### 3.1 Display Priority

```
┌─────────────────────────────────────────────────────────────────────┐
│                       DISPLAY PRIORITY                               │
└─────────────────────────────────────────────────────────────────────┘

    When rendering a cell, display in this priority order:

    Priority 1: ENTITY (highest)
    ┌─────────────────────────────────────────────────────────────┐
    │ If player present → display '@'                             │
    │ If monster present → display 'M' (or first letter of name)  │
    └─────────────────────────────────────────────────────────────┘
                    │ (if no entity)
                    ▼
    Priority 2: COVER
    ┌─────────────────────────────────────────────────────────────┐
    │ If cover present and not destroyed → display cover.DisplayChar│
    │ Examples: □ (crate), █ (pillar), ▄ (wall), ○ (barrel)       │
    └─────────────────────────────────────────────────────────────┘
                    │ (if no cover)
                    ▼
    Priority 3: TERRAIN (lowest)
    ┌─────────────────────────────────────────────────────────────┐
    │ Display terrain type character:                             │
    │   . = Normal    ~ = Difficult    ○ = Impassable    ▲ = Fire │
    └─────────────────────────────────────────────────────────────┘
```

### 3.2 Combat with Cover Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    COMBAT WITH COVER FLOW                            │
└─────────────────────────────────────────────────────────────────────┘

    Attack Request
         │
         ▼
    ┌───────────────────┐
    │ Range/LOS Checks  │──Fail──▶ Return: Out of range/blocked
    │ (from v0.5.1)     │
    └────────┬──────────┘
             │Pass
             ▼
    ┌───────────────────┐
    │ Get Cover Between │
    │ CoverService      │
    └────────┬──────────┘
             │
    ┌────────┼────────────────┐
    │        │                │
    ▼        ▼                ▼
  None     Partial           Full
    │        │                │
    │        │                ▼
    │        │         ┌─────────────────┐
    │        │         │ Cannot Target   │
    │        │         │ Return: Blocked │
    │        │         └─────────────────┘
    │        ▼
    │   ┌───────────────────┐
    │   │ Add Bonus to AC   │
    │   │ targetAC += bonus │
    │   └────────┬──────────┘
    │            │
    └──────┬─────┘
           │
           ▼
    ┌───────────────────┐
    │ Roll Attack       │
    │ vs modified AC    │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Build Message     │
    │ Include cover info│
    └───────────────────┘
```

### 3.3 Grid Initialization Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    GRID INITIALIZATION FLOW                          │
└─────────────────────────────────────────────────────────────────────┘

    StartCombat(room, monsters)
              │
              ▼
    ┌───────────────────┐
    │ Create Grid       │
    │ (from v0.5.0c)    │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Apply Room Terrain│
    │ ForEach terrain:  │
    │   SetTerrain(pos) │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Apply Room Cover  │
    │ ForEach cover:    │
    │   AddCover(def,pos│
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Place Entities    │
    │ (from v0.5.0c)    │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Grid Ready        │
    │ with full layout  │
    └───────────────────┘
```

### 3.4 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  GridRenderer (Extended from v0.5.0c)                                │
│  ├── [v0.5.0c] RenderGrid, RenderCompact                            │
│  ├── [NEW] RenderCell(cell, cover): string (priority-based)         │
│  ├── [NEW] GetTerrainChar(terrainType): char                        │
│  ├── [NEW] RenderLegend(grid): string (dynamic)                     │
│  ├── [NEW] GetUniqueTerrainTypes(grid): terrain on grid             │
│  ├── [NEW] GetUniqueCoverTypes(grid): cover on grid                 │
│  └── [NEW] RenderCombatantList(grid): with cover status             │
├─────────────────────────────────────────────────────────────────────┤
│  GridCommand (Extended)                                              │
│  └── Shows terrain/cover legend and combatant cover status          │
├─────────────────────────────────────────────────────────────────────┤
│  AttackCommand (Extended)                                            │
│  └── Shows cover info when selecting targets                        │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  CombatService (Extended)                                            │
│  ├── [NEW] ProcessAttack: includes cover check                      │
│  ├── [NEW] GetTargetWithCover: returns target + cover info          │
│  └── [NEW] BuildAttackResult: includes cover message                │
├─────────────────────────────────────────────────────────────────────┤
│  MovementService (Extended from v0.5.2a)                             │
│  ├── [v0.5.2a] Terrain cost integration                             │
│  └── [NEW] BuildMovementMessage: includes terrain type/cost         │
├─────────────────────────────────────────────────────────────────────┤
│  CombatGridService (Extended)                                        │
│  ├── [NEW] InitializeFromRoom(roomConfig): apply terrain/cover      │
│  ├── [NEW] ApplyRoomTerrain(roomConfig): set terrain per position   │
│  └── [NEW] ApplyRoomCover(roomConfig): add cover per position       │
├─────────────────────────────────────────────────────────────────────┤
│  GridRenderOptions (Extended from v0.5.0c)                           │
│  ├── [v0.5.0c] ShowCoordinates, ShowLegend, Compact                 │
│  ├── [NEW] ShowTerrain: bool (default: true)                        │
│  └── [NEW] ShowCover: bool (default: true)                          │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    INFRASTRUCTURE / CONFIG                           │
├─────────────────────────────────────────────────────────────────────┤
│  RoomConfiguration (Extended)                                        │
│  ├── [NEW] Terrain: TerrainLayoutEntry[]                            │
│  └── [NEW] Cover: CoverLayoutEntry[]                                │
├─────────────────────────────────────────────────────────────────────┤
│  TerrainLayoutEntry                                                  │
│  ├── Positions: string[] (e.g., ["E1", "F1"])                       │
│  └── TerrainId: string (e.g., "rubble")                             │
├─────────────────────────────────────────────────────────────────────┤
│  CoverLayoutEntry                                                    │
│  ├── Position(s): string(s) (e.g., "B2" or ["C4", "E4"])            │
│  └── CoverId: string (e.g., "wooden-crate")                         │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. GridRenderer Updates

### 4.1 Updated Implementation

**File:** `src/Presentation/RuneAndRust.Presentation/Adapters/GridRenderer.cs`

```csharp
// Update GridRenderer to handle terrain and cover:

public class GridRenderer : IGridRenderer
{
    private readonly ITerrainService _terrainService;
    private readonly ICoverService _coverService;

    public GridRenderer(ITerrainService terrainService, ICoverService coverService)
    {
        _terrainService = terrainService;
        _coverService = coverService;
    }

    /// <summary>Renders a single cell with display priority.</summary>
    public string RenderCell(GridCell cell, CoverObject? cover, Guid? playerId)
    {
        // Priority 1: Entity
        if (cell.IsOccupied)
        {
            if (cell.OccupantId == playerId)
                return "@";
            return "M";
        }

        // Priority 2: Cover
        if (cover != null && !cover.IsDestroyed)
            return cover.DisplayChar.ToString();

        // Priority 3: Terrain
        return GetTerrainChar(cell).ToString();
    }

    /// <summary>Gets the display character for a terrain type.</summary>
    public char GetTerrainChar(GridCell cell)
    {
        // Use definition if available
        var def = _terrainService.GetTerrainDefinition(cell.Position);
        if (def != null) return def.DisplayChar;

        // Otherwise use type default
        return cell.TerrainType switch
        {
            TerrainType.Normal => '.',
            TerrainType.Difficult => '~',
            TerrainType.Impassable => '○',
            TerrainType.Hazardous => '▲',
            _ => '.'
        };
    }

    /// <summary>Renders dynamic legend based on grid content.</summary>
    public string RenderLegend(CombatGrid grid, Guid playerId)
    {
        var legend = new StringBuilder();
        legend.AppendLine("Legend:");
        legend.AppendLine("  @ = You    M = Monster");

        // Add unique terrain types
        var terrainTypes = GetUniqueTerrainTypes(grid);
        foreach (var def in terrainTypes)
        {
            var info = def.Type == TerrainType.Hazardous && def.DealsDamage
                ? $" ({def.DamageOnEntry})"
                : def.MovementCostMultiplier > 1
                    ? $" ({def.MovementCostMultiplier}x move)"
                    : "";
            legend.AppendLine($"  {def.DisplayChar} = {def.Name}{info}");
        }

        // Add unique cover types
        var coverTypes = GetUniqueCoverTypes(grid);
        foreach (var cover in coverTypes)
        {
            var info = cover.CoverType == CoverType.Full
                ? " (full cover)"
                : $" (+{cover.DefenseBonus} def)";
            legend.AppendLine($"  {cover.DisplayChar} = {cover.Name}{info}");
        }

        return legend.ToString();
    }

    /// <summary>Gets unique terrain definitions present on the grid.</summary>
    public IEnumerable<TerrainDefinition> GetUniqueTerrainTypes(CombatGrid grid)
    {
        var seen = new HashSet<string>();
        for (int y = 0; y < grid.Height; y++)
        {
            for (int x = 0; x < grid.Width; x++)
            {
                var pos = new GridPosition(x, y);
                var def = _terrainService.GetTerrainDefinition(pos);
                if (def != null && def.Type != TerrainType.Normal && seen.Add(def.Id))
                    yield return def;
            }
        }
    }

    /// <summary>Gets unique cover objects present on the grid.</summary>
    public IEnumerable<CoverObject> GetUniqueCoverTypes(CombatGrid grid)
    {
        var seen = new HashSet<string>();
        foreach (var (_, cover) in grid.CoverObjects)
        {
            if (!cover.IsDestroyed && seen.Add(cover.DefinitionId))
                yield return cover;
        }
    }

    /// <summary>Renders combatant list with cover status.</summary>
    public string RenderCombatantList(
        CombatGrid grid, Guid playerId, Player player, IEnumerable<Monster> monsters)
    {
        var sb = new StringBuilder();
        sb.AppendLine("Combatants:");

        // Player
        var playerPos = grid.GetEntityPosition(playerId);
        sb.AppendLine($"  @ You ({playerPos}) - HP: {player.Health}/{player.Stats.MaxHealth} - Move: {player.MovementPointsRemaining}/{player.MovementSpeed * 2}");

        // Monsters with cover status
        foreach (var monster in monsters)
        {
            var monsterPos = grid.GetEntityPosition(monster.Id);
            if (!monsterPos.HasValue) continue;

            var coverInfo = GetCoverStatusForDisplay(monster.Id, playerId);
            sb.AppendLine($"  M {monster.Name} ({monsterPos}) - HP: {monster.Health}/{monster.MaxHealth}{coverInfo}");
        }

        return sb.ToString();
    }

    private string GetCoverStatusForDisplay(Guid targetId, Guid attackerId)
    {
        var cover = _coverService.GetCoverBetween(attackerId, targetId);
        if (cover.CoverType == CoverType.None)
            return "";
        if (cover.CoverType == CoverType.Full)
            return $" [Behind {cover.CoverObject?.Name}: FULL COVER]";
        return $" [Behind {cover.CoverObject?.Name}: +{cover.DefenseBonus} def]";
    }
}
```

---

## 5. CombatService Cover Integration

**File:** `src/Core/RuneAndRust.Application/Services/CombatService.cs`

```csharp
// Update CombatService to include cover in attack calculations:

public AttackResult ProcessAttack(Guid attackerId, Guid targetId, Item weapon)
{
    // ... existing range/LOS validation ...

    // Check cover
    var coverResult = _coverService.GetCoverBetween(attackerId, targetId);

    if (coverResult.CoverType == CoverType.Full)
    {
        _logger.LogDebug("Attack blocked by full cover: {Cover}", coverResult.CoverObject?.Name);
        return new AttackResult
        {
            Success = false,
            FullCoverBlocked = true,
            CoverObject = coverResult.CoverObject,
            Message = $"Target has full cover behind {coverResult.CoverObject?.Name}."
        };
    }

    // Get target entity and calculate modified defense
    var target = GetTarget(targetId);
    var baseDefense = target.Defense;
    var coverBonus = coverResult.DefenseBonus;
    var totalDefense = baseDefense + coverBonus;

    // Roll attack
    var attackRoll = _diceService.Roll(weapon.AttackDice ?? "2d6");
    var attackModifier = GetAttackModifier(attackerId, weapon);
    var rangeCheck = _rangeService.CheckFullRange(attackerId, targetId, weapon);
    var rangePenalty = rangeCheck.Penalty;
    var totalAttack = attackRoll.Total + attackModifier - rangePenalty;

    var hit = totalAttack >= totalDefense;

    // Build detailed message
    var message = BuildAttackMessage(
        weapon, attackRoll, attackModifier, rangePenalty,
        baseDefense, coverBonus, coverResult.CoverObject,
        hit, target);

    if (hit)
    {
        var damageRoll = _diceService.Roll(weapon.Damage);
        target.TakeDamage(damageRoll.Total);
        return AttackResult.Hit(damageRoll.Total, message, coverResult.CoverObject);
    }

    return AttackResult.Miss(message, coverResult.CoverObject);
}

private string BuildAttackMessage(
    Item weapon, DiceRollResult attackRoll, int modifier, int rangePenalty,
    int baseDefense, int coverBonus, CoverObject? cover,
    bool hit, ICombatant target)
{
    var sb = new StringBuilder();

    // Attack roll line
    var modStr = modifier >= 0 ? $" + {modifier}" : $" - {Math.Abs(modifier)}";
    var penStr = rangePenalty > 0 ? $" - {rangePenalty}" : "";
    var total = attackRoll.Total + modifier - rangePenalty;
    sb.AppendLine($"[Attack Roll: {attackRoll.Expression}{modStr}{penStr} = {total} vs AC {baseDefense + coverBonus}]");

    // Cover info
    if (coverBonus > 0)
        sb.AppendLine($"[Cover: +{coverBonus} from {cover?.Name}]");

    // Range penalty info
    if (rangePenalty > 0)
        sb.AppendLine($"[Long range penalty: -{rangePenalty}]");

    // Result
    if (hit)
        sb.Append("Hit!");
    else
        sb.Append(coverBonus > 0 ? "Miss! The cover partially deflected your attack." : "Miss!");

    return sb.ToString();
}
```

### 5.1 Updated AttackResult

```csharp
public readonly record struct AttackResult
{
    public bool Success { get; init; }
    public bool Hit { get; init; }
    public int Damage { get; init; }
    public bool FullCoverBlocked { get; init; }
    public CoverObject? CoverObject { get; init; }
    public string Message { get; init; }

    public static AttackResult Hit(int damage, string message, CoverObject? cover = null) =>
        new() { Success = true, Hit = true, Damage = damage, Message = message, CoverObject = cover };

    public static AttackResult Miss(string message, CoverObject? cover = null) =>
        new() { Success = true, Hit = false, Message = message, CoverObject = cover };
}
```

---

## 6. MovementService Display Updates

**File:** `src/Core/RuneAndRust.Application/Services/MovementService.cs`

```csharp
// Update MovementService to include terrain info in result messages:

private string BuildMovementMessage(
    GridPosition oldPos, GridPosition newPos,
    int cost, int remaining, TerrainDamageResult? hazardDamage)
{
    var sb = new StringBuilder();

    // Movement line
    sb.AppendLine($"[Movement: {oldPos} → {newPos}]");

    // Terrain info
    var terrain = _terrainService.GetTerrainDefinition(newPos);
    if (terrain != null && terrain.Type != TerrainType.Normal)
    {
        var costInfo = terrain.MovementCostMultiplier > 1
            ? $" - {terrain.MovementCostMultiplier}x movement cost"
            : "";
        sb.AppendLine($"[Terrain: {terrain.Name} ({terrain.Type.ToString().ToLower()}){costInfo}]");
    }

    // Movement points
    sb.AppendLine($"[Movement Points: {remaining + cost} → {remaining} remaining]");

    // Hazard damage
    if (hazardDamage?.DamageDealt == true)
    {
        sb.AppendLine();
        sb.AppendLine("[HAZARD DAMAGE]");
        sb.AppendLine(hazardDamage.Value.Message);
    }

    return sb.ToString();
}
```

---

## 7. Room Configuration Updates

### 7.1 Configuration Types

```csharp
public class TerrainLayoutEntry
{
    public string[] Positions { get; set; } = Array.Empty<string>();
    public string TerrainId { get; set; } = string.Empty;
}

public class CoverLayoutEntry
{
    public string? Position { get; set; }
    public string[]? Positions { get; set; }
    public string CoverId { get; set; } = string.Empty;
}

// Update RoomConfiguration:
public class RoomConfiguration
{
    // ... existing properties ...
    public int GridWidth { get; set; } = 8;
    public int GridHeight { get; set; } = 8;
    public TerrainLayoutEntry[] Terrain { get; set; } = Array.Empty<TerrainLayoutEntry>();
    public CoverLayoutEntry[] Cover { get; set; } = Array.Empty<CoverLayoutEntry>();
}
```

### 7.2 Room Configuration JSON

```json
{
  "rooms": [
    {
      "id": "throne-room",
      "name": "Throne Room",
      "gridWidth": 8,
      "gridHeight": 8,
      "terrain": [
        { "positions": ["E1", "F1", "E5", "F5"], "terrainId": "rubble" },
        { "positions": ["D3"], "terrainId": "fire" },
        { "positions": ["F5"], "terrainId": "pit" }
      ],
      "cover": [
        { "position": "B2", "coverId": "wooden-crate" },
        { "position": "G2", "coverId": "stone-pillar" },
        { "positions": ["C4", "E4"], "coverId": "low-wall" }
      ]
    }
  ]
}
```

---

## 8. Grid Initialization

**File:** `src/Core/RuneAndRust.Application/Services/CombatGridService.cs`

```csharp
// Add methods for room-based initialization:

public void InitializeFromRoom(RoomConfiguration room)
{
    // Create grid
    _activeGrid = CombatGrid.Create(room.GridWidth, room.GridHeight);

    // Apply terrain
    ApplyRoomTerrain(room);

    // Apply cover
    ApplyRoomCover(room);

    _logger.LogInformation("Grid initialized from room {Room}: {W}x{H}",
        room.Id, room.GridWidth, room.GridHeight);
}

private void ApplyRoomTerrain(RoomConfiguration room)
{
    foreach (var entry in room.Terrain)
    {
        var terrainDef = _configProvider.GetTerrainDefinition(entry.TerrainId);
        if (terrainDef == null)
        {
            _logger.LogWarning("Unknown terrain: {Id}", entry.TerrainId);
            continue;
        }

        foreach (var posStr in entry.Positions)
        {
            if (GridPosition.TryParse(posStr, out var pos))
            {
                _terrainService.SetTerrain(pos, entry.TerrainId);
            }
        }
    }
}

private void ApplyRoomCover(RoomConfiguration room)
{
    foreach (var entry in room.Cover)
    {
        var coverDef = _configProvider.GetCoverDefinition(entry.CoverId);
        if (coverDef == null)
        {
            _logger.LogWarning("Unknown cover: {Id}", entry.CoverId);
            continue;
        }

        var positions = entry.Positions ?? (entry.Position != null ? new[] { entry.Position } : Array.Empty<string>());

        foreach (var posStr in positions)
        {
            if (GridPosition.TryParse(posStr, out var pos))
            {
                _coverService.AddCover(coverDef, pos);
            }
        }
    }
}
```

---

## 9. User-Facing Commands

### 9.1 Grid Command with Terrain & Cover

```
> grid

Combat Grid                              [Turn 3]
===============================================

  A B C D E F G H
1 . . . . ~ ~ . .
2 . □ M . . M █ .
3 . . . ▲ . . . .
4 . . ▄ @ ▄ . . .
5 ~ ~ . . . ○ . .

Legend:
  @ = You    M = Monster
  . = Stone Floor
  ~ = Rubble (2x move)
  ▲ = Fire (1d6)
  ○ = Pit (impassable)
  □ = Wooden Crate (+2 def)
  █ = Stone Pillar (full cover)
  ▄ = Low Wall (+2 def)

Combatants:
  @ You (D4) - HP: 25/30 - Move: 3/4
  M Skeleton (C2) - HP: 10/10 [Behind Wooden Crate: +2 def]
  M Skeleton (F2) - HP: 8/10 [Behind Stone Pillar: FULL COVER]
```

### 9.2 Compact Grid

```
Combat: Skeleton x2                      [Your Turn]
═══════════════════════════════════════════════════

  A B C D E F G H
1 . . . . ~ ~ . .
2 . □ M . . M █ .     @ = You    M = Monster
3 . . . ▲ . . . .     □ = Cover  █ = Full cover
4 . . ▄ @ ▄ . . .     ~ = Difficult  ▲ = Fire
5 ~ ~ . . . ○ . .     ○ = Impassable

You (D4) | HP: 25/30 | Weapon: Iron Sword (Melee)
```

### 9.3 Attack with Cover Display

```
> attack skeleton

Which Skeleton?
  1. Skeleton at C2 [Behind Wooden Crate: +2 defense]
  2. Skeleton at F2 [Behind Stone Pillar: FULL COVER]

> 1

You fire your Longbow at the Skeleton at C2...

[Distance: 3 cells - in range]
[Target Cover: Wooden Crate (+2 defense)]
[Attack Roll: 2d6 + 3 = 14 vs AC 14 (12 + 2 cover)]
Hit! 7 damage to Skeleton.

The cover partially deflected your shot.
```

### 9.4 Movement with Terrain Display

```
> move northeast

You carefully pick your way through the rubble...

[Movement: D4 → E3]
[Terrain: Rubble (difficult) - 2x movement cost]
[Movement Points: 4 → 1 remaining]
```

---

## 10. Data Model Changes

| Type | Layer | Description |
|------|-------|-------------|
| `GridRenderer` | Presentation | Updated with terrain/cover rendering |
| `CombatService` | Application | Cover integration in attacks |
| `MovementService` | Application | Terrain display in messages |
| `CombatGridService` | Application | Room initialization |
| `RoomConfiguration` | Config | Terrain/cover layout |
| `TerrainLayoutEntry` | Config | Terrain placement |
| `CoverLayoutEntry` | Config | Cover placement |
| `AttackResult` | Application/DTOs | Add cover info |
| `GridRenderOptions` | Application/DTOs | Add ShowTerrain, ShowCover |

---

## 11. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `GridRenderer` | Debug | Cell rendering, legend generation |
| `CombatService` | Debug | Cover calculations in attacks |
| `CombatGridService` | Information | Room initialization |
| `CombatGridService` | Warning | Unknown terrain/cover IDs |

---

## 12. Unit Testing Requirements

| Feature | Test Count |
|---------|------------|
| GridRenderer.RenderCell | ~4 |
| GridRenderer.RenderLegend | ~3 |
| GridRenderer.GetUniqueTerrainTypes | ~2 |
| GridRenderer.GetUniqueCoverTypes | ~2 |
| CombatService Cover Integration | ~5 |
| MovementService Display | ~3 |
| CombatGridService.InitializeFromRoom | ~4 |
| Room Configuration Parsing | ~2 |
| **Total** | **~25** |

---

## 13. Use Cases

### UC-001: Display Grid with Terrain
**Flow:** grid command → render with terrain symbols → show dynamic legend

### UC-002: Attack with Partial Cover
**Flow:** Attack target → cover check → +2 defense → roll vs modified AC

### UC-003: Attack Blocked by Full Cover
**Flow:** Attack target → full cover → cannot target → show message

### UC-004: Movement Shows Terrain
**Flow:** Move into rubble → display terrain type and 2x cost

### UC-005: Initialize Room with Layout
**Flow:** StartCombat → load room → apply terrain → apply cover → place entities

---

## 14. Deliverable Checklist

### Presentation Layer
- [ ] GridRenderer terrain/cover rendering
- [ ] GridRenderer dynamic legend
- [ ] GridRenderer combatant list with cover
- [ ] Updated grid command display

### Application Layer
- [ ] CombatService cover integration
- [ ] MovementService terrain display
- [ ] CombatGridService room initialization
- [ ] Updated AttackResult
- [ ] Updated GridRenderOptions

### Configuration
- [ ] RoomConfiguration terrain/cover support
- [ ] TerrainLayoutEntry, CoverLayoutEntry types
- [ ] Sample room configuration JSON

### Testing
- [ ] ~25 unit tests
- [ ] All tests passing

---

## 15. Acceptance Criteria

### Functional
- [ ] Grid displays terrain symbols correctly
- [ ] Grid displays cover symbols correctly
- [ ] Legend includes all terrain/cover on grid dynamically
- [ ] Combat calculates defense with cover bonus
- [ ] Full cover blocks targeting
- [ ] Movement shows terrain cost in output
- [ ] Hazard damage shows in movement result
- [ ] Room configuration loads terrain layout
- [ ] Room configuration loads cover layout
- [ ] Grid initialization applies terrain/cover
- [ ] Combatant list shows cover status

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~25 unit tests pass
- [ ] XML documentation complete

---

## 16. Dependencies

### Required from v0.5.2a

| Type | Usage |
|------|-------|
| `TerrainType` | Terrain display characters |
| `TerrainDefinition` | Display info |
| `TerrainService` | Get terrain at position |

### Required from v0.5.2b

| Type | Usage |
|------|-------|
| `CoverType` | Cover display characters |
| `CoverObject` | Cover info and display |
| `CoverService` | Cover checks |

### Required from v0.5.0c

| Type | Usage |
|------|-------|
| `GridRenderer` | Base for extensions |
| `GridRenderOptions` | Extended with new options |

---

## 17. Future Considerations

### Deferred to v0.5.3
- Flanking mechanics
- Area of effect attacks
- Opportunity attacks

### Out of Scope
- Animated terrain effects
- Weather effects on grid
- Dynamic lighting on grid

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: AI Assistant*
