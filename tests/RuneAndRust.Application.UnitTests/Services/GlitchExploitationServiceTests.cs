// ------------------------------------------------------------------------------
// <copyright file="GlitchExploitationServiceTests.cs" company="Rune &amp; Rust">
//     Copyright (c) Rune &amp; Rust. All rights reserved.
// </copyright>
// <summary>
// Unit tests for the GlitchExploitationService, covering pattern observation,
// chaos rolls, exploit window detection, DC modifiers, and phase advancement.
// Part of v0.15.4f Glitch Exploitation System implementation.
// </summary>
// ------------------------------------------------------------------------------

using FluentAssertions;
using Microsoft.Extensions.Logging;
using NSubstitute;
using NUnit.Framework;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

/// <summary>
/// Unit tests for the <see cref="GlitchExploitationService"/> service.
/// </summary>
/// <remarks>
/// <para>
/// Tests cover the following areas:
/// <list type="bullet">
///   <item><description>Pattern observation (WITS DC 14) success and failure</description></item>
///   <item><description>Exploit window detection (Permissive phase = -4 DC)</description></item>
///   <item><description>Chaos roll modifiers (d6: 1-2 = +4, 3-4 = 0, 5-6 = -2)</description></item>
///   <item><description>Phase advancement (Stable → Unstable → Permissive → Lockdown)</description></item>
///   <item><description>DC modifier calculation for various states</description></item>
///   <item><description>Glitch state initialization</description></item>
///   <item><description>ChaosResult value object creation</description></item>
///   <item><description>GlitchState value object computed properties</description></item>
///   <item><description>Null argument validation (guard clauses)</description></item>
/// </list>
/// </para>
/// </remarks>
[TestFixture]
public class GlitchExploitationServiceTests
{
    // -------------------------------------------------------------------------
    // Test Dependencies
    // -------------------------------------------------------------------------

    private IDiceService _diceService = null!;
    private ILogger<GlitchExploitationService> _logger = null!;
    private GlitchExploitationService _service = null!;

    // -------------------------------------------------------------------------
    // Constants
    // -------------------------------------------------------------------------

    private const string TestMechanismType = "glitched-terminal";
    private const int PatternObservationDc = 14;
    private const int ExploitWindowBonus = -4;
    private const int LockdownPenalty = 2;

    // -------------------------------------------------------------------------
    // Setup and Teardown
    // -------------------------------------------------------------------------

    /// <summary>
    /// Sets up the test environment before each test.
    /// </summary>
    [SetUp]
    public void Setup()
    {
        _logger = Substitute.For<ILogger<GlitchExploitationService>>();
        _diceService = Substitute.For<IDiceService>();

        // Create service under test
        _service = new GlitchExploitationService(_diceService, _logger);
    }

    // -------------------------------------------------------------------------
    // Mock Helper Methods
    // -------------------------------------------------------------------------

    /// <summary>
    /// Configures the dice service mock to return a d10 result with specified net successes.
    /// </summary>
    /// <param name="netSuccesses">The net successes (successes - botches) to return.</param>
    /// <param name="isFumble">Whether to simulate a fumble (0 successes + botch).</param>
    private void SetupD10Roll(int netSuccesses, bool isFumble = false)
    {
        var successes = Math.Max(0, netSuccesses);
        var botches = isFumble ? 1 : 0;
        var rolls = CreateRollsForNetSuccesses(successes, botches);
        var pool = DicePool.D10(rolls.Count);

        var result = new DiceRollResult(pool, rolls);
        _diceService.Roll(Arg.Is<DicePool>(p => p.DiceType == DiceType.D10)).Returns(result);
    }

    /// <summary>
    /// Configures the dice service mock to return a d6 result.
    /// </summary>
    /// <param name="value">The d6 roll value (1-6).</param>
    private void SetupD6Roll(int value)
    {
        var pool = DicePool.D6(1);
        var result = new DiceRollResult(pool, new[] { value });
        _diceService.Roll(Arg.Is<DicePool>(p => p.DiceType == DiceType.D6)).Returns(result);
    }

    /// <summary>
    /// Configures the dice service mock to return a d4 result.
    /// </summary>
    /// <param name="value">The d4 roll value (1-4).</param>
    private void SetupD4Roll(int value)
    {
        var pool = DicePool.D4(1);
        var result = new DiceRollResult(pool, new[] { value });
        _diceService.Roll(Arg.Is<DicePool>(p => p.DiceType == DiceType.D4)).Returns(result);
    }

    /// <summary>
    /// Creates a list of rolls that would produce the specified successes and botches.
    /// </summary>
    /// <param name="successes">Number of successes (8-10 on d10).</param>
    /// <param name="botches">Number of botches (1 on d10).</param>
    /// <returns>A list of die roll values.</returns>
    private static List<int> CreateRollsForNetSuccesses(int successes, int botches)
    {
        var rolls = new List<int>();

        // Add successes (8, 9, or 10)
        for (var i = 0; i < successes; i++)
        {
            rolls.Add(8 + (i % 3));
        }

        // Add botches (1)
        for (var i = 0; i < botches; i++)
        {
            rolls.Add(1);
        }

        // Pad with neutral values if needed
        if (rolls.Count == 0)
        {
            rolls.Add(5); // Neutral die
        }

        return rolls;
    }

    // -------------------------------------------------------------------------
    // Pattern Observation Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that successful pattern observation identifies the glitch cycle.
    /// </summary>
    [Test]
    public void ObserveGlitchPattern_Success_IdentifiesCycle()
    {
        // Arrange
        SetupD10Roll(netSuccesses: 2); // Success (net > 0)
        SetupD4Roll(2); // Current phase = Unstable, duration = 3 rounds

        // Act
        var result = _service.ObserveGlitchPattern(witsScore: 12, TestMechanismType);

        // Assert
        result.Success.Should().BeTrue();
        result.GlitchState.GlitchCycleIdentified.Should().BeTrue();
        result.CanTimeActions.Should().BeTrue();
        result.RequiresChaosRoll.Should().BeFalse();
        result.NarrativeText.Should().NotBeNullOrEmpty();
    }

    /// <summary>
    /// Tests that failed pattern observation does not identify the cycle.
    /// </summary>
    [Test]
    public void ObserveGlitchPattern_Failure_PatternUnknown()
    {
        // Arrange
        SetupD10Roll(netSuccesses: 0, isFumble: false); // Failure (net = 0)

        // Act
        var result = _service.ObserveGlitchPattern(witsScore: 5, TestMechanismType);

        // Assert
        result.Success.Should().BeFalse();
        result.GlitchState.GlitchCycleIdentified.Should().BeFalse();
        result.CanTimeActions.Should().BeFalse();
        result.RequiresChaosRoll.Should().BeTrue();
        result.NarrativeText.Should().Contain("defies");
    }

    /// <summary>
    /// Tests that pattern observation throws on invalid WITS score.
    /// </summary>
    [Test]
    public void ObserveGlitchPattern_InvalidWitsScore_ThrowsArgumentOutOfRangeException()
    {
        // Act
        var act = () => _service.ObserveGlitchPattern(witsScore: 0, TestMechanismType);

        // Assert
        act.Should().Throw<ArgumentOutOfRangeException>()
            .WithParameterName("witsScore");
    }

    /// <summary>
    /// Tests that pattern observation throws on null mechanism type.
    /// </summary>
    [Test]
    public void ObserveGlitchPattern_NullMechanismType_ThrowsArgumentNullException()
    {
        // Act
        var act = () => _service.ObserveGlitchPattern(witsScore: 10, null!);

        // Assert
        act.Should().Throw<ArgumentNullException>();
    }

    // -------------------------------------------------------------------------
    // Exploit Window Detection Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that exploit window is detected when in Permissive phase with identified pattern.
    /// </summary>
    [Test]
    public void IsInExploitWindow_IdentifiedAndPermissive_ReturnsTrue()
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Permissive,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var inWindow = _service.IsInExploitWindow(state);

        // Assert
        inWindow.Should().BeTrue();
    }

    /// <summary>
    /// Tests that exploit window is not detected when outside Permissive phase.
    /// </summary>
    /// <param name="phase">The current glitch cycle phase.</param>
    [TestCase(GlitchCyclePhase.Stable)]
    [TestCase(GlitchCyclePhase.Unstable)]
    [TestCase(GlitchCyclePhase.Lockdown)]
    public void IsInExploitWindow_IdentifiedButNotPermissive_ReturnsFalse(GlitchCyclePhase phase)
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: phase,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var inWindow = _service.IsInExploitWindow(state);

        // Assert
        inWindow.Should().BeFalse();
    }

    /// <summary>
    /// Tests that exploit window is not detected when pattern is not identified.
    /// </summary>
    [Test]
    public void IsInExploitWindow_NotIdentified_ReturnsFalse()
    {
        // Arrange - even if technically in Permissive, pattern unknown
        var state = GlitchState.CreateUnobserved(
            initialPhase: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var inWindow = _service.IsInExploitWindow(state);

        // Assert
        inWindow.Should().BeFalse();
    }

    // -------------------------------------------------------------------------
    // DC Modifier Calculation Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that exploit window provides -4 DC modifier.
    /// </summary>
    [Test]
    public void CalculateGlitchModifier_InExploitWindow_ReturnsMinus4()
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Permissive,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var modifier = _service.CalculateGlitchModifier(state);

        // Assert
        modifier.Should().Be(ExploitWindowBonus); // -4
    }

    /// <summary>
    /// Tests that identified pattern outside exploit window provides +0 DC modifier.
    /// </summary>
    /// <param name="phase">The current glitch cycle phase.</param>
    [TestCase(GlitchCyclePhase.Stable)]
    [TestCase(GlitchCyclePhase.Unstable)]
    public void CalculateGlitchModifier_IdentifiedOutsideWindow_ReturnsZero(GlitchCyclePhase phase)
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: phase,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var modifier = _service.CalculateGlitchModifier(state);

        // Assert
        modifier.Should().Be(0);
    }

    /// <summary>
    /// Tests that chaos roll 1-2 provides +4 DC modifier.
    /// </summary>
    /// <param name="roll">The chaos roll value.</param>
    [TestCase(1)]
    [TestCase(2)]
    public void CalculateGlitchModifier_ChaosAgainst_ReturnsPlus4(int roll)
    {
        // Arrange
        var state = GlitchState.CreateWithChaos(roll, GlitchCyclePhase.Stable);

        // Act
        var modifier = _service.CalculateGlitchModifier(state);

        // Assert
        modifier.Should().Be(4); // Against
    }

    /// <summary>
    /// Tests that chaos roll 3-4 provides +0 DC modifier.
    /// </summary>
    /// <param name="roll">The chaos roll value.</param>
    [TestCase(3)]
    [TestCase(4)]
    public void CalculateGlitchModifier_ChaosNeutral_ReturnsZero(int roll)
    {
        // Arrange
        var state = GlitchState.CreateWithChaos(roll, GlitchCyclePhase.Stable);

        // Act
        var modifier = _service.CalculateGlitchModifier(state);

        // Assert
        modifier.Should().Be(0); // Neutral
    }

    /// <summary>
    /// Tests that chaos roll 5-6 provides -2 DC modifier.
    /// </summary>
    /// <param name="roll">The chaos roll value.</param>
    [TestCase(5)]
    [TestCase(6)]
    public void CalculateGlitchModifier_ChaosHelps_ReturnsMinus2(int roll)
    {
        // Arrange
        var state = GlitchState.CreateWithChaos(roll, GlitchCyclePhase.Stable);

        // Act
        var modifier = _service.CalculateGlitchModifier(state);

        // Assert
        modifier.Should().Be(-2); // Helps
    }

    // -------------------------------------------------------------------------
    // Chaos Roll Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that chaos roll 1-2 returns Against effect.
    /// </summary>
    /// <param name="roll">The d6 roll value.</param>
    [TestCase(1)]
    [TestCase(2)]
    public void RollChaos_Roll1Or2_ReturnsAgainst(int roll)
    {
        // Arrange
        SetupD6Roll(roll);

        // Act
        var result = _service.RollChaos();

        // Assert
        result.Effect.Should().Be(ChaosEffect.Against);
        result.DcModifier.Should().Be(4);
        result.Roll.Should().Be(roll);
    }

    /// <summary>
    /// Tests that chaos roll 3-4 returns Neutral effect.
    /// </summary>
    /// <param name="roll">The d6 roll value.</param>
    [TestCase(3)]
    [TestCase(4)]
    public void RollChaos_Roll3Or4_ReturnsNeutral(int roll)
    {
        // Arrange
        SetupD6Roll(roll);

        // Act
        var result = _service.RollChaos();

        // Assert
        result.Effect.Should().Be(ChaosEffect.Neutral);
        result.DcModifier.Should().Be(0);
        result.Roll.Should().Be(roll);
    }

    /// <summary>
    /// Tests that chaos roll 5-6 returns Helps effect.
    /// </summary>
    /// <param name="roll">The d6 roll value.</param>
    [TestCase(5)]
    [TestCase(6)]
    public void RollChaos_Roll5Or6_ReturnsHelps(int roll)
    {
        // Arrange
        SetupD6Roll(roll);

        // Act
        var result = _service.RollChaos();

        // Assert
        result.Effect.Should().Be(ChaosEffect.Helps);
        result.DcModifier.Should().Be(-2);
        result.Roll.Should().Be(roll);
    }

    /// <summary>
    /// Tests that ChaosResult has appropriate narrative text.
    /// </summary>
    [Test]
    public void RollChaos_ReturnsNarrativeText()
    {
        // Arrange
        SetupD6Roll(1);

        // Act
        var result = _service.RollChaos();

        // Assert
        result.NarrativeText.Should().NotBeNullOrEmpty();
    }

    // -------------------------------------------------------------------------
    // ChaosResult Value Object Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests ChaosResult.FromRoll factory for Against effect.
    /// </summary>
    [Test]
    public void ChaosResult_FromRoll_Against_CreatesCorrectly()
    {
        // Act
        var result = ChaosResult.FromRoll(1);

        // Assert
        result.Roll.Should().Be(1);
        result.Effect.Should().Be(ChaosEffect.Against);
        result.DcModifier.Should().Be(4);
        result.EffectSummary.Should().Contain("+4");
    }

    /// <summary>
    /// Tests ChaosResult.FromRoll factory for Helps effect.
    /// </summary>
    [Test]
    public void ChaosResult_FromRoll_Helps_CreatesCorrectly()
    {
        // Act
        var result = ChaosResult.FromRoll(6);

        // Assert
        result.Roll.Should().Be(6);
        result.Effect.Should().Be(ChaosEffect.Helps);
        result.DcModifier.Should().Be(-2);
        result.EffectSummary.Should().Contain("-2");
    }

    /// <summary>
    /// Tests that ChaosResult.FromRoll throws for invalid roll value.
    /// </summary>
    /// <param name="invalidRoll">An invalid roll value.</param>
    [TestCase(0)]
    [TestCase(7)]
    [TestCase(-1)]
    public void ChaosResult_FromRoll_InvalidValue_ThrowsArgumentOutOfRangeException(int invalidRoll)
    {
        // Act
        var act = () => ChaosResult.FromRoll(invalidRoll);

        // Assert
        act.Should().Throw<ArgumentOutOfRangeException>();
    }

    // -------------------------------------------------------------------------
    // Phase Advancement Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that phases advance in correct order.
    /// </summary>
    /// <param name="currentPhase">The current phase.</param>
    /// <param name="expectedNextPhase">The expected next phase.</param>
    [TestCase(GlitchCyclePhase.Stable, GlitchCyclePhase.Unstable)]
    [TestCase(GlitchCyclePhase.Unstable, GlitchCyclePhase.Permissive)]
    [TestCase(GlitchCyclePhase.Permissive, GlitchCyclePhase.Lockdown)]
    [TestCase(GlitchCyclePhase.Lockdown, GlitchCyclePhase.Stable)]
    public void AdvanceRound_WhenPhaseDurationReached_AdvancesPhase(
        GlitchCyclePhase currentPhase,
        GlitchCyclePhase expectedNextPhase)
    {
        // Arrange - create state at last round of phase
        var state = GlitchState.CreateObserved(
            currentPhase: currentPhase,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 2) with { RoundsInCurrentPhase = 1 };

        // Act
        var newState = _service.AdvanceRound(state);

        // Assert
        newState.CyclePhase.Should().Be(expectedNextPhase);
        newState.RoundsInCurrentPhase.Should().Be(0);
    }

    /// <summary>
    /// Tests that round counter increments within a phase.
    /// </summary>
    [Test]
    public void AdvanceRound_WithinPhaseDuration_IncrementsRoundCounter()
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Stable,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 5) with { RoundsInCurrentPhase = 1 };

        // Act
        var newState = _service.AdvanceRound(state);

        // Assert
        newState.CyclePhase.Should().Be(GlitchCyclePhase.Stable);
        newState.RoundsInCurrentPhase.Should().Be(2);
    }

    /// <summary>
    /// Tests full cycle rotation (Stable → Unstable → Permissive → Lockdown → Stable).
    /// </summary>
    [Test]
    public void AdvanceRound_FullCycle_ReturnsToStable()
    {
        // Arrange - start at Stable with duration 1 (advances immediately)
        var state = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Stable,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 1);

        // Act - advance through all phases
        state = _service.AdvanceRound(state); // Stable -> Unstable
        state.CyclePhase.Should().Be(GlitchCyclePhase.Unstable);

        state = state.AdvancePhase(); // Unstable -> Permissive
        state.CyclePhase.Should().Be(GlitchCyclePhase.Permissive);

        state = state.AdvancePhase(); // Permissive -> Lockdown
        state.CyclePhase.Should().Be(GlitchCyclePhase.Lockdown);

        state = state.AdvancePhase(); // Lockdown -> Stable
        state.CyclePhase.Should().Be(GlitchCyclePhase.Stable);
    }

    // -------------------------------------------------------------------------
    // Glitch State Initialization Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that InitializeGlitchState creates a valid unobserved state.
    /// </summary>
    [Test]
    public void InitializeGlitchState_CreatesUnobservedState()
    {
        // Arrange
        SetupD4Roll(1); // Phase = Stable, duration = 2

        // Act
        var state = _service.InitializeGlitchState(TestMechanismType);

        // Assert
        state.GlitchCycleIdentified.Should().BeFalse();
        state.ChaosRoll.Should().BeNull();
        state.PhaseDuration.Should().BeGreaterThan(0);
    }

    /// <summary>
    /// Tests that InitializeGlitchState throws on null mechanism type.
    /// </summary>
    [Test]
    public void InitializeGlitchState_NullMechanismType_ThrowsArgumentNullException()
    {
        // Act
        var act = () => _service.InitializeGlitchState(null!);

        // Assert
        act.Should().Throw<ArgumentNullException>();
    }

    // -------------------------------------------------------------------------
    // Current Cycle Phase Query Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that GetCurrentCyclePhase returns the correct phase.
    /// </summary>
    /// <param name="phase">The expected phase.</param>
    [TestCase(GlitchCyclePhase.Stable)]
    [TestCase(GlitchCyclePhase.Unstable)]
    [TestCase(GlitchCyclePhase.Permissive)]
    [TestCase(GlitchCyclePhase.Lockdown)]
    public void GetCurrentCyclePhase_ReturnsCorrectPhase(GlitchCyclePhase phase)
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: phase,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var currentPhase = _service.GetCurrentCyclePhase(state);

        // Assert
        currentPhase.Should().Be(phase);
    }

    // -------------------------------------------------------------------------
    // GlitchState Value Object Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests GlitchState.CreateUnobserved factory method.
    /// </summary>
    [Test]
    public void GlitchState_CreateUnobserved_SetsDefaultValues()
    {
        // Act
        var state = GlitchState.CreateUnobserved();

        // Assert
        state.GlitchCycleIdentified.Should().BeFalse();
        state.CyclePhase.Should().Be(GlitchCyclePhase.Stable);
        state.ExploitWindow.Should().Be(GlitchCyclePhase.Permissive);
        state.ChaosRoll.Should().BeNull();
        state.RoundsInCurrentPhase.Should().Be(0);
    }

    /// <summary>
    /// Tests GlitchState.CreateObserved factory method.
    /// </summary>
    [Test]
    public void GlitchState_CreateObserved_SetsCorrectValues()
    {
        // Act
        var state = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Unstable,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 4);

        // Assert
        state.GlitchCycleIdentified.Should().BeTrue();
        state.CyclePhase.Should().Be(GlitchCyclePhase.Unstable);
        state.ExploitWindow.Should().Be(GlitchCyclePhase.Permissive);
        state.ChaosRoll.Should().BeNull();
        state.PhaseDuration.Should().Be(4);
    }

    /// <summary>
    /// Tests GlitchState.CreateWithChaos factory method.
    /// </summary>
    [Test]
    public void GlitchState_CreateWithChaos_SetsCorrectValues()
    {
        // Act
        var state = GlitchState.CreateWithChaos(chaosRoll: 5, currentPhase: GlitchCyclePhase.Unstable);

        // Assert
        state.GlitchCycleIdentified.Should().BeFalse();
        state.ChaosRoll.Should().Be(5);
        state.DcModifier.Should().Be(-2); // Roll 5 = Helps
    }

    /// <summary>
    /// Tests GlitchState.CreateWithChaos throws for invalid roll.
    /// </summary>
    /// <param name="invalidRoll">An invalid chaos roll value.</param>
    [TestCase(0)]
    [TestCase(7)]
    [TestCase(-1)]
    public void GlitchState_CreateWithChaos_InvalidRoll_ThrowsArgumentOutOfRangeException(int invalidRoll)
    {
        // Act
        var act = () => GlitchState.CreateWithChaos(invalidRoll, GlitchCyclePhase.Stable);

        // Assert
        act.Should().Throw<ArgumentOutOfRangeException>();
    }

    /// <summary>
    /// Tests GlitchState.RoundsUntilPhaseChange computed property.
    /// </summary>
    [Test]
    public void GlitchState_RoundsUntilPhaseChange_CalculatesCorrectly()
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Stable,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 5) with { RoundsInCurrentPhase = 2 };

        // Act
        var roundsUntilChange = state.RoundsUntilPhaseChange;

        // Assert
        roundsUntilChange.Should().Be(3); // 5 - 2 = 3
    }

    /// <summary>
    /// Tests GlitchState.StateDescription returns appropriate text for each phase.
    /// </summary>
    /// <param name="phase">The glitch cycle phase.</param>
    [TestCase(GlitchCyclePhase.Stable)]
    [TestCase(GlitchCyclePhase.Unstable)]
    [TestCase(GlitchCyclePhase.Permissive)]
    [TestCase(GlitchCyclePhase.Lockdown)]
    public void GlitchState_StateDescription_ReturnsNonEmptyText(GlitchCyclePhase phase)
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: phase,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var description = state.StateDescription;

        // Assert
        description.Should().NotBeNullOrEmpty();
    }

    /// <summary>
    /// Tests GlitchState.ToDisplayString includes all relevant information.
    /// </summary>
    [Test]
    public void GlitchState_ToDisplayString_IncludesPhaseInfo()
    {
        // Arrange
        var state = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Permissive,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var display = state.ToDisplayString();

        // Assert
        display.Should().Contain("IDENTIFIED");
        display.Should().Contain("Permissive");
        display.Should().Contain("-4");
    }

    // -------------------------------------------------------------------------
    // GlitchObservationResult Value Object Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests GlitchObservationResult.Succeeded factory method.
    /// </summary>
    [Test]
    public void GlitchObservationResult_Succeeded_SetsCorrectValues()
    {
        // Arrange
        var glitchState = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Unstable,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var result = GlitchObservationResult.Succeeded(
            netSuccesses: 3,
            glitchState: glitchState,
            mechanismType: TestMechanismType);

        // Assert
        result.Success.Should().BeTrue();
        result.NetSuccesses.Should().Be(3);
        result.CanTimeActions.Should().BeTrue();
        result.RequiresChaosRoll.Should().BeFalse();
    }

    /// <summary>
    /// Tests GlitchObservationResult.Failed factory method.
    /// </summary>
    [Test]
    public void GlitchObservationResult_Failed_SetsCorrectValues()
    {
        // Arrange
        var glitchState = GlitchState.CreateUnobserved();

        // Act
        var result = GlitchObservationResult.Failed(
            netSuccesses: 0,
            glitchState: glitchState);

        // Assert
        result.Success.Should().BeFalse();
        result.NetSuccesses.Should().Be(0);
        result.CanTimeActions.Should().BeFalse();
        result.RequiresChaosRoll.Should().BeTrue();
    }

    /// <summary>
    /// Tests GlitchObservationResult.Skipped factory method.
    /// </summary>
    [Test]
    public void GlitchObservationResult_Skipped_SetsCorrectValues()
    {
        // Arrange
        var glitchState = GlitchState.CreateUnobserved();

        // Act
        var result = GlitchObservationResult.Skipped(glitchState);

        // Assert
        result.Success.Should().BeFalse();
        result.WasAttempted.Should().BeFalse();
        result.RequiresChaosRoll.Should().BeTrue();
    }

    /// <summary>
    /// Tests GlitchObservationResult.ToDisplayString includes relevant information.
    /// </summary>
    [Test]
    public void GlitchObservationResult_ToDisplayString_IncludesRelevantInfo()
    {
        // Arrange
        var glitchState = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Permissive,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);
        var result = GlitchObservationResult.Succeeded(2, glitchState, TestMechanismType);

        // Act
        var display = result.ToDisplayString();

        // Assert
        display.Should().Contain("SUCCESS");
        display.Should().Contain("DC 14");
        display.Should().Contain("Permissive");
    }

    // -------------------------------------------------------------------------
    // GlitchCyclePhase Enum Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that all expected phases exist with correct values.
    /// </summary>
    [Test]
    public void GlitchCyclePhase_HasAllExpectedValues()
    {
        // Assert
        Enum.GetValues<GlitchCyclePhase>().Should().HaveCount(4);
        ((int)GlitchCyclePhase.Stable).Should().Be(0);
        ((int)GlitchCyclePhase.Unstable).Should().Be(1);
        ((int)GlitchCyclePhase.Permissive).Should().Be(2);
        ((int)GlitchCyclePhase.Lockdown).Should().Be(3);
    }

    // -------------------------------------------------------------------------
    // ChaosEffect Enum Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that all expected chaos effects exist with correct values.
    /// </summary>
    [Test]
    public void ChaosEffect_HasAllExpectedValues()
    {
        // Assert
        Enum.GetValues<ChaosEffect>().Should().HaveCount(3);
        ((int)ChaosEffect.Against).Should().Be(0);
        ((int)ChaosEffect.Neutral).Should().Be(1);
        ((int)ChaosEffect.Helps).Should().Be(2);
    }

    // -------------------------------------------------------------------------
    // Constructor Guard Clause Tests
    // -------------------------------------------------------------------------

    /// <summary>
    /// Tests that constructor throws on null dice service.
    /// </summary>
    [Test]
    public void Constructor_NullDiceService_ThrowsArgumentNullException()
    {
        // Act
        var act = () => new GlitchExploitationService(null!, _logger);

        // Assert
        act.Should().Throw<ArgumentNullException>();
    }

    /// <summary>
    /// Tests that constructor throws on null logger.
    /// </summary>
    [Test]
    public void Constructor_NullLogger_ThrowsArgumentNullException()
    {
        // Act
        var act = () => new GlitchExploitationService(_diceService, null!);

        // Assert
        act.Should().Throw<ArgumentNullException>();
    }
}
