# v0.10.0b Design Specification: Buff/Debuff Service

**Version:** 0.10.0b
**Parent:** v0.10.0 (Status Effects System)
**Prerequisites:** v0.10.0a Complete (Status Effect Definitions)
**Status:** Design Complete
**Estimated Unit Tests:** ~15

---

## 1. Overview

### Purpose

Implement the core service for applying, managing, and removing status effects. This includes the `IBuffDebuffService` interface, `BuffDebuffService` implementation, stacking logic, stat modifier application/removal, active effect tracking on entities, and effect events for system integration.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | `IBuffDebuffService`, `IStatModifierService` |
| **Services** | `BuffDebuffService` |
| **Result Types** | `ApplyResult` |
| **Entity Updates** | `ICombatant.ActiveEffects` collection |
| **Events** | `EffectAppliedEvent`, `EffectRemovedEvent`, `EffectStackedEvent` |
| **Tests** | ~15 unit tests |

---

## 2. Feature Overview

```
v0.10.0b Features
├── IBuffDebuffService Interface
│   ├── ApplyEffect(target, effectId, source)
│   ├── RemoveEffect(target, effectId)
│   ├── RemoveAllStacks(target, effectId)
│   ├── ClearEffects(target, type?)
│   ├── ClearDebuffs(target)
│   ├── GetActiveEffects(target)
│   ├── GetActiveEffects(target, type)
│   ├── HasEffect(target, effectId)
│   ├── GetStackCount(target, effectId)
│   └── GetRemainingDuration(target, effectId)
│
├── BuffDebuffService Implementation
│   ├── Effect application
│   ├── Stacking logic (None, Stack, Replace, Refresh)
│   ├── Stat modifier application
│   ├── Stat modifier removal on expire
│   ├── Active effects tracking
│   └── Event publishing
│
├── ApplyResult Record
│   ├── Success, Refreshed, Stacked
│   ├── Replaced, AtMaxStacks
│   ├── Failed, Immune
│   └── ActiveEffect reference
│
├── Combatant Extension
│   ├── List<ActiveStatusEffect> _activeEffects
│   ├── AddStatusEffect(effect)
│   ├── RemoveStatusEffect(effect)
│   └── IReadOnlyList<ActiveStatusEffect> ActiveEffects
│
├── IStatModifierService
│   ├── ApplyModifiers(target, modifiers, stacks)
│   ├── RemoveModifiers(target, modifiers, stacks)
│   └── CalculateModifiedStat(base, modifiers, stacks)
│
└── Events
    ├── EffectAppliedEvent(targetId, effectId, sourceId)
    ├── EffectRemovedEvent(targetId, effectId, reason)
    └── EffectStackedEvent(targetId, effectId, newStacks)
```

---

## 3. Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    BUFF/DEBUFF SERVICE ARCHITECTURE                     │
└─────────────────────────────────────────────────────────────────────────┘

                      ┌───────────────────────────────┐
                      │       Combat System            │
                      │   (Abilities, Items, etc.)     │
                      └───────────────┬───────────────┘
                                      │
                                      ▼
                      ┌───────────────────────────────┐
                      │      IBuffDebuffService        │
                      ├───────────────────────────────┤
                      │ + ApplyEffect(target, id)     │
                      │ + RemoveEffect(target, id)    │
                      │ + GetActiveEffects(target)    │
                      │ + HasEffect(target, id)       │
                      │ + ClearEffects(target, type?) │
                      └───────────────┬───────────────┘
                                      │
                      ┌───────────────┴───────────────┐
                      │       BuffDebuffService        │
                      ├───────────────────────────────┤
                      │ - _effectProvider             │
                      │ - _statModifierService        │
                      │ - _eventBus                   │
                      │                               │
                      │ + ProcessStacking()           │
                      │ + ApplyStatModifiers()        │
                      │ + RemoveStatModifiers()       │
                      └───────────────────────────────┘
                               │           │
                               ▼           ▼
              ┌─────────────────────┐  ┌─────────────────────┐
              │ IStatusEffectProvider│  │ IStatModifierService│
              │   (get definitions)  │  │ (apply/remove mods) │
              └─────────────────────┘  └─────────────────────┘
```

---

## 4. ApplyResult Record

**File:** `src/Core/RuneAndRust.Application/DTOs/ApplyResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of attempting to apply a status effect.
/// </summary>
public record ApplyResult
{
    public bool WasApplied { get; init; }
    public ApplyResultType ResultType { get; init; }
    public string? Message { get; init; }
    public ActiveStatusEffect? ActiveEffect { get; init; }

    public static ApplyResult Success(ActiveStatusEffect effect)
        => new() { WasApplied = true, ResultType = ApplyResultType.Applied, ActiveEffect = effect };

    public static ApplyResult Refreshed(ActiveStatusEffect effect)
        => new() { WasApplied = true, ResultType = ApplyResultType.Refreshed, ActiveEffect = effect };

    public static ApplyResult Stacked(ActiveStatusEffect effect)
        => new() { WasApplied = true, ResultType = ApplyResultType.Stacked, ActiveEffect = effect };

    public static ApplyResult Replaced(ActiveStatusEffect effect)
        => new() { WasApplied = true, ResultType = ApplyResultType.Replaced, ActiveEffect = effect };

    public static ApplyResult AtMaxStacks(ActiveStatusEffect effect)
        => new() { WasApplied = true, ResultType = ApplyResultType.AtMaxStacks, ActiveEffect = effect,
            Message = "Effect is at maximum stacks, duration refreshed" };

    public static ApplyResult Failed(string reason)
        => new() { WasApplied = false, ResultType = ApplyResultType.Failed, Message = reason };

    public static ApplyResult Immune(string effectId)
        => new() { WasApplied = false, ResultType = ApplyResultType.Immune,
            Message = $"Target is immune to {effectId}" };
}

public enum ApplyResultType
{
    Applied,
    Refreshed,
    Stacked,
    Replaced,
    AtMaxStacks,
    Failed,
    Immune
}
```

---

## 5. IBuffDebuffService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IBuffDebuffService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing status effects on combat entities.
/// </summary>
public interface IBuffDebuffService
{
    /// <summary>Applies a status effect to a target.</summary>
    /// <param name="target">The entity to apply the effect to.</param>
    /// <param name="effectId">The effect definition ID.</param>
    /// <param name="source">The source entity applying the effect.</param>
    /// <returns>Result of the application attempt.</returns>
    ApplyResult ApplyEffect(ICombatant target, string effectId, ICombatant? source = null);

    /// <summary>Removes a specific effect from a target.</summary>
    /// <param name="target">The entity to remove the effect from.</param>
    /// <param name="effectId">The effect definition ID to remove.</param>
    /// <returns>True if the effect was removed.</returns>
    bool RemoveEffect(ICombatant target, string effectId);

    /// <summary>Removes all stacks of an effect from a target.</summary>
    bool RemoveAllStacks(ICombatant target, string effectId);

    /// <summary>Clears all effects of a given type from a target.</summary>
    /// <param name="target">The entity to clear effects from.</param>
    /// <param name="type">Optional type filter (null = all).</param>
    /// <returns>Number of effects removed.</returns>
    int ClearEffects(ICombatant target, EffectType? type = null);

    /// <summary>Clears all debuffs from a target.</summary>
    int ClearDebuffs(ICombatant target);

    /// <summary>Clears all buffs from a target.</summary>
    int ClearBuffs(ICombatant target);

    /// <summary>Gets all active effects on a target.</summary>
    IReadOnlyList<ActiveStatusEffect> GetActiveEffects(ICombatant target);

    /// <summary>Gets active effects of a specific type.</summary>
    IReadOnlyList<ActiveStatusEffect> GetActiveEffects(ICombatant target, EffectType type);

    /// <summary>Checks if a target has a specific effect.</summary>
    bool HasEffect(ICombatant target, string effectId);

    /// <summary>Gets the current stack count of an effect.</summary>
    int GetStackCount(ICombatant target, string effectId);

    /// <summary>Gets the remaining duration of an effect.</summary>
    int GetRemainingDuration(ICombatant target, string effectId);

    /// <summary>Gets all stat modifiers currently affecting a target.</summary>
    IReadOnlyList<StatModifier> GetAllActiveModifiers(ICombatant target);
}
```

---

## 6. IStatModifierService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IStatModifierService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for applying and removing stat modifiers from effects.
/// </summary>
public interface IStatModifierService
{
    /// <summary>Applies stat modifiers to a target.</summary>
    void ApplyModifiers(ICombatant target, IReadOnlyList<StatModifier> modifiers, int stacks);

    /// <summary>Removes stat modifiers from a target.</summary>
    void RemoveModifiers(ICombatant target, IReadOnlyList<StatModifier> modifiers, int stacks);

    /// <summary>Calculates the modified value of a stat.</summary>
    int CalculateModifiedStat(int baseValue, IEnumerable<StatModifier> modifiers, int stacks = 1);

    /// <summary>Gets the total modifier for a specific stat on a target.</summary>
    int GetTotalModifier(ICombatant target, string statId);
}
```

---

## 7. BuffDebuffService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/BuffDebuffService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class BuffDebuffService : IBuffDebuffService
{
    private readonly IStatusEffectProvider _effectProvider;
    private readonly IStatModifierService _statModifierService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<BuffDebuffService> _logger;

    public BuffDebuffService(
        IStatusEffectProvider effectProvider,
        IStatModifierService statModifierService,
        IEventBus eventBus,
        ILogger<BuffDebuffService> logger)
    {
        _effectProvider = effectProvider;
        _statModifierService = statModifierService;
        _eventBus = eventBus;
        _logger = logger;
    }

    public ApplyResult ApplyEffect(ICombatant target, string effectId, ICombatant? source = null)
    {
        var definition = _effectProvider.GetEffect(effectId);
        if (definition is null)
        {
            _logger.LogWarning("Effect not found: {EffectId}", effectId);
            return ApplyResult.Failed($"Effect '{effectId}' not found");
        }

        var existingEffect = target.ActiveEffects.FirstOrDefault(e => e.DefinitionId == effectId);

        if (existingEffect is not null)
        {
            return ProcessStacking(target, existingEffect, definition, source);
        }

        // Apply new effect
        var newEffect = ActiveStatusEffect.Create(definition, target.Id, source?.Id ?? Guid.Empty);
        target.AddStatusEffect(newEffect);

        // Apply stat modifiers
        if (definition.StatModifiers.Count > 0)
        {
            _statModifierService.ApplyModifiers(target, definition.StatModifiers, newEffect.CurrentStacks);
        }

        _logger.LogInformation("Applied {Effect} to {Target}", effectId, target.Name);
        _eventBus.Publish(new EffectAppliedEvent(target.Id, effectId, source?.Id));

        return ApplyResult.Success(newEffect);
    }

    private ApplyResult ProcessStacking(
        ICombatant target,
        ActiveStatusEffect existing,
        StatusEffectDefinition definition,
        ICombatant? source)
    {
        switch (definition.Stacking)
        {
            case StackingRule.None:
                // Refresh duration only
                existing.RefreshDuration(definition.BaseDuration);
                _logger.LogDebug("Refreshed {Effect} on {Target}", definition.EffectId, target.Name);
                return ApplyResult.Refreshed(existing);

            case StackingRule.Stack:
                if (existing.CurrentStacks < definition.MaxStacks)
                {
                    // Remove old modifiers, add stack, reapply
                    if (definition.StatModifiers.Count > 0)
                    {
                        _statModifierService.RemoveModifiers(target, definition.StatModifiers, existing.CurrentStacks);
                    }

                    existing.AddStacks(1, definition.MaxStacks);
                    existing.RefreshDuration(definition.BaseDuration);

                    if (definition.StatModifiers.Count > 0)
                    {
                        _statModifierService.ApplyModifiers(target, definition.StatModifiers, existing.CurrentStacks);
                    }

                    _logger.LogDebug("Stacked {Effect} on {Target} ({Stacks}/{Max})",
                        definition.EffectId, target.Name, existing.CurrentStacks, definition.MaxStacks);
                    _eventBus.Publish(new EffectStackedEvent(target.Id, definition.EffectId, existing.CurrentStacks));
                    return ApplyResult.Stacked(existing);
                }
                else
                {
                    // At max stacks, just refresh
                    existing.RefreshDuration(definition.BaseDuration);
                    return ApplyResult.AtMaxStacks(existing);
                }

            case StackingRule.Replace:
                // Remove old, apply new
                if (definition.StatModifiers.Count > 0)
                {
                    _statModifierService.RemoveModifiers(target, definition.StatModifiers, existing.CurrentStacks);
                }
                target.RemoveStatusEffect(existing);

                var newEffect = ActiveStatusEffect.Create(definition, target.Id, source?.Id ?? Guid.Empty);
                target.AddStatusEffect(newEffect);

                if (definition.StatModifiers.Count > 0)
                {
                    _statModifierService.ApplyModifiers(target, definition.StatModifiers, 1);
                }

                _logger.LogDebug("Replaced {Effect} on {Target}", definition.EffectId, target.Name);
                return ApplyResult.Replaced(newEffect);

            case StackingRule.Refresh:
                existing.RefreshDuration(definition.BaseDuration);
                return ApplyResult.Refreshed(existing);

            default:
                return ApplyResult.Failed("Unknown stacking rule");
        }
    }

    public bool RemoveEffect(ICombatant target, string effectId)
    {
        var effect = target.ActiveEffects.FirstOrDefault(e => e.DefinitionId == effectId);
        if (effect is null) return false;

        var definition = _effectProvider.GetEffect(effectId);
        if (definition?.StatModifiers.Count > 0)
        {
            _statModifierService.RemoveModifiers(target, definition.StatModifiers, effect.CurrentStacks);
        }

        target.RemoveStatusEffect(effect);
        _logger.LogInformation("Removed {Effect} from {Target}", effectId, target.Name);
        _eventBus.Publish(new EffectRemovedEvent(target.Id, effectId, EffectRemovalReason.Manual));

        return true;
    }

    public bool RemoveAllStacks(ICombatant target, string effectId)
    {
        return RemoveEffect(target, effectId);
    }

    public int ClearEffects(ICombatant target, EffectType? type = null)
    {
        var effectsToRemove = type.HasValue
            ? target.ActiveEffects.Where(e =>
            {
                var def = _effectProvider.GetEffect(e.DefinitionId);
                return def?.Type == type.Value;
            }).ToList()
            : target.ActiveEffects.ToList();

        foreach (var effect in effectsToRemove)
        {
            RemoveEffect(target, effect.DefinitionId);
        }

        return effectsToRemove.Count;
    }

    public int ClearDebuffs(ICombatant target)
    {
        var debuffs = target.ActiveEffects.Where(e =>
        {
            var def = _effectProvider.GetEffect(e.DefinitionId);
            return def is not null && !def.IsBuff;
        }).ToList();

        foreach (var debuff in debuffs)
        {
            RemoveEffect(target, debuff.DefinitionId);
        }

        _logger.LogDebug("Cleared {Count} debuffs from {Target}", debuffs.Count, target.Name);
        return debuffs.Count;
    }

    public int ClearBuffs(ICombatant target)
    {
        var buffs = target.ActiveEffects.Where(e =>
        {
            var def = _effectProvider.GetEffect(e.DefinitionId);
            return def?.IsBuff == true;
        }).ToList();

        foreach (var buff in buffs)
        {
            RemoveEffect(target, buff.DefinitionId);
        }

        _logger.LogDebug("Cleared {Count} buffs from {Target}", buffs.Count, target.Name);
        return buffs.Count;
    }

    public IReadOnlyList<ActiveStatusEffect> GetActiveEffects(ICombatant target)
        => target.ActiveEffects;

    public IReadOnlyList<ActiveStatusEffect> GetActiveEffects(ICombatant target, EffectType type)
        => target.ActiveEffects.Where(e =>
        {
            var def = _effectProvider.GetEffect(e.DefinitionId);
            return def?.Type == type;
        }).ToList();

    public bool HasEffect(ICombatant target, string effectId)
        => target.ActiveEffects.Any(e => e.DefinitionId == effectId);

    public int GetStackCount(ICombatant target, string effectId)
        => target.ActiveEffects.FirstOrDefault(e => e.DefinitionId == effectId)?.CurrentStacks ?? 0;

    public int GetRemainingDuration(ICombatant target, string effectId)
        => target.ActiveEffects.FirstOrDefault(e => e.DefinitionId == effectId)?.RemainingDuration ?? 0;

    public IReadOnlyList<StatModifier> GetAllActiveModifiers(ICombatant target)
    {
        var modifiers = new List<StatModifier>();
        foreach (var effect in target.ActiveEffects)
        {
            var def = _effectProvider.GetEffect(effect.DefinitionId);
            if (def?.StatModifiers.Count > 0)
            {
                modifiers.AddRange(def.StatModifiers);
            }
        }
        return modifiers;
    }
}
```

---

## 8. StatModifierService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/StatModifierService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class StatModifierService : IStatModifierService
{
    private readonly ILogger<StatModifierService> _logger;

    public StatModifierService(ILogger<StatModifierService> logger)
    {
        _logger = logger;
    }

    public void ApplyModifiers(ICombatant target, IReadOnlyList<StatModifier> modifiers, int stacks)
    {
        foreach (var modifier in modifiers)
        {
            var effectiveValue = modifier.GetEffectiveValue(stacks);
            target.ApplyStatModifier(modifier.StatId, modifier.Operation, effectiveValue);
            _logger.LogDebug("Applied {Modifier} to {Target} ({Stacks} stacks)",
                modifier, target.Name, stacks);
        }
    }

    public void RemoveModifiers(ICombatant target, IReadOnlyList<StatModifier> modifiers, int stacks)
    {
        foreach (var modifier in modifiers)
        {
            var effectiveValue = modifier.GetEffectiveValue(stacks);
            target.RemoveStatModifier(modifier.StatId, modifier.Operation, effectiveValue);
            _logger.LogDebug("Removed {Modifier} from {Target}", modifier, target.Name);
        }
    }

    public int CalculateModifiedStat(int baseValue, IEnumerable<StatModifier> modifiers, int stacks = 1)
    {
        int additive = 0;
        int multiplicative = 0; // Percentage

        foreach (var modifier in modifiers)
        {
            var effectiveValue = modifier.GetEffectiveValue(stacks);

            switch (modifier.Operation)
            {
                case ModifierOperation.Add:
                    additive += effectiveValue;
                    break;
                case ModifierOperation.Multiply:
                    multiplicative += effectiveValue;
                    break;
                case ModifierOperation.Set:
                    return effectiveValue; // Override
            }
        }

        // Apply additive first, then multiplicative
        var modified = baseValue + additive;
        if (multiplicative != 0)
        {
            modified = (int)(modified * (1 + multiplicative / 100.0));
        }

        return modified;
    }

    public int GetTotalModifier(ICombatant target, string statId)
    {
        // This would aggregate all active modifiers on target for a stat
        // Implementation depends on how modifiers are tracked on combatant
        return 0; // Placeholder
    }
}
```

---

## 9. ICombatant Extension

**Updates to:** `src/Core/RuneAndRust.Domain/Interfaces/ICombatant.cs`

```csharp
namespace RuneAndRust.Domain.Interfaces;

public interface ICombatant
{
    // ... existing members ...

    /// <summary>Gets active status effects on this combatant.</summary>
    IReadOnlyList<ActiveStatusEffect> ActiveEffects { get; }

    /// <summary>Adds a status effect.</summary>
    void AddStatusEffect(ActiveStatusEffect effect);

    /// <summary>Removes a status effect.</summary>
    void RemoveStatusEffect(ActiveStatusEffect effect);

    /// <summary>Applies a stat modifier.</summary>
    void ApplyStatModifier(string statId, ModifierOperation operation, int value);

    /// <summary>Removes a stat modifier.</summary>
    void RemoveStatModifier(string statId, ModifierOperation operation, int value);
}
```

---

## 10. Events

**File:** `src/Core/RuneAndRust.Application/Events/StatusEffectEvents.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>Published when a status effect is applied to a combatant.</summary>
public record EffectAppliedEvent(Guid TargetId, string EffectId, Guid? SourceId);

/// <summary>Published when a status effect is removed from a combatant.</summary>
public record EffectRemovedEvent(Guid TargetId, string EffectId, EffectRemovalReason Reason);

/// <summary>Published when a status effect's stack count changes.</summary>
public record EffectStackedEvent(Guid TargetId, string EffectId, int NewStackCount);

/// <summary>Published when a status effect's duration is refreshed.</summary>
public record EffectRefreshedEvent(Guid TargetId, string EffectId, int NewDuration);

/// <summary>Reason why an effect was removed.</summary>
public enum EffectRemovalReason
{
    Expired,
    Manual,
    Cleansed,
    Dispelled,
    Death,
    Replaced
}
```

---

## 11. Stacking Logic Visualization

```
STACKING RULES FLOW:
═══════════════════════════════════════════════════════════════════════

  ApplyEffect("poison") on target with existing poison
                │
                ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │  Check StackingRule                                             │
  ├─────────────────────────────────────────────────────────────────┤
  │                                                                 │
  │  StackingRule.None ────────────────▶  RefreshDuration()         │
  │     • Duration resets to BaseDuration                           │
  │     • Stacks unchanged (stays at 1)                             │
  │                                                                 │
  │  StackingRule.Stack ───────────────▶  AddStacks(1, MaxStacks)   │
  │     • If stacks < max: add 1 stack                              │
  │     • Recalculate stat modifiers                                │
  │     • Duration resets                                           │
  │     • If stacks = max: just refresh duration                    │
  │                                                                 │
  │  StackingRule.Replace ─────────────▶  Remove + Create New       │
  │     • Remove old effect entirely                                │
  │     • Apply fresh effect                                        │
  │     • No memory of previous stacks                              │
  │                                                                 │
  │  StackingRule.Refresh ─────────────▶  RefreshDuration()         │
  │     • Duration resets to BaseDuration                           │
  │     • Identical to None (semantic difference)                   │
  │                                                                 │
  └─────────────────────────────────────────────────────────────────┘


STAT MODIFIER APPLICATION:
═══════════════════════════════════════════════════════════════════════

  Example: "strength-up" with +2 STR per stack, 3 stacks

  Base Strength: 10
        │
        ▼
  Apply Modifiers (3 stacks):
  ├── StatModifier.Add("strength", 2, perStack: true)
  │   └── Effective Value = 2 * 3 = +6
        │
        ▼
  Modified Strength: 10 + 6 = 16
```

---

## 12. Unit Testing Requirements (~15 tests)

| Feature | Tests |
|---------|-------|
| ApplyEffect adds effect to target | 1 |
| ApplyEffect applies stat modifiers | 1 |
| ApplyEffect returns Success result | 1 |
| ProcessStacking None refreshes duration | 1 |
| ProcessStacking Stack adds stacks | 1 |
| ProcessStacking Stack at max refreshes only | 1 |
| ProcessStacking Replace removes and reapplies | 1 |
| RemoveEffect removes from target | 1 |
| RemoveEffect removes stat modifiers | 1 |
| ClearDebuffs removes only debuffs | 1 |
| ClearBuffs removes only buffs | 1 |
| HasEffect returns true when present | 1 |
| GetStackCount returns current stacks | 1 |
| GetRemainingDuration returns duration | 1 |
| Unknown effect returns Failed result | 1 |

---

## 13. Acceptance Criteria

- [ ] IBuffDebuffService interface defined
- [ ] BuffDebuffService implements all methods
- [ ] ApplyEffect adds new effect to target
- [ ] ApplyEffect applies stat modifiers
- [ ] StackingRule.None refreshes duration only
- [ ] StackingRule.Stack adds stacks up to max
- [ ] StackingRule.Replace removes and reapplies
- [ ] StackingRule.Refresh refreshes duration
- [ ] RemoveEffect removes effect from target
- [ ] RemoveEffect removes stat modifiers
- [ ] ClearEffects removes by type
- [ ] ClearDebuffs removes only debuffs
- [ ] ClearBuffs removes only buffs
- [ ] GetActiveEffects returns list
- [ ] HasEffect checks presence
- [ ] GetStackCount returns stacks
- [ ] GetRemainingDuration returns duration
- [ ] EffectAppliedEvent published on apply
- [ ] EffectRemovedEvent published on remove
- [ ] EffectStackedEvent published on stack
- [ ] ~15 unit tests pass

---

## 14. Dependencies

| From | Required |
|------|----------|
| v0.10.0a | `StatusEffectDefinition`, `ActiveStatusEffect`, `StatModifier`, enums |
| Application | `IStatusEffectProvider`, `IEventBus` |
| Domain | `ICombatant` interface |

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
