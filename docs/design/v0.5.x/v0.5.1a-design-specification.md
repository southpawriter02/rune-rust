# v0.5.1a Design Specification: Range Core

**Version:** 0.5.1a
**Phase Name:** Range Core
**Parent Version:** v0.5.1 (Range & Melee Combat)
**Prerequisites:** v0.5.0c Complete (Grid Display & Integration)
**Estimated Tests:** ~30 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [RangeType Enum](#4-rangetype-enum)
5. [Item Modifications](#5-item-modifications)
6. [AbilityDefinition Modifications](#6-abilitydefinition-modifications)
7. [RangeService](#7-rangeservice)
8. [Attack Command Integration](#8-attack-command-integration)
9. [User-Facing Commands](#9-user-facing-commands)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification establishes the foundational range system that leverages the combat grid from v0.5.0 to add tactical depth through positional combat. Weapons and abilities now have range properties that determine valid targets based on grid distance. Melee attacks require adjacency (distance 1), reach weapons extend to distance 2, and ranged attacks can reach further targets.

Key mechanics:
- **RangeType Classification**: Melee, Reach, Ranged categories
- **Melee Adjacency**: Must be adjacent (distance 1) to attack
- **Reach Weapons**: Can attack at distance 1 or 2 (spears, halberds)
- **Range Validation**: Attacks checked against weapon/ability range

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Enums** | `RangeType` |
| **Item Updates** | `Range`, `RangeType` properties |
| **AbilityDefinition Updates** | `Range`, `RangeType` properties |
| **Application Interfaces** | `IRangeService` |
| **Application Services** | `RangeService` |
| **Result Types** | `RangeCheckResult`, `RangeFailureReason` |
| **Command Updates** | Attack command range validation |
| **Configuration** | Updated items.json with ranges |
| **Tests** | ~30 unit tests |

### 1.3 Architectural Significance

This version establishes the **Range Combat Pattern**:

- **Range-Based Targeting**: Valid targets determined by distance
- **Range Type Classification**: Different validation rules per type
- **Weapon/Ability Properties**: Range is configurable per item/ability
- **Grid Integration**: Uses GridPosition.DistanceTo() for calculations
- **Extensible**: Foundation for min range, penalties, LOS in later phases

---

## 2. Feature Overview

```
v0.5.1a Range Core
├── RangeType Enum
│   ├── Melee (adjacent only, distance 1)
│   ├── Reach (distance 1-2)
│   └── Ranged (configurable max distance)
├── Item Modifications
│   ├── Range: int (default: 1)
│   ├── RangeType: RangeType (default: Melee)
│   ├── GetEffectiveRange(): int
│   └── IsInRange(distance): bool
├── AbilityDefinition Modifications
│   ├── Range: int (default: 1)
│   ├── RangeType: RangeType (default: Melee)
│   ├── GetEffectiveRange(): int
│   └── IsInRange(distance): bool
├── RangeService
│   ├── CheckRange(attacker, target, range, type)
│   ├── CheckAbilityRange(caster, target, ability)
│   ├── GetValidTargets(attacker, range, type)
│   ├── GetDistance(entity1, entity2)
│   ├── AreAdjacent(entity1, entity2)
│   ├── GetEffectiveRange(weapon)
│   └── GetEffectiveRange(ability)
└── Attack Command Integration
    ├── Range check before attack
    ├── Out-of-range message
    └── Valid targets display with distance
```

### 2.1 Scope Alignment

**In Scope:**
- `RangeType` enum (Melee, Ranged, Reach)
- `Item.Range` and `Item.RangeType` properties
- `AbilityDefinition.Range` and `RangeType` properties
- `IRangeService` interface
- `RangeService` for range calculations
- Melee adjacency validation (range 1)
- Reach validation (range 2)
- Range checking in attack command
- Valid target display based on range
- Range indicator in combat UI
- Update weapon definitions with range

**Out of Scope:**
- Minimum range (v0.5.1b)
- Range penalties (v0.5.1b)
- Ranged weapon items (v0.5.1b)
- Line of sight (v0.5.1c)

---

## 3. Architecture Diagrams

### 3.1 Range Type Validation

```
┌─────────────────────────────────────────────────────────────────────┐
│                      RANGE TYPE VALIDATION                          │
└─────────────────────────────────────────────────────────────────────┘

    MELEE (Range 1)                 REACH (Range 2)
    ┌───┬───┬───┐                   ┌───┬───┬───┬───┬───┐
    │   │ ✓ │   │                   │   │   │ ✓ │   │   │
    ├───┼───┼───┤                   ├───┼───┼───┼───┼───┤
    │ ✓ │ @ │ ✓ │                   │   │ ✓ │ ✓ │ ✓ │   │
    ├───┼───┼───┤                   ├───┼───┼───┼───┼───┤
    │   │ ✓ │   │                   │ ✓ │ ✓ │ @ │ ✓ │ ✓ │
    └───┴───┴───┘                   ├───┼───┼───┼───┼───┤
                                    │   │ ✓ │ ✓ │ ✓ │   │
    ✓ = Valid target (dist=1)       ├───┼───┼───┼───┼───┤
    @ = Attacker position           │   │   │ ✓ │   │   │
                                    └───┴───┴───┴───┴───┘

                                    ✓ = Valid target (dist≤2)
                                    @ = Attacker position

    RANGED (Range N)
    ┌───────────────────────────┐
    │  Distance-based validation │
    │  Valid if dist ≤ Range    │
    │                           │
    │  Example: Longbow Range 12│
    │  Valid targets: dist 1-12 │
    └───────────────────────────┘
```

### 3.2 Range Check Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                       RANGE CHECK FLOW                               │
└─────────────────────────────────────────────────────────────────────┘

    Attack Command
         │
         ▼
┌───────────────────┐
│  Get Active Grid  │──No──▶ Fail: NoActiveGrid
└────────┬──────────┘
         │Yes
         ▼
┌───────────────────┐
│ Get Attacker Pos  │──No──▶ Fail: AttackerNotOnGrid
└────────┬──────────┘
         │Yes
         ▼
┌───────────────────┐
│  Get Target Pos   │──No──▶ Fail: TargetNotOnGrid
└────────┬──────────┘
         │Yes
         ▼
┌───────────────────┐
│ Calculate Distance│
│ (Chebyshev)       │
└────────┬──────────┘
         │
         ▼
┌───────────────────┐
│ Check by RangeType│
├───────────────────┤
│ Melee: dist == 1  │
│ Reach: dist <= 2  │
│ Ranged: dist <= R │
└────────┬──────────┘
         │
    ┌────┴────┐
    │         │
   Yes        No
    │         │
    ▼         ▼
 Success   Failure
 (attack)  (message)
```

### 3.3 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  AttackCommand (Updated)                                             │
│  ├── Get equipped weapon or ability                                 │
│  ├── Call RangeService.CheckRange()                                 │
│  ├── If out of range: display message with distance                 │
│  └── If in range: proceed with attack                               │
├─────────────────────────────────────────────────────────────────────┤
│  TargetsCommand (New)                                                │
│  ├── Call RangeService.GetValidTargets()                            │
│  └── Display targets with distances                                 │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  IRangeService / RangeService                                        │
│  ├── CheckRange(attackerId, targetId, range, type): RangeCheckResult│
│  ├── CheckAbilityRange(casterId, targetId, ability): RangeCheckResult│
│  ├── GetValidTargets(attackerId, range, type): IEnumerable<Guid>    │
│  ├── GetDistance(entityId1, entityId2): int?                        │
│  ├── AreAdjacent(entityId1, entityId2): bool                        │
│  ├── GetEffectiveRange(weapon): int                                 │
│  └── GetEffectiveRange(ability): int                                │
├─────────────────────────────────────────────────────────────────────┤
│  RangeCheckResult                                                    │
│  ├── InRange: bool                                                  │
│  ├── Distance: int                                                  │
│  ├── WeaponRange: int                                               │
│  ├── RangeType: RangeType                                           │
│  ├── Message: string                                                │
│  └── FailureReason: RangeFailureReason?                             │
├─────────────────────────────────────────────────────────────────────┤
│  RangeFailureReason (Enum)                                           │
│  ├── NoActiveGrid                                                   │
│  ├── AttackerNotOnGrid                                              │
│  ├── TargetNotOnGrid                                                │
│  ├── OutOfRange                                                     │
│  ├── TooClose (for v0.5.1b)                                         │
│  ├── NotAdjacent                                                    │
│  └── NoLineOfSight (for v0.5.1c)                                    │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         DOMAIN LAYER                                 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌────────────────────┐  ┌──────────────────────────────────────┐  │
│  │    RangeType       │  │       Item (Modified)                │  │
│  │      (Enum)        │  │                                      │  │
│  ├────────────────────┤  ├──────────────────────────────────────┤  │
│  │ Melee    = 0       │  │ + Range: int (default: 1)            │  │
│  │ Reach    = 1       │  │ + RangeType: RangeType (Melee)       │  │
│  │ Ranged   = 2       │  │ + GetEffectiveRange(): int           │  │
│  └────────────────────┘  │ + IsInRange(distance): bool          │  │
│                          └──────────────────────────────────────┘  │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │              AbilityDefinition (Modified)                    │  │
│  ├──────────────────────────────────────────────────────────────┤  │
│  │ + Range: int (default: 1)                                    │  │
│  │ + RangeType: RangeType (default: Melee)                      │  │
│  │ + GetEffectiveRange(): int                                   │  │
│  │ + IsInRange(distance): bool                                  │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. RangeType Enum

### 4.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/RangeType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of attack range for weapons and abilities.
/// </summary>
public enum RangeType
{
    /// <summary>Melee range - must be adjacent (distance 1).</summary>
    Melee = 0,

    /// <summary>Reach range - can attack at distance 1 or 2.</summary>
    Reach = 1,

    /// <summary>Ranged - can attack at configurable distance.</summary>
    Ranged = 2
}
```

### 4.2 Range Type Comparison

| Type | Valid Distance | Examples | Validation |
|------|----------------|----------|------------|
| Melee | 1 only | Sword, Axe, Dagger | `distance == 1` |
| Reach | 1-2 | Spear, Halberd, Pike | `distance <= 2` |
| Ranged | 1-N | Bow, Crossbow, Spell | `distance <= Range` |

---

## 5. Item Modifications

**File:** `src/Core/RuneAndRust.Domain/Entities/Item.cs`

```csharp
// Add to Item entity:

#region Range Properties

/// <summary>Gets the attack range of this weapon.</summary>
public int Range { get; private set; } = 1;

/// <summary>Gets the range type of this weapon.</summary>
public RangeType RangeType { get; private set; } = RangeType.Melee;

/// <summary>Sets the range properties from definition.</summary>
public void SetRange(int range, RangeType rangeType)
{
    ArgumentOutOfRangeException.ThrowIfLessThan(range, 1);
    Range = range;
    RangeType = rangeType;
}

/// <summary>Gets the effective range based on range type.</summary>
public int GetEffectiveRange() => RangeType switch
{
    RangeType.Melee => 1,
    RangeType.Reach => 2,
    RangeType.Ranged => Range,
    _ => 1
};

/// <summary>Checks if a target at the given distance is in range.</summary>
public bool IsInRange(int distance) => RangeType switch
{
    RangeType.Melee => distance == 1,
    RangeType.Reach => distance >= 1 && distance <= 2,
    RangeType.Ranged => distance >= 1 && distance <= Range,
    _ => distance == 1
};

#endregion
```

**ItemDefinition Updates:**

```csharp
// Add to ItemDefinition:
public int Range { get; private set; } = 1;
public RangeType RangeType { get; private set; } = RangeType.Melee;
```

---

## 6. AbilityDefinition Modifications

**File:** `src/Core/RuneAndRust.Domain/Definitions/AbilityDefinition.cs`

```csharp
// Add to AbilityDefinition:

#region Range Properties

/// <summary>Gets the range of this ability.</summary>
public int Range { get; private set; } = 1;

/// <summary>Gets the range type of this ability.</summary>
public RangeType RangeType { get; private set; } = RangeType.Melee;

/// <summary>Gets the effective range based on range type.</summary>
public int GetEffectiveRange() => RangeType switch
{
    RangeType.Melee => 1,
    RangeType.Reach => 2,
    RangeType.Ranged => Range,
    _ => 1
};

/// <summary>Checks if a target at the given distance is in range.</summary>
public bool IsInRange(int distance) => RangeType switch
{
    RangeType.Melee => distance == 1,
    RangeType.Reach => distance >= 1 && distance <= 2,
    RangeType.Ranged => distance >= 1 && distance <= Range,
    _ => distance == 1
};

#endregion
```

---

## 7. RangeService

### 7.1 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IRangeService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

public interface IRangeService
{
    RangeCheckResult CheckRange(Guid attackerId, Guid targetId, int weaponRange, RangeType rangeType);
    RangeCheckResult CheckAbilityRange(Guid casterId, Guid targetId, AbilityDefinition ability);
    IEnumerable<Guid> GetValidTargets(Guid attackerId, int range, RangeType rangeType);
    int? GetDistance(Guid entityId1, Guid entityId2);
    bool AreAdjacent(Guid entityId1, Guid entityId2);
    int GetEffectiveRange(Item weapon);
    int GetEffectiveRange(AbilityDefinition ability);
}

public readonly record struct RangeCheckResult(
    bool InRange, int Distance, int WeaponRange, RangeType RangeType,
    string Message, RangeFailureReason? FailureReason);

public enum RangeFailureReason
{
    NoActiveGrid,
    AttackerNotOnGrid,
    TargetNotOnGrid,
    OutOfRange,
    TooClose,
    NotAdjacent,
    NoLineOfSight
}
```

### 7.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/RangeService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class RangeService : IRangeService
{
    private readonly ICombatGridService _gridService;
    private readonly ILogger<RangeService> _logger;

    public RangeService(ICombatGridService gridService, ILogger<RangeService> logger)
    {
        _gridService = gridService;
        _logger = logger;
    }

    public RangeCheckResult CheckRange(
        Guid attackerId, Guid targetId, int weaponRange, RangeType rangeType)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            return Fail(RangeFailureReason.NoActiveGrid, "No active combat grid.");

        var attackerPos = grid.GetEntityPosition(attackerId);
        if (!attackerPos.HasValue)
            return Fail(RangeFailureReason.AttackerNotOnGrid, "Attacker is not on the grid.");

        var targetPos = grid.GetEntityPosition(targetId);
        if (!targetPos.HasValue)
            return Fail(RangeFailureReason.TargetNotOnGrid, "Target is not on the grid.");

        var distance = attackerPos.Value.DistanceTo(targetPos.Value);

        var inRange = rangeType switch
        {
            RangeType.Melee => distance == 1,
            RangeType.Reach => distance <= 2,
            RangeType.Ranged => distance <= weaponRange,
            _ => distance <= weaponRange
        };

        if (!inRange)
        {
            var reason = rangeType == RangeType.Melee
                ? RangeFailureReason.NotAdjacent
                : RangeFailureReason.OutOfRange;

            var msg = rangeType == RangeType.Melee
                ? $"Target is not adjacent (distance: {distance})."
                : $"Target is out of range (distance: {distance}, range: {weaponRange}).";

            _logger.LogDebug("Range check failed: {Reason}", msg);
            return new RangeCheckResult(false, distance, weaponRange, rangeType, msg, reason);
        }

        _logger.LogDebug("Range check passed: dist {Dist}, range {Range}, type {Type}",
            distance, weaponRange, rangeType);

        return new RangeCheckResult(true, distance, weaponRange, rangeType,
            "Target is in range.", null);
    }

    public RangeCheckResult CheckAbilityRange(
        Guid casterId, Guid targetId, AbilityDefinition ability) =>
        CheckRange(casterId, targetId, ability.Range, ability.RangeType);

    public IEnumerable<Guid> GetValidTargets(
        Guid attackerId, int range, RangeType rangeType)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) yield break;

        var attackerPos = grid.GetEntityPosition(attackerId);
        if (!attackerPos.HasValue) yield break;

        var effectiveRange = rangeType switch
        {
            RangeType.Melee => 1,
            RangeType.Reach => 2,
            RangeType.Ranged => range,
            _ => range
        };

        foreach (var entityId in grid.GetEntitiesInRange(attackerPos.Value, effectiveRange))
        {
            if (entityId == attackerId) continue;

            if (rangeType == RangeType.Melee)
            {
                if (grid.AreAdjacent(attackerId, entityId))
                    yield return entityId;
            }
            else
            {
                yield return entityId;
            }
        }
    }

    public int? GetDistance(Guid entityId1, Guid entityId2) =>
        _gridService.GetDistance(entityId1, entityId2);

    public bool AreAdjacent(Guid entityId1, Guid entityId2) =>
        _gridService.AreAdjacent(entityId1, entityId2);

    public int GetEffectiveRange(Item weapon) => weapon.GetEffectiveRange();
    public int GetEffectiveRange(AbilityDefinition ability) => ability.GetEffectiveRange();

    private static RangeCheckResult Fail(RangeFailureReason reason, string message) =>
        new(false, 0, 0, RangeType.Melee, message, reason);
}
```

---

## 8. Attack Command Integration

### 8.1 Updated Attack Flow

```csharp
// In AttackCommand handler:

public CommandResult Execute(Player player, string targetName)
{
    var weapon = player.EquippedWeapon;
    if (weapon == null)
        return CommandResult.Failure("You have no weapon equipped.");

    var target = FindTarget(targetName);
    if (target == null)
        return CommandResult.Failure($"No target named '{targetName}' found.");

    // Range check
    var rangeCheck = _rangeService.CheckRange(
        player.Id, target.Id, weapon.Range, weapon.RangeType);

    if (!rangeCheck.InRange)
    {
        var message = weapon.RangeType == RangeType.Melee
            ? $"You can't attack {target.Name} - it's not adjacent!\n\n" +
              $"[Distance: {rangeCheck.Distance} cells]\n" +
              $"[{weapon.Name} requires melee range (adjacent)]\n\n" +
              "Consider moving closer or using a ranged weapon."
            : $"You can't attack {target.Name} - it's out of range!\n\n" +
              $"[Distance: {rangeCheck.Distance} cells]\n" +
              $"[{weapon.Name} range: {weapon.Range} cells]\n\n" +
              "Move closer to attack.";

        return CommandResult.Failure(message);
    }

    // Proceed with attack...
    return ProcessAttack(player, target, weapon, rangeCheck.Distance);
}
```

---

## 9. User-Facing Commands

### 9.1 Melee Attack (In Range)

```
> attack skeleton

You swing your Iron Sword at the Skeleton at C2...

[Melee attack - adjacent target]
[Attack Roll: 2d6 + 3 = 14 vs AC 12]
Hit! 8 damage to Skeleton.
```

### 9.2 Melee Attack (Out of Range)

```
> attack skeleton

You can't attack the Skeleton - it's not adjacent!

[Distance: 3 cells]
[Iron Sword requires melee range (adjacent)]

Consider moving closer or using a ranged weapon.
```

### 9.3 Reach Attack

```
> attack goblin

You thrust your Spear at the Goblin at E3...

[Reach attack - distance: 2 cells]
[Attack Roll: 2d6 + 2 = 11 vs AC 11]
Hit! 6 damage to Goblin.
```

### 9.4 Valid Targets Display

```
> targets

Valid Targets (Iron Sword - Melee):
  • Skeleton at C3 [Adjacent]
  • Goblin at D3 [Adjacent]

Out of Range:
  • Skeleton Archer at F2 [3 cells away]
```

### 9.5 Grid with Melee Range

```
  A B C D E F G H
1 . . . . . . . .
2 . . M . . M . .       @ = You (D4)
3 . . * * * . . .       M = Monster
4 . . * @ * . . .       * = Melee range
5 . . * * * . . .       . = Empty

You (D4) | HP: 25/30 | Weapon: Iron Sword (Melee)
```

---

## 10. Data Model Changes

| Type | Layer | Description |
|------|-------|-------------|
| `RangeType` | Domain/Enums | Melee, Reach, Ranged |
| `Item` | Domain/Entities | Add Range, RangeType |
| `ItemDefinition` | Domain/Definitions | Add Range, RangeType |
| `AbilityDefinition` | Domain/Definitions | Add Range, RangeType |
| `IRangeService` | Application/Interfaces | Range service interface |
| `RangeService` | Application/Services | Range validation |
| `RangeCheckResult` | Application/DTOs | Check result |
| `RangeFailureReason` | Application/Enums | Failure reasons |

---

## 11. Configuration File Schemas

**Update `config/items.json`:**

```json
{
  "$schema": "./schemas/items.schema.json",
  "items": [
    {
      "id": "iron-sword",
      "name": "Iron Sword",
      "type": "Weapon",
      "subType": "Sword",
      "damage": "1d8",
      "range": 1,
      "rangeType": "Melee"
    },
    {
      "id": "spear",
      "name": "Spear",
      "type": "Weapon",
      "subType": "Polearm",
      "damage": "1d6",
      "range": 2,
      "rangeType": "Reach"
    },
    {
      "id": "halberd",
      "name": "Halberd",
      "type": "Weapon",
      "subType": "Polearm",
      "damage": "1d10",
      "range": 2,
      "rangeType": "Reach"
    },
    {
      "id": "dagger",
      "name": "Dagger",
      "type": "Weapon",
      "subType": "Dagger",
      "damage": "1d4",
      "range": 1,
      "rangeType": "Melee"
    }
  ]
}
```

---

## 12. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `RangeService` | Debug | Range checks, validation results |
| `RangeService` | Information | Valid target queries |
| `AttackCommand` | Debug | Range validation in attack flow |

---

## 13. Unit Testing Requirements

| Feature | Test Count |
|---------|------------|
| RangeType Enum | ~2 |
| Item Range Properties | ~5 |
| AbilityDefinition Range Properties | ~4 |
| RangeService.CheckRange | ~10 |
| RangeService.GetValidTargets | ~5 |
| RangeService Helpers | ~4 |
| **Total** | **~30** |

---

## 14. Use Cases

### UC-001: Melee Attack Adjacent
**Flow:** Player adjacent to target → CheckRange → InRange=true → Attack proceeds

### UC-002: Melee Attack Not Adjacent
**Flow:** Player 3 cells away → CheckRange → InRange=false → Display distance message

### UC-003: Reach Attack
**Flow:** Player 2 cells away with spear → CheckRange → InRange=true → Attack proceeds

### UC-004: Get Valid Targets
**Flow:** Player has sword → GetValidTargets → Returns adjacent monsters only

### UC-005: Ability Range Check
**Flow:** Cast ability → CheckAbilityRange → Validate against ability.Range

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `RangeType` enum
- [ ] Item Range properties
- [ ] AbilityDefinition Range properties

### Application Layer
- [ ] `IRangeService` interface
- [ ] `RangeService` implementation
- [ ] `RangeCheckResult` record
- [ ] `RangeFailureReason` enum

### Presentation Layer
- [ ] Updated Attack command range validation
- [ ] `targets` command
- [ ] Range display in combat UI

### Configuration
- [ ] Updated items.json with ranges
- [ ] Schema updates

### Testing
- [ ] ~30 unit tests
- [ ] All tests passing

---

## 16. Acceptance Criteria

### Functional
- [ ] RangeType enum has Melee, Reach, Ranged values
- [ ] Item.Range stores weapon range correctly
- [ ] Item.RangeType stores range type correctly
- [ ] AbilityDefinition.Range stores ability range
- [ ] Melee attacks require adjacency (distance 1)
- [ ] Reach attacks work at distance 1 or 2
- [ ] RangeService validates attack range correctly
- [ ] Attack command checks range before attacking
- [ ] Out-of-range attacks display helpful message
- [ ] Valid targets command shows range information
- [ ] Grid display can show melee range indicator
- [ ] Existing melee weapons updated with Range=1

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~30 unit tests pass
- [ ] XML documentation complete

---

## 17. Dependencies

### Required from v0.5.0

| Type | Usage |
|------|-------|
| `CombatGrid` | Entity positions |
| `GridPosition.DistanceTo()` | Distance calculation |
| `CombatGrid.AreAdjacent()` | Adjacency check |
| `CombatGrid.GetEntitiesInRange()` | Valid targets |
| `ICombatGridService` | Grid access |

### Provides to v0.5.1b
- Range properties for min range extension
- RangeService for penalty calculations

### Provides to v0.5.1c
- Range validation foundation for LOS checks

---

## 18. Future Considerations

### Deferred to v0.5.1b
- Minimum range (bows can't shoot adjacent enemies)
- Range penalties (accuracy at distance)
- Ranged weapon definitions
- Thrown weapons

### Deferred to v0.5.1c
- Line of sight validation
- Blocking cells
- LOS in attack flow

### Out of Scope for v0.5.1
- Cover affecting attacks
- Flanking bonuses
- Opportunity attacks

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: AI Assistant*
