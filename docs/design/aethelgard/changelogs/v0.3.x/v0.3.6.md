# Changelog: v0.3.6 - The Battlefield, Timeline & Telegraph (Combat Tactical Systems)

**Versions:** v0.3.6a through v0.3.6c
**Release Dates:** December 21-22, 2025

## Table of Contents

- [Overview](#overview)
- [Part A: The Battlefield (Grid & Rows)](#part-a-the-battlefield-grid--rows)
  - [Summary](#summary)
  - [New Features](#new-features)
  - [New Files](#new-files)
  - [Modified Files](#modified-files)
  - [Implementation Details](#implementation-details)
  - [Test Coverage](#test-coverage)
  - [Logging Matrix](#logging-matrix)
  - [Breaking Changes](#breaking-changes)
  - [Known Limitations](#known-limitations)
  - [Architecture Notes](#architecture-notes)
  - [Version History](#version-history)
  - [Next Steps (v0.3.6b/c Candidates)](#next-steps-v036bc-candidates)
- [Part B: The Timeline (Initiative & Log)](#part-b-the-timeline-initiative--log)
  - [Summary](#summary-1)
  - [New Files Created](#new-files-created)
  - [Files Modified](#files-modified)
  - [Code Implementation Details](#code-implementation-details)
  - [Logging Matrix](#logging-matrix-1)
  - [Test Coverage](#test-coverage-1)
  - [DI Registration](#di-registration)
  - [Verification Results](#verification-results)
  - [Directory Structure After Release](#directory-structure-after-release)
  - [Running Tests](#running-tests)
  - [Next Steps](#next-steps)
- [Part C: The Telegraph (Intent & Status)](#part-c-the-telegraph-intent--status)
  - [Summary](#summary-2)
  - [New Files Created](#new-files-created-1)
  - [Files Modified](#files-modified-1)
  - [Code Implementation Details](#code-implementation-details-1)
  - [Logging Matrix](#logging-matrix-2)
  - [Test Coverage](#test-coverage-2)
  - [DI Registration](#di-registration-1)
  - [Verification Results](#verification-results-1)
  - [Directory Structure After Release](#directory-structure-after-release-1)
  - [Running Tests](#running-tests-1)
  - [Next Steps](#next-steps-1)

---

## Overview

Version 0.3.6 represents a comprehensive overhaul of combat visualization and tactical intelligence systems across three integrated releases. This version transforms combat from a linear turn-based system into a spatially-aware tactical battlefield with strategic depth through row positioning, initiative timeline visualization, and enemy intent telegraphing.

**v0.3.6a - The Battlefield** introduces the row positioning system (Front/Back rows) with archetype-based assignment and melee targeting validation, adding spatial tactics to combat encounters.

**v0.3.6b - The Timeline** replaces vertical turn order tables with horizontal initiative timelines showing 8-slot projections across current and next rounds, while introducing rich-text combat log formatting with damage-type-specific coloring through the new CombatLogFormatter service.

**v0.3.6c - The Telegraph** implements the Intent System, providing WITS-based perception checks to reveal enemy planned actions (Attack/Defend/Flee/Pass) with Adept archetype bonuses and the Analyzed debuff for guaranteed visibility.

Together, these releases touch all major layers: Core (Models, ViewModels, Enums), Engine (Services, AI), Terminal (Rendering), and Tests, with 112 new tests bringing total project coverage to 2,161 passing tests.

---

## Part A: The Battlefield (Grid & Rows)

**Release Date:** 2025-12-21
**Codename:** The Battlefield
**Status:** Complete

---

## Summary

Version 0.3.6a introduces a tactical row system for combat. Combatants are now positioned in Front or Back rows based on their archetype, transforming combat from a flat turn order list into a spatial tactical grid. Melee attackers can only target the opposing Front Row unless it's empty or they have the [Reach] weapon property.

---

## New Features

### 1. Row Position System

**Core Concept:** Combat now has spatial positioning with Front and Back rows for both player and enemy teams.

**Row Assignment by Archetype:**

| Player Archetype | Default Row | Rationale |
|------------------|-------------|-----------|
| Warrior | Front | Frontline combatant, melee-focused |
| Skirmisher | Front | Fast fighter, melee-focused |
| Adept | Back | Runic caster, needs protection |
| Mystic | Back | Primal caster, needs protection |

| Enemy Archetype | Default Row | Rationale |
|-----------------|-------------|-----------|
| Tank | Front | Protects allies, absorbs hits |
| DPS | Front | Balanced, reliable damage |
| GlassCannon | Front | High damage melee |
| Support | Back | Buffs/debuffs from safety |
| Swarm | Back | Group tactics, avoid direct hits |
| Caster | Back | Ranged attacks from distance |
| Boss | Back | Special encounters, protected |

### 2. Melee Targeting Validation

**Targeting Rules:**
- Front Row targets are **always valid** for melee attacks
- Back Row targets are **protected** unless:
  - Opposing Front Row is empty (all Front Row enemies dead)
  - Attacker has [Reach] weapon property
- Allies are always valid targets (for healing/buffs)

**Example Error Message:**
```
Blight-Priest is protected by the front line. Target a front row enemy first.
```

### 3. Tactical Combat Grid

The combat UI now displays a battlefield grid showing team formations:

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê BATTLEFIELD ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                            ‚ïë
‚ïë   ‚îÄ‚îÄ ENEMY BACK ‚îÄ‚îÄ                                         ‚ïë
‚ïë       Blight-Priest  Rust-Witch                            ‚ïë
‚ïë                                                            ‚ïë
‚ïë   ‚îÄ‚îÄ ENEMY FRONT ‚îÄ‚îÄ                                        ‚ïë
‚ïë      >Rusted Draugr!!  Haugbui Laborer                     ‚ïë
‚ïë                                                            ‚ïë
‚ïë   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚ïë
‚ïë                                                            ‚ïë
‚ïë   ‚îÄ‚îÄ FRONT LINE ‚îÄ‚îÄ                                         ‚ïë
‚ïë       Kael                                                 ‚ïë
‚ïë                                                            ‚ïë
‚ïë   ‚îÄ‚îÄ BACK LINE ‚îÄ‚îÄ                                          ‚ïë
‚ïë       (empty)                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

**Grid Indicators:**
- `>` marker indicates the active combatant
- `!!` indicates wounded enemy (25-75% HP)
- `!!!` indicates critical enemy (<25% HP)
- `*` indicates targeted combatant

---

## New Files

| File | Layer | Purpose |
|------|-------|---------|
| `RuneAndRust.Core/Enums/RowPosition.cs` | Core | Front/Back row position enum |
| `RuneAndRust.Terminal/Rendering/CombatGridRenderer.cs` | Terminal | Tactical grid display renderer |
| `RuneAndRust.Tests/Engine/RowAssignmentTests.cs` | Tests | Row assignment and targeting tests |
| `RuneAndRust.Tests/Terminal/CombatGridRendererTests.cs` | Tests | Grid rendering tests |

---

## Modified Files

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added `Row` and `IsTargeted` properties |
| `RuneAndRust.Core/ViewModels/CombatViewModel.cs` | Added row-grouped lists, `Row` to CombatantView |
| `RuneAndRust.Engine/Services/CombatService.cs` | Row assignment, targeting validation, ViewModel grouping |
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | Integrated CombatGridRenderer |
| `RuneAndRust.Terminal/Program.cs` | Version updated to v0.3.6a |

---

## Implementation Details

### RowPosition Enum

```csharp
public enum RowPosition
{
    Front = 0,  // Melee combatants, can be targeted
    Back = 1    // Protected unless Front is empty
}
```

### Combatant Properties (v0.3.6a)

```csharp
#region Row System (v0.3.6a)

/// <summary>
/// The combatant's row position on the battlefield.
/// </summary>
public RowPosition Row { get; set; } = RowPosition.Front;

/// <summary>
/// Whether this combatant is currently being targeted.
/// </summary>
public bool IsTargeted { get; set; } = false;

#endregion
```

### Row Assignment Methods

```csharp
public static RowPosition GetDefaultPlayerRow(ArchetypeType archetype) => archetype switch
{
    ArchetypeType.Warrior => RowPosition.Front,
    ArchetypeType.Skirmisher => RowPosition.Front,
    ArchetypeType.Adept => RowPosition.Back,
    ArchetypeType.Mystic => RowPosition.Back,
    _ => RowPosition.Front
};

public static RowPosition GetDefaultEnemyRow(EnemyArchetype archetype) => archetype switch
{
    EnemyArchetype.Tank => RowPosition.Front,
    EnemyArchetype.DPS => RowPosition.Front,
    EnemyArchetype.GlassCannon => RowPosition.Front,
    EnemyArchetype.Support => RowPosition.Back,
    EnemyArchetype.Swarm => RowPosition.Back,
    EnemyArchetype.Caster => RowPosition.Back,
    EnemyArchetype.Boss => RowPosition.Back,
    _ => RowPosition.Front
};
```

### IsValidMeleeTarget Logic

```csharp
public bool IsValidMeleeTarget(Combatant attacker, Combatant target, bool hasReach = false)
{
    // Allies always valid (healing/buffs)
    if (attacker.IsPlayer == target.IsPlayer) return true;

    // Front Row always valid
    if (target.Row == RowPosition.Front) return true;

    // Back Row valid with Reach
    if (hasReach) return true;

    // Back Row valid if opposing Front Row is empty
    var opposingFrontEmpty = !state.TurnOrder.Any(c =>
        c.IsPlayer != attacker.IsPlayer &&
        c.Row == RowPosition.Front &&
        c.CurrentHp > 0);

    return opposingFrontEmpty;
}
```

---

## Test Coverage

**New Tests: 32**
- Row Assignment Tests: 21
- Combat Grid Renderer Tests: 11

**Test Categories:**

| Category | Tests |
|----------|-------|
| Player Row Assignment | 4 |
| Enemy Row Assignment | 7 |
| Melee Targeting Validation | 6 |
| Combat Integration | 4 |
| Grid Render Tests | 3 |
| Format Combatant Tests | 8 |

**Total Tests After v0.3.6a: 2078**

---

## Logging Matrix

| Context | Level | Template |
|---------|-------|----------|
| Player Row Assignment | Debug | `"Added player {Name} to combat with {AbilityCount} abilities, Row: {Row}"` |
| Enemy Row Assignment | Debug | `"Added enemy {Name} to combat, Row: {Row}"` |
| Targeting Blocked | Debug | `"{Target} is in Back Row and protected by Front Row"` |

---

## Breaking Changes

None. All changes are backwards compatible. Row defaults to `Front` if not explicitly set.

---

## Known Limitations

1. **No Row Swapping:** Combatants cannot currently change rows during combat (future v0.3.6c candidate)
2. **Reach Weapons:** The `hasReach` parameter is a placeholder; weapon properties not yet implemented
3. **Single Player:** Row system assumes single player character; party support may require expansion

---

## Architecture Notes

- `Row` is a combat-volatile property: not persisted to database, assigned fresh at combat start
- `CombatGridRenderer` is a stateless static class (no DI registration required)
- Turn Order table retained alongside grid for initiative reference
- ViewModel grouping performs row filtering in GetViewModel for UI simplicity

---

## Version History

| Version | Codename | Focus |
|---------|----------|-------|
| v0.3.5a | The Cartographer's Easel | ExplorationScreenRenderer foundation |
| v0.3.5b | The Cartographer | MinimapRenderer with Fog of War |
| v0.3.5c | The Surveyor | RoomRenderer with entity display |
| v0.3.5d | The Stabilizer | Bug fixes and polish |
| v0.3.6a | The Battlefield | Grid & Row system |

---

## Next Steps (v0.3.6b/c Candidates)

1. **Combat Action Bar** - Display available commands at the bottom of combat screen
2. **Enhanced Enemy AI** - AI considers row positions when selecting targets
3. **Row Swap Ability** - Allow tactical repositioning during combat
4. **Reach Weapons** - Implement weapon property for ignoring row protection

---

## Part B: The Timeline (Initiative & Log)

**Release Date:** 2025-12-22

---

## Summary

Version 0.3.6b replaces the vertical turn order table with a horizontal initiative timeline and introduces rich-text combat log formatting with damage type coloring. This release enhances combat visibility by showing projected turns across the current round and next round preview in an 8-slot horizontal window, while the new `CombatLogFormatter` service centralizes all combat event formatting with Spectre.Console markup, providing visual distinction for 8 damage types and critical hits.

This release touches the **Core Layer** (ViewModels, Models), **Engine Layer** (Services), **Terminal Layer** (Rendering), and **Test Layer** with comprehensive test coverage. Key patterns introduced include static utility classes for stateless formatting operations and record types for immutable timeline projections.

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/ViewModels/TimelineEntryView.cs` | Immutable record representing a single entry in the initiative timeline with combatant ID, name, player status, active marker, initiative value, round number, and health indicator |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/CombatLogFormatter.cs` | Static formatter class providing rich Spectre.Console markup for combat events including hit/miss messages, status effects, deaths, and combat flow with damage type coloring |

### Terminal Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Terminal/Rendering/TimelineRenderer.cs` | Static renderer class generating horizontal initiative timeline panels with round markers, combatant names, health indicators, and initiative values in a grid layout |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/TimelineProjectionTests.cs` | 10 unit tests validating timeline projection generation, window sizing, round transitions, dead combatant filtering, and health indicator mapping |
| `RuneAndRust.Tests/Engine/CombatLogFormatterTests.cs` | 23 unit tests validating damage type color mapping, message formatting, markup escaping, and critical hit display |
| `RuneAndRust.Tests/Terminal/TimelineRendererTests.cs` | 15 unit tests validating panel rendering, entry formatting, health status icons, name truncation, and markup escaping |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/Combat/AttackResult.cs` | Added `DamageType` property with default value `DamageType.Physical` to track damage type for combat log coloring |
| `RuneAndRust.Core/ViewModels/CombatViewModel.cs` | Added `TimelineProjection` property of type `List<TimelineEntryView>?` to transport timeline data to UI layer |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `GetTimelineProjection(int windowSize = 8)` method and `MapToTimelineEntry()` helper to generate timeline projections with current round remaining turns plus next round preview |
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | Replaced `RenderTurnOrder()` call with `TimelineRenderer.Render()` to display horizontal timeline instead of vertical turn order table |
| `RuneAndRust.Terminal/Program.cs` | Updated version string from v0.3.6a to v0.3.6b |

---

## Code Implementation Details

### TimelineEntryView (Core/ViewModels)

**Record Definition:**
```csharp
public record TimelineEntryView(
    Guid CombatantId,
    string Name,
    bool IsPlayer,
    bool IsActive,
    int Initiative,
    int RoundNumber,
    string HealthIndicator
);
```

**Properties:**
- `CombatantId` - Unique identifier for combatant lookup
- `Name` - Display name for timeline rendering
- `IsPlayer` - Determines color coding (cyan for players, red for enemies)
- `IsActive` - Marks the currently acting combatant with `‚ñ∫` indicator
- `Initiative` - Numerical value displayed below combatant name
- `RoundNumber` - Used to show round transition markers (R1, R2, etc.)
- `HealthIndicator` - One of "healthy", "wounded", "critical", or "dead" for status icons

**Immutability:** Record type ensures timeline snapshots cannot be mutated after creation.

---

### CombatLogFormatter (Engine/Services)

**Class Signature:**
```csharp
public static class CombatLogFormatter
```

**Stateless Design:** Static class with no DI registration required. All methods are pure functions.

**Key Methods:**

**Damage Type Color Mapping:**
```csharp
public static string GetDamageColor(DamageType type)
```
- Returns Spectre.Console color names for damage visualization
- Switch expression with exhaustive pattern matching
- Default case returns "white" for unknown types

**Color Mappings:**
| Damage Type | Color | Spectre Name |
|-------------|-------|--------------|
| Physical | White | `"white"` |
| Fire | Orange | `"orange1"` |
| Ice | Cyan | `"cyan1"` |
| Lightning | Yellow | `"yellow"` |
| Poison | Green | `"green"` |
| Acid | Lime | `"lime"` |
| Psychic | Magenta | `"magenta"` |
| Blight | Maroon | `"maroon"` |

**Attack Message Formatting:**
```csharp
public static string FormatHitMessage(
    string attackerName,
    string targetName,
    int damage,
    DamageType damageType,
    bool isCritical = false)
```

**Behaviors:**
- Prepends `[bold yellow]CRITICAL![/]` prefix for critical hits
- Omits damage type label for Physical damage (reduces noise)
- Includes damage type name for elemental damage ("15 Fire", "12 Ice")
- Escapes special characters in combatant names using `EscapeMarkup()` helper
- Attacker names colored cyan, target names colored red

**Miss Message:**
```csharp
public static string FormatMissMessage(string attackerName, string targetName)
```
- Returns grey "misses!" text to de-emphasize failed attacks

**Glancing Blow:**
```csharp
public static string FormatGlancingMessage(
    string attackerName,
    string targetName,
    int damage,
    DamageType damageType)
```
- Uses grey "glances" text to differentiate from solid hits
- Includes reduced damage with appropriate coloring

**Status Effects:**
```csharp
public static string FormatStatusApplied(string targetName, string effectName)
public static string FormatStatusExpired(string targetName, string effectName)
```
- Applied effects use yellow highlighting
- Expired effects use grey to show diminishing importance

**Death Messages:**
```csharp
public static string FormatDeathMessage(string targetName, bool isPlayer)
```
- Player deaths: `[bold red]...has fallen![/]` for dramatic emphasis
- Enemy deaths: `[red]...is [grey]defeated![/]` with subdued styling

**Combat Flow:**
```csharp
public static string FormatRoundStart(int roundNumber)
public static string FormatTurnStart(string combatantName, bool isPlayer)
public static string FormatVictory()
public static string FormatDefeat()
```
- Round starts display separator with bold white styling
- Turn starts use player/enemy color coding (cyan/red)
- Victory shows bold green, defeat shows bold red

**Ability System:**
```csharp
public static string FormatAbilityUse(string casterName, string abilityName)
public static string FormatHealMessage(string targetName, int amount)
```
- Abilities highlighted in yellow
- Healing values displayed in green

**Markup Escaping:**
```csharp
private static string EscapeMarkup(string text)
```
- Replaces `[` with `[[` and `]` with `]]`
- Prevents combatant names containing brackets from breaking Spectre.Console rendering

---

### TimelineRenderer (Terminal/Rendering)

**Class Signature:**
```csharp
public static class TimelineRenderer
```

**Constants:**
```csharp
public const int DefaultWindowSize = 8;
```
- Default 8-slot window shows current round remaining + next round preview

**Main Render Method:**
```csharp
public static Panel Render(List<TimelineEntryView>? projection, int currentRound)
```

**Behaviors:**
- Returns empty panel with "No timeline data" if projection is null or empty
- Creates `Grid` with dynamic column count based on entries (up to 8)
- Each column width set to 10 characters with `NoWrap()` to prevent wrapping
- Grid contains 3 rows:
  1. **Round Markers** - Display "R1", "R2" only when round changes
  2. **Combatant Names** - Active marker, name, health icon
  3. **Initiative Values** - Grey initiative numbers for reference
- Returns panel with yellow "INITIATIVE TIMELINE" header and rounded border

**Round Marker Logic:**
```csharp
private static string[] BuildRoundMarkers(List<TimelineEntryView> entries)
```
- Tracks last round number to detect transitions
- Only displays round marker on first entry of each new round
- Empty string for subsequent entries in same round
- Prevents visual clutter while maintaining round awareness

**Entry Formatting:**
```csharp
public static string FormatTimelineEntry(TimelineEntryView entry)
```

**Behaviors:**
- Color coding: `cyan` for players, `red` for enemies
- Active marker: `[bold yellow]‚ñ∫[/]` for active combatant, space for others
- Health icons:
  - `critical` ‚Üí `[red]![/]` (exclamation mark)
  - `wounded` ‚Üí `[yellow]~[/]` (tilde)
  - `dead` ‚Üí `[grey]‚úó[/]` (cross mark)
  - `healthy` ‚Üí No icon
- Name truncation to 8 characters maximum
- Appends `‚Ä¶` (ellipsis) for truncated names
- Total entry width: 1 marker + 8 name chars + 1 health icon = 10 characters

**Name Truncation:**
```csharp
private static string TruncateName(string name, int maxLength)
```
- Substring to `maxLength - 1` if exceeding limit
- Appends Unicode ellipsis character `‚Ä¶`
- Ensures consistent column alignment

**Markup Safety:**
- Uses `Markup.Escape()` to prevent injection attacks from combatant names

---

### CombatService Timeline Methods (Engine/Services)

**Timeline Projection:**
```csharp
public List<TimelineEntryView> GetTimelineProjection(int windowSize = 8)
```

**Algorithm:**
1. Return empty list if `CombatState` is null
2. Collect remaining combatants from current round (skip dead, skip past turns via `TurnIndex`)
3. Add entries until window size reached or current round exhausted
4. If window not full, backfill from next round's full turn order (alive only)
5. Map each combatant to `TimelineEntryView` with appropriate round number
6. Log trace message with projection count

**Entry Mapping:**
```csharp
private static TimelineEntryView MapToTimelineEntry(Combatant c, int roundNumber, Combatant? active)
```

**Health Indicator Logic:**
- `CurrentHp <= 0` ‚Üí `"dead"`
- `CurrentHp <= MaxHp / 4` ‚Üí `"critical"` (25% threshold)
- `CurrentHp <= MaxHp / 2` ‚Üí `"wounded"` (50% threshold)
- Otherwise ‚Üí `"healthy"`

**Active Detection:**
- `IsActive = (c.Id == active?.Id)` for current round entries
- Next round entries always have `IsActive = false`

**Integration Point:**
```csharp
TimelineProjection: GetTimelineProjection()
```
- Called in `GetCombatViewModel()` to populate view model
- Automatically updates every render cycle to reflect combat state changes

---

### AttackResult DamageType Addition (Core/Models)

**Modified Record:**
```csharp
public record AttackResult(
    AttackOutcome Outcome,
    int NetSuccesses,
    int RawDamage,
    int FinalDamage,
    bool IsHit,
    DamageType DamageType = DamageType.Physical  // Added v0.3.6b
);
```

**Default Value Justification:**
- `DamageType.Physical` is default for backward compatibility
- Existing attack resolution code continues to work without modification
- Elemental damage systems can override explicitly when implemented

---

## Logging Matrix

### CombatService (Timeline System)

| Event | Level | Template |
|-------|-------|----------|
| Timeline projection built | Trace | `"Built timeline projection with {Count} entries"` |

### CombatScreenRenderer

| Event | Level | Template |
|-------|-------|----------|
| Screen rendered | Trace | `"Rendered combat screen"` |

**Note:** `CombatLogFormatter` and `TimelineRenderer` are stateless static classes with no logging. They are pure formatting utilities.

---

## Test Coverage

**Total Tests Added:** 48
**Total Project Tests:** 2,129
**Passed:** 2,129
**Failed:** 0
**Duration:** ~1 second

---

### TimelineProjectionTests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `GetTimelineProjection_NoCombatState_ReturnsEmptyList` | Returns empty list when combat state is null |
| `GetTimelineProjection_CurrentRoundOnly_ReturnsRemainingCombatants` | Returns remaining combatants from current round when within window size |
| `GetTimelineProjection_FillsFromNextRound_WhenNeeded` | Backfills from next round when current round has fewer entries than window size |
| `GetTimelineProjection_ExcludesDeadCombatants` | Filters out combatants with CurrentHp <= 0 from projection |
| `GetTimelineProjection_MarksActiveCorrectly` | Sets IsActive=true only for the current active combatant |
| `GetTimelineProjection_RespectsWindowSize` | Limits projection to specified window size parameter |
| `GetTimelineProjection_NextRoundEntries_NotMarkedActive` | Ensures next round entries have IsActive=false |
| `GetTimelineProjection_CriticalHealth_ReturnsCorrectIndicator` | Returns "critical" health indicator when HP <= 25% |
| `GetTimelineProjection_WoundedHealth_ReturnsCorrectIndicator` | Returns "wounded" health indicator when HP between 25-50% |
| `GetTimelineProjection_HealthyHealth_ReturnsCorrectIndicator` | Returns "healthy" health indicator when HP > 50% |

**Test Setup:**
- Uses Moq to mock 12 service dependencies
- Creates test characters with `CreateTestCharacter()` helper
- Creates test enemies with `CreateTestEnemy()` helper
- Manipulates `TurnIndex` to simulate mid-round scenarios
- Modifies `CurrentHp` to test health thresholds

---

### CombatLogFormatterTests (23 tests)

| Test Name | Description |
|-----------|-------------|
| `GetDamageColor_Physical_ReturnsWhite` | Returns "white" for Physical damage type |
| `GetDamageColor_Fire_ReturnsOrange` | Returns "orange1" for Fire damage type |
| `GetDamageColor_Ice_ReturnsCyan` | Returns "cyan1" for Ice damage type |
| `GetDamageColor_Lightning_ReturnsYellow` | Returns "yellow" for Lightning damage type |
| `GetDamageColor_Poison_ReturnsGreen` | Returns "green" for Poison damage type |
| `GetDamageColor_Acid_ReturnsLime` | Returns "lime" for Acid damage type |
| `GetDamageColor_Psychic_ReturnsMagenta` | Returns "magenta" for Psychic damage type |
| `GetDamageColor_Blight_ReturnsMaroon` | Returns "maroon" for Blight damage type |
| `FormatHitMessage_Physical_NoTypeLabel` | Omits damage type label for Physical damage to reduce noise |
| `FormatHitMessage_Fire_IncludesTypeLabel` | Includes "Fire" label for elemental damage |
| `FormatHitMessage_Critical_AddsCriticalPrefix` | Adds "[bold yellow]CRITICAL![/]" prefix for critical hits |
| `FormatHitMessage_IncludesAttackerName` | Includes attacker name with cyan coloring |
| `FormatHitMessage_IncludesTargetName` | Includes target name with red coloring |
| `FormatHitMessage_EscapesBracketsInNames` | Escapes [ and ] characters to prevent markup injection |
| `FormatMissMessage_IncludesNames` | Includes both attacker and target names with appropriate colors |
| `FormatMissMessage_HasGreyMissIndicator` | Uses grey "misses!" text for de-emphasis |
| `FormatDeathMessage_Player_UsesBoldRed` | Uses bold red "has fallen!" for player deaths |
| `FormatDeathMessage_Enemy_UsesGreyDefeated` | Uses grey "defeated!" for enemy deaths |
| `FormatStatusApplied_IncludesTargetAndEffect` | Includes target name and effect name with yellow highlighting |
| `FormatAbilityUse_IncludesCasterAndAbility` | Includes caster name and ability name with yellow highlighting |
| `FormatHealMessage_ShowsGreenHealing` | Shows healing amount in green with HP label |
| `FormatRoundStart_IncludesRoundNumber` | Includes round number with bold white separator styling |
| `FormatTurnStart_Player_UsesCyan` | Uses cyan for player turn announcements |
| `FormatTurnStart_Enemy_UsesRed` | Uses red for enemy turn announcements |
| `FormatVictory_ShowsBoldGreen` | Uses bold green for victory message |
| `FormatDefeat_ShowsBoldRed` | Uses bold red for defeat message |

**Test Characteristics:**
- No mocking required (static utility class)
- Direct assertion on returned markup strings
- Uses FluentAssertions `Contain()` for markup pattern validation
- Verifies proper escaping with bracket characters `[` and `]`

---

### TimelineRendererTests (15 tests)

| Test Name | Description |
|-----------|-------------|
| `Render_NullProjection_ReturnsPanel` | Returns valid panel when projection is null |
| `Render_EmptyProjection_ReturnsPanel` | Returns valid panel when projection is empty list |
| `Render_WithEntries_ReturnsPanel` | Returns valid panel when projection contains entries |
| `Render_RespectsWindowSize` | Handles projections larger than window size without errors |
| `FormatTimelineEntry_Player_UsesCyan` | Uses cyan color for player combatants |
| `FormatTimelineEntry_Enemy_UsesRed` | Uses red color for enemy combatants |
| `FormatTimelineEntry_Active_ShowsMarker` | Shows "[bold yellow]‚ñ∫[/]" marker for active combatant |
| `FormatTimelineEntry_Inactive_NoMarker` | Shows space character for inactive combatants |
| `FormatTimelineEntry_CriticalHealth_ShowsExclamation` | Shows "[red]![/]" for critical health status |
| `FormatTimelineEntry_WoundedHealth_ShowsTilde` | Shows "[yellow]~[/]" for wounded health status |
| `FormatTimelineEntry_DeadHealth_ShowsCross` | Shows "[grey]‚úó[/]" for dead health status |
| `FormatTimelineEntry_HealthyHealth_NoIndicator` | Shows no health icon for healthy combatants |
| `FormatTimelineEntry_LongName_Truncates` | Truncates names exceeding 8 characters with ellipsis |
| `FormatTimelineEntry_ShortName_NoTruncation` | Preserves names 8 characters or shorter |
| `FormatTimelineEntry_NameWithBrackets_EscapesMarkup` | Uses `Markup.Escape()` to convert [ to [[ and ] to ]] |

**Test Helpers:**
- `CreateTestProjection()` generates sample timeline entries
- `CreateTestEntry()` creates individual entries with default values
- Direct string assertions on returned markup

---

## DI Registration

**No Changes Required**

Both `CombatLogFormatter` and `TimelineRenderer` are static utility classes and do not require DI registration. They are invoked directly via static method calls:

```csharp
// CombatLogFormatter usage example
var message = CombatLogFormatter.FormatHitMessage(attacker, target, damage, damageType, isCrit);

// TimelineRenderer usage example
var panel = TimelineRenderer.Render(vm.TimelineProjection, vm.RoundNumber);
```

---

## Verification Results

**Build Output:**
```
Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:00.75
```

**Test Output:**
```
Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:  2129, Skipped:     0, Total:  2129, Duration: 1 s - RuneAndRust.Tests.dll (net9.0)
```

---

## Directory Structure After Release

```
RuneAndRust/
‚îú‚îÄ‚îÄ RuneAndRust.Core/
‚îÇ   ‚îú‚îÄ‚îÄ Enums/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DamageType.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RowPosition.cs
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Combat/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ AttackResult.cs [MODIFIED]
‚îÇ   ‚îî‚îÄ‚îÄ ViewModels/
‚îÇ       ‚îú‚îÄ‚îÄ CombatViewModel.cs [MODIFIED]
‚îÇ       ‚îî‚îÄ‚îÄ TimelineEntryView.cs [NEW]
‚îú‚îÄ‚îÄ RuneAndRust.Engine/
‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ       ‚îú‚îÄ‚îÄ CombatLogFormatter.cs [NEW]
‚îÇ       ‚îî‚îÄ‚îÄ CombatService.cs [MODIFIED]
‚îú‚îÄ‚îÄ RuneAndRust.Terminal/
‚îÇ   ‚îú‚îÄ‚îÄ Rendering/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CombatGridRenderer.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TimelineRenderer.cs [NEW]
‚îÇ   ‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CombatScreenRenderer.cs [MODIFIED]
‚îÇ   ‚îî‚îÄ‚îÄ Program.cs [MODIFIED]
‚îî‚îÄ‚îÄ RuneAndRust.Tests/
    ‚îú‚îÄ‚îÄ Engine/
    ‚îÇ   ‚îú‚îÄ‚îÄ CombatLogFormatterTests.cs [NEW]
    ‚îÇ   ‚îî‚îÄ‚îÄ TimelineProjectionTests.cs [NEW]
    ‚îî‚îÄ‚îÄ Terminal/
        ‚îî‚îÄ‚îÄ TimelineRendererTests.cs [NEW]
```

---

## Running Tests

**Run All Timeline/Formatter Tests:**
```bash
dotnet test --filter "FullyQualifiedName~TimelineProjectionTests"
dotnet test --filter "FullyQualifiedName~CombatLogFormatterTests"
dotnet test --filter "FullyQualifiedName~TimelineRendererTests"
```

**Run Full Test Suite:**
```bash
dotnet test
```

**Run Specific Test:**
```bash
dotnet test --filter "FullyQualifiedName~GetTimelineProjection_FillsFromNextRound_WhenNeeded"
```

---

## Next Steps

Planned work for **v0.3.6c**:

- **Damage Type Integration:** Wire `DamageType` property through attack resolution for elemental weapon damage
- **Elemental Resistance System:** Implement resistance/vulnerability multipliers based on enemy weaknesses
- **Combat Log Persistence:** Store combat log history to file for post-battle review
- **Timeline Customization:** Add configuration for window size and health threshold display
- **Status Effect Icons:** Integrate status effect symbols into timeline health indicators
- **Multi-Round Projection:** Extend timeline to show 2-3 rounds ahead for long-term planning
- **Combat Log Filtering:** Allow players to toggle damage type visibility
- **Timeline Animation:** Smooth scrolling transitions when active combatant changes

---

## Part C: The Telegraph (Intent & Status)

**Release Date:** 2025-12-22

---

## Summary

Version 0.3.6c introduces the Intent System, providing players with strategic foresight into enemy actions through WITS-based perception checks. This release implements AI pre-planning mechanics where enemies telegraph their intended actions (Attack, Defend, Flee, Pass) at the start of combat and each round, with visibility determined by player WITS checks or the new Analyzed debuff. The system includes dynamic replanning triggered by significant state changes (HP damage, status effects), ensuring enemies adapt to evolving combat conditions.

This release touches the **Core Layer** (Models, ViewModels, Enums), **Engine Layer** (Services), **Terminal Layer** (Rendering), and **Test Layer** with comprehensive test coverage. Key patterns introduced include proactive AI planning with reactive replanning, archetype-specific perception bonuses (Adept +2 WITS), and a new intel-category status effect that bypasses perception requirements.

---

## New Files Created

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/IntentSystemTests.cs` | 13 unit tests validating enemy action planning, WITS-based intent visibility, Adept archetype bonuses, Analyzed status auto-reveal, and intent icon mapping to ViewModel |
| `RuneAndRust.Tests/Engine/AnalyzedStatusTests.cs` | 10 unit tests validating Analyzed status effect behavior including non-stacking mechanics, duration refresh, effect detection, turn-end processing, debuff classification, and max stack limits |
| `RuneAndRust.Tests/Terminal/CombatGridRendererIntentTests.cs` | 9 unit tests validating intent icon rendering (‚öîÔ∏è/üõ°Ô∏è/üí®/üí§/?), status icon display (ü©∏/ü§¢/üí´/üíî/üõ°Ô∏è), stack count formatting, and combined intent/status/targeting display |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/StatusEffectType.cs` | Added `Analyzed = 6` as intel debuff effect. Documented as non-stacking (max stacks = 1), reapplication refreshes duration, auto-reveals enemy intent regardless of WITS check |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added `PlannedAction` property (type `CombatAction?`) to store AI-determined action at round start. Added `IsIntentRevealed` property (type `bool`) to track whether player can see the planned action via WITS check or Analyzed status |
| `RuneAndRust.Core/ViewModels/CombatViewModel.cs` | Added `IntentIcon` parameter to `CombatantView` record (type `string?`) showing enemy intent icons (‚öîÔ∏è/üõ°Ô∏è/üí®/üí§/? or null for player). Added `StatusIcons` parameter (type `string?`) showing Unicode status effect icons with stack counts |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added Intent System region with `PlanEnemyActions()`, `CalculateIntentVisibility()`, `GetIntentIcon()`, `GetStatusIcons()`, and `OnStateChange()` methods. Updated constructor to inject `IDiceService` dependency. Modified `StartCombat()` to call `PlanEnemyActions()` after turn order setup. Modified `NextTurn()` to call `PlanEnemyActions()` at round start. Updated `ProcessEnemyTurnAsync()` to use `PlannedAction` with fallback to fresh `DetermineAction()`. Modified `MapToView()` to populate `IntentIcon` and `StatusIcons` for CombatantView. Added `OnStateChange()` calls after damage application in player and enemy attack methods |
| `RuneAndRust.Terminal/Rendering/CombatGridRenderer.cs` | Updated `FormatCombatant()` to display intent icons for enemies with yellow coloring. Added status icon display for all combatants using `StatusIcons` property |
| `RuneAndRust.Terminal/Program.cs` | Updated version string from v0.3.6b to v0.3.6c in boot sequence |

---

## Code Implementation Details

### StatusEffectType.Analyzed (Core/Enums)

**Enum Value:**
```csharp
/// <summary>
/// Intel effect. Target's planned action is revealed to the player.
/// Reveals enemy intent regardless of WITS check result.
/// Does not stack; reapplication refreshes duration only (v0.3.6c).
/// </summary>
Analyzed = 6,
```

**Classification:**
- **Value:** 6 (debuff range: 0-99)
- **Category:** Intel debuff (not DoT)
- **Stacking:** Does not stack (max stacks = 1)
- **Reapplication Behavior:** Refreshes duration to new value
- **Interaction:** Grants automatic intent visibility, bypassing WITS checks entirely

---

### Combatant Intent Properties (Core/Models)

**Added Properties:**
```csharp
/// <summary>
/// The action the AI intends to take this round (v0.3.6c).
/// Calculated at round start and on state changes (HP, status).
/// Null for player combatants.
/// </summary>
public CombatAction? PlannedAction { get; set; }

/// <summary>
/// Whether the player has successfully perceived this enemy's intent (v0.3.6c).
/// Set by CombatService based on WITS check or Analyzed status.
/// Always false for player combatants.
/// </summary>
public bool IsIntentRevealed { get; set; } = false;
```

**Lifecycle:**
- `PlannedAction` set by `PlanEnemyActions()` at combat start, round start, and after state changes
- `PlannedAction` cleared to null after consumption in `ProcessEnemyTurnAsync()`
- `IsIntentRevealed` recalculated each time `PlanEnemyActions()` runs
- Player combatants always have `PlannedAction = null` and `IsIntentRevealed = false`

---

### CombatantView Intent Properties (Core/ViewModels)

**Added Parameters:**
```csharp
public record CombatantView(
    // ... existing parameters ...
    string? IntentIcon = null,    // v0.3.6c
    string? StatusIcons = null    // v0.3.6c
);
```

**IntentIcon Values:**
- `"‚öîÔ∏è"` - Attack action
- `"üõ°Ô∏è"` - Defend action
- `"üí®"` - Flee action
- `"üí§"` - Pass action
- `"?"` - Hidden intent (failed WITS check, no Analyzed status)
- `null` - Player combatants (no intent display)

**StatusIcons Format:**
- Single effect: `"ü©∏"` (Bleeding)
- Stacked effect: `"ü©∏√ó3"` (Bleeding with 3 stacks)
- Multiple effects: `"ü©∏ ü§¢"` (Bleeding and Poisoned, space-separated)
- No effects: `null`

**Icon Mappings:**
| Status Effect | Icon | Display Example |
|---------------|------|-----------------|
| Bleeding | ü©∏ | `"ü©∏√ó2"` |
| Poisoned | ü§¢ | `"ü§¢√ó1"` |
| Stunned | üí´ | `"üí´"` |
| Vulnerable | üíî | `"üíî"` |
| Disoriented | üòµ | `"üòµ"` |
| Exhausted | üò¥ | `"üò¥"` |
| Analyzed | üîç | `"üîç"` |
| Fortified | üõ°Ô∏è | `"üõ°Ô∏è√ó3"` |
| Hasted | ‚ö° | `"‚ö°"` |
| Inspired | ‚ú® | `"‚ú®"` |

---

### CombatService Intent System Methods (Engine/Services)

**PlanEnemyActions:**
```csharp
private void PlanEnemyActions()
```

**Algorithm:**
1. Return early if `CombatState` is null
2. Locate player combatant from turn order
3. Iterate all living enemy combatants (`CurrentHp > 0`)
4. For each enemy:
   - Call `_aiService.DetermineAction()` to get planned action
   - Call `CalculateIntentVisibility()` to determine if player can perceive
   - Log action type and revealed status at Trace level
5. Total runtime: O(n) where n = enemy count

**Invocation Points:**
- `StartCombat()` - After turn order initialization, before first turn
- `NextTurn()` - When `TurnIndex` wraps to 0 (new round start)
- `OnStateChange()` - After HP damage applied to any combatant

**CalculateIntentVisibility:**
```csharp
private bool CalculateIntentVisibility(Combatant player, Combatant enemy)
```

**Visibility Logic:**
1. **Analyzed Check:** If enemy has `Analyzed` status, return `true` immediately (bypass WITS)
2. **WITS Pool Calculation:**
   - Base pool: `player.GetAttribute(CharacterAttribute.Wits)`
   - Archetype bonus: +2 if player is `ArchetypeType.Adept`, else 0
   - Condition modifier: `player.ConditionWitsModifier`
   - Total pool: `baseWits + archetypeBonus + conditionModifier`
   - Minimum pool: 1 (never roll 0 dice)
3. **Dice Roll:** Roll pool size using `_dice.Roll()`
4. **Success Threshold:** 1+ successes reveals intent
5. **Log:** Debug message showing result, successes, and final pool size

**Behaviors:**
- Analyzed status always reveals, no roll needed
- Adept archetype receives +2 WITS pool for intent checks only (not global bonus)
- Success threshold is low (1 success) to favor player strategic awareness
- Each enemy rolls independently (possible to see some intents but not others)

---

**GetIntentIcon:**
```csharp
private static string GetIntentIcon(CombatAction? action, bool isRevealed)
```

**Mapping:**
```csharp
if (!isRevealed || action == null) return "?";

return action.Type switch
{
    ActionType.Attack => "‚öîÔ∏è",
    ActionType.Defend => "üõ°Ô∏è",
    ActionType.Flee => "üí®",
    ActionType.Pass => "üí§",
    _ => "?"
};
```

**Edge Cases:**
- `null` action ‚Üí `"?"`
- `isRevealed = false` ‚Üí `"?"` regardless of action
- Unknown `ActionType` ‚Üí `"?"` (defensive fallback)

---

**GetStatusIcons:**
```csharp
private static string? GetStatusIcons(List<ActiveStatusEffect>? effects)
```

**Algorithm:**
1. Return `null` if effects list is null or empty
2. Iterate effects and map each to icon (see table above)
3. For stacks > 1, append `√ó{Stacks}` to icon
4. Join icons with space separator
5. Return `null` if no icons generated (all effects unmapped)

**Output Examples:**
- `"ü©∏√ó2"` - Bleeding with 2 stacks
- `"ü©∏ ü§¢√ó3"` - Bleeding (1 stack) and Poisoned (3 stacks)
- `"üí´"` - Stunned (non-stacking effect)
- `null` - No effects or all effects unmapped

---

**OnStateChange:**
```csharp
private void OnStateChange()
```

**Purpose:** Trigger enemy replanning after significant combat state changes (HP damage, status effects).

**Behaviors:**
- Calls `PlanEnemyActions()` to recalculate all enemy actions
- Logs trace message indicating replanning occurred
- Lightweight operation: only recalculates actions, does not modify turn order

**Invocation Sites:**
1. **Player Attack Resolution:** After `target.CurrentHp -= result.FinalDamage` in player attack method
2. **Enemy Attack Resolution:** After `target.CurrentHp -= result.FinalDamage` in enemy attack method

**Rationale:** Enemies should adapt strategies when player HP drops (Tank may Defend to protect wounded allies) or enemy HP changes (DPS may become more aggressive when wounded).

---

**ProcessEnemyTurnAsync Updates:**
```csharp
public async Task ProcessEnemyTurnAsync(Combatant enemy)
{
    // ... delay, reset defending ...

    // Use planned action if available, otherwise determine fresh (v0.3.6c)
    var action = enemy.PlannedAction ?? _aiService.DetermineAction(enemy, _gameState.CombatState!);

    // Clear the planned action after use
    enemy.PlannedAction = null;

    // ... execute action ...
}
```

**Behaviors:**
- Prefers `PlannedAction` over fresh determination (uses pre-planned intent)
- Fallback to `DetermineAction()` if `PlannedAction` is null (defensive programming)
- Clears `PlannedAction` after consumption to prevent reuse
- Logs continue to reference action type for debugging

**Fallback Scenarios:**
- `PlannedAction` manually set to null (testing or debugging)
- Enemy added mid-combat without planning phase
- Corruption of combat state

---

**MapToView Intent Mapping:**
```csharp
private static CombatantView MapToView(Combatant combatant, Combatant? activeCombatant)
{
    // ... existing health and status logic ...

    return new CombatantView(
        // ... existing parameters ...
        IntentIcon: combatant.IsPlayer ? null : GetIntentIcon(combatant.PlannedAction, combatant.IsIntentRevealed),
        StatusIcons: GetStatusIcons(combatant.StatusEffects)
    );
}
```

**Intent Display Rules:**
- Player combatants: `IntentIcon = null` (never show intent for player)
- Enemy combatants: Call `GetIntentIcon()` with `PlannedAction` and `IsIntentRevealed`
- Hidden intent: `"?"` if `IsIntentRevealed = false`
- Revealed intent: Action-specific icon if `IsIntentRevealed = true`

**Status Display Rules:**
- All combatants: Call `GetStatusIcons()` with `StatusEffects` list
- Empty list: `StatusIcons = null`
- Populated list: Space-separated icon string with stack counts

---

### CombatGridRenderer Intent Display (Terminal/Rendering)

**Updated FormatCombatant:**
```csharp
public static string FormatCombatant(CombatantView c, bool isEnemy)
{
    // ... existing active marker, name, health icon ...

    // Add intent icon for enemies (v0.3.6c)
    var intentDisplay = "";
    if (isEnemy && !string.IsNullOrEmpty(c.IntentIcon))
    {
        intentDisplay = $" [yellow]{c.IntentIcon}[/]";
    }

    // Add status icons (v0.3.6c)
    var statusDisplay = "";
    if (!string.IsNullOrEmpty(c.StatusIcons))
    {
        statusDisplay = $" {c.StatusIcons}";
    }

    // ... existing targeting indicator ...

    return $"{activeMarker}[{color}]{escapedName}[/]{healthIcon}{intentDisplay}{statusDisplay}{targetIndicator}";
}
```

**Display Order:**
1. Active marker (`>` or space)
2. Combatant name (cyan for players, red for enemies)
3. Health icon (`!!!` / `!!` for enemies)
4. Intent icon (yellow, enemies only)
5. Status icons (default color)
6. Target indicator (`*` if targeted)

**Example Outputs:**
- ` [red]Voidling[/] [yellow]‚öîÔ∏è[/] ü©∏√ó2` - Enemy with revealed Attack intent and Bleeding √ó2
- `>[red]Feralhound[/] !!! [yellow]?[/] üí´` - Active enemy, Critical health, hidden intent, Stunned
- ` [cyan]Kael[/] üõ°Ô∏è ü§¢` - Player with Fortified and Poisoned (no intent icon)

**Styling:**
- Intent icons: `[yellow]...[/]` (consistent warning color)
- Status icons: No Spectre markup (render as raw Unicode)
- Active marker: `[bold yellow]>[/]`
- Target indicator: `[bold white]*[/]`

---

### Constructor Update (Engine/Services)

**Added Dependency:**
```csharp
public CombatService(
    // ... existing dependencies ...
    IDiceService dice,              // v0.3.6c for WITS checks
    ILogger<CombatService> logger)
{
    // ... existing assignments ...
    _dice = dice;
    _logger = logger;
}
```

**Rationale:** Intent visibility requires dice rolls for WITS checks. `IDiceService` provides standard d10 pool rolling with success counting (8+ = success).

**Impact:** All existing DI registrations and test mocks must include `IDiceService`.

---

## Logging Matrix

### CombatService (Intent System)

| Event | Level | Template |
|-------|-------|----------|
| Enemy action planned | Trace | `"[AI] {Enemy} planned action: {ActionType}. Revealed: {Revealed}"` |
| Intent check result | Debug | `"[Combat] Intent check vs {Enemy}: {Result} ({Successes} successes, pool: {Pool})"` |
| Analyzed bypass | Debug | `"[Combat] {Enemy} intent revealed via Analyzed status"` |
| State change replanning | Trace | `"[Combat] Replanned enemy actions after state change"` |

**Log Contexts:**
- `{Enemy}` - Enemy combatant name (string)
- `{ActionType}` - Enum value (Attack, Defend, Flee, Pass)
- `{Revealed}` - Boolean (true/false)
- `{Result}` - String ("Revealed" or "Hidden")
- `{Successes}` - Integer (dice successes, 8+ counts)
- `{Pool}` - Integer (total dice pool size)

---

## Test Coverage

**Total Tests Added:** 32
**Total Project Tests:** 2,161
**Passed:** 2,161
**Failed:** 0
**Duration:** ~1 second

---

### IntentSystemTests (13 tests)

| Test Name | Description |
|-----------|-------------|
| `StartCombat_PlansActionsForAllEnemies` | Verifies all enemy combatants receive `PlannedAction` at combat start |
| `StartCombat_SkipsDeadEnemies_WhenPlanningActions` | Confirms dead enemies (`CurrentHp <= 0`) are excluded from planning |
| `StartCombat_PlayerCombatant_HasNullPlannedAction` | Asserts player combatant always has `PlannedAction = null` |
| `StartCombat_AnalyzedStatus_AlwaysRevealsIntent` | Validates Analyzed status bypasses WITS checks, sets `IsIntentRevealed = true` |
| `StartCombat_HighWits_WithSuccessfulRoll_RevealsIntent` | Tests successful WITS check (1+ successes) reveals intent |
| `StartCombat_LowWits_WithFailedRoll_HidesIntent` | Tests failed WITS check (0 successes) hides intent |
| `StartCombat_AdeptArchetype_GetsBonusToWitsPool` | Confirms Adept archetype receives +2 dice pool size for intent checks |
| `StartCombat_NonAdeptArchetype_NoBonus` | Confirms Warrior/Skirmisher/Mystic archetypes get no bonus |
| `GetViewModel_Enemy_WithRevealedIntent_ShowsIntentIcon` | Asserts `CombatantView.IntentIcon` shows action icon (‚öîÔ∏è) when `IsIntentRevealed = true` |
| `GetViewModel_Enemy_WithHiddenIntent_ShowsQuestionMark` | Asserts `CombatantView.IntentIcon` shows `"?"` when `IsIntentRevealed = false` |
| `GetViewModel_Player_HasNullIntentIcon` | Confirms player combatants have `IntentIcon = null` |
| `GetViewModel_DefendAction_ShowsShieldIcon` | Tests Defend action maps to `"üõ°Ô∏è"` icon |

**Test Setup:**
- Uses Moq to mock 13 service dependencies (added `IDiceService` in v0.3.6c)
- `CreateTestCharacter()` helper creates player combatants with configurable WITS
- `CreateTestEnemy()` helper creates enemy combatants
- Mocks `_mockDice.Roll()` to control success/failure for WITS checks
- Mocks `_mockStatusEffects.HasEffect()` to simulate Analyzed status
- Captures dice pool size via `Callback<int, string>()` to verify bonus application

---

### AnalyzedStatusTests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `ApplyEffect_Analyzed_DoesNotStack` | Verifies applying Analyzed twice results in 1 stack only |
| `ApplyEffect_Analyzed_RefreshesDuration_OnReapplication` | Confirms reapplication refreshes duration to new value |
| `HasEffect_Analyzed_ReturnsTrue_WhenApplied` | Tests `HasEffect()` returns true when Analyzed is active |
| `HasEffect_Analyzed_ReturnsFalse_WhenNotApplied` | Tests `HasEffect()` returns false when Analyzed is not active |
| `ProcessTurnEnd_Analyzed_DecrementsDuration` | Validates duration decrements by 1 each turn via `ProcessTurnEnd()` |
| `ProcessTurnEnd_Analyzed_RemovesEffect_WhenExpired` | Confirms effect removed when duration reaches 0 |
| `Analyzed_IsDebuff` | Asserts `ActiveStatusEffect.IsDebuff()` returns true (value 6 < 100) |
| `Analyzed_IsNotDamageOverTime` | Asserts `ActiveStatusEffect.IsDamageOverTime()` returns false |
| `Analyzed_CannotStack` | Asserts `ActiveStatusEffect.CanStack()` returns false |
| `Analyzed_MaxStacks_IsOne` | Asserts `ActiveStatusEffect.GetMaxStacks()` returns 1 |

**Test Characteristics:**
- Uses `StatusEffectService` as system under test
- `CreateTestCombatant()` helper creates clean combatant for effect application
- Tests cover full lifecycle: apply, check, decrement, expire
- Tests verify static classification methods (`IsDebuff`, `CanStack`, etc.)

---

### CombatGridRendererIntentTests (9 tests)

| Test Name | Description |
|-----------|-------------|
| `FormatCombatant_Enemy_WithIntentIcon_ShowsIcon` | Verifies intent icon (‚öîÔ∏è) appears in formatted output for enemies |
| `FormatCombatant_Enemy_WithQuestionMarkIntent_ShowsQuestionMark` | Confirms `"?"` displays for hidden intent |
| `FormatCombatant_Player_NoIntentIcon` | Asserts player combatants do not show any intent icons |
| `FormatCombatant_Enemy_WithDefendIntent_ShowsShieldIcon` | Tests Defend icon (üõ°Ô∏è) renders correctly |
| `FormatCombatant_WithStatusIcons_ShowsIcons` | Validates status icons (ü©∏ ü§¢) appear in output |
| `FormatCombatant_WithStackedStatus_ShowsStackCount` | Confirms stacked status displays as `ü©∏√ó3` |
| `FormatCombatant_NoStatusIcons_DoesNotAddExtraSpace` | Ensures null status icons don't add spurious whitespace |
| `FormatCombatant_Enemy_WithIntentAndStatus_ShowsBoth` | Tests combined intent and status icon display |
| `FormatCombatant_ActiveEnemy_ShowsActiveMarker` | Verifies `>` marker displays for active combatants |
| `FormatCombatant_TargetedEnemy_ShowsTargetIndicator` | Verifies `*` marker displays for targeted combatants |

**Test Helpers:**
- `CreateCombatantView()` generates test `CombatantView` records with configurable parameters
- Uses FluentAssertions `Contain()` to verify icon presence in output strings
- Tests static `FormatCombatant()` method (no mocking required)

---

### Updated Tests (3 files, existing tests modified)

| File | Change |
|------|--------|
| `CombatServiceTests.cs` | Added `Mock<IDiceService>` to test constructor, passed to `CombatService` constructor in all test methods |
| `TimelineProjectionTests.cs` | Added `Mock<IDiceService>` to test constructor, passed to `CombatService` constructor in all test methods |
| `RowAssignmentTests.cs` | Added `Mock<IDiceService>` to test constructor, passed to `CombatService` constructor in all test methods |

**Impact:** No test logic changes, only constructor signature updates to accommodate new `IDiceService` dependency.

---

## DI Registration

**No New Registrations Required**

Both `GetIntentIcon()` and `GetStatusIcons()` are private static helper methods within `CombatService`. The `IDiceService` dependency was already registered in prior versions and is reused for intent WITS checks.

**Existing Registration (unchanged):**
```csharp
// Program.cs or App.axaml.cs
services.AddSingleton<IDiceService, DiceService>();
services.AddSingleton<ICombatService, CombatService>();
```

---

## Verification Results

**Build Output:**
```
Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:00.82
```

**Test Output:**
```
Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:  2161, Skipped:     0, Total:  2161, Duration: 1 s - RuneAndRust.Tests.dll (net9.0)
```

---

## Directory Structure After Release

```
RuneAndRust/
‚îú‚îÄ‚îÄ RuneAndRust.Core/
‚îÇ   ‚îú‚îÄ‚îÄ Enums/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StatusEffectType.cs [MODIFIED]
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Combat/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Combatant.cs [MODIFIED]
‚îÇ   ‚îî‚îÄ‚îÄ ViewModels/
‚îÇ       ‚îî‚îÄ‚îÄ CombatViewModel.cs [MODIFIED]
‚îú‚îÄ‚îÄ RuneAndRust.Engine/
‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ       ‚îî‚îÄ‚îÄ CombatService.cs [MODIFIED]
‚îú‚îÄ‚îÄ RuneAndRust.Terminal/
‚îÇ   ‚îú‚îÄ‚îÄ Rendering/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CombatGridRenderer.cs [MODIFIED]
‚îÇ   ‚îî‚îÄ‚îÄ Program.cs [MODIFIED]
‚îî‚îÄ‚îÄ RuneAndRust.Tests/
    ‚îú‚îÄ‚îÄ Engine/
    ‚îÇ   ‚îú‚îÄ‚îÄ AnalyzedStatusTests.cs [NEW]
    ‚îÇ   ‚îú‚îÄ‚îÄ CombatServiceTests.cs [MODIFIED - IDiceService mock added]
    ‚îÇ   ‚îú‚îÄ‚îÄ IntentSystemTests.cs [NEW]
    ‚îÇ   ‚îú‚îÄ‚îÄ RowAssignmentTests.cs [MODIFIED - IDiceService mock added]
    ‚îÇ   ‚îî‚îÄ‚îÄ TimelineProjectionTests.cs [MODIFIED - IDiceService mock added]
    ‚îî‚îÄ‚îÄ Terminal/
        ‚îî‚îÄ‚îÄ CombatGridRendererIntentTests.cs [NEW]
```

---

## Running Tests

**Run All Intent System Tests:**
```bash
dotnet test --filter "FullyQualifiedName~IntentSystemTests"
dotnet test --filter "FullyQualifiedName~AnalyzedStatusTests"
dotnet test --filter "FullyQualifiedName~CombatGridRendererIntentTests"
```

**Run Specific Test:**
```bash
dotnet test --filter "FullyQualifiedName~StartCombat_AdeptArchetype_GetsBonusToWitsPool"
```

**Run Full Test Suite:**
```bash
dotnet test
```

---

## Next Steps

Planned work for **v0.3.6d**:

- **Ability-Based Intent Reveal:** Introduce "Scan" or "Analyze" abilities that apply Analyzed status to enemies
- **Multi-Turn Intent Projection:** Show enemy intent for current turn and next turn in timeline
- **Intent Icon Tooltips:** Rich hover details showing full action description ("This enemy will attack the Front Row")
- **AI Strategy Hints:** Display additional intel for Analyzed enemies (target selection, ability choice)
- **Intent-Based Counterplay:** Abilities that trigger off specific enemy intents (Riposte on Attack, Brace on Defend)
- **Status Effect Synergies:** Status effects that interact with intent (Fear prevents Defend, Taunt forces Attack on caster)
- **WITS Passive Bonuses:** Equipment or traits that grant permanent WITS bonuses for intent checks
- **Intent Log Messages:** Combat log entries when intent is revealed ("You sense the Voidling preparing to strike!")

---

**End of Consolidated Changelog v0.3.6**
