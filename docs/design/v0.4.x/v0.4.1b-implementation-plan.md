# v0.4.1b Implementation Plan: Trap Mechanics

**Version:** 0.4.1b
**Parent:** v0.4.1 (Traps & Environmental Hazards)
**Prerequisites:** v0.4.1a Complete (Core Trap System)
**Status:** Ready for Implementation
**Target Tests:** ~1500 -> ~1535 (+35 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Implement the active mechanics for traps including Perception-based detection (`search` command), skill-based disarm attempts (`disarm` command), automatic triggering based on player actions, trap effects (damage, status effects, alerts), and saving throws. This phase brings the trap system established in v0.4.1a to full functionality.

### Scope

**In Scope:**
- `TrapEffect` value object for effect configuration
- `TrapEffectResult` value object for effect outcomes
- `TrapDisarmResult` value object for disarm outcomes
- Trap detection via Perception skill checks (`search` command)
- Passive perception check on room entry
- Trap disarm via skill checks (`disarm` command)
- Failed disarm consequences (trigger if 5+ below DC)
- Automatic trap triggering on movement (Step/Proximity traps)
- Automatic trap triggering on object interaction (Open/Touch traps)
- Trap damage calculation using DiceService
- Saving throws to reduce/avoid trap effects
- Status effect application via StatusEffectService
- Alert effects (monster awareness flags)
- Trapped container integration with InteractiveObject
- Detection/disarm DC display for detected traps
- Configuration updates for trap effects

**Out of Scope:**
- Environmental hazards (v0.4.1c)
- Hazard zones with ongoing effects (v0.4.1c)
- Trap creation by players (future)
- Trap respawning on room reset (future)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Passive Perception | 10 + Wits modifier + skill bonus | Standard D&D formula |
| Disarm trigger threshold | 5 below DC | Balances risk/reward, consistent with RPG patterns |
| Save halves vs negates | Configurable per trap | Flexibility for different trap types |
| Skill for disarm | DisableDevice (Finesse) | Thematically appropriate |
| Detection on entry | Passive only (no roll) | Avoids slowdown, rewards high Perception builds |
| Detected trap avoidance | Auto-avoid Step traps | Reward for detection |

---

## Dependencies from Previous Phases

### Dependencies from v0.4.1a (Core Trap System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Trap` entity | `Domain/Entities/Trap.cs` | Add Effect property |
| `TrapState` enum | `Domain/Enums/TrapState.cs` | State checks |
| `TriggerType` enum | `Domain/Enums/TriggerType.cs` | Trigger logic |
| `TrapDefinition` | `Domain/Definitions/TrapDefinition.cs` | Effect definition updates |
| `TrapEffectDefinition` | `Domain/Definitions/TrapDefinition.cs` | Expand placeholder |
| `TrapTriggerResult` | `Domain/ValueObjects/TrapTriggerResult.cs` | Extend with effects |
| `TrapDetectionResult` | `Domain/ValueObjects/TrapDetectionResult.cs` | Use in search |
| `ITrapService` | `Application/Interfaces/ITrapService.cs` | Add new methods |
| `TrapService` | `Application/Services/TrapService.cs` | Implement mechanics |
| `Room.Traps` | `Domain/Entities/Room.cs` | Collection access |

### Dependencies from Existing Systems

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `DiceService` | `Application/Services/DiceService.cs` | Damage rolls |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Detection/disarm checks |
| `StatusEffectService` | `Application/Services/StatusEffectService.cs` | Apply status effects |
| `Player` | `Domain/Entities/Player.cs` | Target for effects |
| `InteractiveObject` | `Domain/Entities/InteractiveObject.cs` | Add trap attachment |
| `IInteractionService` | `Application/Interfaces/IInteractionService.cs` | Update Open signature |
| `InteractionService` | `Application/Services/InteractionService.cs` | Trap checking on open |

---

## Current System Analysis

### Current v0.4.1a Trap Flow

```
v0.4.1a Flow (Foundation Only)
                    ┌───────────────────────────────────────────────────────┐
                    │              TrapService (Basic)                       │
                    ├───────────────────────────────────────────────────────┤
                    │ • GetRoomTrapsDescription() - display visible traps   │
                    │ • FindTrap() - keyword lookup                         │
                    │ • ExamineTrap() - basic examination                   │
                    │ • DetectTrap() - manual state change                  │
                    │ • DisarmTrap() - manual state change                  │
                    │ • TriggerTrap() - manual trigger, no effects          │
                    │ • CheckStepTraps() - placeholder, no dice             │
                    │ • CheckOpenTrap() - placeholder, no effects           │
                    │ • ProcessRoomTurnTick() - reset handling              │
                    └───────────────────────────────────────────────────────┘

MISSING: Detection dice rolls, disarm dice rolls, damage application,
         status effects, saving throws, trapped containers
```

### v0.4.1b Target Flow

```
v0.4.1b Flow (Full Mechanics)
                    ┌───────────────────────────────────────────────────────┐
                    │              TrapService (Full)                        │
                    ├───────────────────────────────────────────────────────┤
                    │ NEW Methods:                                          │
                    │ • SearchForTraps() - Perception check vs DCs          │
                    │ • PassivePerceptionCheck() - auto on room entry       │
                    │ • AttemptDisarm() - skill check + consequences        │
                    │ • ApplyTrapEffect() - damage, status, saves           │
                    │ • CheckEntryTraps() - trigger + apply effects         │
                    │ • CheckOpenTraps() - trigger + apply effects          │
                    │ • GetPassivePerception() - calculate passive          │
                    │                                                       │
                    │ Dependencies:                                         │
                    │ • DiceService - damage and save rolls                 │
                    │ • SkillCheckService - Perception/DisableDevice        │
                    │ • StatusEffectService - apply poison, etc.            │
                    └───────────────────────────────────────────────────────┘
```

---

## Detailed Implementation

### Domain Layer

#### 1. TrapEffect.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapEffect.cs`

```csharp
using RuneAndRust.Domain.Definitions;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the effect that occurs when a trap is triggered.
/// </summary>
/// <remarks>
/// <para>TrapEffect encapsulates all the consequences of a trap trigger,
/// including damage, status effects, saving throws, and alerts.</para>
/// <para>This is immutable once created and provides factory methods
/// for common effect types.</para>
/// </remarks>
public class TrapEffect
{
    // ===== Damage Properties =====

    /// <summary>
    /// Gets the damage dice expression (e.g., "2d6").
    /// </summary>
    /// <remarks>
    /// If null or empty, the trap does not deal damage.
    /// </remarks>
    public string? DamageDice { get; private set; }

    /// <summary>
    /// Gets the damage type (e.g., "piercing", "fire").
    /// </summary>
    public string? DamageType { get; private set; }

    // ===== Status Effect Properties =====

    /// <summary>
    /// Gets the status effects applied by this trap.
    /// </summary>
    public IReadOnlyList<string> StatusEffects { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the duration in turns for status effects.
    /// </summary>
    public int StatusDuration { get; private set; } = 3;

    // ===== Saving Throw Properties =====

    /// <summary>
    /// Gets the save DC to reduce or avoid the effect.
    /// </summary>
    public int? SaveDC { get; private set; }

    /// <summary>
    /// Gets the attribute used for the saving throw.
    /// </summary>
    /// <remarks>
    /// Common values: "Agility" for dodging, "Fortitude" for poison/disease.
    /// </remarks>
    public string? SaveAttribute { get; private set; }

    /// <summary>
    /// Gets whether a successful save halves damage (true) or negates it (false).
    /// </summary>
    public bool SaveHalvesDamage { get; private set; } = true;

    // ===== Message Properties =====

    /// <summary>
    /// Gets the custom message displayed when the trap triggers.
    /// </summary>
    public string? TriggerMessage { get; private set; }

    // ===== Alert Properties =====

    /// <summary>
    /// Gets whether this trap alerts nearby monsters.
    /// </summary>
    public bool AlertsMonsters { get; private set; }

    /// <summary>
    /// Gets the alert radius in rooms (0 = current room only).
    /// </summary>
    public int AlertRadius { get; private set; }

    // ===== Computed Properties =====

    /// <summary>
    /// Gets whether this effect deals damage.
    /// </summary>
    public bool DealsDamage => !string.IsNullOrEmpty(DamageDice);

    /// <summary>
    /// Gets whether this effect applies status effects.
    /// </summary>
    public bool AppliesStatus => StatusEffects.Count > 0;

    /// <summary>
    /// Gets whether this effect has a saving throw.
    /// </summary>
    public bool HasSave => SaveDC.HasValue && !string.IsNullOrEmpty(SaveAttribute);

    // ===== Constructors =====

    /// <summary>
    /// Private constructor for factory methods.
    /// </summary>
    private TrapEffect() { }

    // ===== Factory Methods =====

    /// <summary>
    /// Creates a trap effect from a definition.
    /// </summary>
    /// <param name="definition">The effect definition.</param>
    /// <returns>A new TrapEffect.</returns>
    /// <exception cref="ArgumentNullException">Thrown when definition is null.</exception>
    public static TrapEffect FromDefinition(TrapEffectDefinition definition)
    {
        ArgumentNullException.ThrowIfNull(definition);

        return new TrapEffect
        {
            DamageDice = definition.DamageDice,
            DamageType = definition.DamageType,
            StatusEffects = definition.StatusEffects?.ToList() ?? new List<string>(),
            StatusDuration = definition.StatusDuration > 0 ? definition.StatusDuration : 3,
            SaveDC = definition.SaveDC,
            SaveAttribute = definition.SaveType,
            SaveHalvesDamage = definition.SaveHalvesDamage,
            TriggerMessage = definition.TriggerMessage,
            AlertsMonsters = definition.AlertsMonsters,
            AlertRadius = definition.AlertRadius
        };
    }

    /// <summary>
    /// Creates a damage-only trap effect.
    /// </summary>
    /// <param name="damageDice">The damage dice expression (e.g., "2d6").</param>
    /// <param name="damageType">The damage type (e.g., "piercing").</param>
    /// <param name="saveDC">Optional save DC to reduce damage.</param>
    /// <param name="saveAttribute">Optional save attribute.</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect Damage(
        string damageDice,
        string damageType,
        int? saveDC = null,
        string? saveAttribute = null) => new()
    {
        DamageDice = damageDice,
        DamageType = damageType,
        SaveDC = saveDC,
        SaveAttribute = saveAttribute
    };

    /// <summary>
    /// Creates a status-only trap effect.
    /// </summary>
    /// <param name="statusEffects">The status effects to apply.</param>
    /// <param name="duration">The duration in turns.</param>
    /// <param name="saveDC">Optional save DC to avoid effects.</param>
    /// <param name="saveAttribute">Optional save attribute.</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect Status(
        IEnumerable<string> statusEffects,
        int duration = 3,
        int? saveDC = null,
        string? saveAttribute = null) => new()
    {
        StatusEffects = statusEffects.ToList(),
        StatusDuration = duration,
        SaveDC = saveDC,
        SaveAttribute = saveAttribute,
        SaveHalvesDamage = false // Save negates status, not halves
    };

    /// <summary>
    /// Creates an alert-only trap effect.
    /// </summary>
    /// <param name="message">The alert message.</param>
    /// <param name="alertRadius">The radius in rooms.</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect Alert(string message, int alertRadius = 0) => new()
    {
        TriggerMessage = message,
        AlertsMonsters = true,
        AlertRadius = alertRadius
    };

    /// <summary>
    /// Creates a combined damage and status effect.
    /// </summary>
    /// <param name="damageDice">The damage dice expression.</param>
    /// <param name="damageType">The damage type.</param>
    /// <param name="statusEffects">The status effects to apply.</param>
    /// <param name="saveDC">The save DC.</param>
    /// <param name="saveAttribute">The save attribute.</param>
    /// <param name="saveHalvesDamage">Whether save halves (true) or negates (false).</param>
    /// <returns>A new TrapEffect.</returns>
    public static TrapEffect DamageAndStatus(
        string damageDice,
        string damageType,
        IEnumerable<string> statusEffects,
        int saveDC,
        string saveAttribute,
        bool saveHalvesDamage = true) => new()
    {
        DamageDice = damageDice,
        DamageType = damageType,
        StatusEffects = statusEffects.ToList(),
        SaveDC = saveDC,
        SaveAttribute = saveAttribute,
        SaveHalvesDamage = saveHalvesDamage
    };

    /// <inheritdoc />
    public override string ToString()
    {
        var parts = new List<string>();
        if (DealsDamage) parts.Add($"{DamageDice} {DamageType}");
        if (AppliesStatus) parts.Add(string.Join(", ", StatusEffects));
        if (AlertsMonsters) parts.Add("alerts");
        return string.Join(" + ", parts);
    }
}
```

#### 2. TrapEffectResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapEffectResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of applying a trap's effect to a target.
/// </summary>
/// <remarks>
/// Captures all outcomes including damage dealt, saves made, and status
/// effects applied. Provides factory methods for common result scenarios.
/// </remarks>
public readonly record struct TrapEffectResult
{
    /// <summary>
    /// Gets the total damage dealt.
    /// </summary>
    public int DamageDealt { get; init; }

    /// <summary>
    /// Gets the damage type.
    /// </summary>
    public string? DamageType { get; init; }

    /// <summary>
    /// Gets the individual damage dice rolls.
    /// </summary>
    public IReadOnlyList<int> DamageRolls { get; init; }

    /// <summary>
    /// Gets whether a save was attempted.
    /// </summary>
    public bool SaveAttempted { get; init; }

    /// <summary>
    /// Gets whether the save was successful.
    /// </summary>
    public bool SaveSucceeded { get; init; }

    /// <summary>
    /// Gets the save roll total.
    /// </summary>
    public int? SaveRoll { get; init; }

    /// <summary>
    /// Gets the save DC.
    /// </summary>
    public int? SaveDC { get; init; }

    /// <summary>
    /// Gets the status effects applied.
    /// </summary>
    public IReadOnlyList<string> StatusEffectsApplied { get; init; }

    /// <summary>
    /// Gets whether monsters were alerted.
    /// </summary>
    public bool MonstersAlerted { get; init; }

    /// <summary>
    /// Gets the message to display.
    /// </summary>
    public string Message { get; init; }

    // ===== Factory Methods =====

    /// <summary>
    /// Creates a result for damage dealt.
    /// </summary>
    public static TrapEffectResult DamageResult(
        int damage,
        string damageType,
        IEnumerable<int> rolls,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null) => new()
    {
        DamageDealt = damage,
        DamageType = damageType,
        DamageRolls = rolls.ToList(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        StatusEffectsApplied = Array.Empty<string>(),
        MonstersAlerted = false,
        Message = message
    };

    /// <summary>
    /// Creates a result for status effects applied.
    /// </summary>
    public static TrapEffectResult StatusResult(
        IEnumerable<string> effects,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null) => new()
    {
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        StatusEffectsApplied = effects.ToList(),
        MonstersAlerted = false,
        Message = message
    };

    /// <summary>
    /// Creates a result for an alert effect.
    /// </summary>
    public static TrapEffectResult AlertResult(string message) => new()
    {
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = false,
        SaveSucceeded = false,
        StatusEffectsApplied = Array.Empty<string>(),
        MonstersAlerted = true,
        Message = message
    };

    /// <summary>
    /// Creates a combined result with damage, status, and optionally alert.
    /// </summary>
    public static TrapEffectResult Combined(
        int damage,
        string? damageType,
        IEnumerable<int> rolls,
        IEnumerable<string> statusEffects,
        bool monstersAlerted,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null) => new()
    {
        DamageDealt = damage,
        DamageType = damageType,
        DamageRolls = rolls.ToList(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        StatusEffectsApplied = statusEffects.ToList(),
        MonstersAlerted = monstersAlerted,
        Message = message
    };

    /// <summary>
    /// Creates a result where the save completely negated the effect.
    /// </summary>
    public static TrapEffectResult SavedCompletely(
        int saveRoll,
        int saveDC,
        string message) => new()
    {
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = true,
        SaveSucceeded = true,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        StatusEffectsApplied = Array.Empty<string>(),
        MonstersAlerted = false,
        Message = message
    };
}
```

#### 3. TrapDisarmResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapDisarmResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of attempting to disarm a trap.
/// </summary>
/// <remarks>
/// Captures the skill check outcome and any consequences such as
/// safely failing, triggering the trap, or successfully disarming.
/// </remarks>
public readonly record struct TrapDisarmResult
{
    /// <summary>
    /// Gets whether the disarm was successful.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the message to display.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the skill check roll total.
    /// </summary>
    public int RollTotal { get; init; }

    /// <summary>
    /// Gets the disarm DC.
    /// </summary>
    public int DisarmDC { get; init; }

    /// <summary>
    /// Gets the individual dice rolls.
    /// </summary>
    public IReadOnlyList<int> Rolls { get; init; }

    /// <summary>
    /// Gets the skill modifier applied.
    /// </summary>
    public int SkillModifier { get; init; }

    /// <summary>
    /// Gets whether failure triggered the trap.
    /// </summary>
    public bool TriggeredTrap { get; init; }

    /// <summary>
    /// Gets the trap effect result if the trap was triggered.
    /// </summary>
    public TrapEffectResult? TrapEffect { get; init; }

    /// <summary>
    /// Gets whether the trap can be retried.
    /// </summary>
    public bool CanRetry { get; init; }

    // ===== Factory Methods =====

    /// <summary>
    /// Creates a successful disarm result.
    /// </summary>
    public static TrapDisarmResult Succeeded(
        int rollTotal,
        int disarmDC,
        IEnumerable<int> rolls,
        int modifier,
        string message) => new()
    {
        Success = true,
        Message = message,
        RollTotal = rollTotal,
        DisarmDC = disarmDC,
        Rolls = rolls.ToList(),
        SkillModifier = modifier,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = false
    };

    /// <summary>
    /// Creates a failed disarm result that didn't trigger the trap.
    /// </summary>
    public static TrapDisarmResult FailedSafely(
        int rollTotal,
        int disarmDC,
        IEnumerable<int> rolls,
        int modifier,
        string message) => new()
    {
        Success = false,
        Message = message,
        RollTotal = rollTotal,
        DisarmDC = disarmDC,
        Rolls = rolls.ToList(),
        SkillModifier = modifier,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = true
    };

    /// <summary>
    /// Creates a failed disarm result that triggered the trap.
    /// </summary>
    public static TrapDisarmResult FailedAndTriggered(
        int rollTotal,
        int disarmDC,
        IEnumerable<int> rolls,
        int modifier,
        TrapEffectResult effect,
        string message) => new()
    {
        Success = false,
        Message = message,
        RollTotal = rollTotal,
        DisarmDC = disarmDC,
        Rolls = rolls.ToList(),
        SkillModifier = modifier,
        TriggeredTrap = true,
        TrapEffect = effect,
        CanRetry = false
    };

    /// <summary>
    /// Creates a result for when the trap cannot be disarmed.
    /// </summary>
    public static TrapDisarmResult CannotDisarm(string trapName) => new()
    {
        Success = false,
        Message = $"The {trapName} cannot be disarmed.",
        RollTotal = 0,
        DisarmDC = 0,
        Rolls = Array.Empty<int>(),
        SkillModifier = 0,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = false
    };

    /// <summary>
    /// Creates a result for when the trap is not detected.
    /// </summary>
    public static TrapDisarmResult NotDetected() => new()
    {
        Success = false,
        Message = "You don't see any trap to disarm here.",
        RollTotal = 0,
        DisarmDC = 0,
        Rolls = Array.Empty<int>(),
        SkillModifier = 0,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = false
    };

    /// <summary>
    /// Creates a result for when the trap is already disarmed.
    /// </summary>
    public static TrapDisarmResult AlreadyDisarmed(string trapName) => new()
    {
        Success = false,
        Message = $"The {trapName} has already been disarmed.",
        RollTotal = 0,
        DisarmDC = 0,
        Rolls = Array.Empty<int>(),
        SkillModifier = 0,
        TriggeredTrap = false,
        TrapEffect = null,
        CanRetry = false
    };
}
```

#### 4. Trap.cs Updates (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Trap.cs`

Add Effect property and update FromDefinition:

```csharp
// Add property after Keywords:

/// <summary>
/// Gets the effect that occurs when this trap triggers.
/// </summary>
/// <remarks>
/// May be null if the trap has no effect configured.
/// Effects are loaded from TrapEffectDefinition.
/// </remarks>
public TrapEffect? Effect { get; private set; }

/// <summary>
/// Gets whether this trap has an effect configured.
/// </summary>
public bool HasEffect => Effect != null;

// Add method after ProcessTurnTick:

/// <summary>
/// Sets the trap effect.
/// </summary>
/// <param name="effect">The effect to set.</param>
public void SetEffect(TrapEffect effect)
{
    Effect = effect;
}

// Update FromDefinition method:

/// <summary>
/// Creates a trap from a definition.
/// </summary>
/// <param name="definition">The trap definition.</param>
/// <returns>A new Trap instance.</returns>
/// <exception cref="ArgumentNullException">Thrown when definition is null.</exception>
public static Trap FromDefinition(TrapDefinition definition)
{
    ArgumentNullException.ThrowIfNull(definition);

    var trap = new Trap
    {
        Id = Guid.NewGuid(),
        DefinitionId = definition.Id.ToLowerInvariant(),
        Name = definition.Name,
        Description = definition.Description ?? string.Empty,
        TriggerType = definition.TriggerType,
        DetectionDC = definition.DetectionDC,
        DisarmDC = definition.DisarmDC,
        CanBeDisarmed = definition.CanBeDisarmed,
        Resets = definition.Resets,
        ResetDelay = definition.Resets ? definition.ResetDelay : -1,
        AttachedObjectId = definition.AttachedObjectId,
        Keywords = definition.Keywords.Count > 0
            ? definition.Keywords.ToList()
            : new List<string> { definition.Name.ToLowerInvariant() }
    };

    // Set effect if configured
    if (definition.Effect != null)
    {
        trap.Effect = TrapEffect.FromDefinition(definition.Effect);
    }

    return trap;
}
```

#### 5. TrapEffectDefinition Updates (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Definitions/TrapDefinition.cs`

Update the TrapEffectDefinition class:

```csharp
/// <summary>
/// Configuration for trap effects loaded from JSON.
/// </summary>
/// <remarks>
/// Defines the consequences of triggering a trap including damage,
/// status effects, saving throws, and alerts.
/// </remarks>
public class TrapEffectDefinition
{
    // ===== Damage Configuration =====

    /// <summary>
    /// Gets or sets the damage dice expression (e.g., "2d6").
    /// </summary>
    public string? DamageDice { get; set; }

    /// <summary>
    /// Gets or sets the damage type (e.g., "piercing", "fire").
    /// </summary>
    public string? DamageType { get; set; }

    // ===== Status Effect Configuration =====

    /// <summary>
    /// Gets or sets status effects applied by the trap.
    /// </summary>
    public List<string> StatusEffects { get; set; } = new();

    /// <summary>
    /// Gets or sets the duration of status effects in turns.
    /// </summary>
    public int StatusDuration { get; set; } = 3;

    // ===== Saving Throw Configuration =====

    /// <summary>
    /// Gets or sets the save DC to reduce/avoid damage.
    /// </summary>
    public int? SaveDC { get; set; }

    /// <summary>
    /// Gets or sets the save type (attribute name).
    /// </summary>
    /// <remarks>
    /// Common values: "Agility", "Fortitude", "Will".
    /// </remarks>
    public string? SaveType { get; set; }

    /// <summary>
    /// Gets or sets whether a successful save halves damage (true) or negates it (false).
    /// </summary>
    public bool SaveHalvesDamage { get; set; } = true;

    // ===== Message Configuration =====

    /// <summary>
    /// Gets or sets a message displayed when the trap triggers.
    /// </summary>
    public string? TriggerMessage { get; set; }

    // ===== Alert Configuration =====

    /// <summary>
    /// Gets or sets whether this trap alerts nearby monsters.
    /// </summary>
    public bool AlertsMonsters { get; set; }

    /// <summary>
    /// Gets or sets the alert radius in rooms (0 = current room only).
    /// </summary>
    public int AlertRadius { get; set; }
}
```

#### 6. InteractiveObject Updates (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/InteractiveObject.cs`

Add trap attachment support:

```csharp
// Add property after existing properties:

/// <summary>
/// Gets the ID of a trap attached to this object (for trapped containers/doors).
/// </summary>
/// <remarks>
/// When set, opening/touching this object may trigger the attached trap.
/// The trap must exist in the room's Traps collection with a matching DefinitionId.
/// </remarks>
public string? AttachedTrapId { get; private set; }

/// <summary>
/// Gets whether this object has an attached trap.
/// </summary>
public bool HasAttachedTrap => !string.IsNullOrEmpty(AttachedTrapId);

// Add methods:

/// <summary>
/// Attaches a trap to this object.
/// </summary>
/// <param name="trapDefinitionId">The trap definition ID to attach.</param>
/// <exception cref="ArgumentException">Thrown when trapDefinitionId is null or empty.</exception>
public void AttachTrap(string trapDefinitionId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(trapDefinitionId);
    AttachedTrapId = trapDefinitionId.ToLowerInvariant();
}

/// <summary>
/// Removes any attached trap from this object.
/// </summary>
public void RemoveAttachedTrap()
{
    AttachedTrapId = null;
}
```

---

### Application Layer

#### 7. ITrapService Interface Updates (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITrapService.cs`

Add new methods:

```csharp
// Add these methods to the interface:

/// <summary>
/// Attempts to detect hidden traps in a room using a Perception check.
/// </summary>
/// <param name="room">The room to search.</param>
/// <param name="player">The player searching.</param>
/// <returns>The detection result including which traps were found.</returns>
/// <remarks>
/// Performs a single Perception skill check and compares the result
/// against each hidden trap's DetectionDC. Traps with DC lower than or
/// equal to the roll are detected.
/// </remarks>
TrapDetectionResult SearchForTraps(Room room, Player player);

/// <summary>
/// Performs a passive perception check when entering a room.
/// </summary>
/// <param name="room">The room being entered.</param>
/// <param name="player">The player entering.</param>
/// <returns>The detection result (only includes automatically detected traps).</returns>
/// <remarks>
/// Uses passive perception (10 + Wits + skill bonus) without rolling.
/// Only detects traps with DC lower than or equal to passive score.
/// Does not notify player of traps they failed to detect passively.
/// </remarks>
TrapDetectionResult PassivePerceptionCheck(Room room, Player player);

/// <summary>
/// Gets the passive perception score for a player.
/// </summary>
/// <param name="player">The player.</param>
/// <returns>The passive perception score (10 + Wits modifier + Perception bonus).</returns>
int GetPassivePerception(Player player);

/// <summary>
/// Attempts to disarm a detected trap.
/// </summary>
/// <param name="trap">The trap to disarm.</param>
/// <param name="player">The player attempting to disarm.</param>
/// <returns>The disarm result including success/failure and any consequences.</returns>
/// <remarks>
/// <para>Performs a DisableDevice skill check against the trap's DisarmDC.</para>
/// <para>Success: Trap transitions to Disarmed state.</para>
/// <para>Failure by less than 5: Can retry.</para>
/// <para>Failure by 5 or more: Trap triggers.</para>
/// </remarks>
TrapDisarmResult AttemptDisarm(Trap trap, Player player);

/// <summary>
/// Applies a trap's effect to a target.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <param name="player">The player affected.</param>
/// <returns>The effect result including damage, saves, and status effects.</returns>
TrapEffectResult ApplyTrapEffect(Trap trap, Player player);

/// <summary>
/// Checks for and triggers traps when a player enters a room.
/// </summary>
/// <param name="room">The room being entered.</param>
/// <param name="player">The player entering.</param>
/// <returns>The trigger and effect results if a trap was triggered, null otherwise.</returns>
/// <remarks>
/// Checks for Step and Proximity traps. Only hidden traps trigger automatically;
/// detected traps are assumed to be avoided by the player.
/// </remarks>
(TrapTriggerResult Trigger, TrapEffectResult? Effect)? CheckEntryTraps(Room room, Player player);

/// <summary>
/// Checks for and triggers traps when opening an object.
/// </summary>
/// <param name="room">The room containing the object.</param>
/// <param name="objectId">The object being opened.</param>
/// <param name="player">The player opening the object.</param>
/// <returns>The trigger and effect results if a trap was triggered, null otherwise.</returns>
/// <remarks>
/// Checks for Open/Touch trigger traps attached to the specified object.
/// Triggers even if detected (player opens anyway).
/// </remarks>
(TrapTriggerResult Trigger, TrapEffectResult? Effect)? CheckOpenTraps(Room room, string objectId, Player player);
```

#### 8. TrapService Implementation Updates (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/TrapService.cs`

Add new implementations (key methods shown):

```csharp
// Update constructor to include dependencies:

private readonly ILogger<TrapService> _logger;
private readonly IDiceService _diceService;
private readonly ISkillCheckService _skillCheckService;
private readonly IStatusEffectService _statusEffectService;

// Passive perception base value
private const int PassivePerceptionBase = 10;

// Threshold below DC where failed disarm triggers trap
private const int DisarmTriggerThreshold = 5;

/// <summary>
/// Creates a new TrapService instance.
/// </summary>
public TrapService(
    ILogger<TrapService> logger,
    IDiceService diceService,
    ISkillCheckService skillCheckService,
    IStatusEffectService statusEffectService)
{
    _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
    _skillCheckService = skillCheckService ?? throw new ArgumentNullException(nameof(skillCheckService));
    _statusEffectService = statusEffectService ?? throw new ArgumentNullException(nameof(statusEffectService));
}

/// <inheritdoc />
public TrapDetectionResult SearchForTraps(Room room, Player player)
{
    ArgumentNullException.ThrowIfNull(room);
    ArgumentNullException.ThrowIfNull(player);

    var hiddenTraps = room.GetHiddenTraps().ToList();
    if (!hiddenTraps.Any())
    {
        _logger.LogDebug("SearchForTraps: No hidden traps in room {RoomId}", room.Id);
        return TrapDetectionResult.NoHiddenTraps();
    }

    // Perform Perception skill check (no fixed DC - compare against each trap)
    var checkResult = _skillCheckService.PerformCheck(player, "Perception", 0);
    
    _logger.LogInformation(
        "SearchForTraps: Player rolled {Total} for Perception check in room {RoomId}",
        checkResult.Total, room.Id);

    var detectedNames = new List<string>();
    var remainingHidden = 0;

    foreach (var trap in hiddenTraps)
    {
        if (checkResult.Total >= trap.DetectionDC)
        {
            trap.Detect();
            detectedNames.Add(trap.Name);
            _logger.LogInformation(
                "Player detected {TrapName} (rolled {Roll} vs DC {DC})",
                trap.Name, checkResult.Total, trap.DetectionDC);
        }
        else
        {
            remainingHidden++;
            _logger.LogDebug(
                "Player failed to detect {TrapName} (rolled {Roll} vs DC {DC})",
                trap.Name, checkResult.Total, trap.DetectionDC);
        }
    }

    if (detectedNames.Any())
    {
        var message = BuildDetectionMessage(checkResult, detectedNames);
        return TrapDetectionResult.Detected(detectedNames, message, remainingHidden);
    }

    var failMessage = $"Perception Check: [{string.Join(",", checkResult.Rolls)}] + {checkResult.Modifier} = {checkResult.Total}\n" +
                      "You search carefully but don't find any traps.";
    return TrapDetectionResult.NoneDetected(failMessage, remainingHidden);
}

/// <inheritdoc />
public int GetPassivePerception(Player player)
{
    ArgumentNullException.ThrowIfNull(player);
    
    var witsModifier = player.GetAttributeModifier("Wits");
    var perceptionBonus = player.GetSkillBonus("Perception");
    var passive = PassivePerceptionBase + witsModifier + perceptionBonus;
    
    _logger.LogDebug(
        "PassivePerception for player: {Base} + {Wits} + {Skill} = {Total}",
        PassivePerceptionBase, witsModifier, perceptionBonus, passive);
    
    return passive;
}

/// <inheritdoc />
public TrapDisarmResult AttemptDisarm(Trap trap, Player player)
{
    ArgumentNullException.ThrowIfNull(trap);
    ArgumentNullException.ThrowIfNull(player);

    // Validate trap state
    if (trap.State != TrapState.Detected)
    {
        if (trap.State == TrapState.Hidden)
            return TrapDisarmResult.NotDetected();
        if (trap.State == TrapState.Disarmed)
            return TrapDisarmResult.AlreadyDisarmed(trap.Name);
        if (trap.State == TrapState.Triggered)
            return TrapDisarmResult.AlreadyDisarmed(trap.Name) with
            {
                Message = $"The {trap.Name} has already been triggered."
            };
    }

    if (!trap.CanBeDisarmed)
    {
        _logger.LogDebug("AttemptDisarm: {TrapName} cannot be disarmed", trap.Name);
        return TrapDisarmResult.CannotDisarm(trap.Name);
    }

    // Perform skill check
    var checkResult = _skillCheckService.PerformCheck(player, "DisableDevice", trap.DisarmDC);
    var rollInfo = $"[{string.Join(",", checkResult.Rolls)}] + {checkResult.Modifier} = {checkResult.Total} vs DC {trap.DisarmDC}";

    if (checkResult.Success)
    {
        trap.Disarm();
        _logger.LogInformation(
            "Player successfully disarmed {TrapName} ({RollInfo})",
            trap.Name, rollInfo);

        return TrapDisarmResult.Succeeded(
            checkResult.Total,
            trap.DisarmDC,
            checkResult.Rolls,
            checkResult.Modifier,
            $"Disarm Check: {rollInfo}\n\nYou carefully disarm the {trap.Name}.");
    }

    // Failed - check if we triggered the trap
    var failedBy = trap.DisarmDC - checkResult.Total;

    if (failedBy >= DisarmTriggerThreshold)
    {
        // Critical failure - trigger the trap
        trap.Trigger();
        var effectResult = ApplyTrapEffectInternal(trap, player);

        _logger.LogInformation(
            "Player critically failed disarm on {TrapName}, triggering it ({RollInfo})",
            trap.Name, rollInfo);

        return TrapDisarmResult.FailedAndTriggered(
            checkResult.Total,
            trap.DisarmDC,
            checkResult.Rolls,
            checkResult.Modifier,
            effectResult,
            $"Disarm Check: {rollInfo}\n\nYour hand slips and you trigger the {trap.Name}!\n\n{effectResult.Message}");
    }

    // Failed but didn't trigger
    _logger.LogInformation(
        "Player failed to disarm {TrapName} but didn't trigger it ({RollInfo})",
        trap.Name, rollInfo);

    return TrapDisarmResult.FailedSafely(
        checkResult.Total,
        trap.DisarmDC,
        checkResult.Rolls,
        checkResult.Modifier,
        $"Disarm Check: {rollInfo}\n\nYou fail to disarm the {trap.Name}, but manage to avoid triggering it.");
}

/// <inheritdoc />
public TrapEffectResult ApplyTrapEffect(Trap trap, Player player)
{
    ArgumentNullException.ThrowIfNull(trap);
    ArgumentNullException.ThrowIfNull(player);
    return ApplyTrapEffectInternal(trap, player);
}

private TrapEffectResult ApplyTrapEffectInternal(Trap trap, Player player)
{
    if (trap.Effect == null)
    {
        _logger.LogDebug("ApplyTrapEffect: {TrapName} has no effect configured", trap.Name);
        return TrapEffectResult.AlertResult($"The {trap.Name} activates!");
    }

    var effect = trap.Effect;
    var messageBuilder = new StringBuilder();
    var totalDamage = 0;
    var damageRolls = new List<int>();
    var appliedEffects = new List<string>();
    var saveAttempted = false;
    var saveSucceeded = false;
    int? saveRoll = null;

    // Add trigger message
    messageBuilder.AppendLine(!string.IsNullOrEmpty(effect.TriggerMessage) 
        ? effect.TriggerMessage 
        : $"The {trap.Name} activates!");

    // Handle saving throw
    if (effect.HasSave)
    {
        saveAttempted = true;
        var saveResult = PerformSavingThrow(player, effect.SaveAttribute!, effect.SaveDC!.Value);
        saveRoll = saveResult.Total;
        saveSucceeded = saveResult.Success;

        messageBuilder.AppendLine();
        messageBuilder.AppendLine($"Saving Throw ({effect.SaveAttribute}): [{string.Join(",", saveResult.Rolls)}] + {saveResult.Modifier} = {saveResult.Total} vs DC {effect.SaveDC}");

        if (saveSucceeded)
        {
            if (effect.SaveHalvesDamage && effect.DealsDamage)
            {
                messageBuilder.AppendLine("Save successful! Damage halved.");
            }
            else
            {
                messageBuilder.AppendLine("Save successful! You avoid the effect.");
                _logger.LogInformation(
                    "Player saved completely against {TrapName} (rolled {Roll} vs DC {DC})",
                    trap.Name, saveResult.Total, effect.SaveDC);
                return TrapEffectResult.SavedCompletely(saveResult.Total, effect.SaveDC!.Value, messageBuilder.ToString().TrimEnd());
            }
        }
        else
        {
            messageBuilder.AppendLine("Save failed!");
        }
    }

    // Apply damage
    if (effect.DealsDamage)
    {
        var damageResult = _diceService.Roll(effect.DamageDice!);
        damageRolls.AddRange(damageResult.Rolls);
        totalDamage = damageResult.Total;

        // Halve damage on successful save
        if (saveSucceeded && effect.SaveHalvesDamage)
        {
            totalDamage /= 2;
        }

        player.TakeDamage(totalDamage, effect.DamageType);

        messageBuilder.AppendLine();
        messageBuilder.AppendLine($"Damage: [{string.Join(",", damageResult.Rolls)}] = {damageResult.Total}{(saveSucceeded ? " / 2 = " + totalDamage : "")} {effect.DamageType} damage");

        _logger.LogInformation(
            "Trap {TrapName} dealt {Damage} {DamageType} damage to player",
            trap.Name, totalDamage, effect.DamageType);
    }

    // Apply status effects (only if save failed or no save)
    if (effect.AppliesStatus && !saveSucceeded)
    {
        foreach (var statusEffect in effect.StatusEffects)
        {
            _statusEffectService.ApplyEffect(player, statusEffect, effect.StatusDuration);
            appliedEffects.Add(statusEffect);
        }

        if (appliedEffects.Any())
        {
            messageBuilder.AppendLine();
            messageBuilder.AppendLine($"You are afflicted with: {string.Join(", ", appliedEffects)}");
            _logger.LogInformation(
                "Trap {TrapName} applied status effects: {Effects}",
                trap.Name, string.Join(", ", appliedEffects));
        }
    }

    // Handle monster alert
    if (effect.AlertsMonsters)
    {
        messageBuilder.AppendLine();
        messageBuilder.AppendLine("The noise alerts nearby creatures!");
        _logger.LogInformation("Trap {TrapName} alerted monsters in radius {Radius}", trap.Name, effect.AlertRadius);
    }

    return TrapEffectResult.Combined(
        totalDamage,
        effect.DamageType,
        damageRolls,
        appliedEffects,
        effect.AlertsMonsters,
        messageBuilder.ToString().TrimEnd(),
        saveAttempted,
        saveSucceeded,
        saveRoll,
        effect.SaveDC);
}

/// <inheritdoc />
public (TrapTriggerResult Trigger, TrapEffectResult? Effect)? CheckEntryTraps(Room room, Player player)
{
    ArgumentNullException.ThrowIfNull(room);
    ArgumentNullException.ThrowIfNull(player);

    // Check for Step and Proximity traps
    var entryTraps = room.GetTrapsByTriggerType(TriggerType.Step)
        .Concat(room.GetTrapsByTriggerType(TriggerType.Proximity))
        .Where(t => t.IsActive && t.State == TrapState.Hidden) // Only hidden traps trigger on entry
        .ToList();

    _logger.LogDebug("CheckEntryTraps: Found {Count} hidden entry traps in room {RoomId}", entryTraps.Count, room.Id);

    foreach (var trap in entryTraps)
    {
        var triggerResult = TriggerTrap(trap);
        var effectResult = ApplyTrapEffectInternal(trap, player);
        return (triggerResult, effectResult);
    }

    return null;
}

private SaveResult PerformSavingThrow(Player player, string attribute, int dc)
{
    var modifier = player.GetAttributeModifier(attribute);
    var roll = _diceService.Roll("1d20");
    var total = roll.Total + modifier;
    
    _logger.LogDebug(
        "SavingThrow: Player rolled {Roll} + {Mod} = {Total} vs DC {DC} ({Attribute})",
        roll.Total, modifier, total, dc, attribute);

    return new SaveResult
    {
        Total = total,
        Rolls = roll.Rolls.ToList(),
        Modifier = modifier,
        DC = dc,
        Success = total >= dc
    };
}

private record SaveResult
{
    public int Total { get; init; }
    public List<int> Rolls { get; init; } = new();
    public int Modifier { get; init; }
    public int DC { get; init; }
    public bool Success { get; init; }
}
```

---

## Flow Diagrams

### Trap Detection Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        TRAP DETECTION FLOW                                   │
└─────────────────────────────────────────────────────────────────────────────┘

    Player enters room
            │
            ▼
┌───────────────────────┐
│  Has hidden traps?    │
└───────────┬───────────┘
       Yes  │   No
            │    └──────► [No action]
            ▼
┌───────────────────────┐
│ Calculate Passive     │
│   10 + Wits + Skill   │
└───────────┬───────────┘
            │
            ▼
┌───────────────────────┐
│ For each hidden trap: │
│   Passive >= DC?      │
└───────────┬───────────┘
       Yes  │   No
            │    └──────► [Trap remains hidden]
            ▼
┌───────────────────────┐
│  trap.Detect()        │
│  "Your keen senses    │
│   notice danger!"     │
└───────────────────────┘


    Player uses "search"
            │
            ▼
┌───────────────────────┐
│  SkillCheckService    │
│   .PerformCheck()     │
│  "Perception"         │
└───────────┬───────────┘
            │
            ▼
┌───────────────────────┐
│ For each hidden trap: │
│   Roll >= DC?         │
└───────────┬───────────┘
       Yes  │   No
            │    └──────► "Search but find nothing"
            ▼
┌───────────────────────┐
│  trap.Detect()        │
│  Show detection msg   │
│  with roll details    │
└───────────────────────┘
```

### Trap Disarm Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        TRAP DISARM FLOW                                      │
└─────────────────────────────────────────────────────────────────────────────┘

    Player uses "disarm <trap>"
            │
            ▼
┌───────────────────────┐
│  trap.State ==        │
│    Detected?          │────No────► Return error message
└───────────┬───────────┘
            │ Yes
            ▼
┌───────────────────────┐
│  trap.CanBeDisarmed?  │────No────► "Cannot be disarmed"
└───────────┬───────────┘
            │ Yes
            ▼
┌───────────────────────┐
│  SkillCheckService    │
│   .PerformCheck()     │
│  "DisableDevice"      │
│   vs DisarmDC         │
└───────────┬───────────┘
            │
            ▼
┌───────────────────────┐
│  Roll >= DC?          │
└───────────┬───────────┘
       Yes  │   No
            │    │
            ▼    │
┌─────────────┐  │
│ trap.Disarm │  │
│ SUCCESS!    │  │
└─────────────┘  │
                 ▼
        ┌───────────────────────┐
        │  Failed by >= 5?      │
        └───────┬───────────────┘
           Yes  │   No
                │    │
                ▼    ▼
     ┌─────────────────────┐   ┌─────────────────────┐
     │ trap.Trigger()      │   │ FailedSafely        │
     │ ApplyTrapEffect()   │   │ CanRetry = true     │
     │ FailedAndTriggered  │   │ "Avoid triggering"  │
     └─────────────────────┘   └─────────────────────┘
```

### Trap Effect Application Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      TRAP EFFECT APPLICATION FLOW                            │
└─────────────────────────────────────────────────────────────────────────────┘

    Trap triggered
            │
            ▼
┌───────────────────────┐
│  trap.Effect == null? │────Yes────► AlertResult("activates!")
└───────────┬───────────┘
            │ No
            ▼
┌───────────────────────┐
│  effect.HasSave?      │
└───────────┬───────────┘
       Yes  │   No
            │    └──────────────┐
            ▼                   │
┌───────────────────────┐       │
│  PerformSavingThrow() │       │
│  d20 + attribute mod  │       │
└───────────┬───────────┘       │
            │                   │
            ▼                   │
┌───────────────────────┐       │
│  Save >= DC?          │       │
└───────────┬───────────┘       │
       Yes  │   No              │
            │    │              │
            ▼    │              │
┌─────────────┐  │              │
│SaveHalves?  │  │              │
│ Yes: /2 dmg │  │              │
│ No: negate  │  │              │
└─────────────┘  │              │
                 ▼              ▼
        ┌───────────────────────────────┐
        │         Apply Effects         │
        ├───────────────────────────────┤
        │ • DealsDamage?                │
        │   DiceService.Roll(dice)      │
        │   player.TakeDamage()         │
        │                               │
        │ • AppliesStatus? (!saved)     │
        │   StatusEffectService.Apply() │
        │                               │
        │ • AlertsMonsters?             │
        │   Set alert flag              │
        └───────────────────────────────┘
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   └── ValueObjects/
│       ├── TrapEffectTests.cs           (5 tests)
│       ├── TrapEffectResultTests.cs     (4 tests)
│       └── TrapDisarmResultTests.cs     (5 tests)
├── RuneAndRust.Application.UnitTests/
│   └── Services/
│       ├── TrapServiceDetectionTests.cs (6 tests)
│       ├── TrapServiceDisarmTests.cs    (6 tests)
│       ├── TrapServiceEffectTests.cs    (5 tests)
│       └── TrapIntegrationTests.cs      (4 tests)
```

### Test Specifications

#### TrapEffectTests.cs (5 tests)

| Test Name | Description |
|-----------|-------------|
| `FromDefinition_CreatesCorrectEffect` | Definition mapping |
| `Damage_CreatesDamageOnlyEffect` | Damage factory |
| `Status_CreatesStatusOnlyEffect` | Status factory |
| `Alert_CreatesAlertOnlyEffect` | Alert factory |
| `DamageAndStatus_CreatesCombinedEffect` | Combined factory |

#### TrapEffectResultTests.cs (4 tests)

| Test Name | Description |
|-----------|-------------|
| `DamageResult_CapturesAllFields` | Damage result creation |
| `StatusResult_CapturesAllFields` | Status result creation |
| `SavedCompletely_ZeroDamage` | Complete save result |
| `Combined_AllFieldsPopulated` | Combined result |

#### TrapDisarmResultTests.cs (5 tests)

| Test Name | Description |
|-----------|-------------|
| `Succeeded_HasCorrectValues` | Success result |
| `FailedSafely_AllowsRetry` | Safe failure |
| `FailedAndTriggered_IncludesEffect` | Triggered failure |
| `CannotDisarm_HasCorrectMessage` | Cannot disarm |
| `NotDetected_HasCorrectMessage` | Not detected |

#### TrapServiceDetectionTests.cs (6 tests)

| Test Name | Description |
|-----------|-------------|
| `SearchForTraps_WithHiddenTraps_PerformsCheck` | Search performs check |
| `SearchForTraps_SuccessfulRoll_DetectsTraps` | Detection on success |
| `SearchForTraps_FailedRoll_DoesNotDetect` | No detection on fail |
| `PassivePerceptionCheck_HighPassive_DetectsEasyTraps` | Passive detection |
| `PassivePerceptionCheck_LowPassive_MissesTraps` | Passive miss |
| `GetPassivePerception_CalculatesCorrectly` | Passive calculation |

#### TrapServiceDisarmTests.cs (6 tests)

| Test Name | Description |
|-----------|-------------|
| `AttemptDisarm_SuccessfulCheck_DisarmsTrap` | Successful disarm |
| `AttemptDisarm_FailedCheck_AllowsRetry` | Safe failure |
| `AttemptDisarm_CriticalFailure_TriggersTrap` | Triggers on crit fail |
| `AttemptDisarm_HiddenTrap_ReturnsNotDetected` | Cannot disarm hidden |
| `AttemptDisarm_AlreadyDisarmed_ReturnsAlready` | Already disarmed |
| `AttemptDisarm_CannotDisarm_ReturnsCannot` | Cannot disarm type |

#### TrapServiceEffectTests.cs (5 tests)

| Test Name | Description |
|-----------|-------------|
| `ApplyTrapEffect_WithDamage_DealsDamage` | Damage application |
| `ApplyTrapEffect_WithSave_RollsSave` | Save roll |
| `ApplyTrapEffect_SuccessfulSave_HalvesDamage` | Save halves |
| `ApplyTrapEffect_SuccessfulSave_NegatesStatus` | Save negates status |
| `ApplyTrapEffect_WithStatus_AppliesEffects` | Status application |

#### TrapIntegrationTests.cs (4 tests)

| Test Name | Description |
|-----------|-------------|
| `CheckEntryTraps_HiddenTrap_Triggers` | Entry trigger |
| `CheckEntryTraps_DetectedTrap_DoesNotTrigger` | Detected avoidance |
| `CheckOpenTraps_AttachedTrap_Triggers` | Open trigger |
| `OpenContainer_WithTrap_TriggersAndOpens` | Container trap |

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Template |
|-----------|-------|----------|
| Search performed | Information | "SearchForTraps: Player rolled {Total} for Perception check in room {RoomId}" |
| Trap detected via search | Information | "Player detected {TrapName} (rolled {Roll} vs DC {DC})" |
| Trap detected passively | Information | "Passive perception detected {TrapName} (passive {Passive} vs DC {DC})" |
| Search miss | Debug | "Player failed to detect {TrapName} (rolled {Roll} vs DC {DC})" |
| Disarm success | Information | "Player successfully disarmed {TrapName} ({RollInfo})" |
| Disarm fail safe | Information | "Player failed to disarm {TrapName} but didn't trigger it ({RollInfo})" |
| Disarm fail trigger | Information | "Player critically failed disarm on {TrapName}, triggering it ({RollInfo})" |
| Effect damage | Information | "Trap {TrapName} dealt {Damage} {DamageType} damage to player" |
| Effect status | Information | "Trap {TrapName} applied status effects: {Effects}" |
| Effect alert | Information | "Trap {TrapName} alerted monsters in radius {Radius}" |
| Save result | Information | "Player saved completely against {TrapName} (rolled {Roll} vs DC {DC})" |
| Passive calculation | Debug | "PassivePerception for player: {Base} + {Wits} + {Skill} = {Total}" |
| Save roll | Debug | "SavingThrow: Player rolled {Roll} + {Mod} = {Total} vs DC {DC} ({Attribute})" |

---

## Implementation Checklist

### Domain Layer
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/TrapEffect.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/TrapEffectResult.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/TrapDisarmResult.cs`
- [ ] Modify `src/Core/RuneAndRust.Domain/Entities/Trap.cs` - Add Effect property
- [ ] Modify `src/Core/RuneAndRust.Domain/Definitions/TrapDefinition.cs` - Update TrapEffectDefinition
- [ ] Modify `src/Core/RuneAndRust.Domain/Entities/InteractiveObject.cs` - Add AttachedTrapId

### Application Layer
- [ ] Modify `src/Core/RuneAndRust.Application/Interfaces/ITrapService.cs` - Add new methods
- [ ] Modify `src/Core/RuneAndRust.Application/Services/TrapService.cs` - Implement mechanics
- [ ] Modify `src/Core/RuneAndRust.Application/Interfaces/IInteractionService.cs` - Update Open signature
- [ ] Modify `src/Core/RuneAndRust.Application/Services/InteractionService.cs` - Add trap checking
- [ ] Modify `src/Core/RuneAndRust.Application/Services/GameSessionService.cs` - Add search/disarm commands

### Configuration
- [ ] Update `config/schemas/traps.schema.json` - Effect properties
- [ ] Update `config/schemas/interactive-objects.schema.json` - Add attachedTrapId
- [ ] Update `config/traps.json` - Sample traps with effects
- [ ] Update `config/interactive-objects.json` - Trapped containers

### Tests
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/TrapEffectTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/TrapEffectResultTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/TrapDisarmResultTests.cs`
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/TrapServiceDetectionTests.cs`
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/TrapServiceDisarmTests.cs`
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/TrapServiceEffectTests.cs`
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/TrapIntegrationTests.cs`

### Validation
- [ ] All ~35 new tests pass
- [ ] All existing tests pass (~1500)
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | `search` command performs Perception check against hidden trap DCs | Unit test |
| AC-2 | Successful search reveals traps with DC <= roll total | Unit test |
| AC-3 | Passive perception check runs on room entry | Unit test |
| AC-4 | Passive perception only detects traps with DC <= passive score | Unit test |
| AC-5 | `disarm` command performs skill check against disarm DC | Unit test |
| AC-6 | Successful disarm transitions trap to Disarmed state | Unit test |
| AC-7 | Failed disarm by 5+ triggers the trap | Unit test |
| AC-8 | Failed disarm by less than 5 allows retry | Unit test |
| AC-9 | Step/Proximity traps trigger on room entry if hidden | Unit test |
| AC-10 | Open traps trigger when attached object is opened | Unit test |
| AC-11 | Detected traps don't trigger on entry (player avoids) | Unit test |
| AC-12 | Trap effects deal damage via DiceService | Unit test |
| AC-13 | Trap effects apply status via StatusEffectService | Unit test |
| AC-14 | Saving throws reduce or negate trap effects | Unit test |
| AC-15 | Examine shows DC values for detected traps | Manual verification |
| AC-16 | ~35 unit tests pass | Test suite |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | Services accept dependencies via constructor injection | Code review |
| NF-2 | Services follow single responsibility principle | Code review |
| NF-3 | Logging follows structured patterns | Code review |
| NF-4 | Configuration is JSON-driven | Code review |
| NF-5 | All public methods have XML documentation | Code review |
| NF-6 | Integration with existing skill system is seamless | Code review |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Skill service interface mismatch | High | Low | Review ISkillCheckService before implementation |
| Status effect service integration issues | Medium | Low | Use existing patterns from combat system |
| Dice expression parsing errors | Medium | Low | Reuse existing DiceService validation |
| Passive perception edge cases | Low | Medium | Comprehensive unit tests for boundary values |
| Disarm trigger threshold confusion | Low | Low | Clear documentation, configurable constant |
| Save halves vs negates complexity | Medium | Medium | Thorough testing of both paths |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Domain/ValueObjects/TrapEffect.cs` | Effect configuration value object | ~200 |
| `Domain/ValueObjects/TrapEffectResult.cs` | Effect result value object | ~120 |
| `Domain/ValueObjects/TrapDisarmResult.cs` | Disarm result value object | ~110 |

### Files to Modify

| File | Changes | Est. Lines Added |
|------|---------|------------------|
| `Domain/Entities/Trap.cs` | Add Effect property, update FromDefinition | ~25 |
| `Domain/Definitions/TrapDefinition.cs` | Expand TrapEffectDefinition | ~30 |
| `Domain/Entities/InteractiveObject.cs` | Add AttachedTrapId property | ~20 |
| `Application/Interfaces/ITrapService.cs` | Add 6 new methods | ~80 |
| `Application/Services/TrapService.cs` | Implement mechanics | ~250 |
| `Application/Interfaces/IInteractionService.cs` | Update Open signature | ~5 |
| `Application/Services/InteractionService.cs` | Add trap checking | ~30 |
| `Application/Services/GameSessionService.cs` | Add search/disarm commands | ~50 |
| `config/schemas/traps.schema.json` | Effect properties | ~50 |
| `config/traps.json` | Sample traps with effects | ~80 |

### Test Files

| File | Test Count |
|------|------------|
| `Tests/ValueObjects/TrapEffectTests.cs` | 5 |
| `Tests/ValueObjects/TrapEffectResultTests.cs` | 4 |
| `Tests/ValueObjects/TrapDisarmResultTests.cs` | 5 |
| `Tests/Services/TrapServiceDetectionTests.cs` | 6 |
| `Tests/Services/TrapServiceDisarmTests.cs` | 6 |
| `Tests/Services/TrapServiceEffectTests.cs` | 5 |
| `Tests/Services/TrapIntegrationTests.cs` | 4 |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| Value Objects | +2 from v0.4.1a | +3 more |
| TrapService methods | 10 | 16 |
| Trap has Effect property | No | Yes |
| InteractiveObject has AttachedTrapId | No | Yes |
| Unit Tests | ~1500 | ~1535 |

---

## Next Steps

After completing this phase:

1. **v0.4.1c (Environmental Hazards)** - HazardZone entity, ongoing effects, environmental damage, hazard saves
2. **Integration Testing** - Full integration with movement, combat, and container systems
3. **Configuration** - Comprehensive trap definitions for all dungeon types

---

*This implementation plan provides a complete roadmap for implementing v0.4.1b trap mechanics. It builds upon the v0.4.1a foundation to create a fully functional trap system with Perception-based detection, risk/reward disarm mechanics, and varied effects with saving throws.*
