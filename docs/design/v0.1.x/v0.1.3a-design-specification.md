# v0.1.3a Design Specification: Architectural Styles

**Version:** 0.1.3a
**Phase Name:** Architectural Styles
**Parent Version:** v0.1.3 (Advanced Procedural Architecture)
**Prerequisites:** v0.1.2 Complete (Dungeon Theming & Biomes)
**Estimated Tests:** ~22 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ArchitecturalStyle Entity](#4-architecturalstyle-entity)
5. [StyleDescriptors Value Object](#5-styledescriptors-value-object)
6. [StyleRules Value Object](#6-stylerules-value-object)
7. [ArchitecturalStyleService](#7-architecturalstyleservice)
8. [Room Style Integration](#8-room-style-integration)
9. [DescriptorService Integration](#9-descriptorservice-integration)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement the architectural style system that defines distinct construction patterns for dungeon areas. Each style determines room characteristics, material usage, structural features, and descriptive text specific to that construction type. This phase establishes the foundation for procedural architecture by integrating styles with the existing biome system, ensuring thematic consistency while adding architectural variety.

### 1.2 Current State

| Area | Current State (v0.1.2) | Target State (v0.1.3a) |
|------|------------------------|------------------------|
| Room construction | Generic based on biome | Style-aware construction patterns |
| Descriptors | Biome-specific only | Biome + Style layered descriptors |
| Corridors | Implicit connections | Style-defined corridor rules |
| Doors | Always present | Style-dependent presence |
| Room generation | Biome-filtered templates | Style + Biome filtered templates |
| Structural patterns | None | Style-defined construction rules |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `ArchitecturalStyle` |
| **Value Objects** | `StyleDescriptors`, `StyleRules` |
| **Services** | `ArchitecturalStyleService` (with `IArchitecturalStyleService` interface) |
| **Configuration** | `architectural-styles.json`, `architectural-styles-schema.json` |
| **Entity Updates** | `Room.ArchitecturalStyleId` property |
| **Service Updates** | `DescriptorService` style-aware descriptor selection |
| **Tests** | ~22 new unit tests |

### 1.4 Architectural Significance

This version establishes the **architectural style pattern** that will be extended throughout v0.1.3:
- Data-driven style definitions loaded from JSON configuration
- Style-biome compatibility matrix for thematic consistency
- Layered descriptor system combining biome and style text
- Construction rules affecting room generation behavior
- Foundation for room shapes (v0.1.3b) and landmark rooms (v0.1.3c)

---

## 2. Feature Overview

```
v0.1.3a Architectural Styles
├── ArchitecturalStyle Entity
│   ├── Unique style identification (Id)
│   ├── Display name and description
│   ├── StyleDescriptors for room text
│   ├── StyleRules for construction parameters
│   ├── Compatible biomes list
│   ├── Preferred room shapes (placeholder for v0.1.3b)
│   ├── Common structural features (placeholder for v0.1.3b)
│   ├── Selection weight for randomization
│   ├── UsesDoors flag
│   ├── HasCorridors flag
│   ├── Depth constraints (MinDepth, MaxDepth)
│   └── Tags for categorization
├── StyleDescriptors Value Object
│   ├── Wall descriptors (array)
│   ├── Floor descriptors (array)
│   ├── Ceiling descriptors (array)
│   ├── Passage descriptors (array)
│   ├── Decoration descriptors (array)
│   └── Descriptor pool prefix
├── StyleRules Value Object
│   ├── Room size range (min, max)
│   ├── Multiple exit chance
│   ├── Average exits count
│   ├── Symmetry preference
│   ├── Regular shape preference
│   ├── Corridor width
│   ├── Hidden passage chance
│   └── Trap chance
├── ArchitecturalStyleService
│   ├── GetStyle(styleId)
│   ├── GetAllStyles()
│   ├── GetStylesForBiome(biomeId)
│   ├── GetStylesForDepth(depth)
│   ├── SelectStyleForPosition(position, biomeId)
│   ├── IsCompatible(styleId, biomeId)
│   └── GetRandomDescriptor(styleId, type, position)
├── Room Style Integration
│   ├── Room.ArchitecturalStyleId property
│   └── Room.SetArchitecturalStyle(styleId) method
├── DescriptorService Integration
│   └── Style-aware descriptor selection
└── Configuration
    ├── architectural-styles.json (4 default styles)
    └── architectural-styles-schema.json (validation)
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Room descriptions now include style-themed descriptors                      │
│  ├── GameView displays style-appropriate environment text                    │
│  └── Look command shows style-biome combined descriptions                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  ArchitecturalStyleService            DescriptorService (Updated)            │
│  ├── GetStyle(styleId)                ├── GetDescriptor() // style-aware    │
│  ├── GetAllStyles()                   ├── GetStyleDescriptor()              │
│  ├── GetStylesForBiome(biomeId)       └── GenerateStyledRoomDescription()   │
│  ├── GetStylesForDepth(depth)                                               │
│  ├── SelectStyleForPosition()         RoomGeneratorService (Updated)        │
│  ├── IsCompatible()                   └── Assigns StyleId during generation │
│  └── GetRandomDescriptor()                                                  │
│                                                                              │
│  Interfaces:                         Configuration:                          │
│  └── IArchitecturalStyleService      └── ArchitecturalStyleConfigurationDto │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Definitions:                  Value Objects:                                │
│  ┌─────────────────────────┐  ┌─────────────────────────┐                   │
│  │ ArchitecturalStyle      │  │ StyleDescriptors        │                   │
│  │ ├── Id: string          │  │ ├── Walls: string[]     │                   │
│  │ ├── Name: string        │  │ ├── Floors: string[]    │                   │
│  │ ├── Description: string │  │ ├── Ceilings: string[]  │                   │
│  │ ├── Descriptors         │  │ ├── Passages: string[]  │                   │
│  │ ├── Rules               │  │ ├── Decorations: string[]                   │
│  │ ├── CompatibleBiomes    │  │ └── DescriptorPoolPrefix│                   │
│  │ ├── PreferredShapes     │  └─────────────────────────┘                   │
│  │ ├── CommonFeatures      │  ┌─────────────────────────┐                   │
│  │ ├── Weight: int         │  │ StyleRules              │                   │
│  │ ├── UsesDoors: bool     │  │ ├── RoomSizeRange       │                   │
│  │ ├── HasCorridors: bool  │  │ ├── MultipleExitChance  │                   │
│  │ ├── MinDepth: int       │  │ ├── AverageExits        │                   │
│  │ ├── MaxDepth: int?      │  │ ├── PrefersSymmetry     │                   │
│  │ └── Tags: string[]      │  │ ├── PrefersRegularShapes│                   │
│  └─────────────────────────┘  │ ├── CorridorWidth       │                   │
│                               │ ├── HiddenPassageChance │                   │
│  Entities (Updated):          │ └── TrapChance          │                   │
│  ┌─────────────────────────┐  └─────────────────────────┘                   │
│  │ Room                    │                                                │
│  │ └── ArchitecturalStyleId│                                                │
│  └─────────────────────────┘                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetArchitecturalStyles(): IReadOnlyList<ArchitecturalStyle>            │
│  └── Loads and deserializes config/architectural-styles.json                │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/architectural-styles.json (4 default styles)                    │
│  └── config/schemas/architectural-styles-schema.json (validation schema)    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Style Selection Flow

```
┌───────────────────────────────────────┐
│ RoomGeneratorService generates room   │
│ at Position3D with BiomeId assigned   │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ ArchitecturalStyleService.SelectStyleForPosition(pos, biome) │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Get Styles Compatible with Biome                      │
├───────────────────────────────────────────────────────────────┤
│ GetStylesForBiome("catacombs")                                │
│ ├── Natural Caves - compatibleBiomes: [mines, frozen...] ✗   │
│ ├── Carved Halls - compatibleBiomes: [catacombs, ...] ✓      │
│ ├── Ruined Structures - compatibleBiomes: [ancient-ruins...] │
│ │   └── Empty list = compatible with all ✓                    │
│ └── Ancient Temples - compatibleBiomes: [ancient-ruins, cat] ✓│
│                                                               │
│ Compatible styles for catacombs: [Carved Halls, Ruined, Temple]
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Filter by Depth                                       │
├───────────────────────────────────────────────────────────────┤
│ Position.Z = 2                                                │
│                                                               │
│ ├── Carved Halls (minDepth: 0, maxDepth: null) ✓              │
│ ├── Ruined Structures (minDepth: 2, maxDepth: null) ✓         │
│ └── Ancient Temples (minDepth: 3, maxDepth: null) ✗           │
│                                                               │
│ Valid at depth 2: [Carved Halls, Ruined Structures]           │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Weighted Random Selection                             │
├───────────────────────────────────────────────────────────────┤
│ SeededRandomService.SelectWeighted(position, styles, "style") │
│                                                               │
│ Style weights:                                                │
│ ├── Carved Halls: 100                                         │
│ └── Ruined Structures: 80                                     │
│                                                               │
│ Total weight: 180                                             │
│ Seeded roll for position → 0.62 × 180 = 112                   │
│ ├── 0-99: Carved Halls ← Selected                             │
│ └── 100-179: Ruined Structures                                │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: Assign Style to Room                                  │
├───────────────────────────────────────────────────────────────┤
│ room.SetArchitecturalStyle("carved-halls")                    │
│                                                               │
│ Room now has:                                                 │
│ ├── BiomeId: "catacombs"                                      │
│ ├── ArchitecturalStyleId: "carved-halls"                      │
│ └── Access to style descriptors, rules via StyleService       │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Descriptor Integration Flow

```
┌───────────────────────────────────────┐
│ DescriptorService generates room text │
│ for Room with:                        │
│ ├── BiomeId = "catacombs"             │
│ └── ArchitecturalStyleId = "carved-halls"
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Get Biome Definition                                          │
├───────────────────────────────────────────────────────────────┤
│ BiomeService.GetBiome("catacombs")                            │
│ └── Returns BiomeDefinition with BiomeDescriptors             │
│     ├── Lighting: ["pale candlelight", "flickering shadows"]  │
│     ├── Sounds: ["whispered prayers", "rattling bones"]       │
│     ├── Smells: ["incense and decay", "ancient dust"]         │
│     └── Atmosphere: ["reverent silence", "oppressive grief"]  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Get Style Definition                                          │
├───────────────────────────────────────────────────────────────┤
│ ArchitecturalStyleService.GetStyle("carved-halls")            │
│ └── Returns ArchitecturalStyle with StyleDescriptors          │
│     ├── Walls: ["smooth-cut stone", "precise masonry"]        │
│     ├── Floors: ["fitted flagstones", "geometric patterns"]   │
│     ├── Ceilings: ["vaulted arches", "supporting beams"]      │
│     ├── Passages: ["wide corridor", "pillared hall"]          │
│     └── Decorations: ["carved reliefs", "stone pillars"]      │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Combine Descriptors                                           │
├───────────────────────────────────────────────────────────────┤
│ From Biome (atmosphere/senses):                               │
│ ├── lighting → "flickering shadows"                           │
│ ├── smell → "ancient dust"                                    │
│ └── atmosphere → "reverent silence"                           │
│                                                               │
│ From Style (physical structure):                              │
│ ├── walls → "smooth-cut stone"                                │
│ ├── floor → "fitted flagstones"                               │
│ ├── ceiling → "vaulted arches"                                │
│ └── decoration → "carved reliefs"                             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Generate Combined Description                                 │
├───────────────────────────────────────────────────────────────┤
│ "You stand in a chamber with smooth-cut stone walls rising to │
│  vaulted arches above. Fitted flagstones form the floor,      │
│  adorned with carved reliefs. Flickering shadows dance across │
│  the surfaces. The smell of ancient dust fills the air. A     │
│  sense of reverent silence pervades the space."               │
└───────────────────────────────────────────────────────────────┘
```

---

## 4. ArchitecturalStyle Entity

### 4.1 Purpose

The `ArchitecturalStyle` entity represents a distinct construction pattern for dungeon areas. Each style defines how rooms are built, what materials are used, and how passages connect. Styles are loaded from JSON configuration and are immutable during runtime.

### 4.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Definitions/ArchitecturalStyle.cs`

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a distinct construction pattern for dungeon areas.
/// </summary>
/// <remarks>
/// Architectural styles determine how rooms are constructed, including
/// materials, structural features, passage types, and decorative elements.
/// Each style is compatible with specific biomes and depth ranges.
/// </remarks>
public class ArchitecturalStyle
{
    /// <summary>
    /// Gets the unique identifier for this style (e.g., "natural-caves").
    /// </summary>
    /// <remarks>
    /// Uses kebab-case naming convention. Must be unique across all styles.
    /// </remarks>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name (e.g., "Natural Caves").
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the style description for codex/discovery.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets style-specific descriptors for room generation.
    /// </summary>
    public StyleDescriptors Descriptors { get; init; } = StyleDescriptors.Default;

    /// <summary>
    /// Gets construction rules for this style.
    /// </summary>
    public StyleRules Rules { get; init; } = StyleRules.Default;

    /// <summary>
    /// Gets biome IDs compatible with this style.
    /// </summary>
    /// <remarks>
    /// Empty list means compatible with all biomes.
    /// </remarks>
    public IReadOnlyList<string> CompatibleBiomes { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets preferred room shapes for this style.
    /// </summary>
    /// <remarks>
    /// Placeholder for v0.1.3b. Shape IDs that are commonly used with this style.
    /// </remarks>
    public IReadOnlyList<string> PreferredShapes { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets structural features common to this style.
    /// </summary>
    /// <remarks>
    /// Placeholder for v0.1.3b. Feature IDs typically found in this style.
    /// </remarks>
    public IReadOnlyList<string> CommonFeatures { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the probability weight for style selection.
    /// </summary>
    /// <remarks>
    /// Higher weights increase selection probability. Default is 100.
    /// </remarks>
    public int Weight { get; init; } = 100;

    /// <summary>
    /// Gets whether this style uses doors between rooms.
    /// </summary>
    /// <remarks>
    /// Natural caves typically don't have doors; carved halls do.
    /// </remarks>
    public bool UsesDoors { get; init; } = true;

    /// <summary>
    /// Gets whether this style has corridors connecting rooms.
    /// </summary>
    /// <remarks>
    /// Constructed styles have formal corridors; natural caves connect directly.
    /// </remarks>
    public bool HasCorridors { get; init; } = true;

    /// <summary>
    /// Gets the minimum depth (Z-level) where this style can appear.
    /// </summary>
    /// <remarks>
    /// Depth 0 is the dungeon entrance. Higher values are deeper.
    /// </remarks>
    public int MinDepth { get; init; }

    /// <summary>
    /// Gets the maximum depth where this style can appear.
    /// </summary>
    /// <remarks>
    /// Null indicates no maximum depth limit.
    /// </remarks>
    public int? MaxDepth { get; init; }

    /// <summary>
    /// Gets tags for filtering and categorization.
    /// </summary>
    /// <remarks>
    /// Tags enable filtering styles by characteristics (e.g., "constructed", "natural", "sacred").
    /// </remarks>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Private constructor for EF Core and factory method.
    /// </summary>
    private ArchitecturalStyle() { }

    /// <summary>
    /// Creates an architectural style from configuration.
    /// </summary>
    /// <param name="id">Unique style identifier (kebab-case).</param>
    /// <param name="name">Display name.</param>
    /// <param name="description">Codex description.</param>
    /// <param name="descriptors">Style descriptors.</param>
    /// <param name="rules">Construction rules.</param>
    /// <param name="compatibleBiomes">Compatible biome IDs (empty = all).</param>
    /// <param name="preferredShapes">Preferred shape IDs.</param>
    /// <param name="commonFeatures">Common feature IDs.</param>
    /// <param name="weight">Selection weight.</param>
    /// <param name="usesDoors">Whether style uses doors.</param>
    /// <param name="hasCorridors">Whether style has corridors.</param>
    /// <param name="minDepth">Minimum depth for appearance.</param>
    /// <param name="maxDepth">Maximum depth (null = unlimited).</param>
    /// <param name="tags">Categorization tags.</param>
    /// <returns>A new ArchitecturalStyle instance.</returns>
    /// <exception cref="ArgumentException">Thrown when id or name is null/empty.</exception>
    public static ArchitecturalStyle Create(
        string id,
        string name,
        string description,
        StyleDescriptors descriptors,
        StyleRules? rules = null,
        IEnumerable<string>? compatibleBiomes = null,
        IEnumerable<string>? preferredShapes = null,
        IEnumerable<string>? commonFeatures = null,
        int weight = 100,
        bool usesDoors = true,
        bool hasCorridors = true,
        int minDepth = 0,
        int? maxDepth = null,
        IEnumerable<string>? tags = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id, nameof(id));
        ArgumentException.ThrowIfNullOrWhiteSpace(name, nameof(name));

        if (minDepth < 0)
            throw new ArgumentOutOfRangeException(nameof(minDepth), "MinDepth cannot be negative.");

        if (maxDepth.HasValue && maxDepth.Value < minDepth)
            throw new ArgumentException("MaxDepth cannot be less than MinDepth.", nameof(maxDepth));

        if (weight <= 0)
            throw new ArgumentOutOfRangeException(nameof(weight), "Weight must be positive.");

        return new ArchitecturalStyle
        {
            Id = id,
            Name = name,
            Description = description ?? string.Empty,
            Descriptors = descriptors,
            Rules = rules ?? StyleRules.Default,
            CompatibleBiomes = compatibleBiomes?.ToList() ?? new List<string>(),
            PreferredShapes = preferredShapes?.ToList() ?? new List<string>(),
            CommonFeatures = commonFeatures?.ToList() ?? new List<string>(),
            Weight = weight,
            UsesDoors = usesDoors,
            HasCorridors = hasCorridors,
            MinDepth = minDepth,
            MaxDepth = maxDepth,
            Tags = tags?.ToList() ?? new List<string>()
        };
    }

    /// <summary>
    /// Checks if this style is valid for a given depth.
    /// </summary>
    /// <param name="depth">The Z-level depth to check.</param>
    /// <returns>True if the style can appear at this depth.</returns>
    public bool IsValidForDepth(int depth)
    {
        if (depth < MinDepth)
            return false;

        if (MaxDepth.HasValue && depth > MaxDepth.Value)
            return false;

        return true;
    }

    /// <summary>
    /// Checks if this style is compatible with a biome.
    /// </summary>
    /// <param name="biomeId">The biome identifier to check.</param>
    /// <returns>True if the style is compatible with the biome.</returns>
    public bool IsCompatibleWithBiome(string biomeId)
    {
        // Empty list means compatible with all biomes
        if (!CompatibleBiomes.Any())
            return true;

        return CompatibleBiomes.Contains(biomeId, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Checks if this style has a specific tag.
    /// </summary>
    /// <param name="tag">The tag to check for.</param>
    /// <returns>True if the style has the tag.</returns>
    public bool HasTag(string tag)
    {
        return Tags.Contains(tag, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets a string representation of the style.
    /// </summary>
    public override string ToString() => $"Style[{Id}] {Name} (depth {MinDepth}-{MaxDepth?.ToString() ?? "∞"})";
}
```

### 4.4 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `string` | Unique identifier (kebab-case) | Required |
| `Name` | `string` | Display name | Required |
| `Description` | `string` | Codex description | Empty |
| `Descriptors` | `StyleDescriptors` | Room text descriptors | Default |
| `Rules` | `StyleRules` | Construction parameters | Default |
| `CompatibleBiomes` | `IReadOnlyList<string>` | Compatible biome IDs | Empty (all) |
| `PreferredShapes` | `IReadOnlyList<string>` | Preferred shape IDs | Empty |
| `CommonFeatures` | `IReadOnlyList<string>` | Common feature IDs | Empty |
| `Weight` | `int` | Selection probability weight | 100 |
| `UsesDoors` | `bool` | Has doors between rooms | true |
| `HasCorridors` | `bool` | Has formal corridors | true |
| `MinDepth` | `int` | Minimum Z-level | 0 |
| `MaxDepth` | `int?` | Maximum Z-level | null (unlimited) |
| `Tags` | `IReadOnlyList<string>` | Categorization tags | Empty |

---

## 5. StyleDescriptors Value Object

### 5.1 Purpose

The `StyleDescriptors` value object contains arrays of themed descriptive text for physical structure elements. These descriptors describe walls, floors, ceilings, passages, and decorations specific to the architectural style.

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/StyleDescriptors.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Descriptors specific to an architectural style for room generation.
/// </summary>
/// <remarks>
/// Each property contains an array of themed descriptive text for physical
/// structures. During room generation, random selections create varied
/// descriptions that maintain style consistency.
/// </remarks>
public readonly record struct StyleDescriptors
{
    /// <summary>
    /// Gets wall descriptors (e.g., "rough stone", "carved marble").
    /// </summary>
    public IReadOnlyList<string> Walls { get; init; }

    /// <summary>
    /// Gets floor descriptors (e.g., "uneven rock", "polished tiles").
    /// </summary>
    public IReadOnlyList<string> Floors { get; init; }

    /// <summary>
    /// Gets ceiling descriptors (e.g., "jagged stalactites", "vaulted arches").
    /// </summary>
    public IReadOnlyList<string> Ceilings { get; init; }

    /// <summary>
    /// Gets passage descriptors (e.g., "narrow tunnel", "grand hallway").
    /// </summary>
    public IReadOnlyList<string> Passages { get; init; }

    /// <summary>
    /// Gets decoration descriptors (e.g., "mineral deposits", "carved reliefs").
    /// </summary>
    public IReadOnlyList<string> Decorations { get; init; }

    /// <summary>
    /// Gets the descriptor pool prefix for extended descriptor lookups.
    /// </summary>
    /// <remarks>
    /// Used to reference additional descriptor pools in the descriptor service.
    /// Format: "style.{styleId}" (e.g., "style.caves").
    /// </remarks>
    public string DescriptorPoolPrefix { get; init; }

    /// <summary>
    /// Creates default style descriptors.
    /// </summary>
    public static StyleDescriptors Default => new()
    {
        Walls = new[] { "stone walls", "rough surfaces" },
        Floors = new[] { "stone floor", "solid ground" },
        Ceilings = new[] { "low ceiling", "overhead stone" },
        Passages = new[] { "passage", "opening" },
        Decorations = new[] { "bare stone", "empty alcoves" },
        DescriptorPoolPrefix = "style.default"
    };

    /// <summary>
    /// Creates natural caves descriptors.
    /// </summary>
    public static StyleDescriptors NaturalCaves => new()
    {
        Walls = new[] { "rough stone", "mineral-veined rock", "damp limestone", "jagged surfaces" },
        Floors = new[] { "uneven ground", "scattered gravel", "smooth water-worn stone", "loose rubble" },
        Ceilings = new[] { "stalactite clusters", "low overhangs", "high natural domes", "dripping moisture" },
        Passages = new[] { "narrow squeeze", "winding tunnel", "natural fissure", "widening cavern" },
        Decorations = new[] { "crystal formations", "phosphorescent moss", "mineral deposits", "ancient fossils" },
        DescriptorPoolPrefix = "style.caves"
    };

    /// <summary>
    /// Creates carved halls descriptors.
    /// </summary>
    public static StyleDescriptors CarvedHalls => new()
    {
        Walls = new[] { "smooth-cut stone", "precise masonry", "decorated panels", "torch sconces" },
        Floors = new[] { "fitted flagstones", "geometric patterns", "worn pathways", "drainage channels" },
        Ceilings = new[] { "vaulted arches", "supporting beams", "carved coffers", "hanging lanterns" },
        Passages = new[] { "wide corridor", "pillared hall", "arched doorway", "grand passage" },
        Decorations = new[] { "carved reliefs", "stone pillars", "alcove statues", "inscribed tablets" },
        DescriptorPoolPrefix = "style.halls"
    };

    /// <summary>
    /// Creates ruined structures descriptors.
    /// </summary>
    public static StyleDescriptors RuinedStructures => new()
    {
        Walls = new[] { "crumbling masonry", "collapsed sections", "exposed foundations", "vine-covered stone" },
        Floors = new[] { "broken tiles", "debris piles", "treacherous gaps", "overgrown flagstones" },
        Ceilings = new[] { "partially collapsed", "exposed sky", "precarious beams", "bird nests" },
        Passages = new[] { "rubble-blocked", "improvised path", "collapsed tunnel", "unstable archway" },
        Decorations = new[] { "shattered statues", "faded murals", "scattered artifacts", "nature reclaiming" },
        DescriptorPoolPrefix = "style.ruins"
    };

    /// <summary>
    /// Creates ancient temples descriptors.
    /// </summary>
    public static StyleDescriptors AncientTemples => new()
    {
        Walls = new[] { "sacred inscriptions", "polished marble", "divine imagery", "gold inlays" },
        Floors = new[] { "mosaic patterns", "ceremonial tiles", "altar platforms", "processional paths" },
        Ceilings = new[] { "painted heavens", "domed sanctuaries", "hanging censers", "celestial motifs" },
        Passages = new[] { "ritual corridor", "pilgrimage path", "sanctum approach", "ceremonial gate" },
        Decorations = new[] { "divine statues", "offering bowls", "eternal flames", "sacred symbols" },
        DescriptorPoolPrefix = "style.temples"
    };

    /// <summary>
    /// Gets a random descriptor from a specific category.
    /// </summary>
    /// <param name="category">The category name (walls, floors, ceilings, passages, decorations).</param>
    /// <param name="random">Random instance for selection.</param>
    /// <returns>A random descriptor string, or empty if category not found.</returns>
    public string GetRandomDescriptor(string category, Random random)
    {
        var pool = category.ToLowerInvariant() switch
        {
            "walls" => Walls,
            "floors" => Floors,
            "ceilings" => Ceilings,
            "passages" => Passages,
            "decorations" => Decorations,
            _ => Array.Empty<string>()
        };

        if (pool.Count == 0)
            return string.Empty;

        return pool[random.Next(pool.Count)];
    }

    /// <summary>
    /// Checks if all descriptor arrays have at least one entry.
    /// </summary>
    public bool IsValid =>
        Walls?.Count > 0 &&
        Floors?.Count > 0 &&
        Ceilings?.Count > 0 &&
        Passages?.Count > 0 &&
        Decorations?.Count > 0;
}
```

### 5.4 Descriptor Categories

| Category | Purpose | Example Values |
|----------|---------|----------------|
| `Walls` | Wall surface descriptions | "smooth-cut stone", "rough limestone", "crumbling masonry" |
| `Floors` | Floor surface descriptions | "fitted flagstones", "uneven ground", "mosaic patterns" |
| `Ceilings` | Ceiling descriptions | "vaulted arches", "stalactite clusters", "painted heavens" |
| `Passages` | Connection descriptions | "wide corridor", "narrow squeeze", "ceremonial gate" |
| `Decorations` | Decorative element descriptions | "carved reliefs", "mineral deposits", "sacred symbols" |

---

## 6. StyleRules Value Object

### 6.1 Purpose

The `StyleRules` value object defines construction parameters specific to an architectural style. These rules affect room generation, exit placement, corridor creation, and hazard distribution.

### 6.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/StyleRules.cs`

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Construction rules for an architectural style.
/// </summary>
/// <remarks>
/// Rules define how rooms are generated within a style, including size ranges,
/// exit configurations, and structural preferences.
/// </remarks>
public readonly record struct StyleRules
{
    /// <summary>
    /// Gets the typical room size range (min, max in tiles).
    /// </summary>
    public (int Min, int Max) RoomSizeRange { get; init; }

    /// <summary>
    /// Gets the probability of having multiple exits (0.0-1.0).
    /// </summary>
    public float MultipleExitChance { get; init; }

    /// <summary>
    /// Gets the average number of exits per room.
    /// </summary>
    public float AverageExits { get; init; }

    /// <summary>
    /// Gets whether rooms tend toward symmetry.
    /// </summary>
    /// <remarks>
    /// Affects room shape and feature placement in v0.1.3b.
    /// </remarks>
    public bool PrefersSymmetry { get; init; }

    /// <summary>
    /// Gets whether rooms have regular (rectangular) shapes.
    /// </summary>
    /// <remarks>
    /// Affects shape selection in v0.1.3b.
    /// </remarks>
    public bool PrefersRegularShapes { get; init; }

    /// <summary>
    /// Gets the corridor width (0 = no corridors).
    /// </summary>
    /// <remarks>
    /// Width in tiles. Natural caves have 0 (no formal corridors).
    /// </remarks>
    public int CorridorWidth { get; init; }

    /// <summary>
    /// Gets the probability of hidden passages (0.0-1.0).
    /// </summary>
    public float HiddenPassageChance { get; init; }

    /// <summary>
    /// Gets the probability of traps (0.0-1.0).
    /// </summary>
    /// <remarks>
    /// Affects hazard placement in conjunction with BiomeHazard.
    /// </remarks>
    public float TrapChance { get; init; }

    /// <summary>
    /// Creates default style rules.
    /// </summary>
    public static StyleRules Default => new()
    {
        RoomSizeRange = (3, 8),
        MultipleExitChance = 0.6f,
        AverageExits = 2.5f,
        PrefersSymmetry = false,
        PrefersRegularShapes = true,
        CorridorWidth = 1,
        HiddenPassageChance = 0.1f,
        TrapChance = 0.15f
    };

    /// <summary>
    /// Creates natural caves rules.
    /// </summary>
    public static StyleRules NaturalCaves => new()
    {
        RoomSizeRange = (2, 12),
        MultipleExitChance = 0.7f,
        AverageExits = 2.8f,
        PrefersSymmetry = false,
        PrefersRegularShapes = false,
        CorridorWidth = 0, // No formal corridors
        HiddenPassageChance = 0.15f,
        TrapChance = 0.05f // Natural hazards instead
    };

    /// <summary>
    /// Creates carved halls rules.
    /// </summary>
    public static StyleRules CarvedHalls => new()
    {
        RoomSizeRange = (4, 10),
        MultipleExitChance = 0.5f,
        AverageExits = 2.5f,
        PrefersSymmetry = false,
        PrefersRegularShapes = true,
        CorridorWidth = 1,
        HiddenPassageChance = 0.1f,
        TrapChance = 0.15f
    };

    /// <summary>
    /// Creates ruined structures rules.
    /// </summary>
    public static StyleRules RuinedStructures => new()
    {
        RoomSizeRange = (3, 10),
        MultipleExitChance = 0.4f,
        AverageExits = 2.0f,
        PrefersSymmetry = false,
        PrefersRegularShapes = false,
        CorridorWidth = 0, // Corridors collapsed
        HiddenPassageChance = 0.25f, // Hidden paths through rubble
        TrapChance = 0.2f // Structural hazards
    };

    /// <summary>
    /// Creates ancient temples rules.
    /// </summary>
    public static StyleRules AncientTemples => new()
    {
        RoomSizeRange = (5, 15),
        MultipleExitChance = 0.4f,
        AverageExits = 2.0f,
        PrefersSymmetry = true,
        PrefersRegularShapes = true,
        CorridorWidth = 2, // Wide ceremonial corridors
        HiddenPassageChance = 0.2f, // Secret chambers
        TrapChance = 0.25f // Temple guardians/traps
    };

    /// <summary>
    /// Calculates the minimum room size for this style.
    /// </summary>
    public int MinRoomSize => RoomSizeRange.Min;

    /// <summary>
    /// Calculates the maximum room size for this style.
    /// </summary>
    public int MaxRoomSize => RoomSizeRange.Max;

    /// <summary>
    /// Checks if this style has formal corridors.
    /// </summary>
    public bool HasCorridors => CorridorWidth > 0;

    /// <summary>
    /// Gets the expected number of exits for a room.
    /// </summary>
    /// <param name="random">Random instance for variation.</param>
    /// <returns>Number of exits to generate.</returns>
    public int GetExitCount(Random random)
    {
        // Base is always 1
        if (random.NextDouble() > MultipleExitChance)
            return 1;

        // Otherwise, generate around average with some variation
        var variation = random.NextDouble() - 0.5; // -0.5 to 0.5
        var count = (int)Math.Round(AverageExits + variation);
        return Math.Max(1, Math.Min(4, count)); // Clamp to 1-4
    }
}
```

### 6.4 Style Rules Comparison

| Style | Size Range | Avg Exits | Symmetry | Regular | Corridor | Hidden | Traps |
|-------|------------|-----------|----------|---------|----------|--------|-------|
| Natural Caves | 2-12 | 2.8 | No | No | 0 | 15% | 5% |
| Carved Halls | 4-10 | 2.5 | No | Yes | 1 | 10% | 15% |
| Ruined Structures | 3-10 | 2.0 | No | No | 0 | 25% | 20% |
| Ancient Temples | 5-15 | 2.0 | Yes | Yes | 2 | 20% | 25% |

---

## 7. ArchitecturalStyleService

### 7.1 Purpose

The `ArchitecturalStyleService` provides style lookup, selection, and descriptor access. It integrates with the `SeededRandomService` for reproducible style selection based on position.

### 7.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/IArchitecturalStyleService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/ArchitecturalStyleService.cs`

### 7.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for architectural style lookup, selection, and management.
/// </summary>
public interface IArchitecturalStyleService
{
    /// <summary>
    /// Gets an architectural style definition by ID.
    /// </summary>
    /// <param name="styleId">The unique style identifier.</param>
    /// <returns>The style definition, or null if not found.</returns>
    ArchitecturalStyle? GetStyle(string styleId);

    /// <summary>
    /// Gets all available architectural style definitions.
    /// </summary>
    /// <returns>A read-only list of all style definitions.</returns>
    IReadOnlyList<ArchitecturalStyle> GetAllStyles();

    /// <summary>
    /// Gets styles compatible with a given biome.
    /// </summary>
    /// <param name="biomeId">The biome identifier.</param>
    /// <returns>Styles compatible with the biome.</returns>
    IReadOnlyList<ArchitecturalStyle> GetStylesForBiome(string biomeId);

    /// <summary>
    /// Gets styles valid for a given depth.
    /// </summary>
    /// <param name="depth">The Z-level depth.</param>
    /// <returns>Styles that can appear at this depth.</returns>
    IReadOnlyList<ArchitecturalStyle> GetStylesForDepth(int depth);

    /// <summary>
    /// Selects an architectural style for a position using seeded random.
    /// </summary>
    /// <param name="position">The 3D position.</param>
    /// <param name="biomeId">The biome to filter by.</param>
    /// <returns>The selected style definition.</returns>
    ArchitecturalStyle SelectStyleForPosition(Position3D position, string biomeId);

    /// <summary>
    /// Validates that a style is compatible with a biome.
    /// </summary>
    /// <param name="styleId">The style identifier.</param>
    /// <param name="biomeId">The biome identifier.</param>
    /// <returns>True if the style is compatible with the biome.</returns>
    bool IsCompatible(string styleId, string biomeId);

    /// <summary>
    /// Gets a random descriptor from a style's pools.
    /// </summary>
    /// <param name="styleId">The style identifier.</param>
    /// <param name="descriptorType">The descriptor category.</param>
    /// <param name="position">Position for seeded randomization.</param>
    /// <returns>A random descriptor string.</returns>
    string GetRandomDescriptor(string styleId, string descriptorType, Position3D position);

    /// <summary>
    /// Gets styles matching specified tags.
    /// </summary>
    /// <param name="tags">Tags to match.</param>
    /// <param name="matchAll">True to require all tags, false for any.</param>
    /// <returns>Matching style definitions.</returns>
    IReadOnlyList<ArchitecturalStyle> GetStylesByTags(IEnumerable<string> tags, bool matchAll = false);

    /// <summary>
    /// Gets the default style (fallback when no styles match).
    /// </summary>
    /// <returns>The default style definition.</returns>
    ArchitecturalStyle GetDefaultStyle();
}
```

### 7.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for architectural style lookup, selection, and management.
/// </summary>
public class ArchitecturalStyleService : IArchitecturalStyleService
{
    private readonly IConfigurationProvider _config;
    private readonly SeededRandomService _random;
    private readonly ILogger<ArchitecturalStyleService> _logger;

    private const string DefaultStyleId = "carved-halls";

    /// <summary>
    /// Initializes a new instance of the ArchitecturalStyleService.
    /// </summary>
    public ArchitecturalStyleService(
        IConfigurationProvider config,
        SeededRandomService random,
        ILogger<ArchitecturalStyleService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public ArchitecturalStyle? GetStyle(string styleId)
    {
        if (string.IsNullOrWhiteSpace(styleId))
            return null;

        return _config.GetArchitecturalStyles()
            .FirstOrDefault(s => s.Id.Equals(styleId, StringComparison.OrdinalIgnoreCase));
    }

    /// <inheritdoc />
    public IReadOnlyList<ArchitecturalStyle> GetAllStyles()
    {
        return _config.GetArchitecturalStyles();
    }

    /// <inheritdoc />
    public IReadOnlyList<ArchitecturalStyle> GetStylesForBiome(string biomeId)
    {
        return _config.GetArchitecturalStyles()
            .Where(s => s.IsCompatibleWithBiome(biomeId))
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<ArchitecturalStyle> GetStylesForDepth(int depth)
    {
        return _config.GetArchitecturalStyles()
            .Where(s => s.IsValidForDepth(depth))
            .ToList();
    }

    /// <inheritdoc />
    public ArchitecturalStyle SelectStyleForPosition(Position3D position, string biomeId)
    {
        var validStyles = GetStylesForBiome(biomeId)
            .Where(s => s.IsValidForDepth(position.Z))
            .ToList();

        if (!validStyles.Any())
        {
            _logger.LogWarning(
                "No valid styles for biome {BiomeId} at depth {Depth}, using default style",
                biomeId,
                position.Z);

            return GetDefaultStyle();
        }

        // Use weighted selection based on style weights
        var weightedStyles = validStyles.Select(s => (Item: s, Weight: s.Weight));
        var selected = _random.SelectWeighted(position, weightedStyles, "style_select");

        _logger.LogDebug(
            "Selected style {StyleId} for position ({X}, {Y}, {Z}) in biome {BiomeId}",
            selected.Id,
            position.X,
            position.Y,
            position.Z,
            biomeId);

        return selected;
    }

    /// <inheritdoc />
    public bool IsCompatible(string styleId, string biomeId)
    {
        var style = GetStyle(styleId);
        return style?.IsCompatibleWithBiome(biomeId) ?? false;
    }

    /// <inheritdoc />
    public string GetRandomDescriptor(string styleId, string descriptorType, Position3D position)
    {
        var style = GetStyle(styleId);
        if (style == null)
        {
            _logger.LogWarning("Style {StyleId} not found for descriptor lookup", styleId);
            return string.Empty;
        }

        var pool = descriptorType.ToLowerInvariant() switch
        {
            "walls" => style.Descriptors.Walls,
            "floors" => style.Descriptors.Floors,
            "ceilings" => style.Descriptors.Ceilings,
            "passages" => style.Descriptors.Passages,
            "decorations" => style.Descriptors.Decorations,
            _ => Array.Empty<string>()
        };

        if (!pool.Any())
        {
            _logger.LogDebug(
                "No descriptors for type {Type} in style {StyleId}",
                descriptorType,
                styleId);
            return string.Empty;
        }

        var index = _random.NextForPosition(
            position,
            0,
            pool.Count,
            $"style_descriptor_{descriptorType}");

        return pool[index];
    }

    /// <inheritdoc />
    public IReadOnlyList<ArchitecturalStyle> GetStylesByTags(
        IEnumerable<string> tags,
        bool matchAll = false)
    {
        var tagList = tags.ToList();
        if (!tagList.Any())
            return Array.Empty<ArchitecturalStyle>();

        return _config.GetArchitecturalStyles()
            .Where(s => matchAll
                ? tagList.All(t => s.HasTag(t))
                : tagList.Any(t => s.HasTag(t)))
            .ToList();
    }

    /// <inheritdoc />
    public ArchitecturalStyle GetDefaultStyle()
    {
        var defaultStyle = GetStyle(DefaultStyleId);

        if (defaultStyle == null)
        {
            // Return first available style as fallback
            var allStyles = GetAllStyles();
            if (allStyles.Any())
            {
                _logger.LogWarning(
                    "Default style '{DefaultId}' not found, using first available",
                    DefaultStyleId);
                return allStyles.First();
            }

            // Create minimal fallback style
            _logger.LogError("No styles configured, creating minimal fallback");
            return ArchitecturalStyle.Create(
                "fallback",
                "Unknown",
                "A generic construction style.",
                StyleDescriptors.Default);
        }

        return defaultStyle;
    }
}
```

---

## 8. Room Style Integration

### 8.1 Purpose

Extend the `Room` entity to store the architectural style assignment for each room. This enables style-aware features throughout the game.

### 8.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modification)

### 8.3 Changes

```csharp
// Add to Room.cs

/// <summary>
/// Gets the architectural style ID for this room's construction pattern.
/// </summary>
/// <remarks>
/// Set during room generation based on biome compatibility and random selection.
/// </remarks>
public string ArchitecturalStyleId { get; private set; } = "carved-halls";

/// <summary>
/// Sets the architectural style for this room.
/// </summary>
/// <param name="styleId">The style identifier to assign.</param>
/// <exception cref="ArgumentException">Thrown when styleId is null or whitespace.</exception>
public void SetArchitecturalStyle(string styleId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(styleId, nameof(styleId));
    ArchitecturalStyleId = styleId;
}

/// <summary>
/// Gets whether this room has a specific architectural style assigned.
/// </summary>
/// <param name="styleId">The style identifier to check.</param>
/// <returns>True if the room has this style.</returns>
public bool HasArchitecturalStyle(string styleId)
{
    return ArchitecturalStyleId.Equals(styleId, StringComparison.OrdinalIgnoreCase);
}
```

### 8.4 Data Model Change

```
MODIFY: Room
├── ADD: ArchitecturalStyleId: string (default: "carved-halls")
├── ADD: SetArchitecturalStyle(styleId): void
└── ADD: HasArchitecturalStyle(styleId): bool
```

---

## 9. DescriptorService Integration

### 9.1 Purpose

Update the `DescriptorService` to support style-aware descriptor selection, allowing room descriptions to combine biome atmosphere with style structure.

### 9.2 File Location

**File:** `src/Core/RuneAndRust.Application/Services/DescriptorService.cs` (modification)

### 9.3 Changes

```csharp
// Add to DescriptorService interface and implementation

private readonly IArchitecturalStyleService _styleService;

/// <summary>
/// Gets a descriptor filtered by architectural style.
/// </summary>
/// <param name="category">The descriptor category.</param>
/// <param name="styleId">The style to use.</param>
/// <param name="position">Position for seeded randomization.</param>
/// <returns>A style-appropriate descriptor.</returns>
public string GetStyleDescriptor(string category, string styleId, Position3D position)
{
    // Get style-specific descriptor
    var styleDescriptor = _styleService.GetRandomDescriptor(styleId, category, position);

    if (!string.IsNullOrEmpty(styleDescriptor))
        return styleDescriptor;

    // Fall back to generic descriptor pool
    return GetDescriptor(category, position);
}

/// <summary>
/// Generates a full room description using both biome and style descriptors.
/// </summary>
/// <param name="room">The room to describe.</param>
/// <param name="position">Position for seeded randomization.</param>
/// <returns>A formatted room description combining biome and style.</returns>
public string GenerateStyledRoomDescription(Room room, Position3D position)
{
    var biomeId = room.BiomeId;
    var styleId = room.ArchitecturalStyleId;

    var biome = _biomeService.GetBiome(biomeId);
    var style = _styleService.GetStyle(styleId);

    if (biome == null || style == null)
    {
        _logger.LogWarning(
            "Biome {BiomeId} or style {StyleId} not found, using generic description",
            biomeId,
            styleId);
        return GenerateRoomDescription(room, position);
    }

    // Style descriptors (physical structure)
    var walls = GetStyleDescriptor("walls", styleId, position);
    var floor = GetStyleDescriptor("floors", styleId, position);
    var ceiling = GetStyleDescriptor("ceilings", styleId, position);
    var decoration = GetStyleDescriptor("decorations", styleId, position);

    // Biome descriptors (atmosphere)
    var lighting = GetBiomeDescriptor("lighting", biomeId, position);
    var smell = GetBiomeDescriptor("smells", biomeId, position);
    var atmosphere = GetBiomeDescriptor("atmosphere", biomeId, position);

    var description = new StringBuilder();

    // Build combined description
    description.Append($"You stand in a chamber with {walls} rising to {ceiling} above. ");
    description.Append($"The {floor} stretches beneath your feet");

    if (!string.IsNullOrEmpty(decoration))
        description.Append($", adorned with {decoration}");
    description.Append(". ");

    if (!string.IsNullOrEmpty(lighting))
        description.Append($"{CapitalizeFirst(lighting)} illuminates the space. ");

    if (!string.IsNullOrEmpty(smell))
        description.Append($"The scent of {smell} fills the air. ");

    if (!string.IsNullOrEmpty(atmosphere))
        description.Append($"A sense of {atmosphere} pervades the area.");

    return description.ToString().Trim();
}

private static string CapitalizeFirst(string text)
{
    if (string.IsNullOrEmpty(text))
        return text;
    return char.ToUpper(text[0]) + text.Substring(1);
}
```

---

## 10. Data Model Changes

### 10.1 Summary

```
NEW: ArchitecturalStyle (Definition)
├── Id: string (unique identifier)
├── Name: string (display name)
├── Description: string (codex text)
├── Descriptors: StyleDescriptors
├── Rules: StyleRules
├── CompatibleBiomes: IReadOnlyList<string>
├── PreferredShapes: IReadOnlyList<string>
├── CommonFeatures: IReadOnlyList<string>
├── Weight: int
├── UsesDoors: bool
├── HasCorridors: bool
├── MinDepth: int
├── MaxDepth: int?
├── Tags: IReadOnlyList<string>
├── IsValidForDepth(depth): bool
├── IsCompatibleWithBiome(biomeId): bool
└── HasTag(tag): bool

NEW: StyleDescriptors (Value Object)
├── Walls: IReadOnlyList<string>
├── Floors: IReadOnlyList<string>
├── Ceilings: IReadOnlyList<string>
├── Passages: IReadOnlyList<string>
├── Decorations: IReadOnlyList<string>
├── DescriptorPoolPrefix: string
├── GetRandomDescriptor(category, random): string
└── IsValid: bool

NEW: StyleRules (Value Object)
├── RoomSizeRange: (int Min, int Max)
├── MultipleExitChance: float
├── AverageExits: float
├── PrefersSymmetry: bool
├── PrefersRegularShapes: bool
├── CorridorWidth: int
├── HiddenPassageChance: float
├── TrapChance: float
├── MinRoomSize: int (computed)
├── MaxRoomSize: int (computed)
├── HasCorridors: bool (computed)
└── GetExitCount(random): int

MODIFY: Room
├── ADD: ArchitecturalStyleId: string
├── ADD: SetArchitecturalStyle(styleId): void
└── ADD: HasArchitecturalStyle(styleId): bool

MODIFY: IConfigurationProvider
└── ADD: GetArchitecturalStyles(): IReadOnlyList<ArchitecturalStyle>
```

---

## 11. Configuration File Schemas

### 11.1 Architectural Styles Configuration

**File:** `config/architectural-styles.json`

```json
{
  "$schema": "schemas/architectural-styles-schema.json",
  "styles": [
    {
      "id": "natural-caves",
      "name": "Natural Caves",
      "description": "Organic caverns formed by geological processes over millennia. Irregular shapes, no formal construction, natural formations throughout.",
      "compatibleBiomes": ["mines", "frozen-depths", "volcanic-caverns"],
      "preferredShapes": ["irregular", "circular"],
      "commonFeatures": ["stalactite", "stalagmite", "pool", "ledge"],
      "weight": 100,
      "usesDoors": false,
      "hasCorridors": false,
      "minDepth": 0,
      "maxDepth": null,
      "tags": ["organic", "natural", "cave"],
      "descriptors": {
        "walls": ["rough stone", "mineral-veined rock", "damp limestone", "jagged surfaces"],
        "floors": ["uneven ground", "scattered gravel", "smooth water-worn stone", "loose rubble"],
        "ceilings": ["stalactite clusters", "low overhangs", "high natural domes", "dripping moisture"],
        "passages": ["narrow squeeze", "winding tunnel", "natural fissure", "widening cavern"],
        "decorations": ["crystal formations", "phosphorescent moss", "mineral deposits", "ancient fossils"],
        "descriptorPoolPrefix": "style.caves"
      },
      "rules": {
        "roomSizeRange": [2, 12],
        "multipleExitChance": 0.7,
        "averageExits": 2.8,
        "prefersSymmetry": false,
        "prefersRegularShapes": false,
        "corridorWidth": 0,
        "hiddenPassageChance": 0.15,
        "trapChance": 0.05
      }
    },
    {
      "id": "carved-halls",
      "name": "Carved Halls",
      "description": "Precisely constructed passages with orderly architecture. Rectangular rooms, formal corridors, and deliberate stonework.",
      "compatibleBiomes": ["catacombs", "ancient-ruins", "mines"],
      "preferredShapes": ["rectangular", "l-shaped"],
      "commonFeatures": ["pillar", "alcove", "torch-sconce", "bench"],
      "weight": 100,
      "usesDoors": true,
      "hasCorridors": true,
      "minDepth": 0,
      "maxDepth": null,
      "tags": ["constructed", "orderly", "formal"],
      "descriptors": {
        "walls": ["smooth-cut stone", "precise masonry", "decorated panels", "torch sconces"],
        "floors": ["fitted flagstones", "geometric patterns", "worn pathways", "drainage channels"],
        "ceilings": ["vaulted arches", "supporting beams", "carved coffers", "hanging lanterns"],
        "passages": ["wide corridor", "pillared hall", "arched doorway", "grand passage"],
        "decorations": ["carved reliefs", "stone pillars", "alcove statues", "inscribed tablets"],
        "descriptorPoolPrefix": "style.halls"
      },
      "rules": {
        "roomSizeRange": [4, 10],
        "multipleExitChance": 0.5,
        "averageExits": 2.5,
        "prefersSymmetry": false,
        "prefersRegularShapes": true,
        "corridorWidth": 1,
        "hiddenPassageChance": 0.1,
        "trapChance": 0.15
      }
    },
    {
      "id": "ruined-structures",
      "name": "Ruined Structures",
      "description": "Collapsed and decaying remnants of once-grand construction. Rubble, gaps, and unstable areas throughout.",
      "compatibleBiomes": ["ancient-ruins", "catacombs"],
      "preferredShapes": ["irregular", "rectangular"],
      "commonFeatures": ["rubble", "collapsed-wall", "broken-pillar", "gap"],
      "weight": 80,
      "usesDoors": false,
      "hasCorridors": false,
      "minDepth": 2,
      "maxDepth": null,
      "tags": ["ruined", "collapsed", "dangerous"],
      "descriptors": {
        "walls": ["crumbling masonry", "collapsed sections", "exposed foundations", "vine-covered stone"],
        "floors": ["broken tiles", "debris piles", "treacherous gaps", "overgrown flagstones"],
        "ceilings": ["partially collapsed", "exposed sky", "precarious beams", "bird nests"],
        "passages": ["rubble-blocked", "improvised path", "collapsed tunnel", "unstable archway"],
        "decorations": ["shattered statues", "faded murals", "scattered artifacts", "nature reclaiming"],
        "descriptorPoolPrefix": "style.ruins"
      },
      "rules": {
        "roomSizeRange": [3, 10],
        "multipleExitChance": 0.4,
        "averageExits": 2.0,
        "prefersSymmetry": false,
        "prefersRegularShapes": false,
        "corridorWidth": 0,
        "hiddenPassageChance": 0.25,
        "trapChance": 0.2
      }
    },
    {
      "id": "ancient-temples",
      "name": "Ancient Temples",
      "description": "Grand sacred chambers with ceremonial architecture and divine imagery. Symmetrical layouts, wide corridors, and religious iconography.",
      "compatibleBiomes": ["ancient-ruins", "catacombs"],
      "preferredShapes": ["rectangular", "circular"],
      "commonFeatures": ["altar", "pillar", "statue", "offering-bowl", "eternal-flame"],
      "weight": 60,
      "usesDoors": true,
      "hasCorridors": true,
      "minDepth": 3,
      "maxDepth": null,
      "tags": ["sacred", "grand", "ceremonial"],
      "descriptors": {
        "walls": ["sacred inscriptions", "polished marble", "divine imagery", "gold inlays"],
        "floors": ["mosaic patterns", "ceremonial tiles", "altar platforms", "processional paths"],
        "ceilings": ["painted heavens", "domed sanctuaries", "hanging censers", "celestial motifs"],
        "passages": ["ritual corridor", "pilgrimage path", "sanctum approach", "ceremonial gate"],
        "decorations": ["divine statues", "offering bowls", "eternal flames", "sacred symbols"],
        "descriptorPoolPrefix": "style.temples"
      },
      "rules": {
        "roomSizeRange": [5, 15],
        "multipleExitChance": 0.4,
        "averageExits": 2.0,
        "prefersSymmetry": true,
        "prefersRegularShapes": true,
        "corridorWidth": 2,
        "hiddenPassageChance": 0.2,
        "trapChance": 0.25
      }
    }
  ]
}
```

### 11.2 JSON Schema

**File:** `config/schemas/architectural-styles-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "architectural-styles-schema.json",
  "title": "Architectural Styles Definitions",
  "description": "Schema for dungeon architectural style configuration",
  "type": "object",
  "required": ["styles"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "styles": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/architecturalStyle"
      }
    }
  },
  "$defs": {
    "architecturalStyle": {
      "type": "object",
      "required": ["id", "name", "descriptors", "rules"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier in kebab-case"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Display name for the style"
        },
        "description": {
          "type": "string",
          "description": "Codex/discovery description"
        },
        "compatibleBiomes": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Biome IDs compatible with this style (empty = all)"
        },
        "preferredShapes": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Preferred room shape IDs"
        },
        "commonFeatures": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Common structural feature IDs"
        },
        "weight": {
          "type": "integer",
          "minimum": 1,
          "default": 100,
          "description": "Selection probability weight"
        },
        "usesDoors": {
          "type": "boolean",
          "default": true,
          "description": "Whether this style uses doors between rooms"
        },
        "hasCorridors": {
          "type": "boolean",
          "default": true,
          "description": "Whether this style has formal corridors"
        },
        "minDepth": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Minimum Z-level for this style"
        },
        "maxDepth": {
          "type": ["integer", "null"],
          "minimum": 0,
          "description": "Maximum Z-level (null = unlimited)"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Categorization tags"
        },
        "descriptors": {
          "$ref": "#/$defs/styleDescriptors"
        },
        "rules": {
          "$ref": "#/$defs/styleRules"
        }
      }
    },
    "styleDescriptors": {
      "type": "object",
      "required": ["walls", "floors", "ceilings", "passages", "decorations"],
      "properties": {
        "walls": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        },
        "floors": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        },
        "ceilings": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        },
        "passages": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        },
        "decorations": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        },
        "descriptorPoolPrefix": {
          "type": "string",
          "pattern": "^style\\.[a-z]+$"
        }
      }
    },
    "styleRules": {
      "type": "object",
      "properties": {
        "roomSizeRange": {
          "type": "array",
          "items": { "type": "integer", "minimum": 1 },
          "minItems": 2,
          "maxItems": 2,
          "description": "[min, max] room size in tiles"
        },
        "multipleExitChance": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0,
          "default": 0.5
        },
        "averageExits": {
          "type": "number",
          "minimum": 1.0,
          "maximum": 6.0,
          "default": 2.5
        },
        "prefersSymmetry": {
          "type": "boolean",
          "default": false
        },
        "prefersRegularShapes": {
          "type": "boolean",
          "default": true
        },
        "corridorWidth": {
          "type": "integer",
          "minimum": 0,
          "maximum": 3,
          "default": 1
        },
        "hiddenPassageChance": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0,
          "default": 0.1
        },
        "trapChance": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0,
          "default": 0.15
        }
      }
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `ArchitecturalStyleService` | Information | Style loaded, style selected for position |
| `ArchitecturalStyleService` | Debug | Style lookup, descriptor selection |
| `ArchitecturalStyleService` | Warning | Style not found, no valid styles for context |
| `ArchitecturalStyleService` | Error | Configuration loading failure |
| `DescriptorService` | Debug | Style descriptor selection |
| `DescriptorService` | Warning | Fallback to generic descriptor |
| `Room` | Debug | Style assignment |

### 12.2 Log Message Examples

```csharp
// Information
_logger.LogInformation("Loaded {Count} architectural style definitions", styles.Count);
_logger.LogInformation("Selected style {StyleId} for position ({X}, {Y}, {Z}) in biome {BiomeId}",
    selected.Id, position.X, position.Y, position.Z, biomeId);

// Debug
_logger.LogDebug("Looking up style {StyleId}", styleId);
_logger.LogDebug("Selected descriptor '{Descriptor}' for {Type} in style {StyleId}",
    descriptor, type, styleId);
_logger.LogDebug("Getting styles compatible with biome {BiomeId}", biomeId);

// Warning
_logger.LogWarning("Style {StyleId} not found, using default", styleId);
_logger.LogWarning("No valid styles for biome {BiomeId} at depth {Depth}, using fallback",
    biomeId, depth);

// Error
_logger.LogError(ex, "Failed to load architectural style configuration from {Path}", configPath);
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| ArchitecturalStyle entity | ~6 |
| StyleDescriptors value object | ~4 |
| StyleRules value object | ~4 |
| ArchitecturalStyleService | ~5 |
| Room style integration | ~3 |
| **Total** | **~22** |

### 13.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `ArchitecturalStyleTests.cs` | ~6 | Create, validation, IsValidForDepth, IsCompatibleWithBiome, HasTag |
| `StyleDescriptorsTests.cs` | ~4 | Default, GetRandomDescriptor, IsValid, static factories |
| `StyleRulesTests.cs` | ~4 | Default, GetExitCount, static factories, computed properties |
| `ArchitecturalStyleServiceTests.cs` | ~5 | GetStyle, GetStylesForBiome, SelectStyleForPosition, GetRandomDescriptor |
| `RoomStyleTests.cs` | ~3 | SetArchitecturalStyle, HasArchitecturalStyle |

### 13.3 Test Categories

**ArchitecturalStyle Tests:**
```csharp
[Test]
public void Create_WithValidParameters_CreatesArchitecturalStyle()

[Test]
public void Create_WithNullId_ThrowsArgumentException()

[Test]
public void Create_WithNegativeMinDepth_ThrowsArgumentOutOfRangeException()

[Test]
public void Create_WithMaxDepthLessThanMinDepth_ThrowsArgumentException()

[Test]
public void IsValidForDepth_WithDepthInRange_ReturnsTrue()

[Test]
public void IsValidForDepth_WithDepthBelowMin_ReturnsFalse()

[Test]
public void IsCompatibleWithBiome_WithEmptyList_ReturnsTrue()

[Test]
public void IsCompatibleWithBiome_WithMatchingBiome_ReturnsTrue()

[Test]
public void HasTag_WithMatchingTag_ReturnsTrue()

[Test]
public void HasTag_WithNoMatchingTag_ReturnsFalse()
```

**ArchitecturalStyleService Tests:**
```csharp
[Test]
public void GetStyle_WithExistingId_ReturnsStyle()

[Test]
public void GetStyle_WithNonExistingId_ReturnsNull()

[Test]
public void GetStylesForBiome_ReturnsCompatibleStyles()

[Test]
public void SelectStyleForPosition_ReturnsValidStyleForBiomeAndDepth()

[Test]
public void SelectStyleForPosition_WithNoValidStyles_ReturnsDefault()

[Test]
public void GetRandomDescriptor_ReturnsDescriptorFromPool()
```

---

## 14. Use Cases

### UC-001: Generate Room with Style

**Actor:** System (Room Generator)
**Flow:** Room generated → BiomeService assigns biome → ArchitecturalStyleService.SelectStyleForPosition(position, biomeId) → Room.SetArchitecturalStyle(styleId) → Room has biome and style

### UC-002: Display Style-Themed Room

**Actor:** Player
**Flow:** Player enters room → DescriptorService.GenerateStyledRoomDescription(room, position) → Biome + style descriptors combined → Themed description displayed

### UC-003: Filter Styles by Biome

**Actor:** System (Room Generator)
**Flow:** Generating room in biome → ArchitecturalStyleService.GetStylesForBiome(biomeId) → Compatible styles returned → Weighted selection performed

### UC-004: Filter Styles by Depth

**Actor:** System (Room Generator)
**Flow:** Generating room at depth Z → ArchitecturalStyleService.GetStylesForDepth(Z) → Valid styles returned → Combined with biome filter

### UC-005: Look Up Style Information

**Actor:** System (UI/Codex)
**Flow:** Display style info → ArchitecturalStyleService.GetStyle(styleId) → ArchitecturalStyle returned → Name, description, rules displayed

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `ArchitecturalStyle.cs` created
- [ ] `StyleDescriptors.cs` created
- [ ] `StyleRules.cs` created
- [ ] `Room.cs` updated with ArchitecturalStyleId

### Application Layer
- [ ] `IArchitecturalStyleService.cs` created
- [ ] `ArchitecturalStyleService.cs` created
- [ ] `DescriptorService.cs` updated with style support

### Infrastructure Layer
- [ ] `IConfigurationProvider.cs` updated
- [ ] `JsonConfigurationProvider.cs` updated to load styles
- [ ] `ArchitecturalStyleConfigurationDto.cs` created

### Configuration Files
- [ ] `config/architectural-styles.json` created with 4 default styles
- [ ] `config/schemas/architectural-styles-schema.json` created

### Testing
- [ ] `ArchitecturalStyleTests.cs` created (~6 tests)
- [ ] `StyleDescriptorsTests.cs` created (~4 tests)
- [ ] `StyleRulesTests.cs` created (~4 tests)
- [ ] `ArchitecturalStyleServiceTests.cs` created (~5 tests)
- [ ] `RoomStyleTests.cs` created (~3 tests)
- [ ] All ~22 tests passing

### Documentation
- [ ] XML documentation on all public members
- [ ] Code follows .editorconfig conventions

---

## 16. Acceptance Criteria

### Functional

- [ ] ArchitecturalStyle entity stores all style properties
- [ ] StyleDescriptors provides 5 descriptor categories (walls, floors, ceilings, passages, decorations)
- [ ] StyleRules defines construction parameters
- [ ] ArchitecturalStyleService loads styles from JSON configuration
- [ ] ArchitecturalStyleService.GetStyle returns definition by ID
- [ ] ArchitecturalStyleService.GetStylesForBiome filters by compatibility
- [ ] ArchitecturalStyleService.GetStylesForDepth filters by depth constraints
- [ ] ArchitecturalStyleService.SelectStyleForPosition uses weighted selection
- [ ] ArchitecturalStyleService.GetRandomDescriptor returns seeded descriptor
- [ ] Room.ArchitecturalStyleId stores assigned style
- [ ] Room.SetArchitecturalStyle validates and assigns style
- [ ] DescriptorService generates style-biome combined descriptions
- [ ] Four default styles configured with unique characteristics

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~22 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on public members
- [ ] Code follows .editorconfig conventions
- [ ] No hardcoded descriptor strings outside configuration

---

## 17. Dependencies

### 17.1 Prerequisites (v0.1.2)

| Component | Purpose for v0.1.3a |
|-----------|---------------------|
| `BiomeDefinition` | Biome compatibility filtering |
| `BiomeService` | Biome lookup for style selection |
| `BiomeDescriptors` | Pattern for StyleDescriptors |
| `SeededRandomService` | Reproducible style selection |
| `DescriptorService` | Base for style descriptor integration |
| `Room.BiomeId` | Biome context for style selection |
| `IConfigurationProvider` | Configuration loading pattern |
| `Position3D` | Position-based seeded randomization |

### 17.2 Provides to Future Phases

| Component | Used By |
|-----------|---------|
| `ArchitecturalStyle` | v0.1.3b (Room Shapes), v0.1.3c (Landmarks), v0.1.3d (Coherence) |
| `ArchitecturalStyleService` | All subsequent v0.1.3 phases |
| `Room.ArchitecturalStyleId` | All style-aware features |
| `StyleDescriptors` | Room generation, description service |
| `StyleRules` | Room generation, feature placement |
| `PreferredShapes` | v0.1.3b shape selection |
| `CommonFeatures` | v0.1.3b feature placement |

### 17.3 Dependency Diagram

```
v0.1.2 (Dungeon Theming & Biomes)
    │
    ├── BiomeDefinition ─────────────────────┐
    ├── BiomeService ────────────────────────┤
    ├── BiomeDescriptors ────────────────────┤
    ├── SeededRandomService ─────────────────┤
    └── DescriptorService ───────────────────┘
                                             │
                                             ▼
v0.1.3a (Architectural Styles)
    │
    ├── ArchitecturalStyle ─────────────────────────────────────┐
    ├── StyleDescriptors ───────────────────────────────────────│
    ├── StyleRules ─────────────────────────────────────────────│
    ├── ArchitecturalStyleService ──────────────────────────────┤
    └── Room.ArchitecturalStyleId ──────────────────────────────┘
                                                                │
                                                                ▼
                                      ┌─────────────────────────┴─────────────────────────┐
                                      │                                                   │
                                      ▼                                                   ▼
                              v0.1.3b (Room Shapes)                           v0.1.3c (Landmarks)
                                      │                                                   │
                                      └─────────────────────────┬─────────────────────────┘
                                                                │
                                                                ▼
                                                  v0.1.3d (Age & Coherence)
```

---

## 18. Future Considerations

### 18.1 Deferred to v0.1.3b

- **RoomShape integration** - PreferredShapes used for shape selection
- **StructuralFeature integration** - CommonFeatures used for feature placement
- **Shape-based exit placement** - StyleRules.PrefersRegularShapes affects exit logic

### 18.2 Deferred to v0.1.3c

- **LandmarkRoom style compatibility** - Landmarks filter by compatible styles
- **Boss arena style requirements** - Specific styles for boss encounters

### 18.3 Deferred to v0.1.3d

- **DungeonAge style interactions** - Age affects style descriptors
- **CoherenceRules** - Style consistency validation
- **MaterialPalette** - Style affects material selection

### 18.4 Out of Scope (Future Versions)

- **Custom style creation UI** - Player/modder style editor
- **Dynamic style evolution** - Styles changing over time
- **Style-specific quests** - Quest chains tied to architectural styles
- **Style music/sound themes** - Audio integration

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
