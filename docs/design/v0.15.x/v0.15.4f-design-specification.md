# v0.15.4f Design Specification: Glitch Exploitation System

**Version:** 0.15.4f
**Theme:** Glitch Exploitation (Pattern Observation & Chaos)
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0 Complete (Dice Pool Refactor), v0.15.1 Complete (Skill Infrastructure), v0.15.4a Complete (Lockpicking System), v0.15.4b Complete (Terminal Hacking System), v0.15.4c Complete (ICE Countermeasures), v0.15.4d Complete (Trap Disarmament System), v0.15.4e Complete (Jury-Rigging System)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [GlitchState Value Object](#4-glitchstate-value-object)
5. [GlitchCyclePhase Enum](#5-glitchcyclephase-enum)
6. [ChaosRoll System](#6-chaosroll-system)
7. [GlitchExploitationService](#7-glitchexploitationservice-implementation)
8. [Pattern Identification Mechanics](#8-pattern-identification-mechanics)
9. [Timing-Based Exploitation](#9-timing-based-exploitation)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration Files](#11-configuration-files)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

The Glitch Exploitation System enables characters to leverage the corrupted, unstable behavior of [Glitched] Old World technology. Rather than fighting against a mechanism's erratic patterns, skilled characters learn to observe, predict, and exploit these glitches—timing their actions to coincide with permissive states or favorable malfunctions.

This phase builds upon v0.15.4e's `GlitchExploitation` bypass method by implementing the full pattern observation mechanics, cycle phase tracking, and the chaos roll system for unpredictable glitch behavior.

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Value Objects** | `GlitchState` |
| **Enums** | `GlitchCyclePhase` (implicit in state tracking) |
| **Services** | `GlitchExploitationService` |
| **Configuration** | `glitch-cycles.json` |
| **Tests** | ~2 new unit tests |

### 1.3 Architectural Significance

This version establishes the **Corrupted Technology Interaction Pattern** that reflects Aethelgard's "cargo cult" theme:

- **Pattern Observation**: Characters watch for repeating behaviors without understanding why
- **Timing Windows**: Exploiting permissive states during glitch cycles
- **Chaos as Resource**: Unpredictable behavior can help or hinder
- **Risk-Reward Gambling**: The -4 DC bonus comes with unpredictable consequences

---

## 2. Feature Overview

```
v0.15.4f Glitch Exploitation System
├── GlitchState Value Object
│   ├── GlitchCycleIdentified (bool)
│   ├── CyclePhase (current position)
│   ├── ExploitWindow (when to act)
│   └── ChaosRoll (d6 result)
├── Pattern Identification
│   ├── Observation Check (WITS DC 14)
│   ├── Success: Identify cycle timing
│   └── Failure: Random chaos effects
├── Timing-Based Exploitation
│   ├── Identified Pattern: -4 DC bonus
│   ├── Exploit Window: Optimal action timing
│   └── Missed Window: Normal difficulty
└── Chaos Roll System (d6)
    ├── 1-2: Glitch works against you (+4 DC)
    ├── 3-4: Normal difficulty (+0)
    └── 5-6: Glitch helps (-2 DC)
```

---

## 3. Architecture Diagrams

### 3.1 Glitch Exploitation Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      GLITCH EXPLOITATION FLOW                                │
└─────────────────────────────────────────────────────────────────────────────┘

    Character encounters [Glitched] mechanism
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      IS MECHANISM GLITCHED?                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  Check mechanism's CorruptionLevel                                           │
│  ┌─────────────┐                    ┌─────────────┐                         │
│  │ NOT Glitched│                    │ [Glitched]  │                         │
│  │             │                    │             │                         │
│  │ Cannot use  │                    │ Proceed to  │                         │
│  │ exploitation│                    │ observation │                         │
│  └──────┬──────┘                    └──────┬──────┘                         │
│         │                                  │                                │
│         ▼                                  ▼                                │
│  Use other methods              ┌─────────────────────┐                     │
│  (normal bypass)                │ PATTERN OBSERVATION │                     │
│                                 └──────────┬──────────┘                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                             │
                                             ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 1: OBSERVE PATTERN (Optional)                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  WITS check DC 14 to identify glitch cycle                                   │
│                                                                              │
│  ┌─────────────────────────────┐    ┌─────────────────────────────┐        │
│  │        SUCCESS              │    │        FAILURE              │        │
│  ├─────────────────────────────┤    ├─────────────────────────────┤        │
│  │ • Identify cycle pattern    │    │ • Pattern remains unknown   │        │
│  │ • Learn exploit window      │    │ • Must proceed blind        │        │
│  │ • Can time actions          │    │ • Roll on chaos table       │        │
│  │ • Guaranteed -4 DC bonus    │    │ • DC modifier is random     │        │
│  └─────────────┬───────────────┘    └─────────────┬───────────────┘        │
└────────────────┼──────────────────────────────────┼─────────────────────────┘
                 │                                  │
                 ▼                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 2: TIME ACTION OR ROLL CHAOS                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────┐    ┌─────────────────────────────┐        │
│  │    PATTERN IDENTIFIED       │    │    PATTERN UNKNOWN          │        │
│  ├─────────────────────────────┤    ├─────────────────────────────┤        │
│  │ Wait for exploit window     │    │ Roll d6 on Chaos Table      │        │
│  │                             │    │                             │        │
│  │ ┌─────────┐ ┌─────────┐    │    │ ┌─────────────────────────┐ │        │
│  │ │ IN      │ │ OUTSIDE │    │    │ │   CHAOS ROLL (d6)       │ │        │
│  │ │ WINDOW  │ │ WINDOW  │    │    │ ├─────────────────────────┤ │        │
│  │ │         │ │         │    │    │ │ 1-2: +4 DC (against)    │ │        │
│  │ │ -4 DC   │ │ +0 DC   │    │    │ │ 3-4: +0 DC (neutral)    │ │        │
│  │ │ bonus   │ │ normal  │    │    │ │ 5-6: -2 DC (helps)      │ │        │
│  │ └────┬────┘ └────┬────┘    │    │ └──────────┬──────────────┘ │        │
│  └──────┼───────────┼─────────┘    └────────────┼────────────────┘        │
└─────────┼───────────┼──────────────────────────┼────────────────────────────┘
          └─────┬─────┘                          │
                └────────────────┬───────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 3: ATTEMPT BYPASS                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  System Bypass check vs. Modified DC                                         │
│                                                                              │
│  Base DC = Mechanism DC                                                      │
│  Modified DC = Base DC + Glitch Modifier (from timing or chaos)              │
│                                                                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ CRITICAL    │  │ SUCCESS     │  │ FAILURE     │  │ FUMBLE      │        │
│  │ Net ≥5      │  │ Net >0      │  │ Net ≤0      │  │ 0 succ      │        │
│  │             │  │             │  │ No botch    │  │ ≥1 botch    │        │
│  │ Bypass +    │  │ Mechanism   │  │ Glitch      │  │ Mechanism   │        │
│  │ Salvage +   │  │ Bypassed    │  │ destabilizes│  │ explodes or │        │
│  │ Learn cycle │  │             │  │ May retry   │  │ locks       │        │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Glitch Cycle Visualization

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         GLITCH CYCLE PHASES                                  │
└─────────────────────────────────────────────────────────────────────────────┘

    The glitch cycles through predictable (once observed) phases:

    ┌────────────────────────────────────────────────────────────────────────┐
    │                                                                        │
    │   STABLE        UNSTABLE       PERMISSIVE      LOCKDOWN      STABLE   │
    │   ┌───┐         ┌───┐          ┌───┐          ┌───┐         ┌───┐    │
    │   │   │ ──────▶ │   │ ──────▶  │   │ ──────▶  │   │ ──────▶ │   │    │
    │   └───┘         └───┘          └───┘          └───┘         └───┘    │
    │                                  ▲                                    │
    │                                  │                                    │
    │                         EXPLOIT WINDOW                                │
    │                         Act here for -4 DC                            │
    │                                                                        │
    └────────────────────────────────────────────────────────────────────────┘

    Phase Descriptions:
    ┌─────────────┬───────────────────────────────────────────────────────────┐
    │ STABLE      │ Mechanism operates normally (with [Glitched] DC penalty)  │
    ├─────────────┼───────────────────────────────────────────────────────────┤
    │ UNSTABLE    │ Lights flicker, sounds distort, behavior becomes erratic  │
    ├─────────────┼───────────────────────────────────────────────────────────┤
    │ PERMISSIVE  │ Security momentarily lapses, defenses down (EXPLOIT NOW!) │
    ├─────────────┼───────────────────────────────────────────────────────────┤
    │ LOCKDOWN    │ System compensates, temporarily more secure (+2 DC)       │
    └─────────────┴───────────────────────────────────────────────────────────┘

    Cycle Duration: Varies by mechanism type (1d4+1 rounds per phase)
```

### 3.3 Service Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  ConsoleInputHandler          IGameRenderer                                  │
│  - ParseGlitchObserveCommand()- RenderGlitchCycleAsync()                    │
│  - ParseGlitchExploitCommand()- RenderChaosRollAsync()                      │
│                               - RenderExploitWindowAsync()                   │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  GameEngine                                                                  │
│  - HandleGlitchObservationAsync()                                           │
│  - HandleGlitchExploitAsync()                                               │
│  - TrackGlitchCyclePhase()                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN SERVICES                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ GlitchExploitationService                                            │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ + ObserveGlitchPattern(character, mechanism) → ObservationResult    │   │
│  │ + GetCurrentCyclePhase(glitchState) → GlitchCyclePhase              │   │
│  │ + IsInExploitWindow(glitchState) → bool                             │   │
│  │ + CalculateGlitchModifier(glitchState) → int                        │   │
│  │ + RollChaos(diceRoller) → ChaosResult                               │   │
│  │ + AttemptExploit(state, context, skill) → ExploitResult             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Integration with JuryRiggingService (v0.15.4e):                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ When BypassMethod.GlitchExploitation is selected:                    │   │
│  │ 1. Check mechanism is [Glitched]                                     │   │
│  │ 2. Optionally observe pattern (WITS DC 14)                           │   │
│  │ 3. Calculate DC modifier from glitch state                           │   │
│  │ 4. Proceed with bypass attempt                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN VALUE OBJECTS                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  GlitchState               ChaosResult               ObservationResult      │
│  - GlitchCycleIdentified   - Roll (1-6)              - Success              │
│  - CyclePhase              - Modifier                - CycleIdentified      │
│  - ExploitWindow           - NarrativeText           - NextExploitWindow    │
│  - ChaosRoll                                         - NarrativeText        │
│  - PhaseDuration                                                            │
│  - PhaseStartTime                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. GlitchState Value Object

### 4.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/GlitchState.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Captures the current state of a glitch cycle for a [Glitched] mechanism,
/// including whether the pattern has been identified and the current phase.
/// </summary>
/// <remarks>
/// Glitched mechanisms cycle through phases: Stable → Unstable → Permissive → Lockdown.
/// Characters who observe the pattern (WITS DC 14) can time their actions to exploit
/// the Permissive phase for a -4 DC bonus. Those who don't observe must roll on the
/// Chaos table for a random modifier.
/// </remarks>
/// <param name="GlitchCycleIdentified">True if character has successfully observed the pattern.</param>
/// <param name="CyclePhase">Current phase of the glitch cycle.</param>
/// <param name="ExploitWindow">The phase during which exploitation grants -4 DC.</param>
/// <param name="ChaosRoll">The d6 chaos roll result (null if pattern was identified).</param>
/// <param name="PhaseDuration">How many rounds the current phase lasts.</param>
/// <param name="RoundsInCurrentPhase">How many rounds have passed in current phase.</param>
public readonly record struct GlitchState(
    bool GlitchCycleIdentified,
    GlitchCyclePhase CyclePhase,
    GlitchCyclePhase ExploitWindow,
    int? ChaosRoll,
    int PhaseDuration,
    int RoundsInCurrentPhase)
{
    /// <summary>
    /// The default exploit window phase.
    /// </summary>
    public static readonly GlitchCyclePhase DefaultExploitWindow = GlitchCyclePhase.Permissive;

    /// <summary>
    /// Gets whether the character is currently in the exploit window.
    /// </summary>
    public bool IsInExploitWindow => GlitchCycleIdentified && CyclePhase == ExploitWindow;

    /// <summary>
    /// Gets the DC modifier based on current glitch state.
    /// </summary>
    /// <remarks>
    /// If pattern identified and in exploit window: -4 DC
    /// If pattern identified but outside window: +0 DC
    /// If pattern not identified: Based on chaos roll
    /// </remarks>
    public int DcModifier
    {
        get
        {
            if (GlitchCycleIdentified)
            {
                return IsInExploitWindow ? -4 : 0;
            }

            // Pattern not identified - use chaos roll
            return ChaosRoll switch
            {
                1 or 2 => +4,  // Glitch works against you
                3 or 4 => 0,   // Normal difficulty
                5 or 6 => -2,  // Glitch helps
                _ => 0         // Fallback
            };
        }
    }

    /// <summary>
    /// Gets a description of the current glitch state.
    /// </summary>
    public string StateDescription => CyclePhase switch
    {
        GlitchCyclePhase.Stable => "The mechanism operates with its usual erratic hum.",
        GlitchCyclePhase.Unstable => "Lights flicker and strange sounds emanate from within.",
        GlitchCyclePhase.Permissive => "The mechanism's defenses momentarily lapse!",
        GlitchCyclePhase.Lockdown => "The system compensates, becoming more resistant.",
        _ => "The glitch state is indeterminate."
    };

    /// <summary>
    /// Gets how many rounds until the next phase transition.
    /// </summary>
    public int RoundsUntilPhaseChange => Math.Max(0, PhaseDuration - RoundsInCurrentPhase);

    /// <summary>
    /// Creates an initial glitch state for an unobserved mechanism.
    /// </summary>
    /// <param name="initialPhase">The starting phase of the cycle.</param>
    /// <param name="phaseDuration">Duration of each phase in rounds.</param>
    /// <returns>A new unobserved GlitchState.</returns>
    public static GlitchState CreateUnobserved(
        GlitchCyclePhase initialPhase = GlitchCyclePhase.Stable,
        int phaseDuration = 2)
    {
        return new GlitchState(
            GlitchCycleIdentified: false,
            CyclePhase: initialPhase,
            ExploitWindow: DefaultExploitWindow,
            ChaosRoll: null,
            PhaseDuration: phaseDuration,
            RoundsInCurrentPhase: 0);
    }

    /// <summary>
    /// Creates a glitch state after successful pattern observation.
    /// </summary>
    /// <param name="currentPhase">The observed current phase.</param>
    /// <param name="exploitWindow">The identified exploit window phase.</param>
    /// <param name="phaseDuration">Duration of each phase in rounds.</param>
    /// <returns>A new observed GlitchState.</returns>
    public static GlitchState CreateObserved(
        GlitchCyclePhase currentPhase,
        GlitchCyclePhase exploitWindow,
        int phaseDuration)
    {
        return new GlitchState(
            GlitchCycleIdentified: true,
            CyclePhase: currentPhase,
            ExploitWindow: exploitWindow,
            ChaosRoll: null,
            PhaseDuration: phaseDuration,
            RoundsInCurrentPhase: 0);
    }

    /// <summary>
    /// Creates a glitch state with a chaos roll (pattern not identified).
    /// </summary>
    /// <param name="chaosRoll">The d6 chaos roll result (1-6).</param>
    /// <param name="currentPhase">The current phase (unknown to character).</param>
    /// <returns>A new GlitchState with chaos modifier.</returns>
    public static GlitchState CreateWithChaos(int chaosRoll, GlitchCyclePhase currentPhase)
    {
        if (chaosRoll < 1 || chaosRoll > 6)
            throw new ArgumentOutOfRangeException(nameof(chaosRoll), "Chaos roll must be 1-6");

        return new GlitchState(
            GlitchCycleIdentified: false,
            CyclePhase: currentPhase,
            ExploitWindow: DefaultExploitWindow,
            ChaosRoll: chaosRoll,
            PhaseDuration: 0,
            RoundsInCurrentPhase: 0);
    }

    /// <summary>
    /// Advances to the next phase in the cycle.
    /// </summary>
    /// <returns>A new GlitchState in the next phase.</returns>
    public GlitchState AdvancePhase()
    {
        var nextPhase = CyclePhase switch
        {
            GlitchCyclePhase.Stable => GlitchCyclePhase.Unstable,
            GlitchCyclePhase.Unstable => GlitchCyclePhase.Permissive,
            GlitchCyclePhase.Permissive => GlitchCyclePhase.Lockdown,
            GlitchCyclePhase.Lockdown => GlitchCyclePhase.Stable,
            _ => GlitchCyclePhase.Stable
        };

        return this with
        {
            CyclePhase = nextPhase,
            RoundsInCurrentPhase = 0
        };
    }

    /// <summary>
    /// Advances the round counter within the current phase.
    /// </summary>
    /// <returns>A new GlitchState with incremented round count, or advanced phase if duration exceeded.</returns>
    public GlitchState AdvanceRound()
    {
        if (RoundsInCurrentPhase + 1 >= PhaseDuration)
        {
            return AdvancePhase();
        }

        return this with { RoundsInCurrentPhase = RoundsInCurrentPhase + 1 };
    }

    /// <summary>
    /// Creates a display string for the glitch state.
    /// </summary>
    public string ToDisplayString()
    {
        var lines = new List<string>();

        if (GlitchCycleIdentified)
        {
            lines.Add($"Pattern: IDENTIFIED");
            lines.Add($"Current Phase: {CyclePhase}");
            lines.Add($"Exploit Window: {ExploitWindow}");

            if (IsInExploitWindow)
                lines.Add("★ IN EXPLOIT WINDOW (-4 DC) ★");
            else
                lines.Add($"Rounds until {ExploitWindow}: ~{EstimateRoundsToExploitWindow()}");
        }
        else if (ChaosRoll.HasValue)
        {
            lines.Add($"Pattern: UNKNOWN (Chaos Roll: {ChaosRoll})");
            lines.Add($"Effect: {GetChaosDescription()}");
        }
        else
        {
            lines.Add("Pattern: UNOBSERVED");
            lines.Add("Observe pattern (WITS DC 14) or proceed blind.");
        }

        return string.Join(Environment.NewLine, lines);
    }

    private int EstimateRoundsToExploitWindow()
    {
        // Simplified estimation - would be more complex in real implementation
        var phases = new[] {
            GlitchCyclePhase.Stable,
            GlitchCyclePhase.Unstable,
            GlitchCyclePhase.Permissive,
            GlitchCyclePhase.Lockdown
        };

        var currentIndex = Array.IndexOf(phases, CyclePhase);
        var targetIndex = Array.IndexOf(phases, ExploitWindow);

        var phasesToWait = (targetIndex - currentIndex + 4) % 4;
        return (phasesToWait * PhaseDuration) - RoundsInCurrentPhase;
    }

    private string GetChaosDescription() => ChaosRoll switch
    {
        1 or 2 => "Glitch works AGAINST you (+4 DC)",
        3 or 4 => "Neutral effect (+0 DC)",
        5 or 6 => "Glitch HELPS you (-2 DC)",
        _ => "Unknown effect"
    };
}

/// <summary>
/// The phases of a glitch cycle in corrupted Old World technology.
/// </summary>
public enum GlitchCyclePhase
{
    /// <summary>
    /// Mechanism operates with normal [Glitched] behavior.
    /// </summary>
    Stable,

    /// <summary>
    /// Erratic behavior increases, lights flicker, sounds distort.
    /// </summary>
    Unstable,

    /// <summary>
    /// Security momentarily lapses—the exploit window for -4 DC bonus.
    /// </summary>
    Permissive,

    /// <summary>
    /// System compensates, temporarily more resistant (+2 DC).
    /// </summary>
    Lockdown
}
```

---

## 5. GlitchCyclePhase Enum

### 5.1 Phase Definitions

The `GlitchCyclePhase` enum is defined within the `GlitchState` value object file (Section 4). Here we document the phase mechanics in detail.

### 5.2 Phase Mechanics Table

| Phase | Duration | DC Effect | Visual Indicators | Audio Indicators |
|-------|----------|-----------|-------------------|------------------|
| `Stable` | 1d4+1 rounds | +0 (normal [Glitched]) | Steady but flickering lights | Low hum |
| `Unstable` | 1d4+1 rounds | +0 | Rapid flickering, sparks | Crackling, whine |
| `Permissive` | 1d4 rounds | -4 DC (exploit!) | Lights dim, panels open | Silence, clicks |
| `Lockdown` | 1d4+1 rounds | +2 DC | Red warning lights | Alarm tone |

### 5.3 Phase Transition Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         GLITCH CYCLE STATE MACHINE                           │
└─────────────────────────────────────────────────────────────────────────────┘

                              ┌─────────────┐
                              │   STABLE    │
                              │   +0 DC     │
                              │ 1d4+1 rnds  │
                              └──────┬──────┘
                                     │
                                     │ Duration expires
                                     ▼
                              ┌─────────────┐
                              │  UNSTABLE   │
                              │   +0 DC     │
                              │ 1d4+1 rnds  │
                              └──────┬──────┘
                                     │
                                     │ Duration expires
                                     ▼
                              ┌─────────────┐
            ┌────────────────▶│ PERMISSIVE  │◀─── EXPLOIT WINDOW
            │                 │   -4 DC     │     Act here!
            │                 │  1d4 rnds   │
            │                 └──────┬──────┘
            │                        │
            │                        │ Duration expires
            │                        ▼
            │                 ┌─────────────┐
            │                 │  LOCKDOWN   │
            │                 │   +2 DC     │
            │                 │ 1d4+1 rnds  │
            │                 └──────┬──────┘
            │                        │
            │                        │ Duration expires
            └────────────────────────┘
                    (Cycle repeats)
```

---

## 6. ChaosRoll System

### 6.1 Overview

When a character attempts to exploit a [Glitched] mechanism without first observing its pattern, they must roll on the Chaos table. The unpredictable nature of corrupted technology means it might help, hinder, or have no effect.

### 6.2 Chaos Table

| d6 Roll | Effect | DC Modifier | Description |
|---------|--------|-------------|-------------|
| 1-2 | Against | +4 DC | The glitch actively resists your interference |
| 3-4 | Neutral | +0 DC | The glitch has no particular effect |
| 5-6 | Helps | -2 DC | The glitch coincidentally aids your attempt |

### 6.3 ChaosResult Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ChaosResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Captures the result of a chaos roll when exploiting a glitch without
/// first identifying the pattern.
/// </summary>
/// <param name="Roll">The d6 roll result (1-6).</param>
/// <param name="Effect">The effect category (Against, Neutral, Helps).</param>
/// <param name="DcModifier">The DC modifier to apply.</param>
/// <param name="NarrativeText">Descriptive text for the chaos effect.</param>
public readonly record struct ChaosResult(
    int Roll,
    ChaosEffect Effect,
    int DcModifier,
    string NarrativeText)
{
    /// <summary>
    /// Creates a ChaosResult from a d6 roll.
    /// </summary>
    /// <param name="roll">The d6 roll (1-6).</param>
    /// <returns>A ChaosResult with appropriate effect.</returns>
    public static ChaosResult FromRoll(int roll)
    {
        if (roll < 1 || roll > 6)
            throw new ArgumentOutOfRangeException(nameof(roll), "Roll must be 1-6");

        return roll switch
        {
            1 or 2 => new ChaosResult(
                Roll: roll,
                Effect: ChaosEffect.Against,
                DcModifier: +4,
                NarrativeText: "The glitch pulses angrily as you approach, its erratic behavior " +
                              "intensifying as if the machine itself rejects your interference. " +
                              "Security protocols flare to life in unexpected ways."),

            3 or 4 => new ChaosResult(
                Roll: roll,
                Effect: ChaosEffect.Neutral,
                DcModifier: 0,
                NarrativeText: "The machine's corrupted patterns continue their chaotic dance, " +
                              "neither helping nor hindering your attempt. You proceed against " +
                              "the normal [Glitched] resistance."),

            5 or 6 => new ChaosResult(
                Roll: roll,
                Effect: ChaosEffect.Helps,
                DcModifier: -2,
                NarrativeText: "Fortune favors the bold! The glitch cycles into a momentarily " +
                              "permissive state just as you act. The machine's own malfunction " +
                              "becomes your ally."),

            _ => throw new InvalidOperationException("Unexpected roll value")
        };
    }

    /// <summary>
    /// Gets a short description of the effect.
    /// </summary>
    public string EffectSummary => Effect switch
    {
        ChaosEffect.Against => $"Glitch works against you (+{DcModifier} DC)",
        ChaosEffect.Neutral => "Neutral effect (no modifier)",
        ChaosEffect.Helps => $"Glitch helps you ({DcModifier} DC)",
        _ => "Unknown effect"
    };
}

/// <summary>
/// The effect categories for chaos rolls.
/// </summary>
public enum ChaosEffect
{
    /// <summary>d6 = 1-2: Glitch actively resists, +4 DC.</summary>
    Against,

    /// <summary>d6 = 3-4: No particular effect, +0 DC.</summary>
    Neutral,

    /// <summary>d6 = 5-6: Glitch aids the attempt, -2 DC.</summary>
    Helps
}
```

### 6.4 Chaos Effect Descriptions

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ⚠️  CHAOS EFFECT: AGAINST (d6 = 1-2)                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  The glitch pulses angrily as you approach. Its erratic behavior            │
│  intensifies as if the machine itself rejects your interference.            │
│  Security protocols flare to life in unexpected ways.                        │
│                                                                              │
│  Effect: +4 DC to bypass attempt                                            │
│  Flavor: The corruption works against you, almost malevolently              │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  ○  CHAOS EFFECT: NEUTRAL (d6 = 3-4)                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  The machine's corrupted patterns continue their chaotic dance,              │
│  neither helping nor hindering your attempt. You proceed against            │
│  the normal [Glitched] resistance.                                          │
│                                                                              │
│  Effect: +0 DC (normal difficulty)                                          │
│  Flavor: The chaos is indifferent to your presence                          │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  ★  CHAOS EFFECT: HELPS (d6 = 5-6)                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│  Fortune favors the bold! The glitch cycles into a momentarily              │
│  permissive state just as you act. The machine's own malfunction            │
│  becomes your ally.                                                          │
│                                                                              │
│  Effect: -2 DC to bypass attempt                                            │
│  Flavor: Lucky timing—the chaos coincidentally aids you                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 7. GlitchExploitationService Implementation

### 7.1 Service Interface

**File:** `src/Core/RuneAndRust.Domain/Interfaces/IGlitchExploitationService.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Interfaces;

/// <summary>
/// Service interface for the glitch exploitation system.
/// Handles pattern observation, cycle tracking, and chaos rolls
/// for [Glitched] Old World technology.
/// </summary>
public interface IGlitchExploitationService
{
    /// <summary>
    /// Attempts to observe and identify the glitch pattern.
    /// </summary>
    /// <param name="witsScore">Character's WITS attribute.</param>
    /// <param name="mechanismType">Type of mechanism being observed.</param>
    /// <param name="diceRoller">Dice rolling service.</param>
    /// <returns>Observation result with glitch state if successful.</returns>
    GlitchObservationResult ObserveGlitchPattern(
        int witsScore,
        string mechanismType,
        IDiceRoller diceRoller);

    /// <summary>
    /// Gets the current phase of a glitch cycle.
    /// </summary>
    /// <param name="state">Current glitch state.</param>
    /// <returns>The current cycle phase.</returns>
    GlitchCyclePhase GetCurrentCyclePhase(GlitchState state);

    /// <summary>
    /// Determines if the current state is in the exploit window.
    /// </summary>
    /// <param name="state">Current glitch state.</param>
    /// <returns>True if in exploit window.</returns>
    bool IsInExploitWindow(GlitchState state);

    /// <summary>
    /// Calculates the DC modifier based on glitch state.
    /// </summary>
    /// <param name="state">Current glitch state.</param>
    /// <returns>The DC modifier to apply (-4, -2, 0, +2, or +4).</returns>
    int CalculateGlitchModifier(GlitchState state);

    /// <summary>
    /// Rolls on the chaos table for unobserved glitch exploitation.
    /// </summary>
    /// <param name="diceRoller">Dice rolling service.</param>
    /// <returns>The chaos roll result.</returns>
    ChaosResult RollChaos(IDiceRoller diceRoller);

    /// <summary>
    /// Advances the glitch state by one round.
    /// </summary>
    /// <param name="state">Current glitch state.</param>
    /// <returns>Updated glitch state.</returns>
    GlitchState AdvanceRound(GlitchState state);

    /// <summary>
    /// Creates an initial glitch state for a mechanism.
    /// </summary>
    /// <param name="mechanismType">Type of mechanism.</param>
    /// <param name="diceRoller">Dice roller for phase duration.</param>
    /// <returns>Initial unobserved glitch state.</returns>
    GlitchState InitializeGlitchState(string mechanismType, IDiceRoller diceRoller);
}

/// <summary>
/// Result of attempting to observe a glitch pattern.
/// </summary>
/// <param name="Success">Whether the observation succeeded.</param>
/// <param name="NetSuccesses">Net successes on the WITS check.</param>
/// <param name="GlitchState">The resulting glitch state.</param>
/// <param name="NarrativeText">Descriptive text.</param>
public readonly record struct GlitchObservationResult(
    bool Success,
    int NetSuccesses,
    GlitchState GlitchState,
    string NarrativeText);
```

### 7.2 Service Implementation

**File:** `src/Core/RuneAndRust.Domain/Services/GlitchExploitationService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Implements the glitch exploitation system for [Glitched] Old World technology.
/// Handles pattern observation, cycle tracking, and chaos rolls.
/// </summary>
public class GlitchExploitationService : IGlitchExploitationService
{
    private readonly ILogger<GlitchExploitationService> _logger;

    /// <summary>
    /// DC for observing and identifying a glitch pattern.
    /// </summary>
    private const int PatternObservationDC = 14;

    /// <summary>
    /// Base phase duration before dice modifier.
    /// </summary>
    private const int BasePhaseDuration = 1;

    /// <summary>
    /// Dice added to base phase duration (1d4).
    /// </summary>
    private const int PhaseDurationDice = 4;

    public GlitchExploitationService(ILogger<GlitchExploitationService> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc/>
    public GlitchObservationResult ObserveGlitchPattern(
        int witsScore,
        string mechanismType,
        IDiceRoller diceRoller)
    {
        _logger.LogDebug(
            "Attempting glitch pattern observation: WITS {WitsScore} vs DC {DC}",
            witsScore, PatternObservationDC);

        var rollResult = diceRoller.RollSkillCheck(witsScore, PatternObservationDC);

        if (rollResult.NetSuccesses > 0)
        {
            // Success - identify the pattern
            var phaseDuration = BasePhaseDuration + diceRoller.RollDice(1, PhaseDurationDice);
            var currentPhase = DetermineCurrentPhase(diceRoller);

            var glitchState = GlitchState.CreateObserved(
                currentPhase: currentPhase,
                exploitWindow: GlitchCyclePhase.Permissive,
                phaseDuration: phaseDuration);

            _logger.LogInformation(
                "Glitch pattern identified: Phase {Phase}, Duration {Duration}, Window {Window}",
                currentPhase, phaseDuration, GlitchCyclePhase.Permissive);

            return new GlitchObservationResult(
                Success: true,
                NetSuccesses: rollResult.NetSuccesses,
                GlitchState: glitchState,
                NarrativeText: GenerateSuccessNarrative(currentPhase, mechanismType));
        }
        else
        {
            // Failure - pattern remains unknown
            var unobservedState = GlitchState.CreateUnobserved();

            _logger.LogDebug("Glitch pattern observation failed: {NetSuccesses} net successes",
                rollResult.NetSuccesses);

            return new GlitchObservationResult(
                Success: false,
                NetSuccesses: rollResult.NetSuccesses,
                GlitchState: unobservedState,
                NarrativeText: "The machine's erratic behavior defies your attempts to find a pattern. " +
                              "Its glitches seem random, unpredictable—the corruption too deep to read. " +
                              "You'll have to proceed blind and hope the chaos favors you.");
        }
    }

    /// <inheritdoc/>
    public GlitchCyclePhase GetCurrentCyclePhase(GlitchState state)
    {
        return state.CyclePhase;
    }

    /// <inheritdoc/>
    public bool IsInExploitWindow(GlitchState state)
    {
        return state.IsInExploitWindow;
    }

    /// <inheritdoc/>
    public int CalculateGlitchModifier(GlitchState state)
    {
        var modifier = state.DcModifier;

        _logger.LogDebug(
            "Glitch modifier calculated: {Modifier} (Identified: {Identified}, InWindow: {InWindow}, Chaos: {Chaos})",
            modifier, state.GlitchCycleIdentified, state.IsInExploitWindow, state.ChaosRoll);

        return modifier;
    }

    /// <inheritdoc/>
    public ChaosResult RollChaos(IDiceRoller diceRoller)
    {
        var roll = diceRoller.RollDice(1, 6);
        var result = ChaosResult.FromRoll(roll);

        _logger.LogInformation(
            "Chaos roll: {Roll} → {Effect} ({Modifier:+0;-0;+0} DC)",
            roll, result.Effect, result.DcModifier);

        return result;
    }

    /// <inheritdoc/>
    public GlitchState AdvanceRound(GlitchState state)
    {
        var newState = state.AdvanceRound();

        if (newState.CyclePhase != state.CyclePhase)
        {
            _logger.LogDebug(
                "Glitch cycle advanced: {OldPhase} → {NewPhase}",
                state.CyclePhase, newState.CyclePhase);
        }

        return newState;
    }

    /// <inheritdoc/>
    public GlitchState InitializeGlitchState(string mechanismType, IDiceRoller diceRoller)
    {
        var initialPhase = DetermineCurrentPhase(diceRoller);
        var phaseDuration = BasePhaseDuration + diceRoller.RollDice(1, PhaseDurationDice);

        var state = GlitchState.CreateUnobserved(initialPhase, phaseDuration);

        _logger.LogDebug(
            "Initialized glitch state for {MechanismType}: Phase {Phase}, Duration {Duration}",
            mechanismType, initialPhase, phaseDuration);

        return state;
    }

    /// <summary>
    /// Randomly determines the current phase of the glitch cycle.
    /// </summary>
    private GlitchCyclePhase DetermineCurrentPhase(IDiceRoller diceRoller)
    {
        var roll = diceRoller.RollDice(1, 4);
        return roll switch
        {
            1 => GlitchCyclePhase.Stable,
            2 => GlitchCyclePhase.Unstable,
            3 => GlitchCyclePhase.Permissive,
            4 => GlitchCyclePhase.Lockdown,
            _ => GlitchCyclePhase.Stable
        };
    }

    /// <summary>
    /// Generates narrative text for successful pattern observation.
    /// </summary>
    private string GenerateSuccessNarrative(GlitchCyclePhase currentPhase, string mechanismType)
    {
        var phaseDescription = currentPhase switch
        {
            GlitchCyclePhase.Stable =>
                "The machine is currently in a stable phase, its corruption simmering beneath the surface.",
            GlitchCyclePhase.Unstable =>
                "The machine is becoming unstable—lights flicker and strange sounds emanate from within.",
            GlitchCyclePhase.Permissive =>
                "The machine's defenses are momentarily lapsed! This is your window to strike!",
            GlitchCyclePhase.Lockdown =>
                "The machine is in lockdown, compensating for its corruption. Wait for it to cycle.",
            _ => "The machine's state is unclear."
        };

        return $"You study the {mechanismType}'s erratic behavior, and gradually a pattern emerges. " +
               $"The corruption cycles through phases—stable, unstable, permissive, lockdown. " +
               $"{phaseDescription} " +
               "When it reaches the permissive phase, that's your moment to act for maximum advantage.";
    }
}
```

---

## 8. Pattern Identification Mechanics

### 8.1 Observation Check

| Aspect | Value |
|--------|-------|
| Attribute | WITS |
| DC | 14 |
| Time | 1 round (6 seconds of observation) |
| Retry | Yes, but mechanism may cycle |

### 8.2 Success Benefits

Upon successful pattern identification:

1. **Cycle Knowledge**: Character knows the current phase and phase order
2. **Timing Ability**: Can wait for the Permissive phase
3. **Guaranteed Bonus**: -4 DC when acting in exploit window
4. **Phase Duration**: Learns approximate time until next phase change

### 8.3 Failure Consequences

Upon failed pattern identification:

1. **Chaos Roll Required**: Must roll d6 on chaos table
2. **Unpredictable Modifier**: -2, +0, or +4 DC based on roll
3. **No Timing**: Cannot predict when to act optimally
4. **Can Retry**: But costs time and mechanism cycles continue

### 8.4 Observation Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    PATTERN OBSERVATION FLOW                                  │
└─────────────────────────────────────────────────────────────────────────────┘

    Character approaches [Glitched] mechanism
                │
                ▼
        ┌───────────────────────┐
        │ Attempt observation?  │
        │ (WITS DC 14)          │
        └───────────┬───────────┘
                    │
           ┌────────┴────────┐
           ▼                 ▼
    ┌─────────────┐   ┌─────────────┐
    │    YES      │   │     NO      │
    │ Spend round │   │ Skip to     │
    │ observing   │   │ chaos roll  │
    └──────┬──────┘   └──────┬──────┘
           │                 │
           ▼                 │
    WITS check DC 14         │
           │                 │
    ┌──────┴──────┐          │
    ▼             ▼          │
SUCCESS       FAILURE        │
    │             │          │
    ▼             ▼          │
┌─────────┐  ┌─────────┐     │
│ Pattern │  │ Pattern │     │
│ KNOWN   │  │ UNKNOWN │◀────┘
│         │  │         │
│ Can time│  │ Roll d6 │
│ actions │  │ chaos   │
│ -4 DC   │  │ table   │
│ in      │  │         │
│ window  │  │ +4/0/-2 │
└─────────┘  └─────────┘
```

---

## 9. Timing-Based Exploitation

### 9.1 Exploit Window Mechanics

When a character has identified the glitch pattern, they can time their bypass attempt to coincide with the Permissive phase:

| Timing | DC Modifier | Description |
|--------|-------------|-------------|
| In Permissive phase | -4 DC | Optimal timing, security lapsed |
| In Stable phase | +0 DC | Normal [Glitched] difficulty |
| In Unstable phase | +0 DC | Normal [Glitched] difficulty |
| In Lockdown phase | +2 DC | System compensating, harder |

### 9.2 Waiting for the Window

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    WAITING FOR EXPLOIT WINDOW                                │
└─────────────────────────────────────────────────────────────────────────────┘

    Pattern identified, current phase: STABLE
                │
                ▼
    ┌───────────────────────────┐
    │ Player chooses:           │
    │                           │
    │ [A] Act now (+0 DC)       │
    │ [W] Wait for window       │
    └───────────┬───────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
    ACT NOW         WAIT
        │               │
        ▼               ▼
    Normal roll     Each round:
    with +0 DC      - Cycle advances
                    - Check if Permissive
                    - Risks: combat, patrol, etc.
                            │
                            ▼
                    ┌───────────────────┐
                    │ PERMISSIVE PHASE  │
                    │ reached!          │
                    │                   │
                    │ "The machine's    │
                    │ lights dim and    │
                    │ panels open—NOW!" │
                    └─────────┬─────────┘
                              │
                              ▼
                    Roll with -4 DC bonus
```

### 9.3 Risk of Waiting

Waiting for the exploit window has costs:

| Risk | Description |
|------|-------------|
| Time | Each phase lasts 1d4+1 rounds (roughly 6-30 seconds) |
| Combat | Enemies may arrive or act while waiting |
| Patrols | Guards may discover the character |
| Cycle Miss | If interrupted, may miss the window |
| Phase Duration | Permissive phase may be brief (1d4 rounds) |

---

## 10. Data Model Changes

### 10.1 New Value Objects

| Value Object | Layer | Description |
|--------------|-------|-------------|
| `GlitchState` | Domain | Tracks glitch cycle, pattern identification, chaos roll |
| `ChaosResult` | Domain | Result of d6 chaos roll with DC modifier |
| `GlitchObservationResult` | Domain | Result of pattern observation attempt |

### 10.2 New Enums

| Enum | Layer | Description |
|------|-------|-------------|
| `GlitchCyclePhase` | Domain | Phases: Stable, Unstable, Permissive, Lockdown |
| `ChaosEffect` | Domain | Effects: Against (+4), Neutral (+0), Helps (-2) |

### 10.3 Integration with v0.15.4e

The `GlitchExploitation` bypass method from v0.15.4e integrates with this system:

```csharp
// In JuryRiggingService.PerformExperiment():

if (context.MethodUsed == BypassMethod.GlitchExploitation)
{
    // Validate mechanism is glitched
    if (!state.IsGlitched)
        throw new InvalidOperationException("GlitchExploitation requires [Glitched] mechanism");

    // Get glitch modifier from exploitation service
    var glitchState = _glitchExploitationService.GetOrCreateState(state.MechanismType);
    var glitchModifier = _glitchExploitationService.CalculateGlitchModifier(glitchState);

    // Apply to DC calculation
    modifiedDC += glitchModifier;
}
```

### 10.4 Entity Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    GLITCH EXPLOITATION DATA MODEL                            │
└─────────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────┐
│        GlitchState            │
│       (Value Object)          │
├───────────────────────────────┤
│ + GlitchCycleIdentified: bool│
│ + CyclePhase: GlitchCyclePhase│
│ + ExploitWindow: GlitchCycle- │
│   Phase                       │
│ + ChaosRoll: int?             │
│ + PhaseDuration: int          │
│ + RoundsInCurrentPhase: int   │
├───────────────────────────────┤
│ + IsInExploitWindow: bool     │
│ + DcModifier: int             │
│ + StateDescription: string    │
│ + RoundsUntilPhaseChange: int │
├───────────────────────────────┤
│ + CreateUnobserved()          │
│ + CreateObserved()            │
│ + CreateWithChaos()           │
│ + AdvancePhase()              │
│ + AdvanceRound()              │
└───────────────────────────────┘
        │
        │ produces
        ▼
┌───────────────────────────────┐
│        ChaosResult            │
│       (Value Object)          │
├───────────────────────────────┤
│ + Roll: int (1-6)             │
│ + Effect: ChaosEffect         │
│ + DcModifier: int             │
│ + NarrativeText: string       │
├───────────────────────────────┤
│ + FromRoll(roll): ChaosResult │
│ + EffectSummary: string       │
└───────────────────────────────┘

┌───────────────────────────────┐    ┌───────────────────────────────┐
│      GlitchCyclePhase         │    │        ChaosEffect            │
│          (Enum)               │    │          (Enum)               │
├───────────────────────────────┤    ├───────────────────────────────┤
│ Stable                        │    │ Against (+4 DC)               │
│ Unstable                      │    │ Neutral (+0 DC)               │
│ Permissive (-4 DC exploit)    │    │ Helps (-2 DC)                 │
│ Lockdown (+2 DC)              │    │                               │
└───────────────────────────────┘    └───────────────────────────────┘
```

---

## 11. Configuration Files

### 11.1 glitch-cycles.json

**File:** `config/glitch-cycles.json`

```json
{
  "$schema": "./schemas/glitch-cycles.schema.json",
  "patternObservation": {
    "attribute": "WITS",
    "dc": 14,
    "timeRequired": "1 round"
  },
  "phases": [
    {
      "id": "stable",
      "displayName": "Stable",
      "description": "The mechanism operates with its usual erratic hum.",
      "dcModifier": 0,
      "baseDuration": 1,
      "durationDice": "1d4",
      "visualIndicators": ["Steady but flickering lights", "Occasional sparks"],
      "audioIndicators": ["Low electrical hum", "Intermittent clicks"]
    },
    {
      "id": "unstable",
      "displayName": "Unstable",
      "description": "Lights flicker rapidly and strange sounds emanate from within.",
      "dcModifier": 0,
      "baseDuration": 1,
      "durationDice": "1d4",
      "visualIndicators": ["Rapid light flickering", "Visible sparks", "Display glitches"],
      "audioIndicators": ["Crackling electricity", "High-pitched whine", "Distorted sounds"]
    },
    {
      "id": "permissive",
      "displayName": "Permissive",
      "description": "The mechanism's defenses momentarily lapse!",
      "dcModifier": -4,
      "isExploitWindow": true,
      "baseDuration": 1,
      "durationDice": "1d4",
      "visualIndicators": ["Lights dim suddenly", "Access panels loosen", "Security indicators off"],
      "audioIndicators": ["Sudden silence", "Soft clicks", "Whirring down"]
    },
    {
      "id": "lockdown",
      "displayName": "Lockdown",
      "description": "The system compensates, becoming more resistant.",
      "dcModifier": 2,
      "baseDuration": 1,
      "durationDice": "1d4",
      "visualIndicators": ["Red warning lights", "Panels seal tight", "Security active"],
      "audioIndicators": ["Alarm tone", "Heavy clicking locks", "Power surge hum"]
    }
  ],
  "chaosTable": {
    "diceType": "d6",
    "entries": [
      {
        "rollRange": [1, 2],
        "effect": "against",
        "dcModifier": 4,
        "description": "The glitch actively resists your interference.",
        "narrativeText": "The glitch pulses angrily as you approach, its erratic behavior intensifying as if the machine itself rejects your interference."
      },
      {
        "rollRange": [3, 4],
        "effect": "neutral",
        "dcModifier": 0,
        "description": "The glitch has no particular effect.",
        "narrativeText": "The machine's corrupted patterns continue their chaotic dance, neither helping nor hindering your attempt."
      },
      {
        "rollRange": [5, 6],
        "effect": "helps",
        "dcModifier": -2,
        "description": "The glitch coincidentally aids your attempt.",
        "narrativeText": "Fortune favors the bold! The glitch cycles into a momentarily permissive state just as you act."
      }
    ]
  }
}
```

### 11.2 Configuration Schema

**File:** `config/schemas/glitch-cycles.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "glitch-cycles.schema.json",
  "title": "Glitch Cycles Configuration",
  "description": "Schema for glitch cycle phase and chaos table definitions",
  "type": "object",
  "required": ["patternObservation", "phases", "chaosTable"],
  "properties": {
    "patternObservation": {
      "type": "object",
      "required": ["attribute", "dc", "timeRequired"],
      "properties": {
        "attribute": {
          "type": "string",
          "enum": ["WITS", "FINESSE", "MIGHT", "WILL"]
        },
        "dc": {
          "type": "integer",
          "minimum": 1,
          "maximum": 30
        },
        "timeRequired": {
          "type": "string"
        }
      }
    },
    "phases": {
      "type": "array",
      "minItems": 4,
      "maxItems": 4,
      "items": {
        "type": "object",
        "required": ["id", "displayName", "description", "dcModifier", "baseDuration", "durationDice"],
        "properties": {
          "id": {
            "type": "string",
            "enum": ["stable", "unstable", "permissive", "lockdown"]
          },
          "displayName": {
            "type": "string",
            "maxLength": 20
          },
          "description": {
            "type": "string",
            "maxLength": 200
          },
          "dcModifier": {
            "type": "integer",
            "minimum": -10,
            "maximum": 10
          },
          "isExploitWindow": {
            "type": "boolean"
          },
          "baseDuration": {
            "type": "integer",
            "minimum": 1
          },
          "durationDice": {
            "type": "string",
            "pattern": "^\\d+d\\d+$"
          },
          "visualIndicators": {
            "type": "array",
            "items": { "type": "string" }
          },
          "audioIndicators": {
            "type": "array",
            "items": { "type": "string" }
          }
        }
      }
    },
    "chaosTable": {
      "type": "object",
      "required": ["diceType", "entries"],
      "properties": {
        "diceType": {
          "type": "string",
          "enum": ["d6"]
        },
        "entries": {
          "type": "array",
          "minItems": 3,
          "items": {
            "type": "object",
            "required": ["rollRange", "effect", "dcModifier", "description"],
            "properties": {
              "rollRange": {
                "type": "array",
                "minItems": 2,
                "maxItems": 2,
                "items": { "type": "integer", "minimum": 1, "maximum": 6 }
              },
              "effect": {
                "type": "string",
                "enum": ["against", "neutral", "helps"]
              },
              "dcModifier": {
                "type": "integer"
              },
              "description": {
                "type": "string"
              },
              "narrativeText": {
                "type": "string"
              }
            }
          }
        }
      }
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `GlitchExploitationService` | Information | Pattern observation result, chaos roll result |
| `GlitchExploitationService` | Debug | Phase transitions, modifier calculations, state initialization |
| `GlitchExploitationService` | Warning | Exploitation attempted on non-glitched mechanism |
| `GlitchExploitationService` | Error | Invalid glitch state transitions |

### 12.2 Log Message Templates

```csharp
// GlitchExploitationService - Information
"Glitch pattern identified: Phase {Phase}, Duration {Duration}, Window {Window}"
"Chaos roll: {Roll} → {Effect} ({Modifier:+0;-0;+0} DC)"

// GlitchExploitationService - Debug
"Attempting glitch pattern observation: WITS {WitsScore} vs DC {DC}"
"Glitch pattern observation failed: {NetSuccesses} net successes"
"Glitch modifier calculated: {Modifier} (Identified: {Identified}, InWindow: {InWindow}, Chaos: {Chaos})"
"Glitch cycle advanced: {OldPhase} → {NewPhase}"
"Initialized glitch state for {MechanismType}: Phase {Phase}, Duration {Duration}"

// GlitchExploitationService - Warning
"Glitch exploitation attempted on non-glitched mechanism {MechanismId}"

// GlitchExploitationService - Error
"Invalid glitch state transition: {CurrentPhase} cannot transition to {RequestedPhase}"
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Pattern identification reduces DC | ~1 |
| Chaos roll applies correct modifier | ~1 |
| **Total** | **~2** |

### 13.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.Tests/Services/GlitchExploitationServiceTests.cs`

```csharp
using NUnit.Framework;
using Moq;
using RuneAndRust.Domain.Services;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.Tests.Services;

[TestFixture]
public class GlitchExploitationServiceTests
{
    private GlitchExploitationService _service;
    private Mock<IDiceRoller> _diceRollerMock;
    private Mock<ILogger<GlitchExploitationService>> _loggerMock;

    [SetUp]
    public void Setup()
    {
        _loggerMock = new Mock<ILogger<GlitchExploitationService>>();
        _diceRollerMock = new Mock<IDiceRoller>();

        _service = new GlitchExploitationService(_loggerMock.Object);
    }

    [Test]
    public void PatternIdentification_WhenInExploitWindow_ReducesDcByFour()
    {
        // Arrange - Create observed state in Permissive phase
        var glitchState = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Permissive,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var modifier = _service.CalculateGlitchModifier(glitchState);
        var isInWindow = _service.IsInExploitWindow(glitchState);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(isInWindow, Is.True, "Should be in exploit window");
            Assert.That(modifier, Is.EqualTo(-4), "Should reduce DC by 4 when in exploit window");
        });
    }

    [Test]
    public void ChaosRoll_AppliesCorrectModifier()
    {
        // Arrange & Act - Test all chaos roll outcomes
        var againstResult = ChaosResult.FromRoll(1);  // 1-2 = Against
        var neutralResult = ChaosResult.FromRoll(3);  // 3-4 = Neutral
        var helpsResult = ChaosResult.FromRoll(6);    // 5-6 = Helps

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(againstResult.Effect, Is.EqualTo(ChaosEffect.Against));
            Assert.That(againstResult.DcModifier, Is.EqualTo(+4), "Against should be +4 DC");

            Assert.That(neutralResult.Effect, Is.EqualTo(ChaosEffect.Neutral));
            Assert.That(neutralResult.DcModifier, Is.EqualTo(0), "Neutral should be +0 DC");

            Assert.That(helpsResult.Effect, Is.EqualTo(ChaosEffect.Helps));
            Assert.That(helpsResult.DcModifier, Is.EqualTo(-2), "Helps should be -2 DC");
        });
    }

    [Test]
    public void GlitchState_WhenNotInExploitWindow_ReturnsZeroModifier()
    {
        // Arrange - Create observed state NOT in Permissive phase
        var glitchState = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Stable,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Act
        var modifier = _service.CalculateGlitchModifier(glitchState);
        var isInWindow = _service.IsInExploitWindow(glitchState);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(isInWindow, Is.False, "Should NOT be in exploit window");
            Assert.That(modifier, Is.EqualTo(0), "Should have +0 modifier outside window");
        });
    }

    [Test]
    public void GlitchState_InLockdownPhase_ReturnsPlusTwoModifier()
    {
        // Arrange - Lockdown phase has +2 DC penalty
        var glitchState = GlitchState.CreateObserved(
            currentPhase: GlitchCyclePhase.Lockdown,
            exploitWindow: GlitchCyclePhase.Permissive,
            phaseDuration: 3);

        // Note: Current implementation returns 0 outside exploit window
        // Lockdown +2 modifier would be an enhancement
        var isInWindow = _service.IsInExploitWindow(glitchState);

        // Assert
        Assert.That(isInWindow, Is.False, "Should NOT be in exploit window during Lockdown");
    }
}
```

---

## 14. Use Cases

### UC-001: Observe Glitch Pattern Successfully

**Actor:** Player
**Flow:**
1. Player encounters [Glitched] mechanism
2. Player chooses to observe pattern (spend 1 round)
3. System rolls WITS check vs DC 14
4. Success: Pattern identified, current phase revealed
5. Player learns when exploit window will occur
6. Player can time action for -4 DC bonus

### UC-002: Observe Glitch Pattern Failure

**Actor:** Player
**Flow:**
1. Player encounters [Glitched] mechanism
2. Player chooses to observe pattern
3. System rolls WITS check vs DC 14
4. Failure: Pattern remains unknown
5. Player must proceed blind or retry
6. If proceeding, roll d6 on chaos table

### UC-003: Exploit Without Observation (Chaos Roll)

**Actor:** Player
**Flow:**
1. Player encounters [Glitched] mechanism
2. Player skips observation (or observation failed)
3. Player attempts bypass with GlitchExploitation method
4. System rolls d6 on chaos table
5. Result determines DC modifier (-2, +0, or +4)
6. Player proceeds with modified DC

### UC-004: Wait for Exploit Window

**Actor:** Player
**Flow:**
1. Player has identified glitch pattern
2. Current phase is not Permissive
3. Player chooses to wait
4. Each round: cycle advances, check phase
5. When Permissive phase reached, system notifies player
6. Player acts with -4 DC bonus

### UC-005: Act Outside Exploit Window

**Actor:** Player
**Flow:**
1. Player has identified glitch pattern
2. Current phase is Stable or Unstable
3. Player chooses to act immediately (can't wait)
4. System applies +0 DC modifier (no bonus)
5. Player rolls bypass normally

---

## 15. Deliverable Checklist

### Value Objects
- [ ] `GlitchState` value object created
- [ ] `GlitchState.CreateUnobserved()` factory method
- [ ] `GlitchState.CreateObserved()` factory method
- [ ] `GlitchState.CreateWithChaos()` factory method
- [ ] `GlitchState.AdvancePhase()` method
- [ ] `GlitchState.AdvanceRound()` method
- [ ] `ChaosResult` value object created
- [ ] `ChaosResult.FromRoll()` factory method
- [ ] `GlitchObservationResult` value object created

### Enums
- [ ] `GlitchCyclePhase` enum created (Stable, Unstable, Permissive, Lockdown)
- [ ] `ChaosEffect` enum created (Against, Neutral, Helps)

### Services
- [ ] `IGlitchExploitationService` interface defined
- [ ] `GlitchExploitationService` implemented
- [ ] `ObserveGlitchPattern()` method
- [ ] `RollChaos()` method
- [ ] `CalculateGlitchModifier()` method
- [ ] `IsInExploitWindow()` method

### Configuration Files
- [ ] `config/glitch-cycles.json` created
- [ ] `config/schemas/glitch-cycles.schema.json` created

### Integration
- [ ] `JuryRiggingService` integrates with `GlitchExploitationService`
- [ ] `BypassMethod.GlitchExploitation` uses glitch modifier

### Testing
- [ ] ~2 unit tests implemented
- [ ] Pattern identification DC reduction test
- [ ] Chaos roll modifier test
- [ ] All tests passing

### Quality
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings
- [ ] XML documentation complete
- [ ] Configuration files validate against schemas

---

## 16. Acceptance Criteria

### Functional
- [ ] Pattern observation uses WITS DC 14
- [ ] Successful observation identifies glitch cycle
- [ ] Exploit window provides -4 DC bonus
- [ ] Chaos table correctly maps d6 rolls to modifiers
- [ ] d6 1-2 results in +4 DC (against)
- [ ] d6 3-4 results in +0 DC (neutral)
- [ ] d6 5-6 results in -2 DC (helps)
- [ ] Glitch state tracks current phase
- [ ] Phase advancement works correctly (Stable→Unstable→Permissive→Lockdown→Stable)
- [ ] GlitchExploitation method validates mechanism is [Glitched]

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~2 tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete for all public types

---

## 17. Dependencies

### 17.1 Required from Previous Versions

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `BypassMethod.GlitchExploitation` | v0.15.4e | Method that triggers glitch exploitation |
| `JuryRigContext` | v0.15.4e | Provides context for bypass attempts |
| `IDiceRoller` | Domain | WITS checks, chaos rolls, phase duration |
| `CorruptionLevel` enum | v0.15.4a | Determines if mechanism is [Glitched] |
| Success-counting dice | v0.15.0 | Core resolution mechanic |

### 17.2 Provides to Future Versions

| Type | Usage |
|------|-------|
| `GlitchState` | Any system interacting with [Glitched] technology |
| `GlitchExploitationService` | Reusable glitch pattern mechanics |
| `ChaosResult` | Template for other chaos/random effect systems |
| Cycle phase tracking | Future environmental hazard systems |

---

## 18. Future Considerations

### Deferred to v0.15.4i (Specialization Integration)

- **Jötun-Reader [Pattern Recognition]**: Reduce [Glitched] DC penalty by 2
- **Glitch Affinity**: Some specializations may auto-succeed on pattern observation

### Out of Scope

- **Glitch-induced combat effects**: Environmental hazards from glitched mechanisms
- **Glitch contagion**: Spreading corruption to other devices
- **Persistent glitch state**: Mechanisms "remembering" previous exploits
- **Advanced glitch types**: Multiple exploit windows, irregular cycles

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*
