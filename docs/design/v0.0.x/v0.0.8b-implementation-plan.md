# v0.0.8b Implementation Plan: Level-Up Mechanics

**Version:** 0.0.8b
**Parent:** v0.0.8 (Experience & Leveling)
**Prerequisites:** v0.0.8a Complete (Core Experience System)
**Design Specification:** [v0.0.8b-design-specification.md](v0.0.8b-design-specification.md)
**Status:** Ready for Implementation
**Target Tests:** ~317 -> ~335 (+18 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Presentation Layer](#presentation-layer)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Implement level-up detection, stat increases on level-up, and level-up notifications. This phase builds on the XP tracking infrastructure from v0.0.8a and integrates with the existing ability unlock system from v0.0.4c. When a player accumulates enough XP to reach the next level threshold, the system automatically levels them up, applies stat bonuses, checks for newly unlocked abilities, and displays a celebratory notification.

### Scope

**In Scope:**
- `LevelUpResult` value object containing level-up details
- `StatModifiers` value object for representing stat changes
- `ProgressionService` for level-up detection and application
- Default level thresholds using `level * 100` formula
- Default stat increases per level: +5 MaxHealth, +1 Attack, +1 Defense
- Level-up detection after XP is added
- Multi-level gain support (e.g., gaining enough XP to go from level 1 to level 3)
- Stat application on level-up (modifying player's Stats)
- Health restoration to new maximum on level-up
- Ability unlock check using existing v0.0.4c `AbilityService.GetUnlockedAbilitiesAtLevel()`
- `LevelUpDto` for presenting level-up information to the UI
- Level-up notification display via `IGameRenderer.RenderLevelUpAsync()`

**Out of Scope:**
- Configurable XP terminology (v0.0.8c)
- Configurable progression curves (v0.0.8c)
- Class-specific stat bonuses (v0.0.8c)
- Custom level rewards (v0.0.8c)
- Maximum level cap configuration (v0.0.8c)
- Skill points or attribute allocation (future)
- Prestige/Rebirth system (future)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| XP formula | `level * 100` | Simple, configurable in v0.0.8c |
| Stat bonuses | +5 HP, +1 ATK, +1 DEF per level | Balanced defaults |
| Heal on level-up | Full heal to new max | Quality of life feature |
| Ability unlocks | Use existing v0.0.4c infrastructure | Minimize duplication |
| Service location | Domain layer | Core business logic |
| Multi-level support | Cumulative stat bonuses | One XP gain can skip levels |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.8a (Core Experience System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Player.Experience` | `Domain/Entities/Player.cs` | Used to determine target level |
| `Player.AddExperience()` | `Domain/Entities/Player.cs` | XP tracking (no changes needed) |
| `Player.ExperienceToNextLevel` | `Domain/Entities/Player.cs` | Used for display calculations |
| `Player.ExperienceProgressPercent` | `Domain/Entities/Player.cs` | Used for display calculations |
| `ExperienceService` | `Domain/Services/ExperienceService.cs` | Awards XP before level-up check |
| `ExperienceGainResult` | `Domain/ValueObjects/ExperienceGainResult.cs` | XP award result |
| `CombatResult.ExperienceGained` | `Domain/Services/CombatService.cs` | XP value on monster defeat |
| `IGameRenderer.RenderExperienceGainAsync()` | `Application/Interfaces/IGameRenderer.cs` | Display XP gain |

### Dependencies from v0.0.4c (Ability System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `AbilityService.GetUnlockedAbilitiesAtLevel()` | `Application/Services/AbilityService.cs` | Get abilities to unlock at level |
| `AbilityDefinition.UnlockLevel` | `Domain/Definitions/AbilityDefinition.cs` | Ability level requirements |
| `PlayerAbility.Unlock()` | `Domain/ValueObjects/PlayerAbility.cs` | Unlock ability for player |
| `Player.GetAbility()` | `Domain/Entities/Player.cs` | Access player's abilities |

### Dependencies from Core Domain

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Player` | `Domain/Entities/Player.cs` | Extended with ApplyStatModifiers, level calculation methods |
| `Player.Level` | `Domain/Entities/Player.cs` | Current level property |
| `Player.SetLevel()` | `Domain/Entities/Player.cs` | Update level after level-up |
| `Player.Stats` | `Domain/Entities/Player.cs` | Stats to modify on level-up |
| `Stats` | `Domain/ValueObjects/Stats.cs` | Stat values (MaxHealth, Attack, Defense) |
| `IGameRenderer` | `Application/Interfaces/IGameRenderer.cs` | Extended with RenderLevelUpAsync |
| `GameSessionService` | `Application/Services/GameSessionService.cs` | Integrates level-up check |

---

## Current System Analysis

### Existing Player Entity

**Location:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

**Relevant Current Properties (after v0.0.8a):**
```
Player
├── Level: int (default 1)
├── SetLevel(level): void
├── Experience: int (default 0)       ← from v0.0.8a
├── AddExperience(amount): int        ← from v0.0.8a
├── ExperienceToNextLevel: int        ← from v0.0.8a
├── ExperienceProgressPercent: int    ← from v0.0.8a
├── Health: int
├── Stats: Stats
├── ClassId: string?
├── Abilities: IReadOnlyList<PlayerAbility>
└── GetAbility(id): PlayerAbility?
```

**Required Changes:**
- Add `ApplyStatModifiers(modifiers, healToNewMax)` method
- Add `GetExperienceForLevel(level)` static method
- Add `GetLevelForExperience(experience)` static method

### Existing XP Flow (v0.0.8a)

```
Monster Defeated → ExperienceService.AwardExperience()
    │
    ├── player.AddExperience(amount)
    │   └── Experience += amount
    │
    ├── Return ExperienceGainResult
    │
    └── Render XP gain message
        └── "★ You gained 25 XP!"
```

### New Level-Up Flow (v0.0.8b)

```
Monster Defeated → ExperienceService.AwardExperience()
    │
    ├── player.AddExperience(amount)
    │
    ├── Render XP gain message
    │
    └── ProgressionService.CheckAndApplyLevelUp(player)  ← NEW
        │
        ├── Get target level from current XP
        │
        ├── If targetLevel > currentLevel:
        │   ├── Calculate stat increases
        │   ├── Apply stat modifiers
        │   ├── Update player level
        │   ├── Heal to new max HP
        │   ├── Check for unlocked abilities
        │   └── Return LevelUpResult
        │
        └── Render level-up notification
            └── "★ LEVEL UP! ★"
```

---

## Detailed Implementation

### Domain Layer

#### 1. StatModifiers.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/StatModifiers.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a set of stat modifications that can be applied to a player.
/// </summary>
/// <remarks>
/// <para>Used for level-up bonuses, equipment effects, and buff/debuff calculations.
/// All values are additive modifiers to base stats.</para>
/// <para>This value object is immutable and provides arithmetic operations
/// for combining and scaling modifiers.</para>
/// </remarks>
/// <param name="MaxHealth">The modifier to maximum health.</param>
/// <param name="Attack">The modifier to attack stat.</param>
/// <param name="Defense">The modifier to defense stat.</param>
/// <example>
/// <code>
/// // Create modifiers for a level-up
/// var levelUp = StatModifiers.DefaultLevelUp;
/// Console.WriteLine(levelUp.MaxHealth); // 5
///
/// // Scale for multi-level gain
/// var twoLevels = levelUp.Multiply(2);
/// Console.WriteLine(twoLevels.MaxHealth); // 10
///
/// // Combine modifiers
/// var combined = levelUp.Add(new StatModifiers(10, 0, 0));
/// Console.WriteLine(combined.MaxHealth); // 15
/// </code>
/// </example>
public readonly record struct StatModifiers(
    int MaxHealth,
    int Attack,
    int Defense)
{
    /// <summary>
    /// A zero modifier that applies no changes.
    /// </summary>
    public static readonly StatModifiers Zero = new(0, 0, 0);

    /// <summary>
    /// The default stat increases per level.
    /// </summary>
    /// <remarks>
    /// +5 MaxHealth, +1 Attack, +1 Defense per level.
    /// Will be configurable in v0.0.8c.
    /// </remarks>
    public static readonly StatModifiers DefaultLevelUp = new(5, 1, 1);

    /// <summary>
    /// Gets whether any stats are modified.
    /// </summary>
    public bool HasModifications => MaxHealth != 0 || Attack != 0 || Defense != 0;

    /// <summary>
    /// Adds two stat modifiers together.
    /// </summary>
    /// <param name="other">The other modifier to add.</param>
    /// <returns>A new StatModifiers with combined values.</returns>
    public StatModifiers Add(StatModifiers other) =>
        new(MaxHealth + other.MaxHealth, Attack + other.Attack, Defense + other.Defense);

    /// <summary>
    /// Multiplies all stat modifiers by a factor.
    /// </summary>
    /// <param name="factor">The multiplication factor.</param>
    /// <returns>A new StatModifiers with scaled values.</returns>
    public StatModifiers Multiply(int factor) =>
        new(MaxHealth * factor, Attack * factor, Defense * factor);

    /// <summary>
    /// Returns a formatted string representation.
    /// </summary>
    public override string ToString() =>
        $"StatModifiers(HP: {MaxHealth:+0;-0;0}, ATK: {Attack:+0;-0;0}, DEF: {Defense:+0;-0;0})";
}
```

#### 2. LevelUpResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LevelUpResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of a level-up operation.
/// </summary>
/// <remarks>
/// <para>Contains all information about what changed during the level-up,
/// including stat increases and newly unlocked abilities.</para>
/// <para>Use the <see cref="None"/> factory method when no level-up occurred,
/// and use the <see cref="DidLevelUp"/> property to check if a level-up happened.</para>
/// </remarks>
/// <param name="OldLevel">The player's level before the level-up.</param>
/// <param name="NewLevel">The player's level after the level-up.</param>
/// <param name="StatIncreases">The total stat increases applied.</param>
/// <param name="NewAbilities">List of ability IDs that were unlocked.</param>
/// <example>
/// <code>
/// // Check for level-up
/// var result = progressionService.CheckForLevelUp(player);
/// if (result.DidLevelUp)
/// {
///     Console.WriteLine($"Gained {result.LevelsGained} level(s)!");
///     if (result.HasNewAbilities)
///     {
///         Console.WriteLine($"Unlocked: {string.Join(", ", result.NewAbilities)}");
///     }
/// }
/// </code>
/// </example>
public readonly record struct LevelUpResult(
    int OldLevel,
    int NewLevel,
    StatModifiers StatIncreases,
    IReadOnlyList<string> NewAbilities)
{
    /// <summary>
    /// Gets the number of levels gained in this level-up.
    /// </summary>
    public int LevelsGained => NewLevel - OldLevel;

    /// <summary>
    /// Gets whether multiple levels were gained at once.
    /// </summary>
    public bool IsMultiLevel => LevelsGained > 1;

    /// <summary>
    /// Gets whether any abilities were unlocked.
    /// </summary>
    public bool HasNewAbilities => NewAbilities.Count > 0;

    /// <summary>
    /// Gets whether a level-up actually occurred.
    /// </summary>
    public bool DidLevelUp => LevelsGained > 0;

    /// <summary>
    /// Creates a result for no level-up occurring.
    /// </summary>
    /// <param name="currentLevel">The player's current level.</param>
    /// <returns>A LevelUpResult indicating no change.</returns>
    public static LevelUpResult None(int currentLevel) =>
        new(currentLevel, currentLevel, StatModifiers.Zero, Array.Empty<string>());

    /// <summary>
    /// Returns a formatted string representation.
    /// </summary>
    public override string ToString() =>
        DidLevelUp
            ? $"LevelUpResult(Level {OldLevel} -> {NewLevel}, {StatIncreases}, Abilities: {NewAbilities.Count})"
            : $"LevelUpResult(No change, Level {OldLevel})";
}
```

#### 3. Player.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

**Changes:** Add `ApplyStatModifiers()`, `GetExperienceForLevel()`, and `GetLevelForExperience()` methods.

```csharp
// Add after existing XP-related methods from v0.0.8a:

/// <summary>
/// Applies stat modifiers to the player's stats.
/// </summary>
/// <param name="modifiers">The stat modifiers to apply.</param>
/// <param name="healToNewMax">Whether to heal to the new max health.</param>
/// <remarks>
/// Used during level-up to increase stats. When healToNewMax is true,
/// the player's current health is set to the new maximum.
/// </remarks>
/// <example>
/// <code>
/// var modifiers = new StatModifiers(5, 1, 1);
/// player.ApplyStatModifiers(modifiers, healToNewMax: true);
/// // Player's stats are now increased and health is at new maximum
/// </code>
/// </example>
public void ApplyStatModifiers(StatModifiers modifiers, bool healToNewMax = false)
{
    var newMaxHealth = Stats.MaxHealth + modifiers.MaxHealth;
    var newAttack = Stats.Attack + modifiers.Attack;
    var newDefense = Stats.Defense + modifiers.Defense;

    Stats = new Stats(newMaxHealth, newAttack, newDefense);

    if (healToNewMax)
    {
        Health = Stats.MaxHealth;
    }
}

/// <summary>
/// Gets the cumulative XP required to reach the specified level.
/// </summary>
/// <param name="level">The target level.</param>
/// <returns>The cumulative XP required.</returns>
/// <remarks>
/// <para>Default formula: level * 100 (Level 2 = 200 XP, Level 3 = 300 XP, etc.).</para>
/// <para>Will be replaced with configurable curves in v0.0.8c.</para>
/// </remarks>
/// <example>
/// <code>
/// var xpForLevel2 = Player.GetExperienceForLevel(2); // 200
/// var xpForLevel5 = Player.GetExperienceForLevel(5); // 500
/// </code>
/// </example>
public static int GetExperienceForLevel(int level)
{
    if (level <= 1) return 0;
    return level * 100;
}

/// <summary>
/// Gets what level the player should be at for a given XP amount.
/// </summary>
/// <param name="experience">The experience amount.</param>
/// <returns>The level corresponding to that experience.</returns>
/// <remarks>
/// <para>This is the inverse of <see cref="GetExperienceForLevel"/>.</para>
/// <para>Uses the default formula where level = XP / 100 (for XP >= 200).</para>
/// </remarks>
/// <example>
/// <code>
/// var level1 = Player.GetLevelForExperience(150);  // 1 (not enough for level 2)
/// var level2 = Player.GetLevelForExperience(200);  // 2 (exactly level 2)
/// var level3 = Player.GetLevelForExperience(350);  // 3 (enough for level 3)
/// </code>
/// </example>
public static int GetLevelForExperience(int experience)
{
    if (experience < 200) return 1;  // Level 2 requires 200 XP

    // level * 100 = XP, so level = XP / 100
    // We need the highest level where XP >= threshold
    var level = experience / 100;
    return Math.Max(1, level);
}
```

#### 4. ProgressionService.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Services/ProgressionService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Service for managing player level progression.
/// </summary>
/// <remarks>
/// <para>Handles level-up detection, stat increases, and ability unlocks.
/// Uses default progression values that will be configurable in v0.0.8c.</para>
/// <para>Key responsibilities:</para>
/// <list type="bullet">
/// <item>Detect when a player should level up based on XP</item>
/// <item>Calculate cumulative stat increases for gained levels</item>
/// <item>Apply stat modifiers and level changes to the player</item>
/// <item>Coordinate with AbilityService for ability unlocks</item>
/// </list>
/// </remarks>
public class ProgressionService
{
    private readonly ILogger<ProgressionService> _logger;

    /// <summary>
    /// Creates a new ProgressionService instance.
    /// </summary>
    /// <param name="logger">The logger for progression operations.</param>
    public ProgressionService(ILogger<ProgressionService> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Checks if the player should level up based on their current experience.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>A LevelUpResult if leveling up, or LevelUpResult.None if not.</returns>
    /// <exception cref="ArgumentNullException">Thrown when player is null.</exception>
    /// <remarks>
    /// This method only calculates the potential level-up; it does not apply changes.
    /// Call <see cref="ApplyLevelUp"/> to actually apply the level-up.
    /// </remarks>
    public LevelUpResult CheckForLevelUp(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var targetLevel = Player.GetLevelForExperience(player.Experience);

        if (targetLevel <= player.Level)
        {
            _logger.LogDebug(
                "No level up - Player {PlayerName} at level {Level} with {XP} XP",
                player.Name, player.Level, player.Experience);
            return LevelUpResult.None(player.Level);
        }

        var levelsGained = targetLevel - player.Level;
        var statIncreases = GetStatIncreasesForLevels(levelsGained);

        _logger.LogInformation(
            "Level up detected - Player {PlayerName}: Level {OldLevel} -> {NewLevel} " +
            "(+{HP} HP, +{ATK} ATK, +{DEF} DEF)",
            player.Name, player.Level, targetLevel,
            statIncreases.MaxHealth, statIncreases.Attack, statIncreases.Defense);

        return new LevelUpResult(
            player.Level,
            targetLevel,
            statIncreases,
            Array.Empty<string>());  // Abilities filled in by ApplyLevelUp
    }

    /// <summary>
    /// Applies a level-up result to the player.
    /// </summary>
    /// <param name="player">The player to level up.</param>
    /// <param name="result">The level-up result to apply.</param>
    /// <param name="getAbilitiesAtLevel">Function to get abilities unlocked at a level.</param>
    /// <returns>The final LevelUpResult with unlocked abilities populated.</returns>
    /// <exception cref="ArgumentNullException">Thrown when player is null.</exception>
    /// <remarks>
    /// <para>This method applies the following changes:</para>
    /// <list type="number">
    /// <item>Applies stat modifiers with full heal</item>
    /// <item>Updates player level</item>
    /// <item>Collects ability IDs from each gained level</item>
    /// </list>
    /// </remarks>
    public LevelUpResult ApplyLevelUp(
        Player player,
        LevelUpResult result,
        Func<int, IReadOnlyList<string>>? getAbilitiesAtLevel = null)
    {
        ArgumentNullException.ThrowIfNull(player);

        if (!result.DidLevelUp)
        {
            return result;
        }

        // Apply stat increases with full heal
        player.ApplyStatModifiers(result.StatIncreases, healToNewMax: true);

        // Update level
        player.SetLevel(result.NewLevel);

        // Check for newly unlocked abilities
        var unlockedAbilities = new List<string>();
        if (getAbilitiesAtLevel != null)
        {
            for (var level = result.OldLevel + 1; level <= result.NewLevel; level++)
            {
                var abilities = getAbilitiesAtLevel(level);
                unlockedAbilities.AddRange(abilities);
            }
        }

        _logger.LogInformation(
            "Level up applied - Player {PlayerName} is now level {Level}. " +
            "Stats: HP={HP}, ATK={ATK}, DEF={DEF}. Abilities unlocked: {AbilityCount}",
            player.Name, player.Level,
            player.Stats.MaxHealth, player.Stats.Attack, player.Stats.Defense,
            unlockedAbilities.Count);

        // Return updated result with abilities
        return new LevelUpResult(
            result.OldLevel,
            result.NewLevel,
            result.StatIncreases,
            unlockedAbilities);
    }

    /// <summary>
    /// Checks for level-up and applies it in one operation.
    /// </summary>
    /// <param name="player">The player to check and potentially level up.</param>
    /// <param name="getAbilitiesAtLevel">Function to get abilities unlocked at a level.</param>
    /// <returns>The LevelUpResult (DidLevelUp will be false if no level-up occurred).</returns>
    /// <remarks>
    /// This is a convenience method that combines <see cref="CheckForLevelUp"/> and
    /// <see cref="ApplyLevelUp"/> into a single call.
    /// </remarks>
    public LevelUpResult CheckAndApplyLevelUp(
        Player player,
        Func<int, IReadOnlyList<string>>? getAbilitiesAtLevel = null)
    {
        var result = CheckForLevelUp(player);

        if (!result.DidLevelUp)
        {
            return result;
        }

        return ApplyLevelUp(player, result, getAbilitiesAtLevel);
    }

    /// <summary>
    /// Gets the cumulative stat increases for gaining multiple levels.
    /// </summary>
    /// <param name="levelsGained">The number of levels gained.</param>
    /// <returns>The total stat increases.</returns>
    /// <remarks>
    /// Uses default values: +5 MaxHealth, +1 Attack, +1 Defense per level.
    /// Will be configurable in v0.0.8c.
    /// </remarks>
    public StatModifiers GetStatIncreasesForLevels(int levelsGained)
    {
        if (levelsGained <= 0)
        {
            return StatModifiers.Zero;
        }

        return StatModifiers.DefaultLevelUp.Multiply(levelsGained);
    }

    /// <summary>
    /// Gets the XP required for the next level.
    /// </summary>
    /// <param name="currentLevel">The current level.</param>
    /// <returns>The XP required to reach the next level.</returns>
    public int GetExperienceForNextLevel(int currentLevel)
    {
        return Player.GetExperienceForLevel(currentLevel + 1);
    }

    /// <summary>
    /// Gets the XP remaining until the next level.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>The XP needed to reach the next level.</returns>
    public int GetExperienceUntilNextLevel(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var nextLevelXp = Player.GetExperienceForLevel(player.Level + 1);
        return Math.Max(0, nextLevelXp - player.Experience);
    }
}
```

---

### Application Layer

#### 5. LevelUpDto.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/DTOs/LevelUpDto.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying level-up information to the UI.
/// </summary>
/// <remarks>
/// <para>Contains pre-calculated display values for the level-up notification,
/// including before/after stats and ability names for display.</para>
/// <para>Use the <see cref="FromResult"/> factory method to create from a
/// <see cref="LevelUpResult"/> and player state.</para>
/// </remarks>
/// <param name="OldLevel">The player's previous level.</param>
/// <param name="NewLevel">The player's new level.</param>
/// <param name="LevelsGained">Number of levels gained.</param>
/// <param name="OldMaxHealth">Previous max health.</param>
/// <param name="NewMaxHealth">New max health.</param>
/// <param name="OldAttack">Previous attack stat.</param>
/// <param name="NewAttack">New attack stat.</param>
/// <param name="OldDefense">Previous defense stat.</param>
/// <param name="NewDefense">New defense stat.</param>
/// <param name="UnlockedAbilityNames">Names of newly unlocked abilities.</param>
/// <param name="XpToNextLevel">XP needed to reach the next level.</param>
public record LevelUpDto(
    int OldLevel,
    int NewLevel,
    int LevelsGained,
    int OldMaxHealth,
    int NewMaxHealth,
    int OldAttack,
    int NewAttack,
    int OldDefense,
    int NewDefense,
    IReadOnlyList<string> UnlockedAbilityNames,
    int XpToNextLevel)
{
    /// <summary>
    /// Gets whether multiple levels were gained.
    /// </summary>
    public bool IsMultiLevel => LevelsGained > 1;

    /// <summary>
    /// Gets whether any abilities were unlocked.
    /// </summary>
    public bool HasUnlockedAbilities => UnlockedAbilityNames.Count > 0;

    /// <summary>
    /// Gets the health increase amount.
    /// </summary>
    public int HealthIncrease => NewMaxHealth - OldMaxHealth;

    /// <summary>
    /// Gets the attack increase amount.
    /// </summary>
    public int AttackIncrease => NewAttack - OldAttack;

    /// <summary>
    /// Gets the defense increase amount.
    /// </summary>
    public int DefenseIncrease => NewDefense - OldDefense;

    /// <summary>
    /// Creates a DTO from a LevelUpResult and player state.
    /// </summary>
    /// <param name="result">The level-up result.</param>
    /// <param name="oldStats">The player's stats before level-up.</param>
    /// <param name="newStats">The player's stats after level-up.</param>
    /// <param name="abilityNames">Names of unlocked abilities.</param>
    /// <param name="xpToNextLevel">XP needed for next level.</param>
    /// <returns>A DTO for rendering.</returns>
    public static LevelUpDto FromResult(
        LevelUpResult result,
        Stats oldStats,
        Stats newStats,
        IReadOnlyList<string> abilityNames,
        int xpToNextLevel) =>
        new(
            result.OldLevel,
            result.NewLevel,
            result.LevelsGained,
            oldStats.MaxHealth,
            newStats.MaxHealth,
            oldStats.Attack,
            newStats.Attack,
            oldStats.Defense,
            newStats.Defense,
            abilityNames,
            xpToNextLevel);
}
```

#### 6. GameSessionService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

**Changes:** Add `ProgressionService` dependency, integrate level-up check after XP award.

```csharp
// Add to existing using statements:
using RuneAndRust.Domain.Services;
using RuneAndRust.Application.DTOs;

// Add ProgressionService dependency to existing fields:
private readonly ProgressionService _progressionService;

// Update constructor to include ProgressionService:
public GameSessionService(
    // ... existing dependencies ...
    ExperienceService experienceService,
    ProgressionService progressionService)  // NEW
{
    // ... existing initialization ...
    _experienceService = experienceService;
    _progressionService = progressionService;  // NEW
}

// Modify HandleCombatResult or equivalent combat victory handler:

/// <summary>
/// Handles the result of a combat round, including XP award and level-up.
/// </summary>
/// <param name="result">The combat result.</param>
/// <param name="monster">The monster involved in combat.</param>
/// <param name="ct">Cancellation token.</param>
private async Task HandleCombatResult(CombatResult result, Monster monster, CancellationToken ct)
{
    // ... existing combat result handling (render damage, defeat message) ...

    // Award XP if monster was defeated
    if (result.MonsterDefeated && result.ExperienceGained > 0)
    {
        var xpResult = _experienceService.AwardExperienceFromMonster(_session!.Player, monster);

        if (xpResult.DidGainExperience)
        {
            var xpDto = ExperienceGainDto.FromResult(
                xpResult,
                _session.Player.Level,
                _session.Player.ExperienceToNextLevel,
                _session.Player.ExperienceProgressPercent);

            await _renderer.RenderExperienceGainAsync(xpDto, ct);

            // Check for level-up (NEW)
            await CheckAndHandleLevelUp(ct);
        }
    }
}

/// <summary>
/// Checks for level-up and renders notification if applicable.
/// </summary>
/// <param name="ct">Cancellation token.</param>
/// <remarks>
/// <para>This method performs the following steps:</para>
/// <list type="number">
/// <item>Stores the player's old stats for the DTO</item>
/// <item>Checks for and applies level-up via ProgressionService</item>
/// <item>Collects ability names for display</item>
/// <item>Unlocks abilities on the player entity</item>
/// <item>Renders the level-up notification</item>
/// </list>
/// </remarks>
private async Task CheckAndHandleLevelUp(CancellationToken ct)
{
    var player = _session!.Player;
    var oldStats = player.Stats;

    // Function to get ability names for a level (for display)
    IReadOnlyList<string> GetAbilityNamesAtLevel(int level)
    {
        if (player.ClassId == null) return Array.Empty<string>();

        return _abilityService.GetUnlockedAbilitiesAtLevel(player.ClassId, level)
            .Select(a => a.Name)
            .ToList();
    }

    // Function to get ability IDs for unlocking
    IReadOnlyList<string> GetAbilityIdsAtLevel(int level)
    {
        if (player.ClassId == null) return Array.Empty<string>();

        return _abilityService.GetUnlockedAbilitiesAtLevel(player.ClassId, level)
            .Select(a => a.Id)
            .ToList();
    }

    var levelUpResult = _progressionService.CheckAndApplyLevelUp(player, GetAbilityIdsAtLevel);

    if (levelUpResult.DidLevelUp)
    {
        // Collect ability names for display
        var abilityNames = new List<string>();
        for (var level = levelUpResult.OldLevel + 1; level <= levelUpResult.NewLevel; level++)
        {
            abilityNames.AddRange(GetAbilityNamesAtLevel(level));
        }

        // Unlock abilities on the player
        foreach (var abilityId in levelUpResult.NewAbilities)
        {
            var ability = player.GetAbility(abilityId);
            if (ability != null && !ability.IsUnlocked)
            {
                ability.Unlock();
            }
        }

        var levelUpDto = LevelUpDto.FromResult(
            levelUpResult,
            oldStats,
            player.Stats,
            abilityNames,
            _progressionService.GetExperienceUntilNextLevel(player));

        await _renderer.RenderLevelUpAsync(levelUpDto, ct);
    }
}
```

---

### Presentation Layer

#### 7. IGameRenderer.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs`

**Changes:** Add `RenderLevelUpAsync()` method.

```csharp
// Add to existing IGameRenderer interface:

/// <summary>
/// Renders level-up notification with stat increases and unlocked abilities.
/// </summary>
/// <param name="levelUp">The level-up information to display.</param>
/// <param name="ct">Cancellation token.</param>
/// <returns>A task representing the async operation.</returns>
/// <remarks>
/// Displays a celebratory notification including:
/// - New level (or levels gained if multi-level)
/// - Stat increases with before/after values
/// - Newly unlocked abilities (if any)
/// - XP needed for next level
/// </remarks>
Task RenderLevelUpAsync(LevelUpDto levelUp, CancellationToken ct = default);
```

#### 8. SpectreGameRenderer.cs (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

**Changes:** Implement `RenderLevelUpAsync()` method.

```csharp
using System.Text;
using RuneAndRust.Application.DTOs;
using Spectre.Console;

// Implement the new method:

/// <inheritdoc />
public Task RenderLevelUpAsync(LevelUpDto levelUp, CancellationToken ct = default)
{
    var panel = new Panel(BuildLevelUpContent(levelUp))
    {
        Border = BoxBorder.Double,
        BorderStyle = new Style(Color.Yellow),
        Padding = new Padding(2, 1),
        Header = new PanelHeader("[bold yellow]★ LEVEL UP! ★[/]", Justify.Center)
    };

    AnsiConsole.WriteLine();
    AnsiConsole.Write(panel);
    AnsiConsole.WriteLine();

    return Task.CompletedTask;
}

/// <summary>
/// Builds the content string for the level-up notification.
/// </summary>
/// <param name="levelUp">The level-up information.</param>
/// <returns>A formatted string for the panel content.</returns>
private static string BuildLevelUpContent(LevelUpDto levelUp)
{
    var sb = new StringBuilder();

    // Level announcement
    if (levelUp.IsMultiLevel)
    {
        sb.AppendLine($"[bold]You gained {levelUp.LevelsGained} levels![/]");
        sb.AppendLine($"[dim]Level {levelUp.OldLevel} → Level {levelUp.NewLevel}[/]");
    }
    else
    {
        sb.AppendLine($"[bold]You have reached Level {levelUp.NewLevel}![/]");
    }

    sb.AppendLine();

    // Stat increases
    sb.AppendLine("[underline]Stat Increases:[/]");
    sb.AppendLine($"  Max Health: [dim]{levelUp.OldMaxHealth}[/] → [green]{levelUp.NewMaxHealth}[/] " +
        $"[dim](+{levelUp.HealthIncrease})[/]");
    sb.AppendLine($"  Attack: [dim]{levelUp.OldAttack}[/] → [green]{levelUp.NewAttack}[/] " +
        $"[dim](+{levelUp.AttackIncrease})[/]");
    sb.AppendLine($"  Defense: [dim]{levelUp.OldDefense}[/] → [green]{levelUp.NewDefense}[/] " +
        $"[dim](+{levelUp.DefenseIncrease})[/]");

    // Unlocked abilities
    if (levelUp.HasUnlockedAbilities)
    {
        sb.AppendLine();
        sb.AppendLine("[underline]New Abilities Unlocked:[/]");
        foreach (var ability in levelUp.UnlockedAbilityNames)
        {
            sb.AppendLine($"  [cyan]•[/] [bold]{ability}[/]");
        }
    }

    // Next level info
    sb.AppendLine();
    sb.AppendLine($"[dim]Next Level: {levelUp.XpToNextLevel} XP needed (Level {levelUp.NewLevel + 1})[/]");

    return sb.ToString();
}
```

---

## Flow Diagrams

### Level-Up Detection and Application Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      LEVEL-UP FLOW (After XP Award)                          │
└─────────────────────────────────────────────────────────────────────────────┘

    Monster Defeated → ExperienceService.AwardExperience()
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 1: CHECK FOR LEVEL UP                                │
├─────────────────────────────────────────────────────────────────────────────┤
│  ProgressionService.CheckForLevelUp(player)                                  │
│  ├── Get target level: Player.GetLevelForExperience(player.Experience)       │
│  ├── Compare to current level                                                │
│  ├── If targetLevel <= currentLevel → Return LevelUpResult.None              │
│  └── Otherwise:                                                              │
│      ├── levelsGained = targetLevel - currentLevel                           │
│      ├── statIncreases = GetStatIncreasesForLevels(levelsGained)             │
│      └── Return LevelUpResult(OldLevel, NewLevel, StatIncreases, [])         │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼ (if DidLevelUp)
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 2: APPLY LEVEL UP                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│  ProgressionService.ApplyLevelUp(player, result, getAbilitiesAtLevel)        │
│  ├── player.ApplyStatModifiers(result.StatIncreases, healToNewMax: true)     │
│  │   ├── Stats.MaxHealth += modifiers.MaxHealth                              │
│  │   ├── Stats.Attack += modifiers.Attack                                    │
│  │   ├── Stats.Defense += modifiers.Defense                                  │
│  │   └── Health = Stats.MaxHealth (full heal)                                │
│  ├── player.SetLevel(result.NewLevel)                                        │
│  ├── For each level gained:                                                  │
│  │   └── getAbilitiesAtLevel(level) → collect unlocked ability IDs           │
│  └── Return updated LevelUpResult with abilities                             │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 3: CREATE DTO                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  LevelUpDto.FromResult(result, oldStats, newStats, abilityNames, xpToNext)   │
│  ├── OldLevel: 1                                                             │
│  ├── NewLevel: 2                                                             │
│  ├── LevelsGained: 1                                                         │
│  ├── OldMaxHealth: 100, NewMaxHealth: 105                                    │
│  ├── OldAttack: 10, NewAttack: 11                                            │
│  ├── OldDefense: 5, NewDefense: 6                                            │
│  ├── UnlockedAbilityNames: ["Shield Bash"]                                   │
│  └── XpToNextLevel: 100                                                      │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 4: RENDER LEVEL UP                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  IGameRenderer.RenderLevelUpAsync(dto)                                       │
│  ├── ═══════════════════════════════════════════                            │
│  ├──            ★ LEVEL UP! ★                                               │
│  ├── ═══════════════════════════════════════════                            │
│  ├── You have reached Level 2!                                              │
│  ├──                                                                         │
│  ├── Stat Increases:                                                         │
│  ├──   Max Health: 100 → 105 (+5)                                           │
│  ├──   Attack: 10 → 11 (+1)                                                 │
│  ├──   Defense: 5 → 6 (+1)                                                  │
│  ├──                                                                         │
│  ├── New Abilities Unlocked:                                                 │
│  ├──   • Shield Bash                                                        │
│  ├──                                                                         │
│  └── Next Level: 100 XP needed (Level 3)                                    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Multi-Level Gain Flow

```
Player with 0 XP (Level 1)
     │
     ▼  Receives 500 XP (enough for Level 5)
┌─────────────────────────────────────────────┐
│  Player.GetLevelForExperience(500)          │
│  └── Returns 5                              │
└─────────────────────────────────────────────┘
     │
     ▼
┌─────────────────────────────────────────────┐
│  levelsGained = 5 - 1 = 4                   │
│  statIncreases = DefaultLevelUp × 4        │
│  └── (+20 HP, +4 ATK, +4 DEF)              │
└─────────────────────────────────────────────┘
     │
     ▼
┌─────────────────────────────────────────────┐
│  For level 2, 3, 4, 5:                      │
│  └── Check getAbilitiesAtLevel(level)       │
│      └── Collect all unlocked abilities     │
└─────────────────────────────────────────────┘
     │
     ▼
┌─────────────────────────────────────────────┐
│  Display: "You gained 4 levels!"            │
│           "Level 1 → Level 5"               │
│           Stats: 100→120, 10→14, 5→9        │
└─────────────────────────────────────────────┘
```

### XP Threshold Decision Tree

```
                         ┌─────────────────────┐
                         │ Player gains XP     │
                         └──────────┬──────────┘
                                    │
                                    ▼
                         ┌─────────────────────┐
                         │ Calculate target    │
                         │ level from total XP │
                         └──────────┬──────────┘
                                    │
                     ┌──────────────┼──────────────┐
                     │              │              │
                     ▼              ▼              ▼
              ┌───────────┐ ┌───────────┐ ┌───────────┐
              │ target ≤  │ │ target =  │ │ target >  │
              │ current   │ │ current+1 │ │ current+1 │
              └─────┬─────┘ └─────┬─────┘ └─────┬─────┘
                    │             │             │
                    ▼             ▼             ▼
             No Level Up   Single Level  Multi-Level
                          └──────┬──────┘
                                 │
                                 ▼
                     ┌───────────────────────┐
                     │ Apply stat bonuses    │
                     │ per level gained      │
                     │ (DefaultLevelUp × N)  │
                     └───────────────────────┘
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── ValueObjects/
│   │   ├── LevelUpResultTests.cs           (4 tests)
│   │   └── StatModifiersTests.cs           (4 tests)
│   ├── Entities/
│   │   └── PlayerLevelUpTests.cs           (4 tests)
│   └── Services/
│       └── ProgressionServiceTests.cs      (6 tests)
```

### Test Files

#### 1. StatModifiersTests.cs (4 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/StatModifiersTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class StatModifiersTests
{
    [Test]
    public void Zero_HasNoModifications()
    {
        // Act
        var zero = StatModifiers.Zero;

        // Assert
        zero.HasModifications.Should().BeFalse();
        zero.MaxHealth.Should().Be(0);
        zero.Attack.Should().Be(0);
        zero.Defense.Should().Be(0);
    }

    [Test]
    public void DefaultLevelUp_HasCorrectValues()
    {
        // Act
        var defaults = StatModifiers.DefaultLevelUp;

        // Assert
        defaults.MaxHealth.Should().Be(5);
        defaults.Attack.Should().Be(1);
        defaults.Defense.Should().Be(1);
        defaults.HasModifications.Should().BeTrue();
    }

    [Test]
    public void Add_CombinesModifiers()
    {
        // Arrange
        var a = new StatModifiers(5, 1, 1);
        var b = new StatModifiers(10, 2, 3);

        // Act
        var result = a.Add(b);

        // Assert
        result.MaxHealth.Should().Be(15);
        result.Attack.Should().Be(3);
        result.Defense.Should().Be(4);
    }

    [Test]
    public void Multiply_ScalesAllValues()
    {
        // Arrange
        var modifiers = new StatModifiers(5, 1, 1);

        // Act
        var result = modifiers.Multiply(3);

        // Assert
        result.MaxHealth.Should().Be(15);
        result.Attack.Should().Be(3);
        result.Defense.Should().Be(3);
    }
}
```

#### 2. LevelUpResultTests.cs (4 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/LevelUpResultTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class LevelUpResultTests
{
    [Test]
    public void LevelsGained_ReturnsCorrectDifference()
    {
        // Arrange
        var result = new LevelUpResult(
            1, 3,
            StatModifiers.DefaultLevelUp.Multiply(2),
            Array.Empty<string>());

        // Act & Assert
        result.LevelsGained.Should().Be(2);
    }

    [Test]
    public void IsMultiLevel_MultipleLevels_ReturnsTrue()
    {
        // Arrange
        var result = new LevelUpResult(
            1, 3,
            StatModifiers.DefaultLevelUp.Multiply(2),
            Array.Empty<string>());

        // Act & Assert
        result.IsMultiLevel.Should().BeTrue();
    }

    [Test]
    public void IsMultiLevel_SingleLevel_ReturnsFalse()
    {
        // Arrange
        var result = new LevelUpResult(
            1, 2,
            StatModifiers.DefaultLevelUp,
            Array.Empty<string>());

        // Act & Assert
        result.IsMultiLevel.Should().BeFalse();
        result.DidLevelUp.Should().BeTrue();
    }

    [Test]
    public void None_ReturnsResultWithNoChange()
    {
        // Act
        var result = LevelUpResult.None(5);

        // Assert
        result.DidLevelUp.Should().BeFalse();
        result.OldLevel.Should().Be(5);
        result.NewLevel.Should().Be(5);
        result.LevelsGained.Should().Be(0);
        result.StatIncreases.Should().Be(StatModifiers.Zero);
        result.NewAbilities.Should().BeEmpty();
    }
}
```

#### 3. PlayerLevelUpTests.cs (4 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerLevelUpTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Entities;

[TestFixture]
public class PlayerLevelUpTests
{
    private Player _player = null!;

    [SetUp]
    public void SetUp()
    {
        _player = new Player("TestPlayer", new Stats(100, 10, 5));
    }

    [Test]
    public void ApplyStatModifiers_IncreasesStats()
    {
        // Arrange
        var modifiers = new StatModifiers(5, 1, 1);

        // Act
        _player.ApplyStatModifiers(modifiers);

        // Assert
        _player.Stats.MaxHealth.Should().Be(105);
        _player.Stats.Attack.Should().Be(11);
        _player.Stats.Defense.Should().Be(6);
    }

    [Test]
    public void ApplyStatModifiers_WithHealToMax_RestoresHealth()
    {
        // Arrange
        _player.TakeDamage(50); // Damage player first
        _player.Health.Should().Be(50);
        var modifiers = new StatModifiers(5, 1, 1);

        // Act
        _player.ApplyStatModifiers(modifiers, healToNewMax: true);

        // Assert
        _player.Health.Should().Be(105); // Full health at new max
        _player.Stats.MaxHealth.Should().Be(105);
    }

    [Test]
    public void GetExperienceForLevel_ReturnsCorrectThresholds()
    {
        // Assert
        Player.GetExperienceForLevel(1).Should().Be(0);
        Player.GetExperienceForLevel(2).Should().Be(200);
        Player.GetExperienceForLevel(3).Should().Be(300);
        Player.GetExperienceForLevel(5).Should().Be(500);
        Player.GetExperienceForLevel(10).Should().Be(1000);
    }

    [Test]
    public void GetLevelForExperience_ReturnsCorrectLevel()
    {
        // Assert - below level 2 threshold
        Player.GetLevelForExperience(0).Should().Be(1);
        Player.GetLevelForExperience(199).Should().Be(1);

        // At exactly level 2
        Player.GetLevelForExperience(200).Should().Be(2);

        // Between levels
        Player.GetLevelForExperience(250).Should().Be(2);
        Player.GetLevelForExperience(350).Should().Be(3);

        // High XP
        Player.GetLevelForExperience(1000).Should().Be(10);
    }
}
```

#### 4. ProgressionServiceTests.cs (6 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Services/ProgressionServiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Services;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Services;

[TestFixture]
public class ProgressionServiceTests
{
    private ProgressionService _service = null!;
    private Player _player = null!;

    [SetUp]
    public void SetUp()
    {
        var loggerFactory = new NullLoggerFactory();
        _service = new ProgressionService(loggerFactory.CreateLogger<ProgressionService>());
        _player = new Player("TestPlayer", new Stats(100, 10, 5));
    }

    [Test]
    public void CheckForLevelUp_BelowThreshold_ReturnsNone()
    {
        // Arrange
        _player.AddExperience(150); // Not enough for level 2 (needs 200)

        // Act
        var result = _service.CheckForLevelUp(_player);

        // Assert
        result.DidLevelUp.Should().BeFalse();
        result.OldLevel.Should().Be(1);
        result.NewLevel.Should().Be(1);
    }

    [Test]
    public void CheckForLevelUp_AtThreshold_ReturnsLevelUp()
    {
        // Arrange
        _player.AddExperience(200); // Exactly level 2

        // Act
        var result = _service.CheckForLevelUp(_player);

        // Assert
        result.DidLevelUp.Should().BeTrue();
        result.OldLevel.Should().Be(1);
        result.NewLevel.Should().Be(2);
        result.LevelsGained.Should().Be(1);
        result.StatIncreases.MaxHealth.Should().Be(5);
        result.StatIncreases.Attack.Should().Be(1);
        result.StatIncreases.Defense.Should().Be(1);
    }

    [Test]
    public void CheckForLevelUp_MultiLevel_ReturnsCorrectLevels()
    {
        // Arrange
        _player.AddExperience(500); // Enough for level 5

        // Act
        var result = _service.CheckForLevelUp(_player);

        // Assert
        result.DidLevelUp.Should().BeTrue();
        result.OldLevel.Should().Be(1);
        result.NewLevel.Should().Be(5);
        result.LevelsGained.Should().Be(4);
        result.IsMultiLevel.Should().BeTrue();
        result.StatIncreases.MaxHealth.Should().Be(20);
        result.StatIncreases.Attack.Should().Be(4);
        result.StatIncreases.Defense.Should().Be(4);
    }

    [Test]
    public void ApplyLevelUp_UpdatesPlayerLevel()
    {
        // Arrange
        _player.AddExperience(200);
        var result = _service.CheckForLevelUp(_player);

        // Act
        _service.ApplyLevelUp(_player, result);

        // Assert
        _player.Level.Should().Be(2);
    }

    [Test]
    public void ApplyLevelUp_AppliesStatIncreases()
    {
        // Arrange
        _player.AddExperience(200);
        var result = _service.CheckForLevelUp(_player);

        // Act
        _service.ApplyLevelUp(_player, result);

        // Assert
        _player.Stats.MaxHealth.Should().Be(105);
        _player.Stats.Attack.Should().Be(11);
        _player.Stats.Defense.Should().Be(6);
    }

    [Test]
    public void ApplyLevelUp_HealsToNewMax()
    {
        // Arrange
        _player.TakeDamage(50);
        _player.Health.Should().Be(50);
        _player.AddExperience(200);
        var result = _service.CheckForLevelUp(_player);

        // Act
        _service.ApplyLevelUp(_player, result);

        // Assert
        _player.Health.Should().Be(_player.Stats.MaxHealth);
        _player.Health.Should().Be(105);
    }
}
```

### Test Summary

| Test File | Test Count | Focus Areas |
|-----------|------------|-------------|
| `StatModifiersTests.cs` | 4 | Value object arithmetic, defaults |
| `LevelUpResultTests.cs` | 4 | Value object behavior, computed properties |
| `PlayerLevelUpTests.cs` | 4 | Player entity level-up methods |
| `ProgressionServiceTests.cs` | 6 | Level-up detection, application, multi-level |
| **Total** | **18** | |

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Level-up detection (no change) | Debug | "No level up - Player {PlayerName} at level {Level} with {XP} XP" |
| Level-up detected | Information | "Level up detected - Player {PlayerName}: Level {OldLevel} -> {NewLevel}" |
| Level-up applied | Information | "Level up applied - Player {PlayerName} is now level {Level}" |
| Stat increases | Information | "Stats: HP={HP}, ATK={ATK}, DEF={DEF}" |
| Abilities unlocked | Information | "Abilities unlocked: {AbilityCount}" |

### Structured Logging Format

```csharp
// ProgressionService - Check for level-up (no change)
_logger.LogDebug(
    "No level up - Player {PlayerName} at level {Level} with {XP} XP",
    player.Name, player.Level, player.Experience);

// ProgressionService - Level-up detected
_logger.LogInformation(
    "Level up detected - Player {PlayerName}: Level {OldLevel} -> {NewLevel} " +
    "(+{HP} HP, +{ATK} ATK, +{DEF} DEF)",
    player.Name, player.Level, targetLevel,
    statIncreases.MaxHealth, statIncreases.Attack, statIncreases.Defense);

// ProgressionService - Level-up applied
_logger.LogInformation(
    "Level up applied - Player {PlayerName} is now level {Level}. " +
    "Stats: HP={HP}, ATK={ATK}, DEF={DEF}. Abilities unlocked: {AbilityCount}",
    player.Name, player.Level,
    player.Stats.MaxHealth, player.Stats.Attack, player.Stats.Defense,
    unlockedAbilities.Count);
```

---

## Implementation Checklist

### Phase 1: Domain Layer - Value Objects
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/StatModifiers.cs`
  - [ ] Record struct with MaxHealth, Attack, Defense properties
  - [ ] Static `Zero` field
  - [ ] Static `DefaultLevelUp` field (+5 HP, +1 ATK, +1 DEF)
  - [ ] `HasModifications` computed property
  - [ ] `Add()` method for combining modifiers
  - [ ] `Multiply()` method for scaling
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/LevelUpResult.cs`
  - [ ] Record struct with OldLevel, NewLevel, StatIncreases, NewAbilities
  - [ ] `LevelsGained` computed property
  - [ ] `IsMultiLevel` computed property
  - [ ] `HasNewAbilities` computed property
  - [ ] `DidLevelUp` computed property
  - [ ] Static `None()` factory method
  - [ ] XML documentation

### Phase 2: Domain Layer - Player Entity
- [ ] Modify `src/Core/RuneAndRust.Domain/Entities/Player.cs`
  - [ ] Add `ApplyStatModifiers(modifiers, healToNewMax)` method
  - [ ] Add `GetExperienceForLevel(level)` static method
  - [ ] Add `GetLevelForExperience(experience)` static method
  - [ ] XML documentation for new methods

### Phase 3: Domain Layer - ProgressionService
- [ ] Create `src/Core/RuneAndRust.Domain/Services/ProgressionService.cs`
  - [ ] Constructor with ILogger dependency
  - [ ] `CheckForLevelUp(player)` method
  - [ ] `ApplyLevelUp(player, result, getAbilitiesAtLevel)` method
  - [ ] `CheckAndApplyLevelUp(player, getAbilitiesAtLevel)` convenience method
  - [ ] `GetStatIncreasesForLevels(levelsGained)` method
  - [ ] `GetExperienceForNextLevel(currentLevel)` method
  - [ ] `GetExperienceUntilNextLevel(player)` method
  - [ ] XML documentation

### Phase 4: Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/LevelUpDto.cs`
  - [ ] Record with all display properties
  - [ ] `IsMultiLevel`, `HasUnlockedAbilities` computed properties
  - [ ] `HealthIncrease`, `AttackIncrease`, `DefenseIncrease` properties
  - [ ] `FromResult()` factory method
  - [ ] XML documentation
- [ ] Modify `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs`
  - [ ] Add `RenderLevelUpAsync(LevelUpDto levelUp, CancellationToken ct)` method
- [ ] Modify `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`
  - [ ] Add ProgressionService dependency
  - [ ] Update constructor
  - [ ] Add `CheckAndHandleLevelUp()` private method
  - [ ] Call level-up check after XP award in combat handling

### Phase 5: Presentation Layer
- [ ] Modify `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`
  - [ ] Implement `RenderLevelUpAsync()` method
  - [ ] Implement `BuildLevelUpContent()` helper method
  - [ ] Yellow double-border panel with star header
  - [ ] Single-level and multi-level display support
  - [ ] Stat increases with before/after values
  - [ ] Ability list (when applicable)
  - [ ] Next level XP info

### Phase 6: DI Registration
- [ ] Register `ProgressionService` in DI container (Program.cs or ServiceRegistration)

### Phase 7: Testing
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/StatModifiersTests.cs` (4 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/LevelUpResultTests.cs` (4 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerLevelUpTests.cs` (4 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Services/ProgressionServiceTests.cs` (6 tests)

### Phase 8: Validation
- [ ] All 18 new tests pass
- [ ] All existing tests pass (~317 → ~335 total)
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | `StatModifiers.Zero` has no modifications | Unit test |
| AC-2 | `StatModifiers.DefaultLevelUp` = +5 HP, +1 ATK, +1 DEF | Unit test |
| AC-3 | `StatModifiers.Add()` combines modifiers correctly | Unit test |
| AC-4 | `StatModifiers.Multiply()` scales modifiers correctly | Unit test |
| AC-5 | `LevelUpResult.LevelsGained` returns correct difference | Unit test |
| AC-6 | `LevelUpResult.IsMultiLevel` returns true when > 1 level gained | Unit test |
| AC-7 | `LevelUpResult.None()` creates result with no change | Unit test |
| AC-8 | `Player.ApplyStatModifiers()` updates player stats | Unit test |
| AC-9 | `Player.ApplyStatModifiers()` with healToNewMax heals player | Unit test |
| AC-10 | `Player.GetExperienceForLevel()` returns correct thresholds | Unit test |
| AC-11 | `Player.GetLevelForExperience()` returns correct level | Unit test |
| AC-12 | `ProgressionService.CheckForLevelUp()` detects level-up | Unit test |
| AC-13 | `ProgressionService.CheckForLevelUp()` returns None when no level-up | Unit test |
| AC-14 | `ProgressionService.ApplyLevelUp()` updates player level | Unit test |
| AC-15 | `ProgressionService.ApplyLevelUp()` applies stat increases | Unit test |
| AC-16 | `ProgressionService.ApplyLevelUp()` heals to new max | Unit test |
| AC-17 | Multi-level gains are handled correctly | Unit test |
| AC-18 | Level-up check occurs after XP is awarded | Integration |
| AC-19 | Level-up notification renders when level increases | Manual verification |
| AC-20 | Abilities are unlocked on level-up | Integration |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | All new code has XML documentation | Code review |
| NF-2 | Logging follows established patterns | Code review |
| NF-3 | Build completes with 0 errors and 0 warnings | Build verification |
| NF-4 | All 18 new tests pass | Test suite |
| NF-5 | Existing tests remain passing | Test suite |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| XP threshold changes break existing saves | Medium | Low | Formula is same as v0.0.8a |
| Stat overflow at very high levels | Low | Low | int max is ~2B, stats won't reach that |
| Ability unlock not triggering | Medium | Medium | Thorough testing of ability service integration |
| Multi-level edge cases | Medium | Medium | Comprehensive tests for large XP gains |
| Health heal conflicts with damage-in-progress | Medium | Low | Level-up only occurs after combat resolution |
| Display formatting issues with large numbers | Low | Low | Test with high level/stat values |
| DI registration forgotten | Medium | Low | Clear checklist item, integration test |
| Stats struct immutability issues | Medium | Low | Creating new Stats instance in ApplyStatModifiers |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `src/Core/RuneAndRust.Domain/ValueObjects/StatModifiers.cs` | Stat modification value object | ~50 |
| `src/Core/RuneAndRust.Domain/ValueObjects/LevelUpResult.cs` | Level-up result value object | ~50 |
| `src/Core/RuneAndRust.Domain/Services/ProgressionService.cs` | Level-up detection and application | ~120 |
| `src/Core/RuneAndRust.Application/DTOs/LevelUpDto.cs` | Level-up display DTO | ~60 |
| `tests/RuneAndRust.Domain.UnitTests/ValueObjects/StatModifiersTests.cs` | StatModifiers tests | ~60 |
| `tests/RuneAndRust.Domain.UnitTests/ValueObjects/LevelUpResultTests.cs` | LevelUpResult tests | ~60 |
| `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerLevelUpTests.cs` | Player level-up tests | ~80 |
| `tests/RuneAndRust.Domain.UnitTests/Services/ProgressionServiceTests.cs` | ProgressionService tests | ~100 |

### Files to Modify

| File | Changes |
|------|---------|
| `src/Core/RuneAndRust.Domain/Entities/Player.cs` | Add ApplyStatModifiers(), GetExperienceForLevel(), GetLevelForExperience() (~40 lines) |
| `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs` | Add RenderLevelUpAsync() method (~10 lines) |
| `src/Core/RuneAndRust.Application/Services/GameSessionService.cs` | Add ProgressionService dependency, CheckAndHandleLevelUp() (~60 lines) |
| `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs` | Implement RenderLevelUpAsync(), BuildLevelUpContent() (~60 lines) |
| DI Container (Program.cs or equivalent) | Register ProgressionService (~2 lines) |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| Value Objects | N | N+2 (StatModifiers, LevelUpResult) |
| Domain Services | N | N+1 (ProgressionService) |
| Application DTOs | N | N+1 (LevelUpDto) |
| Unit Tests | ~317 | ~335 |

---

## Next Steps

After completing this phase:

1. **v0.0.8c (Progression Configuration)** - Make the progression system fully configurable:
   - `ProgressionDefinition` entity loaded from JSON
   - Configurable terminology (XP/Level names)
   - Configurable progression curves (linear, exponential, custom)
   - Class-specific stat bonus multipliers
   - `config/progression.json` configuration file

---

## Provides to Future Phases

### To v0.0.8c (Progression Configuration)

| Type | Usage |
|------|-------|
| `ProgressionService` | Replace default formulas with config-driven calculations |
| `StatModifiers` | Replace DefaultLevelUp with config-driven values |
| `LevelUpResult` | Extended with custom reward information |
| `Player.GetExperienceForLevel()` | Replace with config-driven thresholds |
| `Player.GetLevelForExperience()` | Replace with config-driven lookup |

---

*This implementation plan provides the detailed step-by-step blueprint for implementing v0.0.8b Level-Up Mechanics. This phase builds on the XP tracking from v0.0.8a and integrates with the ability unlock system from v0.0.4c, while establishing the foundation for configurable progression in v0.0.8c.*

