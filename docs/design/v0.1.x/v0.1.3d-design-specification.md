# v0.1.3d Design Specification: Dungeon Age & Coherence

**Version:** 0.1.3d
**Phase Name:** Dungeon Age & Coherence
**Parent Version:** v0.1.3 (Advanced Procedural Architecture)
**Prerequisites:** v0.1.3a (Architectural Styles), v0.1.3b (Room Shapes & Features), v0.1.3c (Landmark Rooms), v0.1.2c (BiomeHazard)
**Estimated Tests:** ~23 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [DungeonAge Enum](#4-dungeonage-enum)
5. [AgeDescriptors Value Object](#5-agedescriptors-value-object)
6. [MaterialPalette Value Object](#6-materialpalette-value-object)
7. [CoherenceService](#7-coherenceservice)
8. [Room Age Integration](#8-room-age-integration)
9. [Age-Based Hazard Modifiers](#9-age-based-hazard-modifiers)
10. [Corridor Generation Rules](#10-corridor-generation-rules)
11. [Data Model Changes](#11-data-model-changes)
12. [Configuration File Schemas](#12-configuration-file-schemas)
13. [Logging Specifications](#13-logging-specifications)
14. [Unit Testing Requirements](#14-unit-testing-requirements)
15. [Use Cases](#15-use-cases)
16. [Deliverable Checklist](#16-deliverable-checklist)
17. [Acceptance Criteria](#17-acceptance-criteria)
18. [Dependencies](#18-dependencies)
19. [Future Considerations](#19-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement the dungeon age and structural coherence systems that complete the Advanced Procedural Architecture version. Dungeon age represents the condition of structures—from freshly occupied to nature-reclaimed ruins—affecting descriptors, hazards, and atmosphere. Coherence rules ensure logical architecture by validating material consistency, corridor requirements, and structural support needs. Together, these systems add environmental storytelling and believable construction to procedurally generated dungeons.

### 1.2 Current State

| Area | Current State (v0.1.3c) | Target State (v0.1.3d) |
|------|-------------------------|------------------------|
| Room condition | No age representation | Four-state age system (Fresh, Ancient, Collapsed, Reclaimed) |
| Descriptors | Style + Biome layered | Style + Biome + Age layered |
| Hazards | Biome-based only | Age-modified hazard probabilities |
| Materials | Implicit | Explicit MaterialPalette per biome |
| Corridors | Style-dependent presence | Style + Age corridor requirements |
| Structural logic | None | CoherenceService validation |
| Room entity | Shape, Style, Landmarks | + Age property |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Enums** | `DungeonAge` |
| **Value Objects** | `AgeDescriptors`, `MaterialPalette`, `CoherenceRules` |
| **Services** | `CoherenceService` (with `ICoherenceService` interface) |
| **Configuration** | `dungeon-ages.json`, `coherence-rules.json`, JSON schemas |
| **Entity Updates** | `Room.Age` property |
| **Service Updates** | `DescriptorService` age-aware overlays, `HazardService` age modifiers |
| **Tests** | ~23 new unit tests |

### 1.4 Architectural Significance

This version completes the **environmental storytelling layer** for dungeon architecture:
- Age system adds temporal dimension to static structures
- Coherence validation ensures believable construction
- Material palettes provide visual consistency per biome
- Age-based hazard modifiers create environmental storytelling through danger
- Descriptor overlays enable rich, layered room descriptions
- Foundation for future environmental progression systems

---

## 2. Feature Overview

```
v0.1.3d Dungeon Age & Coherence
├── DungeonAge Enum
│   ├── Fresh (recently occupied, clean, maintained)
│   ├── Ancient (long abandoned, dusty, worn)
│   ├── Collapsed (structural damage, rubble, unstable)
│   └── Reclaimed (nature overtaking, vegetation, wildlife)
├── AgeDescriptors Value Object
│   ├── Surface condition descriptors
│   ├── Atmosphere modifiers
│   ├── Debris descriptors
│   ├── Lighting modifiers
│   ├── Smell modifiers
│   └── Static factory methods per age
├── MaterialPalette Value Object
│   ├── Primary wall material
│   ├── Secondary/accent material
│   ├── Floor material
│   ├── Metal accent
│   ├── Color palette
│   └── ForBiome(biomeId) factory
├── CoherenceService
│   ├── GetMaterialPalette(biomeId, styleId)
│   ├── RequiresCorridor(fromRoom, toRoom, style)
│   ├── GetRequiredSupports(room, style)
│   ├── GetAgeModifiedDescription(room, age, baseDescription)
│   ├── GetAgeHazardModifier(age)
│   └── ValidateCoherence(rooms, expectedStyle)
├── Room Age Integration
│   ├── Room.Age property
│   └── Room.SetAge(age) method
├── Age-Based Hazard Modifiers
│   ├── Fresh: 0.5x (fewer hazards)
│   ├── Ancient: 1.0x (baseline)
│   ├── Collapsed: 1.5x (structural hazards)
│   └── Reclaimed: 1.2x (nature hazards)
├── Corridor Generation Rules
│   ├── Style-based corridor requirements
│   └── Room type corridor logic
└── Configuration
    ├── dungeon-ages.json (4 age definitions)
    ├── coherence-rules.json (material palettes, corridor rules)
    └── JSON schemas for validation
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Room descriptions now include age-themed overlays                           │
│  ├── GameView displays age-appropriate condition text                        │
│  ├── Look command shows style + biome + age combined descriptions           │
│  └── Hazard warnings reflect age-modified danger levels                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  CoherenceService                   DescriptorService (Updated)              │
│  ├── GetMaterialPalette()           ├── GetAgeOverlay()                      │
│  ├── RequiresCorridor()             ├── GenerateAgedRoomDescription()        │
│  ├── GetRequiredSupports()          └── CombineDescriptorLayers()            │
│  ├── GetAgeModifiedDescription()                                             │
│  ├── GetAgeHazardModifier()         HazardService (Updated)                  │
│  └── ValidateCoherence()            └── ApplyAgeModifier(hazard, age)        │
│                                                                              │
│  Interfaces:                        RoomGeneratorService (Updated)           │
│  └── ICoherenceService              └── Assigns Age during generation        │
│                                                                              │
│  Configuration:                                                              │
│  ├── DungeonAgeConfigurationDto                                              │
│  └── CoherenceRulesConfigurationDto                                          │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Enums:                          Value Objects:                              │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                 │
│  │ DungeonAge              │     │ AgeDescriptors          │                 │
│  │ ├── Fresh               │     │ ├── Age: DungeonAge     │                 │
│  │ ├── Ancient             │     │ ├── SurfaceConditions   │                 │
│  │ ├── Collapsed           │     │ ├── AtmosphereModifiers │                 │
│  │ └── Reclaimed           │     │ ├── Debris              │                 │
│  └─────────────────────────┘     │ ├── LightingModifiers   │                 │
│                                  │ └── SmellModifiers      │                 │
│                                  └─────────────────────────┘                 │
│                                  ┌─────────────────────────┐                 │
│                                  │ MaterialPalette         │                 │
│                                  │ ├── PrimaryMaterial     │                 │
│                                  │ ├── SecondaryMaterial   │                 │
│                                  │ ├── FloorMaterial       │                 │
│                                  │ ├── MetalAccent         │                 │
│                                  │ └── Colors              │                 │
│                                  └─────────────────────────┘                 │
│                                  ┌─────────────────────────┐                 │
│                                  │ CoherenceValidationResult│                │
│                                  │ ├── IsValid: bool       │                 │
│                                  │ └── Issues: string[]    │                 │
│                                  └─────────────────────────┘                 │
│                                                                              │
│  Entities (Updated):                                                         │
│  ┌─────────────────────────┐                                                 │
│  │ Room                    │                                                 │
│  │ ├── Age: DungeonAge     │                                                 │
│  │ └── SetAge(age): void   │                                                 │
│  └─────────────────────────┘                                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetDungeonAges(): IReadOnlyList<DungeonAgeDefinition>                  │
│  └── GetCoherenceRules(): CoherenceRulesDefinition                          │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/dungeon-ages.json                                               │
│  ├── config/coherence-rules.json                                            │
│  ├── config/schemas/dungeon-ages-schema.json                                │
│  └── config/schemas/coherence-rules-schema.json                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Age Selection and Application Flow

```
┌───────────────────────────────────────┐
│ RoomGeneratorService generates room   │
│ with BiomeId and ArchitecturalStyleId │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Determine Age Based on Context                        │
├───────────────────────────────────────────────────────────────┤
│ Consider factors:                                             │
│ ├── Dungeon depth (deeper = older)                            │
│ ├── Biome characteristics                                     │
│ ├── Architectural style tendencies                            │
│ └── Random weighted selection                                 │
│                                                               │
│ Weight calculation:                                           │
│ ├── Fresh: high weight near entrance, low weight deep         │
│ ├── Ancient: baseline weight throughout                       │
│ ├── Collapsed: increases with depth and certain styles        │
│ └── Reclaimed: depends on biome (high in nature biomes)       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Assign Age to Room                                    │
├───────────────────────────────────────────────────────────────┤
│ room.SetAge(DungeonAge.Ancient)                               │
│                                                               │
│ Room now has:                                                 │
│ ├── BiomeId: "catacombs"                                      │
│ ├── ArchitecturalStyleId: "carved-halls"                      │
│ ├── Shape: RoomShape.Rectangular                              │
│ └── Age: DungeonAge.Ancient                                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Apply Age Effects                                     │
├───────────────────────────────────────────────────────────────┤
│ Age affects:                                                  │
│ ├── Description overlays (dust-covered, crumbling, etc.)      │
│ ├── Hazard probability modifiers (0.5x to 1.5x)               │
│ ├── Trap functionality (Fresh=100%, Collapsed=30%)            │
│ ├── Loot quality (Fresh=90%, Reclaimed=70%)                   │
│ └── Encounter rates (Fresh=120%, Ancient=80%)                 │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Description Generation with Age Overlay

```
┌───────────────────────────────────────┐
│ DescriptorService generates room text │
│ for Room with:                        │
│ ├── BiomeId = "catacombs"             │
│ ├── ArchitecturalStyleId = "carved-halls"
│ └── Age = DungeonAge.Collapsed        │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Layer 1: Style Descriptors (Physical Structure)               │
├───────────────────────────────────────────────────────────────┤
│ StyleDescriptors for "carved-halls":                          │
│ ├── walls → "smooth-cut stone"                                │
│ ├── floor → "fitted flagstones"                               │
│ └── ceiling → "vaulted arches"                                │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Layer 2: Biome Descriptors (Atmosphere)                       │
├───────────────────────────────────────────────────────────────┤
│ BiomeDescriptors for "catacombs":                             │
│ ├── lighting → "flickering shadows"                           │
│ ├── smell → "ancient dust"                                    │
│ └── atmosphere → "reverent silence"                           │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Layer 3: Age Overlay (Condition)                              │
├───────────────────────────────────────────────────────────────┤
│ AgeDescriptors for DungeonAge.Collapsed:                      │
│ ├── surfaceConditions → "crumbling"                           │
│ ├── atmosphereModifiers → "threatening collapse"              │
│ ├── debris → "fallen stones"                                  │
│ ├── lightingModifiers → "dust-filtered light"                 │
│ └── smellModifiers → "crushed stone"                          │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Combined Description Output                                   │
├───────────────────────────────────────────────────────────────┤
│ "You stand in a chamber with crumbling smooth-cut stone walls │
│  rising to vaulted arches above—though several sections show  │
│  signs of threatening collapse. Fitted flagstones, now broken │
│  and uneven, stretch beneath your feet. Fallen stones litter  │
│  the floor. Dust-filtered light barely illuminates the space, │
│  and the smell of crushed stone mingles with ancient dust."   │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 Coherence Validation Flow

```
┌───────────────────────────────────────┐
│ Dungeon region generated with rooms   │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ CoherenceService.ValidateCoherence(rooms, "carved-halls")     │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│ Check 1: Style Consistency                                    │
│ ├── Count rooms with matching style                           │
│ ├── If >20% mismatched → Issue: "Style inconsistency"         │
│ └── Allow transitions at biome boundaries                     │
│                                                               │
│ Check 2: Material Consistency                                 │
│ ├── Get MaterialPalette for biome                             │
│ ├── Count distinct biomes in region                           │
│ └── If >2 biomes without transition → Issue                   │
│                                                               │
│ Check 3: Structural Support                                   │
│ ├── For each large room in constructed style                  │
│ ├── Check if support features present                         │
│ └── If missing → Issue: "Large room lacks supports"           │
│                                                               │
│ Check 4: Corridor Requirements                                │
│ ├── For constructed styles with HasCorridors                  │
│ ├── Verify corridors connect rooms appropriately              │
│ └── Natural caves exempt from corridor requirements           │
│                                                               │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Return CoherenceValidationResult                              │
├───────────────────────────────────────────────────────────────┤
│ {                                                             │
│   IsValid: true/false,                                        │
│   Issues: [                                                   │
│     "Style inconsistencies: 25% of rooms",                    │
│     "Missing supports in room at (5, 3, 2)"                   │
│   ]                                                           │
│ }                                                             │
│                                                               │
│ Note: Issues are warnings, not blocking errors.               │
│ Generator may choose to address or log for review.            │
└───────────────────────────────────────────────────────────────┘
```

---

## 4. DungeonAge Enum

### 4.1 Purpose

The `DungeonAge` enum represents the temporal condition of dungeon structures, affecting descriptors, hazards, and gameplay. Each age represents a distinct stage of structural decay and environmental change.

### 4.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Enums/DungeonAge.cs`

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the age and condition of dungeon structures.
/// </summary>
/// <remarks>
/// Age affects room descriptors, hazard probabilities, trap functionality,
/// loot quality, and encounter rates. Each age creates distinct atmospheric
/// conditions and gameplay implications.
/// </remarks>
public enum DungeonAge
{
    /// <summary>
    /// Recently constructed or actively maintained structures.
    /// </summary>
    /// <remarks>
    /// Characteristics:
    /// - Clean, well-maintained surfaces
    /// - Active occupation possible
    /// - Working traps and mechanisms
    /// - Higher encounter rates (inhabitants present)
    /// - Lower environmental hazard probability
    /// </remarks>
    Fresh,

    /// <summary>
    /// Long abandoned but structurally sound ruins.
    /// </summary>
    /// <remarks>
    /// Characteristics:
    /// - Dust-covered, faded surfaces
    /// - No active occupation
    /// - Partially functional traps
    /// - Baseline hazard and encounter rates
    /// - Standard loot quality
    /// </remarks>
    Ancient,

    /// <summary>
    /// Partially destroyed with structural damage.
    /// </summary>
    /// <remarks>
    /// Characteristics:
    /// - Crumbling walls, unstable ceilings
    /// - Rubble and blocked passages
    /// - Mostly non-functional traps
    /// - Higher structural hazard probability
    /// - Reduced encounter rates (difficult to inhabit)
    /// </remarks>
    Collapsed,

    /// <summary>
    /// Nature overtaking former structures.
    /// </summary>
    /// <remarks>
    /// Characteristics:
    /// - Vegetation, roots, water damage
    /// - Wildlife presence
    /// - Non-functional mechanical traps
    /// - Nature-based hazards (vines, pools, creatures)
    /// - Unique encounter types (animals, nature spirits)
    /// </remarks>
    Reclaimed
}
```

### 4.4 Age Characteristics Summary

| Age | Hazard Mod | Trap Function | Loot Quality | Encounter Mod |
|-----|------------|---------------|--------------|---------------|
| Fresh | 0.5x | 100% | 90% | 120% |
| Ancient | 1.0x | 70% | 100% | 80% |
| Collapsed | 1.5x | 30% | 80% | 60% |
| Reclaimed | 1.2x | 10% | 70% | 100% |

---

## 5. AgeDescriptors Value Object

### 5.1 Purpose

The `AgeDescriptors` value object contains arrays of themed descriptive text specific to each dungeon age. These descriptors overlay on base room descriptions to convey the temporal condition of structures.

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AgeDescriptors.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Descriptors that overlay on room descriptions based on dungeon age.
/// </summary>
/// <remarks>
/// Age descriptors modify base descriptions to convey the temporal condition
/// of structures. They layer on top of style and biome descriptors to create
/// rich, contextual room descriptions.
/// </remarks>
public readonly record struct AgeDescriptors
{
    /// <summary>
    /// Gets the age this descriptor set applies to.
    /// </summary>
    public DungeonAge Age { get; init; }

    /// <summary>
    /// Gets condition modifiers for surfaces (walls, floors, ceilings).
    /// </summary>
    /// <remarks>
    /// Applied as adjectives to physical structure descriptions.
    /// Example: "crumbling" + "stone walls" → "crumbling stone walls"
    /// </remarks>
    public IReadOnlyList<string> SurfaceConditions { get; init; }

    /// <summary>
    /// Gets atmosphere modifiers.
    /// </summary>
    /// <remarks>
    /// Describes the overall feeling of the space based on its age.
    /// </remarks>
    public IReadOnlyList<string> AtmosphereModifiers { get; init; }

    /// <summary>
    /// Gets debris and clutter descriptors.
    /// </summary>
    /// <remarks>
    /// Physical objects scattered in the room due to age-related decay.
    /// </remarks>
    public IReadOnlyList<string> Debris { get; init; }

    /// <summary>
    /// Gets lighting modifiers.
    /// </summary>
    /// <remarks>
    /// How age affects the lighting conditions in the room.
    /// </remarks>
    public IReadOnlyList<string> LightingModifiers { get; init; }

    /// <summary>
    /// Gets smell modifiers.
    /// </summary>
    /// <remarks>
    /// Age-specific scent descriptors layered on biome smells.
    /// </remarks>
    public IReadOnlyList<string> SmellModifiers { get; init; }

    /// <summary>
    /// Creates descriptors for Fresh age (recently occupied/maintained).
    /// </summary>
    public static AgeDescriptors Fresh => new()
    {
        Age = DungeonAge.Fresh,
        SurfaceConditions = new[] { "clean", "well-maintained", "recently swept", "polished" },
        AtmosphereModifiers = new[] { "lived-in", "active", "occupied", "purposeful" },
        Debris = Array.Empty<string>(),
        LightingModifiers = new[] { "well-lit", "maintained torches", "fresh candles", "steady lamplight" },
        SmellModifiers = new[] { "recent habitation", "burning oil", "cooked food", "wood smoke" }
    };

    /// <summary>
    /// Creates descriptors for Ancient age (long abandoned, dusty).
    /// </summary>
    public static AgeDescriptors Ancient => new()
    {
        Age = DungeonAge.Ancient,
        SurfaceConditions = new[] { "dust-covered", "faded", "worn smooth", "time-weathered" },
        AtmosphereModifiers = new[] { "long-abandoned", "forgotten", "silent for ages", "timeless" },
        Debris = new[] { "scattered dust", "cobwebs", "faded remnants", "ancient debris" },
        LightingModifiers = new[] { "dim", "shadows deepened by time", "ancient darkness", "fading light" },
        SmellModifiers = new[] { "ancient dust", "stale air", "the scent of ages", "musty stillness" }
    };

    /// <summary>
    /// Creates descriptors for Collapsed age (partially destroyed, unstable).
    /// </summary>
    public static AgeDescriptors Collapsed => new()
    {
        Age = DungeonAge.Collapsed,
        SurfaceConditions = new[] { "crumbling", "fractured", "unstable", "ruined", "broken" },
        AtmosphereModifiers = new[] { "dangerous", "precarious", "threatening collapse", "structurally compromised" },
        Debris = new[] { "fallen stones", "rubble piles", "debris", "broken supports", "scattered masonry" },
        LightingModifiers = new[] { "shafts through gaps", "dust-filtered light", "unstable shadows", "flickering through cracks" },
        SmellModifiers = new[] { "dust and decay", "crushed stone", "exposed earth", "fresh rubble" }
    };

    /// <summary>
    /// Creates descriptors for Reclaimed age (nature overtaking).
    /// </summary>
    public static AgeDescriptors Reclaimed => new()
    {
        Age = DungeonAge.Reclaimed,
        SurfaceConditions = new[] { "vine-covered", "moss-grown", "root-cracked", "nature-claimed", "overgrown" },
        AtmosphereModifiers = new[] { "wild", "untamed", "returning to nature", "peaceful reclamation" },
        Debris = new[] { "fallen leaves", "animal droppings", "bird nests", "pooled water", "tangled roots" },
        LightingModifiers = new[] { "filtered through growth", "dappled green", "natural light through gaps", "soft organic glow" },
        SmellModifiers = new[] { "growing things", "damp earth", "wild animals", "fresh growth", "forest floor" }
    };

    /// <summary>
    /// Gets descriptors for a specific age.
    /// </summary>
    /// <param name="age">The dungeon age.</param>
    /// <returns>The appropriate age descriptors.</returns>
    public static AgeDescriptors ForAge(DungeonAge age) => age switch
    {
        DungeonAge.Fresh => Fresh,
        DungeonAge.Ancient => Ancient,
        DungeonAge.Collapsed => Collapsed,
        DungeonAge.Reclaimed => Reclaimed,
        _ => Ancient // Default to Ancient for unknown values
    };

    /// <summary>
    /// Gets a random descriptor from a specific category.
    /// </summary>
    /// <param name="category">The category name (surfaceConditions, atmosphereModifiers, debris, lightingModifiers, smellModifiers).</param>
    /// <param name="random">Random instance for selection.</param>
    /// <returns>A random descriptor string, or empty if category not found or empty.</returns>
    public string GetRandomDescriptor(string category, Random random)
    {
        var pool = category.ToLowerInvariant() switch
        {
            "surfaceconditions" or "surface" => SurfaceConditions,
            "atmospheremodifiers" or "atmosphere" => AtmosphereModifiers,
            "debris" => Debris,
            "lightingmodifiers" or "lighting" => LightingModifiers,
            "smellmodifiers" or "smell" => SmellModifiers,
            _ => Array.Empty<string>()
        };

        if (pool.Count == 0)
            return string.Empty;

        return pool[random.Next(pool.Count)];
    }

    /// <summary>
    /// Checks if this age has debris descriptors.
    /// </summary>
    public bool HasDebris => Debris?.Count > 0;

    /// <summary>
    /// Checks if all required descriptor arrays have at least one entry.
    /// </summary>
    public bool IsValid =>
        SurfaceConditions?.Count > 0 &&
        AtmosphereModifiers?.Count > 0 &&
        LightingModifiers?.Count > 0 &&
        SmellModifiers?.Count > 0;
}
```

### 5.4 Descriptor Categories

| Category | Purpose | Example Values (Collapsed) |
|----------|---------|---------------------------|
| `SurfaceConditions` | Modifies physical structure adjectives | "crumbling", "fractured", "unstable" |
| `AtmosphereModifiers` | Overall room feeling | "dangerous", "threatening collapse" |
| `Debris` | Physical clutter in room | "fallen stones", "rubble piles" |
| `LightingModifiers` | Age effect on lighting | "dust-filtered light", "shafts through gaps" |
| `SmellModifiers` | Age-specific scents | "crushed stone", "dust and decay" |

---

## 6. MaterialPalette Value Object

### 6.1 Purpose

The `MaterialPalette` value object defines consistent construction materials for a dungeon region based on biome. This ensures visual and descriptive coherence across rooms within the same biome.

### 6.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/MaterialPalette.cs`

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines consistent materials for a dungeon region based on biome.
/// </summary>
/// <remarks>
/// Material palettes ensure descriptive and visual consistency across rooms
/// within the same biome. Each biome has a characteristic set of materials
/// that architectural styles may modify.
/// </remarks>
public readonly record struct MaterialPalette
{
    /// <summary>
    /// Gets the primary wall material.
    /// </summary>
    /// <remarks>
    /// The dominant construction material for walls in this biome.
    /// </remarks>
    public string PrimaryMaterial { get; init; }

    /// <summary>
    /// Gets the secondary/accent material.
    /// </summary>
    /// <remarks>
    /// Used for decorative elements, borders, and contrasting features.
    /// </remarks>
    public string SecondaryMaterial { get; init; }

    /// <summary>
    /// Gets the floor material.
    /// </summary>
    /// <remarks>
    /// The typical flooring material for this biome.
    /// </remarks>
    public string FloorMaterial { get; init; }

    /// <summary>
    /// Gets the decorative metal accent.
    /// </summary>
    /// <remarks>
    /// Metal used for fixtures, decorations, and hardware.
    /// </remarks>
    public string MetalAccent { get; init; }

    /// <summary>
    /// Gets the color palette for this biome.
    /// </summary>
    /// <remarks>
    /// Primary colors associated with materials and decorations.
    /// </remarks>
    public IReadOnlyList<string> Colors { get; init; }

    /// <summary>
    /// Creates a default material palette.
    /// </summary>
    public static MaterialPalette Default => new()
    {
        PrimaryMaterial = "gray stone",
        SecondaryMaterial = "granite",
        FloorMaterial = "stone tiles",
        MetalAccent = "iron",
        Colors = new[] { "gray", "brown", "dark" }
    };

    /// <summary>
    /// Creates a material palette for the specified biome.
    /// </summary>
    /// <param name="biomeId">The biome identifier.</param>
    /// <returns>A material palette appropriate for the biome.</returns>
    public static MaterialPalette ForBiome(string biomeId) => biomeId?.ToLowerInvariant() switch
    {
        "catacombs" => new MaterialPalette
        {
            PrimaryMaterial = "limestone",
            SecondaryMaterial = "marble",
            FloorMaterial = "worn flagstone",
            MetalAccent = "tarnished bronze",
            Colors = new[] { "bone white", "gray", "faded gold" }
        },
        "volcanic-caverns" or "volcanic" => new MaterialPalette
        {
            PrimaryMaterial = "obsidian",
            SecondaryMaterial = "basalt",
            FloorMaterial = "cooled lava",
            MetalAccent = "blackened iron",
            Colors = new[] { "black", "red", "orange glow" }
        },
        "frozen-depths" or "frozen" => new MaterialPalette
        {
            PrimaryMaterial = "blue ice",
            SecondaryMaterial = "frosted stone",
            FloorMaterial = "frozen ground",
            MetalAccent = "silver",
            Colors = new[] { "ice blue", "white", "pale silver" }
        },
        "ancient-ruins" => new MaterialPalette
        {
            PrimaryMaterial = "weathered sandstone",
            SecondaryMaterial = "cracked marble",
            FloorMaterial = "broken mosaic",
            MetalAccent = "corroded copper",
            Colors = new[] { "sand", "faded ochre", "dusty brown" }
        },
        "mines" => new MaterialPalette
        {
            PrimaryMaterial = "rough-hewn rock",
            SecondaryMaterial = "ore-veined stone",
            FloorMaterial = "packed earth",
            MetalAccent = "rusted iron",
            Colors = new[] { "dark brown", "rust", "coal black" }
        },
        "fungal-grotto" or "fungal" => new MaterialPalette
        {
            PrimaryMaterial = "spongy growth",
            SecondaryMaterial = "petrified wood",
            FloorMaterial = "soft mycelium",
            MetalAccent = "corroded brass",
            Colors = new[] { "purple", "sickly green", "pale gray" }
        },
        "flooded-depths" or "flooded" => new MaterialPalette
        {
            PrimaryMaterial = "water-stained stone",
            SecondaryMaterial = "barnacled rock",
            FloorMaterial = "slippery algae",
            MetalAccent = "sea-green copper",
            Colors = new[] { "deep blue", "green", "murky brown" }
        },
        _ => Default
    };

    /// <summary>
    /// Modifies this palette for a specific architectural style.
    /// </summary>
    /// <param name="styleId">The style identifier.</param>
    /// <returns>A modified palette appropriate for the style.</returns>
    public MaterialPalette WithStyle(string styleId) => styleId?.ToLowerInvariant() switch
    {
        "ancient-temples" => this with
        {
            SecondaryMaterial = "polished " + SecondaryMaterial,
            MetalAccent = "gilded " + MetalAccent
        },
        "carved-halls" => this with
        {
            FloorMaterial = "fitted " + FloorMaterial
        },
        "natural-caves" => this with
        {
            PrimaryMaterial = "natural " + PrimaryMaterial,
            FloorMaterial = "uneven " + FloorMaterial
        },
        "ruined-structures" => this with
        {
            PrimaryMaterial = "crumbling " + PrimaryMaterial,
            FloorMaterial = "broken " + FloorMaterial
        },
        _ => this
    };

    /// <summary>
    /// Gets a formatted description of the primary material.
    /// </summary>
    /// <returns>A descriptive string for room text.</returns>
    public string GetMaterialDescription()
    {
        return $"{PrimaryMaterial} with accents of {SecondaryMaterial}";
    }

    /// <summary>
    /// Gets the dominant color from the palette.
    /// </summary>
    public string DominantColor => Colors?.FirstOrDefault() ?? "gray";
}
```

### 6.4 Biome Material Palettes

| Biome | Primary | Secondary | Floor | Metal | Colors |
|-------|---------|-----------|-------|-------|--------|
| Catacombs | limestone | marble | worn flagstone | tarnished bronze | bone white, gray, faded gold |
| Volcanic | obsidian | basalt | cooled lava | blackened iron | black, red, orange glow |
| Frozen | blue ice | frosted stone | frozen ground | silver | ice blue, white, pale silver |
| Ancient Ruins | weathered sandstone | cracked marble | broken mosaic | corroded copper | sand, faded ochre |
| Mines | rough-hewn rock | ore-veined stone | packed earth | rusted iron | dark brown, rust |
| Fungal Grotto | spongy growth | petrified wood | soft mycelium | corroded brass | purple, sickly green |
| Flooded | water-stained stone | barnacled rock | slippery algae | sea-green copper | deep blue, green |

---

## 7. CoherenceService

### 7.1 Purpose

The `CoherenceService` ensures structural coherence in generated dungeons by providing material palettes, corridor requirements, support structure needs, age-modified descriptions, and coherence validation.

### 7.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/ICoherenceService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/CoherenceService.cs`

### 7.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for ensuring structural coherence in generated dungeons.
/// </summary>
public interface ICoherenceService
{
    /// <summary>
    /// Gets the material palette for a biome and style combination.
    /// </summary>
    /// <param name="biomeId">The biome identifier.</param>
    /// <param name="styleId">The architectural style identifier.</param>
    /// <returns>A material palette appropriate for the combination.</returns>
    MaterialPalette GetMaterialPalette(string biomeId, string styleId);

    /// <summary>
    /// Determines if a corridor is required between two rooms.
    /// </summary>
    /// <param name="fromRoom">The source room.</param>
    /// <param name="toRoom">The destination room.</param>
    /// <param name="style">The architectural style of the region.</param>
    /// <returns>True if a corridor is required.</returns>
    bool RequiresCorridor(Room fromRoom, Room toRoom, ArchitecturalStyle style);

    /// <summary>
    /// Gets required structural support features for a room.
    /// </summary>
    /// <param name="room">The room to check.</param>
    /// <param name="style">The architectural style.</param>
    /// <returns>List of required support feature IDs.</returns>
    IReadOnlyList<string> GetRequiredSupports(Room room, ArchitecturalStyle style);

    /// <summary>
    /// Gets an age-modified description overlaying base text.
    /// </summary>
    /// <param name="room">The room to describe.</param>
    /// <param name="age">The dungeon age.</param>
    /// <param name="baseDescription">The base description from style/biome.</param>
    /// <returns>An enhanced description with age overlays.</returns>
    string GetAgeModifiedDescription(Room room, DungeonAge age, string baseDescription);

    /// <summary>
    /// Gets the hazard probability modifier for a dungeon age.
    /// </summary>
    /// <param name="age">The dungeon age.</param>
    /// <returns>A multiplier for hazard probabilities (e.g., 1.5 = 150%).</returns>
    float GetAgeHazardModifier(DungeonAge age);

    /// <summary>
    /// Gets the trap functionality percentage for a dungeon age.
    /// </summary>
    /// <param name="age">The dungeon age.</param>
    /// <returns>Probability that traps are functional (0.0 to 1.0).</returns>
    float GetTrapFunctionality(DungeonAge age);

    /// <summary>
    /// Gets the loot quality modifier for a dungeon age.
    /// </summary>
    /// <param name="age">The dungeon age.</param>
    /// <returns>A multiplier for loot quality (e.g., 0.8 = 80%).</returns>
    float GetLootQualityModifier(DungeonAge age);

    /// <summary>
    /// Gets the encounter rate modifier for a dungeon age.
    /// </summary>
    /// <param name="age">The dungeon age.</param>
    /// <returns>A multiplier for encounter rates.</returns>
    float GetEncounterModifier(DungeonAge age);

    /// <summary>
    /// Validates structural coherence of a dungeon region.
    /// </summary>
    /// <param name="rooms">The rooms in the region.</param>
    /// <param name="expectedStyle">The expected dominant style.</param>
    /// <returns>Validation result with any issues found.</returns>
    CoherenceValidationResult ValidateCoherence(IEnumerable<Room> rooms, string expectedStyle);

    /// <summary>
    /// Selects an appropriate age for a room based on context.
    /// </summary>
    /// <param name="position">The room position.</param>
    /// <param name="biomeId">The biome identifier.</param>
    /// <param name="styleId">The style identifier.</param>
    /// <returns>A contextually appropriate dungeon age.</returns>
    DungeonAge SelectAgeForContext(Position3D position, string biomeId, string styleId);
}
```

### 7.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for ensuring structural coherence in generated dungeons.
/// </summary>
public class CoherenceService : ICoherenceService
{
    private readonly IConfigurationProvider _config;
    private readonly IArchitecturalStyleService _styleService;
    private readonly IBiomeService _biomeService;
    private readonly SeededRandomService _random;
    private readonly ILogger<CoherenceService> _logger;

    /// <summary>
    /// Initializes a new instance of the CoherenceService.
    /// </summary>
    public CoherenceService(
        IConfigurationProvider config,
        IArchitecturalStyleService styleService,
        IBiomeService biomeService,
        SeededRandomService random,
        ILogger<CoherenceService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _styleService = styleService ?? throw new ArgumentNullException(nameof(styleService));
        _biomeService = biomeService ?? throw new ArgumentNullException(nameof(biomeService));
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public MaterialPalette GetMaterialPalette(string biomeId, string styleId)
    {
        var basePalette = MaterialPalette.ForBiome(biomeId);
        var style = _styleService.GetStyle(styleId);

        if (style == null)
        {
            _logger.LogDebug("Style {StyleId} not found, using base palette for biome {BiomeId}", styleId, biomeId);
            return basePalette;
        }

        // Apply style modifications
        var styledPalette = basePalette.WithStyle(styleId);

        _logger.LogDebug(
            "Created material palette for biome {BiomeId} with style {StyleId}: {Primary}",
            biomeId,
            styleId,
            styledPalette.PrimaryMaterial);

        return styledPalette;
    }

    /// <inheritdoc />
    public bool RequiresCorridor(Room fromRoom, Room toRoom, ArchitecturalStyle style)
    {
        // Natural styles don't use formal corridors
        if (!style.HasCorridors)
        {
            _logger.LogDebug("Style {StyleId} does not use corridors", style.Id);
            return false;
        }

        // Same room type adjacent rooms may not need corridor
        if (fromRoom.RoomType == toRoom.RoomType &&
            fromRoom.RoomType == RoomType.Standard)
        {
            return false;
        }

        // Boss rooms always need corridor approach
        if (toRoom.RoomType == RoomType.Boss)
        {
            _logger.LogDebug("Boss room requires corridor approach");
            return true;
        }

        // Constructed styles typically need corridors between distinct spaces
        if (style.HasTag("constructed"))
        {
            return true;
        }

        return style.HasCorridors;
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetRequiredSupports(Room room, ArchitecturalStyle style)
    {
        var supports = new List<string>();

        // Only constructed styles need structural supports
        if (!style.HasTag("constructed"))
        {
            return supports;
        }

        // Irregular shapes don't need artificial supports (organic formation)
        if (room.Shape == RoomShape.Irregular)
        {
            return supports;
        }

        // Check room size threshold for requiring supports
        var sizeThreshold = (style.Rules.RoomSizeRange.Max + style.Rules.RoomSizeRange.Min) / 2;

        // Large rooms need pillars or supports
        // Note: Actual size calculation would depend on room dimensions
        // This is a placeholder check based on style rules
        if (style.CommonFeatures.Contains("pillar"))
        {
            supports.Add("pillar");
            _logger.LogDebug("Room in style {StyleId} requires pillar supports", style.Id);
        }

        // Temples may need additional supports for grand spaces
        if (style.Id == "ancient-temples" && style.CommonFeatures.Contains("statue"))
        {
            supports.Add("statue");
        }

        return supports;
    }

    /// <inheritdoc />
    public string GetAgeModifiedDescription(Room room, DungeonAge age, string baseDescription)
    {
        var ageDescriptors = AgeDescriptors.ForAge(age);

        // Select age-specific modifiers
        var condition = ageDescriptors.SurfaceConditions.FirstOrDefault() ?? "";
        var atmosphere = ageDescriptors.AtmosphereModifiers.FirstOrDefault() ?? "";
        var lighting = ageDescriptors.LightingModifiers.FirstOrDefault() ?? "";
        var smell = ageDescriptors.SmellModifiers.FirstOrDefault() ?? "";

        var modified = new StringBuilder(baseDescription);

        // Add condition overlay
        if (!string.IsNullOrEmpty(condition))
        {
            modified.Append($" The {condition} surfaces speak of ");
        }

        // Add atmosphere
        if (!string.IsNullOrEmpty(atmosphere))
        {
            modified.Append($"a {atmosphere} place. ");
        }

        // Add debris if present
        if (ageDescriptors.HasDebris)
        {
            var debris = ageDescriptors.Debris.FirstOrDefault();
            if (!string.IsNullOrEmpty(debris))
            {
                modified.Append($"{CapitalizeFirst(debris)} litter the floor. ");
            }
        }

        // Add lighting modification
        if (!string.IsNullOrEmpty(lighting))
        {
            modified.Append($"{CapitalizeFirst(lighting)} fills the space. ");
        }

        // Add smell
        if (!string.IsNullOrEmpty(smell))
        {
            modified.Append($"The scent of {smell} hangs in the air.");
        }

        return modified.ToString().Trim();
    }

    /// <inheritdoc />
    public float GetAgeHazardModifier(DungeonAge age) => age switch
    {
        DungeonAge.Fresh => 0.5f,      // Fewer environmental hazards
        DungeonAge.Ancient => 1.0f,     // Baseline hazards
        DungeonAge.Collapsed => 1.5f,   // More structural hazards
        DungeonAge.Reclaimed => 1.2f,   // Nature-based hazards
        _ => 1.0f
    };

    /// <inheritdoc />
    public float GetTrapFunctionality(DungeonAge age) => age switch
    {
        DungeonAge.Fresh => 1.0f,      // Traps fully functional
        DungeonAge.Ancient => 0.7f,     // Some traps degraded
        DungeonAge.Collapsed => 0.3f,   // Most traps broken
        DungeonAge.Reclaimed => 0.1f,   // Almost all traps non-functional
        _ => 0.7f
    };

    /// <inheritdoc />
    public float GetLootQualityModifier(DungeonAge age) => age switch
    {
        DungeonAge.Fresh => 0.9f,      // Slight reduction (recently looted?)
        DungeonAge.Ancient => 1.0f,     // Baseline
        DungeonAge.Collapsed => 0.8f,   // Some items damaged
        DungeonAge.Reclaimed => 0.7f,   // Nature degradation
        _ => 1.0f
    };

    /// <inheritdoc />
    public float GetEncounterModifier(DungeonAge age) => age switch
    {
        DungeonAge.Fresh => 1.2f,      // Active occupation
        DungeonAge.Ancient => 0.8f,     // Fewer inhabitants
        DungeonAge.Collapsed => 0.6f,   // Difficult to inhabit
        DungeonAge.Reclaimed => 1.0f,   // Wildlife presence
        _ => 1.0f
    };

    /// <inheritdoc />
    public CoherenceValidationResult ValidateCoherence(IEnumerable<Room> rooms, string expectedStyle)
    {
        var roomList = rooms.ToList();
        var issues = new List<string>();

        if (!roomList.Any())
        {
            return new CoherenceValidationResult
            {
                IsValid = true,
                Issues = issues
            };
        }

        // Check 1: Style consistency
        var styleViolations = roomList
            .Where(r => !string.IsNullOrEmpty(r.ArchitecturalStyleId))
            .Count(r => !r.ArchitecturalStyleId.Equals(expectedStyle, StringComparison.OrdinalIgnoreCase));

        var styleViolationPercent = (float)styleViolations / roomList.Count;
        if (styleViolationPercent > 0.2f)
        {
            issues.Add($"Style inconsistencies: {styleViolations}/{roomList.Count} rooms ({styleViolationPercent:P0}) differ from expected style '{expectedStyle}'");
            _logger.LogWarning(
                "Coherence issue: {ViolationCount} rooms have inconsistent styles in region expecting {ExpectedStyle}",
                styleViolations,
                expectedStyle);
        }

        // Check 2: Material consistency (biome count)
        var biomes = roomList
            .Where(r => !string.IsNullOrEmpty(r.BiomeId))
            .Select(r => r.BiomeId)
            .Distinct()
            .ToList();

        if (biomes.Count > 2)
        {
            issues.Add($"Too many biome transitions: {biomes.Count} distinct biomes without proper transition zones");
            _logger.LogWarning(
                "Coherence issue: {BiomeCount} biomes in single region without transitions",
                biomes.Count);
        }

        // Check 3: Age consistency
        var ages = roomList
            .Select(r => r.Age)
            .Distinct()
            .ToList();

        if (ages.Count > 2)
        {
            // More than 2 ages in a small region is unusual
            _logger.LogDebug(
                "Multiple ages ({AgeCount}) in region - may be intentional transition",
                ages.Count);
        }

        // Check 4: Structural support (for constructed styles)
        var style = _styleService.GetStyle(expectedStyle);
        if (style != null && style.HasTag("constructed"))
        {
            foreach (var room in roomList.Where(r => r.Shape != RoomShape.Irregular))
            {
                var requiredSupports = GetRequiredSupports(room, style);
                if (requiredSupports.Any())
                {
                    var hasSupports = room.StructuralFeatures
                        .Any(f => requiredSupports.Contains(f.FeatureId));

                    if (!hasSupports)
                    {
                        issues.Add($"Room at {room.Position} in constructed style lacks required supports");
                    }
                }
            }
        }

        return new CoherenceValidationResult
        {
            IsValid = !issues.Any(),
            Issues = issues
        };
    }

    /// <inheritdoc />
    public DungeonAge SelectAgeForContext(Position3D position, string biomeId, string styleId)
    {
        // Calculate weights based on context
        var weights = new Dictionary<DungeonAge, int>
        {
            { DungeonAge.Fresh, 100 },
            { DungeonAge.Ancient, 100 },
            { DungeonAge.Collapsed, 80 },
            { DungeonAge.Reclaimed, 60 }
        };

        // Depth affects age distribution
        var depth = position.Z;

        // Shallow depths favor Fresh
        if (depth <= 2)
        {
            weights[DungeonAge.Fresh] += 50;
            weights[DungeonAge.Collapsed] -= 30;
        }
        // Deep areas favor Ancient and Collapsed
        else if (depth >= 5)
        {
            weights[DungeonAge.Fresh] -= 60;
            weights[DungeonAge.Ancient] += 30;
            weights[DungeonAge.Collapsed] += 40;
        }

        // Style affects age tendencies
        var style = _styleService.GetStyle(styleId);
        if (style != null)
        {
            if (style.Id == "ruined-structures")
            {
                weights[DungeonAge.Collapsed] += 100;
                weights[DungeonAge.Fresh] = 0;
            }
            else if (style.Id == "ancient-temples")
            {
                weights[DungeonAge.Ancient] += 50;
                weights[DungeonAge.Fresh] -= 30;
            }
        }

        // Certain biomes favor reclaimed
        if (biomeId?.Contains("forest") == true ||
            biomeId?.Contains("fungal") == true ||
            biomeId?.Contains("overgrown") == true)
        {
            weights[DungeonAge.Reclaimed] += 80;
        }

        // Ensure no negative weights
        foreach (var key in weights.Keys.ToList())
        {
            if (weights[key] < 0)
                weights[key] = 0;
        }

        // Weighted selection
        var weightedAges = weights
            .Where(kvp => kvp.Value > 0)
            .Select(kvp => (Age: kvp.Key, Weight: kvp.Value));

        var selected = _random.SelectWeighted(position, weightedAges, "age_select");

        _logger.LogDebug(
            "Selected age {Age} for position ({X}, {Y}, {Z}) in biome {BiomeId} with style {StyleId}",
            selected,
            position.X,
            position.Y,
            position.Z,
            biomeId,
            styleId);

        return selected;
    }

    private static string CapitalizeFirst(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;
        return char.ToUpper(text[0]) + text.Substring(1);
    }
}
```

### 7.5 CoherenceValidationResult

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of structural coherence validation for a dungeon region.
/// </summary>
/// <remarks>
/// Issues are informational warnings, not blocking errors.
/// The dungeon generator may choose to address issues or log them for review.
/// </remarks>
public readonly record struct CoherenceValidationResult
{
    /// <summary>
    /// Gets whether the region passes coherence validation.
    /// </summary>
    public bool IsValid { get; init; }

    /// <summary>
    /// Gets the list of coherence issues found.
    /// </summary>
    public IReadOnlyList<string> Issues { get; init; }

    /// <summary>
    /// Gets whether there are any issues.
    /// </summary>
    public bool HasIssues => Issues?.Count > 0;

    /// <summary>
    /// Creates a valid result with no issues.
    /// </summary>
    public static CoherenceValidationResult Valid => new()
    {
        IsValid = true,
        Issues = Array.Empty<string>()
    };

    /// <summary>
    /// Creates an invalid result with the specified issues.
    /// </summary>
    /// <param name="issues">The coherence issues found.</param>
    /// <returns>An invalid validation result.</returns>
    public static CoherenceValidationResult Invalid(params string[] issues) => new()
    {
        IsValid = false,
        Issues = issues
    };

    /// <summary>
    /// Gets a formatted summary of validation results.
    /// </summary>
    public string GetSummary()
    {
        if (IsValid)
            return "Coherence validation passed.";

        return $"Coherence validation failed with {Issues.Count} issue(s):\n" +
               string.Join("\n", Issues.Select(i => $"  - {i}"));
    }
}
```

---

## 8. Room Age Integration

### 8.1 Purpose

Extend the `Room` entity to store the dungeon age for each room, enabling age-aware features throughout the game.

### 8.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modification)

### 8.3 Changes

```csharp
// Add to Room.cs - after existing Shape property

/// <summary>
/// Gets the age/condition of this room's structures.
/// </summary>
/// <remarks>
/// Age affects descriptors, hazard probabilities, trap functionality,
/// and loot quality. Set during room generation based on context.
/// </remarks>
public DungeonAge Age { get; private set; } = DungeonAge.Ancient;

/// <summary>
/// Sets the dungeon age for this room.
/// </summary>
/// <param name="age">The age to assign.</param>
public void SetAge(DungeonAge age)
{
    Age = age;
}

/// <summary>
/// Gets whether this room has a specific age.
/// </summary>
/// <param name="age">The age to check.</param>
/// <returns>True if the room has this age.</returns>
public bool HasAge(DungeonAge age)
{
    return Age == age;
}

/// <summary>
/// Gets whether this room's structures are in dangerous condition.
/// </summary>
/// <remarks>
/// Collapsed and Fresh (occupied) rooms may have different danger types.
/// </remarks>
public bool IsDangerousCondition => Age == DungeonAge.Collapsed;

/// <summary>
/// Gets whether this room shows signs of nature reclamation.
/// </summary>
public bool IsNatureReclaimed => Age == DungeonAge.Reclaimed;
```

### 8.4 Data Model Change

```
MODIFY: Room
├── ADD: Age: DungeonAge (default: Ancient)
├── ADD: SetAge(age): void
├── ADD: HasAge(age): bool
├── ADD: IsDangerousCondition: bool (computed)
└── ADD: IsNatureReclaimed: bool (computed)
```

---

## 9. Age-Based Hazard Modifiers

### 9.1 Purpose

Integrate dungeon age with the existing hazard system to modify hazard probabilities, trap functionality, and environmental danger levels.

### 9.2 HazardService Integration

**File:** `src/Core/RuneAndRust.Application/Services/HazardService.cs` (modification)

```csharp
// Add to HazardService

private readonly ICoherenceService _coherenceService;

/// <summary>
/// Gets the effective hazard probability for a room, modified by age.
/// </summary>
/// <param name="baseHazard">The base hazard definition.</param>
/// <param name="room">The room to check.</param>
/// <returns>The modified hazard probability.</returns>
public float GetEffectiveHazardProbability(BiomeHazard baseHazard, Room room)
{
    var ageModifier = _coherenceService.GetAgeHazardModifier(room.Age);
    var effectiveProbability = baseHazard.BaseProbability * ageModifier;

    _logger.LogDebug(
        "Hazard {HazardId} probability: {Base:P0} × {AgeMod} (age: {Age}) = {Effective:P0}",
        baseHazard.Id,
        baseHazard.BaseProbability,
        ageModifier,
        room.Age,
        effectiveProbability);

    return Math.Clamp(effectiveProbability, 0f, 1f);
}

/// <summary>
/// Determines if a trap in the room is functional based on age.
/// </summary>
/// <param name="room">The room containing the trap.</param>
/// <param name="position">Position for seeded randomization.</param>
/// <returns>True if the trap is functional.</returns>
public bool IsTrapFunctional(Room room, Position3D position)
{
    var functionality = _coherenceService.GetTrapFunctionality(room.Age);
    var roll = _random.NextFloatForPosition(position, "trap_function");

    var isFunctional = roll < functionality;

    _logger.LogDebug(
        "Trap functionality check: age {Age} = {Functionality:P0}, roll {Roll:F2} = {Result}",
        room.Age,
        functionality,
        roll,
        isFunctional ? "FUNCTIONAL" : "BROKEN");

    return isFunctional;
}

/// <summary>
/// Gets age-appropriate hazards for a room.
/// </summary>
/// <param name="room">The room to get hazards for.</param>
/// <returns>Hazards filtered and modified by age.</returns>
public IReadOnlyList<ActiveHazard> GetAgeAppropriateHazards(Room room)
{
    var biomeHazards = GetHazardsForBiome(room.BiomeId);
    var ageModifier = _coherenceService.GetAgeHazardModifier(room.Age);

    var activeHazards = new List<ActiveHazard>();

    foreach (var hazard in biomeHazards)
    {
        // Skip trap hazards if traps are non-functional
        if (hazard.IsTrap && !IsTrapFunctional(room, room.Position))
        {
            continue;
        }

        var effectiveProbability = hazard.BaseProbability * ageModifier;
        var roll = _random.NextFloatForPosition(room.Position, $"hazard_{hazard.Id}");

        if (roll < effectiveProbability)
        {
            activeHazards.Add(new ActiveHazard
            {
                HazardId = hazard.Id,
                Severity = CalculateSeverity(hazard, room.Age),
                Description = GetAgeModifiedHazardDescription(hazard, room.Age)
            });
        }
    }

    // Add age-specific hazards
    switch (room.Age)
    {
        case DungeonAge.Collapsed:
            // Chance of falling debris
            if (_random.NextFloatForPosition(room.Position, "collapse_hazard") < 0.3f)
            {
                activeHazards.Add(new ActiveHazard
                {
                    HazardId = "falling-debris",
                    Severity = HazardSeverity.Moderate,
                    Description = "Loose stones threaten to fall from the unstable ceiling."
                });
            }
            break;

        case DungeonAge.Reclaimed:
            // Chance of nature hazards
            if (_random.NextFloatForPosition(room.Position, "nature_hazard") < 0.25f)
            {
                activeHazards.Add(new ActiveHazard
                {
                    HazardId = "tangling-roots",
                    Severity = HazardSeverity.Minor,
                    Description = "Thick roots snake across the floor, threatening to trip the unwary."
                });
            }
            break;
    }

    return activeHazards;
}

private string GetAgeModifiedHazardDescription(BiomeHazard hazard, DungeonAge age)
{
    return age switch
    {
        DungeonAge.Fresh => hazard.Description,
        DungeonAge.Ancient => $"An ancient {hazard.Description.ToLower()}",
        DungeonAge.Collapsed => $"Among the rubble, {hazard.Description.ToLower()}",
        DungeonAge.Reclaimed => $"Partially overgrown, {hazard.Description.ToLower()}",
        _ => hazard.Description
    };
}
```

### 9.3 Age Modifier Summary

| Age | Hazard Mod | Trap Function | Special Hazards |
|-----|------------|---------------|-----------------|
| Fresh | 0.5x | 100% | None |
| Ancient | 1.0x | 70% | None |
| Collapsed | 1.5x | 30% | Falling debris (30% chance) |
| Reclaimed | 1.2x | 10% | Tangling roots (25% chance) |

---

## 10. Corridor Generation Rules

### 10.1 Purpose

Define rules for corridor generation based on architectural style and room context. Corridors connect rooms in constructed styles but are absent in natural formations.

### 10.2 Corridor Configuration

**File:** `config/coherence-rules.json` (partial)

```json
{
  "corridorRules": {
    "default": {
      "required": true,
      "minWidth": 1,
      "maxWidth": 2,
      "allowDecorations": true
    },
    "byStyle": {
      "natural-caves": {
        "required": false,
        "note": "Direct room connections, no formal corridors"
      },
      "carved-halls": {
        "required": true,
        "minWidth": 1,
        "maxWidth": 1,
        "allowDecorations": true,
        "decorationFeatures": ["torch-sconce", "alcove"]
      },
      "ruined-structures": {
        "required": false,
        "note": "Corridors collapsed, may have rubble-blocked paths"
      },
      "ancient-temples": {
        "required": true,
        "minWidth": 2,
        "maxWidth": 3,
        "allowDecorations": true,
        "decorationFeatures": ["pillar", "statue", "offering-bowl"]
      }
    },
    "roomTypeOverrides": {
      "Boss": {
        "required": true,
        "note": "Boss rooms always need approach corridor"
      },
      "Safe": {
        "required": true,
        "note": "Safe havens need defined entrance"
      }
    }
  }
}
```

### 10.3 Corridor Service Methods

```csharp
// In CoherenceService - corridor-related methods

/// <summary>
/// Gets the corridor width for a style.
/// </summary>
/// <param name="style">The architectural style.</param>
/// <returns>The corridor width in tiles (0 = no corridors).</returns>
public int GetCorridorWidth(ArchitecturalStyle style)
{
    return style.Rules.CorridorWidth;
}

/// <summary>
/// Gets corridor decoration features for a style.
/// </summary>
/// <param name="styleId">The style identifier.</param>
/// <returns>List of feature IDs suitable for corridor decoration.</returns>
public IReadOnlyList<string> GetCorridorDecorations(string styleId)
{
    var rules = _config.GetCoherenceRules();

    if (rules.CorridorRules.ByStyle.TryGetValue(styleId, out var styleRules))
    {
        return styleRules.DecorationFeatures ?? Array.Empty<string>();
    }

    return Array.Empty<string>();
}

/// <summary>
/// Determines corridor material based on biome and style.
/// </summary>
/// <param name="biomeId">The biome identifier.</param>
/// <param name="styleId">The style identifier.</param>
/// <returns>A description of corridor materials.</returns>
public string GetCorridorMaterialDescription(string biomeId, string styleId)
{
    var palette = GetMaterialPalette(biomeId, styleId);
    var style = _styleService.GetStyle(styleId);

    if (style == null || !style.HasCorridors)
    {
        return string.Empty;
    }

    return style.Id switch
    {
        "carved-halls" => $"The corridor is lined with {palette.PrimaryMaterial}, " +
                         $"its {palette.FloorMaterial} floor worn smooth by countless footsteps.",
        "ancient-temples" => $"A ceremonial passage of {palette.SecondaryMaterial} " +
                            $"stretches before you, {palette.MetalAccent} fixtures lining the walls.",
        _ => $"A passage of {palette.PrimaryMaterial} connects the chambers."
    };
}
```

---

## 11. Data Model Changes

### 11.1 Summary

```
NEW: DungeonAge (Enum)
├── Fresh
├── Ancient
├── Collapsed
└── Reclaimed

NEW: AgeDescriptors (Value Object)
├── Age: DungeonAge
├── SurfaceConditions: IReadOnlyList<string>
├── AtmosphereModifiers: IReadOnlyList<string>
├── Debris: IReadOnlyList<string>
├── LightingModifiers: IReadOnlyList<string>
├── SmellModifiers: IReadOnlyList<string>
├── ForAge(age): AgeDescriptors (static)
├── GetRandomDescriptor(category, random): string
├── HasDebris: bool (computed)
└── IsValid: bool (computed)

NEW: MaterialPalette (Value Object)
├── PrimaryMaterial: string
├── SecondaryMaterial: string
├── FloorMaterial: string
├── MetalAccent: string
├── Colors: IReadOnlyList<string>
├── Default: MaterialPalette (static)
├── ForBiome(biomeId): MaterialPalette (static)
├── WithStyle(styleId): MaterialPalette
├── GetMaterialDescription(): string
└── DominantColor: string (computed)

NEW: CoherenceValidationResult (Value Object)
├── IsValid: bool
├── Issues: IReadOnlyList<string>
├── HasIssues: bool (computed)
├── Valid: CoherenceValidationResult (static)
├── Invalid(issues): CoherenceValidationResult (static)
└── GetSummary(): string

MODIFY: Room
├── ADD: Age: DungeonAge (default: Ancient)
├── ADD: SetAge(age): void
├── ADD: HasAge(age): bool
├── ADD: IsDangerousCondition: bool (computed)
└── ADD: IsNatureReclaimed: bool (computed)

MODIFY: IConfigurationProvider
├── ADD: GetDungeonAges(): IReadOnlyList<DungeonAgeDefinition>
└── ADD: GetCoherenceRules(): CoherenceRulesDefinition

NEW: ICoherenceService (Interface)
├── GetMaterialPalette(biomeId, styleId): MaterialPalette
├── RequiresCorridor(fromRoom, toRoom, style): bool
├── GetRequiredSupports(room, style): IReadOnlyList<string>
├── GetAgeModifiedDescription(room, age, baseDescription): string
├── GetAgeHazardModifier(age): float
├── GetTrapFunctionality(age): float
├── GetLootQualityModifier(age): float
├── GetEncounterModifier(age): float
├── ValidateCoherence(rooms, expectedStyle): CoherenceValidationResult
└── SelectAgeForContext(position, biomeId, styleId): DungeonAge

NEW: CoherenceService (Implementation of ICoherenceService)
```

---

## 12. Configuration File Schemas

### 12.1 Dungeon Ages Configuration

**File:** `config/dungeon-ages.json`

```json
{
  "$schema": "schemas/dungeon-ages-schema.json",
  "ages": [
    {
      "id": "fresh",
      "name": "Fresh",
      "description": "Recently constructed or actively maintained structures.",
      "hazardModifier": 0.5,
      "trapFunctionality": 1.0,
      "lootQualityModifier": 0.9,
      "encounterModifier": 1.2,
      "descriptors": {
        "surfaceConditions": ["clean", "well-maintained", "recently swept", "polished"],
        "atmosphereModifiers": ["lived-in", "active", "occupied", "purposeful"],
        "debris": [],
        "lightingModifiers": ["well-lit", "maintained torches", "fresh candles", "steady lamplight"],
        "smellModifiers": ["recent habitation", "burning oil", "cooked food", "wood smoke"]
      },
      "depthWeightModifiers": {
        "shallow": 50,
        "deep": -60
      }
    },
    {
      "id": "ancient",
      "name": "Ancient",
      "description": "Long abandoned but structurally sound ruins.",
      "hazardModifier": 1.0,
      "trapFunctionality": 0.7,
      "lootQualityModifier": 1.0,
      "encounterModifier": 0.8,
      "descriptors": {
        "surfaceConditions": ["dust-covered", "faded", "worn smooth", "time-weathered"],
        "atmosphereModifiers": ["long-abandoned", "forgotten", "silent for ages", "timeless"],
        "debris": ["scattered dust", "cobwebs", "faded remnants", "ancient debris"],
        "lightingModifiers": ["dim", "shadows deepened by time", "ancient darkness", "fading light"],
        "smellModifiers": ["ancient dust", "stale air", "the scent of ages", "musty stillness"]
      },
      "depthWeightModifiers": {
        "shallow": 0,
        "deep": 30
      }
    },
    {
      "id": "collapsed",
      "name": "Collapsed",
      "description": "Partially destroyed with structural damage.",
      "hazardModifier": 1.5,
      "trapFunctionality": 0.3,
      "lootQualityModifier": 0.8,
      "encounterModifier": 0.6,
      "descriptors": {
        "surfaceConditions": ["crumbling", "fractured", "unstable", "ruined", "broken"],
        "atmosphereModifiers": ["dangerous", "precarious", "threatening collapse", "structurally compromised"],
        "debris": ["fallen stones", "rubble piles", "debris", "broken supports", "scattered masonry"],
        "lightingModifiers": ["shafts through gaps", "dust-filtered light", "unstable shadows", "flickering through cracks"],
        "smellModifiers": ["dust and decay", "crushed stone", "exposed earth", "fresh rubble"]
      },
      "depthWeightModifiers": {
        "shallow": -30,
        "deep": 40
      },
      "specialHazards": [
        {
          "id": "falling-debris",
          "probability": 0.3,
          "severity": "moderate",
          "description": "Loose stones threaten to fall from the unstable ceiling."
        }
      ]
    },
    {
      "id": "reclaimed",
      "name": "Reclaimed",
      "description": "Nature overtaking former structures.",
      "hazardModifier": 1.2,
      "trapFunctionality": 0.1,
      "lootQualityModifier": 0.7,
      "encounterModifier": 1.0,
      "descriptors": {
        "surfaceConditions": ["vine-covered", "moss-grown", "root-cracked", "nature-claimed", "overgrown"],
        "atmosphereModifiers": ["wild", "untamed", "returning to nature", "peaceful reclamation"],
        "debris": ["fallen leaves", "animal droppings", "bird nests", "pooled water", "tangled roots"],
        "lightingModifiers": ["filtered through growth", "dappled green", "natural light through gaps", "soft organic glow"],
        "smellModifiers": ["growing things", "damp earth", "wild animals", "fresh growth", "forest floor"]
      },
      "depthWeightModifiers": {
        "shallow": 0,
        "deep": 0
      },
      "biomeWeightModifiers": {
        "forest": 80,
        "fungal": 60,
        "overgrown": 100
      },
      "specialHazards": [
        {
          "id": "tangling-roots",
          "probability": 0.25,
          "severity": "minor",
          "description": "Thick roots snake across the floor, threatening to trip the unwary."
        }
      ]
    }
  ]
}
```

### 12.2 Coherence Rules Configuration

**File:** `config/coherence-rules.json`

```json
{
  "$schema": "schemas/coherence-rules-schema.json",
  "materialPalettes": {
    "default": {
      "primaryMaterial": "gray stone",
      "secondaryMaterial": "granite",
      "floorMaterial": "stone tiles",
      "metalAccent": "iron",
      "colors": ["gray", "brown", "dark"]
    },
    "byBiome": {
      "catacombs": {
        "primaryMaterial": "limestone",
        "secondaryMaterial": "marble",
        "floorMaterial": "worn flagstone",
        "metalAccent": "tarnished bronze",
        "colors": ["bone white", "gray", "faded gold"]
      },
      "volcanic-caverns": {
        "primaryMaterial": "obsidian",
        "secondaryMaterial": "basalt",
        "floorMaterial": "cooled lava",
        "metalAccent": "blackened iron",
        "colors": ["black", "red", "orange glow"]
      },
      "frozen-depths": {
        "primaryMaterial": "blue ice",
        "secondaryMaterial": "frosted stone",
        "floorMaterial": "frozen ground",
        "metalAccent": "silver",
        "colors": ["ice blue", "white", "pale silver"]
      },
      "ancient-ruins": {
        "primaryMaterial": "weathered sandstone",
        "secondaryMaterial": "cracked marble",
        "floorMaterial": "broken mosaic",
        "metalAccent": "corroded copper",
        "colors": ["sand", "faded ochre", "dusty brown"]
      },
      "mines": {
        "primaryMaterial": "rough-hewn rock",
        "secondaryMaterial": "ore-veined stone",
        "floorMaterial": "packed earth",
        "metalAccent": "rusted iron",
        "colors": ["dark brown", "rust", "coal black"]
      }
    }
  },
  "corridorRules": {
    "default": {
      "required": true,
      "minWidth": 1,
      "maxWidth": 2,
      "allowDecorations": true
    },
    "byStyle": {
      "natural-caves": {
        "required": false,
        "note": "Direct room connections, no formal corridors"
      },
      "carved-halls": {
        "required": true,
        "minWidth": 1,
        "maxWidth": 1,
        "allowDecorations": true,
        "decorationFeatures": ["torch-sconce", "alcove"]
      },
      "ruined-structures": {
        "required": false,
        "note": "Corridors collapsed"
      },
      "ancient-temples": {
        "required": true,
        "minWidth": 2,
        "maxWidth": 3,
        "allowDecorations": true,
        "decorationFeatures": ["pillar", "statue", "offering-bowl"]
      }
    },
    "roomTypeOverrides": {
      "Boss": {
        "required": true,
        "minWidth": 2,
        "note": "Boss rooms need grand approach"
      },
      "Safe": {
        "required": true,
        "note": "Safe havens need defined entrance"
      }
    }
  },
  "supportRules": {
    "sizeThreshold": 10,
    "byStyle": {
      "carved-halls": {
        "requiredFeatures": ["pillar"],
        "minFeaturesForLargeRoom": 2
      },
      "ancient-temples": {
        "requiredFeatures": ["pillar", "statue"],
        "minFeaturesForLargeRoom": 4
      }
    }
  },
  "coherenceThresholds": {
    "maxStyleInconsistencyPercent": 0.2,
    "maxBiomeTransitions": 2,
    "allowGradualTransitions": true
  }
}
```

### 12.3 Dungeon Ages JSON Schema

**File:** `config/schemas/dungeon-ages-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "dungeon-ages-schema.json",
  "title": "Dungeon Ages Definitions",
  "description": "Schema for dungeon age configuration",
  "type": "object",
  "required": ["ages"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "ages": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/dungeonAge"
      }
    }
  },
  "$defs": {
    "dungeonAge": {
      "type": "object",
      "required": ["id", "name", "hazardModifier", "trapFunctionality", "descriptors"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier in kebab-case"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Display name"
        },
        "description": {
          "type": "string",
          "description": "Descriptive text for the age state"
        },
        "hazardModifier": {
          "type": "number",
          "minimum": 0,
          "maximum": 3,
          "description": "Multiplier for hazard probabilities"
        },
        "trapFunctionality": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Probability that traps are functional"
        },
        "lootQualityModifier": {
          "type": "number",
          "minimum": 0,
          "maximum": 2,
          "description": "Multiplier for loot quality"
        },
        "encounterModifier": {
          "type": "number",
          "minimum": 0,
          "maximum": 3,
          "description": "Multiplier for encounter rates"
        },
        "descriptors": {
          "$ref": "#/$defs/ageDescriptors"
        },
        "depthWeightModifiers": {
          "type": "object",
          "properties": {
            "shallow": { "type": "integer" },
            "deep": { "type": "integer" }
          }
        },
        "biomeWeightModifiers": {
          "type": "object",
          "additionalProperties": { "type": "integer" }
        },
        "specialHazards": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/specialHazard"
          }
        }
      }
    },
    "ageDescriptors": {
      "type": "object",
      "required": ["surfaceConditions", "atmosphereModifiers", "lightingModifiers", "smellModifiers"],
      "properties": {
        "surfaceConditions": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        },
        "atmosphereModifiers": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        },
        "debris": {
          "type": "array",
          "items": { "type": "string" }
        },
        "lightingModifiers": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        },
        "smellModifiers": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "string" }
        }
      }
    },
    "specialHazard": {
      "type": "object",
      "required": ["id", "probability", "description"],
      "properties": {
        "id": { "type": "string" },
        "probability": { "type": "number", "minimum": 0, "maximum": 1 },
        "severity": { "type": "string", "enum": ["minor", "moderate", "major", "severe"] },
        "description": { "type": "string" }
      }
    }
  }
}
```

### 12.4 Coherence Rules JSON Schema

**File:** `config/schemas/coherence-rules-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "coherence-rules-schema.json",
  "title": "Coherence Rules Definitions",
  "description": "Schema for dungeon coherence configuration",
  "type": "object",
  "required": ["materialPalettes", "corridorRules", "coherenceThresholds"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "materialPalettes": {
      "$ref": "#/$defs/materialPaletteConfig"
    },
    "corridorRules": {
      "$ref": "#/$defs/corridorRulesConfig"
    },
    "supportRules": {
      "$ref": "#/$defs/supportRulesConfig"
    },
    "coherenceThresholds": {
      "$ref": "#/$defs/coherenceThresholdsConfig"
    }
  },
  "$defs": {
    "materialPaletteConfig": {
      "type": "object",
      "required": ["default"],
      "properties": {
        "default": { "$ref": "#/$defs/materialPalette" },
        "byBiome": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/materialPalette" }
        }
      }
    },
    "materialPalette": {
      "type": "object",
      "required": ["primaryMaterial", "floorMaterial"],
      "properties": {
        "primaryMaterial": { "type": "string" },
        "secondaryMaterial": { "type": "string" },
        "floorMaterial": { "type": "string" },
        "metalAccent": { "type": "string" },
        "colors": {
          "type": "array",
          "items": { "type": "string" }
        }
      }
    },
    "corridorRulesConfig": {
      "type": "object",
      "required": ["default"],
      "properties": {
        "default": { "$ref": "#/$defs/corridorRule" },
        "byStyle": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/corridorRule" }
        },
        "roomTypeOverrides": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/corridorRule" }
        }
      }
    },
    "corridorRule": {
      "type": "object",
      "properties": {
        "required": { "type": "boolean" },
        "minWidth": { "type": "integer", "minimum": 0 },
        "maxWidth": { "type": "integer", "minimum": 0 },
        "allowDecorations": { "type": "boolean" },
        "decorationFeatures": {
          "type": "array",
          "items": { "type": "string" }
        },
        "note": { "type": "string" }
      }
    },
    "supportRulesConfig": {
      "type": "object",
      "properties": {
        "sizeThreshold": { "type": "integer" },
        "byStyle": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "requiredFeatures": {
                "type": "array",
                "items": { "type": "string" }
              },
              "minFeaturesForLargeRoom": { "type": "integer" }
            }
          }
        }
      }
    },
    "coherenceThresholdsConfig": {
      "type": "object",
      "properties": {
        "maxStyleInconsistencyPercent": { "type": "number", "minimum": 0, "maximum": 1 },
        "maxBiomeTransitions": { "type": "integer", "minimum": 1 },
        "allowGradualTransitions": { "type": "boolean" }
      }
    }
  }
}
```

---

## 13. Logging Specifications

### 13.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `CoherenceService` | Information | Age selected, coherence validation complete |
| `CoherenceService` | Debug | Material palette creation, corridor checks, support requirements |
| `CoherenceService` | Warning | Coherence issues found, missing supports |
| `CoherenceService` | Error | Configuration loading failure |
| `HazardService` | Debug | Age modifier applied, trap functionality check |
| `DescriptorService` | Debug | Age overlay applied |
| `Room` | Debug | Age assignment |

### 13.2 Log Message Examples

```csharp
// Information
_logger.LogInformation("Selected age {Age} for room at position ({X}, {Y}, {Z})",
    age, position.X, position.Y, position.Z);
_logger.LogInformation("Coherence validation complete: {Result} with {IssueCount} issues",
    result.IsValid ? "PASSED" : "FAILED", result.Issues.Count);

// Debug
_logger.LogDebug("Created material palette for biome {BiomeId} with style {StyleId}: {Primary}",
    biomeId, styleId, palette.PrimaryMaterial);
_logger.LogDebug("Corridor requirement check: from {FromType} to {ToType} in style {Style} = {Result}",
    fromRoom.RoomType, toRoom.RoomType, style.Id, requiresCorridor);
_logger.LogDebug("Hazard {HazardId} probability: {Base:P0} × {AgeMod} (age: {Age}) = {Effective:P0}",
    hazard.Id, baseProbability, ageModifier, room.Age, effectiveProbability);
_logger.LogDebug("Trap functionality check: age {Age} = {Functionality:P0}, result = {Result}",
    room.Age, functionality, isFunctional ? "FUNCTIONAL" : "BROKEN");

// Warning
_logger.LogWarning("Coherence issue: {ViolationCount} rooms have inconsistent styles",
    styleViolations);
_logger.LogWarning("Room at {Position} in constructed style lacks required supports",
    room.Position);

// Error
_logger.LogError(ex, "Failed to load dungeon age configuration from {Path}", configPath);
```

---

## 14. Unit Testing Requirements

### 14.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| DungeonAge enum | ~2 |
| AgeDescriptors value object | ~5 |
| MaterialPalette value object | ~4 |
| CoherenceValidationResult value object | ~2 |
| CoherenceService | ~7 |
| Room age integration | ~3 |
| **Total** | **~23** |

### 14.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `DungeonAgeTests.cs` | ~2 | Enum values, age count |
| `AgeDescriptorsTests.cs` | ~5 | ForAge, GetRandomDescriptor, static factories, HasDebris, IsValid |
| `MaterialPaletteTests.cs` | ~4 | ForBiome, WithStyle, Default, GetMaterialDescription |
| `CoherenceValidationResultTests.cs` | ~2 | Valid, Invalid factories, GetSummary |
| `CoherenceServiceTests.cs` | ~7 | GetMaterialPalette, RequiresCorridor, GetAgeHazardModifier, ValidateCoherence, SelectAgeForContext |
| `RoomAgeTests.cs` | ~3 | SetAge, HasAge, IsDangerousCondition |

### 14.3 Test Categories

**AgeDescriptors Tests:**
```csharp
[Test]
public void ForAge_WithFresh_ReturnsFreshDescriptors()

[Test]
public void ForAge_WithCollapsed_ReturnsCollapsedDescriptors()

[Test]
public void GetRandomDescriptor_WithValidCategory_ReturnsDescriptor()

[Test]
public void GetRandomDescriptor_WithInvalidCategory_ReturnsEmpty()

[Test]
public void HasDebris_ForFresh_ReturnsFalse()

[Test]
public void HasDebris_ForCollapsed_ReturnsTrue()

[Test]
public void IsValid_WithAllCategories_ReturnsTrue()
```

**MaterialPalette Tests:**
```csharp
[Test]
public void ForBiome_WithCatacombs_ReturnsLimestone()

[Test]
public void ForBiome_WithUnknown_ReturnsDefault()

[Test]
public void WithStyle_ForCarvedHalls_ModifiesFloorMaterial()

[Test]
public void GetMaterialDescription_ReturnsFormattedString()
```

**CoherenceService Tests:**
```csharp
[Test]
public void GetMaterialPalette_CombinesBiomeAndStyle()

[Test]
public void RequiresCorridor_ForNaturalCaves_ReturnsFalse()

[Test]
public void RequiresCorridor_ForBossRoom_ReturnsTrue()

[Test]
public void GetAgeHazardModifier_ForCollapsed_ReturnsOnePointFive()

[Test]
public void ValidateCoherence_WithConsistentRooms_ReturnsValid()

[Test]
public void ValidateCoherence_WithStyleInconsistency_ReturnsIssues()

[Test]
public void SelectAgeForContext_AtShallowDepth_FavorsFresh()
```

---

## 15. Use Cases

### UC-001: Generate Room with Age

**Actor:** System (Room Generator)
**Flow:** Room generated with biome and style → CoherenceService.SelectAgeForContext(position, biomeId, styleId) → Room.SetAge(age) → Room has complete attributes

### UC-002: Display Age-Modified Room Description

**Actor:** Player
**Flow:** Player enters room → DescriptorService gets base description → CoherenceService.GetAgeModifiedDescription(room, age, base) → Layered description displayed

### UC-003: Apply Age Hazard Modifier

**Actor:** System (Hazard Generator)
**Flow:** Checking hazards for room → HazardService.GetEffectiveHazardProbability(hazard, room) → Age modifier applied → Hazard check performed

### UC-004: Check Trap Functionality

**Actor:** System (Trap Trigger)
**Flow:** Player triggers trap → HazardService.IsTrapFunctional(room, position) → Age-based roll → Trap fires or fails

### UC-005: Validate Dungeon Coherence

**Actor:** System (Post-Generation)
**Flow:** Dungeon generated → CoherenceService.ValidateCoherence(rooms, style) → Issues logged → Optional regeneration or adjustment

### UC-006: Get Material Palette for Room

**Actor:** System (Description Generator)
**Flow:** Generating room description → CoherenceService.GetMaterialPalette(biomeId, styleId) → Material terms included in text

### UC-007: Check Corridor Requirement

**Actor:** System (Dungeon Generator)
**Flow:** Connecting two rooms → CoherenceService.RequiresCorridor(from, to, style) → Corridor generated or direct connection made

---

## 16. Deliverable Checklist

### Domain Layer
- [ ] `DungeonAge.cs` created
- [ ] `AgeDescriptors.cs` created
- [ ] `MaterialPalette.cs` created
- [ ] `CoherenceValidationResult.cs` created
- [ ] `Room.cs` updated with Age property

### Application Layer
- [ ] `ICoherenceService.cs` created
- [ ] `CoherenceService.cs` created
- [ ] `DescriptorService.cs` updated with age overlay support
- [ ] `HazardService.cs` updated with age modifiers

### Infrastructure Layer
- [ ] `IConfigurationProvider.cs` updated
- [ ] `JsonConfigurationProvider.cs` updated to load ages and coherence rules
- [ ] `DungeonAgeConfigurationDto.cs` created
- [ ] `CoherenceRulesConfigurationDto.cs` created

### Configuration Files
- [ ] `config/dungeon-ages.json` created with 4 age definitions
- [ ] `config/coherence-rules.json` created with material palettes and corridor rules
- [ ] `config/schemas/dungeon-ages-schema.json` created
- [ ] `config/schemas/coherence-rules-schema.json` created

### Testing
- [ ] `DungeonAgeTests.cs` created (~2 tests)
- [ ] `AgeDescriptorsTests.cs` created (~5 tests)
- [ ] `MaterialPaletteTests.cs` created (~4 tests)
- [ ] `CoherenceValidationResultTests.cs` created (~2 tests)
- [ ] `CoherenceServiceTests.cs` created (~7 tests)
- [ ] `RoomAgeTests.cs` created (~3 tests)
- [ ] All ~23 tests passing

### Documentation
- [ ] XML documentation on all public members
- [ ] Code follows .editorconfig conventions

---

## 17. Acceptance Criteria

### Functional

- [ ] DungeonAge enum contains Fresh, Ancient, Collapsed, Reclaimed values
- [ ] AgeDescriptors provides descriptors for all five categories
- [ ] AgeDescriptors.ForAge returns appropriate descriptors for each age
- [ ] MaterialPalette.ForBiome returns biome-appropriate materials
- [ ] MaterialPalette.WithStyle modifies palette for architectural style
- [ ] CoherenceService.GetMaterialPalette combines biome and style
- [ ] CoherenceService.RequiresCorridor respects style rules
- [ ] CoherenceService.GetAgeHazardModifier returns correct multipliers
- [ ] CoherenceService.ValidateCoherence identifies style inconsistencies
- [ ] CoherenceService.SelectAgeForContext uses weighted selection
- [ ] Room.Age stores assigned age
- [ ] Room.SetAge validates and assigns age
- [ ] Age modifies hazard probabilities correctly
- [ ] Trap functionality respects age-based degradation
- [ ] Corridor generation follows style rules
- [ ] Four default ages configured with distinct characteristics
- [ ] Material palettes defined for all biomes

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~23 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on public members
- [ ] Code follows .editorconfig conventions
- [ ] No hardcoded descriptor strings outside configuration
- [ ] Age modifiers are data-driven from configuration

---

## 18. Dependencies

### 18.1 Prerequisites

| Component | Source | Purpose for v0.1.3d |
|-----------|--------|---------------------|
| `ArchitecturalStyle` | v0.1.3a | Style rules for coherence |
| `ArchitecturalStyleService` | v0.1.3a | Style lookup |
| `StyleRules` | v0.1.3a | Construction parameters |
| `RoomShape` | v0.1.3b | Shape-based support needs |
| `StructuralFeature` | v0.1.3b | Support feature validation |
| `Room.Shape` | v0.1.3b | Shape for support calculation |
| `Room.StructuralFeatures` | v0.1.3b | Feature presence validation |
| `LandmarkRoom` | v0.1.3c | Landmark age handling |
| `BiomeHazard` | v0.1.2c | Hazard modification |
| `BiomeDefinition` | v0.1.2a | Biome material palettes |
| `SeededRandomService` | v0.1.0+ | Reproducible age selection |
| `Position3D` | v0.1.0+ | Depth-based age weighting |

### 18.2 Provides to Future Versions

| Component | Used By |
|-----------|---------|
| `DungeonAge` | v0.1.4+ (environmental progression) |
| `CoherenceService` | v0.1.4+ (dungeon validation) |
| `MaterialPalette` | v0.1.4+ (visual consistency) |
| `AgeDescriptors` | v0.1.4+ (enhanced descriptions) |
| `Room.Age` | All age-aware features |

### 18.3 Dependency Diagram

```
v0.1.2 (Dungeon Theming & Biomes)
    │
    ├── BiomeDefinition, BiomeService ──────────────┐
    └── BiomeHazard ─────────────────────────────────┤
                                                     │
v0.1.3a (Architectural Styles)                       │
    │                                                │
    ├── ArchitecturalStyle ──────────────────────────┤
    ├── StyleRules ──────────────────────────────────┤
    └── ArchitecturalStyleService ───────────────────┤
                                                     │
v0.1.3b (Room Shapes & Features)                     │
    │                                                │
    ├── RoomShape ───────────────────────────────────┤
    ├── StructuralFeature ───────────────────────────┤
    └── Room.Shape, Room.StructuralFeatures ─────────┤
                                                     │
v0.1.3c (Landmark Rooms)                             │
    │                                                │
    └── LandmarkRoom ────────────────────────────────┘
                                                     │
                                                     ▼
v0.1.3d (Dungeon Age & Coherence)
    │
    ├── DungeonAge ─────────────────────────────────────────────┐
    ├── AgeDescriptors ─────────────────────────────────────────│
    ├── MaterialPalette ────────────────────────────────────────│
    ├── CoherenceService ───────────────────────────────────────│
    └── Room.Age ───────────────────────────────────────────────┘
                                                                │
                                                                ▼
                                        v0.1.4+ (Future Versions)
                                        ├── Environmental progression
                                        ├── Dynamic age changes
                                        └── Enhanced coherence features
```

---

## 19. Future Considerations

### 19.1 Deferred to Future Versions

- **Dynamic Age Progression** - Dungeons aging over in-game time
- **Age Restoration** - Player actions restoring or degrading structures
- **Custom Age Creation** - Modder-defined age states
- **Age-Specific Creatures** - Wildlife tied to Reclaimed age
- **Structural Collapse Events** - Real-time collapse in Collapsed areas
- **Material Crafting** - Harvesting materials from specific palettes

### 19.2 Out of Scope

- **Visual Rendering** - Actual graphical representation of materials (TUI only)
- **Sound Integration** - Age-specific ambient audio
- **Weather Effects** - Environmental conditions in Reclaimed areas
- **Construction Mechanics** - Player building/repairing structures

### 19.3 Design Notes

The age and coherence systems are intentionally non-blocking. Coherence validation produces warnings rather than errors, allowing procedural generation to continue while logging potential issues. This supports both strict validation for curated content and flexible validation for random generation.

Material palettes are defined per-biome with style modifications, ensuring consistency while allowing architectural styles to influence material descriptions. This layered approach matches the existing biome-style-age descriptor pattern.

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
