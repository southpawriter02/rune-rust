# v0.2.0: Combat Resolution Core

> **Status:** Complete
> **Milestone:** 3 - The Warrior
> **Theme:** Transform the application into a tactical turn-based RPG

## Table of Contents
- [Overview](#overview)
- [Phase A: The Arena (State & Initiative)](#phase-a-the-arena-state--initiative)
- [Phase B: The Exchange (Actions & Resolution)](#phase-b-the-exchange-actions--resolution)
- [Phase C: The Interface (Combat UI)](#phase-c-the-interface-combat-ui)
- [Phase D: The Enemy's Turn (AI & Defense)](#phase-d-the-enemys-turn-ai--defense)
- [Testing Strategy](#testing-strategy)
- [Draft Changelog](#draft-changelog)

## Overview

This version establishes the rules of engagement, turn order, and the mathematical resolution of violence. Given the complexity of turn-based state management, action economy, and dice resolution, this version is divided into four sub-milestones:

- **Phase A: The Arena** - CombatState, turn management, Initiative calculation
- **Phase B: The Exchange** - Action Economy, Attack Resolution, Damage Logic
- **Phase C: The Interface** - Combat UI with turn order, health bars, combat log
- **Phase D: The Enemy's Turn** - AI actions, Defense options, complete loop

---

## Phase A: The Arena (State & Initiative)

**Goal:** Establish the underlying infrastructure for the Combat System. This includes the CombatState machine, the Combatant adapter pattern, and the Initiative sorting logic.

### 1. Implementation Workflow

1. **Domain Entities:** Create CombatState, Combatant, and Enemy (stub) in Core
2. **State Management:** Update GameState to hold the active CombatState
3. **Initiative Logic:** Implement InitiativeService using IDiceService (d10 + FINESSE + WITS)
4. **Orchestration:** Implement CombatService to handle StartCombat, NextTurn, and EndCombat
5. **Integration:** Wire debug-combat command in CommandParser to test transitions

### 2. Architecture

Use an Adapter Pattern (Combatant) to treat Players and Enemies identically during combat processing.

```
GameState "1" -- "0..1" CombatState
CombatState "1" -- "many" Combatant
```

### 3. Code Implementation

#### A. Core Layer (Models)

**File:** `RuneAndRust.Core/Entities/Enemy.cs`
```csharp
public class Enemy
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = "Training Dummy";
    public Dictionary<Attribute, int> Attributes { get; set; } = new();
    public int MaxHp { get; set; }
}
```

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs`
```csharp
public class Combatant
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;
    public bool IsPlayer { get; set; }
    public int Initiative { get; set; }
    public int CurrentHp { get; set; }
    public int MaxHp { get; set; }
    public Character? CharacterSource { get; set; }
    public Enemy? EnemySource { get; set; }

    public int GetAttribute(Attribute attr) =>
        CharacterSource?.GetAttribute(attr) ??
        EnemySource?.Attributes.GetValueOrDefault(attr, 0) ?? 0;

    public static Combatant FromCharacter(Character c) => new() { ... };
    public static Combatant FromEnemy(Enemy e) => new() { ... };
}
```

**File:** `RuneAndRust.Core/Models/CombatState.cs`
```csharp
public class CombatState
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public List<Combatant> TurnOrder { get; set; } = new();
    public int RoundNumber { get; set; } = 1;
    public int TurnIndex { get; set; } = 0;
    public Combatant ActiveCombatant => TurnOrder[TurnIndex];
}
```

#### B. Engine Layer (Services)

**File:** `RuneAndRust.Engine/Services/InitiativeService.cs`
```csharp
public class InitiativeService
{
    public void RollInitiative(Combatant combatant)
    {
        // Formula: d10 + FINESSE + WITS (Vigilance)
        var roll = _dice.Roll(1, "Initiative").Successes;
        var vigilance = combatant.GetAttribute(Attribute.Finesse) +
                        combatant.GetAttribute(Attribute.Wits);
        combatant.Initiative = roll + vigilance;
    }

    public List<Combatant> SortTurnOrder(IEnumerable<Combatant> combatants)
    {
        return combatants
            .OrderByDescending(c => c.Initiative)
            .ThenByDescending(c => c.GetAttribute(Attribute.Finesse))
            .ThenBy(_ => Guid.NewGuid()) // Chaos tie-breaker
            .ToList();
    }
}
```

### 4. Decision Tree

- **Q: How do we handle "Surprise"?**
  - A: Not in Phase A. Add isSurprise flag later.

- **Q: Do attributes update mid-combat?**
  - A: Combatant keeps reference to source. GetAttribute reflects changes immediately.

### 5. Deliverable Checklist (Phase A)

- [x] Core: Combatant and CombatState classes created
- [x] Core: Enemy entity created (stub)
- [x] Core: GameState updated with CombatState property
- [x] Engine: InitiativeService implemented and registered
- [x] Engine: CombatService implemented and registered
- [x] Integration: debug-combat command added
- [x] Tests: Passing unit tests for Initiative sorting

---

## Phase B: The Exchange (Actions & Resolution)

**Goal:** Implement the "Engine of Violence" - Action Economy, Attack Resolution (Opposed Rolls), and Damage Logic.

### 1. Implementation Workflow

1. **Domain Expansion:** Update Combatant with Stamina, Defense, Soak properties
2. **Logic Core:** Implement AttackResolutionService for hit/miss calculations
3. **Damage Pipeline:** Implement DamageService (Raw Damage - Soak)
4. **Orchestration:** Extend CombatService with ExecutePlayerAttack
5. **Integration:** Connect attack command in CommandParser

### 2. Architecture

"Resolution Pipeline" separates concerns:
```
Player Command -> CombatService -> AttackResolution -> Damage -> Target HP
```

### 3. Code Implementation

#### A. Core Layer (Models)

**File:** `RuneAndRust.Core/Models/Combat/AttackResult.cs`
```csharp
public enum AttackOutcome { Fumble, Miss, Glancing, Solid, Critical }

public record AttackResult(
    AttackOutcome Outcome,
    int NetSuccesses,
    int RawDamage,
    bool IsHit
);
```

#### B. Engine Layer (Resolution)

**File:** `RuneAndRust.Engine/Services/AttackResolutionService.cs`
```csharp
public class AttackResolutionService
{
    public AttackResult ResolveMelee(Combatant attacker, Combatant defender)
    {
        var attackPool = attacker.GetAttribute(Attribute.Might);
        var roll = _dice.Roll(attackPool, "Attack Roll");
        int netSuccesses = roll.Successes - (defender.Defense / 2);

        var outcome = netSuccesses switch
        {
            <= -5 => AttackOutcome.Fumble,
            <= 0 => AttackOutcome.Miss,
            1 or 2 => AttackOutcome.Glancing,
            3 or 4 => AttackOutcome.Solid,
            _ => AttackOutcome.Critical
        };

        int rawDamage = attacker.GetAttribute(Attribute.Might) +
                        _dice.RollSingle(6, "Weapon Dmg");

        if (outcome == AttackOutcome.Critical) rawDamage *= 2;
        if (outcome == AttackOutcome.Glancing) rawDamage /= 2;

        return new AttackResult(outcome, netSuccesses, rawDamage, netSuccesses > 0);
    }
}
```

### 4. Decision Tree

- **Q: Does "Defense" reduce damage or hit chance?**
  - A: Hit Chance. Defense reduces Net Successes. Soak reduces Damage.

- **Q: What happens on a Tie?**
  - A: Defender Wins. 0 Net Successes is a Miss.

### 5. Logging Matrix

| System | Event | Level | Message Template |
|--------|-------|-------|------------------|
| Resolution | Attack Roll | Debug | "{Attacker} rolled {Successes} vs Defense {Def}. Net: {Net}" |
| Combat | Damage Dealt | Info | "{Target} took {Dmg} damage. HP: {Cur}/{Max}" |
| Combat | Death | Warning | "{Target} was slain by {Attacker}!" |

### 6. Deliverable Checklist (Phase B)

- [x] Core: Update Combatant with Stamina/Defense/Soak
- [x] Core: Create AttackResult and AttackOutcome types
- [x] Engine: Implement AttackResolutionService
- [x] Engine: Update CombatService with ExecutePlayerAttack
- [x] Terminal: Update CommandParser for attack <target>

---

## Phase C: The Interface (Combat UI)

**Goal:** Implement the visual layer for combat - Turn Order, Enemy Status (narrative cues), Combat Log.

### 1. Implementation Workflow

1. **Data Transformation:** Create CombatViewModel for UI-ready data
2. **Log Buffer:** Implement rolling CombatLog (last N events)
3. **Rendering:** Build CombatScreenRenderer with Spectre.Console
4. **Loop Integration:** Trigger re-render after every combat input

### 2. Architecture

```
CombatService -> ViewModelFactory -> Renderer -> Player
```

### 3. Code Implementation

#### A. Engine Layer (Display Models)

**File:** `RuneAndRust.Engine/ViewModels/CombatViewModel.cs`
```csharp
public record CombatViewModel(
    int RoundNumber,
    string ActiveCombatantName,
    List<CombatantView> TurnOrder,
    List<string> CombatLog,
    PlayerStatsView PlayerStats
);

public record CombatantView(
    Guid Id,
    string Name,
    bool IsPlayer,
    bool IsActive,
    string HealthStatus,  // Narrative for enemies ("Bloodied")
    string StatusEffects,
    string InitiativeDisplay
);
```

#### B. Terminal Layer (Renderer)

**File:** `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs`
```csharp
public class CombatScreenRenderer
{
    public void Render(CombatViewModel vm)
    {
        AnsiConsole.Clear();

        // Header: Player Stats
        // Main: Turn Order Table
        // Footer: Combat Log Panel

        var layout = new Layout("Root")
            .SplitRows(
                new Layout("Stats"),
                new Layout("TurnOrder"),
                new Layout("Log")
            );

        AnsiConsole.Write(layout);
    }
}
```

### 4. Decision Tree

- **Q: Do we render a grid?**
  - A: No. "Theater of the mind" for now.

- **Q: How do we handle color coding?**
  - A: CombatService injects markup tags into log strings.

### 5. Deliverable Checklist (Phase C)

- [x] Engine: Implement CombatViewModel records
- [x] Engine: Update ICombatService with GetViewModel()
- [x] Engine: Implement CombatLog queue with markup
- [x] Terminal: Create CombatScreenRenderer
- [x] Testing: Verify enemy HP is obscured (narrative only)

---

## Phase D: The Enemy's Turn (AI & Defense)

**Goal:** Close the combat loop with Enemy AI, Stamina Regeneration, and Defensive options.

### 1. Implementation Workflow

1. **AI Service:** Implement EnemyAIService (Attack vs Pass)
2. **Turn Automation:** Auto-trigger AI actions on enemy turns
3. **Regeneration:** Stamina regen at start of each turn
4. **Defensive Actions:** Implement Defend and Flee

### 2. Architecture

```
NextTurn() -> IsPlayer? -> Await Command
           -> IsEnemy?  -> EnemyAI.DetermineAction -> Apply -> NextTurn()
```

### 3. Code Implementation

#### A. Engine Layer (AI Service)

**File:** `RuneAndRust.Engine/Services/EnemyAIService.cs`
```csharp
public class EnemyAIService
{
    public string DetermineAndExecuteAction(CombatState state)
    {
        var enemy = state.ActiveCombatant;
        var player = state.TurnOrder.First(c => c.IsPlayer);

        if (_attackResolution.CanAffordAttack(enemy, AttackType.Standard))
        {
            var result = _attackResolution.ResolveMeleeAttack(enemy, player);
            if (result.IsHit)
            {
                player.CurrentHp -= result.FinalDamage;
                return $"{enemy.Name} attacks for {result.FinalDamage} damage.";
            }
            return $"{enemy.Name} attacks but misses!";
        }

        return $"{enemy.Name} catches their breath (Pass).";
    }
}
```

#### B. Combat Service Updates

**File:** `RuneAndRust.Engine/Services/CombatService.cs`
```csharp
public async Task NextTurn()
{
    var active = _gameState.CombatState.ActiveCombatant;

    // Regen Stamina
    active.CurrentStamina = Math.Min(active.MaxStamina, active.CurrentStamina + 5);

    if (!active.IsPlayer)
    {
        await Task.Delay(500); // UX delay
        var resultMsg = _enemyAI.DetermineAndExecuteAction(_gameState.CombatState);
        LogCombatEvent(resultMsg);
        await NextTurn();
    }
}

public string ExecuteDefend()
{
    _gameState.CombatState.ActiveCombatant.IsDefending = true;
    return "You raise your guard (+Defense/Soak next turn).";
}

public string ExecuteFlee()
{
    var player = _gameState.CombatState.ActiveCombatant;
    var roll = _dice.Roll(player.GetAttribute(Attribute.Finesse) +
                          player.GetAttribute(Attribute.Wits), "Flee Check");

    if (roll.Successes >= 1)
    {
        EndCombat();
        return "You escaped!";
    }

    NextTurn();
    return "You failed to escape!";
}
```

### 4. Deliverable Checklist (Phase D)

- [x] Engine: EnemyAIService implemented (Basic Attack logic)
- [x] Engine: CombatService auto-plays enemy turns
- [x] Engine: Stamina Regeneration on turn start
- [x] Engine: Combatant.IsDefending flag
- [x] Engine: ExecuteDefend and ExecuteFlee implemented
- [x] Terminal: Wire defend and flee commands
- [x] Testing: Verify AI damages player, Flee ends combat

---

## Testing Strategy

### Unit Tests

**InitiativeTests.cs:**
- SortOrder_HigherInitiative_GoesFirst
- RollInitiative_IncludesAttributes

**AttackResolutionTests.cs:**
- Hit logic with high MIGHT vs low Defense
- Miss logic with low MIGHT vs high Defense

**CombatViewModelTests.cs:**
- MapToView_HidesEnemyHealth

### Integration Tests

**CombatLoopTests.cs:**
- StartCombat_SetsPhaseToCombat
- StartCombat_PopulatesTurnOrder
- NextTurn_CyclesCorrectly
- EndCombat_ClearsState

---

## Draft Changelog

```markdown
# Changelog: v0.2.0 - Combat Resolution Core

## Summary
Tactical turn-based combat is now live. Players can engage enemies, roll for
initiative, attack, defend, and flee. The combat UI displays turn order,
health status, and a scrolling combat log.

## Features
- **Combat State Machine:** Initiative-based turn order with round tracking
- **Attack Resolution:** Dice pool vs Defense with Fumble/Miss/Glancing/Solid/Critical outcomes
- **Damage System:** Raw damage minus Soak, with critical multipliers
- **Combat UI:** Turn order display, narrative health status, combat log
- **Enemy AI:** Basic aggressive behavior with attack/pass decisions
- **Defensive Options:** Defend (bonus next turn) and Flee (skill check)

## Technical
- Implemented Combatant adapter pattern for Player/Enemy abstraction
- Created InitiativeService with d10 + FINESSE + WITS formula
- Built AttackResolutionService with opposed roll mechanics
- Added CombatScreenRenderer with Spectre.Console layouts
```

---

*This completes the Combat Core. The next phase, v0.2.1: The Armory, adds weapon damage, armor soak, and status effects.*
