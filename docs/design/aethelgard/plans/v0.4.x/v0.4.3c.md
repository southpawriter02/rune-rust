# v0.4.3c: The Incantation (Cast Command & MagicService)

> **Status:** Planned
> **Parent:** v0.4.3 - The Weaver (Magic Core System)
> **Theme:** Speaking the words of power—spell execution, targeting validation, and the arcane pipeline.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Component Specifications](#component-specifications)
5. [Code Implementation](#code-implementation)
6. [Logging Matrix](#logging-matrix)
7. [Unit Testing Specification](#unit-testing-specification)
8. [Integration Points](#integration-points)
9. [Deliverable Checklist](#deliverable-checklist)
10. [Workflow](#workflow)
11. [Changelog](#changelog)

---

## Overview

v0.4.3c introduces the **MagicService** and the `cast` command—the execution pipeline that transforms spell definitions (v0.4.3b) into combat effects while integrating with the Flux system (v0.4.3a). This version follows the established `AbilityService` pattern but extends it for magic-specific concerns.

### Design Philosophy

The MagicService mirrors AbilityService but adds:

1. **Flux Integration**: Every spell cast adds to environmental Flux via AetherService
2. **School-Aware Targeting**: Spells have explicit target type constraints
3. **Spell-Specific Validation**: Range categories, target types, concentration checks
4. **Event Publishing**: SpellCastEvent for UI/audio integration

### MagicService vs AbilityService Comparison

| Aspect | AbilityService | MagicService |
|--------|----------------|--------------|
| **Resource** | Stamina + optional AP | AP only (Aether Points) |
| **Environmental** | None | Adds FluxCost to AetherService |
| **Lookup** | By hotkey or name | By spell name via SpellRepository |
| **Targeting** | Simple range (0 = self, 1+ = enemies) | SpellTargetType enum + SpellRange |
| **Result Type** | AbilityResult | MagicResult (extends pattern) |
| **Events** | None specific | SpellCastEvent |

### Command Syntax

```
cast <spell>                    # Auto-target single enemy or self
cast <spell> on <target>        # Explicit target
cast <spell> at <target>        # Alternative syntax
```

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           CommandParser                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ HandleCombat("cast spark on goblin")                            │   │
│  │     │                                                           │   │
│  │     ▼                                                           │   │
│  │ ExecuteCastCommand("spark on goblin")                           │   │
│  │     │                                                           │   │
│  │     ├─── spellName: "spark"                                     │   │
│  │     └─── targetName: "goblin"                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ calls
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           CombatService                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ ExecutePlayerSpell("spark", "goblin")                           │   │
│  │     │                                                           │   │
│  │     ├─── 1. Validate combat active & player's turn              │   │
│  │     ├─── 2. Lookup spell via SpellRepository                    │   │
│  │     ├─── 3. Resolve target                                      │   │
│  │     ├─── 4. Call MagicService.CastSpell()                       │   │
│  │     ├─── 5. Log to combat log                                   │   │
│  │     └─── 6. Check victory condition                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ delegates to
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                            MagicService                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ CastSpell(caster, target, spell)                                │   │
│  │     │                                                           │   │
│  │     ├─── 1. CanCast() validation                                │   │
│  │     ├─── 2. DeductAp() via ResourceService                      │   │
│  │     ├─── 3. AddFlux() via AetherService                         │   │
│  │     ├─── 4. ExecuteEffect() via EffectScriptExecutor            │   │
│  │     ├─── 5. Publish SpellCastEvent                              │   │
│  │     └─── 6. Return MagicResult                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
           │                    │                    │
           │                    │                    │
           ▼                    ▼                    ▼
    ┌────────────┐      ┌────────────┐      ┌─────────────────┐
    │ Resource   │      │  Aether    │      │ EffectScript    │
    │  Service   │      │  Service   │      │   Executor      │
    │ (AP cost)  │      │ (Flux add) │      │ (DAMAGE/HEAL)   │
    └────────────┘      └────────────┘      └─────────────────┘
```

### Data Flow: "cast spark on goblin"

```
User Input: "cast spark on goblin"
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 1. COMMAND PARSING (CommandParser)                              │
│    ├─── Detect "cast " prefix                                   │
│    ├─── Extract spell: "spark"                                  │
│    ├─── Extract target: "goblin" (after " on ")                 │
│    └─── Call CombatService.ExecutePlayerSpell("spark", "goblin")│
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. SPELL LOOKUP (CombatService)                                 │
│    ├─── Validate: Combat active? Player's turn?                 │
│    ├─── SpellRepository.GetByNameAsync("spark") → Spell         │
│    ├─── If null → "Unknown spell: spark"                        │
│    └─── Resolve target → Combatant "Goblin"                     │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. VALIDATION (MagicService.CanCast)                            │
│    ├─── Check AP: caster.CurrentAp >= spell.ApCost?             │
│    ├─── Check Target Type: spell.TargetType allows enemy?       │
│    ├─── Check Range: target within spell.Range?                 │
│    ├─── Check Concentration: not already concentrating?         │
│    └─── If any fail → MagicResult.Failure(reason)               │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. EXECUTION (MagicService.CastSpell)                           │
│    ├─── ResourceService.Deduct(caster, Aether, spell.ApCost)    │
│    ├─── AetherService.ModifyFlux(spell.FluxCost, "Cast Spark")  │
│    ├─── EffectScriptExecutor.Execute(spell.EffectScript, target)│
│    │        └─── "DAMAGE:Fire:1d6" → 4 damage dealt             │
│    ├─── EventBus.Publish(SpellCastEvent)                        │
│    └─── Return MagicResult.Success(message, damage, etc.)       │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. POST-EXECUTION (CombatService)                               │
│    ├─── LogCombatEvent("[cyan]Player[/] casts [yellow]Spark[/]")│
│    ├─── Check target.CurrentHp <= 0 → RemoveDefeatedCombatant() │
│    ├─── CheckVictoryCondition()                                 │
│    └─── Return result.Message to CommandParser                  │
└─────────────────────────────────────────────────────────────────┘
```

### Service Dependencies

```
MagicService
    ├─── ISpellRepository      (spell lookup)
    ├─── IResourceService      (AP deduction, Overcast)
    ├─── IAetherService        (Flux accumulation)
    ├─── IStatusEffectService  (concentration checks, status application)
    ├─── EffectScriptExecutor  (effect resolution)
    ├─── IEventBus             (SpellCastEvent publishing)
    └─── ILogger<MagicService> (logging)
```

---

## Decision Trees

### 1. CastSpell Decision Tree (Main Flow)

```
CastSpell(caster: Combatant, target: Combatant, spell: Spell): MagicResult
│
├─── [LOG] Info: "{Caster} attempting to cast {Spell} on {Target}"
│
├─── 1. VALIDATE with CanCast()
│    │
│    ├─── CanCast() returns false?
│    │    └─── [LOG] Debug: "Cast failed: {Reason}"
│    │         └─── RETURN MagicResult.Failure(reason)
│    │
│    └─── CanCast() returns true → continue
│
├─── 2. CHECK for charged spell
│    │
│    ├─── spell.ChargeTurns > 0 AND NOT caster.IsChanting?
│    │    └─── RETURN InitiateCharge(caster, spell)
│    │
│    ├─── spell.ChargeTurns > 0 AND caster.IsChanting AND caster.ChanneledSpellId == spell.Id?
│    │    └─── RETURN ReleaseCharge(caster, target, spell)
│    │
│    └─── Instant cast (ChargeTurns == 0) → continue
│
├─── 3. DEDUCT resources
│    │
│    ├─── ResourceService.Deduct(caster, Aether, spell.ApCost)
│    │    └─── [LOG] Debug: "Deducted {ApCost} AP from {Caster}"
│    │
│    └─── If Overcast occurred → [LOG] Warning: "OVERCAST! {HpCost} HP spent"
│
├─── 4. ADD Flux to environment
│    │
│    └─── AetherService.ModifyFlux(spell.FluxCost, $"Cast {spell.Name}")
│         └─── [LOG] Debug: "Added {FluxCost} Flux"
│
├─── 5. EXECUTE effect script
│    │
│    ├─── EffectScriptExecutor.Execute(spell.EffectScript, target, caster.Name, caster.Id)
│    │    └─── Returns EffectScriptResult { Damage, Healing, Statuses, Narrative }
│    │
│    └─── [LOG] Info: "Spell effect resolved: {Damage} damage, {Healing} healing"
│
├─── 6. PUBLISH event
│    │
│    └─── EventBus.Publish(new SpellCastEvent(...))
│
├─── 7. BUILD result message
│    │
│    └─── message = $"{caster.Name} casts {spell.Name}! {effectResult.Narrative}"
│
└─── 8. RETURN MagicResult.Success(message, damage, healing, statuses)
```

### 2. CanCast Decision Tree

```
CanCast(caster: Combatant, target: Combatant, spell: Spell): (bool, CastFailureReason?)
│
├─── 1. CHECK Aether Points
│    │
│    ├─── IsMystic(caster) == false?
│    │    └─── RETURN (false, CastFailureReason.NotMystic)
│    │
│    ├─── ResourceService.CanAfford(caster, Aether, spell.ApCost) == false?
│    │    └─── Check Overcast possibility
│    │         ├─── Can Overcast? → continue (will spend HP)
│    │         └─── Cannot Overcast → RETURN (false, CastFailureReason.InsufficientAp)
│    │
│    └─── Has enough AP → continue
│
├─── 2. CHECK target type validity
│    │
│    ├─── spell.TargetType == Self AND target != caster?
│    │    └─── RETURN (false, CastFailureReason.InvalidTarget)
│    │
│    ├─── spell.TargetType == SingleEnemy AND target.IsPlayer?
│    │    └─── RETURN (false, CastFailureReason.InvalidTarget)
│    │
│    ├─── spell.TargetType == SingleAlly AND !target.IsPlayer?
│    │    └─── RETURN (false, CastFailureReason.InvalidTarget)
│    │
│    └─── Target type valid → continue
│
├─── 3. CHECK range
│    │
│    ├─── GetDistance(caster, target) > GetRangeValue(spell.Range)?
│    │    └─── RETURN (false, CastFailureReason.OutOfRange)
│    │
│    └─── In range → continue
│
├─── 4. CHECK concentration
│    │
│    ├─── caster already concentrating on another spell?
│    │    └─── RETURN (false, CastFailureReason.AlreadyConcentrating)
│    │
│    └─── Not concentrating → continue
│
├─── 5. CHECK silenced/blocked
│    │
│    ├─── StatusEffectService.HasEffect(caster, Silenced)?
│    │    └─── RETURN (false, CastFailureReason.Silenced)
│    │
│    └─── Not silenced → continue
│
└─── 6. ALL CHECKS PASSED
     └─── RETURN (true, null)
```

### 3. Target Resolution Decision Tree

```
ResolveSpellTarget(spell: Spell, targetName: string?, state: CombatState): Combatant?
│
├─── 1. SELF-TARGETING spells
│    │
│    ├─── spell.TargetType == Self OR spell.Range == Self?
│    │    └─── RETURN state.ActiveCombatant (caster)
│    │
│    └─── Not self-targeted → continue
│
├─── 2. EXPLICIT target specified
│    │
│    ├─── targetName not empty?
│    │    │
│    │    ├─── spell.TargetType allows enemies?
│    │    │    └─── Search enemies by name (case-insensitive, partial match)
│    │    │         ├─── Found → RETURN enemy
│    │    │         └─── Not found → RETURN null
│    │    │
│    │    ├─── spell.TargetType allows allies?
│    │    │    └─── Search allies by name
│    │    │         ├─── Found → RETURN ally
│    │    │         └─── Not found → RETURN null
│    │    │
│    │    └─── spell.TargetType == SingleAny?
│    │         └─── Search all combatants
│    │
│    └─── No target specified → continue
│
├─── 3. AUTO-TARGET for enemy spells
│    │
│    ├─── spell.TargetType in [SingleEnemy, AllEnemies]?
│    │    │
│    │    ├─── enemies = GetLivingEnemies(state)
│    │    │
│    │    ├─── enemies.Count == 1?
│    │    │    └─── RETURN enemies[0] (auto-target)
│    │    │
│    │    └─── enemies.Count > 1?
│    │         └─── RETURN null (requires explicit target)
│    │
│    └─── Not enemy spell → continue
│
├─── 4. AUTO-TARGET for ally spells
│    │
│    ├─── spell.TargetType in [SingleAlly, AllAllies]?
│    │    │
│    │    └─── allies = GetLivingAllies(state) (excluding caster for SingleAlly)
│    │         ├─── allies.Count == 1? → RETURN allies[0]
│    │         └─── allies.Count > 1? → RETURN null
│    │
│    └─── Not ally spell → continue
│
└─── 5. FALLBACK
     └─── RETURN null (target required but not resolvable)
```

### 4. InitiateCharge Decision Tree

```
InitiateCharge(caster: Combatant, spell: Spell): MagicResult
│
├─── 1. DEDUCT resources immediately
│    └─── ResourceService.Deduct(caster, Aether, spell.ApCost)
│
├─── 2. ADD partial Flux (half on initiate, half on release)
│    └─── AetherService.ModifyFlux(spell.FluxCost / 2, $"Charging {spell.Name}")
│
├─── 3. APPLY Chanting status
│    └─── StatusEffectService.ApplyEffect(caster, Chanting, spell.ChargeTurns, caster.Id)
│
├─── 4. STORE channeled spell
│    └─── caster.ChanneledSpellId = spell.Id
│
├─── 5. BUILD telegraph message
│    │
│    ├─── spell.TelegraphMessage not empty?
│    │    └─── message = spell.TelegraphMessage
│    │
│    └─── Use default: $"{caster.Name} begins channeling {spell.Name}..."
│
└─── 6. RETURN MagicResult.Charging(message)
```

### 5. ReleaseCharge Decision Tree

```
ReleaseCharge(caster: Combatant, target: Combatant, spell: Spell): MagicResult
│
├─── 1. CLEAR channeling state
│    ├─── caster.ChanneledSpellId = null
│    └─── StatusEffectService.RemoveEffect(caster, Chanting)
│
├─── 2. ADD remaining Flux
│    └─── AetherService.ModifyFlux(spell.FluxCost - (spell.FluxCost / 2), $"Release {spell.Name}")
│
├─── 3. EXECUTE effect (potentially with bonus)
│    │
│    └─── EffectScriptExecutor.Execute(spell.EffectScript, target, caster.Name, caster.Id)
│         NOTE: Charged spells may have bonus damage built into EffectScript
│
├─── 4. PUBLISH event
│    └─── EventBus.Publish(new SpellCastEvent(..., WasCharged: true))
│
├─── 5. BUILD release message
│    └─── message = $"{caster.Name} unleashes {spell.Name}! {effectResult.Narrative}"
│
└─── 6. RETURN MagicResult.Success(message, damage, healing, statuses)
```

### 6. ExecuteCastCommand Decision Tree (CommandParser)

```
ExecuteCastCommand(args: string): ParseResult
│
├─── 1. PARSE arguments
│    │
│    ├─── Find " on " or " at " separator (case-insensitive)
│    │    ├─── Found at index i?
│    │    │    ├─── spellName = args[0..i].Trim()
│    │    │    └─── targetName = args[(i+4)..].Trim()
│    │    │
│    │    └─── Not found?
│    │         ├─── spellName = args.Trim()
│    │         └─── targetName = null
│    │
│    └─── [LOG] Debug: "Parsing cast: spell='{Spell}', target='{Target}'"
│
├─── 2. VALIDATE spell name
│    │
│    ├─── spellName empty?
│    │    └─── Display "Usage: cast <spell> [on <target>]"
│    │         └─── RETURN ParseResult.None
│    │
│    └─── spellName not empty → continue
│
├─── 3. DELEGATE to CombatService
│    │
│    └─── result = _combatService.ExecutePlayerSpell(spellName, targetName)
│         └─── Display result message to player
│
├─── 4. CHECK for victory
│    │
│    ├─── _combatService.CheckVictoryCondition()?
│    │    └─── Handle victory sequence
│    │
│    └─── Not victory → continue
│
├─── 5. ADVANCE turn
│    │
│    └─── _combatService.NextTurn()
│         └─── DisplayCombatTurnInfo()
│
└─── 6. RETURN ParseResult.None
```

---

## Component Specifications

### 1. IMagicService Interface

**File:** `RuneAndRust.Core/Interfaces/IMagicService.cs`

| Method | Returns | Description |
|--------|---------|-------------|
| `CanCast(Combatant, Combatant, Spell)` | `(bool, CastFailureReason?)` | Validate casting requirements |
| `CastSpell(Combatant, Combatant, Spell)` | `MagicResult` | Execute spell with full pipeline |
| `GetAvailableSpells(Combatant)` | `Task<IEnumerable<Spell>>` | Get spells caster can use |
| `GetCannotCastReason(Combatant, Spell)` | `string` | Human-readable failure reason |
| `IsConcentrating(Combatant)` | `bool` | Check if maintaining concentration |
| `BreakConcentration(Combatant)` | `void` | Force-end concentration spell |

### 2. MagicResult Record

**File:** `RuneAndRust.Core/Models/Magic/MagicResult.cs`

| Property | Type | Description |
|----------|------|-------------|
| `Success` | `bool` | Whether cast succeeded |
| `Message` | `string` | Player-facing narrative |
| `FailureReason` | `CastFailureReason?` | Why cast failed (if applicable) |
| `TotalDamage` | `int` | Damage dealt |
| `TotalHealing` | `int` | Healing done |
| `StatusesApplied` | `List<string>?` | Status effects applied |
| `FluxAdded` | `int` | Flux added to environment |
| `WasCharged` | `bool` | Whether this was a charged release |
| `IsCharging` | `bool` | Whether charge initiated (not released) |

**Static Factory Methods:**
- `Success(message, damage, healing, statuses, flux)`
- `Failure(reason, message)`
- `Charging(message)`

### 3. CastFailureReason Enum

**File:** `RuneAndRust.Core/Enums/CastFailureReason.cs`

| Value | Int | Description |
|-------|-----|-------------|
| `UnknownSpell` | 0 | Spell not found in repository |
| `InsufficientAp` | 1 | Not enough Aether Points |
| `InvalidTarget` | 2 | Target doesn't match spell's TargetType |
| `OutOfRange` | 3 | Target beyond spell's Range |
| `Silenced` | 4 | Caster has Silenced status effect |
| `AlreadyConcentrating` | 5 | Caster already concentrating on another spell |
| `NotMystic` | 6 | Character archetype cannot cast spells |
| `NotPlayerTurn` | 7 | Attempted cast outside player's turn |
| `NoCombatActive` | 8 | Attempted cast outside combat |
| `TargetDead` | 9 | Target has 0 or less HP |
| `InterruptedCharge` | 10 | Charged spell was interrupted |

### 4. SpellCastEvent Record

**File:** `RuneAndRust.Core/Events/SpellCastEvent.cs`

| Property | Type | Description |
|----------|------|-------------|
| `CasterId` | `Guid` | Who cast the spell |
| `CasterName` | `string` | Caster display name |
| `SpellId` | `Guid` | Which spell was cast |
| `SpellName` | `string` | Spell display name |
| `SpellSchool` | `SpellSchool` | Magic school |
| `TargetId` | `Guid` | Who was targeted |
| `TargetName` | `string` | Target display name |
| `ApCost` | `int` | AP consumed |
| `FluxAdded` | `int` | Flux added to environment |
| `TotalDamage` | `int` | Damage dealt |
| `TotalHealing` | `int` | Healing done |
| `WasCharged` | `bool` | Whether released from charge |

---

## Code Implementation

### 1. IMagicService.cs

```csharp
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Models.Combat;
using RuneAndRust.Core.Models.Magic;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service contract for spell casting and magic execution.
/// Orchestrates AP consumption, Flux accumulation, and effect resolution.
/// </summary>
/// <remarks>
/// See: v0.4.3c (The Incantation) for MagicService implementation.
/// </remarks>
public interface IMagicService
{
    /// <summary>
    /// Validates whether a caster can cast a specific spell on a target.
    /// Checks AP, target type, range, concentration, and status effects.
    /// </summary>
    /// <param name="caster">The combatant attempting to cast.</param>
    /// <param name="target">The intended target.</param>
    /// <param name="spell">The spell to cast.</param>
    /// <returns>Tuple of (canCast, failureReason if cannot cast).</returns>
    (bool CanCast, CastFailureReason? Reason) CanCast(Combatant caster, Combatant target, Spell spell);

    /// <summary>
    /// Executes a spell cast, consuming resources and applying effects.
    /// </summary>
    /// <param name="caster">The combatant casting the spell.</param>
    /// <param name="target">The target of the spell.</param>
    /// <param name="spell">The spell to cast.</param>
    /// <returns>Result containing success/failure, damage, healing, and narrative.</returns>
    MagicResult CastSpell(Combatant caster, Combatant target, Spell spell);

    /// <summary>
    /// Gets all spells available to a caster based on their archetype and tier.
    /// </summary>
    /// <param name="caster">The combatant to check spells for.</param>
    /// <returns>Available spells.</returns>
    Task<IEnumerable<Spell>> GetAvailableSpellsAsync(Combatant caster);

    /// <summary>
    /// Gets a human-readable reason why a spell cannot be cast.
    /// </summary>
    /// <param name="caster">The caster.</param>
    /// <param name="spell">The spell.</param>
    /// <returns>Descriptive failure message.</returns>
    string GetCannotCastReason(Combatant caster, Spell spell);

    /// <summary>
    /// Checks if a caster is currently concentrating on a spell.
    /// </summary>
    /// <param name="caster">The combatant to check.</param>
    /// <returns>True if concentrating.</returns>
    bool IsConcentrating(Combatant caster);

    /// <summary>
    /// Forces a caster to break concentration, ending the maintained spell.
    /// </summary>
    /// <param name="caster">The combatant to break concentration for.</param>
    void BreakConcentration(Combatant caster);
}
```

### 2. MagicResult.cs

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Represents the outcome of a spell casting attempt.
/// Contains success/failure status, effects applied, and narrative message.
/// </summary>
/// <remarks>
/// See: v0.4.3c (The Incantation) for MagicService implementation.
/// </remarks>
public record MagicResult
{
    /// <summary>
    /// Whether the spell was successfully cast.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Player-facing narrative message.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Why the cast failed, if applicable.
    /// </summary>
    public CastFailureReason? FailureReason { get; init; }

    /// <summary>
    /// Total damage dealt by the spell.
    /// </summary>
    public int TotalDamage { get; init; }

    /// <summary>
    /// Total healing done by the spell.
    /// </summary>
    public int TotalHealing { get; init; }

    /// <summary>
    /// Status effects applied by the spell.
    /// </summary>
    public List<string>? StatusesApplied { get; init; }

    /// <summary>
    /// Flux added to the environment by this cast.
    /// </summary>
    public int FluxAdded { get; init; }

    /// <summary>
    /// Whether this was a charged spell being released.
    /// </summary>
    public bool WasCharged { get; init; }

    /// <summary>
    /// Whether the caster is now charging (not yet released).
    /// </summary>
    public bool IsCharging { get; init; }

    /// <summary>
    /// Creates a successful cast result.
    /// </summary>
    public static MagicResult Successful(
        string message,
        int damage = 0,
        int healing = 0,
        List<string>? statuses = null,
        int fluxAdded = 0,
        bool wasCharged = false)
    {
        return new MagicResult
        {
            Success = true,
            Message = message,
            TotalDamage = damage,
            TotalHealing = healing,
            StatusesApplied = statuses,
            FluxAdded = fluxAdded,
            WasCharged = wasCharged
        };
    }

    /// <summary>
    /// Creates a failed cast result.
    /// </summary>
    public static MagicResult Failure(CastFailureReason reason, string message)
    {
        return new MagicResult
        {
            Success = false,
            Message = message,
            FailureReason = reason
        };
    }

    /// <summary>
    /// Creates a charging result (spell initiated but not released).
    /// </summary>
    public static MagicResult Charging(string message, int fluxAdded = 0)
    {
        return new MagicResult
        {
            Success = true,
            Message = message,
            IsCharging = true,
            FluxAdded = fluxAdded
        };
    }
}
```

### 3. CastFailureReason.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Reasons why a spell cast may fail validation.
/// </summary>
/// <remarks>
/// See: v0.4.3c (The Incantation) for MagicService implementation.
/// </remarks>
public enum CastFailureReason
{
    /// <summary>
    /// The spell name was not found in the repository.
    /// </summary>
    UnknownSpell = 0,

    /// <summary>
    /// The caster does not have enough Aether Points.
    /// </summary>
    InsufficientAp = 1,

    /// <summary>
    /// The target is not valid for this spell's TargetType.
    /// </summary>
    InvalidTarget = 2,

    /// <summary>
    /// The target is beyond the spell's range.
    /// </summary>
    OutOfRange = 3,

    /// <summary>
    /// The caster has the Silenced status effect.
    /// </summary>
    Silenced = 4,

    /// <summary>
    /// The caster is already concentrating on another spell.
    /// </summary>
    AlreadyConcentrating = 5,

    /// <summary>
    /// The character's archetype cannot cast spells.
    /// </summary>
    NotMystic = 6,

    /// <summary>
    /// Attempted to cast outside the player's turn.
    /// </summary>
    NotPlayerTurn = 7,

    /// <summary>
    /// Attempted to cast outside of combat.
    /// </summary>
    NoCombatActive = 8,

    /// <summary>
    /// The target is dead (0 or less HP).
    /// </summary>
    TargetDead = 9,

    /// <summary>
    /// A charged spell was interrupted before release.
    /// </summary>
    InterruptedCharge = 10
}
```

### 4. SpellCastEvent.cs

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Events;

/// <summary>
/// Published when a spell is successfully cast.
/// Consumed by UI for visual effects and audio for sound cues.
/// </summary>
/// <remarks>
/// See: v0.4.3c (The Incantation) for MagicService implementation.
/// </remarks>
/// <param name="CasterId">Unique ID of the caster.</param>
/// <param name="CasterName">Display name of the caster.</param>
/// <param name="SpellId">Unique ID of the spell cast.</param>
/// <param name="SpellName">Display name of the spell.</param>
/// <param name="SpellSchool">School of magic.</param>
/// <param name="TargetId">Unique ID of the target.</param>
/// <param name="TargetName">Display name of the target.</param>
/// <param name="ApCost">Aether Points consumed.</param>
/// <param name="FluxAdded">Flux added to the environment.</param>
/// <param name="TotalDamage">Damage dealt.</param>
/// <param name="TotalHealing">Healing done.</param>
/// <param name="WasCharged">Whether this was a charged spell release.</param>
public record SpellCastEvent(
    Guid CasterId,
    string CasterName,
    Guid SpellId,
    string SpellName,
    SpellSchool SpellSchool,
    Guid TargetId,
    string TargetName,
    int ApCost,
    int FluxAdded,
    int TotalDamage,
    int TotalHealing,
    bool WasCharged)
{
    /// <summary>
    /// Returns true if the spell dealt damage.
    /// </summary>
    public bool DealtDamage => TotalDamage > 0;

    /// <summary>
    /// Returns true if the spell healed the target.
    /// </summary>
    public bool DidHealing => TotalHealing > 0;

    /// <summary>
    /// Returns true if the caster targeted themselves.
    /// </summary>
    public bool WasSelfTargeted => CasterId == TargetId;
}
```

### 5. MagicService.cs

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Combat;
using RuneAndRust.Core.Models.Magic;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Service for spell casting and magic execution.
/// Orchestrates AP consumption, Flux accumulation, and effect resolution.
/// </summary>
/// <remarks>
/// See: v0.4.3c (The Incantation) for MagicService implementation.
/// </remarks>
public class MagicService : IMagicService
{
    private readonly ISpellRepository _spellRepository;
    private readonly IResourceService _resourceService;
    private readonly IAetherService _aetherService;
    private readonly IStatusEffectService _statusEffects;
    private readonly EffectScriptExecutor _effectExecutor;
    private readonly IEventBus _eventBus;
    private readonly ILogger<MagicService> _logger;

    /// <summary>
    /// Status effect type for spell charging/channeling.
    /// </summary>
    private const StatusEffectType ChantingEffect = StatusEffectType.Chanting;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicService"/> class.
    /// </summary>
    public MagicService(
        ISpellRepository spellRepository,
        IResourceService resourceService,
        IAetherService aetherService,
        IStatusEffectService statusEffects,
        EffectScriptExecutor effectExecutor,
        IEventBus eventBus,
        ILogger<MagicService> logger)
    {
        _spellRepository = spellRepository;
        _resourceService = resourceService;
        _aetherService = aetherService;
        _statusEffects = statusEffects;
        _effectExecutor = effectExecutor;
        _eventBus = eventBus;
        _logger = logger;

        _logger.LogDebug("[Magic] MagicService initialized");
    }

    /// <inheritdoc/>
    public (bool CanCast, CastFailureReason? Reason) CanCast(Combatant caster, Combatant target, Spell spell)
    {
        _logger.LogDebug("[Magic] Validating cast: {Caster} → {Spell} → {Target}",
            caster.Name, spell.Name, target.Name);

        // 1. Check if caster can use magic (Mystic archetype or universal spell)
        if (!CanUseMagic(caster, spell))
        {
            _logger.LogDebug("[Magic] {Caster} cannot use magic (not Mystic)", caster.Name);
            return (false, CastFailureReason.NotMystic);
        }

        // 2. Check Aether Points (with Overcast consideration)
        if (!_resourceService.CanAfford(caster, ResourceType.Aether, spell.ApCost))
        {
            _logger.LogDebug("[Magic] {Caster} cannot afford {Cost} AP (has {Current})",
                caster.Name, spell.ApCost, caster.CurrentAp);
            return (false, CastFailureReason.InsufficientAp);
        }

        // 3. Check target validity
        if (!IsValidTarget(caster, target, spell))
        {
            _logger.LogDebug("[Magic] Invalid target: {Target} for {Spell} (TargetType: {Type})",
                target.Name, spell.Name, spell.TargetType);
            return (false, CastFailureReason.InvalidTarget);
        }

        // 4. Check range
        if (!IsInRange(caster, target, spell))
        {
            _logger.LogDebug("[Magic] Target {Target} out of range for {Spell} (Range: {Range})",
                target.Name, spell.Name, spell.Range);
            return (false, CastFailureReason.OutOfRange);
        }

        // 5. Check target is alive
        if (target.CurrentHp <= 0)
        {
            _logger.LogDebug("[Magic] Target {Target} is dead", target.Name);
            return (false, CastFailureReason.TargetDead);
        }

        // 6. Check Silenced status
        if (_statusEffects.HasEffect(caster, StatusEffectType.Silenced))
        {
            _logger.LogDebug("[Magic] {Caster} is Silenced", caster.Name);
            return (false, CastFailureReason.Silenced);
        }

        // 7. Check concentration conflict
        if (spell.RequiresConcentration && IsConcentrating(caster))
        {
            _logger.LogDebug("[Magic] {Caster} already concentrating", caster.Name);
            return (false, CastFailureReason.AlreadyConcentrating);
        }

        _logger.LogDebug("[Magic] Validation passed for {Caster} casting {Spell}",
            caster.Name, spell.Name);
        return (true, null);
    }

    /// <inheritdoc/>
    public MagicResult CastSpell(Combatant caster, Combatant target, Spell spell)
    {
        _logger.LogInformation("[Magic] {Caster} attempting to cast {Spell} on {Target}",
            caster.Name, spell.Name, target.Name);

        // 1. Validate
        var (canCast, reason) = CanCast(caster, target, spell);
        if (!canCast)
        {
            var failureMessage = GetFailureMessage(reason!.Value, caster, spell);
            _logger.LogDebug("[Magic] Cast failed: {Reason}", reason);
            return MagicResult.Failure(reason.Value, failureMessage);
        }

        // 2. Check for charged spell initiation
        if (spell.ChargeTurns > 0 && !_statusEffects.HasEffect(caster, ChantingEffect))
        {
            return InitiateCharge(caster, spell);
        }

        // 3. Check for charged spell release
        if (spell.ChargeTurns > 0 &&
            _statusEffects.HasEffect(caster, ChantingEffect) &&
            caster.ChanneledAbilityId == spell.Id)
        {
            return ReleaseCharge(caster, target, spell);
        }

        // 4. Instant cast execution
        return ExecuteInstantCast(caster, target, spell);
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<Spell>> GetAvailableSpellsAsync(Combatant caster)
    {
        _logger.LogDebug("[Magic] Getting available spells for {Caster}", caster.Name);

        // Determine archetype and tier from source character
        var archetype = caster.CharacterSource?.Archetype ?? ArchetypeType.Mystic;
        var tier = (caster.CharacterSource?.Level ?? 1) / 3 + 1;

        var spells = await _spellRepository.GetAvailableForCasterAsync(archetype, tier);

        _logger.LogDebug("[Magic] Found {Count} available spells for {Caster}",
            spells.Count(), caster.Name);

        return spells;
    }

    /// <inheritdoc/>
    public string GetCannotCastReason(Combatant caster, Spell spell)
    {
        // Check each condition and return specific message
        if (!CanUseMagic(caster, spell))
            return "Only Mystics can cast spells.";

        if (!_resourceService.CanAfford(caster, ResourceType.Aether, spell.ApCost))
            return $"Not enough Aether. Need {spell.ApCost} AP, have {caster.CurrentAp}.";

        if (_statusEffects.HasEffect(caster, StatusEffectType.Silenced))
            return "You are Silenced and cannot cast spells.";

        if (spell.RequiresConcentration && IsConcentrating(caster))
            return "You are already concentrating on another spell.";

        return $"Cannot cast {spell.Name}.";
    }

    /// <inheritdoc/>
    public bool IsConcentrating(Combatant caster)
    {
        return caster.ChanneledAbilityId != null &&
               _statusEffects.HasEffect(caster, StatusEffectType.Concentrating);
    }

    /// <inheritdoc/>
    public void BreakConcentration(Combatant caster)
    {
        if (!IsConcentrating(caster))
            return;

        _logger.LogInformation("[Magic] Breaking concentration for {Caster}", caster.Name);

        caster.ChanneledAbilityId = null;
        _statusEffects.RemoveEffect(caster, StatusEffectType.Concentrating);
    }

    #region Private Methods

    /// <summary>
    /// Executes an instant (non-charged) spell.
    /// </summary>
    private MagicResult ExecuteInstantCast(Combatant caster, Combatant target, Spell spell)
    {
        _logger.LogDebug("[Magic] Executing instant cast: {Spell}", spell.Name);

        // Deduct AP
        _resourceService.Deduct(caster, ResourceType.Aether, spell.ApCost);
        _logger.LogDebug("[Magic] Deducted {Cost} AP from {Caster}. Remaining: {Remaining}",
            spell.ApCost, caster.Name, caster.CurrentAp);

        // Add Flux
        _aetherService.ModifyFlux(spell.FluxCost, $"Cast {spell.Name}");
        _logger.LogDebug("[Magic] Added {Flux} Flux to environment", spell.FluxCost);

        // Execute effect script
        var effectResult = _effectExecutor.Execute(
            spell.EffectScript,
            target,
            caster.Name,
            caster.Id);

        _logger.LogInformation(
            "[Magic] {Caster} cast {Spell} on {Target}. Damage: {Damage}, Healing: {Healing}",
            caster.Name, spell.Name, target.Name, effectResult.TotalDamage, effectResult.TotalHealing);

        // Apply concentration if needed
        if (spell.RequiresConcentration)
        {
            caster.ChanneledAbilityId = spell.Id;
            _statusEffects.ApplyEffect(caster, StatusEffectType.Concentrating, 99, caster.Id);
            _logger.LogDebug("[Magic] {Caster} is now concentrating on {Spell}", caster.Name, spell.Name);
        }

        // Publish event
        PublishSpellCastEvent(caster, target, spell, effectResult, wasCharged: false);

        // Build result message
        var message = BuildCastMessage(caster, target, spell, effectResult);

        return MagicResult.Successful(
            message,
            effectResult.TotalDamage,
            effectResult.TotalHealing,
            effectResult.StatusesApplied,
            spell.FluxCost);
    }

    /// <summary>
    /// Initiates a charged spell (does not release yet).
    /// </summary>
    private MagicResult InitiateCharge(Combatant caster, Spell spell)
    {
        _logger.LogInformation("[Magic] {Caster} begins charging {Spell}", caster.Name, spell.Name);

        // Deduct AP immediately
        _resourceService.Deduct(caster, ResourceType.Aether, spell.ApCost);

        // Add partial Flux (half now, half on release)
        var partialFlux = spell.FluxCost / 2;
        _aetherService.ModifyFlux(partialFlux, $"Charging {spell.Name}");

        // Apply Chanting status
        _statusEffects.ApplyEffect(caster, ChantingEffect, spell.ChargeTurns, caster.Id);

        // Store channeled spell
        caster.ChanneledAbilityId = spell.Id;

        // Build telegraph message
        var message = !string.IsNullOrEmpty(spell.TelegraphMessage)
            ? spell.TelegraphMessage
            : $"{caster.Name} begins channeling {spell.Name}...";

        _logger.LogDebug("[Magic] Charge initiated. Turns remaining: {Turns}", spell.ChargeTurns);

        return MagicResult.Charging($"⚠ {message}", partialFlux);
    }

    /// <summary>
    /// Releases a fully charged spell.
    /// </summary>
    private MagicResult ReleaseCharge(Combatant caster, Combatant target, Spell spell)
    {
        _logger.LogInformation("[Magic] {Caster} releases {Spell} on {Target}",
            caster.Name, spell.Name, target.Name);

        // Clear channeling state
        caster.ChanneledAbilityId = null;
        _statusEffects.RemoveEffect(caster, ChantingEffect);

        // Add remaining Flux
        var remainingFlux = spell.FluxCost - (spell.FluxCost / 2);
        _aetherService.ModifyFlux(remainingFlux, $"Release {spell.Name}");

        // Execute effect
        var effectResult = _effectExecutor.Execute(
            spell.EffectScript,
            target,
            caster.Name,
            caster.Id);

        _logger.LogInformation(
            "[Magic] Charged spell released. Damage: {Damage}, Healing: {Healing}",
            effectResult.TotalDamage, effectResult.TotalHealing);

        // Publish event
        PublishSpellCastEvent(caster, target, spell, effectResult, wasCharged: true);

        // Build release message
        var message = $"{caster.Name} unleashes {spell.Name}! {effectResult.Narrative}";

        return MagicResult.Successful(
            message,
            effectResult.TotalDamage,
            effectResult.TotalHealing,
            effectResult.StatusesApplied,
            remainingFlux,
            wasCharged: true);
    }

    /// <summary>
    /// Checks if a caster can use magic (Mystic or universal spell).
    /// </summary>
    private static bool CanUseMagic(Combatant caster, Spell spell)
    {
        // Universal spells can be used by anyone
        if (spell.Archetype == null)
            return true;

        // Check archetype
        var archetype = caster.CharacterSource?.Archetype;
        return archetype == ArchetypeType.Mystic || archetype == spell.Archetype;
    }

    /// <summary>
    /// Validates target against spell's TargetType.
    /// </summary>
    private static bool IsValidTarget(Combatant caster, Combatant target, Spell spell)
    {
        return spell.TargetType switch
        {
            SpellTargetType.Self => target == caster,
            SpellTargetType.SingleEnemy => !target.IsPlayer && target != caster,
            SpellTargetType.SingleAlly => target.IsPlayer && target != caster,
            SpellTargetType.AllEnemies => !target.IsPlayer,
            SpellTargetType.AllAllies => target.IsPlayer,
            SpellTargetType.SingleAny => true,
            SpellTargetType.Area => true,
            _ => false
        };
    }

    /// <summary>
    /// Validates target is within spell's range.
    /// </summary>
    private static bool IsInRange(Combatant caster, Combatant target, Spell spell)
    {
        // Self-targeted spells are always in range
        if (spell.Range == SpellRange.Self || target == caster)
            return true;

        // For now, use simple range categories
        // Future: integrate with spatial grid for precise distance
        var distance = GetApproximateDistance(caster, target);
        var maxRange = GetRangeValue(spell.Range);

        return distance <= maxRange;
    }

    /// <summary>
    /// Gets approximate distance between combatants.
    /// </summary>
    private static int GetApproximateDistance(Combatant caster, Combatant target)
    {
        // If spatial positions available, use them
        if (caster.Position != null && target.Position != null)
        {
            var dx = Math.Abs(caster.Position.X - target.Position.X);
            var dy = Math.Abs(caster.Position.Y - target.Position.Y);
            return Math.Max(dx, dy); // Chebyshev distance
        }

        // Fallback: all combatants considered at Close range
        return 2;
    }

    /// <summary>
    /// Converts SpellRange enum to numeric value.
    /// </summary>
    private static int GetRangeValue(SpellRange range)
    {
        return range switch
        {
            SpellRange.Self => 0,
            SpellRange.Touch => 1,
            SpellRange.Close => 3,
            SpellRange.Medium => 6,
            SpellRange.Far => 10,
            _ => 3
        };
    }

    /// <summary>
    /// Gets human-readable failure message.
    /// </summary>
    private string GetFailureMessage(CastFailureReason reason, Combatant caster, Spell spell)
    {
        return reason switch
        {
            CastFailureReason.UnknownSpell => $"Unknown spell: {spell.Name}",
            CastFailureReason.InsufficientAp => $"Not enough Aether. Need {spell.ApCost} AP, have {caster.CurrentAp}.",
            CastFailureReason.InvalidTarget => "Invalid target for this spell.",
            CastFailureReason.OutOfRange => "Target is out of range.",
            CastFailureReason.Silenced => "You are Silenced and cannot cast spells.",
            CastFailureReason.AlreadyConcentrating => "You are already concentrating on another spell.",
            CastFailureReason.NotMystic => "Only Mystics can cast spells.",
            CastFailureReason.TargetDead => "Target is already dead.",
            _ => $"Cannot cast {spell.Name}."
        };
    }

    /// <summary>
    /// Builds the narrative message for a successful cast.
    /// </summary>
    private static string BuildCastMessage(
        Combatant caster,
        Combatant target,
        Spell spell,
        EffectScriptResult effectResult)
    {
        var targetText = target == caster ? "self" : target.Name;
        var baseMessage = $"{caster.Name} casts {spell.Name} on {targetText}!";

        if (!string.IsNullOrEmpty(effectResult.Narrative))
        {
            return $"{baseMessage} {effectResult.Narrative}";
        }

        return baseMessage;
    }

    /// <summary>
    /// Publishes SpellCastEvent to the event bus.
    /// </summary>
    private void PublishSpellCastEvent(
        Combatant caster,
        Combatant target,
        Spell spell,
        EffectScriptResult effectResult,
        bool wasCharged)
    {
        var spellEvent = new SpellCastEvent(
            caster.Id,
            caster.Name,
            spell.Id,
            spell.Name,
            spell.School,
            target.Id,
            target.Name,
            spell.ApCost,
            spell.FluxCost,
            effectResult.TotalDamage,
            effectResult.TotalHealing,
            wasCharged);

        _eventBus.Publish(spellEvent);

        _logger.LogDebug("[Magic] Published SpellCastEvent: {Spell} by {Caster}",
            spell.Name, caster.Name);
    }

    #endregion
}
```

### 6. CombatService Extension (ExecutePlayerSpell)

Add to `CombatService.cs`:

```csharp
private readonly IMagicService _magicService;
private readonly ISpellRepository _spellRepository;

// Add to constructor parameters and assignments

/// <summary>
/// Executes a player spell cast by spell name.
/// </summary>
/// <param name="spellName">Name of the spell to cast.</param>
/// <param name="targetName">Optional explicit target name.</param>
/// <returns>Result message for display.</returns>
public async Task<string> ExecutePlayerSpellAsync(string spellName, string? targetName = null)
{
    var state = _gameState.CombatState;

    // 1. Validate combat state
    if (state == null)
    {
        return "You are not in combat.";
    }

    if (!state.IsPlayerTurn)
    {
        return "It is not your turn.";
    }

    var caster = state.ActiveCombatant!;

    // 2. Look up spell
    var spell = await _spellRepository.GetByNameAsync(spellName);
    if (spell == null)
    {
        return $"Unknown spell: '{spellName}'. Use 'spells' to see available spells.";
    }

    // 3. Resolve target
    var target = ResolveSpellTarget(spell, targetName, state);
    if (target == null)
    {
        var enemies = state.TurnOrder.Where(c => !c.IsPlayer && c.CurrentHp > 0).ToList();
        if (enemies.Count > 1)
        {
            var names = string.Join(", ", enemies.Select(e => e.Name));
            return $"Multiple targets available: {names}. Specify with 'cast {spell.Name} on <target>'.";
        }
        return $"No valid target for {spell.Name}.";
    }

    // 4. Execute via MagicService
    var result = _magicService.CastSpell(caster, target, spell);

    // 5. Log to combat log
    if (result.Success)
    {
        var logMessage = BuildSpellLogMessage(spell, result, target, caster);
        LogCombatEvent(logMessage);
    }

    // 6. Check for target death
    if (result.Success && target.CurrentHp <= 0 && target != caster)
    {
        RemoveDefeatedCombatant(target);
        if (CheckVictoryCondition())
        {
            return $"{result.Message} VICTORY! All enemies defeated!";
        }
    }

    // 7. Process turn end for caster
    if (result.Success && !result.IsCharging)
    {
        _statusEffects.ProcessTurnEnd(caster);
    }

    return result.Message;
}

/// <summary>
/// Resolves the target for a spell based on TargetType and explicit name.
/// </summary>
private Combatant? ResolveSpellTarget(Spell spell, string? targetName, CombatState state)
{
    var caster = state.ActiveCombatant!;

    // Self-targeting
    if (spell.TargetType == SpellTargetType.Self || spell.Range == SpellRange.Self)
    {
        return caster;
    }

    var enemies = state.TurnOrder.Where(c => !c.IsPlayer && c.CurrentHp > 0).ToList();
    var allies = state.TurnOrder.Where(c => c.IsPlayer && c.CurrentHp > 0 && c != caster).ToList();

    // Explicit target specified
    if (!string.IsNullOrWhiteSpace(targetName))
    {
        // Search based on target type
        if (spell.TargetType is SpellTargetType.SingleEnemy or SpellTargetType.AllEnemies)
        {
            return enemies.FirstOrDefault(e =>
                e.Name.Contains(targetName, StringComparison.OrdinalIgnoreCase));
        }

        if (spell.TargetType is SpellTargetType.SingleAlly or SpellTargetType.AllAllies)
        {
            return allies.FirstOrDefault(a =>
                a.Name.Contains(targetName, StringComparison.OrdinalIgnoreCase));
        }

        if (spell.TargetType == SpellTargetType.SingleAny)
        {
            var all = state.TurnOrder.Where(c => c.CurrentHp > 0);
            return all.FirstOrDefault(c =>
                c.Name.Contains(targetName, StringComparison.OrdinalIgnoreCase));
        }
    }

    // Auto-target single enemy
    if (spell.TargetType is SpellTargetType.SingleEnemy or SpellTargetType.AllEnemies)
    {
        return enemies.Count == 1 ? enemies[0] : null;
    }

    // Auto-target single ally
    if (spell.TargetType is SpellTargetType.SingleAlly or SpellTargetType.AllAllies)
    {
        return allies.Count == 1 ? allies[0] : null;
    }

    return null;
}

/// <summary>
/// Builds Spectre.Console formatted log message for spell cast.
/// </summary>
private static string BuildSpellLogMessage(
    Spell spell,
    MagicResult result,
    Combatant target,
    Combatant caster)
{
    var targetText = target == caster
        ? "[cyan]self[/]"
        : $"[red]{target.Name}[/]";

    var effectParts = new List<string>();

    if (result.TotalDamage > 0)
        effectParts.Add($"[red]{result.TotalDamage}[/] damage");

    if (result.TotalHealing > 0)
        effectParts.Add($"[green]{result.TotalHealing}[/] HP");

    if (result.StatusesApplied?.Count > 0)
        effectParts.Add($"[purple]{string.Join(", ", result.StatusesApplied)}[/]");

    if (result.FluxAdded > 0)
        effectParts.Add($"[yellow]+{result.FluxAdded}[/] Flux");

    var effects = effectParts.Count > 0
        ? $" ({string.Join(", ", effectParts)})"
        : "";

    return $"[cyan]{caster.Name}[/] casts [magenta]{spell.Name}[/] on {targetText}!{effects}";
}
```

### 7. CommandParser Extension (Cast Command)

Add to `HandleCombat()` method in `CommandParser.cs`:

```csharp
// Add near top of HandleCombat method, after attack commands:

// Cast spell commands
if (command.StartsWith("cast "))
{
    return await ExecuteCastCommandAsync(command.Substring(5).Trim());
}
```

Add new method:

```csharp
/// <summary>
/// Handles the "cast [spell] [on target]" command.
/// </summary>
private async Task<ParseResult> ExecuteCastCommandAsync(string args)
{
    _logger.LogDebug("[Parser] Parsing cast command: '{Args}'", args);

    if (string.IsNullOrWhiteSpace(args))
    {
        _inputHandler.DisplayMessage("Usage: cast <spell> [on <target>]");
        _inputHandler.DisplayMessage("Example: cast spark on goblin");
        return ParseResult.None;
    }

    // Parse "spell on target" or "spell at target"
    string spellName;
    string? targetName = null;

    var onIndex = args.IndexOf(" on ", StringComparison.OrdinalIgnoreCase);
    var atIndex = args.IndexOf(" at ", StringComparison.OrdinalIgnoreCase);
    var separatorIndex = onIndex >= 0 ? onIndex : atIndex;

    if (separatorIndex >= 0)
    {
        spellName = args[..separatorIndex].Trim();
        targetName = args[(separatorIndex + 4)..].Trim();
    }
    else
    {
        spellName = args.Trim();
    }

    _logger.LogDebug("[Parser] Parsed cast: spell='{Spell}', target='{Target}'",
        spellName, targetName ?? "(auto)");

    // Execute via CombatService
    if (_combatService == null)
    {
        _inputHandler.DisplayMessage("Not in combat.");
        return ParseResult.None;
    }

    var result = await _combatService.ExecutePlayerSpellAsync(spellName, targetName);
    _inputHandler.DisplayMessage(result);

    // Check for victory
    if (_combatService.CheckVictoryCondition())
    {
        var combatResult = _combatService.EndCombat();
        if (combatResult?.Victory == true && _victoryRenderer != null)
        {
            _victoryRenderer.Render(combatResult);
        }
        return new ParseResult { RequiresLook = true };
    }

    // Advance turn
    _combatService.NextTurn();
    DisplayCombatTurnInfo();

    return ParseResult.None;
}
```

### 8. DI Registration (Program.cs)

```csharp
// Add after other service registrations:

// v0.4.3c: Magic Service
services.AddSingleton<IMagicService, MagicService>();
```

---

## Logging Matrix

### MagicService Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| Constructor | Initialized | Debug | `"[Magic] MagicService initialized"` | - |
| CanCast | Validating | Debug | `"[Magic] Validating cast: {Caster} → {Spell} → {Target}"` | Caster, Spell, Target |
| CanCast | NotMystic | Debug | `"[Magic] {Caster} cannot use magic (not Mystic)"` | Caster |
| CanCast | InsufficientAp | Debug | `"[Magic] {Caster} cannot afford {Cost} AP (has {Current})"` | Caster, Cost, Current |
| CanCast | InvalidTarget | Debug | `"[Magic] Invalid target: {Target} for {Spell} (TargetType: {Type})"` | Target, Spell, Type |
| CanCast | OutOfRange | Debug | `"[Magic] Target {Target} out of range for {Spell} (Range: {Range})"` | Target, Spell, Range |
| CanCast | TargetDead | Debug | `"[Magic] Target {Target} is dead"` | Target |
| CanCast | Silenced | Debug | `"[Magic] {Caster} is Silenced"` | Caster |
| CanCast | AlreadyConcentrating | Debug | `"[Magic] {Caster} already concentrating"` | Caster |
| CanCast | ValidationPassed | Debug | `"[Magic] Validation passed for {Caster} casting {Spell}"` | Caster, Spell |
| CastSpell | Attempting | Info | `"[Magic] {Caster} attempting to cast {Spell} on {Target}"` | Caster, Spell, Target |
| CastSpell | Failed | Debug | `"[Magic] Cast failed: {Reason}"` | Reason |
| ExecuteInstantCast | Executing | Debug | `"[Magic] Executing instant cast: {Spell}"` | Spell |
| ExecuteInstantCast | ApDeducted | Debug | `"[Magic] Deducted {Cost} AP from {Caster}. Remaining: {Remaining}"` | Cost, Caster, Remaining |
| ExecuteInstantCast | FluxAdded | Debug | `"[Magic] Added {Flux} Flux to environment"` | Flux |
| ExecuteInstantCast | Complete | Info | `"[Magic] {Caster} cast {Spell} on {Target}. Damage: {Damage}, Healing: {Healing}"` | Caster, Spell, Target, Damage, Healing |
| ExecuteInstantCast | Concentrating | Debug | `"[Magic] {Caster} is now concentrating on {Spell}"` | Caster, Spell |
| InitiateCharge | Starting | Info | `"[Magic] {Caster} begins charging {Spell}"` | Caster, Spell |
| InitiateCharge | Initiated | Debug | `"[Magic] Charge initiated. Turns remaining: {Turns}"` | Turns |
| ReleaseCharge | Releasing | Info | `"[Magic] {Caster} releases {Spell} on {Target}"` | Caster, Spell, Target |
| ReleaseCharge | Released | Info | `"[Magic] Charged spell released. Damage: {Damage}, Healing: {Healing}"` | Damage, Healing |
| PublishSpellCastEvent | Published | Debug | `"[Magic] Published SpellCastEvent: {Spell} by {Caster}"` | Spell, Caster |
| GetAvailableSpellsAsync | Fetching | Debug | `"[Magic] Getting available spells for {Caster}"` | Caster |
| GetAvailableSpellsAsync | Found | Debug | `"[Magic] Found {Count} available spells for {Caster}"` | Count, Caster |
| BreakConcentration | Breaking | Info | `"[Magic] Breaking concentration for {Caster}"` | Caster |

### CommandParser Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| ExecuteCastCommandAsync | Parsing | Debug | `"[Parser] Parsing cast command: '{Args}'"` | Args |
| ExecuteCastCommandAsync | Parsed | Debug | `"[Parser] Parsed cast: spell='{Spell}', target='{Target}'"` | Spell, Target |

---

## Unit Testing Specification

### Test Class: MagicServiceTests.cs

**File:** `RuneAndRust.Tests/Engine/Services/MagicServiceTests.cs`

#### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| CanCast Validation | 12 | All failure reasons |
| CastSpell Success | 8 | Various spell types and targets |
| Resource Integration | 6 | AP deduction, Overcast |
| Flux Integration | 5 | Flux accumulation |
| Charged Spells | 8 | Initiate, release, interrupt |
| Target Resolution | 6 | Auto-target, explicit target |
| Event Publishing | 4 | SpellCastEvent verification |
| Edge Cases | 4 | Empty scripts, null handling |

**Total: 53 tests**

#### Key Test Specifications

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using NSubstitute;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Combat;
using RuneAndRust.Engine.Services;
using Xunit;

namespace RuneAndRust.Tests.Engine.Services;

/// <summary>
/// Unit tests for MagicService (v0.4.3c - The Incantation).
/// </summary>
public class MagicServiceTests
{
    private readonly ISpellRepository _mockSpellRepo;
    private readonly IResourceService _mockResourceService;
    private readonly IAetherService _mockAetherService;
    private readonly IStatusEffectService _mockStatusEffects;
    private readonly EffectScriptExecutor _mockEffectExecutor;
    private readonly IEventBus _mockEventBus;
    private readonly ILogger<MagicService> _mockLogger;
    private readonly MagicService _sut;

    public MagicServiceTests()
    {
        _mockSpellRepo = Substitute.For<ISpellRepository>();
        _mockResourceService = Substitute.For<IResourceService>();
        _mockAetherService = Substitute.For<IAetherService>();
        _mockStatusEffects = Substitute.For<IStatusEffectService>();
        _mockEffectExecutor = Substitute.For<EffectScriptExecutor>();
        _mockEventBus = Substitute.For<IEventBus>();
        _mockLogger = Substitute.For<ILogger<MagicService>>();

        // Default: can afford resources
        _mockResourceService.CanAfford(Arg.Any<Combatant>(), Arg.Any<ResourceType>(), Arg.Any<int>())
            .Returns(true);

        // Default: no status effects
        _mockStatusEffects.HasEffect(Arg.Any<Combatant>(), Arg.Any<StatusEffectType>())
            .Returns(false);

        // Default: effect execution returns empty result
        _mockEffectExecutor.Execute(Arg.Any<string>(), Arg.Any<Combatant>(), Arg.Any<string>(), Arg.Any<Guid?>())
            .Returns(new EffectScriptResult(0, 0, new List<string>(), ""));

        _sut = new MagicService(
            _mockSpellRepo,
            _mockResourceService,
            _mockAetherService,
            _mockStatusEffects,
            _mockEffectExecutor,
            _mockEventBus,
            _mockLogger);
    }

    #region CanCast Tests

    [Fact]
    public void CanCast_ReturnsTrue_WhenAllValidationsPass()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell();

        // Act
        var (canCast, reason) = _sut.CanCast(caster, target, spell);

        // Assert
        canCast.Should().BeTrue();
        reason.Should().BeNull();
    }

    [Fact]
    public void CanCast_ReturnsFalse_WhenInsufficientAp()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell(apCost: 10);

        _mockResourceService.CanAfford(caster, ResourceType.Aether, 10).Returns(false);

        // Act
        var (canCast, reason) = _sut.CanCast(caster, target, spell);

        // Assert
        canCast.Should().BeFalse();
        reason.Should().Be(CastFailureReason.InsufficientAp);
    }

    [Fact]
    public void CanCast_ReturnsFalse_WhenTargetTypeInvalid()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateMysticCombatant(); // Ally, not enemy
        var spell = CreateTestSpell(targetType: SpellTargetType.SingleEnemy);

        // Act
        var (canCast, reason) = _sut.CanCast(caster, target, spell);

        // Assert
        canCast.Should().BeFalse();
        reason.Should().Be(CastFailureReason.InvalidTarget);
    }

    [Fact]
    public void CanCast_ReturnsFalse_WhenCasterSilenced()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell();

        _mockStatusEffects.HasEffect(caster, StatusEffectType.Silenced).Returns(true);

        // Act
        var (canCast, reason) = _sut.CanCast(caster, target, spell);

        // Assert
        canCast.Should().BeFalse();
        reason.Should().Be(CastFailureReason.Silenced);
    }

    [Fact]
    public void CanCast_ReturnsFalse_WhenTargetDead()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        target.CurrentHp = 0;
        var spell = CreateTestSpell();

        // Act
        var (canCast, reason) = _sut.CanCast(caster, target, spell);

        // Assert
        canCast.Should().BeFalse();
        reason.Should().Be(CastFailureReason.TargetDead);
    }

    #endregion

    #region CastSpell Tests

    [Fact]
    public void CastSpell_DeductsAp_WhenSuccessful()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell(apCost: 5);

        // Act
        _sut.CastSpell(caster, target, spell);

        // Assert
        _mockResourceService.Received(1).Deduct(caster, ResourceType.Aether, 5);
    }

    [Fact]
    public void CastSpell_AddsFlux_WhenSuccessful()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell(fluxCost: 8);

        // Act
        _sut.CastSpell(caster, target, spell);

        // Assert
        _mockAetherService.Received(1).ModifyFlux(8, Arg.Is<string>(s => s.Contains("Spark")));
    }

    [Fact]
    public void CastSpell_ExecutesEffectScript()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell(effectScript: "DAMAGE:Fire:2d6");

        // Act
        _sut.CastSpell(caster, target, spell);

        // Assert
        _mockEffectExecutor.Received(1).Execute(
            "DAMAGE:Fire:2d6",
            target,
            caster.Name,
            caster.Id);
    }

    [Fact]
    public void CastSpell_PublishesEvent_WhenSuccessful()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell();

        // Act
        _sut.CastSpell(caster, target, spell);

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<SpellCastEvent>(e =>
            e.SpellName == spell.Name &&
            e.CasterName == caster.Name));
    }

    [Fact]
    public void CastSpell_ReturnsFailure_WhenCanCastFails()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell(apCost: 100);

        _mockResourceService.CanAfford(caster, ResourceType.Aether, 100).Returns(false);

        // Act
        var result = _sut.CastSpell(caster, target, spell);

        // Assert
        result.Success.Should().BeFalse();
        result.FailureReason.Should().Be(CastFailureReason.InsufficientAp);
    }

    #endregion

    #region Charged Spell Tests

    [Fact]
    public void CastSpell_InitiatesCharge_WhenChargedSpellAndNotChanting()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell(chargeTurns: 2);

        // Act
        var result = _sut.CastSpell(caster, target, spell);

        // Assert
        result.IsCharging.Should().BeTrue();
        _mockStatusEffects.Received(1).ApplyEffect(
            caster, StatusEffectType.Chanting, 2, caster.Id);
    }

    [Fact]
    public void CastSpell_ReleasesCharge_WhenChantingAndSameSpell()
    {
        // Arrange
        var caster = CreateMysticCombatant();
        var target = CreateEnemyCombatant();
        var spell = CreateTestSpell(chargeTurns: 2);
        caster.ChanneledAbilityId = spell.Id;

        _mockStatusEffects.HasEffect(caster, StatusEffectType.Chanting).Returns(true);

        // Act
        var result = _sut.CastSpell(caster, target, spell);

        // Assert
        result.WasCharged.Should().BeTrue();
        result.IsCharging.Should().BeFalse();
        _mockStatusEffects.Received(1).RemoveEffect(caster, StatusEffectType.Chanting);
    }

    #endregion

    #region Helper Methods

    private static Combatant CreateMysticCombatant()
    {
        return new Combatant
        {
            Id = Guid.NewGuid(),
            Name = "Test Mystic",
            IsPlayer = true,
            CurrentHp = 50,
            MaxHp = 50,
            CurrentAp = 10,
            MaxAp = 10,
            CharacterSource = new Character { Archetype = ArchetypeType.Mystic }
        };
    }

    private static Combatant CreateEnemyCombatant()
    {
        return new Combatant
        {
            Id = Guid.NewGuid(),
            Name = "Test Enemy",
            IsPlayer = false,
            CurrentHp = 30,
            MaxHp = 30
        };
    }

    private static Spell CreateTestSpell(
        int apCost = 2,
        int fluxCost = 5,
        SpellTargetType targetType = SpellTargetType.SingleEnemy,
        string effectScript = "DAMAGE:Fire:1d6",
        int chargeTurns = 0)
    {
        return new Spell
        {
            Id = Guid.NewGuid(),
            Name = "Spark",
            Description = "Test spell",
            School = SpellSchool.Destruction,
            TargetType = targetType,
            Range = SpellRange.Close,
            ApCost = apCost,
            FluxCost = fluxCost,
            EffectScript = effectScript,
            ChargeTurns = chargeTurns
        };
    }

    #endregion
}
```

---

## Integration Points

### 1. AetherService Integration (v0.4.3a)

Every successful cast calls:
```csharp
_aetherService.ModifyFlux(spell.FluxCost, $"Cast {spell.Name}");
```

This feeds into the Backlash system (v0.4.3d).

### 2. SpellRepository Integration (v0.4.3b)

Spell lookup via:
```csharp
var spell = await _spellRepository.GetByNameAsync(spellName);
var available = await _spellRepository.GetAvailableForCasterAsync(archetype, tier);
```

### 3. BacklashService Integration (v0.4.3d - Future)

Before executing a spell, check Backlash risk:
```csharp
// In CastSpell, after CanCast validation:
var backlashResult = _backlashService.CheckBacklash(caster);
if (backlashResult.Triggered)
{
    // Apply backlash effects before spell
    _backlashService.ApplyBacklash(caster, backlashResult.Severity);
}
```

### 4. TUI Integration (v0.4.3e - Future)

Combat HUD will display:
- Current Flux level with threshold color
- Available spells list via `spells` command
- AP bar alongside HP/Stamina

---

## Deliverable Checklist

### Core Components

- [ ] **IMagicService.cs** - Service interface
  - [ ] CanCast(), CastSpell(), GetAvailableSpellsAsync()
  - [ ] GetCannotCastReason(), IsConcentrating(), BreakConcentration()

- [ ] **MagicService.cs** - Full implementation
  - [ ] CanCast validation (7 checks)
  - [ ] CastSpell execution pipeline
  - [ ] Charged spell support (InitiateCharge, ReleaseCharge)
  - [ ] Target validation helpers
  - [ ] Event publishing

- [ ] **MagicResult.cs** - Result model
  - [ ] Success, Failure, Charging factory methods
  - [ ] All properties (damage, healing, flux, statuses)

- [ ] **CastFailureReason.cs** - Failure enum
  - [ ] 11 failure reasons

- [ ] **SpellCastEvent.cs** - Event record
  - [ ] All spell cast metadata
  - [ ] Computed properties

### Integration

- [ ] **CombatService.cs** - Extension
  - [ ] Add IMagicService, ISpellRepository dependencies
  - [ ] ExecutePlayerSpellAsync() method
  - [ ] ResolveSpellTarget() helper
  - [ ] BuildSpellLogMessage() helper

- [ ] **CommandParser.cs** - Extension
  - [ ] Handle "cast " prefix in HandleCombat()
  - [ ] ExecuteCastCommandAsync() method
  - [ ] Parse "on/at" target syntax

- [ ] **Program.cs** - DI registration
  - [ ] Register IMagicService as Singleton

### Testing

- [ ] **MagicServiceTests.cs** - 53 unit tests
  - [ ] CanCast validation tests (12)
  - [ ] CastSpell success tests (8)
  - [ ] Resource integration tests (6)
  - [ ] Flux integration tests (5)
  - [ ] Charged spell tests (8)
  - [ ] Target resolution tests (6)
  - [ ] Event publishing tests (4)
  - [ ] Edge case tests (4)

---

## Workflow

### Implementation Order

```
1. CREATE Core Models
   ├── MagicResult.cs
   └── CastFailureReason.cs

2. CREATE Core Events
   └── SpellCastEvent.cs

3. CREATE Core Interface
   └── IMagicService.cs

4. CREATE Engine Service
   └── MagicService.cs

5. CREATE Tests (TDD)
   └── MagicServiceTests.cs

6. EXTEND CombatService
   ├── Add dependencies
   ├── ExecutePlayerSpellAsync()
   └── Helper methods

7. EXTEND CommandParser
   ├── Handle "cast " prefix
   └── ExecuteCastCommandAsync()

8. REGISTER in DI
   └── Program.cs modification

9. VERIFY
   ├── Run all tests
   ├── Manual cast testing
   └── Verify Flux integration
```

### File Creation Order

| Order | File | Layer | Dependencies |
|-------|------|-------|--------------|
| 1 | CastFailureReason.cs | Core/Enums | None |
| 2 | MagicResult.cs | Core/Models/Magic | CastFailureReason |
| 3 | SpellCastEvent.cs | Core/Events | SpellSchool |
| 4 | IMagicService.cs | Core/Interfaces | All above |
| 5 | MagicService.cs | Engine/Services | All above + v0.4.3a/b |
| 6 | MagicServiceTests.cs | Tests | All above |
| 7 | CombatService.cs (modify) | Engine/Services | MagicService |
| 8 | CommandParser.cs (modify) | Engine/Services | CombatService |
| 9 | Program.cs (modify) | Terminal | MagicService |

---

## Changelog

```markdown
## v0.4.3c - The Incantation (Cast Command & MagicService)

**Release Date:** TBD

### Summary
Introduced the spell casting pipeline with the `cast` command and MagicService.
Players can now cast spells in combat, consuming Aether Points and adding Flux
to the environment.

### Features
- **Cast Command**: New `cast <spell> [on <target>]` syntax for spellcasting.
- **MagicService**: Full spell execution pipeline with validation, resource
  deduction, effect resolution, and event publishing.
- **Target Resolution**: Intelligent auto-targeting for single enemies, explicit
  targeting for multiple.
- **Charged Spells**: Support for multi-turn spell charging with telegraph messages.
- **Concentration**: Spells can require concentration, limiting one at a time.

### Technical
- Implemented `IMagicService` interface with 6 methods.
- Created `MagicService` with comprehensive validation (7 checks).
- Added `MagicResult` record with factory methods.
- Added `CastFailureReason` enum with 11 failure types.
- Added `SpellCastEvent` for UI/audio integration.
- Extended `CombatService` with `ExecutePlayerSpellAsync()`.
- Extended `CommandParser` to handle `cast` command in combat.
- Registered `IMagicService` as Singleton in DI.

### Integration
- Consumes spells from `ISpellRepository` (v0.4.3b).
- Calls `IAetherService.ModifyFlux()` on every successful cast (v0.4.3a).
- Uses `EffectScriptExecutor` for effect resolution.
- Publishes `SpellCastEvent` to `IEventBus`.

### New Files
- `RuneAndRust.Core/Enums/CastFailureReason.cs`
- `RuneAndRust.Core/Models/Magic/MagicResult.cs`
- `RuneAndRust.Core/Events/SpellCastEvent.cs`
- `RuneAndRust.Core/Interfaces/IMagicService.cs`
- `RuneAndRust.Engine/Services/MagicService.cs`
- `RuneAndRust.Tests/Engine/Services/MagicServiceTests.cs`

### Modified Files
- `RuneAndRust.Engine/Services/CombatService.cs` - Added spell execution
- `RuneAndRust.Engine/Services/CommandParser.cs` - Added cast command
- `RuneAndRust.Terminal/Program.cs` - Added DI registration

### Testing
- 53 new unit tests in `MagicServiceTests.cs`
- Coverage: Validation, execution, resources, flux, charging, targeting, events

### Usage
```
cast spark              # Auto-targets single enemy
cast spark on goblin    # Explicit target
cast heal on self       # Self-targeting spell
```

### Domain 4 Compliance
- Cast messages use narrative tone without precision measurements.
- Failure messages maintain archaeologist perspective.
- Telegraph messages for charged spells use Domain 4 compliant language.
```

---

## Next Steps

After v0.4.3c implementation:

1. **v0.4.3d (The Backlash)**: Add risk checks before casting when Flux is high
2. **v0.4.3e (The Resonance)**: Seed starter spells, add `spells` command, TUI integration
