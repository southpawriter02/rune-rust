# v0.10.4b Design Specification: Boss Mechanics

**Version:** 0.10.4b
**Parent:** v0.10.4 (Advanced Encounters)
**Prerequisites:** v0.10.4a Complete (Boss Definitions)
**Status:** Design Complete
**Estimated Unit Tests:** ~12

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ActiveBossState Tracking Class](#4-activebossstate-tracking-class)
5. [Boss Events](#5-boss-events)
6. [IBossMechanicsService Interface](#6-ibossmechanicsservice-interface)
7. [BossMechanicsService Implementation](#7-bossmechanicsservice-implementation)
8. [Phase Transition Logic](#8-phase-transition-logic)
9. [Transition Effect Execution](#9-transition-effect-execution)
10. [Enrage Mechanics](#10-enrage-mechanics)
11. [Vulnerability Windows](#11-vulnerability-windows)
12. [Unit Testing Requirements](#12-unit-testing-requirements)
13. [Use Cases](#13-use-cases)
14. [Deliverable Checklist](#14-deliverable-checklist)
15. [Acceptance Criteria](#15-acceptance-criteria)
16. [Dependencies](#16-dependencies)
17. [Future Considerations](#17-future-considerations)
18. [Logging Specifications](#18-logging-specifications)

---

## 1. Executive Summary

### Purpose

This version implements the boss mechanics service that manages active boss encounters at runtime. Building upon the boss definitions from v0.10.4a, this phase adds phase transition detection and execution, transition effect processing (knockback, summons, environmental hazards), enrage stat application, and vulnerability windows. The `BossMechanicsService` monitors boss health, triggers phase changes with dramatic effects, and provides tactical windows of opportunity for players.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Tracking Classes** | `ActiveBossState` |
| **Events** | `BossSpawnedEvent`, `BossPhaseChangedEvent`, `BossVulnerableEvent`, `BossDefeatedEvent` |
| **Interfaces** | `IBossMechanicsService` |
| **Services** | `BossMechanicsService` |
| **Tests** | ~12 unit tests |

### Architectural Significance

This version establishes the **Runtime Boss State Pattern** for encounter mechanics:

- Active boss state tracking separate from definition data
- Health-threshold-based phase transition detection and execution
- Event-driven architecture for phase changes and vulnerability windows
- Transition effects that integrate with existing combat systems (knockback, zones)
- Turn-based vulnerability window countdown
- The pattern enables dramatic multi-phase boss encounters

---

## 2. Feature Overview

```
v0.10.4b Features
├── ActiveBossState Tracking
│   ├── BossId (reference to definition)
│   ├── CurrentPhaseNumber
│   ├── VulnerableTurns (countdown)
│   ├── TurnsSinceLastSummon
│   ├── SummonedMinionIds (active summons)
│   └── EnrageStacks (optional future use)
│
├── IBossMechanicsService Interface
│   ├── SpawnBoss(bossId, position) → Monster
│   ├── OnBossDamaged(boss, damage)
│   ├── GetCurrentPhase(boss) → BossPhase
│   ├── GetBossState(boss) → ActiveBossState?
│   ├── IsVulnerable(boss) → bool
│   ├── GetVulnerabilityMultiplier(boss) → float
│   ├── SetVulnerable(boss, turns)
│   ├── TickBoss(boss) (per-turn updates)
│   ├── GetAvailableAbilities(boss) → List<string>
│   ├── IsBoss(monster) → bool
│   └── GetActiveBosses() → List<Monster>
│
├── BossMechanicsService Implementation
│   ├── Active boss state dictionary
│   ├── Phase transition detection
│   ├── Transition effect execution
│   │   ├── knockback-all-N (push players)
│   │   ├── heal-minions (restore summon HP)
│   │   └── create-lava-zones (environmental)
│   ├── Phase modifier application
│   ├── Ability pool updates
│   ├── Vulnerability window management
│   ├── Summon interval tracking
│   └── Boss defeat handling
│
├── Boss Events
│   ├── BossSpawnedEvent
│   │   ├── BossId
│   │   ├── MonsterId (instance)
│   │   └── TitleText
│   ├── BossPhaseChangedEvent
│   │   ├── MonsterId
│   │   ├── BossId
│   │   ├── OldPhase, NewPhase
│   │   ├── PhaseName
│   │   └── TransitionText?
│   ├── BossVulnerableEvent
│   │   ├── MonsterId
│   │   └── DurationTurns
│   └── BossDefeatedEvent
│       ├── MonsterId
│       ├── BossId
│       └── LootEntries
│
├── Phase Transition Logic
│   ├── Health percentage calculation
│   ├── Threshold comparison
│   ├── One-way transitions (no reverse)
│   └── Immediate execution on damage
│
├── Transition Effects
│   ├── Effect ID lookup and dispatch
│   ├── Knockback integration with grid
│   ├── Minion heal integration
│   └── Zone creation integration
│
├── Enrage Mechanics
│   ├── Phase-defined stat modifiers
│   ├── Clear previous phase modifiers
│   ├── Apply new phase modifiers
│   └── Behavior pattern update
│
└── Vulnerability Windows
    ├── Turn-based duration
    ├── Damage multiplier (1.5x default)
    ├── Countdown on TickBoss
    └── Event on vulnerability end
```

---

## 3. Architecture Diagrams

### 3.1 Boss Mechanics Service Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    BOSS MECHANICS ARCHITECTURE                           │
└─────────────────────────────────────────────────────────────────────────┘

                      ┌───────────────────────────┐
                      │      Combat System         │
                      │   (Damage, Turn events)    │
                      └───────────────┬───────────┘
                                      │ OnDamageDealt
                                      │ OnTurnEnd
                                      ▼
                      ┌───────────────────────────┐
                      │   IBossMechanicsService    │
                      ├───────────────────────────┤
                      │ + SpawnBoss(bossId, pos)  │
                      │ + OnBossDamaged(boss,dmg) │
                      │ + GetCurrentPhase(boss)   │
                      │ + GetBossState(boss)      │
                      │ + IsVulnerable(boss)      │
                      │ + GetVulnMultiplier(boss) │
                      │ + SetVulnerable(boss,trn) │
                      │ + TickBoss(boss)          │
                      │ + GetAvailableAbilities() │
                      │ + IsBoss(monster)         │
                      │ + GetActiveBosses()       │
                      └───────────────┬───────────┘
                                      │
        ┌─────────────────────────────┴─────────────────────────────┐
        │                    BossMechanicsService                    │
        ├───────────────────────────────────────────────────────────┤
        │  Dependencies:                                             │
        │  ├── IBossProvider (definitions)                          │
        │  ├── IMonsterProvider (base monsters)                     │
        │  ├── IBuffDebuffService (stat modifiers)                  │
        │  ├── IEnvironmentalCombatService (knockback, zones)       │
        │  ├── IMonsterSpawnService (summons, boss spawn)           │
        │  └── IEventBus (phase change events)                      │
        │                                                           │
        │  State:                                                   │
        │  └── _activeBosses: Dictionary<Guid, ActiveBossState>     │
        │                                                           │
        │  Methods:                                                 │
        │  ├── CheckPhaseTransition(boss, state, def)               │
        │  ├── TransitionToPhase(boss, state, def, newPhase)        │
        │  ├── ExecuteTransitionEffect(boss, phase)                 │
        │  ├── ApplyPhaseModifiers(boss, phase)                     │
        │  ├── UpdateBossAbilities(boss, phase)                     │
        │  ├── ProcessVulnerability(boss, state)                    │
        │  ├── TrySummonMinions(boss, config)                       │
        │  └── OnBossDefeated(boss, def)                            │
        └───────────────────────────────────────────────────────────┘
```

### 3.2 Phase Transition Flow

```
    PHASE TRANSITION FLOW
    ═══════════════════════════════════════════════════════════════════

    Boss takes damage (Combat System)
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 1. DAMAGE NOTIFICATION                                           │
    │    → OnBossDamaged(boss, damage)                                │
    │    → Calculate health percentage: (HP / MaxHP) * 100            │
    │    → Example: 450/700 = 64%                                     │
    └──────────────────────────────────────────────────────────────────┘
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 2. PHASE THRESHOLD CHECK                                         │
    │    → Get current phase from definition                          │
    │    → Compare with tracked state phase                           │
    │    → Thresholds: Phase 1 (100), Phase 2 (66), Phase 3 (33)      │
    │    → Health 64% → Phase 2 threshold (66) passed!                │
    └──────────────────────────────────────────────────────────────────┘
            │
            ▼ Phase changed?
    ┌───────┴───────┐
    │  YES          │  NO → Continue combat
    ▼               │
    ┌───────────────┴──────────────────────────────────────────────────┐
    │ 3. EXECUTE TRANSITION EFFECTS                                    │
    │    → Display TransitionText: "The Skeleton King raises his      │
    │      arms! Bones rise from the ground!"                         │
    │    → Execute TransitionEffectId: "knockback-all-2"              │
    │      → Get all players in combat                                │
    │      → Knockback each 2 cells away from boss                    │
    └──────────────────────────────────────────────────────────────────┘
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 4. APPLY NEW PHASE MODIFIERS                                     │
    │    → Clear previous phase stat modifiers                        │
    │    → Apply new StatModifiers: { damage: 1.5, defense: 0.75 }    │
    │    → Update boss Behavior to new pattern (Enraged)              │
    └──────────────────────────────────────────────────────────────────┘
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 5. UPDATE ABILITY POOL                                           │
    │    → Set available abilities from phase definition              │
    │    → Phase 3: ["bone-strike", "soul-drain", "death-nova"]       │
    └──────────────────────────────────────────────────────────────────┘
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 6. FIRE PHASE CHANGED EVENT                                      │
    │    → BossPhaseChangedEvent(monsterId, bossId, 1→2, "Legion",    │
    │        "The Skeleton King raises his arms!...")                 │
    │    → UI/Renderer displays dramatic phase transition             │
    └──────────────────────────────────────────────────────────────────┘
```

### 3.3 Vulnerability Window Flow

```
    VULNERABILITY WINDOW MECHANICS
    ═══════════════════════════════════════════════════════════════════

    Trigger: Major ability exhaustion / Phase transition / Manual set
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ SET VULNERABLE                                                   │
    │                                                                  │
    │    SetVulnerable(boss, 2)                                       │
    │    → state.VulnerableTurns = 2                                  │
    │    → Fire BossVulnerableEvent(monsterId, 2)                     │
    │    → Log: "Skeleton King is now vulnerable for 2 turns"         │
    └──────────────────────────────────────────────────────────────────┘
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ VULNERABILITY ACTIVE                                             │
    │                                                                  │
    │    ★ VULNERABLE ★ (2 turns remaining)                           │
    │                                                                  │
    │    • IsVulnerable(boss) → true                                  │
    │    • GetVulnerabilityMultiplier(boss) → 1.5f                    │
    │    • Damage calculation: baseDamage * 1.5 = enhanced damage     │
    │                                                                  │
    │    Boss cannot use certain abilities while vulnerable           │
    └──────────────────────────────────────────────────────────────────┘
            │
            │ Each turn
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ TICK BOSS (Per Turn)                                             │
    │                                                                  │
    │    TickBoss(boss)                                               │
    │    → if (state.VulnerableTurns > 0)                             │
    │         state.VulnerableTurns--                                 │
    │    → Countdown: 2 → 1 → 0                                       │
    └──────────────────────────────────────────────────────────────────┘
            │
            ▼ VulnerableTurns == 0?
    ┌───────┴───────┐
    │  YES          │  NO → Continue vulnerable
    ▼               │
    ┌───────────────┴──────────────────────────────────────────────────┐
    │ VULNERABILITY ENDED                                              │
    │                                                                  │
    │    → Fire BossVulnerabilityEndedEvent(monsterId)                │
    │    → IsVulnerable(boss) → false                                 │
    │    → GetVulnerabilityMultiplier(boss) → 1.0f                    │
    │    → Boss returns to normal combat state                        │
    └──────────────────────────────────────────────────────────────────┘


    VULNERABILITY STATE DIAGRAM
    ───────────────────────────

    ┌────────────────┐     SetVulnerable(n)     ┌────────────────┐
    │    NORMAL      │ ─────────────────────▶   │   VULNERABLE   │
    │                │                          │                │
    │ Multiplier:1.0 │     VulnerableTurns=0    │ Multiplier:1.5 │
    │                │ ◀─────────────────────   │ Turns: n → 0   │
    └────────────────┘   (auto after countdown) └────────────────┘
                                                       │
                                                       │ TickBoss()
                                                       │ each turn
                                                       ▼
                                                  Decrement
                                                  VulnerableTurns
```

### 3.4 Clean Architecture Layers

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      CLEAN ARCHITECTURE LAYERS                           │
└─────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────┐
    │                        PRESENTATION                              │
    │  (Consumes events for UI display)                               │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Event Handlers (via IEventBus)                          │    │
    │  │ └── Renders phase transitions, vulnerability indicators │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
                                    │ subscribes to events
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                        APPLICATION                               │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Interfaces/                                              │    │
    │  │ └── IBossMechanicsService.cs  [NEW]                     │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Services/                                                │    │
    │  │ └── BossMechanicsService.cs  [NEW]                      │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Events/                                                  │    │
    │  │ ├── BossSpawnedEvent.cs  [NEW]                          │    │
    │  │ ├── BossPhaseChangedEvent.cs  [NEW]                     │    │
    │  │ ├── BossVulnerableEvent.cs  [NEW]                       │    │
    │  │ └── BossDefeatedEvent.cs  [NEW]                         │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Tracking/                                                │    │
    │  │ └── ActiveBossState.cs  [NEW]                           │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
                                    │ uses
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                          DOMAIN                                  │
    │  (No changes - uses existing from v0.10.4a)                     │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Definitions/                                             │    │
    │  │ ├── BossDefinition.cs (from v0.10.4a)                   │    │
    │  │ └── BossPhase.cs (from v0.10.4a)                        │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
                                    │ uses
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                      INFRASTRUCTURE                              │
    │  (No changes - uses existing from v0.10.4a)                     │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Providers/                                               │    │
    │  │ └── BossProvider.cs (from v0.10.4a)                     │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
```

### 3.5 Transition Effect Decision Tree

```
    TRANSITION EFFECT EXECUTION
    ═══════════════════════════════════════════════════════════════════

    TransitionEffectId from BossPhase
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ ExecuteTransitionEffect(boss, phase)                             │
    │                                                                  │
    │ switch (phase.TransitionEffectId)                                │
    └──────────────────────────────────────────────────────────────────┘
            │
            ├──────────────────────────────────────────────────────────┐
            │ "knockback-all-N"                                        │
            ▼                                                          │
    ┌───────────────────────────────────────┐                          │
    │ KNOCKBACK ALL PLAYERS                 │                          │
    ├───────────────────────────────────────┤                          │
    │ 1. Parse N from effect ID (e.g., 2)  │                          │
    │ 2. Get all players in combat         │                          │
    │ 3. For each player:                  │                          │
    │    → Calculate direction from boss   │                          │
    │    → Knockback N cells away          │                          │
    │    → Handle collision with walls     │                          │
    └───────────────────────────────────────┘                          │
            │                                                          │
            ├──────────────────────────────────────────────────────────┤
            │ "heal-minions"                                           │
            ▼                                                          │
    ┌───────────────────────────────────────┐                          │
    │ HEAL ALL MINIONS                      │                          │
    ├───────────────────────────────────────┤                          │
    │ 1. Get boss's summoned minion IDs    │                          │
    │ 2. For each alive minion:            │                          │
    │    → Heal 50% of max HP              │                          │
    │ 3. Log healing amounts               │                          │
    └───────────────────────────────────────┘                          │
            │                                                          │
            ├──────────────────────────────────────────────────────────┤
            │ "create-lava-zones"                                      │
            ▼                                                          │
    ┌───────────────────────────────────────┐                          │
    │ CREATE HAZARD ZONES                   │                          │
    ├───────────────────────────────────────┤                          │
    │ 1. Get cells around boss (radius 3)  │                          │
    │ 2. For each valid cell:              │                          │
    │    → Create lava zone effect         │                          │
    │    → Zone deals fire damage on entry │                          │
    │ 3. Log zone creation                 │                          │
    └───────────────────────────────────────┘                          │
            │                                                          │
            ├──────────────────────────────────────────────────────────┘
            │ null / unknown
            ▼
    ┌───────────────────────────────────────┐
    │ NO EFFECT                             │
    │ (Phase has no transition effect)      │
    │ → Log: "No transition effect"         │
    └───────────────────────────────────────┘
```

---

## 4. ActiveBossState Tracking Class

**File:** `src/Core/RuneAndRust.Application/Tracking/ActiveBossState.cs`

```csharp
namespace RuneAndRust.Application.Tracking;

/// <summary>
/// Tracks the runtime state of an active boss in combat.
/// </summary>
/// <remarks>
/// Separates runtime state from static definition data:
/// - Current phase progression
/// - Vulnerability window countdown
/// - Summon timing and tracking
/// - Future: enrage stacks, special mechanic timers
///
/// This class is mutable and updated throughout the encounter.
/// </remarks>
public class ActiveBossState
{
    /// <summary>
    /// The boss definition ID this state tracks.
    /// </summary>
    public string BossId { get; }

    /// <summary>
    /// The current phase number (1-based).
    /// </summary>
    /// <remarks>
    /// Updated when health drops below phase thresholds.
    /// Only increases - phases do not reverse.
    /// </remarks>
    public int CurrentPhaseNumber { get; set; }

    /// <summary>
    /// Remaining turns of vulnerability.
    /// </summary>
    /// <remarks>
    /// When > 0, boss takes increased damage (1.5x default).
    /// Decremented each turn via TickBoss().
    /// </remarks>
    public int VulnerableTurns { get; set; }

    /// <summary>
    /// Turns since the boss last summoned minions.
    /// </summary>
    /// <remarks>
    /// Used to track summon interval timing.
    /// Reset to 0 after each summon.
    /// </remarks>
    public int TurnsSinceLastSummon { get; set; }

    /// <summary>
    /// IDs of minions summoned by this boss.
    /// </summary>
    /// <remarks>
    /// Used to track active summons against MaxActive limit.
    /// Cleared when minions die.
    /// </remarks>
    public List<Guid> SummonedMinionIds { get; } = [];

    /// <summary>
    /// Optional enrage stack count for future mechanics.
    /// </summary>
    public int EnrageStacks { get; set; }

    /// <summary>
    /// Creates a new active boss state.
    /// </summary>
    /// <param name="bossId">The boss definition ID.</param>
    /// <param name="startingPhase">The starting phase number (typically 1).</param>
    public ActiveBossState(string bossId, int startingPhase)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(bossId);
        ArgumentOutOfRangeException.ThrowIfLessThan(startingPhase, 1);

        BossId = bossId;
        CurrentPhaseNumber = startingPhase;
        VulnerableTurns = 0;
        TurnsSinceLastSummon = 0;
        EnrageStacks = 0;
    }

    /// <summary>
    /// Gets whether the boss is currently vulnerable.
    /// </summary>
    public bool IsVulnerable => VulnerableTurns > 0;

    /// <summary>
    /// Gets the count of active summoned minions.
    /// </summary>
    public int ActiveSummonCount => SummonedMinionIds.Count;

    /// <summary>
    /// Removes a minion from the tracked summons (on death).
    /// </summary>
    /// <param name="minionId">The minion's entity ID.</param>
    public void RemoveSummonedMinion(Guid minionId)
    {
        SummonedMinionIds.Remove(minionId);
    }

    /// <summary>
    /// Adds a minion to the tracked summons.
    /// </summary>
    /// <param name="minionId">The minion's entity ID.</param>
    public void AddSummonedMinion(Guid minionId)
    {
        if (!SummonedMinionIds.Contains(minionId))
        {
            SummonedMinionIds.Add(minionId);
        }
    }

    /// <summary>
    /// Checks if more minions can be summoned based on configuration.
    /// </summary>
    /// <param name="maxActive">Maximum active summons allowed.</param>
    /// <returns>True if under the summon limit.</returns>
    public bool CanSummon(int maxActive)
    {
        return SummonedMinionIds.Count < maxActive;
    }
}
```

---

## 5. Boss Events

### 5.1 BossSpawnedEvent

**File:** `src/Core/RuneAndRust.Application/Events/BossSpawnedEvent.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>
/// Event fired when a boss is spawned into combat.
/// </summary>
/// <param name="MonsterId">The spawned monster instance ID.</param>
/// <param name="BossId">The boss definition ID.</param>
/// <param name="TitleText">Optional title text to display (e.g., "The Skeleton King Awakens!").</param>
public record BossSpawnedEvent(
    Guid MonsterId,
    string BossId,
    string? TitleText) : IGameEvent
{
    /// <summary>
    /// Gets the event timestamp.
    /// </summary>
    public DateTime Timestamp { get; } = DateTime.UtcNow;
}
```

### 5.2 BossPhaseChangedEvent

**File:** `src/Core/RuneAndRust.Application/Events/BossPhaseChangedEvent.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>
/// Event fired when a boss transitions to a new phase.
/// </summary>
/// <param name="MonsterId">The boss monster instance ID.</param>
/// <param name="BossId">The boss definition ID.</param>
/// <param name="OldPhaseNumber">The previous phase number.</param>
/// <param name="NewPhaseNumber">The new phase number.</param>
/// <param name="PhaseName">The new phase's display name.</param>
/// <param name="TransitionText">Optional dramatic text for the transition.</param>
public record BossPhaseChangedEvent(
    Guid MonsterId,
    string BossId,
    int OldPhaseNumber,
    int NewPhaseNumber,
    string PhaseName,
    string? TransitionText) : IGameEvent
{
    /// <summary>
    /// Gets the event timestamp.
    /// </summary>
    public DateTime Timestamp { get; } = DateTime.UtcNow;

    /// <summary>
    /// Gets whether this is a significant phase transition (has text).
    /// </summary>
    public bool HasTransitionText => !string.IsNullOrEmpty(TransitionText);
}
```

### 5.3 BossVulnerableEvent

**File:** `src/Core/RuneAndRust.Application/Events/BossVulnerableEvent.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>
/// Event fired when a boss becomes vulnerable to increased damage.
/// </summary>
/// <param name="MonsterId">The boss monster instance ID.</param>
/// <param name="DurationTurns">Number of turns the vulnerability lasts.</param>
public record BossVulnerableEvent(
    Guid MonsterId,
    int DurationTurns) : IGameEvent
{
    /// <summary>
    /// Gets the event timestamp.
    /// </summary>
    public DateTime Timestamp { get; } = DateTime.UtcNow;
}
```

### 5.4 BossVulnerabilityEndedEvent

**File:** `src/Core/RuneAndRust.Application/Events/BossVulnerabilityEndedEvent.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>
/// Event fired when a boss's vulnerability window ends.
/// </summary>
/// <param name="MonsterId">The boss monster instance ID.</param>
public record BossVulnerabilityEndedEvent(
    Guid MonsterId) : IGameEvent
{
    /// <summary>
    /// Gets the event timestamp.
    /// </summary>
    public DateTime Timestamp { get; } = DateTime.UtcNow;
}
```

### 5.5 BossDefeatedEvent

**File:** `src/Core/RuneAndRust.Application/Events/BossDefeatedEvent.cs`

```csharp
namespace RuneAndRust.Application.Events;

using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Event fired when a boss is defeated.
/// </summary>
/// <param name="MonsterId">The boss monster instance ID.</param>
/// <param name="BossId">The boss definition ID.</param>
/// <param name="LootEntries">The loot table entries for drops.</param>
public record BossDefeatedEvent(
    Guid MonsterId,
    string BossId,
    IReadOnlyList<BossLootEntry> LootEntries) : IGameEvent
{
    /// <summary>
    /// Gets the event timestamp.
    /// </summary>
    public DateTime Timestamp { get; } = DateTime.UtcNow;

    /// <summary>
    /// Gets whether this boss has any loot to drop.
    /// </summary>
    public bool HasLoot => LootEntries.Count > 0;
}
```

---

## 6. IBossMechanicsService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IBossMechanicsService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Application.Tracking;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing boss encounter mechanics at runtime.
/// </summary>
/// <remarks>
/// Handles:
/// - Boss spawning with state initialization
/// - Phase transition detection and execution
/// - Transition effect processing
/// - Vulnerability window management
/// - Per-turn state updates (summons, cooldowns)
/// - Boss defeat handling
/// </remarks>
public interface IBossMechanicsService
{
    /// <summary>
    /// Spawns a boss at a grid position.
    /// </summary>
    /// <param name="bossId">The boss definition ID.</param>
    /// <param name="position">Grid position to spawn at.</param>
    /// <returns>The spawned boss monster instance.</returns>
    /// <exception cref="ArgumentException">If boss definition not found.</exception>
    Monster SpawnBoss(string bossId, GridPosition position);

    /// <summary>
    /// Called when a boss takes damage to check for phase transitions.
    /// </summary>
    /// <param name="boss">The boss monster that was damaged.</param>
    /// <param name="damage">Amount of damage taken.</param>
    /// <remarks>
    /// Triggers phase transition if health drops below threshold.
    /// Should be called from combat service after damage is applied.
    /// </remarks>
    void OnBossDamaged(Monster boss, int damage);

    /// <summary>
    /// Gets the current phase for a boss.
    /// </summary>
    /// <param name="boss">The boss monster.</param>
    /// <returns>The current BossPhase, or null if not a tracked boss.</returns>
    BossPhase? GetCurrentPhase(Monster boss);

    /// <summary>
    /// Gets the active state for a boss.
    /// </summary>
    /// <param name="boss">The boss monster.</param>
    /// <returns>The ActiveBossState, or null if not a tracked boss.</returns>
    ActiveBossState? GetBossState(Monster boss);

    /// <summary>
    /// Checks if a boss is currently in a vulnerable state.
    /// </summary>
    /// <param name="boss">The boss monster.</param>
    /// <returns>True if the boss is vulnerable to increased damage.</returns>
    bool IsVulnerable(Monster boss);

    /// <summary>
    /// Gets the damage multiplier for vulnerability.
    /// </summary>
    /// <param name="boss">The boss monster.</param>
    /// <returns>1.5f if vulnerable, 1.0f otherwise.</returns>
    float GetVulnerabilityMultiplier(Monster boss);

    /// <summary>
    /// Makes a boss vulnerable for a specified duration.
    /// </summary>
    /// <param name="boss">The boss monster.</param>
    /// <param name="turns">Number of turns to be vulnerable.</param>
    void SetVulnerable(Monster boss, int turns);

    /// <summary>
    /// Called each turn to update boss state.
    /// </summary>
    /// <param name="boss">The boss monster.</param>
    /// <remarks>
    /// Handles:
    /// - Vulnerability countdown
    /// - Summon interval timing
    /// - Other per-turn mechanics
    /// </remarks>
    void TickBoss(Monster boss);

    /// <summary>
    /// Gets the abilities available in the boss's current phase.
    /// </summary>
    /// <param name="boss">The boss monster.</param>
    /// <returns>List of ability IDs available for use.</returns>
    IReadOnlyList<string> GetAvailableAbilities(Monster boss);

    /// <summary>
    /// Checks if a monster is a tracked boss.
    /// </summary>
    /// <param name="monster">The monster to check.</param>
    /// <returns>True if this monster is an active boss.</returns>
    bool IsBoss(Monster monster);

    /// <summary>
    /// Gets all currently active bosses in combat.
    /// </summary>
    /// <returns>List of active boss monsters.</returns>
    IReadOnlyList<Monster> GetActiveBosses();

    /// <summary>
    /// Handles minion death to update boss summon tracking.
    /// </summary>
    /// <param name="boss">The boss that summoned the minion.</param>
    /// <param name="minionId">The deceased minion's ID.</param>
    void OnMinionDeath(Monster boss, Guid minionId);
}
```

---

## 7. BossMechanicsService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/BossMechanicsService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Events;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Tracking;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Manages boss encounter mechanics including phase transitions,
/// transition effects, vulnerability windows, and summon tracking.
/// </summary>
public class BossMechanicsService : IBossMechanicsService
{
    private readonly IBossProvider _bossProvider;
    private readonly IMonsterProvider _monsterProvider;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IEnvironmentalCombatService _environmentalService;
    private readonly IMonsterSpawnService _spawnService;
    private readonly ICombatContext _combatContext;
    private readonly IEventBus _eventBus;
    private readonly ILogger<BossMechanicsService> _logger;

    /// <summary>
    /// Tracks active boss states keyed by monster instance ID.
    /// </summary>
    private readonly Dictionary<Guid, ActiveBossState> _activeBosses = new();

    /// <summary>
    /// Default damage multiplier when boss is vulnerable.
    /// </summary>
    private const float VulnerabilityMultiplier = 1.5f;

    /// <summary>
    /// Creates a new BossMechanicsService.
    /// </summary>
    public BossMechanicsService(
        IBossProvider bossProvider,
        IMonsterProvider monsterProvider,
        IBuffDebuffService buffDebuffService,
        IEnvironmentalCombatService environmentalService,
        IMonsterSpawnService spawnService,
        ICombatContext combatContext,
        IEventBus eventBus,
        ILogger<BossMechanicsService> logger)
    {
        _bossProvider = bossProvider;
        _monsterProvider = monsterProvider;
        _buffDebuffService = buffDebuffService;
        _environmentalService = environmentalService;
        _spawnService = spawnService;
        _combatContext = combatContext;
        _eventBus = eventBus;
        _logger = logger;
    }

    /// <inheritdoc />
    public Monster SpawnBoss(string bossId, GridPosition position)
    {
        var bossDef = _bossProvider.GetBoss(bossId);
        if (bossDef is null)
        {
            throw new ArgumentException($"Boss definition not found: {bossId}", nameof(bossId));
        }

        // Get base monster definition
        var monsterDef = _monsterProvider.GetMonster(bossDef.BaseMonsterDefinitionId);
        if (monsterDef is null)
        {
            throw new InvalidOperationException(
                $"Base monster definition not found: {bossDef.BaseMonsterDefinitionId}");
        }

        // Spawn the monster
        var boss = _spawnService.Spawn(monsterDef, position);

        // Mark as boss (if Monster entity supports this)
        boss.SetBossId(bossId);

        // Initialize boss state
        var startingPhase = bossDef.GetStartingPhase();
        var state = new ActiveBossState(bossId, startingPhase.PhaseNumber);
        _activeBosses[boss.Id] = state;

        // Apply initial phase abilities and behavior
        UpdateBossAbilities(boss, startingPhase);
        boss.SetBehavior(startingPhase.Behavior);

        _logger.LogInformation(
            "Spawned boss {BossName} ({BossId}) at {Position}, starting phase: {Phase}",
            bossDef.Name, bossId, position, startingPhase.Name);

        // Fire spawn event
        _eventBus.Publish(new BossSpawnedEvent(boss.Id, bossId, bossDef.TitleText));

        return boss;
    }

    /// <inheritdoc />
    public void OnBossDamaged(Monster boss, int damage)
    {
        if (!_activeBosses.TryGetValue(boss.Id, out var state))
        {
            return;
        }

        var bossDef = _bossProvider.GetBoss(state.BossId);
        if (bossDef is null)
        {
            _logger.LogWarning("Boss definition not found for active boss: {BossId}", state.BossId);
            return;
        }

        // Calculate current health percentage
        var healthPercent = CalculateHealthPercent(boss);

        // Get the phase for current health
        var newPhase = bossDef.GetPhaseForHealth(healthPercent);

        // Check for phase transition
        if (newPhase.PhaseNumber != state.CurrentPhaseNumber)
        {
            TransitionToPhase(boss, state, bossDef, newPhase);
        }

        // Check for defeat
        if (boss.Health <= 0)
        {
            OnBossDefeated(boss, bossDef);
        }
    }

    /// <summary>
    /// Transitions the boss to a new phase.
    /// </summary>
    private void TransitionToPhase(
        Monster boss,
        ActiveBossState state,
        BossDefinition bossDef,
        BossPhase newPhase)
    {
        var oldPhaseNumber = state.CurrentPhaseNumber;
        state.CurrentPhaseNumber = newPhase.PhaseNumber;

        _logger.LogInformation(
            "{BossName} transitioning from phase {OldPhase} to phase {NewPhase} ({PhaseName})",
            bossDef.Name, oldPhaseNumber, newPhase.PhaseNumber, newPhase.Name);

        // Execute transition effects
        if (newPhase.HasTransition)
        {
            ExecuteTransitionEffect(boss, newPhase);
        }

        // Apply new phase stat modifiers
        ApplyPhaseModifiers(boss, newPhase);

        // Update available abilities
        UpdateBossAbilities(boss, newPhase);

        // Update AI behavior
        boss.SetBehavior(newPhase.Behavior);

        // Fire phase changed event
        _eventBus.Publish(new BossPhaseChangedEvent(
            boss.Id,
            state.BossId,
            oldPhaseNumber,
            newPhase.PhaseNumber,
            newPhase.Name,
            newPhase.TransitionText));
    }

    /// <summary>
    /// Executes a phase transition effect.
    /// </summary>
    private void ExecuteTransitionEffect(Monster boss, BossPhase phase)
    {
        if (string.IsNullOrEmpty(phase.TransitionEffectId))
        {
            return;
        }

        _logger.LogDebug("Executing transition effect: {EffectId}", phase.TransitionEffectId);

        // Parse effect ID and parameters
        var effectParts = phase.TransitionEffectId.Split('-');
        var effectType = effectParts[0];

        switch (phase.TransitionEffectId)
        {
            case var s when s.StartsWith("knockback-all-"):
                ExecuteKnockbackAll(boss, ParseEffectParameter(s, 2));
                break;

            case "heal-minions":
                ExecuteHealMinions(boss);
                break;

            case "create-lava-zones":
                ExecuteCreateHazardZones(boss, "lava", 3);
                break;

            default:
                _logger.LogWarning("Unknown transition effect: {EffectId}", phase.TransitionEffectId);
                break;
        }
    }

    /// <summary>
    /// Parses a numeric parameter from an effect ID like "knockback-all-2".
    /// </summary>
    private static int ParseEffectParameter(string effectId, int defaultValue)
    {
        var parts = effectId.Split('-');
        if (parts.Length > 0 && int.TryParse(parts[^1], out var value))
        {
            return value;
        }
        return defaultValue;
    }

    /// <summary>
    /// Knocks back all players away from the boss.
    /// </summary>
    private void ExecuteKnockbackAll(Monster boss, int distance)
    {
        var players = _combatContext.GetPlayerCombatants();
        foreach (var player in players)
        {
            _environmentalService.Knockback(player, boss.Position, distance);
            _logger.LogDebug("Knocked back {Player} {Distance} cells from {Boss}",
                player.Name, distance, boss.Name);
        }
    }

    /// <summary>
    /// Heals all minions summoned by the boss.
    /// </summary>
    private void ExecuteHealMinions(Monster boss)
    {
        if (!_activeBosses.TryGetValue(boss.Id, out var state))
        {
            return;
        }

        foreach (var minionId in state.SummonedMinionIds.ToList())
        {
            var minion = _combatContext.GetMonsterById(minionId);
            if (minion is not null && minion.IsAlive)
            {
                var healAmount = minion.MaxHealth / 2;
                minion.Heal(healAmount);
                _logger.LogDebug("Healed minion {Minion} for {Amount} HP", minion.Name, healAmount);
            }
        }
    }

    /// <summary>
    /// Creates hazard zones around the boss.
    /// </summary>
    private void ExecuteCreateHazardZones(Monster boss, string zoneType, int radius)
    {
        var positions = GetPositionsInRadius(boss.Position, radius);
        foreach (var pos in positions)
        {
            if (_combatContext.Grid.IsValidPosition(pos) && _combatContext.Grid.IsPassable(pos))
            {
                _environmentalService.CreateZone(pos, zoneType);
            }
        }
        _logger.LogDebug("Created {Type} zones around {Boss} (radius {Radius})",
            zoneType, boss.Name, radius);
    }

    /// <summary>
    /// Gets grid positions within a radius of a center point.
    /// </summary>
    private static IEnumerable<GridPosition> GetPositionsInRadius(GridPosition center, int radius)
    {
        for (int dx = -radius; dx <= radius; dx++)
        {
            for (int dy = -radius; dy <= radius; dy++)
            {
                if (dx == 0 && dy == 0) continue; // Skip center
                if (Math.Abs(dx) + Math.Abs(dy) <= radius) // Manhattan distance
                {
                    yield return new GridPosition(center.X + dx, center.Y + dy);
                }
            }
        }
    }

    /// <summary>
    /// Applies stat modifiers for a phase.
    /// </summary>
    private void ApplyPhaseModifiers(Monster boss, BossPhase phase)
    {
        // Clear previous phase modifiers
        _buffDebuffService.ClearEffectsBySource(boss, $"boss-phase");

        // Apply new phase modifiers
        foreach (var (statId, multiplier) in phase.StatModifiers)
        {
            // Convert multiplier to percentage change (1.5 -> +50, 0.75 -> -25)
            var percentChange = (int)((multiplier - 1.0f) * 100);
            _buffDebuffService.ApplyStatModifier(
                boss,
                statId,
                percentChange,
                source: $"boss-phase:{phase.PhaseNumber}");
        }

        _logger.LogDebug("Applied phase {Phase} modifiers to {Boss}: {Modifiers}",
            phase.PhaseNumber, boss.Name, phase.StatModifiers);
    }

    /// <summary>
    /// Updates the boss's available abilities for the current phase.
    /// </summary>
    private void UpdateBossAbilities(Monster boss, BossPhase phase)
    {
        boss.SetAvailableAbilities(phase.AbilityIds.ToList());
        _logger.LogDebug("Updated {Boss} abilities to: {Abilities}",
            boss.Name, string.Join(", ", phase.AbilityIds));
    }

    /// <inheritdoc />
    public BossPhase? GetCurrentPhase(Monster boss)
    {
        if (!_activeBosses.TryGetValue(boss.Id, out var state))
        {
            return null;
        }

        var bossDef = _bossProvider.GetBoss(state.BossId);
        return bossDef?.Phases.FirstOrDefault(p => p.PhaseNumber == state.CurrentPhaseNumber);
    }

    /// <inheritdoc />
    public ActiveBossState? GetBossState(Monster boss)
    {
        return _activeBosses.GetValueOrDefault(boss.Id);
    }

    /// <inheritdoc />
    public bool IsVulnerable(Monster boss)
    {
        return _activeBosses.TryGetValue(boss.Id, out var state) && state.IsVulnerable;
    }

    /// <inheritdoc />
    public float GetVulnerabilityMultiplier(Monster boss)
    {
        return IsVulnerable(boss) ? VulnerabilityMultiplier : 1.0f;
    }

    /// <inheritdoc />
    public void SetVulnerable(Monster boss, int turns)
    {
        if (_activeBosses.TryGetValue(boss.Id, out var state))
        {
            state.VulnerableTurns = turns;
            _eventBus.Publish(new BossVulnerableEvent(boss.Id, turns));
            _logger.LogInformation("{Boss} is now vulnerable for {Turns} turns", boss.Name, turns);
        }
    }

    /// <inheritdoc />
    public void TickBoss(Monster boss)
    {
        if (!_activeBosses.TryGetValue(boss.Id, out var state))
        {
            return;
        }

        // Decrement vulnerability
        if (state.VulnerableTurns > 0)
        {
            state.VulnerableTurns--;
            if (state.VulnerableTurns == 0)
            {
                _eventBus.Publish(new BossVulnerabilityEndedEvent(boss.Id));
                _logger.LogDebug("{Boss} is no longer vulnerable", boss.Name);
            }
        }

        // Check for summoning
        var bossDef = _bossProvider.GetBoss(state.BossId);
        var currentPhase = bossDef?.Phases.FirstOrDefault(p => p.PhaseNumber == state.CurrentPhaseNumber);

        if (currentPhase?.SummonConfig is { } summonConfig && summonConfig.IsValid)
        {
            state.TurnsSinceLastSummon++;
            if (state.TurnsSinceLastSummon >= summonConfig.IntervalTurns)
            {
                TrySummonMinions(boss, state, summonConfig);
                state.TurnsSinceLastSummon = 0;
            }
        }
    }

    /// <summary>
    /// Attempts to summon minions for a boss.
    /// </summary>
    private void TrySummonMinions(Monster boss, ActiveBossState state, SummonConfiguration config)
    {
        // Check summon limit
        if (!state.CanSummon(config.MaxActive))
        {
            _logger.LogDebug("{Boss} at summon limit ({Count}/{Max})",
                boss.Name, state.ActiveSummonCount, config.MaxActive);
            return;
        }

        // Find spawn positions near boss
        var spawnPositions = GetPositionsInRadius(boss.Position, 2)
            .Where(p => _combatContext.Grid.IsValidPosition(p) && _combatContext.Grid.IsEmpty(p))
            .Take(config.Count)
            .ToList();

        foreach (var pos in spawnPositions)
        {
            if (!state.CanSummon(config.MaxActive))
            {
                break;
            }

            var minion = _spawnService.SpawnByDefinitionId(config.MonsterDefinitionId, pos);
            if (minion is not null)
            {
                state.AddSummonedMinion(minion.Id);
                _logger.LogDebug("{Boss} summoned {Minion} at {Position}",
                    boss.Name, minion.Name, pos);
            }
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetAvailableAbilities(Monster boss)
    {
        var phase = GetCurrentPhase(boss);
        return phase?.AbilityIds ?? [];
    }

    /// <inheritdoc />
    public bool IsBoss(Monster monster)
    {
        return _activeBosses.ContainsKey(monster.Id);
    }

    /// <inheritdoc />
    public IReadOnlyList<Monster> GetActiveBosses()
    {
        return _activeBosses.Keys
            .Select(id => _combatContext.GetMonsterById(id))
            .Where(m => m is not null && m.IsAlive)
            .Cast<Monster>()
            .ToList();
    }

    /// <inheritdoc />
    public void OnMinionDeath(Monster boss, Guid minionId)
    {
        if (_activeBosses.TryGetValue(boss.Id, out var state))
        {
            state.RemoveSummonedMinion(minionId);
            _logger.LogDebug("Minion {MinionId} died, removed from {Boss} summons",
                minionId, boss.Name);
        }
    }

    /// <summary>
    /// Handles boss defeat.
    /// </summary>
    private void OnBossDefeated(Monster boss, BossDefinition bossDef)
    {
        _activeBosses.Remove(boss.Id);
        _eventBus.Publish(new BossDefeatedEvent(boss.Id, bossDef.BossId, bossDef.Loot));
        _logger.LogInformation("Boss {BossName} ({BossId}) defeated!", bossDef.Name, bossDef.BossId);
    }

    /// <summary>
    /// Calculates health as a percentage (0-100).
    /// </summary>
    private static int CalculateHealthPercent(Monster boss)
    {
        if (boss.MaxHealth <= 0)
        {
            return 0;
        }
        return (int)Math.Ceiling((boss.Health / (float)boss.MaxHealth) * 100);
    }
}
```

---

## 8. Phase Transition Logic

### 8.1 Transition Detection Algorithm

```csharp
/// <summary>
/// Phase transition detection occurs in OnBossDamaged.
/// </summary>
/// <remarks>
/// Algorithm:
/// 1. Calculate current health percentage
/// 2. Get the appropriate phase for that health level
/// 3. Compare with tracked current phase
/// 4. If different, trigger transition
///
/// Key behaviors:
/// - One-way transitions only (phase numbers only increase)
/// - Immediate execution on damage event
/// - Multiple phase skips possible (e.g., 1 -> 3 if damage is large)
/// </remarks>
```

### 8.2 Health Percentage Calculation

```csharp
/// <summary>
/// Health percentage uses ceiling to ensure clean threshold handling.
/// </summary>
/// <example>
/// Health: 66/100 = 66% exactly → Phase 2 (threshold 66)
/// Health: 67/100 = 67% → Phase 1 (above threshold 66)
/// Health: 33/100 = 33% exactly → Phase 3 (threshold 33)
/// </example>
private static int CalculateHealthPercent(Monster boss)
{
    if (boss.MaxHealth <= 0) return 0;
    return (int)Math.Ceiling((boss.Health / (float)boss.MaxHealth) * 100);
}
```

### 8.3 Phase Lookup Integration

The `BossDefinition.GetPhaseForHealth(percent)` method from v0.10.4a provides the phase lookup. The mechanics service compares this with the tracked state to detect transitions:

```csharp
var healthPercent = CalculateHealthPercent(boss);
var newPhase = bossDef.GetPhaseForHealth(healthPercent);

if (newPhase.PhaseNumber != state.CurrentPhaseNumber)
{
    TransitionToPhase(boss, state, bossDef, newPhase);
}
```

---

## 9. Transition Effect Execution

### 9.1 Supported Transition Effects

| Effect ID | Description | Parameters |
|-----------|-------------|------------|
| `knockback-all-N` | Knockback all players N cells away from boss | N = distance (default 2) |
| `heal-minions` | Heal all summoned minions 50% of max HP | None |
| `create-lava-zones` | Create lava zones in radius around boss | Radius = 3 (hardcoded) |

### 9.2 Effect Execution Flow

```
ExecuteTransitionEffect(boss, phase)
    │
    ├─ Parse TransitionEffectId
    │
    ├─ Match effect type
    │   ├─ knockback-all-* → ExecuteKnockbackAll(boss, distance)
    │   ├─ heal-minions → ExecuteHealMinions(boss)
    │   └─ create-lava-zones → ExecuteCreateHazardZones(boss, "lava", 3)
    │
    └─ Log effect execution
```

### 9.3 Integration Points

| Effect | Integration Service | Method |
|--------|---------------------|--------|
| Knockback | `IEnvironmentalCombatService` | `Knockback(target, fromPosition, distance)` |
| Heal | `Monster` entity | `Heal(amount)` |
| Zone Creation | `IEnvironmentalCombatService` | `CreateZone(position, zoneType)` |

---

## 10. Enrage Mechanics

### 10.1 Phase-Based Stat Modifiers

Enrage mechanics are implemented through phase stat modifiers:

```json
{
  "phaseNumber": 3,
  "name": "Fury",
  "behavior": "Enraged",
  "statModifiers": {
    "damage": 1.5,
    "attackSpeed": 1.25,
    "defense": 0.75
  }
}
```

### 10.2 Modifier Application Flow

```
ApplyPhaseModifiers(boss, phase)
    │
    ├─ Clear previous phase modifiers
    │   └─ _buffDebuffService.ClearEffectsBySource(boss, "boss-phase")
    │
    ├─ For each stat modifier:
    │   ├─ Convert multiplier to percentage: (1.5 - 1.0) * 100 = +50%
    │   └─ Apply via _buffDebuffService.ApplyStatModifier()
    │
    └─ Log applied modifiers
```

### 10.3 Behavior Update

Each phase has a `BossBehavior` enum value that affects AI decision-making:

```csharp
// Update AI behavior pattern
boss.SetBehavior(newPhase.Behavior);
```

| Behavior | AI Priority |
|----------|-------------|
| `Aggressive` | Maximize damage output |
| `Tactical` | Balance offense/defense |
| `Defensive` | Prioritize self-preservation |
| `Enraged` | All-out attack, ignore defense |
| `Summoner` | Prioritize summon abilities |

---

## 11. Vulnerability Windows

### 11.1 Vulnerability State

```csharp
public class ActiveBossState
{
    public int VulnerableTurns { get; set; }
    public bool IsVulnerable => VulnerableTurns > 0;
}
```

### 11.2 Damage Multiplier

When a boss is vulnerable, incoming damage is multiplied:

```csharp
public float GetVulnerabilityMultiplier(Monster boss)
{
    return IsVulnerable(boss) ? 1.5f : 1.0f;
}
```

The combat system should call this when calculating damage:

```csharp
// In combat damage calculation:
var vulnerabilityMultiplier = _bossMechanicsService.GetVulnerabilityMultiplier(target);
var finalDamage = (int)(baseDamage * vulnerabilityMultiplier);
```

### 11.3 Countdown Mechanism

```csharp
public void TickBoss(Monster boss)
{
    if (state.VulnerableTurns > 0)
    {
        state.VulnerableTurns--;
        if (state.VulnerableTurns == 0)
        {
            _eventBus.Publish(new BossVulnerabilityEndedEvent(boss.Id));
        }
    }
}
```

### 11.4 Triggering Vulnerability

Vulnerability can be triggered by:
1. Manual call: `SetVulnerable(boss, turns)`
2. Ability effects (future)
3. After major boss abilities (future)

---

## 12. Unit Testing Requirements

### Test Count by Feature

| Feature | Tests |
|---------|-------|
| SpawnBoss validation and state | 2 |
| Phase transition detection | 3 |
| Transition effect execution | 2 |
| Vulnerability window mechanics | 3 |
| TickBoss turn processing | 2 |
| **Total** | **~12** |

### Test Specifications

**File:** `tests/RuneAndRust.Application.UnitTests/Services/BossMechanicsServiceTests.cs`

```csharp
[TestFixture]
public class BossMechanicsServiceTests
{
    private Mock<IBossProvider> _bossProviderMock = null!;
    private Mock<IMonsterProvider> _monsterProviderMock = null!;
    private Mock<IBuffDebuffService> _buffDebuffServiceMock = null!;
    private Mock<IEnvironmentalCombatService> _environmentalServiceMock = null!;
    private Mock<IMonsterSpawnService> _spawnServiceMock = null!;
    private Mock<ICombatContext> _combatContextMock = null!;
    private Mock<IEventBus> _eventBusMock = null!;
    private Mock<ILogger<BossMechanicsService>> _loggerMock = null!;
    private BossMechanicsService _service = null!;

    [SetUp]
    public void Setup()
    {
        _bossProviderMock = new Mock<IBossProvider>();
        _monsterProviderMock = new Mock<IMonsterProvider>();
        _buffDebuffServiceMock = new Mock<IBuffDebuffService>();
        _environmentalServiceMock = new Mock<IEnvironmentalCombatService>();
        _spawnServiceMock = new Mock<IMonsterSpawnService>();
        _combatContextMock = new Mock<ICombatContext>();
        _eventBusMock = new Mock<IEventBus>();
        _loggerMock = new Mock<ILogger<BossMechanicsService>>();

        _service = new BossMechanicsService(
            _bossProviderMock.Object,
            _monsterProviderMock.Object,
            _buffDebuffServiceMock.Object,
            _environmentalServiceMock.Object,
            _spawnServiceMock.Object,
            _combatContextMock.Object,
            _eventBusMock.Object,
            _loggerMock.Object);
    }

    // ===== SpawnBoss Tests =====

    [Test]
    public void SpawnBoss_WithValidBossId_ReturnsMonsterAndInitializesState()
    {
        // Arrange
        var bossDef = CreateTestBossDefinition("test-boss");
        var monsterDef = CreateTestMonsterDefinition("base-monster");
        var monster = CreateTestMonster();

        _bossProviderMock.Setup(x => x.GetBoss("test-boss")).Returns(bossDef);
        _monsterProviderMock.Setup(x => x.GetMonster("base-monster")).Returns(monsterDef);
        _spawnServiceMock.Setup(x => x.Spawn(monsterDef, It.IsAny<GridPosition>())).Returns(monster);

        // Act
        var result = _service.SpawnBoss("test-boss", new GridPosition(5, 5));

        // Assert
        result.Should().NotBeNull();
        _service.IsBoss(result).Should().BeTrue();
        _service.GetBossState(result).Should().NotBeNull();
        _service.GetBossState(result)!.CurrentPhaseNumber.Should().Be(1);
    }

    [Test]
    public void SpawnBoss_WithInvalidBossId_ThrowsArgumentException()
    {
        // Arrange
        _bossProviderMock.Setup(x => x.GetBoss("invalid")).Returns((BossDefinition?)null);

        // Act
        var act = () => _service.SpawnBoss("invalid", new GridPosition(5, 5));

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithMessage("*Boss definition not found*");
    }

    // ===== Phase Transition Tests =====

    [Test]
    public void OnBossDamaged_WhenHealthCrossesThreshold_TransitionsToNewPhase()
    {
        // Arrange
        var (boss, bossDef) = SetupActiveBoss(currentHealth: 65, maxHealth: 100);
        // Phase thresholds: 100 (phase 1), 66 (phase 2), 33 (phase 3)

        // Act
        _service.OnBossDamaged(boss, 0); // Damage already applied, just trigger check

        // Assert
        _service.GetBossState(boss)!.CurrentPhaseNumber.Should().Be(2);
        _eventBusMock.Verify(x => x.Publish(It.IsAny<BossPhaseChangedEvent>()), Times.Once);
    }

    [Test]
    public void OnBossDamaged_WhenHealthAboveThreshold_DoesNotTransition()
    {
        // Arrange
        var (boss, bossDef) = SetupActiveBoss(currentHealth: 70, maxHealth: 100);

        // Act
        _service.OnBossDamaged(boss, 0);

        // Assert
        _service.GetBossState(boss)!.CurrentPhaseNumber.Should().Be(1);
        _eventBusMock.Verify(x => x.Publish(It.IsAny<BossPhaseChangedEvent>()), Times.Never);
    }

    [Test]
    public void OnBossDamaged_WhenBossDefeated_FiresDefeatedEvent()
    {
        // Arrange
        var (boss, bossDef) = SetupActiveBoss(currentHealth: 0, maxHealth: 100);

        // Act
        _service.OnBossDamaged(boss, 0);

        // Assert
        _eventBusMock.Verify(x => x.Publish(It.IsAny<BossDefeatedEvent>()), Times.Once);
        _service.IsBoss(boss).Should().BeFalse();
    }

    // ===== Transition Effect Tests =====

    [Test]
    public void TransitionToPhase_WithKnockbackEffect_KnockbacksAllPlayers()
    {
        // Arrange
        var (boss, bossDef) = SetupActiveBossWithKnockbackPhase();
        var players = new List<ICombatant> { CreateTestPlayer() };
        _combatContextMock.Setup(x => x.GetPlayerCombatants()).Returns(players);

        // Force transition by setting health
        boss.Health = 60; // Below 66% threshold

        // Act
        _service.OnBossDamaged(boss, 0);

        // Assert
        _environmentalServiceMock.Verify(
            x => x.Knockback(It.IsAny<ICombatant>(), boss.Position, 2),
            Times.Once);
    }

    [Test]
    public void TransitionToPhase_WithStatModifiers_AppliesModifiers()
    {
        // Arrange
        var (boss, bossDef) = SetupActiveBossWithEnragePhase();
        boss.Health = 30; // Below 33% threshold

        // Act
        _service.OnBossDamaged(boss, 0);

        // Assert
        _buffDebuffServiceMock.Verify(
            x => x.ApplyStatModifier(boss, "damage", 50, It.IsAny<string>()),
            Times.Once);
    }

    // ===== Vulnerability Tests =====

    [Test]
    public void SetVulnerable_SetsVulnerabilityAndFiresEvent()
    {
        // Arrange
        var (boss, _) = SetupActiveBoss(currentHealth: 80, maxHealth: 100);

        // Act
        _service.SetVulnerable(boss, 2);

        // Assert
        _service.IsVulnerable(boss).Should().BeTrue();
        _service.GetVulnerabilityMultiplier(boss).Should().Be(1.5f);
        _eventBusMock.Verify(x => x.Publish(It.Is<BossVulnerableEvent>(e => e.DurationTurns == 2)), Times.Once);
    }

    [Test]
    public void GetVulnerabilityMultiplier_WhenNotVulnerable_ReturnsOne()
    {
        // Arrange
        var (boss, _) = SetupActiveBoss(currentHealth: 80, maxHealth: 100);

        // Act
        var multiplier = _service.GetVulnerabilityMultiplier(boss);

        // Assert
        multiplier.Should().Be(1.0f);
    }

    [Test]
    public void TickBoss_DecrementsVulnerabilityAndFiresEndEvent()
    {
        // Arrange
        var (boss, _) = SetupActiveBoss(currentHealth: 80, maxHealth: 100);
        _service.SetVulnerable(boss, 1);

        // Act
        _service.TickBoss(boss);

        // Assert
        _service.IsVulnerable(boss).Should().BeFalse();
        _eventBusMock.Verify(x => x.Publish(It.IsAny<BossVulnerabilityEndedEvent>()), Times.Once);
    }

    // ===== TickBoss Summon Tests =====

    [Test]
    public void TickBoss_WhenSummonIntervalReached_AttemptsSummon()
    {
        // Arrange
        var (boss, bossDef) = SetupActiveBossWithSummonPhase();
        var state = _service.GetBossState(boss)!;
        state.TurnsSinceLastSummon = 1; // One turn away from interval

        var emptyPositions = new[] { new GridPosition(4, 5) };
        SetupGridWithEmptyPositions(boss.Position, emptyPositions);

        // Act
        _service.TickBoss(boss);

        // Assert
        _spawnServiceMock.Verify(
            x => x.SpawnByDefinitionId("skeleton-warrior", It.IsAny<GridPosition>()),
            Times.AtLeastOnce);
    }

    [Test]
    public void TickBoss_WhenAtSummonLimit_DoesNotSummon()
    {
        // Arrange
        var (boss, bossDef) = SetupActiveBossWithSummonPhase();
        var state = _service.GetBossState(boss)!;
        state.TurnsSinceLastSummon = 2;
        // Add summons to reach limit (4)
        for (int i = 0; i < 4; i++)
        {
            state.AddSummonedMinion(Guid.NewGuid());
        }

        // Act
        _service.TickBoss(boss);

        // Assert
        _spawnServiceMock.Verify(
            x => x.SpawnByDefinitionId(It.IsAny<string>(), It.IsAny<GridPosition>()),
            Times.Never);
    }

    // ===== Helper Methods =====

    private BossDefinition CreateTestBossDefinition(string bossId)
    {
        var phases = new[]
        {
            BossPhase.Create(1, "Phase 1", 100),
            BossPhase.Create(2, "Phase 2", 66),
            BossPhase.Create(3, "Phase 3", 33)
        };
        return BossDefinition.Create(bossId, "Test Boss", "A test boss", "base-monster", phases);
    }

    // ... additional helper methods
}
```

---

## 13. Use Cases

### UC-001: Spawn Boss in Combat

**Actor:** Encounter System
**Flow:** Encounter triggers boss spawn → IBossMechanicsService.SpawnBoss(bossId, position) called → Boss definition loaded → Base monster spawned → ActiveBossState created → Initial phase abilities set → BossSpawnedEvent published → UI displays title text

### UC-002: Boss Takes Damage (No Phase Change)

**Actor:** Combat System
**Flow:** Player attacks boss → Damage applied → OnBossDamaged(boss, damage) called → Health percentage calculated (e.g., 75%) → GetPhaseForHealth returns Phase 1 → Same as current phase → No transition → Continue combat

### UC-003: Boss Takes Damage (Phase Transition)

**Actor:** Combat System
**Flow:** Player attacks boss → Damage applied → OnBossDamaged(boss, damage) called → Health percentage calculated (e.g., 60%) → GetPhaseForHealth returns Phase 2 → Different from current (Phase 1) → TransitionToPhase executed → Transition effect triggered (knockback) → New stat modifiers applied → New abilities set → BossPhaseChangedEvent published → UI displays transition text

### UC-004: Boss Vulnerability Window

**Actor:** Ability System / Combat Service
**Flow:** Major boss ability exhausts boss → SetVulnerable(boss, 2) called → VulnerableTurns = 2 → BossVulnerableEvent published → UI shows vulnerability indicator → Player attacks → GetVulnerabilityMultiplier returns 1.5 → Enhanced damage dealt → Turn ends → TickBoss decrements VulnerableTurns → After 2 turns → VulnerableTurns = 0 → BossVulnerabilityEndedEvent published

### UC-005: Boss Summons Minions

**Actor:** Turn System
**Flow:** Boss turn ends → TickBoss(boss) called → Check summon config for current phase → TurnsSinceLastSummon >= IntervalTurns → Check summon limit (ActiveSummonCount < MaxActive) → Find valid spawn positions → SpawnByDefinitionId for each summon → Add minion IDs to SummonedMinionIds → Reset TurnsSinceLastSummon

### UC-006: Boss Defeated

**Actor:** Combat System
**Flow:** Player attacks boss → Damage applied → Boss health <= 0 → OnBossDamaged detects defeat → ActiveBossState removed → BossDefeatedEvent published with loot entries → Loot system processes drops → UI displays victory message

---

## 14. Deliverable Checklist

### Application Layer - Tracking

- [ ] `ActiveBossState` class created at `src/Core/RuneAndRust.Application/Tracking/ActiveBossState.cs`
- [ ] Properties: BossId, CurrentPhaseNumber, VulnerableTurns, TurnsSinceLastSummon, SummonedMinionIds
- [ ] Methods: IsVulnerable, CanSummon, AddSummonedMinion, RemoveSummonedMinion

### Application Layer - Events

- [ ] `BossSpawnedEvent` created at `src/Core/RuneAndRust.Application/Events/BossSpawnedEvent.cs`
- [ ] `BossPhaseChangedEvent` created at `src/Core/RuneAndRust.Application/Events/BossPhaseChangedEvent.cs`
- [ ] `BossVulnerableEvent` created at `src/Core/RuneAndRust.Application/Events/BossVulnerableEvent.cs`
- [ ] `BossVulnerabilityEndedEvent` created at `src/Core/RuneAndRust.Application/Events/BossVulnerabilityEndedEvent.cs`
- [ ] `BossDefeatedEvent` created at `src/Core/RuneAndRust.Application/Events/BossDefeatedEvent.cs`
- [ ] All events implement `IGameEvent`

### Application Layer - Interfaces

- [ ] `IBossMechanicsService` interface created at `src/Core/RuneAndRust.Application/Interfaces/IBossMechanicsService.cs`
- [ ] Interface has 12 methods (SpawnBoss, OnBossDamaged, GetCurrentPhase, GetBossState, IsVulnerable, GetVulnerabilityMultiplier, SetVulnerable, TickBoss, GetAvailableAbilities, IsBoss, GetActiveBosses, OnMinionDeath)

### Application Layer - Services

- [ ] `BossMechanicsService` implementation created at `src/Core/RuneAndRust.Application/Services/BossMechanicsService.cs`
- [ ] Dependencies injected via constructor
- [ ] Active boss state dictionary implemented
- [ ] Phase transition logic implemented
- [ ] Transition effect execution implemented (knockback-all-N, heal-minions, create-lava-zones)
- [ ] Stat modifier application implemented
- [ ] Vulnerability window mechanics implemented
- [ ] Summon interval tracking implemented
- [ ] Boss defeat handling implemented

### Testing

- [ ] `BossMechanicsServiceTests.cs` created (~12 tests)
- [ ] SpawnBoss tests (2 tests)
- [ ] Phase transition tests (3 tests)
- [ ] Transition effect tests (2 tests)
- [ ] Vulnerability tests (3 tests)
- [ ] TickBoss tests (2 tests)
- [ ] All ~12 tests passing

### Documentation

- [ ] Design specification complete (this document)
- [ ] All code snippets include file paths
- [ ] XML documentation complete on all public members

---

## 15. Acceptance Criteria

### Functional

- [ ] SpawnBoss creates monster from boss definition's base monster
- [ ] SpawnBoss initializes ActiveBossState with correct starting phase
- [ ] SpawnBoss fires BossSpawnedEvent with title text
- [ ] OnBossDamaged calculates health percentage correctly
- [ ] OnBossDamaged triggers phase transition when threshold crossed
- [ ] Phase transitions only go forward (higher phase numbers)
- [ ] TransitionToPhase executes transition text and effects
- [ ] knockback-all-N effect knocks back all players
- [ ] heal-minions effect heals summoned minions
- [ ] create-lava-zones effect creates environmental hazards
- [ ] ApplyPhaseModifiers clears previous modifiers before applying new
- [ ] Phase stat modifiers applied as percentage changes via IBuffDebuffService
- [ ] Boss behavior updated on phase change
- [ ] Boss abilities updated to current phase's ability list
- [ ] BossPhaseChangedEvent fired on phase transition
- [ ] SetVulnerable sets vulnerability duration and fires event
- [ ] IsVulnerable returns true when VulnerableTurns > 0
- [ ] GetVulnerabilityMultiplier returns 1.5 when vulnerable, 1.0 otherwise
- [ ] TickBoss decrements VulnerableTurns
- [ ] BossVulnerabilityEndedEvent fired when vulnerability expires
- [ ] TickBoss tracks summon intervals
- [ ] TrySummonMinions respects MaxActive limit
- [ ] Summoned minion IDs tracked in state
- [ ] OnMinionDeath removes minion from tracked summons
- [ ] Boss defeat removes state and fires BossDefeatedEvent

### Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~12 unit tests pass
- [ ] XML documentation complete on all public members
- [ ] Service follows dependency injection pattern
- [ ] Events follow immutable record pattern
- [ ] Integration with existing services (IBuffDebuffService, IEnvironmentalCombatService, IMonsterSpawnService, IEventBus)

---

## 16. Dependencies

### Required From

| Layer | Dependency | Usage |
|-------|------------|-------|
| v0.10.4a | `IBossProvider` | Boss definition retrieval |
| v0.10.4a | `BossDefinition` | Phase data, loot entries |
| v0.10.4a | `BossPhase` | Transition info, abilities |
| v0.10.4a | `SummonConfiguration` | Minion spawning config |
| v0.10.4a | `BossLootEntry` | Defeat loot data |
| Application | `IMonsterProvider` | Base monster definitions |
| Application | `IBuffDebuffService` | Stat modifier application |
| Application | `IEnvironmentalCombatService` | Knockback, zone creation |
| Application | `IMonsterSpawnService` | Boss and minion spawning |
| Application | `ICombatContext` | Grid access, combatant lookup |
| Application | `IEventBus` | Event publishing |
| Domain | `Monster` entity | Boss instance |
| Domain | `GridPosition` | Position handling |

### Provides To

| Consumer | Dependency | Usage |
|----------|------------|-------|
| Combat Service | `IBossMechanicsService` | Damage handling, vulnerability |
| Turn Service | `IBossMechanicsService.TickBoss` | Per-turn updates |
| AI Service | `IBossMechanicsService.GetAvailableAbilities` | Ability selection |
| Loot Service | `BossDefeatedEvent` | Boss loot drops |
| UI/Renderer | Boss events | Phase transitions, vulnerability display |

---

## 17. Future Considerations

### Deferred to Future Versions

- **Boss Spawning Integration**: Encounter room boss spawning integration
- **Boss AI Enhancement**: Complex multi-phase AI decision trees
- **Time-Based Enrage**: Automatic enrage after N turns regardless of phase
- **Phase-Specific Immunities**: Damage type immunities per phase
- **Boss Dialogue System**: Voice lines or text dialogue during phases

### Out of Scope for v0.10.4

- **Boss Audio/Visual**: Boss-specific sound effects and visual effects
- **Boss Difficulty Scaling**: Dynamic difficulty adjustment
- **Boss Checkpoints**: Save/restore mid-boss encounter

### Potential Enhancements (Future Versions)

- **Phase Interrupts**: Player abilities that can prevent phase transitions
- **Multi-Boss Encounters**: Multiple bosses with shared or independent phases
- **Boss Minion AI**: Coordinated minion behavior with boss
- **Boss Rage Meter**: Visible meter tracking progress to enrage

---

## 18. Logging Specifications

### Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `BossMechanicsService` | Information | Boss spawned, phase transition, vulnerability set, boss defeated |
| `BossMechanicsService` | Debug | Transition effect execution, modifier application, ability update, summon attempts |
| `BossMechanicsService` | Warning | Unknown transition effect, missing definition |

### Log Message Examples

```
[Information] Spawned boss Skeleton King (skeleton-king) at (5, 5), starting phase: Rise
[Information] Skeleton King transitioning from phase 1 to phase 2 (Legion)
[Information] Skeleton King is now vulnerable for 2 turns
[Information] Boss Skeleton King (skeleton-king) defeated!

[Debug] Executing transition effect: knockback-all-2
[Debug] Knocked back Player 2 cells from Skeleton King
[Debug] Applied phase 2 modifiers to Skeleton King: { damage: 1.5, defense: 0.75 }
[Debug] Updated Skeleton King abilities to: bone-strike, summon-skeletons, dark-shield
[Debug] Skeleton King summoned Skeleton Warrior at (4, 5)
[Debug] Skeleton King is no longer vulnerable

[Warning] Unknown transition effect: unknown-effect-id
[Warning] Boss definition not found for active boss: invalid-boss
```

---

*Document Version: 1.0*
*Last Updated: 2026-01-16*
