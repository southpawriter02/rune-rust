# v0.1.4c Design Specification: Faction Territory Control

**Version:** 0.1.4c
**Phase Name:** Faction Territory Control
**Parent Version:** v0.1.4 (World Persistence & Evolution)
**Prerequisites:** v0.1.4b Complete (Monster Repopulation)
**Estimated Tests:** ~32 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [FactionDefinition Entity](#4-factiondefinition-entity)
5. [TerritoryControl Entity](#5-territorycontrol-entity)
6. [FactionRelationship Value Object](#6-factionrelationship-value-object)
7. [TerritoryService](#7-territoryservice)
8. [Room Entity Integration](#8-room-entity-integration)
9. [Territory Expansion Mechanics](#9-territory-expansion-mechanics)
10. [Cross-Faction Conflict](#10-cross-faction-conflict)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement the faction territory control system that transforms dungeons into dynamic battlegrounds where monster factions compete for dominance. This phase builds on v0.1.4a's persistent world state and v0.1.4b's monster repopulation, adding monster factions that claim dungeon zones, expand territory based on player actions, and engage in cross-faction conflict. Players experience a living world where their choices affect the balance of power between competing monster groups.

### 1.2 Current State

| Area | Current State (v0.1.4b) | Target State (v0.1.4c) |
|------|-------------------------|------------------------|
| Monster groups | Individual spawners | Faction-organized groups |
| Room ownership | Not tracked | ControllingFaction per room |
| Territory | Not tracked | TerritoryControl zones |
| Faction relationships | None | Hostile/Neutral/Allied relationships |
| Expansion behavior | Static spawners | Dynamic territory expansion |
| Cross-faction conflict | None | Factions fight each other |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `FactionDefinition`, `TerritoryControl` |
| **Enums** | `FactionRelationshipType`, `TerritoryState` |
| **Value Objects** | `FactionRelationship`, `TerritoryBoundary`, `ExpansionRule` |
| **Services** | `TerritoryService` (with `ITerritoryService` interface) |
| **Configuration** | `faction-definitions.json`, `faction-definitions-schema.json` |
| **Entity Updates** | `Room.ControllingFaction`, `Spawner.FactionId` integration |
| **Tests** | ~32 new unit tests |

### 1.4 Architectural Significance

This version establishes the **faction control pattern** that creates political dungeons:
- Faction-based monster organization and behavior
- Territory tracking and zone ownership
- Dynamic expansion based on player actions (clearing rooms creates power vacuums)
- Cross-faction conflict resolution
- Foundation for environmental storytelling (v0.1.4d battle sites)
- Integration with RepopulationService for faction-controlled spawning

---

## 2. Feature Overview

```
v0.1.4c Faction Territory Control
├── FactionDefinition Entity
│   ├── Unique identification
│   ├── Faction name and description
│   ├── Monster types belonging to faction
│   ├── Preferred spawner types
│   ├── Aggression level
│   ├── Expansion priority
│   └── Home room types
├── TerritoryControl Entity
│   ├── Faction reference
│   ├── Controlled rooms collection
│   ├── Territory state (Stable, Expanding, Contested, Collapsing)
│   ├── Control strength per room
│   ├── Expansion targets
│   └── Last conflict timestamp
├── FactionRelationshipType Enum
│   ├── Hostile (attack on sight)
│   ├── Neutral (ignore unless provoked)
│   └── Allied (cooperate)
├── TerritoryState Enum
│   ├── Stable (no change)
│   ├── Expanding (gaining rooms)
│   ├── Contested (under attack)
│   └── Collapsing (losing rooms)
├── FactionRelationship Value Object
│   ├── Faction A reference
│   ├── Faction B reference
│   ├── Relationship type
│   └── Conflict history
├── TerritoryBoundary Value Object
│   ├── Room IDs at boundary
│   ├── Adjacent faction territories
│   └── Contested status
├── ExpansionRule Value Object
│   ├── Trigger conditions
│   ├── Target priority
│   ├── Expansion rate
│   └── Requirements
├── TerritoryService
│   ├── GetControllingFaction(roomId)
│   ├── SetRoomControl(roomId, factionId)
│   ├── ClearRoomControl(roomId)
│   ├── GetFactionTerritory(factionId)
│   ├── GetTerritoryBoundaries(factionId)
│   ├── CheckExpansionOpportunity(factionId)
│   ├── TriggerExpansion(factionId, targetRoomId)
│   ├── ProcessTerritoryConflicts()
│   ├── GetFactionRelationship(factionA, factionB)
│   ├── ResolveFactionConflict(roomId)
│   └── OnRoomCleared(roomId) [event handler]
├── Room Entity Updates
│   ├── ControllingFaction property
│   ├── FactionControlStrength property
│   ├── SetControllingFaction(factionId, strength)
│   ├── ClearControllingFaction()
│   └── IsContested property (computed)
├── Spawner Entity Updates
│   ├── FactionId property
│   └── SetFaction(factionId)
└── Configuration
    ├── faction-definitions.json
    └── faction-definitions-schema.json
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Faction control affects displayed content and narrative                     │
│  ├── Room descriptions mention controlling faction                          │
│  ├── Map displays faction territory colors/icons                            │
│  ├── Combat messages reflect faction allegiances                            │
│  └── Exploration reveals faction conflict zones                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  TerritoryService                                                            │
│  ├── GetControllingFaction(roomId)    ├── CheckExpansionOpportunity(id)    │
│  ├── SetRoomControl(roomId, faction)  ├── TriggerExpansion(faction, room)  │
│  ├── ClearRoomControl(roomId)         ├── ProcessTerritoryConflicts()      │
│  ├── GetFactionTerritory(factionId)   ├── GetFactionRelationship(a, b)     │
│  ├── GetTerritoryBoundaries(faction)  ├── ResolveFactionConflict(roomId)   │
│  │                                    └── OnRoomCleared(roomId)            │
│  │                                                                          │
│  Interfaces:                        RepopulationService (v0.1.4b Updated)   │
│  └── ITerritoryService              └── Uses faction for spawner selection  │
│                                                                              │
│  WorldStateService (v0.1.4a)        CombatService (Updated)                 │
│  └── Tracks faction territory       └── Triggers OnRoomCleared events       │
│      changes as persistent changes                                          │
│                                                                              │
│  Configuration:                                                              │
│  └── FactionDefinitionsConfigDto                                            │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Entities:                       Value Objects:                              │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                │
│  │ FactionDefinition       │     │ FactionRelationship     │                │
│  │ ├── Id: string          │     │ ├── FactionAId: string  │                │
│  │ ├── Name: string        │     │ ├── FactionBId: string  │                │
│  │ ├── Description         │     │ ├── RelationshipType    │                │
│  │ ├── MonsterTypeIds      │     │ └── ConflictCount: int  │                │
│  │ ├── PreferredSpawners   │     └─────────────────────────┘                │
│  │ ├── AggressionLevel     │     ┌─────────────────────────┐                │
│  │ ├── ExpansionPriority   │     │ TerritoryBoundary       │                │
│  │ └── HomeRoomTypes       │     │ ├── RoomIds: List<Guid> │                │
│  └─────────────────────────┘     │ ├── AdjacentFactions    │                │
│                                  │ └── IsContested: bool   │                │
│  ┌─────────────────────────┐     └─────────────────────────┘                │
│  │ TerritoryControl        │     ┌─────────────────────────┐                │
│  │ ├── Id: Guid            │     │ ExpansionRule           │                │
│  │ ├── FactionId: string   │     │ ├── TriggerCondition    │                │
│  │ ├── ControlledRooms     │     │ ├── TargetPriority      │                │
│  │ ├── TerritoryState      │     │ ├── ExpansionRate       │                │
│  │ ├── ControlStrength     │     │ └── Requirements        │                │
│  │ ├── ExpansionTargets    │     └─────────────────────────┘                │
│  │ └── LastConflict        │                                                │
│  └─────────────────────────┘     Enums:                                     │
│                                  ┌─────────────────────────┐                │
│  Entities (Updated):             │ FactionRelationshipType │                │
│  ┌─────────────────────────┐     │ ├── Hostile             │                │
│  │ Room                    │     │ ├── Neutral             │                │
│  │ ├── ControllingFaction  │     │ └── Allied              │                │
│  │ ├── FactionControlStrength    └─────────────────────────┘                │
│  │ └── IsContested         │     ┌─────────────────────────┐                │
│  └─────────────────────────┘     │ TerritoryState          │                │
│  ┌─────────────────────────┐     │ ├── Stable              │                │
│  │ Spawner                 │     │ ├── Expanding           │                │
│  │ └── FactionId: string?  │     │ ├── Contested           │                │
│  └─────────────────────────┘     │ └── Collapsing          │                │
│                                  └─────────────────────────┘                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetFactionDefinitions(): IReadOnlyList<FactionDefinition>              │
│  └── Loads and deserializes config/faction-definitions.json                 │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/faction-definitions.json                                        │
│  └── config/schemas/faction-definitions-schema.json                         │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Territory Control Flow

```
┌───────────────────────────────────────┐
│ Room cleared by player (CombatService)│
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ TerritoryService.OnRoomCleared(roomId)                        │
├───────────────────────────────────────────────────────────────┤
│ 1. Get previous controlling faction                           │
│ 2. Clear room control (creates power vacuum)                  │
│ 3. Notify adjacent faction territories                        │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ CheckExpansionOpportunity() for adjacent factions             │
├───────────────────────────────────────────────────────────────┤
│ For each adjacent faction:                                    │
│   1. Get faction's expansion rule                             │
│   2. Check if expansion conditions met                        │
│   3. Calculate expansion priority for this room               │
│   4. Add to faction's expansion targets                       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Multiple factions interested in same room?                    │
├───────────────┬───────────────────────────────────────────────┤
│     Yes       │                    No                         │
│       ▼       │                     ▼                         │
│ Mark room as  │              Single faction                   │
│ Contested     │              claims room                      │
│       │       │                     │                         │
│       ▼       │                     ▼                         │
│ Schedule      │              TriggerExpansion(                │
│ conflict      │                  factionId, roomId)           │
│ resolution    │                                               │
└───────────────┴───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ ProcessTerritoryConflicts() [called periodically]             │
├───────────────────────────────────────────────────────────────┤
│ For each contested room:                                      │
│   1. Get competing factions                                   │
│   2. Check faction relationship (Hostile/Neutral/Allied)      │
│   3. If Hostile: ResolveFactionConflict(roomId)              │
│   4. If Neutral: Higher aggression faction claims             │
│   5. If Allied: Random or shared control                      │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Faction Expansion Flow

```
┌───────────────────────────────────────────────────────────────┐
│ TerritoryService.TriggerExpansion(factionId, targetRoomId)    │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Validate expansion                                    │
├───────────────────────────────────────────────────────────────┤
│ - Target room is adjacent to faction territory                │
│ - Target room is not permanently cleared                      │
│ - Faction has sufficient strength (controlled rooms > min)    │
│ - Expansion rule conditions are met                           │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Claim room for faction                                │
├───────────────────────────────────────────────────────────────┤
│ room.SetControllingFaction(factionId, initialStrength);       │
│                                                               │
│ // Add room to faction's territory                            │
│ territory.AddControlledRoom(roomId);                          │
│ territory.UpdateState(TerritoryState.Expanding);              │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Assign faction spawners                               │
├───────────────────────────────────────────────────────────────┤
│ For existing spawners in room:                                │
│   spawner.SetFaction(factionId);                              │
│                                                               │
│ Or create new spawner if room has none:                       │
│   var spawnerType = faction.PreferredSpawnerTypes.First();    │
│   var monsterTypes = faction.MonsterTypeIds;                  │
│   room.AddSpawner(Spawner.Create(...));                       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: Set respawn timer for new territory                   │
├───────────────────────────────────────────────────────────────┤
│ RepopulationService.SetRespawnTimer(roomId);                  │
│                                                               │
│ Log: "Faction {Name} has claimed {RoomName}"                  │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 Cross-Faction Conflict Resolution

```
┌───────────────────────────────────────────────────────────────┐
│ TerritoryService.ResolveFactionConflict(roomId)               │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Get competing factions                                │
├───────────────────────────────────────────────────────────────┤
│ var competitors = GetFactionsCompetingFor(roomId);            │
│ // Returns factions with expansion targets including this room│
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Calculate conflict strength                           │
├───────────────────────────────────────────────────────────────┤
│ For each faction:                                             │
│   strength = adjacentControlledRooms * controlStrength        │
│            + aggressionLevel * 10                             │
│            + random(0, 20) // Combat variance                 │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Determine winner                                      │
├───────────────────────────────────────────────────────────────┤
│ var winner = competitors.OrderByDescending(c => c.Strength)   │
│                         .First();                             │
│                                                               │
│ var loser = competitors.Where(c => c != winner);              │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: Apply conflict results                                │
├───────────────────────────────────────────────────────────────┤
│ // Winner claims room                                         │
│ SetRoomControl(roomId, winner.FactionId);                     │
│                                                               │
│ // Losers retreat, may lose adjacent rooms                    │
│ foreach (var loser in losers)                                 │
│ {                                                             │
│     loser.Territory.UpdateState(TerritoryState.Collapsing);   │
│     loser.Territory.RemoveExpansionTarget(roomId);            │
│ }                                                             │
│                                                               │
│ // Record conflict in relationship history                    │
│ UpdateRelationshipConflictCount(winner, losers);              │
│                                                               │
│ // Clear contested flag                                       │
│ room.IsContested = false;                                     │
│                                                               │
│ Log: "Faction {Winner} defeated {Losers} for control of room" │
└───────────────────────────────────────────────────────────────┘
```

---

## 4. FactionDefinition Entity

### 4.1 Purpose

The `FactionDefinition` entity represents a group of monsters that share territory, spawn from common sources, and have defined relationships with other factions. Factions compete for dungeon control and respond to player actions.

### 4.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/FactionDefinition.cs`

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents a monster faction that claims and controls dungeon territory.
/// </summary>
/// <remarks>
/// Factions are groups of monsters that work together, share territory,
/// and have defined relationships with other factions. They expand into
/// cleared rooms and engage in conflicts with hostile factions.
/// </remarks>
public class FactionDefinition
{
    /// <summary>
    /// Gets the unique identifier for this faction.
    /// </summary>
    /// <remarks>
    /// String ID for easy reference in configuration (e.g., "undead", "goblin-tribe").
    /// </remarks>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name of the faction.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description of the faction.
    /// </summary>
    /// <remarks>
    /// Flavor text describing the faction's nature, goals, and behavior.
    /// </remarks>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the monster type IDs that belong to this faction.
    /// </summary>
    /// <remarks>
    /// Monsters of these types are spawned by faction-controlled spawners.
    /// </remarks>
    public IReadOnlyList<string> MonsterTypeIds => _monsterTypeIds.AsReadOnly();
    private readonly List<string> _monsterTypeIds = new();

    /// <summary>
    /// Gets the preferred spawner types for this faction.
    /// </summary>
    /// <remarks>
    /// When a faction claims a room, it prefers to create spawners of these types.
    /// </remarks>
    public IReadOnlyList<SpawnerType> PreferredSpawnerTypes => _preferredSpawnerTypes.AsReadOnly();
    private readonly List<SpawnerType> _preferredSpawnerTypes = new();

    /// <summary>
    /// Gets the aggression level of this faction (0-100).
    /// </summary>
    /// <remarks>
    /// Higher aggression means more likely to expand, attack other factions,
    /// and less likely to retreat from conflicts.
    /// </remarks>
    public int AggressionLevel { get; private set; }

    /// <summary>
    /// Gets the expansion priority of this faction (0-100).
    /// </summary>
    /// <remarks>
    /// Higher priority means the faction expands faster and targets
    /// more rooms when opportunities arise.
    /// </remarks>
    public int ExpansionPriority { get; private set; }

    /// <summary>
    /// Gets the room types this faction prefers for its home territory.
    /// </summary>
    /// <remarks>
    /// Factions are more likely to expand into and defend these room types.
    /// </remarks>
    public IReadOnlyList<RoomType> HomeRoomTypes => _homeRoomTypes.AsReadOnly();
    private readonly List<RoomType> _homeRoomTypes = new();

    /// <summary>
    /// Gets the relationships this faction has with other factions.
    /// </summary>
    public IReadOnlyDictionary<string, FactionRelationshipType> Relationships =>
        _relationships.AsReadOnly();
    private readonly Dictionary<string, FactionRelationshipType> _relationships = new();

    /// <summary>
    /// Gets the default relationship for factions not explicitly defined.
    /// </summary>
    public FactionRelationshipType DefaultRelationship { get; private set; } =
        FactionRelationshipType.Hostile;

    /// <summary>
    /// Gets whether this faction is currently active in the dungeon.
    /// </summary>
    public bool IsActive { get; private set; } = true;

    /// <summary>
    /// Private constructor for EF Core and deserialization.
    /// </summary>
    private FactionDefinition() { }

    /// <summary>
    /// Creates a new faction definition.
    /// </summary>
    public static FactionDefinition Create(
        string id,
        string name,
        string description,
        IEnumerable<string> monsterTypeIds,
        IEnumerable<SpawnerType> preferredSpawnerTypes,
        int aggressionLevel,
        int expansionPriority,
        IEnumerable<RoomType> homeRoomTypes)
    {
        if (string.IsNullOrWhiteSpace(id))
            throw new ArgumentException("Faction ID cannot be empty.", nameof(id));

        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Faction name cannot be empty.", nameof(name));

        if (aggressionLevel < 0 || aggressionLevel > 100)
            throw new ArgumentException("Aggression level must be between 0 and 100.", nameof(aggressionLevel));

        if (expansionPriority < 0 || expansionPriority > 100)
            throw new ArgumentException("Expansion priority must be between 0 and 100.", nameof(expansionPriority));

        var faction = new FactionDefinition
        {
            Id = id,
            Name = name,
            Description = description ?? string.Empty,
            AggressionLevel = aggressionLevel,
            ExpansionPriority = expansionPriority,
            IsActive = true
        };

        faction._monsterTypeIds.AddRange(monsterTypeIds ?? Enumerable.Empty<string>());
        faction._preferredSpawnerTypes.AddRange(preferredSpawnerTypes ?? Enumerable.Empty<SpawnerType>());
        faction._homeRoomTypes.AddRange(homeRoomTypes ?? Enumerable.Empty<RoomType>());

        if (faction._monsterTypeIds.Count == 0)
            throw new ArgumentException("Faction must have at least one monster type.", nameof(monsterTypeIds));

        if (faction._preferredSpawnerTypes.Count == 0)
            faction._preferredSpawnerTypes.Add(SpawnerType.Nest); // Default

        return faction;
    }

    /// <summary>
    /// Sets the relationship with another faction.
    /// </summary>
    /// <param name="otherFactionId">The other faction's ID.</param>
    /// <param name="relationship">The relationship type.</param>
    public void SetRelationship(string otherFactionId, FactionRelationshipType relationship)
    {
        if (string.IsNullOrWhiteSpace(otherFactionId))
            throw new ArgumentException("Other faction ID cannot be empty.", nameof(otherFactionId));

        _relationships[otherFactionId] = relationship;
    }

    /// <summary>
    /// Gets the relationship with another faction.
    /// </summary>
    /// <param name="otherFactionId">The other faction's ID.</param>
    /// <returns>The relationship type.</returns>
    public FactionRelationshipType GetRelationshipWith(string otherFactionId)
    {
        if (_relationships.TryGetValue(otherFactionId, out var relationship))
            return relationship;

        return DefaultRelationship;
    }

    /// <summary>
    /// Sets the default relationship for undefined faction pairs.
    /// </summary>
    public void SetDefaultRelationship(FactionRelationshipType relationship)
    {
        DefaultRelationship = relationship;
    }

    /// <summary>
    /// Checks if this faction prefers the given room type.
    /// </summary>
    public bool PrefersRoomType(RoomType roomType)
    {
        return _homeRoomTypes.Count == 0 || _homeRoomTypes.Contains(roomType);
    }

    /// <summary>
    /// Deactivates this faction.
    /// </summary>
    public void Deactivate()
    {
        IsActive = false;
    }

    /// <summary>
    /// Activates this faction.
    /// </summary>
    public void Activate()
    {
        IsActive = true;
    }

    /// <summary>
    /// Gets a random monster type from this faction.
    /// </summary>
    public string GetRandomMonsterType(Random? random = null)
    {
        random ??= Random.Shared;
        return _monsterTypeIds[random.Next(_monsterTypeIds.Count)];
    }

    /// <summary>
    /// Gets a string representation of the faction.
    /// </summary>
    public override string ToString() =>
        $"Faction[{Id}] {Name} (Aggression: {AggressionLevel}, Expansion: {ExpansionPriority})";
}
```

### 4.4 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `string` | Unique identifier | Required |
| `Name` | `string` | Display name | Required |
| `Description` | `string` | Flavor text | Empty |
| `MonsterTypeIds` | `IReadOnlyList<string>` | Monster types | Required |
| `PreferredSpawnerTypes` | `IReadOnlyList<SpawnerType>` | Spawner preferences | [Nest] |
| `AggressionLevel` | `int` | 0-100 aggression | Required |
| `ExpansionPriority` | `int` | 0-100 priority | Required |
| `HomeRoomTypes` | `IReadOnlyList<RoomType>` | Preferred rooms | Any |
| `Relationships` | `IReadOnlyDictionary<string, FactionRelationshipType>` | Faction relations | Empty |
| `DefaultRelationship` | `FactionRelationshipType` | Default relation | Hostile |
| `IsActive` | `bool` | Active status | true |

---

## 5. TerritoryControl Entity

### 5.1 Purpose

The `TerritoryControl` entity tracks a faction's controlled territory, including which rooms it controls, the strength of that control, and its expansion targets.

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/TerritoryControl.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Tracks a faction's territorial control within the dungeon.
/// </summary>
/// <remarks>
/// TerritoryControl maintains the state of a faction's holdings,
/// including controlled rooms, expansion targets, and territory state.
/// </remarks>
public class TerritoryControl
{
    /// <summary>
    /// Gets the unique identifier for this territory control record.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the faction ID this territory belongs to.
    /// </summary>
    public string FactionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the IDs of rooms controlled by this faction.
    /// </summary>
    public IReadOnlyList<Guid> ControlledRoomIds => _controlledRoomIds.AsReadOnly();
    private readonly List<Guid> _controlledRoomIds = new();

    /// <summary>
    /// Gets the control strength for each room (0-100).
    /// </summary>
    public IReadOnlyDictionary<Guid, int> RoomControlStrength =>
        _roomControlStrength.AsReadOnly();
    private readonly Dictionary<Guid, int> _roomControlStrength = new();

    /// <summary>
    /// Gets the current state of this territory.
    /// </summary>
    public TerritoryState State { get; private set; } = TerritoryState.Stable;

    /// <summary>
    /// Gets the IDs of rooms this faction is targeting for expansion.
    /// </summary>
    public IReadOnlyList<Guid> ExpansionTargets => _expansionTargets.AsReadOnly();
    private readonly List<Guid> _expansionTargets = new();

    /// <summary>
    /// Gets when this territory last experienced a conflict.
    /// </summary>
    public DateTime? LastConflict { get; private set; }

    /// <summary>
    /// Gets the total number of rooms controlled.
    /// </summary>
    public int TotalRooms => _controlledRoomIds.Count;

    /// <summary>
    /// Gets the average control strength across all rooms.
    /// </summary>
    public double AverageControlStrength =>
        _roomControlStrength.Count > 0
            ? _roomControlStrength.Values.Average()
            : 0;

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private TerritoryControl() { }

    /// <summary>
    /// Creates a new territory control record for a faction.
    /// </summary>
    public static TerritoryControl Create(string factionId)
    {
        if (string.IsNullOrWhiteSpace(factionId))
            throw new ArgumentException("Faction ID cannot be empty.", nameof(factionId));

        return new TerritoryControl
        {
            Id = Guid.NewGuid(),
            FactionId = factionId,
            State = TerritoryState.Stable
        };
    }

    /// <summary>
    /// Adds a room to this faction's controlled territory.
    /// </summary>
    /// <param name="roomId">The room to add.</param>
    /// <param name="controlStrength">Initial control strength (0-100).</param>
    public void AddControlledRoom(Guid roomId, int controlStrength = 50)
    {
        if (roomId == Guid.Empty)
            throw new ArgumentException("Room ID cannot be empty.", nameof(roomId));

        controlStrength = Math.Clamp(controlStrength, 0, 100);

        if (!_controlledRoomIds.Contains(roomId))
        {
            _controlledRoomIds.Add(roomId);
        }

        _roomControlStrength[roomId] = controlStrength;

        // Remove from expansion targets if claimed
        _expansionTargets.Remove(roomId);
    }

    /// <summary>
    /// Removes a room from this faction's controlled territory.
    /// </summary>
    /// <param name="roomId">The room to remove.</param>
    /// <returns>True if the room was removed.</returns>
    public bool RemoveControlledRoom(Guid roomId)
    {
        _roomControlStrength.Remove(roomId);
        return _controlledRoomIds.Remove(roomId);
    }

    /// <summary>
    /// Gets the control strength for a specific room.
    /// </summary>
    public int GetControlStrength(Guid roomId)
    {
        return _roomControlStrength.TryGetValue(roomId, out var strength) ? strength : 0;
    }

    /// <summary>
    /// Updates the control strength for a room.
    /// </summary>
    public void SetControlStrength(Guid roomId, int strength)
    {
        if (!_controlledRoomIds.Contains(roomId))
            return;

        _roomControlStrength[roomId] = Math.Clamp(strength, 0, 100);
    }

    /// <summary>
    /// Increases control strength for a room.
    /// </summary>
    public void IncreaseControlStrength(Guid roomId, int amount)
    {
        var current = GetControlStrength(roomId);
        SetControlStrength(roomId, current + amount);
    }

    /// <summary>
    /// Decreases control strength for a room.
    /// </summary>
    public void DecreaseControlStrength(Guid roomId, int amount)
    {
        var current = GetControlStrength(roomId);
        SetControlStrength(roomId, current - amount);
    }

    /// <summary>
    /// Adds a room as an expansion target.
    /// </summary>
    public void AddExpansionTarget(Guid roomId)
    {
        if (roomId == Guid.Empty)
            throw new ArgumentException("Room ID cannot be empty.", nameof(roomId));

        if (!_expansionTargets.Contains(roomId) && !_controlledRoomIds.Contains(roomId))
        {
            _expansionTargets.Add(roomId);
        }
    }

    /// <summary>
    /// Removes a room from expansion targets.
    /// </summary>
    public bool RemoveExpansionTarget(Guid roomId)
    {
        return _expansionTargets.Remove(roomId);
    }

    /// <summary>
    /// Updates the territory state.
    /// </summary>
    public void UpdateState(TerritoryState newState)
    {
        State = newState;
    }

    /// <summary>
    /// Records a conflict event.
    /// </summary>
    public void RecordConflict()
    {
        LastConflict = DateTime.UtcNow;
    }

    /// <summary>
    /// Checks if this faction controls the specified room.
    /// </summary>
    public bool ControlsRoom(Guid roomId)
    {
        return _controlledRoomIds.Contains(roomId);
    }

    /// <summary>
    /// Checks if this faction is targeting the specified room for expansion.
    /// </summary>
    public bool IsTargeting(Guid roomId)
    {
        return _expansionTargets.Contains(roomId);
    }

    /// <summary>
    /// Gets a string representation of the territory control.
    /// </summary>
    public override string ToString() =>
        $"Territory[{FactionId}] {TotalRooms} rooms, State: {State}, Targets: {_expansionTargets.Count}";
}
```

### 5.4 TerritoryState Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/TerritoryState.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// States a faction's territory can be in.
/// </summary>
/// <remarks>
/// Territory state affects how the faction behaves and how
/// quickly it expands or contracts.
/// </remarks>
public enum TerritoryState
{
    /// <summary>
    /// Territory is stable with no active changes.
    /// </summary>
    /// <remarks>
    /// Faction maintains current holdings without
    /// aggressive expansion or retreat.
    /// </remarks>
    Stable = 0,

    /// <summary>
    /// Territory is actively expanding.
    /// </summary>
    /// <remarks>
    /// Faction is claiming new rooms and increasing
    /// its dungeon presence.
    /// </remarks>
    Expanding = 1,

    /// <summary>
    /// Territory is under attack or disputed.
    /// </summary>
    /// <remarks>
    /// One or more rooms are being contested by
    /// other factions or player actions.
    /// </remarks>
    Contested = 2,

    /// <summary>
    /// Territory is shrinking.
    /// </summary>
    /// <remarks>
    /// Faction is losing rooms to other factions
    /// or player clearing. May retreat to core territory.
    /// </remarks>
    Collapsing = 3
}
```

---

## 6. FactionRelationship Value Object

### 6.1 Purpose

The `FactionRelationship` value object represents the relationship between two factions, including their stance toward each other and conflict history.

### 6.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/FactionRelationship.cs`

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the relationship between two factions.
/// </summary>
/// <remarks>
/// Tracks how two factions interact, including their relationship
/// type and history of conflicts. Relationships are bidirectional.
/// </remarks>
public readonly record struct FactionRelationship
{
    /// <summary>
    /// Gets the first faction's ID.
    /// </summary>
    public string FactionAId { get; init; }

    /// <summary>
    /// Gets the second faction's ID.
    /// </summary>
    public string FactionBId { get; init; }

    /// <summary>
    /// Gets the relationship type between the factions.
    /// </summary>
    public FactionRelationshipType RelationshipType { get; init; }

    /// <summary>
    /// Gets the number of conflicts between these factions.
    /// </summary>
    public int ConflictCount { get; init; }

    /// <summary>
    /// Gets when this relationship was last updated.
    /// </summary>
    public DateTime LastUpdated { get; init; }

    /// <summary>
    /// Creates a new faction relationship.
    /// </summary>
    public static FactionRelationship Create(
        string factionAId,
        string factionBId,
        FactionRelationshipType relationshipType)
    {
        if (string.IsNullOrWhiteSpace(factionAId))
            throw new ArgumentException("Faction A ID cannot be empty.", nameof(factionAId));

        if (string.IsNullOrWhiteSpace(factionBId))
            throw new ArgumentException("Faction B ID cannot be empty.", nameof(factionBId));

        // Normalize ordering for consistent lookups
        var (first, second) = string.Compare(factionAId, factionBId, StringComparison.Ordinal) < 0
            ? (factionAId, factionBId)
            : (factionBId, factionAId);

        return new FactionRelationship
        {
            FactionAId = first,
            FactionBId = second,
            RelationshipType = relationshipType,
            ConflictCount = 0,
            LastUpdated = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Creates a hostile relationship.
    /// </summary>
    public static FactionRelationship Hostile(string factionAId, string factionBId) =>
        Create(factionAId, factionBId, FactionRelationshipType.Hostile);

    /// <summary>
    /// Creates a neutral relationship.
    /// </summary>
    public static FactionRelationship Neutral(string factionAId, string factionBId) =>
        Create(factionAId, factionBId, FactionRelationshipType.Neutral);

    /// <summary>
    /// Creates an allied relationship.
    /// </summary>
    public static FactionRelationship Allied(string factionAId, string factionBId) =>
        Create(factionAId, factionBId, FactionRelationshipType.Allied);

    /// <summary>
    /// Records a conflict between the factions.
    /// </summary>
    public FactionRelationship WithConflict() => this with
    {
        ConflictCount = ConflictCount + 1,
        LastUpdated = DateTime.UtcNow
    };

    /// <summary>
    /// Changes the relationship type.
    /// </summary>
    public FactionRelationship WithRelationshipType(FactionRelationshipType newType) => this with
    {
        RelationshipType = newType,
        LastUpdated = DateTime.UtcNow
    };

    /// <summary>
    /// Checks if this relationship involves the specified faction.
    /// </summary>
    public bool InvolvesFaction(string factionId) =>
        FactionAId == factionId || FactionBId == factionId;

    /// <summary>
    /// Gets the other faction in this relationship.
    /// </summary>
    public string GetOtherFaction(string factionId)
    {
        if (FactionAId == factionId)
            return FactionBId;
        if (FactionBId == factionId)
            return FactionAId;

        throw new ArgumentException("Faction is not part of this relationship.", nameof(factionId));
    }

    /// <summary>
    /// Gets a string representation of the relationship.
    /// </summary>
    public override string ToString() =>
        $"{FactionAId} <-> {FactionBId}: {RelationshipType} (Conflicts: {ConflictCount})";
}
```

### 6.4 FactionRelationshipType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/FactionRelationshipType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of relationships between factions.
/// </summary>
/// <remarks>
/// Determines how factions interact when they encounter
/// each other or compete for territory.
/// </remarks>
public enum FactionRelationshipType
{
    /// <summary>
    /// Factions attack each other on sight.
    /// </summary>
    /// <remarks>
    /// Will fight for contested territory. Members attack
    /// members of the other faction immediately.
    /// </remarks>
    Hostile = 0,

    /// <summary>
    /// Factions ignore each other unless provoked.
    /// </summary>
    /// <remarks>
    /// May share territory boundaries peacefully.
    /// Higher aggression faction claims contested rooms.
    /// </remarks>
    Neutral = 1,

    /// <summary>
    /// Factions cooperate and share territory.
    /// </summary>
    /// <remarks>
    /// May share rooms or coordinate expansion.
    /// Will not fight each other for territory.
    /// </remarks>
    Allied = 2
}
```

---

## 7. TerritoryService

### 7.1 Purpose

The `TerritoryService` manages all aspects of faction territory control, including room ownership, expansion, and conflict resolution.

### 7.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/ITerritoryService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/TerritoryService.cs`

### 7.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing faction territory control.
/// </summary>
public interface ITerritoryService
{
    /// <summary>
    /// Gets the faction controlling a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>The controlling faction ID, or null if uncontrolled.</returns>
    string? GetControllingFaction(Guid roomId);

    /// <summary>
    /// Sets a faction's control over a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="factionId">The faction identifier.</param>
    /// <param name="controlStrength">Initial control strength (0-100).</param>
    void SetRoomControl(Guid roomId, string factionId, int controlStrength = 50);

    /// <summary>
    /// Clears faction control from a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    void ClearRoomControl(Guid roomId);

    /// <summary>
    /// Gets all rooms controlled by a faction.
    /// </summary>
    /// <param name="factionId">The faction identifier.</param>
    /// <returns>The faction's territory control.</returns>
    TerritoryControl? GetFactionTerritory(string factionId);

    /// <summary>
    /// Gets rooms at the boundary of a faction's territory.
    /// </summary>
    /// <param name="factionId">The faction identifier.</param>
    /// <returns>Boundary information.</returns>
    TerritoryBoundary GetTerritoryBoundaries(string factionId);

    /// <summary>
    /// Checks for expansion opportunities for a faction.
    /// </summary>
    /// <param name="factionId">The faction identifier.</param>
    /// <returns>Room IDs available for expansion.</returns>
    IReadOnlyList<Guid> CheckExpansionOpportunities(string factionId);

    /// <summary>
    /// Triggers faction expansion into a target room.
    /// </summary>
    /// <param name="factionId">The faction identifier.</param>
    /// <param name="targetRoomId">The room to claim.</param>
    /// <returns>True if expansion succeeded.</returns>
    bool TriggerExpansion(string factionId, Guid targetRoomId);

    /// <summary>
    /// Processes all pending territory conflicts.
    /// </summary>
    /// <returns>Room IDs where conflicts were resolved.</returns>
    IReadOnlyList<Guid> ProcessTerritoryConflicts();

    /// <summary>
    /// Gets the relationship between two factions.
    /// </summary>
    FactionRelationship GetFactionRelationship(string factionAId, string factionBId);

    /// <summary>
    /// Resolves a conflict in a contested room.
    /// </summary>
    /// <param name="roomId">The contested room.</param>
    /// <returns>The winning faction ID, or null if no resolution.</returns>
    string? ResolveFactionConflict(Guid roomId);

    /// <summary>
    /// Event handler for when a room is cleared by the player.
    /// </summary>
    /// <param name="roomId">The cleared room.</param>
    void OnRoomCleared(Guid roomId);

    /// <summary>
    /// Gets all active factions.
    /// </summary>
    IReadOnlyList<FactionDefinition> GetActiveFactions();

    /// <summary>
    /// Gets a faction by ID.
    /// </summary>
    FactionDefinition? GetFaction(string factionId);

    /// <summary>
    /// Gets factions competing for a specific room.
    /// </summary>
    IReadOnlyList<string> GetCompetingFactions(Guid roomId);

    /// <summary>
    /// Checks if a room is contested between factions.
    /// </summary>
    bool IsRoomContested(Guid roomId);
}
```

### 7.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing faction territory control.
/// </summary>
public class TerritoryService : ITerritoryService
{
    private readonly IConfigurationProvider _config;
    private readonly IRepopulationService _repopulationService;
    private readonly ILogger<TerritoryService> _logger;

    private readonly Dictionary<string, FactionDefinition> _factions = new();
    private readonly Dictionary<string, TerritoryControl> _territories = new();
    private readonly Dictionary<Guid, string> _roomToFaction = new();
    private readonly HashSet<Guid> _contestedRooms = new();
    private readonly List<FactionRelationship> _relationships = new();
    private readonly Dictionary<Guid, Room> _trackedRooms = new();

    /// <summary>
    /// Initializes a new instance of the TerritoryService.
    /// </summary>
    public TerritoryService(
        IConfigurationProvider config,
        IRepopulationService repopulationService,
        ILogger<TerritoryService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _repopulationService = repopulationService ?? throw new ArgumentNullException(nameof(repopulationService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        LoadFactions();
    }

    private void LoadFactions()
    {
        var definitions = _config.GetFactionDefinitions();
        foreach (var faction in definitions)
        {
            _factions[faction.Id] = faction;
            _territories[faction.Id] = TerritoryControl.Create(faction.Id);

            _logger.LogDebug("Loaded faction {FactionId}: {FactionName}", faction.Id, faction.Name);
        }

        // Build relationships from faction definitions
        foreach (var faction in _factions.Values)
        {
            foreach (var (otherFactionId, relationshipType) in faction.Relationships)
            {
                var existing = _relationships.FirstOrDefault(r =>
                    r.InvolvesFaction(faction.Id) && r.InvolvesFaction(otherFactionId));

                if (existing.Equals(default(FactionRelationship)))
                {
                    _relationships.Add(FactionRelationship.Create(faction.Id, otherFactionId, relationshipType));
                }
            }
        }

        _logger.LogInformation("Loaded {FactionCount} factions with {RelationshipCount} relationships",
            _factions.Count, _relationships.Count);
    }

    /// <summary>
    /// Registers a room for territory tracking.
    /// </summary>
    public void RegisterRoom(Room room)
    {
        if (room == null)
            throw new ArgumentNullException(nameof(room));

        _trackedRooms[room.Id] = room;
    }

    /// <inheritdoc />
    public string? GetControllingFaction(Guid roomId)
    {
        return _roomToFaction.TryGetValue(roomId, out var factionId) ? factionId : null;
    }

    /// <inheritdoc />
    public void SetRoomControl(Guid roomId, string factionId, int controlStrength = 50)
    {
        if (!_factions.ContainsKey(factionId))
        {
            _logger.LogWarning("Cannot set room control: faction {FactionId} not found", factionId);
            return;
        }

        if (!_trackedRooms.TryGetValue(roomId, out var room))
        {
            _logger.LogWarning("Cannot set room control: room {RoomId} not tracked", roomId);
            return;
        }

        // Remove from previous faction if any
        var previousFaction = GetControllingFaction(roomId);
        if (previousFaction != null && previousFaction != factionId)
        {
            _territories[previousFaction].RemoveControlledRoom(roomId);
        }

        // Add to new faction
        _roomToFaction[roomId] = factionId;
        _territories[factionId].AddControlledRoom(roomId, controlStrength);
        room.SetControllingFaction(factionId, controlStrength);

        // Update spawners in room to belong to faction
        foreach (var spawner in room.Spawners)
        {
            spawner.SetFaction(factionId);
        }

        _contestedRooms.Remove(roomId);

        _logger.LogInformation(
            "Faction {FactionId} now controls room {RoomId} (strength: {Strength})",
            factionId, roomId, controlStrength);
    }

    /// <inheritdoc />
    public void ClearRoomControl(Guid roomId)
    {
        var previousFaction = GetControllingFaction(roomId);
        if (previousFaction == null)
            return;

        _territories[previousFaction].RemoveControlledRoom(roomId);
        _roomToFaction.Remove(roomId);

        if (_trackedRooms.TryGetValue(roomId, out var room))
        {
            room.ClearControllingFaction();
        }

        _logger.LogInformation(
            "Cleared faction control from room {RoomId} (was {FactionId})",
            roomId, previousFaction);
    }

    /// <inheritdoc />
    public TerritoryControl? GetFactionTerritory(string factionId)
    {
        return _territories.TryGetValue(factionId, out var territory) ? territory : null;
    }

    /// <inheritdoc />
    public TerritoryBoundary GetTerritoryBoundaries(string factionId)
    {
        if (!_territories.TryGetValue(factionId, out var territory))
        {
            return TerritoryBoundary.Empty;
        }

        var boundaryRooms = new List<Guid>();
        var adjacentFactions = new HashSet<string>();

        foreach (var roomId in territory.ControlledRoomIds)
        {
            if (!_trackedRooms.TryGetValue(roomId, out var room))
                continue;

            // Check if room is at boundary (has adjacent rooms not controlled by this faction)
            var adjacentRoomIds = GetAdjacentRoomIds(roomId);
            var hasExternalAdjacent = false;

            foreach (var adjacentId in adjacentRoomIds)
            {
                var adjacentFaction = GetControllingFaction(adjacentId);
                if (adjacentFaction != factionId)
                {
                    hasExternalAdjacent = true;
                    if (adjacentFaction != null)
                    {
                        adjacentFactions.Add(adjacentFaction);
                    }
                }
            }

            if (hasExternalAdjacent)
            {
                boundaryRooms.Add(roomId);
            }
        }

        return TerritoryBoundary.Create(boundaryRooms, adjacentFactions.ToList());
    }

    /// <inheritdoc />
    public IReadOnlyList<Guid> CheckExpansionOpportunities(string factionId)
    {
        if (!_factions.TryGetValue(factionId, out var faction))
            return Array.Empty<Guid>();

        if (!_territories.TryGetValue(factionId, out var territory))
            return Array.Empty<Guid>();

        var opportunities = new List<Guid>();
        var boundary = GetTerritoryBoundaries(factionId);

        foreach (var boundaryRoomId in boundary.RoomIds)
        {
            var adjacentRoomIds = GetAdjacentRoomIds(boundaryRoomId);

            foreach (var adjacentId in adjacentRoomIds)
            {
                // Skip if already controlled by this faction
                if (territory.ControlsRoom(adjacentId))
                    continue;

                // Skip if already targeted
                if (territory.IsTargeting(adjacentId))
                    continue;

                // Skip if permanently cleared
                if (_trackedRooms.TryGetValue(adjacentId, out var room) && room.IsPermanentlyCleared)
                    continue;

                // Check room type preference
                if (_trackedRooms.TryGetValue(adjacentId, out room) && !faction.PrefersRoomType(room.RoomType))
                {
                    // Lower priority, but still possible
                    if (faction.ExpansionPriority < 50)
                        continue;
                }

                // Check if controlled by hostile faction (affects priority)
                var currentController = GetControllingFaction(adjacentId);
                if (currentController != null)
                {
                    var relationship = GetFactionRelationship(factionId, currentController);
                    if (relationship.RelationshipType == FactionRelationshipType.Allied)
                        continue; // Don't expand into ally territory
                }

                opportunities.Add(adjacentId);
            }
        }

        _logger.LogDebug(
            "Faction {FactionId} has {Count} expansion opportunities",
            factionId, opportunities.Count);

        return opportunities;
    }

    /// <inheritdoc />
    public bool TriggerExpansion(string factionId, Guid targetRoomId)
    {
        if (!_factions.TryGetValue(factionId, out var faction))
        {
            _logger.LogWarning("Cannot expand: faction {FactionId} not found", factionId);
            return false;
        }

        if (!_territories.TryGetValue(factionId, out var territory))
            return false;

        // Validate expansion
        var opportunities = CheckExpansionOpportunities(factionId);
        if (!opportunities.Contains(targetRoomId))
        {
            _logger.LogDebug(
                "Faction {FactionId} cannot expand to room {RoomId}: not a valid opportunity",
                factionId, targetRoomId);
            return false;
        }

        // Check if contested
        var currentController = GetControllingFaction(targetRoomId);
        if (currentController != null)
        {
            // Mark as contested, don't claim yet
            _contestedRooms.Add(targetRoomId);
            territory.AddExpansionTarget(targetRoomId);
            territory.UpdateState(TerritoryState.Contested);

            _logger.LogInformation(
                "Room {RoomId} is now contested between {FactionId} and {CurrentController}",
                targetRoomId, factionId, currentController);

            return true;
        }

        // Claim room
        var initialStrength = 30 + (faction.AggressionLevel / 2); // 30-80 based on aggression
        SetRoomControl(targetRoomId, factionId, initialStrength);
        territory.UpdateState(TerritoryState.Expanding);

        // Set up respawning for the new territory
        _repopulationService.SetRespawnTimer(targetRoomId);

        _logger.LogInformation(
            "Faction {FactionId} ({FactionName}) expanded into room {RoomId}",
            factionId, faction.Name, targetRoomId);

        return true;
    }

    /// <inheritdoc />
    public IReadOnlyList<Guid> ProcessTerritoryConflicts()
    {
        var resolved = new List<Guid>();

        foreach (var roomId in _contestedRooms.ToList())
        {
            var winner = ResolveFactionConflict(roomId);
            if (winner != null)
            {
                resolved.Add(roomId);
            }
        }

        if (resolved.Count > 0)
        {
            _logger.LogInformation("Resolved {Count} territory conflicts", resolved.Count);
        }

        return resolved;
    }

    /// <inheritdoc />
    public FactionRelationship GetFactionRelationship(string factionAId, string factionBId)
    {
        var existing = _relationships.FirstOrDefault(r =>
            r.InvolvesFaction(factionAId) && r.InvolvesFaction(factionBId));

        if (!existing.Equals(default(FactionRelationship)))
            return existing;

        // Create default relationship
        var factionA = _factions.GetValueOrDefault(factionAId);
        var defaultType = factionA?.DefaultRelationship ?? FactionRelationshipType.Hostile;

        return FactionRelationship.Create(factionAId, factionBId, defaultType);
    }

    /// <inheritdoc />
    public string? ResolveFactionConflict(Guid roomId)
    {
        if (!_contestedRooms.Contains(roomId))
            return null;

        var competitors = GetCompetingFactions(roomId);
        if (competitors.Count < 2)
        {
            _contestedRooms.Remove(roomId);
            return null;
        }

        // Calculate conflict strength for each faction
        var strengths = new Dictionary<string, int>();
        var random = Random.Shared;

        foreach (var factionId in competitors)
        {
            var faction = _factions[factionId];
            var territory = _territories[factionId];

            // Adjacent rooms provide strength
            var adjacentControlled = GetAdjacentRoomIds(roomId)
                .Count(adj => territory.ControlsRoom(adj));

            var strength = adjacentControlled * territory.GetControlStrength(roomId)
                + faction.AggressionLevel * 10
                + random.Next(0, 20);

            strengths[factionId] = strength;
        }

        // Winner is faction with highest strength
        var winner = strengths.OrderByDescending(kvp => kvp.Value).First().Key;
        var losers = competitors.Where(f => f != winner).ToList();

        // Apply results
        SetRoomControl(roomId, winner);
        _contestedRooms.Remove(roomId);

        foreach (var loserId in losers)
        {
            var loserTerritory = _territories[loserId];
            loserTerritory.RemoveExpansionTarget(roomId);
            loserTerritory.UpdateState(TerritoryState.Collapsing);
            loserTerritory.RecordConflict();

            // Update relationship with conflict
            var index = _relationships.FindIndex(r =>
                r.InvolvesFaction(winner) && r.InvolvesFaction(loserId));

            if (index >= 0)
            {
                _relationships[index] = _relationships[index].WithConflict();
            }
        }

        if (_trackedRooms.TryGetValue(roomId, out var room))
        {
            room.SetContested(false);
        }

        _logger.LogInformation(
            "Faction {Winner} won conflict against {Losers} for room {RoomId}",
            winner, string.Join(", ", losers), roomId);

        return winner;
    }

    /// <inheritdoc />
    public void OnRoomCleared(Guid roomId)
    {
        var previousFaction = GetControllingFaction(roomId);

        // Clear the room control (creates power vacuum)
        ClearRoomControl(roomId);

        if (previousFaction != null)
        {
            var territory = _territories[previousFaction];
            territory.UpdateState(TerritoryState.Collapsing);

            _logger.LogInformation(
                "Room {RoomId} cleared by player, faction {FactionId} loses control",
                roomId, previousFaction);
        }

        // Check for expansion opportunities from adjacent factions
        var adjacentRoomIds = GetAdjacentRoomIds(roomId);
        var adjacentFactions = adjacentRoomIds
            .Select(adj => GetControllingFaction(adj))
            .Where(f => f != null)
            .Distinct()
            .ToList();

        foreach (var factionId in adjacentFactions)
        {
            var faction = _factions[factionId!];

            // High expansion priority factions immediately target cleared rooms
            if (faction.ExpansionPriority >= 50)
            {
                _territories[factionId!].AddExpansionTarget(roomId);

                _logger.LogDebug(
                    "Faction {FactionId} targeting cleared room {RoomId} for expansion",
                    factionId, roomId);
            }
        }

        // If multiple factions targeting, mark as contested
        var targetingFactions = _territories.Values
            .Where(t => t.IsTargeting(roomId))
            .ToList();

        if (targetingFactions.Count > 1)
        {
            _contestedRooms.Add(roomId);
            if (_trackedRooms.TryGetValue(roomId, out var room))
            {
                room.SetContested(true);
            }
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<FactionDefinition> GetActiveFactions()
    {
        return _factions.Values.Where(f => f.IsActive).ToList();
    }

    /// <inheritdoc />
    public FactionDefinition? GetFaction(string factionId)
    {
        return _factions.TryGetValue(factionId, out var faction) ? faction : null;
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetCompetingFactions(Guid roomId)
    {
        var competitors = new List<string>();

        // Current controller if any
        var controller = GetControllingFaction(roomId);
        if (controller != null)
        {
            competitors.Add(controller);
        }

        // Factions targeting this room
        foreach (var (factionId, territory) in _territories)
        {
            if (territory.IsTargeting(roomId) && !competitors.Contains(factionId))
            {
                competitors.Add(factionId);
            }
        }

        return competitors;
    }

    /// <inheritdoc />
    public bool IsRoomContested(Guid roomId)
    {
        return _contestedRooms.Contains(roomId);
    }

    /// <summary>
    /// Gets adjacent room IDs for a room.
    /// </summary>
    private IReadOnlyList<Guid> GetAdjacentRoomIds(Guid roomId)
    {
        // In a full implementation, this would use dungeon layout data
        // For now, return empty - would be populated from room connections
        if (!_trackedRooms.TryGetValue(roomId, out var room))
            return Array.Empty<Guid>();

        // Assuming Room has ConnectedRoomIds property (from dungeon generation)
        return room.ConnectedRoomIds ?? Array.Empty<Guid>();
    }
}
```

---

## 8. Room Entity Integration

### 8.1 Purpose

Extend the `Room` entity with faction control properties and the `Spawner` entity with faction assignment.

### 8.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modification)

### 8.3 Room Changes

```csharp
// Add to Room.cs - after spawner properties from v0.1.4b

/// <summary>
/// Gets the ID of the faction controlling this room.
/// </summary>
/// <remarks>
/// Null if no faction controls this room. Controlled rooms
/// spawn monsters of the controlling faction's type.
/// </remarks>
public string? ControllingFactionId { get; private set; }

/// <summary>
/// Gets the strength of faction control (0-100).
/// </summary>
/// <remarks>
/// Higher control strength means the faction has stronger
/// presence and is less likely to lose the room.
/// </remarks>
public int FactionControlStrength { get; private set; }

/// <summary>
/// Gets whether this room is contested between factions.
/// </summary>
public bool IsContested { get; private set; }

/// <summary>
/// Gets the IDs of rooms connected to this one.
/// </summary>
/// <remarks>
/// Used for territory expansion calculations.
/// Set during dungeon generation.
/// </remarks>
public IReadOnlyList<Guid> ConnectedRoomIds => _connectedRoomIds.AsReadOnly();
private readonly List<Guid> _connectedRoomIds = new();

/// <summary>
/// Sets the controlling faction for this room.
/// </summary>
/// <param name="factionId">The faction ID.</param>
/// <param name="controlStrength">Control strength (0-100).</param>
public void SetControllingFaction(string factionId, int controlStrength = 50)
{
    if (string.IsNullOrWhiteSpace(factionId))
        throw new ArgumentException("Faction ID cannot be empty.", nameof(factionId));

    ControllingFactionId = factionId;
    FactionControlStrength = Math.Clamp(controlStrength, 0, 100);
    IsContested = false;
}

/// <summary>
/// Clears faction control from this room.
/// </summary>
public void ClearControllingFaction()
{
    ControllingFactionId = null;
    FactionControlStrength = 0;
    IsContested = false;
}

/// <summary>
/// Updates the faction control strength.
/// </summary>
public void SetFactionControlStrength(int strength)
{
    FactionControlStrength = Math.Clamp(strength, 0, 100);
}

/// <summary>
/// Sets the contested status for this room.
/// </summary>
public void SetContested(bool isContested)
{
    IsContested = isContested;
}

/// <summary>
/// Adds a connected room.
/// </summary>
public void AddConnectedRoom(Guid roomId)
{
    if (!_connectedRoomIds.Contains(roomId))
    {
        _connectedRoomIds.Add(roomId);
    }
}

/// <summary>
/// Gets a description of the faction control status.
/// </summary>
public string GetFactionStatusDescription()
{
    if (ControllingFactionId == null)
        return "This area is unclaimed territory.";

    if (IsContested)
        return $"This area is contested! Multiple factions fight for control.";

    var strengthDesc = FactionControlStrength switch
    {
        >= 80 => "firmly",
        >= 50 => "steadily",
        >= 30 => "loosely",
        _ => "barely"
    };

    return $"This area is {strengthDesc} controlled by hostile forces.";
}
```

### 8.4 Spawner Changes

**File:** `src/Core/RuneAndRust.Domain/Entities/Spawner.cs` (modification)

```csharp
// Add to Spawner.cs - after existing properties

/// <summary>
/// Gets the ID of the faction this spawner belongs to.
/// </summary>
/// <remarks>
/// Spawners produce monsters for their controlling faction.
/// Null if spawner is independent.
/// </remarks>
public string? FactionId { get; private set; }

/// <summary>
/// Sets the faction for this spawner.
/// </summary>
/// <param name="factionId">The faction ID.</param>
public void SetFaction(string? factionId)
{
    FactionId = factionId;
}

/// <summary>
/// Clears the faction assignment.
/// </summary>
public void ClearFaction()
{
    FactionId = null;
}
```

### 8.5 Data Model Changes Summary

```
MODIFY: Room
├── ADD: ControllingFactionId: string? (default: null)
├── ADD: FactionControlStrength: int (default: 0)
├── ADD: IsContested: bool (default: false)
├── ADD: ConnectedRoomIds: IReadOnlyList<Guid>
├── ADD: SetControllingFaction(factionId, strength): void
├── ADD: ClearControllingFaction(): void
├── ADD: SetFactionControlStrength(strength): void
├── ADD: SetContested(isContested): void
├── ADD: AddConnectedRoom(roomId): void
└── ADD: GetFactionStatusDescription(): string

MODIFY: Spawner
├── ADD: FactionId: string? (default: null)
├── ADD: SetFaction(factionId): void
└── ADD: ClearFaction(): void
```

---

## 9. Territory Expansion Mechanics

### 9.1 Expansion Triggers

Territory expansion occurs when:
1. A room is cleared by the player (creates power vacuum)
2. Adjacent faction has high expansion priority (50+)
3. Target room is not permanently cleared
4. Target room is not controlled by an allied faction

### 9.2 Expansion Priority Calculation

```
expansionPriority = faction.ExpansionPriority
                  + (prefersRoomType ? 20 : 0)
                  - (isControlledByHostile ? 0 : 30)
                  + random(-10, 10)
```

### 9.3 Expansion Rule Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ExpansionRule.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines rules for faction territory expansion.
/// </summary>
public readonly record struct ExpansionRule
{
    /// <summary>
    /// Gets the minimum rooms required before expansion.
    /// </summary>
    public int MinimumTerritory { get; init; }

    /// <summary>
    /// Gets the maximum expansion rate (rooms per tick).
    /// </summary>
    public int MaxExpansionRate { get; init; }

    /// <summary>
    /// Gets whether expansion requires adjacent controlled territory.
    /// </summary>
    public bool RequiresAdjacency { get; init; }

    /// <summary>
    /// Gets preferred room types for expansion.
    /// </summary>
    public IReadOnlyList<RoomType> PreferredTargets { get; init; }

    /// <summary>
    /// Creates default expansion rules.
    /// </summary>
    public static ExpansionRule Default => new()
    {
        MinimumTerritory = 1,
        MaxExpansionRate = 2,
        RequiresAdjacency = true,
        PreferredTargets = Array.Empty<RoomType>()
    };
}
```

### 9.4 Territory Boundary Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TerritoryBoundary.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the boundary of a faction's territory.
/// </summary>
public readonly record struct TerritoryBoundary
{
    /// <summary>
    /// Gets the room IDs at the boundary.
    /// </summary>
    public IReadOnlyList<Guid> RoomIds { get; init; }

    /// <summary>
    /// Gets IDs of adjacent factions.
    /// </summary>
    public IReadOnlyList<string> AdjacentFactionIds { get; init; }

    /// <summary>
    /// Gets whether any boundary rooms are contested.
    /// </summary>
    public bool HasContestedBoundary { get; init; }

    /// <summary>
    /// Gets an empty boundary.
    /// </summary>
    public static TerritoryBoundary Empty => new()
    {
        RoomIds = Array.Empty<Guid>(),
        AdjacentFactionIds = Array.Empty<string>(),
        HasContestedBoundary = false
    };

    /// <summary>
    /// Creates a territory boundary.
    /// </summary>
    public static TerritoryBoundary Create(
        IEnumerable<Guid> roomIds,
        IEnumerable<string> adjacentFactionIds,
        bool hasContested = false)
    {
        return new TerritoryBoundary
        {
            RoomIds = roomIds.ToList(),
            AdjacentFactionIds = adjacentFactionIds.ToList(),
            HasContestedBoundary = hasContested
        };
    }
}
```

---

## 10. Cross-Faction Conflict

### 10.1 Conflict Resolution

When multiple factions compete for the same room:

1. **Hostile factions** - Fight for control, highest strength wins
2. **Neutral factions** - Higher aggression faction claims room
3. **Allied factions** - Share or randomly assign

### 10.2 Conflict Strength Calculation

```
conflictStrength = adjacentControlledRooms * averageControlStrength
                 + aggressionLevel * 10
                 + random(0, 20)
```

### 10.3 Conflict Results

| Winner | Loser Effects |
|--------|---------------|
| Claims room | Territory state → Collapsing |
| Gains control strength | Loses expansion target |
| Updates expansion state | Relationship conflict count +1 |

---

## 11. Configuration File Schemas

### 11.1 Faction Definitions Configuration

**File:** `config/faction-definitions.json`

```json
{
  "$schema": "schemas/faction-definitions-schema.json",
  "factions": [
    {
      "id": "undead-legion",
      "name": "The Undead Legion",
      "description": "Ancient undead warriors bound to serve in death. They seek to expand their domain across the dungeon.",
      "monsterTypeIds": ["skeleton-warrior", "zombie", "wraith", "skeleton-archer"],
      "preferredSpawnerTypes": ["Altar"],
      "aggressionLevel": 60,
      "expansionPriority": 70,
      "homeRoomTypes": ["Standard", "Corridor"],
      "relationships": {
        "goblin-tribe": "Hostile",
        "beast-pack": "Neutral"
      },
      "defaultRelationship": "Hostile"
    },
    {
      "id": "goblin-tribe",
      "name": "Goblin Tribe",
      "description": "A cunning tribe of goblins that infests dungeons, setting traps and ambushes.",
      "monsterTypeIds": ["goblin", "goblin-shaman", "hobgoblin", "goblin-archer"],
      "preferredSpawnerTypes": ["Nest", "Hive"],
      "aggressionLevel": 45,
      "expansionPriority": 80,
      "homeRoomTypes": ["Treasure", "Standard"],
      "relationships": {
        "undead-legion": "Hostile",
        "beast-pack": "Neutral"
      },
      "defaultRelationship": "Hostile"
    },
    {
      "id": "beast-pack",
      "name": "Beast Pack",
      "description": "Wild creatures that have made the dungeon their hunting grounds.",
      "monsterTypeIds": ["wolf", "dire-wolf", "giant-spider", "cave-bear"],
      "preferredSpawnerTypes": ["Nest"],
      "aggressionLevel": 70,
      "expansionPriority": 50,
      "homeRoomTypes": ["Corridor", "Entrance"],
      "relationships": {
        "undead-legion": "Neutral",
        "goblin-tribe": "Neutral"
      },
      "defaultRelationship": "Neutral"
    },
    {
      "id": "demon-cult",
      "name": "Demon Cult",
      "description": "Fanatical cultists summoning demons to overrun the dungeon.",
      "monsterTypeIds": ["cultist", "imp", "demon-warrior", "cult-leader"],
      "preferredSpawnerTypes": ["Portal", "Altar"],
      "aggressionLevel": 85,
      "expansionPriority": 90,
      "homeRoomTypes": ["Boss", "Secret"],
      "relationships": {
        "undead-legion": "Allied",
        "goblin-tribe": "Hostile",
        "beast-pack": "Hostile"
      },
      "defaultRelationship": "Hostile"
    }
  ]
}
```

### 11.2 JSON Schema

**File:** `config/schemas/faction-definitions-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "faction-definitions-schema.json",
  "title": "Faction Definitions Configuration",
  "description": "Schema for monster faction definitions",
  "type": "object",
  "required": ["factions"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "factions": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/factionDefinition"
      }
    }
  },
  "$defs": {
    "factionDefinition": {
      "type": "object",
      "required": ["id", "name", "monsterTypeIds", "aggressionLevel", "expansionPriority"],
      "properties": {
        "id": {
          "type": "string",
          "minLength": 1,
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier for the faction"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Display name of the faction"
        },
        "description": {
          "type": "string",
          "description": "Flavor text describing the faction"
        },
        "monsterTypeIds": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "string"
          },
          "description": "Monster types belonging to this faction"
        },
        "preferredSpawnerTypes": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["Nest", "Portal", "Altar", "Hive"]
          },
          "description": "Preferred spawner types for this faction"
        },
        "aggressionLevel": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100,
          "description": "How aggressive the faction is (0-100)"
        },
        "expansionPriority": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100,
          "description": "How quickly the faction expands (0-100)"
        },
        "homeRoomTypes": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["Standard", "Boss", "Treasure", "Entrance", "Corridor", "Safe", "Secret", "Puzzle"]
          },
          "description": "Preferred room types for faction territory"
        },
        "relationships": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "enum": ["Hostile", "Neutral", "Allied"]
          },
          "description": "Relationships with other factions"
        },
        "defaultRelationship": {
          "type": "string",
          "enum": ["Hostile", "Neutral", "Allied"],
          "default": "Hostile",
          "description": "Default relationship with undefined factions"
        }
      }
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `TerritoryService` | Information | Room control changed, expansion triggered, conflict resolved |
| `TerritoryService` | Debug | Expansion opportunities checked, boundaries calculated |
| `TerritoryService` | Warning | Faction not found, invalid expansion |
| `FactionDefinition` | Debug | Relationship queries |

### 12.2 Log Message Examples

```csharp
// Information
_logger.LogInformation(
    "Faction {FactionId} now controls room {RoomId} (strength: {Strength})",
    factionId, roomId, controlStrength);

_logger.LogInformation(
    "Faction {FactionId} ({FactionName}) expanded into room {RoomId}",
    factionId, faction.Name, targetRoomId);

_logger.LogInformation(
    "Faction {Winner} won conflict against {Losers} for room {RoomId}",
    winner, string.Join(", ", losers), roomId);

_logger.LogInformation(
    "Room {RoomId} cleared by player, faction {FactionId} loses control",
    roomId, previousFaction);

// Debug
_logger.LogDebug(
    "Faction {FactionId} has {Count} expansion opportunities",
    factionId, opportunities.Count);

_logger.LogDebug(
    "Faction {FactionId} targeting cleared room {RoomId} for expansion",
    factionId, roomId);

// Warning
_logger.LogWarning(
    "Cannot set room control: faction {FactionId} not found",
    factionId);
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| FactionDefinition entity | ~6 |
| TerritoryControl entity | ~6 |
| FactionRelationship value object | ~4 |
| TerritoryBoundary value object | ~2 |
| TerritoryService | ~10 |
| Room integration | ~4 |
| **Total** | **~32** |

### 13.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `FactionDefinitionTests.cs` | ~6 | Create, SetRelationship, GetRelationshipWith, PrefersRoomType |
| `TerritoryControlTests.cs` | ~6 | Create, AddControlledRoom, RemoveRoom, ControlStrength |
| `FactionRelationshipTests.cs` | ~4 | Create, WithConflict, InvolvesFaction |
| `TerritoryBoundaryTests.cs` | ~2 | Create, Empty |
| `TerritoryServiceTests.cs` | ~10 | SetRoomControl, ClearControl, Expansion, Conflicts, OnRoomCleared |
| `RoomFactionTests.cs` | ~4 | SetControllingFaction, ClearFaction, IsContested |

### 13.3 Test Categories

**FactionDefinition Tests:**
```csharp
[Test]
public void Create_WithValidParameters_CreatesFaction()

[Test]
public void Create_WithEmptyId_ThrowsArgumentException()

[Test]
public void SetRelationship_UpdatesRelationshipMap()

[Test]
public void GetRelationshipWith_ReturnsDefault_WhenNotDefined()

[Test]
public void PrefersRoomType_ReturnsTrue_WhenInHomeTypes()

[Test]
public void GetRandomMonsterType_ReturnsTypeFromList()
```

**TerritoryService Tests:**
```csharp
[Test]
public void SetRoomControl_AssignsRoom_ToFaction()

[Test]
public void SetRoomControl_UpdatesSpawners_WithFactionId()

[Test]
public void ClearRoomControl_RemovesRoom_FromFactionTerritory()

[Test]
public void CheckExpansionOpportunities_ReturnsAdjacentUncontrolledRooms()

[Test]
public void TriggerExpansion_ClaimsRoom_WhenUncontested()

[Test]
public void TriggerExpansion_MarksContested_WhenAlreadyControlled()

[Test]
public void ResolveFactionConflict_AwardsRoom_ToStrongestFaction()

[Test]
public void OnRoomCleared_CreatesVacuum_ForAdjacentFactions()

[Test]
public void GetFactionRelationship_ReturnsHostile_ByDefault()

[Test]
public void ProcessTerritoryConflicts_ResolvesAllContested()
```

---

## 14. Use Cases

### UC-001: Player Clears Faction-Controlled Room

**Actor:** Player
**Flow:** Player clears room → TerritoryService.OnRoomCleared() → Previous faction loses control → Adjacent factions check expansion → Power vacuum created → Factions may contest room

### UC-002: Faction Expands Into Cleared Room

**Actor:** System
**Flow:** Room cleared → Adjacent faction has expansion priority 50+ → CheckExpansionOpportunities() finds room → TriggerExpansion() claims room → Spawners assigned to faction → Respawn timer set

### UC-003: Cross-Faction Conflict

**Actor:** System
**Flow:** Multiple factions target same room → Room marked contested → ProcessTerritoryConflicts() called → Conflict strength calculated → Winner claims room → Losers retreat

### UC-004: Query Faction Territory

**Actor:** Player (via map)
**Flow:** Player views map → GetFactionTerritory() for each faction → Display faction-colored zones → Show contested areas → Display faction relationships

### UC-005: Faction Relationship Query

**Actor:** System (combat)
**Flow:** Monster encounters other faction's monster → GetFactionRelationship() checked → If Hostile: monsters fight → If Neutral: ignore → If Allied: cooperate

### UC-006: Room Becomes Contested

**Actor:** System
**Flow:** Faction A controls room → Faction B (hostile) targets room → Room marked IsContested → Battle sites may form (v0.1.4d) → Conflict resolved next tick

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `FactionDefinition.cs` created
- [ ] `TerritoryControl.cs` created
- [ ] `FactionRelationshipType.cs` created
- [ ] `TerritoryState.cs` created
- [ ] `FactionRelationship.cs` created
- [ ] `TerritoryBoundary.cs` created
- [ ] `ExpansionRule.cs` created
- [ ] `Room.cs` updated with faction control properties
- [ ] `Spawner.cs` updated with faction assignment

### Application Layer
- [ ] `ITerritoryService.cs` created
- [ ] `TerritoryService.cs` created

### Infrastructure Layer
- [ ] `IConfigurationProvider.cs` updated with GetFactionDefinitions()
- [ ] `JsonConfigurationProvider.cs` updated to load faction definitions

### Configuration Files
- [ ] `config/faction-definitions.json` created with 4 faction definitions
- [ ] `config/schemas/faction-definitions-schema.json` created

### Testing
- [ ] `FactionDefinitionTests.cs` created (~6 tests)
- [ ] `TerritoryControlTests.cs` created (~6 tests)
- [ ] `FactionRelationshipTests.cs` created (~4 tests)
- [ ] `TerritoryBoundaryTests.cs` created (~2 tests)
- [ ] `TerritoryServiceTests.cs` created (~10 tests)
- [ ] `RoomFactionTests.cs` created (~4 tests)
- [ ] All ~32 tests passing

### Documentation
- [ ] XML documentation on all public members
- [ ] Code follows .editorconfig conventions

---

## 16. Acceptance Criteria

### Functional

- [ ] FactionDefinition entity stores faction properties and relationships
- [ ] TerritoryControl tracks faction's controlled rooms and expansion targets
- [ ] TerritoryService.SetRoomControl assigns faction to room
- [ ] TerritoryService.ClearRoomControl creates power vacuum
- [ ] TerritoryService.OnRoomCleared triggers expansion checks for adjacent factions
- [ ] TerritoryService.CheckExpansionOpportunities returns valid targets
- [ ] TerritoryService.TriggerExpansion claims uncontested rooms
- [ ] TerritoryService.TriggerExpansion marks contested rooms appropriately
- [ ] TerritoryService.ResolveFactionConflict determines winner by strength
- [ ] Room.ControllingFactionId reflects current faction control
- [ ] Spawner.FactionId assigned when room is claimed
- [ ] Faction definitions load from JSON configuration
- [ ] Cross-faction relationships affect conflict behavior

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~32 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on public members
- [ ] Code follows .editorconfig conventions
- [ ] No hardcoded faction IDs outside configuration

---

## 17. Dependencies

### 17.1 Prerequisites (v0.1.4b)

| Component | Purpose for v0.1.4c |
|-----------|---------------------|
| `Spawner` entity | Extended with FactionId property |
| `RepopulationService` | Sets respawn timers for faction territory |
| `Room.Spawners` | Spawners assigned to controlling faction |
| `Room.IsPermanentlyCleared` | Excluded from expansion targets |
| `RespawnTimer` | Timing for faction respawns |

### 17.2 Prerequisites (v0.1.4a)

| Component | Purpose for v0.1.4c |
|-----------|---------------------|
| `WorldStateService` | Integration for territory changes as persistent changes |
| `RoomState` | Room state affects faction expansion |
| `PersistentChange` | Track faction control changes |

### 17.3 Provides to Future Phases

| Component | Used By |
|-----------|---------|
| `FactionDefinition` | v0.1.4d (Faction-related battle sites) |
| `TerritoryControl` | v0.1.4d (Territory-based evolution events) |
| `TerritoryService` | v0.1.4d (Trigger evolution from faction conflicts) |
| `Room.ControllingFactionId` | v0.1.4d (Environmental evidence generation) |

### 17.4 Dependency Diagram

```
v0.1.4a (Persistent World State)
    │
    ├── WorldStateService ────────────────────────────────────┐
    └── RoomState, PersistentChange ──────────────────────────┤
                                                              │
v0.1.4b (Monster Repopulation)                                │
    │                                                         │
    ├── Spawner entity ───────────────────────────────────────┤
    ├── RepopulationService ──────────────────────────────────┤
    └── Room.Spawners, Room.IsPermanentlyCleared ─────────────┘
                                                              │
                                                              ▼
v0.1.4c (Faction Territory Control)
    │
    ├── FactionDefinition entity ─────────────────────────────────────────┐
    ├── TerritoryControl entity ──────────────────────────────────────────│
    ├── FactionRelationship value object ─────────────────────────────────│
    ├── TerritoryService ─────────────────────────────────────────────────┤
    ├── Room.ControllingFactionId, Room.IsContested ──────────────────────│
    └── Spawner.FactionId ────────────────────────────────────────────────┘
                                                                          │
                                                                          ▼
                                                      v0.1.4d (Evolution Events)
```

---

## 18. Future Considerations

### 18.1 Deferred to v0.1.4d

- **Battle sites from faction conflicts** - Dead monsters, broken equipment at conflict locations
- **Faction-based evolution events** - Major faction victories trigger dungeon changes
- **Time-based territory decay** - Unvisited faction territory weakens over time
- **Environmental evidence of faction presence** - Faction markings, camps, fortifications

### 18.2 Out of Scope (Future Versions)

- **Player faction alignment** - Players joining or opposing factions
- **Faction quests** - Missions from faction leaders
- **Faction diplomacy** - Player-influenced faction relationships
- **Faction NPCs** - Non-combat faction members
- **Faction economy** - Trade between factions
- **Procedural faction generation** - New factions emerging during play

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
