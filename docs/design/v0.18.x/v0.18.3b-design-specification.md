# v0.18.3b Design Specification: CharacterTrauma Entity

**Version:** 0.18.3b
**Parent:** v0.18.3 (Trauma System)
**Prerequisites:** v0.18.3a (Trauma Enums & Definitions)
**Status:** Design Complete
**Estimated Unit Tests:** ~5

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [CharacterTrauma Entity](#5-charactertrauma-entity)
6. [TraumaAcquisitionResult Record](#6-traumaacquisitionresult-record)
7. [RetirementCheckResult Record](#7-retirementcheckresult-record)
8. [Retirement Logic](#8-retirement-logic)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Deliverable Checklist](#11-deliverable-checklist)
12. [Acceptance Criteria](#12-acceptance-criteria)
13. [Dependencies](#13-dependencies)
14. [Future Considerations](#14-future-considerations)

---

## 1. Executive Summary

This design specification defines per-character trauma tracking, including acquisition history, stack counts, and retirement condition evaluation.

v0.18.3b establishes the **Character Domain Integration** for Trauma by defining:

- `CharacterTrauma` entity — per-character trauma instance
- `TraumaAcquisitionResult` record — acquisition outcome
- `RetirementCheckResult` record — retirement evaluation

### Key Deliverables

| Category          | Items                     |
| ----------------- | ------------------------- |
| **Domain Entities** | `CharacterTrauma`         |
| **Domain Records** | `TraumaAcquisitionResult`, `RetirementCheckResult` |
| **Tests**         | ~5 unit tests             |

### Retirement Conditions Overview

| Trauma            | Condition                  | Trigger Type |
| ----------------- | -------------------------- | ------------ |
| Survivor's Guilt  | First acquisition          | Immediate    |
| Reality Doubt     | 5+ instances               | Stacking     |
| Machine Affinity  | First acquisition          | Immediate    |
| Hollow Resonance  | 3+ instances               | Stacking     |
| Death Wish        | First acquisition          | Immediate    |
| Multiple Moderate | Any 3+ different moderates | Accumulation |

---

## 2. Feature Overview

```
v0.18.3b Features
└── Character Trauma Tracking (Domain Integration)
    │
    ├── CharacterTrauma Entity
    │   ├── Id: Guid
    │   ├── CharacterId: Guid
    │   ├── TraumaDefinitionId: string
    │   ├── AcquiredAt: DateTime
    │   ├── Source: string
    │   ├── StackCount: int
    │   ├── IsActive: bool
    │   ├── ManagedSince: DateTime?
    │   └── Notes: string?
    │
    ├── TraumaAcquisitionResult Record
    │   ├── Success: bool
    │   ├── TraumaId: string
    │   ├── TraumaName: string
    │   ├── Source: string
    │   ├── IsNewTrauma: bool
    │   ├── NewStackCount: int
    │   ├── TriggersRetirementCheck: bool
    │   └── Message: string
    │
    └── RetirementCheckResult Record
        ├── CharacterId: Guid
        ├── MustRetire: bool
        ├── RetirementReason: string?
        ├── TraumasCausingRetirement: IReadOnlyList<string>
        ├── TotalRetirementTraumas: int
        └── CanContinueWithPermission: bool
```

---

## 3. Architecture Diagrams

### 3.1 CharacterTrauma Entity Structure

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    CharacterTrauma (Entity)                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Properties:                                                             │
│  ─────────────────────────────────────────────────────────────────────  │
│  + Id: Guid                  — Unique identifier                         │
│  + CharacterId: Guid         — Which character owns this trauma          │
│  + TraumaDefinitionId: string — Reference to TraumaDefinition           │
│  + AcquiredAt: DateTime      — When this trauma was acquired            │
│  + Source: string            — What caused this trauma (event name)     │
│  + StackCount: int           — How many times this trauma has occurred  │
│  + IsActive: bool            — Whether effects are currently applying   │
│  + ManagedSince: DateTime?   — When trauma management started (if any)  │
│  + Notes: string?            — Campaign-specific notes                  │
│                                                                          │
│  Constraints:                                                            │
│  ─────────────────────────────────────────────────────────────────────  │
│  + UNIQUE (CharacterId, TraumaDefinitionId)                             │
│  + AcquiredAt <= ManagedSince (if ManagedSince is set)                 │
│  + StackCount >= 1                                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Trauma Acquisition Flow

```
┌────────────────────────────────────────────────┐
│   AcquireTrauma(charId, traumaId, source)     │
└──────────────┬─────────────────────────────────┘
               │
               ▼
    ┌──────────────────────────┐
    │ Check if Character has   │
    │ this trauma already      │
    └──────────┬───────────────┘
               │
        ┌──────┴──────┐
        │             │
        ▼             ▼
    [NO]          [YES]
        │             │
        │             ▼
        │    ┌─────────────────────────┐
        │    │  Is Stackable?          │
        │    └────┬─────────────┬──────┘
        │         │             │
        │      [NO]          [YES]
        │         │             │
        │         ▼             ▼
        │      FAIL         Increment
        │      (already     StackCount
        │       has)        └──────┬──────┐
        │                          │      │
        └──────────┬───────────────┘      │
                   │                      │
                   ▼                      ▼
        ┌──────────────────┐    ┌────────────────────┐
        │  Create New      │    │  Update Existing   │
        │  CharacterTrauma │    │  CharacterTrauma   │
        └────────┬─────────┘    └────────┬───────────┘
                 │                       │
                 └───────────┬───────────┘
                             │
                             ▼
                ┌────────────────────────────┐
                │  Check Retirement Condition │
                └────────────┬───────────────┘
                             │
                             ▼
                ┌────────────────────────────┐
                │ Return AcquisitionResult   │
                └────────────────────────────┘
```

### 3.3 Retirement Condition Evaluation

```
┌──────────────────────────────────────────────────────┐
│  CheckRetirementCondition(characterId)               │
└────────────────────┬─────────────────────────────────┘
                     │
                     ▼
         ┌───────────────────────┐
         │  Get All Traumas for  │
         │  Character            │
         └────────────┬──────────┘
                      │
                      ▼
         ┌───────────────────────────────────────────┐
         │ Check Each Trauma's RetirementCondition   │
         └─────┬─────────────────────────────────────┘
               │
        ┌──────┴────────────────────────────────┐
        │                                       │
        ▼                                       ▼
    Check Immediate        Check Stacking/Accumulation
    Triggers:              Triggers:
    ├─ Survivor's Guilt    ├─ Reality Doubt (5+ instances)
    ├─ Machine Affinity    ├─ Hollow Resonance (3+ instances)
    ├─ Death Wish          └─ Multiple Moderate (3+ types)
    └─ ...                    with StackCount > 1
        │                     │
        ├─ ANY MATCH       ├─ ANY MATCH
        ▼                  ▼
    MustRetire=true    MustRetire=true
                       (or CanContinue=true
                        if accumulation)
        │                  │
        └──────────┬───────┘
                   │
                   ▼
        ┌──────────────────────────┐
        │ Return RetirementCheck   │
        │ Result                   │
        └──────────────────────────┘
```

---

## 4. User Stories

### US-18.3b-1: Track Per-Character Traumas

**As a** character management system
**I want to** track which traumas a character has acquired
**So that** trauma effects and states can be queried and applied

**Acceptance Criteria:**

- CharacterTrauma uniquely identifies a character + trauma pair
- Acquisition date is always recorded
- Source of trauma is always recorded
- Stack counts are tracked for stackable traumas

### US-18.3b-2: Detect New vs Stacked Trauma

**As a** trauma acquisition system
**I want to** distinguish between first-time trauma and repeated acquisition
**So that** acquisition messages and effects differ appropriately

**Acceptance Criteria:**

- TraumaAcquisitionResult includes IsNewTrauma flag
- NewStackCount reflects actual stack state
- Attempt to acquire non-stackable trauma twice fails appropriately

### US-18.3b-3: Evaluate Retirement Triggers

**As a** character retirement system
**I want to** check if a character must retire due to trauma severity
**So that** character loss procedures are initiated automatically

**Acceptance Criteria:**

- RetirementCheckResult identifies immediate retirement traumas
- Accumulation conditions are evaluated (e.g., 5+ Reality Doubt)
- Multiple moderate traumas trigger optional retirement check
- RetirementReason explains why retirement is required/suggested

### US-18.3b-4: Enable Trauma Management

**As a** campaign system
**I want to** track when a character begins managing/suppressing a trauma
**So that** therapies and rehabilitation mechanics can hook into this

**Acceptance Criteria:**

- ManagedSince timestamp can be set
- ManagedSince only sets after AcquiredAt
- IsActive can be toggled based on management status

---

## 5. CharacterTrauma Entity

### 5.1 Purpose

Tracks a specific trauma instance for a character, including when it was acquired, from what source, and how many times it has occurred.

### 5.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/CharacterTrauma.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a trauma instance for a specific character.
/// </summary>
/// <remarks>
/// <para>
/// CharacterTrauma tracks the acquisition and progression of a specific trauma
/// on a character. Traumas are permanent, but their effects can be suppressed
/// through therapy or management (to be implemented in v0.22.x).
/// </para>
/// <para>
/// For stackable traumas, StackCount tracks the number of times the trauma
/// has been acquired or intensified. For non-stackable traumas, StackCount
/// still tracks event intensity or number of near-misses.
/// </para>
/// <para>
/// Constraints:
/// - No duplicate traumas: UNIQUE (CharacterId, TraumaDefinitionId)
/// - StackCount >= 1 always
/// - ManagedSince >= AcquiredAt if set
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var trauma = CharacterTrauma.Create(
///     characterId: characterId,
///     traumaDefinitionId: "survivors-guilt",
///     source: "AllyDeath",
///     acquiredAt: DateTime.UtcNow
/// );
/// </code>
/// </example>
public class CharacterTrauma
{
    /// <summary>
    /// Gets the unique identifier for this CharacterTrauma instance.
    /// </summary>
    public Guid Id { get; private init; }

    /// <summary>
    /// Gets the character who has acquired this trauma.
    /// </summary>
    /// <remarks>
    /// Foreign key to Character aggregate root.
    /// </remarks>
    public Guid CharacterId { get; private init; }

    /// <summary>
    /// Gets the trauma definition ID this instance is based on.
    /// </summary>
    /// <remarks>
    /// Foreign key to TraumaDefinition. String ID matches config key.
    /// </remarks>
    public string TraumaDefinitionId { get; private init; }

    /// <summary>
    /// Gets the date/time when this trauma was first acquired.
    /// </summary>
    /// <remarks>
    /// Immutable. Set at creation time. Represents the original event.
    /// </remarks>
    public DateTime AcquiredAt { get; private init; }

    /// <summary>
    /// Gets the source/trigger that caused this trauma.
    /// </summary>
    /// <remarks>
    /// Examples: "AllyDeath", "CorruptionThreshold75", "ForlornContact"
    /// Used for narrative and mechanical understanding of origin.
    /// </remarks>
    public string Source { get; private init; }

    /// <summary>
    /// Gets the number of times this trauma has been reinforced.
    /// </summary>
    /// <remarks>
    /// For stackable traumas: Number of acquisitions
    /// For non-stackable traumas: Intensity/near-miss counter
    /// Always >= 1
    /// </remarks>
    public int StackCount { get; private set; }

    /// <summary>
    /// Gets whether this trauma is currently applying its effects.
    /// </summary>
    /// <remarks>
    /// Traumas are always acquired as IsActive=true.
    /// Future systems (v0.22.x) may allow suppression via therapy.
    /// </remarks>
    public bool IsActive { get; private set; }

    /// <summary>
    /// Gets the date when trauma management/therapy began (if any).
    /// </summary>
    /// <remarks>
    /// Null if trauma has not begun being managed.
    /// Must be >= AcquiredAt if set.
    /// </remarks>
    public DateTime? ManagedSince { get; private set; }

    /// <summary>
    /// Gets optional campaign-specific notes about this trauma.
    /// </summary>
    /// <remarks>
    /// Used by GMs to track special circumstances or modifications.
    /// </remarks>
    public string? Notes { get; private set; }

    // Private constructor for EF Core
    private CharacterTrauma() { }

    /// <summary>
    /// Creates a new CharacterTrauma instance.
    /// </summary>
    /// <param name="characterId">The character acquiring the trauma</param>
    /// <param name="traumaDefinitionId">The trauma definition ID</param>
    /// <param name="source">The source/trigger of the trauma</param>
    /// <param name="acquiredAt">When the trauma was acquired</param>
    /// <returns>A new CharacterTrauma instance</returns>
    /// <exception cref="ArgumentException">If any string parameter is empty</exception>
    /// <exception cref="ArgumentException">If characterId is empty Guid</exception>
    public static CharacterTrauma Create(
        Guid characterId,
        string traumaDefinitionId,
        string source,
        DateTime acquiredAt)
    {
        if (characterId == Guid.Empty)
            throw new ArgumentException("CharacterId cannot be empty", nameof(characterId));
        if (string.IsNullOrWhiteSpace(traumaDefinitionId))
            throw new ArgumentException("TraumaDefinitionId cannot be empty", nameof(traumaDefinitionId));
        if (string.IsNullOrWhiteSpace(source))
            throw new ArgumentException("Source cannot be empty", nameof(source));

        return new CharacterTrauma
        {
            Id = Guid.NewGuid(),
            CharacterId = characterId,
            TraumaDefinitionId = traumaDefinitionId,
            AcquiredAt = acquiredAt,
            Source = source,
            StackCount = 1,
            IsActive = true,
            ManagedSince = null,
            Notes = null
        };
    }

    /// <summary>
    /// Increments the stack count for this trauma.
    /// </summary>
    /// <remarks>
    /// Called when a stackable trauma is acquired multiple times.
    /// Throws if already at maximum (arbitrary high number).
    /// </remarks>
    /// <exception cref="InvalidOperationException">If stack count would exceed maximum</exception>
    public void IncrementStackCount()
    {
        const int maxStackCount = 100; // Arbitrary safety limit
        if (StackCount >= maxStackCount)
            throw new InvalidOperationException(
                $"Cannot increment StackCount beyond {maxStackCount}");

        StackCount++;
    }

    /// <summary>
    /// Marks this trauma as being actively managed/treated.
    /// </summary>
    /// <param name="managedSince">When management started</param>
    /// <remarks>
    /// Can only be set to a date >= AcquiredAt.
    /// Used by therapy systems (future implementation).
    /// </remarks>
    /// <exception cref="ArgumentException">If managedSince is before AcquiredAt</exception>
    public void SetManagementStart(DateTime managedSince)
    {
        if (managedSince < AcquiredAt)
            throw new ArgumentException(
                "Management cannot start before trauma acquisition",
                nameof(managedSince));

        ManagedSince = managedSince;
    }

    /// <summary>
    /// Updates the campaign notes for this trauma.
    /// </summary>
    /// <param name="notes">New notes content</param>
    public void SetNotes(string? notes)
    {
        Notes = notes;
    }

    /// <summary>
    /// Toggles whether this trauma is actively applying effects.
    /// </summary>
    /// <remarks>
    /// IsActive can be false if trauma is managed/suppressed.
    /// Always true for newly acquired traumas.
    /// </remarks>
    public void SetActive(bool active)
    {
        IsActive = active;
    }

    /// <summary>
    /// Gets the display string for this trauma instance.
    /// </summary>
    public override string ToString() =>
        $"[{TraumaDefinitionId}] x{StackCount}" +
        (IsActive ? "" : " [MANAGED]") +
        (ManagedSince != null ? $" (since {ManagedSince:yyyy-MM-dd})" : "");
}
```

---

## 6. TraumaAcquisitionResult Record

### 6.1 Purpose

Immutable record representing the outcome of an attempt to acquire a trauma.

### 6.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Records/TraumaAcquisitionResult.cs`

```csharp
namespace RuneAndRust.Domain.Records;

/// <summary>
/// Represents the outcome of a trauma acquisition attempt.
/// </summary>
/// <remarks>
/// <para>
/// This record is returned when attempting to acquire a trauma on a character.
/// It distinguishes between successful new acquisitions and attempts to add
/// a trauma the character already has.
/// </para>
/// <para>
/// Success conditions:
/// - First time acquiring trauma (IsNewTrauma=true)
/// - Stackable trauma being re-acquired (IsNewTrauma=false, StackCount increases)
/// </para>
/// <para>
/// Failure conditions:
/// - Non-stackable trauma and character already has it (Success=false)
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = TraumaAcquisitionResult.CreateNew(
///     traumaId: "survivors-guilt",
///     traumaName: "Survivor's Guilt",
///     source: "AllyDeath",
///     triggersRetirementCheck: true
/// );
/// </code>
/// </example>
public record TraumaAcquisitionResult
{
    /// <summary>
    /// Gets whether the trauma acquisition was successful.
    /// </summary>
    /// <remarks>
    /// True if trauma was newly acquired or successfully stacked.
    /// False if character already has non-stackable trauma.
    /// </remarks>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the trauma ID that was acquired or attempted.
    /// </summary>
    public string TraumaId { get; init; }

    /// <summary>
    /// Gets the display name of the trauma.
    /// </summary>
    public string TraumaName { get; init; }

    /// <summary>
    /// Gets the source/trigger of the acquisition.
    /// </summary>
    public string Source { get; init; }

    /// <summary>
    /// Gets whether this is a new trauma or a stacked instance.
    /// </summary>
    /// <remarks>
    /// True if character did not previously have this trauma.
    /// False if stacking an existing trauma.
    /// </remarks>
    public bool IsNewTrauma { get; init; }

    /// <summary>
    /// Gets the current stack count after acquisition.
    /// </summary>
    /// <remarks>
    /// 1 for newly acquired, 2+ for stacked.
    /// </remarks>
    public int NewStackCount { get; init; }

    /// <summary>
    /// Gets whether this acquisition triggers a retirement check.
    /// </summary>
    /// <remarks>
    /// True if the trauma is a retirement trauma or stacking to critical level.
    /// False for normal traumas.
    /// </remarks>
    public bool TriggersRetirementCheck { get; init; }

    /// <summary>
    /// Gets a message describing the acquisition result.
    /// </summary>
    /// <remarks>
    /// Human-readable message for display to player.
    /// </remarks>
    public string Message { get; init; }

    /// <summary>
    /// Creates a new successful acquisition result for a first-time trauma.
    /// </summary>
    /// <param name="traumaId">Trauma ID</param>
    /// <param name="traumaName">Trauma name</param>
    /// <param name="source">Acquisition source</param>
    /// <param name="triggersRetirementCheck">Whether this triggers retirement</param>
    /// <returns>A new TraumaAcquisitionResult</returns>
    public static TraumaAcquisitionResult CreateNew(
        string traumaId,
        string traumaName,
        string source,
        bool triggersRetirementCheck)
    {
        return new TraumaAcquisitionResult
        {
            Success = true,
            TraumaId = traumaId,
            TraumaName = traumaName,
            Source = source,
            IsNewTrauma = true,
            NewStackCount = 1,
            TriggersRetirementCheck = triggersRetirementCheck,
            Message = $"You have acquired {traumaName}." +
                (triggersRetirementCheck ? " [RETIREMENT CHECK REQUIRED]" : "")
        };
    }

    /// <summary>
    /// Creates a new successful acquisition result for a stacked trauma.
    /// </summary>
    /// <param name="traumaId">Trauma ID</param>
    /// <param name="traumaName">Trauma name</param>
    /// <param name="source">Acquisition source</param>
    /// <param name="newStackCount">New stack count after increment</param>
    /// <param name="triggersRetirementCheck">Whether stacking triggers retirement</param>
    /// <returns>A new TraumaAcquisitionResult</returns>
    public static TraumaAcquisitionResult CreateStacked(
        string traumaId,
        string traumaName,
        string source,
        int newStackCount,
        bool triggersRetirementCheck)
    {
        return new TraumaAcquisitionResult
        {
            Success = true,
            TraumaId = traumaId,
            TraumaName = traumaName,
            Source = source,
            IsNewTrauma = false,
            NewStackCount = newStackCount,
            TriggersRetirementCheck = triggersRetirementCheck,
            Message = $"{traumaName} has worsened (x{newStackCount})." +
                (triggersRetirementCheck ? " [CRITICAL - RETIREMENT CHECK REQUIRED]" : "")
        };
    }

    /// <summary>
    /// Creates a failed acquisition result for non-stackable trauma.
    /// </summary>
    /// <param name="traumaId">Trauma ID</param>
    /// <param name="traumaName">Trauma name</param>
    /// <param name="source">Attempted source</param>
    /// <returns>A new TraumaAcquisitionResult</returns>
    public static TraumaAcquisitionResult CreateFailure(
        string traumaId,
        string traumaName,
        string source)
    {
        return new TraumaAcquisitionResult
        {
            Success = false,
            TraumaId = traumaId,
            TraumaName = traumaName,
            Source = source,
            IsNewTrauma = false,
            NewStackCount = 0,
            TriggersRetirementCheck = false,
            Message = $"Character already has {traumaName} (cannot stack)."
        };
    }
}
```

---

## 7. RetirementCheckResult Record

### 7.1 Purpose

Immutable record representing the evaluation of retirement conditions for a character.

### 7.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Records/RetirementCheckResult.cs`

```csharp
namespace RuneAndRust.Domain.Records;

/// <summary>
/// Represents the result of evaluating a character's retirement conditions.
/// </summary>
/// <remarks>
/// <para>
/// This record is returned when checking if a character must retire due to
/// accumulated trauma. It provides detailed information about which traumas
/// triggered the retirement and what options are available.
/// </para>
/// <para>
/// Retirement Scenarios:
/// - Immediate: Single retirement trauma acquired (MustRetire=true)
/// - Accumulation: Multiple traumas stacked (MustRetire=true or CanContinue=true)
/// - Optional: Player can choose to retire or continue
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = RetirementCheckResult.CreateMustRetire(
///     characterId: characterId,
///     retirementReason: "Machine Affinity forces retirement",
///     traumasCausingRetirement: new[] { "machine-affinity" }
/// );
/// </code>
/// </example>
public record RetirementCheckResult
{
    /// <summary>
    /// Gets the character being evaluated.
    /// </summary>
    public Guid CharacterId { get; init; }

    /// <summary>
    /// Gets whether the character must retire.
    /// </summary>
    /// <remarks>
    /// True: Character forced to retire immediately
    /// False: Character can continue (but may be optional retirement)
    /// </remarks>
    public bool MustRetire { get; init; }

    /// <summary>
    /// Gets the reason for forced retirement (if applicable).
    /// </summary>
    /// <remarks>
    /// Null if MustRetire is false.
    /// Example: "Machine Affinity forces immediate retirement"
    /// </remarks>
    public string? RetirementReason { get; init; }

    /// <summary>
    /// Gets the traumas that triggered retirement conditions.
    /// </summary>
    /// <remarks>
    /// List of trauma IDs that contributed to retirement evaluation.
    /// May be single trauma (immediate) or multiple (accumulation).
    /// </remarks>
    public IReadOnlyList<string> TraumasCausingRetirement { get; init; }

    /// <summary>
    /// Gets the total count of retirement traumas the character has.
    /// </summary>
    /// <remarks>
    /// Used to assess severity of accumulated trauma.
    /// </remarks>
    public int TotalRetirementTraumas { get; init; }

    /// <summary>
    /// Gets whether the character can continue with permission.
    /// </summary>
    /// <remarks>
    /// True if retirement is optional (e.g., multiple moderate traumas).
    /// False if retirement is mandatory.
    /// Ignored if MustRetire is true.
    /// </remarks>
    public bool CanContinueWithPermission { get; init; }

    /// <summary>
    /// Creates a result indicating mandatory retirement.
    /// </summary>
    /// <param name="characterId">Character ID</param>
    /// <param name="retirementReason">Why retirement is mandatory</param>
    /// <param name="traumasCausingRetirement">Which traumas caused it</param>
    /// <returns>A new RetirementCheckResult</returns>
    public static RetirementCheckResult CreateMustRetire(
        Guid characterId,
        string retirementReason,
        IReadOnlyList<string> traumasCausingRetirement)
    {
        return new RetirementCheckResult
        {
            CharacterId = characterId,
            MustRetire = true,
            RetirementReason = retirementReason,
            TraumasCausingRetirement = traumasCausingRetirement,
            TotalRetirementTraumas = traumasCausingRetirement.Count,
            CanContinueWithPermission = false
        };
    }

    /// <summary>
    /// Creates a result indicating optional retirement.
    /// </summary>
    /// <param name="characterId">Character ID</param>
    /// <param name="traumasCausingRetirement">Which traumas contributed</param>
    /// <returns>A new RetirementCheckResult</returns>
    public static RetirementCheckResult CreateOptional(
        Guid characterId,
        IReadOnlyList<string> traumasCausingRetirement)
    {
        return new RetirementCheckResult
        {
            CharacterId = characterId,
            MustRetire = false,
            RetirementReason = null,
            TraumasCausingRetirement = traumasCausingRetirement,
            TotalRetirementTraumas = traumasCausingRetirement.Count,
            CanContinueWithPermission = true
        };
    }

    /// <summary>
    /// Creates a result indicating no retirement conditions met.
    /// </summary>
    /// <param name="characterId">Character ID</param>
    /// <returns>A new RetirementCheckResult</returns>
    public static RetirementCheckResult CreateNoRetirement(Guid characterId)
    {
        return new RetirementCheckResult
        {
            CharacterId = characterId,
            MustRetire = false,
            RetirementReason = null,
            TraumasCausingRetirement = new List<string>(),
            TotalRetirementTraumas = 0,
            CanContinueWithPermission = false
        };
    }
}
```

---

## 8. Retirement Logic

### 8.1 Retirement Condition Rules

The following conditions trigger retirement evaluations:

**Immediate Retirement (MustRetire=true):**
1. Acquire Survivor's Guilt (first acquisition)
2. Acquire Machine Affinity (first acquisition)
3. Acquire Death Wish (first acquisition)

**Stacking Retirement (MustRetire=true):**
1. Reality Doubt reaches 5+ instances
2. Hollow Resonance reaches 3+ instances

**Accumulation Retirement (Optional, CanContinue=true):**
1. Any 3+ different moderate traumas with StackCount > 1

### 8.2 Retirement Evaluation Pseudocode

```
function CheckRetirementCondition(character):
    immediateRetirementTraumas = []
    stackingRetirementTraumas = []
    accumulatedModerateLevelTraumas = []

    for each trauma in character.traumas:
        if trauma.definition.isRetirementTrauma:
            if trauma.definition.retirementCondition == "On acquisition":
                immediateRetirementTraumas.add(trauma.id)
            elif trauma.definition.retirementCondition == "5+ instances":
                if trauma.stackCount >= 5:
                    stackingRetirementTraumas.add(trauma.id)
            elif trauma.definition.retirementCondition == "3+ instances":
                if trauma.stackCount >= 3:
                    stackingRetirementTraumas.add(trauma.id)

        if trauma.stackCount > 1:
            accumulatedModerateLevelTraumas.add(trauma.id)

    causedRetirement = immediateRetirementTraumas + stackingRetirementTraumas

    if immediateRetirementTraumas.count > 0:
        return CreateMustRetire(character.id, "Immediate trauma forces retirement", causedRetirement)
    elif stackingRetirementTraumas.count > 0:
        return CreateMustRetire(character.id, "Critical trauma stacking forces retirement", causedRetirement)
    elif accumulatedModerateLevelTraumas.count >= 3:
        return CreateOptional(character.id, accumulatedModerateLevelTraumas)
    else:
        return CreateNoRetirement(character.id)
```

---

## 9. Logging Specifications

### 9.1 Entity Logging

> **Note:** Entity creation/modification typically logged in Application Layer (v0.18.3e).

### 9.2 Expected Log Events (Future Implementation)

| Event                    | Level       | Template                                                       |
| ------------------------ | ----------- | -------------------------------------------------------------- |
| Trauma Acquired          | Information | `"Trauma acquired: {CharacterId} {TraumaId} from {Source}"`    |
| Trauma Stacked           | Warning     | `"Trauma stacked: {CharacterId} {TraumaId} x{NewStackCount}"`  |
| Retirement Check Triggered | Warning    | `"Retirement check triggered: {CharacterId} ({Reason})"`       |
| Mandatory Retirement      | Error       | `"Character must retire: {CharacterId} ({Reason})"`            |

---

## 10. Unit Testing Requirements

### 10.1 Test File Locations

**Files:**
- `tests/RuneAndRust.Domain.UnitTests/Entities/CharacterTraumaTests.cs`
- `tests/RuneAndRust.Domain.UnitTests/Records/TraumaAcquisitionResultTests.cs`
- `tests/RuneAndRust.Domain.UnitTests/Records/RetirementCheckResultTests.cs`

### 10.2 Required Tests

| Test Name | Description |
| --- | --- |
| `Create_WithValidParameters_CreatesCharacterTrauma` | Verify entity creation |
| `IncrementStackCount_IncrementsCount` | Verify stack increment logic |
| `Create_WithEmptyCharacterId_ThrowsException` | Verify validation |
| `TraumaAcquisitionResult_CreateNew_ReturnsCorrectValues` | Verify new acquisition result |
| `TraumaAcquisitionResult_CreateStacked_IncrementsCount` | Verify stacking result |
| `RetirementCheckResult_CreateMustRetire_SetsCorrectValues` | Verify mandatory retirement |
| `RetirementCheckResult_CreateOptional_AllowsContinuation` | Verify optional retirement |

### 10.3 Example Test

```csharp
[TestFixture]
public class CharacterTraumaTests
{
    private readonly Guid _characterId = Guid.NewGuid();

    [Test]
    public void Create_WithValidParameters_CreatesCharacterTrauma()
    {
        // Arrange
        var traumaId = "survivors-guilt";
        var source = "AllyDeath";
        var acquiredAt = DateTime.UtcNow;

        // Act
        var trauma = CharacterTrauma.Create(
            characterId: _characterId,
            traumaDefinitionId: traumaId,
            source: source,
            acquiredAt: acquiredAt
        );

        // Assert
        trauma.CharacterId.Should().Be(_characterId);
        trauma.TraumaDefinitionId.Should().Be(traumaId);
        trauma.Source.Should().Be(source);
        trauma.AcquiredAt.Should().Be(acquiredAt);
        trauma.StackCount.Should().Be(1);
        trauma.IsActive.Should().BeTrue();
        trauma.ManagedSince.Should().BeNull();
    }

    [Test]
    public void IncrementStackCount_IncrementsCount()
    {
        // Arrange
        var trauma = CharacterTrauma.Create(
            _characterId, "survivors-guilt", "AllyDeath", DateTime.UtcNow
        );

        // Act
        trauma.IncrementStackCount();

        // Assert
        trauma.StackCount.Should().Be(2);
    }

    [Test]
    public void SetManagementStart_AfterAcquisition_Succeeds()
    {
        // Arrange
        var acquiredAt = DateTime.UtcNow;
        var managedAt = acquiredAt.AddDays(1);
        var trauma = CharacterTrauma.Create(
            _characterId, "survivors-guilt", "AllyDeath", acquiredAt
        );

        // Act
        trauma.SetManagementStart(managedAt);

        // Assert
        trauma.ManagedSince.Should().Be(managedAt);
    }

    [Test]
    public void SetManagementStart_BeforeAcquisition_ThrowsException()
    {
        // Arrange
        var acquiredAt = DateTime.UtcNow;
        var managedAt = acquiredAt.AddDays(-1);
        var trauma = CharacterTrauma.Create(
            _characterId, "survivors-guilt", "AllyDeath", acquiredAt
        );

        // Act & Assert
        var ex = Assert.Throws<ArgumentException>(() =>
            trauma.SetManagementStart(managedAt)
        );
        ex.ParamName.Should().Be("managedSince");
    }
}

[TestFixture]
public class TraumaAcquisitionResultTests
{
    [Test]
    public void CreateNew_ReturnsCorrectValues()
    {
        // Arrange & Act
        var result = TraumaAcquisitionResult.CreateNew(
            traumaId: "survivors-guilt",
            traumaName: "Survivor's Guilt",
            source: "AllyDeath",
            triggersRetirementCheck: true
        );

        // Assert
        result.Success.Should().BeTrue();
        result.IsNewTrauma.Should().BeTrue();
        result.NewStackCount.Should().Be(1);
        result.TriggersRetirementCheck.Should().BeTrue();
    }

    [Test]
    public void CreateStacked_IncrementsStackCount()
    {
        // Arrange & Act
        var result = TraumaAcquisitionResult.CreateStacked(
            traumaId: "reality-doubt",
            traumaName: "Reality Doubt",
            source: "ProximityEvent",
            newStackCount: 5,
            triggersRetirementCheck: true
        );

        // Assert
        result.Success.Should().BeTrue();
        result.IsNewTrauma.Should().BeFalse();
        result.NewStackCount.Should().Be(5);
    }
}

[TestFixture]
public class RetirementCheckResultTests
{
    [Test]
    public void CreateMustRetire_SetsMandatoryRetirement()
    {
        // Arrange & Act
        var characterId = Guid.NewGuid();
        var result = RetirementCheckResult.CreateMustRetire(
            characterId: characterId,
            retirementReason: "Machine Affinity forces retirement",
            traumasCausingRetirement: new[] { "machine-affinity" }
        );

        // Assert
        result.CharacterId.Should().Be(characterId);
        result.MustRetire.Should().BeTrue();
        result.RetirementReason.Should().NotBeNullOrEmpty();
        result.CanContinueWithPermission.Should().BeFalse();
    }

    [Test]
    public void CreateOptional_AllowsContinuation()
    {
        // Arrange & Act
        var characterId = Guid.NewGuid();
        var traumaList = new[] { "trauma-1", "trauma-2", "trauma-3" };
        var result = RetirementCheckResult.CreateOptional(
            characterId: characterId,
            traumasCausingRetirement: traumaList
        );

        // Assert
        result.CharacterId.Should().Be(characterId);
        result.MustRetire.Should().BeFalse();
        result.CanContinueWithPermission.Should().BeTrue();
        result.TotalRetirementTraumas.Should().Be(3);
    }
}
```

---

## 11. Deliverable Checklist

### 11.1 Domain Layer

- [ ] `src/Core/RuneAndRust.Domain/Entities/CharacterTrauma.cs`
- [ ] `src/Core/RuneAndRust.Domain/Records/TraumaAcquisitionResult.cs`
- [ ] `src/Core/RuneAndRust.Domain/Records/RetirementCheckResult.cs`

### 11.2 Tests

- [ ] `tests/RuneAndRust.Domain.UnitTests/Entities/CharacterTraumaTests.cs`
- [ ] `tests/RuneAndRust.Domain.UnitTests/Records/TraumaAcquisitionResultTests.cs`
- [ ] `tests/RuneAndRust.Domain.UnitTests/Records/RetirementCheckResultTests.cs`

### 11.3 Documentation

- [ ] Update `docs/design/v0.18.x/v0.18.3-scope-breakdown.md` (mark v0.18.3b complete)
- [ ] Create `docs/changelogs/v0.18.3b-changelog.md`

---

## 12. Acceptance Criteria

### 12.1 Build Verification

- [ ] Solution builds without errors
- [ ] Solution builds without warnings in new code

### 12.2 Test Verification

- [ ] All new unit tests pass (~5 tests)
- [ ] All existing unit tests continue to pass

### 12.3 Functional Verification

- [ ] `CharacterTrauma.Create()` validates all required parameters
- [ ] `StackCount` increments correctly
- [ ] `SetManagementStart()` prevents dates before acquisition
- [ ] `TraumaAcquisitionResult` correctly identifies new vs stacked
- [ ] `RetirementCheckResult` correctly categorizes retirement conditions
- [ ] Entities serialize/deserialize for database persistence (v0.18.3e)

---

## 13. Dependencies

### 13.1 Required Prerequisites

| Dependency            | Version | Status   | Notes                            |
| --------------------- | ------- | -------- | -------------------------------- |
| Trauma Enums & Definitions | v0.18.3a | Required | References TraumaType |
| Character Entity      | v0.x.x  | Required | CharacterTrauma references Character |

### 13.2 Provides to v0.18.3c

| Type | Usage |
| --- | --- |
| `CharacterTrauma` | Trauma check system references character traumas |
| `TraumaAcquisitionResult` | Result of trauma checks |
| `RetirementCheckResult` | Evaluated by trauma checks |

### 13.3 Deferred to Later Phases

| Item | Deferred To | Reason |
| --- | --- | --- |
| Trauma check mechanics | v0.18.3c | Separate service layer |
| Trauma effects application | v0.18.5 | Integration phase |
| Trauma therapy/management | v0.22.x | Advanced recovery system |

---

## 14. Future Considerations

### 14.1 v0.18.3c (Trauma Check System)

- Integration of CharacterTrauma into check system
- Automatic retirement evaluation on trauma acquisition

### 14.2 v0.18.3d-e (Service Layer & Config)

- Database persistence of CharacterTrauma
- Querying and filtering trauma history
- Retirement condition persistence

### 14.3 v0.18.5 (Trauma Integration)

- Trauma effect application based on IsActive
- Combat modifiers based on active traumas
- NPC trauma effects on AI behavior
- Trauma interaction matrix (conflicting effects)

### 14.4 v0.22.x (Trauma Therapy)

- Therapy and management systems setting ManagedSince
- Partial suppression of trauma effects
- Recovery progression tracking

---

*This design specification provides the detailed blueprint for implementing v0.18.3b. The Character Trauma Tracking layer enables all subsequent trauma system functionality.*

---

## Changelog

| Version | Date       | Changes                        |
| ------- | ---------- | ------------------------------ |
| 1.0     | 2026-01-28 | Initial design specification   |
