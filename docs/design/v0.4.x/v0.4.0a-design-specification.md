# v0.4.0a Design Specification: Interactive Object Core

**Version:** 0.4.0a
**Phase Name:** Interactive Object Core
**Parent Version:** v0.4.0 (Interactive Objects Foundation)
**Prerequisites:** v0.3.2 Complete (Quest Chains & Advanced Features)
**Estimated Tests:** ~35 unit tests

---

## 1. Overview

### 1.1 Purpose

Establish the foundational `InteractiveObject` entity with state management, the `interact` command infrastructure, and Room integration. This phase creates the base class that all interactive objects (containers, doors, levers, etc.) will extend in subsequent phases.

### 1.2 Current State

The following infrastructure already exists from prior versions:

| Component | Location | Status |
|-----------|----------|--------|
| `ObjectState` enum | `Domain/Enums/ObjectState.cs` | Complete (20+ states) |
| `InteractiveObjectType` enum | `Domain/Enums/InteractiveObjectType.cs` | Partial (needs expansion) |
| `InteractiveObjectDescriptor` | `Domain/ValueObjects/InteractiveObjectDescriptor.cs` | Complete |
| `ObjectDescriptorService` | `Application/Services/ObjectDescriptorService.cs` | Complete |
| `ObjectDescriptorContext` | `Application/Services/ObjectDescriptorContext.cs` | Complete |
| `Room` entity | `Domain/Entities/Room.cs` | Needs modification |
| `DiceService` | `Application/Services/DiceService.cs` | Complete |
| `GameSessionService` | `Application/Services/GameSessionService.cs` | Complete |
| `IGameRenderer` | `Application/Interfaces/IGameRenderer.cs` | Complete |

### 1.3 Scope

**In Scope:**
- `InteractiveObject` entity with state tracking (uses existing `ObjectState` enum)
- `InteractiveObjectType` enum expansion (add: Crate, Barrel, Button, Web, Barrier)
- `InteractionType` enum (NEW: Open, Close, Unlock, Activate, Deactivate, Break, Search, Examine, Take, Put, Lock)
- `InteractiveObjectDefinition` for JSON configuration
- Integration with existing `InteractiveObjectDescriptor` and `ObjectDescriptorService`
- `interact <object>` command
- `open <object>` and `close <object>` commands (basic, non-locked)
- Room.Interactables collection
- `InteractionService` for handling interactions
- Basic doors (non-locked, passage blockers)
- Object discovery in room descriptions
- Examine integration for interactive objects

**Out of Scope:**
- Container inventories (v0.4.0b)
- Keys and locks (v0.4.0b)
- Lockpicking (v0.4.0b)
- Levers and buttons (v0.4.0c)
- Destructible objects (v0.4.0c)
- Linked effects (v0.4.0c)

### 1.4 Design Goals

1. **Foundation First**: Create solid base entity that future phases extend
2. **State Integrity**: All state transitions validated and consistent
3. **Discoverability**: Objects naturally integrate into room descriptions
4. **Extensibility**: Architecture supports containers, locks, effects in future phases
5. **Consistency**: Uses existing patterns (ObjectState, ObjectDescriptor) for coherent design
6. **Testability**: Clean separation enables comprehensive unit testing

---

## 2. Data Model

### 2.1 InteractiveObject Entity

**File:** `src/Core/RuneAndRust.Domain/Entities/InteractiveObject.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents an object in the world that players can interact with.
/// Uses existing ObjectState and InteractiveObjectType enums.
/// </summary>
public class InteractiveObject : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this object.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the definition ID from configuration.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name of this object.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the type of interactive object (uses existing enum).
    /// </summary>
    public InteractiveObjectType ObjectType { get; private set; }

    /// <summary>
    /// Gets the current state of this object (uses existing enum).
    /// </summary>
    public ObjectState State { get; private set; } = ObjectState.Normal;

    /// <summary>
    /// Gets the default state this object starts in.
    /// </summary>
    public ObjectState DefaultState { get; private set; } = ObjectState.Normal;

    /// <summary>
    /// Gets the allowed interaction types for this object.
    /// </summary>
    public IReadOnlyList<InteractionType> AllowedInteractions { get; private set; } = Array.Empty<InteractionType>();

    /// <summary>
    /// Gets whether this object blocks passage (like a closed door).
    /// </summary>
    public bool BlocksPassage { get; private set; }

    /// <summary>
    /// Gets the direction this object blocks (for doors).
    /// </summary>
    public Direction? BlockedDirection { get; private set; }

    /// <summary>
    /// Gets whether this object is currently blocking passage.
    /// </summary>
    public bool IsCurrentlyBlocking => BlocksPassage && (State == ObjectState.Closed || State == ObjectState.Locked);

    /// <summary>
    /// Gets whether this object can be interacted with.
    /// </summary>
    public bool CanInteract => State != ObjectState.Broken && State != ObjectState.Destroyed;

    /// <summary>
    /// Gets whether this object is visible in room descriptions.
    /// </summary>
    public bool IsVisible { get; private set; } = true;

    /// <summary>
    /// Gets keywords that can be used to reference this object.
    /// </summary>
    public IReadOnlyList<string> Keywords { get; private set; } = Array.Empty<string>();

    private InteractiveObject() { }

    /// <summary>
    /// Creates a new interactive object.
    /// </summary>
    public static InteractiveObject Create(
        string definitionId,
        string name,
        InteractiveObjectType objectType,
        ObjectState defaultState,
        IEnumerable<InteractionType> allowedInteractions,
        bool blocksPassage = false,
        Direction? blockedDirection = null,
        IEnumerable<string>? keywords = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(definitionId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new InteractiveObject
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId,
            Name = name,
            ObjectType = objectType,
            State = defaultState,
            DefaultState = defaultState,
            AllowedInteractions = allowedInteractions.ToList(),
            BlocksPassage = blocksPassage,
            BlockedDirection = blockedDirection,
            Keywords = keywords?.ToList() ?? new List<string> { name.ToLowerInvariant() }
        };
    }

    /// <summary>
    /// Creates an interactive object from a definition.
    /// </summary>
    public static InteractiveObject FromDefinition(InteractiveObjectDefinition definition)
    {
        ArgumentNullException.ThrowIfNull(definition);

        return new InteractiveObject
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.Id,
            Name = definition.Name,
            ObjectType = definition.ObjectType,
            State = definition.DefaultState,
            DefaultState = definition.DefaultState,
            AllowedInteractions = definition.AllowedInteractions.ToList(),
            BlocksPassage = definition.BlocksPassage,
            BlockedDirection = definition.BlockedDirection,
            Keywords = definition.Keywords.ToList(),
            IsVisible = definition.IsVisible
        };
    }

    /// <summary>
    /// Attempts to change the object's state.
    /// </summary>
    /// <param name="newState">The new state to set.</param>
    /// <returns>True if state was changed, false if not allowed.</returns>
    public bool TrySetState(ObjectState newState)
    {
        if (State == ObjectState.Broken || State == ObjectState.Destroyed)
            return false;

        State = newState;
        return true;
    }

    /// <summary>
    /// Checks if an interaction type is allowed.
    /// </summary>
    /// <param name="type">The interaction type to check.</param>
    /// <returns>True if the interaction is allowed.</returns>
    public bool CanPerformInteraction(InteractionType type)
    {
        if (!CanInteract) return false;
        return AllowedInteractions.Contains(type);
    }

    /// <summary>
    /// Gets the default interaction for this object based on its current state.
    /// </summary>
    /// <returns>The default interaction type, or null if none available.</returns>
    public InteractionType? GetDefaultInteraction()
    {
        return State switch
        {
            ObjectState.Closed => AllowedInteractions.Contains(InteractionType.Open) ? InteractionType.Open : null,
            ObjectState.Open => AllowedInteractions.Contains(InteractionType.Close) ? InteractionType.Close : null,
            ObjectState.Locked => AllowedInteractions.Contains(InteractionType.Unlock) ? InteractionType.Unlock : null,
            ObjectState.Inactive => AllowedInteractions.Contains(InteractionType.Activate) ? InteractionType.Activate : null,
            ObjectState.Active => AllowedInteractions.Contains(InteractionType.Deactivate) ? InteractionType.Deactivate : null,
            ObjectState.Down => AllowedInteractions.Contains(InteractionType.Activate) ? InteractionType.Activate : null,
            ObjectState.Up => AllowedInteractions.Contains(InteractionType.Deactivate) ? InteractionType.Deactivate : null,
            _ => null
        };
    }

    /// <summary>
    /// Checks if a keyword matches this object.
    /// </summary>
    /// <param name="keyword">The keyword to check.</param>
    /// <returns>True if the keyword matches.</returns>
    public bool MatchesKeyword(string keyword)
    {
        return Keywords.Any(k => k.Equals(keyword, StringComparison.OrdinalIgnoreCase)) ||
               Name.Contains(keyword, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Resets the object to its default state.
    /// </summary>
    public void Reset()
    {
        if (State != ObjectState.Broken && State != ObjectState.Destroyed)
        {
            State = DefaultState;
        }
    }

    /// <summary>
    /// Sets the visibility of this object.
    /// </summary>
    /// <param name="visible">Whether the object should be visible.</param>
    public void SetVisibility(bool visible)
    {
        IsVisible = visible;
    }
}
```

### 2.2 InteractionType Enum (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/InteractionType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of interactions that can be performed on interactive objects.
/// </summary>
public enum InteractionType
{
    /// <summary>Open a closed object (chest, door).</summary>
    Open,

    /// <summary>Close an open object.</summary>
    Close,

    /// <summary>Unlock a locked object with a key.</summary>
    Unlock,

    /// <summary>Lock an unlocked object with a key.</summary>
    Lock,

    /// <summary>Activate a mechanism (pull lever, press button).</summary>
    Activate,

    /// <summary>Deactivate an active mechanism.</summary>
    Deactivate,

    /// <summary>Break/destroy the object.</summary>
    Break,

    /// <summary>Search the object for hidden items or secrets.</summary>
    Search,

    /// <summary>Examine the object for detailed information.</summary>
    Examine,

    /// <summary>Take items from a container.</summary>
    Take,

    /// <summary>Put items into a container.</summary>
    Put
}
```

### 2.3 InteractiveObjectType Enum Update

**File:** `src/Core/RuneAndRust.Domain/Enums/InteractiveObjectType.cs`

Add the following values to the existing enum:

```csharp
// Add to existing InteractiveObjectType enum:

/// <summary>A breakable wooden crate.</summary>
Crate,

/// <summary>A storage barrel.</summary>
Barrel,

/// <summary>A momentary push button.</summary>
Button,

/// <summary>A spider web or similar barrier.</summary>
Web,

/// <summary>A generic destructible barrier.</summary>
Barrier
```

### 2.4 InteractiveObjectDefinition

**File:** `src/Core/RuneAndRust.Domain/Definitions/InteractiveObjectDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Configuration definition for an interactive object type.
/// </summary>
public class InteractiveObjectDefinition
{
    /// <summary>
    /// Gets or sets the unique identifier for this definition.
    /// </summary>
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the display name of objects created from this definition.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the type of interactive object.
    /// </summary>
    public InteractiveObjectType ObjectType { get; set; }

    /// <summary>
    /// Gets or sets the default state for new objects.
    /// </summary>
    public ObjectState DefaultState { get; set; } = ObjectState.Normal;

    /// <summary>
    /// Gets or sets the allowed interaction types.
    /// </summary>
    public List<InteractionType> AllowedInteractions { get; set; } = new();

    /// <summary>
    /// Gets or sets whether this object blocks passage.
    /// </summary>
    public bool BlocksPassage { get; set; }

    /// <summary>
    /// Gets or sets the direction this object blocks (for doors).
    /// </summary>
    public Direction? BlockedDirection { get; set; }

    /// <summary>
    /// Gets or sets keywords that can be used to reference this object.
    /// </summary>
    public List<string> Keywords { get; set; } = new();

    /// <summary>
    /// Gets or sets whether this object is visible by default.
    /// </summary>
    public bool IsVisible { get; set; } = true;
}
```

### 2.5 InteractionResult Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/InteractionResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the result of an interaction attempt.
/// </summary>
public readonly record struct InteractionResult
{
    /// <summary>
    /// Gets whether the interaction was successful.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the message to display to the player.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the interaction type that was attempted.
    /// </summary>
    public InteractionType InteractionType { get; init; }

    /// <summary>
    /// Gets the new state of the object after interaction (if successful).
    /// </summary>
    public ObjectState? NewState { get; init; }

    /// <summary>
    /// Gets whether the object state changed.
    /// </summary>
    public bool StateChanged { get; init; }

    /// <summary>
    /// Gets the reason for failure (if unsuccessful).
    /// </summary>
    public string? FailureReason { get; init; }

    /// <summary>
    /// Creates a successful interaction result.
    /// </summary>
    public static InteractionResult Succeeded(
        InteractionType type,
        string message,
        ObjectState? newState = null,
        bool stateChanged = false) => new()
    {
        Success = true,
        InteractionType = type,
        Message = message,
        NewState = newState,
        StateChanged = stateChanged
    };

    /// <summary>
    /// Creates a failed interaction result.
    /// </summary>
    public static InteractionResult Failed(
        InteractionType type,
        string message,
        string? reason = null) => new()
    {
        Success = false,
        InteractionType = type,
        Message = message,
        FailureReason = reason
    };

    /// <summary>
    /// Creates a result for when the interaction is not allowed.
    /// </summary>
    public static InteractionResult NotAllowed(InteractionType type, string objectName) =>
        Failed(type, $"You cannot {type.ToString().ToLowerInvariant()} the {objectName}.", "Interaction not allowed");

    /// <summary>
    /// Creates a result for when the object cannot be interacted with.
    /// </summary>
    public static InteractionResult CannotInteract(string objectName) =>
        Failed(InteractionType.Examine, $"The {objectName} cannot be interacted with in its current state.", "Object not interactable");
}
```

---

## 3. Room Modifications

### 3.1 Room Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

Add the following members:

```csharp
// Add private field
private readonly List<InteractiveObject> _interactables = new();

// Add public properties
/// <summary>
/// Gets the interactive objects in this room.
/// </summary>
public IReadOnlyList<InteractiveObject> Interactables => _interactables;

/// <summary>
/// Gets whether this room has any interactive objects.
/// </summary>
public bool HasInteractables => _interactables.Count > 0;

// Add methods
/// <summary>
/// Adds an interactive object to this room.
/// </summary>
/// <param name="interactable">The object to add.</param>
public void AddInteractable(InteractiveObject interactable)
{
    ArgumentNullException.ThrowIfNull(interactable);
    _interactables.Add(interactable);
}

/// <summary>
/// Removes an interactive object from this room.
/// </summary>
/// <param name="interactable">The object to remove.</param>
/// <returns>True if the object was removed.</returns>
public bool RemoveInteractable(InteractiveObject interactable)
{
    return _interactables.Remove(interactable);
}

/// <summary>
/// Gets an interactive object by keyword.
/// </summary>
/// <param name="keyword">The keyword to search for.</param>
/// <returns>The matching object, or null if not found.</returns>
public InteractiveObject? GetInteractableByKeyword(string keyword)
{
    return _interactables.FirstOrDefault(i => i.MatchesKeyword(keyword));
}

/// <summary>
/// Gets the object blocking a specific direction.
/// </summary>
/// <param name="direction">The direction to check.</param>
/// <returns>The blocking object, or null if no object is blocking.</returns>
public InteractiveObject? GetBlockingObject(Direction direction)
{
    return _interactables.FirstOrDefault(i =>
        i.IsCurrentlyBlocking &&
        i.BlockedDirection == direction);
}

/// <summary>
/// Gets all visible interactive objects.
/// </summary>
/// <returns>Enumerable of visible objects.</returns>
public IEnumerable<InteractiveObject> GetVisibleInteractables()
{
    return _interactables.Where(i => i.IsVisible);
}

/// <summary>
/// Checks if movement in a direction is blocked by an object.
/// </summary>
/// <param name="direction">The direction to check.</param>
/// <returns>True if an object is blocking that direction.</returns>
public bool IsDirectionBlocked(Direction direction)
{
    return GetBlockingObject(direction) != null;
}
```

---

## 4. Services

### 4.1 IInteractionService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IInteractionService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for handling player interactions with interactive objects.
/// </summary>
public interface IInteractionService
{
    /// <summary>
    /// Performs the default interaction on an object.
    /// </summary>
    /// <param name="obj">The object to interact with.</param>
    /// <returns>The result of the interaction.</returns>
    InteractionResult Interact(InteractiveObject obj);

    /// <summary>
    /// Performs a specific interaction on an object.
    /// </summary>
    /// <param name="obj">The object to interact with.</param>
    /// <param name="type">The type of interaction.</param>
    /// <returns>The result of the interaction.</returns>
    InteractionResult PerformInteraction(InteractiveObject obj, InteractionType type);

    /// <summary>
    /// Opens an interactive object.
    /// </summary>
    /// <param name="obj">The object to open.</param>
    /// <returns>The result of the interaction.</returns>
    InteractionResult Open(InteractiveObject obj);

    /// <summary>
    /// Closes an interactive object.
    /// </summary>
    /// <param name="obj">The object to close.</param>
    /// <returns>The result of the interaction.</returns>
    InteractionResult Close(InteractiveObject obj);

    /// <summary>
    /// Examines an interactive object.
    /// </summary>
    /// <param name="obj">The object to examine.</param>
    /// <returns>The result with examination details.</returns>
    InteractionResult Examine(InteractiveObject obj);

    /// <summary>
    /// Finds an interactive object in a room by keyword.
    /// </summary>
    /// <param name="room">The room to search.</param>
    /// <param name="keyword">The keyword to search for.</param>
    /// <returns>The matching object, or null if not found.</returns>
    InteractiveObject? FindObject(Room room, string keyword);

    /// <summary>
    /// Gets a description of all visible objects in a room.
    /// </summary>
    /// <param name="room">The room to describe.</param>
    /// <returns>A formatted description of objects.</returns>
    string GetRoomObjectsDescription(Room room);
}
```

### 4.2 InteractionService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/InteractionService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using System.Text;

/// <summary>
/// Service for handling player interactions with interactive objects.
/// </summary>
public class InteractionService : IInteractionService
{
    private readonly IObjectDescriptorService _descriptorService;
    private readonly ILogger<InteractionService> _logger;

    /// <summary>
    /// Creates a new interaction service.
    /// </summary>
    public InteractionService(
        IObjectDescriptorService descriptorService,
        ILogger<InteractionService> logger)
    {
        _descriptorService = descriptorService ?? throw new ArgumentNullException(nameof(descriptorService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public InteractionResult Interact(InteractiveObject obj)
    {
        ArgumentNullException.ThrowIfNull(obj);

        _logger.LogDebug("Default interact with {ObjectName} (State: {State})", obj.Name, obj.State);

        if (!obj.CanInteract)
        {
            return InteractionResult.CannotInteract(obj.Name);
        }

        var defaultInteraction = obj.GetDefaultInteraction();
        if (defaultInteraction == null)
        {
            return InteractionResult.Failed(
                InteractionType.Examine,
                $"You examine the {obj.Name}, but there's nothing obvious to do with it.",
                "No default interaction available");
        }

        return PerformInteraction(obj, defaultInteraction.Value);
    }

    /// <inheritdoc />
    public InteractionResult PerformInteraction(InteractiveObject obj, InteractionType type)
    {
        ArgumentNullException.ThrowIfNull(obj);

        _logger.LogDebug("Performing {InteractionType} on {ObjectName}", type, obj.Name);

        if (!obj.CanInteract)
        {
            return InteractionResult.CannotInteract(obj.Name);
        }

        if (!obj.CanPerformInteraction(type))
        {
            return InteractionResult.NotAllowed(type, obj.Name);
        }

        return type switch
        {
            InteractionType.Open => Open(obj),
            InteractionType.Close => Close(obj),
            InteractionType.Examine => Examine(obj),
            // Future phases will handle these:
            // InteractionType.Unlock => Unlock(obj),
            // InteractionType.Lock => Lock(obj),
            // InteractionType.Activate => Activate(obj),
            // InteractionType.Deactivate => Deactivate(obj),
            // InteractionType.Break => Break(obj),
            // InteractionType.Search => Search(obj),
            // InteractionType.Take => Take(obj),
            // InteractionType.Put => Put(obj),
            _ => InteractionResult.NotAllowed(type, obj.Name)
        };
    }

    /// <inheritdoc />
    public InteractionResult Open(InteractiveObject obj)
    {
        ArgumentNullException.ThrowIfNull(obj);

        if (obj.State == ObjectState.Open)
        {
            return InteractionResult.Failed(
                InteractionType.Open,
                $"The {obj.Name} is already open.");
        }

        if (obj.State == ObjectState.Locked)
        {
            return InteractionResult.Failed(
                InteractionType.Open,
                $"The {obj.Name} is locked.",
                "Object is locked");
        }

        if (!obj.TrySetState(ObjectState.Open))
        {
            return InteractionResult.Failed(
                InteractionType.Open,
                $"The {obj.Name} cannot be opened.",
                "State change not allowed");
        }

        _logger.LogInformation("Opened {ObjectName}", obj.Name);

        var message = GetInteractionMessage(obj, InteractionType.Open);
        return InteractionResult.Succeeded(
            InteractionType.Open,
            message,
            ObjectState.Open,
            stateChanged: true);
    }

    /// <inheritdoc />
    public InteractionResult Close(InteractiveObject obj)
    {
        ArgumentNullException.ThrowIfNull(obj);

        if (obj.State == ObjectState.Closed)
        {
            return InteractionResult.Failed(
                InteractionType.Close,
                $"The {obj.Name} is already closed.");
        }

        if (obj.State != ObjectState.Open)
        {
            return InteractionResult.Failed(
                InteractionType.Close,
                $"The {obj.Name} cannot be closed in its current state.",
                "Invalid state for closing");
        }

        if (!obj.TrySetState(ObjectState.Closed))
        {
            return InteractionResult.Failed(
                InteractionType.Close,
                $"The {obj.Name} cannot be closed.",
                "State change not allowed");
        }

        _logger.LogInformation("Closed {ObjectName}", obj.Name);

        var message = GetInteractionMessage(obj, InteractionType.Close);
        return InteractionResult.Succeeded(
            InteractionType.Close,
            message,
            ObjectState.Closed,
            stateChanged: true);
    }

    /// <inheritdoc />
    public InteractionResult Examine(InteractiveObject obj)
    {
        ArgumentNullException.ThrowIfNull(obj);

        var descriptor = _descriptorService.GetDescriptor(obj.ObjectType, obj.State);
        var description = descriptor.GetDescription(ExaminationDepth.Examine);

        _logger.LogDebug("Examined {ObjectName}: {Description}", obj.Name, description);

        return InteractionResult.Succeeded(
            InteractionType.Examine,
            $"{obj.Name}\n{description}");
    }

    /// <inheritdoc />
    public InteractiveObject? FindObject(Room room, string keyword)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentException.ThrowIfNullOrWhiteSpace(keyword);

        var obj = room.GetInteractableByKeyword(keyword);

        if (obj != null)
        {
            _logger.LogDebug("Found object {ObjectName} by keyword '{Keyword}'", obj.Name, keyword);
        }
        else
        {
            _logger.LogDebug("No object found for keyword '{Keyword}'", keyword);
        }

        return obj;
    }

    /// <inheritdoc />
    public string GetRoomObjectsDescription(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var visibleObjects = room.GetVisibleInteractables().ToList();
        if (!visibleObjects.Any())
        {
            return string.Empty;
        }

        var sb = new StringBuilder();
        sb.AppendLine("You notice:");

        foreach (var obj in visibleObjects)
        {
            var stateInfo = GetStateDisplayText(obj);
            var blockingInfo = obj.IsCurrentlyBlocking && obj.BlockedDirection.HasValue
                ? $" - blocking {obj.BlockedDirection.Value.ToString().ToLowerInvariant()}"
                : string.Empty;

            sb.AppendLine($"  {obj.Name}{stateInfo}{blockingInfo}");
        }

        return sb.ToString().TrimEnd();
    }

    private string GetStateDisplayText(InteractiveObject obj)
    {
        return obj.State switch
        {
            ObjectState.Open => " (open)",
            ObjectState.Closed => " (closed)",
            ObjectState.Locked => " (locked)",
            ObjectState.Active => " (active)",
            ObjectState.Inactive => " (inactive)",
            ObjectState.Lit => " (lit)",
            ObjectState.Unlit => " (unlit)",
            ObjectState.Broken => " (broken)",
            ObjectState.Destroyed => " (destroyed)",
            ObjectState.Up => " (up)",
            ObjectState.Down => " (down)",
            _ => string.Empty
        };
    }

    private string GetInteractionMessage(InteractiveObject obj, InteractionType type)
    {
        var descriptor = _descriptorService.GetDescriptor(obj.ObjectType, obj.State);

        return type switch
        {
            InteractionType.Open => GetOpenMessage(obj),
            InteractionType.Close => GetCloseMessage(obj),
            _ => descriptor.GetDescription(ExaminationDepth.Look)
        };
    }

    private string GetOpenMessage(InteractiveObject obj)
    {
        return obj.ObjectType switch
        {
            InteractiveObjectType.Door => $"You push open the {obj.Name}. It swings open with a creak.",
            InteractiveObjectType.Chest => $"You lift the lid of the {obj.Name}.",
            InteractiveObjectType.Crate => $"You pry open the {obj.Name}.",
            InteractiveObjectType.Barrel => $"You remove the lid from the {obj.Name}.",
            _ => $"You open the {obj.Name}."
        };
    }

    private string GetCloseMessage(InteractiveObject obj)
    {
        return obj.ObjectType switch
        {
            InteractiveObjectType.Door => $"You push the {obj.Name} closed.",
            InteractiveObjectType.Chest => $"You close the lid of the {obj.Name}.",
            InteractiveObjectType.Crate => $"You close the {obj.Name}.",
            InteractiveObjectType.Barrel => $"You replace the lid on the {obj.Name}.",
            _ => $"You close the {obj.Name}."
        };
    }
}
```

---

## 5. Configuration

### 5.1 Interactive Objects Configuration Schema

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/schemas/interactive-objects.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Interactive Objects Configuration",
  "description": "Configuration for interactive objects in the game world",
  "type": "object",
  "properties": {
    "interactiveObjects": {
      "type": "array",
      "description": "List of interactive object definitions",
      "items": {
        "$ref": "#/definitions/interactiveObjectDefinition"
      }
    }
  },
  "definitions": {
    "interactiveObjectDefinition": {
      "type": "object",
      "required": ["id", "name", "objectType"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for this object definition"
        },
        "name": {
          "type": "string",
          "description": "Display name of the object"
        },
        "objectType": {
          "type": "string",
          "description": "Type of interactive object",
          "enum": ["Door", "Chest", "Lever", "Statue", "Altar", "LightSource", "Inscription", "WaterFeature", "Crate", "Barrel", "Button", "Web", "Barrier"]
        },
        "defaultState": {
          "type": "string",
          "description": "Default state of the object",
          "enum": ["Normal", "Open", "Closed", "Locked", "Active", "Inactive", "Up", "Down", "Lit", "Unlit"],
          "default": "Normal"
        },
        "allowedInteractions": {
          "type": "array",
          "description": "Interactions allowed on this object",
          "items": {
            "type": "string",
            "enum": ["Open", "Close", "Unlock", "Lock", "Activate", "Deactivate", "Break", "Search", "Examine", "Take", "Put"]
          }
        },
        "blocksPassage": {
          "type": "boolean",
          "description": "Whether this object blocks passage when closed/locked",
          "default": false
        },
        "blockedDirection": {
          "type": "string",
          "description": "Direction this object blocks",
          "enum": ["North", "South", "East", "West", "Up", "Down"]
        },
        "keywords": {
          "type": "array",
          "description": "Keywords that can be used to reference this object",
          "items": {
            "type": "string"
          }
        },
        "isVisible": {
          "type": "boolean",
          "description": "Whether this object is visible by default",
          "default": true
        }
      }
    }
  }
}
```

### 5.2 Sample Configuration

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/interactive-objects.json`

```json
{
  "$schema": "./schemas/interactive-objects.schema.json",
  "interactiveObjects": [
    {
      "id": "iron-door-basic",
      "name": "Heavy Iron Door",
      "objectType": "Door",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine"],
      "blocksPassage": true,
      "keywords": ["door", "iron door", "heavy door"]
    },
    {
      "id": "wooden-door-basic",
      "name": "Wooden Door",
      "objectType": "Door",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine"],
      "blocksPassage": true,
      "keywords": ["door", "wooden door"]
    },
    {
      "id": "wooden-chest-basic",
      "name": "Weathered Wooden Chest",
      "objectType": "Chest",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine", "Search"],
      "keywords": ["chest", "wooden chest", "box"]
    },
    {
      "id": "iron-chest-basic",
      "name": "Iron-Bound Chest",
      "objectType": "Chest",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine", "Search"],
      "keywords": ["chest", "iron chest"]
    },
    {
      "id": "rusty-lever-basic",
      "name": "Rusty Lever",
      "objectType": "Lever",
      "defaultState": "Down",
      "allowedInteractions": ["Activate", "Examine"],
      "keywords": ["lever", "switch", "mechanism"]
    },
    {
      "id": "wooden-crate-basic",
      "name": "Wooden Crate",
      "objectType": "Crate",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Break", "Examine", "Search"],
      "keywords": ["crate", "box", "wooden crate"]
    },
    {
      "id": "storage-barrel-basic",
      "name": "Storage Barrel",
      "objectType": "Barrel",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Examine", "Search"],
      "keywords": ["barrel", "storage barrel"]
    },
    {
      "id": "spider-web-basic",
      "name": "Giant Spider Web",
      "objectType": "Web",
      "defaultState": "Normal",
      "allowedInteractions": ["Break", "Examine"],
      "blocksPassage": true,
      "keywords": ["web", "spider web", "cobweb"]
    },
    {
      "id": "stone-statue-basic",
      "name": "Stone Statue",
      "objectType": "Statue",
      "defaultState": "Normal",
      "allowedInteractions": ["Examine"],
      "keywords": ["statue", "stone statue"]
    },
    {
      "id": "ancient-altar-basic",
      "name": "Ancient Altar",
      "objectType": "Altar",
      "defaultState": "Inactive",
      "allowedInteractions": ["Activate", "Examine"],
      "keywords": ["altar", "ancient altar"]
    },
    {
      "id": "wall-torch-basic",
      "name": "Wall Torch",
      "objectType": "LightSource",
      "defaultState": "Lit",
      "allowedInteractions": ["Examine"],
      "keywords": ["torch", "wall torch", "light"]
    },
    {
      "id": "stone-inscription-basic",
      "name": "Stone Inscription",
      "objectType": "Inscription",
      "defaultState": "Normal",
      "allowedInteractions": ["Examine"],
      "keywords": ["inscription", "writing", "runes"]
    }
  ]
}
```

---

## 6. Command Integration

### 6.1 Interact Command

The `interact` command allows players to interact with objects using the default interaction:

```
> interact <object>
```

**Command Processing:**

```csharp
// In GameSessionService or CommandProcessor:

private InteractionResult ProcessInteractCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Examine,
            "Interact with what? Try 'interact <object>'.");
    }

    var keyword = string.Join(" ", args);
    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Examine,
            $"You don't see any '{keyword}' here.");
    }

    return _interactionService.Interact(obj);
}
```

### 6.2 Open/Close Commands

```
> open <object>
> close <object>
```

**Command Processing:**

```csharp
private InteractionResult ProcessOpenCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Open,
            "Open what? Try 'open <object>'.");
    }

    var keyword = string.Join(" ", args);
    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Open,
            $"You don't see any '{keyword}' here.");
    }

    return _interactionService.Open(obj);
}

private InteractionResult ProcessCloseCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Close,
            "Close what? Try 'close <object>'.");
    }

    var keyword = string.Join(" ", args);
    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Close,
            $"You don't see any '{keyword}' here.");
    }

    return _interactionService.Close(obj);
}
```

### 6.3 Movement Blocking Integration

Update movement logic to check for blocking objects:

```csharp
// In movement processing:
public MoveResult TryMove(Direction direction, Room currentRoom)
{
    var blockingObject = currentRoom.GetBlockingObject(direction);
    if (blockingObject != null)
    {
        return MoveResult.Blocked(
            $"The {blockingObject.Name} blocks your path to the {direction.ToString().ToLowerInvariant()}.");
    }

    // Continue with normal movement...
}
```

---

## 7. User Experience

### 7.1 Room Description with Objects

```
You are in the Ancient Vault. Dust-covered stone walls
surround a chamber that hasn't been disturbed for centuries.

You notice:
  Heavy Iron Door (closed) - blocking north
  Weathered Wooden Chest (closed)
  Rusty Lever (inactive)

Exits: south
```

### 7.2 Interaction Examples

**Default Interaction:**
```
> interact door

You push open the Heavy Iron Door. It swings open with a creak.

The Heavy Iron Door is now open.

Exits: north, south
```

**Explicit Commands:**
```
> open chest

You lift the lid of the Weathered Wooden Chest.

The Weathered Wooden Chest is now open.

---

> close chest

You close the lid of the Weathered Wooden Chest.

The Weathered Wooden Chest is now closed.

---

> examine lever

Rusty Lever
A corroded iron lever mounted on the wall. Years of moisture
have left it covered in rust, but it still appears functional.
The lever is currently in the down position.
```

**Movement Blocking:**
```
> north

The Heavy Iron Door blocks your path to the north.

> interact door

You push open the Heavy Iron Door. It swings open with a creak.

> north

You move north into the Dark Corridor.
```

---

## 8. Acceptance Criteria

### 8.1 Functional Requirements

- [ ] `InteractiveObject` entity stores state and allowed interactions
- [ ] `InteractionType` enum covers all interaction types
- [ ] `InteractiveObjectType` enum expanded with new types
- [ ] `interact` command finds objects by keyword
- [ ] `interact` performs default action based on state
- [ ] `open` and `close` commands work on applicable objects
- [ ] Room.Interactables collection works correctly
- [ ] Blocking objects prevent movement until opened
- [ ] Room descriptions list visible interactive objects
- [ ] Configuration loads interactive object definitions
- [ ] Integration with existing ObjectDescriptorService works

### 8.2 Non-Functional Requirements

- [ ] All entity properties are immutable or protected
- [ ] Services follow DI patterns
- [ ] Logging follows established patterns
- [ ] Unit tests cover entity logic, service methods, edge cases

---

## 9. Test Specifications

### 9.1 InteractiveObject Entity Tests (~12 tests)

| Test Name | Description |
|-----------|-------------|
| `Create_WithValidParameters_ReturnsObject` | Valid creation |
| `Create_WithNullDefinitionId_ThrowsException` | Null ID rejected |
| `Create_WithEmptyName_ThrowsException` | Empty name rejected |
| `FromDefinition_CreatesCorrectObject` | Definition mapping |
| `TrySetState_WhenBroken_ReturnsFalse` | Broken state immutable |
| `TrySetState_WhenDestroyed_ReturnsFalse` | Destroyed state immutable |
| `TrySetState_WhenNormal_ReturnsTrue` | Normal state changeable |
| `CanPerformInteraction_WhenAllowed_ReturnsTrue` | Allowed interaction check |
| `CanPerformInteraction_WhenNotAllowed_ReturnsFalse` | Not allowed check |
| `GetDefaultInteraction_WhenClosed_ReturnsOpen` | Default for closed |
| `GetDefaultInteraction_WhenOpen_ReturnsClose` | Default for open |
| `MatchesKeyword_CaseInsensitive_ReturnsTrue` | Keyword matching |
| `IsCurrentlyBlocking_WhenClosedAndBlocks_ReturnsTrue` | Blocking check |

### 9.2 InteractionService Tests (~12 tests)

| Test Name | Description |
|-----------|-------------|
| `Interact_WithDefaultInteraction_PerformsAction` | Default interaction |
| `Interact_WithNoDefaultInteraction_ReturnsExamine` | No default available |
| `Interact_WithBrokenObject_ReturnsFailed` | Broken object handling |
| `Open_WhenClosed_OpensObject` | Open command |
| `Open_WhenAlreadyOpen_ReturnsFailed` | Already open handling |
| `Open_WhenLocked_ReturnsFailed` | Locked handling |
| `Close_WhenOpen_ClosesObject` | Close command |
| `Close_WhenAlreadyClosed_ReturnsFailed` | Already closed handling |
| `Examine_ReturnsDescription` | Examine command |
| `FindObject_WithMatchingKeyword_ReturnsObject` | Object finding |
| `FindObject_WithNoMatch_ReturnsNull` | No match handling |
| `GetRoomObjectsDescription_WithObjects_ReturnsFormatted` | Room description |

### 9.3 Room Integration Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `AddInteractable_AddsToCollection` | Adding objects |
| `RemoveInteractable_RemovesFromCollection` | Removing objects |
| `GetInteractableByKeyword_FindsObject` | Keyword lookup |
| `GetBlockingObject_ReturnsBlockingObject` | Blocking lookup |
| `IsDirectionBlocked_WhenBlocked_ReturnsTrue` | Direction blocking |
| `GetVisibleInteractables_ReturnsOnlyVisible` | Visibility filtering |

### 9.4 Configuration Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `LoadConfiguration_ParsesValidJson` | JSON parsing |
| `LoadConfiguration_CreatesDefinitions` | Definition creation |
| `GetDefinitionById_ReturnsDefinition` | Definition lookup |
| `GetDefinitionById_WhenNotFound_ReturnsNull` | Not found handling |
| `FromDefinition_CreatesValidObject` | Definition to entity |

---

## 10. Dependencies

### 10.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| ObjectState enum | v0.0.x | Complete | Use as-is |
| InteractiveObjectType enum | v0.0.x | Partial | Needs expansion |
| InteractiveObjectDescriptor | v0.0.x | Complete | Use for descriptions |
| ObjectDescriptorService | v0.0.x | Complete | Integration point |
| Room entity | v0.0.x | Complete | Needs modification |
| GameSessionService | v0.0.x | Complete | Command processing |
| IGameRenderer | v0.0.x | Complete | Display output |

### 10.2 External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Microsoft.Extensions.Logging | 9.0.x | Logging |
| System.Text.Json | 9.0.x | Configuration parsing |

---

## 11. Files Summary

### 11.1 New Files

| File | Purpose |
|------|---------|
| `Domain/Entities/InteractiveObject.cs` | Core entity |
| `Domain/Enums/InteractionType.cs` | Interaction types enum |
| `Domain/Definitions/InteractiveObjectDefinition.cs` | Configuration definition |
| `Domain/ValueObjects/InteractionResult.cs` | Interaction result |
| `Application/Interfaces/IInteractionService.cs` | Service interface |
| `Application/Services/InteractionService.cs` | Service implementation |
| `Configuration/schemas/interactive-objects.schema.json` | JSON schema |
| `Configuration/interactive-objects.json` | Object definitions |
| `Tests/InteractiveObjectTests.cs` | Entity tests |
| `Tests/InteractionServiceTests.cs` | Service tests |
| `Tests/RoomInteractableTests.cs` | Room integration tests |

### 11.2 Modified Files

| File | Changes |
|------|---------|
| `Domain/Enums/InteractiveObjectType.cs` | Add Crate, Barrel, Button, Web, Barrier |
| `Domain/Entities/Room.cs` | Add Interactables collection and methods |
| `Application/Services/GameSessionService.cs` | Add interact/open/close command handling |
| `Infrastructure/DependencyInjection.cs` | Register InteractionService |
| `Presentation/GameView.cs` | Display interactive objects in room |

---

## 12. Future Considerations

### 12.1 v0.4.0b Preparation

The following will extend this foundation:
- ContainerInventory for chest contents
- LockDefinition for locked objects
- Unlock command with key matching
- Lockpicking skill checks

### 12.2 v0.4.0c Preparation

The following will extend this foundation:
- ObjectEffect for linked activation
- DestructibleProperties for breakable objects
- Lever and button specific behavior
- Break command integration with combat

---

*This design specification establishes the foundational interactive object system, enabling environmental interaction that future phases will extend with containers, locks, activation mechanics, and destructible objects.*
