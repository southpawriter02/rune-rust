# Implementation Plan: v0.4.1c - The Tree of Runes (Specialization UI)

**Status:** Ready for Implementation
**Theme:** "The Tree of Runes"
**Scope:** Terminal UI layer, ViewModel, Renderer, Controller, GameService integration

---

## Executive Summary

v0.4.1c implements the **Specialization UI Layer**, enabling players to view, navigate, and interact with specialization trees through a modal terminal interface. This release builds on v0.4.1b's service layer to provide the visual and input-handling components.

**Key Features:**
- **SpecializationViewModel**: Immutable snapshot for rendering specialization tree state
- **SpecializationScreenRenderer**: Spectre.Console-based tree visualization with tier layout
- **SpecializationController**: Arrow-key navigation and unlock input handling
- **GamePhase.SpecializationMenu**: New game phase for modal UI loop
- **GameService Integration**: Phase routing, input handling, and ViewModel building

**Layers Touched:** Core (ViewModel, Enums), Terminal (Rendering, Controllers), Engine (GameService), Test
**Patterns Used:** Modal UI Pattern (Saga), MVVM, Two-Tier Navigation
**Target Test Count:** 52 new unit tests

---

## Table of Contents

1. [Decision Trees](#1-decision-trees)
2. [Deliverable Checklist](#2-deliverable-checklist)
3. [ViewModel Definition](#3-viewmodel-definition)
4. [Renderer Interface & Implementation](#4-renderer-interface--implementation)
5. [Controller Implementation](#5-controller-implementation)
6. [GamePhase Enum Extension](#6-gamephase-enum-extension)
7. [GameService Integration](#7-gameservice-integration)
8. [Logging Matrix](#8-logging-matrix)
9. [Test Coverage Plan](#9-test-coverage-plan)
10. [DI Registration](#10-di-registration)
11. [Changelog Template](#11-changelog-template)
12. [Critical Files](#12-critical-files)
13. [Implementation Order](#13-implementation-order)

---

## 1. Decision Trees

### 1.1 Render Phase Decision Flow

```
RenderCurrentPhaseAsync()
                │
                ▼
    ┌───────────────────────────────┐
    │ _state.Phase ==               │
    │ GamePhase.SpecializationMenu? │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌─────────────────┐
│ _specRenderer   │  │ Handle other    │
│ != null?        │  │ phases...       │
└─────────────────┘  └─────────────────┘
        │
        ▼
┌─────────────────┐
│ Build ViewModel │
│ from service    │
└─────────────────┘
        │
        ▼
┌─────────────────┐
│ Call Render()   │
│ with ViewModel  │
└─────────────────┘
```

### 1.2 Input Handling Flow

```
HandleSpecializationInput(ConsoleKey key)
                │
                ▼
    ┌───────────────────────────────┐
    │ key == Escape or Q?           │──Yes──► Return GamePhase.Exploration
    └───────────────────────────────┘
                │ No
                ▼
    ┌───────────────────────────────┐
    │ key == UpArrow or W?          │──Yes──► Decrement SelectedIndex
    └───────────────────────────────┘         Return GamePhase.SpecializationMenu
                │ No
                ▼
    ┌───────────────────────────────┐
    │ key == DownArrow or S?        │──Yes──► Increment SelectedIndex
    └───────────────────────────────┘         Return GamePhase.SpecializationMenu
                │ No
                ▼
    ┌───────────────────────────────┐
    │ key == LeftArrow or A?        │──Yes──► Switch to Spec List View
    └───────────────────────────────┘         (ViewMode = SpecList)
                │ No                          Return GamePhase.SpecializationMenu
                ▼
    ┌───────────────────────────────┐
    │ key == RightArrow or D?       │──Yes──► Switch to Tree Detail View
    └───────────────────────────────┘         (ViewMode = TreeDetail)
                │ No                          Return GamePhase.SpecializationMenu
                ▼
    ┌───────────────────────────────┐
    │ key == Enter or Spacebar?     │──Yes──► Attempt Unlock Flow
    └───────────────────────────────┘              │
                │ No                               ▼
                ▼                         ┌─────────────────┐
    ┌───────────────────────────────┐     │ ViewMode ==     │
    │ Return GamePhase.             │     │ SpecList?       │
    │ SpecializationMenu            │     └─────────────────┘
    └───────────────────────────────┘             │
                                          ┌───────┴───────┐
                                         Yes              No
                                          │                │
                                          ▼                ▼
                                  ┌─────────────┐  ┌─────────────────┐
                                  │ Unlock      │  │ Unlock Node     │
                                  │ Specializ-  │  │ via Service     │
                                  │ ation       │  └─────────────────┘
                                  └─────────────┘
```

### 1.3 ViewModel Building Flow

```
BuildSpecializationViewModel()
                │
                ▼
    ┌───────────────────────────────┐
    │ Get current Character         │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Fetch available specs for     │
    │ character's archetype         │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ For each specialization:      │
    │ - Determine unlock status     │
    │ - Build SpecializationItem    │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ If spec selected:             │
    │ - Fetch nodes for tree        │
    │ - Determine node statuses     │
    │ - Build NodeItem list         │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Build SpecializationViewModel │
    │ with all computed data        │
    └───────────────────────────────┘
```

### 1.4 Node Status Determination Flow

```
DetermineNodeStatus(node, character)
                │
                ▼
    ┌───────────────────────────────┐
    │ Character.HasNode(nodeId)?    │──Yes──► Return NodeStatus.Unlocked
    └───────────────────────────────┘
                │ No
                ▼
    ┌───────────────────────────────┐
    │ ValidatePrerequisites(node)?  │──No──► Return NodeStatus.Locked
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ Character.PP >= node.CostPP?  │──No──► Return NodeStatus.InsufficientPP
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ Return NodeStatus.Available   │
    └───────────────────────────────┘
```

---

## 2. Deliverable Checklist

### New Files to Create

| Layer | File Path | Purpose |
|-------|-----------|---------|
| Core | `RuneAndRust.Core/ViewModels/SpecializationViewModel.cs` | Immutable view state record |
| Core | `RuneAndRust.Core/Enums/SpecializationViewMode.cs` | View mode enum (SpecList/TreeDetail) |
| Core | `RuneAndRust.Core/Enums/NodeStatus.cs` | Node display status enum |
| Core | `RuneAndRust.Core/Interfaces/ISpecializationScreenRenderer.cs` | Renderer interface |
| Terminal | `RuneAndRust.Terminal/Rendering/SpecializationScreenRenderer.cs` | Spectre.Console renderer |
| Terminal | `RuneAndRust.Terminal/Controllers/SpecializationController.cs` | Input handler |
| Tests | `RuneAndRust.Tests/Terminal/SpecializationControllerTests.cs` | Controller tests |
| Tests | `RuneAndRust.Tests/Terminal/SpecializationScreenRendererTests.cs` | Renderer tests |
| Tests | `RuneAndRust.Tests/Core/SpecializationViewModelTests.cs` | ViewModel tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/GamePhase.cs` | Add `SpecializationMenu` value |
| `RuneAndRust.Engine/Services/GameService.cs` | Add phase routing, input handling, ViewModel building |
| `RuneAndRust.Terminal/Program.cs` | Register renderer and controller |

---

## 3. ViewModel Definition

### 3.1 SpecializationViewModel

**File:** `RuneAndRust.Core/ViewModels/SpecializationViewModel.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.ViewModels;

/// <summary>
/// Immutable view state for the Specialization UI screen.
/// Contains all data needed to render the "Tree of Runes" interface.
/// </summary>
/// <remarks>See: v0.4.1c (The Tree of Runes) for implementation.</remarks>
public record SpecializationViewModel(
    string CharacterName,
    int AvailableProgressionPoints,
    SpecializationViewMode ViewMode,
    IReadOnlyList<SpecializationListItem> Specializations,
    int SelectedSpecIndex,
    SpecializationTreeView? CurrentTree,
    int SelectedNodeIndex,
    string? StatusMessage = null);

/// <summary>
/// Display item for the specialization list (left panel).
/// </summary>
public record SpecializationListItem(
    Guid Id,
    string Name,
    string Description,
    bool IsUnlocked,
    bool CanUnlock,
    int UnlockCost,
    int NodesUnlocked,
    int TotalNodes);

/// <summary>
/// Display model for a specialization tree (right panel).
/// </summary>
public record SpecializationTreeView(
    Guid SpecializationId,
    string SpecializationName,
    IReadOnlyList<NodeDisplayItem> Nodes);

/// <summary>
/// Display item for a single node in the tree.
/// </summary>
public record NodeDisplayItem(
    Guid NodeId,
    string NodeName,
    string AbilityName,
    string AbilityDescription,
    int Tier,
    int CostPP,
    NodeStatus Status,
    int PositionX,
    int PositionY,
    bool IsCapstone,
    IReadOnlyList<Guid> ParentNodeIds);
```

### 3.2 SpecializationViewMode Enum

**File:** `RuneAndRust.Core/Enums/SpecializationViewMode.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Determines which panel has focus in the Specialization UI.
/// </summary>
/// <remarks>See: v0.4.1c (The Tree of Runes) for implementation.</remarks>
public enum SpecializationViewMode
{
    /// <summary>
    /// Left panel focused: browsing available specializations.
    /// </summary>
    SpecList,

    /// <summary>
    /// Right panel focused: navigating nodes within selected tree.
    /// </summary>
    TreeDetail
}
```

### 3.3 NodeStatus Enum

**File:** `RuneAndRust.Core/Enums/NodeStatus.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Display status for a specialization node.
/// </summary>
/// <remarks>See: v0.4.1c (The Tree of Runes) for implementation.</remarks>
public enum NodeStatus
{
    /// <summary>
    /// Prerequisites not met - cannot unlock.
    /// </summary>
    Locked,

    /// <summary>
    /// Prerequisites met but insufficient PP.
    /// </summary>
    InsufficientPP,

    /// <summary>
    /// Can be unlocked now (prerequisites met, PP available).
    /// </summary>
    Available,

    /// <summary>
    /// Already unlocked by character.
    /// </summary>
    Unlocked
}
```

---

## 4. Renderer Interface & Implementation

### 4.1 ISpecializationScreenRenderer Interface

**File:** `RuneAndRust.Core/Interfaces/ISpecializationScreenRenderer.cs`

```csharp
using RuneAndRust.Core.ViewModels;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Renders the Specialization UI ("Tree of Runes") to the terminal.
/// </summary>
/// <remarks>See: v0.4.1c (The Tree of Runes) for implementation.</remarks>
public interface ISpecializationScreenRenderer
{
    /// <summary>
    /// Renders the specialization view to the console.
    /// </summary>
    /// <param name="viewModel">The current view state.</param>
    void Render(SpecializationViewModel viewModel);
}
```

### 4.2 SpecializationScreenRenderer Implementation

**File:** `RuneAndRust.Terminal/Rendering/SpecializationScreenRenderer.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.ViewModels;
using Spectre.Console;

namespace RuneAndRust.Terminal.Rendering;

/// <summary>
/// Spectre.Console implementation of the Specialization screen renderer.
/// Displays a two-panel layout: specialization list (left) and tree detail (right).
/// </summary>
/// <remarks>See: v0.4.1c (The Tree of Runes) for implementation.</remarks>
public class SpecializationScreenRenderer : ISpecializationScreenRenderer
{
    private readonly ILogger<SpecializationScreenRenderer> _logger;
    private readonly IThemeService? _themeService;

    public SpecializationScreenRenderer(
        ILogger<SpecializationScreenRenderer> logger,
        IThemeService? themeService = null)
    {
        _logger = logger;
        _themeService = themeService;
    }

    public void Render(SpecializationViewModel viewModel)
    {
        _logger.LogDebug("[SpecUI] Rendering SpecializationScreen: ViewMode={Mode}, SelectedSpec={SpecIdx}, SelectedNode={NodeIdx}",
            viewModel.ViewMode, viewModel.SelectedSpecIndex, viewModel.SelectedNodeIndex);

        AnsiConsole.Clear();

        // Header
        RenderHeader(viewModel);

        // Two-column layout
        var layout = new Layout("Root")
            .SplitColumns(
                new Layout("SpecList").Size(30),
                new Layout("TreeDetail"));

        layout["SpecList"].Update(BuildSpecListPanel(viewModel));
        layout["TreeDetail"].Update(BuildTreeDetailPanel(viewModel));

        AnsiConsole.Write(layout);

        // Status message (if any)
        if (!string.IsNullOrEmpty(viewModel.StatusMessage))
        {
            AnsiConsole.MarkupLine($"\n[yellow]{viewModel.StatusMessage}[/]");
        }

        // Footer with controls
        RenderFooter(viewModel);

        _logger.LogTrace("[SpecUI] Render complete");
    }

    private void RenderHeader(SpecializationViewModel viewModel)
    {
        var headerPanel = new Panel(
            new Markup($"[bold cyan]THE TREE OF RUNES[/]\n" +
                       $"[dim]{viewModel.CharacterName}[/] | " +
                       $"[green]PP: {viewModel.AvailableProgressionPoints}[/]"))
            .Border(BoxBorder.Double)
            .BorderColor(Color.Cyan1);

        AnsiConsole.Write(headerPanel);
        AnsiConsole.WriteLine();
    }

    private Panel BuildSpecListPanel(SpecializationViewModel viewModel)
    {
        var table = new Table()
            .Border(TableBorder.None)
            .HideHeaders()
            .AddColumn("Spec");

        for (int i = 0; i < viewModel.Specializations.Count; i++)
        {
            var spec = viewModel.Specializations[i];
            var isSelected = i == viewModel.SelectedSpecIndex;
            var isFocused = viewModel.ViewMode == SpecializationViewMode.SpecList;

            var prefix = isSelected ? (isFocused ? "► " : "  ") : "  ";
            var statusIcon = spec.IsUnlocked ? "[green]✓[/]" : (spec.CanUnlock ? "[yellow]○[/]" : "[red]✗[/]");
            var progress = $"[dim]{spec.NodesUnlocked}/{spec.TotalNodes}[/]";

            var style = isSelected && isFocused ? "bold white on blue" : (isSelected ? "bold" : "");
            var line = $"{prefix}{statusIcon} {spec.Name} {progress}";

            table.AddRow(new Markup($"[{style}]{line}[/]"));
        }

        var borderColor = viewModel.ViewMode == SpecializationViewMode.SpecList ? Color.Yellow : Color.Grey;
        return new Panel(table)
            .Header("[bold]Specializations[/]")
            .Border(BoxBorder.Rounded)
            .BorderColor(borderColor);
    }

    private Panel BuildTreeDetailPanel(SpecializationViewModel viewModel)
    {
        if (viewModel.CurrentTree == null)
        {
            return new Panel(new Markup("[dim]Select a specialization to view its tree[/]"))
                .Header("[bold]Tree[/]")
                .Border(BoxBorder.Rounded)
                .BorderColor(Color.Grey);
        }

        var tree = viewModel.CurrentTree;
        var isFocused = viewModel.ViewMode == SpecializationViewMode.TreeDetail;

        // Group nodes by tier for visual layout
        var tiers = tree.Nodes
            .GroupBy(n => n.Tier)
            .OrderBy(g => g.Key)
            .ToList();

        var grid = new Grid().AddColumn().AddColumn().AddColumn();

        foreach (var tierGroup in tiers)
        {
            var tierNodes = tierGroup.OrderBy(n => n.PositionX).ToList();
            var tierLabel = tierGroup.Key == 4 ? "[bold magenta]CAPSTONE[/]" : $"[dim]Tier {tierGroup.Key}[/]";

            grid.AddRow(new Markup(tierLabel), new Text(""), new Text(""));

            foreach (var node in tierNodes)
            {
                var nodeIndex = tree.Nodes.ToList().IndexOf(node);
                var isSelected = nodeIndex == viewModel.SelectedNodeIndex;

                var statusColor = node.Status switch
                {
                    NodeStatus.Unlocked => "green",
                    NodeStatus.Available => "yellow",
                    NodeStatus.InsufficientPP => "darkorange",
                    NodeStatus.Locked => "red",
                    _ => "grey"
                };

                var statusIcon = node.Status switch
                {
                    NodeStatus.Unlocked => "★",
                    NodeStatus.Available => "○",
                    NodeStatus.InsufficientPP => "◐",
                    NodeStatus.Locked => "✗",
                    _ => "?"
                };

                var prefix = isSelected && isFocused ? "►" : " ";
                var costDisplay = node.Status == NodeStatus.Unlocked ? "" : $" [{node.CostPP} PP]";
                var style = isSelected && isFocused ? $"bold {statusColor} on grey23" : statusColor;

                var nodeLine = $"{prefix} [{style}]{statusIcon} {node.NodeName}{costDisplay}[/]";
                var abilityLine = isSelected ? $"   [dim]{node.AbilityDescription}[/]" : "";

                grid.AddRow(new Markup(nodeLine), new Text(""), new Text(""));
                if (!string.IsNullOrEmpty(abilityLine))
                {
                    grid.AddRow(new Markup(abilityLine), new Text(""), new Text(""));
                }
            }

            grid.AddEmptyRow();
        }

        var borderColor = isFocused ? Color.Yellow : Color.Grey;
        return new Panel(grid)
            .Header($"[bold]{tree.SpecializationName}[/]")
            .Border(BoxBorder.Rounded)
            .BorderColor(borderColor);
    }

    private void RenderFooter(SpecializationViewModel viewModel)
    {
        AnsiConsole.WriteLine();
        var controls = viewModel.ViewMode switch
        {
            SpecializationViewMode.SpecList =>
                "[dim]↑↓[/] Navigate | [dim]→[/] View Tree | [dim]Enter[/] Unlock Spec | [dim]Esc[/] Exit",
            SpecializationViewMode.TreeDetail =>
                "[dim]↑↓[/] Navigate | [dim]←[/] Back to List | [dim]Enter[/] Unlock Node | [dim]Esc[/] Exit",
            _ => "[dim]Esc[/] Exit"
        };
        AnsiConsole.MarkupLine(controls);
    }
}
```

---

## 5. Controller Implementation

**File:** `RuneAndRust.Terminal/Controllers/SpecializationController.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;

namespace RuneAndRust.Terminal.Controllers;

/// <summary>
/// Handles input for the Specialization UI ("Tree of Runes").
/// Manages navigation between specializations and nodes, and triggers unlock actions.
/// </summary>
/// <remarks>See: v0.4.1c (The Tree of Runes) for implementation.</remarks>
public class SpecializationController
{
    private readonly ISpecializationService _specService;
    private readonly ILogger<SpecializationController> _logger;

    public SpecializationViewMode ViewMode { get; private set; } = SpecializationViewMode.SpecList;
    public int SelectedSpecIndex { get; private set; } = 0;
    public int SelectedNodeIndex { get; private set; } = 0;
    public string? LastStatusMessage { get; private set; }

    private int _specCount = 0;
    private int _nodeCount = 0;

    public SpecializationController(
        ISpecializationService specService,
        ILogger<SpecializationController> logger)
    {
        _specService = specService;
        _logger = logger;
    }

    /// <summary>
    /// Updates internal counts for navigation bounds.
    /// Call this before HandleInput when data changes.
    /// </summary>
    public void UpdateCounts(int specCount, int nodeCount)
    {
        _specCount = specCount;
        _nodeCount = nodeCount;
    }

    /// <summary>
    /// Processes a key input and returns the resulting game phase.
    /// </summary>
    public async Task<GamePhase> HandleInputAsync(ConsoleKey key, Character character,
        IReadOnlyList<Guid> specIds, IReadOnlyList<Guid> nodeIds)
    {
        _logger.LogTrace("[SpecController] HandleInputAsync: Key={Key}, ViewMode={Mode}", key, ViewMode);
        LastStatusMessage = null;

        switch (key)
        {
            case ConsoleKey.Escape:
            case ConsoleKey.Q:
                _logger.LogDebug("[SpecController] Exit requested");
                return GamePhase.Exploration;

            case ConsoleKey.UpArrow:
            case ConsoleKey.W:
                NavigateUp();
                return GamePhase.SpecializationMenu;

            case ConsoleKey.DownArrow:
            case ConsoleKey.S:
                NavigateDown();
                return GamePhase.SpecializationMenu;

            case ConsoleKey.LeftArrow:
            case ConsoleKey.A:
                SwitchToSpecList();
                return GamePhase.SpecializationMenu;

            case ConsoleKey.RightArrow:
            case ConsoleKey.D:
                SwitchToTreeDetail();
                return GamePhase.SpecializationMenu;

            case ConsoleKey.Enter:
            case ConsoleKey.Spacebar:
                await HandleUnlockAsync(character, specIds, nodeIds);
                return GamePhase.SpecializationMenu;

            default:
                return GamePhase.SpecializationMenu;
        }
    }

    private void NavigateUp()
    {
        if (ViewMode == SpecializationViewMode.SpecList)
        {
            if (SelectedSpecIndex > 0)
            {
                SelectedSpecIndex--;
                SelectedNodeIndex = 0; // Reset node selection when changing spec
                _logger.LogDebug("[SpecController] SpecList navigate up: Index={Idx}", SelectedSpecIndex);
            }
        }
        else
        {
            if (SelectedNodeIndex > 0)
            {
                SelectedNodeIndex--;
                _logger.LogDebug("[SpecController] TreeDetail navigate up: Index={Idx}", SelectedNodeIndex);
            }
        }
    }

    private void NavigateDown()
    {
        if (ViewMode == SpecializationViewMode.SpecList)
        {
            if (SelectedSpecIndex < _specCount - 1)
            {
                SelectedSpecIndex++;
                SelectedNodeIndex = 0;
                _logger.LogDebug("[SpecController] SpecList navigate down: Index={Idx}", SelectedSpecIndex);
            }
        }
        else
        {
            if (SelectedNodeIndex < _nodeCount - 1)
            {
                SelectedNodeIndex++;
                _logger.LogDebug("[SpecController] TreeDetail navigate down: Index={Idx}", SelectedNodeIndex);
            }
        }
    }

    private void SwitchToSpecList()
    {
        ViewMode = SpecializationViewMode.SpecList;
        _logger.LogDebug("[SpecController] Switched to SpecList view");
    }

    private void SwitchToTreeDetail()
    {
        ViewMode = SpecializationViewMode.TreeDetail;
        _logger.LogDebug("[SpecController] Switched to TreeDetail view");
    }

    private async Task HandleUnlockAsync(Character character,
        IReadOnlyList<Guid> specIds, IReadOnlyList<Guid> nodeIds)
    {
        if (ViewMode == SpecializationViewMode.SpecList)
        {
            // Unlock specialization
            if (SelectedSpecIndex < specIds.Count)
            {
                var specId = specIds[SelectedSpecIndex];
                _logger.LogDebug("[SpecController] Attempting to unlock specialization: {SpecId}", specId);

                var result = await _specService.UnlockSpecializationAsync(character, specId);

                if (result.Success)
                {
                    LastStatusMessage = $"Unlocked {result.SpecializationName}! (-{result.PpSpent} PP)";
                    _logger.LogInformation("[SpecController] Specialization unlocked: {Name}", result.SpecializationName);
                }
                else
                {
                    LastStatusMessage = result.Message;
                    _logger.LogWarning("[SpecController] Unlock failed: {Reason}", result.Message);
                }
            }
        }
        else
        {
            // Unlock node
            if (SelectedNodeIndex < nodeIds.Count)
            {
                var nodeId = nodeIds[SelectedNodeIndex];
                _logger.LogDebug("[SpecController] Attempting to unlock node: {NodeId}", nodeId);

                var result = await _specService.UnlockNodeAsync(character, nodeId);

                if (result.Success)
                {
                    LastStatusMessage = $"Unlocked {result.NodeName}! (-{result.PpSpent} PP)";
                    _logger.LogInformation("[SpecController] Node unlocked: {Name} (Tier {Tier})",
                        result.NodeName, result.Tier);
                }
                else
                {
                    LastStatusMessage = result.Message;
                    _logger.LogWarning("[SpecController] Node unlock failed: {Reason}", result.Message);
                }
            }
        }
    }

    /// <summary>
    /// Resets controller state to initial values.
    /// </summary>
    public void Reset()
    {
        ViewMode = SpecializationViewMode.SpecList;
        SelectedSpecIndex = 0;
        SelectedNodeIndex = 0;
        LastStatusMessage = null;
        _logger.LogDebug("[SpecController] State reset");
    }
}
```

---

## 6. GamePhase Enum Extension

**File:** `RuneAndRust.Core/Enums/GamePhase.cs`

Add new enum value:

```csharp
/// <summary>
/// The specialization tree menu ("The Tree of Runes").
/// Allows players to view specialization paths and unlock ability nodes.
/// </summary>
/// <remarks>See: v0.4.1c (The Tree of Runes) for implementation.</remarks>
SpecializationMenu = 6  // or next available number after existing values
```

---

## 7. GameService Integration

### 7.1 New Fields

```csharp
// Specialization UI (v0.4.1c)
private readonly ISpecializationScreenRenderer? _specRenderer;
private readonly ISpecializationService? _specService;
private readonly SpecializationController? _specController;
```

### 7.2 Constructor Injection

Add parameters:
```csharp
ISpecializationScreenRenderer? specRenderer = null,
ISpecializationService? specService = null,
SpecializationController? specController = null
```

### 7.3 RenderCurrentPhaseAsync Addition

```csharp
else if (_state.Phase == GamePhase.SpecializationMenu && _specRenderer != null)
{
    var viewModel = await BuildSpecializationViewModelAsync();
    if (viewModel != null)
    {
        _specRenderer.Render(viewModel);
    }
}
```

### 7.4 BuildSpecializationViewModelAsync Method

```csharp
private async Task<SpecializationViewModel?> BuildSpecializationViewModelAsync()
{
    if (_state.CurrentCharacter == null || _specService == null || _specController == null)
        return null;

    var character = _state.CurrentCharacter;

    // Get available specializations
    var specs = await _specService.GetAvailableSpecializationsAsync(character);
    var specList = new List<SpecializationListItem>();

    foreach (var spec in specs)
    {
        var isUnlocked = character.UnlockedSpecializationIds.Contains(spec.Id);
        var canUnlock = !isUnlocked && await _specService.CanUnlockSpecializationAsync(character, spec.Id);
        var unlockedNodes = spec.Nodes.Count(n => character.HasNode(n.Id));

        specList.Add(new SpecializationListItem(
            spec.Id,
            spec.Name,
            spec.Description,
            isUnlocked,
            canUnlock,
            10, // Unlock cost constant
            unlockedNodes,
            spec.Nodes.Count));
    }

    // Build tree view for selected spec
    SpecializationTreeView? treeView = null;
    var nodeIds = new List<Guid>();

    if (_specController.SelectedSpecIndex < specList.Count)
    {
        var selectedSpec = specs.ElementAt(_specController.SelectedSpecIndex);
        var nodes = await _specService.GetNodesWithStatusAsync(character, selectedSpec.Id);
        var nodeItems = new List<NodeDisplayItem>();

        foreach (var node in nodes)
        {
            var status = await DetermineNodeStatusAsync(node, character);
            nodeItems.Add(new NodeDisplayItem(
                node.Id,
                node.Name,
                node.Ability?.Name ?? "Unknown",
                node.Ability?.Description ?? "",
                node.Tier,
                node.CostPP,
                status,
                node.PositionX,
                node.PositionY,
                node.IsCapstone,
                node.ParentNodeIds.ToList()));
            nodeIds.Add(node.Id);
        }

        treeView = new SpecializationTreeView(selectedSpec.Id, selectedSpec.Name, nodeItems);
    }

    // Update controller bounds
    _specController.UpdateCounts(specList.Count, nodeIds.Count);

    return new SpecializationViewModel(
        character.Name,
        character.ProgressionPoints,
        _specController.ViewMode,
        specList,
        _specController.SelectedSpecIndex,
        treeView,
        _specController.SelectedNodeIndex,
        _specController.LastStatusMessage);
}

private async Task<NodeStatus> DetermineNodeStatusAsync(SpecializationNode node, Character character)
{
    if (character.HasNode(node.Id))
        return NodeStatus.Unlocked;

    var (prereqsMet, _) = await _specService!.ValidatePrerequisitesAsync(character, node);
    if (!prereqsMet)
        return NodeStatus.Locked;

    if (character.ProgressionPoints < node.CostPP)
        return NodeStatus.InsufficientPP;

    return NodeStatus.Available;
}
```

### 7.5 Input Handling Integration

In the main game loop input section:

```csharp
if (_state.Phase == GamePhase.SpecializationMenu && _specController != null && _inputService != null)
{
    var inputEvent = _inputService.ReadNextFiltered();
    if (inputEvent.HasValue)
    {
        var key = inputEvent.Value.Key;
        var specs = await _specService!.GetAvailableSpecializationsAsync(_state.CurrentCharacter!);
        var specIds = specs.Select(s => s.Id).ToList();
        var nodeIds = new List<Guid>();

        if (_specController.SelectedSpecIndex < specIds.Count)
        {
            var selectedSpec = specs.ElementAt(_specController.SelectedSpecIndex);
            var nodes = await _specService.GetNodesWithStatusAsync(_state.CurrentCharacter!, selectedSpec.Id);
            nodeIds = nodes.Select(n => n.Id).ToList();
        }

        _state.Phase = await _specController.HandleInputAsync(key, _state.CurrentCharacter!, specIds, nodeIds);
        _renderRequired = true;
    }
}
```

---

## 8. Logging Matrix

### SpecializationController Logging

| Event | Level | Template |
|-------|-------|----------|
| HandleInput entry | Trace | `[SpecController] HandleInputAsync: Key={Key}, ViewMode={Mode}` |
| Exit requested | Debug | `[SpecController] Exit requested` |
| SpecList navigate up | Debug | `[SpecController] SpecList navigate up: Index={Idx}` |
| SpecList navigate down | Debug | `[SpecController] SpecList navigate down: Index={Idx}` |
| TreeDetail navigate up | Debug | `[SpecController] TreeDetail navigate up: Index={Idx}` |
| TreeDetail navigate down | Debug | `[SpecController] TreeDetail navigate down: Index={Idx}` |
| Switch to SpecList | Debug | `[SpecController] Switched to SpecList view` |
| Switch to TreeDetail | Debug | `[SpecController] Switched to TreeDetail view` |
| Unlock spec attempt | Debug | `[SpecController] Attempting to unlock specialization: {SpecId}` |
| Unlock spec success | Info | `[SpecController] Specialization unlocked: {Name}` |
| Unlock spec failed | Warning | `[SpecController] Unlock failed: {Reason}` |
| Unlock node attempt | Debug | `[SpecController] Attempting to unlock node: {NodeId}` |
| Unlock node success | Info | `[SpecController] Node unlocked: {Name} (Tier {Tier})` |
| Unlock node failed | Warning | `[SpecController] Node unlock failed: {Reason}` |
| State reset | Debug | `[SpecController] State reset` |

### SpecializationScreenRenderer Logging

| Event | Level | Template |
|-------|-------|----------|
| Render entry | Debug | `[SpecUI] Rendering SpecializationScreen: ViewMode={Mode}, SelectedSpec={SpecIdx}, SelectedNode={NodeIdx}` |
| Render complete | Trace | `[SpecUI] Render complete` |

---

## 9. Test Coverage Plan

### Test Inventory (52 tests)

#### SpecializationControllerTests (24 tests)

| Test Name | Description |
|-----------|-------------|
| `HandleInputAsync_Escape_ReturnsExploration` | Exit via Escape |
| `HandleInputAsync_Q_ReturnsExploration` | Exit via Q key |
| `HandleInputAsync_UpArrow_DecrementsSpecIndex_WhenSpecList` | Navigate up in spec list |
| `HandleInputAsync_DownArrow_IncrementsSpecIndex_WhenSpecList` | Navigate down in spec list |
| `HandleInputAsync_UpArrow_DecrementsNodeIndex_WhenTreeDetail` | Navigate up in tree |
| `HandleInputAsync_DownArrow_IncrementsNodeIndex_WhenTreeDetail` | Navigate down in tree |
| `HandleInputAsync_UpArrow_StopsAtZero` | Bounds check at top |
| `HandleInputAsync_DownArrow_StopsAtMax` | Bounds check at bottom |
| `HandleInputAsync_LeftArrow_SwitchesToSpecList` | View mode switch |
| `HandleInputAsync_RightArrow_SwitchesToTreeDetail` | View mode switch |
| `HandleInputAsync_Enter_UnlocksSpec_WhenSpecList` | Spec unlock trigger |
| `HandleInputAsync_Enter_UnlocksNode_WhenTreeDetail` | Node unlock trigger |
| `HandleInputAsync_Enter_SetsSuccessMessage_OnUnlock` | Status message on success |
| `HandleInputAsync_Enter_SetsFailureMessage_OnFailure` | Status message on failure |
| `HandleInputAsync_UnknownKey_ReturnsSpecializationMenu` | Unknown key handling |
| `HandleInputAsync_W_BehavesLikeUpArrow` | WASD support |
| `HandleInputAsync_S_BehavesLikeDownArrow` | WASD support |
| `HandleInputAsync_A_BehavesLikeLeftArrow` | WASD support |
| `HandleInputAsync_D_BehavesLikeRightArrow` | WASD support |
| `UpdateCounts_SetsNavigationBounds` | Count update |
| `Reset_ClearsAllState` | State reset |
| `NavigateDown_ResetsNodeIndex_WhenChangingSpec` | Cross-navigation reset |
| `HandleInputAsync_Spacebar_BehavesLikeEnter` | Spacebar unlock |
| `HandleInputAsync_CallsService_WithCorrectIds` | Service integration |

#### SpecializationScreenRendererTests (16 tests)

| Test Name | Description |
|-----------|-------------|
| `Render_DoesNotThrow_WithValidViewModel` | Basic render |
| `Render_DisplaysCharacterName` | Header content |
| `Render_DisplaysProgressionPoints` | PP display |
| `Render_ShowsSpecializationList` | Left panel |
| `Render_ShowsTreeDetail_WhenSpecSelected` | Right panel |
| `Render_HighlightsSelectedSpec` | Selection indicator |
| `Render_HighlightsSelectedNode` | Selection indicator |
| `Render_ShowsUnlockedStatus_Green` | Status color |
| `Render_ShowsAvailableStatus_Yellow` | Status color |
| `Render_ShowsLockedStatus_Red` | Status color |
| `Render_ShowsInsufficientPPStatus_Orange` | Status color |
| `Render_DisplaysNodeCost` | PP cost display |
| `Render_HidesCost_ForUnlockedNodes` | Cost hidden |
| `Render_ShowsCapstoneLabel` | Tier 4 label |
| `Render_DisplaysStatusMessage` | Footer message |
| `Render_ShowsContextualControls` | Control hints |

#### SpecializationViewModelTests (12 tests)

| Test Name | Description |
|-----------|-------------|
| `SpecializationListItem_ContainsAllProperties` | Record construction |
| `NodeDisplayItem_ContainsAllProperties` | Record construction |
| `SpecializationTreeView_ContainsAllProperties` | Record construction |
| `SpecializationViewModel_IsImmutable` | Immutability check |
| `SpecializationListItem_ProgressDisplay_FormatsCorrectly` | Progress format |
| `NodeDisplayItem_IsCapstone_IdentifiesTier4` | Capstone detection |
| `NodeStatus_HasCorrectValues` | Enum values |
| `SpecializationViewMode_HasCorrectValues` | Enum values |
| `ViewModel_DefaultStatusMessage_IsNull` | Default value |
| `ViewModel_WithStatusMessage_PreservesMessage` | Message preservation |
| `TreeView_Null_WhenNoSpecSelected` | Null handling |
| `Specializations_EmptyList_Allowed` | Empty state |

---

## 10. DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

Add after the v0.4.1b registration:

```csharp
// Specialization UI (v0.4.1c - The Tree of Runes)
services.AddSingleton<ISpecializationScreenRenderer, SpecializationScreenRenderer>();
services.AddScoped<SpecializationController>();
```

---

## 11. Changelog Template

```markdown
# Changelog: v0.4.1c - The Tree of Runes (Specialization UI)

**Release Date:** [DATE]
**Total Tests:** [N] (52 new tests added)

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.1c](#directory-structure-after-v041c)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

Version 0.4.1c implements the **Specialization UI Layer** ("The Tree of Runes"),
providing players with a terminal-based interface to view, navigate, and unlock
specialization trees and ability nodes...

[Continue with CHANGELOG_GENERATION_RULES.md format]
```

---

## 12. Critical Files

### Files to Create (Priority Order)

| Priority | File | Purpose |
|----------|------|---------|
| 1 | `RuneAndRust.Core/Enums/NodeStatus.cs` | Node display status enum |
| 2 | `RuneAndRust.Core/Enums/SpecializationViewMode.cs` | View mode enum |
| 3 | `RuneAndRust.Core/ViewModels/SpecializationViewModel.cs` | ViewModel records |
| 4 | `RuneAndRust.Core/Interfaces/ISpecializationScreenRenderer.cs` | Renderer interface |
| 5 | `RuneAndRust.Terminal/Rendering/SpecializationScreenRenderer.cs` | Renderer implementation |
| 6 | `RuneAndRust.Terminal/Controllers/SpecializationController.cs` | Input controller |
| 7 | `RuneAndRust.Tests/Core/SpecializationViewModelTests.cs` | ViewModel tests |
| 8 | `RuneAndRust.Tests/Terminal/SpecializationControllerTests.cs` | Controller tests |
| 9 | `RuneAndRust.Tests/Terminal/SpecializationScreenRendererTests.cs` | Renderer tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/GamePhase.cs` | Add SpecializationMenu value |
| `RuneAndRust.Engine/Services/GameService.cs` | Add phase routing, input handling, ViewModel building |
| `RuneAndRust.Terminal/Program.cs` | Register renderer and controller |

### Reference Files (Read Only)

| File | Purpose |
|------|---------|
| `RuneAndRust.Terminal/Controllers/SagaController.cs` | Pattern reference for modal input |
| `RuneAndRust.Core/ViewModels/SagaViewModel.cs` | Pattern reference for ViewModel |
| `RuneAndRust.Terminal/Rendering/SagaScreenRenderer.cs` | Pattern reference for rendering |
| `RuneAndRust.Engine/Services/GameService.cs` | Integration point reference |

---

## 13. Implementation Order

1. **Create Enums** (NodeStatus, SpecializationViewMode)
2. **Create ViewModel Records** (SpecializationViewModel and nested types)
3. **Extend GamePhase Enum** (add SpecializationMenu)
4. **Create ISpecializationScreenRenderer Interface**
5. **Create SpecializationScreenRenderer Implementation**
6. **Create SpecializationController**
7. **Integrate into GameService** (fields, constructor, render, input)
8. **Register in Program.cs DI**
9. **Write Unit Tests** (52 tests)
10. **Run Build and Tests**
11. **Generate Changelog** following CHANGELOG_GENERATION_RULES.md

---

## Design Decisions

### Why Modal UI Pattern (Like Saga)?

**Problem:** Specialization trees require focused navigation without text command interference.

**Decision:** Use key-based modal input (arrow keys, Enter, Escape) rather than text commands.

**Rationale:**
- Proven pattern in SagaController works well for menu-driven UIs
- Arrow key navigation feels natural for tree browsing
- Real-time visual feedback during navigation
- Consistent with existing Saga/Inventory patterns

### Why Two-Tier Navigation?

**Problem:** Multiple specializations with 8+ nodes each create information overload.

**Decision:** Split into left panel (spec list) and right panel (tree detail) with cross-navigation.

**Rationale:**
- Keeps each panel focused and readable
- Left/Right arrows switch context naturally
- Prevents overwhelming users on small terminal windows
- Follows Inventory screen pattern for two-column layouts

### Why Immutable ViewModel Records?

**Problem:** Rendering must be deterministic and testable.

**Decision:** Use C# records with immutable data for all display state.

**Rationale:**
- Guarantees rendering consistency (no mid-render mutations)
- Follows MVVM separation of concerns
- Simplifies testing (construct expected state, compare)
- Matches SagaViewModel pattern

### Why NodeStatus Enum Instead of Boolean Flags?

**Problem:** Nodes can be in multiple states beyond simple locked/unlocked.

**Decision:** Create NodeStatus enum with Locked, InsufficientPP, Available, Unlocked.

**Rationale:**
- Four distinct visual states require clear enum values
- Color mapping is cleaner with enum switch
- Extensible for future states (e.g., "Disabled", "Hidden")
- Better than multiple boolean combinations

---

## Dependencies

- **v0.4.1a** (Data Foundation): Entities, Repository, Seeding
- **v0.4.1b** (The Unlock): ISpecializationService, unlock/purchase logic

---

## Next Steps (v0.4.1d and beyond)

- **v0.4.1d**: Combat integration - using unlocked abilities in battle
- **v0.4.2**: Additional specializations for other archetypes
- **v0.4.3**: Visual tree connections (ASCII art for parent-child relationships)
