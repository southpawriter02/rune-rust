# v0.1.2 Dungeon Theming & Biomes - Scope Breakdown

**Version:** 0.1.2
**Theme:** Dungeon Theming & Biomes
**Prerequisites:** v0.1.1 Complete (Dynamic Room Generation)
**Total Estimated Tests:** ~100 new tests

---

## Executive Summary

The Dungeon Theming & Biomes version introduces environmental variety through themed dungeon zones. Each biome defines visual themes, ambient descriptors, gameplay modifiers, spawn pools, and hazards. This creates distinct exploration experiences as players descend through different dungeon regions.

Key focus areas:
- **Biome System**: Core biome entity with environmental definitions
- **Biome-Specific Content**: Monsters, hazards, and loot tailored to each biome
- **Transitional Zones**: Blended areas between biomes with gradual transitions
- **Biome Discovery**: Codex unlocks and lore tracking
- **Customization Support**: Data-driven biome definitions for modding

The work is divided into **four sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.1.2a | Biome System Core | BiomeDefinition entity, biome configuration, room biome assignment | ~25 |
| v0.1.2b | Biome Content Pools | Biome-specific monsters, items, and spawn tables | ~25 |
| v0.1.2c | Environmental Hazards | Biome hazards, damage modifiers, environmental effects | ~28 |
| v0.1.2d | Transitional Zones & Discovery | Transition blending, codex integration, biome progression | ~22 |

---

## Existing Infrastructure

### Already Implemented (from v0.1.1)

| Feature | Location | Notes |
|---------|----------|-------|
| RoomTemplate | `Domain/Entities/RoomTemplate.cs` | Slot-based room patterns |
| TemplateSlot | `Domain/ValueObjects/TemplateSlot.cs` | Variable content positions |
| SeededRandomService | `Application/Services/SeededRandomService.cs` | Reproducible generation |
| DifficultyRating | `Domain/ValueObjects/DifficultyRating.cs` | Position-based difficulty |
| ContentPlacementService | `Application/Services/ContentPlacementService.cs` | Dynamic spawning |
| EnvironmentContext | `Domain/ValueObjects/EnvironmentContext.cs` | Basic biome reference |
| DescriptorService | `Application/Services/DescriptorService.cs` | Weighted text generation |
| Room.Position3D | `Domain/Entities/Room.cs` | Z-axis depth support |
| MonsterDefinition | `Domain/Definitions/MonsterDefinition.cs` | Monster data configuration |
| DamageType | `Domain/Enums/DamageType.cs` | Physical, Fire, Ice, etc. |
| TierDefinition | `Domain/Definitions/TierDefinition.cs` | Monster tier multipliers |
| LootTable | `Domain/Definitions/LootTable.cs` | Loot drop configuration |

### Needs Implementation (v0.1.2)

| Feature | Phase | Notes |
|---------|-------|-------|
| BiomeDefinition | v0.1.2a | Core biome entity |
| BiomeDescriptors | v0.1.2a | Lighting, sounds, smells, textures |
| BiomeSpawnTable | v0.1.2b | Monster/item pools per biome |
| BiomeHazard | v0.1.2c | Environmental dangers |
| BiomeDamageModifier | v0.1.2c | Resistance/vulnerability per biome |
| BiomeTransition | v0.1.2d | Blending rules between biomes |
| BiomeProgress | v0.1.2d | Player discovery tracking |

---

## Feature Analysis & Categorization

### Core Biome Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| BiomeDefinition entity | High | EnvironmentContext | **v0.1.2a** |
| BiomeDescriptors value object | Medium | DescriptorService | **v0.1.2a** |
| Biome configuration (JSON) | Medium | IConfigurationProvider | **v0.1.2a** |
| Room.BiomeId property | Low | Room, BiomeDefinition | **v0.1.2a** |
| BiomeService for lookup | Medium | BiomeDefinition | **v0.1.2a** |
| Biome-aware descriptors | Medium | DescriptorService | **v0.1.2a** |

### Content Pool Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| BiomeSpawnTable entity | High | MonsterDefinition, ItemDefinition | **v0.1.2b** |
| Biome monster pools | Medium | BiomeSpawnTable | **v0.1.2b** |
| Biome item pools | Medium | BiomeSpawnTable | **v0.1.2b** |
| Biome loot modifiers | Medium | LootTable | **v0.1.2b** |
| ContentPlacementService biome filter | Medium | ContentPlacementService | **v0.1.2b** |
| Biome-specific crafting materials | Medium | ItemDefinition | **v0.1.2b** |

### Hazard Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| BiomeHazard entity | High | DamageType, StatusEffect | **v0.1.2c** |
| Hazard configuration | Medium | IConfigurationProvider | **v0.1.2c** |
| BiomeDamageModifier | Medium | DamageType | **v0.1.2c** |
| Environmental damage application | Medium | CombatService | **v0.1.2c** |
| Hazard slot in templates | Low | TemplateSlot | **v0.1.2c** |
| Biome-specific status effects | Medium | StatusEffectDefinition | **v0.1.2c** |

### Transition & Discovery Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| BiomeTransition rules | High | BiomeDefinition | **v0.1.2d** |
| Transitional zone generation | High | RoomGeneratorService | **v0.1.2d** |
| Descriptor blending | Medium | DescriptorService | **v0.1.2d** |
| Mixed encounter tables | Medium | BiomeSpawnTable | **v0.1.2d** |
| BiomeProgress tracking | Medium | Player | **v0.1.2d** |
| Codex biome entries | Medium | Codex integration | **v0.1.2d** |

---

## Phase Definitions

---

## v0.1.2a: Biome System Core

### Overview

Create the foundational biome system with BiomeDefinition entity, environmental descriptors, and room biome assignment. This establishes the data model and configuration for themed dungeon zones.

### Scope

**In Scope:**
- `BiomeDefinition` entity with full environmental configuration
- `BiomeDescriptors` value object for themed descriptions
- `BiomeService` for biome lookup and validation
- Biome configuration schema and JSON loading
- `Room.BiomeId` property for zone assignment
- Integration with `DescriptorService` for biome-aware text
- Default biome set: Catacombs, Sewers, Mines, Ancient Ruins, Frozen Depths, Volcanic Caverns

**Out of Scope:**
- Monster/item spawn pools (v0.1.2b)
- Environmental hazards (v0.1.2c)
- Biome transitions (v0.1.2d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `BiomeDefinition` |
| Value Objects | 2 | `BiomeDescriptors`, `BiomeRules` |
| Services | 1 | `BiomeService` |
| Configuration | 1 | `biomes.json` |
| Entity Updates | 1 | `Room.BiomeId` property |
| Service Updates | 1 | `DescriptorService` biome filtering |
| Unit Tests | ~25 | Biome definition, service, integration |

### BiomeDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a themed dungeon zone with environmental characteristics.
/// </summary>
public class BiomeDefinition
{
    /// <summary>
    /// Gets the unique identifier for this biome (e.g., "catacombs").
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name (e.g., "The Catacombs").
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the biome description for codex/discovery.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the environmental descriptors for this biome.
    /// </summary>
    public BiomeDescriptors Descriptors { get; init; } = default;

    /// <summary>
    /// Gets the minimum depth (Z-level) where this biome can appear.
    /// </summary>
    public int MinDepth { get; init; }

    /// <summary>
    /// Gets the maximum depth where this biome can appear (null = no limit).
    /// </summary>
    public int? MaxDepth { get; init; }

    /// <summary>
    /// Gets the probability weight for biome selection.
    /// </summary>
    public int Weight { get; init; } = 100;

    /// <summary>
    /// Gets biome-specific gameplay rules.
    /// </summary>
    public BiomeRules Rules { get; init; } = default;

    /// <summary>
    /// Gets tags for filtering and categorization.
    /// </summary>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the icon or symbol representing this biome.
    /// </summary>
    public string Icon { get; init; } = string.Empty;

    /// <summary>
    /// Gets the primary color theme for UI display.
    /// </summary>
    public string Color { get; init; } = "white";

    /// <summary>
    /// Creates a biome definition from configuration.
    /// </summary>
    public static BiomeDefinition Create(
        string id,
        string name,
        string description,
        BiomeDescriptors descriptors,
        int minDepth = 0,
        int? maxDepth = null,
        int weight = 100,
        BiomeRules? rules = null,
        IEnumerable<string>? tags = null,
        string icon = "",
        string color = "white")
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new BiomeDefinition
        {
            Id = id,
            Name = name,
            Description = description,
            Descriptors = descriptors,
            MinDepth = minDepth,
            MaxDepth = maxDepth,
            Weight = weight,
            Rules = rules ?? new BiomeRules(),
            Tags = tags?.ToList() ?? new List<string>(),
            Icon = icon,
            Color = color
        };
    }
}
```

### BiomeDescriptors Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Environmental descriptors that define a biome's atmosphere.
/// </summary>
public readonly record struct BiomeDescriptors
{
    /// <summary>
    /// Gets lighting descriptors (e.g., "dim", "flickering torchlight", "pitch black").
    /// </summary>
    public IReadOnlyList<string> Lighting { get; init; }

    /// <summary>
    /// Gets ambient sound descriptors (e.g., "dripping water", "distant screams").
    /// </summary>
    public IReadOnlyList<string> Sounds { get; init; }

    /// <summary>
    /// Gets smell descriptors (e.g., "damp earth", "sulfurous fumes").
    /// </summary>
    public IReadOnlyList<string> Smells { get; init; }

    /// <summary>
    /// Gets texture descriptors (e.g., "moss-covered", "crumbling stone").
    /// </summary>
    public IReadOnlyList<string> Textures { get; init; }

    /// <summary>
    /// Gets atmosphere descriptors (e.g., "oppressive", "eerily silent").
    /// </summary>
    public IReadOnlyList<string> Atmosphere { get; init; }

    /// <summary>
    /// Gets temperature descriptors (e.g., "freezing", "sweltering").
    /// </summary>
    public IReadOnlyList<string> Temperature { get; init; }

    /// <summary>
    /// Gets the descriptor pool prefix for this biome.
    /// </summary>
    public string DescriptorPoolPrefix { get; init; }

    /// <summary>
    /// Creates default biome descriptors.
    /// </summary>
    public static BiomeDescriptors Default => new()
    {
        Lighting = new[] { "dim", "shadowy" },
        Sounds = new[] { "silence" },
        Smells = new[] { "musty" },
        Textures = new[] { "stone" },
        Atmosphere = new[] { "still" },
        Temperature = new[] { "cool" },
        DescriptorPoolPrefix = "biome.default"
    };

    /// <summary>
    /// Creates catacombs biome descriptors.
    /// </summary>
    public static BiomeDescriptors Catacombs => new()
    {
        Lighting = new[] { "pale candlelight", "flickering shadows", "ghostly luminescence" },
        Sounds = new[] { "whispered prayers", "rattling bones", "distant chanting" },
        Smells = new[] { "incense and decay", "ancient dust", "dried flowers" },
        Textures = new[] { "carved crypts", "stacked bones", "crumbling epitaphs" },
        Atmosphere = new[] { "reverent silence", "oppressive grief", "lingering spirits" },
        Temperature = new[] { "deathly cold", "chill air" },
        DescriptorPoolPrefix = "biome.catacombs"
    };

    /// <summary>
    /// Creates volcanic caverns biome descriptors.
    /// </summary>
    public static BiomeDescriptors VolcanicCaverns => new()
    {
        Lighting = new[] { "molten glow", "ember light", "fire-lit passages" },
        Sounds = new[] { "bubbling lava", "cracking stone", "distant eruptions" },
        Smells = new[] { "sulfur", "ash", "burning rock" },
        Textures = new[] { "obsidian walls", "cooled magma", "volcanic glass" },
        Atmosphere = new[] { "oppressive heat", "dangerous instability", "primal fury" },
        Temperature = new[] { "sweltering", "scorching", "unbearably hot" },
        DescriptorPoolPrefix = "biome.volcanic"
    };
}
```

### BiomeRules Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Gameplay rules specific to a biome.
/// </summary>
public readonly record struct BiomeRules
{
    /// <summary>
    /// Gets the visibility range modifier (1.0 = normal).
    /// </summary>
    public float VisibilityModifier { get; init; }

    /// <summary>
    /// Gets the movement speed modifier (1.0 = normal).
    /// </summary>
    public float MovementModifier { get; init; }

    /// <summary>
    /// Gets whether light sources are required.
    /// </summary>
    public bool RequiresLight { get; init; }

    /// <summary>
    /// Gets the natural regeneration modifier (1.0 = normal).
    /// </summary>
    public float RegenerationModifier { get; init; }

    /// <summary>
    /// Gets whether stealth is easier or harder (1.0 = normal).
    /// </summary>
    public float StealthModifier { get; init; }

    /// <summary>
    /// Gets ambient damage per turn (0 = none).
    /// </summary>
    public int AmbientDamage { get; init; }

    /// <summary>
    /// Gets the damage type for ambient damage.
    /// </summary>
    public string? AmbientDamageType { get; init; }

    /// <summary>
    /// Gets status effects that may be applied each turn.
    /// </summary>
    public IReadOnlyList<string> AmbientStatusEffects { get; init; }

    /// <summary>
    /// Gets the chance for ambient status effects (0.0-1.0).
    /// </summary>
    public float AmbientEffectChance { get; init; }

    /// <summary>
    /// Creates default biome rules.
    /// </summary>
    public static BiomeRules Default => new()
    {
        VisibilityModifier = 1.0f,
        MovementModifier = 1.0f,
        RequiresLight = false,
        RegenerationModifier = 1.0f,
        StealthModifier = 1.0f,
        AmbientDamage = 0,
        AmbientDamageType = null,
        AmbientStatusEffects = Array.Empty<string>(),
        AmbientEffectChance = 0f
    };
}
```

### BiomeService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for biome lookup, selection, and management.
/// </summary>
public class BiomeService : IBiomeService
{
    private readonly IConfigurationProvider _config;
    private readonly SeededRandomService _random;
    private readonly ILogger<BiomeService> _logger;

    public BiomeService(
        IConfigurationProvider config,
        SeededRandomService random,
        ILogger<BiomeService> logger)
    {
        _config = config;
        _random = random;
        _logger = logger;
    }

    /// <summary>
    /// Gets a biome definition by ID.
    /// </summary>
    public BiomeDefinition? GetBiome(string biomeId)
    {
        return _config.GetBiomeDefinitions()
            .FirstOrDefault(b => b.Id == biomeId);
    }

    /// <summary>
    /// Gets all available biome definitions.
    /// </summary>
    public IReadOnlyList<BiomeDefinition> GetAllBiomes()
    {
        return _config.GetBiomeDefinitions();
    }

    /// <summary>
    /// Gets biomes valid for a given depth.
    /// </summary>
    public IReadOnlyList<BiomeDefinition> GetBiomesForDepth(int depth)
    {
        return _config.GetBiomeDefinitions()
            .Where(b => b.MinDepth <= depth)
            .Where(b => !b.MaxDepth.HasValue || b.MaxDepth.Value >= depth)
            .ToList();
    }

    /// <summary>
    /// Selects a biome for a position using seeded random.
    /// </summary>
    public BiomeDefinition SelectBiomeForPosition(Position3D position)
    {
        var validBiomes = GetBiomesForDepth(position.Z);

        if (!validBiomes.Any())
        {
            _logger.LogWarning("No valid biomes for depth {Depth}, using default", position.Z);
            return GetBiome("dungeon") ?? validBiomes.First();
        }

        var weightedBiomes = validBiomes.Select(b => (b, b.Weight));
        return _random.SelectWeighted(position, weightedBiomes, "biome_select");
    }

    /// <summary>
    /// Validates that a biome can appear at the specified depth.
    /// </summary>
    public bool IsValidForDepth(string biomeId, int depth)
    {
        var biome = GetBiome(biomeId);
        if (biome == null) return false;

        return biome.MinDepth <= depth &&
               (!biome.MaxDepth.HasValue || biome.MaxDepth.Value >= depth);
    }

    /// <summary>
    /// Gets random descriptors from a biome's pools.
    /// </summary>
    public string GetRandomDescriptor(
        string biomeId,
        string descriptorType,
        Position3D position)
    {
        var biome = GetBiome(biomeId);
        if (biome == null) return string.Empty;

        var pool = descriptorType.ToLowerInvariant() switch
        {
            "lighting" => biome.Descriptors.Lighting,
            "sounds" => biome.Descriptors.Sounds,
            "smells" => biome.Descriptors.Smells,
            "textures" => biome.Descriptors.Textures,
            "atmosphere" => biome.Descriptors.Atmosphere,
            "temperature" => biome.Descriptors.Temperature,
            _ => Array.Empty<string>()
        };

        if (!pool.Any()) return string.Empty;

        var index = _random.NextForPosition(position, 0, pool.Count, $"descriptor_{descriptorType}");
        return pool[index];
    }
}
```

### Biome Configuration Example

```json
{
  "$schema": "schemas/biomes-schema.json",
  "biomes": [
    {
      "id": "catacombs",
      "name": "The Catacombs",
      "description": "Ancient burial chambers where the dead rest uneasily. Bone-lined walls and forgotten tombs hold treasures and terrors alike.",
      "icon": "skull",
      "color": "gray",
      "minDepth": 0,
      "maxDepth": 5,
      "weight": 100,
      "descriptors": {
        "lighting": ["pale candlelight", "flickering shadows", "ghostly luminescence", "dim alcoves"],
        "sounds": ["whispered prayers", "rattling bones", "distant chanting", "echoing footsteps"],
        "smells": ["incense and decay", "ancient dust", "dried flowers", "mold"],
        "textures": ["carved crypts", "stacked bones", "crumbling epitaphs", "worn stone"],
        "atmosphere": ["reverent silence", "oppressive grief", "lingering spirits", "cold stillness"],
        "temperature": ["deathly cold", "chill air", "bone-chilling"],
        "descriptorPoolPrefix": "biome.catacombs"
      },
      "rules": {
        "visibilityModifier": 0.8,
        "movementModifier": 1.0,
        "requiresLight": true,
        "regenerationModifier": 0.9,
        "stealthModifier": 1.1,
        "ambientDamage": 0
      },
      "tags": ["undead", "dark", "treasure"]
    },
    {
      "id": "sewers",
      "name": "The Sewers",
      "description": "Fetid tunnels beneath the city where disease and creatures thrive in the darkness.",
      "icon": "droplet",
      "color": "green",
      "minDepth": 0,
      "maxDepth": 3,
      "weight": 80,
      "descriptors": {
        "lighting": ["sickly green glow", "phosphorescent slime", "murky darkness"],
        "sounds": ["dripping water", "scurrying rats", "gurgling flows", "distant splashing"],
        "smells": ["rot and waste", "stagnant water", "methane", "disease"],
        "textures": ["slick stone", "corroded metal", "fungal growths", "ankle-deep water"],
        "atmosphere": ["nauseating", "claustrophobic", "treacherous footing"],
        "temperature": ["damp", "humid", "clammy"],
        "descriptorPoolPrefix": "biome.sewers"
      },
      "rules": {
        "visibilityModifier": 0.7,
        "movementModifier": 0.9,
        "requiresLight": false,
        "regenerationModifier": 0.8,
        "stealthModifier": 0.9,
        "ambientStatusEffects": ["poisoned"],
        "ambientEffectChance": 0.05
      },
      "tags": ["disease", "vermin", "water"]
    },
    {
      "id": "mines",
      "name": "The Abandoned Mines",
      "description": "Collapsed tunnels and forgotten shafts where miners once sought riches. Now home to creatures that dwell in the dark.",
      "icon": "pickaxe",
      "color": "brown",
      "minDepth": 2,
      "maxDepth": 8,
      "weight": 90,
      "descriptors": {
        "lighting": ["darkness", "scattered helmet lights", "glowing crystals", "lantern remnants"],
        "sounds": ["creaking timbers", "dripping water", "distant collapses", "pickaxe echoes"],
        "smells": ["coal dust", "damp earth", "rust", "stale air"],
        "textures": ["rough-hewn walls", "ore veins", "abandoned equipment", "timber supports"],
        "atmosphere": ["industrial decay", "forgotten labor", "unstable passages"],
        "temperature": ["cool", "earth-chilled", "draft currents"],
        "descriptorPoolPrefix": "biome.mines"
      },
      "rules": {
        "visibilityModifier": 0.6,
        "movementModifier": 0.95,
        "requiresLight": true,
        "regenerationModifier": 1.0,
        "stealthModifier": 0.8
      },
      "tags": ["cave", "mining", "treasure", "collapse"]
    },
    {
      "id": "ancient-ruins",
      "name": "Ancient Ruins",
      "description": "Remnants of a civilization lost to time. Magical wards and ancient guardians protect secrets long forgotten.",
      "icon": "landmark",
      "color": "gold",
      "minDepth": 3,
      "maxDepth": null,
      "weight": 70,
      "descriptors": {
        "lighting": ["magical glyphs", "starlight through cracks", "arcane torches", "crystal formations"],
        "sounds": ["humming wards", "whispering echoes", "magical chimes", "ancient machinery"],
        "smells": ["ozone", "ancient parchment", "stone dust", "arcane residue"],
        "textures": ["intricate carvings", "rune-marked stones", "polished marble", "crumbling murals"],
        "atmosphere": ["mystical", "timeless", "watchful presence", "forgotten grandeur"],
        "temperature": ["temperature-controlled", "magically stable", "slightly warm"],
        "descriptorPoolPrefix": "biome.ruins"
      },
      "rules": {
        "visibilityModifier": 1.0,
        "movementModifier": 1.0,
        "requiresLight": false,
        "regenerationModifier": 1.1,
        "stealthModifier": 0.7
      },
      "tags": ["magic", "ancient", "treasure", "guardian"]
    },
    {
      "id": "frozen-depths",
      "name": "Frozen Depths",
      "description": "Ice-covered caverns where eternal winter reigns. Cold-adapted creatures and frozen treasures await the prepared.",
      "icon": "snowflake",
      "color": "cyan",
      "minDepth": 4,
      "maxDepth": null,
      "weight": 60,
      "descriptors": {
        "lighting": ["blue ice glow", "frost-refracted light", "aurora shimmer", "crystalline sparkle"],
        "sounds": ["cracking ice", "howling wind", "frozen silence", "ice groaning"],
        "smells": ["crisp cold", "nothing", "frozen earth"],
        "textures": ["ice walls", "frost patterns", "frozen pools", "icicle formations"],
        "atmosphere": ["deadly beautiful", "pristine isolation", "merciless cold"],
        "temperature": ["freezing", "bitter cold", "numbing", "hypothermic"],
        "descriptorPoolPrefix": "biome.frozen"
      },
      "rules": {
        "visibilityModifier": 1.2,
        "movementModifier": 0.85,
        "requiresLight": false,
        "regenerationModifier": 0.7,
        "stealthModifier": 1.0,
        "ambientDamage": 2,
        "ambientDamageType": "ice",
        "ambientStatusEffects": ["chilled", "slowed"],
        "ambientEffectChance": 0.1
      },
      "tags": ["cold", "ice", "elemental"]
    },
    {
      "id": "volcanic-caverns",
      "name": "Volcanic Caverns",
      "description": "Molten passages carved by ancient lava flows. Extreme heat and fire creatures make this the most dangerous biome.",
      "icon": "flame",
      "color": "red",
      "minDepth": 6,
      "maxDepth": null,
      "weight": 50,
      "descriptors": {
        "lighting": ["molten glow", "ember light", "fire-lit passages", "magma rivers"],
        "sounds": ["bubbling lava", "cracking stone", "distant eruptions", "hissing steam"],
        "smells": ["sulfur", "ash", "burning rock", "smoke"],
        "textures": ["obsidian walls", "cooled magma", "volcanic glass", "scorched stone"],
        "atmosphere": ["oppressive heat", "dangerous instability", "primal fury", "deadly beauty"],
        "temperature": ["sweltering", "scorching", "unbearably hot", "heat-wavering"],
        "descriptorPoolPrefix": "biome.volcanic"
      },
      "rules": {
        "visibilityModifier": 0.9,
        "movementModifier": 0.9,
        "requiresLight": false,
        "regenerationModifier": 0.6,
        "stealthModifier": 0.8,
        "ambientDamage": 3,
        "ambientDamageType": "fire",
        "ambientStatusEffects": ["burning"],
        "ambientEffectChance": 0.15
      },
      "tags": ["fire", "lava", "elemental", "dangerous"]
    }
  ]
}
```

### Room BiomeId Update

```csharp
// In Room.cs
/// <summary>
/// Gets the biome ID for this room's themed zone.
/// </summary>
public string BiomeId { get; private set; } = "dungeon";

/// <summary>
/// Sets the biome for this room.
/// </summary>
public void SetBiome(string biomeId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(biomeId);
    BiomeId = biomeId;
}
```

### Acceptance Criteria

- [ ] BiomeDefinition entity created with all properties
- [ ] BiomeDescriptors value object supports all descriptor types
- [ ] BiomeRules value object defines gameplay modifications
- [ ] Biomes load from JSON configuration
- [ ] BiomeService provides lookup and selection
- [ ] Room entity has BiomeId property
- [ ] Biome selection respects depth constraints
- [ ] Descriptor pools integrate with DescriptorService
- [ ] Six default biomes configured and tested
- [ ] ~25 unit tests pass

---

## v0.1.2b: Biome Content Pools

### Overview

Create biome-specific spawn tables for monsters, items, and loot. Each biome defines which creatures inhabit it and what treasures can be found, creating distinct exploration experiences.

### Scope

**In Scope:**
- `BiomeSpawnTable` entity for monster/item pools
- Biome-specific monster pools (undead in catacombs, vermin in sewers, etc.)
- Biome-specific item pools (themed equipment and materials)
- Biome loot modifiers (quality/quantity adjustments)
- Integration with `ContentPlacementService`
- Biome-specific crafting materials

**Out of Scope:**
- Environmental hazards (v0.1.2c)
- Biome transitions (v0.1.2d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `BiomeSpawnTable` |
| Value Objects | 2 | `SpawnEntry`, `LootModifiers` |
| Configuration | 1 | `biome-spawn-tables.json` |
| Service Updates | 2 | `ContentPlacementService`, `LootService` |
| Unit Tests | ~25 | Spawn table, placement tests |

### BiomeSpawnTable Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines monster and item spawn pools for a biome.
/// </summary>
public class BiomeSpawnTable
{
    /// <summary>
    /// Gets the biome ID this table applies to.
    /// </summary>
    public string BiomeId { get; init; } = string.Empty;

    /// <summary>
    /// Gets the monster spawn entries for this biome.
    /// </summary>
    public IReadOnlyList<SpawnEntry> MonsterPool { get; init; } = Array.Empty<SpawnEntry>();

    /// <summary>
    /// Gets the item spawn entries for this biome.
    /// </summary>
    public IReadOnlyList<SpawnEntry> ItemPool { get; init; } = Array.Empty<SpawnEntry>();

    /// <summary>
    /// Gets the hazard spawn entries for this biome.
    /// </summary>
    public IReadOnlyList<SpawnEntry> HazardPool { get; init; } = Array.Empty<SpawnEntry>();

    /// <summary>
    /// Gets loot modifiers for this biome.
    /// </summary>
    public LootModifiers LootModifiers { get; init; } = default;

    /// <summary>
    /// Gets biome-exclusive items that only drop here.
    /// </summary>
    public IReadOnlyList<string> ExclusiveItems { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets biome-exclusive monsters that only spawn here.
    /// </summary>
    public IReadOnlyList<string> ExclusiveMonsters { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets crafting materials specific to this biome.
    /// </summary>
    public IReadOnlyList<string> CraftingMaterials { get; init; } = Array.Empty<string>();
}

/// <summary>
/// A weighted spawn table entry.
/// </summary>
public readonly record struct SpawnEntry
{
    /// <summary>
    /// Gets the ID of the monster/item/hazard.
    /// </summary>
    public string Id { get; init; }

    /// <summary>
    /// Gets the spawn weight (higher = more common).
    /// </summary>
    public int Weight { get; init; }

    /// <summary>
    /// Gets the minimum depth where this can spawn.
    /// </summary>
    public int MinDepth { get; init; }

    /// <summary>
    /// Gets the maximum depth where this can spawn.
    /// </summary>
    public int? MaxDepth { get; init; }

    /// <summary>
    /// Gets additional spawn constraints.
    /// </summary>
    public IReadOnlyDictionary<string, string> Constraints { get; init; }

    /// <summary>
    /// Gets required tags for this entry to spawn.
    /// </summary>
    public IReadOnlyList<string> RequiredTags { get; init; }
}

/// <summary>
/// Loot quality and quantity modifiers for a biome.
/// </summary>
public readonly record struct LootModifiers
{
    /// <summary>
    /// Gets the gold drop multiplier.
    /// </summary>
    public float GoldMultiplier { get; init; }

    /// <summary>
    /// Gets the item drop rate multiplier.
    /// </summary>
    public float DropRateMultiplier { get; init; }

    /// <summary>
    /// Gets the quality tier bonus.
    /// </summary>
    public int QualityBonus { get; init; }

    /// <summary>
    /// Gets the rare item chance modifier.
    /// </summary>
    public float RareChanceModifier { get; init; }

    public static LootModifiers Default => new()
    {
        GoldMultiplier = 1.0f,
        DropRateMultiplier = 1.0f,
        QualityBonus = 0,
        RareChanceModifier = 1.0f
    };
}
```

### Spawn Table Configuration Example

```json
{
  "spawnTables": [
    {
      "biomeId": "catacombs",
      "monsterPool": [
        { "id": "skeleton-warrior", "weight": 100, "minDepth": 0 },
        { "id": "skeleton-archer", "weight": 80, "minDepth": 0 },
        { "id": "zombie", "weight": 70, "minDepth": 0 },
        { "id": "ghost", "weight": 40, "minDepth": 1 },
        { "id": "wight", "weight": 30, "minDepth": 2 },
        { "id": "lich", "weight": 10, "minDepth": 4, "constraints": { "tier": "boss" } }
      ],
      "itemPool": [
        { "id": "bone-dagger", "weight": 50 },
        { "id": "skull-amulet", "weight": 30 },
        { "id": "grave-dust", "weight": 80 },
        { "id": "holy-water", "weight": 40 }
      ],
      "exclusiveItems": ["crypt-key", "death-shroud", "phylactery-shard"],
      "exclusiveMonsters": ["tomb-guardian", "crypt-keeper"],
      "craftingMaterials": ["bone-fragment", "grave-dust", "ectoplasm", "burial-cloth"],
      "lootModifiers": {
        "goldMultiplier": 1.2,
        "dropRateMultiplier": 1.0,
        "qualityBonus": 0,
        "rareChanceModifier": 1.1
      }
    },
    {
      "biomeId": "volcanic-caverns",
      "monsterPool": [
        { "id": "fire-elemental", "weight": 100, "minDepth": 6 },
        { "id": "magma-slime", "weight": 80, "minDepth": 6 },
        { "id": "salamander", "weight": 60, "minDepth": 6 },
        { "id": "fire-drake", "weight": 30, "minDepth": 7 },
        { "id": "phoenix", "weight": 10, "minDepth": 8, "constraints": { "tier": "boss" } }
      ],
      "itemPool": [
        { "id": "fire-opal", "weight": 40 },
        { "id": "obsidian-blade", "weight": 30 },
        { "id": "volcanic-glass", "weight": 80 },
        { "id": "fire-resistance-potion", "weight": 60 }
      ],
      "exclusiveItems": ["heart-of-the-mountain", "phoenix-feather", "lava-core"],
      "exclusiveMonsters": ["magma-lord", "volcanic-titan"],
      "craftingMaterials": ["obsidian-shard", "sulfite-crystal", "ash-residue", "fire-essence"],
      "lootModifiers": {
        "goldMultiplier": 1.5,
        "dropRateMultiplier": 0.8,
        "qualityBonus": 1,
        "rareChanceModifier": 1.3
      }
    }
  ]
}
```

### ContentPlacementService Update

```csharp
/// <summary>
/// Fills a template slot with biome-appropriate monster content.
/// </summary>
public IEnumerable<Monster> FillMonsterSlot(
    TemplateSlot slot,
    DifficultyRating difficulty,
    Position3D position,
    EnvironmentContext environment,
    string biomeId)
{
    // Check if slot should be filled
    var fillRoll = _random.NextFloatForPosition(position, "monster_fill");
    if (!slot.IsRequired && fillRoll > slot.FillProbability)
    {
        yield break;
    }

    // Get biome spawn table
    var spawnTable = _biomeService.GetSpawnTable(biomeId);
    if (spawnTable == null)
    {
        _logger.LogWarning("No spawn table for biome {BiomeId}", biomeId);
        yield break;
    }

    // Filter monsters valid for this depth
    var validMonsters = spawnTable.MonsterPool
        .Where(e => e.MinDepth <= position.Z)
        .Where(e => !e.MaxDepth.HasValue || e.MaxDepth.Value >= position.Z);

    // Apply slot constraints
    if (slot.Constraints.TryGetValue("maxTier", out var maxTier))
    {
        validMonsters = validMonsters.Where(e =>
            !e.Constraints.TryGetValue("tier", out var tier) ||
            TierOrder(tier) <= TierOrder(maxTier));
    }

    var quantity = _random.NextForPosition(
        position,
        slot.MinQuantity,
        slot.MaxQuantity + 1,
        "monster_quantity");

    for (int i = 0; i < quantity; i++)
    {
        var entry = _random.SelectWeighted(
            position,
            validMonsters.Select(e => (e, e.Weight)),
            $"monster_select_{i}");

        var monster = _monsterService.CreateMonster(
            entry.Id,
            difficulty.MonsterLevelBonus);

        if (monster != null)
            yield return monster;
    }
}
```

### Acceptance Criteria

- [ ] BiomeSpawnTable entity created with monster/item pools
- [ ] SpawnEntry supports depth constraints and weights
- [ ] LootModifiers adjust quality and drop rates
- [ ] Spawn tables load from JSON configuration
- [ ] ContentPlacementService filters by biome
- [ ] Biome-exclusive items only drop in their biome
- [ ] Crafting materials are biome-specific
- [ ] Loot modifiers apply correctly
- [ ] ~25 unit tests pass

---

## v0.1.2c: Environmental Hazards

### Overview

Implement biome-specific environmental hazards that create danger zones. Hazards deal damage, apply status effects, and add tactical considerations to exploration.

### Scope

**In Scope:**
- `BiomeHazard` entity for environmental dangers
- Hazard configuration and loading
- `BiomeDamageModifier` for resistance/vulnerability
- Hazard slot filling in templates
- Hazard interaction (trigger, avoid, disarm)
- Biome-specific status effect application
- Hazard display and warnings

**Out of Scope:**
- Biome transitions (v0.1.2d)
- Biome discovery/codex (v0.1.2d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `BiomeHazard` |
| Value Objects | 2 | `BiomeDamageModifier`, `HazardTrigger` |
| Services | 1 | `HazardService` |
| Configuration | 1 | `hazards.json` |
| Template Updates | 1 | Hazard slot type |
| Unit Tests | ~28 | Hazard, damage modifier tests |

### BiomeHazard Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines an environmental hazard specific to a biome.
/// </summary>
public class BiomeHazard
{
    /// <summary>
    /// Gets the unique hazard identifier.
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the description shown when encountered.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the warning text shown on approach.
    /// </summary>
    public string WarningText { get; init; } = string.Empty;

    /// <summary>
    /// Gets the biome IDs where this hazard appears.
    /// </summary>
    public IReadOnlyList<string> BiomeIds { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the damage dealt per trigger.
    /// </summary>
    public int Damage { get; init; }

    /// <summary>
    /// Gets the damage type.
    /// </summary>
    public string DamageType { get; init; } = "physical";

    /// <summary>
    /// Gets status effects applied on trigger.
    /// </summary>
    public IReadOnlyList<string> StatusEffects { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the trigger mechanism.
    /// </summary>
    public HazardTrigger Trigger { get; init; } = default;

    /// <summary>
    /// Gets whether the hazard can be disarmed.
    /// </summary>
    public bool CanDisarm { get; init; }

    /// <summary>
    /// Gets the skill check required to disarm.
    /// </summary>
    public string? DisarmSkill { get; init; }

    /// <summary>
    /// Gets the difficulty class to disarm.
    /// </summary>
    public int DisarmDC { get; init; }

    /// <summary>
    /// Gets whether the hazard can be avoided.
    /// </summary>
    public bool CanAvoid { get; init; }

    /// <summary>
    /// Gets the skill check required to avoid.
    /// </summary>
    public string? AvoidSkill { get; init; }

    /// <summary>
    /// Gets the difficulty class to avoid.
    /// </summary>
    public int AvoidDC { get; init; }

    /// <summary>
    /// Gets whether this hazard persists after triggering.
    /// </summary>
    public bool Persistent { get; init; }

    /// <summary>
    /// Gets how often a persistent hazard triggers.
    /// </summary>
    public int TriggerInterval { get; init; } = 1;

    /// <summary>
    /// Gets the visual representation for maps.
    /// </summary>
    public char MapSymbol { get; init; } = '!';

    /// <summary>
    /// Gets the color for display.
    /// </summary>
    public string Color { get; init; } = "red";
}

/// <summary>
/// Defines how a hazard is triggered.
/// </summary>
public readonly record struct HazardTrigger
{
    /// <summary>
    /// Gets the trigger type.
    /// </summary>
    public HazardTriggerType Type { get; init; }

    /// <summary>
    /// Gets the chance to trigger (0.0-1.0).
    /// </summary>
    public float Chance { get; init; }

    /// <summary>
    /// Gets the detection DC (if applicable).
    /// </summary>
    public int DetectionDC { get; init; }

    /// <summary>
    /// Gets whether the hazard is visible by default.
    /// </summary>
    public bool Visible { get; init; }
}

/// <summary>
/// Types of hazard triggers.
/// </summary>
public enum HazardTriggerType
{
    /// <summary>Triggers when entering the room.</summary>
    OnEnter,

    /// <summary>Triggers each turn in the room.</summary>
    PerTurn,

    /// <summary>Triggers on specific actions.</summary>
    OnAction,

    /// <summary>Triggers when a condition is met.</summary>
    Conditional,

    /// <summary>Always active ambient effect.</summary>
    Ambient
}
```

### BiomeDamageModifier Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines damage type modifications for a biome.
/// </summary>
public readonly record struct BiomeDamageModifier
{
    /// <summary>
    /// Gets the biome ID this modifier applies to.
    /// </summary>
    public string BiomeId { get; init; }

    /// <summary>
    /// Gets damage type modifiers (type -> multiplier).
    /// </summary>
    /// <remarks>
    /// Values: 0.0 = immune, 0.5 = resistant, 1.0 = normal, 1.5 = vulnerable, 2.0 = very vulnerable
    /// </remarks>
    public IReadOnlyDictionary<string, float> Modifiers { get; init; }

    /// <summary>
    /// Gets whether fire damage is enhanced in this biome.
    /// </summary>
    public float FireModifier => Modifiers.GetValueOrDefault("fire", 1.0f);

    /// <summary>
    /// Gets whether ice damage is enhanced in this biome.
    /// </summary>
    public float IceModifier => Modifiers.GetValueOrDefault("ice", 1.0f);

    /// <summary>
    /// Applies the modifier to damage.
    /// </summary>
    public int ApplyModifier(int baseDamage, string damageType)
    {
        var multiplier = Modifiers.GetValueOrDefault(damageType.ToLowerInvariant(), 1.0f);
        return (int)(baseDamage * multiplier);
    }

    /// <summary>
    /// Creates volcanic cavern modifiers (fire resistant, ice vulnerable).
    /// </summary>
    public static BiomeDamageModifier VolcanicCaverns => new()
    {
        BiomeId = "volcanic-caverns",
        Modifiers = new Dictionary<string, float>
        {
            ["fire"] = 0.5f,      // Fire creatures resist fire
            ["ice"] = 1.5f,       // Cold is effective
            ["physical"] = 1.0f
        }
    };

    /// <summary>
    /// Creates frozen depths modifiers (ice resistant, fire vulnerable).
    /// </summary>
    public static BiomeDamageModifier FrozenDepths => new()
    {
        BiomeId = "frozen-depths",
        Modifiers = new Dictionary<string, float>
        {
            ["ice"] = 0.5f,       // Ice creatures resist cold
            ["fire"] = 1.5f,      // Fire is effective
            ["physical"] = 1.0f
        }
    };
}
```

### HazardService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing environmental hazards.
/// </summary>
public class HazardService : IHazardService
{
    private readonly IConfigurationProvider _config;
    private readonly IBiomeService _biomeService;
    private readonly ISkillCheckService _skillCheck;
    private readonly ICombatService _combat;
    private readonly ILogger<HazardService> _logger;

    /// <summary>
    /// Gets all hazards for a biome.
    /// </summary>
    public IReadOnlyList<BiomeHazard> GetHazardsForBiome(string biomeId)
    {
        return _config.GetHazardDefinitions()
            .Where(h => h.BiomeIds.Contains(biomeId))
            .ToList();
    }

    /// <summary>
    /// Checks if a hazard triggers and applies effects.
    /// </summary>
    public HazardResult TriggerHazard(
        BiomeHazard hazard,
        Player player,
        Room room)
    {
        // Check if avoided
        if (hazard.CanAvoid && hazard.AvoidSkill != null)
        {
            var avoidCheck = _skillCheck.PerformCheck(
                player,
                hazard.AvoidSkill,
                hazard.AvoidDC);

            if (avoidCheck.IsSuccess)
            {
                _logger.LogInformation(
                    "Player avoided {Hazard} with {Skill} check",
                    hazard.Name,
                    hazard.AvoidSkill);

                return new HazardResult
                {
                    HazardId = hazard.Id,
                    WasAvoided = true,
                    AvoidCheckResult = avoidCheck
                };
            }
        }

        // Check trigger chance
        var triggerRoll = Random.Shared.NextDouble();
        if (triggerRoll > hazard.Trigger.Chance)
        {
            return new HazardResult
            {
                HazardId = hazard.Id,
                DidNotTrigger = true
            };
        }

        // Apply damage
        var biomeModifier = GetBiomeDamageModifier(room.BiomeId);
        var damage = biomeModifier.ApplyModifier(hazard.Damage, hazard.DamageType);

        var damageResult = _combat.ApplyDamage(
            player,
            damage,
            hazard.DamageType,
            $"hazard:{hazard.Id}");

        // Apply status effects
        var appliedEffects = new List<string>();
        foreach (var effectId in hazard.StatusEffects)
        {
            if (_statusEffectService.ApplyEffect(player, effectId))
            {
                appliedEffects.Add(effectId);
            }
        }

        _logger.LogInformation(
            "Hazard {Hazard} triggered: {Damage} {DamageType} damage, effects: {Effects}",
            hazard.Name,
            damage,
            hazard.DamageType,
            string.Join(", ", appliedEffects));

        return new HazardResult
        {
            HazardId = hazard.Id,
            DamageDealt = damage,
            DamageType = hazard.DamageType,
            StatusEffectsApplied = appliedEffects,
            WasTriggered = true
        };
    }

    /// <summary>
    /// Attempts to disarm a hazard.
    /// </summary>
    public DisarmResult TryDisarm(
        BiomeHazard hazard,
        Player player)
    {
        if (!hazard.CanDisarm)
        {
            return new DisarmResult
            {
                HazardId = hazard.Id,
                CannotDisarm = true,
                Message = $"The {hazard.Name} cannot be disarmed."
            };
        }

        var check = _skillCheck.PerformCheck(
            player,
            hazard.DisarmSkill!,
            hazard.DisarmDC);

        if (check.IsSuccess)
        {
            return new DisarmResult
            {
                HazardId = hazard.Id,
                Success = true,
                CheckResult = check,
                Message = $"You successfully disarm the {hazard.Name}."
            };
        }

        // Failed disarm might trigger the hazard
        if (check.IsCriticalFailure)
        {
            var triggerResult = TriggerHazard(hazard, player, player.CurrentRoom!);
            return new DisarmResult
            {
                HazardId = hazard.Id,
                Success = false,
                TriggeredHazard = true,
                TriggerResult = triggerResult,
                CheckResult = check,
                Message = $"Your attempt fails catastrophically! The {hazard.Name} triggers!"
            };
        }

        return new DisarmResult
        {
            HazardId = hazard.Id,
            Success = false,
            CheckResult = check,
            Message = $"You fail to disarm the {hazard.Name}."
        };
    }

    /// <summary>
    /// Gets the damage modifier for a biome.
    /// </summary>
    public BiomeDamageModifier GetBiomeDamageModifier(string biomeId)
    {
        return _config.GetBiomeDamageModifiers()
            .FirstOrDefault(m => m.BiomeId == biomeId);
    }
}
```

### Hazard Configuration Example

```json
{
  "hazards": [
    {
      "id": "poison-gas-cloud",
      "name": "Poison Gas Cloud",
      "description": "A cloud of toxic green gas fills the passage.",
      "warningText": "You notice a sickly green haze ahead...",
      "biomeIds": ["sewers"],
      "damage": 5,
      "damageType": "poison",
      "statusEffects": ["poisoned"],
      "trigger": {
        "type": "PerTurn",
        "chance": 0.6,
        "detectionDC": 10,
        "visible": true
      },
      "canAvoid": true,
      "avoidSkill": "athletics",
      "avoidDC": 12,
      "canDisarm": false,
      "persistent": true,
      "mapSymbol": "~",
      "color": "green"
    },
    {
      "id": "lava-pool",
      "name": "Lava Pool",
      "description": "Molten rock bubbles dangerously at your feet.",
      "warningText": "Intense heat radiates from the glowing floor ahead.",
      "biomeIds": ["volcanic-caverns"],
      "damage": 15,
      "damageType": "fire",
      "statusEffects": ["burning"],
      "trigger": {
        "type": "OnEnter",
        "chance": 1.0,
        "detectionDC": 5,
        "visible": true
      },
      "canAvoid": true,
      "avoidSkill": "acrobatics",
      "avoidDC": 15,
      "canDisarm": false,
      "persistent": true,
      "mapSymbol": "~",
      "color": "red"
    },
    {
      "id": "ice-patch",
      "name": "Slippery Ice",
      "description": "A treacherous patch of black ice covers the floor.",
      "warningText": "The floor ahead glistens with a thin layer of ice.",
      "biomeIds": ["frozen-depths"],
      "damage": 3,
      "damageType": "physical",
      "statusEffects": ["prone", "slowed"],
      "trigger": {
        "type": "OnEnter",
        "chance": 0.5,
        "detectionDC": 12,
        "visible": false
      },
      "canAvoid": true,
      "avoidSkill": "acrobatics",
      "avoidDC": 13,
      "canDisarm": false,
      "persistent": true,
      "mapSymbol": ".",
      "color": "cyan"
    },
    {
      "id": "bone-trap",
      "name": "Bone Scythe Trap",
      "description": "Sharpened bones swing from the ceiling in a deadly arc.",
      "warningText": "You notice thin wires strung across the passage.",
      "biomeIds": ["catacombs"],
      "damage": 12,
      "damageType": "physical",
      "statusEffects": ["bleeding"],
      "trigger": {
        "type": "OnEnter",
        "chance": 1.0,
        "detectionDC": 14,
        "visible": false
      },
      "canAvoid": true,
      "avoidSkill": "acrobatics",
      "avoidDC": 14,
      "canDisarm": true,
      "disarmSkill": "sleight-of-hand",
      "disarmDC": 15,
      "persistent": false,
      "mapSymbol": "^",
      "color": "gray"
    },
    {
      "id": "cave-in-zone",
      "name": "Unstable Ceiling",
      "description": "The ceiling above looks ready to collapse.",
      "warningText": "Dust and pebbles rain down from the crumbling ceiling.",
      "biomeIds": ["mines"],
      "damage": 20,
      "damageType": "physical",
      "statusEffects": ["stunned"],
      "trigger": {
        "type": "Conditional",
        "chance": 0.2,
        "detectionDC": 8,
        "visible": true
      },
      "canAvoid": true,
      "avoidSkill": "perception",
      "avoidDC": 13,
      "canDisarm": false,
      "persistent": false,
      "mapSymbol": "!",
      "color": "brown"
    }
  ],
  "damageModifiers": [
    {
      "biomeId": "volcanic-caverns",
      "modifiers": {
        "fire": 0.5,
        "ice": 1.5
      }
    },
    {
      "biomeId": "frozen-depths",
      "modifiers": {
        "ice": 0.5,
        "fire": 1.5
      }
    },
    {
      "biomeId": "catacombs",
      "modifiers": {
        "holy": 1.5,
        "dark": 0.75
      }
    }
  ]
}
```

### Acceptance Criteria

- [ ] BiomeHazard entity created with all properties
- [ ] HazardTrigger supports all trigger types
- [ ] BiomeDamageModifier adjusts damage by type
- [ ] Hazards load from JSON configuration
- [ ] HazardService triggers hazards correctly
- [ ] Hazard avoidance uses skill checks
- [ ] Hazard disarming uses skill checks
- [ ] Persistent hazards trigger each turn
- [ ] Damage modifiers apply per biome
- [ ] ~28 unit tests pass

---

## v0.1.2d: Transitional Zones & Discovery

### Overview

Create transitional zones between biomes with gradual descriptor blending and mixed encounter tables. Implement biome discovery tracking and codex integration for lore collection.

### Scope

**In Scope:**
- `BiomeTransition` rules for zone connections
- Transitional room generation with blending
- Gradual descriptor transitions
- Mixed encounter tables for transitions
- `BiomeProgress` tracking on Player
- Codex biome entry unlocks
- Biome discovery notifications
- Transition configuration

**Out of Scope:**
- Custom biome creation UI (future version)
- Biome-specific quests (future version)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `BiomeTransition` rules |
| Value Objects | 2 | `TransitionBlend`, `BiomeProgress` |
| Services | 1 | `TransitionService` |
| Player Updates | 1 | `BiomeProgress` tracking |
| Configuration | 1 | `biome-transitions.json` |
| Codex Integration | 1 | Biome lore entries |
| Unit Tests | ~22 | Transition, discovery tests |

### BiomeTransition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines transition rules between two biomes.
/// </summary>
public class BiomeTransition
{
    /// <summary>
    /// Gets the source biome ID.
    /// </summary>
    public string FromBiomeId { get; init; } = string.Empty;

    /// <summary>
    /// Gets the destination biome ID.
    /// </summary>
    public string ToBiomeId { get; init; } = string.Empty;

    /// <summary>
    /// Gets whether this transition is allowed.
    /// </summary>
    public bool IsAllowed { get; init; } = true;

    /// <summary>
    /// Gets the number of transition rooms between biomes.
    /// </summary>
    public int TransitionLength { get; init; } = 2;

    /// <summary>
    /// Gets the transition style.
    /// </summary>
    public TransitionStyle Style { get; init; } = TransitionStyle.Gradual;

    /// <summary>
    /// Gets description text for the transition zone.
    /// </summary>
    public string TransitionDescription { get; init; } = string.Empty;

    /// <summary>
    /// Gets the probability this transition occurs when changing biomes.
    /// </summary>
    public float Probability { get; init; } = 1.0f;

    /// <summary>
    /// Gets required depth for this transition.
    /// </summary>
    public int? RequiredDepth { get; init; }

    /// <summary>
    /// Gets whether the transition is bidirectional.
    /// </summary>
    public bool Bidirectional { get; init; } = true;
}

/// <summary>
/// Styles of biome transitions.
/// </summary>
public enum TransitionStyle
{
    /// <summary>Gradual blend over multiple rooms.</summary>
    Gradual,

    /// <summary>Abrupt change at a border.</summary>
    Abrupt,

    /// <summary>Special portal/door transition.</summary>
    Portal,

    /// <summary>Vertical transition (stairs, pit).</summary>
    Vertical
}
```

### TransitionBlend Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the blended state of a transitional zone.
/// </summary>
public readonly record struct TransitionBlend
{
    /// <summary>
    /// Gets the primary biome ID.
    /// </summary>
    public string PrimaryBiomeId { get; init; }

    /// <summary>
    /// Gets the secondary biome ID.
    /// </summary>
    public string SecondaryBiomeId { get; init; }

    /// <summary>
    /// Gets the blend ratio (0.0 = all primary, 1.0 = all secondary).
    /// </summary>
    public float BlendRatio { get; init; }

    /// <summary>
    /// Gets the primary biome weight for spawn selection.
    /// </summary>
    public float PrimaryWeight => 1.0f - BlendRatio;

    /// <summary>
    /// Gets the secondary biome weight for spawn selection.
    /// </summary>
    public float SecondaryWeight => BlendRatio;

    /// <summary>
    /// Gets whether this is a pure biome (no blend).
    /// </summary>
    public bool IsPure => BlendRatio == 0.0f || BlendRatio == 1.0f;

    /// <summary>
    /// Creates a blend for a specific position in a transition.
    /// </summary>
    public static TransitionBlend ForPosition(
        string fromBiome,
        string toBiome,
        int positionInTransition,
        int transitionLength)
    {
        var ratio = (float)positionInTransition / transitionLength;
        return new TransitionBlend
        {
            PrimaryBiomeId = fromBiome,
            SecondaryBiomeId = toBiome,
            BlendRatio = Math.Clamp(ratio, 0f, 1f)
        };
    }

    /// <summary>
    /// Selects a biome for spawning based on blend weights.
    /// </summary>
    public string SelectBiomeForSpawn(Random random)
    {
        return random.NextDouble() < PrimaryWeight
            ? PrimaryBiomeId
            : SecondaryBiomeId;
    }

    /// <summary>
    /// Gets blended descriptors from both biomes.
    /// </summary>
    public string GetBlendedDescriptor(
        BiomeDescriptors primary,
        BiomeDescriptors secondary,
        string descriptorType,
        Random random)
    {
        var usePrimary = random.NextDouble() < PrimaryWeight;
        var source = usePrimary ? primary : secondary;

        var pool = descriptorType.ToLowerInvariant() switch
        {
            "lighting" => source.Lighting,
            "sounds" => source.Sounds,
            "smells" => source.Smells,
            "textures" => source.Textures,
            "atmosphere" => source.Atmosphere,
            "temperature" => source.Temperature,
            _ => Array.Empty<string>()
        };

        return pool.Any() ? pool[random.Next(pool.Count)] : string.Empty;
    }
}
```

### BiomeProgress Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks player progress in discovering biomes.
/// </summary>
public record BiomeProgress
{
    /// <summary>
    /// Gets discovered biome IDs with discovery timestamps.
    /// </summary>
    public IReadOnlyDictionary<string, DateTime> DiscoveredBiomes { get; init; }
        = new Dictionary<string, DateTime>();

    /// <summary>
    /// Gets rooms visited per biome.
    /// </summary>
    public IReadOnlyDictionary<string, int> RoomsVisited { get; init; }
        = new Dictionary<string, int>();

    /// <summary>
    /// Gets monsters defeated per biome.
    /// </summary>
    public IReadOnlyDictionary<string, int> MonstersDefeated { get; init; }
        = new Dictionary<string, int>();

    /// <summary>
    /// Gets deepest depth reached per biome.
    /// </summary>
    public IReadOnlyDictionary<string, int> DeepestDepth { get; init; }
        = new Dictionary<string, int>();

    /// <summary>
    /// Checks if a biome has been discovered.
    /// </summary>
    public bool HasDiscovered(string biomeId) =>
        DiscoveredBiomes.ContainsKey(biomeId);

    /// <summary>
    /// Gets the discovery date for a biome.
    /// </summary>
    public DateTime? GetDiscoveryDate(string biomeId) =>
        DiscoveredBiomes.GetValueOrDefault(biomeId);

    /// <summary>
    /// Records discovery of a new biome.
    /// </summary>
    public BiomeProgress DiscoverBiome(string biomeId)
    {
        if (HasDiscovered(biomeId)) return this;

        var newDiscovered = new Dictionary<string, DateTime>(DiscoveredBiomes)
        {
            [biomeId] = DateTime.UtcNow
        };

        return this with { DiscoveredBiomes = newDiscovered };
    }

    /// <summary>
    /// Records a room visit in a biome.
    /// </summary>
    public BiomeProgress RecordRoomVisit(string biomeId)
    {
        var current = RoomsVisited.GetValueOrDefault(biomeId, 0);
        var updated = new Dictionary<string, int>(RoomsVisited)
        {
            [biomeId] = current + 1
        };

        var result = HasDiscovered(biomeId)
            ? this
            : DiscoverBiome(biomeId);

        return result with { RoomsVisited = updated };
    }

    /// <summary>
    /// Records a monster defeat in a biome.
    /// </summary>
    public BiomeProgress RecordMonsterDefeat(string biomeId)
    {
        var current = MonstersDefeated.GetValueOrDefault(biomeId, 0);
        var updated = new Dictionary<string, int>(MonstersDefeated)
        {
            [biomeId] = current + 1
        };

        return this with { MonstersDefeated = updated };
    }

    /// <summary>
    /// Updates the deepest depth reached in a biome.
    /// </summary>
    public BiomeProgress UpdateDeepestDepth(string biomeId, int depth)
    {
        var current = DeepestDepth.GetValueOrDefault(biomeId, 0);
        if (depth <= current) return this;

        var updated = new Dictionary<string, int>(DeepestDepth)
        {
            [biomeId] = depth
        };

        return this with { DeepestDepth = updated };
    }
}
```

### TransitionService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing biome transitions.
/// </summary>
public class TransitionService : ITransitionService
{
    private readonly IBiomeService _biomeService;
    private readonly IConfigurationProvider _config;
    private readonly SeededRandomService _random;
    private readonly ILogger<TransitionService> _logger;

    /// <summary>
    /// Gets the transition rules between two biomes.
    /// </summary>
    public BiomeTransition? GetTransition(string fromBiome, string toBiome)
    {
        return _config.GetBiomeTransitions()
            .FirstOrDefault(t =>
                (t.FromBiomeId == fromBiome && t.ToBiomeId == toBiome) ||
                (t.Bidirectional && t.FromBiomeId == toBiome && t.ToBiomeId == fromBiome));
    }

    /// <summary>
    /// Gets valid biomes that can connect to the specified biome.
    /// </summary>
    public IReadOnlyList<string> GetConnectableBiomes(string biomeId, int depth)
    {
        var transitions = _config.GetBiomeTransitions()
            .Where(t => t.IsAllowed)
            .Where(t => !t.RequiredDepth.HasValue || t.RequiredDepth.Value <= depth)
            .Where(t => t.FromBiomeId == biomeId || (t.Bidirectional && t.ToBiomeId == biomeId))
            .Select(t => t.FromBiomeId == biomeId ? t.ToBiomeId : t.FromBiomeId)
            .Distinct()
            .ToList();

        return transitions;
    }

    /// <summary>
    /// Creates a transition blend for a room position.
    /// </summary>
    public TransitionBlend CreateBlend(
        Position3D position,
        string fromBiome,
        string toBiome,
        int roomsFromStart,
        int transitionLength)
    {
        return TransitionBlend.ForPosition(
            fromBiome,
            toBiome,
            roomsFromStart,
            transitionLength);
    }

    /// <summary>
    /// Generates descriptors for a transitional room.
    /// </summary>
    public BiomeDescriptors GetTransitionalDescriptors(
        TransitionBlend blend,
        Position3D position)
    {
        var primary = _biomeService.GetBiome(blend.PrimaryBiomeId);
        var secondary = _biomeService.GetBiome(blend.SecondaryBiomeId);

        if (primary == null || secondary == null)
        {
            return BiomeDescriptors.Default;
        }

        // Create blended descriptors
        return new BiomeDescriptors
        {
            Lighting = BlendDescriptorList(
                primary.Descriptors.Lighting,
                secondary.Descriptors.Lighting,
                blend.BlendRatio),
            Sounds = BlendDescriptorList(
                primary.Descriptors.Sounds,
                secondary.Descriptors.Sounds,
                blend.BlendRatio),
            Smells = BlendDescriptorList(
                primary.Descriptors.Smells,
                secondary.Descriptors.Smells,
                blend.BlendRatio),
            Textures = BlendDescriptorList(
                primary.Descriptors.Textures,
                secondary.Descriptors.Textures,
                blend.BlendRatio),
            Atmosphere = BlendDescriptorList(
                primary.Descriptors.Atmosphere,
                secondary.Descriptors.Atmosphere,
                blend.BlendRatio),
            Temperature = BlendDescriptorList(
                primary.Descriptors.Temperature,
                secondary.Descriptors.Temperature,
                blend.BlendRatio),
            DescriptorPoolPrefix = $"transition.{blend.PrimaryBiomeId}.{blend.SecondaryBiomeId}"
        };
    }

    /// <summary>
    /// Gets a mixed spawn table for a transitional zone.
    /// </summary>
    public BiomeSpawnTable GetMixedSpawnTable(TransitionBlend blend)
    {
        var primary = _biomeService.GetSpawnTable(blend.PrimaryBiomeId);
        var secondary = _biomeService.GetSpawnTable(blend.SecondaryBiomeId);

        if (primary == null) return secondary ?? new BiomeSpawnTable();
        if (secondary == null) return primary;

        // Combine monster pools with adjusted weights
        var combinedMonsters = primary.MonsterPool
            .Select(e => e with { Weight = (int)(e.Weight * blend.PrimaryWeight) })
            .Concat(secondary.MonsterPool
                .Select(e => e with { Weight = (int)(e.Weight * blend.SecondaryWeight) }))
            .ToList();

        var combinedItems = primary.ItemPool
            .Select(e => e with { Weight = (int)(e.Weight * blend.PrimaryWeight) })
            .Concat(secondary.ItemPool
                .Select(e => e with { Weight = (int)(e.Weight * blend.SecondaryWeight) }))
            .ToList();

        return new BiomeSpawnTable
        {
            BiomeId = $"transition:{blend.PrimaryBiomeId}:{blend.SecondaryBiomeId}",
            MonsterPool = combinedMonsters,
            ItemPool = combinedItems,
            LootModifiers = BlendLootModifiers(
                primary.LootModifiers,
                secondary.LootModifiers,
                blend.BlendRatio)
        };
    }

    private IReadOnlyList<string> BlendDescriptorList(
        IReadOnlyList<string> primary,
        IReadOnlyList<string> secondary,
        float ratio)
    {
        var primaryCount = (int)(primary.Count * (1 - ratio));
        var secondaryCount = (int)(secondary.Count * ratio);

        return primary.Take(Math.Max(1, primaryCount))
            .Concat(secondary.Take(Math.Max(1, secondaryCount)))
            .ToList();
    }

    private LootModifiers BlendLootModifiers(
        LootModifiers primary,
        LootModifiers secondary,
        float ratio)
    {
        return new LootModifiers
        {
            GoldMultiplier = Lerp(primary.GoldMultiplier, secondary.GoldMultiplier, ratio),
            DropRateMultiplier = Lerp(primary.DropRateMultiplier, secondary.DropRateMultiplier, ratio),
            QualityBonus = (int)Lerp(primary.QualityBonus, secondary.QualityBonus, ratio),
            RareChanceModifier = Lerp(primary.RareChanceModifier, secondary.RareChanceModifier, ratio)
        };
    }

    private static float Lerp(float a, float b, float t) => a + (b - a) * t;
}
```

### Transition Configuration Example

```json
{
  "transitions": [
    {
      "fromBiomeId": "catacombs",
      "toBiomeId": "sewers",
      "isAllowed": true,
      "transitionLength": 2,
      "style": "Gradual",
      "transitionDescription": "The burial chambers give way to older, flooded passages.",
      "probability": 0.8,
      "bidirectional": true
    },
    {
      "fromBiomeId": "mines",
      "toBiomeId": "volcanic-caverns",
      "isAllowed": true,
      "transitionLength": 3,
      "style": "Gradual",
      "transitionDescription": "The tunnels grow warmer, the stone blackening as you descend toward the earth's fire.",
      "probability": 0.6,
      "requiredDepth": 5,
      "bidirectional": true
    },
    {
      "fromBiomeId": "ancient-ruins",
      "toBiomeId": "frozen-depths",
      "isAllowed": true,
      "transitionLength": 2,
      "style": "Portal",
      "transitionDescription": "An ancient portal shimmers with cold blue light, leading to frozen chambers beyond.",
      "probability": 0.4,
      "requiredDepth": 4,
      "bidirectional": true
    },
    {
      "fromBiomeId": "frozen-depths",
      "toBiomeId": "volcanic-caverns",
      "isAllowed": false,
      "transitionDescription": "These extreme environments cannot connect naturally.",
      "bidirectional": true
    }
  ]
}
```

### Player BiomeProgress Update

```csharp
// In Player.cs
/// <summary>
/// Gets the player's biome discovery progress.
/// </summary>
public BiomeProgress BiomeProgress { get; private set; } = new BiomeProgress();

/// <summary>
/// Records entering a new biome.
/// </summary>
public BiomeDiscoveryResult EnterBiome(string biomeId, int depth)
{
    var wasNew = !BiomeProgress.HasDiscovered(biomeId);

    BiomeProgress = BiomeProgress
        .RecordRoomVisit(biomeId)
        .UpdateDeepestDepth(biomeId, depth);

    return new BiomeDiscoveryResult
    {
        BiomeId = biomeId,
        IsNewDiscovery = wasNew,
        TotalRoomsVisited = BiomeProgress.RoomsVisited.GetValueOrDefault(biomeId, 0),
        DeepestDepth = BiomeProgress.DeepestDepth.GetValueOrDefault(biomeId, 0)
    };
}
```

### Acceptance Criteria

- [ ] BiomeTransition entity defines connection rules
- [ ] TransitionBlend calculates blended state
- [ ] TransitionService creates transitional rooms
- [ ] Descriptors blend between biomes
- [ ] Spawn tables mix for transitions
- [ ] Transition configuration loads from JSON
- [ ] Player tracks BiomeProgress
- [ ] Biome discovery triggers notifications
- [ ] Codex entries unlock on discovery
- [ ] Invalid transitions are blocked
- [ ] ~22 unit tests pass

---

## Dependencies & Prerequisites

```
v0.1.1 (Dynamic Room Generation) - REQUIRED
    
     RoomTemplate, SeededRandomService, ContentPlacementService 
     DescriptorService, EnvironmentContext                         
                                                                       
                                                                       
v0.1.2 (Dungeon Theming & Biomes)
    
     v0.1.2a: Biome System Core 
           Dependencies: v0.1.1 (EnvironmentContext, descriptors)     
                                                                      
     v0.1.2b: Biome Content Pools 
           Dependencies: v0.1.2a (BiomeDefinition, BiomeService)      
                         v0.0.9 (MonsterDefinition, LootTable)        
                                                                      
     v0.1.2c: Environmental Hazards 
           Dependencies: v0.1.2a (BiomeDefinition)                    
                         v0.1.2b (BiomeSpawnTable for hazard pools)   
                         v0.0.6 (StatusEffectDefinition)              
                                                                      
     v0.1.2d: Transitional Zones & Discovery 
            Dependencies: v0.1.2a, v0.1.2b, v0.1.2c (all biome systems)
```

**Note:** Phases are sequential - each depends on prior phases within v0.1.2.

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.1.2a | ~6 | ~4 | ~25 | High |
| v0.1.2b | ~3 | ~4 | ~25 | Medium |
| v0.1.2c | ~4 | ~3 | ~28 | High |
| v0.1.2d | ~5 | ~4 | ~22 | High |
| **Total** | **~18** | **~15** | **~100** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Biome complexity overwhelming | High | Medium | Start with 3-4 core biomes |
| Descriptor repetition feeling stale | Medium | Medium | Large descriptor pools, blending |
| Hazard balance issues | Medium | High | Extensive playtesting, tuning |
| Transition generation edge cases | Medium | Medium | Comprehensive tests |
| Performance with large spawn tables | Low | Low | Caching, lazy loading |

---

## Design Decisions

### Biome System

| Decision | Value | Notes |
|----------|-------|-------|
| **Biome storage** | JSON configuration | Easy to mod/extend |
| **Descriptor pools** | Per-biome arrays | Consistent with v0.1.1 |
| **Depth constraints** | Min/Max per biome | Natural progression |
| **Biome selection** | Weighted by depth | Controlled variety |

### Content Pools

| Decision | Value | Notes |
|----------|-------|-------|
| **Spawn table format** | Weighted entries | Flexible probability |
| **Exclusive content** | Separate lists | Clear biome identity |
| **Loot modifiers** | Multiplicative | Stacking with difficulty |
| **Crafting materials** | Biome-specific | Exploration incentive |

### Hazards

| Decision | Value | Notes |
|----------|-------|-------|
| **Hazard triggers** | Enum-based | Clear behavior |
| **Avoidance** | Skill checks | Player agency |
| **Persistence** | Configurable | Varied danger |
| **Damage modifiers** | Per-biome | Elemental theming |

### Transitions

| Decision | Value | Notes |
|----------|-------|-------|
| **Blend calculation** | Linear ratio | Simple, predictable |
| **Spawn mixing** | Weight adjustment | Fair distribution |
| **Transition length** | Configurable | Natural flow |
| **Discovery tracking** | Per-biome stats | Achievement support |

---

## Files Summary

### Files to Create (New)

| Phase | File | Purpose |
|-------|------|---------|
| 1a | `BiomeDefinition.cs` | Biome entity |
| 1a | `BiomeDescriptors.cs` | Descriptor value object |
| 1a | `BiomeRules.cs` | Rules value object |
| 1a | `BiomeService.cs` | Biome lookup/selection |
| 1a | `IBiomeService.cs` | Service interface |
| 1a | `biomes.json` | Biome configuration |
| 1b | `BiomeSpawnTable.cs` | Spawn table entity |
| 1b | `SpawnEntry.cs` | Spawn entry value object |
| 1b | `biome-spawn-tables.json` | Spawn configuration |
| 1c | `BiomeHazard.cs` | Hazard entity |
| 1c | `BiomeDamageModifier.cs` | Damage modifier value object |
| 1c | `HazardService.cs` | Hazard management |
| 1c | `hazards.json` | Hazard configuration |
| 1d | `BiomeTransition.cs` | Transition rules |
| 1d | `TransitionBlend.cs` | Blend value object |
| 1d | `BiomeProgress.cs` | Progress tracking |
| 1d | `TransitionService.cs` | Transition management |
| 1d | `biome-transitions.json` | Transition configuration |

### Files to Modify

| Phase | File | Changes |
|-------|------|---------|
| 1a | `Room.cs` | Add BiomeId property |
| 1a | `DescriptorService.cs` | Biome-aware filtering |
| 1a | `IConfigurationProvider.cs` | Add biome loading |
| 1a | `JsonConfigurationProvider.cs` | Implement biome loading |
| 1b | `ContentPlacementService.cs` | Biome filtering |
| 1b | `LootService.cs` | Biome modifiers |
| 1c | `TemplateSlot.cs` | Add Hazard slot type |
| 1c | `CombatService.cs` | Environmental damage |
| 1d | `Player.cs` | Add BiomeProgress |
| 1d | `RoomGeneratorService.cs` | Transition generation |
| 1d | `Codex integration` | Biome entries |

---

## Final Metrics

| Metric | Before v0.1.2 | After v0.1.2 |
|--------|---------------|--------------|
| Biomes | 0 | 6 |
| Biome descriptors | 0 | 6 types per biome |
| Spawn tables | Global | Per-biome pools |
| Hazard types | 0 | 5+ per biome |
| Damage modifiers | None | Per-biome elemental |
| Transition types | None | 4 styles |
| Biome progress | None | Full tracking |
| Unit tests (biome) | 0 | ~100 |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.1.2a Design Spec** - Create biome system specification
3. **Implement v0.1.2a** - Build core biome infrastructure
4. **v0.1.2b Design Spec** - Create spawn table specification
5. **Implement v0.1.2b** - Build content pools
6. **v0.1.2c Design Spec** - Create hazard specification
7. **Implement v0.1.2c** - Build hazard system
8. **v0.1.2d Design Spec** - Create transition specification
9. **Implement v0.1.2d** - Build transitions and discovery

---

*This scope breakdown establishes a comprehensive biome theming system. Core biome definitions provide environmental identity, content pools create distinct creature and loot experiences, hazards add tactical depth, and transitions ensure smooth exploration flow. Together, these features transform the dungeon into a diverse, thematic world with distinct zones to discover and master.*
