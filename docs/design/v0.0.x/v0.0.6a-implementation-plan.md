# v0.0.6a Implementation Plan: Multi-Monster Combat Foundation

**Version:** 0.0.6a
**Parent:** v0.0.6 (Enhanced Combat System)
**Prerequisites:** v0.0.5 Complete (Dice Pool System - specifically DiceService, DicePool, DiceRollResult)
**Status:** Ready for Implementation
**Target Tests:** ~198 -> ~218 (+20 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Presentation Layer](#presentation-layer)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Transform the existing single-monster combat system into a multi-monster encounter system with initiative-based turn order and explicit target selection. This phase establishes the foundational combat infrastructure that v0.0.6b-d will build upon.

### Scope

**In Scope:**
- `CombatEncounter` aggregate entity for multi-participant combat
- `Combatant` entity wrapping Player/Monster with combat state
- `InitiativeRoll` value object for dice-based initiative
- `InitiativeService` for rolling and ordering
- `TargetResolver` for target selection by name/number
- `CombatState` enum for state machine
- Updated `AttackCommand` with target parameter
- Monster numbering for duplicates
- Combat encounter rendering

**Out of Scope:**
- Monster AI (v0.0.6b)
- Flee command (v0.0.6b)
- Combat log (v0.0.6b)
- Status effects (v0.0.6c/d)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Maximum monsters per room | 5 | Keeps combat manageable, balances difficulty |
| Initiative die | 1d10 | Consistent with v0.0.5 dice system |
| Player initiative modifier | Finesse | Finesse represents agility/reflexes |
| Tie-breaker | Highest Finesse | Rewards investment in agility stat |
| Monster numbering | 1-based | Natural for player input ("attack goblin 2") |
| Combat aggregate | Separate from Room | Clean separation of concerns |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.5 (Dice Pool System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `DicePool` | `Domain/ValueObjects/DicePool.cs` | Create initiative dice pool (1d10) |
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Store initiative roll results |
| `DiceService` | `Application/Services/DiceService.cs` | Roll initiative dice |
| `DiceType` | `Domain/Enums/DiceType.cs` | D10 for initiative |

### Dependencies from v0.0.4 (Core Systems)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Player` | `Domain/Entities/Player.cs` | Combatant wrapping, attributes |
| `Monster` | `Domain/Entities/Monster.cs` | Combatant wrapping, stats |
| `Room` | `Domain/Entities/Room.cs` | Monster list access |
| `GameSession` | `Domain/Entities/GameSession.cs` | Combat state, room access |
| `CombatService` | `Domain/Services/CombatService.cs` | Attack resolution |
| `PlayerAttributes` | `Domain/ValueObjects/PlayerAttributes.cs` | Finesse for initiative |

---

## Current System Analysis

### Existing Combat Flow

**Location:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs`

**Current Flow:**
```
Player executes "attack" command
    ├── GameSessionService.TryAttack()
    │   ├── Get current room
    │   ├── Find first alive monster
    │   └── Call CombatService.ResolveCombatRound()
    │
    └── CombatService.ResolveCombatRound(player, monster)
        ├── Player attacks (static damage)
        ├── Monster counterattacks (if alive)
        └── Return CombatResult
```

**Current Limitations:**
- Only one monster can be engaged at a time
- No turn order - player always goes first
- No explicit target selection
- No round tracking
- No encounter state machine

### New Multi-Monster Combat Flow

```
Player enters room with monsters OR executes "attack"
    │
    ├── InitiativeService.CreateEncounter()
    │   ├── Roll initiative for player (1d10 + Finesse)
    │   ├── Roll initiative for each monster (1d10 + InitiativeModifier)
    │   ├── Number duplicate monster types
    │   └── Return CombatEncounter (sorted by initiative)
    │
    ├── CombatEncounter.Start()
    │   ├── Set state to Active
    │   ├── Set round to 1
    │   └── Set current turn to first combatant
    │
    └── TURN LOOP
        ├── If Player's turn:
        │   ├── Display combat state
        │   ├── Wait for command ("attack <target>")
        │   ├── TargetResolver.ResolveMonsterTarget()
        │   ├── CombatService.ResolveCombatRound()
        │   ├── encounter.CheckForResolution()
        │   └── encounter.AdvanceTurn()
        │
        ├── If Monster's turn:
        │   ├── Execute monster action (basic attack for now)
        │   ├── encounter.CheckForResolution()
        │   └── encounter.AdvanceTurn()
        │
        └── Check for end conditions
            ├── Victory: All monsters defeated
            ├── Defeat: Player defeated
            └── Continue: More turns
```

---

## Detailed Implementation

### Domain Layer

#### 1. CombatState.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/CombatState.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the current state of a combat encounter.
/// </summary>
/// <remarks>
/// <para>Combat state follows a simple state machine:</para>
/// <code>
/// NotStarted -> Active -> Victory | PlayerDefeated | Fled
/// </code>
/// <para>Transitions are managed by <see cref="Entities.CombatEncounter"/>.</para>
/// </remarks>
public enum CombatState
{
    /// <summary>
    /// Combat has not yet started (setup phase).
    /// Combatants can be added during this state.
    /// </summary>
    NotStarted,

    /// <summary>
    /// Combat is actively in progress.
    /// Turns are being processed in initiative order.
    /// </summary>
    Active,

    /// <summary>
    /// Combat ended with player victory.
    /// All monsters have been defeated.
    /// </summary>
    Victory,

    /// <summary>
    /// Combat ended with player defeat.
    /// The player's health reached zero.
    /// </summary>
    PlayerDefeated,

    /// <summary>
    /// Combat ended because player fled.
    /// Player successfully escaped to previous room.
    /// </summary>
    Fled
}
```

#### 2. InitiativeRoll.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/InitiativeRoll.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of an initiative roll used to determine turn order in combat.
/// </summary>
/// <remarks>
/// <para>Initiative determines when a combatant acts in combat turn order.</para>
/// <para>Formula: 1d10 + modifier (Finesse for players, InitiativeModifier for monsters).</para>
/// <para>Higher initiative acts first. Ties are broken by highest Finesse/InitiativeModifier.</para>
/// </remarks>
/// <param name="DiceResult">The underlying dice roll result from the DiceService.</param>
/// <param name="Modifier">The modifier applied (Finesse for players, InitiativeModifier for monsters).</param>
public readonly record struct InitiativeRoll(
    DiceRollResult DiceResult,
    int Modifier)
{
    /// <summary>
    /// Gets the total initiative value (dice roll + modifier).
    /// </summary>
    /// <remarks>
    /// This value is used for sorting turn order. Higher values act first.
    /// </remarks>
    public int Total => DiceResult.Total + Modifier;

    /// <summary>
    /// Gets the raw dice result before modifier.
    /// </summary>
    public int RollValue => DiceResult.Total;

    /// <summary>
    /// Gets whether this was a natural maximum roll (10 on d10).
    /// </summary>
    public bool IsNaturalMax => DiceResult.IsNaturalMax;

    /// <summary>
    /// Gets whether this was a natural minimum roll (1 on d10).
    /// </summary>
    public bool IsNaturalOne => DiceResult.IsNaturalOne;

    /// <summary>
    /// Creates a display string showing the initiative breakdown.
    /// </summary>
    /// <returns>A formatted string like "[8] + 3 = 11".</returns>
    /// <example>
    /// <code>
    /// var roll = new InitiativeRoll(diceResult, 3);
    /// Console.WriteLine(roll.ToDisplayString()); // "[8] + 3 = 11"
    /// </code>
    /// </example>
    public string ToDisplayString()
    {
        var modStr = Modifier >= 0 ? $"+{Modifier}" : Modifier.ToString();
        return $"[{RollValue}] {modStr} = {Total}";
    }

    /// <inheritdoc />
    public override string ToString() => ToDisplayString();
}
```

#### 3. Combatant.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Entities/Combatant.cs`

```csharp
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Wraps a Player or Monster with combat-specific state and initiative tracking.
/// </summary>
/// <remarks>
/// <para>Combatant serves as a unified interface for participants in combat,
/// abstracting whether the participant is a player or monster.</para>
/// <para>Key responsibilities:</para>
/// <list type="bullet">
/// <item>Track initiative for turn order</item>
/// <item>Track "has acted this round" state</item>
/// <item>Provide numbered display names for duplicate monsters</item>
/// <item>Delegate health checks to underlying entity</item>
/// </list>
/// </remarks>
public class Combatant : IEntity
{
    // ===== Properties =====

    /// <summary>
    /// Gets the unique identifier for this combatant instance.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the underlying Player entity, or null if this combatant is a monster.
    /// </summary>
    public Player? Player { get; private set; }

    /// <summary>
    /// Gets the underlying Monster entity, or null if this combatant is a player.
    /// </summary>
    public Monster? Monster { get; private set; }

    /// <summary>
    /// Gets the combatant's initiative roll result.
    /// </summary>
    public InitiativeRoll InitiativeRoll { get; private set; }

    /// <summary>
    /// Gets the Finesse value used for initiative tie-breaking.
    /// </summary>
    /// <remarks>
    /// For players, this is <see cref="PlayerAttributes.Finesse"/>.
    /// For monsters, this is <see cref="Monster.InitiativeModifier"/>.
    /// </remarks>
    public int Finesse { get; private set; }

    /// <summary>
    /// Gets the display name for this combatant.
    /// </summary>
    /// <remarks>
    /// For players: Player.Name (e.g., "Hero")
    /// For monsters: Monster.Name with number if duplicates (e.g., "Goblin 2")
    /// </remarks>
    public string DisplayName { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display number for this combatant (1-based, for monsters only).
    /// </summary>
    /// <remarks>
    /// Null for players. For monsters, only set when there are multiple of the same type.
    /// A value of 0 indicates a unique monster type (no numbering needed).
    /// </remarks>
    public int? DisplayNumber { get; private set; }

    /// <summary>
    /// Gets or sets whether this combatant has acted this round.
    /// </summary>
    public bool HasActedThisRound { get; private set; }

    // ===== Computed Properties =====

    /// <summary>
    /// Gets the total initiative value used for turn order sorting.
    /// </summary>
    public int Initiative => InitiativeRoll.Total;

    /// <summary>
    /// Gets whether this combatant is still active in combat (not defeated/fled).
    /// </summary>
    public bool IsActive => IsPlayer ? !Player!.IsDead : !Monster!.IsDefeated;

    /// <summary>
    /// Gets whether this combatant is the player.
    /// </summary>
    public bool IsPlayer => Player != null;

    /// <summary>
    /// Gets whether this combatant is a monster.
    /// </summary>
    public bool IsMonster => Monster != null;

    /// <summary>
    /// Gets the current health of the combatant.
    /// </summary>
    public int CurrentHealth => IsPlayer ? Player!.Health : Monster!.Health;

    /// <summary>
    /// Gets the maximum health of the combatant.
    /// </summary>
    public int MaxHealth => IsPlayer ? Player!.Stats.MaxHealth : Monster!.Stats.MaxHealth;

    /// <summary>
    /// Gets the health percentage (0.0 to 1.0) for display purposes.
    /// </summary>
    public float HealthPercentage => MaxHealth > 0 ? (float)CurrentHealth / MaxHealth : 0f;

    // ===== Constructors =====

    /// <summary>
    /// Private parameterless constructor for Entity Framework Core.
    /// </summary>
    private Combatant() { }

    // ===== Factory Methods =====

    /// <summary>
    /// Creates a combatant for a player.
    /// </summary>
    /// <param name="player">The player entity to wrap.</param>
    /// <param name="initiative">The rolled initiative result.</param>
    /// <returns>A new combatant representing the player.</returns>
    /// <exception cref="ArgumentNullException">Thrown when player is null.</exception>
    public static Combatant ForPlayer(Player player, InitiativeRoll initiative)
    {
        ArgumentNullException.ThrowIfNull(player);

        return new Combatant
        {
            Id = Guid.NewGuid(),
            Player = player,
            Monster = null,
            InitiativeRoll = initiative,
            Finesse = player.Attributes.Finesse,
            DisplayName = player.Name,
            DisplayNumber = null,
            HasActedThisRound = false
        };
    }

    /// <summary>
    /// Creates a combatant for a monster.
    /// </summary>
    /// <param name="monster">The monster entity to wrap.</param>
    /// <param name="initiative">The rolled initiative result.</param>
    /// <param name="displayNumber">The display number for duplicate monsters (0 if unique).</param>
    /// <returns>A new combatant representing the monster.</returns>
    /// <exception cref="ArgumentNullException">Thrown when monster is null.</exception>
    /// <remarks>
    /// If displayNumber is 0, the monster name is shown without a number.
    /// If displayNumber is > 0, the name includes the number (e.g., "Goblin 2").
    /// </remarks>
    public static Combatant ForMonster(Monster monster, InitiativeRoll initiative, int displayNumber)
    {
        ArgumentNullException.ThrowIfNull(monster);

        var baseName = monster.Name;
        var displayName = displayNumber > 0 ? $"{baseName} {displayNumber}" : baseName;

        return new Combatant
        {
            Id = Guid.NewGuid(),
            Player = null,
            Monster = monster,
            InitiativeRoll = initiative,
            Finesse = monster.InitiativeModifier,
            DisplayName = displayName,
            DisplayNumber = displayNumber > 0 ? displayNumber : null,
            HasActedThisRound = false
        };
    }

    // ===== Methods =====

    /// <summary>
    /// Marks this combatant as having acted this round.
    /// </summary>
    /// <remarks>
    /// Called after a combatant completes their turn action.
    /// Reset at the start of each new round.
    /// </remarks>
    public void MarkActed()
    {
        HasActedThisRound = true;
    }

    /// <summary>
    /// Resets the acted flag for a new round.
    /// </summary>
    /// <remarks>
    /// Called by <see cref="CombatEncounter"/> at the start of each new round.
    /// </remarks>
    public void ResetActed()
    {
        HasActedThisRound = false;
    }

    /// <inheritdoc />
    public override string ToString()
    {
        var status = IsActive ? $"HP: {CurrentHealth}/{MaxHealth}" : "Defeated";
        return $"{DisplayName} (Init: {Initiative}, {status})";
    }
}
```

#### 4. CombatEncounter.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Entities/CombatEncounter.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents an active combat encounter with multiple combatants.
/// </summary>
/// <remarks>
/// <para>CombatEncounter is the aggregate root for all combat-related state.
/// It tracks turn order, round progression, and combat resolution.</para>
/// <para>State transitions:</para>
/// <code>
/// NotStarted -> (Start) -> Active -> (CheckForResolution) -> Victory | PlayerDefeated
///                                 -> (EndByFlee) -> Fled
/// </code>
/// </remarks>
public class CombatEncounter : IEntity
{
    // ===== Properties =====

    /// <summary>
    /// Gets the unique identifier for this encounter.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the ID of the room where this encounter is taking place.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the ID of the room the player came from (for flee destination).
    /// </summary>
    public Guid? PreviousRoomId { get; private set; }

    /// <summary>
    /// Gets the current state of the encounter.
    /// </summary>
    public CombatState State { get; private set; } = CombatState.NotStarted;

    /// <summary>
    /// Gets the current round number (1-based).
    /// </summary>
    public int RoundNumber { get; private set; } = 0;

    /// <summary>
    /// Gets the index of the current combatant in turn order.
    /// </summary>
    public int CurrentTurnIndex { get; private set; } = 0;

    /// <summary>
    /// Gets the timestamp when combat started.
    /// </summary>
    public DateTime StartedAt { get; private set; }

    /// <summary>
    /// Gets the timestamp when combat ended (null if ongoing).
    /// </summary>
    public DateTime? EndedAt { get; private set; }

    /// <summary>
    /// All combatants participating in this encounter.
    /// </summary>
    private readonly List<Combatant> _combatants = new();

    // ===== Computed Properties =====

    /// <summary>
    /// Gets a read-only list of all combatants in turn order.
    /// </summary>
    public IReadOnlyList<Combatant> Combatants => _combatants.AsReadOnly();

    /// <summary>
    /// Gets the combatant whose turn it currently is, or null if combat not active.
    /// </summary>
    public Combatant? CurrentCombatant =>
        State == CombatState.Active && CurrentTurnIndex < _combatants.Count
            ? _combatants[CurrentTurnIndex]
            : null;

    /// <summary>
    /// Gets whether combat is currently active.
    /// </summary>
    public bool IsActive => State == CombatState.Active;

    /// <summary>
    /// Gets whether combat has ended (any terminal state).
    /// </summary>
    public bool IsEnded => State is CombatState.Victory or CombatState.PlayerDefeated or CombatState.Fled;

    /// <summary>
    /// Gets whether it is currently the player's turn.
    /// </summary>
    public bool IsPlayerTurn => CurrentCombatant?.IsPlayer ?? false;

    /// <summary>
    /// Gets the total number of combatants.
    /// </summary>
    public int CombatantCount => _combatants.Count;

    /// <summary>
    /// Gets the number of active (non-defeated) monsters.
    /// </summary>
    public int ActiveMonsterCount => _combatants.Count(c => c.IsMonster && c.IsActive);

    // ===== Private Constructor =====

    /// <summary>
    /// Private constructor for factory method pattern and EF Core.
    /// </summary>
    private CombatEncounter() { }

    // ===== Factory Methods =====

    /// <summary>
    /// Creates a new combat encounter in the NotStarted state.
    /// </summary>
    /// <param name="roomId">The ID of the room where combat occurs.</param>
    /// <param name="previousRoomId">The ID of the previous room (for flee destination).</param>
    /// <returns>A new combat encounter ready for combatants to be added.</returns>
    public static CombatEncounter Create(Guid roomId, Guid? previousRoomId = null)
    {
        return new CombatEncounter
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            PreviousRoomId = previousRoomId,
            State = CombatState.NotStarted
        };
    }

    // ===== Combatant Management =====

    /// <summary>
    /// Adds a combatant to the encounter.
    /// </summary>
    /// <param name="combatant">The combatant to add.</param>
    /// <exception cref="InvalidOperationException">Thrown if combat has already started.</exception>
    /// <exception cref="ArgumentNullException">Thrown if combatant is null.</exception>
    public void AddCombatant(Combatant combatant)
    {
        ArgumentNullException.ThrowIfNull(combatant);

        if (State != CombatState.NotStarted)
            throw new InvalidOperationException("Cannot add combatants after combat has started.");

        _combatants.Add(combatant);
    }

    // ===== State Transitions =====

    /// <summary>
    /// Starts the encounter, sorting combatants by initiative.
    /// </summary>
    /// <exception cref="InvalidOperationException">Thrown if no combatants or already started.</exception>
    /// <remarks>
    /// Combatants are sorted by initiative (descending), then by Finesse for ties.
    /// Higher values act first.
    /// </remarks>
    public void Start()
    {
        if (_combatants.Count == 0)
            throw new InvalidOperationException("Cannot start combat with no combatants.");
        if (State != CombatState.NotStarted)
            throw new InvalidOperationException("Combat has already started.");

        // Sort by initiative (descending), then by Finesse for ties (descending)
        _combatants.Sort((a, b) =>
        {
            var initiativeCompare = b.Initiative.CompareTo(a.Initiative);
            if (initiativeCompare != 0) return initiativeCompare;
            return b.Finesse.CompareTo(a.Finesse);
        });

        State = CombatState.Active;
        RoundNumber = 1;
        CurrentTurnIndex = 0;
        StartedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Advances to the next combatant's turn, potentially advancing the round.
    /// </summary>
    /// <returns>The new current combatant, or null if combat ended.</returns>
    /// <remarks>
    /// <para>Skips defeated combatants automatically.</para>
    /// <para>When all combatants have acted, advances to the next round and resets acted flags.</para>
    /// </remarks>
    public Combatant? AdvanceTurn()
    {
        if (State != CombatState.Active) return null;

        // Mark current combatant as having acted
        if (CurrentCombatant != null)
            CurrentCombatant.MarkActed();

        // Find next active combatant
        var startIndex = CurrentTurnIndex;
        do
        {
            CurrentTurnIndex++;

            // Check for round end
            if (CurrentTurnIndex >= _combatants.Count)
            {
                CurrentTurnIndex = 0;
                RoundNumber++;
                ResetActedFlags();
            }

            // Skip defeated combatants
            if (_combatants[CurrentTurnIndex].IsActive)
                return _combatants[CurrentTurnIndex];

        } while (CurrentTurnIndex != startIndex);

        // If we've looped completely with no active combatants, combat should be over
        CheckForResolution();
        return CurrentCombatant;
    }

    /// <summary>
    /// Checks if combat should end and updates state accordingly.
    /// </summary>
    /// <remarks>
    /// Call this after any action that could defeat a combatant.
    /// </remarks>
    public void CheckForResolution()
    {
        if (State != CombatState.Active) return;

        var activeMonsters = _combatants.Where(c => c.IsMonster && c.IsActive).ToList();
        var activePlayer = _combatants.FirstOrDefault(c => c.IsPlayer && c.IsActive);

        if (activePlayer == null)
        {
            State = CombatState.PlayerDefeated;
            EndedAt = DateTime.UtcNow;
        }
        else if (activeMonsters.Count == 0)
        {
            State = CombatState.Victory;
            EndedAt = DateTime.UtcNow;
        }
    }

    /// <summary>
    /// Ends combat due to player fleeing.
    /// </summary>
    /// <remarks>
    /// Only valid when combat is Active.
    /// </remarks>
    public void EndByFlee()
    {
        if (State != CombatState.Active) return;
        State = CombatState.Fled;
        EndedAt = DateTime.UtcNow;
    }

    // ===== Monster Targeting =====

    /// <summary>
    /// Gets all active (non-defeated) monsters in the encounter.
    /// </summary>
    /// <returns>An enumerable of active monster combatants.</returns>
    public IEnumerable<Combatant> GetActiveMonsters() =>
        _combatants.Where(c => c.IsMonster && c.IsActive);

    /// <summary>
    /// Gets a monster by its display number (1-based indexing).
    /// </summary>
    /// <param name="number">The 1-based display number.</param>
    /// <returns>The monster combatant, or null if not found.</returns>
    /// <remarks>
    /// Numbers are based on the order of active monsters, not their display numbers.
    /// </remarks>
    public Combatant? GetMonsterByNumber(int number)
    {
        if (number < 1) return null;
        return GetActiveMonsters().ElementAtOrDefault(number - 1);
    }

    /// <summary>
    /// Gets all monsters matching a name (case-insensitive partial match).
    /// </summary>
    /// <param name="name">The name or partial name to match.</param>
    /// <returns>Enumerable of matching monster combatants.</returns>
    public IEnumerable<Combatant> GetMonstersByName(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return Enumerable.Empty<Combatant>();

        return GetActiveMonsters().Where(c =>
            c.DisplayName.Contains(name, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Gets the player combatant.
    /// </summary>
    /// <returns>The player combatant, or null if not found.</returns>
    public Combatant? GetPlayerCombatant() =>
        _combatants.FirstOrDefault(c => c.IsPlayer);

    // ===== Private Helpers =====

    /// <summary>
    /// Resets the "has acted" flag for all active combatants.
    /// </summary>
    private void ResetActedFlags()
    {
        foreach (var combatant in _combatants.Where(c => c.IsActive))
            combatant.ResetActed();
    }

    /// <inheritdoc />
    public override string ToString() =>
        $"Encounter (Round {RoundNumber}, {State}, {ActiveMonsterCount} monsters active)";
}
```

#### 5. Update Monster.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Monster.cs`

```csharp
// Add to existing Monster entity after the Stats property:

/// <summary>
/// Gets the initiative modifier for combat turn order.
/// </summary>
/// <remarks>
/// Higher values mean the monster acts earlier in combat.
/// Typically based on creature agility/reflexes.
/// Default is 0 for average creatures.
/// </remarks>
public int InitiativeModifier { get; private set; } = 0;

/// <summary>
/// Gets the definition ID this monster was created from.
/// </summary>
/// <remarks>
/// Used for grouping duplicate monsters and loading configuration.
/// Null for dynamically created monsters.
/// </remarks>
public string? MonsterDefinitionId { get; private set; }

// Update the constructor to accept initiative modifier:
public Monster(string name, string description, int maxHealth, Stats stats, int initiativeModifier = 0, string? monsterDefinitionId = null)
{
    Id = Guid.NewGuid();
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Description = description ?? throw new ArgumentNullException(nameof(description));
    MaxHealth = maxHealth > 0 ? maxHealth : throw new ArgumentOutOfRangeException(nameof(maxHealth));
    Health = maxHealth;
    Stats = stats;
    InitiativeModifier = initiativeModifier;
    MonsterDefinitionId = monsterDefinitionId;
}

// Update factory method:
/// <summary>
/// Factory method to create a basic goblin enemy.
/// </summary>
/// <returns>A new goblin monster with initiative modifier +1.</returns>
public static Monster CreateGoblin() => new(
    "Goblin",
    "A small, green creature with sharp teeth and beady eyes. It looks hostile.",
    30,
    new Stats(30, 8, 2),
    initiativeModifier: 1,
    monsterDefinitionId: "goblin"
);

// Add additional factory methods for variety:
/// <summary>
/// Factory method to create a skeleton enemy.
/// </summary>
/// <returns>A new skeleton monster with initiative modifier 0.</returns>
public static Monster CreateSkeleton() => new(
    "Skeleton",
    "An animated pile of bones held together by dark magic.",
    25,
    new Stats(25, 6, 3),
    initiativeModifier: 0,
    monsterDefinitionId: "skeleton"
);

/// <summary>
/// Factory method to create an orc enemy.
/// </summary>
/// <returns>A new orc monster with initiative modifier -1 (slower but stronger).</returns>
public static Monster CreateOrc() => new(
    "Orc",
    "A large, brutish creature with green skin and tusks. It wields a crude axe.",
    45,
    new Stats(45, 12, 4),
    initiativeModifier: -1,
    monsterDefinitionId: "orc"
);
```

#### 6. Update GameSession.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/GameSession.cs`

```csharp
// Add to existing GameSession entity after LastPlayedAt property:

/// <summary>
/// Gets the currently active combat encounter, if any.
/// </summary>
public CombatEncounter? ActiveEncounter { get; private set; }

/// <summary>
/// Gets whether the player is currently in combat.
/// </summary>
public bool IsInCombat => ActiveEncounter?.State == CombatState.Active;

/// <summary>
/// Gets the ID of the room the player was in before entering the current room.
/// </summary>
/// <remarks>
/// Used for flee destination in combat.
/// </remarks>
public Guid? PreviousRoomId { get; private set; }

// Add new methods:

/// <summary>
/// Starts a combat encounter.
/// </summary>
/// <param name="encounter">The encounter to start.</param>
/// <exception cref="InvalidOperationException">Thrown if already in combat.</exception>
/// <exception cref="ArgumentNullException">Thrown if encounter is null.</exception>
public void StartCombat(CombatEncounter encounter)
{
    ArgumentNullException.ThrowIfNull(encounter);

    if (ActiveEncounter?.State == CombatState.Active)
        throw new InvalidOperationException("Already in combat.");

    ActiveEncounter = encounter;
}

/// <summary>
/// Ends the current combat encounter.
/// </summary>
/// <remarks>
/// Call this after combat resolves (victory, defeat, or flee).
/// </remarks>
public void EndCombat()
{
    ActiveEncounter = null;
}

// Update TryMovePlayer to track previous room:
/// <summary>
/// Attempts to move the player in the specified direction.
/// </summary>
/// <param name="direction">The direction to move (North, South, East, or West).</param>
/// <returns>
/// <c>true</c> if the move was successful; <c>false</c> if there is no exit
/// in that direction or the current room cannot be found.
/// </returns>
public bool TryMovePlayer(Direction direction)
{
    var currentRoom = CurrentRoom;
    if (currentRoom == null)
        return false;

    var nextRoomId = currentRoom.GetExit(direction);
    if (nextRoomId == null)
        return false;

    // Track previous room for flee mechanic
    PreviousRoomId = CurrentRoomId;

    CurrentRoomId = nextRoomId.Value;
    var nextRoom = CurrentRoom;
    if (nextRoom != null)
    {
        Player.MoveTo(nextRoom.Position);
    }

    UpdateLastPlayed();
    return true;
}
```

### Application Layer

#### 7. InitiativeService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/InitiativeService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for rolling and managing combat initiative.
/// </summary>
/// <remarks>
/// <para>Initiative determines turn order in combat. Higher initiative acts first.</para>
/// <para>Formula: 1d10 + modifier (Finesse for players, InitiativeModifier for monsters).</para>
/// <para>Ties are broken by highest Finesse/InitiativeModifier value.</para>
/// </remarks>
public class InitiativeService
{
    private readonly DiceService _diceService;
    private readonly ILogger<InitiativeService> _logger;

    /// <summary>
    /// Creates a new InitiativeService instance.
    /// </summary>
    /// <param name="diceService">The dice service for rolling initiative.</param>
    /// <param name="logger">The logger for diagnostics.</param>
    /// <exception cref="ArgumentNullException">Thrown if diceService or logger is null.</exception>
    public InitiativeService(DiceService diceService, ILogger<InitiativeService> logger)
    {
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogDebug("InitiativeService initialized");
    }

    /// <summary>
    /// Rolls initiative for a player.
    /// </summary>
    /// <param name="player">The player to roll for.</param>
    /// <returns>The initiative roll result.</returns>
    /// <exception cref="ArgumentNullException">Thrown if player is null.</exception>
    public InitiativeRoll RollForPlayer(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var pool = DicePool.D10(); // 1d10 for initiative
        var result = _diceService.Roll(pool);
        var modifier = player.Attributes.Finesse;

        var initiative = new InitiativeRoll(result, modifier);

        _logger.LogDebug(
            "Player {Name} rolls initiative: {Roll}",
            player.Name, initiative.ToDisplayString());

        return initiative;
    }

    /// <summary>
    /// Rolls initiative for a monster.
    /// </summary>
    /// <param name="monster">The monster to roll for.</param>
    /// <returns>The initiative roll result.</returns>
    /// <exception cref="ArgumentNullException">Thrown if monster is null.</exception>
    public InitiativeRoll RollForMonster(Monster monster)
    {
        ArgumentNullException.ThrowIfNull(monster);

        var pool = DicePool.D10(); // 1d10 for initiative
        var result = _diceService.Roll(pool);
        var modifier = monster.InitiativeModifier;

        var initiative = new InitiativeRoll(result, modifier);

        _logger.LogDebug(
            "Monster {Name} rolls initiative: {Roll}",
            monster.Name, initiative.ToDisplayString());

        return initiative;
    }

    /// <summary>
    /// Creates a fully configured combat encounter with all participants and rolled initiative.
    /// </summary>
    /// <param name="player">The player entering combat.</param>
    /// <param name="monsters">The monsters in the room.</param>
    /// <param name="roomId">The room where combat occurs.</param>
    /// <param name="previousRoomId">The room the player came from (for flee destination).</param>
    /// <returns>A combat encounter with all combatants added and initiative rolled.</returns>
    /// <exception cref="ArgumentNullException">Thrown if player or monsters is null.</exception>
    /// <remarks>
    /// <para>Monsters of the same type are automatically numbered (e.g., "Goblin 1", "Goblin 2").</para>
    /// <para>Unique monster types are not numbered.</para>
    /// <para>The encounter is returned in NotStarted state - call Start() to begin.</para>
    /// </remarks>
    public CombatEncounter CreateEncounter(
        Player player,
        IEnumerable<Monster> monsters,
        Guid roomId,
        Guid? previousRoomId)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(monsters);

        var encounter = CombatEncounter.Create(roomId, previousRoomId);

        // Add player with rolled initiative
        var playerInitiative = RollForPlayer(player);
        encounter.AddCombatant(Combatant.ForPlayer(player, playerInitiative));

        // Count monsters by type for numbering
        var monsterList = monsters.ToList();
        var typeCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        var typeOccurrences = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        // First pass: count occurrences of each type
        foreach (var monster in monsterList)
        {
            var typeKey = monster.MonsterDefinitionId ?? monster.Name;
            typeCounts.TryGetValue(typeKey, out var count);
            typeCounts[typeKey] = count + 1;
        }

        // Second pass: add monsters with appropriate numbering
        foreach (var monster in monsterList)
        {
            var typeKey = monster.MonsterDefinitionId ?? monster.Name;
            typeOccurrences.TryGetValue(typeKey, out var occurrence);
            occurrence++;
            typeOccurrences[typeKey] = occurrence;

            var monsterInitiative = RollForMonster(monster);

            // Only number if there are multiple of this type
            var displayNumber = typeCounts[typeKey] > 1 ? occurrence : 0;

            encounter.AddCombatant(Combatant.ForMonster(monster, monsterInitiative, displayNumber));
        }

        _logger.LogInformation(
            "Created combat encounter with {PlayerCount} player and {MonsterCount} monsters in room {RoomId}",
            1, monsterList.Count, roomId);

        return encounter;
    }
}
```

#### 8. TargetResolver.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/TargetResolver.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Resolves target specifications to actual combatants in combat.
/// </summary>
/// <remarks>
/// <para>Supports multiple targeting formats:</para>
/// <list type="bullet">
/// <item>Empty/null: Target first active monster</item>
/// <item>Number only: Target monster by position (1-based)</item>
/// <item>Name only: Target first monster matching name</item>
/// <item>Name + Number: Target specific monster of that type</item>
/// </list>
/// </remarks>
public class TargetResolver
{
    private readonly ILogger<TargetResolver> _logger;

    /// <summary>
    /// Creates a new TargetResolver instance.
    /// </summary>
    /// <param name="logger">The logger for diagnostics.</param>
    public TargetResolver(ILogger<TargetResolver> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Result of target resolution.
    /// </summary>
    /// <param name="Target">The resolved target, or null if not found.</param>
    /// <param name="IsAmbiguous">True if multiple targets matched (returned first).</param>
    /// <param name="ErrorMessage">Error message if target not found.</param>
    public record TargetResolutionResult(
        Combatant? Target,
        bool IsAmbiguous = false,
        string? ErrorMessage = null)
    {
        /// <summary>
        /// Gets whether the resolution was successful.
        /// </summary>
        public bool Success => Target != null;

        /// <summary>
        /// Creates a successful result.
        /// </summary>
        public static TargetResolutionResult Found(Combatant target, bool isAmbiguous = false) =>
            new(target, isAmbiguous);

        /// <summary>
        /// Creates a not-found result.
        /// </summary>
        public static TargetResolutionResult NotFound(string errorMessage) =>
            new(null, false, errorMessage);
    }

    /// <summary>
    /// Resolves a target specification to a monster combatant.
    /// </summary>
    /// <param name="encounter">The active combat encounter.</param>
    /// <param name="targetSpec">The target specification (name, number, or name+number).</param>
    /// <returns>The resolution result containing the target or error information.</returns>
    /// <exception cref="ArgumentNullException">Thrown if encounter is null.</exception>
    public TargetResolutionResult ResolveMonsterTarget(CombatEncounter encounter, string? targetSpec)
    {
        ArgumentNullException.ThrowIfNull(encounter);

        var activeMonsters = encounter.GetActiveMonsters().ToList();

        if (activeMonsters.Count == 0)
        {
            _logger.LogDebug("No active monsters in encounter");
            return TargetResolutionResult.NotFound("There are no enemies to attack.");
        }

        // No target specified - return first monster
        if (string.IsNullOrWhiteSpace(targetSpec))
        {
            _logger.LogDebug("No target specified, returning first active monster: {Name}",
                activeMonsters[0].DisplayName);
            return TargetResolutionResult.Found(activeMonsters[0]);
        }

        targetSpec = targetSpec.Trim();

        // Try parsing as number only ("attack 2")
        if (int.TryParse(targetSpec, out var number))
        {
            var target = encounter.GetMonsterByNumber(number);
            if (target != null)
            {
                _logger.LogDebug("Resolved number {Number} to {Name}", number, target.DisplayName);
                return TargetResolutionResult.Found(target);
            }
            else
            {
                _logger.LogDebug("No monster at position {Number}", number);
                return TargetResolutionResult.NotFound($"There is no enemy #{number}.");
            }
        }

        // Try parsing as "name number" ("attack goblin 2")
        var parts = targetSpec.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length >= 2 && int.TryParse(parts[^1], out var nameNumber))
        {
            var name = string.Join(' ', parts[..^1]);
            var matchingMonsters = encounter.GetMonstersByName(name).ToList();

            if (matchingMonsters.Count == 0)
            {
                _logger.LogDebug("No monsters matching name '{Name}'", name);
                return TargetResolutionResult.NotFound($"There is no enemy named '{name}'.");
            }

            var target = matchingMonsters.ElementAtOrDefault(nameNumber - 1);
            if (target != null)
            {
                _logger.LogDebug("Resolved '{Name} {Number}' to {DisplayName}",
                    name, nameNumber, target.DisplayName);
                return TargetResolutionResult.Found(target);
            }
            else
            {
                _logger.LogDebug("No {Name} #{Number}", name, nameNumber);
                return TargetResolutionResult.NotFound($"There is no {name} #{nameNumber}.");
            }
        }

        // Try matching by name only ("attack goblin")
        var byName = encounter.GetMonstersByName(targetSpec).ToList();
        if (byName.Count == 1)
        {
            _logger.LogDebug("Resolved name '{Name}' to {DisplayName}",
                targetSpec, byName[0].DisplayName);
            return TargetResolutionResult.Found(byName[0]);
        }
        else if (byName.Count > 1)
        {
            // Ambiguous - return first match but mark as ambiguous
            _logger.LogDebug("Ambiguous target '{Name}' matched {Count} monsters, using first",
                targetSpec, byName.Count);
            return TargetResolutionResult.Found(byName[0], isAmbiguous: true);
        }

        _logger.LogDebug("No match for target specification '{TargetSpec}'", targetSpec);
        return TargetResolutionResult.NotFound($"No enemy matches '{targetSpec}'.");
    }

    /// <summary>
    /// Gets a formatted list of valid targets for display.
    /// </summary>
    /// <param name="encounter">The active combat encounter.</param>
    /// <returns>List of target descriptions.</returns>
    public IReadOnlyList<string> GetValidTargets(CombatEncounter encounter)
    {
        ArgumentNullException.ThrowIfNull(encounter);

        var monsters = encounter.GetActiveMonsters().ToList();
        var targets = new List<string>();

        for (var i = 0; i < monsters.Count; i++)
        {
            var m = monsters[i];
            var healthColor = m.HealthPercentage > 0.5f ? "green" :
                              m.HealthPercentage > 0.25f ? "yellow" : "red";
            targets.Add($"[{i + 1}] {m.DisplayName} ({m.CurrentHealth}/{m.MaxHealth} HP)");
        }

        return targets.AsReadOnly();
    }
}
```

#### 9. CombatDtos.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/DTOs/CombatDtos.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying initiative roll results.
/// </summary>
/// <param name="Name">The combatant's display name.</param>
/// <param name="RollValue">The dice roll value (before modifier).</param>
/// <param name="Modifier">The initiative modifier applied.</param>
/// <param name="Total">The total initiative value.</param>
/// <param name="IsPlayer">Whether this is the player.</param>
public record CombatantInitiativeDto(
    string Name,
    int RollValue,
    int Modifier,
    int Total,
    bool IsPlayer)
{
    /// <summary>
    /// Creates a DTO from a Combatant.
    /// </summary>
    public static CombatantInitiativeDto FromCombatant(Combatant combatant)
    {
        ArgumentNullException.ThrowIfNull(combatant);
        return new CombatantInitiativeDto(
            combatant.DisplayName,
            combatant.InitiativeRoll.RollValue,
            combatant.InitiativeRoll.Modifier,
            combatant.Initiative,
            combatant.IsPlayer);
    }
}

/// <summary>
/// DTO for turn order display.
/// </summary>
/// <param name="Name">The combatant's display name.</param>
/// <param name="Initiative">The combatant's total initiative.</param>
/// <param name="IsCurrentTurn">Whether this combatant has the current turn.</param>
/// <param name="IsPlayer">Whether this is the player.</param>
/// <param name="IsDefeated">Whether this combatant is defeated.</param>
public record TurnOrderEntryDto(
    string Name,
    int Initiative,
    bool IsCurrentTurn,
    bool IsPlayer,
    bool IsDefeated)
{
    /// <summary>
    /// Creates a DTO from a Combatant.
    /// </summary>
    public static TurnOrderEntryDto FromCombatant(Combatant combatant, bool isCurrentTurn)
    {
        ArgumentNullException.ThrowIfNull(combatant);
        return new TurnOrderEntryDto(
            combatant.DisplayName,
            combatant.Initiative,
            isCurrentTurn,
            combatant.IsPlayer,
            !combatant.IsActive);
    }
}

/// <summary>
/// DTO for enemy status display in targeting.
/// </summary>
/// <param name="Number">The 1-based targeting number.</param>
/// <param name="DisplayName">The enemy's display name.</param>
/// <param name="CurrentHealth">Current health points.</param>
/// <param name="MaxHealth">Maximum health points.</param>
/// <param name="IsDefeated">Whether the enemy is defeated.</param>
public record EnemyStatusDto(
    int Number,
    string DisplayName,
    int CurrentHealth,
    int MaxHealth,
    bool IsDefeated)
{
    /// <summary>
    /// Creates a DTO from a Combatant.
    /// </summary>
    public static EnemyStatusDto FromCombatant(Combatant combatant, int number)
    {
        ArgumentNullException.ThrowIfNull(combatant);
        return new EnemyStatusDto(
            number,
            combatant.DisplayName,
            combatant.CurrentHealth,
            combatant.MaxHealth,
            !combatant.IsActive);
    }
}

/// <summary>
/// DTO for current combat state display.
/// </summary>
/// <param name="RoundNumber">The current round number.</param>
/// <param name="TurnOrder">Ordered list of combatants by initiative.</param>
/// <param name="CurrentTurnIndex">Index of current turn in TurnOrder.</param>
/// <param name="Enemies">List of enemies with targeting info.</param>
/// <param name="IsPlayerTurn">Whether it is the player's turn.</param>
public record CombatStateDto(
    int RoundNumber,
    IReadOnlyList<TurnOrderEntryDto> TurnOrder,
    int CurrentTurnIndex,
    IReadOnlyList<EnemyStatusDto> Enemies,
    bool IsPlayerTurn)
{
    /// <summary>
    /// Creates a DTO from a CombatEncounter.
    /// </summary>
    public static CombatStateDto FromEncounter(CombatEncounter encounter)
    {
        ArgumentNullException.ThrowIfNull(encounter);

        var turnOrder = encounter.Combatants
            .Select((c, i) => TurnOrderEntryDto.FromCombatant(c, i == encounter.CurrentTurnIndex))
            .ToList();

        var enemies = encounter.GetActiveMonsters()
            .Select((c, i) => EnemyStatusDto.FromCombatant(c, i + 1))
            .ToList();

        return new CombatStateDto(
            encounter.RoundNumber,
            turnOrder,
            encounter.CurrentTurnIndex,
            enemies,
            encounter.IsPlayerTurn);
    }
}

/// <summary>
/// DTO for combat end result display.
/// </summary>
/// <param name="EndState">The final combat state.</param>
/// <param name="RoundsElapsed">Total rounds of combat.</param>
/// <param name="MonstersDefeated">Number of monsters defeated.</param>
public record CombatEndDto(
    CombatState EndState,
    int RoundsElapsed,
    int MonstersDefeated)
{
    /// <summary>
    /// Creates a DTO from a CombatEncounter.
    /// </summary>
    public static CombatEndDto FromEncounter(CombatEncounter encounter)
    {
        ArgumentNullException.ThrowIfNull(encounter);
        return new CombatEndDto(
            encounter.State,
            encounter.RoundNumber,
            encounter.Combatants.Count(c => c.IsMonster && !c.IsActive));
    }
}

/// <summary>
/// DTO for combat action result.
/// </summary>
public record CombatActionResultDto(
    bool Success,
    string Message,
    int? DamageDealt = null,
    int? DamageReceived = null,
    bool TargetDefeated = false,
    string? TargetName = null,
    bool CombatEnded = false,
    bool CombatVictory = false,
    bool PlayerDefeated = false)
{
    /// <summary>
    /// Creates a failure result.
    /// </summary>
    public static CombatActionResultDto Failure(string message) =>
        new(false, message);

    /// <summary>
    /// Creates a success result.
    /// </summary>
    public static CombatActionResultDto Success(string message) =>
        new(true, message);
}
```

#### 10. Update IGameRenderer.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs`

```csharp
// Add to existing interface:

/// <summary>
/// Renders combat initiative results.
/// </summary>
/// <param name="initiatives">The initiative rolls for all combatants.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderInitiativeAsync(IReadOnlyList<CombatantInitiativeDto> initiatives, CancellationToken ct = default);

/// <summary>
/// Renders the current combat state (turn order, current turn, enemies).
/// </summary>
/// <param name="combatState">The current combat state.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatStateAsync(CombatStateDto combatState, CancellationToken ct = default);

/// <summary>
/// Renders combat start notification.
/// </summary>
/// <param name="monsterCount">Number of enemies.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatStartAsync(int monsterCount, CancellationToken ct = default);

/// <summary>
/// Renders combat end notification.
/// </summary>
/// <param name="result">The combat result (victory, defeat, fled).</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatEndAsync(CombatEndDto result, CancellationToken ct = default);
```

### Presentation Layer

#### 11. Update SpectreGameRenderer.cs (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

```csharp
// Add implementations for new combat rendering methods:

/// <inheritdoc />
public Task RenderCombatStartAsync(int monsterCount, CancellationToken ct = default)
{
    var plural = monsterCount == 1 ? "enemy" : "enemies";
    var panel = new Panel($"[red bold]COMBAT STARTED![/]\n\nYou face [yellow]{monsterCount}[/] {plural}!")
        .Header("[red]! COMBAT ![/]")
        .Border(BoxBorder.Double)
        .BorderColor(Color.Red);

    AnsiConsole.Write(panel);
    AnsiConsole.WriteLine();
    return Task.CompletedTask;
}

/// <inheritdoc />
public Task RenderInitiativeAsync(IReadOnlyList<CombatantInitiativeDto> initiatives, CancellationToken ct = default)
{
    var table = new Table()
        .Border(TableBorder.Rounded)
        .BorderColor(Color.Yellow)
        .AddColumn("[yellow]Combatant[/]")
        .AddColumn("[yellow]Roll[/]")
        .AddColumn("[yellow]Mod[/]")
        .AddColumn("[yellow]Total[/]");

    foreach (var init in initiatives.OrderByDescending(i => i.Total))
    {
        var color = init.IsPlayer ? "green" : "red";
        var modStr = init.Modifier >= 0 ? $"+{init.Modifier}" : init.Modifier.ToString();

        table.AddRow(
            $"[{color}]{init.Name}[/]",
            $"[white]{init.RollValue}[/]",
            $"[grey]{modStr}[/]",
            $"[white bold]{init.Total}[/]");
    }

    AnsiConsole.MarkupLine("[yellow]Rolling Initiative...[/]");
    AnsiConsole.Write(table);
    AnsiConsole.WriteLine();
    return Task.CompletedTask;
}

/// <inheritdoc />
public Task RenderCombatStateAsync(CombatStateDto state, CancellationToken ct = default)
{
    // Header
    var rule = new Rule($"[yellow]COMBAT - Round {state.RoundNumber}[/]")
        .RuleStyle("yellow");
    AnsiConsole.Write(rule);

    // Turn order
    AnsiConsole.MarkupLine("[grey]Turn Order:[/]");
    foreach (var (entry, index) in state.TurnOrder.Select((e, i) => (e, i)))
    {
        var marker = entry.IsCurrentTurn ? "[yellow]►[/]" : " ";
        var color = entry.IsPlayer ? "green" : "red";
        var status = entry.IsDefeated ? " [grey](defeated)[/]" : "";
        var initiative = $"[grey]({entry.Initiative})[/]";
        AnsiConsole.MarkupLine($"  {marker} [{color}]{entry.Name}[/] {initiative}{status}");
    }

    // Enemies list (only on player's turn)
    if (state.IsPlayerTurn)
    {
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[grey]Enemies:[/]");
        foreach (var enemy in state.Enemies.Where(e => !e.IsDefeated))
        {
            var healthPct = (float)enemy.CurrentHealth / enemy.MaxHealth;
            var healthColor = healthPct > 0.5f ? "green" : healthPct > 0.25f ? "yellow" : "red";
            AnsiConsole.MarkupLine(
                $"  [cyan][[{enemy.Number}]][/] {enemy.DisplayName} - [{healthColor}]{enemy.CurrentHealth}/{enemy.MaxHealth} HP[/]");
        }
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[grey]Your turn! (attack <target> or attack <number>)[/]");
    }

    AnsiConsole.WriteLine();
    return Task.CompletedTask;
}

/// <inheritdoc />
public Task RenderCombatEndAsync(CombatEndDto result, CancellationToken ct = default)
{
    var (message, color) = result.EndState switch
    {
        CombatState.Victory => ($"[green bold]VICTORY![/]\n\nYou defeated [yellow]{result.MonstersDefeated}[/] enemies in [yellow]{result.RoundsElapsed}[/] rounds!", Color.Green),
        CombatState.PlayerDefeated => ("[red bold]DEFEAT![/]\n\nYou have fallen in battle...", Color.Red),
        CombatState.Fled => ("[yellow bold]ESCAPED![/]\n\nYou fled from combat!", Color.Yellow),
        _ => ("Combat ended.", Color.White)
    };

    var panel = new Panel(message)
        .Header($"[{color}]Combat Result[/]")
        .Border(BoxBorder.Double)
        .BorderColor(color);

    AnsiConsole.Write(panel);
    AnsiConsole.WriteLine();
    return Task.CompletedTask;
}
```

---

## Flow Diagrams

### Combat Encounter Creation Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    COMBAT ENCOUNTER CREATION FLOW                            │
└─────────────────────────────────────────────────────────────────────────────┘

    Player attacks or enters room with monsters
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 1: GATHER COMBATANTS                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  • Get player from GameSession                                               │
│  • Get alive monsters from current room (max 5)                             │
│  • Get previousRoomId for flee destination                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 2: ROLL INITIATIVE                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  For Player:                                                                 │
│    Roll: 1d10 + Finesse                                                     │
│    Example: [7] + 14 = 21                                                   │
│                                                                              │
│  For each Monster:                                                           │
│    Roll: 1d10 + InitiativeModifier                                          │
│    Example (Goblin): [5] + 1 = 6                                            │
│    Example (Orc): [9] + (-1) = 8                                            │
└─────────────────────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 3: NUMBER DUPLICATE MONSTERS                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  Count monsters by MonsterDefinitionId or Name:                             │
│    { "goblin": 2, "orc": 1 }                                                │
│                                                                              │
│  Assign display numbers:                                                    │
│    - Goblin 1 (first goblin)                                                │
│    - Goblin 2 (second goblin)                                               │
│    - Orc (unique, no number)                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 4: SORT AND START                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│  Sort combatants by:                                                         │
│    1. Initiative (descending)                                               │
│    2. Finesse tie-breaker (descending)                                      │
│                                                                              │
│  Result:                                                                    │
│    1. Hero (21 initiative, 14 Finesse)                                      │
│    2. Orc (8 initiative, -1 Finesse)                                        │
│    3. Goblin 1 (6 initiative, 1 Finesse)                                    │
│    4. Goblin 2 (4 initiative, 1 Finesse)                                    │
│                                                                              │
│  Set RoundNumber = 1, CurrentTurnIndex = 0                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Target Resolution Flow

```
                         ┌─────────────────┐
                         │   targetSpec    │
                         │   (user input)  │
                         └────────┬────────┘
                                  │
                    ┌─────────────┼─────────────┐
                    │             │             │
                    ▼             ▼             ▼
             ┌───────────┐ ┌───────────┐ ┌───────────┐
             │  Empty    │ │  Number   │ │  Name     │
             │  ""       │ │  "2"      │ │  "goblin" │
             └─────┬─────┘ └─────┬─────┘ └─────┬─────┘
                   │             │             │
                   ▼             ▼             ▼
            [First active] [Monster #2] [Name match]
                   │             │             │
                   │             │     ┌───────┴───────┐
                   │             │     │               │
                   │             │     ▼               ▼
                   │             │  [Single]      [Multiple]
                   │             │  [Return]      [Return first]
                   │             │                [Mark ambiguous]
                   │             │
                   ▼             ▼
            ┌─────────────────────────────────────────────┐
            │              Return Result                   │
            │  { Target, IsAmbiguous, ErrorMessage }       │
            └─────────────────────────────────────────────┘
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Enums/
│   │   └── CombatStateTests.cs                  (3 tests)
│   ├── ValueObjects/
│   │   └── InitiativeRollTests.cs               (4 tests)
│   ├── Entities/
│   │   ├── CombatantTests.cs                    (6 tests)
│   │   └── CombatEncounterTests.cs              (10 tests)
├── RuneAndRust.Application.UnitTests/
│   └── Services/
│       ├── InitiativeServiceTests.cs            (5 tests)
│       └── TargetResolverTests.cs               (6 tests)
```

### Test Files

#### 1. CombatStateTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/Enums/CombatStateTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.UnitTests.Enums;

[TestFixture]
public class CombatStateTests
{
    [Test]
    public void CombatState_ContainsAllExpectedValues()
    {
        var values = Enum.GetValues<CombatState>();

        values.Should().Contain(CombatState.NotStarted);
        values.Should().Contain(CombatState.Active);
        values.Should().Contain(CombatState.Victory);
        values.Should().Contain(CombatState.PlayerDefeated);
        values.Should().Contain(CombatState.Fled);
    }

    [Test]
    public void CombatState_NotStarted_IsDefaultValue()
    {
        var defaultState = default(CombatState);
        defaultState.Should().Be(CombatState.NotStarted);
    }

    [Test]
    public void CombatState_CanBeCompared()
    {
        var state1 = CombatState.Active;
        var state2 = CombatState.Active;

        state1.Should().Be(state2);
    }
}
```

#### 2. InitiativeRollTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/InitiativeRollTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class InitiativeRollTests
{
    [Test]
    public void Total_ReturnsRollPlusModifier()
    {
        // Arrange
        var diceResult = CreateDiceResult(7);
        var modifier = 3;

        // Act
        var initiative = new InitiativeRoll(diceResult, modifier);

        // Assert
        initiative.Total.Should().Be(10);
    }

    [Test]
    public void Total_WithNegativeModifier_CalculatesCorrectly()
    {
        var diceResult = CreateDiceResult(5);
        var modifier = -2;

        var initiative = new InitiativeRoll(diceResult, modifier);

        initiative.Total.Should().Be(3);
    }

    [Test]
    public void ToDisplayString_FormatsCorrectly()
    {
        var diceResult = CreateDiceResult(8);
        var modifier = 3;

        var initiative = new InitiativeRoll(diceResult, modifier);

        initiative.ToDisplayString().Should().Be("[8] +3 = 11");
    }

    [Test]
    public void ToDisplayString_WithNegativeModifier_FormatsCorrectly()
    {
        var diceResult = CreateDiceResult(6);
        var modifier = -1;

        var initiative = new InitiativeRoll(diceResult, modifier);

        initiative.ToDisplayString().Should().Be("[6] -1 = 5");
    }

    private static DiceRollResult CreateDiceResult(int total)
    {
        return new DiceRollResult(
            DicePool.D10(),
            new[] { total },
            total);
    }
}
```

#### 3. CombatantTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/CombatantTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Entities;

[TestFixture]
public class CombatantTests
{
    [Test]
    public void ForPlayer_CreatesPlayerCombatant()
    {
        var player = new Player("Hero");
        var initiative = CreateInitiative(15);

        var combatant = Combatant.ForPlayer(player, initiative);

        combatant.IsPlayer.Should().BeTrue();
        combatant.IsMonster.Should().BeFalse();
        combatant.Player.Should().Be(player);
        combatant.DisplayName.Should().Be("Hero");
        combatant.DisplayNumber.Should().BeNull();
    }

    [Test]
    public void ForMonster_WithNumber_CreatesNumberedCombatant()
    {
        var monster = Monster.CreateGoblin();
        var initiative = CreateInitiative(8);

        var combatant = Combatant.ForMonster(monster, initiative, 2);

        combatant.IsMonster.Should().BeTrue();
        combatant.Monster.Should().Be(monster);
        combatant.DisplayName.Should().Be("Goblin 2");
        combatant.DisplayNumber.Should().Be(2);
    }

    [Test]
    public void ForMonster_WithZeroNumber_HasNoNumberInName()
    {
        var monster = Monster.CreateGoblin();
        var initiative = CreateInitiative(8);

        var combatant = Combatant.ForMonster(monster, initiative, 0);

        combatant.DisplayName.Should().Be("Goblin");
        combatant.DisplayNumber.Should().BeNull();
    }

    [Test]
    public void IsActive_ForAlivePlayer_ReturnsTrue()
    {
        var player = new Player("Hero");
        var combatant = Combatant.ForPlayer(player, CreateInitiative(10));

        combatant.IsActive.Should().BeTrue();
    }

    [Test]
    public void MarkActed_SetsHasActedThisRound()
    {
        var player = new Player("Hero");
        var combatant = Combatant.ForPlayer(player, CreateInitiative(10));

        combatant.HasActedThisRound.Should().BeFalse();
        combatant.MarkActed();
        combatant.HasActedThisRound.Should().BeTrue();
    }

    [Test]
    public void ResetActed_ClearsHasActedThisRound()
    {
        var player = new Player("Hero");
        var combatant = Combatant.ForPlayer(player, CreateInitiative(10));

        combatant.MarkActed();
        combatant.ResetActed();

        combatant.HasActedThisRound.Should().BeFalse();
    }

    private static InitiativeRoll CreateInitiative(int total)
    {
        var diceResult = new DiceRollResult(DicePool.D10(), new[] { total }, total);
        return new InitiativeRoll(diceResult, 0);
    }
}
```

#### 4. CombatEncounterTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/CombatEncounterTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Entities;

[TestFixture]
public class CombatEncounterTests
{
    [Test]
    public void Create_InitializesWithNotStartedState()
    {
        var roomId = Guid.NewGuid();

        var encounter = CombatEncounter.Create(roomId);

        encounter.State.Should().Be(CombatState.NotStarted);
        encounter.RoomId.Should().Be(roomId);
        encounter.RoundNumber.Should().Be(0);
    }

    [Test]
    public void AddCombatant_BeforeStart_Succeeds()
    {
        var encounter = CombatEncounter.Create(Guid.NewGuid());
        var player = new Player("Hero");
        var combatant = Combatant.ForPlayer(player, CreateInitiative(15));

        encounter.AddCombatant(combatant);

        encounter.Combatants.Should().HaveCount(1);
    }

    [Test]
    public void AddCombatant_AfterStart_ThrowsException()
    {
        var encounter = CreateEncounterWithPlayer();
        encounter.Start();

        var newCombatant = Combatant.ForMonster(Monster.CreateGoblin(), CreateInitiative(5), 0);

        var act = () => encounter.AddCombatant(newCombatant);

        act.Should().Throw<InvalidOperationException>();
    }

    [Test]
    public void Start_SortsCombatantsByInitiative()
    {
        var encounter = CombatEncounter.Create(Guid.NewGuid());
        var player = Combatant.ForPlayer(new Player("Hero"), CreateInitiative(10));
        var goblin = Combatant.ForMonster(Monster.CreateGoblin(), CreateInitiative(15), 0);

        encounter.AddCombatant(player);
        encounter.AddCombatant(goblin);
        encounter.Start();

        encounter.Combatants[0].Should().Be(goblin); // Higher initiative first
        encounter.Combatants[1].Should().Be(player);
    }

    [Test]
    public void Start_WithNoCombatants_ThrowsException()
    {
        var encounter = CombatEncounter.Create(Guid.NewGuid());

        var act = () => encounter.Start();

        act.Should().Throw<InvalidOperationException>();
    }

    [Test]
    public void AdvanceTurn_MovesToNextCombatant()
    {
        var encounter = CreateEncounterWithPlayerAndMonster();
        encounter.Start();

        var first = encounter.CurrentCombatant;
        encounter.AdvanceTurn();
        var second = encounter.CurrentCombatant;

        first.Should().NotBe(second);
    }

    [Test]
    public void AdvanceTurn_IncrementsRoundAtEndOfTurnOrder()
    {
        var encounter = CreateEncounterWithPlayer();
        encounter.Start();

        encounter.RoundNumber.Should().Be(1);
        encounter.AdvanceTurn(); // Back to start
        encounter.RoundNumber.Should().Be(2);
    }

    [Test]
    public void CheckForResolution_AllMonstersDefeated_SetsVictory()
    {
        var encounter = CreateEncounterWithPlayerAndMonster();
        encounter.Start();

        // Defeat the monster
        var monster = encounter.Combatants.First(c => c.IsMonster).Monster!;
        monster.TakeDamage(1000);

        encounter.CheckForResolution();

        encounter.State.Should().Be(CombatState.Victory);
    }

    [Test]
    public void GetMonsterByNumber_ReturnsCorrectMonster()
    {
        var encounter = CreateEncounterWithMultipleMonsters();
        encounter.Start();

        var first = encounter.GetMonsterByNumber(1);
        var second = encounter.GetMonsterByNumber(2);

        first.Should().NotBeNull();
        second.Should().NotBeNull();
        first.Should().NotBe(second);
    }

    [Test]
    public void GetMonstersByName_ReturnsMatchingMonsters()
    {
        var encounter = CreateEncounterWithMultipleMonsters();
        encounter.Start();

        var goblins = encounter.GetMonstersByName("goblin").ToList();

        goblins.Should().HaveCount(2);
    }

    // Helper methods
    private static CombatEncounter CreateEncounterWithPlayer()
    {
        var encounter = CombatEncounter.Create(Guid.NewGuid());
        encounter.AddCombatant(Combatant.ForPlayer(new Player("Hero"), CreateInitiative(15)));
        return encounter;
    }

    private static CombatEncounter CreateEncounterWithPlayerAndMonster()
    {
        var encounter = CombatEncounter.Create(Guid.NewGuid());
        encounter.AddCombatant(Combatant.ForPlayer(new Player("Hero"), CreateInitiative(15)));
        encounter.AddCombatant(Combatant.ForMonster(Monster.CreateGoblin(), CreateInitiative(8), 0));
        return encounter;
    }

    private static CombatEncounter CreateEncounterWithMultipleMonsters()
    {
        var encounter = CombatEncounter.Create(Guid.NewGuid());
        encounter.AddCombatant(Combatant.ForPlayer(new Player("Hero"), CreateInitiative(15)));
        encounter.AddCombatant(Combatant.ForMonster(Monster.CreateGoblin(), CreateInitiative(8), 1));
        encounter.AddCombatant(Combatant.ForMonster(Monster.CreateGoblin(), CreateInitiative(6), 2));
        return encounter;
    }

    private static InitiativeRoll CreateInitiative(int total)
    {
        var diceResult = new DiceRollResult(DicePool.D10(), new[] { total }, total);
        return new InitiativeRoll(diceResult, 0);
    }
}
```

#### 5. InitiativeServiceTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Services/InitiativeServiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class InitiativeServiceTests
{
    private InitiativeService _service = null!;
    private Mock<ILogger<InitiativeService>> _mockLogger = null!;
    private DiceService _diceService = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<InitiativeService>>();
        var diceLogger = new Mock<ILogger<DiceService>>();
        _diceService = new DiceService(diceLogger.Object);
        _service = new InitiativeService(_diceService, _mockLogger.Object);
    }

    [Test]
    public void RollForPlayer_UsesFinessAsModifier()
    {
        var player = new Player("Hero", new Stats(100, 10, 5));
        // Set Finesse via character creation
        var playerWithFinesse = new Player(
            "Hero", "human", "soldier",
            new PlayerAttributes(10, 10, 10, 10, 15), // 15 Finesse
            "");

        var result = _service.RollForPlayer(playerWithFinesse);

        result.Modifier.Should().Be(15);
        result.Total.Should().BeInRange(16, 25); // 1-10 + 15
    }

    [Test]
    public void RollForMonster_UsesInitiativeModifier()
    {
        var goblin = Monster.CreateGoblin();

        var result = _service.RollForMonster(goblin);

        result.Modifier.Should().Be(1); // Goblin has +1 initiative
        result.Total.Should().BeInRange(2, 11); // 1-10 + 1
    }

    [Test]
    public void CreateEncounter_AddsAllCombatants()
    {
        var player = new Player("Hero");
        var monsters = new[] { Monster.CreateGoblin(), Monster.CreateSkeleton() };

        var encounter = _service.CreateEncounter(player, monsters, Guid.NewGuid(), null);

        encounter.Combatants.Should().HaveCount(3); // 1 player + 2 monsters
    }

    [Test]
    public void CreateEncounter_NumbersDuplicateMonsters()
    {
        var player = new Player("Hero");
        var monsters = new[] { Monster.CreateGoblin(), Monster.CreateGoblin() };

        var encounter = _service.CreateEncounter(player, monsters, Guid.NewGuid(), null);

        var goblins = encounter.Combatants.Where(c => c.IsMonster).ToList();
        goblins.Should().Contain(c => c.DisplayName == "Goblin 1");
        goblins.Should().Contain(c => c.DisplayName == "Goblin 2");
    }

    [Test]
    public void CreateEncounter_SingleMonsterType_NoNumber()
    {
        var player = new Player("Hero");
        var monsters = new[] { Monster.CreateGoblin() };

        var encounter = _service.CreateEncounter(player, monsters, Guid.NewGuid(), null);

        var goblin = encounter.Combatants.First(c => c.IsMonster);
        goblin.DisplayName.Should().Be("Goblin");
        goblin.DisplayNumber.Should().BeNull();
    }
}
```

#### 6. TargetResolverTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Services/TargetResolverTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class TargetResolverTests
{
    private TargetResolver _resolver = null!;
    private Mock<ILogger<TargetResolver>> _mockLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<TargetResolver>>();
        _resolver = new TargetResolver(_mockLogger.Object);
    }

    [Test]
    public void ResolveTarget_EmptySpec_ReturnsFirstMonster()
    {
        var encounter = CreateEncounterWithMonsters();
        encounter.Start();

        var result = _resolver.ResolveMonsterTarget(encounter, null);

        result.Success.Should().BeTrue();
        result.Target.Should().NotBeNull();
    }

    [Test]
    public void ResolveTarget_NumberOnly_ReturnsCorrectMonster()
    {
        var encounter = CreateEncounterWithMonsters();
        encounter.Start();

        var result = _resolver.ResolveMonsterTarget(encounter, "2");

        result.Success.Should().BeTrue();
        result.Target.Should().NotBeNull();
    }

    [Test]
    public void ResolveTarget_NameOnly_ReturnsByName()
    {
        var encounter = CreateEncounterWithMonsters();
        encounter.Start();

        var result = _resolver.ResolveMonsterTarget(encounter, "orc");

        result.Success.Should().BeTrue();
        result.Target!.DisplayName.Should().Contain("Orc");
    }

    [Test]
    public void ResolveTarget_NameAndNumber_ReturnsSpecificMonster()
    {
        var encounter = CreateEncounterWithMultipleGoblins();
        encounter.Start();

        var result = _resolver.ResolveMonsterTarget(encounter, "goblin 2");

        result.Success.Should().BeTrue();
        result.Target!.DisplayName.Should().Be("Goblin 2");
    }

    [Test]
    public void ResolveTarget_PartialName_Matches()
    {
        var encounter = CreateEncounterWithMonsters();
        encounter.Start();

        var result = _resolver.ResolveMonsterTarget(encounter, "gob");

        result.Success.Should().BeTrue();
        result.Target!.DisplayName.Should().Contain("Goblin");
    }

    [Test]
    public void ResolveTarget_InvalidTarget_ReturnsNotFound()
    {
        var encounter = CreateEncounterWithMonsters();
        encounter.Start();

        var result = _resolver.ResolveMonsterTarget(encounter, "dragon");

        result.Success.Should().BeFalse();
        result.ErrorMessage.Should().NotBeNull();
    }

    // Helper methods
    private static CombatEncounter CreateEncounterWithMonsters()
    {
        var encounter = CombatEncounter.Create(Guid.NewGuid());
        encounter.AddCombatant(CreatePlayerCombatant());
        encounter.AddCombatant(CreateMonsterCombatant(Monster.CreateGoblin(), 0));
        encounter.AddCombatant(CreateMonsterCombatant(Monster.CreateOrc(), 0));
        return encounter;
    }

    private static CombatEncounter CreateEncounterWithMultipleGoblins()
    {
        var encounter = CombatEncounter.Create(Guid.NewGuid());
        encounter.AddCombatant(CreatePlayerCombatant());
        encounter.AddCombatant(CreateMonsterCombatant(Monster.CreateGoblin(), 1));
        encounter.AddCombatant(CreateMonsterCombatant(Monster.CreateGoblin(), 2));
        return encounter;
    }

    private static Combatant CreatePlayerCombatant()
    {
        return Combatant.ForPlayer(new Player("Hero"), CreateInitiative(15));
    }

    private static Combatant CreateMonsterCombatant(Monster monster, int displayNumber)
    {
        return Combatant.ForMonster(monster, CreateInitiative(8), displayNumber);
    }

    private static InitiativeRoll CreateInitiative(int total)
    {
        var diceResult = new DiceRollResult(DicePool.D10(), new[] { total }, total);
        return new InitiativeRoll(diceResult, 0);
    }
}
```

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Service initialization | Debug | "InitiativeService initialized" |
| Initiative roll | Debug | "Player Hero rolls initiative: [7] +14 = 21" |
| Encounter created | Information | "Created combat encounter with 1 player and 3 monsters" |
| Combat started | Information | "Combat started - Round 1" |
| Turn advanced | Debug | "Turn advanced to Goblin 2" |
| Round advanced | Information | "Round 2 begins" |
| Target resolved | Debug | "Resolved 'goblin 2' to Goblin 2" |
| Target not found | Debug | "No match for target 'dragon'" |
| Combat ended | Information | "Combat ended - Victory in 3 rounds" |

### Structured Logging Format

```csharp
_logger.LogDebug(
    "Player {Name} rolls initiative: {Roll}",
    player.Name, initiative.ToDisplayString());

_logger.LogInformation(
    "Created combat encounter with {PlayerCount} player and {MonsterCount} monsters in room {RoomId}",
    1, monsterList.Count, roomId);

_logger.LogDebug(
    "Resolved '{TargetSpec}' to {DisplayName}",
    targetSpec, target.DisplayName);
```

---

## Implementation Checklist

### Domain Layer
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/CombatState.cs`
  - [ ] All 5 enum values
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/InitiativeRoll.cs`
  - [ ] DiceResult and Modifier properties
  - [ ] Total computed property
  - [ ] ToDisplayString() method
- [ ] Create `src/Core/RuneAndRust.Domain/Entities/Combatant.cs`
  - [ ] Player/Monster references
  - [ ] Initiative tracking
  - [ ] HasActedThisRound state
  - [ ] Factory methods
- [ ] Create `src/Core/RuneAndRust.Domain/Entities/CombatEncounter.cs`
  - [ ] Combatant list management
  - [ ] State machine
  - [ ] Turn advancement
  - [ ] Monster targeting
- [ ] Update `src/Core/RuneAndRust.Domain/Entities/Monster.cs`
  - [ ] InitiativeModifier property
  - [ ] MonsterDefinitionId property
  - [ ] Updated factory methods
- [ ] Update `src/Core/RuneAndRust.Domain/Entities/GameSession.cs`
  - [ ] ActiveEncounter property
  - [ ] IsInCombat property
  - [ ] PreviousRoomId property
  - [ ] StartCombat/EndCombat methods

### Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/Services/InitiativeService.cs`
  - [ ] RollForPlayer method
  - [ ] RollForMonster method
  - [ ] CreateEncounter method
- [ ] Create `src/Core/RuneAndRust.Application/Services/TargetResolver.cs`
  - [ ] ResolveMonsterTarget method
  - [ ] GetValidTargets method
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/CombatDtos.cs`
  - [ ] CombatantInitiativeDto
  - [ ] TurnOrderEntryDto
  - [ ] EnemyStatusDto
  - [ ] CombatStateDto
  - [ ] CombatEndDto
- [ ] Update `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs`
  - [ ] RenderInitiativeAsync
  - [ ] RenderCombatStateAsync
  - [ ] RenderCombatStartAsync
  - [ ] RenderCombatEndAsync

### Presentation Layer
- [ ] Update `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`
  - [ ] Implement RenderInitiativeAsync
  - [ ] Implement RenderCombatStateAsync
  - [ ] Implement RenderCombatStartAsync
  - [ ] Implement RenderCombatEndAsync

### Tests
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Enums/CombatStateTests.cs` (3 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/InitiativeRollTests.cs` (4 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Entities/CombatantTests.cs` (6 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Entities/CombatEncounterTests.cs` (10 tests)
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/InitiativeServiceTests.cs` (5 tests)
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/TargetResolverTests.cs` (6 tests)

### Validation
- [ ] All 20 new tests pass
- [ ] All existing tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | Rooms can contain 1-5 monsters | Unit test |
| AC-2 | Initiative rolled for all combatants at combat start | Unit test |
| AC-3 | Initiative uses 1d10 + modifier formula | Unit test |
| AC-4 | Turn order sorted by initiative (descending) | Unit test |
| AC-5 | Ties broken by highest Finesse | Unit test |
| AC-6 | `attack` with no target attacks first monster | Unit test |
| AC-7 | `attack 2` attacks monster #2 | Unit test |
| AC-8 | `attack goblin` attacks first goblin | Unit test |
| AC-9 | `attack goblin 2` attacks second goblin | Unit test |
| AC-10 | Duplicate monsters numbered ("Goblin 1", "Goblin 2") | Unit test |
| AC-11 | Combat ends when all monsters defeated (Victory) | Unit test |
| AC-12 | Combat ends when player defeated (PlayerDefeated) | Unit test |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | All public types have XML documentation | Code review |
| NF-2 | Services use dependency injection | Code review |
| NF-3 | Logging follows established patterns | Code review |
| NF-4 | Code follows existing architecture patterns | Code review |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| v0.0.5 not complete | High | Medium | Document dependency, defer implementation |
| Monster balance issues | Medium | Low | Keep existing damage formulas initially |
| Turn order confusion | Low | Low | Clear initiative display with numbers |
| Targeting ambiguity | Medium | Medium | Warn on ambiguous targets |
| Performance with 5 monsters | Low | Low | Simple list operations, no optimization needed |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Domain/Enums/CombatState.cs` | Combat state machine enum | ~35 |
| `Domain/ValueObjects/InitiativeRoll.cs` | Initiative roll value object | ~60 |
| `Domain/Entities/Combatant.cs` | Combatant wrapper entity | ~150 |
| `Domain/Entities/CombatEncounter.cs` | Combat aggregate root | ~200 |
| `Application/Services/InitiativeService.cs` | Initiative rolling service | ~120 |
| `Application/Services/TargetResolver.cs` | Target resolution service | ~100 |
| `Application/DTOs/CombatDtos.cs` | Combat display DTOs | ~130 |
| Test files (6 files) | Unit tests | ~400 |

### Files to Modify

| File | Changes |
|------|---------|
| `Domain/Entities/Monster.cs` | Add InitiativeModifier, MonsterDefinitionId (~30 lines) |
| `Domain/Entities/GameSession.cs` | Add ActiveEncounter, PreviousRoomId, combat methods (~40 lines) |
| `Application/Interfaces/IGameRenderer.cs` | Add combat rendering methods (~20 lines) |
| `Presentation.Tui/Adapters/SpectreGameRenderer.cs` | Implement combat rendering (~100 lines) |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| Combat Entity Count | 0 | 2 (Combatant, CombatEncounter) |
| Combat Service Count | 1 | 3 (+InitiativeService, +TargetResolver) |
| Unit Tests | ~198 | ~218 |

---

## Next Steps

After completing this phase:

1. **v0.0.6b (Monster AI & Flee System)** - AI decision-making, flee command, combat log
2. **v0.0.6c (Status Effect Framework)** - Status effect definitions, application, duration
3. **v0.0.6d (Status Effect Integration)** - Effect interactions, cleanse, combat integration

---

*This implementation plan provides step-by-step guidance for implementing multi-monster combat foundation. The plan builds on v0.0.5's dice system and prepares infrastructure for v0.0.6b's monster AI.*
