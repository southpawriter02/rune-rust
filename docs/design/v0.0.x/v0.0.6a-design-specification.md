# v0.0.6a Design Specification: Multi-Monster Combat Foundation

**Version:** 0.0.6a
**Parent:** v0.0.6 (Enhanced Combat System)
**Prerequisites:** v0.0.5 Complete (Dice Pool System)
**Status:** Design Complete

---

## Table of Contents

1. [Overview](#overview)
2. [Scope](#scope)
3. [Data Model](#data-model)
4. [Combat State Machine](#combat-state-machine)
5. [Initiative System](#initiative-system)
6. [Target Selection](#target-selection)
7. [Turn Order Management](#turn-order-management)
8. [Command Changes](#command-changes)
9. [Rendering Changes](#rendering-changes)
10. [Configuration](#configuration)
11. [Acceptance Criteria](#acceptance-criteria)
12. [Test Specifications](#test-specifications)

---

## Overview

### Purpose

v0.0.6a transforms the existing single-monster combat system into a multi-monster encounter system with initiative-based turn order and explicit target selection. This phase establishes the foundational infrastructure for tactical combat that subsequent phases (v0.0.6b-d) will build upon.

### Key Changes

| Area | Current State (v0.0.5) | Target State (v0.0.6a) |
|------|------------------------|------------------------|
| Monsters per room | 1 (implied) | 1-5 (explicit limit) |
| Combat initiation | Implicit (attack command) | Explicit encounter start |
| Turn order | Player always first | Initiative-based |
| Targeting | Automatic (only target) | Explicit target selection |
| Monster identity | Single name | Numbered duplicates |
| Combat tracking | Per-action | Per-encounter with rounds |

### Design Principles

1. **Backwards Compatibility**: Single-monster encounters should work identically to before
2. **Data-Driven**: Initiative formulas and combat rules configurable
3. **Clean Architecture**: Combat encounter as aggregate root, separate from Room
4. **Testability**: All combat logic in services with injected dependencies

---

## Scope

### In Scope

- `CombatEncounter` aggregate entity for tracking multi-participant combat
- `Combatant` entity wrapping Player/Monster with combat-specific state
- `InitiativeRoll` value object for dice-based initiative
- `InitiativeService` for rolling and ordering initiative
- Combat state machine (NotStarted → Active → Resolved)
- Target selection by name (`attack goblin`) and number (`attack 2`)
- Monster numbering for duplicate types ("Goblin 1", "Goblin 2")
- Round tracking and turn advancement
- Updated `AttackCommand` with optional target parameter
- Combat encounter rendering (initiative, turn order, round display)

### Out of Scope (Future Phases)

- Monster AI decision-making (v0.0.6b)
- Flee command (v0.0.6b)
- Combat log system (v0.0.6b)
- Status effects (v0.0.6c/d)
- AoE targeting multiple monsters

---

## Data Model

### New: CombatEncounter (Aggregate Root)

```csharp
/// <summary>
/// Represents an active combat encounter with multiple combatants.
/// </summary>
/// <remarks>
/// CombatEncounter is the aggregate root for all combat-related state.
/// It tracks turn order, round progression, and combat resolution.
/// </remarks>
public class CombatEncounter
{
    /// <summary>
    /// Unique identifier for this encounter.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// The room where this encounter is taking place.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// All combatants participating in this encounter.
    /// </summary>
    public IReadOnlyList<Combatant> Combatants => _combatants.AsReadOnly();
    private readonly List<Combatant> _combatants = new();

    /// <summary>
    /// Current state of the encounter.
    /// </summary>
    public CombatState State { get; private set; } = CombatState.NotStarted;

    /// <summary>
    /// Current round number (1-based).
    /// </summary>
    public int RoundNumber { get; private set; } = 0;

    /// <summary>
    /// Index of the current combatant in turn order.
    /// </summary>
    public int CurrentTurnIndex { get; private set; } = 0;

    /// <summary>
    /// The combatant whose turn it currently is.
    /// </summary>
    public Combatant? CurrentCombatant =>
        State == CombatState.Active && CurrentTurnIndex < _combatants.Count
            ? _combatants[CurrentTurnIndex]
            : null;

    /// <summary>
    /// The room this encounter entered from (for flee mechanic).
    /// </summary>
    public Guid? PreviousRoomId { get; private set; }

    /// <summary>
    /// Timestamp when combat started.
    /// </summary>
    public DateTime StartedAt { get; private set; }

    /// <summary>
    /// Timestamp when combat ended (null if ongoing).
    /// </summary>
    public DateTime? EndedAt { get; private set; }

    // Private constructor for EF Core
    private CombatEncounter() { }

    /// <summary>
    /// Creates a new combat encounter.
    /// </summary>
    public static CombatEncounter Create(Guid roomId, Guid? previousRoomId = null)
    {
        return new CombatEncounter
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            PreviousRoomId = previousRoomId,
            State = CombatState.NotStarted
        };
    }

    /// <summary>
    /// Adds a combatant to the encounter.
    /// </summary>
    /// <param name="combatant">The combatant to add.</param>
    /// <exception cref="InvalidOperationException">If combat has already started.</exception>
    public void AddCombatant(Combatant combatant)
    {
        if (State != CombatState.NotStarted)
            throw new InvalidOperationException("Cannot add combatants after combat has started.");

        _combatants.Add(combatant);
    }

    /// <summary>
    /// Starts the encounter, sorting combatants by initiative.
    /// </summary>
    /// <exception cref="InvalidOperationException">If no combatants or already started.</exception>
    public void Start()
    {
        if (_combatants.Count == 0)
            throw new InvalidOperationException("Cannot start combat with no combatants.");
        if (State != CombatState.NotStarted)
            throw new InvalidOperationException("Combat has already started.");

        // Sort by initiative (descending), then by Finesse for ties
        _combatants.Sort((a, b) =>
        {
            var initiativeCompare = b.Initiative.CompareTo(a.Initiative);
            if (initiativeCompare != 0) return initiativeCompare;
            return b.Finesse.CompareTo(a.Finesse);
        });

        State = CombatState.Active;
        RoundNumber = 1;
        CurrentTurnIndex = 0;
        StartedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Advances to the next combatant's turn.
    /// </summary>
    /// <returns>The new current combatant, or null if combat ended.</returns>
    public Combatant? AdvanceTurn()
    {
        if (State != CombatState.Active) return null;

        // Mark current combatant as having acted
        if (CurrentCombatant != null)
            CurrentCombatant.MarkActed();

        // Find next active combatant
        var startIndex = CurrentTurnIndex;
        do
        {
            CurrentTurnIndex++;

            // Check for round end
            if (CurrentTurnIndex >= _combatants.Count)
            {
                CurrentTurnIndex = 0;
                RoundNumber++;
                ResetActedFlags();
            }

            // Skip defeated combatants
            if (_combatants[CurrentTurnIndex].IsActive)
                return _combatants[CurrentTurnIndex];

        } while (CurrentTurnIndex != startIndex);

        // If we've looped all the way around with no active combatants, combat is over
        CheckForResolution();
        return CurrentCombatant;
    }

    /// <summary>
    /// Checks if combat should end and updates state accordingly.
    /// </summary>
    public void CheckForResolution()
    {
        if (State != CombatState.Active) return;

        var activeMonsters = _combatants.Where(c => c.IsMonster && c.IsActive).ToList();
        var activePlayer = _combatants.FirstOrDefault(c => c.IsPlayer && c.IsActive);

        if (activePlayer == null)
        {
            State = CombatState.PlayerDefeated;
            EndedAt = DateTime.UtcNow;
        }
        else if (activeMonsters.Count == 0)
        {
            State = CombatState.Victory;
            EndedAt = DateTime.UtcNow;
        }
    }

    /// <summary>
    /// Ends combat due to player fleeing.
    /// </summary>
    public void EndByFlee()
    {
        if (State != CombatState.Active) return;
        State = CombatState.Fled;
        EndedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Gets all active monsters in the encounter.
    /// </summary>
    public IEnumerable<Combatant> GetActiveMonsters() =>
        _combatants.Where(c => c.IsMonster && c.IsActive);

    /// <summary>
    /// Gets a monster by its display number (1-based).
    /// </summary>
    public Combatant? GetMonsterByNumber(int number) =>
        GetActiveMonsters().ElementAtOrDefault(number - 1);

    /// <summary>
    /// Gets monsters matching a name (case-insensitive partial match).
    /// </summary>
    public IEnumerable<Combatant> GetMonstersByName(string name) =>
        GetActiveMonsters().Where(c =>
            c.DisplayName.Contains(name, StringComparison.OrdinalIgnoreCase));

    private void ResetActedFlags()
    {
        foreach (var combatant in _combatants.Where(c => c.IsActive))
            combatant.ResetActed();
    }
}
```

### New: Combatant (Entity)

```csharp
/// <summary>
/// Wraps a Player or Monster with combat-specific state.
/// </summary>
public class Combatant
{
    /// <summary>
    /// Unique identifier for this combatant instance.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Reference to the underlying Player (null if monster).
    /// </summary>
    public Player? Player { get; private set; }

    /// <summary>
    /// Reference to the underlying Monster (null if player).
    /// </summary>
    public Monster? Monster { get; private set; }

    /// <summary>
    /// The combatant's initiative roll result.
    /// </summary>
    public InitiativeRoll InitiativeRoll { get; private set; }

    /// <summary>
    /// Total initiative value (roll + modifier).
    /// </summary>
    public int Initiative => InitiativeRoll.Total;

    /// <summary>
    /// Finesse stat for tie-breaking.
    /// </summary>
    public int Finesse { get; private set; }

    /// <summary>
    /// Display name with numbering for duplicates.
    /// </summary>
    public string DisplayName { get; private set; }

    /// <summary>
    /// The display number for this combatant (1-based, for monsters only).
    /// </summary>
    public int? DisplayNumber { get; private set; }

    /// <summary>
    /// Whether this combatant has acted this round.
    /// </summary>
    public bool HasActedThisRound { get; private set; }

    /// <summary>
    /// Whether this combatant is still active (not defeated/fled).
    /// </summary>
    public bool IsActive => IsPlayer ? !Player!.IsDead : !Monster!.IsDefeated;

    /// <summary>
    /// Whether this combatant is the player.
    /// </summary>
    public bool IsPlayer => Player != null;

    /// <summary>
    /// Whether this combatant is a monster.
    /// </summary>
    public bool IsMonster => Monster != null;

    /// <summary>
    /// Current health of the combatant.
    /// </summary>
    public int CurrentHealth => IsPlayer ? Player!.Health : Monster!.Health;

    /// <summary>
    /// Maximum health of the combatant.
    /// </summary>
    public int MaxHealth => IsPlayer ? Player!.Stats.MaxHealth : Monster!.Stats.MaxHealth;

    // Private constructor for EF Core
    private Combatant() { }

    /// <summary>
    /// Creates a combatant for a player.
    /// </summary>
    public static Combatant ForPlayer(Player player, InitiativeRoll initiative)
    {
        return new Combatant
        {
            Id = Guid.NewGuid(),
            Player = player,
            InitiativeRoll = initiative,
            Finesse = player.Attributes.Finesse,
            DisplayName = player.Name,
            DisplayNumber = null
        };
    }

    /// <summary>
    /// Creates a combatant for a monster.
    /// </summary>
    public static Combatant ForMonster(Monster monster, InitiativeRoll initiative, int displayNumber)
    {
        var baseName = monster.Name;
        var displayName = displayNumber > 0 ? $"{baseName} {displayNumber}" : baseName;

        return new Combatant
        {
            Id = Guid.NewGuid(),
            Monster = monster,
            InitiativeRoll = initiative,
            Finesse = monster.InitiativeModifier, // Monsters use initiative mod as tiebreaker
            DisplayName = displayName,
            DisplayNumber = displayNumber
        };
    }

    /// <summary>
    /// Marks this combatant as having acted this round.
    /// </summary>
    public void MarkActed() => HasActedThisRound = true;

    /// <summary>
    /// Resets the acted flag for a new round.
    /// </summary>
    public void ResetActed() => HasActedThisRound = false;
}
```

### New: CombatState (Enum)

```csharp
/// <summary>
/// Represents the current state of a combat encounter.
/// </summary>
public enum CombatState
{
    /// <summary>
    /// Combat has not yet started (setup phase).
    /// </summary>
    NotStarted,

    /// <summary>
    /// Combat is actively in progress.
    /// </summary>
    Active,

    /// <summary>
    /// Combat ended with player victory.
    /// </summary>
    Victory,

    /// <summary>
    /// Combat ended with player defeat.
    /// </summary>
    PlayerDefeated,

    /// <summary>
    /// Combat ended because player fled.
    /// </summary>
    Fled
}
```

### New: InitiativeRoll (Value Object)

```csharp
/// <summary>
/// Represents the result of an initiative roll.
/// </summary>
/// <param name="DiceResult">The underlying dice roll result.</param>
/// <param name="Modifier">The modifier applied (from stats).</param>
public readonly record struct InitiativeRoll(
    DiceRollResult DiceResult,
    int Modifier)
{
    /// <summary>
    /// The total initiative value (roll + modifier).
    /// </summary>
    public int Total => DiceResult.Total + Modifier;

    /// <summary>
    /// The raw dice result before modifier.
    /// </summary>
    public int RollValue => DiceResult.Total;

    /// <summary>
    /// Creates a display string for the initiative roll.
    /// </summary>
    public string ToDisplayString()
    {
        var modStr = Modifier >= 0 ? $"+{Modifier}" : Modifier.ToString();
        return $"[{RollValue}] {modStr} = {Total}";
    }
}
```

### Modified: Monster (Entity)

```csharp
// Add to existing Monster entity:

/// <summary>
/// Initiative modifier for combat turn order.
/// </summary>
/// <remarks>
/// Higher values mean the monster acts earlier in combat.
/// Typically based on creature agility/reflexes.
/// </remarks>
public int InitiativeModifier { get; private set; } = 0;

/// <summary>
/// The definition ID this monster was created from.
/// </summary>
/// <remarks>
/// Used for grouping duplicate monsters and loading configuration.
/// </remarks>
public string? MonsterDefinitionId { get; private set; }

// Update factory method:
public static Monster CreateGoblin()
{
    return new Monster
    {
        Id = Guid.NewGuid(),
        Name = "Goblin",
        Description = "A small, green-skinned creature with sharp teeth.",
        Health = 30,
        MaxHealth = 30,
        Stats = new Stats(30, 8, 2),
        InitiativeModifier = 1,
        MonsterDefinitionId = "goblin"
    };
}
```

### Modified: GameSession (Entity)

```csharp
// Add to existing GameSession entity:

/// <summary>
/// The currently active combat encounter, if any.
/// </summary>
public CombatEncounter? ActiveEncounter { get; private set; }

/// <summary>
/// Whether the player is currently in combat.
/// </summary>
public bool IsInCombat => ActiveEncounter?.State == CombatState.Active;

/// <summary>
/// Starts a combat encounter in the current room.
/// </summary>
/// <param name="encounter">The encounter to start.</param>
public void StartCombat(CombatEncounter encounter)
{
    if (ActiveEncounter?.State == CombatState.Active)
        throw new InvalidOperationException("Already in combat.");

    ActiveEncounter = encounter;
}

/// <summary>
/// Ends the current combat encounter.
/// </summary>
public void EndCombat()
{
    ActiveEncounter = null;
}

/// <summary>
/// The room the player was in before entering the current room.
/// </summary>
/// <remarks>
/// Used for flee destination.
/// </remarks>
public Guid? PreviousRoomId { get; private set; }

// Update TryMovePlayer to track previous room:
public (bool Success, string Message) TryMovePlayer(Direction direction)
{
    // ... existing validation ...

    PreviousRoomId = CurrentRoomId;
    CurrentRoomId = targetRoomId;

    // ... rest of method ...
}
```

---

## Combat State Machine

```
                    ┌─────────────────┐
                    │   NotStarted    │
                    │                 │
                    │ - Add combatants│
                    │ - Roll initiative│
                    └────────┬────────┘
                             │
                             │ Start()
                             ▼
                    ┌─────────────────┐
         ┌─────────│     Active      │─────────┐
         │         │                 │         │
         │         │ - Process turns │         │
         │         │ - Track rounds  │         │
         │         └────────┬────────┘         │
         │                  │                  │
         │ All monsters     │ Player           │ EndByFlee()
         │ defeated         │ defeated         │
         ▼                  ▼                  ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│    Victory      │ │ PlayerDefeated  │ │      Fled       │
│                 │ │                 │ │                 │
│ - Award XP      │ │ - Game Over     │ │ - Return to     │
│ - Drop loot     │ │                 │ │   previous room │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

---

## Initiative System

### InitiativeService

```csharp
/// <summary>
/// Service for rolling and managing combat initiative.
/// </summary>
public class InitiativeService
{
    private readonly IDiceService _diceService;
    private readonly ILogger<InitiativeService> _logger;

    public InitiativeService(IDiceService diceService, ILogger<InitiativeService> logger)
    {
        _diceService = diceService;
        _logger = logger;
    }

    /// <summary>
    /// Rolls initiative for a player.
    /// </summary>
    /// <param name="player">The player to roll for.</param>
    /// <returns>The initiative roll result.</returns>
    public InitiativeRoll RollForPlayer(Player player)
    {
        var pool = DicePool.D10(); // 1d10 for initiative
        var result = _diceService.Roll(pool);
        var modifier = player.Attributes.Finesse;

        var initiative = new InitiativeRoll(result, modifier);

        _logger.LogDebug(
            "Player {Name} rolls initiative: {Roll}",
            player.Name, initiative.ToDisplayString());

        return initiative;
    }

    /// <summary>
    /// Rolls initiative for a monster.
    /// </summary>
    /// <param name="monster">The monster to roll for.</param>
    /// <returns>The initiative roll result.</returns>
    public InitiativeRoll RollForMonster(Monster monster)
    {
        var pool = DicePool.D10(); // 1d10 for initiative
        var result = _diceService.Roll(pool);
        var modifier = monster.InitiativeModifier;

        var initiative = new InitiativeRoll(result, modifier);

        _logger.LogDebug(
            "Monster {Name} rolls initiative: {Roll}",
            monster.Name, initiative.ToDisplayString());

        return initiative;
    }

    /// <summary>
    /// Creates a combat encounter with all participants and rolled initiative.
    /// </summary>
    /// <param name="player">The player entering combat.</param>
    /// <param name="monsters">The monsters in the room.</param>
    /// <param name="roomId">The room where combat occurs.</param>
    /// <param name="previousRoomId">The room the player came from.</param>
    /// <returns>A fully configured combat encounter.</returns>
    public CombatEncounter CreateEncounter(
        Player player,
        IEnumerable<Monster> monsters,
        Guid roomId,
        Guid? previousRoomId)
    {
        var encounter = CombatEncounter.Create(roomId, previousRoomId);

        // Add player
        var playerInitiative = RollForPlayer(player);
        encounter.AddCombatant(Combatant.ForPlayer(player, playerInitiative));

        // Add monsters with numbering
        var monsterList = monsters.ToList();
        var monsterCounts = new Dictionary<string, int>();

        foreach (var monster in monsterList)
        {
            var defId = monster.MonsterDefinitionId ?? monster.Name;
            monsterCounts.TryGetValue(defId, out var count);
            count++;
            monsterCounts[defId] = count;

            var monsterInitiative = RollForMonster(monster);
            var displayNumber = monsterList.Count(m =>
                (m.MonsterDefinitionId ?? m.Name) == defId) > 1 ? count : 0;

            encounter.AddCombatant(Combatant.ForMonster(monster, monsterInitiative, displayNumber));
        }

        _logger.LogInformation(
            "Created combat encounter with {Count} combatants in room {RoomId}",
            encounter.Combatants.Count, roomId);

        return encounter;
    }
}
```

### Initiative Formula

| Combatant | Formula | Notes |
|-----------|---------|-------|
| Player | 1d10 + Finesse | Finesse typically 1-30 |
| Monster | 1d10 + InitiativeModifier | InitiativeModifier typically 0-5 |
| Tie-breaker | Highest Finesse wins | Monsters use InitiativeModifier |

---

## Target Selection

### TargetResolver Service

```csharp
/// <summary>
/// Resolves target specifications to actual combatants.
/// </summary>
public class TargetResolver
{
    /// <summary>
    /// Resolves a target specification to a monster combatant.
    /// </summary>
    /// <param name="encounter">The active combat encounter.</param>
    /// <param name="targetSpec">The target specification (name, number, or name+number).</param>
    /// <returns>The resolved combatant, or null if not found.</returns>
    public Combatant? ResolveMonsterTarget(CombatEncounter encounter, string? targetSpec)
    {
        var activeMonsters = encounter.GetActiveMonsters().ToList();

        if (activeMonsters.Count == 0)
            return null;

        // No target specified - return first/only monster
        if (string.IsNullOrWhiteSpace(targetSpec))
        {
            return activeMonsters.First();
        }

        targetSpec = targetSpec.Trim();

        // Try parsing as number only ("attack 2")
        if (int.TryParse(targetSpec, out var number))
        {
            return encounter.GetMonsterByNumber(number);
        }

        // Try parsing as "name number" ("attack goblin 2")
        var parts = targetSpec.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length >= 2 && int.TryParse(parts[^1], out var nameNumber))
        {
            var name = string.Join(' ', parts[..^1]);
            var matchingMonsters = encounter.GetMonstersByName(name).ToList();
            return matchingMonsters.ElementAtOrDefault(nameNumber - 1);
        }

        // Try matching by name only ("attack goblin")
        var byName = encounter.GetMonstersByName(targetSpec).ToList();
        if (byName.Count == 1)
        {
            return byName[0];
        }
        else if (byName.Count > 1)
        {
            // Ambiguous - return first match but caller should warn
            return byName[0];
        }

        return null;
    }

    /// <summary>
    /// Gets a list of valid target specifications for display.
    /// </summary>
    public IEnumerable<string> GetValidTargets(CombatEncounter encounter)
    {
        var monsters = encounter.GetActiveMonsters().ToList();

        for (int i = 0; i < monsters.Count; i++)
        {
            var m = monsters[i];
            yield return $"{i + 1}. {m.DisplayName} ({m.CurrentHealth}/{m.MaxHealth} HP)";
        }
    }
}
```

### Target Specification Formats

| Format | Example | Resolves To |
|--------|---------|-------------|
| (empty) | `attack` | First active monster |
| Number | `attack 2` | Second active monster |
| Name | `attack goblin` | First goblin (warns if multiple) |
| Name + Number | `attack goblin 2` | Second goblin |
| Partial Name | `attack gob` | First monster matching "gob" |

---

## Turn Order Management

### Turn Flow

```
START OF COMBAT
│
├─► Roll initiative for all combatants
├─► Sort by initiative (desc), then Finesse (desc) for ties
├─► Start Round 1
│
ROUND LOOP
│
├─► For each combatant in turn order:
│   │
│   ├─► Skip if defeated
│   │
│   ├─► If Player's turn:
│   │   ├─► Display turn prompt
│   │   ├─► Wait for command
│   │   └─► Process action
│   │
│   ├─► If Monster's turn:
│   │   ├─► AI decides action (v0.0.6b)
│   │   └─► Execute action
│   │
│   └─► Check for combat resolution
│
├─► End of Round
│   └─► Reset "acted" flags
│
└─► Continue to next round OR end combat
```

### Turn Order Display

```
═══════════════════════════════════════════
           COMBAT - Round 1
═══════════════════════════════════════════
Turn Order:
  ► 1. You (17 initiative)
    2. Goblin 2 (13 initiative)
    3. Goblin 1 (9 initiative)
───────────────────────────────────────────
Your turn. What do you do?
Enemies:
  [1] Goblin 1 - 30/30 HP
  [2] Goblin 2 - 30/30 HP
>
```

---

## Command Changes

### Updated AttackCommand

```csharp
/// <summary>
/// Command to attack a target in combat.
/// </summary>
/// <param name="Target">Optional target specification (name, number, or name+number).</param>
public record AttackCommand(string? Target = null) : GameCommand;
```

### Command Parsing Updates

```csharp
// In ConsoleInputHandler.ParseCommand():

"attack" or "a" => ParseAttackCommand(argument),

private GameCommand ParseAttackCommand(string? argument)
{
    // "attack" with no argument - target first/only enemy
    if (string.IsNullOrWhiteSpace(argument))
        return new AttackCommand(null);

    // "attack <target>" - pass target spec
    return new AttackCommand(argument.Trim());
}
```

### GameSessionService Updates

```csharp
/// <summary>
/// Attempts to attack a target in the current combat encounter.
/// </summary>
/// <param name="targetSpec">Optional target specification.</param>
/// <returns>Result of the attack attempt.</returns>
public CombatActionResult TryAttack(string? targetSpec = null)
{
    if (_currentSession == null)
        return CombatActionResult.Failure("No active game session.");

    // Check if in combat
    if (!_currentSession.IsInCombat)
    {
        // Try to start combat if monsters present
        var room = GetCurrentRoom();
        var monsters = room?.Monsters.Where(m => m.IsAlive).ToList();

        if (monsters == null || monsters.Count == 0)
            return CombatActionResult.Failure("There's nothing to attack here.");

        StartCombat(monsters);
    }

    var encounter = _currentSession.ActiveEncounter!;

    // Verify it's player's turn
    if (!encounter.CurrentCombatant?.IsPlayer ?? true)
        return CombatActionResult.Failure("It's not your turn.");

    // Resolve target
    var target = _targetResolver.ResolveMonsterTarget(encounter, targetSpec);
    if (target == null)
    {
        var validTargets = string.Join("\n", _targetResolver.GetValidTargets(encounter));
        return CombatActionResult.Failure($"Invalid target. Valid targets:\n{validTargets}");
    }

    // Execute attack using existing CombatService
    var combatResult = _combatService.ResolveCombatRound(
        _currentSession.Player,
        target.Monster!);

    // Build result
    var result = new CombatActionResult(
        Success: true,
        Message: _combatService.GetCombatDescription(
            combatResult,
            _currentSession.Player.Name,
            target.DisplayName),
        DamageDealt: combatResult.DamageDealt,
        TargetDefeated: combatResult.MonsterDefeated,
        TargetName: target.DisplayName);

    // Check for combat resolution
    encounter.CheckForResolution();

    if (encounter.State == CombatState.Victory)
    {
        _currentSession.EndCombat();
        result = result with { CombatEnded = true, CombatVictory = true };
    }
    else if (encounter.State == CombatState.PlayerDefeated)
    {
        _currentSession.SetState(GameState.GameOver);
        result = result with { CombatEnded = true, PlayerDefeated = true };
    }
    else
    {
        // Advance to next turn
        encounter.AdvanceTurn();
    }

    return result;
}

/// <summary>
/// Starts a combat encounter with the given monsters.
/// </summary>
private void StartCombat(IEnumerable<Monster> monsters)
{
    var encounter = _initiativeService.CreateEncounter(
        _currentSession!.Player,
        monsters,
        _currentSession.CurrentRoomId,
        _currentSession.PreviousRoomId);

    encounter.Start();
    _currentSession.StartCombat(encounter);

    _logger.LogInformation("Combat started with {Count} monsters",
        encounter.GetActiveMonsters().Count());
}
```

### CombatActionResult

```csharp
/// <summary>
/// Result of a combat action.
/// </summary>
public record CombatActionResult(
    bool Success,
    string Message,
    int? DamageDealt = null,
    int? DamageReceived = null,
    bool TargetDefeated = false,
    string? TargetName = null,
    bool CombatEnded = false,
    bool CombatVictory = false,
    bool PlayerDefeated = false)
{
    public static CombatActionResult Failure(string message) =>
        new(false, message);
}
```

---

## Rendering Changes

### IGameRenderer Additions

```csharp
/// <summary>
/// Renders combat initiative results.
/// </summary>
/// <param name="initiatives">The initiative rolls for all combatants.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderInitiativeAsync(IReadOnlyList<CombatantInitiativeDto> initiatives, CancellationToken ct = default);

/// <summary>
/// Renders the current combat state (turn order, current turn, enemies).
/// </summary>
/// <param name="combatState">The current combat state.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatStateAsync(CombatStateDto combatState, CancellationToken ct = default);

/// <summary>
/// Renders combat start notification.
/// </summary>
/// <param name="monsterCount">Number of enemies.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatStartAsync(int monsterCount, CancellationToken ct = default);

/// <summary>
/// Renders combat end notification.
/// </summary>
/// <param name="result">The combat result (victory, defeat, fled).</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatEndAsync(CombatEndDto result, CancellationToken ct = default);
```

### DTOs

```csharp
/// <summary>
/// Initiative display information for a combatant.
/// </summary>
public record CombatantInitiativeDto(
    string Name,
    int RollValue,
    int Modifier,
    int Total,
    bool IsPlayer);

/// <summary>
/// Current combat state for display.
/// </summary>
public record CombatStateDto(
    int RoundNumber,
    IReadOnlyList<TurnOrderEntryDto> TurnOrder,
    int CurrentTurnIndex,
    IReadOnlyList<EnemyStatusDto> Enemies,
    bool IsPlayerTurn);

/// <summary>
/// Turn order entry for display.
/// </summary>
public record TurnOrderEntryDto(
    string Name,
    int Initiative,
    bool IsCurrentTurn,
    bool IsPlayer,
    bool IsDefeated);

/// <summary>
/// Enemy status for target selection display.
/// </summary>
public record EnemyStatusDto(
    int Number,
    string DisplayName,
    int CurrentHealth,
    int MaxHealth,
    bool IsDefeated);

/// <summary>
/// Combat end result for display.
/// </summary>
public record CombatEndDto(
    CombatState EndState,
    int RoundsElapsed,
    int MonstersDefeated);
```

### SpectreGameRenderer Implementation

```csharp
public Task RenderInitiativeAsync(IReadOnlyList<CombatantInitiativeDto> initiatives, CancellationToken ct = default)
{
    var panel = new Panel(BuildInitiativeText(initiatives))
        .Header("[yellow]Rolling Initiative[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(Color.Yellow);

    AnsiConsole.Write(panel);
    return Task.CompletedTask;
}

private string BuildInitiativeText(IReadOnlyList<CombatantInitiativeDto> initiatives)
{
    var lines = new List<string>();

    foreach (var init in initiatives.OrderByDescending(i => i.Total))
    {
        var modStr = init.Modifier >= 0 ? $"+{init.Modifier}" : init.Modifier.ToString();
        var color = init.IsPlayer ? "green" : "red";
        lines.Add($"  [{color}]{init.Name}[/]: [[{init.RollValue}]] {modStr} = [white bold]{init.Total}[/]");
    }

    return string.Join("\n", lines);
}

public Task RenderCombatStateAsync(CombatStateDto state, CancellationToken ct = default)
{
    // Header
    var rule = new Rule($"[yellow]COMBAT - Round {state.RoundNumber}[/]")
        .RuleStyle("yellow");
    AnsiConsole.Write(rule);

    // Turn order
    AnsiConsole.MarkupLine("[grey]Turn Order:[/]");
    foreach (var entry in state.TurnOrder)
    {
        var marker = entry.IsCurrentTurn ? "[yellow]►[/]" : " ";
        var color = entry.IsPlayer ? "green" : "red";
        var status = entry.IsDefeated ? " [grey](defeated)[/]" : "";
        AnsiConsole.MarkupLine($"  {marker} [{color}]{entry.Name}[/] ({entry.Initiative}){status}");
    }

    // Enemies list
    if (state.IsPlayerTurn)
    {
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[grey]Enemies:[/]");
        foreach (var enemy in state.Enemies.Where(e => !e.IsDefeated))
        {
            var healthPct = (float)enemy.CurrentHealth / enemy.MaxHealth;
            var healthColor = healthPct > 0.5 ? "green" : healthPct > 0.25 ? "yellow" : "red";
            AnsiConsole.MarkupLine(
                $"  [cyan][[{enemy.Number}]][/] {enemy.DisplayName} - [{healthColor}]{enemy.CurrentHealth}/{enemy.MaxHealth} HP[/]");
        }
    }

    return Task.CompletedTask;
}
```

---

## Configuration

### combat-config.json

```json
{
  "combat": {
    "maxMonstersPerRoom": 5,
    "initiative": {
      "dicePool": "1d10",
      "playerModifierStat": "finesse",
      "tieBreakerStat": "finesse"
    },
    "targeting": {
      "allowPartialNameMatch": true,
      "caseSensitive": false
    }
  }
}
```

---

## Acceptance Criteria

### Combat Encounter Management
- [ ] Rooms can contain 1-5 monsters
- [ ] Combat encounter created when entering room with monsters OR when attacking
- [ ] Combat encounter tracks all combatants
- [ ] Combat ends correctly on victory, defeat, or flee
- [ ] Previous room tracked for flee destination

### Initiative System
- [ ] Initiative rolled for all combatants at combat start
- [ ] Initiative uses 1d10 + modifier formula
- [ ] Player uses Finesse as modifier
- [ ] Monsters use InitiativeModifier
- [ ] Ties broken by highest Finesse
- [ ] Turn order sorted by initiative (descending)
- [ ] Initiative results displayed to player

### Target Selection
- [ ] `attack` with no target attacks first monster
- [ ] `attack 2` attacks monster #2
- [ ] `attack goblin` attacks first goblin
- [ ] `attack goblin 2` attacks second goblin
- [ ] Invalid target shows valid targets list
- [ ] Partial name matching works (case-insensitive)

### Turn Order
- [ ] Turns proceed in initiative order
- [ ] Round counter increments correctly
- [ ] Defeated combatants skipped
- [ ] Turn advancement works correctly
- [ ] "Acted this round" tracking works

### Monster Numbering
- [ ] Single monster type shows name only ("Goblin")
- [ ] Multiple of same type numbered ("Goblin 1", "Goblin 2")
- [ ] Numbers persist through combat
- [ ] Defeated monsters removed from targeting but keep numbers

### Display
- [ ] Initiative roll results displayed
- [ ] Turn order displayed each round
- [ ] Current turn indicator shown
- [ ] Enemy list with health displayed
- [ ] Combat start/end messages

---

## Test Specifications

### Unit Tests (~20 tests)

#### CombatEncounterTests.cs
```csharp
[TestFixture]
public class CombatEncounterTests
{
    [Test]
    public void Create_InitializesWithNotStartedState();

    [Test]
    public void AddCombatant_BeforeStart_Succeeds();

    [Test]
    public void AddCombatant_AfterStart_ThrowsException();

    [Test]
    public void Start_SortsCombatantsByInitiative();

    [Test]
    public void Start_WithTiedInitiative_SortsByFinesse();

    [Test]
    public void Start_WithNoCombatants_ThrowsException();

    [Test]
    public void AdvanceTurn_MovesToNextCombatant();

    [Test]
    public void AdvanceTurn_SkipsDefeatedCombatants();

    [Test]
    public void AdvanceTurn_IncrementsRoundAtEndOfTurnOrder();

    [Test]
    public void CheckForResolution_AllMonstersDefeated_SetsVictory();

    [Test]
    public void CheckForResolution_PlayerDefeated_SetsPlayerDefeated();

    [Test]
    public void GetMonsterByNumber_ReturnsCorrectMonster();

    [Test]
    public void GetMonstersByName_ReturnsMatchingMonsters();
}
```

#### InitiativeServiceTests.cs
```csharp
[TestFixture]
public class InitiativeServiceTests
{
    [Test]
    public void RollForPlayer_UsesFinessAsModifier();

    [Test]
    public void RollForMonster_UsesInitiativeModifier();

    [Test]
    public void CreateEncounter_AddsAllCombatants();

    [Test]
    public void CreateEncounter_NumbersDuplicateMonsters();

    [Test]
    public void CreateEncounter_SingleMonsterType_NoNumber();
}
```

#### TargetResolverTests.cs
```csharp
[TestFixture]
public class TargetResolverTests
{
    [Test]
    public void ResolveTarget_EmptySpec_ReturnsFirstMonster();

    [Test]
    public void ResolveTarget_NumberOnly_ReturnsCorrectMonster();

    [Test]
    public void ResolveTarget_NameOnly_ReturnsByName();

    [Test]
    public void ResolveTarget_NameAndNumber_ReturnsSpecificMonster();

    [Test]
    public void ResolveTarget_PartialName_Matches();

    [Test]
    public void ResolveTarget_InvalidTarget_ReturnsNull();
}
```

---

## Dependencies

### Required from v0.0.5
- `IDiceService` - For initiative rolls
- `DicePool` - For creating initiative dice pools
- `DiceRollResult` - For initiative roll results
- `CombatService` - For attack resolution (existing)

### Provides to v0.0.6b
- `CombatEncounter` - For AI decision context
- `Combatant` - For AI targeting
- Initiative system - For monster turn execution
- Turn management - For AI action timing

---

*This design specification provides the foundation for multi-monster tactical combat. Subsequent phases will add monster AI (v0.0.6b), status effects (v0.0.6c), and effect integration (v0.0.6d).*
