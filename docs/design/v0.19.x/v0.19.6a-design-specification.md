# v0.19.6a Design Specification: Biome Integration & Transitions

**Version:** 0.19.6a
**Phase:** Final Integration Layer - Realm Interconnection
**Status:** Specification (Pre-Implementation)
**Target Tests:** ~28 Unit Tests
**Last Updated:** 2026-01-28

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Feature Overview](#feature-overview)
3. [Architecture Diagrams](#architecture-diagrams)
4. [User Stories](#user-stories)
5. [Service Specifications](#service-specifications)
6. [Data Transfer Objects (DTOs)](#data-transfer-objects)
7. [Transition Zone Mechanics](#transition-zone-mechanics)
8. [Property Interpolation Algorithm](#property-interpolation-algorithm)
9. [Sector Assignment System](#sector-assignment-system)
10. [Route Classification System](#route-classification-system)
11. [Biome Validation Framework](#biome-validation-framework)
12. [Configuration Schema (routes.json)](#configuration-schema)
13. [Decision Trees & Logic Flow](#decision-trees)
14. [Code Examples with XML Documentation](#code-examples)
15. [Logging & Monitoring](#logging-monitoring)
16. [Unit Testing Strategy (~28 Tests)](#unit-testing-strategy)
17. [Deliverable Checklist](#deliverable-checklist)
18. [Acceptance Criteria](#acceptance-criteria)
19. [Dependencies & Prerequisites](#dependencies)
20. [v0.19.x Completion Summary](#completion-summary)

---

## Executive Summary

v0.19.6a represents the **final integration phase** of the Rune Rust biome system, connecting all 9 Norse-themed realms (Midgard, Vanaheim, Muspelheim, Niflheim, Jotunheim, Asgard, Hel, Svartalfheim, Muspelheim-variant) into a cohesive dungeon experience. This specification defines four core services that enable:

- **Seamless Realm Transitions:** Dynamic generation of transition zones between compatible realms
- **Spatial Organization:** Deterministic sector assignment for 9-sector dungeon layouts
- **Travel Safety Classification:** Hazard assessment and difficulty rating for inter-realm routes
- **Comprehensive Validation:** End-to-end integrity checking across all biome configurations

The implementation focuses on **property interpolation** (blending biome characteristics at transition boundaries), **compatibility matrices** (determining which realm pairs can be connected), and **deterministic routing** (ensuring reproducible transitions given the same input parameters).

This specification provides sufficient detail for a team to implement all services, pass ~28 unit tests, and maintain code quality through comprehensive XML documentation and logging infrastructure.

---

## Feature Overview

### 1. Transition Zone Generation
Generate dynamic buffer zones between adjacent realms that interpolate environmental properties.

**Key Behaviors:**
- Compatible realms (e.g., Midgard ↔ Vanaheim) require 0-1 transition room
- RequiresTransition realms (e.g., Asgard ↔ Jotunheim) require 1-3 transition rooms
- Incompatible realms (e.g., Vanaheim ↔ Muspelheim) block transitions entirely
- Properties smoothly interpolate across transition zones (temperature, humidity, danger level)

### 2. Sector Assignment
Assign biome types to numbered sectors in a deterministic 9-sector dungeon layout.

**Key Behaviors:**
- Each sector (0-8) maps to a primary realm
- Assignments are deterministic (same seed → same layout)
- Supports standard dungeon positioning (center, cardinal directions, diagonal corners)

### 3. Route Classification
Classify inter-realm travel routes by safety level and difficulty.

**Key Behaviors:**
- Safe routes: no environmental hazards (DC None)
- Moderate routes: minor hazards (DC 10)
- Dangerous routes: significant hazards (DC 14)
- Extreme routes: severe hazards (DC 18)
- Includes travel time estimation

### 4. Biome Validation
Comprehensive validation ensuring all realms are properly configured and compatible.

**Key Behaviors:**
- Validates individual biome configurations
- Checks adjacency rules across realms
- Verifies transition zone viability
- Reports detailed validation errors

---

## Architecture Diagrams

### High-Level Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                    BIOME INTEGRATION LAYER (v0.19.6a)           │
└─────────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
        ▼                     ▼                     ▼
┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
│ TransitionZone   │ │ SectorAssignment │ │ RouteClassif.    │
│ Generator        │ │ Service          │ │ Service          │
└────────┬─────────┘ └────────┬─────────┘ └────────┬─────────┘
         │                    │                    │
         └────────────────────┼────────────────────┘
                              │
                    ┌─────────▼──────────┐
                    │ Biome Validation   │
                    │ Service            │
                    └────────┬───────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   ▼                   ▼
    ┌────────┐         ┌──────────┐      ┌────────────┐
    │ 9 Core │         │Transition│      │ Route      │
    │ Realms │         │ Zones    │      │ Registry   │
    └────────┘         └──────────┘      └────────────┘
```

### Transition Zone Flow

```
Request: GenerateTransition(Midgard → Vanaheim)
         │
         ▼
Check Compatibility Matrix
         │
    ┌────┴────┐
    │          │
    ▼          ▼
Compatible   RequiresTransition / Incompatible
    │               │
    ▼               ▼
Generate        Generate 1-3
0-1 Zone        Transition Zones
    │               │
    └───────┬───────┘
            │
            ▼
    Interpolate Properties
    (Temperature, Humidity, Danger, etc.)
            │
            ▼
    Return TransitionZone(s)
```

---

## User Stories

### Story 1: Seamless Realm Exploration
**As a** dungeon explorer
**I want to** travel smoothly between adjacent realms
**So that** the world feels interconnected and exploration is intuitive

**Acceptance Criteria:**
- Transition zones exist between compatible realms
- Properties gradually shift (no jarring environmental changes)
- Travel time is accurately estimated based on difficulty

### Story 2: Dungeon Layout Understanding
**As a** dungeon master
**I want to** understand the spatial organization of all 9 realms
**So that** I can design encounters and encounters feel appropriately distributed

**Acceptance Criteria:**
- Each 9-sector dungeon has exactly one realm per sector
- Sector assignments are deterministic
- Adjacent sectors are logically related in the realm hierarchy

### Story 3: Hazard Assessment
**As a** adventurer preparing for a journey
**I want to** know the danger level of travel routes
**So that** I can prepare appropriate equipment and party composition

**Acceptance Criteria:**
- Routes have clear safety classifications
- Difficulty classes correspond to actual hazards
- Travel time reflects route difficulty

### Story 4: System Integrity
**As a** dungeon developer
**I want to** validate that all realms are properly configured
**So that** bugs and configuration errors are caught before gameplay

**Acceptance Criteria:**
- All realms pass individual validation
- Adjacency rules are verified
- Transition zones are viable
- Detailed error reports guide fixes

---

## Service Specifications

### Service 1: ITransitionZoneGenerator / TransitionZoneGenerator

**Namespace:** `RuneRust.Biome.Services`
**Dependency Injection:** Registered as `ITransitionZoneGenerator`

#### Method: GenerateTransition(RealmId fromRealm, RealmId toRealm)

```csharp
/// <summary>
/// Generates a single transition zone between two realms.
/// Returns null if realms are incompatible.
/// </summary>
/// <param name="fromRealm">Source realm identifier</param>
/// <param name="toRealm">Destination realm identifier</param>
/// <returns>TransitionZone or null if no transition possible</returns>
/// <remarks>
/// Compatibility Rules:
/// - Compatible: 0-1 transition room (usually 0)
/// - RequiresTransition: 1-3 transition rooms
/// - Incompatible: Returns null
///
/// Example: Midgard (temperate) → Vanaheim (temperate)
/// Result: Direct transition or 1-room buffer
///
/// Example: Vanaheim (cool) → Muspelheim (extreme heat)
/// Result: 2-3 transition rooms with property interpolation
/// </remarks>
TransitionZone? GenerateTransition(RealmId fromRealm, RealmId toRealm);
```

**Implementation Notes:**
- Load compatibility matrix from configuration
- Determine transition room count based on realm pair
- Interpolate biome properties across transition zones
- Return null for incompatible pairs (e.g., Vanaheim → Muspelheim direct is invalid)

#### Method: GenerateTransitionSequence(RealmId from, RealmId to, int roomCount)

```csharp
/// <summary>
/// Generates a sequence of transition zones between two realms.
/// Useful for multi-room transitions requiring gradual property shifts.
/// </summary>
/// <param name="from">Source realm</param>
/// <param name="to">Destination realm</param>
/// <param name="roomCount">Number of transition rooms (1-3)</param>
/// <returns>List of TransitionZone objects (ordered from source to dest)</returns>
/// <remarks>
/// If roomCount = 1, interpolation point is at 50% blend.
/// If roomCount = 2, interpolation points are at 33% and 66% blend.
/// If roomCount = 3, interpolation points are at 25%, 50%, and 75% blend.
///
/// Example:
/// GenerateTransitionSequence(Midgard, Jotunheim, 2)
/// Returns: [TransitionZone @ 50% blend, TransitionZone @ 100% blend]
/// </remarks>
List<TransitionZone> GenerateTransitionSequence(RealmId from, RealmId to, int roomCount);
```

**Implementation Notes:**
- Validate roomCount (1-3 range)
- Calculate evenly distributed interpolation points
- Create ordered list of zones
- Ensure smooth property progression

#### Method: InterpolateProperties(BiomeProperties from, BiomeProperties to, double blend)

```csharp
/// <summary>
/// Linearly interpolates biome properties between two realms.
/// </summary>
/// <param name="from">Source biome properties</param>
/// <param name="to">Destination biome properties</param>
/// <param name="blend">Interpolation factor (0.0 = from, 1.0 = to, 0.5 = midpoint)</param>
/// <returns>Interpolated BiomeProperties</returns>
/// <remarks>
/// Example: blend = 0.5 (midpoint)
/// - From: Midgard (18°C, 60% humidity)
/// - To: Vanaheim (28°C, 70% humidity)
/// - Result: (23°C, 65% humidity)
///
/// Formula: result = from + (to - from) * blend
///
/// Applies to:
/// - Temperature (Celsius)
/// - Humidity (percentage 0-100)
/// - DangerLevel (enum-weighted)
/// - LightLevel (0-255 scale)
/// - AmbientNoiseLevel (dB equivalent)
/// </remarks>
BiomeProperties InterpolateProperties(BiomeProperties from, BiomeProperties to, double blend);
```

**Implementation Notes:**
- Validate blend (0.0 ≤ blend ≤ 1.0)
- Linear interpolation for numeric properties
- Weighted enum interpolation for categorical properties
- Clamp results to valid ranges

#### Method: CanGenerateTransition(RealmId from, RealmId to)

```csharp
/// <summary>
/// Determines if a transition can be generated between two realms.
/// </summary>
/// <param name="from">Source realm</param>
/// <param name="to">Destination realm</param>
/// <returns>true if transition is possible; false if incompatible</returns>
BiomeProperties CanGenerateTransition(RealmId from, RealmId to);
```

---

### Service 2: ISectorAssignmentService / SectorAssignmentService

**Namespace:** `RuneRust.Biome.Services`
**Dependency Injection:** Registered as `ISectorAssignmentService`

#### Method: AssignBiome(int sectorNumber, int totalSectors)

```csharp
/// <summary>
/// Assigns a biome type to a specific sector in a dungeon layout.
/// </summary>
/// <param name="sectorNumber">Sector index (0-8 for standard 9-sector layout)</param>
/// <param name="totalSectors">Total sector count (typically 9)</param>
/// <returns>SectorBiomeAssignment containing realm ID and sector metadata</returns>
/// <remarks>
/// Standard 9-Sector Layout (for totalSectors = 9):
///
///   Sector Layout:
///   ┌───┬───┬───┐
///   │ 0 │ 1 │ 2 │
///   ├───┼───┼───┤
///   │ 3 │ 4 │ 5 │  Sector 4 = Central (Asgard / Yggdrasil)
///   ├───┼───┼───┤
///   │ 6 │ 7 │ 8 │
///   └───┴───┴───┘
///
/// Sector Assignments (Example - Deterministic):
/// - Sector 4 (Center): Asgard (Yggdrasil)
/// - Sectors 0,1,2: Upper Row (Vanaheim, Midgard, Jotunheim)
/// - Sectors 3,5: Middle Row (Hel, Muspelheim)
/// - Sectors 6,7,8: Lower Row (Svartalfheim, Niflheim, Asgard-variant)
/// </remarks>
SectorBiomeAssignment AssignBiome(int sectorNumber, int totalSectors);
```

**Implementation Notes:**
- For totalSectors = 9, use predefined layout
- Sector 4 (center) typically reserved for Asgard/Yggdrasil
- Layout must be deterministic (reproducible with same parameters)
- Support other sector counts (6, 12) in future versions

#### Method: GetPrimaryRealmForSector(int sectorNumber)

```csharp
/// <summary>
/// Gets the primary realm ID assigned to a sector.
/// </summary>
/// <param name="sectorNumber">Sector index</param>
/// <returns>RealmId of the primary realm for this sector</returns>
RealmId GetPrimaryRealmForSector(int sectorNumber);
```

#### Method: GenerateAssignments(int totalSectors)

```csharp
/// <summary>
/// Generates all sector-to-biome assignments for a complete dungeon.
/// </summary>
/// <param name="totalSectors">Total sector count</param>
/// <returns>List of SectorBiomeAssignment objects (in sector order)</returns>
/// <remarks>
/// Returns assignments indexed 0 to totalSectors-1.
/// Each assignment includes realm ID, sector position, and connectivity info.
/// </remarks>
List<SectorBiomeAssignment> GenerateAssignments(int totalSectors);
```

---

### Service 3: IRouteClassificationService / RouteClassificationService

**Namespace:** `RuneRust.Biome.Services`
**Dependency Injection:** Registered as `IRouteClassificationService`

#### Method: ClassifyRoute(RealmId from, RealmId to)

```csharp
/// <summary>
/// Classifies the difficulty and hazard level of travel between two realms.
/// </summary>
/// <param name="from">Source realm</param>
/// <param name="to">Destination realm</param>
/// <returns>RouteClassification containing safety level and difficulty class</returns>
/// <remarks>
/// Classification Logic:
/// - Compatible realms with similar properties → Safe
/// - RequiresTransition realms with 1-2 transition zones → Moderate
/// - RequiresTransition realms with 3 transition zones → Dangerous
/// - Extremely different realms (e.g., Fire ↔ Ice) → Extreme
///
/// Example Classifications:
/// - Midgard → Vanaheim = Safe (both temperate)
/// - Vanaheim → Asgard = Moderate (some environmental shift)
/// - Muspelheim → Niflheim = Extreme (opposite extremes)
/// - Jotunheim → Svartalfheim = Dangerous (significant hazards)
/// </remarks>
RouteClassification ClassifyRoute(RealmId from, RealmId to);
```

**Implementation Notes:**
- Load classification rules from configuration
- Consider realm compatibility, environmental difference, and hazard levels
- Map to Safety enum and Difficulty Class values

#### Method: GetRouteSafety(RouteClassification classification)

```csharp
/// <summary>
/// Extracts the safety level from a route classification.
/// </summary>
/// <param name="classification">RouteClassification object</param>
/// <returns>RouteSafety enum value</returns>
/// <remarks>
/// RouteSafety Enum:
/// - Safe = No environmental hazards, DC None
/// - Moderate = Minor hazards (extreme cold/heat), DC 10
/// - Dangerous = Significant hazards (hostile creatures, magic), DC 14
/// - Extreme = Severe hazards (reality distortion, planar instability), DC 18
/// </remarks>
RouteSafety GetRouteSafety(RouteClassification classification);
```

#### Method: EstimateTravelTime(RealmId from, RealmId to)

```csharp
/// <summary>
/// Estimates travel time between two realms based on route difficulty.
/// </summary>
/// <param name="from">Source realm</param>
/// <param name="to">Destination realm</param>
/// <returns>TimeSpan representing estimated travel duration</returns>
/// <remarks>
/// Base travel time: 4 hours
/// Multipliers:
/// - Safe: 1.0x (4 hours)
/// - Moderate: 1.5x (6 hours)
/// - Dangerous: 2.0x (8 hours)
/// - Extreme: 3.0x (12 hours)
///
/// Does not include rests or hazard encounters.
/// </remarks>
TimeSpan EstimateTravelTime(RealmId from, RealmId to);
```

#### Method: GetAllRoutes()

```csharp
/// <summary>
/// Retrieves all possible inter-realm routes and their classifications.
/// </summary>
/// <returns>List of RouteClassification for all realm pairs</returns>
/// <remarks>
/// For 9 realms, returns up to 81 routes (including same-realm paths).
/// Each route is classified once and cached for performance.
/// </remarks>
List<RouteClassification> GetAllRoutes();
```

---

### Service 4: IBiomeValidationService / BiomeValidationService

**Namespace:** `RuneRust.Biome.Services`
**Dependency Injection:** Registered as `IBiomeValidationService`

#### Method: ValidateAllBiomes()

```csharp
/// <summary>
/// Performs comprehensive validation on all configured biomes.
/// </summary>
/// <returns>ValidationResult containing success status and detailed error list</returns>
/// <remarks>
/// Validation Steps:
/// 1. Validate each individual biome configuration
/// 2. Check adjacency rules across realms
/// 3. Verify transition zone viability
/// 4. Confirm route classification consistency
///
/// Example Success Result:
/// {
///   IsValid = true,
///   Errors = [],
///   WarningCount = 0,
///   RealmCount = 9
/// }
///
/// Example Failure Result:
/// {
///   IsValid = false,
///   Errors = [
///     "Realm 'Vanaheim' temperature out of valid range",
///     "Transition 'Asgard→Muspelheim' missing from config",
///     "Sector 4 assignment not set (required for center)"
///   ],
///   WarningCount = 2,
///   RealmCount = 8
/// }
/// </remarks>
ValidationResult ValidateAllBiomes();
```

**Implementation Notes:**
- Aggregate results from all sub-validation methods
- Collect all errors without stopping on first failure
- Include warning count and realm count in result

#### Method: ValidateBiome(RealmId realmId)

```csharp
/// <summary>
/// Validates a single biome's configuration.
/// </summary>
/// <param name="realmId">Realm to validate</param>
/// <returns>ValidationResult for this biome</returns>
/// <remarks>
/// Checks:
/// - Name and description not empty
/// - Temperature within valid range (-50°C to 60°C)
/// - Humidity within 0-100%
/// - DangerLevel valid enum value
/// - LightLevel 0-255
/// - At least one required feature exists
/// </remarks>
ValidationResult ValidateBiome(RealmId realmId);
```

#### Method: ValidateAdjacencyRules()

```csharp
/// <summary>
/// Validates that adjacency rules between realms are satisfied.
/// </summary>
/// <returns>ValidationResult for all adjacency constraints</returns>
/// <remarks>
/// Checks:
/// - All "RequiresTransition" pairs have defined transitions
/// - No "Incompatible" pairs have transitions
/// - Transition zones exist for assigned adjacent sectors
/// - Bidirectional consistency (if A→B valid, then B→A valid)
/// </remarks>
ValidationResult ValidateAdjacencyRules();
```

#### Method: ValidateZoneConfiguration(RealmId realmId)

```csharp
/// <summary>
/// Validates that a realm's zones are properly configured.
/// </summary>
/// <param name="realmId">Realm to validate</param>
/// <returns>ValidationResult for this realm's zone configuration</returns>
/// <remarks>
/// Checks:
/// - Each zone has a unique identifier
/// - Zone properties are within valid ranges
/// - Zone hazards are appropriate for realm danger level
/// </remarks>
ValidationResult ValidateZoneConfiguration(RealmId realmId);
```

---

## Data Transfer Objects (DTOs)

### TransitionZone DTO

```csharp
/// <summary>
/// Represents a single transition zone between two realms.
/// </summary>
public class TransitionZone
{
    /// <summary>
    /// Unique identifier for this transition zone.
    /// Format: "from_realm_name→to_realm_name_sequence_index"
    /// Example: "Midgard→Vanaheim_0"
    /// </summary>
    public string Id { get; set; }

    /// <summary>
    /// Source realm identifier.
    /// </summary>
    public RealmId FromRealm { get; set; }

    /// <summary>
    /// Destination realm identifier.
    /// </summary>
    public RealmId ToRealm { get; set; }

    /// <summary>
    /// Order in sequence (0 = closest to source, n = closest to dest).
    /// For single-zone transitions, this is 0.
    /// </summary>
    public int SequenceIndex { get; set; }

    /// <summary>
    /// Interpolation blend factor (0.0 = from, 1.0 = to).
    /// Example: 0.5 for midpoint transition.
    /// </summary>
    public double BlendFactor { get; set; }

    /// <summary>
    /// Interpolated biome properties at this transition point.
    /// </summary>
    public BiomeProperties InterpolatedProperties { get; set; }

    /// <summary>
    /// Time to traverse this zone (seconds).
    /// </summary>
    public int TraversalTimeSeconds { get; set; }

    /// <summary>
    /// Hazard level specific to this transition.
    /// </summary>
    public DangerLevel HazardLevel { get; set; }

    /// <summary>
    /// Environmental description of this zone.
    /// </summary>
    public string Description { get; set; }
}
```

### RouteClassification DTO

```csharp
/// <summary>
/// Classifies a route between two realms.
/// </summary>
public class RouteClassification
{
    /// <summary>
    /// Source realm.
    /// </summary>
    public RealmId FromRealm { get; set; }

    /// <summary>
    /// Destination realm.
    /// </summary>
    public RealmId ToRealm { get; set; }

    /// <summary>
    /// Safety level of this route.
    /// </summary>
    public RouteSafety Safety { get; set; }

    /// <summary>
    /// Difficulty class (DC) for skill checks.
    /// Typical values: None (0), 10, 14, 18
    /// </summary>
    public int DifficultyClass { get; set; }

    /// <summary>
    /// Estimated travel time via this route.
    /// </summary>
    public TimeSpan EstimatedTravelTime { get; set; }

    /// <summary>
    /// Number of transition zones required.
    /// 0 = direct (compatible), 1-3 = transition, null = impossible
    /// </summary>
    public int? TransitionZoneCount { get; set; }

    /// <summary>
    /// Compatibility status between realms.
    /// </summary>
    public CompatibilityStatus Compatibility { get; set; }

    /// <summary>
    /// Human-readable description of route hazards.
    /// </summary>
    public string HazardDescription { get; set; }
}

/// <summary>
/// Safety levels for routes.
/// </summary>
public enum RouteSafety
{
    Safe = 0,           // DC None, no hazards
    Moderate = 1,       // DC 10, some environmental hazards
    Dangerous = 2,      // DC 14, significant hazards
    Extreme = 3         // DC 18, severe reality hazards
}

/// <summary>
/// Realm compatibility status.
/// </summary>
public enum CompatibilityStatus
{
    Compatible = 0,          // 0-1 transition zone
    RequiresTransition = 1,  // 1-3 transition zones
    Incompatible = 2         // No transition possible
}
```

### SectorBiomeAssignment DTO

```csharp
/// <summary>
/// Assigns a biome to a dungeon sector.
/// </summary>
public class SectorBiomeAssignment
{
    /// <summary>
    /// Sector number (0-8 for 9-sector layout).
    /// </summary>
    public int SectorNumber { get; set; }

    /// <summary>
    /// Primary realm assigned to this sector.
    /// </summary>
    public RealmId PrimaryRealm { get; set; }

    /// <summary>
    /// Grid position (for visual layout).
    /// Example: (1, 1) for center sector in 3x3 grid.
    /// </summary>
    public (int X, int Y) GridPosition { get; set; }

    /// <summary>
    /// Adjacent sector numbers (for connectivity).
    /// Example: Sector 4 (center) adjacent to [1,3,5,7]
    /// </summary>
    public List<int> AdjacentSectors { get; set; }

    /// <summary>
    /// Whether this sector is central (typically sector 4).
    /// </summary>
    public bool IsCentral { get; set; }

    /// <summary>
    /// Accessibility from other sectors.
    /// </summary>
    public List<int> AccessibleFrom { get; set; }
}
```

### ValidationResult DTO

```csharp
/// <summary>
/// Result of biome validation checks.
/// </summary>
public class ValidationResult
{
    /// <summary>
    /// True if all validation checks passed.
    /// </summary>
    public bool IsValid { get; set; }

    /// <summary>
    /// List of error messages (empty if valid).
    /// </summary>
    public List<string> Errors { get; set; }

    /// <summary>
    /// Number of warnings (non-fatal issues).
    /// </summary>
    public int WarningCount { get; set; }

    /// <summary>
    /// Number of validated realms.
    /// </summary>
    public int RealmCount { get; set; }

    /// <summary>
    /// Timestamp of validation.
    /// </summary>
    public DateTime ValidatedAt { get; set; }

    /// <summary>
    /// Validation duration (milliseconds).
    /// </summary>
    public long ElapsedMilliseconds { get; set; }
}
```

---

## Transition Zone Mechanics

### Compatibility Matrix

Define realm-to-realm compatibility in a matrix format (loaded from routes.json):

```
Matrix Structure (9 realms):
         M    V    Mu   N    J    A    H    S    Mo
M (Midgard)      C    RT   RT   C    RT   RT   RT   Mu
V (Vanaheim)     C         RT   RT   RT   RT   I    RT
Mu (Muspelheim)  RT   RT        I    I    RT   I    I
N (Niflheim)     RT   RT   I         I    RT   I    I
J (Jotunheim)    C    RT   I    I         RT   RT   RT
A (Asgard)       RT   RT   RT   RT   RT        RT   RT
H (Hel)          RT   I    I    I    RT   RT        RT
S (Svartalfheim) RT   RT   I    I    RT   RT   RT        RT
Mo (Muspelheim-v)Mu   RT   I    I    RT   RT   RT   RT

Legend:
C  = Compatible (0-1 zone)
RT = RequiresTransition (1-3 zones)
I  = Incompatible (no transition)
```

### Compatibility Rules

**Compatible (C):** Realms can be adjacent with 0 transition zones or 1 buffer room.
- Environmental properties are similar enough for direct transition
- Example: Midgard (18°C) ↔ Vanaheim (20°C) - both temperate

**RequiresTransition (RT):** Realms require 1-3 transition zones.
- Environmental difference is significant but bridgeable
- Number of zones depends on property difference magnitude
- Example: Vanaheim (20°C) ↔ Jotunheim (-15°C) - requires 2-3 zones

**Incompatible (I):** Realms cannot be directly connected.
- Environmental difference is too extreme for safe transition
- Example: Muspelheim (50°C) ↔ Niflheim (-40°C) - no direct path

### Transition Zone Count Logic

```csharp
private int DetermineTransitionZoneCount(BiomeProperties from, BiomeProperties to)
{
    double temperatureDiff = Math.Abs(from.Temperature - to.Temperature);
    double humidityDiff = Math.Abs(from.Humidity - to.Humidity);
    double dangerDiff = Math.Abs((int)from.DangerLevel - (int)to.DangerLevel);

    // Weighted calculation
    double totalDifference = (temperatureDiff * 0.5) + (humidityDiff * 0.3) + (dangerDiff * 0.2);

    // Determine zone count
    if (totalDifference < 10) return 1;      // Minor difference
    if (totalDifference < 25) return 2;      // Moderate difference
    return 3;                                 // Significant difference
}
```

---

## Property Interpolation Algorithm

### Linear Interpolation Formula

For numeric properties (temperature, humidity, light level):

```
result = from + (to - from) * blend
```

**Example: Midgard (18°C) to Vanaheim (28°C) at blend=0.5**
```
result = 18 + (28 - 18) * 0.5
       = 18 + 10 * 0.5
       = 18 + 5
       = 23°C
```

### Multi-Zone Interpolation

For 3-zone transitions from realm A to realm B:
```
Zone 1: blend = 0.25  → A + (B - A) * 0.25 (25% toward B)
Zone 2: blend = 0.50  → A + (B - A) * 0.50 (50% toward B)
Zone 3: blend = 0.75  → A + (B - A) * 0.75 (75% toward B)
Final: Realm B properties
```

### Categorical Property Interpolation

For enum properties (DangerLevel), use weighted selection:

```csharp
public DangerLevel InterpolateEnumProperty(
    DangerLevel from,
    DangerLevel to,
    double blend)
{
    int fromValue = (int)from;
    int toValue = (int)to;
    int interpolated = (int)Math.Round(fromValue + (toValue - fromValue) * blend);
    return (DangerLevel)Math.Clamp(interpolated, 0, 4);
}
```

---

## Sector Assignment System

### 9-Sector Standard Layout

```
Grid Representation:
┌───┬───┬───┐
│ 0 │ 1 │ 2 │  Coordinates:
├───┼───┼───┤  (0,0) (1,0) (2,0)
│ 3 │ 4 │ 5 │  (0,1) (1,1) (2,1)
├───┼───┼───┤  (0,2) (1,2) (2,2)
│ 6 │ 7 │ 8 │
└───┴───┴───┘

Sector Assignments (Deterministic Example):
- Sector 0 (NW): Vanaheim
- Sector 1 (N):  Midgard
- Sector 2 (NE): Jotunheim
- Sector 3 (W):  Hel
- Sector 4 (C):  Asgard (Yggdrasil)
- Sector 5 (E):  Muspelheim
- Sector 6 (SW): Svartalfheim
- Sector 7 (S):  Niflheim
- Sector 8 (SE): Muspelheim-variant
```

### Adjacency Rules

For the 3x3 grid:
- Sector 4 (center) is adjacent to all other sectors
- Corner sectors (0,2,6,8) are adjacent to 3 other sectors
- Edge sectors (1,3,5,7) are adjacent to 4 other sectors
- Diagonal connections exist in some configurations

### Implementation Algorithm

```csharp
private Dictionary<int, RealmId> GenerateSectorAssignments()
{
    var assignments = new Dictionary<int, RealmId>();

    // Predefined for 9 sectors
    var realmOrder = new RealmId[] {
        RealmId.Vanaheim,        // 0
        RealmId.Midgard,         // 1
        RealmId.Jotunheim,       // 2
        RealmId.Hel,             // 3
        RealmId.Asgard,          // 4 (center)
        RealmId.Muspelheim,      // 5
        RealmId.Svartalfheim,    // 6
        RealmId.Niflheim,        // 7
        RealmId.MuspelheimVariant // 8
    };

    for (int i = 0; i < 9; i++)
    {
        assignments[i] = realmOrder[i];
    }

    return assignments;
}
```

---

## Route Classification System

### Safety Classification Logic

```csharp
private RouteSafety ClassifyRouteSafety(
    RealmId from,
    RealmId to,
    CompatibilityStatus compatibility)
{
    // Same realm = Safe
    if (from == to) return RouteSafety.Safe;

    // Compatible realms = Safe or Moderate
    if (compatibility == CompatibilityStatus.Compatible)
    {
        return RouteSafety.Safe;
    }

    // RequiresTransition = Moderate to Dangerous
    if (compatibility == CompatibilityStatus.RequiresTransition)
    {
        var difference = CalculateEnvironmentalDifference(from, to);
        return difference < 20 ? RouteSafety.Moderate : RouteSafety.Dangerous;
    }

    // Incompatible = Extreme
    return RouteSafety.Extreme;
}
```

### Difficulty Class Mapping

```
RouteSafety → Difficulty Class
Safe         → 0 (DC None / Automatic)
Moderate     → 10
Dangerous    → 14
Extreme      → 18
```

### Travel Time Estimation

```csharp
private TimeSpan EstimateTravelTime(RouteSafety safety)
{
    const int BaseHours = 4;

    var multipliers = new Dictionary<RouteSafety, double>
    {
        { RouteSafety.Safe, 1.0 },        // 4 hours
        { RouteSafety.Moderate, 1.5 },    // 6 hours
        { RouteSafety.Dangerous, 2.0 },   // 8 hours
        { RouteSafety.Extreme, 3.0 }      // 12 hours
    };

    double hours = BaseHours * multipliers[safety];
    return TimeSpan.FromHours(hours);
}
```

---

## Biome Validation Framework

### Validation Rules

**Individual Biome Validation:**
- Name: not null/empty, 2-50 characters
- Description: not null/empty
- Temperature: -50°C to 60°C
- Humidity: 0-100%
- DangerLevel: valid enum value
- LightLevel: 0-255 scale
- Features: at least one feature defined

**Adjacency Validation:**
- All RequiresTransition pairs have configurations
- No Incompatible pairs have transitions
- Bidirectional consistency
- Sector assignments respect adjacency

**Transition Zone Validation:**
- Valid source and destination realms
- Interpolated properties within valid ranges
- Blend factors 0.0-1.0
- Hazard levels consistent with realms

### Validation Execution Order

```
1. Validate each realm configuration
   ├─ Check all properties within ranges
   ├─ Verify required fields present
   └─ Confirm feature definitions

2. Validate adjacency rules
   ├─ Check compatibility matrix
   ├─ Verify transition configurations
   └─ Test bidirectional consistency

3. Validate zone configurations
   ├─ Check unique zone IDs
   ├─ Verify property ranges
   └─ Confirm hazard appropriateness

4. Aggregate results
   ├─ Collect all errors
   ├─ Count warnings
   └─ Generate summary report
```

---

## Configuration Schema (routes.json)

### File Structure

```json
{
  "version": "1.0",
  "lastUpdated": "2026-01-28T00:00:00Z",
  "realms": [
    {
      "id": "midgard",
      "displayName": "Midgard",
      "temperature": 18,
      "humidity": 60,
      "dangerLevel": "Low",
      "lightLevel": 200,
      "description": "The realm of humans and nature"
    }
  ],
  "compatibilityMatrix": {
    "midgard": {
      "vanaheim": "Compatible",
      "muspelheim": "RequiresTransition",
      "niflheim": "RequiresTransition"
    }
  },
  "sectorAssignments": {
    "totalSectors": 9,
    "layout": "3x3-grid",
    "assignments": [
      {"sector": 0, "realm": "vanaheim", "gridX": 0, "gridY": 0},
      {"sector": 4, "realm": "asgard", "gridX": 1, "gridY": 1, "isCentral": true}
    ]
  },
  "routeClassifications": [
    {
      "from": "midgard",
      "to": "vanaheim",
      "safety": "Safe",
      "difficultyClass": 0,
      "transitionZoneCount": 0
    }
  ]
}
```

---

## Decision Trees

### Transition Zone Generation Decision Tree

```
Input: fromRealm, toRealm
│
├─ Are realms identical?
│  └─ YES → Return null (no transition needed)
│
├─ Are realms Compatible?
│  └─ YES → Generate 0-1 zone (usually 0)
│
├─ Are realms RequiresTransition?
│  └─ YES → Calculate zone count (1-3)
│           Generate transition sequence
│
└─ Are realms Incompatible?
   └─ YES → Return null (no transition possible)
```

### Route Classification Decision Tree

```
Input: fromRealm, toRealm
│
├─ Same realm?
│  └─ YES → Return Safe (DC 0)
│
├─ Compatible?
│  └─ YES → Check environmental difference
│           └─ Difference < 15 → Safe (DC 0)
│           └─ Difference ≥ 15 → Moderate (DC 10)
│
├─ RequiresTransition?
│  └─ YES → Check zone count and difference
│           └─ 1 zone, diff < 20 → Moderate (DC 10)
│           └─ 2 zones, diff 20-30 → Dangerous (DC 14)
│           └─ 3 zones, diff > 30 → Extreme (DC 18)
│
└─ Incompatible?
   └─ YES → Return Extreme (DC 18)
```

### Biome Validation Decision Tree

```
Input: All realms and configurations
│
├─ Validate each realm individually
│  └─ IF any realm invalid → Add to errors list
│
├─ Validate adjacency rules
│  └─ IF rule violation → Add to errors list
│
├─ Validate zone configurations
│  └─ IF zone invalid → Add to errors list
│
├─ Check error count
│  ├─ IF errors empty → Set IsValid = true
│  └─ IF errors exist → Set IsValid = false
│
└─ Return ValidationResult
```

---

## Code Examples with XML Documentation

### Example 1: Transition Zone Generation

```csharp
namespace RuneRust.Biome.Services
{
    /// <summary>
    /// Generates transition zones between realms.
    /// Handles property interpolation and compatibility checking.
    /// </summary>
    public class TransitionZoneGenerator : ITransitionZoneGenerator
    {
        private readonly IRealmConfigurationService _realmConfig;
        private readonly ILogger<TransitionZoneGenerator> _logger;
        private readonly CompatibilityMatrix _matrix;

        /// <summary>
        /// Initializes a new instance of TransitionZoneGenerator.
        /// </summary>
        /// <param name="realmConfig">Realm configuration service</param>
        /// <param name="logger">Logger instance</param>
        /// <param name="matrix">Compatibility matrix</param>
        public TransitionZoneGenerator(
            IRealmConfigurationService realmConfig,
            ILogger<TransitionZoneGenerator> logger,
            CompatibilityMatrix matrix)
        {
            _realmConfig = realmConfig ?? throw new ArgumentNullException(nameof(realmConfig));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _matrix = matrix ?? throw new ArgumentNullException(nameof(matrix));
        }

        /// <summary>
        /// Generates a single transition zone between two realms.
        /// </summary>
        /// <param name="fromRealm">Source realm ID</param>
        /// <param name="toRealm">Destination realm ID</param>
        /// <returns>TransitionZone or null if no transition possible</returns>
        /// <exception cref="ArgumentNullException">If realm IDs are null</exception>
        public TransitionZone? GenerateTransition(RealmId fromRealm, RealmId toRealm)
        {
            if (fromRealm == null) throw new ArgumentNullException(nameof(fromRealm));
            if (toRealm == null) throw new ArgumentNullException(nameof(toRealm));

            _logger.LogDebug($"Generating transition from {fromRealm} to {toRealm}");

            // Check compatibility
            if (!CanGenerateTransition(fromRealm, toRealm))
            {
                _logger.LogWarning($"Transition not possible: {fromRealm} → {toRealm}");
                return null;
            }

            // Get biome properties
            var fromBiome = _realmConfig.GetRealm(fromRealm);
            var toBiome = _realmConfig.GetRealm(toRealm);

            // Interpolate at 50% blend for single zone
            var interpolatedProps = InterpolateProperties(
                fromBiome.Properties,
                toBiome.Properties,
                0.5);

            var zone = new TransitionZone
            {
                Id = $"{fromRealm}→{toRealm}_0",
                FromRealm = fromRealm,
                ToRealm = toRealm,
                SequenceIndex = 0,
                BlendFactor = 0.5,
                InterpolatedProperties = interpolatedProps,
                TraversalTimeSeconds = 900, // 15 minutes
                HazardLevel = DeterminHazardLevel(fromBiome, toBiome),
                Description = GenerateTransitionDescription(fromRealm, toRealm)
            };

            _logger.LogInformation($"Transition generated: {zone.Id}");
            return zone;
        }

        /// <summary>
        /// Interpolates biome properties between two realms.
        /// </summary>
        /// <param name="from">Source properties</param>
        /// <param name="to">Destination properties</param>
        /// <param name="blend">Interpolation factor (0-1)</param>
        /// <returns>Interpolated properties</returns>
        public BiomeProperties InterpolateProperties(
            BiomeProperties from,
            BiomeProperties to,
            double blend)
        {
            if (blend < 0 || blend > 1)
                throw new ArgumentOutOfRangeException(nameof(blend), "Blend must be 0-1");

            var temperature = from.Temperature + (to.Temperature - from.Temperature) * blend;
            var humidity = from.Humidity + (to.Humidity - from.Humidity) * blend;

            return new BiomeProperties
            {
                Temperature = temperature,
                Humidity = humidity,
                DangerLevel = InterpolateEnumProperty(from.DangerLevel, to.DangerLevel, blend),
                LightLevel = (int)Math.Round(from.LightLevel + (to.LightLevel - from.LightLevel) * blend)
            };
        }

        /// <summary>
        /// Checks if a transition can be generated.
        /// </summary>
        /// <param name="from">Source realm</param>
        /// <param name="to">Destination realm</param>
        /// <returns>true if transition possible</returns>
        public bool CanGenerateTransition(RealmId from, RealmId to)
        {
            if (from == to) return false; // Same realm doesn't need transition

            var status = _matrix.GetCompatibility(from, to);
            return status != CompatibilityStatus.Incompatible;
        }

        private DangerLevel InterpolateEnumProperty(
            DangerLevel from,
            DangerLevel to,
            double blend)
        {
            int fromValue = (int)from;
            int toValue = (int)to;
            int result = (int)Math.Round(fromValue + (toValue - fromValue) * blend);
            return (DangerLevel)Math.Clamp(result, 0, 4);
        }

        private DangerLevel DeterminHazardLevel(BiomeConfiguration from, BiomeConfiguration to)
        {
            // Average the danger levels with some variance
            int average = ((int)from.Properties.DangerLevel + (int)to.Properties.DangerLevel) / 2;
            return (DangerLevel)Math.Min(average + 1, 4);
        }

        private string GenerateTransitionDescription(RealmId from, RealmId to)
        {
            return $"Transition zone between {from} and {to}";
        }
    }
}
```

### Example 2: Route Classification

```csharp
namespace RuneRust.Biome.Services
{
    /// <summary>
    /// Classifies routes between realms by safety and difficulty.
    /// </summary>
    public class RouteClassificationService : IRouteClassificationService
    {
        private readonly ITransitionZoneGenerator _transitionGenerator;
        private readonly CompatibilityMatrix _matrix;
        private readonly ILogger<RouteClassificationService> _logger;
        private Dictionary<string, RouteClassification> _routeCache;

        /// <summary>
        /// Initializes a new instance of RouteClassificationService.
        /// </summary>
        public RouteClassificationService(
            ITransitionZoneGenerator transitionGenerator,
            CompatibilityMatrix matrix,
            ILogger<RouteClassificationService> logger)
        {
            _transitionGenerator = transitionGenerator;
            _matrix = matrix;
            _logger = logger;
            _routeCache = new Dictionary<string, RouteClassification>();
        }

        /// <summary>
        /// Classifies a route between two realms.
        /// </summary>
        /// <param name="from">Source realm</param>
        /// <param name="to">Destination realm</param>
        /// <returns>Route classification with safety and difficulty</returns>
        public RouteClassification ClassifyRoute(RealmId from, RealmId to)
        {
            var cacheKey = $"{from}→{to}";

            if (_routeCache.TryGetValue(cacheKey, out var cached))
            {
                return cached;
            }

            var compatibility = _matrix.GetCompatibility(from, to);
            var safety = ClassifyRouteSafety(from, to, compatibility);
            var dc = MapSafetyToDifficultyClass(safety);
            var travelTime = EstimateTravelTime(safety);

            int? zoneCount = null;
            if (_transitionGenerator.CanGenerateTransition(from, to))
            {
                var zone = _transitionGenerator.GenerateTransition(from, to);
                zoneCount = zone != null ? 1 : 0;
            }

            var classification = new RouteClassification
            {
                FromRealm = from,
                ToRealm = to,
                Safety = safety,
                DifficultyClass = dc,
                EstimatedTravelTime = travelTime,
                TransitionZoneCount = zoneCount,
                Compatibility = compatibility,
                HazardDescription = GenerateHazardDescription(from, to, safety)
            };

            _routeCache[cacheKey] = classification;
            _logger.LogDebug($"Classified route {cacheKey} as {safety}");

            return classification;
        }

        /// <summary>
        /// Gets the safety level for a route.
        /// </summary>
        public RouteSafety GetRouteSafety(RouteClassification classification)
        {
            return classification?.Safety ?? RouteSafety.Extreme;
        }

        /// <summary>
        /// Estimates travel time for a route.
        /// </summary>
        public TimeSpan EstimateTravelTime(RealmId from, RealmId to)
        {
            var classification = ClassifyRoute(from, to);
            return classification.EstimatedTravelTime;
        }

        /// <summary>
        /// Gets all classified routes.
        /// </summary>
        public List<RouteClassification> GetAllRoutes()
        {
            return _routeCache.Values.ToList();
        }

        private RouteSafety ClassifyRouteSafety(
            RealmId from,
            RealmId to,
            CompatibilityStatus compatibility)
        {
            if (from == to) return RouteSafety.Safe;

            if (compatibility == CompatibilityStatus.Compatible)
                return RouteSafety.Safe;

            if (compatibility == CompatibilityStatus.RequiresTransition)
                return RouteSafety.Moderate;

            return RouteSafety.Extreme;
        }

        private int MapSafetyToDifficultyClass(RouteSafety safety) => safety switch
        {
            RouteSafety.Safe => 0,
            RouteSafety.Moderate => 10,
            RouteSafety.Dangerous => 14,
            RouteSafety.Extreme => 18,
            _ => 20
        };

        private TimeSpan EstimateTravelTime(RouteSafety safety)
        {
            const int BaseHours = 4;
            var multiplier = safety switch
            {
                RouteSafety.Safe => 1.0,
                RouteSafety.Moderate => 1.5,
                RouteSafety.Dangerous => 2.0,
                RouteSafety.Extreme => 3.0,
                _ => 4.0
            };

            return TimeSpan.FromHours(BaseHours * multiplier);
        }

        private string GenerateHazardDescription(RealmId from, RealmId to, RouteSafety safety)
        {
            return safety switch
            {
                RouteSafety.Safe => "No environmental hazards on this route",
                RouteSafety.Moderate => "Minor environmental hazards may be encountered",
                RouteSafety.Dangerous => "Significant hazards present; skilled navigation required",
                RouteSafety.Extreme => "Severe hazards; experienced adventurers only",
                _ => "Unknown hazard level"
            };
        }
    }
}
```

---

## Logging & Monitoring

### Logging Levels and Scope

**DEBUG:**
- Transition zone generation attempts
- Property interpolation calculations
- Route classification queries

**INFORMATION:**
- Successfully generated transitions
- Completed validation runs
- Route classifications cached

**WARNING:**
- Impossible transitions attempted
- Validation warnings (e.g., marginal values)
- Compatibility edge cases

**ERROR:**
- Validation failures
- Configuration errors
- Invalid realm references

### Sample Log Entries

```
[INFO] TransitionZoneGenerator: Transition generated: Midgard→Vanaheim_0
[DEBUG] TransitionZoneGenerator: Interpolated temperature: 18°C + 28°C = 23°C at blend 0.5
[WARN] RouteClassificationService: Route Vanaheim→Muspelheim requires extreme caution
[ERROR] BiomeValidationService: Validation failed: 3 errors, 2 warnings
```

---

## Unit Testing Strategy (~28 Tests)

### Test Categories and Count

**TransitionZoneGenerator Tests (8 tests):**
1. ✓ GenerateTransition_Compatible_ReturnsZone
2. ✓ GenerateTransition_RequiresTransition_ReturnsZone
3. ✓ GenerateTransition_Incompatible_ReturnsNull
4. ✓ GenerateTransitionSequence_ThreeZones_ReturnsOrderedList
5. ✓ InterpolateProperties_MidpointBlend_ReturnsAveragedProperties
6. ✓ InterpolateProperties_BlendBoundaries_ReturnsCorrectValues
7. ✓ CanGenerateTransition_SameRealm_ReturnsFalse
8. ✓ CanGenerateTransition_ValidPair_ReturnsTrue

**SectorAssignmentService Tests (6 tests):**
9. ✓ AssignBiome_CenterSector_ReturnsAsgard
10. ✓ AssignBiome_AllSectors_ReturnsDeterministicLayout
11. ✓ GetPrimaryRealmForSector_ValidIndex_ReturnsRealmId
12. ✓ GenerateAssignments_NineSectors_ReturnNineAssignments
13. ✓ GenerateAssignments_SectorAdjacency_ReturnsCorrectConnections
14. ✓ AssignBiome_DifferentSeeds_ProduceIdenticalLayouts

**RouteClassificationService Tests (7 tests):**
15. ✓ ClassifyRoute_SameRealm_ReturnsSafe
16. ✓ ClassifyRoute_Compatible_ReturnsSafe
17. ✓ ClassifyRoute_RequiresTransition_ReturnsModerate
18. ✓ ClassifyRoute_Incompatible_ReturnsExtreme
19. ✓ GetRouteSafety_ExtractsFromClassification_ReturnsValue
20. ✓ EstimateTravelTime_Moderate_ReturnsCorrectDuration
21. ✓ GetAllRoutes_ReturnsCompleteMatrix_Returns81Routes

**BiomeValidationService Tests (7 tests):**
22. ✓ ValidateAllBiomes_ValidConfiguration_ReturnsIsValidTrue
23. ✓ ValidateAllBiomes_InvalidTemperature_ReturnsError
24. ✓ ValidateBiome_OutOfRangeHumidity_ReturnsError
25. ✓ ValidateAdjacencyRules_IncompatiblePair_ReturnsError
26. ✓ ValidateZoneConfiguration_ValidZones_ReturnsNoError
27. ✓ ValidateAllBiomes_MultipleErrors_ReturnsAllErrors
28. ✓ ValidateAllBiomes_IncludesRealmCount_ReturnsAccurateCount

### Test Execution Standards

- All tests use AAA pattern (Arrange, Act, Assert)
- Mock external dependencies (IRealmConfigurationService, ILogger)
- Each test has single responsibility
- Clear, descriptive test names
- Tests execute in < 100ms each
- Coverage target: ≥ 85%

---

## Deliverable Checklist

**Implementation Deliverables:**
- [ ] ITransitionZoneGenerator interface implementation
- [ ] TransitionZoneGenerator class with all methods
- [ ] ISectorAssignmentService interface implementation
- [ ] SectorAssignmentService class with all methods
- [ ] IRouteClassificationService interface implementation
- [ ] RouteClassificationService class with all methods
- [ ] IBiomeValidationService interface implementation
- [ ] BiomeValidationService class with all methods

**DTO Deliverables:**
- [ ] TransitionZone class
- [ ] RouteClassification class + RouteSafety enum + CompatibilityStatus enum
- [ ] SectorBiomeAssignment class
- [ ] ValidationResult class

**Configuration Deliverables:**
- [ ] routes.json configuration file with full compatibility matrix
- [ ] Configuration loader implementation
- [ ] Configuration validation logic

**Documentation Deliverables:**
- [ ] This design specification (v0.19.6a-design-specification.md)
- [ ] API documentation (XML comments on all public members)
- [ ] Architecture diagrams (in specification or separate)
- [ ] Example usage guide

**Testing Deliverables:**
- [ ] All 28 unit tests implemented and passing
- [ ] Test coverage report (≥ 85%)
- [ ] Integration tests for service interactions
- [ ] Mock/fake implementations for testing

**Quality Assurance:**
- [ ] Code style conformance (C# conventions)
- [ ] Static analysis passes (no critical issues)
- [ ] Performance benchmarks (service methods < 10ms)
- [ ] Logging verification

---

## Acceptance Criteria

### Functional Requirements

**FR-1: Transition Zone Generation**
- All 4 TransitionZoneGenerator methods implemented
- Compatible and RequiresTransition pairs properly identified
- Property interpolation accurate to 0.01% precision
- Incompatible pairs correctly return null

**FR-2: Sector Assignment**
- 9-sector layout deterministically assigned
- Each sector receives exactly one realm
- Adjacency relationships correctly calculated
- Reproducible with same parameters

**FR-3: Route Classification**
- All possible realm-to-realm routes classified
- Safety levels correctly assigned per compatibility
- Difficulty classes match safety levels (0, 10, 14, 18)
- Travel times proportional to difficulty

**FR-4: Biome Validation**
- Individual realm validation checks all properties
- Adjacency validation covers all realm pairs
- Zone configuration validated comprehensively
- Detailed error messages provided

### Non-Functional Requirements

**NFR-1: Performance**
- GenerateTransition() completes in < 5ms
- ClassifyRoute() completes in < 3ms
- ValidateAllBiomes() completes in < 50ms
- Caching prevents redundant calculations

**NFR-2: Reliability**
- All null inputs handled with ArgumentNullException
- All enum values in valid range
- Configuration file missing handled gracefully
- Logging captures all significant events

**NFR-3: Maintainability**
- All public methods have XML documentation
- Code follows C# naming conventions
- Dependency injection used throughout
- Tests cover ≥ 85% of code paths

**NFR-4: Correctness**
- All 28 unit tests passing
- Integration tests verify service interactions
- Configuration validates against schema
- No console output (logging only)

---

## Dependencies & Prerequisites

### .NET Framework Requirements
- .NET 6.0 or higher
- Microsoft.Extensions.DependencyInjection
- Microsoft.Extensions.Logging

### Internal Dependencies
- `RuneRust.Biome.Models` (RealmId, BiomeProperties, DangerLevel enums)
- `RuneRust.Biome.Configuration` (IRealmConfigurationService)
- `RuneRust.Core.Logging` (ILogger<T>)

### External Dependencies
- routes.json configuration file (must exist and be valid)
- Valid RealmId enum with 9 values
- Valid BiomeConfiguration types

### Installation & Setup
1. Reference RuneRust.Biome.Services project
2. Register services in dependency injection container:
   ```csharp
   services.AddScoped<ITransitionZoneGenerator, TransitionZoneGenerator>();
   services.AddScoped<ISectorAssignmentService, SectorAssignmentService>();
   services.AddScoped<IRouteClassificationService, RouteClassificationService>();
   services.AddScoped<IBiomeValidationService, BiomeValidationService>();
   ```
3. Load and validate routes.json during startup
4. Initialize CompatibilityMatrix from configuration

---

## v0.19.x Completion Summary

### Phases 1-5 (Prior Implementations)
- **v0.19.1a:** Core Realm Models (9 realms defined)
- **v0.19.2a:** Biome Properties System (Temperature, Humidity, Danger)
- **v0.19.3a:** Zone Variant Generation (Diverse properties per realm)
- **v0.19.4a:** Environmental Hazard System (Procedural hazard generation)
- **v0.19.5a:** Feature Integration (Realm-specific features)

### Phase 6 (Current: v0.19.6a)
**Biome Integration & Transitions**
- ✓ Transition zone generation between realms
- ✓ Property interpolation at arbitrary blend factors
- ✓ Sector assignment for dungeon layout
- ✓ Route classification by safety and difficulty
- ✓ Comprehensive biome validation system

### Key Achievements
- **9 Realms Interconnected:** All Norse realms now seamlessly connected via transition zones
- **Deterministic Layouts:** Sector assignments reproducible across game sessions
- **Safety Classification:** Clear hazard assessment for player decision-making
- **Validation Framework:** Ensures data integrity across all configurations
- **~28 Unit Tests:** Comprehensive test coverage for all services

### Architecture Summary

The v0.19.6a phase brings together all previous biome systems into a cohesive whole:

```
Realm Models (v0.19.1) → Biome Properties (v0.19.2) → Zone Variants (v0.19.3)
         ↓                       ↓                              ↓
    9 Realms          Temperature/Humidity/Danger      Variant Generation
                                  ↓
                    Environmental Hazards (v0.19.4)
                                  ↓
                    Feature Integration (v0.19.5)
                                  ↓
        ╔═══════════════════════════════════════════════════════╗
        ║         Biome Integration & Transitions (v0.19.6a)     ║
        ║  ┌─────────────┬────────────────┬────────────────┐    ║
        ║  │ Transitions │ Sector Assign. │ Route Class.   │    ║
        ║  │ & Interpol. │ & Validation   │ & Travel Time  │    ║
        ║  └─────────────┴────────────────┴────────────────┘    ║
        ╚═══════════════════════════════════════════════════════╝
                             ↓
                    Complete Biome System Ready for:
                    - Dungeon Generation
                    - NPC Pathfinding
                    - Environmental Encounters
                    - Gameplay Integration
```

### Testing Completeness

- **Unit Tests:** 28 tests covering all service methods
- **Integration Tests:** Verify service interactions (additional)
- **Configuration Tests:** Validate routes.json schema
- **Performance Tests:** Ensure sub-100ms execution
- **Validation Tests:** Comprehensive error scenarios

### Post-Implementation Roadmap

**v0.19.7a (Future):** Encounter Integration
- Realm-appropriate encounter tables
- Hazard-based encounter scaling
- NPC realm affiliation

**v0.19.8a (Future):** Loot & Rewards
- Realm-specific item tables
- Transition zone unique drops
- Route difficulty loot scaling

**v0.19.9a (Future):** Final Polish & Release
- Performance optimization
- Configuration UI tools
- Complete gameplay integration

---

**End of Design Specification**

This document provides comprehensive guidance for implementing v0.19.6a: Biome Integration & Transitions. The specification includes detailed service definitions, example code, testing strategies, and acceptance criteria necessary for a production-quality implementation of the final integration layer of the Rune Rust biome system.

For questions or clarifications, refer to the specific service sections or consult the architecture diagrams provided throughout this specification.
