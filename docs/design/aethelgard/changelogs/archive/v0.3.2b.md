> **Archived** - This changelog has been consolidated. See the complete version at [v0.3.2](../v0.3.x/v0.3.2.md).

# v0.3.2b Changelog: The Watch

**Release Date:** December 20, 2025
**Total Tests:** 1778 (all passing)

---

## Summary

Version 0.3.2b extends the Rest & Recovery system with ambush mechanics for wilderness rest. This release introduces risk-based encounter spawning driven by Room.DangerLevel, with character Wits providing mitigation through probabilistic dice pools. The ambush system integrates seamlessly with the existing RestService, consuming supplies even on failed rest attempts and applying the Disoriented status effect when caught off-guard.

Key additions:
- **AmbushService**: Calculates ambush probability using Room.DangerLevel and character Wits mitigation
- **Risk Calculation**: Base risk percentages (Safe=0%, Unstable=15%, Hostile=30%, Lethal=50%)
- **Wits Mitigation**: Dice pool rolls reduce risk by 5% per success, with 5% minimum floor
- **Encounter Generation**: Budget-based enemy selection prioritizing fast/stealthy ambush templates
- **Disoriented Status**: Applied to ambushed characters representing combat disadvantage
- **Supply Loss**: Supplies consumed even when rest is interrupted by ambush

This release touches the Engine Layer (service logic), Core Layer (models and interfaces), and Test Layer (25 new tests across 2 test classes).

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/AmbushResult.cs` | Record containing ambush check results with risk percentages, roll values, and optional encounter definition |
| `RuneAndRust.Core/Models/EncounterDefinition.cs` | Record defining combat encounter to spawn with template IDs, budget, and ambush flag |
| `RuneAndRust.Core/Interfaces/IAmbushService.cs` | Service interface for ambush risk calculation and encounter generation |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/AmbushService.cs` | Service implementation for ambush mechanics with dice-based mitigation and budget-based encounter spawning |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/AmbushServiceTests.cs` | Unit tests (17) covering ambush risk calculation, mitigation, safe zones, minimum floor, triggers, and encounter generation |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/RestResult.cs` | Added `WasAmbushed` bool field (default false) and `AmbushDetails` nullable field for ambush result data |
| `RuneAndRust.Core/Interfaces/IRestService.cs` | Added overload `PerformRestAsync(Character, RestType, Room)` for ambush-aware wilderness rest |
| `RuneAndRust.Engine/Services/RestService.cs` | Integrated `IAmbushService` dependency, added Room overload, implemented ambush check before recovery, added `PerformAmbushedRestAsync` private method applying Disoriented status |
| `RuneAndRust.Terminal/Program.cs` | Registered `IAmbushService` in DI container as scoped service, updated version display to v0.3.2b |
| `RuneAndRust.Tests/Engine/RestServiceTests.cs` | Added 8 ambush integration tests (total 28 tests in file) |

---

## Code Implementation Details

### AmbushResult Record

```csharp
public record AmbushResult(
    bool IsAmbush,                         // True if ambush was triggered
    string Message,                         // AAM-VOICE compliant narrative message
    int BaseRiskPercent,                    // Initial risk based on DangerLevel
    int MitigationPercent,                  // Risk reduction from Wits roll
    int FinalRiskPercent,                   // Final risk after mitigation (minimum 5% in dangerous zones)
    int RollValue,                          // The d100 roll result (1-100)
    int MitigationSuccesses,                // Number of successes on the Wits roll
    EncounterDefinition? Encounter = null   // Optional encounter if ambush triggered
);
```

**Purpose**: Captures complete ambush calculation state for UI display and combat initialization.

### EncounterDefinition Record

```csharp
public record EncounterDefinition(
    IReadOnlyList<string> TemplateIds,    // List of enemy template IDs to spawn
    float Budget,                          // The encounter budget used for scaling
    bool IsAmbush,                         // Whether this is an ambush encounter (affects initiative)
    string EncounterType = "Ambush"        // Type classification for logging and loot tables
);
```

**Purpose**: Defines combat encounter structure. Future-proofed for random encounter generation beyond ambushes.

### IAmbushService Interface

**Method Signatures:**
```csharp
Task<AmbushResult> CalculateAmbushAsync(Character character, Room room);
EncounterDefinition GenerateAmbushEncounter(Room room, int partyLevel = 1);
int GetBaseRisk(DangerLevel dangerLevel);
```

**Responsibilities:**
- Calculate ambush risk using Room.DangerLevel and character Wits
- Generate budget-appropriate enemy groups for ambush encounters
- Provide base risk lookup for danger level tiers

### AmbushService Implementation

**Constants:**
```csharp
MitigationPerSuccess = 5      // 5% risk reduction per Wits success
MinimumRiskFloor = 5          // 5% minimum in dangerous zones (DangerLevel > Safe)
AmbushBudgetMultiplier = 0.8f // 80% of standard encounter budget
BaseEncounterBudget = 100f    // Base budget before level scaling
```

**Enemy Template Costs:**
```csharp
"bst_vargr_01" => 40f    // Ash-Vargr (GlassCannon, fast)
"mec_serv_01" => 25f     // Utility Servitor (Swarm, cheap)
"hum_raider_01" => 35f   // Rust-Clan Scav (Support, opportunistic)
```

**Base Risk by DangerLevel:**
- **Safe**: 0% (no ambush possible)
- **Unstable**: 15%
- **Hostile**: 30%
- **Lethal**: 50%

**Key Behaviors:**

1. **CalculateAmbushAsync(Character, Room)**:
   - Returns safe result immediately if DangerLevel.Safe (no dice rolls)
   - Rolls Wits dice pool for mitigation (successes × 5% reduction)
   - Applies minimum 5% floor in dangerous zones after mitigation
   - Rolls d100 against final risk (ambush if roll ≤ risk)
   - Generates encounter if ambush triggered

2. **GenerateAmbushEncounter(Room, int partyLevel)**:
   - Calculates budget: `100 × (1 + (level-1) × 0.1) × 0.8`
   - Prioritizes Ash-Vargr (cost 40) for ambush flavor
   - Fills remaining budget with Utility Servitors (cost 25)
   - Guarantees at least 1 enemy if budget too low

3. **GetBaseRisk(DangerLevel)**:
   - Simple switch expression mapping DangerLevel enum to percentages
   - Returns 15% for unknown DangerLevel values (default to Unstable)

### RestService Integration

**New Dependency:**
```csharp
private readonly IAmbushService _ambushService;
```

**New Overload:**
```csharp
public async Task<RestResult> PerformRestAsync(Character character, RestType type, Room room)
{
    // Sanctuary rest - skip ambush check
    if (type == RestType.Sanctuary)
        return await PerformSanctuaryRestAsync(character);

    // Wilderness rest - check ambush first
    var ambushResult = await _ambushService.CalculateAmbushAsync(character, room);

    if (ambushResult.IsAmbush)
        return await PerformAmbushedRestAsync(character, ambushResult);

    // No ambush - normal recovery with ambush details attached
    var restResult = await PerformWildernessRestAsync(character);
    return restResult with { AmbushDetails = ambushResult };
}
```

**PerformAmbushedRestAsync(Character, AmbushResult) Behaviors:**
- Checks for supplies (Ration + Water)
- Consumes supplies if present (wasted/scattered during ambush)
- Applies `StatusEffectType.Disoriented` to character
- Returns RestResult with zero recovery (HP, Stamina, Stress all 0)
- Sets `WasAmbushed = true` and attaches `AmbushDetails`

---

## Logging Matrix

### AmbushService Logs

| Event | Level | Template |
|-------|-------|----------|
| Ambush calculation start | Information | `"[Rest] Calculating ambush risk for {Character} in {Room} (DangerLevel: {Danger})"` |
| Safe zone bypass | Information | `"[Rest] Base Risk: 0% (Safe zone). No ambush possible."` |
| Risk calculation result | Information | `"[Rest] Base Risk: {Base}%, Mitigation: -{Mit}% (Successes: {S}), Final: {Final}%"` |
| Ambush roll result | Information | `"[Rest] Ambush Roll: {Roll} vs {Risk}. Result: {IsAmbush}"` |
| Ambush triggered | Warning | `"[Combat] Ambush triggered! Spawning {Count} enemies."` |
| Encounter generation start | Debug | `"[Encounter] Generating ambush: Budget={Budget:F0}, Biome={Biome}"` |
| Template selection complete | Debug | `"[Encounter] Selected {Count} enemies: [{Templates}]"` |

### RestService Logs (Ambush Integration)

| Event | Level | Template |
|-------|-------|----------|
| Rest with room context | Information | `"{Name} initiating {Type} rest in {Room}."` |
| Ambush interruption | Warning | `"{Name} was ambushed during rest!"` |
| Supplies lost in ambush | Debug | `"Supplies lost in ambush: 1x {RationName}, 1x {WaterName}."` |
| Disoriented applied | Information | `"{Name} is [Disoriented] from the ambush."` |

---

## Test Coverage

### Summary

```
AmbushServiceTests: 17 tests
RestServiceTests: 28 tests (8 new, 20 from v0.3.2a)
Total New Tests: 25
Duration: 52ms (AmbushServiceTests), 71ms (RestServiceTests)
All Passed: 1778/1778
```

### AmbushServiceTests (17 tests)

#### GetBaseRisk Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `GetBaseRisk_SafeZone_ReturnsZero` | Validates DangerLevel.Safe returns 0% risk |
| `GetBaseRisk_UnstableZone_ReturnsFifteen` | Validates DangerLevel.Unstable returns 15% risk |
| `GetBaseRisk_HostileZone_ReturnsThirty` | Validates DangerLevel.Hostile returns 30% risk |
| `GetBaseRisk_LethalZone_ReturnsFifty` | Validates DangerLevel.Lethal returns 50% risk |

#### Safe Zone Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `CalculateAmbush_SafeZone_AlwaysReturnsSafe` | Validates safe zones always return IsAmbush=false with 0% risk |
| `CalculateAmbush_SafeZone_NoRollPerformed` | Verifies no dice rolls occur in safe zones (performance optimization) |

#### Mitigation Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `CalculateAmbush_HighWits_ReducesRisk` | Validates Wits 8 rolling 4 successes reduces Hostile 30% to 10% (20% mitigation) |
| `CalculateAmbush_SuccessfulMitigation_AppliesFivePercentPerSuccess` | Validates 3 successes = 15% mitigation formula (3 × 5%) |

#### Minimum Risk Floor Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `CalculateAmbush_ExcessiveMitigation_ClampsToFivePercent` | Validates 8 successes (40% mitigation) on Unstable 15% clamps to 5% floor |
| `CalculateAmbush_DangerousZone_NeverBelowFivePercent` | Validates Lethal 50% with 10 successes (50% mitigation) clamps to 5% floor |

#### Ambush Trigger Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `CalculateAmbush_RollBelowRisk_TriggersAmbush` | Validates d100 roll of 15 triggers ambush against 30% risk |
| `CalculateAmbush_RollAboveRisk_ReturnsSafe` | Validates d100 roll of 50 does not trigger ambush against 30% risk |
| `CalculateAmbush_RollEqualsRisk_TriggersAmbush` | Validates boundary condition (roll = risk) uses <= comparison |

#### Encounter Generation Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `GenerateAmbushEncounter_UsesBudgetMultiplier` | Validates party level 1 produces budget of 80 (100 × 0.8) |
| `GenerateAmbushEncounter_AlwaysReturnsAtLeastOneEnemy` | Validates fallback ensures minimum 1 enemy even with low budget |
| `GenerateAmbushEncounter_HigherPartyLevel_ScalesBudget` | Validates party level 3 produces budget of 96 (100 × 1.2 × 0.8) |
| `GenerateAmbushEncounter_PrioritizesVargr` | Validates Ash-Vargr (bst_vargr_01) is always selected first for ambush encounters |

### RestServiceTests - Ambush Integration (8 new tests)

| Test Name | Description |
|-----------|-------------|
| `Wilderness_WithRoom_CallsAmbushService` | Validates ambush service invoked when Room parameter provided |
| `Wilderness_AmbushTriggered_ReturnsWasAmbushed` | Validates RestResult.WasAmbushed=true and AmbushDetails populated when ambush occurs |
| `Wilderness_AmbushTriggered_ConsumesSupplies` | Validates supplies consumed even when rest interrupted by ambush |
| `Wilderness_AmbushTriggered_AppliesDisoriented` | Validates StatusEffectType.Disoriented applied to ambushed character |
| `Wilderness_NoAmbush_NoDisoriented` | Validates Disoriented not applied when ambush check passes |
| `Wilderness_AmbushTriggered_NoRecovery` | Validates HP and Stamina remain unchanged when ambushed (recovery = 0) |
| `Wilderness_AmbushTriggered_StressNotReduced` | Validates PsychicStress unchanged when ambushed |
| `Sanctuary_SkipsAmbushCheck` | Validates sanctuary rest never calls ambush service regardless of Room parameter |

---

## Dependency Injection Registration

### Added Service (Program.cs)

```csharp
// Register Ambush Services (v0.3.2b)
services.AddScoped<IAmbushService, AmbushService>();

// Register Rest Services (v0.3.2a) - Already registered
services.AddScoped<IRestService, RestService>();
```

**Lifetime Justification:**
- `IAmbushService`: Scoped - stateless calculation service, no shared state required
- `IRestService`: Scoped - depends on scoped InventoryService for supply operations

---

## Verification Results

### Build Output

```
Build succeeded.
    0 Error(s)
    1 Warning(s) (pre-existing dependency conflict)
```

### Test Results

```
AmbushServiceTests:
  Passed:  17
  Failed:   0
  Duration: 52ms

RestServiceTests:
  Passed:  28
  Failed:   0
  Duration: 71ms

Total Project Tests: 1778/1778 passing
```

---

## Directory Structure After v0.3.2b

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Interfaces/
│   │   ├── IAmbushService.cs                [NEW]
│   │   └── IRestService.cs                  [MODIFIED - Room overload]
│   └── Models/
│       ├── AmbushResult.cs                  [NEW]
│       ├── EncounterDefinition.cs           [NEW]
│       └── RestResult.cs                    [MODIFIED - WasAmbushed, AmbushDetails]
├── RuneAndRust.Engine/
│   └── Services/
│       ├── AmbushService.cs                 [NEW]
│       └── RestService.cs                   [MODIFIED - Ambush integration]
├── RuneAndRust.Terminal/
│   └── Program.cs                           [MODIFIED - IAmbushService registration, v0.3.2b]
├── RuneAndRust.Tests/
│   └── Engine/
│       ├── AmbushServiceTests.cs            [NEW - 17 tests]
│       └── RestServiceTests.cs              [MODIFIED - +8 tests, total 28]
└── docs/
    └── changelogs/
        └── v0.3.2b.md                       [NEW - This file]
```

---

## Running Tests

### Run All Rest & Ambush Tests

```bash
dotnet test --filter "FullyQualifiedName~AmbushServiceTests"
dotnet test --filter "FullyQualifiedName~RestServiceTests"
```

### Run Specific Test Categories

```bash
# Base risk calculation tests
dotnet test --filter "FullyQualifiedName~GetBaseRisk"

# Ambush trigger tests
dotnet test --filter "DisplayName~Trigger"

# Encounter generation tests
dotnet test --filter "DisplayName~GenerateAmbush"

# Ambush integration tests
dotnet test --filter "DisplayName~Ambush"
```

---

## API Usage Examples

### Performing Wilderness Rest with Ambush Check

```csharp
public class GameService
{
    private readonly IRestService _restService;
    private readonly ICombatService _combatService;

    public async Task AttemptWildernessRestAsync(Character character, Room currentRoom)
    {
        // Perform rest with ambush check
        var result = await _restService.PerformRestAsync(
            character,
            RestType.Wilderness,
            currentRoom);

        if (result.WasAmbushed)
        {
            Console.WriteLine(result.AmbushDetails!.Message);
            Console.WriteLine($"Final Risk: {result.AmbushDetails.FinalRiskPercent}%");
            Console.WriteLine($"Roll: {result.AmbushDetails.RollValue}");

            // Character is now Disoriented
            Debug.Assert(character.HasStatusEffect(StatusEffectType.Disoriented));

            // Initialize combat with ambush encounter
            var encounter = result.AmbushDetails.Encounter!;
            await _combatService.InitiateCombatAsync(
                character,
                encounter.TemplateIds.ToList(),
                isAmbush: true);
        }
        else
        {
            Console.WriteLine($"HP +{result.HpRecovered}, Stamina +{result.StaminaRecovered}");
            Console.WriteLine($"Stress -{result.StressRecovered}");

            if (result.AmbushDetails != null)
            {
                Console.WriteLine($"Your watch was successful (Risk: {result.AmbushDetails.FinalRiskPercent}%)");
            }
        }
    }
}
```

### Generating Standalone Ambush Encounters

```csharp
// Generate ambush encounter without performing rest
var encounter = _ambushService.GenerateAmbushEncounter(
    room: currentRoom,
    partyLevel: character.Level);

Console.WriteLine($"Ambush Budget: {encounter.Budget}");
Console.WriteLine($"Enemies: {string.Join(", ", encounter.TemplateIds)}");

// Example Output for Level 1:
// Ambush Budget: 80
// Enemies: bst_vargr_01, mec_serv_01, mec_serv_01
```

### Calculating Ambush Risk Without Rest

```csharp
// Preview ambush risk before committing to rest
var ambushCheck = await _ambushService.CalculateAmbushAsync(character, currentRoom);

Console.WriteLine($"Base Risk: {ambushCheck.BaseRiskPercent}%");
Console.WriteLine($"Your Wits reduces risk by {ambushCheck.MitigationPercent}%");
Console.WriteLine($"Final Risk: {ambushCheck.FinalRiskPercent}%");

// Player can now decide whether to rest or move to safer location
```

---

## Technical Notes

### Risk Calculation Formula

```
BaseRisk = DangerLevel switch
{
    Safe     => 0%,
    Unstable => 15%,
    Hostile  => 30%,
    Lethal   => 50%
}

MitigationRoll = Roll Wits dice pool
MitigationPercent = MitigationRoll.Successes × 5

RawFinalRisk = BaseRisk - MitigationPercent
FinalRisk = DangerLevel > Safe
    ? Max(5, RawFinalRisk)  // Apply 5% floor in dangerous zones
    : RawFinalRisk          // No floor in safe zones (already 0%)

AmbushTriggered = RollSingle(d100) <= FinalRisk
```

### Encounter Budget Calculation

```
ScaledBudget = 100 × (1 + (PartyLevel - 1) × 0.1)
AmbushBudget = ScaledBudget × 0.8

Examples:
  Level 1: 100 × 1.0 × 0.8 = 80
  Level 2: 100 × 1.1 × 0.8 = 88
  Level 3: 100 × 1.2 × 0.8 = 96
  Level 5: 100 × 1.4 × 0.8 = 112
```

### Enemy Selection Algorithm

```csharp
1. Prioritize Ash-Vargr (cost 40) if budget allows
2. Fill remaining budget with Utility Servitors (cost 25)
3. Fallback: Guarantee at least 1 Servitor if budget insufficient
```

**Example Compositions:**
- Budget 80: 1× Vargr (40), 1× Servitor (25) = 65 used
- Budget 96: 1× Vargr (40), 2× Servitor (50) = 90 used
- Budget 112: 1× Vargr (40), 2× Servitor (50) = 90 used (future: add Raider)

### Supply Consumption Edge Case

Supplies are consumed even when ambushed because:
1. Player had begun preparing camp (set out rations/water)
2. Ambush scatters/ruins prepared supplies
3. Creates meaningful risk (supply loss) even if rest interrupted
4. Prevents exploit of "free ambush checks" by attempting rest without consequence

---

## Design Decisions

### Why 5% Minimum Risk Floor?

Prevents Wits-stacking characters from achieving absolute safety in dangerous zones. Even the most vigilant scout has a small chance of being caught off-guard in hostile territory. Safe zones (DangerLevel.Safe) remain truly safe at 0% risk.

### Why 0.8× Budget Multiplier for Ambushes?

Ambush encounters are typically smaller, stealthier groups rather than full frontal assaults. The reduced budget reflects:
- Emphasis on speed/stealth over raw power
- Narrative appropriateness (not every enemy can ambush effectively)
- Mechanical balance (ambushes grant initiative disadvantage via Disoriented)

### Why Prioritize Ash-Vargr?

Ash-Vargr are established as fast, pack-hunting creatures ideal for ambush tactics. The GlassCannon archetype (high damage, low HP) fits the "strike from shadows" narrative. Mechanically, their higher cost (40) ensures ambush encounters feel dangerous without overwhelming budget.

### Why Apply Disoriented Instead of Surprised?

Surprised implies total loss of action (skipping turn). Disoriented (-2 to attack/defense pools) allows player agency while representing combat disadvantage. This matches the existing StatusEffectType enum without introducing new mechanics.

---

## Known Limitations

1. **Biome-Specific Enemies**: Currently ignores Room.BiomeType in enemy selection. All ambushes use Ruin-appropriate templates.
   - **Future**: v0.3.3 will add biome-specific enemy pools

2. **Skill System Integration**: Mitigation uses raw Wits attribute. No Camp Craft skill bonus yet.
   - **Future**: v0.4.0 Skills system will add skill-based bonuses

3. **Solo Encounters Only**: Encounter generation assumes single-character party.
   - **Future**: v0.5.0 Party system will scale budget by party size

4. **Static Template Costs**: Enemy costs are hardcoded constants.
   - **Future**: Consider moving to EnemyTemplate.AmbushCost property

---

## Next Steps (Deferred to v0.3.2c: The Dawn)

### Command Wiring
- [ ] Add `rest` command to CommandParser with Room context
- [ ] Add `camp` alias as synonym for wilderness rest
- [ ] Implement RestScreenRenderer using Spectre.Console panels
- [ ] Display ambush risk preview before committing to rest

### UI/UX
- [ ] Render AmbushResult in narrative format
- [ ] Show risk breakdown (Base → Mitigation → Final)
- [ ] Display enemy composition if ambushed
- [ ] Add "Your vigilance saved you" flavor text on successful mitigation

### Time System Integration
- [ ] Advance world time by 480 minutes (8 hours) on rest
- [ ] Trigger time-based events (hunger, exhaustion timers)
- [ ] Update Room.LastVisited timestamp

### Sanctuary Validation
- [ ] Add Room.Features enum with Sanctuary flag
- [ ] Validate Sanctuary rest only allowed in flagged rooms
- [ ] Add settlement/safe room discovery mechanics

---

## Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Serilog | 3.x | Structured logging for ambush calculations |
| FluentAssertions | 8.x | Test assertions for probability validation |
| xUnit | 2.9.x | Test framework |
| Moq | 4.x | Mocking framework for DiceService and InventoryService |

---

## Migration Notes

This release requires no database migrations. All changes are code-only.

**Recommended Testing Steps:**
1. Verify IAmbushService registered in DI container
2. Test wilderness rest in Hostile room with low-Wits character (should frequently ambush)
3. Test wilderness rest in Hostile room with high-Wits character (should rarely ambush)
4. Test wilderness rest in Safe room (should never ambush)
5. Verify supplies consumed even when ambushed
6. Verify Disoriented status applied when ambushed
7. Verify no recovery granted when ambushed

**Breaking Changes:** None. The original `PerformRestAsync(Character, RestType)` overload remains unchanged. New Room overload is additive.

---

## Performance Considerations

### Optimization: Safe Zone Early Exit

Safe zones skip dice rolling entirely, returning immediately with 0% risk. This avoids unnecessary RNG overhead in settlements and sanctuaries.

```csharp
if (baseRisk == 0)
{
    return new AmbushResult(/* ... no dice rolls ... */);
}
```

### Encounter Generation Complexity

Current implementation is O(n) where n = budget/cheapest_enemy. For typical budgets (80-120), this produces 1-5 enemies. Negligible performance impact.

Future biome-specific filtering may require O(m×n) where m = template pool size. Consider pre-filtering by biome if template count exceeds 50.

---

## Changelog Metadata

- **Version**: v0.3.2b
- **Codename**: The Watch
- **Release Type**: Feature Release (Rest & Recovery Milestone)
- **Parent Version**: v0.3.2a (The Campfire)
- **Next Version**: v0.3.2c (The Dawn)
- **Lines of Code Added**: ~500 (implementation + tests)
- **Test Coverage Increase**: +25 tests (17 AmbushServiceTests, 8 RestServiceTests integration)
- **Architecture Impact**: Introduced probabilistic encounter spawning pattern, established ambush template priority system
