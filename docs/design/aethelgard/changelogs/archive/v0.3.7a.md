> **Archived** - This changelog has been consolidated. See the complete version at [v0.3.7](../v0.3.x/v0.3.7.md).

# Changelog: v0.3.7a - The Pack (Inventory UI)

**Release Date:** 2025-12-22

---

## Summary

Version 0.3.7a introduces a full-screen interactive inventory UI using Spectre.Console Layout, transitioning inventory management from text commands to a split-screen Terminal User Interface (TUI). The new system features a 30/70 split layout with equipment slots on the left and backpack contents on the right, a visual Unicode burden bar with color-coded thresholds, quality tier color coding (Grey→White→Green→Blue→Gold), and item type iconography.

This release touches the **Core Layer** (ViewModels, Interfaces), **Engine Layer** (Services), **Terminal Layer** (Rendering, Services), and **Test Layer** with comprehensive test coverage. Key patterns introduced include immutable ViewModel records for UI data transfer, screen renderer pattern for full-screen layouts, and static helper classes for formatting utilities.

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/ViewModels/InventoryViewModel.cs` | Immutable view model records for inventory UI data transfer |
| `RuneAndRust.Core/Interfaces/IInventoryScreenRenderer.cs` | Interface contract for inventory screen rendering |

### Terminal Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Terminal/Rendering/InventoryViewHelper.cs` | Static helper class for color mapping, weight formatting, and icon generation |
| `RuneAndRust.Terminal/Services/InventoryScreenRenderer.cs` | Full-screen inventory renderer using Spectre.Console Layout |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/InventoryServiceViewModelTests.cs` | 8 unit tests validating `GetViewModelAsync()` method for equipped items, backpack items, burden calculation, and edge cases |
| `RuneAndRust.Tests/Terminal/InventoryViewHelperTests.cs` | 18 unit tests validating quality color mapping, burden color mapping, slot display names, weight formatting, burden bar rendering, and item type icons |
| `RuneAndRust.Tests/Terminal/InventoryScreenRendererTests.cs` | 4 unit tests validating renderer construction and rendering with various inventory states |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Interfaces/IInventoryService.cs` | Added `GetViewModelAsync(Character character, int selectedIndex = 0)` method signature |
| `RuneAndRust.Engine/Services/InventoryService.cs` | Implemented `GetViewModelAsync()` method to build immutable inventory snapshots |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added `RequiresInventoryScreen` property to `ParseResult` class. Changed `pack`/`p` commands to set `RequiresInventoryScreen = true` instead of `RequiresInventory` |
| `RuneAndRust.Terminal/Program.cs` | Registered `IInventoryScreenRenderer` as singleton in DI container |
| `RuneAndRust.Tests/Engine/CommandParserTests.cs` | Updated `ParseAndExecute_Exploration_InventoryCommands_ReturnsRequiresInventory` test to remove "pack" command. Added new `ParseAndExecute_Exploration_PackCommand_ReturnsRequiresInventoryScreen` test for `pack`/`p` commands |

---

## UI Layout Design

```
┌─────────────────────────────────────────────────────────┐
│              THE PACK - [Character Name]                │
├─────────────────┬───────────────────────────────────────┤
│ EQUIPPED (30%)  │  BACKPACK (70%)                       │
├─────────────────┼───────────────────────────────────────┤
│ Main Hand: Axe  │  1. ⚔ Healing Salve (x3)  (150g)     │
│ Off Hand:  ---  │  2. ⚔ Iron Dagger         (800g)  E  │
│ Head:      ---  │  3. ☕ Rations (x5)        (500g)     │
│ Body:   Leather │  4. ◆ Torch (x2)          (400g)     │
│ Hands:     ---  │  ...                                  │
│ Feet:    Boots  │                                       │
│ Accessory: ---  │                                       │
├─────────────────┴───────────────────────────────────────┤
│ BURDEN: [████████░░░░░░░░░░░░] 42% (Light)              │
│ Weight: 4.2kg / 10.0kg                                  │
├─────────────────────────────────────────────────────────┤
│ [↑/↓] Navigate  [E]quip  [D]rop  [I]nspect  [ESC] Close │
└─────────────────────────────────────────────────────────┘
```

---

## Code Implementation Details

### InventoryViewModel Records (Core/ViewModels)

**File:** `RuneAndRust.Core/ViewModels/InventoryViewModel.cs`

```csharp
/// <summary>
/// Immutable snapshot of inventory state for UI rendering (v0.3.7a).
/// </summary>
public record InventoryViewModel(
    string CharacterName,
    Dictionary<EquipmentSlot, EquippedItemView?> EquippedItems,
    List<BackpackItemView> BackpackItems,
    int CurrentWeight,
    int MaxCapacity,
    int BurdenPercentage,
    BurdenState BurdenState,
    int SelectedIndex = 0
);

/// <summary>
/// Display-ready view of an equipped item.
/// </summary>
public record EquippedItemView(
    string Name,
    QualityTier Quality,
    int DurabilityPercentage,
    bool IsBroken
);

/// <summary>
/// Display-ready view of a backpack item.
/// </summary>
public record BackpackItemView(
    int Index,
    string Name,
    int Quantity,
    QualityTier Quality,
    int WeightGrams,
    ItemType ItemType,
    bool IsEquipable
);
```

**Record Properties:**

| Record | Property | Type | Purpose |
|--------|----------|------|---------|
| `InventoryViewModel` | `CharacterName` | `string` | Character name for header display |
| `InventoryViewModel` | `EquippedItems` | `Dictionary<EquipmentSlot, EquippedItemView?>` | Equipment slots mapped to equipped items (null = empty) |
| `InventoryViewModel` | `BackpackItems` | `List<BackpackItemView>` | Ordered list of backpack items |
| `InventoryViewModel` | `CurrentWeight` | `int` | Total inventory weight in grams |
| `InventoryViewModel` | `MaxCapacity` | `int` | Maximum carry capacity in grams |
| `InventoryViewModel` | `BurdenPercentage` | `int` | Current weight as percentage of capacity (0-100) |
| `InventoryViewModel` | `BurdenState` | `BurdenState` | Light/Heavy/Overburdened classification |
| `InventoryViewModel` | `SelectedIndex` | `int` | Currently selected backpack item index |
| `EquippedItemView` | `Name` | `string` | Equipment item name |
| `EquippedItemView` | `Quality` | `QualityTier` | Item quality tier for color coding |
| `EquippedItemView` | `DurabilityPercentage` | `int` | Current durability as percentage (0-100) |
| `EquippedItemView` | `IsBroken` | `bool` | True if durability is 0 |
| `BackpackItemView` | `Index` | `int` | 1-based display index |
| `BackpackItemView` | `Name` | `string` | Item name |
| `BackpackItemView` | `Quantity` | `int` | Stack quantity |
| `BackpackItemView` | `Quality` | `QualityTier` | Item quality tier for color coding |
| `BackpackItemView` | `WeightGrams` | `int` | Total weight of stack in grams |
| `BackpackItemView` | `ItemType` | `ItemType` | Item category for icon display |
| `BackpackItemView` | `IsEquipable` | `bool` | True if item is Equipment type |

---

### IInventoryScreenRenderer Interface (Core/Interfaces)

**File:** `RuneAndRust.Core/Interfaces/IInventoryScreenRenderer.cs`

```csharp
/// <summary>
/// Defines the contract for rendering the inventory screen (v0.3.7a).
/// </summary>
public interface IInventoryScreenRenderer
{
    /// <summary>
    /// Renders the complete inventory screen.
    /// </summary>
    /// <param name="viewModel">The inventory data to render.</param>
    void Render(InventoryViewModel viewModel);
}
```

**Purpose:** Defines abstraction for inventory screen rendering, allowing terminal-agnostic testing and potential future UI implementations.

---

### GetViewModelAsync Implementation (Engine/Services)

**File:** `RuneAndRust.Engine/Services/InventoryService.cs`

```csharp
/// <inheritdoc/>
public async Task<InventoryViewModel> GetViewModelAsync(Character character, int selectedIndex = 0)
{
    _logger.LogTrace("[GetViewModel] Building inventory snapshot for {CharacterName}", character.Name);

    var allItems = (await _inventoryRepository.GetByCharacterIdAsync(character.Id)).ToList();

    // Build equipped items dictionary (all 7 slots)
    var equippedDict = new Dictionary<EquipmentSlot, EquippedItemView?>();
    foreach (var slot in Enum.GetValues<EquipmentSlot>())
    {
        var equipped = allItems.FirstOrDefault(i => i.IsEquipped && i.Item is Equipment eq && eq.Slot == slot);
        if (equipped?.Item is Equipment equipment)
        {
            equippedDict[slot] = new EquippedItemView(
                Name: equipment.Name,
                Quality: equipment.Quality,
                DurabilityPercentage: equipment.MaxDurability > 0
                    ? (int)((double)equipment.CurrentDurability / equipment.MaxDurability * 100)
                    : 100,
                IsBroken: equipment.IsBroken
            );
        }
        else
        {
            equippedDict[slot] = null;
        }
    }

    // Build backpack items list (non-equipped, ordered by slot position)
    var backpackItems = allItems
        .Where(i => !i.IsEquipped)
        .OrderBy(i => i.SlotPosition)
        .Select((item, idx) => new BackpackItemView(
            Index: idx + 1,
            Name: item.Item.Name,
            Quantity: item.Quantity,
            Quality: item.Item.Quality,
            WeightGrams: item.Item.Weight * item.Quantity,
            ItemType: item.Item.ItemType,
            IsEquipable: item.Item is Equipment
        ))
        .ToList();

    // Calculate burden metrics
    var currentWeight = await _inventoryRepository.GetTotalWeightAsync(character.Id);
    var maxCapacity = GetMaxCapacity(character);
    var burdenPct = maxCapacity > 0 ? (int)((double)currentWeight / maxCapacity * 100) : 0;
    var burdenState = await CalculateBurdenAsync(character);

    _logger.LogTrace("[GetViewModel] Built snapshot: {BackpackCount} backpack items, {Weight}g/{Capacity}g, {BurdenState}",
        backpackItems.Count, currentWeight, maxCapacity, burdenState);

    return new InventoryViewModel(
        CharacterName: character.Name,
        EquippedItems: equippedDict,
        BackpackItems: backpackItems,
        CurrentWeight: currentWeight,
        MaxCapacity: maxCapacity,
        BurdenPercentage: burdenPct,
        BurdenState: burdenState,
        SelectedIndex: Math.Clamp(selectedIndex, 0, Math.Max(0, backpackItems.Count - 1))
    );
}
```

**Algorithm:**

1. **Fetch Inventory:** Load all inventory items for character via `IInventoryRepository.GetByCharacterIdAsync()`
2. **Build Equipped Dictionary:**
   - Iterate all 7 `EquipmentSlot` enum values
   - For each slot, find equipped item matching that slot
   - Create `EquippedItemView` with durability percentage or `null` if empty
3. **Build Backpack List:**
   - Filter non-equipped items
   - Order by `SlotPosition` (inventory order)
   - Map to `BackpackItemView` with 1-based display index
   - Calculate total stack weight (`Weight × Quantity`)
4. **Calculate Burden:**
   - Get total weight via repository
   - Get max capacity (`MIGHT × 10,000g`)
   - Calculate percentage and burden state
5. **Clamp Selected Index:** Ensure `selectedIndex` is within valid backpack range
6. **Return Immutable ViewModel:** Construct and return `InventoryViewModel` record

**Complexity:** O(n) where n = inventory item count

---

### InventoryViewHelper Static Class (Terminal/Rendering)

**File:** `RuneAndRust.Terminal/Rendering/InventoryViewHelper.cs`

**GetQualityColor:**
```csharp
public static string GetQualityColor(QualityTier quality) => quality switch
{
    QualityTier.JuryRigged => "grey",
    QualityTier.Scavenged => "white",
    QualityTier.ClanForged => "green",
    QualityTier.Optimized => "blue",
    QualityTier.MythForged => "gold1",
    _ => "white"
};
```

**Quality Tier Color Mappings:**

| QualityTier | Spectre Color | Visual Meaning |
|-------------|---------------|----------------|
| JuryRigged | `grey` | Broken/poor quality |
| Scavenged | `white` | Common quality |
| ClanForged | `green` | Uncommon quality |
| Optimized | `blue` | Rare quality |
| MythForged | `gold1` | Legendary quality |

---

**GetBurdenColor:**
```csharp
public static string GetBurdenColor(BurdenState state) => state switch
{
    BurdenState.Light => "green",
    BurdenState.Heavy => "yellow",
    BurdenState.Overburdened => "red",
    _ => "white"
};
```

**Burden State Color Mappings:**

| BurdenState | Spectre Color | Threshold |
|-------------|---------------|-----------|
| Light | `green` | 0-69% |
| Heavy | `yellow` | 70-89% |
| Overburdened | `red` | 90%+ |

---

**GetSlotDisplayName:**
```csharp
public static string GetSlotDisplayName(EquipmentSlot slot) => slot switch
{
    EquipmentSlot.MainHand => "Main Hand",
    EquipmentSlot.OffHand => "Off Hand",
    EquipmentSlot.Head => "Head",
    EquipmentSlot.Body => "Body",
    EquipmentSlot.Hands => "Hands",
    EquipmentSlot.Feet => "Feet",
    EquipmentSlot.Accessory => "Accessory",
    _ => slot.ToString()
};
```

**Equipment Slot Display Names:**

| EquipmentSlot | Display Name |
|---------------|--------------|
| MainHand | "Main Hand" |
| OffHand | "Off Hand" |
| Head | "Head" |
| Body | "Body" |
| Hands | "Hands" |
| Feet | "Feet" |
| Accessory | "Accessory" |

---

**FormatWeight:**
```csharp
public static string FormatWeight(int grams)
{
    if (grams >= 1000)
        return $"{grams / 1000.0:F1}kg";
    return $"{grams}g";
}
```

**Weight Formatting Examples:**

| Input (grams) | Output |
|---------------|--------|
| 0 | "0g" |
| 500 | "500g" |
| 1000 | "1.0kg" |
| 4200 | "4.2kg" |
| 50000 | "50.0kg" |

---

**RenderBurdenBar:**
```csharp
public static string RenderBurdenBar(int percentage, int width = 20)
{
    var clamped = Math.Clamp(percentage, 0, 100);
    var filled = (int)(clamped / 100.0 * width);
    var empty = width - filled;
    return new string('\u2588', filled) + new string('\u2591', empty);
}
```

**Unicode Characters:**
- `\u2588` (█) - Full block for filled portion
- `\u2591` (░) - Light shade for empty portion

**Examples:**

| Percentage | Output (width=10) |
|------------|-------------------|
| 0% | `░░░░░░░░░░` |
| 50% | `█████░░░░░` |
| 100% | `██████████` |
| 150% | `██████████` (clamped) |

---

**FormatItemWithQuantity:**
```csharp
public static string FormatItemWithQuantity(string name, int quantity)
{
    return quantity > 1 ? $"{name} (x{quantity})" : name;
}
```

**Examples:**

| Name | Quantity | Output |
|------|----------|--------|
| "Health Potion" | 1 | "Health Potion" |
| "Health Potion" | 5 | "Health Potion (x5)" |

---

**GetItemTypeIcon:**
```csharp
public static string GetItemTypeIcon(ItemType type) => type switch
{
    ItemType.Weapon => "[red]\u2694[/]",       // ⚔ Crossed swords
    ItemType.Armor => "[cyan]\u26E8[/]",       // ⛨ Shield
    ItemType.Consumable => "[green]\u2615[/]", // ☕ Cup (potion)
    ItemType.Material => "[yellow]\u25C6[/]",  // ◆ Diamond (resource)
    ItemType.KeyItem => "[gold1]\u2605[/]",    // ★ Star (important)
    ItemType.Junk => "[grey]\u25A0[/]",        // ■ Square (misc)
    _ => "[grey]\u25A0[/]"
};
```

**Item Type Icon Mappings:**

| ItemType | Icon | Unicode | Spectre Color |
|----------|------|---------|---------------|
| Weapon | ⚔ | `\u2694` | red |
| Armor | ⛨ | `\u26E8` | cyan |
| Consumable | ☕ | `\u2615` | green |
| Material | ◆ | `\u25C6` | yellow |
| KeyItem | ★ | `\u2605` | gold1 |
| Junk | ■ | `\u25A0` | grey |

---

### InventoryScreenRenderer Implementation (Terminal/Services)

**File:** `RuneAndRust.Terminal/Services/InventoryScreenRenderer.cs`

**Render Method:**
```csharp
public void Render(InventoryViewModel vm)
{
    _logger.LogTrace("[Inventory] Rendering screen for {Character}", vm.CharacterName);

    var rootLayout = new Layout("Root")
        .SplitRows(
            new Layout("Header").Size(3),
            new Layout("Body").SplitColumns(
                new Layout("Equipment").Ratio(3),
                new Layout("Backpack").Ratio(7)
            ),
            new Layout("BurdenBar").Size(3),
            new Layout("Footer").Size(1)
        );

    rootLayout["Header"].Update(CreateHeader(vm.CharacterName));
    rootLayout["Equipment"].Update(CreateEquipmentPanel(vm.EquippedItems));
    rootLayout["Backpack"].Update(CreateBackpackPanel(vm.BackpackItems, vm.SelectedIndex));
    rootLayout["BurdenBar"].Update(CreateBurdenPanel(vm));
    rootLayout["Footer"].Update(CreateFooter());

    AnsiConsole.Clear();
    AnsiConsole.Write(rootLayout);
}
```

**Layout Structure:**

```
┌─────────────────────────────────────────┐
│              Header (3 rows)            │
├─────────────┬───────────────────────────┤
│  Equipment  │       Backpack            │
│   (30%)     │        (70%)              │
│  Ratio: 3   │       Ratio: 7            │
├─────────────┴───────────────────────────┤
│          BurdenBar (3 rows)             │
├─────────────────────────────────────────┤
│           Footer (1 row)                │
└─────────────────────────────────────────┘
```

---

**CreateHeader:**
```csharp
private Panel CreateHeader(string characterName)
{
    var title = new Rule($"[bold gold1]THE PACK - {Markup.Escape(characterName)}[/]")
    {
        Justification = Justify.Center,
        Style = Style.Parse("gold1")
    };
    return new Panel(title).Border(BoxBorder.None);
}
```

**Output Example:** `════════════ THE PACK - Kael ════════════`

---

**CreateEquipmentPanel:**
```csharp
private Panel CreateEquipmentPanel(Dictionary<EquipmentSlot, EquippedItemView?> equipped)
```

**Algorithm:**

1. Iterate all 7 `EquipmentSlot` values in order
2. For each slot:
   - Get display name (e.g., "Main Hand")
   - Pad to 10 characters for alignment
   - If item exists:
     - Apply quality color to item name
     - Add durability percentage if < 50%
     - Add "(BROKEN)" marker if `IsBroken = true`
   - If empty: Show grey "---"
3. Wrap in Panel with cyan "EQUIPPED" header

**Output Example:**
```
┌─ EQUIPPED ───────┐
│ Main Hand: Iron Sword              │
│ Off Hand:  ---                     │
│ Head:      ---                     │
│ Body:      Leather Armor (45%)     │
│ Hands:     ---                     │
│ Feet:      Worn Boots (BROKEN)     │
│ Accessory: ---                     │
└────────────────────────────────────┘
```

---

**CreateBackpackPanel:**
```csharp
private Panel CreateBackpackPanel(List<BackpackItemView> items, int selectedIndex)
```

**Algorithm:**

1. If empty: Return panel with grey "(empty)" message
2. For each item:
   - Add selection cursor (`>` if selected, space otherwise)
   - Format display index (1-based, right-aligned)
   - Add item type icon (colored Unicode)
   - Apply quality color to item name
   - Add quantity suffix if stacked
   - Add weight in parentheses
   - Add "E" marker if equipable
3. Wrap in Panel with white "BACKPACK" header

**Output Example:**
```
┌─ BACKPACK ─────────────────────────────┐
│ >  1. ☕ Health Potion (x3)  (300g)    │
│    2. ⚔ Iron Dagger         (800g)  E │
│    3. ◆ Torch (x2)          (400g)    │
│    4. ■ Broken Gears        (200g)    │
└────────────────────────────────────────┘
```

---

**CreateBurdenPanel:**
```csharp
private Panel CreateBurdenPanel(InventoryViewModel vm)
```

**Algorithm:**

1. Get burden color based on `BurdenState`
2. Render burden bar using `RenderBurdenBar()`
3. Format percentage and state label
4. Format weight string (current/max)
5. Return borderless panel with two-line content

**Output Example:**
```
BURDEN: [████████░░░░░░░░░░░░] 42% (Light)
Weight: 4.2kg / 10.0kg
```

---

**CreateFooter:**
```csharp
private static Markup CreateFooter()
{
    return new Markup("[grey][[↑/↓]] Navigate  [[E]]quip  [[D]]rop  [[I]]nspect  [[ESC]] Close[/]");
}
```

**Output:** `[↑/↓] Navigate  [E]quip  [D]rop  [I]nspect  [ESC] Close`

---

### CommandParser Changes (Engine/Services)

**File:** `RuneAndRust.Engine/Services/CommandParser.cs`

**New Property:**
```csharp
/// <summary>
/// Gets or sets whether the full inventory screen should be opened (v0.3.7a).
/// </summary>
public bool RequiresInventoryScreen { get; set; }
```

**Updated Command Handling:**
```csharp
case "inventory":
case "i":
    _logger.LogDebug("Inventory text display command executed.");
    return new ParseResult { RequiresInventory = true };

case "pack":
case "p":
    _logger.LogDebug("Full inventory screen requested (v0.3.7a).");
    return new ParseResult { RequiresInventoryScreen = true };
```

**Command Behavior:**

| Command | Property Set | Description |
|---------|--------------|-------------|
| `inventory`, `i` | `RequiresInventory = true` | Opens text-based inventory display |
| `pack`, `p` | `RequiresInventoryScreen = true` | Opens full-screen inventory UI |

---

### DI Registration (Terminal/Program.cs)

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// Register Inventory Screen Renderer (v0.3.7a)
services.AddSingleton<IInventoryScreenRenderer, InventoryScreenRenderer>();
```

**Lifetime:** Singleton (stateless renderer, reused across sessions)

---

## Logging Matrix

### InventoryService

| Event | Level | Template |
|-------|-------|----------|
| Build snapshot start | Trace | `"[GetViewModel] Building inventory snapshot for {CharacterName}"` |
| Build snapshot complete | Trace | `"[GetViewModel] Built snapshot: {BackpackCount} backpack items, {Weight}g/{Capacity}g, {BurdenState}"` |

### InventoryScreenRenderer

| Event | Level | Template |
|-------|-------|----------|
| Render screen | Trace | `"[Inventory] Rendering screen for {Character}"` |

### CommandParser

| Event | Level | Template |
|-------|-------|----------|
| Inventory text command | Debug | `"Inventory text display command executed."` |
| Pack screen command | Debug | `"Full inventory screen requested (v0.3.7a)."` |

---

## Test Coverage

**Total Tests Added:** 32
**Total Project Tests:** 2,205
**Passed:** 2,205
**Failed:** 0
**Duration:** ~1 second

---

### InventoryServiceViewModelTests (8 tests)

**File:** `RuneAndRust.Tests/Engine/InventoryServiceViewModelTests.cs`

| Test Name | Description |
|-----------|-------------|
| `GetViewModelAsync_EmptyInventory_ReturnsEmptyLists` | Verifies empty inventory returns empty backpack and all 7 equipment slots set to null |
| `GetViewModelAsync_WithEquippedItem_PopulatesEquippedDict` | Validates equipped items populate correct slot with name, quality, durability, and broken flag |
| `GetViewModelAsync_AllSlotsEmpty_AllSlotsNull` | Confirms all 7 equipment slots exist in dictionary with null values when empty |
| `GetViewModelAsync_WithBackpackItems_ReturnsOrderedList` | Tests backpack items ordered by SlotPosition with correct 1-based display indices |
| `GetViewModelAsync_CalculatesBurdenPercentageCorrectly` | Validates burden percentage calculation (weight / capacity × 100) |
| `GetViewModelAsync_BrokenEquipment_SetsIsBrokenTrue` | Confirms IsBroken flag set when CurrentDurability = 0 |
| `GetViewModelAsync_SelectedIndexClamped_WhenOutOfRange` | Tests selectedIndex clamped to valid backpack range (0 to count-1) |
| `GetViewModelAsync_StackedItems_ShowsCorrectQuantity` | Validates stacked items show correct quantity and total stack weight |

**Test Setup:**
- Uses Moq to mock `IInventoryRepository` and `ILogger<InventoryService>`
- `_testCharacter` has MIGHT = 5 (50,000g capacity)
- Tests cover Equipment items (with durability) and regular Items (no durability)

---

### InventoryViewHelperTests (18 tests)

**File:** `RuneAndRust.Tests/Terminal/InventoryViewHelperTests.cs`

| Test Category | Tests |
|---------------|-------|
| **GetQualityColor** | 5 tests covering all QualityTier values |
| **GetBurdenColor** | 3 tests covering all BurdenState values |
| **GetSlotDisplayName** | 1 Theory test with 7 InlineData cases for all slots |
| **FormatWeight** | 4 tests covering 0g, under 1000g, exactly 1000g, and over 1000g |
| **RenderBurdenBar** | 4 tests covering 0%, 50%, 100%, and over 100% (clamped) |
| **FormatItemWithQuantity** | 2 tests covering quantity = 1 and quantity > 1 |
| **GetItemTypeIcon** | 6 tests covering all ItemType values |

**Test Characteristics:**
- Pure unit tests with no mocking (static helper class)
- Uses FluentAssertions for readable assertions
- Theory/InlineData for parameterized slot name tests

---

### InventoryScreenRendererTests (4 tests)

**File:** `RuneAndRust.Tests/Terminal/InventoryScreenRendererTests.cs`

| Test Name | Description |
|-----------|-------------|
| `Render_WithEmptyBackpack_DoesNotThrow` | Verifies renderer handles empty inventory without exception |
| `Render_WithItems_DoesNotThrow` | Tests rendering with equipped items and backpack items |
| `Render_WithBrokenEquipment_DoesNotThrow` | Validates renderer handles broken equipment display |
| `Render_WithSelectedItem_DoesNotThrow` | Confirms selected item highlighting doesn't cause errors |

**Test Helpers:**
- `CreateEmptyViewModel()` generates empty inventory state
- `CreateViewModelWithItems()` generates populated inventory with equipped and backpack items
- `CreateViewModelWithBrokenEquipment()` generates inventory with broken equipment

**Note:** Visual rendering tests are limited to non-throwing verification. Full visual testing done via manual integration testing due to terminal output constraints.

---

### CommandParserTests Updates

**File:** `RuneAndRust.Tests/Engine/CommandParserTests.cs`

| Change | Description |
|--------|-------------|
| Modified `ParseAndExecute_Exploration_InventoryCommands_ReturnsRequiresInventory` | Removed "pack" from InlineData, now only tests "inventory" and "i" |
| Added `ParseAndExecute_Exploration_PackCommand_ReturnsRequiresInventoryScreen` | New test validating "pack" and "p" commands set `RequiresInventoryScreen = true` |

---

## Verification Results

**Build Output:**
```
Build succeeded.
    74 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.79
```

**Test Output:**
```
Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:  2205, Skipped:     0, Total:  2205, Duration: 1 s - RuneAndRust.Tests.dll (net9.0)
```

---

## Directory Structure After Release

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Interfaces/
│   │   ├── IInventoryService.cs [MODIFIED]
│   │   └── IInventoryScreenRenderer.cs [NEW]
│   └── ViewModels/
│       └── InventoryViewModel.cs [NEW]
├── RuneAndRust.Engine/
│   └── Services/
│       ├── CommandParser.cs [MODIFIED]
│       └── InventoryService.cs [MODIFIED]
├── RuneAndRust.Terminal/
│   ├── Program.cs [MODIFIED]
│   ├── Rendering/
│   │   └── InventoryViewHelper.cs [NEW]
│   └── Services/
│       └── InventoryScreenRenderer.cs [NEW]
└── RuneAndRust.Tests/
    ├── Engine/
    │   ├── CommandParserTests.cs [MODIFIED]
    │   └── InventoryServiceViewModelTests.cs [NEW]
    └── Terminal/
        ├── InventoryScreenRendererTests.cs [NEW]
        └── InventoryViewHelperTests.cs [NEW]
```

---

## Running Tests

**Run All Inventory UI Tests:**
```bash
dotnet test --filter "FullyQualifiedName~InventoryServiceViewModelTests"
dotnet test --filter "FullyQualifiedName~InventoryViewHelperTests"
dotnet test --filter "FullyQualifiedName~InventoryScreenRendererTests"
```

**Run Specific Test:**
```bash
dotnet test --filter "FullyQualifiedName~GetViewModelAsync_WithEquippedItem_PopulatesEquippedDict"
```

**Run Full Test Suite:**
```bash
dotnet test
```

---

## Migration Notes

### Command Behavior Change

The `pack` and `p` commands now trigger `RequiresInventoryScreen` instead of `RequiresInventory`. This is a **breaking change** for any code that checks `RequiresInventory` to handle the pack command.

**Before (v0.3.6c):**
```csharp
if (result.RequiresInventory)
{
    // Handles: inventory, i, pack
}
```

**After (v0.3.7a):**
```csharp
if (result.RequiresInventory)
{
    // Handles: inventory, i (text display)
}

if (result.RequiresInventoryScreen)
{
    // Handles: pack, p (full-screen UI)
}
```

---

## Next Steps

Planned work for **v0.3.7b**:

- **Keyboard Input Handling:** Implement arrow key navigation (↑/↓) for backpack selection
- **Equip Action:** Implement [E] key to equip selected backpack item
- **Drop Action:** Implement [D] key to drop selected item
- **Inspect Action:** Implement [I] key to view item details
- **ESC to Close:** Return to exploration mode on ESC key press
- **Real-time Refresh:** Update display when inventory changes
- **Sound Effects:** Terminal bell on invalid actions

---

**End of Changelog v0.3.7a**
