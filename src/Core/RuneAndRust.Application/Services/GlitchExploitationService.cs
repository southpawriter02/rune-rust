// ------------------------------------------------------------------------------
// <copyright file="GlitchExploitationService.cs" company="Rune &amp; Rust">
//     Copyright (c) Rune &amp; Rust. All rights reserved.
// </copyright>
// <summary>
// Service for exploiting glitch cycles in [Glitched] Old World technology.
// Manages pattern observation, chaos rolls, and exploit window timing.
// Part of v0.15.4f Glitch Exploitation System implementation.
// </summary>
// ------------------------------------------------------------------------------

namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for exploiting glitch cycles in [Glitched] Old World technology.
/// </summary>
/// <remarks>
/// <para>
/// Glitched mechanisms cycle through four phases: Stable → Unstable → Permissive → Lockdown.
/// This service enables characters to:
/// <list type="bullet">
///   <item><description>Observe patterns (WITS DC 14) to identify the cycle timing</description></item>
///   <item><description>Exploit the Permissive phase for -4 DC bonus</description></item>
///   <item><description>Proceed blind and roll on the Chaos table (+4, +0, or -2 DC)</description></item>
/// </list>
/// </para>
/// <para>
/// This service integrates with the Jury-Rigging System (v0.15.4e) when the
/// <see cref="BypassMethod.GlitchExploitation"/> method is selected on a [Glitched] mechanism.
/// </para>
/// </remarks>
public sealed class GlitchExploitationService : IGlitchExploitationService
{
    // -------------------------------------------------------------------------
    // Constants
    // -------------------------------------------------------------------------

    /// <summary>
    /// DC for pattern observation (WITS check).
    /// </summary>
    private const int PatternObservationDc = 14;

    /// <summary>
    /// Base duration for each phase (before adding d4 roll).
    /// </summary>
    private const int BasePhaseDuration = 1;

    /// <summary>
    /// Maximum additional rounds for phase duration (d4 result).
    /// </summary>
    private const int PhaseDurationDice = 4;

    /// <summary>
    /// DC bonus when in the exploit window (Permissive phase).
    /// </summary>
    private const int ExploitWindowBonus = -4;

    /// <summary>
    /// DC penalty when in Lockdown phase.
    /// </summary>
    private const int LockdownPenalty = 2;

    /// <summary>
    /// DC modifier when chaos roll is Against (1-2 on d6).
    /// </summary>
    private const int ChaosAgainstModifier = 4;

    /// <summary>
    /// DC modifier when chaos roll is Neutral (3-4 on d6).
    /// </summary>
    private const int ChaosNeutralModifier = 0;

    /// <summary>
    /// DC modifier when chaos roll is Helps (5-6 on d6).
    /// </summary>
    private const int ChaosHelpsModifier = -2;

    // -------------------------------------------------------------------------
    // Glitch Phase Descriptions
    // -------------------------------------------------------------------------

    /// <summary>
    /// Narrative descriptions for each glitch cycle phase.
    /// </summary>
    private static readonly IReadOnlyDictionary<GlitchCyclePhase, string> PhaseDescriptions =
        new Dictionary<GlitchCyclePhase, string>
        {
            { GlitchCyclePhase.Stable, "The mechanism operates with its usual erratic hum, the corruption simmering beneath the surface." },
            { GlitchCyclePhase.Unstable, "Lights flicker rapidly and strange sounds emanate from within. The corruption intensifies." },
            { GlitchCyclePhase.Permissive, "The mechanism's defenses momentarily lapse! Security protocols flicker and fail." },
            { GlitchCyclePhase.Lockdown, "The system compensates for its corruption, becoming temporarily more resistant to interference." }
        };

    // -------------------------------------------------------------------------
    // Dependencies
    // -------------------------------------------------------------------------

    private readonly IDiceService _diceService;
    private readonly ILogger<GlitchExploitationService> _logger;

    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------

    /// <summary>
    /// Initializes a new instance of the <see cref="GlitchExploitationService"/> class.
    /// </summary>
    /// <param name="diceService">Service for rolling dice.</param>
    /// <param name="logger">Logger for diagnostic output.</param>
    /// <exception cref="ArgumentNullException">Thrown when any parameter is null.</exception>
    public GlitchExploitationService(
        IDiceService diceService,
        ILogger<GlitchExploitationService> logger)
    {
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        _logger.LogInformation("GlitchExploitationService initialized");
    }

    // -------------------------------------------------------------------------
    // Pattern Observation
    // -------------------------------------------------------------------------

    /// <inheritdoc />
    public GlitchObservationResult ObserveGlitchPattern(int witsScore, string mechanismType)
    {
        if (witsScore < 1)
        {
            throw new ArgumentOutOfRangeException(
                nameof(witsScore),
                witsScore,
                "WITS score must be at least 1.");
        }

        ArgumentNullException.ThrowIfNull(mechanismType);

        _logger.LogInformation(
            "Attempting glitch pattern observation: MechanismType={MechanismType}, " +
            "WitsScore={WitsScore}, DC={DC}",
            mechanismType,
            witsScore,
            PatternObservationDc);

        // Roll WITS check against DC 14
        var netSuccesses = RollNetSuccesses(witsScore);

        _logger.LogDebug(
            "Observation roll: NetSuccesses={NetSuccesses}, DC={DC}, Success={Success}",
            netSuccesses,
            PatternObservationDc,
            netSuccesses > 0);

        if (netSuccesses > 0)
        {
            // Success - identify the pattern
            var currentPhase = DetermineCurrentPhase();
            var phaseDuration = RollPhaseDuration();

            var observedState = GlitchState.CreateObserved(
                currentPhase,
                GlitchCyclePhase.Permissive,
                phaseDuration);

            _logger.LogInformation(
                "Glitch pattern IDENTIFIED: MechanismType={MechanismType}, " +
                "CurrentPhase={Phase}, PhaseDuration={Duration} rounds, " +
                "ExploitWindow={Window}",
                mechanismType,
                currentPhase,
                phaseDuration,
                GlitchCyclePhase.Permissive);

            if (observedState.IsInExploitWindow)
            {
                _logger.LogInformation(
                    "*** IN EXPLOIT WINDOW! *** Modifier={Modifier} DC",
                    ExploitWindowBonus);
            }

            return GlitchObservationResult.Succeeded(
                netSuccesses,
                observedState,
                mechanismType);
        }
        else
        {
            // Failure - pattern unknown
            var unobservedState = GlitchState.CreateUnobserved();

            _logger.LogInformation(
                "Glitch pattern observation FAILED: MechanismType={MechanismType}, " +
                "NetSuccesses={NetSuccesses}. Chaos roll required if proceeding.",
                mechanismType,
                netSuccesses);

            return GlitchObservationResult.Failed(netSuccesses, unobservedState);
        }
    }

    // -------------------------------------------------------------------------
    // Cycle Phase Queries
    // -------------------------------------------------------------------------

    /// <inheritdoc />
    public GlitchCyclePhase GetCurrentCyclePhase(GlitchState state)
    {
        _logger.LogDebug(
            "Getting current cycle phase: Phase={Phase}, Identified={Identified}",
            state.CyclePhase,
            state.GlitchCycleIdentified);

        return state.CyclePhase;
    }

    /// <inheritdoc />
    public bool IsInExploitWindow(GlitchState state)
    {
        var inWindow = state.IsInExploitWindow;

        _logger.LogDebug(
            "Checking exploit window: Phase={Phase}, ExploitWindow={Window}, " +
            "Identified={Identified}, InWindow={InWindow}",
            state.CyclePhase,
            state.ExploitWindow,
            state.GlitchCycleIdentified,
            inWindow);

        return inWindow;
    }

    // -------------------------------------------------------------------------
    // DC Modifier Calculation
    // -------------------------------------------------------------------------

    /// <inheritdoc />
    public int CalculateGlitchModifier(GlitchState state)
    {
        var modifier = state.DcModifier;

        if (state.GlitchCycleIdentified)
        {
            _logger.LogDebug(
                "Glitch modifier (identified): Phase={Phase}, InWindow={InWindow}, " +
                "Modifier={Modifier}",
                state.CyclePhase,
                state.IsInExploitWindow,
                modifier);
        }
        else if (state.ChaosRoll.HasValue)
        {
            _logger.LogDebug(
                "Glitch modifier (chaos): ChaosRoll={Roll}, Modifier={Modifier}",
                state.ChaosRoll.Value,
                modifier);
        }
        else
        {
            _logger.LogDebug(
                "Glitch modifier (unobserved): Modifier={Modifier}. " +
                "Call RollChaos() to determine modifier.",
                modifier);
        }

        return modifier;
    }

    // -------------------------------------------------------------------------
    // Chaos Roll
    // -------------------------------------------------------------------------

    /// <inheritdoc />
    public ChaosResult RollChaos()
    {
        _logger.LogInformation("Rolling on Chaos table (d6)...");

        // Roll d6 for chaos
        var dicePool = DicePool.D6(1);
        var rollResult = _diceService.Roll(dicePool);
        var roll = rollResult.Total;

        var result = ChaosResult.FromRoll(roll);

        _logger.LogInformation(
            "Chaos roll: {Roll} -> {Effect} ({Modifier:+0;-0;+0} DC)",
            roll,
            result.Effect,
            result.DcModifier);

        _logger.LogDebug(
            "Chaos narrative: {Narrative}",
            result.NarrativeText);

        return result;
    }

    // -------------------------------------------------------------------------
    // Phase Advancement
    // -------------------------------------------------------------------------

    /// <inheritdoc />
    public GlitchState AdvanceRound(GlitchState state)
    {
        var previousPhase = state.CyclePhase;
        var previousRounds = state.RoundsInCurrentPhase;

        var newState = state.AdvanceRound();

        if (newState.CyclePhase != previousPhase)
        {
            _logger.LogInformation(
                "Glitch phase advanced: {PreviousPhase} -> {NewPhase}",
                previousPhase,
                newState.CyclePhase);

            if (newState.IsInExploitWindow)
            {
                _logger.LogInformation(
                    "*** EXPLOIT WINDOW NOW OPEN! *** Modifier={Modifier} DC",
                    ExploitWindowBonus);
            }
        }
        else
        {
            _logger.LogDebug(
                "Glitch round advanced: Phase={Phase}, Round={Round}/{Duration}",
                newState.CyclePhase,
                newState.RoundsInCurrentPhase,
                newState.PhaseDuration);
        }

        return newState;
    }

    // -------------------------------------------------------------------------
    // State Initialization
    // -------------------------------------------------------------------------

    /// <inheritdoc />
    public GlitchState InitializeGlitchState(string mechanismType)
    {
        ArgumentNullException.ThrowIfNull(mechanismType);

        var initialPhase = DetermineCurrentPhase();
        var phaseDuration = RollPhaseDuration();

        var state = GlitchState.CreateUnobserved(initialPhase, phaseDuration);

        _logger.LogInformation(
            "Initialized glitch state: MechanismType={MechanismType}, " +
            "InitialPhase={Phase}, PhaseDuration={Duration} rounds",
            mechanismType,
            initialPhase,
            phaseDuration);

        return state;
    }

    // -------------------------------------------------------------------------
    // Private Helper Methods - Dice Rolling
    // -------------------------------------------------------------------------

    /// <summary>
    /// Rolls a WITS check and returns net successes.
    /// </summary>
    /// <param name="witsScore">The WITS attribute score.</param>
    /// <returns>Net successes from the roll.</returns>
    private int RollNetSuccesses(int witsScore)
    {
        var dicePool = DicePool.D10(Math.Max(1, witsScore));
        var result = _diceService.Roll(dicePool);

        _logger.LogDebug(
            "WITS roll: Score={Score}, Successes={Successes}, Botches={Botches}, " +
            "NetSuccesses={Net}",
            witsScore,
            result.TotalSuccesses,
            result.TotalBotches,
            result.NetSuccesses);

        return result.NetSuccesses;
    }

    /// <summary>
    /// Determines the current phase by rolling d4.
    /// </summary>
    /// <returns>A randomly selected glitch cycle phase.</returns>
    private GlitchCyclePhase DetermineCurrentPhase()
    {
        var dicePool = DicePool.D4(1);
        var rollResult = _diceService.Roll(dicePool);
        var roll = rollResult.Total;

        // Map d4 result (1-4) to phases (0-3)
        var phase = (GlitchCyclePhase)(roll - 1);

        _logger.LogDebug(
            "Determined current phase: Roll={Roll}, Phase={Phase}",
            roll,
            phase);

        return phase;
    }

    /// <summary>
    /// Rolls phase duration (1d4+1 rounds = 2-5 rounds).
    /// </summary>
    /// <returns>The number of rounds the current phase lasts.</returns>
    private int RollPhaseDuration()
    {
        var dicePool = DicePool.D4(1);
        var rollResult = _diceService.Roll(dicePool);
        var duration = BasePhaseDuration + rollResult.Total;

        _logger.LogDebug(
            "Rolled phase duration: 1d4+1 = {Roll}+1 = {Duration} rounds",
            rollResult.Total,
            duration);

        return duration;
    }
}
