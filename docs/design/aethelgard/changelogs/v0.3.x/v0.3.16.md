# Changelog: v0.3.16 - The Sentinel (Stability & Recovery)

**Versions:** v0.3.16a and v0.3.16b
**Release Date:** 2025-12-25 (both parts)
**Total Tests:** 26 new tests (10 CrashService + 16 EmergencySave)
**Test Results:** All passing

---

## Table of Contents

- [Overview](#overview)
- [Key Metrics](#key-metrics)
- [Part A: The Safety Net (Global Exception Handler)](#part-a-the-safety-net-global-exception-handler)
  - [Summary](#summary)
  - [Architecture & Data Flow](#architecture--data-flow)
  - [New Files Created](#new-files-created)
  - [Files Modified](#files-modified)
  - [Code Implementation Details](#code-implementation-details)
  - [Crash Report Format](#crash-report-format)
  - [Decision Trees](#decision-trees)
  - [Logging Matrix](#logging-matrix)
  - [Test Coverage](#test-coverage)
  - [Manual QA Checklist](#manual-qa-checklist)
  - [Design Decisions](#design-decisions)
  - [Directory Structure](#directory-structure)
  - [Related Specifications](#related-specifications)
  - [Next Steps](#next-steps)
  - [Credits](#credits)
  - [Verification Results](#verification-results)
- [Part B: The Black Box (Emergency Save)](#part-b-the-black-box-emergency-save)
  - [Summary](#summary-1)
  - [Architecture & Data Flow](#architecture--data-flow-1)
  - [New Files Created](#new-files-created-1)
  - [Files Modified](#files-modified-1)
  - [Code Implementation Details](#code-implementation-details-1)
  - [Logging Matrix](#logging-matrix-1)
  - [Test Coverage](#test-coverage-1)
  - [Verification Results](#verification-results-1)
  - [Architecture Decisions](#architecture-decisions)
  - [Directory Structure](#directory-structure-1)
  - [Running Tests](#running-tests)
  - [Usage Examples](#usage-examples)
  - [Next Steps](#next-steps-1)

---

## Overview

v0.3.16 "The Sentinel" focuses on application stability and crash recovery. This milestone implements global exception handling infrastructure that catches unhandled exceptions, generates detailed crash reports, presents a user-friendly error screen, and preserves player progress before graceful shutdown.

**Part A (The Safety Net)** establishes the crash handling foundation with:
- ICrashService interface and CrashReport DTO in Core layer
- CrashService implementation with timestamped crash log generation
- CrashScreenRenderer "Red Screen of Death" using Spectre.Console
- Program.cs global exception handler with manual service instantiation pattern

**Part B (The Black Box)** adds emergency save functionality with:
- IEmergencySaveService interface for panic save operations
- EmergencySaveService implementation with synchronous JSON serialization
- Emergency save attempt integrated into catch block before crash screen
- CrashScreenRenderer enhanced to display backup success/failure status

---

## Key Metrics

| Metric | Part A | Part B | Total |
|--------|--------|--------|-------|
| New Files | 5 | 3 | 8 |
| Modified Files | 1 | 2 | 3 |
| New Tests | 10 | 16 | 26 |
| Test Pass Rate | 100% | 100% | 100% |
| Regressions | 0 | 0 | 0 |

---

## Part A: The Safety Net (Global Exception Handler)

**Release Date:** 2025-12-25
**Tests Added:** 10 (CrashServiceTests)

### Summary

Version 0.3.16a implements **The Safety Net** - a global exception handler that intercepts unhandled exceptions, writes detailed crash logs to `logs/crashes/`, and displays a user-friendly "Red Screen of Death" using Spectre.Console. This is Part A of the v0.3.16 "The Sentinel" stability and recovery update.

**Patterns Introduced:**
- **Global Exception Handler Pattern:** Top-level catch block with exception filter
- **Manual Service Instantiation Pattern:** CrashService bypasses DI when container may be unavailable
- **Static Renderer Pattern:** CrashScreenRenderer is static since it has no dependencies
- **Fallback Logger Pattern:** Uses NullLogger when Serilog infrastructure unavailable
- **Graceful Shutdown Pattern:** OperationCanceledException excluded to allow Ctrl+C

**Layers Touched:**
- **Core Layer:** `ICrashService` interface, `CrashReport` DTO record
- **Engine Layer:** `CrashService` implementation with file I/O and formatting
- **Terminal Layer:** `CrashScreenRenderer` static class, `Program.cs` catch block
- **Test Layer:** 10 unit tests in `CrashServiceTests.cs`

**Key Metrics:**
- 5 new files created
- 1 file modified (Program.cs)
- 10 new unit tests
- 0 regressions
- 100% test pass rate for CrashService tests

---

### Architecture & Data Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Program.Main()                                  │
│                                                                          │
│  try {                                                                   │
│      // Normal application flow                                          │
│      host.Build();                                                       │
│      game.StartAsync();                                                  │
│  }                                                                       │
│  catch (Exception ex) when (ex is not OperationCanceledException) {     │
│      │                                                                   │
│      ▼                                                                   │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  CRASH RECOVERY SEQUENCE                                          │  │
│  │                                                                   │  │
│  │  1. Instantiate CrashService (manual, no DI)                     │  │
│  │     └─> new CrashService(NullLogger<CrashService>.Instance)      │  │
│  │                                                                   │  │
│  │  2. Log crash to file                                            │  │
│  │     └─> CrashService.LogCrash(ex)                                │  │
│  │         ├─> Directory.CreateDirectory("logs/crashes")            │  │
│  │         ├─> Build CrashReport DTO                                │  │
│  │         ├─> FormatReport() → human-readable text                 │  │
│  │         └─> File.WriteAllText() → crash_YYYYMMDD_HHmmss.txt      │  │
│  │                                                                   │  │
│  │  3. Render crash screen                                          │  │
│  │     └─> CrashScreenRenderer.Render(ex, logPath)                  │  │
│  │         ├─> AnsiConsole.Clear()                                  │  │
│  │         ├─> Build Spectre.Console Panel (red border)             │  │
│  │         ├─> Display exception details                            │  │
│  │         ├─> Show crash log path                                  │  │
│  │         ├─> Show GitHub issues link                              │  │
│  │         └─> Console.ReadLine() → wait for ENTER                  │  │
│  │                                                                   │  │
│  │  4. Log to Serilog (if available)                                │  │
│  │     └─> Log.Fatal(ex, "System Crash")                            │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│  }                                                                       │
│  finally {                                                               │
│      Log.CloseAndFlush();                                               │
│  }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### New Files Created

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Core/Interfaces/ICrashService.cs` | Interface for crash handling service | 26 |
| `RuneAndRust.Core/Models/CrashReport.cs` | DTO record for crash diagnostic data | 51 |
| `RuneAndRust.Engine/Services/CrashService.cs` | Crash logging and report generation | 122 |
| `RuneAndRust.Terminal/Rendering/CrashScreenRenderer.cs` | Spectre.Console "Red Screen of Death" UI | 85 |
| `RuneAndRust.Tests/Engine/CrashServiceTests.cs` | Unit tests for CrashService | 227 |

---

### Files Modified

| File | Change | Lines Affected |
|------|--------|----------------|
| `RuneAndRust.Terminal/Program.cs` | Enhanced catch block with crash recovery sequence | 428-450 |

---

### Code Implementation Details

#### ICrashService Interface

**File:** `RuneAndRust.Core/Interfaces/ICrashService.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for handling critical application failures (v0.3.16a).
/// Provides crash logging and report generation when unhandled exceptions occur.
/// </summary>
/// <remarks>See: SPEC-CRASH-001 for Crash Handling System design.</remarks>
public interface ICrashService
{
    /// <summary>
    /// Logs a crash to the crash log directory.
    /// Creates a timestamped crash report file with exception details,
    /// stack trace, and system information.
    /// </summary>
    /// <param name="ex">The exception that caused the crash.</param>
    /// <returns>The path to the generated crash log file.</returns>
    string LogCrash(Exception ex);

    /// <summary>
    /// Generates the file path for a crash report based on timestamp.
    /// </summary>
    /// <param name="timestamp">The time of the crash.</param>
    /// <returns>The full path for the crash log file.</returns>
    string GenerateReportPath(DateTime timestamp);
}
```

**Design Notes:**
- Interface allows for future mock implementations in tests
- `GenerateReportPath` exposed for testability (path format validation)
- Returns path to enable UI to display location to user

---

#### CrashReport Record

**File:** `RuneAndRust.Core/Models/CrashReport.cs`

```csharp
namespace RuneAndRust.Core.Models;

/// <summary>
/// Data Transfer Object for crash report data (v0.3.16a).
/// Captures diagnostic information when a critical exception occurs.
/// Used by CrashService to generate human-readable crash log files.
/// </summary>
public record CrashReport
{
    /// <summary>Timestamp when the crash occurred.</summary>
    public DateTime Timestamp { get; init; }

    /// <summary>The fully qualified type name of the exception.</summary>
    public string ExceptionType { get; init; } = string.Empty;

    /// <summary>The exception message describing what went wrong.</summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>The full stack trace showing the call hierarchy at crash.</summary>
    public string StackTrace { get; init; } = string.Empty;

    /// <summary>Inner exception details as formatted string, if any.</summary>
    public string? InnerException { get; init; }

    /// <summary>Application version at time of crash (e.g., "v0.3.16a").</summary>
    public string GameVersion { get; init; } = string.Empty;

    /// <summary>Operating system description from Environment.OSVersion.</summary>
    public string OperatingSystem { get; init; } = string.Empty;

    /// <summary>.NET runtime version from Environment.Version.</summary>
    public string RuntimeVersion { get; init; } = string.Empty;
}
```

**Design Notes:**
- Uses C# 9 record with `init` properties for immutability
- Default empty strings prevent null reference issues in formatting
- Inner exception is nullable (not all exceptions have inner exceptions)

---

#### CrashService Implementation

**File:** `RuneAndRust.Engine/Services/CrashService.cs`

```csharp
public class CrashService : ICrashService
{
    private readonly ILogger<CrashService> _logger;
    private const string CrashDirectory = "logs/crashes";
    private const string GameVersion = "v0.3.16a";

    public CrashService(ILogger<CrashService> logger) => _logger = logger;

    public string GenerateReportPath(DateTime timestamp)
        => Path.Combine(CrashDirectory, $"crash_{timestamp:yyyyMMdd_HHmmss}.txt");

    public string LogCrash(Exception ex)
    {
        _logger.LogTrace("[CRASH] LogCrash invoked for {ExType}", ex.GetType().Name);

        // Ensure crash directory exists
        Directory.CreateDirectory(CrashDirectory);

        // Build crash report DTO
        var report = new CrashReport
        {
            Timestamp = DateTime.Now,
            ExceptionType = ex.GetType().FullName ?? ex.GetType().Name,
            Message = ex.Message,
            StackTrace = ex.StackTrace ?? "No stack trace available.",
            InnerException = ex.InnerException?.ToString(),
            GameVersion = GameVersion,
            OperatingSystem = Environment.OSVersion.ToString(),
            RuntimeVersion = Environment.Version.ToString()
        };

        // Generate file path and write report
        var path = GenerateReportPath(report.Timestamp);
        var content = FormatReport(report);
        File.WriteAllText(path, content);

        _logger.LogInformation("[CRASH] Crash report written to {Path}", path);
        return path;
    }

    private static string FormatReport(CrashReport report)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("                         RUNE & RUST CRASH REPORT");
        sb.AppendLine("═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();

        // System Information
        sb.AppendLine($"Timestamp:      {report.Timestamp:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine($"Game Version:   {report.GameVersion}");
        sb.AppendLine($"OS:             {report.OperatingSystem}");
        sb.AppendLine($".NET Runtime:   {report.RuntimeVersion}");
        sb.AppendLine();

        // Exception Details
        sb.AppendLine("───────────────────────────────────────────────────────────────────────────────");
        sb.AppendLine("EXCEPTION DETAILS");
        sb.AppendLine("───────────────────────────────────────────────────────────────────────────────");
        sb.AppendLine();
        sb.AppendLine($"Type:    {report.ExceptionType}");
        sb.AppendLine($"Message: {report.Message}");
        sb.AppendLine();

        // Stack Trace
        sb.AppendLine("STACK TRACE:");
        sb.AppendLine("─────────────");
        sb.AppendLine(report.StackTrace);

        // Inner Exception (if present)
        if (!string.IsNullOrEmpty(report.InnerException))
        {
            sb.AppendLine();
            sb.AppendLine("───────────────────────────────────────────────────────────────────────────────");
            sb.AppendLine("INNER EXCEPTION");
            sb.AppendLine("───────────────────────────────────────────────────────────────────────────────");
            sb.AppendLine();
            sb.AppendLine(report.InnerException);
        }

        // Footer
        sb.AppendLine();
        sb.AppendLine("═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("Please report this issue at:");
        sb.AppendLine("https://github.com/southpawriter02/rune-rust/issues");
        sb.AppendLine("═══════════════════════════════════════════════════════════════════════════════");

        return sb.ToString();
    }
}
```

**Design Notes:**
- Uses StringBuilder for efficient string concatenation
- Directory.CreateDirectory is idempotent (safe to call multiple times)
- Timestamp format `yyyyMMdd_HHmmss` ensures unique filenames and chronological sorting
- GitHub issues URL included in footer for user convenience

---

#### CrashScreenRenderer

**File:** `RuneAndRust.Terminal/Rendering/CrashScreenRenderer.cs`

```csharp
using Spectre.Console;
using Spectre.Console.Rendering;

namespace RuneAndRust.Terminal.Rendering;

/// <summary>
/// Renders the "Red Screen of Death" when a critical error occurs (v0.3.16a).
/// Uses Spectre.Console for styled terminal output.
/// Part of "The Safety Net" crash recovery system.
/// </summary>
/// <remarks>
/// This is a static class because it must function when the DI container
/// may not be available (e.g., if the host failed to build).
/// </remarks>
public static class CrashScreenRenderer
{
    public static void Render(Exception ex, string? logPath = null)
    {
        AnsiConsole.Clear();

        // Build the panel content
        var rows = new List<IRenderable>
        {
            new Markup("[bold white]A critical error has occurred.[/]"),
            new Text(""),
            new Markup($"[bold red]{Markup.Escape(ex.GetType().Name)}[/]"),
            new Markup($"[italic grey]{Markup.Escape(TruncateMessage(ex.Message))}[/]"),
            new Text("")
        };

        // Add crash log path or fallback message
        if (!string.IsNullOrEmpty(logPath))
        {
            rows.Add(new Markup($"[grey]Crash report saved to:[/]"));
            rows.Add(new Markup($"[dim]{Markup.Escape(logPath)}[/]"));
        }
        else
        {
            rows.Add(new Markup("[yellow]Unable to save crash report.[/]"));
        }

        rows.Add(new Text(""));
        rows.Add(new Markup("[dim]Please report this issue at:[/]"));
        rows.Add(new Markup("[blue link]https://github.com/southpawriter02/rune-rust/issues[/]"));

        // Create the error panel
        var panel = new Panel(new Rows(rows))
        {
            Header = new PanelHeader(" [bold white on red] SYSTEM FAILURE [/] ", Justify.Center),
            Border = BoxBorder.Double,
            BorderStyle = new Style(Color.Red),
            Padding = new Padding(2, 1)
        };

        AnsiConsole.Write(panel);
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[grey]Press [bold]ENTER[/] to exit...[/]");

        // Wait for user acknowledgement
        Console.ReadLine();
    }

    private static string TruncateMessage(string message, int maxLength = 200)
    {
        if (string.IsNullOrEmpty(message))
            return "(No message provided)";

        if (message.Length <= maxLength)
            return message;

        return message[..(maxLength - 3)] + "...";
    }
}
```

**Design Notes:**
- Static class since no dependencies needed
- Uses `Markup.Escape()` to prevent formatting injection from exception messages
- Truncates long messages to prevent display issues
- Double-border box with red styling for visual impact
- Console.ReadLine() ensures user sees the screen before exit

---

#### Program.cs Exception Handler

**File:** `RuneAndRust.Terminal/Program.cs` (lines 428-450)

```csharp
catch (Exception ex) when (ex is not OperationCanceledException)
{
    // v0.3.16a: The Safety Net - Global Exception Handler
    // 1. Attempt to log crash details to file
    string? logPath = null;
    try
    {
        // Manually instantiate CrashService since DI container may not be available
        var crashService = new CrashService(
            Microsoft.Extensions.Logging.Abstractions.NullLogger<CrashService>.Instance);
        logPath = crashService.LogCrash(ex);
    }
    catch
    {
        // Swallow - don't crash the crash handler
    }

    // 2. Render user-friendly crash screen
    CrashScreenRenderer.Render(ex, logPath);

    // 3. Log to Serilog if still available
    Log.Fatal(ex, "System Crash");
}
finally
{
    Log.CloseAndFlush();
}
```

**Design Notes:**
- Exception filter `when (ex is not OperationCanceledException)` allows graceful Ctrl+C
- Manual instantiation bypasses DI which may not be available
- NullLogger from Microsoft.Extensions.Logging.Abstractions used as fallback
- Inner try/catch prevents crash handler from crashing
- Serilog Log.Fatal() still called for logging infrastructure if available

---

### Crash Report Format

Example crash report file (`logs/crashes/crash_20251225_143045.txt`):

```
═══════════════════════════════════════════════════════════════════════════════
                         RUNE & RUST CRASH REPORT
═══════════════════════════════════════════════════════════════════════════════

Timestamp:      2025-12-25 14:30:45
Game Version:   v0.3.16a
OS:             Unix 15.3.0
.NET Runtime:   9.0.10

───────────────────────────────────────────────────────────────────────────────
EXCEPTION DETAILS
───────────────────────────────────────────────────────────────────────────────

Type:    System.NullReferenceException
Message: Object reference not set to an instance of an object.

STACK TRACE:
─────────────
   at RuneAndRust.Engine.Services.GameService.ProcessTurnAsync() in /src/GameService.cs:line 142
   at RuneAndRust.Engine.Services.GameService.StartAsync() in /src/GameService.cs:line 98
   at Program.Main(String[] args) in /src/Program.cs:line 426

═══════════════════════════════════════════════════════════════════════════════
Please report this issue at:
https://github.com/southpawriter02/rune-rust/issues
═══════════════════════════════════════════════════════════════════════════════
```

---

### Decision Trees

#### Exception Handler Logic

```
Exception Thrown
       │
       ▼
┌──────────────────────────┐
│ Is OperationCanceled-    │
│ Exception?               │
└──────────────────────────┘
       │
   ┌───┴───┐
   │ YES   │ NO
   ▼       ▼
┌─────┐  ┌────────────────────┐
│PASS │  │ Enter Crash Handler│
│(Ctrl│  │                    │
│+C)  │  └────────────────────┘
└─────┘           │
                  ▼
         ┌───────────────────┐
         │ Try: Instantiate  │
         │ CrashService      │
         └───────────────────┘
                  │
              ┌───┴───┐
          SUCCESS  FAIL
              │       │
              ▼       ▼
         ┌────────┐ ┌────────┐
         │LogCrash│ │logPath │
         │ → path │ │= null  │
         └────────┘ └────────┘
              │       │
              └───┬───┘
                  │
                  ▼
         ┌───────────────────┐
         │ CrashScreenRenderer│
         │ .Render(ex, path) │
         └───────────────────┘
                  │
                  ▼
         ┌───────────────────┐
         │ Log.Fatal(ex,     │
         │ "System Crash")   │
         └───────────────────┘
                  │
                  ▼
         ┌───────────────────┐
         │ finally:          │
         │ Log.CloseAndFlush │
         └───────────────────┘
```

---

### Logging Matrix

| Component | Event | Level | Message Template | Properties |
|-----------|-------|-------|------------------|------------|
| CrashService | Invoked | Trace | "[CRASH] LogCrash invoked for {ExType}" | ExType |
| CrashService | Written | Information | "[CRASH] Crash report written to {Path}" | Path |
| Program | Crash | Fatal | "System Crash" | (exception) |

---

### Test Coverage

#### CrashServiceTests (10 tests)

| Test Name | Purpose | Status |
|-----------|---------|--------|
| `GenerateReportPath_CreatesValidFilename` | Verifies filename format `crash_YYYYMMDD_HHmmss.txt` | Pass |
| `GenerateReportPath_PadsZeros_ForSingleDigitValues` | Verifies zero-padding for dates like `01/05 09:03:07` | Pass |
| `LogCrash_CreatesDirectory_IfMissing` | Verifies `logs/crashes/` created if not exists | Pass |
| `LogCrash_WritesFile_WithExceptionDetails` | Verifies file contains exception type and message | Pass |
| `LogCrash_IncludesSystemInfo` | Verifies version, OS, and runtime in report | Pass |
| `LogCrash_HandlesNestedExceptions` | Verifies inner exception included in report | Pass |
| `LogCrash_ReturnsValidPath` | Verifies returned path is in correct directory | Pass |
| `LogCrash_IncludesStackTrace` | Verifies stack trace included when exception thrown | Pass |
| `LogCrash_IncludesReportingUrl` | Verifies GitHub issues URL in footer | Pass |
| `LogCrash_HandlesNullStackTrace` | Verifies "No stack trace available." fallback | Pass |

**Test Execution:**
```bash
dotnet test --filter "FullyQualifiedName~CrashService"

Test Run Successful.
Total tests: 10
     Passed: 10
 Total time: 0.48 Seconds
```

---

### Manual QA Checklist

- [ ] Sabotage Test: Add `throw new Exception("Test crash");` after host build
- [ ] Verify crash screen appears with red border
- [ ] Verify exception type and message displayed
- [ ] Verify crash log file created in `logs/crashes/`
- [ ] Verify crash log contains system information
- [ ] Verify GitHub issues link displayed
- [ ] Verify ENTER key dismisses screen
- [ ] Verify Ctrl+C still exits gracefully (no crash screen)
- [ ] Remove sabotage code after testing

---

### Design Decisions

#### 1. CrashService Instantiated Manually

**Decision:** Create CrashService with `new` instead of DI

**Rationale:** The DI container may not be available during a crash:
- Host building could have failed
- Container may be in an inconsistent state
- Startup exceptions occur before container is built

**Fallback:** NullLogger used when full logging infrastructure unavailable

#### 2. OperationCanceledException Excluded

**Decision:** Use exception filter `when (ex is not OperationCanceledException)`

**Rationale:** Allow graceful Ctrl+C shutdown:
- Users expect Ctrl+C to exit cleanly
- CancellationToken propagates as OperationCanceledException
- No crash screen needed for intentional cancellation

#### 3. CrashScreenRenderer is Static

**Decision:** Make CrashScreenRenderer a static class

**Rationale:** No dependencies needed:
- Uses only Spectre.Console (static API)
- Console I/O is inherently static
- Simpler invocation from catch block

#### 4. Crash Logs in Separate Directory

**Decision:** Use `logs/crashes/` separate from `logs/`

**Rationale:** Easy identification:
- Crash logs distinct from normal application logs
- Simple to collect for bug reports
- Prevents crash logs from being rotated with daily logs

#### 5. Human-Readable Report Format

**Decision:** Use ASCII art box-drawing characters

**Rationale:** Maximum compatibility:
- Works in all terminals
- Copy-pasteable to GitHub issues
- Readable without special tools

---

### Directory Structure

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Interfaces/
│   │   └── ICrashService.cs          # NEW: Crash handling interface
│   └── Models/
│       └── CrashReport.cs            # NEW: Crash data DTO record
│
├── RuneAndRust.Engine/
│   └── Services/
│       └── CrashService.cs           # NEW: Crash logging implementation
│
├── RuneAndRust.Terminal/
│   ├── Program.cs                    # MODIFIED: Enhanced catch block
│   └── Rendering/
│       └── CrashScreenRenderer.cs    # NEW: Spectre.Console crash UI
│
├── RuneAndRust.Tests/
│   └── Engine/
│       └── CrashServiceTests.cs      # NEW: 10 unit tests
│
└── logs/
    └── crashes/                       # NEW: Crash report output directory
        └── crash_20251225_143045.txt  # Example crash report
```

---

### Related Specifications

| Specification | Status | Description |
|---------------|--------|-------------|
| SPEC-CRASH-001 | To Be Created | Crash Handling System design specification |

---

### Next Steps

**v0.3.16b "The Black Box"** (Emergency Save):
- Implement emergency autosave trigger before crash screen
- Save game state to `data/emergency_save.json`
- Add recovery prompt on next startup
- Integrate with existing SaveGameService

---

### Credits

- **Implementation:** Claude Code (The Architect)
- **Framework:** Spectre.Console for terminal UI
- **Testing:** xUnit + FluentAssertions + NSubstitute
- **Version:** v0.3.16a "The Safety Net"

---

### Verification Results

```
Build: Succeeded (0 errors, 0 warnings)
Tests: 10/10 CrashService tests passing
Total: 2725 tests passing (excluding PostgreSQL integration tests)
Regressions: 0
```

---

## Part B: The Black Box (Emergency Save)

**Release Date:** 2025-12-25
**Tests Added:** 16 (EmergencySaveServiceTests)

### Summary

Version 0.3.16b implements **The Black Box** - an emergency save system that preserves player progress during critical crashes. When the global exception handler (v0.3.16a) catches an unhandled exception, the system now attempts a synchronous JSON serialization of the current game state to `data/saves/emergency.json` before displaying the crash screen. This is Part B of the v0.3.16 "The Sentinel" stability and recovery update.

**Patterns Introduced:**
- **Panic Save Pattern:** Last-chance data preservation using synchronous I/O for reliability
- **Viability Check Pattern:** State validation before attempting emergency operations
- **Fallback Console Logging:** Uses Console.WriteLine when Serilog unavailable
- **Graceful Degradation:** Returns boolean success/failure instead of throwing exceptions
- **File-Based Recovery:** Independent of database connection state

**Layers Touched:**
- **Core Layer:** `IEmergencySaveService` interface defining recovery contract
- **Engine Layer:** `EmergencySaveService` implementation with synchronous JSON serialization
- **Terminal Layer:** `Program.cs` enhanced catch block, `CrashScreenRenderer` backup status display
- **Test Layer:** 16 unit tests in `EmergencySaveServiceTests.cs`

**Key Metrics:**
- 3 new files created
- 2 files modified (Program.cs, CrashScreenRenderer.cs)
- 16 new unit tests
- 0 regressions
- 100% test pass rate for EmergencySaveService

---

### Architecture & Data Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Program.Main() Exception Handler                      │
│                                                                          │
│  catch (Exception ex) when (ex is not OperationCanceledException) {     │
│      │                                                                   │
│      ▼                                                                   │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  CRASH RECOVERY SEQUENCE (v0.3.16a + v0.3.16b)                    │  │
│  │                                                                   │  │
│  │  1. Log Crash (v0.3.16a)                                         │  │
│  │     └─> CrashService.LogCrash(ex)                                │  │
│  │         └─> logs/crashes/crash_YYYYMMDD_HHmmss.txt               │  │
│  │                                                                   │  │
│  │  2. Emergency Save (v0.3.16b) ◄── NEW                            │  │
│  │     ├─> Resolve GameState from DI (if available)                 │  │
│  │     ├─> Viability Check:                                         │  │
│  │     │   ├─ Is GameState null? → Skip                             │  │
│  │     │   ├─ Is CurrentCharacter null? → Skip                      │  │
│  │     │   └─ Is IsSessionActive false? → Skip                      │  │
│  │     ├─> Instantiate EmergencySaveService (manual, no DI)         │  │
│  │     ├─> TryEmergencySave(gameState)                              │  │
│  │     │   ├─> Serialize GameState to JSON (synchronous)            │  │
│  │     │   ├─> Directory.CreateDirectory("data/saves")              │  │
│  │     │   ├─> File.WriteAllText("emergency.json", json)            │  │
│  │     │   └─> Return true/false                                    │  │
│  │     └─> backupSaved = true/false/null                            │  │
│  │                                                                   │  │
│  │  3. Render Crash Screen (v0.3.16a, enhanced v0.3.16b)            │  │
│  │     └─> CrashScreenRenderer.Render(ex, logPath, backupSaved)     │  │
│  │         ├─> Display exception details                            │  │
│  │         ├─> Show crash log path                                  │  │
│  │         ├─> Show backup status: ◄── NEW                          │  │
│  │         │   ├─ Green: "Game progress backed up successfully"     │  │
│  │         │   └─ Yellow: "Unable to backup game progress"          │  │
│  │         └─> Wait for ENTER                                       │  │
│  │                                                                   │  │
│  │  4. Log to Serilog (v0.3.16a)                                    │  │
│  │     └─> Log.Fatal(ex, "System Crash")                            │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│  }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘
```

**Emergency Save State Machine:**

```
GameState Input
     │
     ▼
┌──────────────────┐
│ Viability Checks │
└──────────────────┘
     │
  ┌──┴───┬─────────┬──────────┐
  │      │         │          │
  ▼      ▼         ▼          ▼
Null  Char=null Session   Valid
State           Inactive
  │      │         │          │
  └──────┴─────────┘          │
         │                    │
         ▼                    ▼
  Return false          ┌──────────────┐
                        │ Serialize to │
                        │    JSON      │
                        └──────────────┘
                               │
                           ┌───┴───┐
                        SUCCESS  FAIL
                           │       │
                           ▼       ▼
                    Return true  Return false
                           │       │
                           └───┬───┘
                               │
                               ▼
                     Display Backup Status
```

---

### New Files Created

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Core/Interfaces/IEmergencySaveService.cs` | Interface for emergency save operations during crashes | 38 |
| `RuneAndRust.Engine/Services/EmergencySaveService.cs` | Synchronous JSON serialization for panic saves | 104 |
| `RuneAndRust.Tests/Engine/EmergencySaveServiceTests.cs` | Unit tests for emergency save functionality | 348 |

---

### Files Modified

| File | Change | Lines Affected |
|------|--------|----------------|
| `RuneAndRust.Terminal/Program.cs` | Added emergency save attempt before crash screen | 455-476 (22 lines added) |
| `RuneAndRust.Terminal/Rendering/CrashScreenRenderer.cs` | Added backup status parameter and display logic | 23, 49-61 (enhanced) |

---

### Code Implementation Details

#### IEmergencySaveService Interface

**File:** `RuneAndRust.Core/Interfaces/IEmergencySaveService.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for emergency game state preservation during crashes (v0.3.16b).
/// Uses file-based synchronous I/O to maximize reliability when the
/// application is in a potentially unstable state.
/// Part of "The Black Box" crash recovery system.
/// </summary>
public interface IEmergencySaveService
{
    /// <summary>
    /// Attempts to save the current game state to the emergency backup file.
    /// Uses synchronous I/O to ensure completion before process death.
    /// </summary>
    bool TryEmergencySave(GameState state);

    /// <summary>
    /// Checks if an emergency save file exists.
    /// </summary>
    bool EmergencySaveExists();

    /// <summary>
    /// Loads the emergency save file if it exists.
    /// </summary>
    GameState? LoadEmergencySave();

    /// <summary>
    /// Deletes the emergency save file after successful recovery.
    /// </summary>
    void ClearEmergencySave();
}
```

**Method Signatures:**
- `bool TryEmergencySave(GameState state)` - Returns true if save succeeded, false otherwise
- `bool EmergencySaveExists()` - Returns true if emergency.json exists
- `GameState? LoadEmergencySave()` - Returns loaded state or null if not found/corrupt
- `void ClearEmergencySave()` - Deletes emergency save file, no-throw

**Design Notes:**
- Interface allows for future alternative implementations
- All methods use synchronous I/O (no async) for crash reliability
- Returns nullables/booleans instead of throwing exceptions
- Follows the "fail gracefully" principle

---

#### EmergencySaveService Implementation

**File:** `RuneAndRust.Engine/Services/EmergencySaveService.cs`

**Key Constants:**
```csharp
private const string EmergencyPath = "data/saves/emergency.json";
```

**JSON Serialization Options:**
```csharp
private static readonly JsonSerializerOptions JsonOptions = new()
{
    WriteIndented = true,
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
};
```

**Core Behaviors:**

##### TryEmergencySave(GameState state)
- **Viability Checks:**
  - Returns false if `state` is null
  - Returns false if `state.CurrentCharacter` is null
  - Returns false if `state.IsSessionActive` is false
- **Directory Creation:** Ensures `data/saves/` exists via `Directory.CreateDirectory()`
- **Serialization:** Uses `JsonSerializer.Serialize()` synchronously
- **File Write:** Uses `File.WriteAllText()` synchronously
- **Logging:** Writes success/failure to Console (Serilog may be unavailable)
- **Exception Handling:** Catches all exceptions, logs to Console, returns false
- **No Throw Guarantee:** Never throws; always returns boolean

##### EmergencySaveExists()
- Returns `File.Exists(EmergencyPath)`
- Simple existence check, no I/O errors propagated

##### LoadEmergencySave()
- Returns null if file doesn't exist
- Reads file synchronously with `File.ReadAllText()`
- Deserializes JSON to `GameState`
- Returns null on any deserialization error (corrupt JSON)
- No throw guarantee

##### ClearEmergencySave()
- Deletes file if it exists
- Ignores all errors (cleanup is not critical)
- No throw guarantee

**Thresholds & Constants:**
- Emergency path: `data/saves/emergency.json` (relative to working directory)
- JSON format: Indented, camelCase property names
- No retry logic (crash context requires single attempt)

---

#### Program.cs Crash Handler Integration

**File:** `RuneAndRust.Terminal/Program.cs` (lines 455-476)

```csharp
// v0.3.16b: The Black Box - Attempt emergency save
// 2. Try to preserve game state before displaying crash screen
bool? backupSaved = null;
try
{
    if (host != null)
    {
        var gameState = host.Services.GetService<GameState>();
        if (gameState?.CurrentCharacter != null && gameState.IsSessionActive)
        {
            var emergencySaveService = new EmergencySaveService();
            backupSaved = emergencySaveService.TryEmergencySave(gameState);
        }
    }
}
catch
{
    backupSaved = false;
}

// 3. Render user-friendly crash screen with backup status
CrashScreenRenderer.Render(ex, logPath, backupSaved);
```

**Integration Behavior:**
- Executes after crash log creation but before crash screen display
- Manually instantiates `EmergencySaveService` (DI container may be compromised)
- Pre-filters viability (CurrentCharacter not null, session active)
- Three-state logic: `true` (saved), `false` (failed), `null` (not attempted)
- Inner try/catch prevents emergency save failures from hiding crash screen
- Passes `backupSaved` status to CrashScreenRenderer

---

#### CrashScreenRenderer Enhancement

**File:** `RuneAndRust.Terminal/Rendering/CrashScreenRenderer.cs`

**Method Signature Change:**
```csharp
public static void Render(Exception ex, string? logPath = null, bool? backupSaved = null)
```

**Backup Status Display Logic (lines 49-61):**
```csharp
// v0.3.16b: Add backup status section
if (backupSaved.HasValue)
{
    rows.Add(new Text(""));
    if (backupSaved.Value)
    {
        rows.Add(new Markup("[green]Game progress backed up successfully[/]"));
    }
    else
    {
        rows.Add(new Markup("[yellow]Unable to backup game progress[/]"));
    }
}
```

**Visual Output:**
- **Success:** Green text stating "Game progress backed up successfully"
- **Failure:** Yellow text stating "Unable to backup game progress"
- **Not Attempted:** No backup status line displayed (backward compatible)

---

### Logging Matrix

| Component | Event | Level | Message Template | Output |
|-----------|-------|-------|------------------|--------|
| EmergencySaveService | Success | Console | `"[EMERGENCY] Game state saved to {Path}"` | Console.WriteLine |
| EmergencySaveService | Failure | Console | `"[EMERGENCY] Save failed: {Message}"` | Console.WriteLine |

**Note:** This service uses `Console.WriteLine` instead of Serilog because:
1. Serilog may be disposed during crash
2. Logger dependency injection unavailable
3. Console output visible in crash context
4. Simplicity maximizes reliability

---

### Test Coverage

#### EmergencySaveServiceTests (16 tests)

##### TryEmergencySave Tests (8 tests)

| Test Name | Description |
|-----------|-------------|
| `TryEmergencySave_WritesFile_WhenStateValid` | Verifies emergency.json created when valid GameState provided |
| `TryEmergencySave_ReturnsTrue_OnSuccess` | Verifies method returns true for successful save |
| `TryEmergencySave_ReturnsFalse_WhenStateNull` | Verifies null state rejected, returns false, no file created |
| `TryEmergencySave_ReturnsFalse_WhenCharacterNull` | Verifies null character rejected, returns false, no file created |
| `TryEmergencySave_ReturnsFalse_WhenSessionInactive` | Verifies inactive session rejected, returns false, no file created |
| `TryEmergencySave_CreatesDirectory_IfMissing` | Verifies `data/saves/` directory created if doesn't exist |
| `TryEmergencySave_OverwritesExisting` | Verifies subsequent saves overwrite previous emergency.json |
| `TryEmergencySave_WritesValidJson` | Verifies JSON contains expected fields (phase, character, turnCount, isSessionActive) |

##### EmergencySaveExists Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `EmergencySaveExists_ReturnsTrue_WhenFileExists` | Verifies returns true after successful save |
| `EmergencySaveExists_ReturnsFalse_WhenNoFile` | Verifies returns false when emergency.json doesn't exist |

##### LoadEmergencySave Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `LoadEmergencySave_ReturnsState_WhenFileValid` | Verifies GameState loaded with correct TurnCount, IsSessionActive, Character.Name |
| `LoadEmergencySave_ReturnsNull_WhenFileCorrupt` | Verifies returns null for malformed JSON without throwing |
| `LoadEmergencySave_ReturnsNull_WhenFileMissing` | Verifies returns null when emergency.json doesn't exist |
| `LoadEmergencySave_PreservesCharacterData` | Verifies CurrentHP and CurrentStamina preserved during serialization round-trip |

##### ClearEmergencySave Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `ClearEmergencySave_DeletesFile` | Verifies emergency.json deleted after clear operation |
| `ClearEmergencySave_DoesNotThrow_WhenFileMissing` | Verifies no exception thrown when clearing non-existent file |

**Test Execution Summary:**
```
Test Run Successful.
Total tests: 16
     Passed: 16
     Failed: 0
 Total time: 0.52 Seconds
```

---

### Verification Results

#### Build Output

```
Build succeeded.
    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.10
```

**Warnings:** None related to v0.3.16b changes (Entity Framework version conflict unrelated)

#### Test Results

```bash
$ dotnet test --filter "FullyQualifiedName~EmergencySaveServiceTests"

Test Run Successful.
Total tests: 16
     Passed: 16
 Total time: 0.52 Seconds
```

**All 16 EmergencySaveService tests passing.**

---

### Architecture Decisions

#### 1. Synchronous I/O Instead of Async

**Decision:** Use `File.WriteAllText()` instead of `File.WriteAllTextAsync()`

**Rationale:**
- Application is crashing; process may terminate at any moment
- Async operations require event loop which may be compromised
- Synchronous calls block until completion, ensuring write finishes
- No benefit to async in crash context (no other work to interleave)
- Simplicity reduces failure modes

**Trade-off:** Blocks main thread, but acceptable since crash is imminent

#### 2. Manual Service Instantiation

**Decision:** `new EmergencySaveService()` instead of DI resolution

**Rationale:**
- DI container may not be built yet (startup crash)
- DI container may be in inconsistent state (container crash)
- No dependencies needed (file I/O is self-contained)
- Reduces coupling to infrastructure during crisis

**Trade-off:** Not testable via DI mocking, but unit tests directly instantiate anyway

#### 3. Viability Checks Before Serialization

**Decision:** Reject null state, null character, or inactive session

**Rationale:**
- No character = no meaningful progress to save
- Inactive session = game not started or already ended
- Prevents writing empty/useless emergency saves
- Reduces disk writes in non-game-playing crash scenarios

**Threshold:** `IsSessionActive == true` AND `CurrentCharacter != null`

#### 4. File-Based Instead of Database

**Decision:** Use `emergency.json` file instead of database table

**Rationale:**
- Database connection may be unavailable during crash
- Database transaction may be in progress (locking issues)
- File I/O simpler, more reliable
- JSON portable for debugging (can inspect file manually)
- Independent of PostgreSQL service status

**Trade-off:** File may be overwritten on subsequent crash (acceptable, only need most recent)

#### 5. Three-State Backup Status (true/false/null)

**Decision:** `bool?` with null meaning "not attempted"

**Rationale:**
- `null` distinguishes "no GameState available" from "save failed"
- Allows backward compatibility (v0.3.16a calls still work)
- UI can skip backup section if null
- More informative than binary success/failure

**Display Logic:**
- `true` → Green success message
- `false` → Yellow failure message
- `null` → No backup status displayed

#### 6. Console Logging Instead of Serilog

**Decision:** Use `Console.WriteLine` in EmergencySaveService

**Rationale:**
- Serilog may be disposed during crash
- Serilog configuration may be source of crash
- Console.WriteLine always available
- Output visible in crash dumps
- No dependency on external infrastructure

**Trade-off:** Not captured in structured logs, but crash logs capture exception anyway

---

### Directory Structure

```
RuneAndRust/
├── RuneAndRust.Core/
│   └── Interfaces/
│       ├── ICrashService.cs                 # v0.3.16a
│       └── IEmergencySaveService.cs         # NEW v0.3.16b: Emergency save interface
│
├── RuneAndRust.Engine/
│   └── Services/
│       ├── CrashService.cs                  # v0.3.16a
│       └── EmergencySaveService.cs          # NEW v0.3.16b: Panic save implementation
│
├── RuneAndRust.Terminal/
│   ├── Program.cs                           # MODIFIED v0.3.16b: Lines 455-476 (emergency save)
│   └── Rendering/
│       └── CrashScreenRenderer.cs           # MODIFIED v0.3.16b: Backup status parameter
│
├── RuneAndRust.Tests/
│   └── Engine/
│       ├── CrashServiceTests.cs             # v0.3.16a (10 tests)
│       └── EmergencySaveServiceTests.cs     # NEW v0.3.16b: 16 unit tests
│
└── data/
    └── saves/
        └── emergency.json                    # NEW: Emergency backup file (created on crash)
```

---

### Running Tests

#### Run All EmergencySaveService Tests

```bash
dotnet test --filter "FullyQualifiedName~EmergencySaveServiceTests"
```

**Expected Output:**
```
Test Run Successful.
Total tests: 16
     Passed: 16
 Total time: 0.52 Seconds
```

#### Run All Crash System Tests (v0.3.16a + v0.3.16b)

```bash
dotnet test --filter "FullyQualifiedName~CrashService | FullyQualifiedName~EmergencySaveService"
```

**Expected:** 26 tests total (10 CrashService + 16 EmergencySaveService)

---

### Usage Examples

#### Example 1: Crash With Successful Backup

**Scenario:** Player is exploring, game crashes due to null reference exception

**Console Output:**
```
[EMERGENCY] Game state saved to data/saves/emergency.json

╔═══════════════════════════════════════════════════════════════╗
║              SYSTEM FAILURE                                    ║
╠═══════════════════════════════════════════════════════════════╣
║                                                                ║
║  A critical error has occurred.                                ║
║                                                                ║
║  NullReferenceException                                        ║
║  Object reference not set to an instance of an object.         ║
║                                                                ║
║  Crash report saved to:                                        ║
║  logs/crashes/crash_20251225_143045.txt                        ║
║                                                                ║
║  Game progress backed up successfully                          ║ ← GREEN
║                                                                ║
║  Please report this issue at:                                  ║
║  https://github.com/southpawriter02/rune-rust/issues           ║
║                                                                ║
╚═══════════════════════════════════════════════════════════════╝

Press ENTER to exit...
```

#### Example 2: Crash Without Backup (No Active Session)

**Scenario:** Game crashes during startup before player creates character

**Console Output:**
```
╔═══════════════════════════════════════════════════════════════╗
║              SYSTEM FAILURE                                    ║
╠═══════════════════════════════════════════════════════════════╣
║                                                                ║
║  A critical error has occurred.                                ║
║                                                                ║
║  InvalidOperationException                                     ║
║  Failed to load localization resources.                        ║
║                                                                ║
║  Crash report saved to:                                        ║
║  logs/crashes/crash_20251225_091522.txt                        ║
║                                                                ║
║  (No backup status shown - no active session)                  ║
║                                                                ║
║  Please report this issue at:                                  ║
║  https://github.com/southpawriter02/rune-rust/issues           ║
║                                                                ║
╚═══════════════════════════════════════════════════════════════╝

Press ENTER to exit...
```

---

### Next Steps

**v0.3.17 "The Toolbox"** (Debug Console & Cheat Commands):
- Implement developer console overlay
- Add cheat command parser
- Integrate with existing game systems

**Technical Debt:**
- Consider adding emergency save age check (warn if > 7 days old)
- Evaluate adding partial state saves (character only, no full dungeon)
- Research async signal handlers for SIGTERM/SIGKILL interception

---

### Credits

- **Implementation:** Claude Code (The Architect)
- **Framework:** System.Text.Json for synchronous serialization
- **Testing:** xUnit + FluentAssertions
- **Version:** v0.3.16b "The Black Box"
- **Design Specification:** `docs/plans/v0.3.x/v0.3.16b.md`

---

**End of Changelog v0.3.16**
