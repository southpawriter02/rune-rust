> **Archived** - This plan has been consolidated. See the complete version at [v0.3.14](../v0.3.x/v0.3.14.md).

# v0.3.14b: The Flow (Animations & Transitions)

This version implements "Juice" for the Terminal UI. It introduces a ScreenTransitionService that intercepts Game Phase changes to play short, ASCII-based animations (Shatter, Dissolve, Static), smoothing the jarring visual snap between Exploration and Combat. Crucially, it integrates with the ReduceMotion setting established in v0.3.9a to ensure accessibility.

Goal: Implement ScreenTransitionService to manage visual hand-offs between game states, using Spectre.Console.Live to render frame-based ASCII effects.
1. Architecture & Data Flow
The Interstitial Pipeline Unlike standard renderers which draw once per input, the Transition Service creates a temporary Render Loop that blocks the Game Loop for 500-1000ms.
	1	Trigger: GameService detects a Phase Change (e.g., Exploration → Combat).
	2	Guard: Check GameSettings.ReduceMotion.
	◦	If True: Console.Clear() and proceed immediately.
	3	Handoff: Call TransitionService.PlayAsync(TransitionType).
	4	Animation Loop:
	◦	Initialize AnsiConsole.Live.
	◦	Frame 0-N: Generate ASCII frame (e.g., increased noise density).
	◦	Update: Push frame to terminal.
	◦	Delay: Wait 16ms-50ms (simulating 20-60 FPS).
	5	Completion: Clear screen. Return control to GameService.
	6	Resume: GameService calls the new Phase's Renderer.
2. Logic Decision Trees
A. Transition Selection Logic Input: PreviousPhase, NewPhase
	1	Combat Start (Exploration -> Combat):
	◦	Effect: Shatter (Screen appears to break into noise).
	◦	Tone: Aggressive, red/yellow colors.
	2	Combat Victory (Combat -> Exploration):
	◦	Effect: Dissolve (Screen fades to empty/green).
	◦	Tone: Calm, slowing down.
	3	Game Over (Combat -> Quit/Menu):
	◦	Effect: GlitchDecay (Text turns to Zalgo/Garbage then black).
	4	Default: Instant (Clear screen only).
B. "Shatter" Generation Logic (Per Frame) Input: FrameIndex (0 to 10), ScreenWidth, ScreenHeight
	1	Calculate Density: Density = FrameIndex * 10%.
	2	Generate Grid: Create a string buffer matching screen dimensions.
	3	Fill: For every character cell:
	◦	Roll RNG < Density?
	▪	Yes: Insert random "shard" char (/, \, #, X) with random color (Red, Grey).
	▪	No: Insert Space (or preserve previous if feasible).
	4	Output: Return Markup string.
3. Deliverable Checklist
	•	Core:
	◦	[ ] Define TransitionType enum.
	◦	[ ] Define IScreenTransitionService interface.
	•	Terminal:
	◦	[ ] Implement ScreenTransitionService.
	◦	[ ] Implement TransitionRenderer (Helper for ASCII generation).
	◦	[ ] Register service in Program.cs.
	•	Engine:
	◦	[ ] Update GameService to inject IScreenTransitionService.
	◦	[ ] Refactor GameService loop to await transitions on phase changes.
4. Code Implementation
A. Interface Definition File: RuneAndRust.Core/Interfaces/IScreenTransitionService.cs
public enum TransitionType { None, Shatter, Dissolve, Glitch }

public interface IScreenTransitionService
{
    Task PlayAsync(TransitionType type);
}
B. Service Implementation (The Effect Loop) File: RuneAndRust.Terminal/Services/ScreenTransitionService.cs
public class ScreenTransitionService : IScreenTransitionService
{
    private readonly ILogger _logger;

    public ScreenTransitionService(ILogger logger)
    {
        _logger = logger;
    }

    public async Task PlayAsync(TransitionType type)
    {
        // 1. Accessibility Check
        if (GameSettings.ReduceMotion)
        {
            AnsiConsole.Clear();
            return;
        }

        _logger.LogTrace("[VFX] Playing transition: {Type}", type);

        // 2. Select Animation
        switch (type)
        {
            case TransitionType.Shatter:
                await PlayShatterEffect();
                break;
            case TransitionType.Dissolve:
                await PlayDissolveEffect();
                break;
        }

        // 3. Final Cleanup
        AnsiConsole.Clear();
    }

    private async Task PlayShatterEffect()
    {
        // Using Live render for smooth updates
        await AnsiConsole.Live(new Text(""))
            .AutoClear(false)
            .StartAsync(async ctx =>
            {
                var width = Console.WindowWidth;
                var height = Math.Min(Console.WindowHeight, 20); // Cap height for perf
                var random = new Random();
                var shards = new[] { '/', '\\', '#', 'X', '%', '&' };

                // 10 Frames over 500ms
                for (int i = 1; i <= 10; i++)
                {
                    var density = i * 10; // 10% to 100%
                    var sb = new StringBuilder();

                    for (int y = 0; y < height; y++)
                    {
                        for (int x = 0; x < width; x++)
                        {
                            if (random.Next(100) < density)
                            {
                                var shard = shards[random.Next(shards.Length)];
                                sb.Append($"[red]{shard}[/]");
                            }
                            else
                            {
                                sb.Append(" ");
                            }
                        }
                        sb.AppendLine();
                    }

                    ctx.UpdateTarget(new Markup(sb.ToString()));
                    await Task.Delay(50); // Frame delay
                }
            });
    }
}
C. GameService Integration File: RuneAndRust.Engine/Services/GameService.cs
// In the Main Loop
if (_state.Phase != _previousPhase)
{
    if (_state.Phase == GamePhase.Combat)
    {
        await _transitionService.PlayAsync(TransitionType.Shatter);
    }
    else if (_previousPhase == GamePhase.Combat && _state.Phase == GamePhase.Exploration)
    {
        await _transitionService.PlayAsync(TransitionType.Dissolve);
    }
    else
    {
        Console.Clear(); // Fallback
    }

    _previousPhase = _state.Phase;
}
5. Logging Requirements
System
Event
Level
Message Template
Properties
VFX
Start
Trace
"[VFX] Transition Sequence: {Type}"
Type
VFX
Skip
Debug
"[VFX] Transition skipped (ReduceMotion: ON)"
-
VFX
Frame
Verbose
"[VFX] Rendered Frame {Frame}/{Total}"
Frame, Total
6. Testing Strategy
Unit Tests (ScreenTransitionTests.cs):
	•	ReduceMotion_Skips: Set GameSettings.ReduceMotion = true. Call PlayAsync. Assert method returns almost instantly (use Stopwatch).
	•	Enum_Routing: Call PlayAsync(TransitionType.Shatter). Verify internal logic routes to Shatter method (via Mock or spy).
Manual QA:
	•	Performance: Resize terminal to full screen. Trigger combat. Ensure the animation does not lag significantly (>1s).
	•	Accessibility: Enable ReduceMotion. Trigger combat. Ensure screen clears instantly with no flashing.
	•	Visuals: Verify "Shatter" looks chaotic (Red/Noise) and "Dissolve" looks peaceful (Fade out).
7. Draft Changelog (v0.3.14b)
# v0.3.14b Changelog: The Flow
**Release Date:** 2026-02-10

## Summary
This release adds "The Flow," a visual transition system that bridges the gap between gameplay phases. Instead of instant context switches, the terminal now renders ASCII-based animations—Shattering when entering combat and Dissolving when leaving it—providing visual cues for state changes.

## New Features
*   **Screen Transitions:** Implemented `Shatter` (Combat Start) and `Dissolve` (Victory) animations using `Spectre.Console.Live`.
*   **Motion Settings:** Fully integrated with `GameSettings.ReduceMotion`. When enabled, all transitions are skipped for instant response.

## Technical Changes
*   Added `IScreenTransitionService` to Core.
*   Refactored `GameService` loop to handle asynchronous phase transitions.
*   Implemented frame-based ASCII generation in `ScreenTransitionService`.