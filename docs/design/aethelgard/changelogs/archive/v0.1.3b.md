> **Archived** - This changelog has been consolidated. See the complete version at [v0.1.3](../v0.1.x/v0.1.3.md).

# Changelog: v0.1.3b - The Codex (Capture Logic & Distribution)

**Release Date:** 2025-12-19

---

## Summary

Version 0.1.3b implements the **Engine layer services** for discovering, generating, and assigning Data Captures during gameplay. Building on v0.1.3a's data foundation, this release adds the `DataCaptureService` for probabilistic capture generation during container searches and expert-tier examinations. Captures are automatically matched to Codex Entries by keyword and include WITS-based chance modifiers. The implementation features 19 Domain 4 compliant lore templates across 6 categories, deterministic testing via seeded Random, and comprehensive trace/debug logging throughout all code paths. Integration with `InteractionService` hooks capture generation into existing examine and search mechanics without breaking backward compatibility.

---

## New Files Created

### Core Layer - Models

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/CaptureResult.cs` | Result record for capture operations with factory methods (`Generated`, `NoCapture`) |

### Core Layer - Interfaces

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IDataCaptureService.cs` | Service contract for capture generation, completion tracking, and threshold unlocking |

### Engine Layer - Services

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/CaptureTemplates.cs` | Static capture template definitions (19 templates across 6 categories) with Domain 4 compliant lore content |
| `RuneAndRust.Engine/Services/DataCaptureService.cs` | Main capture generation and assignment logic with WITS-based probability modifiers |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/DataCaptureServiceTests.cs` | 23 unit tests for generation, auto-assignment, and completion percentage calculations |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Engine/Services/InteractionService.cs` | Added optional `IDataCaptureService` injection; integrated capture generation into `ExamineAsync` (expert tier) and `SearchContainerAsync` |
| `RuneAndRust.Terminal/Program.cs` | Registered `ICodexEntryRepository`, `IDataCaptureRepository`, and `IDataCaptureService` in DI container |

---

## Code Implementation Details

### CaptureResult Model

```csharp
public record CaptureResult(
    bool Success,
    string Message,
    DataCapture? Capture,
    bool WasAutoAssigned)
{
    public static CaptureResult Generated(string message, DataCapture capture, bool autoAssigned)
        => new(true, message, capture, autoAssigned);

    public static CaptureResult NoCapture(string message)
        => new(false, message, null, false);
}
```

**Factory Methods:**
- `Generated`: Creates successful result with capture and auto-assignment status
- `NoCapture`: Creates failure result with explanation message

### IDataCaptureService Interface

```csharp
public interface IDataCaptureService
{
    Task<CaptureResult> TryGenerateFromSearchAsync(
        Guid characterId, InteractableObject container, int witsBonus = 0);

    Task<CaptureResult> TryGenerateFromExaminationAsync(
        Guid characterId, InteractableObject target, int tierRevealed, int witsBonus = 0);

    Task<int> GetCompletionPercentageAsync(Guid entryId, Guid characterId);

    Task<IEnumerable<string>> GetUnlockedThresholdsAsync(Guid entryId, Guid characterId);
}
```

**Key Methods:**
- `TryGenerateFromSearchAsync`: 25% base chance + (WITS × 5%)
- `TryGenerateFromExaminationAsync`: Tier-based chances (Expert: 75%, Detailed: 37%, Base: 0%)
- `GetCompletionPercentageAsync`: Returns (fragmentCount × 100) / totalFragments, capped at 100
- `GetUnlockedThresholdsAsync`: Returns threshold tags where key <= percentage

### CaptureTemplate Record

```csharp
public record CaptureTemplate(
    CaptureType Type,
    string FragmentContent,
    string Source,
    string[] MatchingKeywords);
```

### Template Categories

| Category | Template Count | Trigger Keywords |
|----------|---------------|------------------|
| RustedServitor | 4 | servitor, automaton, machine, mechanical |
| GenericContainer | 3 | container, chest, crate, box |
| BlightedCreature | 3 | blight, corrupted, infected, mutation |
| IndustrialSite | 3 | industrial, forge, foundry, factory |
| AncientRuin | 3 | ruin, ancient, inscription, tomb |
| FieldGuideTriggers | 3 | psychic, combat, burden, inventory |

### DataCaptureService Constants

```csharp
private const int BaseSearchCaptureChance = 25;     // 25% base on container search
private const int ExpertExamCaptureChance = 75;     // 75% on expert examination
private const int DetailedExamCaptureChance = 37;   // 37% on detailed examination
private const int StandardQuality = 15;              // Quality for search/detailed
private const int SpecialistQuality = 30;           // Quality for expert tier
private const int ExpertTier = 2;                   // 3+ net successes
private const int DetailedTier = 1;                 // 1+ net successes
```

### InteractionService Integration

**Constructor Change:**
```csharp
public InteractionService(
    // ... existing 7 parameters ...
    IDataCaptureService? captureService = null)  // Optional for backward compatibility
```

**ExamineAsync Integration (expert tier):**
```csharp
if (tierRevealed >= ExpertTierThreshold && _captureService != null && _gameState.CurrentCharacter != null)
{
    var witsBonus = _gameState.CurrentCharacter.GetAttribute(CharacterAttribute.Wits) / 2;
    var captureResult = await _captureService.TryGenerateFromExaminationAsync(
        _gameState.CurrentCharacter.Id, target, tierRevealed, witsBonus);

    if (captureResult.Success)
    {
        description += $"\n\n[Data Captured: {captureResult.Capture!.Type}]";
        _logger.LogInformation("Generated capture during examination: {Message}", captureResult.Message);
    }
}
```

**SearchContainerAsync Integration:**
```csharp
if (_captureService != null && _gameState.CurrentCharacter != null)
{
    var witsBonus = _gameState.CurrentCharacter.GetAttribute(CharacterAttribute.Wits) / 2;
    var captureResult = await _captureService.TryGenerateFromSearchAsync(
        _gameState.CurrentCharacter.Id, container, witsBonus);

    if (captureResult.Success)
    {
        _logger.LogInformation("Generated capture during search: {Message}", captureResult.Message);
    }
}
```

---

## Logging Matrix

### DataCaptureService

| Method | Level | Template |
|--------|-------|----------|
| TryGenerateFromSearchAsync | Debug | `"Attempting capture generation for Character {CharacterId} from search of {ContainerName}"` |
| TryGenerateFromSearchAsync | Debug | `"Capture roll: {Roll} vs target {Target} (WITS bonus: {WitsBonus})"` |
| TryGenerateFromSearchAsync | Debug | `"Capture roll failed, no capture generated"` |
| TryGenerateFromSearchAsync | Info | `"Generated {CaptureType} capture for Character {CharacterId}"` |
| TryGenerateFromExaminationAsync | Debug | `"Attempting capture generation for Character {CharacterId} from examination of {TargetName} (tier {Tier})"` |
| TryGenerateFromExaminationAsync | Debug | `"Base tier examination, no capture chance"` |
| TryGenerateFromExaminationAsync | Trace | `"Assigned quality {Quality} based on tier {Tier} (Expert threshold: {ExpertTier})"` |
| GetCompletionPercentageAsync | Debug | `"Calculating completion percentage for Entry {EntryId} and Character {CharacterId}"` |
| GetCompletionPercentageAsync | Debug | `"Character {CharacterId} has {Percentage}% completion for Entry {EntryId}"` |
| GetUnlockedThresholdsAsync | Debug | `"Getting unlocked thresholds for Entry {EntryId} and Character {CharacterId}"` |
| GetUnlockedThresholdsAsync | Trace | `"Filtered thresholds at {Percentage}%: {Thresholds}"` |
| SelectTemplate | Trace | `"Selecting capture template for object {ObjectName}"` |
| SelectTemplate | Trace | `"Selected [Category] template category for {ObjectName}"` |
| SelectTemplate | Trace | `"No template category matched for {ObjectName}"` |
| SelectRandomTemplate | Trace | `"Selecting random template from {TemplateCount} templates"` |
| SelectRandomTemplate | Trace | `"Selected template at index {Index}: Type {TemplateType}"` |
| SelectRandomTemplate | Warning | `"Template array is empty, returning null"` |
| TryAutoAssignAsync | Debug | `"Attempting auto-assignment for capture using keywords: {Keywords}"` |
| TryAutoAssignAsync | Trace | `"Checking CodexEntry {EntryId} ({EntryTitle}) for keyword match"` |
| TryAutoAssignAsync | Debug | `"Auto-assigned capture to CodexEntry {EntryTitle}"` |
| TryAutoAssignAsync | Debug | `"No matching CodexEntry found, capture remains unassigned"` |

### InteractionService (New)

| Method | Level | Template |
|--------|-------|----------|
| ExamineAsync | Info | `"Generated capture during examination: {Message}"` |
| SearchContainerAsync | Info | `"Generated capture during search: {Message}"` |

---

## Test Coverage

### DataCaptureServiceTests.cs (23 tests)

| Region | Tests |
|--------|-------|
| TryGenerateFromSearchAsync | `RollSucceeds_ReturnsCapture`, `RollFails_ReturnsNoCapture`, `WithHighWits_IncreasesChance`, `ServitorContainer_ReturnsServitorCapture`, `PersistsCaptureToRepository` |
| TryGenerateFromExaminationAsync | `ExpertTier_HighChance`, `DetailedTier_MediumChance`, `BaseTier_NoCapture`, `ExpertTier_SetsSpecialistQuality` |
| Auto-Assignment | `MatchingEntry_AutoAssigns`, `NoMatchingEntry_RemainsUnassigned` |
| GetCompletionPercentageAsync | `NoFragments_ReturnsZero`, `AllFragments_ReturnsHundred`, `HalfFragments_ReturnsFifty`, `EntryNotFound_ReturnsZero`, `MoreFragmentsThanRequired_CapsAtHundred` |
| GetUnlockedThresholdsAsync | `AtZeroPercent_ReturnsEmpty`, `AtTwentyFivePercent_ReturnsFirstThreshold`, `AtFiftyPercent_ReturnsTwoThresholds`, `AtHundredPercent_ReturnsAllThresholds`, `EntryNotFound_ReturnsEmpty` |
| CaptureResult Factory | `Generated_SetsAllProperties`, `NoCapture_ReturnsFailure` |

---

## Test Summary

| Category | Count | Status |
|----------|-------|--------|
| DataCaptureServiceTests | 23 | Passed |
| **v0.1.3b Total** | **23** | **All Passed** |
| **Full Suite Total** | **1,141** | **All Passed** |

---

## Directory Structure

```
RuneAndRust.Core/
├── Interfaces/
│   └── IDataCaptureService.cs   [NEW]
└── Models/
    └── CaptureResult.cs         [NEW]

RuneAndRust.Engine/
└── Services/
    ├── CaptureTemplates.cs      [NEW]
    ├── DataCaptureService.cs    [NEW]
    └── InteractionService.cs    [MODIFIED]

RuneAndRust.Terminal/
└── Program.cs                   [MODIFIED]

RuneAndRust.Tests/
└── Engine/
    └── DataCaptureServiceTests.cs   [NEW]
```

---

## Technical Highlights

### Deterministic Testing with Seeded Random

The service supports a seeded Random for deterministic unit tests:

```csharp
// Production constructor
public DataCaptureService(
    ILogger<DataCaptureService> logger,
    IDataCaptureRepository captureRepository,
    ICodexEntryRepository codexRepository)
{
    _random = new Random();  // Non-deterministic
}

// Test constructor with seed
public DataCaptureService(
    ILogger<DataCaptureService> logger,
    IDataCaptureRepository captureRepository,
    ICodexEntryRepository codexRepository,
    int seed)
{
    _random = new Random(seed);  // Deterministic for testing
}
```

### Template Selection Logic

Templates are selected based on keyword matching in the object's name and description:

```csharp
private CaptureTemplate? SelectTemplate(InteractableObject obj)
{
    var combined = $"{obj.Name.ToLowerInvariant()} {obj.Description.ToLowerInvariant()}";

    if (ContainsAny(combined, "servitor", "automaton", "machine", "mechanical"))
        return SelectRandomTemplate(CaptureTemplates.RustedServitor);

    if (ContainsAny(combined, "blight", "corrupted", "infected", "mutation"))
        return SelectRandomTemplate(CaptureTemplates.BlightedCreature);

    // ... additional categories ...

    if (obj.IsContainer)
        return SelectRandomTemplate(CaptureTemplates.GenericContainer);

    return null;  // No matching template
}
```

### WITS Bonus Mechanics

| Generation Source | Base Chance | WITS Modifier | Max Effective |
|-------------------|-------------|---------------|---------------|
| Container Search | 25% | +5% per point | 75% (at WITS 10) |
| Expert Examination | 75% | +3% per point | 105% → 100% |
| Detailed Examination | 37% | +3% per point | 67% (at WITS 10) |
| Base Examination | 0% | N/A | 0% (never generates) |

### Optional Service Injection Pattern

The `InteractionService` uses optional injection for backward compatibility:

```csharp
private readonly IDataCaptureService? _captureService;

public InteractionService(
    // ... required parameters ...
    IDataCaptureService? captureService = null)  // Optional
{
    _captureService = captureService;
}
```

This allows existing tests and configurations to continue working without the capture service while enabling the feature when properly registered.

### Domain 4 Compliance

All template content follows Domain 4 constraints (no precision measurements):

```csharp
// Compliant
"Mycelial threads have woven through the mechanical joints, creating an unsettling fusion of rust and growth."

// Non-compliant (would be rejected)
"Mycelial threads measuring 0.5mm in diameter have infiltrated 78% of the servo-motors."
```

---

## Verification

```bash
# Build
dotnet build
# Build succeeded. 0 Error(s)

# Test new components
dotnet test --filter "FullyQualifiedName~DataCaptureService"
# Passed! - Failed: 0, Passed: 23, Skipped: 0

# Full test suite
dotnet test
# Passed! - Failed: 0, Passed: 1141, Skipped: 0
```

---

## Next Steps

**v0.1.3c: The Journal UI**
- Implement `journal` and `codex` terminal commands
- Create tabbed interface (Codex | Bestiary | Field Guide)
- Implement redaction renderer for incomplete entries
- Display completion percentages and unlocked thresholds
- Show unassigned captures awaiting matching entries
