# v0.3.15a: The Lexicon (String Extraction)

This milestone refactors the engine to support multiple languages and dynamic text injection. It moves the game from "Hardcoded Strings" to a "Resource-Driven" architecture, essential for future scalability and community translations.
To manage the complexity of extracting thousands of strings and implementing the loading logic, this version is split into three sub-versions:
	•	v0.3.15a: The Lexicon (String Extraction) – Defining the schema and extracting core UI strings.
	•	v0.3.15b: The Translator (Locale Service) – Implementing the loading logic and variable interpolation.
	•	v0.3.15c: The Polyglot (UI Integration) – Adding language selection to the Options menu and implementing "Pseudo-Localization" for testing.

Focus: Infrastructure definition and data extraction. We will establish the JSON schema for localization files and migrate the "Shell" strings (Menus, Headers, Common Prompts) to this format.
	1	Architecture & Data Flow
	◦	Resource Format: Use hierarchical JSON for readability (e.g., Strings.en-US.json).
	◦	Keys: Use dot-notation string keys (e.g., UI.MainMenu.StartGame).
	◦	Storage: Locate files in data/locales/.
	2	Deliverables
	◦	[ ] Define LocalizationKey static class (Constants to prevent magic strings).
	◦	[ ] Create data/locales/en-US.json.
	◦	[ ] Extract strings from TitleScreenService, MainMenuController, and OptionsScreenRenderer.
v0.3.15b: The Translator (Locale Service)
Focus: The engine logic that loads, parses, and serves the correct strings.
	1	Architecture & Data Flow
	◦	Service: LocalizationService loads the active JSON file into a Dictionary<string, string> cache at startup.
	◦	Interpolation: The service handles C#-style arguments (e.g., "Hit for {0} damage" -> string.Format).
	◦	Fallback: If a key is missing in the target language, fall back to the Default Language (en-US).
	2	Deliverables
	◦	[ ] Implement ILocalizationService interface.
	◦	[ ] Implement LocalizationService with LoadAsync(culture) and Get(key, args) methods.
	◦	[ ] Update Program.cs to load the service before UI initialization.
	◦	[ ] Unit Test: Get_Returns_Formatted_String.
v0.3.15c: The Polyglot (UI Integration & Validation)
Focus: User-facing controls and developer tooling to verify the system works.
	1	Architecture & Data Flow
	◦	Settings Integration: Update GameSettings to include a Language property.
	◦	Options UI: Add a "Language" Enum picker to the "Display" tab.
	◦	Pseudo-Localization: Implement a "Test Language" that wraps strings in brackets (e.g., [---Start Game---]) to test for UI overflow and hardcoded string spotting.
	2	Deliverables
	◦	[ ] Update OptionsViewModel to support Language selection.
	◦	[ ] Implement PseudoLocalizationService (or mode) for QA.
	◦	[ ] Audit: Verify ExplorationScreenRenderer and CombatScreenRenderer use localized strings.

Overview Logic: The Localization Pipeline
A. Startup Flow
	1	Boot: Application starts.
	2	Settings: Load GameSettings.Language (Default: "en-US").
	3	Service: LocalizationService looks for data/locales/{Language}.json.
	◦	Found: Deserialize to Memory Cache.
	◦	Missing: Fallback to en-US.json.
	4	Ready: Game Loop begins.
B. Runtime Lookup Flow Input: Renderer needs "Health" label.
	1	Call: _loc.Get(LocKeys.HUD.Health).
	2	Lookup: Check Memory Cache.
	◦	Exists: Return value (e.g., "Health" or "Salud").
	◦	Missing: Return Key Name ("HUD.Health") and Log Warning.

Master Deliverable Checklist
	•	Core:
	◦	[ ] ILocalizationService interface.
	◦	[ ] LocKeys constant definitions.
	•	Engine:
	◦	[ ] LocalizationService implementation.
	◦	[ ] JSON parsing logic (System.Text.Json).
	•	Data:
	◦	[ ] data/locales/en-US.json (The master file).
	◦	[ ] data/locales/qps-ploc.json (Pseudo-locale for testing).
	•	Terminal:
	◦	[ ] Update OptionsController to handle language switching.
	◦	[ ] Refactor ExplorationScreenRenderer, CombatScreenRenderer, InventoryScreenRenderer.

> **Archived** - This plan has been consolidated. See the complete version at [v0.3.15](../v0.3.x/v0.3.15.md).

# v0.3.15a: The Lexicon (String Extraction)

This version establishes the data structures and standards for the localization system. It focuses on removing hardcoded strings from the Terminal layer, defining the JSON resource schema, and creating the key constants that ensure type safety when requesting text.

Goal: Establish the data/locales/ directory structure, define the en-US.json schema, and refactor the Main Menu and Options screens to use LocalizationKey constants instead of string literals.
1. Architecture & Data Flow
The Key-Value Pipeline
  1 Source: Strings are moved from C# files to data/locales/en-US.json.
  2 Definition: Keys are defined as constants in RuneAndRust.Core.Constants.LocKeys to prevent "magic string" errors.
  3 Reference: The UI code references LocKeys.UI_MainMenu_NewGame instead of "New Game".
  4 Interface: We define ILocalizationService (to be implemented in v0.3.15b) so we can inject it into controllers now.
2. Logic Decision Trees
A. Key Naming Logic Input: Hardcoded string found in code (e.g., "Press any key to continue...")
  1 Determine Context:
  ◦ Is it a specific Menu? -> UI.{MenuName}.{Action}
  ◦ Is it a Message Log? -> Log.{Category}.{Event}
  ◦ Is it an Entity Name? -> Entity.{Type}.{Name}
  ◦ Is it shared (e.g., "Cancel")? -> Common.{Action}
  2 Determine Parameterization:
  ◦ Does it use variables? (e.g., "Damage: 50") -> Ensure the value in JSON uses indexed placeholders: "Damage: {0}".
  3 Create Key: UI.Common.PressAnyKey.
B. Extraction Workflow Input: Console.WriteLine("Welcome!");
  1 Add to JSON: Insert "UI.Title.Welcome": "Welcome!" into en-US.json.
  2 Add to Constants: Add public const string UI_Title_Welcome = "UI.Title.Welcome"; to LocKeys.cs.
  3 Refactor Code: Change to _loc.Get(LocKeys.UI_Title_Welcome);.
3. Deliverable Checklist
  • Core:
  ◦ [ ] Create Constants/LocKeys.cs static class.
  ◦ [ ] Define Interfaces/ILocalizationService.cs (Contract).
  • Data:
  ◦ [ ] Create directory data/locales/.
  ◦ [ ] Create data/locales/en-US.json (The Master Locale).
  • Terminal (Refactoring):
  ◦ [ ] Refactor TitleScreenService.cs.
  ◦ [ ] Refactor MainMenuController.cs.
  ◦ [ ] Refactor OptionsScreenRenderer.cs.
  ◦ [ ] Refactor CreationWizard.cs (Step prompts only).
  • Tests:
  ◦ [ ] LocalizationKeyTests.cs: Ensure no duplicate keys in constants.
4. Code Implementation
A. The Schema (data/locales/en-US.json) We use a flat JSON structure for easier parsing, or nested for organization. Decision: Hierarchical (Nested) JSON is preferred for readability, flattened by the loader.
{
  "UI": {
    "Common": {
      "Back": "[ESC] Back",
      "Confirm": "[ENTER] Confirm",
      "PressAnyKey": "Press any key to continue..."
    },
    "MainMenu": {
      "Title": "Rune & Rust",
      "NewGame": "New Game",
      "LoadGame": "Load Game",
      "Options": "Options",
      "Quit": "Quit"
    },
    "Options": {
      "Header": "SETTINGS",
      "Saved": "Settings saved successfully."
    }
  },
  "Log": {
    "Combat": {
      "Hit": "{0} hits {1} for {2} damage!",
      "Miss": "{0} attacks {1} but misses."
    }
  }
}
B. The Constants (RuneAndRust.Core/Constants/LocKeys.cs) This prevents typos in string keys.
namespace RuneAndRust.Core.Constants;

public static class LocKeys
{
    // UI - Common
    public const string UI_Common_Back = "UI.Common.Back";
    public const string UI_Common_Confirm = "UI.Common.Confirm";
    public const string UI_Common_PressAnyKey = "UI.Common.PressAnyKey";

    // UI - Main Menu
    public const string UI_MainMenu_NewGame = "UI.MainMenu.NewGame";
    public const string UI_MainMenu_LoadGame = "UI.MainMenu.LoadGame";
    public const string UI_MainMenu_Quit = "UI.MainMenu.Quit";

    // Log - Combat
    public const string Log_Combat_Hit = "Log.Combat.Hit"; // Expects {0}=Attacker, {1}=Target, {2}=Dmg
}
C. The Contract (RuneAndRust.Core/Interfaces/ILocalizationService.cs)
public interface ILocalizationService
{
    // Get simple string
    string Get(string key);

    // Get formatted string (e.g., string.Format)
    string Get(string key, params object[] args);

    // Switch language at runtime
    Task LoadLocaleAsync(string cultureCode);
}
5. Logging Requirements
Since this version is primarily data setup, logging focuses on the absence of keys during the refactor testing (simulated by a Mock service until v0.3.15b).
System
Event
Level
Message Template
Properties
Loc
Key Missing
Warning
"[Loc] Key not found in dictionary: {Key}"
Key
Loc
Init
Info
"[Loc] Data structure initialized for extraction."
-
6. Testing Strategy
Unit Tests (LocalizationArchitectureTests.cs)
  • Key_Format_Validation:
  ◦ Use Reflection to iterate all string constants in LocKeys.
  ◦ Assert that every value matches the pattern Category.SubCategory.Key.
  • JSON_Integrity:
  ◦ Load en-US.json.
  ◦ Flatten the JSON keys.
  ◦ Assert that every constant in LocKeys exists as a key in the JSON file. (This ensures we don't define a constant in C# that is missing from the data).
Example Test:
[Fact]
public void All_Constants_Have_Entries_In_JSON()
{
    var json = File.ReadAllText("data/locales/en-US.json");
    var data = JsonSerializer.Deserialize<Dictionary<string, object>>(json);
    var flatKeys = FlattenKeys(data); // Helper to flatten hierarchy

    var constantKeys = typeof(LocKeys)
        .GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy)
        .Select(f => f.GetRawConstantValue().ToString());

    foreach (var key in constantKeys)
    {
        flatKeys.Should().Contain(key, $"LocKeys.{key} is missing from en-US.json");
    }
}
7. Draft Changelog (v0.3.15a)
# v0.3.15a Changelog: The Lexicon
**Release Date:** 2026-02-25

## Summary
This release lays the foundation for the Localization System. We have extracted hardcoded strings from the Main Menu and Options screens into a structured JSON resource file (`en-US.json`) and established the `LocKeys` constant system to ensure type-safe text retrieval.

## New Features
*   **Locale Data Structure:** Implemented hierarchical JSON format for game strings.
*   **Localization Keys:** Added `LocKeys` static class to map code constants to JSON keys.

## Technical Changes
*   Created `data/locales/en-US.json` containing initial UI strings.
*   Refactored `TitleScreenService` and `MainMenuController` to prepare for `ILocalizationService` injection.
*   Added `ILocalizationService` interface definition.

> **Archived** - This plan has been consolidated. See the complete version at [v0.3.15](../v0.3.x/v0.3.15.md).

# v0.3.15b: The Translator (Locale Service)

This version implements the engine logic required to load, parse, and serve localized text. It transforms the static JSON files created in v0.3.15a into a high-performance, in-memory dictionary that supports variable interpolation (e.g., "Hit for {0} damage").

Goal: Implement LocalizationService to deserialize hierarchical JSON files into a flat key-value cache, handle string formatting, and manage fallback logic for missing keys.

1. Architecture & Data Flow
The Loading Pipeline
    1   Trigger: Application startup (or Language change event).
    2   File Access: Service reads data/locales/{CurrentCulture}.json.
    3   Deserialization: Parse JSON into a JsonElement (System.Text.Json).
    4   Flattening: Recursively walk the JSON tree to build dot-notation keys.
    ◦   Input: {"UI": {"Title": "Hello"}}
    ◦   Output: Key: "UI.Title", Value: "Hello"
    5   Cache: Store in Dictionary<string, string> _translations.
    6   Fallback Load: (Optional) If current culture $\neq$ Default, also load en-US.json into a separate _fallbackTranslationsdictionary.
The Retrieval Pipeline
    1   Call: _loc.Get("Log.Combat.Hit", "Draugr", "5").
    2   Lookup:
    ◦   Check _translations. Found? Use it.
    ◦   Check _fallbackTranslations. Found? Use it.
    ◦   Missing? Return "[Log.Combat.Hit]".
    3   Format: Apply string.Format(template, args).
    4   Return: "Draugr takes 5 damage."

2. Logic Decision Trees
A. Flattening Logic (Recursive) Input: Current JSON Element, Parent Key Prefix
    1   Is Object?
    ◦   Loop through properties.
    ◦   New Prefix = ParentKey + . + PropertyName.
    ◦   Recurse.
    2   Is String?
    ◦   Add to Dictionary: Key = ParentKey, Value = StringContent.
    3   Is Array?
    ◦   (Decision: Arrays usually map to indexed keys or joined strings. For now, treat as unsupported or join with newline).
B. Get String Logic Input: Key, Args
    1   Dictionary Lookup: Does Key exist?
    ◦   Yes: template = value.
    ◦   No: Log Warning -> Return Key (fail loudly in Dev, softly in Prod).
    2   Formatting Check: Are there Args?
    ◦   No: Return template.
    ◦   Yes: Wrap string.Format in Try/Catch (to catch malformed templates like "Hello {1}").
    ▪   Success: Return formatted string.
    ▪   Fail: Log Error -> Return template (unformatted).

3. Deliverable Checklist
    •   Core:
    ◦   [ ] Update GameSettings to include string Language { get; set; } = "en-US";.
    •   Engine:
    ◦   [ ] Implement LocalizationService class.
    ◦   [ ] Implement JsonFlattener helper (private method or static utility).
    ◦   [ ] Implement LoadLocaleAsync(string culture) method.
    ◦   [ ] Implement Get(string key, params object[] args) method.
    •   Terminal:
    ◦   [ ] Update Program.cs to register ILocalizationService as Singleton.
    ◦   [ ] Call LoadLocaleAsync during startup sequence.

4. Code Implementation
A. Service Implementation (RuneAndRust.Engine/Services/LocalizationService.cs)
using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Interfaces;

public class LocalizationService : ILocalizationService
{
    private readonly ILogger<LocalizationService> _logger;
    private Dictionary<string, string> _translations = new();
    private Dictionary<string, string> _fallbackTranslations = new();
    private const string DefaultCulture = "en-US";

    public LocalizationService(ILogger<LocalizationService> logger)
    {
        _logger = logger;
    }

    public async Task LoadLocaleAsync(string cultureCode)
    {
        _logger.LogInformation("Loading locale: {Culture}", cultureCode);

        // 1. Load active language
        _translations = await LoadFileAsync(cultureCode);

        // 2. Load fallback if different
        if (!cultureCode.Equals(DefaultCulture, StringComparison.OrdinalIgnoreCase))
        {
            _fallbackTranslations = await LoadFileAsync(DefaultCulture);
        }
    }

    private async Task<Dictionary<string, string>> LoadFileAsync(string culture)
    {
        var path = Path.Combine("data", "locales", $"{culture}.json");
        if (!File.Exists(path))
        {
            _logger.LogError("Locale file not found: {Path}", path);
            return new Dictionary<string, string>();
        }

        try
        {
            var jsonString = await File.ReadAllTextAsync(path);
            var doc = JsonDocument.Parse(jsonString);
            return FlattenJson(doc.RootElement);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to parse locale: {Path}", path);
            return new Dictionary<string, string>();
        }
    }

    public string Get(string key, params object[] args)
    {
        if (!_translations.TryGetValue(key, out var template))
        {
            if (!_fallbackTranslations.TryGetValue(key, out template))
            {
                _logger.LogWarning("Missing translation key: {Key}", key);
                return $"[{key}]";
            }
        }

        if (args.Length == 0) return template;

        try
        {
            return string.Format(template, args);
        }
        catch (FormatException)
        {
            _logger.LogError("Format error for key: {Key} with args: {Args}", key, string.Join(",", args));
            return template;
        }
    }

    private Dictionary<string, string> FlattenJson(JsonElement element, string prefix = "")
    {
        var dict = new Dictionary<string, string>();

        foreach (var prop in element.EnumerateObject())
        {
            string key = string.IsNullOrEmpty(prefix) ? prop.Name : $"{prefix}.{prop.Name}";

            if (prop.Value.ValueKind == JsonValueKind.Object)
            {
                var nested = FlattenJson(prop.Value, key);
                foreach (var kvp in nested) dict.Add(kvp.Key, kvp.Value);
            }
            else if (prop.Value.ValueKind == JsonValueKind.String)
            {
                dict.Add(key, prop.Value.GetString() ?? "");
            }
        }
        return dict;
    }
}

5. Logging Requirements
System
Event
Level
Message Template
Properties
Loc
Load Start
Info
"Loading locale: {Culture}"
Culture
Loc
File Missing
Error
"Locale file not found: {Path}. Fallback may fail."
Path
Loc
Key Missing
Warn
"Missing translation key: {Key}"
Key
Loc
Format Error
Error
"Format error for key: {Key} with args: {Args}"
Key, Args

6. Testing Strategy
Unit Tests (LocalizationServiceTests.cs)
    •   Load_FlattensJsonCorrectly:
    ◦   Arrange: Create temporary JSON {"Parent": {"Child": "Value"}}.
    ◦   Act: Load file.
    ◦   Assert: Get("Parent.Child") returns "Value".
    •   Get_ReturnsFormattedString:
    ◦   Arrange: JSON has "Key": "Hello {0}".
    ◦   Act: Get("Key", "World").
    ◦   Assert: Returns "Hello World".
    •   Get_FallsBackToDefault:
    ◦   Arrange: Load "fr-FR" (empty) and "en-US" (has key).
    ◦   Act: Get("Key").
    ◦   Assert: Returns value from en-US.
    •   Get_MissingReturnsKey:
    ◦   Act: Get("NonExistent").
    ◦   Assert: Returns "[NonExistent]".

7. Draft Changelog (v0.3.15b)
# v0.3.15b Changelog: The Translator
**Release Date:** 2026-02-25

## Summary
This release implements the engine logic for the Localization System. The `LocalizationService` now dynamically loads JSON resource files, flattens them into an efficient lookup cache, and handles string interpolation. This enables the game to support multiple languages and separates text content from code logic.

## New Features
*   **JSON Locale Loading:** Support for hierarchical JSON string tables.
*   **Key Flattening:** Automatic conversion of nested JSON (e.g., `UI -> Menu -> Title`) into dot-notation keys (`UI.Menu.Title`).
*   **Graceful Fallback:** Missing keys in a target language automatically fall back to English (en-US).

## Technical Changes
*   Implemented `LocalizationService`.
*   Added `System.Text.Json` logic for recursive object flattening.
*   Integrated logging for missing keys and malformed string templates.

> **Archived** - This plan has been consolidated. See the complete version at [v0.3.15](../v0.3.x/v0.3.15.md).

# v0.3.15c: The Polyglot (UI Integration)

Goal: Integrate language selection into the OptionsController, persist the choice in GameSettings, and implement a "Pseudo-Locale" (qps-ploc) to stress-test the UI layout.

This version connects the backend localization infrastructure (built in v0.3.15b) to the user interface. It introduces the Language selector in the Options menu and implements Pseudo-Localization—a critical QA tool that programmatically garbles text to test for UI overflow and identify hardcoded strings that were missed during extraction.

1. Architecture & Data Flow
The Language Switch Pipeline
    1   Input: User changes "Language" in the Options Menu.
    2   Validation: OptionsController validates the locale code (e.g., "en-US", "qps-ploc").
    3   Loading: Calls LocalizationService.LoadLocaleAsync(newCode).
    ◦   If Pseudo-Loc: The service enters generation mode (no file needed).
    ◦   If Standard: The service loads JSON from disk.
    4   Persistence: Updates GameSettings.Language.
    5   Refresh: Triggers a re-render of the Options UI immediately to show the new language in effect.

2. Logic Decision Trees
A. Pseudo-Localization Logic (Runtime Generation) Input: Original String ("Start Game")
    1   Wrapper: Enclose in brackets to detect clipping. [ ... ]
    2   Expansion: Pad string length by 30-50% to test UI overflow.
    ◦   Method: Repeat vowels or append exclamation marks.
    3   Diacritics: Replace standard ASCII chars with extended characters to test font rendering.
    ◦   a -> à, e -> é, o -> ô.
    4   Output: [!!! Stàrt Gámé !!!]
B. Options Menu Update Logic Input: Setting Change Event
    1   Is setting Language?
    ◦   Yes:
    1   Await _localization.LoadLocaleAsync(newValue).
    2   Re-build OptionsViewModel (Labels must update to new language).
    3   Call _renderer.Render(newViewModel).
    ◦   No: Proceed with standard update.

3. Deliverable Checklist
    •   Core:
    ◦   [ ] Add Language property to GameSettings (default "en-US").
    ◦   [ ] Add Language to SettingsDto for persistence.
    ◦   [ ] Add PseudoLocalization helper class.
    •   Engine:
    ◦   [ ] Update LocalizationService.Get() to intercept "qps-ploc" and apply pseudo-logic.
    ◦   [ ] Add GetAvailableLocales() method to LocalizationService.
    •   Terminal:
    ◦   [ ] Update OptionsViewModel to include Language dropdown.
    ◦   [ ] Update OptionsController to handle language switching triggers.
    •   Tests:
    ◦   [ ] PseudoLocalization_ExpandsLength: Verify string is longer than input.
    ◦   [ ] Options_LanguageSwitch_Persists: Verify settings save correctly.

4. Code Implementation
A. Pseudo-Localizer Helper (RuneAndRust.Engine/Services/PseudoLocalizer.cs)
public static class PseudoLocalizer
{
    private static readonly Dictionary<char, char> _replacements = new()
    {
        {'a', 'à'}, {'e', 'é'}, {'i', 'î'}, {'o', 'ô'}, {'u', 'ü'},
        {'A', 'À'}, {'E', 'É'}, {'I', 'Î'}, {'O', 'Ô'}, {'U', 'Ü'}
    };

    public static string Localize(string input)
    {
        var sb = new StringBuilder();
        sb.Append("[!!"); // Start wrapper

        foreach (var c in input)
        {
            sb.Append(_replacements.TryGetValue(c, out var r) ? r : c);
        }

        // 30% expansion padding
        int pad = (int)(input.Length * 0.3);
        sb.Append(new string('!', pad));

        sb.Append("!!]"); // End wrapper
        return sb.ToString();
    }
}
B. Service Update (LocalizationService.cs)
public string Get(string key, params object[] args)
{
    // 1. Handle Pseudo-Localization Mode
    if (_currentCulture == "qps-ploc")
    {
        // Get English base, then mangle it
        var baseStr = _fallbackTranslations.GetValueOrDefault(key, key);
        var formatted = string.Format(baseStr, args);
        return PseudoLocalizer.Localize(formatted);
    }

    // 2. Standard Lookup (Existing Logic)
    // ...
}
C. Options Integration (OptionsController.cs)
private void BuildLanguageOption(OptionsViewModel vm)
{
    var languages = new List<string> { "en-US", "es-ES", "qps-ploc" }; // Discovery logic later

    vm.CurrentItems.Add(new SettingItemView(
        Name: _loc.Get(LocKeys.UI_Options_Language), // Localized Label!
        ValueDisplay: _currentLanguage,
        Type: SettingType.Enum,
        IsSelected: index == vm.SelectedIndex,
        PropertyName: "Language",
        EnumValues: languages
    ));
}

5. Logging Requirements
System
Event
Level
Message Template
Properties
Loc
Switch
Info
"Language switched to {Culture}"
Culture
Loc
Pseudo
Debug
"Pseudo-loc generated: {Input} -> {Output}"
Input, Output
Options
Refresh
Info
"UI Refreshed due to locale change."
-

6. Testing Strategy
Unit Tests (LocalizationServiceTests.cs):
    •   Pseudo_TransformsText:
    ◦   Arr: Set locale to "qps-ploc".
    ◦   Act: Get("Test").
    ◦   Assert: Returns "[!!Tést!!]" (approx).
    •   Pseudo_ExpandsLength:
    ◦   Act: Get("Short").
    ◦   Assert: Length > Original Length (checks for overflow simulation).
Integration Tests:
    •   Switch_Updates_UI:
    ◦   Arr: Open Options. Select "qps-ploc".
    ◦   Act: Confirm selection.
    ◦   Assert: OptionsViewModel.Name is now garbled (e.g., [!!Óptîôns!!]). This confirms the UI re-rendered using the new service state.

7. Draft Changelog (v0.3.15)
# v0.3.15 Changelog: The Scribe
**Release Date:** 2026-02-28

## Summary
This release implements the complete localization infrastructure ("The Scribe"). The game engine is no longer hardcoded to English; all UI text is now loaded dynamically from resource files. We have also added a "Pseudo-Localization" mode to help developers identify UI layout issues and untranslated strings.

## New Features
*   **Localization Support:** The game can now load language packs from `data/locales/`.
*   **Language Selector:** Added a Language option to the Settings menu.
*   **Pseudo-Localization:** A "Test Language" (qps-ploc) that garbles text (e.g., `[!!Sêttîngs!!]`) to test font rendering and UI expansion.

## Technical Changes
*   **LocalizationService:** Implemented JSON-based string loading and caching.
*   **String Extraction:** Migrated over 200 hardcoded UI strings to `en-US.json`.
*   **Settings Persistence:** Added `Language` key to `options.json`.