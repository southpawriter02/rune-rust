# v0.4.4c: The Mastery (School Progression)

> **Status:** Planned
> **Parent:** v0.4.4 - The Mystic (Archetype Specialization)
> **Theme:** Long-term magical progression through spell school expertise—practice breeds mastery, and mastery breeds power.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Deliverables Checklist](#deliverables-checklist)
5. [Implementation Workflow](#implementation-workflow)
6. [Code Examples](#code-examples)
7. [Logging Specification](#logging-specification)
8. [Unit Testing](#unit-testing)
9. [Integration Points](#integration-points)
10. [Domain 4 Compliance](#domain-4-compliance)
11. [Changelog Template](#changelog-template)

---

## Overview

v0.4.4c introduces **School Mastery**—the permanent progression system for Mystics that rewards dedication to specific magical disciplines. Unlike Saga-based leveling (which provides general character growth), School Mastery tracks experience gained within each of the four spell schools, unlocking cost reductions, passive abilities, and advanced spells.

### Core Concept

> *"The Weave does not yield its secrets to the impatient. Those who cast a thousand flames learn not merely to summon fire—they become flame themselves. The Archons of old did not study magic; they became it."*
> — Jötun-Reader Field Notes, Codex Entry #623

### Mastery vs Saga Progression

| Aspect | Saga Progression (v0.4.0) | School Mastery (v0.4.4c) |
|--------|---------------------------|--------------------------|
| **Scope** | Character-wide | Per spell school |
| **Currency** | Legend (XP) → Progression Points | Mastery XP (per school) |
| **Unlocks** | Attributes, Skill ranks | Cost reductions, spells, passives |
| **Spending** | Player chooses allocation | Automatic tier progression |
| **Cap** | No level cap | Archon tier (1000 XP per school) |
| **Reset** | Never | Never (permanent growth) |

### Mastery Tier System

| Tier | XP Required | AP Cost Mod | Flux Cost Mod | Special Unlock |
|------|-------------|-------------|---------------|----------------|
| **Novice** | 0 | +0% | +0% | Basic spells only |
| **Apprentice** | 100 | -5% | -5% | Tier 2 spells unlock |
| **Adept** | 300 | -10% | -10% | School passive unlocks |
| **Master** | 600 | -15% | -15% | Tier 3 spells unlock |
| **Archon** | 1000 | -20% | -20% | Ultimate ability unlocks |

### XP Gain Sources

| Source | Base XP | Notes |
|--------|---------|-------|
| **Casting a spell** | +10 | Applies to spell's school |
| **Killing with spell** | +25 (bonus) | Stacks with casting XP |
| **Completing Galdr** | +15 (bonus) | Rewards sustained casting |
| **Learning new spell** | +50 | One-time per spell |
| **School research** | +20 | From deciphering scrolls |
| **Master training** | +100 | Quest reward milestone |

### Spell Tier Requirements

| Spell Tier | Minimum Mastery | Examples |
|------------|-----------------|----------|
| **Tier 1** | Novice (0 XP) | Flame Bolt, Minor Ward, Detect Magic |
| **Tier 2** | Apprentice (100 XP) | Fireball, Shield of Faith, Reveal Weakness |
| **Tier 3** | Master (600 XP) | Inferno, Resurrection, Reality Warp |
| **Ultimate** | Archon (1000 XP) | School capstone abilities |

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        MagicService                              │
│   (Orchestrates spell casting, calls MasteryService for XP)     │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      IMasteryService                             │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ + AddMasteryXP(character, school, amount, source): XPResult ││
│  │ + GetSchoolMastery(character, school): SchoolMastery        ││
│  │ + GetMasteryTier(character, school): MasteryTier            ││
│  │ + GetCostModifier(character, school): CostModifiers         ││
│  │ + GetSchoolPassive(character, school): SchoolPassive?       ││
│  │ + IsSpellUnlocked(character, spell): bool                   ││
│  │ + GetAllMasteries(character): IReadOnlyDictionary           ││
│  │ + ApplyPassiveEffect(character, school, context): void      ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      MasteryService                              │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ - _logger: ILogger<MasteryService>                          ││
│  │ - _eventBus: IEventBus                                      ││
│  │ - _passiveRegistry: ISchoolPassiveRegistry                  ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────┬───────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  SchoolMastery  │ │   MasteryTier   │ │  SchoolPassive  │
│  ┌───────────┐  │ │  ┌───────────┐  │ │  ┌───────────┐  │
│  │ School    │  │ │  │ Novice    │  │ │  │ Name      │  │
│  │ CurrentXP │  │ │  │ Apprentice│  │ │  │ School    │  │
│  │ Tier      │  │ │  │ Adept     │  │ │  │ Effect    │  │
│  │ TierUpAt  │  │ │  │ Master    │  │ │  │ Trigger   │  │
│  └───────────┘  │ │  │ Archon    │  │ │  └───────────┘  │
└─────────────────┘ │  └───────────┘  │ └─────────────────┘
                    └─────────────────┘
```

### Data Flow

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           MagicService.CastSpell()                        │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 1. Get spell school from Spell entity                                     │
│ 2. Check IsSpellUnlocked(character, spell)                               │
│    ├─ FALSE → Return SpellLockedResult                                   │
│    └─ TRUE  → Continue                                                   │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 3. Get cost modifiers: GetCostModifier(character, school)                │
│    └─ Returns: { APModifier: 0.90m, FluxModifier: 0.90m }               │
│ 4. Apply modifiers to spell costs                                         │
│    └─ ModifiedAPCost = BaseCost * APModifier (rounded up)               │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 5. Execute spell effect                                                   │
│ 6. Apply school passive if active: ApplyPassiveEffect()                  │
│    └─ Destruction Adept: +1 damage die on crit                          │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 7. Calculate XP gain:                                                     │
│    ├─ Base: +10 XP                                                       │
│    ├─ Kill bonus: +25 XP (if target died)                               │
│    └─ Galdr bonus: +15 XP (if was Galdr completion)                     │
│ 8. Call AddMasteryXP(character, school, totalXP, source)                 │
│    └─ If tier up: Publish MasteryTierReachedEvent                       │
└──────────────────────────────────────────────────────────────────────────┘
```

### Character State Extension

```
Character
  └─ MasteryStates: Dictionary<SpellSchool, SchoolMastery>
       ├─ [Destruction]: { CurrentXP: 245, Tier: Apprentice, TierUpAt: 300 }
       ├─ [Restoration]: { CurrentXP: 50, Tier: Novice, TierUpAt: 100 }
       ├─ [Alteration]: { CurrentXP: 310, Tier: Adept, TierUpAt: 600 }
       └─ [Divination]: { CurrentXP: 0, Tier: Novice, TierUpAt: 100 }
```

---

## Decision Trees

### 1. AddMasteryXP Decision Tree

```
AddMasteryXP(character, school, amount, source)
│
├─ Validate inputs
│   ├─ character is null? → throw ArgumentNullException
│   ├─ school is invalid? → throw ArgumentException
│   └─ amount <= 0? → return XPResult.NoChange (log warning)
│
├─ Get or create SchoolMastery for school
│   ├─ Exists? → Use existing
│   └─ Not exists? → Create new with Tier = Novice, XP = 0
│
├─ Calculate new XP
│   └─ newXP = current.CurrentXP + amount
│
├─ Check tier progression
│   ├─ newXP >= TierThreshold(current.Tier + 1)?
│   │   ├─ YES → Tier up!
│   │   │   ├─ Update tier
│   │   │   ├─ Set next threshold
│   │   │   ├─ Publish MasteryTierReachedEvent
│   │   │   └─ Log tier advancement
│   │   └─ NO → No tier change
│   └─ Tier == Archon? → XP capped at 1000 (no further gains logged)
│
└─ Return XPResult
    ├─ PreviousXP
    ├─ NewXP
    ├─ XPGained
    ├─ TierChanged (bool)
    ├─ NewTier (if changed)
    └─ Source
```

### 2. GetCostModifier Decision Tree

```
GetCostModifier(character, school)
│
├─ Get mastery tier for school
│   └─ tier = GetMasteryTier(character, school)
│
├─ Calculate modifiers based on tier
│   ├─ Novice     → { APMod: 1.00m, FluxMod: 1.00m }
│   ├─ Apprentice → { APMod: 0.95m, FluxMod: 0.95m }
│   ├─ Adept      → { APMod: 0.90m, FluxMod: 0.90m }
│   ├─ Master     → { APMod: 0.85m, FluxMod: 0.85m }
│   └─ Archon    → { APMod: 0.80m, FluxMod: 0.80m }
│
└─ Return CostModifiers
    ├─ APModifier (decimal)
    ├─ FluxModifier (decimal)
    └─ Tier (for logging/display)
```

### 3. IsSpellUnlocked Decision Tree

```
IsSpellUnlocked(character, spell)
│
├─ Get spell's school and tier requirement
│   └─ spellTier = spell.TierRequirement (1-4)
│
├─ Get character's mastery tier for school
│   └─ masteryTier = GetMasteryTier(character, spell.School)
│
├─ Map tier requirement to minimum mastery
│   ├─ Tier 1 → Novice (always unlocked)
│   ├─ Tier 2 → Apprentice (100 XP)
│   ├─ Tier 3 → Master (600 XP)
│   └─ Tier 4 (Ultimate) → Archon (1000 XP)
│
├─ Compare tiers
│   ├─ masteryTier >= requiredTier? → return TRUE
│   └─ masteryTier < requiredTier? → return FALSE
│
└─ Log result for debugging
```

### 4. ApplyPassiveEffect Decision Tree

```
ApplyPassiveEffect(character, school, context)
│
├─ Check tier qualifies for passive
│   ├─ tier < Adept? → return (no passive yet)
│   └─ tier >= Adept? → continue
│
├─ Get passive for school
│   └─ passive = _passiveRegistry.GetPassive(school)
│
├─ Check trigger condition
│   ├─ passive.Trigger == OnCritical && context.IsCritical?
│   │   └─ Apply Destruction passive: +1 damage die
│   ├─ passive.Trigger == OnHeal && context.IsHealing?
│   │   └─ Apply Restoration passive: +10% healing
│   ├─ passive.Trigger == OnBuff && context.IsBuff?
│   │   └─ Apply Alteration passive: +1 turn duration
│   └─ passive.Trigger == OnAnalyze && context.IsAnalyze?
│       └─ Apply Divination passive: reveal intent
│
└─ Log passive application
```

### 5. GetTierThreshold Decision Tree

```
GetTierThreshold(tier)
│
├─ Novice     → 0
├─ Apprentice → 100
├─ Adept      → 300
├─ Master     → 600
└─ Archon    → 1000
```

### 6. GetNextTier Decision Tree

```
GetNextTier(currentTier)
│
├─ Novice     → Apprentice
├─ Apprentice → Adept
├─ Adept      → Master
├─ Master     → Archon
└─ Archon    → null (max tier)
```

---

## Deliverables Checklist

### Core Models (RuneAndRust.Core)

- [ ] **`MasteryTier.cs`** (Enums)
  - Enum: `Novice`, `Apprentice`, `Adept`, `Master`, `Archon`
  - Extension method: `GetThreshold()` returning XP requirement
  - Extension method: `GetCostModifier()` returning decimal

- [ ] **`SchoolMastery.cs`** (Models/Magic)
  - Properties: `School`, `CurrentXP`, `Tier`, `TierUpAt`
  - Computed: `ProgressToNextTier` (percentage)
  - Method: `Clone()` for state snapshots

- [ ] **`CostModifiers.cs`** (Models/Magic)
  - Properties: `APModifier`, `FluxModifier`, `Tier`
  - Factory: `FromTier(MasteryTier)` static constructor

- [ ] **`SchoolPassive.cs`** (Models/Magic)
  - Properties: `Name`, `Description`, `School`, `Trigger`, `Effect`
  - Enum reference: `PassiveTrigger` (OnCritical, OnHeal, OnBuff, OnAnalyze)

- [ ] **`MasteryXPResult.cs`** (Models/Magic)
  - Properties: `PreviousXP`, `NewXP`, `XPGained`, `TierChanged`, `NewTier`, `Source`

- [ ] **`MasteryTierReachedEvent.cs`** (Events)
  - Properties: `CharacterId`, `School`, `NewTier`, `UnlockedPassive`, `UnlockedSpells`

### Service Layer (RuneAndRust.Engine)

- [ ] **`IMasteryService.cs`** (Interfaces)
  - Full interface contract (8 methods)

- [ ] **`MasteryService.cs`** (Services)
  - Full implementation with logging
  - Dependency: `ILogger`, `IEventBus`, `ISchoolPassiveRegistry`

- [ ] **`ISchoolPassiveRegistry.cs`** (Interfaces)
  - Method: `GetPassive(SpellSchool)` → `SchoolPassive?`
  - Method: `GetAllPassives()` → `IReadOnlyList<SchoolPassive>`

- [ ] **`SchoolPassiveRegistry.cs`** (Services)
  - Static initialization of 4 school passives
  - Thread-safe singleton pattern

### Integration (RuneAndRust.Engine)

- [ ] **MagicService extension**
  - Call `AddMasteryXP` after spell cast
  - Apply cost modifiers before AP deduction
  - Apply passive effects on appropriate triggers

- [ ] **CombatService extension**
  - Track kill attribution for XP bonus
  - Forward kill event to MagicService for mastery XP

### Terminal UI (RuneAndRust.Terminal)

- [ ] **`SchoolMasteryDisplay.cs`** (Rendering)
  - Progress bar per school
  - Tier indicator with color coding
  - Passive status display

- [ ] **`MasteryCommand.cs`** (Commands)
  - `mastery` command to view all schools
  - `mastery [school]` for detailed view

- [ ] **CommandParser extension**
  - Register `mastery` command

### Tests (RuneAndRust.Tests)

- [ ] **`MasteryServiceTests.cs`**
  - 35 unit tests across 6 categories
  - 80%+ code coverage

- [ ] **`SchoolPassiveRegistryTests.cs`**
  - 4 tests for passive lookup

---

## Implementation Workflow

### Phase 1: Core Models (Day 1)

```
1. Create MasteryTier enum with extension methods
   ├─ Define 5 tier values
   ├─ Add GetThreshold() extension
   └─ Add GetCostModifier() extension

2. Create SchoolMastery model
   ├─ Define properties
   ├─ Add computed ProgressToNextTier
   └─ Implement Clone()

3. Create CostModifiers record
   ├─ Define properties
   └─ Add FromTier() factory

4. Create SchoolPassive model
   ├─ Define properties
   └─ Add PassiveTrigger enum

5. Create MasteryXPResult record
   └─ Define all result properties

6. Create MasteryTierReachedEvent
   └─ Define event properties
```

### Phase 2: Service Interface (Day 1)

```
1. Create IMasteryService interface
   ├─ AddMasteryXP method signature
   ├─ GetSchoolMastery method signature
   ├─ GetMasteryTier method signature
   ├─ GetCostModifier method signature
   ├─ GetSchoolPassive method signature
   ├─ IsSpellUnlocked method signature
   ├─ GetAllMasteries method signature
   └─ ApplyPassiveEffect method signature

2. Create ISchoolPassiveRegistry interface
   ├─ GetPassive method signature
   └─ GetAllPassives method signature
```

### Phase 3: Service Implementation (Day 2-3)

```
1. Implement SchoolPassiveRegistry
   ├─ Static passive definitions
   ├─ Thread-safe singleton
   └─ Unit tests

2. Implement MasteryService
   ├─ AddMasteryXP with tier tracking
   ├─ GetSchoolMastery with lazy init
   ├─ GetMasteryTier lookup
   ├─ GetCostModifier calculation
   ├─ GetSchoolPassive delegation
   ├─ IsSpellUnlocked check
   ├─ GetAllMasteries enumeration
   └─ ApplyPassiveEffect dispatch

3. Write unit tests (35 tests)
   └─ Cover all decision paths
```

### Phase 4: Integration (Day 3-4)

```
1. Extend MagicService
   ├─ Inject IMasteryService
   ├─ Call cost modifiers in CastSpell
   ├─ Award XP after successful cast
   └─ Apply passives on triggers

2. Extend CombatService
   ├─ Track damage sources
   └─ Notify MagicService of kills

3. Integration tests
   └─ Full casting cycle with mastery
```

### Phase 5: Terminal UI (Day 4)

```
1. Create SchoolMasteryDisplay
   ├─ Progress bars
   ├─ Tier badges
   └─ Passive indicators

2. Create MasteryCommand
   ├─ Parse arguments
   └─ Render display

3. Register command
   └─ Update CommandParser
```

### Phase 6: Polish & Documentation (Day 5)

```
1. Edge case testing
2. Performance validation
3. Changelog generation
4. Code review
```

---

## Code Examples

### MasteryTier Enum

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Represents the mastery progression tiers within a spell school.
/// Each tier unlocks new spells and reduces casting costs.
/// </summary>
public enum MasteryTier
{
    /// <summary>Starting tier. Access to Tier 1 spells only.</summary>
    Novice = 0,

    /// <summary>100 XP required. Unlocks Tier 2 spells. -5% costs.</summary>
    Apprentice = 1,

    /// <summary>300 XP required. Unlocks school passive. -10% costs.</summary>
    Adept = 2,

    /// <summary>600 XP required. Unlocks Tier 3 spells. -15% costs.</summary>
    Master = 3,

    /// <summary>1000 XP required. Unlocks Ultimate ability. -20% costs.</summary>
    Archon = 4
}

public static class MasteryTierExtensions
{
    /// <summary>
    /// Gets the XP threshold required to reach this tier.
    /// </summary>
    public static int GetThreshold(this MasteryTier tier) => tier switch
    {
        MasteryTier.Novice => 0,
        MasteryTier.Apprentice => 100,
        MasteryTier.Adept => 300,
        MasteryTier.Master => 600,
        MasteryTier.Archon => 1000,
        _ => throw new ArgumentOutOfRangeException(nameof(tier))
    };

    /// <summary>
    /// Gets the cost modifier multiplier for this tier.
    /// Lower values mean cheaper spell costs.
    /// </summary>
    public static decimal GetCostModifier(this MasteryTier tier) => tier switch
    {
        MasteryTier.Novice => 1.00m,
        MasteryTier.Apprentice => 0.95m,
        MasteryTier.Adept => 0.90m,
        MasteryTier.Master => 0.85m,
        MasteryTier.Archon => 0.80m,
        _ => throw new ArgumentOutOfRangeException(nameof(tier))
    };

    /// <summary>
    /// Gets the next tier in progression, or null if at max.
    /// </summary>
    public static MasteryTier? GetNextTier(this MasteryTier tier) => tier switch
    {
        MasteryTier.Novice => MasteryTier.Apprentice,
        MasteryTier.Apprentice => MasteryTier.Adept,
        MasteryTier.Adept => MasteryTier.Master,
        MasteryTier.Master => MasteryTier.Archon,
        MasteryTier.Archon => null,
        _ => throw new ArgumentOutOfRangeException(nameof(tier))
    };

    /// <summary>
    /// Gets the XP threshold for the next tier, or null if at Archon.
    /// </summary>
    public static int? GetNextThreshold(this MasteryTier tier)
    {
        var next = tier.GetNextTier();
        return next?.GetThreshold();
    }
}
```

### SchoolMastery Model

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Tracks a character's mastery progression within a single spell school.
/// </summary>
public class SchoolMastery
{
    /// <summary>The spell school this mastery tracks.</summary>
    public SpellSchool School { get; init; }

    /// <summary>Current accumulated XP in this school.</summary>
    public int CurrentXP { get; private set; }

    /// <summary>Current mastery tier.</summary>
    public MasteryTier Tier { get; private set; } = MasteryTier.Novice;

    /// <summary>XP threshold for the next tier, or null if at Archon.</summary>
    public int? TierUpAt => Tier.GetNextThreshold();

    /// <summary>
    /// Progress toward the next tier as a percentage (0-100).
    /// Returns 100 if at Archon tier.
    /// </summary>
    public int ProgressToNextTier
    {
        get
        {
            if (Tier == MasteryTier.Archon) return 100;

            var currentThreshold = Tier.GetThreshold();
            var nextThreshold = TierUpAt ?? 1000;
            var xpInTier = CurrentXP - currentThreshold;
            var xpNeeded = nextThreshold - currentThreshold;

            return (int)Math.Floor((decimal)xpInTier / xpNeeded * 100);
        }
    }

    /// <summary>
    /// Adds XP and returns whether a tier-up occurred.
    /// </summary>
    public bool AddXP(int amount)
    {
        if (amount <= 0) return false;
        if (Tier == MasteryTier.Archon) return false; // Capped

        CurrentXP += amount;

        // Check for tier advancement
        var nextThreshold = TierUpAt;
        if (nextThreshold.HasValue && CurrentXP >= nextThreshold.Value)
        {
            var nextTier = Tier.GetNextTier();
            if (nextTier.HasValue)
            {
                Tier = nextTier.Value;
                return true;
            }
        }

        return false;
    }

    /// <summary>Creates a deep copy of this mastery state.</summary>
    public SchoolMastery Clone() => new()
    {
        School = School,
        CurrentXP = CurrentXP,
        Tier = Tier
    };
}
```

### CostModifiers Record

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Encapsulates the cost reduction modifiers for a mastery tier.
/// </summary>
public record CostModifiers
{
    /// <summary>Multiplier for AP costs (0.80 = 20% reduction).</summary>
    public decimal APModifier { get; init; }

    /// <summary>Multiplier for Flux costs (0.80 = 20% reduction).</summary>
    public decimal FluxModifier { get; init; }

    /// <summary>The tier these modifiers correspond to.</summary>
    public MasteryTier Tier { get; init; }

    /// <summary>
    /// Creates cost modifiers from a mastery tier.
    /// </summary>
    public static CostModifiers FromTier(MasteryTier tier)
    {
        var modifier = tier.GetCostModifier();
        return new CostModifiers
        {
            APModifier = modifier,
            FluxModifier = modifier,
            Tier = tier
        };
    }

    /// <summary>
    /// Applies the AP modifier to a base cost, rounding up.
    /// </summary>
    public int ApplyToAPCost(int baseCost) =>
        (int)Math.Ceiling(baseCost * APModifier);

    /// <summary>
    /// Applies the Flux modifier to a base cost, rounding up.
    /// </summary>
    public int ApplyToFluxCost(int baseCost) =>
        (int)Math.Ceiling(baseCost * FluxModifier);
}
```

### SchoolPassive Model

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Defines a passive ability granted by reaching Adept tier in a spell school.
/// </summary>
public record SchoolPassive
{
    /// <summary>Display name of the passive.</summary>
    public required string Name { get; init; }

    /// <summary>Flavor description for UI.</summary>
    public required string Description { get; init; }

    /// <summary>The school that grants this passive.</summary>
    public required SpellSchool School { get; init; }

    /// <summary>When this passive activates.</summary>
    public required PassiveTrigger Trigger { get; init; }

    /// <summary>The effect applied when triggered.</summary>
    public required PassiveEffect Effect { get; init; }
}

/// <summary>
/// Defines when a school passive is triggered.
/// </summary>
public enum PassiveTrigger
{
    /// <summary>Triggers on critical hit with a spell.</summary>
    OnCritical,

    /// <summary>Triggers when healing is received.</summary>
    OnHeal,

    /// <summary>Triggers when a buff is applied.</summary>
    OnBuff,

    /// <summary>Triggers when using Analyze action.</summary>
    OnAnalyze
}

/// <summary>
/// Defines the mechanical effect of a school passive.
/// </summary>
public record PassiveEffect
{
    /// <summary>Type of effect.</summary>
    public required PassiveEffectType Type { get; init; }

    /// <summary>Magnitude of the effect (interpretation depends on Type).</summary>
    public required int Magnitude { get; init; }
}

public enum PassiveEffectType
{
    /// <summary>Add extra damage dice.</summary>
    BonusDamageDice,

    /// <summary>Percentage bonus to healing.</summary>
    HealingBonus,

    /// <summary>Extra turns of buff duration.</summary>
    BuffDurationExtension,

    /// <summary>Reveal enemy combat intent.</summary>
    RevealIntent
}
```

### IMasteryService Interface

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for managing spell school mastery progression.
/// </summary>
public interface IMasteryService
{
    /// <summary>
    /// Adds mastery XP to a character for a specific school.
    /// </summary>
    /// <param name="character">The character gaining XP.</param>
    /// <param name="school">The spell school.</param>
    /// <param name="amount">XP amount to add.</param>
    /// <param name="source">Source of the XP gain (for logging).</param>
    /// <returns>Result containing XP change and any tier advancement.</returns>
    MasteryXPResult AddMasteryXP(Character character, SpellSchool school, int amount, string source);

    /// <summary>
    /// Gets the mastery state for a character in a specific school.
    /// Creates a new Novice entry if none exists.
    /// </summary>
    SchoolMastery GetSchoolMastery(Character character, SpellSchool school);

    /// <summary>
    /// Gets the current mastery tier for a character in a specific school.
    /// </summary>
    MasteryTier GetMasteryTier(Character character, SpellSchool school);

    /// <summary>
    /// Gets the cost modifiers for a character's mastery tier in a school.
    /// </summary>
    CostModifiers GetCostModifier(Character character, SpellSchool school);

    /// <summary>
    /// Gets the school passive for a character, if they qualify (Adept+).
    /// </summary>
    /// <returns>The passive, or null if below Adept tier.</returns>
    SchoolPassive? GetSchoolPassive(Character character, SpellSchool school);

    /// <summary>
    /// Checks if a spell is unlocked for a character based on mastery tier.
    /// </summary>
    bool IsSpellUnlocked(Character character, Spell spell);

    /// <summary>
    /// Gets all mastery states for a character.
    /// </summary>
    IReadOnlyDictionary<SpellSchool, SchoolMastery> GetAllMasteries(Character character);

    /// <summary>
    /// Applies the school passive effect if triggered by the context.
    /// </summary>
    void ApplyPassiveEffect(Character character, SpellSchool school, SpellContext context);
}
```

### MasteryService Implementation

```csharp
namespace RuneAndRust.Engine.Services;

/// <summary>
/// Manages spell school mastery progression, XP accumulation, and passive effects.
/// </summary>
public class MasteryService : IMasteryService
{
    private readonly ILogger<MasteryService> _logger;
    private readonly IEventBus _eventBus;
    private readonly ISchoolPassiveRegistry _passiveRegistry;

    public MasteryService(
        ILogger<MasteryService> logger,
        IEventBus eventBus,
        ISchoolPassiveRegistry passiveRegistry)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _eventBus = eventBus ?? throw new ArgumentNullException(nameof(eventBus));
        _passiveRegistry = passiveRegistry ?? throw new ArgumentNullException(nameof(passiveRegistry));
    }

    /// <inheritdoc />
    public MasteryXPResult AddMasteryXP(Character character, SpellSchool school, int amount, string source)
    {
        _logger.LogDebug(
            "AddMasteryXP called for Character={CharacterId}, School={School}, Amount={Amount}, Source={Source}",
            character.Id, school, amount, source);

        if (amount <= 0)
        {
            _logger.LogWarning(
                "Attempted to add non-positive XP ({Amount}) for {School}. Ignoring.",
                amount, school);
            return MasteryXPResult.NoChange(character.Id, school);
        }

        var mastery = GetSchoolMastery(character, school);
        var previousXP = mastery.CurrentXP;
        var previousTier = mastery.Tier;

        var tieredUp = mastery.AddXP(amount);

        _logger.LogInformation(
            "Mastery XP added: Character={CharacterId}, School={School}, " +
            "PreviousXP={PreviousXP}, NewXP={NewXP}, XPGained={XPGained}, " +
            "TierChanged={TierChanged}, Source={Source}",
            character.Id, school, previousXP, mastery.CurrentXP, amount, tieredUp, source);

        if (tieredUp)
        {
            _logger.LogInformation(
                "TIER UP! Character={CharacterId} reached {NewTier} in {School}",
                character.Id, mastery.Tier, school);

            var passive = mastery.Tier >= MasteryTier.Adept
                ? _passiveRegistry.GetPassive(school)
                : null;

            var tierEvent = new MasteryTierReachedEvent
            {
                CharacterId = character.Id,
                School = school,
                NewTier = mastery.Tier,
                PreviousTier = previousTier,
                UnlockedPassive = passive,
                Timestamp = DateTime.UtcNow
            };

            _eventBus.Publish(tierEvent);
        }

        return new MasteryXPResult
        {
            CharacterId = character.Id,
            School = school,
            PreviousXP = previousXP,
            NewXP = mastery.CurrentXP,
            XPGained = amount,
            TierChanged = tieredUp,
            PreviousTier = previousTier,
            NewTier = tieredUp ? mastery.Tier : null,
            Source = source
        };
    }

    /// <inheritdoc />
    public SchoolMastery GetSchoolMastery(Character character, SpellSchool school)
    {
        _logger.LogDebug(
            "GetSchoolMastery called for Character={CharacterId}, School={School}",
            character.Id, school);

        // Lazy initialization: create if not exists
        if (!character.MasteryStates.TryGetValue(school, out var mastery))
        {
            _logger.LogDebug(
                "No mastery found for {School}, creating new Novice entry",
                school);

            mastery = new SchoolMastery { School = school };
            character.MasteryStates[school] = mastery;
        }

        return mastery;
    }

    /// <inheritdoc />
    public MasteryTier GetMasteryTier(Character character, SpellSchool school)
    {
        var mastery = GetSchoolMastery(character, school);
        return mastery.Tier;
    }

    /// <inheritdoc />
    public CostModifiers GetCostModifier(Character character, SpellSchool school)
    {
        var tier = GetMasteryTier(character, school);
        var modifiers = CostModifiers.FromTier(tier);

        _logger.LogDebug(
            "Cost modifiers for Character={CharacterId}, School={School}: " +
            "Tier={Tier}, APMod={APMod}, FluxMod={FluxMod}",
            character.Id, school, tier, modifiers.APModifier, modifiers.FluxModifier);

        return modifiers;
    }

    /// <inheritdoc />
    public SchoolPassive? GetSchoolPassive(Character character, SpellSchool school)
    {
        var tier = GetMasteryTier(character, school);

        if (tier < MasteryTier.Adept)
        {
            _logger.LogDebug(
                "Character={CharacterId} is below Adept in {School}, no passive",
                character.Id, school);
            return null;
        }

        return _passiveRegistry.GetPassive(school);
    }

    /// <inheritdoc />
    public bool IsSpellUnlocked(Character character, Spell spell)
    {
        var masteryTier = GetMasteryTier(character, spell.School);

        // Map spell tier requirements to mastery tiers
        var requiredMastery = spell.TierRequirement switch
        {
            1 => MasteryTier.Novice,
            2 => MasteryTier.Apprentice,
            3 => MasteryTier.Master,
            4 => MasteryTier.Archon,
            _ => MasteryTier.Novice
        };

        var isUnlocked = masteryTier >= requiredMastery;

        _logger.LogDebug(
            "Spell unlock check: Character={CharacterId}, Spell={SpellName}, " +
            "RequiredTier={RequiredTier}, CurrentTier={CurrentTier}, Unlocked={Unlocked}",
            character.Id, spell.Name, requiredMastery, masteryTier, isUnlocked);

        return isUnlocked;
    }

    /// <inheritdoc />
    public IReadOnlyDictionary<SpellSchool, SchoolMastery> GetAllMasteries(Character character)
    {
        // Ensure all schools are represented (lazy init any missing)
        foreach (SpellSchool school in Enum.GetValues<SpellSchool>())
        {
            GetSchoolMastery(character, school);
        }

        return character.MasteryStates.AsReadOnly();
    }

    /// <inheritdoc />
    public void ApplyPassiveEffect(Character character, SpellSchool school, SpellContext context)
    {
        var passive = GetSchoolPassive(character, school);
        if (passive is null) return;

        var shouldTrigger = passive.Trigger switch
        {
            PassiveTrigger.OnCritical => context.IsCriticalHit,
            PassiveTrigger.OnHeal => context.IsHealing,
            PassiveTrigger.OnBuff => context.IsBuff,
            PassiveTrigger.OnAnalyze => context.IsAnalyze,
            _ => false
        };

        if (!shouldTrigger)
        {
            _logger.LogDebug(
                "Passive {PassiveName} not triggered for context",
                passive.Name);
            return;
        }

        _logger.LogInformation(
            "Applying passive {PassiveName}: Character={CharacterId}, " +
            "Effect={EffectType}, Magnitude={Magnitude}",
            passive.Name, character.Id, passive.Effect.Type, passive.Effect.Magnitude);

        // Apply effect based on type
        switch (passive.Effect.Type)
        {
            case PassiveEffectType.BonusDamageDice:
                context.BonusDamageDice += passive.Effect.Magnitude;
                break;
            case PassiveEffectType.HealingBonus:
                context.HealingMultiplier *= (1 + passive.Effect.Magnitude / 100m);
                break;
            case PassiveEffectType.BuffDurationExtension:
                context.BonusBuffDuration += passive.Effect.Magnitude;
                break;
            case PassiveEffectType.RevealIntent:
                context.RevealEnemyIntent = true;
                break;
        }
    }
}
```

### SchoolPassiveRegistry Implementation

```csharp
namespace RuneAndRust.Engine.Services;

/// <summary>
/// Registry of school-specific passive abilities unlocked at Adept tier.
/// </summary>
public class SchoolPassiveRegistry : ISchoolPassiveRegistry
{
    private static readonly IReadOnlyDictionary<SpellSchool, SchoolPassive> _passives =
        new Dictionary<SpellSchool, SchoolPassive>
        {
            [SpellSchool.Destruction] = new SchoolPassive
            {
                Name = "Entropic Resonance",
                Description = "Critical hits with Destruction spells deal an additional damage die.",
                School = SpellSchool.Destruction,
                Trigger = PassiveTrigger.OnCritical,
                Effect = new PassiveEffect
                {
                    Type = PassiveEffectType.BonusDamageDice,
                    Magnitude = 1
                }
            },
            [SpellSchool.Restoration] = new SchoolPassive
            {
                Name = "Life Attunement",
                Description = "All healing received is increased by 10%.",
                School = SpellSchool.Restoration,
                Trigger = PassiveTrigger.OnHeal,
                Effect = new PassiveEffect
                {
                    Type = PassiveEffectType.HealingBonus,
                    Magnitude = 10
                }
            },
            [SpellSchool.Alteration] = new SchoolPassive
            {
                Name = "Reality Anchor",
                Description = "Buff effects you apply last 1 additional turn.",
                School = SpellSchool.Alteration,
                Trigger = PassiveTrigger.OnBuff,
                Effect = new PassiveEffect
                {
                    Type = PassiveEffectType.BuffDurationExtension,
                    Magnitude = 1
                }
            },
            [SpellSchool.Divination] = new SchoolPassive
            {
                Name = "Third Eye",
                Description = "Analyze actions reveal the enemy's next intended action.",
                School = SpellSchool.Divination,
                Trigger = PassiveTrigger.OnAnalyze,
                Effect = new PassiveEffect
                {
                    Type = PassiveEffectType.RevealIntent,
                    Magnitude = 1
                }
            }
        };

    /// <inheritdoc />
    public SchoolPassive? GetPassive(SpellSchool school)
    {
        return _passives.TryGetValue(school, out var passive) ? passive : null;
    }

    /// <inheritdoc />
    public IReadOnlyList<SchoolPassive> GetAllPassives()
    {
        return _passives.Values.ToList().AsReadOnly();
    }
}
```

### MasteryXPResult Record

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Result of adding mastery XP to a character.
/// </summary>
public record MasteryXPResult
{
    public required Guid CharacterId { get; init; }
    public required SpellSchool School { get; init; }
    public required int PreviousXP { get; init; }
    public required int NewXP { get; init; }
    public required int XPGained { get; init; }
    public required bool TierChanged { get; init; }
    public MasteryTier PreviousTier { get; init; }
    public MasteryTier? NewTier { get; init; }
    public required string Source { get; init; }

    /// <summary>
    /// Creates a no-change result for invalid XP additions.
    /// </summary>
    public static MasteryXPResult NoChange(Guid characterId, SpellSchool school) => new()
    {
        CharacterId = characterId,
        School = school,
        PreviousXP = 0,
        NewXP = 0,
        XPGained = 0,
        TierChanged = false,
        PreviousTier = MasteryTier.Novice,
        NewTier = null,
        Source = "NoChange"
    };
}
```

### MasteryTierReachedEvent

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Published when a character reaches a new mastery tier in a spell school.
/// </summary>
public record MasteryTierReachedEvent : IEvent
{
    public required Guid CharacterId { get; init; }
    public required SpellSchool School { get; init; }
    public required MasteryTier NewTier { get; init; }
    public required MasteryTier PreviousTier { get; init; }
    public SchoolPassive? UnlockedPassive { get; init; }
    public IReadOnlyList<Spell>? NewlyUnlockedSpells { get; init; }
    public required DateTime Timestamp { get; init; }
}
```

---

## Logging Specification

### Log Levels

| Level | Usage |
|-------|-------|
| **Debug** | Method entry, parameter values, intermediate states |
| **Information** | XP gains, tier changes, passive applications |
| **Warning** | Invalid inputs (negative XP), edge cases |
| **Error** | Exceptions, invariant violations |

### Structured Logging Fields

| Field | Type | Description |
|-------|------|-------------|
| `CharacterId` | Guid | Character identifier |
| `School` | SpellSchool | Spell school being tracked |
| `Amount` | int | XP amount being added |
| `Source` | string | Origin of XP (cast, kill, learn) |
| `PreviousXP` | int | XP before modification |
| `NewXP` | int | XP after modification |
| `PreviousTier` | MasteryTier | Tier before modification |
| `NewTier` | MasteryTier | Tier after modification (if changed) |
| `TierChanged` | bool | Whether tier advancement occurred |
| `PassiveName` | string | Name of applied passive |
| `EffectType` | PassiveEffectType | Type of passive effect |
| `Magnitude` | int | Magnitude of passive effect |

### Log Message Templates

```csharp
// XP Addition
_logger.LogInformation(
    "Mastery XP added: Character={CharacterId}, School={School}, " +
    "PreviousXP={PreviousXP}, NewXP={NewXP}, XPGained={XPGained}, " +
    "TierChanged={TierChanged}, Source={Source}",
    character.Id, school, previousXP, mastery.CurrentXP, amount, tieredUp, source);

// Tier Advancement
_logger.LogInformation(
    "TIER UP! Character={CharacterId} reached {NewTier} in {School}",
    character.Id, mastery.Tier, school);

// Cost Modifier Calculation
_logger.LogDebug(
    "Cost modifiers for Character={CharacterId}, School={School}: " +
    "Tier={Tier}, APMod={APMod}, FluxMod={FluxMod}",
    character.Id, school, tier, modifiers.APModifier, modifiers.FluxModifier);

// Passive Application
_logger.LogInformation(
    "Applying passive {PassiveName}: Character={CharacterId}, " +
    "Effect={EffectType}, Magnitude={Magnitude}",
    passive.Name, character.Id, passive.Effect.Type, passive.Effect.Magnitude);

// Spell Unlock Check
_logger.LogDebug(
    "Spell unlock check: Character={CharacterId}, Spell={SpellName}, " +
    "RequiredTier={RequiredTier}, CurrentTier={CurrentTier}, Unlocked={Unlocked}",
    character.Id, spell.Name, requiredMastery, masteryTier, isUnlocked);

// Warning: Invalid XP
_logger.LogWarning(
    "Attempted to add non-positive XP ({Amount}) for {School}. Ignoring.",
    amount, school);
```

---

## Unit Testing

### Test Class Structure

```csharp
namespace RuneAndRust.Tests.Services;

public class MasteryServiceTests
{
    private readonly Mock<ILogger<MasteryService>> _loggerMock;
    private readonly Mock<IEventBus> _eventBusMock;
    private readonly Mock<ISchoolPassiveRegistry> _passiveRegistryMock;
    private readonly MasteryService _sut;

    public MasteryServiceTests()
    {
        _loggerMock = new Mock<ILogger<MasteryService>>();
        _eventBusMock = new Mock<IEventBus>();
        _passiveRegistryMock = new Mock<ISchoolPassiveRegistry>();

        _sut = new MasteryService(
            _loggerMock.Object,
            _eventBusMock.Object,
            _passiveRegistryMock.Object);
    }
}
```

### Test Categories (35 Tests)

#### Category 1: XP Gain (8 tests)

```csharp
[Fact]
public void AddMasteryXP_WithValidAmount_IncreasesCurrentXP()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 10, "cast");

    // Assert
    result.NewXP.Should().Be(10);
    result.XPGained.Should().Be(10);
    result.TierChanged.Should().BeFalse();
}

[Fact]
public void AddMasteryXP_WithZeroAmount_ReturnsNoChange()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 0, "cast");

    // Assert
    result.XPGained.Should().Be(0);
    result.TierChanged.Should().BeFalse();
}

[Fact]
public void AddMasteryXP_WithNegativeAmount_ReturnsNoChange()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, -10, "cast");

    // Assert
    result.XPGained.Should().Be(0);
}

[Fact]
public void AddMasteryXP_FromCast_AddsBaseXP()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 10, "spell_cast");

    // Assert
    result.NewXP.Should().Be(10);
    result.Source.Should().Be("spell_cast");
}

[Fact]
public void AddMasteryXP_FromKill_AddsBonusXP()
{
    // Arrange
    var character = CreateTestCharacter();
    _sut.AddMasteryXP(character, SpellSchool.Destruction, 10, "spell_cast"); // Base

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 25, "spell_kill");

    // Assert
    result.NewXP.Should().Be(35); // 10 + 25
}

[Fact]
public void AddMasteryXP_FromGaldr_AddsBonusXP()
{
    // Arrange
    var character = CreateTestCharacter();
    _sut.AddMasteryXP(character, SpellSchool.Destruction, 10, "spell_cast");

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 15, "galdr_completion");

    // Assert
    result.NewXP.Should().Be(25);
}

[Fact]
public void AddMasteryXP_FromLearning_AddsLargeXP()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 50, "spell_learned");

    // Assert
    result.NewXP.Should().Be(50);
}

[Fact]
public void AddMasteryXP_AtArchonTier_DoesNotExceedCap()
{
    // Arrange
    var character = CreateTestCharacter();
    character.MasteryStates[SpellSchool.Destruction] = new SchoolMastery
    {
        School = SpellSchool.Destruction,
        CurrentXP = 1000,
        Tier = MasteryTier.Archon
    };

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 100, "cast");

    // Assert
    result.XPGained.Should().Be(0);
    result.NewXP.Should().Be(1000);
}
```

#### Category 2: Tier Calculation (6 tests)

```csharp
[Theory]
[InlineData(0, MasteryTier.Novice)]
[InlineData(99, MasteryTier.Novice)]
[InlineData(100, MasteryTier.Apprentice)]
[InlineData(299, MasteryTier.Apprentice)]
[InlineData(300, MasteryTier.Adept)]
[InlineData(599, MasteryTier.Adept)]
[InlineData(600, MasteryTier.Master)]
[InlineData(999, MasteryTier.Master)]
[InlineData(1000, MasteryTier.Archon)]
public void GetMasteryTier_ReturnsCorrectTierForXP(int xp, MasteryTier expectedTier)
{
    // Arrange
    var character = CreateTestCharacterWithXP(SpellSchool.Destruction, xp);

    // Act
    var tier = _sut.GetMasteryTier(character, SpellSchool.Destruction);

    // Assert
    tier.Should().Be(expectedTier);
}

[Fact]
public void AddMasteryXP_CrossingThreshold_TriggersTierUp()
{
    // Arrange
    var character = CreateTestCharacterWithXP(SpellSchool.Destruction, 95);

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 10, "cast");

    // Assert
    result.TierChanged.Should().BeTrue();
    result.NewTier.Should().Be(MasteryTier.Apprentice);
    result.PreviousTier.Should().Be(MasteryTier.Novice);
}

[Fact]
public void AddMasteryXP_TierUp_PublishesEvent()
{
    // Arrange
    var character = CreateTestCharacterWithXP(SpellSchool.Destruction, 95);

    // Act
    _sut.AddMasteryXP(character, SpellSchool.Destruction, 10, "cast");

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.Is<MasteryTierReachedEvent>(
            ev => ev.NewTier == MasteryTier.Apprentice)),
        Times.Once);
}

[Fact]
public void AddMasteryXP_NoTierChange_DoesNotPublishEvent()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    _sut.AddMasteryXP(character, SpellSchool.Destruction, 10, "cast");

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.IsAny<MasteryTierReachedEvent>()),
        Times.Never);
}

[Fact]
public void AddMasteryXP_SkippingMultipleTiers_ReachesCorrectTier()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var result = _sut.AddMasteryXP(character, SpellSchool.Destruction, 350, "massive_boost");

    // Assert - Should reach Adept (300) but not Master (600)
    result.TierChanged.Should().BeTrue();
    var currentTier = _sut.GetMasteryTier(character, SpellSchool.Destruction);
    currentTier.Should().Be(MasteryTier.Adept);
}

[Fact]
public void GetMasteryTier_ForNewSchool_ReturnsNovice()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var tier = _sut.GetMasteryTier(character, SpellSchool.Restoration);

    // Assert
    tier.Should().Be(MasteryTier.Novice);
}
```

#### Category 3: Cost Modifiers (8 tests)

```csharp
[Theory]
[InlineData(MasteryTier.Novice, 1.00)]
[InlineData(MasteryTier.Apprentice, 0.95)]
[InlineData(MasteryTier.Adept, 0.90)]
[InlineData(MasteryTier.Master, 0.85)]
[InlineData(MasteryTier.Archon, 0.80)]
public void GetCostModifier_ReturnsCorrectModifierForTier(MasteryTier tier, decimal expectedMod)
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, tier);

    // Act
    var modifiers = _sut.GetCostModifier(character, SpellSchool.Destruction);

    // Assert
    modifiers.APModifier.Should().Be(expectedMod);
    modifiers.FluxModifier.Should().Be(expectedMod);
}

[Fact]
public void CostModifiers_ApplyToAPCost_RoundsUp()
{
    // Arrange
    var modifiers = CostModifiers.FromTier(MasteryTier.Apprentice); // 0.95

    // Act
    var result = modifiers.ApplyToAPCost(10); // 10 * 0.95 = 9.5

    // Assert
    result.Should().Be(10); // Rounded up
}

[Fact]
public void CostModifiers_ApplyToAPCost_ReducesCost()
{
    // Arrange
    var modifiers = CostModifiers.FromTier(MasteryTier.Archon); // 0.80

    // Act
    var result = modifiers.ApplyToAPCost(10);

    // Assert
    result.Should().Be(8);
}

[Fact]
public void CostModifiers_ApplyToFluxCost_RoundsUp()
{
    // Arrange
    var modifiers = CostModifiers.FromTier(MasteryTier.Adept); // 0.90

    // Act
    var result = modifiers.ApplyToFluxCost(15); // 15 * 0.90 = 13.5

    // Assert
    result.Should().Be(14); // Rounded up
}

[Fact]
public void CostModifiers_FromTier_IncludesTierInfo()
{
    // Act
    var modifiers = CostModifiers.FromTier(MasteryTier.Master);

    // Assert
    modifiers.Tier.Should().Be(MasteryTier.Master);
}

[Fact]
public void GetCostModifier_ForNewSchool_ReturnsNoviceModifiers()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var modifiers = _sut.GetCostModifier(character, SpellSchool.Alteration);

    // Assert
    modifiers.APModifier.Should().Be(1.00m);
    modifiers.Tier.Should().Be(MasteryTier.Novice);
}

[Fact]
public void CostModifiers_ApplyToAPCost_MinimumIsOne()
{
    // Arrange
    var modifiers = CostModifiers.FromTier(MasteryTier.Archon);

    // Act
    var result = modifiers.ApplyToAPCost(1); // 1 * 0.80 = 0.8

    // Assert
    result.Should().Be(1); // Minimum cost is 1
}

[Fact]
public void CostModifiers_Immutability_FromTierReturnsNewInstance()
{
    // Act
    var mod1 = CostModifiers.FromTier(MasteryTier.Adept);
    var mod2 = CostModifiers.FromTier(MasteryTier.Adept);

    // Assert
    mod1.Should().NotBeSameAs(mod2);
    mod1.Should().Be(mod2); // Value equality
}
```

#### Category 4: Spell Unlocks (6 tests)

```csharp
[Fact]
public void IsSpellUnlocked_Tier1SpellAtNovice_ReturnsTrue()
{
    // Arrange
    var character = CreateTestCharacter();
    var spell = CreateSpell(SpellSchool.Destruction, tierRequirement: 1);

    // Act
    var unlocked = _sut.IsSpellUnlocked(character, spell);

    // Assert
    unlocked.Should().BeTrue();
}

[Fact]
public void IsSpellUnlocked_Tier2SpellAtNovice_ReturnsFalse()
{
    // Arrange
    var character = CreateTestCharacter();
    var spell = CreateSpell(SpellSchool.Destruction, tierRequirement: 2);

    // Act
    var unlocked = _sut.IsSpellUnlocked(character, spell);

    // Assert
    unlocked.Should().BeFalse();
}

[Fact]
public void IsSpellUnlocked_Tier2SpellAtApprentice_ReturnsTrue()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Apprentice);
    var spell = CreateSpell(SpellSchool.Destruction, tierRequirement: 2);

    // Act
    var unlocked = _sut.IsSpellUnlocked(character, spell);

    // Assert
    unlocked.Should().BeTrue();
}

[Fact]
public void IsSpellUnlocked_Tier3SpellAtAdept_ReturnsFalse()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Adept);
    var spell = CreateSpell(SpellSchool.Destruction, tierRequirement: 3);

    // Act
    var unlocked = _sut.IsSpellUnlocked(character, spell);

    // Assert
    unlocked.Should().BeFalse();
}

[Fact]
public void IsSpellUnlocked_Tier3SpellAtMaster_ReturnsTrue()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Master);
    var spell = CreateSpell(SpellSchool.Destruction, tierRequirement: 3);

    // Act
    var unlocked = _sut.IsSpellUnlocked(character, spell);

    // Assert
    unlocked.Should().BeTrue();
}

[Fact]
public void IsSpellUnlocked_UltimateSpellAtMaster_ReturnsFalse()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Master);
    var spell = CreateSpell(SpellSchool.Destruction, tierRequirement: 4);

    // Act
    var unlocked = _sut.IsSpellUnlocked(character, spell);

    // Assert
    unlocked.Should().BeFalse();
}
```

#### Category 5: Passives (5 tests)

```csharp
[Fact]
public void GetSchoolPassive_BelowAdept_ReturnsNull()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Apprentice);

    // Act
    var passive = _sut.GetSchoolPassive(character, SpellSchool.Destruction);

    // Assert
    passive.Should().BeNull();
}

[Fact]
public void GetSchoolPassive_AtAdept_ReturnsPassive()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Adept);
    var expectedPassive = new SchoolPassive
    {
        Name = "Entropic Resonance",
        School = SpellSchool.Destruction,
        Trigger = PassiveTrigger.OnCritical,
        Effect = new PassiveEffect { Type = PassiveEffectType.BonusDamageDice, Magnitude = 1 }
    };
    _passiveRegistryMock.Setup(r => r.GetPassive(SpellSchool.Destruction))
        .Returns(expectedPassive);

    // Act
    var passive = _sut.GetSchoolPassive(character, SpellSchool.Destruction);

    // Assert
    passive.Should().NotBeNull();
    passive!.Name.Should().Be("Entropic Resonance");
}

[Fact]
public void ApplyPassiveEffect_OnCritical_AddsBonusDice()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Adept);
    var passive = CreateDestructionPassive();
    _passiveRegistryMock.Setup(r => r.GetPassive(SpellSchool.Destruction)).Returns(passive);
    var context = new SpellContext { IsCriticalHit = true };

    // Act
    _sut.ApplyPassiveEffect(character, SpellSchool.Destruction, context);

    // Assert
    context.BonusDamageDice.Should().Be(1);
}

[Fact]
public void ApplyPassiveEffect_NotTriggered_NoEffect()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Adept);
    var passive = CreateDestructionPassive();
    _passiveRegistryMock.Setup(r => r.GetPassive(SpellSchool.Destruction)).Returns(passive);
    var context = new SpellContext { IsCriticalHit = false };

    // Act
    _sut.ApplyPassiveEffect(character, SpellSchool.Destruction, context);

    // Assert
    context.BonusDamageDice.Should().Be(0);
}

[Fact]
public void ApplyPassiveEffect_BelowAdept_NoEffect()
{
    // Arrange
    var character = CreateTestCharacterAtTier(SpellSchool.Destruction, MasteryTier.Apprentice);
    var context = new SpellContext { IsCriticalHit = true };

    // Act
    _sut.ApplyPassiveEffect(character, SpellSchool.Destruction, context);

    // Assert
    context.BonusDamageDice.Should().Be(0);
}
```

#### Category 6: Integration (2 tests)

```csharp
[Fact]
public void FullProgressionCycle_NoviceToAdept_UnlocksPassive()
{
    // Arrange
    var character = CreateTestCharacter();
    var realRegistry = new SchoolPassiveRegistry();
    var sut = new MasteryService(_loggerMock.Object, _eventBusMock.Object, realRegistry);

    // Act - Progress through tiers
    sut.AddMasteryXP(character, SpellSchool.Destruction, 100, "learning"); // → Apprentice
    sut.AddMasteryXP(character, SpellSchool.Destruction, 200, "practice"); // → Adept

    var passive = sut.GetSchoolPassive(character, SpellSchool.Destruction);

    // Assert
    passive.Should().NotBeNull();
    passive!.Name.Should().Be("Entropic Resonance");
    _eventBusMock.Verify(e => e.Publish(It.IsAny<MasteryTierReachedEvent>()), Times.Exactly(2));
}

[Fact]
public void GetAllMasteries_InitializesAllSchools()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act
    var masteries = _sut.GetAllMasteries(character);

    // Assert
    masteries.Should().HaveCount(4); // All 4 schools
    masteries.Values.Should().OnlyContain(m => m.Tier == MasteryTier.Novice);
}
```

### Test Helper Methods

```csharp
private static Character CreateTestCharacter() => new()
{
    Id = Guid.NewGuid(),
    Name = "Test Mystic",
    MasteryStates = new Dictionary<SpellSchool, SchoolMastery>()
};

private static Character CreateTestCharacterWithXP(SpellSchool school, int xp)
{
    var character = CreateTestCharacter();
    var mastery = new SchoolMastery { School = school };
    // Manually set XP through reflection or internal setter for testing
    SetMasteryXP(mastery, xp);
    character.MasteryStates[school] = mastery;
    return character;
}

private static Character CreateTestCharacterAtTier(SpellSchool school, MasteryTier tier)
{
    var xp = tier.GetThreshold();
    return CreateTestCharacterWithXP(school, xp);
}

private static Spell CreateSpell(SpellSchool school, int tierRequirement) => new()
{
    Id = Guid.NewGuid(),
    Name = "Test Spell",
    School = school,
    TierRequirement = tierRequirement
};

private static SchoolPassive CreateDestructionPassive() => new()
{
    Name = "Entropic Resonance",
    Description = "Test passive",
    School = SpellSchool.Destruction,
    Trigger = PassiveTrigger.OnCritical,
    Effect = new PassiveEffect { Type = PassiveEffectType.BonusDamageDice, Magnitude = 1 }
};
```

---

## Integration Points

### MagicService Integration

```csharp
// In MagicService.CastSpell()
public async Task<SpellCastResult> CastSpell(Character caster, Spell spell, ITarget target)
{
    _logger.LogDebug("Casting {SpellName} by {CharacterId}", spell.Name, caster.Id);

    // 1. Check spell unlock
    if (!_masteryService.IsSpellUnlocked(caster, spell))
    {
        return SpellCastResult.SpellLocked(spell,
            _masteryService.GetMasteryTier(caster, spell.School));
    }

    // 2. Apply cost modifiers
    var costMods = _masteryService.GetCostModifier(caster, spell.School);
    var effectiveAPCost = costMods.ApplyToAPCost(spell.APCost);
    var effectiveFluxCost = costMods.ApplyToFluxCost(spell.FluxCost);

    // 3. Execute spell...
    var context = await ExecuteSpellEffect(caster, spell, target, effectiveAPCost, effectiveFluxCost);

    // 4. Apply school passive if triggered
    _masteryService.ApplyPassiveEffect(caster, spell.School, context);

    // 5. Award mastery XP
    var xpGained = CalculateMasteryXP(context);
    _masteryService.AddMasteryXP(caster, spell.School, xpGained, context.Source);

    return context.ToResult();
}

private int CalculateMasteryXP(SpellContext context)
{
    var baseXP = 10; // Casting XP

    if (context.TargetKilled)
        baseXP += 25; // Kill bonus

    if (context.WasGaldr)
        baseXP += 15; // Galdr bonus

    return baseXP;
}
```

### CombatService Integration

```csharp
// In CombatService - track damage sources for kill attribution
private void ProcessDeath(Creature target)
{
    if (_lastDamageSource is SpellDamageSource spellSource)
    {
        // Notify for kill XP bonus
        var killEvent = new SpellKillEvent
        {
            CasterId = spellSource.CasterId,
            SpellSchool = spellSource.School,
            TargetId = target.Id
        };
        _eventBus.Publish(killEvent);
    }
}
```

### Terminal UI Integration

```csharp
// mastery command handler
public class MasteryCommand : ICommand
{
    private readonly IMasteryService _masteryService;
    private readonly ICharacterService _characterService;

    public void Execute(string[] args)
    {
        var character = _characterService.GetCurrentCharacter();
        var masteries = _masteryService.GetAllMasteries(character);

        var display = new SchoolMasteryDisplay(masteries);
        display.Render();
    }
}
```

---

## Domain 4 Compliance

### Layer Classification

| Content Type | Layer | Voice Requirements |
|--------------|-------|-------------------|
| Mastery tier names | Layer 1 (Mythic) | Archaic, symbolic |
| Passive descriptions | Layer 2 (Diagnostic) | Observer perspective |
| XP mechanics | Layer 4 (Ground Truth) | Technical spec |

### Forbidden Precision Violations

| ❌ Violation | ✅ Compliant Alternative |
|-------------|-------------------------|
| "100 XP required" | "A practitioner's dozen of channeled intentions" |
| "-20% cost reduction" | "The Art flows more freely through seasoned hands" |
| "Adept tier at 300 XP" | "Those who have woven the Weave a hundred times" |

### Compliant Passive Descriptions (Layer 2)

```csharp
// Destruction - Entropic Resonance
Description = "When the flame finds true purchase, it burns deeper still—" +
              "as if the Weave itself remembers the caster's intent.";

// Restoration - Life Attunement
Description = "The healer who has mended a thousand wounds " +
              "becomes one with the body's own will to persist.";

// Alteration - Reality Anchor
Description = "Those steeped in transmutation learn to anchor their " +
              "workings to the fabric of existence itself.";

// Divination - Third Eye
Description = "The seer's gaze pierces beyond the immediate—" +
              "glimpsing the thread of intent before it is woven.";
```

### UI Display Guidelines

- Use progress bars, not percentages
- Show tier names, not XP numbers
- Use flavor text for advancement notifications:
  > "Your understanding of Destruction deepens. The flames recognize you as Adept."

---

## Changelog Template

```markdown
## [v0.4.4c] - YYYY-MM-DD

### Added

#### Core Models
- `MasteryTier` enum with `Novice`, `Apprentice`, `Adept`, `Master`, `Archon` values
- `MasteryTierExtensions` with `GetThreshold()`, `GetCostModifier()`, `GetNextTier()` methods
- `SchoolMastery` model tracking per-school XP and tier progression
- `CostModifiers` record with `APModifier`, `FluxModifier`, and `FromTier()` factory
- `SchoolPassive` model with `PassiveTrigger` and `PassiveEffect` components
- `MasteryXPResult` record for XP operation results
- `MasteryTierReachedEvent` for tier advancement notifications

#### Services
- `IMasteryService` interface with 8 methods for mastery management
- `MasteryService` implementation with full XP/tier/passive logic
- `ISchoolPassiveRegistry` interface for passive ability lookup
- `SchoolPassiveRegistry` with 4 school-specific passives:
  - Destruction: Entropic Resonance (+1 damage die on crits)
  - Restoration: Life Attunement (+10% healing received)
  - Alteration: Reality Anchor (+1 turn buff duration)
  - Divination: Third Eye (reveal enemy intent)

#### Terminal UI
- `SchoolMasteryDisplay` renderer with progress bars and tier badges
- `MasteryCommand` handler for `mastery` terminal command
- CommandParser registration for mastery command

#### Integration
- MagicService hooks for cost modifier application
- MagicService hooks for passive effect triggering
- MagicService hooks for XP award on spell cast
- CombatService hooks for kill XP bonus attribution

### Test Coverage

| Category | Tests | Coverage |
|----------|-------|----------|
| XP Gain | 8 | 100% |
| Tier Calculation | 6 | 100% |
| Cost Modifiers | 8 | 100% |
| Spell Unlocks | 6 | 100% |
| Passives | 5 | 100% |
| Integration | 2 | 100% |
| **Total** | **35** | **85%** |

### Dependencies
- Requires v0.4.3 (Flux, BacklashService, SpellSchool enum)
- Requires v0.4.4a (ResonanceService - for context)
- Requires v0.4.4b (GaldrService - for Galdr XP bonus integration)

### Migration Notes
- Characters require `MasteryStates` dictionary property
- Existing characters will have empty mastery (lazy initialized to Novice)
- No database migration required (state stored in character entity)

---

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

---

## Appendix: Quick Reference

### Tier Thresholds

| Tier | XP | Cost Mod | Passive |
|------|----|---------:|:-------:|
| Novice | 0 | 1.00x | ❌ |
| Apprentice | 100 | 0.95x | ❌ |
| Adept | 300 | 0.90x | ✅ |
| Master | 600 | 0.85x | ✅ |
| Archon | 1000 | 0.80x | ✅ |

### XP Sources

| Source | XP | Notes |
|--------|---:|-------|
| Cast spell | +10 | Per cast |
| Kill with spell | +25 | Bonus |
| Complete Galdr | +15 | Bonus |
| Learn spell | +50 | One-time |
| Research | +20 | Scrolls |
| Master training | +100 | Quest |

### File Locations

| File | Path |
|------|------|
| MasteryTier | `Core/Enums/MasteryTier.cs` |
| SchoolMastery | `Core/Models/Magic/SchoolMastery.cs` |
| CostModifiers | `Core/Models/Magic/CostModifiers.cs` |
| SchoolPassive | `Core/Models/Magic/SchoolPassive.cs` |
| IMasteryService | `Core/Interfaces/IMasteryService.cs` |
| MasteryService | `Engine/Services/MasteryService.cs` |
| SchoolPassiveRegistry | `Engine/Services/SchoolPassiveRegistry.cs` |
| MasteryServiceTests | `Tests/Services/MasteryServiceTests.cs` |
