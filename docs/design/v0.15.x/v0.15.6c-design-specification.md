# v0.15.6c Design Specification: Object Category Descriptors

**Version:** 0.15.6c
**Phase Name:** Object Category Descriptors
**Parent Version:** v0.15.6 (Advanced Perception System)
**Prerequisites:** v0.15.6b Complete (Three-Layer Examination System), v0.15.6a Complete (Passive Perception System), v0.15.0 Complete (Dice Pool Refactor)
**Estimated Tests:** ~2 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ObjectCategory Enum](#4-objectcategory-enum)
5. [ObjectDescriptor Entity](#5-objectdescriptor-entity)
6. [IObjectDescriptorService Interface](#6-iobjectdescriptorservice-interface)
7. [Data Model Changes](#7-data-model-changes)
8. [Configuration File Schema](#8-configuration-file-schema)
9. [Descriptor Content Specifications](#9-descriptor-content-specifications)
10. [Logging Specifications](#10-logging-specifications)
11. [Unit Testing Requirements](#11-unit-testing-requirements)
12. [Use Cases](#12-use-cases)
13. [Deliverable Checklist](#13-deliverable-checklist)
14. [Acceptance Criteria](#14-acceptance-criteria)
15. [Dependencies](#15-dependencies)
16. [Future Considerations](#16-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification defines the Object Category Descriptors system, which provides category-specific examination text for objects in the game world. Building upon the Three-Layer Examination System (v0.15.6b), this phase introduces:

- **ObjectCategory enum**: Categorizes objects (Door, Machinery, Decorative, Container, Furniture, Environmental, Creature)
- **ObjectDescriptor entity**: Stores layered descriptions with optional biome affinity
- **Weighted variant selection**: Randomizes descriptor text for variety
- **Configuration-driven descriptors**: Loaded from `examination-descriptors.json`

This system provides the content foundation for the examination system, enabling rich, varied descriptions that respond to object type, examination depth, and biome context.

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Enums** | `ObjectCategory` |
| **Entities** | `ObjectDescriptor` |
| **Services** | `IObjectDescriptorService`, `ObjectDescriptorService` |
| **Configuration** | `examination-descriptors.json` (~100 descriptors) |
| **Tests** | ~2 unit tests |

### 1.3 Architectural Significance

This version establishes the **Category-Based Descriptor Pattern**:

- **Object Categorization**: All examinable objects belong to a category
- **Type Granularity**: Categories contain specific types (e.g., Door → LockedDoor, BlastDoor)
- **Layer Association**: Each descriptor targets a specific examination layer (1, 2, or 3)
- **Biome Affinity**: Descriptors can be universal or biome-specific
- **Weighted Selection**: Multiple descriptors per layer allow randomized variety

---

## 2. Feature Overview

```
v0.15.6c Object Category Descriptors
├── ObjectCategory Enum
│   ├── Door - Locked, blast, security doors
│   ├── Machinery - Consoles, servitors, devices
│   ├── Decorative - Inscriptions, skeletons, art
│   ├── Container - Chests, lockers, crates
│   ├── Furniture - Tables, chairs, beds
│   ├── Environmental - Walls, floors, features
│   └── Creature - Corpses, remains
├── ObjectDescriptor Entity
│   ├── DescriptorId - Unique identifier
│   ├── ObjectCategory - Category enum value
│   ├── ObjectType - Specific type (LockedDoor, Console)
│   ├── Layer - Target examination layer (1, 2, 3)
│   ├── RequiredDc - DC for this layer (0, 12, 18)
│   ├── BiomeAffinity - Biome restriction (null = universal)
│   ├── DescriptorText - The description content
│   ├── RevealsHint - Links to puzzle hint (v0.15.6e)
│   ├── RevealsSolutionId - Puzzle solution link
│   └── Weight - Variant selection weight
├── IObjectDescriptorService Interface
│   ├── GetDescriptor() - Get single descriptor by criteria
│   ├── GetDescriptorsForObject() - Get all layers for object
│   └── GetDescriptorsByCategory() - Get all descriptors in category
└── Configuration
    └── examination-descriptors.json (~100 descriptors)
```

### 2.1 Scope Alignment

**In Scope:**
- `ObjectCategory` enum with seven categories
- `ObjectDescriptor` entity with all specified properties
- `IObjectDescriptorService` interface definition
- `ObjectDescriptorService` implementation
- Configuration schema for `examination-descriptors.json`
- ~100 descriptors across categories (~20 Door, ~30 Machinery, ~25 Decorative, ~15 Container, ~10 Environmental)
- Weighted variant selection for randomized text
- Biome affinity filtering

**Out of Scope:**
- Flora & fauna observation (v0.15.6d)
- Puzzle hint integration logic (v0.15.6e)
- Search command enhancement (v0.15.6f)
- Investigation command (v0.15.6g)
- Specialization examination bonuses (v0.15.6h)
- Room entry integration (v0.15.6i)

---

## 3. Architecture Diagrams

### 3.1 Descriptor Resolution Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                   DESCRIPTOR RESOLUTION FLOW                         │
└─────────────────────────────────────────────────────────────────────┘

    ExaminationService requests descriptors for object
           │
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    IDENTIFY OBJECT CATEGORY                          │
├─────────────────────────────────────────────────────────────────────┤
│  1. Get object from repository                                       │
│  2. Resolve ObjectCategory from object definition                    │
│  3. Resolve ObjectType (e.g., LockedDoor, Console)                  │
│  4. Get current BiomeId from room context                           │
└─────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    QUERY DESCRIPTOR REPOSITORY                       │
├─────────────────────────────────────────────────────────────────────┤
│  Query: Category + ObjectType + Layer + (BiomeId or null)           │
│                                                                      │
│  Filter order:                                                       │
│    1. Exact match: Category + Type + Layer + Biome                  │
│    2. Universal: Category + Type + Layer + (Biome = null)           │
│    3. Fallback: Category + Layer only (generic)                     │
└─────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    WEIGHTED VARIANT SELECTION                        │
├─────────────────────────────────────────────────────────────────────┤
│  If multiple descriptors match:                                      │
│    1. Sum all weights                                                │
│    2. Generate random value in range                                 │
│    3. Select descriptor based on cumulative weight                   │
│                                                                      │
│  Example:                                                            │
│    Descriptor A (weight 2) → 0-1                                    │
│    Descriptor B (weight 1) → 2                                      │
│    Random(3) = 1 → Select A                                         │
└─────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     RETURN DESCRIPTOR TEXT                           │
├─────────────────────────────────────────────────────────────────────┤
│  Return ObjectDescriptor with:                                       │
│    - DescriptorText for display                                     │
│    - RevealsHint flag (for v0.15.6e integration)                    │
│    - RevealsSolutionId (for v0.15.6e integration)                   │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  (No changes in this phase - uses existing IGameRenderer)           │
│  ExaminationResult display unchanged                                 │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │               ObjectDescriptorService                          │  │
│  ├───────────────────────────────────────────────────────────────┤  │
│  │  + GetDescriptor(category, type, layer, biome?)               │  │
│  │      : ObjectDescriptor?                                      │  │
│  │  + GetDescriptorsForObject(category, type, biome?)            │  │
│  │      : IReadOnlyList<ObjectDescriptor>                        │  │
│  │  + GetDescriptorsByCategory(category)                         │  │
│  │      : IReadOnlyList<ObjectDescriptor>                        │  │
│  │                                                               │  │
│  │  - SelectWeightedVariant(descriptors): ObjectDescriptor       │  │
│  │  - FilterByBiome(descriptors, biome): IEnumerable             │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                      │
│  ExaminationService (modified)                                       │
│  └── Calls ObjectDescriptorService for layer descriptions           │
│                                                                      │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │           IObjectDescriptorRepository                          │  │
│  ├───────────────────────────────────────────────────────────────┤  │
│  │  + GetByCategory(category): IReadOnlyList<ObjectDescriptor>   │  │
│  │  + GetByTypeAndLayer(category, type, layer)                   │  │
│  │      : IReadOnlyList<ObjectDescriptor>                        │  │
│  │  + GetAll(): IReadOnlyList<ObjectDescriptor>                  │  │
│  └───────────────────────────────────────────────────────────────┘  │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         DOMAIN LAYER                                 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐  ┌────────────────────────────────────┐   │
│  │   ObjectCategory    │  │         ObjectDescriptor           │   │
│  │       (Enum)        │  │           (Entity)                 │   │
│  ├─────────────────────┤  ├────────────────────────────────────┤   │
│  │ Door                │  │ DescriptorId: string               │   │
│  │ Machinery           │  │ ObjectCategory: ObjectCategory     │   │
│  │ Decorative          │  │ ObjectType: string                 │   │
│  │ Container           │  │ Layer: int (1, 2, 3)               │   │
│  │ Furniture           │  │ RequiredDc: int (0, 12, 18)        │   │
│  │ Environmental       │  │ BiomeAffinity: string?             │   │
│  │ Creature            │  │ DescriptorText: string             │   │
│  └─────────────────────┘  │ RevealsHint: bool                  │   │
│                           │ RevealsSolutionId: string?         │   │
│                           │ Weight: int                        │   │
│                           └────────────────────────────────────┘   │
│                                                                     │
│  (From v0.15.6b)                                                    │
│  ┌─────────────────────┐  ┌────────────────────────────────────┐   │
│  │  ExaminationLayer   │  │        ExaminationResult           │   │
│  │       (Enum)        │  │         (Value Object)             │   │
│  └─────────────────────┘  └────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 Category-Type Hierarchy

```
┌─────────────────────────────────────────────────────────────────────┐
│                    OBJECT CATEGORY HIERARCHY                         │
└─────────────────────────────────────────────────────────────────────┘

    ObjectCategory (Enum)
           │
           ├── Door (~20 descriptors)
           │   ├── LockedDoor
           │   ├── BlastDoor
           │   ├── SecurityDoor
           │   ├── JammedDoor
           │   ├── AirlockDoor
           │   └── SecretDoor
           │
           ├── Machinery (~30 descriptors)
           │   ├── Console
           │   ├── Terminal
           │   ├── Servitor
           │   ├── PowerUnit
           │   ├── ControlPanel
           │   ├── EnvironmentalUnit
           │   ├── HolographicDisplay
           │   └── Reactor
           │
           ├── Decorative (~25 descriptors)
           │   ├── Inscription
           │   ├── Skeleton
           │   ├── Mural
           │   ├── Statue
           │   ├── Tapestry
           │   ├── RunicCarving
           │   └── Trophy
           │
           ├── Container (~15 descriptors)
           │   ├── Chest
           │   ├── Locker
           │   ├── Crate
           │   ├── Compartment
           │   ├── Safe
           │   └── StoragePod
           │
           ├── Furniture (~10 descriptors)
           │   ├── Table
           │   ├── Chair
           │   ├── Bed
           │   ├── Workbench
           │   └── Shelf
           │
           ├── Environmental (~10 descriptors)
           │   ├── Wall
           │   ├── Floor
           │   ├── Ceiling
           │   ├── Pillar
           │   ├── Vent
           │   └── Pipe
           │
           └── Creature (~0 in this phase)
               └── (Defined, but descriptors in v0.15.6d)

    Total: ~100 descriptors
```

### 3.4 Biome Affinity Filtering

```
┌─────────────────────────────────────────────────────────────────────┐
│                     BIOME AFFINITY FILTERING                         │
└─────────────────────────────────────────────────────────────────────┘

    Request: Get descriptor for Console, Layer 2, Biome "Muspelheim"
           │
           ▼
┌───────────────────────────────────────────────────────────────────┐
│                    DESCRIPTOR CANDIDATES                           │
├───────────────────────────────────────────────────────────────────┤
│  console-detailed-01 | Layer 2 | BiomeAffinity: null (universal) │
│  console-detailed-02 | Layer 2 | BiomeAffinity: null (universal) │
│  console-detailed-03 | Layer 2 | BiomeAffinity: "Muspelheim"     │ ← Biome match
│  console-detailed-04 | Layer 2 | BiomeAffinity: "The Roots"      │ ✗ Wrong biome
└───────────────────────────────────────────────────────────────────┘
           │
           ▼
┌───────────────────────────────────────────────────────────────────┐
│                     FILTERING LOGIC                                │
├───────────────────────────────────────────────────────────────────┤
│  Priority 1: Biome-specific descriptors (BiomeAffinity matches)   │
│    → console-detailed-03 included                                 │
│                                                                   │
│  Priority 2: Universal descriptors (BiomeAffinity = null)         │
│    → console-detailed-01, console-detailed-02 included            │
│                                                                   │
│  Excluded: Other biome descriptors                                │
│    → console-detailed-04 excluded (The Roots ≠ Muspelheim)        │
└───────────────────────────────────────────────────────────────────┘
           │
           ▼
┌───────────────────────────────────────────────────────────────────┐
│                   WEIGHTED SELECTION                               │
├───────────────────────────────────────────────────────────────────┤
│  Eligible: console-detailed-01, 02, 03                            │
│  Biome-specific given higher effective weight (×2)                │
│                                                                   │
│  console-detailed-01: weight 1                                    │
│  console-detailed-02: weight 1                                    │
│  console-detailed-03: weight 1 × 2 = 2 (biome boost)              │
│                                                                   │
│  Total: 4                                                         │
│  Random selection favors biome-specific descriptor                │
└───────────────────────────────────────────────────────────────────┘
```

---

## 4. ObjectCategory Enum

### 4.1 Purpose

The `ObjectCategory` enum categorizes all examinable objects in the game world, providing the primary filter for descriptor lookup.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/ObjectCategory.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categorizes examinable objects in the game world.
/// </summary>
/// <remarks>
/// <para>
/// Each category represents a broad class of objects that share
/// similar examination patterns and descriptor styles:
/// </para>
/// <list type="bullet">
///   <item><description>Door: Entry points, locks, security barriers</description></item>
///   <item><description>Machinery: Technical equipment, consoles, devices</description></item>
///   <item><description>Decorative: Art, inscriptions, remains, trophies</description></item>
///   <item><description>Container: Storage objects, chests, lockers</description></item>
///   <item><description>Furniture: Functional furniture, workstations</description></item>
///   <item><description>Environmental: Structural elements, room features</description></item>
///   <item><description>Creature: Living or deceased creatures, remains</description></item>
/// </list>
/// <para>
/// Object types within each category provide further granularity
/// (e.g., Door → LockedDoor, BlastDoor, SecurityDoor).
/// </para>
/// </remarks>
public enum ObjectCategory
{
    /// <summary>
    /// Entry points and barriers including locked, blast, and security doors.
    /// </summary>
    /// <remarks>
    /// Door examinations typically reveal lock mechanisms (Layer 2)
    /// and bypass methods or historical significance (Layer 3).
    /// Types: LockedDoor, BlastDoor, SecurityDoor, JammedDoor, AirlockDoor, SecretDoor
    /// </remarks>
    Door = 1,

    /// <summary>
    /// Technical equipment including consoles, terminals, and devices.
    /// </summary>
    /// <remarks>
    /// Machinery examinations reveal operational status (Layer 2)
    /// and override methods or internal schematics (Layer 3).
    /// Types: Console, Terminal, Servitor, PowerUnit, ControlPanel, EnvironmentalUnit
    /// </remarks>
    Machinery = 2,

    /// <summary>
    /// Artistic and historical objects including inscriptions, murals, and remains.
    /// </summary>
    /// <remarks>
    /// Decorative examinations reveal craftsmanship (Layer 2)
    /// and historical context or hidden meanings (Layer 3).
    /// Types: Inscription, Skeleton, Mural, Statue, Tapestry, RunicCarving, Trophy
    /// </remarks>
    Decorative = 3,

    /// <summary>
    /// Storage objects including chests, lockers, and crates.
    /// </summary>
    /// <remarks>
    /// Container examinations reveal lock complexity (Layer 2)
    /// and origin, previous owners, or hidden compartments (Layer 3).
    /// Types: Chest, Locker, Crate, Compartment, Safe, StoragePod
    /// </remarks>
    Container = 4,

    /// <summary>
    /// Functional furniture including tables, chairs, and workbenches.
    /// </summary>
    /// <remarks>
    /// Furniture examinations reveal condition and quality (Layer 2)
    /// and craftsmanship details or hidden features (Layer 3).
    /// Types: Table, Chair, Bed, Workbench, Shelf
    /// </remarks>
    Furniture = 5,

    /// <summary>
    /// Structural elements including walls, floors, and room features.
    /// </summary>
    /// <remarks>
    /// Environmental examinations reveal material composition (Layer 2)
    /// and structural weaknesses or hidden passages (Layer 3).
    /// Types: Wall, Floor, Ceiling, Pillar, Vent, Pipe
    /// </remarks>
    Environmental = 6,

    /// <summary>
    /// Living or deceased creatures and their remains.
    /// </summary>
    /// <remarks>
    /// Creature examinations reveal species identification (Layer 2)
    /// and cause of death, behavior patterns, or harvestable materials (Layer 3).
    /// Note: Flora/fauna descriptors are defined in v0.15.6d.
    /// Types: Corpse, Skeleton, BeastRemains
    /// </remarks>
    Creature = 7
}
```

### 4.3 Category Coverage Targets

| Category | Target Descriptors | Object Types |
|----------|-------------------|--------------|
| Door | ~20 | LockedDoor, BlastDoor, SecurityDoor, JammedDoor, AirlockDoor, SecretDoor |
| Machinery | ~30 | Console, Terminal, Servitor, PowerUnit, ControlPanel, EnvironmentalUnit, HolographicDisplay, Reactor |
| Decorative | ~25 | Inscription, Skeleton, Mural, Statue, Tapestry, RunicCarving, Trophy |
| Container | ~15 | Chest, Locker, Crate, Compartment, Safe, StoragePod |
| Furniture | ~10 | Table, Chair, Bed, Workbench, Shelf |
| Environmental | ~10 | Wall, Floor, Ceiling, Pillar, Vent, Pipe |
| Creature | ~0 | (Deferred to v0.15.6d for flora/fauna) |
| **Total** | **~100** | |

---

## 5. ObjectDescriptor Entity

### 5.1 Purpose

The `ObjectDescriptor` entity stores category-specific examination text with optional biome affinity and weighted variant selection support.

### 5.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Entities/ObjectDescriptor.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

/// <summary>
/// Stores category-specific examination text for objects.
/// </summary>
/// <remarks>
/// <para>
/// Each descriptor targets a specific combination of:
/// - Object category (Door, Machinery, etc.)
/// - Object type within category (LockedDoor, Console, etc.)
/// - Examination layer (1 = Cursory, 2 = Detailed, 3 = Expert)
/// - Optional biome affinity (null = universal)
/// </para>
/// <para>
/// Multiple descriptors can exist for the same criteria with different
/// weights, allowing randomized variety in examination text.
/// </para>
/// <para>
/// Descriptors at Layer 3 may reveal puzzle hints (v0.15.6e integration).
/// </para>
/// </remarks>
public class ObjectDescriptor : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this descriptor.
    /// </summary>
    /// <remarks>
    /// Format: "{type}-{layer}-{index}" (e.g., "locked-door-cursory-01")
    /// </remarks>
    public string DescriptorId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the object category this descriptor applies to.
    /// </summary>
    public ObjectCategory ObjectCategory { get; private set; }

    /// <summary>
    /// Gets the specific object type within the category.
    /// </summary>
    /// <remarks>
    /// Examples: "LockedDoor", "BlastDoor", "Console", "Terminal"
    /// </remarks>
    public string ObjectType { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the examination layer this descriptor targets (1, 2, or 3).
    /// </summary>
    /// <remarks>
    /// Layer 1 = Cursory (DC 0), Layer 2 = Detailed (DC 12), Layer 3 = Expert (DC 18)
    /// </remarks>
    public int Layer { get; private set; }

    /// <summary>
    /// Gets the DC required to unlock this descriptor's layer.
    /// </summary>
    /// <remarks>
    /// Layer 1: DC 0 (auto), Layer 2: DC 12, Layer 3: DC 18
    /// </remarks>
    public int RequiredDc { get; private set; }

    /// <summary>
    /// Gets the biome affinity for this descriptor, or null if universal.
    /// </summary>
    /// <remarks>
    /// When set, this descriptor is only used in the specified biome.
    /// When null, the descriptor is available in all biomes.
    /// Biome-specific descriptors are preferred over universal ones.
    /// </remarks>
    public string? BiomeAffinity { get; private set; }

    /// <summary>
    /// Gets the examination text displayed to the player.
    /// </summary>
    public string DescriptorText { get; private set; } = string.Empty;

    /// <summary>
    /// Gets whether this descriptor reveals a puzzle hint (Layer 3 only).
    /// </summary>
    /// <remarks>
    /// When true, examining at Layer 3 triggers hint integration (v0.15.6e).
    /// </remarks>
    public bool RevealsHint { get; private set; }

    /// <summary>
    /// Gets the puzzle solution ID revealed by this descriptor, if any.
    /// </summary>
    /// <remarks>
    /// Links to PuzzleHint definitions (v0.15.6e).
    /// Only relevant when RevealsHint is true.
    /// </remarks>
    public string? RevealsSolutionId { get; private set; }

    /// <summary>
    /// Gets the weight for variant selection (higher = more likely).
    /// </summary>
    /// <remarks>
    /// Default: 1. Multiple descriptors with the same criteria use
    /// weighted random selection for variety.
    /// </remarks>
    public int Weight { get; private set; } = 1;

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private ObjectDescriptor() { }

    /// <summary>
    /// Creates a new object descriptor.
    /// </summary>
    /// <param name="descriptorId">Unique identifier for this descriptor.</param>
    /// <param name="category">The object category.</param>
    /// <param name="objectType">The specific object type.</param>
    /// <param name="layer">The examination layer (1, 2, or 3).</param>
    /// <param name="descriptorText">The examination text.</param>
    /// <param name="biomeAffinity">Optional biome restriction.</param>
    /// <param name="weight">Selection weight (default: 1).</param>
    /// <param name="revealsHint">Whether this reveals a puzzle hint.</param>
    /// <param name="solutionId">The puzzle solution ID to reveal.</param>
    /// <returns>A new ObjectDescriptor instance.</returns>
    public static ObjectDescriptor Create(
        string descriptorId,
        ObjectCategory category,
        string objectType,
        int layer,
        string descriptorText,
        string? biomeAffinity = null,
        int weight = 1,
        bool revealsHint = false,
        string? solutionId = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(descriptorId);
        ArgumentException.ThrowIfNullOrWhiteSpace(objectType);
        ArgumentException.ThrowIfNullOrWhiteSpace(descriptorText);

        if (layer < 1 || layer > 3)
        {
            throw new ArgumentOutOfRangeException(nameof(layer), "Layer must be 1, 2, or 3.");
        }

        if (weight < 1)
        {
            throw new ArgumentOutOfRangeException(nameof(weight), "Weight must be at least 1.");
        }

        var requiredDc = layer switch
        {
            1 => 0,
            2 => 12,
            3 => 18,
            _ => 0
        };

        return new ObjectDescriptor
        {
            DescriptorId = descriptorId,
            ObjectCategory = category,
            ObjectType = objectType,
            Layer = layer,
            RequiredDc = requiredDc,
            BiomeAffinity = biomeAffinity,
            DescriptorText = descriptorText,
            RevealsHint = revealsHint,
            RevealsSolutionId = solutionId,
            Weight = weight
        };
    }

    /// <summary>
    /// Gets whether this descriptor is universal (not biome-specific).
    /// </summary>
    public bool IsUniversal => BiomeAffinity is null;

    /// <summary>
    /// Gets the layer name for display purposes.
    /// </summary>
    public string LayerName => Layer switch
    {
        1 => "Cursory",
        2 => "Detailed",
        3 => "Expert",
        _ => "Unknown"
    };

    /// <summary>
    /// Checks if this descriptor matches the specified biome.
    /// </summary>
    /// <param name="biomeId">The biome to check.</param>
    /// <returns>True if this descriptor is valid for the biome.</returns>
    /// <remarks>
    /// Universal descriptors (BiomeAffinity = null) match all biomes.
    /// Biome-specific descriptors only match their specified biome.
    /// </remarks>
    public bool MatchesBiome(string? biomeId)
    {
        if (IsUniversal)
        {
            return true;
        }

        return string.Equals(BiomeAffinity, biomeId, StringComparison.OrdinalIgnoreCase);
    }
}
```

---

## 6. IObjectDescriptorService Interface

### 6.1 Purpose

The `IObjectDescriptorService` interface defines the contract for retrieving object descriptors with category, type, layer, and biome filtering.

### 6.2 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IObjectDescriptorService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Service for retrieving object examination descriptors.
/// </summary>
/// <remarks>
/// <para>
/// Provides category-based descriptor lookup with:
/// - Object type filtering
/// - Layer-specific retrieval
/// - Biome affinity matching
/// - Weighted variant selection
/// </para>
/// <para>
/// Used by ExaminationService to get layer descriptions for objects.
/// </para>
/// </remarks>
public interface IObjectDescriptorService
{
    /// <summary>
    /// Gets a single descriptor for the specified criteria.
    /// </summary>
    /// <param name="category">The object category.</param>
    /// <param name="objectType">The specific object type.</param>
    /// <param name="layer">The examination layer (1, 2, or 3).</param>
    /// <param name="biomeId">The current biome for affinity matching.</param>
    /// <returns>A descriptor matching the criteria, or null if none found.</returns>
    /// <remarks>
    /// If multiple descriptors match, uses weighted random selection.
    /// Biome-specific descriptors are preferred over universal ones.
    /// </remarks>
    ObjectDescriptor? GetDescriptor(
        ObjectCategory category,
        string objectType,
        int layer,
        string? biomeId = null);

    /// <summary>
    /// Gets all layer descriptors for an object type.
    /// </summary>
    /// <param name="category">The object category.</param>
    /// <param name="objectType">The specific object type.</param>
    /// <param name="biomeId">The current biome for affinity matching.</param>
    /// <returns>Descriptors for all three layers (if available).</returns>
    /// <remarks>
    /// Returns one descriptor per layer (1, 2, 3) based on weighted selection.
    /// May return fewer than 3 if some layers have no descriptors defined.
    /// </remarks>
    IReadOnlyList<ObjectDescriptor> GetDescriptorsForObject(
        ObjectCategory category,
        string objectType,
        string? biomeId = null);

    /// <summary>
    /// Gets all descriptors in a category.
    /// </summary>
    /// <param name="category">The object category.</param>
    /// <returns>All descriptors in the category.</returns>
    /// <remarks>
    /// Returns all descriptors without filtering by type or biome.
    /// Useful for category statistics or validation.
    /// </remarks>
    IReadOnlyList<ObjectDescriptor> GetDescriptorsByCategory(ObjectCategory category);

    /// <summary>
    /// Gets the total count of descriptors loaded.
    /// </summary>
    /// <returns>The total descriptor count.</returns>
    int GetTotalDescriptorCount();
}
```

### 6.3 Service Implementation

**File:** `src/Core/RuneAndRust.Application/Services/ObjectDescriptorService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Implementation of the object descriptor service.
/// </summary>
public class ObjectDescriptorService : IObjectDescriptorService
{
    /// <summary>
    /// Weight multiplier for biome-specific descriptors.
    /// </summary>
    private const int BiomeAffinityBoost = 2;

    private readonly IObjectDescriptorRepository _repository;
    private readonly Random _random;
    private readonly ILogger<ObjectDescriptorService> _logger;

    /// <summary>
    /// Initializes a new instance of ObjectDescriptorService.
    /// </summary>
    public ObjectDescriptorService(
        IObjectDescriptorRepository repository,
        ILogger<ObjectDescriptorService> logger)
    {
        _repository = repository;
        _random = new Random();
        _logger = logger;
    }

    /// <inheritdoc />
    public ObjectDescriptor? GetDescriptor(
        ObjectCategory category,
        string objectType,
        int layer,
        string? biomeId = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(objectType);

        if (layer < 1 || layer > 3)
        {
            throw new ArgumentOutOfRangeException(nameof(layer), "Layer must be 1, 2, or 3.");
        }

        // Get all descriptors for category, type, and layer
        var candidates = _repository.GetByTypeAndLayer(category, objectType, layer);

        if (candidates.Count == 0)
        {
            _logger.LogDebug(
                "No descriptors found for {Category}/{Type} Layer {Layer}",
                category, objectType, layer);
            return null;
        }

        // Filter by biome
        var eligible = FilterByBiome(candidates, biomeId).ToList();

        if (eligible.Count == 0)
        {
            _logger.LogDebug(
                "No biome-compatible descriptors for {Category}/{Type} Layer {Layer} in {Biome}",
                category, objectType, layer, biomeId ?? "universal");
            return null;
        }

        // Select weighted variant
        var selected = SelectWeightedVariant(eligible, biomeId);

        _logger.LogDebug(
            "Selected descriptor {DescriptorId} for {Category}/{Type} Layer {Layer}",
            selected.DescriptorId, category, objectType, layer);

        return selected;
    }

    /// <inheritdoc />
    public IReadOnlyList<ObjectDescriptor> GetDescriptorsForObject(
        ObjectCategory category,
        string objectType,
        string? biomeId = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(objectType);

        var result = new List<ObjectDescriptor>();

        // Get one descriptor per layer
        for (int layer = 1; layer <= 3; layer++)
        {
            var descriptor = GetDescriptor(category, objectType, layer, biomeId);
            if (descriptor is not null)
            {
                result.Add(descriptor);
            }
        }

        return result;
    }

    /// <inheritdoc />
    public IReadOnlyList<ObjectDescriptor> GetDescriptorsByCategory(ObjectCategory category)
    {
        return _repository.GetByCategory(category);
    }

    /// <inheritdoc />
    public int GetTotalDescriptorCount()
    {
        return _repository.GetAll().Count;
    }

    /// <summary>
    /// Filters descriptors by biome affinity.
    /// </summary>
    /// <param name="descriptors">The descriptors to filter.</param>
    /// <param name="biomeId">The target biome.</param>
    /// <returns>Descriptors valid for the biome.</returns>
    private static IEnumerable<ObjectDescriptor> FilterByBiome(
        IEnumerable<ObjectDescriptor> descriptors,
        string? biomeId)
    {
        foreach (var descriptor in descriptors)
        {
            // Universal descriptors always match
            if (descriptor.IsUniversal)
            {
                yield return descriptor;
            }
            // Biome-specific descriptors match only their biome
            else if (descriptor.MatchesBiome(biomeId))
            {
                yield return descriptor;
            }
            // Skip descriptors for other biomes
        }
    }

    /// <summary>
    /// Selects a descriptor using weighted random selection.
    /// </summary>
    /// <param name="descriptors">The eligible descriptors.</param>
    /// <param name="biomeId">The current biome (for affinity boost).</param>
    /// <returns>The selected descriptor.</returns>
    private ObjectDescriptor SelectWeightedVariant(
        IReadOnlyList<ObjectDescriptor> descriptors,
        string? biomeId)
    {
        if (descriptors.Count == 1)
        {
            return descriptors[0];
        }

        // Calculate effective weights (biome-specific get boost)
        var effectiveWeights = new List<int>();
        var totalWeight = 0;

        foreach (var descriptor in descriptors)
        {
            var weight = descriptor.Weight;

            // Boost biome-specific descriptors
            if (!descriptor.IsUniversal && descriptor.MatchesBiome(biomeId))
            {
                weight *= BiomeAffinityBoost;
            }

            effectiveWeights.Add(weight);
            totalWeight += weight;
        }

        // Random selection based on cumulative weight
        var roll = _random.Next(totalWeight);
        var cumulative = 0;

        for (int i = 0; i < descriptors.Count; i++)
        {
            cumulative += effectiveWeights[i];
            if (roll < cumulative)
            {
                return descriptors[i];
            }
        }

        // Fallback (should not reach here)
        return descriptors[^1];
    }
}
```

### 6.4 Repository Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IObjectDescriptorRepository.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Repository for object examination descriptors.
/// </summary>
public interface IObjectDescriptorRepository
{
    /// <summary>
    /// Gets all descriptors in a category.
    /// </summary>
    /// <param name="category">The object category.</param>
    /// <returns>All descriptors in the category.</returns>
    IReadOnlyList<ObjectDescriptor> GetByCategory(ObjectCategory category);

    /// <summary>
    /// Gets descriptors for a specific type and layer.
    /// </summary>
    /// <param name="category">The object category.</param>
    /// <param name="objectType">The specific object type.</param>
    /// <param name="layer">The examination layer (1, 2, or 3).</param>
    /// <returns>Matching descriptors.</returns>
    IReadOnlyList<ObjectDescriptor> GetByTypeAndLayer(
        ObjectCategory category,
        string objectType,
        int layer);

    /// <summary>
    /// Gets all loaded descriptors.
    /// </summary>
    /// <returns>All descriptors.</returns>
    IReadOnlyList<ObjectDescriptor> GetAll();
}
```

---

## 7. Data Model Changes

### 7.1 New Enums

| Enum | Layer | Description |
|------|-------|-------------|
| `ObjectCategory` | Domain | Categorizes examinable objects (7 values) |

### 7.2 New Entities

| Entity | Layer | Description |
|--------|-------|-------------|
| `ObjectDescriptor` | Domain | Stores layered examination text with biome affinity |

### 7.3 New Interfaces

| Interface | Layer | Description |
|-----------|-------|-------------|
| `IObjectDescriptorService` | Application | Descriptor retrieval with filtering |
| `IObjectDescriptorRepository` | Application | Descriptor data access |

### 7.4 New Services

| Service | Layer | Description |
|---------|-------|-------------|
| `ObjectDescriptorService` | Application | Weighted descriptor selection |

### 7.5 Modified Components

| Component | Modification |
|-----------|--------------|
| `ExaminationService.GetLayerDescriptions()` | Now calls `ObjectDescriptorService` for category-specific text |

---

## 8. Configuration File Schema

### 8.1 examination-descriptors.json

**File:** `config/examination-descriptors.json`

```json
{
  "$schema": "./schemas/examination-descriptors.schema.json",
  "version": "0.15.6c",
  "descriptors": [
    {
      "id": "locked-door-cursory-01",
      "category": "Door",
      "type": "LockedDoor",
      "layer": 1,
      "dc": 0,
      "text": "A heavy iron door, currently locked.",
      "weight": 1
    },
    {
      "id": "locked-door-detailed-01",
      "category": "Door",
      "type": "LockedDoor",
      "layer": 2,
      "dc": 12,
      "text": "A heavy iron door reinforced with Jötun metalwork. The lock mechanism is complex—Jötun engineering, designed to resist forced entry. No visible signs of recent use; dust coats the handle.",
      "weight": 1
    },
    {
      "id": "locked-door-expert-01",
      "category": "Door",
      "type": "LockedDoor",
      "layer": 3,
      "dc": 18,
      "text": "A heavy iron door bearing the seal of Level 7 Security Clearance. The lock mechanism uses a combination of physical tumblers and runic authentication. Age has corrupted the rune-lock—a skilled lockpicker might bypass the physical mechanism, or someone with Galdr knowledge could attempt to restore the runic component.",
      "weight": 1,
      "revealsHint": true,
      "solutionId": "door-bypass-galdr"
    },
    {
      "id": "console-cursory-01",
      "category": "Machinery",
      "type": "Console",
      "layer": 1,
      "dc": 0,
      "text": "A Jötun control console, its surface covered in unfamiliar glyphs.",
      "weight": 1
    },
    {
      "id": "console-detailed-01",
      "category": "Machinery",
      "type": "Console",
      "layer": 2,
      "dc": 12,
      "text": "A Jötun Environmental Control Console, designation ENV-4422. Status indicators glow a steady amber—the system is in standby mode. Several interface panels are accessible, though their functions are not immediately apparent.",
      "weight": 1
    },
    {
      "id": "console-detailed-muspelheim-01",
      "category": "Machinery",
      "type": "Console",
      "layer": 2,
      "dc": 12,
      "biomeAffinity": "Muspelheim",
      "text": "A Jötun Thermal Regulation Console, its casing scorched by centuries of exposure to Muspelheim's heat. Despite the damage, status indicators pulse with amber light—remarkably, the system remains functional. Heat-resistant coolant lines snake from its base.",
      "weight": 1
    },
    {
      "id": "console-expert-01",
      "category": "Machinery",
      "type": "Console",
      "layer": 3,
      "dc": 18,
      "text": "A Jötun Environmental Control Console, Designation ENV-4422, capable of manipulating atmospheric conditions within this sector. The console could potentially be used to divert power, vent atmospheres, or even access locked-down emergency protocols. A maintenance override exists—bypassing the security protocols requires either a valid authorization key or successful manipulation of the runic command interface.",
      "weight": 1,
      "revealsHint": true,
      "solutionId": "console-override"
    }
  ]
}
```

### 8.2 JSON Schema

**File:** `config/schemas/examination-descriptors.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Examination Descriptors Configuration",
  "description": "Object examination descriptors for the three-layer examination system",
  "type": "object",
  "required": ["version", "descriptors"],
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema reference"
    },
    "version": {
      "type": "string",
      "description": "Configuration version",
      "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+[a-z]?$"
    },
    "descriptors": {
      "type": "array",
      "description": "Array of object descriptors",
      "items": {
        "type": "object",
        "required": ["id", "category", "type", "layer", "dc", "text"],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique descriptor identifier",
            "pattern": "^[a-z0-9-]+$"
          },
          "category": {
            "type": "string",
            "description": "Object category",
            "enum": ["Door", "Machinery", "Decorative", "Container", "Furniture", "Environmental", "Creature"]
          },
          "type": {
            "type": "string",
            "description": "Specific object type within category"
          },
          "layer": {
            "type": "integer",
            "description": "Examination layer (1, 2, or 3)",
            "minimum": 1,
            "maximum": 3
          },
          "dc": {
            "type": "integer",
            "description": "DC required for this layer (0, 12, or 18)",
            "enum": [0, 12, 18]
          },
          "text": {
            "type": "string",
            "description": "The examination text displayed to the player",
            "minLength": 10
          },
          "biomeAffinity": {
            "type": "string",
            "description": "Biome restriction (omit for universal)"
          },
          "weight": {
            "type": "integer",
            "description": "Selection weight (default: 1)",
            "minimum": 1,
            "default": 1
          },
          "revealsHint": {
            "type": "boolean",
            "description": "Whether this reveals a puzzle hint",
            "default": false
          },
          "solutionId": {
            "type": "string",
            "description": "Puzzle solution ID to reveal"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "additionalProperties": false
}
```

### 8.3 Configuration Loading

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Repositories/ObjectDescriptorRepository.cs`

```csharp
namespace RuneAndRust.Infrastructure.Repositories;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Repository that loads descriptors from examination-descriptors.json.
/// </summary>
public class ObjectDescriptorRepository : IObjectDescriptorRepository
{
    private readonly List<ObjectDescriptor> _descriptors = new();
    private readonly ILogger<ObjectDescriptorRepository> _logger;

    /// <summary>
    /// Initializes the repository and loads descriptors from configuration.
    /// </summary>
    public ObjectDescriptorRepository(
        string configPath,
        ILogger<ObjectDescriptorRepository> logger)
    {
        _logger = logger;
        LoadDescriptors(configPath);
    }

    /// <inheritdoc />
    public IReadOnlyList<ObjectDescriptor> GetByCategory(ObjectCategory category)
    {
        return _descriptors
            .Where(d => d.ObjectCategory == category)
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<ObjectDescriptor> GetByTypeAndLayer(
        ObjectCategory category,
        string objectType,
        int layer)
    {
        return _descriptors
            .Where(d =>
                d.ObjectCategory == category &&
                string.Equals(d.ObjectType, objectType, StringComparison.OrdinalIgnoreCase) &&
                d.Layer == layer)
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<ObjectDescriptor> GetAll()
    {
        return _descriptors;
    }

    /// <summary>
    /// Loads descriptors from the configuration file.
    /// </summary>
    private void LoadDescriptors(string configPath)
    {
        try
        {
            var json = File.ReadAllText(configPath);
            var config = JsonSerializer.Deserialize<DescriptorConfig>(json, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });

            if (config?.Descriptors is null)
            {
                _logger.LogWarning("No descriptors found in configuration");
                return;
            }

            foreach (var dto in config.Descriptors)
            {
                var category = Enum.Parse<ObjectCategory>(dto.Category, ignoreCase: true);

                var descriptor = ObjectDescriptor.Create(
                    dto.Id,
                    category,
                    dto.Type,
                    dto.Layer,
                    dto.Text,
                    dto.BiomeAffinity,
                    dto.Weight ?? 1,
                    dto.RevealsHint ?? false,
                    dto.SolutionId);

                _descriptors.Add(descriptor);
            }

            _logger.LogInformation(
                "Loaded {Count} object descriptors from configuration",
                _descriptors.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load object descriptors from {Path}", configPath);
            throw;
        }
    }

    /// <summary>
    /// Configuration file DTO.
    /// </summary>
    private record DescriptorConfig(string Version, List<DescriptorDto> Descriptors);

    /// <summary>
    /// Descriptor DTO from JSON.
    /// </summary>
    private record DescriptorDto(
        string Id,
        string Category,
        string Type,
        int Layer,
        int Dc,
        string Text,
        string? BiomeAffinity,
        int? Weight,
        bool? RevealsHint,
        string? SolutionId);
}
```

---

## 9. Descriptor Content Specifications

### 9.1 Door Descriptors (~20)

| Type | Layer | Description Focus |
|------|-------|-------------------|
| LockedDoor | 1 | Basic appearance, locked state |
| LockedDoor | 2 | Lock mechanism, craftsmanship |
| LockedDoor | 3 | Bypass methods, security clearance |
| BlastDoor | 1 | Massive scale, sealed state |
| BlastDoor | 2 | Mechanism type, damage resistance |
| BlastDoor | 3 | Override protocols, structural weak points |
| SecurityDoor | 1 | Reinforced appearance, access panel |
| SecurityDoor | 2 | Biometric requirements, alert status |
| SecurityDoor | 3 | Security protocols, bypass codes |
| JammedDoor | 1 | Partially open, obstruction visible |
| JammedDoor | 2 | Cause of jam, structural stress |
| JammedDoor | 3 | Repair methods, force requirements |
| AirlockDoor | 1 | Double-sealed design, warning lights |
| AirlockDoor | 2 | Pressure indicators, cycle mechanism |
| AirlockDoor | 3 | Emergency protocols, atmosphere data |
| SecretDoor | 1 | (Appears as wall until revealed) |
| SecretDoor | 2 | Subtle seams, hidden mechanism |
| SecretDoor | 3 | Trigger method, destination hints |

### 9.2 Machinery Descriptors (~30)

| Type | Layer | Description Focus |
|------|-------|-------------------|
| Console | 1 | Surface appearance, glyph types |
| Console | 2 | Operational status, interface panels |
| Console | 3 | Override methods, system capabilities |
| Terminal | 1 | Screen state, input interface |
| Terminal | 2 | Access level, connected systems |
| Terminal | 3 | Hacking vectors, data access |
| Servitor | 1 | Mechanical form, current state |
| Servitor | 2 | Damage assessment, function type |
| Servitor | 3 | Reactivation methods, programming |
| PowerUnit | 1 | Size, energy indicators |
| PowerUnit | 2 | Output capacity, connection points |
| PowerUnit | 3 | Overload potential, bypass routes |
| ControlPanel | 1 | Button/lever arrangement |
| ControlPanel | 2 | Control functions, current settings |
| ControlPanel | 3 | Master override, sequence hints |
| EnvironmentalUnit | 1 | Vent/pipe configuration |
| EnvironmentalUnit | 2 | Atmosphere readings, filter status |
| EnvironmentalUnit | 3 | Manipulation options, hazard potential |
| HolographicDisplay | 1 | Flickering image, subject matter |
| HolographicDisplay | 2 | Recording age, data integrity |
| HolographicDisplay | 3 | Hidden layers, access commands |
| Reactor | 1 | Massive scale, containment visible |
| Reactor | 2 | Power output, stability readings |
| Reactor | 3 | Emergency protocols, shutdown codes |

### 9.3 Decorative Descriptors (~25)

| Type | Layer | Description Focus |
|------|-------|-------------------|
| Inscription | 1 | Script type, surface material |
| Inscription | 2 | Language identification, age |
| Inscription | 3 | Full translation, hidden meaning |
| Skeleton | 1 | Species, position |
| Skeleton | 2 | Cause of death, equipment remnants |
| Skeleton | 3 | Identity clues, final moments |
| Mural | 1 | Subject matter, colors |
| Mural | 2 | Artistic style, symbolism |
| Mural | 3 | Historical context, hidden details |
| Statue | 1 | Subject, material, scale |
| Statue | 2 | Craftsmanship, age indicators |
| Statue | 3 | Hidden mechanisms, historical identity |
| Tapestry | 1 | Scene depicted, condition |
| Tapestry | 2 | Weaving technique, origin |
| Tapestry | 3 | Hidden messages, cultural significance |
| RunicCarving | 1 | Rune type, surface |
| RunicCarving | 2 | Runic school, power level |
| RunicCarving | 3 | Activation method, effect |
| Trophy | 1 | Creature type, mounting |
| Trophy | 2 | Kill method, hunter skill |
| Trophy | 3 | Creature significance, hunter identity |

### 9.4 Container Descriptors (~15)

| Type | Layer | Description Focus |
|------|-------|-------------------|
| Chest | 1 | Material, size, lock visible |
| Chest | 2 | Lock complexity, trap indicators |
| Chest | 3 | Trap type, bypass method |
| Locker | 1 | Standard/military design |
| Locker | 2 | Lock type, ownership markings |
| Locker | 3 | Contents hints, security level |
| Crate | 1 | Material, shipping labels |
| Crate | 2 | Origin, handling instructions |
| Crate | 3 | Actual contents hints, smuggling signs |
| Compartment | 1 | Hidden, partially visible |
| Compartment | 2 | Access mechanism, size |
| Compartment | 3 | Original purpose, secret contents |
| Safe | 1 | Reinforced design, lock type |
| Safe | 2 | Security rating, manufacturer |
| Safe | 3 | Crack methods, combination hints |

### 9.5 Environmental Descriptors (~10)

| Type | Layer | Description Focus |
|------|-------|-------------------|
| Wall | 1 | Material, condition |
| Wall | 2 | Construction method, age |
| Wall | 3 | Hollow sections, hidden passages |
| Floor | 1 | Surface material, wear patterns |
| Floor | 2 | Traffic patterns, stains |
| Floor | 3 | Pressure plates, hidden panels |
| Pillar | 1 | Material, structural role |
| Pillar | 2 | Load bearing, carvings |
| Pillar | 3 | Hidden compartments, structural weakness |

---

## 10. Logging Specifications

### 10.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `ObjectDescriptorService` | Information | Configuration loaded, descriptor count |
| `ObjectDescriptorService` | Debug | Descriptor selection, biome filtering |
| `ObjectDescriptorService` | Warning | No descriptors found, fallback used |
| `ObjectDescriptorRepository` | Information | Load complete with count |
| `ObjectDescriptorRepository` | Error | Configuration load failure |

### 10.2 Example Log Messages

```
[INF] ObjectDescriptorRepository: Loaded 100 object descriptors from configuration
[DBG] ObjectDescriptorService: Selected descriptor locked-door-detailed-01 for Door/LockedDoor Layer 2
[DBG] ObjectDescriptorService: 3 candidates for Machinery/Console Layer 2, biome Muspelheim
[DBG] ObjectDescriptorService: Applied biome boost to console-detailed-muspelheim-01
[WRN] ObjectDescriptorService: No descriptors found for Creature/BeastRemains Layer 2
[ERR] ObjectDescriptorRepository: Failed to load object descriptors from config/examination-descriptors.json
```

---

## 11. Unit Testing Requirements

### 11.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| ObjectDescriptor entity | 1 |
| ObjectDescriptorService | 1 |
| **Total** | **~2** |

### 11.2 Test Specifications

#### ObjectDescriptorTests.cs

**File:** `tests/RuneAndRust.Domain.Tests/Entities/ObjectDescriptorTests.cs`

```csharp
[TestFixture]
public class ObjectDescriptorTests
{
    [Test]
    public void GetDescriptor_ByCategoryAndType_ReturnsCorrectDescriptor()
    {
        // Arrange
        var descriptors = new List<ObjectDescriptor>
        {
            ObjectDescriptor.Create(
                "door-1", ObjectCategory.Door, "LockedDoor", 1,
                "A heavy iron door.", weight: 1),
            ObjectDescriptor.Create(
                "door-2", ObjectCategory.Door, "LockedDoor", 2,
                "The lock is complex.", weight: 1),
            ObjectDescriptor.Create(
                "console-1", ObjectCategory.Machinery, "Console", 1,
                "A Jötun console.", weight: 1)
        };

        var mockRepo = Substitute.For<IObjectDescriptorRepository>();
        mockRepo.GetByTypeAndLayer(ObjectCategory.Door, "LockedDoor", 1)
            .Returns(new[] { descriptors[0] });

        var service = new ObjectDescriptorService(
            mockRepo,
            Substitute.For<ILogger<ObjectDescriptorService>>());

        // Act
        var result = service.GetDescriptor(ObjectCategory.Door, "LockedDoor", 1);

        // Assert
        Assert.That(result, Is.Not.Null);
        Assert.That(result!.DescriptorId, Is.EqualTo("door-1"));
        Assert.That(result.ObjectCategory, Is.EqualTo(ObjectCategory.Door));
        Assert.That(result.Layer, Is.EqualTo(1));
    }
}
```

#### ObjectDescriptorBiomeFilterTests.cs

**File:** `tests/RuneAndRust.Application.Tests/Services/ObjectDescriptorBiomeFilterTests.cs`

```csharp
[TestFixture]
public class ObjectDescriptorBiomeFilterTests
{
    [Test]
    public void BiomeAffinity_FiltersCorrectly_ReturnsMatchingAndUniversal()
    {
        // Arrange
        var descriptors = new List<ObjectDescriptor>
        {
            ObjectDescriptor.Create(
                "console-universal", ObjectCategory.Machinery, "Console", 2,
                "Universal description.", weight: 1),
            ObjectDescriptor.Create(
                "console-muspelheim", ObjectCategory.Machinery, "Console", 2,
                "Muspelheim description.", biomeAffinity: "Muspelheim", weight: 1),
            ObjectDescriptor.Create(
                "console-roots", ObjectCategory.Machinery, "Console", 2,
                "The Roots description.", biomeAffinity: "The Roots", weight: 1)
        };

        var mockRepo = Substitute.For<IObjectDescriptorRepository>();
        mockRepo.GetByTypeAndLayer(ObjectCategory.Machinery, "Console", 2)
            .Returns(descriptors);

        var service = new ObjectDescriptorService(
            mockRepo,
            Substitute.For<ILogger<ObjectDescriptorService>>());

        // Act - request for Muspelheim biome
        var result = service.GetDescriptor(
            ObjectCategory.Machinery, "Console", 2, "Muspelheim");

        // Assert
        Assert.That(result, Is.Not.Null);
        // Result should be either universal or Muspelheim, not The Roots
        Assert.That(
            result!.BiomeAffinity,
            Is.Null.Or.EqualTo("Muspelheim"),
            "Should return universal or Muspelheim descriptor");
    }
}
```

---

## 12. Use Cases

### UC-001: Examination with Category Descriptors

**Actor:** Player
**Preconditions:** Player is in a room with a locked door
**Flow:**
1. Player enters `examine door`
2. ExaminationService identifies object as Door/LockedDoor
3. ExaminationService gets room biome context
4. ExaminationService calls ObjectDescriptorService
5. ObjectDescriptorService queries repository for Door/LockedDoor descriptors
6. ObjectDescriptorService filters by biome affinity
7. ObjectDescriptorService selects weighted variant for each unlocked layer
8. ExaminationService composes result with category-specific text
9. Player sees rich, contextual description

**Postconditions:** Player sees category-specific examination text

### UC-002: Biome-Specific Descriptor Selection

**Actor:** Player in Muspelheim
**Flow:**
1. Player examines a Console (Machinery)
2. System requests Layer 2 descriptor for Console in Muspelheim
3. Repository returns:
   - console-detailed-01 (universal, weight 1)
   - console-detailed-02 (universal, weight 1)
   - console-detailed-muspelheim-01 (Muspelheim, weight 1)
4. Service applies biome boost (×2) to Muspelheim descriptor
5. Weighted selection: 1 + 1 + 2 = 4 total weight
6. Muspelheim descriptor has 50% chance of selection
7. Player sees heat-themed console description

**Postconditions:** Biome-appropriate text displayed

### UC-003: Fallback to Universal Descriptors

**Actor:** Player in unknown biome
**Flow:**
1. Player examines object in biome without specific descriptors
2. Service queries for biome-specific descriptors
3. No biome-specific matches found
4. Service returns universal descriptors only
5. Player sees generic (but appropriate) description

**Postconditions:** Examination succeeds with universal text

### UC-004: Weighted Variant Selection

**Actor:** Player examining common object
**Flow:**
1. Player examines chest (Container/Chest)
2. Multiple Layer 1 descriptors exist:
   - chest-cursory-01 (weight 2, common)
   - chest-cursory-02 (weight 1, ornate variant)
3. Weighted selection: 66% common, 33% ornate
4. Player sees selected variant
5. Re-examination may show different variant

**Postconditions:** Variety in repeated examinations

---

## 13. Deliverable Checklist

### Domain Layer

- [ ] `ObjectCategory` enum with seven values
- [ ] `ObjectDescriptor` entity with all properties
- [ ] `ObjectDescriptor.Create()` factory method
- [ ] `ObjectDescriptor.MatchesBiome()` helper method

### Application Layer

- [ ] `IObjectDescriptorService` interface with three methods
- [ ] `ObjectDescriptorService` implementation
- [ ] `IObjectDescriptorRepository` interface
- [ ] Weighted variant selection algorithm
- [ ] Biome affinity filtering

### Infrastructure Layer

- [ ] `ObjectDescriptorRepository` implementation
- [ ] JSON configuration loading
- [ ] Error handling for missing configuration

### Configuration

- [ ] `examination-descriptors.json` with ~100 descriptors
- [ ] `examination-descriptors.schema.json` validation schema
- [ ] Door descriptors (~20)
- [ ] Machinery descriptors (~30)
- [ ] Decorative descriptors (~25)
- [ ] Container descriptors (~15)
- [ ] Environmental descriptors (~10)

### Testing

- [ ] ~2 unit tests implemented
- [ ] All tests passing

---

## 14. Acceptance Criteria

### Functional

- [ ] ObjectCategory enum defines all seven categories
- [ ] ObjectDescriptor entity stores all specified properties
- [ ] Descriptors load from examination-descriptors.json
- [ ] Descriptor lookup works by category, type, and layer
- [ ] Biome affinity filtering includes universal and matching descriptors
- [ ] Biome affinity filtering excludes other-biome descriptors
- [ ] Weighted selection provides variety for multiple matches
- [ ] Biome-specific descriptors receive selection boost
- [ ] ~100 descriptors defined across categories
- [ ] RevealsHint and RevealsSolutionId properties prepared for v0.15.6e

### Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] ~2 unit tests pass
- [ ] XML documentation complete for all public members
- [ ] JSON schema validates configuration file
- [ ] Configuration loading handles missing file gracefully

---

## 15. Dependencies

### 15.1 Required from Previous Versions

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `ExaminationLayer` | `Domain/Enums/ExaminationLayer.cs` | Layer values (1, 2, 3) |
| `ExaminationResult` | `Domain/ValueObjects/ExaminationResult.cs` | Receives descriptor text |
| `ExaminationService` | `Application/Services/ExaminationService.cs` | Calls ObjectDescriptorService |
| v0.15.6b Three-Layer System | Various | Foundation for layered descriptors |

### 15.2 Provides to v0.15.6d

| Type | Usage |
|------|-------|
| `ObjectCategory.Creature` | Base category for fauna observation |
| `ObjectDescriptor` pattern | Model for FloraFaunaDescriptor |
| Configuration pattern | Model for flora-fauna-descriptors.json |

### 15.3 Provides to v0.15.6e

| Type | Usage |
|------|-------|
| `ObjectDescriptor.RevealsHint` | Triggers puzzle hint integration |
| `ObjectDescriptor.RevealsSolutionId` | Links to puzzle solutions |
| Layer 3 descriptors | Source of puzzle hints |

### 15.4 Provides to v0.15.6h

| Type | Usage |
|------|-------|
| `ObjectCategory.Machinery` | Jötun-Reader bonus context |
| `ObjectCategory.Decorative` | Thul auto-succeed context |

### 15.5 Provides to v0.15.6i

| Type | Usage |
|------|-------|
| Category-aware descriptions | Room entry description composition |
| Biome-specific variants | Context-appropriate room text |

---

## 16. Future Considerations

### Deferred to v0.15.6d

- **Flora & fauna descriptors** - Creature category content
- **Species-specific examination** - Biome flora/fauna
- **Harvestable materials** - Alchemical uses

### Deferred to v0.15.6e

- **Puzzle hint activation** - Using RevealsHint property
- **Solution ID linking** - Connecting to puzzle system
- **Interaction unlocking** - New commands from expert examination

### Deferred to Future Versions

- **Dynamic descriptor generation** - AI-assisted text variation
- **Player-contributed descriptors** - Community content
- **Descriptor localization** - Multi-language support
- **Descriptor versioning** - Content updates without breaking saves

### Out of Scope for v0.15.6c

- **Furniture descriptors** - Minimal priority (10 planned)
- **Creature descriptors** - Deferred to v0.15.6d
- **Object condition variants** - Damaged/pristine text variations
- **Time-based descriptors** - Day/night variations

---

*Document Version: 1.0*
*Last Updated: 2026-01-18*
*Author: AI Assistant*
