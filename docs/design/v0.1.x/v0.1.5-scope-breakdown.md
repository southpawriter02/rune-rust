# v0.1.5 Procedural Puzzles & Secrets - Scope Breakdown

**Version:** 0.1.5
**Theme:** Procedural Puzzles & Secrets
**Prerequisites:** v0.1.4 Complete (World Persistence & Evolution)
**Total Estimated Tests:** ~85 new tests

---

## Executive Summary

The Procedural Puzzles & Secrets version extends the dungeon generator to procedurally place puzzles, secrets, traps, and treasure vaults. This version focuses exclusively on **generation and placement logic**â€”determining where these elements appear, what types are appropriate for each context, and how difficulty scales with depth. The actual player interaction mechanics (solving puzzles, disarming traps, searching for secrets) are deferred to v0.4.0 (Interactive Environment & Puzzles).

Key focus areas:
- **Puzzle Placement**: Template selection, biome/depth-appropriate puzzle types, solution generation
- **Secret Room Generation**: Hidden area placement, passage configuration, loot table assignment
- **Trap Placement**: Architecture-aware trap distribution, density rules, trap type selection
- **Treasure Vault Generation**: Vault template selection, guardian assignment, lock configuration

> **Note:** This version creates the *data structures* and *placement logic* for puzzles, traps, and secrets. Player interaction mechanics (solve attempts, disarm checks, search commands) are implemented in v0.4.0.

The work is divided into **four sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.1.5a | Puzzle Placement System | PuzzleTemplate, PuzzleInstance, placement rules | ~22 |
| v0.1.5b | Secret Room Generation | SecretRoomTemplate, HiddenPassage, generation rules | ~20 |
| v0.1.5c | Trap Placement System | TrapDefinition, TrapInstance, placement rules | ~22 |
| v0.1.5d | Treasure Vault Generation | TreasureRoomTemplate, Guardian, vault configuration | ~21 |

---

## Scope Boundaries

### In Scope (v0.1.5 - Generation)

| Category | What's Included |
|----------|-----------------|
| **Puzzles** | Template definitions, placement rules, solution generation, difficulty scaling |
| **Secrets** | Room templates, passage placement, discovery DC assignment, loot table linking |
| **Traps** | Type definitions, placement rules, density scaling, DC assignment |
| **Vaults** | Template definitions, guardian assignment, lock type configuration |

### Out of Scope (Deferred to v0.4.0 - Interaction)

| Category | What's Deferred |
|----------|-----------------|
| **Puzzles** | `solve` command, attempt tracking, success/failure handling, reward distribution |
| **Secrets** | `search` command, perception checks, discovery mechanics, reveal logic |
| **Traps** | `disarm` command, trigger mechanics, damage application, detection checks |
| **Vaults** | Unlock mechanics, guardian combat integration, puzzle-lock solving |

---

## Existing Infrastructure

### Already Implemented (from v0.1.4)

| Feature | Location | Notes |
|---------|----------|-------|
| RoomState | `Domain/Entities/RoomState.cs` | Persistent room tracking |
| BiomeDefinition | `Domain/Definitions/BiomeDefinition.cs` | Themed zones |
| ArchitecturalStyle | `Domain/Definitions/ArchitecturalStyle.cs` | Construction patterns |
| LandmarkRoom | `Domain/Definitions/LandmarkRoom.cs` | Special room templates |
| DungeonAge | `Domain/Enums/DungeonAge.cs` | Age/decay states |
| RoomType | `Domain/Enums/RoomType.cs` | Room classifications |
| Position3D | `Domain/ValueObjects/Position3D.cs` | 3D coordinates |
| SeededRandomService | `Application/Services/SeededRandomService.cs` | Reproducible random |
| MonsterDefinition | `Domain/Definitions/MonsterDefinition.cs` | Monster configuration |
| LootTable | `Domain/Definitions/LootTable.cs` | Loot configuration |

### Needs Implementation (v0.1.5)

| Feature | Phase | Notes |
|---------|-------|-------|
| PuzzleTemplate | v0.1.5a | Puzzle type definitions |
| PuzzleInstance | v0.1.5a | Placed puzzle with generated solution |
| PuzzlePlacementService | v0.1.5a | Puzzle placement logic |
| SecretRoomTemplate | v0.1.5b | Hidden area patterns |
| HiddenPassage | v0.1.5b | Passage configuration |
| SecretPlacementService | v0.1.5b | Secret room generation |
| TrapDefinition | v0.1.5c | Trap type configurations |
| TrapInstance | v0.1.5c | Placed trap configuration |
| TrapPlacementService | v0.1.5c | Trap placement logic |
| TreasureRoomTemplate | v0.1.5d | Vault designs |
| GuardianAssignment | v0.1.5d | Guardian configuration |
| VaultGenerationService | v0.1.5d | Vault generation logic |

---

## Feature Analysis & Categorization

### Puzzle Placement Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| PuzzleTemplate entity | Medium | BiomeDefinition | **v0.1.5a** |
| PuzzleType enum | Low | None | **v0.1.5a** |
| PuzzleSolution value object | Medium | PuzzleTemplate | **v0.1.5a** |
| PuzzleInstance entity | Medium | PuzzleTemplate | **v0.1.5a** |
| PuzzlePlacementService | High | PuzzleTemplate, BiomeDefinition | **v0.1.5a** |
| Difficulty scaling rules | Medium | Position3D | **v0.1.5a** |
| Biome-appropriate selection | Medium | BiomeDefinition | **v0.1.5a** |

### Secret Room Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| SecretRoomTemplate entity | Medium | LandmarkRoom | **v0.1.5b** |
| HiddenPassage entity | Medium | Room, Exit | **v0.1.5b** |
| SecretPlacementService | High | SecretRoomTemplate | **v0.1.5b** |
| Placement probability rules | Medium | BiomeDefinition | **v0.1.5b** |
| Discovery DC assignment | Low | Position3D | **v0.1.5b** |
| Loot table linking | Low | LootTable | **v0.1.5b** |

### Trap Placement Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| TrapDefinition entity | Medium | BiomeDefinition, ArchitecturalStyle | **v0.1.5c** |
| TrapInstance entity | Medium | TrapDefinition | **v0.1.5c** |
| TrapPlacementService | High | TrapDefinition | **v0.1.5c** |
| Trap density rules | Medium | RoomType, Position3D | **v0.1.5c** |
| DC assignment by depth | Low | Position3D | **v0.1.5c** |
| Biome/style filtering | Medium | BiomeDefinition, ArchitecturalStyle | **v0.1.5c** |

### Treasure Vault Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| TreasureRoomTemplate entity | Medium | LandmarkRoom | **v0.1.5d** |
| GuardianAssignment value object | Medium | MonsterDefinition | **v0.1.5d** |
| VaultLockType enum | Low | None | **v0.1.5d** |
| VaultGenerationService | High | TreasureRoomTemplate | **v0.1.5d** |
| Guardian configuration | Medium | MonsterDefinition | **v0.1.5d** |
| Lock type assignment | Low | PuzzleTemplate | **v0.1.5d** |

---

## Phase Definitions

---

## v0.1.5a: Puzzle Placement System

### Overview

Create the puzzle template system and placement logic for procedural puzzle generation. This phase defines puzzle types, generates solutions, and determines where puzzles are placed in the dungeon based on biome, architecture, and depth.

### Scope

**In Scope:**
- `PuzzleTemplate` entity defining puzzle types
- `PuzzleType` enum (Sequence, Combination, Riddle, Pattern)
- `PuzzleSolution` value object for generated answers
- `PuzzleClue` value object for hint data
- `PuzzleInstance` entity for placed puzzles
- `PuzzlePlacementService` for generation and placement
- Difficulty scaling based on depth
- Biome/style-appropriate template selection
- Configuration via `puzzles.json`

**Out of Scope (v0.4.0):**
- Solve attempt mechanics
- Success/failure handling
- Reward distribution
- Player-facing puzzle commands

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 2 | `PuzzleTemplate`, `PuzzleInstance` |
| Value Objects | 2 | `PuzzleSolution`, `PuzzleClue` |
| Enums | 1 | `PuzzleType` |
| Services | 1 | `PuzzlePlacementService` |
| Configuration | 1 | `puzzles.json` |
| Unit Tests | ~22 | Template loading, placement, solution generation |

### PuzzleType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of procedurally generated puzzles.
/// </summary>
public enum PuzzleType
{
    /// <summary>Player must complete a sequence (e.g., lever order).</summary>
    Sequence,

    /// <summary>Player must enter a combination (e.g., lock digits).</summary>
    Combination,

    /// <summary>Player must solve a riddle with a word answer.</summary>
    Riddle,

    /// <summary>Player must recognize and complete a pattern.</summary>
    Pattern,

    /// <summary>Player must match symbols or elements.</summary>
    Matching,

    /// <summary>Player must arrange tiles or blocks.</summary>
    Tile
}
```

### PuzzleTemplate Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a puzzle template for procedural generation.
/// </summary>
public class PuzzleTemplate : IDefinition
{
    /// <summary>
    /// Gets the unique identifier (e.g., "lever-sequence").
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the puzzle type.
    /// </summary>
    public PuzzleType Type { get; private set; }

    /// <summary>
    /// Gets the base difficulty (1-10).
    /// </summary>
    public int BaseDifficulty { get; private set; }

    /// <summary>
    /// Gets the minimum dungeon depth for this puzzle.
    /// </summary>
    public int MinDepth { get; private set; }

    /// <summary>
    /// Gets the maximum dungeon depth (0 = no limit).
    /// </summary>
    public int MaxDepth { get; private set; }

    /// <summary>
    /// Gets biome IDs this puzzle can appear in (empty = all).
    /// </summary>
    public IReadOnlyList<string> AllowedBiomes { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets architectural styles this puzzle fits (empty = all).
    /// </summary>
    public IReadOnlyList<string> AllowedStyles { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the description template with placeholders.
    /// </summary>
    public string DescriptionTemplate { get; private set; } = string.Empty;

    /// <summary>
    /// Gets clue templates for this puzzle type.
    /// </summary>
    public IReadOnlyList<string> ClueTemplates { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the minimum solution length/count.
    /// </summary>
    public int MinSolutionSize { get; private set; }

    /// <summary>
    /// Gets the maximum solution length/count.
    /// </summary>
    public int MaxSolutionSize { get; private set; }

    /// <summary>
    /// Gets possible solution elements for this puzzle.
    /// </summary>
    public IReadOnlyList<string> SolutionElements { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether this puzzle blocks passage until solved.
    /// </summary>
    public bool BlocksPassage { get; private set; }

    /// <summary>
    /// Gets the maximum solve attempts (0 = unlimited).
    /// </summary>
    public int MaxAttempts { get; private set; }

    /// <summary>
    /// Gets the placement weight for random selection.
    /// </summary>
    public int PlacementWeight { get; private set; }

    private PuzzleTemplate() { /* JSON deserialization */ }

    /// <summary>
    /// Creates a puzzle template from configuration.
    /// </summary>
    public static PuzzleTemplate Create(
        string id,
        string name,
        PuzzleType type,
        int baseDifficulty,
        string descriptionTemplate,
        IEnumerable<string> solutionElements)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentOutOfRangeException.ThrowIfLessThan(baseDifficulty, 1);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(baseDifficulty, 10);

        return new PuzzleTemplate
        {
            Id = id,
            Name = name,
            Type = type,
            BaseDifficulty = baseDifficulty,
            DescriptionTemplate = descriptionTemplate,
            SolutionElements = solutionElements.ToList(),
            MinSolutionSize = 3,
            MaxSolutionSize = 6,
            PlacementWeight = 100
        };
    }

    /// <summary>
    /// Checks if this puzzle is valid for the given context.
    /// </summary>
    public bool IsValidFor(int depth, string? biomeId, string? styleId)
    {
        if (depth < MinDepth) return false;
        if (MaxDepth > 0 && depth > MaxDepth) return false;

        if (AllowedBiomes.Count > 0 && biomeId != null && !AllowedBiomes.Contains(biomeId))
            return false;

        if (AllowedStyles.Count > 0 && styleId != null && !AllowedStyles.Contains(styleId))
            return false;

        return true;
    }

    /// <summary>
    /// Gets the effective difficulty scaled by depth.
    /// </summary>
    public int GetScaledDifficulty(int depth)
    {
        var depthBonus = depth / 3;
        return Math.Min(BaseDifficulty + depthBonus, 10);
    }
}
```

### PuzzleSolution Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a generated puzzle solution.
/// Stores the correct answer for later validation in v0.4.0.
/// </summary>
public readonly record struct PuzzleSolution
{
    /// <summary>
    /// Gets the ordered solution elements (for sequence/combination puzzles).
    /// </summary>
    public IReadOnlyList<string> Elements { get; init; }

    /// <summary>
    /// Gets the solution as a single answer (for riddles).
    /// </summary>
    public string? Answer { get; init; }

    /// <summary>
    /// Gets the seed used to generate this solution.
    /// </summary>
    public int Seed { get; init; }

    /// <summary>
    /// Creates a sequence-based solution.
    /// </summary>
    public static PuzzleSolution FromSequence(IEnumerable<string> elements, int seed)
    {
        return new PuzzleSolution
        {
            Elements = elements.ToList(),
            Answer = null,
            Seed = seed
        };
    }

    /// <summary>
    /// Creates an answer-based solution.
    /// </summary>
    public static PuzzleSolution FromAnswer(string answer, int seed)
    {
        return new PuzzleSolution
        {
            Elements = Array.Empty<string>(),
            Answer = answer,
            Seed = seed
        };
    }
}
```

### PuzzleClue Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a hint for solving a puzzle.
/// Clue discovery mechanics implemented in v0.4.0.
/// </summary>
public readonly record struct PuzzleClue
{
    /// <summary>
    /// Gets the clue text.
    /// </summary>
    public string Text { get; init; }

    /// <summary>
    /// Gets how much of the solution this clue reveals (0-1).
    /// </summary>
    public float Specificity { get; init; }

    /// <summary>
    /// Gets the location description where this clue can be found.
    /// </summary>
    public string Location { get; init; }

    /// <summary>
    /// Creates a vague clue.
    /// </summary>
    public static PuzzleClue CreateVague(string text, string location)
    {
        return new PuzzleClue
        {
            Text = text,
            Specificity = 0.25f,
            Location = location
        };
    }

    /// <summary>
    /// Creates a specific clue.
    /// </summary>
    public static PuzzleClue CreateSpecific(string text, string location)
    {
        return new PuzzleClue
        {
            Text = text,
            Specificity = 0.75f,
            Location = location
        };
    }
}
```

### PuzzleInstance Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// A placed puzzle instance in a dungeon room.
/// Interaction state (solved, attempts) managed in v0.4.0.
/// </summary>
public class PuzzleInstance : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the room containing this puzzle.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the template ID used to generate this puzzle.
    /// </summary>
    public string TemplateId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the puzzle description shown to player.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the generated solution.
    /// </summary>
    public PuzzleSolution Solution { get; private set; }

    /// <summary>
    /// Gets the clues for this puzzle.
    /// </summary>
    public IReadOnlyList<PuzzleClue> Clues { get; private set; } = Array.Empty<PuzzleClue>();

    /// <summary>
    /// Gets the effective difficulty (DC for skill checks in v0.4.0).
    /// </summary>
    public int Difficulty { get; private set; }

    /// <summary>
    /// Gets the maximum allowed attempts (0 = unlimited).
    /// </summary>
    public int MaxAttempts { get; private set; }

    /// <summary>
    /// Gets whether the puzzle blocks an exit.
    /// </summary>
    public bool BlocksPassage { get; private set; }

    /// <summary>
    /// Gets the exit direction blocked (if any).
    /// </summary>
    public Direction? BlockedDirection { get; private set; }

    /// <summary>
    /// Gets reward item IDs for solving.
    /// </summary>
    public IReadOnlyList<string> RewardIds { get; private set; } = Array.Empty<string>();

    private PuzzleInstance() { /* EF Core */ }

    /// <summary>
    /// Creates a puzzle instance from a template.
    /// </summary>
    public static PuzzleInstance Create(
        Guid roomId,
        PuzzleTemplate template,
        string description,
        PuzzleSolution solution,
        IEnumerable<PuzzleClue> clues,
        int difficulty)
    {
        return new PuzzleInstance
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            TemplateId = template.Id,
            Description = description,
            Solution = solution,
            Clues = clues.ToList(),
            Difficulty = difficulty,
            MaxAttempts = template.MaxAttempts,
            BlocksPassage = template.BlocksPassage
        };
    }

    /// <summary>
    /// Sets the blocked direction for passage-blocking puzzles.
    /// </summary>
    public void SetBlockedDirection(Direction direction)
    {
        if (!BlocksPassage) return;
        BlockedDirection = direction;
    }

    /// <summary>
    /// Sets the rewards for solving this puzzle.
    /// </summary>
    public void SetRewards(IEnumerable<string> rewardIds)
    {
        RewardIds = rewardIds.ToList();
    }
}
```

### PuzzlePlacementService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Generates and places puzzles during dungeon generation.
/// Does not handle puzzle solving (see v0.4.0).
/// </summary>
public class PuzzlePlacementService : IPuzzlePlacementService
{
    private readonly IConfigurationProvider _configurationProvider;
    private readonly ISeededRandomService _randomService;
    private readonly ILogger<PuzzlePlacementService> _logger;

    public PuzzlePlacementService(
        IConfigurationProvider configurationProvider,
        ISeededRandomService randomService,
        ILogger<PuzzlePlacementService> logger)
    {
        _configurationProvider = configurationProvider;
        _randomService = randomService;
        _logger = logger;
    }

    /// <summary>
    /// Generates a puzzle for the given room context.
    /// </summary>
    public PuzzleInstance? GeneratePuzzle(PuzzlePlacementContext context)
    {
        var templates = _configurationProvider.GetPuzzleTemplates()
            .Where(t => t.IsValidFor(context.Depth, context.BiomeId, context.ArchitecturalStyleId))
            .ToList();

        if (templates.Count == 0)
        {
            _logger.LogDebug("No valid puzzle templates for depth {Depth}, biome {Biome}",
                context.Depth, context.BiomeId);
            return null;
        }

        var template = SelectTemplate(templates, context);
        var solution = GenerateSolution(template, context);
        var description = GenerateDescription(template, context);
        var clues = GenerateClues(template, context, solution);
        var difficulty = template.GetScaledDifficulty(context.Depth);

        var puzzle = PuzzleInstance.Create(
            context.RoomId,
            template,
            description,
            solution,
            clues,
            difficulty);

        _logger.LogInformation("Placed {Type} puzzle '{Template}' in room {RoomId} at depth {Depth}",
            template.Type, template.Id, context.RoomId, context.Depth);

        return puzzle;
    }

    /// <summary>
    /// Determines if a room should contain a puzzle.
    /// </summary>
    public bool ShouldPlacePuzzle(PuzzlePlacementContext context)
    {
        // Puzzle rooms always get puzzles
        if (context.RoomType == RoomType.Puzzle) return true;

        // Boss rooms may have puzzle locks
        if (context.RoomType == RoomType.Boss)
            return _randomService.NextDouble() < 0.3;

        // Treasure rooms may have puzzle locks
        if (context.RoomType == RoomType.Treasure)
            return _randomService.NextDouble() < 0.4;

        return false;
    }

    private PuzzleTemplate SelectTemplate(
        IList<PuzzleTemplate> templates,
        PuzzlePlacementContext context)
    {
        var totalWeight = templates.Sum(t => GetAdjustedWeight(t, context));
        var roll = _randomService.Next(0, totalWeight);
        var cumulative = 0;

        foreach (var template in templates)
        {
            cumulative += GetAdjustedWeight(template, context);
            if (roll < cumulative)
                return template;
        }

        return templates[0];
    }

    private int GetAdjustedWeight(PuzzleTemplate template, PuzzlePlacementContext context)
    {
        var weight = template.PlacementWeight;

        // Prefer biome-matched puzzles
        if (template.AllowedBiomes.Count > 0 && context.BiomeId != null)
        {
            if (template.AllowedBiomes.Contains(context.BiomeId))
                weight += 50;
        }

        // Prefer style-matched puzzles
        if (template.AllowedStyles.Count > 0 && context.ArchitecturalStyleId != null)
        {
            if (template.AllowedStyles.Contains(context.ArchitecturalStyleId))
                weight += 30;
        }

        return weight;
    }

    private PuzzleSolution GenerateSolution(PuzzleTemplate template, PuzzlePlacementContext context)
    {
        var seed = context.WorldSeed ^ context.RoomId.GetHashCode();

        return template.Type switch
        {
            PuzzleType.Sequence => GenerateSequenceSolution(template, seed),
            PuzzleType.Combination => GenerateCombinationSolution(template, seed),
            PuzzleType.Riddle => GenerateRiddleSolution(template, seed),
            PuzzleType.Pattern => GeneratePatternSolution(template, seed),
            _ => GenerateSequenceSolution(template, seed)
        };
    }

    private PuzzleSolution GenerateSequenceSolution(PuzzleTemplate template, int seed)
    {
        var length = _randomService.Next(template.MinSolutionSize, template.MaxSolutionSize + 1);
        var elements = _randomService.Shuffle(template.SolutionElements.ToList())
            .Take(length)
            .ToList();

        return PuzzleSolution.FromSequence(elements, seed);
    }

    private PuzzleSolution GenerateCombinationSolution(PuzzleTemplate template, int seed)
    {
        var length = _randomService.Next(template.MinSolutionSize, template.MaxSolutionSize + 1);
        var elements = Enumerable.Range(0, length)
            .Select(_ => _randomService.SelectRandom(template.SolutionElements))
            .ToList();

        return PuzzleSolution.FromSequence(elements, seed);
    }

    private PuzzleSolution GenerateRiddleSolution(PuzzleTemplate template, int seed)
    {
        var answer = _randomService.SelectRandom(template.SolutionElements);
        return PuzzleSolution.FromAnswer(answer, seed);
    }

    private PuzzleSolution GeneratePatternSolution(PuzzleTemplate template, int seed)
    {
        var patternLength = _randomService.Next(2, 4);
        var pattern = template.SolutionElements.Take(patternLength).ToList();
        var repetitions = _randomService.Next(2, 4);
        var elements = Enumerable.Range(0, repetitions)
            .SelectMany(_ => pattern)
            .ToList();

        return PuzzleSolution.FromSequence(elements, seed);
    }

    private string GenerateDescription(PuzzleTemplate template, PuzzlePlacementContext context)
    {
        var description = template.DescriptionTemplate;
        description = description.Replace("{biome}", context.BiomeName ?? "dungeon");
        return description;
    }

    private IEnumerable<PuzzleClue> GenerateClues(
        PuzzleTemplate template,
        PuzzlePlacementContext context,
        PuzzleSolution solution)
    {
        var clueCount = _randomService.Next(2, 4);
        var clues = new List<PuzzleClue>();

        for (var i = 0; i < clueCount && i < template.ClueTemplates.Count; i++)
        {
            var clueText = template.ClueTemplates[i];

            if (solution.Elements.Count > 0)
            {
                var revealIndex = _randomService.Next(0, solution.Elements.Count);
                clueText = clueText.Replace("{element}", solution.Elements[revealIndex]);
                clueText = clueText.Replace("{position}", (revealIndex + 1).ToString());
            }

            var location = $"Nearby wall inscription ({i + 1})";
            clues.Add(i == 0
                ? PuzzleClue.CreateVague(clueText, location)
                : PuzzleClue.CreateSpecific(clueText, location));
        }

        return clues;
    }
}
```

### PuzzlePlacementContext Record

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Context for puzzle placement during dungeon generation.
/// </summary>
public record PuzzlePlacementContext
{
    /// <summary>
    /// Gets the room ID for the puzzle.
    /// </summary>
    public required Guid RoomId { get; init; }

    /// <summary>
    /// Gets the dungeon depth (Z coordinate).
    /// </summary>
    public required int Depth { get; init; }

    /// <summary>
    /// Gets the biome ID (if any).
    /// </summary>
    public string? BiomeId { get; init; }

    /// <summary>
    /// Gets the biome display name.
    /// </summary>
    public string? BiomeName { get; init; }

    /// <summary>
    /// Gets the architectural style ID (if any).
    /// </summary>
    public string? ArchitecturalStyleId { get; init; }

    /// <summary>
    /// Gets the world seed for reproducibility.
    /// </summary>
    public required int WorldSeed { get; init; }

    /// <summary>
    /// Gets the room type.
    /// </summary>
    public RoomType? RoomType { get; init; }
}
```

### Configuration: puzzles.json

```json
{
  "$schema": "../schemas/puzzles.schema.json",
  "puzzleTemplates": [
    {
      "id": "lever-sequence",
      "name": "Lever Sequence",
      "type": "Sequence",
      "baseDifficulty": 3,
      "minDepth": 1,
      "maxDepth": 0,
      "allowedBiomes": [],
      "allowedStyles": ["carved-halls", "ancient-temple"],
      "descriptionTemplate": "A row of ancient levers protrudes from the wall. Each is marked with a different symbol.",
      "clueTemplates": [
        "An old inscription reads: 'Begin with {element}'",
        "Scratched into the stone: 'The {position}th lever is {element}'",
        "A faded mural depicts the sequence..."
      ],
      "minSolutionSize": 3,
      "maxSolutionSize": 5,
      "solutionElements": ["sun", "moon", "star", "tree", "wave", "flame"],
      "blocksPassage": true,
      "maxAttempts": 5,
      "placementWeight": 100
    },
    {
      "id": "combination-lock",
      "name": "Combination Lock",
      "type": "Combination",
      "baseDifficulty": 4,
      "minDepth": 2,
      "maxDepth": 0,
      "allowedBiomes": [],
      "allowedStyles": ["carved-halls", "ruined-structures"],
      "descriptionTemplate": "A heavy door is secured by a combination lock with rotating dials.",
      "clueTemplates": [
        "A note reads: 'The first number is {element}'",
        "Worn grooves suggest {element} at position {position}",
        "Someone scratched numbers into the doorframe..."
      ],
      "minSolutionSize": 3,
      "maxSolutionSize": 4,
      "solutionElements": ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
      "blocksPassage": true,
      "maxAttempts": 0,
      "placementWeight": 80
    },
    {
      "id": "cave-riddle",
      "name": "Cave Spirit's Riddle",
      "type": "Riddle",
      "baseDifficulty": 5,
      "minDepth": 3,
      "maxDepth": 0,
      "allowedBiomes": ["natural-caves"],
      "allowedStyles": [],
      "descriptionTemplate": "A voice echoes from the darkness: 'Answer my riddle to pass...'",
      "clueTemplates": [
        "Think of something found in caves...",
        "The answer relates to this very place...",
        "The spirits whisper hints..."
      ],
      "minSolutionSize": 1,
      "maxSolutionSize": 1,
      "solutionElements": ["stone", "darkness", "water", "echo", "silence", "shadow"],
      "blocksPassage": true,
      "maxAttempts": 3,
      "placementWeight": 60
    },
    {
      "id": "symbol-pattern",
      "name": "Symbol Pattern",
      "type": "Pattern",
      "baseDifficulty": 4,
      "minDepth": 2,
      "maxDepth": 0,
      "allowedBiomes": [],
      "allowedStyles": ["ancient-temple"],
      "descriptionTemplate": "Tiles on the floor display a repeating pattern with some symbols missing.",
      "clueTemplates": [
        "The pattern repeats every few tiles",
        "Notice how {element} appears in the sequence...",
        "The sequence is clear if you look carefully"
      ],
      "minSolutionSize": 4,
      "maxSolutionSize": 8,
      "solutionElements": ["circle", "square", "triangle", "diamond"],
      "blocksPassage": false,
      "maxAttempts": 2,
      "placementWeight": 70
    }
  ]
}
```

### Acceptance Criteria

- [ ] PuzzleTemplate loads from `puzzles.json` configuration
- [ ] PuzzlePlacementService selects appropriate templates for biome/depth
- [ ] PuzzleSolution generates valid solutions based on template type
- [ ] PuzzleClue generates hints with partial solution information
- [ ] Difficulty scales correctly with dungeon depth
- [ ] Placement weight adjusts for biome/style matches
- [ ] ~22 unit tests pass

---

## v0.1.5b: Secret Room Generation

### Overview

Implement hidden passage placement and secret room generation. This phase determines where secret rooms are placed, configures their discovery difficulty, and assigns loot tables. The actual search mechanics are implemented in v0.4.0.

### Scope

**In Scope:**
- `SecretRoomTemplate` entity for hidden area types
- `HiddenPassage` entity for passage configuration
- `SecretPlacementService` for generation logic
- Placement probability by biome/architecture
- Discovery DC assignment by depth
- Loot table linking
- Configuration via `secrets.json`

**Out of Scope (v0.4.0):**
- Search command
- Perception skill checks
- Discovery state tracking
- Reveal mechanics

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 2 | `SecretRoomTemplate`, `HiddenPassage` |
| Value Objects | 1 | `SecretPlacementRules` |
| Services | 1 | `SecretPlacementService` |
| Configuration | 1 | `secrets.json` |
| Unit Tests | ~20 | Template loading, placement, DC assignment |

### SecretRoomTemplate Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a template for secret room generation.
/// </summary>
public class SecretRoomTemplate : IDefinition
{
    /// <summary>
    /// Gets the unique identifier (e.g., "hidden-treasury").
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description template.
    /// </summary>
    public string DescriptionTemplate { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the base discovery difficulty (DC).
    /// </summary>
    public int BaseDiscoveryDC { get; private set; }

    /// <summary>
    /// Gets the minimum depth for this secret type.
    /// </summary>
    public int MinDepth { get; private set; }

    /// <summary>
    /// Gets the maximum depth (0 = no limit).
    /// </summary>
    public int MaxDepth { get; private set; }

    /// <summary>
    /// Gets the base spawn probability (0-1).
    /// </summary>
    public float SpawnProbability { get; private set; }

    /// <summary>
    /// Gets biomes where this secret appears more often.
    /// </summary>
    public IReadOnlyList<string> PreferredBiomes { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets architectural styles with higher spawn chance.
    /// </summary>
    public IReadOnlyList<string> PreferredStyles { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the loot table ID for rewards.
    /// </summary>
    public string LootTableId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets passage description templates.
    /// </summary>
    public IReadOnlyList<string> PassageDescriptions { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets discovery hint templates.
    /// </summary>
    public IReadOnlyList<string> DiscoveryHints { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether this secret can contain traps.
    /// </summary>
    public bool CanContainTraps { get; private set; }

    /// <summary>
    /// Gets whether this secret can contain a guardian.
    /// </summary>
    public bool CanContainGuardian { get; private set; }

    private SecretRoomTemplate() { /* JSON deserialization */ }

    /// <summary>
    /// Creates a secret room template.
    /// </summary>
    public static SecretRoomTemplate Create(
        string id,
        string name,
        string descriptionTemplate,
        int baseDiscoveryDC,
        float spawnProbability,
        string lootTableId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentOutOfRangeException.ThrowIfNegative(baseDiscoveryDC);

        return new SecretRoomTemplate
        {
            Id = id,
            Name = name,
            DescriptionTemplate = descriptionTemplate,
            BaseDiscoveryDC = baseDiscoveryDC,
            SpawnProbability = Math.Clamp(spawnProbability, 0f, 1f),
            LootTableId = lootTableId
        };
    }

    /// <summary>
    /// Gets the scaled discovery DC for a depth.
    /// </summary>
    public int GetScaledDC(int depth)
    {
        var depthBonus = depth / 2;
        return BaseDiscoveryDC + depthBonus;
    }

    /// <summary>
    /// Gets the adjusted spawn probability for context.
    /// </summary>
    public float GetAdjustedProbability(string? biomeId, string? styleId)
    {
        var probability = SpawnProbability;

        if (biomeId != null && PreferredBiomes.Contains(biomeId))
            probability *= 1.5f;

        if (styleId != null && PreferredStyles.Contains(styleId))
            probability *= 1.3f;

        return Math.Min(probability, 1f);
    }

    /// <summary>
    /// Checks if valid for the given depth.
    /// </summary>
    public bool IsValidFor(int depth)
    {
        if (depth < MinDepth) return false;
        if (MaxDepth > 0 && depth > MaxDepth) return false;
        return true;
    }
}
```

### HiddenPassage Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// A hidden passage connecting rooms.
/// Discovery state managed in v0.4.0.
/// </summary>
public class HiddenPassage : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the room containing this passage.
    /// </summary>
    public Guid SourceRoomId { get; private set; }

    /// <summary>
    /// Gets the secret room this leads to.
    /// </summary>
    public Guid DestinationRoomId { get; private set; }

    /// <summary>
    /// Gets the template ID used to generate this.
    /// </summary>
    public string TemplateId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the direction of the hidden passage.
    /// </summary>
    public Direction Direction { get; private set; }

    /// <summary>
    /// Gets the DC to discover this passage (used in v0.4.0).
    /// </summary>
    public int DiscoveryDC { get; private set; }

    /// <summary>
    /// Gets the description shown before discovery.
    /// </summary>
    public string HiddenDescription { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description shown after discovery.
    /// </summary>
    public string RevealedDescription { get; private set; } = string.Empty;

    /// <summary>
    /// Gets hints that may appear in room description.
    /// </summary>
    public IReadOnlyList<string> Hints { get; private set; } = Array.Empty<string>();

    private HiddenPassage() { /* EF Core */ }

    /// <summary>
    /// Creates a hidden passage.
    /// </summary>
    public static HiddenPassage Create(
        Guid sourceRoomId,
        Guid destinationRoomId,
        SecretRoomTemplate template,
        Direction direction,
        int discoveryDC,
        string hiddenDescription,
        string revealedDescription,
        IEnumerable<string> hints)
    {
        return new HiddenPassage
        {
            Id = Guid.NewGuid(),
            SourceRoomId = sourceRoomId,
            DestinationRoomId = destinationRoomId,
            TemplateId = template.Id,
            Direction = direction,
            DiscoveryDC = discoveryDC,
            HiddenDescription = hiddenDescription,
            RevealedDescription = revealedDescription,
            Hints = hints.ToList()
        };
    }
}
```

### SecretPlacementService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Generates and places secret rooms during dungeon generation.
/// Does not handle discovery mechanics (see v0.4.0).
/// </summary>
public class SecretPlacementService : ISecretPlacementService
{
    private readonly IConfigurationProvider _configurationProvider;
    private readonly ISeededRandomService _randomService;
    private readonly ILogger<SecretPlacementService> _logger;

    public SecretPlacementService(
        IConfigurationProvider configurationProvider,
        ISeededRandomService randomService,
        ILogger<SecretPlacementService> logger)
    {
        _configurationProvider = configurationProvider;
        _randomService = randomService;
        _logger = logger;
    }

    /// <summary>
    /// Generates secret rooms for a dungeon level.
    /// </summary>
    public IEnumerable<SecretPlacementResult> GenerateSecrets(
        SecretPlacementContext context,
        IEnumerable<Room> rooms)
    {
        var templates = _configurationProvider.GetSecretRoomTemplates()
            .Where(t => t.IsValidFor(context.Depth))
            .ToList();

        if (templates.Count == 0)
        {
            _logger.LogDebug("No valid secret templates for depth {Depth}", context.Depth);
            yield break;
        }

        foreach (var room in rooms)
        {
            if (room.Type == RoomType.Secret) continue;

            var result = TryPlaceSecret(room, templates, context);
            if (result != null)
            {
                yield return result;
            }
        }
    }

    private SecretPlacementResult? TryPlaceSecret(
        Room sourceRoom,
        IList<SecretRoomTemplate> templates,
        SecretPlacementContext context)
    {
        foreach (var template in templates)
        {
            var probability = template.GetAdjustedProbability(
                context.BiomeId,
                context.ArchitecturalStyleId);

            if (_randomService.NextDouble() >= probability)
                continue;

            var direction = FindAvailableDirection(sourceRoom);
            if (direction == null)
                continue;

            var secretRoom = CreateSecretRoom(template, sourceRoom, context);
            var passage = CreateHiddenPassage(template, sourceRoom, secretRoom, direction.Value, context);

            _logger.LogInformation("Placed secret '{Template}' adjacent to room {RoomId}",
                template.Id, sourceRoom.Id);

            return new SecretPlacementResult
            {
                SecretRoom = secretRoom,
                Passage = passage,
                Template = template
            };
        }

        return null;
    }

    private Room CreateSecretRoom(
        SecretRoomTemplate template,
        Room sourceRoom,
        SecretPlacementContext context)
    {
        return Room.Create(
            context.DungeonId,
            template.Name,
            template.DescriptionTemplate,
            sourceRoom.Position, // Position adjusted by dungeon generator
            RoomType.Secret);
    }

    private HiddenPassage CreateHiddenPassage(
        SecretRoomTemplate template,
        Room sourceRoom,
        Room secretRoom,
        Direction direction,
        SecretPlacementContext context)
    {
        var hiddenDescription = SelectDescription(template.PassageDescriptions,
            "The wall here looks slightly different...");
        var revealedDescription = $"A hidden passage leads {direction.ToString().ToLower()}.";
        var hints = template.DiscoveryHints.Take(3);

        return HiddenPassage.Create(
            sourceRoom.Id,
            secretRoom.Id,
            template,
            direction,
            template.GetScaledDC(context.Depth),
            hiddenDescription,
            revealedDescription,
            hints);
    }

    private Direction? FindAvailableDirection(Room room)
    {
        var usedDirections = room.Exits.Select(e => e.Direction).ToHashSet();
        var available = new[] { Direction.North, Direction.South, Direction.East, Direction.West }
            .Where(d => !usedDirections.Contains(d))
            .ToList();

        return available.Count > 0
            ? available[_randomService.Next(0, available.Count)]
            : null;
    }

    private string SelectDescription(IReadOnlyList<string> options, string fallback)
    {
        return options.Count > 0
            ? options[_randomService.Next(0, options.Count)]
            : fallback;
    }
}
```

### Configuration: secrets.json

```json
{
  "$schema": "../schemas/secrets.schema.json",
  "secretRoomTemplates": [
    {
      "id": "hidden-cache",
      "name": "Hidden Cache",
      "descriptionTemplate": "A small alcove concealed behind loose stones. Dusty crates and forgotten supplies fill the cramped space.",
      "baseDiscoveryDC": 12,
      "minDepth": 1,
      "maxDepth": 0,
      "spawnProbability": 0.15,
      "preferredBiomes": ["natural-caves", "ruined-structures"],
      "preferredStyles": [],
      "lootTableId": "secret-cache-common",
      "passageDescriptions": [
        "A section of wall swings inward",
        "Loose stones reveal an opening",
        "A hidden panel slides aside"
      ],
      "discoveryHints": [
        "The stonework here seems slightly uneven",
        "A faint draft comes from somewhere nearby",
        "You notice scratches around certain stones"
      ],
      "canContainTraps": false,
      "canContainGuardian": false
    },
    {
      "id": "ancient-vault",
      "name": "Ancient Vault",
      "descriptionTemplate": "An intact vault from a forgotten age. Magical wards still shimmer faintly on the walls.",
      "baseDiscoveryDC": 18,
      "minDepth": 4,
      "maxDepth": 0,
      "spawnProbability": 0.05,
      "preferredBiomes": [],
      "preferredStyles": ["ancient-temple", "carved-halls"],
      "lootTableId": "secret-vault-rare",
      "passageDescriptions": [
        "An illusory wall fades away",
        "Ancient runes reveal a doorway",
        "A magical seal dissolves"
      ],
      "discoveryHints": [
        "Magic tingles at your fingertips here",
        "The air feels different near this wall",
        "You sense something hidden by arcane means"
      ],
      "canContainTraps": true,
      "canContainGuardian": true
    },
    {
      "id": "smugglers-den",
      "name": "Smuggler's Den",
      "descriptionTemplate": "A cramped hideout once used by smugglers. Maps and contraband remain scattered about.",
      "baseDiscoveryDC": 14,
      "minDepth": 2,
      "maxDepth": 6,
      "spawnProbability": 0.10,
      "preferredBiomes": ["natural-caves"],
      "preferredStyles": ["natural-caves"],
      "lootTableId": "secret-smuggler",
      "passageDescriptions": [
        "A hidden lever reveals an opening",
        "A false rock wall pivots inward",
        "A concealed trapdoor opens"
      ],
      "discoveryHints": [
        "Boot prints disappear near this wall",
        "You notice well-worn handholds",
        "The floor is scuffed in an odd pattern"
      ],
      "canContainTraps": true,
      "canContainGuardian": false
    }
  ]
}
```

### Acceptance Criteria

- [ ] SecretRoomTemplate loads from `secrets.json` configuration
- [ ] SecretPlacementService generates secrets based on probability
- [ ] HiddenPassage assigns correct discovery DC by depth
- [ ] Spawn probability adjusts for biome/style preferences
- [ ] Hints are assigned from template
- [ ] Loot table is linked correctly
- [ ] ~20 unit tests pass

---

## v0.1.5c: Trap Placement System

### Overview

Implement trap type definitions and placement logic. This phase determines where traps are placed, what types are appropriate, and assigns detection/disarm DCs. The actual trap mechanics (triggering, disarming, damage) are implemented in v0.4.0.

### Scope

**In Scope:**
- `TrapDefinition` entity for trap types
- `TrapInstance` entity for placed traps
- `TrapPlacementService` for placement logic
- Trap density rules by room type
- DC assignment by depth
- Biome/architecture filtering
- Configuration via `traps.json`

**Out of Scope (v0.4.0):**
- Disarm command
- Detection checks
- Trigger mechanics
- Damage application

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 2 | `TrapDefinition`, `TrapInstance` |
| Value Objects | 1 | `TrapPlacement` |
| Enums | 1 | `TrapTriggerType` |
| Services | 1 | `TrapPlacementService` |
| Configuration | 1 | `traps.json` |
| Unit Tests | ~22 | Template loading, placement, DC scaling |

### TrapDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a trap type for dungeon placement.
/// </summary>
public class TrapDefinition : IDefinition
{
    /// <summary>
    /// Gets the unique identifier (e.g., "poison-dart").
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the hidden description (before detection).
    /// </summary>
    public string HiddenDescription { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the revealed description (after detection).
    /// </summary>
    public string RevealedDescription { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the trigger description.
    /// </summary>
    public string TriggerDescription { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the base detection DC.
    /// </summary>
    public int BaseDetectionDC { get; private set; }

    /// <summary>
    /// Gets the base disarm DC.
    /// </summary>
    public int BaseDisarmDC { get; private set; }

    /// <summary>
    /// Gets the damage dice expression.
    /// </summary>
    public string DamageExpression { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the damage type.
    /// </summary>
    public string DamageTypeId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets status effects applied on trigger.
    /// </summary>
    public IReadOnlyList<string> StatusEffectIds { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the minimum depth for this trap.
    /// </summary>
    public int MinDepth { get; private set; }

    /// <summary>
    /// Gets the maximum depth (0 = no limit).
    /// </summary>
    public int MaxDepth { get; private set; }

    /// <summary>
    /// Gets biomes where this trap appears.
    /// </summary>
    public IReadOnlyList<string> AllowedBiomes { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets architectural styles where this trap fits.
    /// </summary>
    public IReadOnlyList<string> AllowedStyles { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether this trap resets after triggering.
    /// </summary>
    public bool Resettable { get; private set; }

    /// <summary>
    /// Gets the trigger type.
    /// </summary>
    public TrapTriggerType TriggerType { get; private set; }

    /// <summary>
    /// Gets the placement weight for random selection.
    /// </summary>
    public int PlacementWeight { get; private set; }

    private TrapDefinition() { /* JSON deserialization */ }

    /// <summary>
    /// Creates a trap definition.
    /// </summary>
    public static TrapDefinition Create(
        string id,
        string name,
        int baseDetectionDC,
        int baseDisarmDC,
        string damageExpression,
        string damageTypeId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new TrapDefinition
        {
            Id = id,
            Name = name,
            BaseDetectionDC = baseDetectionDC,
            BaseDisarmDC = baseDisarmDC,
            DamageExpression = damageExpression,
            DamageTypeId = damageTypeId,
            PlacementWeight = 100
        };
    }

    /// <summary>
    /// Gets the scaled detection DC for depth.
    /// </summary>
    public int GetScaledDetectionDC(int depth) => BaseDetectionDC + (depth / 2);

    /// <summary>
    /// Gets the scaled disarm DC for depth.
    /// </summary>
    public int GetScaledDisarmDC(int depth) => BaseDisarmDC + (depth / 2);

    /// <summary>
    /// Checks if this trap is valid for the context.
    /// </summary>
    public bool IsValidFor(int depth, string? biomeId, string? styleId)
    {
        if (depth < MinDepth) return false;
        if (MaxDepth > 0 && depth > MaxDepth) return false;

        if (AllowedBiomes.Count > 0 && biomeId != null && !AllowedBiomes.Contains(biomeId))
            return false;

        if (AllowedStyles.Count > 0 && styleId != null && !AllowedStyles.Contains(styleId))
            return false;

        return true;
    }
}

/// <summary>
/// Types of trap triggers.
/// </summary>
public enum TrapTriggerType
{
    /// <summary>Triggers on movement within room.</summary>
    Movement,

    /// <summary>Triggers when opening container.</summary>
    ContainerOpen,

    /// <summary>Triggers on specific tile.</summary>
    PressurePlate,

    /// <summary>Triggers when interacting with object.</summary>
    Interaction
}
```

### TrapInstance Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// A placed trap instance in a dungeon.
/// Detection/disarm state managed in v0.4.0.
/// </summary>
public class TrapInstance : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the room containing this trap.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the trap definition ID.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the detection DC for this instance.
    /// </summary>
    public int DetectionDC { get; private set; }

    /// <summary>
    /// Gets the disarm DC for this instance.
    /// </summary>
    public int DisarmDC { get; private set; }

    /// <summary>
    /// Gets the placement details.
    /// </summary>
    public TrapPlacement Placement { get; private set; }

    private TrapInstance() { /* EF Core */ }

    /// <summary>
    /// Creates a trap instance.
    /// </summary>
    public static TrapInstance Create(
        Guid roomId,
        TrapDefinition definition,
        int depth,
        TrapPlacement placement)
    {
        return new TrapInstance
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            DefinitionId = definition.Id,
            DetectionDC = definition.GetScaledDetectionDC(depth),
            DisarmDC = definition.GetScaledDisarmDC(depth),
            Placement = placement
        };
    }
}
```

### TrapPlacement Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Describes where a trap is placed.
/// </summary>
public readonly record struct TrapPlacement
{
    /// <summary>
    /// Gets the placement location type.
    /// </summary>
    public TrapLocation Location { get; init; }

    /// <summary>
    /// Gets the associated object ID (container, door, etc.).
    /// </summary>
    public string? ObjectId { get; init; }

    /// <summary>
    /// Gets the placement description.
    /// </summary>
    public string Description { get; init; }

    /// <summary>
    /// Creates an entrance trap placement.
    /// </summary>
    public static TrapPlacement AtEntrance(Direction direction) => new()
    {
        Location = TrapLocation.Entrance,
        ObjectId = direction.ToString(),
        Description = $"Near the {direction.ToString().ToLower()} entrance"
    };

    /// <summary>
    /// Creates a floor trap placement.
    /// </summary>
    public static TrapPlacement OnFloor(string description) => new()
    {
        Location = TrapLocation.Floor,
        Description = description
    };

    /// <summary>
    /// Creates a container trap placement.
    /// </summary>
    public static TrapPlacement OnContainer(string containerId) => new()
    {
        Location = TrapLocation.Container,
        ObjectId = containerId,
        Description = "On the container"
    };
}

/// <summary>
/// Where a trap can be placed.
/// </summary>
public enum TrapLocation
{
    Entrance,
    Floor,
    Container,
    Door,
    Wall
}
```

### TrapPlacementService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Places traps during dungeon generation.
/// Does not handle trap mechanics (see v0.4.0).
/// </summary>
public class TrapPlacementService : ITrapPlacementService
{
    private readonly IConfigurationProvider _configurationProvider;
    private readonly ISeededRandomService _randomService;
    private readonly ILogger<TrapPlacementService> _logger;

    public TrapPlacementService(
        IConfigurationProvider configurationProvider,
        ISeededRandomService randomService,
        ILogger<TrapPlacementService> logger)
    {
        _configurationProvider = configurationProvider;
        _randomService = randomService;
        _logger = logger;
    }

    /// <summary>
    /// Generates traps for a room based on context.
    /// </summary>
    public IEnumerable<TrapInstance> GenerateTraps(TrapPlacementContext context)
    {
        var definitions = _configurationProvider.GetTrapDefinitions()
            .Where(d => d.IsValidFor(context.Depth, context.BiomeId, context.ArchitecturalStyleId))
            .ToList();

        if (definitions.Count == 0) yield break;

        var trapCount = CalculateTrapCount(context);

        for (var i = 0; i < trapCount; i++)
        {
            var definition = SelectTrapDefinition(definitions);
            var placement = GeneratePlacement(definition, context, i);

            var trap = TrapInstance.Create(
                context.RoomId,
                definition,
                context.Depth,
                placement);

            _logger.LogInformation("Placed trap '{Definition}' in room {RoomId}",
                definition.Id, context.RoomId);

            yield return trap;
        }
    }

    /// <summary>
    /// Determines if a room should contain traps.
    /// </summary>
    public bool ShouldPlaceTraps(TrapPlacementContext context)
    {
        return context.RoomType switch
        {
            RoomType.Trap => true,
            RoomType.Treasure => _randomService.NextDouble() < 0.7,
            RoomType.Corridor => _randomService.NextDouble() < 0.2,
            RoomType.Boss => _randomService.NextDouble() < 0.3,
            _ => _randomService.NextDouble() < 0.1
        };
    }

    private int CalculateTrapCount(TrapPlacementContext context)
    {
        var baseDensity = context.RoomType switch
        {
            RoomType.Trap => 3,
            RoomType.Treasure => 2,
            RoomType.Corridor => 1,
            _ => 1
        };

        var depthModifier = context.Depth / 5;
        return Math.Min(baseDensity + depthModifier, 5);
    }

    private TrapDefinition SelectTrapDefinition(IList<TrapDefinition> definitions)
    {
        var totalWeight = definitions.Sum(d => d.PlacementWeight);
        var roll = _randomService.Next(0, totalWeight);
        var cumulative = 0;

        foreach (var definition in definitions)
        {
            cumulative += definition.PlacementWeight;
            if (roll < cumulative)
                return definition;
        }

        return definitions[0];
    }

    private TrapPlacement GeneratePlacement(
        TrapDefinition definition,
        TrapPlacementContext context,
        int index)
    {
        return definition.TriggerType switch
        {
            TrapTriggerType.PressurePlate => TrapPlacement.OnFloor($"Floor section {index + 1}"),
            TrapTriggerType.ContainerOpen => TrapPlacement.OnContainer($"chest-{index}"),
            TrapTriggerType.Movement => TrapPlacement.OnFloor("Center of room"),
            _ => TrapPlacement.OnFloor("Hidden location")
        };
    }
}
```

### Configuration: traps.json

```json
{
  "$schema": "../schemas/traps.schema.json",
  "trapDefinitions": [
    {
      "id": "poison-dart",
      "name": "Poison Dart Trap",
      "hiddenDescription": "Small holes line the wall at various heights.",
      "revealedDescription": "A poison dart trap! Tiny holes in the wall conceal spring-loaded darts.",
      "triggerDescription": "Darts shoot from the walls!",
      "baseDetectionDC": 12,
      "baseDisarmDC": 14,
      "damageExpression": "1d4",
      "damageTypeId": "poison",
      "statusEffectIds": ["poisoned-minor"],
      "minDepth": 1,
      "maxDepth": 0,
      "allowedBiomes": [],
      "allowedStyles": ["carved-halls", "ruined-structures"],
      "resettable": true,
      "triggerType": "Movement",
      "placementWeight": 100
    },
    {
      "id": "pit-trap",
      "name": "Concealed Pit",
      "hiddenDescription": "The floor seems solid enough.",
      "revealedDescription": "A concealed pit trap! The floor here is a thin covering over a deep pit.",
      "triggerDescription": "The floor gives way beneath you!",
      "baseDetectionDC": 14,
      "baseDisarmDC": 16,
      "damageExpression": "2d6",
      "damageTypeId": "bludgeoning",
      "statusEffectIds": [],
      "minDepth": 1,
      "maxDepth": 0,
      "allowedBiomes": [],
      "allowedStyles": ["carved-halls", "ancient-temple"],
      "resettable": false,
      "triggerType": "PressurePlate",
      "placementWeight": 80
    },
    {
      "id": "fire-jet",
      "name": "Fire Jet",
      "hiddenDescription": "Strange pipes run along the walls.",
      "revealedDescription": "A fire jet trap! The pipes are connected to a hidden fuel reservoir.",
      "triggerDescription": "Flames blast from the walls!",
      "baseDetectionDC": 15,
      "baseDisarmDC": 17,
      "damageExpression": "3d6",
      "damageTypeId": "fire",
      "statusEffectIds": ["burning"],
      "minDepth": 3,
      "maxDepth": 0,
      "allowedBiomes": ["volcanic-caves"],
      "allowedStyles": ["ancient-temple"],
      "resettable": true,
      "triggerType": "Movement",
      "placementWeight": 60
    },
    {
      "id": "cave-in",
      "name": "Unstable Ceiling",
      "hiddenDescription": "Cracks spider across the ceiling.",
      "revealedDescription": "The ceiling is unstable! Heavy stones could fall with the slightest vibration.",
      "triggerDescription": "The ceiling collapses!",
      "baseDetectionDC": 10,
      "baseDisarmDC": 20,
      "damageExpression": "4d6",
      "damageTypeId": "bludgeoning",
      "statusEffectIds": ["prone"],
      "minDepth": 2,
      "maxDepth": 0,
      "allowedBiomes": ["natural-caves"],
      "allowedStyles": ["natural-caves", "ruined-structures"],
      "resettable": false,
      "triggerType": "Movement",
      "placementWeight": 50
    }
  ]
}
```

### Acceptance Criteria

- [ ] TrapDefinition loads from `traps.json` configuration
- [ ] TrapPlacementService selects appropriate traps for context
- [ ] Detection and disarm DCs scale with depth
- [ ] Trap density varies by room type
- [ ] Biome/style filtering works correctly
- [ ] Placement descriptions are generated
- [ ] ~22 unit tests pass

---

## v0.1.5d: Treasure Vault Generation

### Overview

Implement treasure room templates and guardian assignment. This phase determines vault layouts, assigns guardians, and configures lock types. The actual unlock mechanics are implemented in v0.4.0.

### Scope

**In Scope:**
- `TreasureRoomTemplate` entity for vault designs
- `GuardianAssignment` value object for guardian configuration
- `VaultLockType` enum for lock categories
- `VaultGenerationService` for vault creation
- Guardian monster assignment
- Lock type configuration
- Configuration via `vaults.json`

**Out of Scope (v0.4.0):**
- Unlock mechanics
- Guardian combat integration
- Puzzle-lock solving
- Loot distribution

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `TreasureRoomTemplate` |
| Value Objects | 2 | `GuardianAssignment`, `VaultConfiguration` |
| Enums | 1 | `VaultLockType` |
| Services | 1 | `VaultGenerationService` |
| Configuration | 1 | `vaults.json` |
| Unit Tests | ~21 | Template loading, generation, guardian assignment |

### TreasureRoomTemplate Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a treasure vault template.
/// </summary>
public class TreasureRoomTemplate : IDefinition
{
    /// <summary>
    /// Gets the unique identifier (e.g., "dragon-hoard").
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description template.
    /// </summary>
    public string DescriptionTemplate { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the minimum depth for this vault type.
    /// </summary>
    public int MinDepth { get; private set; }

    /// <summary>
    /// Gets the maximum depth (0 = no limit).
    /// </summary>
    public int MaxDepth { get; private set; }

    /// <summary>
    /// Gets the spawn probability.
    /// </summary>
    public float SpawnProbability { get; private set; }

    /// <summary>
    /// Gets the lock type for this vault.
    /// </summary>
    public VaultLockType LockType { get; private set; }

    /// <summary>
    /// Gets the puzzle template ID if puzzle-locked.
    /// </summary>
    public string? PuzzleTemplateId { get; private set; }

    /// <summary>
    /// Gets the guardian configuration (if any).
    /// </summary>
    public GuardianAssignment? Guardian { get; private set; }

    /// <summary>
    /// Gets the loot table ID.
    /// </summary>
    public string LootTableId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the reward multiplier.
    /// </summary>
    public float RewardMultiplier { get; private set; }

    /// <summary>
    /// Gets biomes where this vault appears.
    /// </summary>
    public IReadOnlyList<string> AllowedBiomes { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets architectural styles for this vault.
    /// </summary>
    public IReadOnlyList<string> AllowedStyles { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets trap IDs that guard this vault.
    /// </summary>
    public IReadOnlyList<string> TrapIds { get; private set; } = Array.Empty<string>();

    private TreasureRoomTemplate() { /* JSON deserialization */ }

    /// <summary>
    /// Creates a treasure room template.
    /// </summary>
    public static TreasureRoomTemplate Create(
        string id,
        string name,
        string descriptionTemplate,
        VaultLockType lockType,
        string lootTableId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new TreasureRoomTemplate
        {
            Id = id,
            Name = name,
            DescriptionTemplate = descriptionTemplate,
            LockType = lockType,
            LootTableId = lootTableId,
            RewardMultiplier = 1.0f
        };
    }

    /// <summary>
    /// Checks if valid for context.
    /// </summary>
    public bool IsValidFor(int depth, string? biomeId, string? styleId)
    {
        if (depth < MinDepth) return false;
        if (MaxDepth > 0 && depth > MaxDepth) return false;

        if (AllowedBiomes.Count > 0 && biomeId != null && !AllowedBiomes.Contains(biomeId))
            return false;

        if (AllowedStyles.Count > 0 && styleId != null && !AllowedStyles.Contains(styleId))
            return false;

        return true;
    }
}

/// <summary>
/// Types of vault locks.
/// </summary>
public enum VaultLockType
{
    /// <summary>No lock, freely accessible.</summary>
    None,

    /// <summary>Requires defeating guardian.</summary>
    Guardian,

    /// <summary>Requires solving puzzle.</summary>
    Puzzle,

    /// <summary>Requires both guardian and puzzle.</summary>
    GuardianAndPuzzle,

    /// <summary>Requires a specific key item.</summary>
    Key
}
```

### GuardianAssignment Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a vault guardian.
/// </summary>
public readonly record struct GuardianAssignment
{
    /// <summary>
    /// Gets the monster definition ID.
    /// </summary>
    public string MonsterDefinitionId { get; init; }

    /// <summary>
    /// Gets the guardian's display name.
    /// </summary>
    public string Name { get; init; }

    /// <summary>
    /// Gets the introduction text when encountered.
    /// </summary>
    public string IntroductionText { get; init; }

    /// <summary>
    /// Gets the defeat text.
    /// </summary>
    public string DefeatText { get; init; }

    /// <summary>
    /// Gets the level offset from dungeon depth.
    /// </summary>
    public int LevelOffset { get; init; }

    /// <summary>
    /// Gets bonus trait IDs for this guardian.
    /// </summary>
    public IReadOnlyList<string> BonusTraitIds { get; init; }

    /// <summary>
    /// Creates a guardian assignment.
    /// </summary>
    public static GuardianAssignment Create(
        string monsterDefinitionId,
        string name,
        int levelOffset = 0)
    {
        return new GuardianAssignment
        {
            MonsterDefinitionId = monsterDefinitionId,
            Name = name,
            IntroductionText = string.Empty,
            DefeatText = string.Empty,
            LevelOffset = levelOffset,
            BonusTraitIds = Array.Empty<string>()
        };
    }
}
```

### VaultConfiguration Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a generated vault instance.
/// </summary>
public readonly record struct VaultConfiguration
{
    /// <summary>
    /// Gets the template ID.
    /// </summary>
    public string TemplateId { get; init; }

    /// <summary>
    /// Gets the lock type.
    /// </summary>
    public VaultLockType LockType { get; init; }

    /// <summary>
    /// Gets the puzzle instance ID if puzzle-locked.
    /// </summary>
    public Guid? PuzzleId { get; init; }

    /// <summary>
    /// Gets the guardian monster definition ID if guardian-locked.
    /// </summary>
    public string? GuardianDefinitionId { get; init; }

    /// <summary>
    /// Gets the guardian level.
    /// </summary>
    public int GuardianLevel { get; init; }

    /// <summary>
    /// Gets the required key item ID if key-locked.
    /// </summary>
    public string? RequiredKeyId { get; init; }

    /// <summary>
    /// Gets the loot table ID.
    /// </summary>
    public string LootTableId { get; init; }

    /// <summary>
    /// Gets the reward multiplier.
    /// </summary>
    public float RewardMultiplier { get; init; }

    /// <summary>
    /// Gets trap instance IDs placed in this vault.
    /// </summary>
    public IReadOnlyList<Guid> TrapIds { get; init; }
}
```

### VaultGenerationService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Generates treasure vaults during dungeon generation.
/// Does not handle unlock mechanics (see v0.4.0).
/// </summary>
public class VaultGenerationService : IVaultGenerationService
{
    private readonly IConfigurationProvider _configurationProvider;
    private readonly IPuzzlePlacementService _puzzlePlacementService;
    private readonly ITrapPlacementService _trapPlacementService;
    private readonly ISeededRandomService _randomService;
    private readonly ILogger<VaultGenerationService> _logger;

    public VaultGenerationService(
        IConfigurationProvider configurationProvider,
        IPuzzlePlacementService puzzlePlacementService,
        ITrapPlacementService trapPlacementService,
        ISeededRandomService randomService,
        ILogger<VaultGenerationService> logger)
    {
        _configurationProvider = configurationProvider;
        _puzzlePlacementService = puzzlePlacementService;
        _trapPlacementService = trapPlacementService;
        _randomService = randomService;
        _logger = logger;
    }

    /// <summary>
    /// Generates a treasure vault.
    /// </summary>
    public VaultGenerationResult? GenerateVault(VaultGenerationContext context)
    {
        var templates = _configurationProvider.GetTreasureRoomTemplates()
            .Where(t => t.IsValidFor(context.Depth, context.BiomeId, context.ArchitecturalStyleId))
            .ToList();

        if (templates.Count == 0)
        {
            _logger.LogDebug("No valid vault templates for depth {Depth}", context.Depth);
            return null;
        }

        var template = SelectTemplate(templates, context);
        var room = CreateVaultRoom(template, context);
        var puzzle = CreateVaultPuzzle(template, room.Id, context);
        var traps = CreateVaultTraps(template, room.Id, context);
        var configuration = CreateConfiguration(template, puzzle, traps, context);

        _logger.LogInformation("Generated vault '{Template}' at depth {Depth}",
            template.Id, context.Depth);

        return new VaultGenerationResult
        {
            Room = room,
            Template = template,
            Puzzle = puzzle,
            Traps = traps.ToList(),
            Configuration = configuration
        };
    }

    /// <summary>
    /// Determines if a room should be a vault.
    /// </summary>
    public bool ShouldGenerateVault(VaultGenerationContext context)
    {
        if (context.RoomType != RoomType.Treasure) return false;

        var templates = _configurationProvider.GetTreasureRoomTemplates()
            .Where(t => t.IsValidFor(context.Depth, context.BiomeId, context.ArchitecturalStyleId));

        return templates.Any();
    }

    private TreasureRoomTemplate SelectTemplate(
        IList<TreasureRoomTemplate> templates,
        VaultGenerationContext context)
    {
        var totalProbability = templates.Sum(t => t.SpawnProbability);
        var roll = (float)(_randomService.NextDouble() * totalProbability);
        var cumulative = 0f;

        foreach (var template in templates)
        {
            cumulative += template.SpawnProbability;
            if (roll < cumulative)
                return template;
        }

        return templates[0];
    }

    private Room CreateVaultRoom(TreasureRoomTemplate template, VaultGenerationContext context)
    {
        return Room.Create(
            context.DungeonId,
            template.Name,
            template.DescriptionTemplate,
            context.Position,
            RoomType.Treasure);
    }

    private PuzzleInstance? CreateVaultPuzzle(
        TreasureRoomTemplate template,
        Guid roomId,
        VaultGenerationContext context)
    {
        if (template.LockType is not (VaultLockType.Puzzle or VaultLockType.GuardianAndPuzzle))
            return null;

        if (string.IsNullOrEmpty(template.PuzzleTemplateId))
            return null;

        var puzzleContext = new PuzzlePlacementContext
        {
            RoomId = roomId,
            Depth = context.Depth,
            BiomeId = context.BiomeId,
            WorldSeed = context.WorldSeed,
            RoomType = RoomType.Treasure
        };

        return _puzzlePlacementService.GeneratePuzzle(puzzleContext);
    }

    private IEnumerable<TrapInstance> CreateVaultTraps(
        TreasureRoomTemplate template,
        Guid roomId,
        VaultGenerationContext context)
    {
        if (template.TrapIds.Count == 0)
            yield break;

        var trapContext = new TrapPlacementContext
        {
            RoomId = roomId,
            Depth = context.Depth,
            BiomeId = context.BiomeId,
            ArchitecturalStyleId = context.ArchitecturalStyleId,
            RoomType = RoomType.Treasure
        };

        foreach (var trap in _trapPlacementService.GenerateTraps(trapContext))
        {
            yield return trap;
        }
    }

    private VaultConfiguration CreateConfiguration(
        TreasureRoomTemplate template,
        PuzzleInstance? puzzle,
        IEnumerable<TrapInstance> traps,
        VaultGenerationContext context)
    {
        return new VaultConfiguration
        {
            TemplateId = template.Id,
            LockType = template.LockType,
            PuzzleId = puzzle?.Id,
            GuardianDefinitionId = template.Guardian?.MonsterDefinitionId,
            GuardianLevel = context.Depth + (template.Guardian?.LevelOffset ?? 0),
            LootTableId = template.LootTableId,
            RewardMultiplier = template.RewardMultiplier,
            TrapIds = traps.Select(t => t.Id).ToList()
        };
    }
}
```

### Configuration: vaults.json

```json
{
  "$schema": "../schemas/vaults.schema.json",
  "treasureRoomTemplates": [
    {
      "id": "minor-cache",
      "name": "Hidden Cache",
      "descriptionTemplate": "A small chamber stacked with crates and forgotten supplies.",
      "minDepth": 1,
      "maxDepth": 5,
      "spawnProbability": 0.15,
      "lockType": "None",
      "puzzleTemplateId": null,
      "guardian": null,
      "lootTableId": "vault-minor",
      "rewardMultiplier": 1.0,
      "allowedBiomes": [],
      "allowedStyles": [],
      "trapIds": []
    },
    {
      "id": "guarded-treasury",
      "name": "Guarded Treasury",
      "descriptionTemplate": "An imposing chamber filled with gleaming treasure. A fearsome guardian stands watch.",
      "minDepth": 3,
      "maxDepth": 0,
      "spawnProbability": 0.08,
      "lockType": "Guardian",
      "puzzleTemplateId": null,
      "guardian": {
        "monsterDefinitionId": "guardian-construct",
        "name": "Treasury Guardian",
        "introductionText": "A massive construct stirs to life, ancient runes blazing.",
        "defeatText": "The guardian crumbles. The treasury is yours.",
        "levelOffset": 2,
        "bonusTraitIds": ["resilient"]
      },
      "lootTableId": "vault-guarded",
      "rewardMultiplier": 1.5,
      "allowedBiomes": [],
      "allowedStyles": ["carved-halls", "ancient-temple"],
      "trapIds": ["poison-dart", "pit-trap"]
    },
    {
      "id": "puzzle-vault",
      "name": "Sealed Vault",
      "descriptionTemplate": "A perfectly preserved vault sealed by ancient mechanisms.",
      "minDepth": 4,
      "maxDepth": 0,
      "spawnProbability": 0.06,
      "lockType": "Puzzle",
      "puzzleTemplateId": "combination-lock",
      "guardian": null,
      "lootTableId": "vault-sealed",
      "rewardMultiplier": 1.75,
      "allowedBiomes": [],
      "allowedStyles": ["ancient-temple"],
      "trapIds": ["fire-jet"]
    },
    {
      "id": "dragon-hoard",
      "name": "Dragon's Hoard",
      "descriptionTemplate": "A vast cavern glittering with gold and jewels. An ancient dragon guards this legendary treasure.",
      "minDepth": 8,
      "maxDepth": 0,
      "spawnProbability": 0.02,
      "lockType": "GuardianAndPuzzle",
      "puzzleTemplateId": "cave-riddle",
      "guardian": {
        "monsterDefinitionId": "ancient-dragon",
        "name": "Hoard Guardian",
        "introductionText": "Ancient eyes open. 'Who dares disturb my slumber?'",
        "defeatText": "The dragon falls. The legendary hoard is finally yours.",
        "levelOffset": 5,
        "bonusTraitIds": ["legendary", "fire-breath"]
      },
      "lootTableId": "vault-legendary",
      "rewardMultiplier": 3.0,
      "allowedBiomes": ["volcanic-caves"],
      "allowedStyles": ["natural-caves"],
      "trapIds": ["fire-jet", "cave-in"]
    }
  ]
}
```

### Acceptance Criteria

- [ ] TreasureRoomTemplate loads from `vaults.json` configuration
- [ ] VaultGenerationService selects appropriate templates
- [ ] GuardianAssignment configures guardian monsters correctly
- [ ] Puzzle-locked vaults link to PuzzlePlacementService
- [ ] Trap placement integrates correctly
- [ ] VaultConfiguration captures all lock requirements
- [ ] ~21 unit tests pass

---

## Dependencies & Prerequisites

```
v0.1.4 (World Persistence & Evolution) - REQUIRED
    â”‚
    â””â”€â”€ RoomState, BiomeDefinition, ArchitecturalStyle,
        LandmarkRoom, MonsterDefinition, LootTable
                                            â”‚
                                            â–¼
v0.1.5 (Procedural Puzzles & Secrets) - GENERATION ONLY
    â”‚
    â”œâ”€â”€ v0.1.5a: Puzzle Placement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚       Provides: PuzzleTemplate, PuzzleInstance    â”‚
    â”‚                                                   â”‚
    â”œâ”€â”€ v0.1.5b: Secret Room Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚       Provides: SecretRoomTemplate, HiddenPassage â”‚
    â”‚                                                   â”‚
    â”œâ”€â”€ v0.1.5c: Trap Placement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚       Provides: TrapDefinition, TrapInstance      â”‚
    â”‚                                                   â”‚
    â””â”€â”€ v0.1.5d: Treasure Vault Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            Provides: TreasureRoomTemplate, VaultConfiguration
            Uses: v0.1.5a (puzzles), v0.1.5c (traps)
                                            â”‚
                                            â–¼
v0.4.0 (Interactive Environment & Puzzles) - INTERACTION
    â”‚
    â””â”€â”€ Implements: solve, search, disarm commands,
        skill checks, damage application, state tracking
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.1.5a | ~7 | ~2 | ~22 | Medium |
| v0.1.5b | ~5 | ~2 | ~20 | Medium |
| v0.1.5c | ~6 | ~2 | ~22 | Medium |
| v0.1.5d | ~5 | ~3 | ~21 | Medium |
| **Total** | **~23** | **~9** | **~85** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| v0.4.0 scope creep into generation | Medium | Medium | Clear scope boundaries documented |
| Template flexibility insufficient | Low | Low | Design for extensibility |
| DC scaling imbalance | Medium | Low | Tune in v0.4.0 testing |
| Integration complexity with dungeon generator | Medium | Medium | Define clear interfaces |

---

## Design Decisions (Confirmed)

### Scope Separation

| Decision | Value | Notes |
|----------|-------|-------|
| **v0.1.5 responsibility** | Generation/placement only | No interaction mechanics |
| **v0.4.0 responsibility** | Player interaction | Solve, search, disarm, trigger |
| **State tracking** | Deferred to v0.4.0 | Entities store config, not state |

### Puzzle Placement

| Decision | Value | Notes |
|----------|-------|-------|
| **Puzzle types** | 6 base types | Sequence, Combination, Riddle, Pattern, Matching, Tile |
| **Difficulty scaling** | Depth / 3 bonus | Gradual increase |
| **Solution storage** | PuzzleSolution value object | Validated in v0.4.0 |

### Secret Placement

| Decision | Value | Notes |
|----------|-------|-------|
| **DC scaling** | Depth / 2 bonus | Moderate scaling |
| **Max secrets per room** | 1 | Prevents over-discovery |
| **Probability adjustment** | Biome/style bonuses | +50% / +30% |

### Trap Placement

| Decision | Value | Notes |
|----------|-------|-------|
| **Density by room type** | Trap: 3, Treasure: 2, Corridor: 1 | Plus depth modifier |
| **DC storage** | Detection and disarm DCs | Used in v0.4.0 |
| **Biome/style filtering** | Required match if specified | Empty = all allowed |

### Vault Generation

| Decision | Value | Notes |
|----------|-------|-------|
| **Lock types** | 5 types | None, Guardian, Puzzle, Both, Key |
| **Guardian level** | Depth + offset | Configurable per template |
| **Reward multiplier** | 1.0 - 3.0x | Applied in v0.4.0 loot distribution |

---

## Integration with v0.4.0

When v0.4.0 is implemented, it will:

1. **Add state tracking** to PuzzleInstance, HiddenPassage, TrapInstance
2. **Implement commands**: `solve`, `search`, `disarm`, `interact`
3. **Add skill checks**: Perception for secrets/traps, various for puzzles
4. **Handle triggers**: Trap damage, puzzle rewards, secret reveals
5. **Manage state persistence**: Solved puzzles, discovered secrets, disarmed traps

The entities created in v0.1.5 are designed to be extended with additional properties for state tracking without breaking changes.

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown with stakeholders
2. **v0.1.5a Design Spec** - Create detailed design specification for Puzzle Placement
3. **Implement v0.1.5a** - Build puzzle templates and placement service
4. **Repeat for v0.1.5b, v0.1.5c, v0.1.5d**

---

*This scope breakdown provides a structured approach to implementing v0.1.5 Procedural Puzzles & Secrets with clear separation from v0.4.0 interaction mechanics. Each sub-phase focuses on generation logic, deferring player interaction to the appropriate version.*
