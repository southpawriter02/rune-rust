# v0.1.4d Design Specification: Environmental Storytelling & Dungeon Evolution Events

**Version:** 0.1.4d
**Phase Name:** Environmental Storytelling & Dungeon Evolution Events
**Parent Version:** v0.1.4 (World Persistence & Evolution)
**Prerequisites:** v0.1.4c Complete (Faction Territory Control)
**Estimated Tests:** ~35 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Environmental Storytelling](#4-environmental-storytelling)
5. [EnvironmentalEvidence Entity](#5-environmentalevidence-entity)
6. [WorldEvent Entity](#6-worldevent-entity)
7. [Dungeon Evolution Events](#7-dungeon-evolution-events)
8. [EvolutionService](#8-evolutionservice)
9. [Time-Based Changes](#9-time-based-changes)
10. [Configuration File Schemas](#10-configuration-file-schemas)
11. [Data Model Changes](#11-data-model-changes)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement environmental storytelling and dungeon evolution events that bring dungeons to life with procedural evidence of past events and dynamic world changes over time. This final phase of v0.1.4 completes the World Persistence & Evolution milestone by adding visual evidence of battles and activities (dead monsters, broken equipment), time-based environmental changes (fires burning out), and major dungeon evolution events (cave-ins, monster migrations, seasonal effects). Players encounter a world that tells stories through its environment and evolves in response to time and events.

### 1.2 Current State

| Area | Current State (v0.1.4c) | Target State (v0.1.4d) |
|------|-------------------------|------------------------|
| Battle aftermath | None | Dead monsters, broken equipment evidence |
| Time progression | Static environments | Time-based changes (fires burn out) |
| Path changes | Static dungeon layout | Cave-ins can alter paths |
| Monster movement | Spawner-based only | Migrations between zones |
| Seasonal effects | None | Environmental seasonal changes |
| World events | Faction conflicts only | Scheduled world evolution events |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `EnvironmentalEvidence`, `WorldEvent` |
| **Enums** | `EvidenceType`, `WorldEventType`, `SeasonalEffect` |
| **Value Objects** | `BattleSite`, `TimedChange`, `MigrationPath`, `CaveInResult` |
| **Services** | `EvolutionService` (with `IEvolutionService` interface) |
| **Configuration** | `evolution-events.json`, `evolution-events-schema.json` |
| **Integration** | Updated WorldStateService, save/load for full world state |
| **Tests** | ~35 new unit tests |

### 1.4 Architectural Significance

This version establishes the **environmental narrative pattern** that creates storytelling dungeons:
- Procedural evidence generation for environmental storytelling
- Time-based state changes for dynamic environments
- Scheduled world events for dungeon evolution
- Integration with WorldStateService for persistence
- Integration with TerritoryService for faction-driven evidence
- Foundation for future narrative and quest systems

---

## 2. Feature Overview

```
v0.1.4d Environmental Storytelling & Dungeon Evolution Events
├── Environmental Storytelling
│   ├── EnvironmentalEvidence Entity
│   │   ├── Evidence type identification
│   │   ├── Creation timestamp
│   │   ├── Decay/expiration tracking
│   │   ├── Associated room reference
│   │   └── Descriptive narrative text
│   ├── Battle Sites
│   │   ├── Dead monster corpses
│   │   ├── Broken equipment remains
│   │   ├── Blood/damage evidence
│   │   └── Combat debris generation
│   └── Time-Based Changes
│       ├── Fire burnout tracking
│       ├── Torch/light expiration
│       ├── Water level changes
│       └── Decay progression
├── WorldEvent Entity
│   ├── Event type identification
│   ├── Scheduled trigger time
│   ├── Affected room(s) reference
│   ├── Event parameters
│   ├── Completion status
│   └── Result tracking
├── Dungeon Evolution Events
│   ├── Cave-Ins
│   │   ├── Path blockage/alteration
│   │   ├── New passage creation
│   │   └── Structural damage effects
│   ├── Monster Migrations
│   │   ├── Population shifts between zones
│   │   ├── Faction-driven movements
│   │   └── Seasonal migration patterns
│   └── Seasonal Effects
│       ├── Temperature changes
│       ├── Environmental hazards
│       └── Resource availability
├── EvolutionService
│   ├── ScheduleEvent(eventType, trigger, parameters)
│   ├── ProcessScheduledEvents()
│   ├── TriggerCaveIn(roomId, severity)
│   ├── TriggerMigration(factionId, fromRooms, toRooms)
│   ├── ApplySeasonalEffect(effect)
│   ├── CreateBattleEvidence(roomId, combatResult)
│   ├── ProcessTimeBasedChanges()
│   ├── GetActiveEvents()
│   └── GetRoomEvidence(roomId)
└── Configuration
    ├── evolution-events.json
    └── evolution-events-schema.json
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Environmental evidence affects displayed content and narrative              │
│  ├── Room descriptions include evidence details                             │
│  ├── Battle sites show corpses and debris                                   │
│  ├── Time-based changes reflected in environment                            │
│  ├── Cave-in effects shown in map and navigation                            │
│  └── Seasonal effects modify ambience and descriptions                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  EvolutionService                                                            │
│  ├── ScheduleEvent(type, trigger, params)  ├── TriggerCaveIn(roomId)        │
│  ├── ProcessScheduledEvents()              ├── TriggerMigration(faction)    │
│  ├── CreateBattleEvidence(roomId, result)  ├── ApplySeasonalEffect(effect)  │
│  ├── ProcessTimeBasedChanges()             ├── GetActiveEvents()            │
│  ├── GetRoomEvidence(roomId)               └── RemoveExpiredEvidence()      │
│  │                                                                          │
│  Interfaces:                        WorldStateService (v0.1.4a Updated)     │
│  └── IEvolutionService              └── Tracks evidence as persistent state │
│                                                                              │
│  TerritoryService (v0.1.4c)         RepopulationService (v0.1.4b Updated)   │
│  └── Triggers migration events      └── Updated for migration support       │
│                                                                              │
│  Configuration:                                                              │
│  └── EvolutionEventsConfigDto                                               │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Entities:                       Value Objects:                              │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                │
│  │ EnvironmentalEvidence   │     │ BattleSite              │                │
│  │ ├── Id: Guid            │     │ ├── Location: Guid      │                │
│  │ ├── RoomId: Guid        │     │ ├── CombatantsKilled    │                │
│  │ ├── EvidenceType        │     │ ├── EquipmentDropped    │                │
│  │ ├── Description: string │     │ ├── Timestamp: DateTime │                │
│  │ ├── CreatedAt: DateTime │     │ └── Severity: int       │                │
│  │ ├── ExpiresAt: DateTime?│     └─────────────────────────┘                │
│  │ └── IsExpired: bool     │     ┌─────────────────────────┐                │
│  └─────────────────────────┘     │ TimedChange             │                │
│                                  │ ├── TargetId: Guid      │                │
│  ┌─────────────────────────┐     │ ├── ChangeType: string  │                │
│  │ WorldEvent              │     │ ├── StartTime: DateTime │                │
│  │ ├── Id: Guid            │     │ ├── Duration: TimeSpan  │                │
│  │ ├── EventType           │     │ └── CurrentPhase: int   │                │
│  │ ├── ScheduledTime       │     └─────────────────────────┘                │
│  │ ├── TargetRoomIds       │     ┌─────────────────────────┐                │
│  │ ├── Parameters          │     │ MigrationPath           │                │
│  │ ├── Status              │     │ ├── FactionId: string   │                │
│  │ └── Result              │     │ ├── FromRoomIds: List   │                │
│  └─────────────────────────┘     │ ├── ToRoomIds: List     │                │
│                                  │ └── Progress: float     │                │
│  Enums:                          └─────────────────────────┘                │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                │
│  │ EvidenceType            │     │ CaveInResult            │                │
│  │ ├── BattleSite          │     │ ├── BlockedExits: List  │                │
│  │ ├── Corpse              │     │ ├── NewExits: List      │                │
│  │ ├── BrokenEquipment     │     │ ├── DamageLevel: int    │                │
│  │ ├── BloodStain          │     │ └── Debris: List        │                │
│  │ ├── BurnedOut           │     └─────────────────────────┘                │
│  │ ├── Debris              │                                                │
│  │ └── Decay               │                                                │
│  └─────────────────────────┘                                                │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                │
│  │ WorldEventType          │     │ SeasonalEffect          │                │
│  │ ├── CaveIn              │     │ ├── None                │                │
│  │ ├── Migration           │     │ ├── Winter              │                │
│  │ ├── SeasonalChange      │     │ ├── Spring              │                │
│  │ └── EnvironmentalDecay  │     │ ├── Summer              │                │
│  └─────────────────────────┘     │ └── Autumn              │                │
│  ┌─────────────────────────┐     └─────────────────────────┘                │
│  │ WorldEventStatus        │                                                │
│  │ ├── Scheduled           │                                                │
│  │ ├── InProgress          │                                                │
│  │ ├── Completed           │                                                │
│  │ └── Cancelled           │                                                │
│  └─────────────────────────┘                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetEvolutionEventDefinitions(): IReadOnlyList<EvolutionEventDefinition>│
│  └── Loads and deserializes config/evolution-events.json                    │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/evolution-events.json                                           │
│  └── config/schemas/evolution-events-schema.json                            │
│                                                                              │
│  Save/Load Integration:                                                      │
│  └── Full world state persistence (evidence, events, time-based changes)    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Environmental Evidence Generation Flow

```
┌───────────────────────────────────────┐
│ Combat ends in room (CombatService)   │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ EvolutionService.CreateBattleEvidence(roomId, combatResult)   │
├───────────────────────────────────────────────────────────────┤
│ 1. Extract combat details (monsters killed, damage dealt)     │
│ 2. Determine evidence types to generate                       │
│ 3. Calculate evidence decay timers                            │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Generate Evidence Items                                       │
├───────────────────────────────────────────────────────────────┤
│ For each killed monster:                                      │
│   var corpse = EnvironmentalEvidence.CreateCorpse(            │
│       roomId, monsterName, decayDuration);                    │
│                                                               │
│ For each broken item:                                         │
│   var debris = EnvironmentalEvidence.CreateBrokenEquipment(   │
│       roomId, itemName, decayDuration);                       │
│                                                               │
│ If significant battle:                                        │
│   var battleSite = EnvironmentalEvidence.CreateBattleSite(    │
│       roomId, combatResult.Summary, decayDuration);           │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Register Evidence with WorldStateService                      │
├───────────────────────────────────────────────────────────────┤
│ WorldStateService.AddPersistentChange(                        │
│     roomId,                                                   │
│     PersistentChangeType.EvidenceAdded,                       │
│     evidence.Id);                                             │
│                                                               │
│ Log: "Created {EvidenceCount} evidence items in {RoomName}"   │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 World Event Processing Flow

```
┌───────────────────────────────────────────────────────────────┐
│ EvolutionService.ProcessScheduledEvents() [called periodically]│
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Get all scheduled events where ScheduledTime <= Now           │
├───────────────────────────────────────────────────────────────┤
│ var dueEvents = _scheduledEvents                              │
│     .Where(e => e.Status == WorldEventStatus.Scheduled)       │
│     .Where(e => e.ScheduledTime <= DateTime.UtcNow)           │
│     .OrderBy(e => e.ScheduledTime);                           │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Process each due event by type                                │
├───────────────────────────────────────────────────────────────┤
│ foreach (var worldEvent in dueEvents)                         │
│ {                                                             │
│     worldEvent.SetStatus(WorldEventStatus.InProgress);        │
│                                                               │
│     switch (worldEvent.EventType)                             │
│     {                                                         │
│         case WorldEventType.CaveIn:                           │
│             ProcessCaveIn(worldEvent);                        │
│             break;                                            │
│         case WorldEventType.Migration:                        │
│             ProcessMigration(worldEvent);                     │
│             break;                                            │
│         case WorldEventType.SeasonalChange:                   │
│             ProcessSeasonalChange(worldEvent);                │
│             break;                                            │
│         case WorldEventType.EnvironmentalDecay:               │
│             ProcessEnvironmentalDecay(worldEvent);            │
│             break;                                            │
│     }                                                         │
│                                                               │
│     worldEvent.SetStatus(WorldEventStatus.Completed);         │
│ }                                                             │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 Cave-In Event Flow

```
┌───────────────────────────────────────────────────────────────┐
│ EvolutionService.TriggerCaveIn(roomId, severity)              │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Validate cave-in target                               │
├───────────────────────────────────────────────────────────────┤
│ - Room exists and is tracked                                  │
│ - Room type supports cave-ins (not outdoors, etc.)            │
│ - Severity is valid (1-100)                                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Determine cave-in effects based on severity           │
├───────────────────────────────────────────────────────────────┤
│ severity 1-30 (Minor):                                        │
│   - Create debris evidence                                    │
│   - No path changes                                           │
│                                                               │
│ severity 31-70 (Moderate):                                    │
│   - Create debris evidence                                    │
│   - May block one exit (random selection)                     │
│   - Small chance of revealing hidden passage                  │
│                                                               │
│ severity 71-100 (Severe):                                     │
│   - Heavy debris evidence                                     │
│   - Block 1-2 exits                                           │
│   - Higher chance of new passage                              │
│   - Potential monster casualties                              │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Apply cave-in results                                 │
├───────────────────────────────────────────────────────────────┤
│ // Block exits if applicable                                  │
│ foreach (var exitId in result.BlockedExits)                   │
│ {                                                             │
│     room.BlockExit(exitId);                                   │
│     WorldStateService.AddPersistentChange(                    │
│         roomId, PersistentChangeType.ExitBlocked, exitId);    │
│ }                                                             │
│                                                               │
│ // Create new passages if applicable                          │
│ foreach (var newExit in result.NewExits)                      │
│ {                                                             │
│     room.AddExit(newExit);                                    │
│     WorldStateService.AddPersistentChange(                    │
│         roomId, PersistentChangeType.ExitCreated, newExit);   │
│ }                                                             │
│                                                               │
│ // Add debris evidence                                        │
│ CreateDebrisEvidence(roomId, result.Debris);                  │
│                                                               │
│ Log: "Cave-in in {RoomName}: {BlockedCount} exits blocked,    │
│       {NewCount} new passages"                                │
└───────────────────────────────────────────────────────────────┘
```

### 3.5 Monster Migration Flow

```
┌───────────────────────────────────────────────────────────────┐
│ EvolutionService.TriggerMigration(factionId, fromRooms,       │
│                                   toRooms)                    │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Validate migration parameters                         │
├───────────────────────────────────────────────────────────────┤
│ - Faction exists and is active                                │
│ - Source rooms are controlled by faction                      │
│ - Target rooms are accessible (not permanently cleared)       │
│ - Migration path is valid (connected rooms)                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Calculate migration details                           │
├───────────────────────────────────────────────────────────────┤
│ var migrationPath = MigrationPath.Create(                     │
│     factionId, fromRooms, toRooms);                           │
│                                                               │
│ // Determine monsters to move                                 │
│ var monstersToMove = GetFactionMonstersInRooms(               │
│     factionId, fromRooms);                                    │
│                                                               │
│ // Calculate migration duration based on distance             │
│ var duration = CalculateMigrationDuration(fromRooms, toRooms);│
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Execute migration                                     │
├───────────────────────────────────────────────────────────────┤
│ // Remove faction control from source rooms                   │
│ foreach (var roomId in fromRooms)                             │
│ {                                                             │
│     TerritoryService.ClearRoomControl(roomId);                │
│     CreateMigrationEvidence(roomId, "abandoned");             │
│ }                                                             │
│                                                               │
│ // Establish control in target rooms                          │
│ foreach (var roomId in toRooms)                               │
│ {                                                             │
│     TerritoryService.SetRoomControl(roomId, factionId);       │
│     RepopulationService.SetRespawnTimer(roomId);              │
│     CreateMigrationEvidence(roomId, "newly_occupied");        │
│ }                                                             │
│                                                               │
│ Log: "Faction {FactionName} migrated from {FromCount} rooms   │
│       to {ToCount} rooms"                                     │
└───────────────────────────────────────────────────────────────┘
```

### 3.6 Time-Based Changes Flow

```
┌───────────────────────────────────────────────────────────────┐
│ EvolutionService.ProcessTimeBasedChanges() [called regularly] │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Process active timed changes                          │
├───────────────────────────────────────────────────────────────┤
│ foreach (var change in _activeTimedChanges)                   │
│ {                                                             │
│     var elapsed = DateTime.UtcNow - change.StartTime;         │
│     var progress = elapsed / change.Duration;                 │
│                                                               │
│     if (progress >= 1.0)                                      │
│     {                                                         │
│         CompleteTimedChange(change);                          │
│     }                                                         │
│     else                                                      │
│     {                                                         │
│         UpdateTimedChangePhase(change, progress);             │
│     }                                                         │
│ }                                                             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Process expiring evidence                             │
├───────────────────────────────────────────────────────────────┤
│ var expiredEvidence = _evidence                               │
│     .Where(e => e.IsExpired)                                  │
│     .ToList();                                                │
│                                                               │
│ foreach (var evidence in expiredEvidence)                     │
│ {                                                             │
│     RemoveEvidence(evidence);                                 │
│     WorldStateService.AddPersistentChange(                    │
│         evidence.RoomId,                                      │
│         PersistentChangeType.EvidenceRemoved,                 │
│         evidence.Id);                                         │
│ }                                                             │
│                                                               │
│ Log: "Processed {ChangedCount} time-based changes,            │
│       removed {ExpiredCount} expired evidence"                │
└───────────────────────────────────────────────────────────────┘
```

---

## 4. Environmental Storytelling

### 4.1 Purpose

Environmental storytelling creates a sense of history and consequence in the dungeon. When players encounter evidence of past events—corpses, broken equipment, blood stains, burned-out torches—they experience a world that feels lived-in and reactive rather than static and artificial.

### 4.2 Evidence Categories

#### 4.2.1 Battle Sites

Battle sites represent the aftermath of combat. They are generated when combat occurs and provide visual narrative of what happened.

**Evidence Generated:**
- Corpses of defeated monsters (decay over time)
- Broken weapons and armor from combat
- Blood stains and scorch marks
- Combat debris (overturned furniture, broken containers)

**Generation Rules:**
- One corpse evidence per monster killed
- Broken equipment chance: 30% per combat participant
- Blood stain if total damage exceeded threshold
- Battle site marker for fights with 3+ participants

#### 4.2.2 Time-Based Changes

Time-based changes represent the natural progression of environmental state.

**Supported Changes:**
- **Fire Burnout:** Torches and fires transition through phases (bright → dim → embers → cold)
- **Light Expiration:** Magical lights fade over time
- **Water Levels:** Pools may drain or fill based on events
- **Decay Progression:** Organic materials rot, metal rusts, wood warps

**Decay Phases:**
```
Phase 0: Fresh/Active (100% visible, full description)
Phase 1: Fading (75% effect, reduced description)
Phase 2: Deteriorating (50% effect, minimal description)
Phase 3: Nearly Gone (25% effect, bare mention)
Phase 4: Expired (removed from world)
```

### 4.3 Evidence Persistence

All environmental evidence integrates with WorldStateService (v0.1.4a) for persistence:

- Evidence is tracked as PersistentChanges
- Save/load preserves all active evidence
- Expired evidence is cleaned up on load
- Evidence respects room state (cleared rooms may have evidence)

---

## 5. EnvironmentalEvidence Entity

### 5.1 Purpose

The `EnvironmentalEvidence` entity represents a piece of environmental storytelling within a room—corpses, debris, stains, or other evidence of past events.

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/EnvironmentalEvidence.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents environmental evidence that tells stories about past events.
/// </summary>
/// <remarks>
/// Environmental evidence includes battle aftermath (corpses, broken equipment),
/// time-based changes (burned-out fires), and other procedurally generated
/// narrative elements that make the dungeon feel alive and reactive.
/// </remarks>
public class EnvironmentalEvidence
{
    /// <summary>
    /// Gets the unique identifier for this evidence.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the room where this evidence is located.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the type of evidence.
    /// </summary>
    public EvidenceType Type { get; private set; }

    /// <summary>
    /// Gets the narrative description of this evidence.
    /// </summary>
    /// <remarks>
    /// Description text varies based on decay phase, providing
    /// different levels of detail as evidence ages.
    /// </remarks>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the detailed description shown on examination.
    /// </summary>
    public string DetailedDescription { get; private set; } = string.Empty;

    /// <summary>
    /// Gets when this evidence was created.
    /// </summary>
    public DateTime CreatedAt { get; private set; }

    /// <summary>
    /// Gets when this evidence expires (null for permanent evidence).
    /// </summary>
    public DateTime? ExpiresAt { get; private set; }

    /// <summary>
    /// Gets the current decay phase (0-4).
    /// </summary>
    public int DecayPhase { get; private set; }

    /// <summary>
    /// Gets the source entity that created this evidence (e.g., monster ID).
    /// </summary>
    public string? SourceEntityId { get; private set; }

    /// <summary>
    /// Gets whether this evidence has expired.
    /// </summary>
    public bool IsExpired => ExpiresAt.HasValue && DateTime.UtcNow >= ExpiresAt.Value;

    /// <summary>
    /// Gets the remaining time until expiration.
    /// </summary>
    public TimeSpan? TimeRemaining => ExpiresAt.HasValue
        ? ExpiresAt.Value - DateTime.UtcNow
        : null;

    /// <summary>
    /// Gets the visibility multiplier based on decay phase (1.0 to 0.25).
    /// </summary>
    public float VisibilityMultiplier => DecayPhase switch
    {
        0 => 1.0f,
        1 => 0.75f,
        2 => 0.5f,
        3 => 0.25f,
        _ => 0.0f
    };

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private EnvironmentalEvidence() { }

    /// <summary>
    /// Creates new environmental evidence.
    /// </summary>
    /// <param name="roomId">The room containing this evidence.</param>
    /// <param name="type">The type of evidence.</param>
    /// <param name="description">The narrative description.</param>
    /// <param name="detailedDescription">The detailed examination description.</param>
    /// <param name="duration">How long until this evidence expires (null for permanent).</param>
    /// <param name="sourceEntityId">Optional source entity ID.</param>
    public static EnvironmentalEvidence Create(
        Guid roomId,
        EvidenceType type,
        string description,
        string detailedDescription,
        TimeSpan? duration = null,
        string? sourceEntityId = null)
    {
        if (roomId == Guid.Empty)
            throw new ArgumentException("Room ID cannot be empty.", nameof(roomId));

        if (string.IsNullOrWhiteSpace(description))
            throw new ArgumentException("Description cannot be empty.", nameof(description));

        var now = DateTime.UtcNow;

        return new EnvironmentalEvidence
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            Type = type,
            Description = description,
            DetailedDescription = detailedDescription ?? description,
            CreatedAt = now,
            ExpiresAt = duration.HasValue ? now + duration.Value : null,
            DecayPhase = 0,
            SourceEntityId = sourceEntityId
        };
    }

    /// <summary>
    /// Creates corpse evidence from a killed monster.
    /// </summary>
    public static EnvironmentalEvidence CreateCorpse(
        Guid roomId,
        string monsterName,
        string? monsterId = null,
        TimeSpan? decayDuration = null)
    {
        decayDuration ??= TimeSpan.FromHours(24);

        return Create(
            roomId,
            EvidenceType.Corpse,
            $"The corpse of a {monsterName} lies here.",
            $"A dead {monsterName}, its body already beginning to decay. " +
            "The wounds from combat are still visible.",
            decayDuration,
            monsterId);
    }

    /// <summary>
    /// Creates broken equipment evidence.
    /// </summary>
    public static EnvironmentalEvidence CreateBrokenEquipment(
        Guid roomId,
        string equipmentName,
        TimeSpan? decayDuration = null)
    {
        decayDuration ??= TimeSpan.FromHours(48);

        return Create(
            roomId,
            EvidenceType.BrokenEquipment,
            $"Broken {equipmentName} lies discarded on the ground.",
            $"The remains of {equipmentName}, shattered beyond repair. " +
            "Evidence of the violence that occurred here.",
            decayDuration);
    }

    /// <summary>
    /// Creates battle site evidence.
    /// </summary>
    public static EnvironmentalEvidence CreateBattleSite(
        Guid roomId,
        string battleSummary,
        TimeSpan? decayDuration = null)
    {
        decayDuration ??= TimeSpan.FromHours(12);

        return Create(
            roomId,
            EvidenceType.BattleSite,
            "Signs of recent combat are evident throughout this area.",
            $"The aftermath of battle: {battleSummary}. " +
            "Scorch marks, blood stains, and disturbed debris tell the story.",
            decayDuration);
    }

    /// <summary>
    /// Creates blood stain evidence.
    /// </summary>
    public static EnvironmentalEvidence CreateBloodStain(
        Guid roomId,
        TimeSpan? decayDuration = null)
    {
        decayDuration ??= TimeSpan.FromHours(6);

        return Create(
            roomId,
            EvidenceType.BloodStain,
            "Dark stains mark the floor here.",
            "Blood has pooled and begun to dry on the stone floor. " +
            "Something died here recently.",
            decayDuration);
    }

    /// <summary>
    /// Creates burned-out fire evidence.
    /// </summary>
    public static EnvironmentalEvidence CreateBurnedOut(
        Guid roomId,
        string fireSource,
        TimeSpan? duration = null)
    {
        return Create(
            roomId,
            EvidenceType.BurnedOut,
            $"A {fireSource} has burned out, leaving only cold ashes.",
            $"The {fireSource} is now cold and dark. Only ash and charred " +
            "remains mark where the fire once burned.",
            duration);
    }

    /// <summary>
    /// Creates debris evidence.
    /// </summary>
    public static EnvironmentalEvidence CreateDebris(
        Guid roomId,
        string debrisDescription,
        TimeSpan? decayDuration = null)
    {
        return Create(
            roomId,
            EvidenceType.Debris,
            $"Debris litters the area: {debrisDescription}.",
            $"Rubble and debris are scattered about. {debrisDescription}. " +
            "Something significant happened here.",
            decayDuration);
    }

    /// <summary>
    /// Updates the decay phase based on time elapsed.
    /// </summary>
    /// <returns>True if the phase changed.</returns>
    public bool UpdateDecayPhase()
    {
        if (!ExpiresAt.HasValue)
            return false;

        var totalDuration = ExpiresAt.Value - CreatedAt;
        var elapsed = DateTime.UtcNow - CreatedAt;
        var progress = elapsed / totalDuration;

        var newPhase = progress switch
        {
            < 0.25 => 0,
            < 0.50 => 1,
            < 0.75 => 2,
            < 1.0 => 3,
            _ => 4
        };

        if (newPhase != DecayPhase)
        {
            DecayPhase = newPhase;
            UpdateDescriptionForPhase();
            return true;
        }

        return false;
    }

    private void UpdateDescriptionForPhase()
    {
        var prefix = DecayPhase switch
        {
            1 => "Fading ",
            2 => "Deteriorating ",
            3 => "Nearly gone, ",
            _ => ""
        };

        if (DecayPhase > 0 && !Description.StartsWith(prefix))
        {
            Description = prefix + Description.ToLowerInvariant();
        }
    }

    /// <summary>
    /// Gets the description appropriate for the current decay phase.
    /// </summary>
    public string GetPhasedDescription()
    {
        return DecayPhase switch
        {
            0 => Description,
            1 => $"Fading signs: {Description.ToLowerInvariant()}",
            2 => $"Barely visible: {Description.ToLowerInvariant()}",
            3 => $"Almost gone: {Description.ToLowerInvariant()}",
            _ => string.Empty
        };
    }

    /// <summary>
    /// Gets a string representation of the evidence.
    /// </summary>
    public override string ToString() =>
        $"Evidence[{Type}] in Room {RoomId}: {Description} (Phase: {DecayPhase})";
}
```

### 5.4 EvidenceType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/EvidenceType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of environmental evidence that can exist in rooms.
/// </summary>
/// <remarks>
/// Evidence types determine how the evidence is described,
/// how it decays over time, and what events generated it.
/// </remarks>
public enum EvidenceType
{
    /// <summary>
    /// Marks the site of a significant battle.
    /// </summary>
    /// <remarks>
    /// Generated when combat involves multiple participants
    /// or deals significant damage. Includes scorch marks,
    /// disturbed terrain, and general battle damage.
    /// </remarks>
    BattleSite = 0,

    /// <summary>
    /// The corpse of a defeated creature.
    /// </summary>
    /// <remarks>
    /// Generated for each monster killed in combat.
    /// Decays through stages and eventually disappears.
    /// </remarks>
    Corpse = 1,

    /// <summary>
    /// Broken weapons, armor, or equipment.
    /// </summary>
    /// <remarks>
    /// Generated when equipment is destroyed in combat
    /// or when items decay beyond usability.
    /// </remarks>
    BrokenEquipment = 2,

    /// <summary>
    /// Blood stains on surfaces.
    /// </summary>
    /// <remarks>
    /// Generated when significant damage is dealt.
    /// Short decay time.
    /// </remarks>
    BloodStain = 3,

    /// <summary>
    /// A fire source that has burned out.
    /// </summary>
    /// <remarks>
    /// Generated when torches, campfires, or other
    /// fire sources complete their burn duration.
    /// </remarks>
    BurnedOut = 4,

    /// <summary>
    /// Rubble, debris, and scattered remains.
    /// </summary>
    /// <remarks>
    /// Generated by cave-ins, explosions, or
    /// destruction of objects.
    /// </remarks>
    Debris = 5,

    /// <summary>
    /// Evidence of natural decay and deterioration.
    /// </summary>
    /// <remarks>
    /// Generated over time as objects and
    /// environments age.
    /// </remarks>
    Decay = 6
}
```

### 5.5 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `Guid` | Unique identifier | Generated |
| `RoomId` | `Guid` | Location of evidence | Required |
| `Type` | `EvidenceType` | Category of evidence | Required |
| `Description` | `string` | Narrative text | Required |
| `DetailedDescription` | `string` | Examination text | Same as Description |
| `CreatedAt` | `DateTime` | Creation timestamp | Now |
| `ExpiresAt` | `DateTime?` | Expiration time | Null (permanent) |
| `DecayPhase` | `int` | Current decay phase (0-4) | 0 |
| `SourceEntityId` | `string?` | Source entity reference | Null |
| `IsExpired` | `bool` | Computed expiration check | Computed |
| `VisibilityMultiplier` | `float` | Decay-based visibility | 1.0 |

---

## 6. WorldEvent Entity

### 6.1 Purpose

The `WorldEvent` entity represents a scheduled or in-progress dungeon evolution event—cave-ins, monster migrations, seasonal changes, or environmental decay processes.

### 6.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/WorldEvent.cs`

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents a scheduled world evolution event.
/// </summary>
/// <remarks>
/// World events are dungeon-changing occurrences that can alter
/// paths (cave-ins), move populations (migrations), change
/// environmental conditions (seasonal effects), or progress
/// natural decay. Events can be scheduled for future execution
/// or triggered immediately.
/// </remarks>
public class WorldEvent
{
    /// <summary>
    /// Gets the unique identifier for this event.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the type of world event.
    /// </summary>
    public WorldEventType EventType { get; private set; }

    /// <summary>
    /// Gets the scheduled time for this event.
    /// </summary>
    public DateTime ScheduledTime { get; private set; }

    /// <summary>
    /// Gets when this event started processing.
    /// </summary>
    public DateTime? StartedAt { get; private set; }

    /// <summary>
    /// Gets when this event completed.
    /// </summary>
    public DateTime? CompletedAt { get; private set; }

    /// <summary>
    /// Gets the IDs of rooms affected by this event.
    /// </summary>
    public IReadOnlyList<Guid> TargetRoomIds => _targetRoomIds.AsReadOnly();
    private readonly List<Guid> _targetRoomIds = new();

    /// <summary>
    /// Gets the current status of this event.
    /// </summary>
    public WorldEventStatus Status { get; private set; }

    /// <summary>
    /// Gets the event parameters as key-value pairs.
    /// </summary>
    public IReadOnlyDictionary<string, string> Parameters =>
        _parameters.AsReadOnly();
    private readonly Dictionary<string, string> _parameters = new();

    /// <summary>
    /// Gets the result data from event execution.
    /// </summary>
    public IReadOnlyDictionary<string, string> Result =>
        _result.AsReadOnly();
    private readonly Dictionary<string, string> _result = new();

    /// <summary>
    /// Gets the descriptive name for this event.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description of what this event does.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets whether this event can be cancelled.
    /// </summary>
    public bool IsCancellable => Status == WorldEventStatus.Scheduled;

    /// <summary>
    /// Gets whether this event is ready to execute.
    /// </summary>
    public bool IsDue => Status == WorldEventStatus.Scheduled &&
                         DateTime.UtcNow >= ScheduledTime;

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private WorldEvent() { }

    /// <summary>
    /// Creates a new world event.
    /// </summary>
    /// <param name="eventType">The type of event.</param>
    /// <param name="scheduledTime">When the event should trigger.</param>
    /// <param name="targetRoomIds">Rooms affected by the event.</param>
    /// <param name="name">Descriptive name.</param>
    /// <param name="description">Description of the event.</param>
    public static WorldEvent Create(
        WorldEventType eventType,
        DateTime scheduledTime,
        IEnumerable<Guid> targetRoomIds,
        string name,
        string description = "")
    {
        var evt = new WorldEvent
        {
            Id = Guid.NewGuid(),
            EventType = eventType,
            ScheduledTime = scheduledTime,
            Name = name ?? $"{eventType} Event",
            Description = description ?? string.Empty,
            Status = WorldEventStatus.Scheduled
        };

        evt._targetRoomIds.AddRange(targetRoomIds ?? Enumerable.Empty<Guid>());

        return evt;
    }

    /// <summary>
    /// Creates a cave-in event.
    /// </summary>
    public static WorldEvent CreateCaveIn(
        DateTime scheduledTime,
        Guid targetRoomId,
        int severity)
    {
        var evt = Create(
            WorldEventType.CaveIn,
            scheduledTime,
            new[] { targetRoomId },
            "Cave-In",
            $"A cave-in of severity {severity} is scheduled to occur.");

        evt.SetParameter("severity", severity.ToString());

        return evt;
    }

    /// <summary>
    /// Creates a migration event.
    /// </summary>
    public static WorldEvent CreateMigration(
        DateTime scheduledTime,
        string factionId,
        IEnumerable<Guid> fromRoomIds,
        IEnumerable<Guid> toRoomIds)
    {
        var allRooms = fromRoomIds.Concat(toRoomIds).Distinct();
        var evt = Create(
            WorldEventType.Migration,
            scheduledTime,
            allRooms,
            $"Faction Migration: {factionId}",
            $"Faction {factionId} is migrating to new territory.");

        evt.SetParameter("factionId", factionId);
        evt.SetParameter("fromRoomIds", string.Join(",", fromRoomIds));
        evt.SetParameter("toRoomIds", string.Join(",", toRoomIds));

        return evt;
    }

    /// <summary>
    /// Creates a seasonal change event.
    /// </summary>
    public static WorldEvent CreateSeasonalChange(
        DateTime scheduledTime,
        SeasonalEffect newSeason,
        IEnumerable<Guid> affectedRoomIds)
    {
        var evt = Create(
            WorldEventType.SeasonalChange,
            scheduledTime,
            affectedRoomIds,
            $"Seasonal Change: {newSeason}",
            $"The season is changing to {newSeason}.");

        evt.SetParameter("season", newSeason.ToString());

        return evt;
    }

    /// <summary>
    /// Creates an environmental decay event.
    /// </summary>
    public static WorldEvent CreateEnvironmentalDecay(
        DateTime scheduledTime,
        IEnumerable<Guid> affectedRoomIds)
    {
        return Create(
            WorldEventType.EnvironmentalDecay,
            scheduledTime,
            affectedRoomIds,
            "Environmental Decay",
            "Natural decay processes are progressing.");
    }

    /// <summary>
    /// Sets a parameter for this event.
    /// </summary>
    public void SetParameter(string key, string value)
    {
        if (string.IsNullOrWhiteSpace(key))
            throw new ArgumentException("Parameter key cannot be empty.", nameof(key));

        _parameters[key] = value ?? string.Empty;
    }

    /// <summary>
    /// Gets a parameter value.
    /// </summary>
    public string? GetParameter(string key)
    {
        return _parameters.TryGetValue(key, out var value) ? value : null;
    }

    /// <summary>
    /// Gets a parameter as an integer.
    /// </summary>
    public int GetParameterInt(string key, int defaultValue = 0)
    {
        var value = GetParameter(key);
        return int.TryParse(value, out var result) ? result : defaultValue;
    }

    /// <summary>
    /// Sets the event status to in-progress.
    /// </summary>
    public void Start()
    {
        if (Status != WorldEventStatus.Scheduled)
            throw new InvalidOperationException(
                $"Cannot start event with status {Status}.");

        Status = WorldEventStatus.InProgress;
        StartedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Sets the event status to completed with result data.
    /// </summary>
    public void Complete(IDictionary<string, string>? resultData = null)
    {
        if (Status != WorldEventStatus.InProgress)
            throw new InvalidOperationException(
                $"Cannot complete event with status {Status}.");

        Status = WorldEventStatus.Completed;
        CompletedAt = DateTime.UtcNow;

        if (resultData != null)
        {
            foreach (var (key, value) in resultData)
            {
                _result[key] = value;
            }
        }
    }

    /// <summary>
    /// Cancels the event if possible.
    /// </summary>
    public bool Cancel()
    {
        if (!IsCancellable)
            return false;

        Status = WorldEventStatus.Cancelled;
        CompletedAt = DateTime.UtcNow;
        return true;
    }

    /// <summary>
    /// Sets a result value.
    /// </summary>
    public void SetResult(string key, string value)
    {
        _result[key] = value ?? string.Empty;
    }

    /// <summary>
    /// Adds a target room.
    /// </summary>
    public void AddTargetRoom(Guid roomId)
    {
        if (!_targetRoomIds.Contains(roomId))
        {
            _targetRoomIds.Add(roomId);
        }
    }

    /// <summary>
    /// Gets a string representation of the event.
    /// </summary>
    public override string ToString() =>
        $"WorldEvent[{EventType}] {Name} - Status: {Status}, " +
        $"Scheduled: {ScheduledTime:u}, Rooms: {_targetRoomIds.Count}";
}
```

### 6.4 WorldEventType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/WorldEventType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of world evolution events.
/// </summary>
/// <remarks>
/// World events represent significant changes to the dungeon
/// that can alter paths, populations, and environmental conditions.
/// </remarks>
public enum WorldEventType
{
    /// <summary>
    /// A structural collapse that can block or create passages.
    /// </summary>
    /// <remarks>
    /// Cave-ins alter the dungeon layout by blocking existing exits
    /// or potentially revealing hidden passages. Severity determines
    /// the extent of changes.
    /// </remarks>
    CaveIn = 0,

    /// <summary>
    /// Movement of monster populations between zones.
    /// </summary>
    /// <remarks>
    /// Migrations represent faction populations relocating from
    /// one area to another, leaving abandoned rooms behind and
    /// occupying new territory.
    /// </remarks>
    Migration = 1,

    /// <summary>
    /// A change in seasonal conditions.
    /// </summary>
    /// <remarks>
    /// Seasonal changes affect environmental hazards, resource
    /// availability, and monster behavior throughout affected areas.
    /// </remarks>
    SeasonalChange = 2,

    /// <summary>
    /// Natural decay and deterioration of the environment.
    /// </summary>
    /// <remarks>
    /// Environmental decay progresses the natural aging of
    /// objects, evidence, and structures in the dungeon.
    /// </remarks>
    EnvironmentalDecay = 3
}
```

### 6.5 WorldEventStatus Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/WorldEventStatus.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Status of a world event.
/// </summary>
public enum WorldEventStatus
{
    /// <summary>
    /// Event is scheduled but not yet triggered.
    /// </summary>
    Scheduled = 0,

    /// <summary>
    /// Event is currently being processed.
    /// </summary>
    InProgress = 1,

    /// <summary>
    /// Event has completed successfully.
    /// </summary>
    Completed = 2,

    /// <summary>
    /// Event was cancelled before execution.
    /// </summary>
    Cancelled = 3
}
```

### 6.6 SeasonalEffect Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/SeasonalEffect.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Seasonal effects that can apply to the dungeon.
/// </summary>
/// <remarks>
/// Seasons affect environmental conditions, hazards,
/// and monster behavior. Not all areas are affected
/// by seasons (deep underground areas may be constant).
/// </remarks>
public enum SeasonalEffect
{
    /// <summary>
    /// No seasonal effect active.
    /// </summary>
    None = 0,

    /// <summary>
    /// Winter conditions: cold, ice hazards, reduced visibility.
    /// </summary>
    /// <remarks>
    /// Water sources may freeze, cold-based monsters more active,
    /// fire-based effects more valuable.
    /// </remarks>
    Winter = 1,

    /// <summary>
    /// Spring conditions: flooding, growth, renewal.
    /// </summary>
    /// <remarks>
    /// Water levels rise, plant growth increases,
    /// some monsters become more active after hibernation.
    /// </remarks>
    Spring = 2,

    /// <summary>
    /// Summer conditions: heat, drought, increased activity.
    /// </summary>
    /// <remarks>
    /// Fire hazards increase, water sources may dry,
    /// most monsters at peak activity.
    /// </remarks>
    Summer = 3,

    /// <summary>
    /// Autumn conditions: decay, harvest, preparation.
    /// </summary>
    /// <remarks>
    /// Increased decay rates, some resources more abundant,
    /// monsters begin hoarding behavior.
    /// </remarks>
    Autumn = 4
}
```

### 6.7 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `Guid` | Unique identifier | Generated |
| `EventType` | `WorldEventType` | Type of event | Required |
| `ScheduledTime` | `DateTime` | When to trigger | Required |
| `StartedAt` | `DateTime?` | When processing started | Null |
| `CompletedAt` | `DateTime?` | When completed | Null |
| `TargetRoomIds` | `IReadOnlyList<Guid>` | Affected rooms | Required |
| `Status` | `WorldEventStatus` | Current status | Scheduled |
| `Parameters` | `IReadOnlyDictionary<string, string>` | Event configuration | Empty |
| `Result` | `IReadOnlyDictionary<string, string>` | Execution results | Empty |
| `Name` | `string` | Descriptive name | Generated |
| `Description` | `string` | Event description | Empty |

---

## 7. Dungeon Evolution Events

### 7.1 Overview

Dungeon evolution events represent significant changes to the world that go beyond simple evidence generation. These events can permanently alter the dungeon layout, relocate monster populations, or change environmental conditions.

### 7.2 Cave-Ins

Cave-ins alter dungeon connectivity by blocking or creating passages. They are the primary mechanism for dynamic path changes.

#### 7.2.1 CaveInResult Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CaveInResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of a cave-in event.
/// </summary>
public readonly record struct CaveInResult
{
    /// <summary>
    /// Gets the room where the cave-in occurred.
    /// </summary>
    public Guid RoomId { get; init; }

    /// <summary>
    /// Gets the severity of the cave-in (1-100).
    /// </summary>
    public int Severity { get; init; }

    /// <summary>
    /// Gets the IDs of exits that were blocked.
    /// </summary>
    public IReadOnlyList<Guid> BlockedExits { get; init; }

    /// <summary>
    /// Gets the IDs of new exits that were created.
    /// </summary>
    public IReadOnlyList<Guid> NewExits { get; init; }

    /// <summary>
    /// Gets the damage level to the room (0-100).
    /// </summary>
    public int DamageLevel { get; init; }

    /// <summary>
    /// Gets descriptions of debris created.
    /// </summary>
    public IReadOnlyList<string> Debris { get; init; }

    /// <summary>
    /// Gets IDs of entities (monsters) that were killed.
    /// </summary>
    public IReadOnlyList<Guid> Casualties { get; init; }

    /// <summary>
    /// Creates a cave-in result.
    /// </summary>
    public static CaveInResult Create(
        Guid roomId,
        int severity,
        IEnumerable<Guid>? blockedExits = null,
        IEnumerable<Guid>? newExits = null,
        int damageLevel = 0,
        IEnumerable<string>? debris = null,
        IEnumerable<Guid>? casualties = null)
    {
        return new CaveInResult
        {
            RoomId = roomId,
            Severity = Math.Clamp(severity, 1, 100),
            BlockedExits = (blockedExits?.ToList() ?? new List<Guid>()).AsReadOnly(),
            NewExits = (newExits?.ToList() ?? new List<Guid>()).AsReadOnly(),
            DamageLevel = Math.Clamp(damageLevel, 0, 100),
            Debris = (debris?.ToList() ?? new List<string>()).AsReadOnly(),
            Casualties = (casualties?.ToList() ?? new List<Guid>()).AsReadOnly()
        };
    }

    /// <summary>
    /// Gets whether any exits were affected.
    /// </summary>
    public bool AffectedExits => BlockedExits.Count > 0 || NewExits.Count > 0;

    /// <summary>
    /// Gets a summary of the cave-in.
    /// </summary>
    public string GetSummary()
    {
        var parts = new List<string>();

        if (BlockedExits.Count > 0)
            parts.Add($"{BlockedExits.Count} exit(s) blocked");

        if (NewExits.Count > 0)
            parts.Add($"{NewExits.Count} new passage(s) revealed");

        if (Casualties.Count > 0)
            parts.Add($"{Casualties.Count} casualt(ies)");

        if (parts.Count == 0)
            parts.Add("minor debris only");

        return $"Cave-in (severity {Severity}): {string.Join(", ", parts)}";
    }
}
```

#### 7.2.2 Cave-In Mechanics

**Severity Levels:**

| Severity | Description | Effects |
|----------|-------------|---------|
| 1-30 | Minor | Debris only, no structural changes |
| 31-50 | Moderate | May block one exit |
| 51-70 | Significant | Blocks 1 exit, 20% chance of new passage |
| 71-90 | Severe | Blocks 1-2 exits, 40% chance of new passage |
| 91-100 | Catastrophic | Blocks 2+ exits, 60% new passage, casualties |

**Triggering Conditions:**
- Time-based (scheduled events)
- Combat-induced (heavy damage to room)
- Explosion effects
- Natural progression (unstable rooms)

### 7.3 Monster Migrations

Monster migrations represent faction populations moving from one area to another, creating abandoned zones and newly occupied territories.

#### 7.3.1 MigrationPath Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/MigrationPath.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a monster migration path and progress.
/// </summary>
public readonly record struct MigrationPath
{
    /// <summary>
    /// Gets the faction performing the migration.
    /// </summary>
    public string FactionId { get; init; }

    /// <summary>
    /// Gets the rooms being abandoned.
    /// </summary>
    public IReadOnlyList<Guid> FromRoomIds { get; init; }

    /// <summary>
    /// Gets the destination rooms.
    /// </summary>
    public IReadOnlyList<Guid> ToRoomIds { get; init; }

    /// <summary>
    /// Gets the migration progress (0.0 to 1.0).
    /// </summary>
    public float Progress { get; init; }

    /// <summary>
    /// Gets when the migration started.
    /// </summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// Gets the expected duration.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Creates a new migration path.
    /// </summary>
    public static MigrationPath Create(
        string factionId,
        IEnumerable<Guid> fromRoomIds,
        IEnumerable<Guid> toRoomIds,
        TimeSpan? duration = null)
    {
        if (string.IsNullOrWhiteSpace(factionId))
            throw new ArgumentException("Faction ID required.", nameof(factionId));

        return new MigrationPath
        {
            FactionId = factionId,
            FromRoomIds = (fromRoomIds?.ToList() ?? new List<Guid>()).AsReadOnly(),
            ToRoomIds = (toRoomIds?.ToList() ?? new List<Guid>()).AsReadOnly(),
            Progress = 0f,
            StartedAt = DateTime.UtcNow,
            Duration = duration ?? TimeSpan.FromHours(1)
        };
    }

    /// <summary>
    /// Gets whether the migration is complete.
    /// </summary>
    public bool IsComplete => Progress >= 1.0f;

    /// <summary>
    /// Creates a copy with updated progress.
    /// </summary>
    public MigrationPath WithProgress(float newProgress) => this with
    {
        Progress = Math.Clamp(newProgress, 0f, 1f)
    };

    /// <summary>
    /// Gets the current progress based on time elapsed.
    /// </summary>
    public float CalculateProgress()
    {
        var elapsed = DateTime.UtcNow - StartedAt;
        return (float)Math.Min(elapsed / Duration, 1.0);
    }
}
```

#### 7.3.2 Migration Mechanics

**Migration Triggers:**
- Territory loss to hostile faction (retreat)
- Resource depletion in current area
- Seasonal migration patterns
- Player actions creating power vacuums

**Migration Effects:**
- Source rooms: Faction control cleared, "abandoned" evidence created
- Destination rooms: Faction control established, respawn timers set
- Intermediate rooms: May see migration evidence (tracks, trails)

### 7.4 Seasonal Effects

Seasonal effects modify environmental conditions across affected dungeon areas.

#### 7.4.1 Seasonal Effect Mechanics

| Season | Environmental Changes | Monster Behavior |
|--------|----------------------|------------------|
| Winter | Ice hazards, reduced light, frozen water | Cold monsters active, others sluggish |
| Spring | Flooding, growth, increased humidity | Activity increases, some monsters spawn |
| Summer | Heat hazards, drought, fire risk | Peak activity, territorial behavior |
| Autumn | Rapid decay, falling debris, darkness | Hoarding behavior, preparation |

**Affected Systems:**
- Room descriptions include seasonal elements
- Some room types may become hazardous
- Monster spawn rates may change
- Resource availability shifts

---

## 8. EvolutionService

### 8.1 Purpose

The `EvolutionService` manages all aspects of dungeon evolution including environmental evidence generation, scheduled world events, time-based changes, and integration with other v0.1.4 services.

### 8.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/IEvolutionService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/EvolutionService.cs`

### 8.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing dungeon evolution and environmental storytelling.
/// </summary>
public interface IEvolutionService
{
    // === Evidence Management ===

    /// <summary>
    /// Creates battle evidence after combat.
    /// </summary>
    /// <param name="roomId">The room where combat occurred.</param>
    /// <param name="monstersKilled">Names/IDs of killed monsters.</param>
    /// <param name="totalDamage">Total damage dealt in combat.</param>
    /// <returns>List of created evidence items.</returns>
    IReadOnlyList<EnvironmentalEvidence> CreateBattleEvidence(
        Guid roomId,
        IEnumerable<(string name, string? id)> monstersKilled,
        int totalDamage);

    /// <summary>
    /// Creates evidence of a fire burning out.
    /// </summary>
    /// <param name="roomId">The room containing the fire.</param>
    /// <param name="fireSource">Description of what burned out.</param>
    /// <returns>The created evidence.</returns>
    EnvironmentalEvidence CreateBurnedOutEvidence(
        Guid roomId,
        string fireSource);

    /// <summary>
    /// Creates debris evidence (from cave-ins, explosions, etc.).
    /// </summary>
    /// <param name="roomId">The room containing debris.</param>
    /// <param name="debrisDescriptions">Descriptions of debris.</param>
    /// <returns>List of created evidence items.</returns>
    IReadOnlyList<EnvironmentalEvidence> CreateDebrisEvidence(
        Guid roomId,
        IEnumerable<string> debrisDescriptions);

    /// <summary>
    /// Gets all evidence in a room.
    /// </summary>
    /// <param name="roomId">The room to query.</param>
    /// <returns>Evidence items in the room.</returns>
    IReadOnlyList<EnvironmentalEvidence> GetRoomEvidence(Guid roomId);

    /// <summary>
    /// Removes expired evidence from all rooms.
    /// </summary>
    /// <returns>Count of evidence items removed.</returns>
    int RemoveExpiredEvidence();

    // === World Event Management ===

    /// <summary>
    /// Schedules a world event.
    /// </summary>
    /// <param name="eventType">Type of event.</param>
    /// <param name="scheduledTime">When to trigger.</param>
    /// <param name="targetRoomIds">Affected rooms.</param>
    /// <param name="parameters">Event parameters.</param>
    /// <returns>The scheduled event.</returns>
    WorldEvent ScheduleEvent(
        WorldEventType eventType,
        DateTime scheduledTime,
        IEnumerable<Guid> targetRoomIds,
        IDictionary<string, string>? parameters = null);

    /// <summary>
    /// Processes all due scheduled events.
    /// </summary>
    /// <returns>List of processed events.</returns>
    IReadOnlyList<WorldEvent> ProcessScheduledEvents();

    /// <summary>
    /// Gets all active (scheduled or in-progress) events.
    /// </summary>
    IReadOnlyList<WorldEvent> GetActiveEvents();

    /// <summary>
    /// Gets all events for a specific room.
    /// </summary>
    IReadOnlyList<WorldEvent> GetEventsForRoom(Guid roomId);

    /// <summary>
    /// Cancels a scheduled event.
    /// </summary>
    /// <param name="eventId">The event to cancel.</param>
    /// <returns>True if cancelled.</returns>
    bool CancelEvent(Guid eventId);

    // === Cave-In Events ===

    /// <summary>
    /// Triggers a cave-in in a room.
    /// </summary>
    /// <param name="roomId">The room for the cave-in.</param>
    /// <param name="severity">Severity (1-100).</param>
    /// <returns>The result of the cave-in.</returns>
    CaveInResult TriggerCaveIn(Guid roomId, int severity);

    /// <summary>
    /// Schedules a cave-in for future occurrence.
    /// </summary>
    WorldEvent ScheduleCaveIn(
        Guid roomId,
        int severity,
        DateTime scheduledTime);

    // === Migration Events ===

    /// <summary>
    /// Triggers a monster migration.
    /// </summary>
    /// <param name="factionId">The migrating faction.</param>
    /// <param name="fromRoomIds">Rooms being abandoned.</param>
    /// <param name="toRoomIds">Destination rooms.</param>
    /// <returns>The migration path.</returns>
    MigrationPath TriggerMigration(
        string factionId,
        IEnumerable<Guid> fromRoomIds,
        IEnumerable<Guid> toRoomIds);

    /// <summary>
    /// Schedules a migration for future occurrence.
    /// </summary>
    WorldEvent ScheduleMigration(
        string factionId,
        IEnumerable<Guid> fromRoomIds,
        IEnumerable<Guid> toRoomIds,
        DateTime scheduledTime);

    // === Seasonal Events ===

    /// <summary>
    /// Applies a seasonal effect to specified areas.
    /// </summary>
    /// <param name="effect">The seasonal effect to apply.</param>
    /// <param name="affectedRoomIds">Rooms affected by the season.</param>
    void ApplySeasonalEffect(
        SeasonalEffect effect,
        IEnumerable<Guid> affectedRoomIds);

    /// <summary>
    /// Gets the current seasonal effect for a room.
    /// </summary>
    SeasonalEffect GetRoomSeasonalEffect(Guid roomId);

    /// <summary>
    /// Schedules a seasonal change.
    /// </summary>
    WorldEvent ScheduleSeasonalChange(
        SeasonalEffect newSeason,
        IEnumerable<Guid> affectedRoomIds,
        DateTime scheduledTime);

    // === Time-Based Processing ===

    /// <summary>
    /// Processes all time-based changes (decay, phase progression).
    /// </summary>
    void ProcessTimeBasedChanges();

    /// <summary>
    /// Registers a timed change for tracking.
    /// </summary>
    void RegisterTimedChange(TimedChange change);

    /// <summary>
    /// Gets all active timed changes.
    /// </summary>
    IReadOnlyList<TimedChange> GetActiveTimedChanges();
}
```

### 8.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing dungeon evolution and environmental storytelling.
/// </summary>
public class EvolutionService : IEvolutionService
{
    private readonly IWorldStateService _worldStateService;
    private readonly ITerritoryService _territoryService;
    private readonly IRepopulationService _repopulationService;
    private readonly IConfigurationProvider _config;
    private readonly ILogger<EvolutionService> _logger;
    private readonly Random _random;

    private readonly Dictionary<Guid, List<EnvironmentalEvidence>> _roomEvidence = new();
    private readonly List<WorldEvent> _events = new();
    private readonly List<TimedChange> _timedChanges = new();
    private readonly Dictionary<Guid, SeasonalEffect> _roomSeasons = new();
    private readonly Dictionary<Guid, Room> _trackedRooms = new();

    /// <summary>
    /// Initializes a new instance of the EvolutionService.
    /// </summary>
    public EvolutionService(
        IWorldStateService worldStateService,
        ITerritoryService territoryService,
        IRepopulationService repopulationService,
        IConfigurationProvider config,
        ILogger<EvolutionService> logger)
    {
        _worldStateService = worldStateService ?? throw new ArgumentNullException(nameof(worldStateService));
        _territoryService = territoryService ?? throw new ArgumentNullException(nameof(territoryService));
        _repopulationService = repopulationService ?? throw new ArgumentNullException(nameof(repopulationService));
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _random = new Random();

        _logger.LogInformation("EvolutionService initialized");
    }

    /// <summary>
    /// Registers a room for evolution tracking.
    /// </summary>
    public void RegisterRoom(Room room)
    {
        if (room == null)
            throw new ArgumentNullException(nameof(room));

        _trackedRooms[room.Id] = room;
        _roomEvidence[room.Id] = new List<EnvironmentalEvidence>();
    }

    // === Evidence Management ===

    /// <inheritdoc />
    public IReadOnlyList<EnvironmentalEvidence> CreateBattleEvidence(
        Guid roomId,
        IEnumerable<(string name, string? id)> monstersKilled,
        int totalDamage)
    {
        var evidence = new List<EnvironmentalEvidence>();
        var config = _config.GetEvolutionEventDefinitions();

        // Create corpse evidence for each killed monster
        foreach (var (name, id) in monstersKilled)
        {
            var corpse = EnvironmentalEvidence.CreateCorpse(
                roomId, name, id,
                TimeSpan.FromHours(config.CorpseDecayHours));

            evidence.Add(corpse);
            AddEvidence(corpse);

            _logger.LogDebug(
                "Created corpse evidence for {MonsterName} in room {RoomId}",
                name, roomId);
        }

        // Create blood stain if significant damage
        if (totalDamage >= config.BloodStainDamageThreshold)
        {
            var bloodStain = EnvironmentalEvidence.CreateBloodStain(
                roomId,
                TimeSpan.FromHours(config.BloodStainDecayHours));

            evidence.Add(bloodStain);
            AddEvidence(bloodStain);
        }

        // Create battle site marker for large battles
        var killedCount = monstersKilled.Count();
        if (killedCount >= config.BattleSiteMinimumCombatants)
        {
            var summary = $"{killedCount} creatures slain, {totalDamage} total damage dealt";
            var battleSite = EnvironmentalEvidence.CreateBattleSite(
                roomId, summary,
                TimeSpan.FromHours(config.BattleSiteDecayHours));

            evidence.Add(battleSite);
            AddEvidence(battleSite);
        }

        _logger.LogInformation(
            "Created {Count} battle evidence items in room {RoomId}",
            evidence.Count, roomId);

        return evidence.AsReadOnly();
    }

    /// <inheritdoc />
    public EnvironmentalEvidence CreateBurnedOutEvidence(
        Guid roomId,
        string fireSource)
    {
        var evidence = EnvironmentalEvidence.CreateBurnedOut(
            roomId, fireSource,
            TimeSpan.FromHours(48)); // Burned-out evidence persists longer

        AddEvidence(evidence);

        _logger.LogDebug(
            "Created burned-out evidence for {Source} in room {RoomId}",
            fireSource, roomId);

        return evidence;
    }

    /// <inheritdoc />
    public IReadOnlyList<EnvironmentalEvidence> CreateDebrisEvidence(
        Guid roomId,
        IEnumerable<string> debrisDescriptions)
    {
        var evidence = new List<EnvironmentalEvidence>();

        foreach (var description in debrisDescriptions)
        {
            var debris = EnvironmentalEvidence.CreateDebris(
                roomId, description,
                TimeSpan.FromHours(72)); // Debris persists a long time

            evidence.Add(debris);
            AddEvidence(debris);
        }

        _logger.LogDebug(
            "Created {Count} debris evidence items in room {RoomId}",
            evidence.Count, roomId);

        return evidence.AsReadOnly();
    }

    private void AddEvidence(EnvironmentalEvidence evidence)
    {
        if (!_roomEvidence.ContainsKey(evidence.RoomId))
        {
            _roomEvidence[evidence.RoomId] = new List<EnvironmentalEvidence>();
        }

        _roomEvidence[evidence.RoomId].Add(evidence);

        // Track with world state service for persistence
        _worldStateService.AddPersistentChange(
            evidence.RoomId,
            PersistentChangeType.EvidenceAdded,
            evidence.Id.ToString());
    }

    /// <inheritdoc />
    public IReadOnlyList<EnvironmentalEvidence> GetRoomEvidence(Guid roomId)
    {
        if (_roomEvidence.TryGetValue(roomId, out var evidence))
        {
            return evidence.Where(e => !e.IsExpired).ToList().AsReadOnly();
        }

        return Array.Empty<EnvironmentalEvidence>();
    }

    /// <inheritdoc />
    public int RemoveExpiredEvidence()
    {
        var removed = 0;

        foreach (var (roomId, evidenceList) in _roomEvidence)
        {
            var expired = evidenceList.Where(e => e.IsExpired).ToList();
            foreach (var evidence in expired)
            {
                evidenceList.Remove(evidence);
                removed++;

                _worldStateService.AddPersistentChange(
                    roomId,
                    PersistentChangeType.EvidenceRemoved,
                    evidence.Id.ToString());
            }
        }

        if (removed > 0)
        {
            _logger.LogInformation("Removed {Count} expired evidence items", removed);
        }

        return removed;
    }

    // === World Event Management ===

    /// <inheritdoc />
    public WorldEvent ScheduleEvent(
        WorldEventType eventType,
        DateTime scheduledTime,
        IEnumerable<Guid> targetRoomIds,
        IDictionary<string, string>? parameters = null)
    {
        var evt = WorldEvent.Create(
            eventType,
            scheduledTime,
            targetRoomIds,
            $"{eventType} Event");

        if (parameters != null)
        {
            foreach (var (key, value) in parameters)
            {
                evt.SetParameter(key, value);
            }
        }

        _events.Add(evt);

        _logger.LogInformation(
            "Scheduled {EventType} event for {Time} affecting {Count} rooms",
            eventType, scheduledTime, evt.TargetRoomIds.Count);

        return evt;
    }

    /// <inheritdoc />
    public IReadOnlyList<WorldEvent> ProcessScheduledEvents()
    {
        var processed = new List<WorldEvent>();
        var dueEvents = _events
            .Where(e => e.IsDue)
            .OrderBy(e => e.ScheduledTime)
            .ToList();

        foreach (var evt in dueEvents)
        {
            try
            {
                evt.Start();

                switch (evt.EventType)
                {
                    case WorldEventType.CaveIn:
                        ProcessCaveInEvent(evt);
                        break;
                    case WorldEventType.Migration:
                        ProcessMigrationEvent(evt);
                        break;
                    case WorldEventType.SeasonalChange:
                        ProcessSeasonalChangeEvent(evt);
                        break;
                    case WorldEventType.EnvironmentalDecay:
                        ProcessEnvironmentalDecayEvent(evt);
                        break;
                }

                evt.Complete();
                processed.Add(evt);

                _logger.LogInformation(
                    "Processed {EventType} event {EventId}",
                    evt.EventType, evt.Id);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Failed to process {EventType} event {EventId}",
                    evt.EventType, evt.Id);
            }
        }

        return processed.AsReadOnly();
    }

    private void ProcessCaveInEvent(WorldEvent evt)
    {
        var severity = evt.GetParameterInt("severity", 50);

        foreach (var roomId in evt.TargetRoomIds)
        {
            var result = TriggerCaveIn(roomId, severity);
            evt.SetResult($"room_{roomId}_summary", result.GetSummary());
        }
    }

    private void ProcessMigrationEvent(WorldEvent evt)
    {
        var factionId = evt.GetParameter("factionId");
        var fromRoomIds = evt.GetParameter("fromRoomIds")?
            .Split(',')
            .Where(s => Guid.TryParse(s, out _))
            .Select(Guid.Parse)
            .ToList() ?? new List<Guid>();

        var toRoomIds = evt.GetParameter("toRoomIds")?
            .Split(',')
            .Where(s => Guid.TryParse(s, out _))
            .Select(Guid.Parse)
            .ToList() ?? new List<Guid>();

        if (!string.IsNullOrEmpty(factionId))
        {
            var path = TriggerMigration(factionId, fromRoomIds, toRoomIds);
            evt.SetResult("migration_complete", path.IsComplete.ToString());
        }
    }

    private void ProcessSeasonalChangeEvent(WorldEvent evt)
    {
        var seasonStr = evt.GetParameter("season");
        if (Enum.TryParse<SeasonalEffect>(seasonStr, out var season))
        {
            ApplySeasonalEffect(season, evt.TargetRoomIds);
        }
    }

    private void ProcessEnvironmentalDecayEvent(WorldEvent evt)
    {
        ProcessTimeBasedChanges();
        RemoveExpiredEvidence();
    }

    /// <inheritdoc />
    public IReadOnlyList<WorldEvent> GetActiveEvents()
    {
        return _events
            .Where(e => e.Status == WorldEventStatus.Scheduled ||
                       e.Status == WorldEventStatus.InProgress)
            .ToList()
            .AsReadOnly();
    }

    /// <inheritdoc />
    public IReadOnlyList<WorldEvent> GetEventsForRoom(Guid roomId)
    {
        return _events
            .Where(e => e.TargetRoomIds.Contains(roomId))
            .ToList()
            .AsReadOnly();
    }

    /// <inheritdoc />
    public bool CancelEvent(Guid eventId)
    {
        var evt = _events.FirstOrDefault(e => e.Id == eventId);
        if (evt == null)
            return false;

        var cancelled = evt.Cancel();
        if (cancelled)
        {
            _logger.LogInformation("Cancelled event {EventId}", eventId);
        }

        return cancelled;
    }

    // === Cave-In Events ===

    /// <inheritdoc />
    public CaveInResult TriggerCaveIn(Guid roomId, int severity)
    {
        severity = Math.Clamp(severity, 1, 100);

        if (!_trackedRooms.TryGetValue(roomId, out var room))
        {
            _logger.LogWarning("Cannot trigger cave-in: room {RoomId} not tracked", roomId);
            return CaveInResult.Create(roomId, severity);
        }

        var blockedExits = new List<Guid>();
        var newExits = new List<Guid>();
        var debris = new List<string>();
        var casualties = new List<Guid>();

        // Calculate effects based on severity
        var damageLevel = severity;

        // Always create debris
        debris.Add(severity switch
        {
            <= 30 => "Small rocks and dust",
            <= 60 => "Fallen stones and rubble",
            <= 90 => "Heavy boulders and debris",
            _ => "Massive rock fall and structural collapse"
        });

        // May block exits (severity 31+)
        if (severity > 30 && room.Exits.Count > 1)
        {
            var blockChance = (severity - 30) / 100.0;
            var exitsToBlock = severity > 70 ? Math.Min(2, room.Exits.Count - 1) : 1;

            var availableExits = room.Exits.ToList();
            for (int i = 0; i < exitsToBlock && availableExits.Count > 1; i++)
            {
                if (_random.NextDouble() < blockChance)
                {
                    var exitIndex = _random.Next(availableExits.Count);
                    var exit = availableExits[exitIndex];
                    blockedExits.Add(exit.Id);
                    availableExits.RemoveAt(exitIndex);

                    debris.Add($"Rubble blocks the passage {exit.Direction}");
                }
            }
        }

        // May reveal new exits (severity 51+)
        if (severity > 50)
        {
            var revealChance = (severity - 50) / 100.0;
            if (_random.NextDouble() < revealChance)
            {
                // This would integrate with room/dungeon generation
                // For now, just note the possibility
                _logger.LogDebug(
                    "Cave-in in room {RoomId} would reveal new passage (placeholder)",
                    roomId);
            }
        }

        // May cause casualties (severity 71+)
        if (severity > 70)
        {
            // Would integrate with monster tracking
            var casualtyChance = (severity - 70) / 100.0;
            _logger.LogDebug(
                "Cave-in casualty chance: {Chance}%",
                casualtyChance * 100);
        }

        // Create debris evidence
        CreateDebrisEvidence(roomId, debris);

        // Apply blocked exits
        foreach (var exitId in blockedExits)
        {
            // Would integrate with room system
            _worldStateService.AddPersistentChange(
                roomId,
                PersistentChangeType.ExitBlocked,
                exitId.ToString());
        }

        var result = CaveInResult.Create(
            roomId, severity,
            blockedExits, newExits,
            damageLevel, debris, casualties);

        _logger.LogInformation(
            "Cave-in in room {RoomId}: {Summary}",
            roomId, result.GetSummary());

        return result;
    }

    /// <inheritdoc />
    public WorldEvent ScheduleCaveIn(
        Guid roomId,
        int severity,
        DateTime scheduledTime)
    {
        return WorldEvent.CreateCaveIn(scheduledTime, roomId, severity);
    }

    // === Migration Events ===

    /// <inheritdoc />
    public MigrationPath TriggerMigration(
        string factionId,
        IEnumerable<Guid> fromRoomIds,
        IEnumerable<Guid> toRoomIds)
    {
        var from = fromRoomIds.ToList();
        var to = toRoomIds.ToList();

        var path = MigrationPath.Create(factionId, from, to);

        // Clear control from source rooms
        foreach (var roomId in from)
        {
            _territoryService.ClearRoomControl(roomId);

            // Create abandoned evidence
            var evidence = EnvironmentalEvidence.Create(
                roomId,
                EvidenceType.Decay,
                "Signs of recent abandonment are visible.",
                "This area was recently occupied but has been abandoned. " +
                "Tracks lead away from here.",
                TimeSpan.FromHours(24));

            AddEvidence(evidence);
        }

        // Establish control in destination rooms
        foreach (var roomId in to)
        {
            _territoryService.SetRoomControl(roomId, factionId);
            _repopulationService.SetRespawnTimer(roomId);

            // Create arrival evidence
            var evidence = EnvironmentalEvidence.Create(
                roomId,
                EvidenceType.Debris,
                "Fresh signs of recent occupation.",
                "New inhabitants have recently moved into this area. " +
                "The space is being claimed and organized.",
                TimeSpan.FromHours(12));

            AddEvidence(evidence);
        }

        _logger.LogInformation(
            "Faction {FactionId} migrated from {FromCount} rooms to {ToCount} rooms",
            factionId, from.Count, to.Count);

        return path.WithProgress(1.0f);
    }

    /// <inheritdoc />
    public WorldEvent ScheduleMigration(
        string factionId,
        IEnumerable<Guid> fromRoomIds,
        IEnumerable<Guid> toRoomIds,
        DateTime scheduledTime)
    {
        var evt = WorldEvent.CreateMigration(
            scheduledTime, factionId, fromRoomIds, toRoomIds);

        _events.Add(evt);
        return evt;
    }

    // === Seasonal Events ===

    /// <inheritdoc />
    public void ApplySeasonalEffect(
        SeasonalEffect effect,
        IEnumerable<Guid> affectedRoomIds)
    {
        foreach (var roomId in affectedRoomIds)
        {
            _roomSeasons[roomId] = effect;

            if (_trackedRooms.TryGetValue(roomId, out var room))
            {
                // Would update room's seasonal modifier
                _logger.LogDebug(
                    "Applied {Season} effect to room {RoomId}",
                    effect, roomId);
            }
        }

        _logger.LogInformation(
            "Applied {Season} seasonal effect to {Count} rooms",
            effect, affectedRoomIds.Count());
    }

    /// <inheritdoc />
    public SeasonalEffect GetRoomSeasonalEffect(Guid roomId)
    {
        return _roomSeasons.TryGetValue(roomId, out var effect)
            ? effect
            : SeasonalEffect.None;
    }

    /// <inheritdoc />
    public WorldEvent ScheduleSeasonalChange(
        SeasonalEffect newSeason,
        IEnumerable<Guid> affectedRoomIds,
        DateTime scheduledTime)
    {
        var evt = WorldEvent.CreateSeasonalChange(
            scheduledTime, newSeason, affectedRoomIds);

        _events.Add(evt);
        return evt;
    }

    // === Time-Based Processing ===

    /// <inheritdoc />
    public void ProcessTimeBasedChanges()
    {
        // Update decay phases for all evidence
        foreach (var (roomId, evidenceList) in _roomEvidence)
        {
            foreach (var evidence in evidenceList)
            {
                if (evidence.UpdateDecayPhase())
                {
                    _logger.LogDebug(
                        "Evidence {EvidenceId} progressed to decay phase {Phase}",
                        evidence.Id, evidence.DecayPhase);
                }
            }
        }

        // Process active timed changes
        var completedChanges = new List<TimedChange>();
        foreach (var change in _timedChanges)
        {
            var progress = change.CalculateProgress();
            if (progress >= 1.0f)
            {
                CompleteTimedChange(change);
                completedChanges.Add(change);
            }
        }

        foreach (var change in completedChanges)
        {
            _timedChanges.Remove(change);
        }

        _logger.LogDebug(
            "Processed time-based changes: {CompletedCount} completed",
            completedChanges.Count);
    }

    private void CompleteTimedChange(TimedChange change)
    {
        // Handle completion based on change type
        switch (change.ChangeType)
        {
            case "fire_burnout":
                if (_trackedRooms.TryGetValue(change.TargetId, out var room))
                {
                    CreateBurnedOutEvidence(change.TargetId, "torch");
                }
                break;

            // Additional change types would be handled here
        }

        _logger.LogDebug(
            "Completed timed change {ChangeType} for target {TargetId}",
            change.ChangeType, change.TargetId);
    }

    /// <inheritdoc />
    public void RegisterTimedChange(TimedChange change)
    {
        _timedChanges.Add(change);

        _logger.LogDebug(
            "Registered timed change {ChangeType} for target {TargetId}, duration {Duration}",
            change.ChangeType, change.TargetId, change.Duration);
    }

    /// <inheritdoc />
    public IReadOnlyList<TimedChange> GetActiveTimedChanges()
    {
        return _timedChanges
            .Where(c => c.CalculateProgress() < 1.0f)
            .ToList()
            .AsReadOnly();
    }
}
```

### 8.5 TimedChange Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TimedChange.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a time-based environmental change in progress.
/// </summary>
public readonly record struct TimedChange
{
    /// <summary>
    /// Gets the target entity ID (room, object, etc.).
    /// </summary>
    public Guid TargetId { get; init; }

    /// <summary>
    /// Gets the type of change occurring.
    /// </summary>
    public string ChangeType { get; init; }

    /// <summary>
    /// Gets when the change started.
    /// </summary>
    public DateTime StartTime { get; init; }

    /// <summary>
    /// Gets the total duration of the change.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Gets the current phase of the change (0-based).
    /// </summary>
    public int CurrentPhase { get; init; }

    /// <summary>
    /// Creates a new timed change.
    /// </summary>
    public static TimedChange Create(
        Guid targetId,
        string changeType,
        TimeSpan duration)
    {
        return new TimedChange
        {
            TargetId = targetId,
            ChangeType = changeType,
            StartTime = DateTime.UtcNow,
            Duration = duration,
            CurrentPhase = 0
        };
    }

    /// <summary>
    /// Creates a fire burnout change.
    /// </summary>
    public static TimedChange FireBurnout(Guid roomId, TimeSpan duration) =>
        Create(roomId, "fire_burnout", duration);

    /// <summary>
    /// Creates a light fade change.
    /// </summary>
    public static TimedChange LightFade(Guid roomId, TimeSpan duration) =>
        Create(roomId, "light_fade", duration);

    /// <summary>
    /// Calculates the current progress (0.0 to 1.0).
    /// </summary>
    public float CalculateProgress()
    {
        var elapsed = DateTime.UtcNow - StartTime;
        return (float)Math.Min(elapsed / Duration, 1.0);
    }

    /// <summary>
    /// Gets whether the change is complete.
    /// </summary>
    public bool IsComplete => CalculateProgress() >= 1.0f;

    /// <summary>
    /// Creates a copy with an updated phase.
    /// </summary>
    public TimedChange WithPhase(int phase) => this with { CurrentPhase = phase };
}
```

---

## 9. Time-Based Changes

### 9.1 Fire Burnout System

Fires in the dungeon (torches, campfires, braziers) progress through phases:

| Phase | Duration % | State | Light Level | Description |
|-------|-----------|-------|-------------|-------------|
| 0 | 0-25% | Bright | 100% | Full flame, maximum light |
| 1 | 25-50% | Normal | 75% | Steady flame |
| 2 | 50-75% | Dim | 50% | Flickering, reduced light |
| 3 | 75-90% | Embers | 25% | Mostly coals, minimal light |
| 4 | 90-100% | Cold | 0% | Burned out, creates evidence |

### 9.2 Decay Progression

Environmental decay affects various elements:

| Element | Base Decay Time | Phases | Final State |
|---------|-----------------|--------|-------------|
| Corpses | 24 hours | 4 | Removed |
| Blood stains | 6 hours | 4 | Removed |
| Battle sites | 12 hours | 4 | Removed |
| Broken equipment | 48 hours | 4 | Removed |
| Debris | 72 hours | 4 | Becomes permanent feature |

### 9.3 Configuration

**Decay timing from configuration:**

```json
{
  "decay": {
    "corpseDecayHours": 24,
    "bloodStainDecayHours": 6,
    "battleSiteDecayHours": 12,
    "brokenEquipmentDecayHours": 48,
    "debrisDecayHours": 72,
    "bloodStainDamageThreshold": 50,
    "battleSiteMinimumCombatants": 3
  }
}
```

---

## 10. Configuration File Schemas

### 10.1 Evolution Events Configuration

**File:** `config/evolution-events.json`

```json
{
  "$schema": "./schemas/evolution-events-schema.json",
  "version": "1.0",
  "decay": {
    "corpseDecayHours": 24,
    "bloodStainDecayHours": 6,
    "battleSiteDecayHours": 12,
    "brokenEquipmentDecayHours": 48,
    "debrisDecayHours": 72,
    "bloodStainDamageThreshold": 50,
    "battleSiteMinimumCombatants": 3
  },
  "caveIns": {
    "enabled": true,
    "minSeverityForExitBlock": 31,
    "minSeverityForNewPassage": 51,
    "minSeverityForCasualties": 71,
    "exitBlockChancePerSeverity": 0.01,
    "newPassageChancePerSeverity": 0.008,
    "casualtyChancePerSeverity": 0.005
  },
  "migrations": {
    "enabled": true,
    "baseDurationHours": 1,
    "retreatTriggerTerritoryLossPercent": 50,
    "createAbandonedEvidence": true,
    "createArrivalEvidence": true
  },
  "seasons": {
    "enabled": false,
    "cycleDurationDays": 30,
    "affectedRoomTypes": ["outdoor", "near_surface", "cave_entrance"],
    "effects": {
      "winter": {
        "freezeWater": true,
        "reducedVisibility": true,
        "coldDamagePerTurn": 1
      },
      "spring": {
        "floodChance": 0.2,
        "growthMultiplier": 1.5
      },
      "summer": {
        "fireHazardMultiplier": 1.5,
        "droughtChance": 0.3
      },
      "autumn": {
        "decayMultiplier": 2.0,
        "harvestBonus": 1.25
      }
    }
  },
  "scheduledEvents": [
    {
      "id": "example-cave-in",
      "type": "cave_in",
      "enabled": false,
      "triggerCondition": "time_based",
      "intervalHours": 168,
      "targetRoomTypes": ["unstable", "mine"],
      "parameters": {
        "minSeverity": 30,
        "maxSeverity": 70
      }
    },
    {
      "id": "seasonal-cycle",
      "type": "seasonal_change",
      "enabled": false,
      "triggerCondition": "time_based",
      "intervalHours": 720,
      "parameters": {
        "cycle": ["spring", "summer", "autumn", "winter"]
      }
    }
  ]
}
```

### 10.2 JSON Schema

**File:** `config/schemas/evolution-events-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "evolution-events-schema.json",
  "title": "Evolution Events Configuration",
  "description": "Configuration for dungeon evolution and environmental storytelling",
  "type": "object",
  "required": ["version", "decay"],
  "properties": {
    "$schema": {
      "type": "string",
      "description": "JSON Schema reference"
    },
    "version": {
      "type": "string",
      "description": "Configuration version",
      "pattern": "^\\d+\\.\\d+$"
    },
    "decay": {
      "type": "object",
      "description": "Evidence decay configuration",
      "required": [
        "corpseDecayHours",
        "bloodStainDecayHours",
        "battleSiteDecayHours"
      ],
      "properties": {
        "corpseDecayHours": {
          "type": "number",
          "minimum": 1,
          "maximum": 168,
          "description": "Hours until corpse evidence decays"
        },
        "bloodStainDecayHours": {
          "type": "number",
          "minimum": 1,
          "maximum": 48,
          "description": "Hours until blood stain evidence decays"
        },
        "battleSiteDecayHours": {
          "type": "number",
          "minimum": 1,
          "maximum": 72,
          "description": "Hours until battle site marker decays"
        },
        "brokenEquipmentDecayHours": {
          "type": "number",
          "minimum": 1,
          "maximum": 168,
          "description": "Hours until broken equipment decays"
        },
        "debrisDecayHours": {
          "type": "number",
          "minimum": 1,
          "maximum": 336,
          "description": "Hours until debris decays (or becomes permanent)"
        },
        "bloodStainDamageThreshold": {
          "type": "integer",
          "minimum": 1,
          "maximum": 200,
          "description": "Minimum damage to create blood stain evidence"
        },
        "battleSiteMinimumCombatants": {
          "type": "integer",
          "minimum": 2,
          "maximum": 10,
          "description": "Minimum combatants for battle site marker"
        }
      }
    },
    "caveIns": {
      "type": "object",
      "description": "Cave-in event configuration",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Whether cave-in events are enabled"
        },
        "minSeverityForExitBlock": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Minimum severity to potentially block exits"
        },
        "minSeverityForNewPassage": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Minimum severity to potentially reveal passages"
        },
        "minSeverityForCasualties": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Minimum severity to potentially cause casualties"
        },
        "exitBlockChancePerSeverity": {
          "type": "number",
          "minimum": 0,
          "maximum": 0.1,
          "description": "Chance per severity point above threshold"
        },
        "newPassageChancePerSeverity": {
          "type": "number",
          "minimum": 0,
          "maximum": 0.1,
          "description": "Chance per severity point above threshold"
        },
        "casualtyChancePerSeverity": {
          "type": "number",
          "minimum": 0,
          "maximum": 0.1,
          "description": "Chance per severity point above threshold"
        }
      }
    },
    "migrations": {
      "type": "object",
      "description": "Monster migration configuration",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Whether migrations are enabled"
        },
        "baseDurationHours": {
          "type": "number",
          "minimum": 0.1,
          "maximum": 24,
          "description": "Base duration for migrations"
        },
        "retreatTriggerTerritoryLossPercent": {
          "type": "integer",
          "minimum": 10,
          "maximum": 90,
          "description": "Territory loss percentage that triggers retreat"
        },
        "createAbandonedEvidence": {
          "type": "boolean",
          "description": "Create evidence in abandoned rooms"
        },
        "createArrivalEvidence": {
          "type": "boolean",
          "description": "Create evidence in newly occupied rooms"
        }
      }
    },
    "seasons": {
      "type": "object",
      "description": "Seasonal effects configuration",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Whether seasonal effects are enabled"
        },
        "cycleDurationDays": {
          "type": "integer",
          "minimum": 1,
          "maximum": 365,
          "description": "Duration of each season in days"
        },
        "affectedRoomTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Room types affected by seasons"
        },
        "effects": {
          "type": "object",
          "description": "Per-season effect configurations"
        }
      }
    },
    "scheduledEvents": {
      "type": "array",
      "description": "Pre-defined scheduled events",
      "items": {
        "type": "object",
        "required": ["id", "type", "enabled"],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique event identifier"
          },
          "type": {
            "type": "string",
            "enum": ["cave_in", "migration", "seasonal_change", "environmental_decay"],
            "description": "Event type"
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether this event is active"
          },
          "triggerCondition": {
            "type": "string",
            "enum": ["time_based", "player_action", "faction_state"],
            "description": "What triggers this event"
          },
          "intervalHours": {
            "type": "number",
            "minimum": 1,
            "description": "Hours between occurrences (for time_based)"
          },
          "targetRoomTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Room types this event can affect"
          },
          "parameters": {
            "type": "object",
            "description": "Event-specific parameters"
          }
        }
      }
    }
  }
}
```

### 10.3 Configuration DTO

**File:** `src/Core/RuneAndRust.Application/DTOs/EvolutionEventsConfigDto.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

using System.Text.Json.Serialization;

/// <summary>
/// Configuration DTO for evolution events.
/// </summary>
public class EvolutionEventsConfigDto
{
    [JsonPropertyName("version")]
    public string Version { get; set; } = "1.0";

    [JsonPropertyName("decay")]
    public DecayConfigDto Decay { get; set; } = new();

    [JsonPropertyName("caveIns")]
    public CaveInConfigDto CaveIns { get; set; } = new();

    [JsonPropertyName("migrations")]
    public MigrationConfigDto Migrations { get; set; } = new();

    [JsonPropertyName("seasons")]
    public SeasonConfigDto Seasons { get; set; } = new();

    [JsonPropertyName("scheduledEvents")]
    public List<ScheduledEventDto> ScheduledEvents { get; set; } = new();
}

/// <summary>
/// Configuration for evidence decay.
/// </summary>
public class DecayConfigDto
{
    [JsonPropertyName("corpseDecayHours")]
    public double CorpseDecayHours { get; set; } = 24;

    [JsonPropertyName("bloodStainDecayHours")]
    public double BloodStainDecayHours { get; set; } = 6;

    [JsonPropertyName("battleSiteDecayHours")]
    public double BattleSiteDecayHours { get; set; } = 12;

    [JsonPropertyName("brokenEquipmentDecayHours")]
    public double BrokenEquipmentDecayHours { get; set; } = 48;

    [JsonPropertyName("debrisDecayHours")]
    public double DebrisDecayHours { get; set; } = 72;

    [JsonPropertyName("bloodStainDamageThreshold")]
    public int BloodStainDamageThreshold { get; set; } = 50;

    [JsonPropertyName("battleSiteMinimumCombatants")]
    public int BattleSiteMinimumCombatants { get; set; } = 3;
}

/// <summary>
/// Configuration for cave-in events.
/// </summary>
public class CaveInConfigDto
{
    [JsonPropertyName("enabled")]
    public bool Enabled { get; set; } = true;

    [JsonPropertyName("minSeverityForExitBlock")]
    public int MinSeverityForExitBlock { get; set; } = 31;

    [JsonPropertyName("minSeverityForNewPassage")]
    public int MinSeverityForNewPassage { get; set; } = 51;

    [JsonPropertyName("minSeverityForCasualties")]
    public int MinSeverityForCasualties { get; set; } = 71;

    [JsonPropertyName("exitBlockChancePerSeverity")]
    public double ExitBlockChancePerSeverity { get; set; } = 0.01;

    [JsonPropertyName("newPassageChancePerSeverity")]
    public double NewPassageChancePerSeverity { get; set; } = 0.008;

    [JsonPropertyName("casualtyChancePerSeverity")]
    public double CasualtyChancePerSeverity { get; set; } = 0.005;
}

/// <summary>
/// Configuration for monster migrations.
/// </summary>
public class MigrationConfigDto
{
    [JsonPropertyName("enabled")]
    public bool Enabled { get; set; } = true;

    [JsonPropertyName("baseDurationHours")]
    public double BaseDurationHours { get; set; } = 1;

    [JsonPropertyName("retreatTriggerTerritoryLossPercent")]
    public int RetreatTriggerTerritoryLossPercent { get; set; } = 50;

    [JsonPropertyName("createAbandonedEvidence")]
    public bool CreateAbandonedEvidence { get; set; } = true;

    [JsonPropertyName("createArrivalEvidence")]
    public bool CreateArrivalEvidence { get; set; } = true;
}

/// <summary>
/// Configuration for seasonal effects.
/// </summary>
public class SeasonConfigDto
{
    [JsonPropertyName("enabled")]
    public bool Enabled { get; set; } = false;

    [JsonPropertyName("cycleDurationDays")]
    public int CycleDurationDays { get; set; } = 30;

    [JsonPropertyName("affectedRoomTypes")]
    public List<string> AffectedRoomTypes { get; set; } = new();

    [JsonPropertyName("effects")]
    public Dictionary<string, Dictionary<string, object>> Effects { get; set; } = new();
}

/// <summary>
/// Configuration for a scheduled event.
/// </summary>
public class ScheduledEventDto
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;

    [JsonPropertyName("type")]
    public string Type { get; set; } = string.Empty;

    [JsonPropertyName("enabled")]
    public bool Enabled { get; set; } = false;

    [JsonPropertyName("triggerCondition")]
    public string TriggerCondition { get; set; } = "time_based";

    [JsonPropertyName("intervalHours")]
    public double? IntervalHours { get; set; }

    [JsonPropertyName("targetRoomTypes")]
    public List<string> TargetRoomTypes { get; set; } = new();

    [JsonPropertyName("parameters")]
    public Dictionary<string, object> Parameters { get; set; } = new();
}
```

---

## 11. Data Model Changes

### 11.1 New Entities Summary

| Entity | Layer | Description |
|--------|-------|-------------|
| `EnvironmentalEvidence` | Domain | Procedural storytelling evidence |
| `WorldEvent` | Domain | Scheduled world evolution events |

### 11.2 New Value Objects Summary

| Value Object | Layer | Description |
|--------------|-------|-------------|
| `BattleSite` | Domain | Combat aftermath data |
| `TimedChange` | Domain | Time-based change tracking |
| `MigrationPath` | Domain | Monster migration data |
| `CaveInResult` | Domain | Cave-in event results |

### 11.3 New Enums Summary

| Enum | Layer | Description |
|------|-------|-------------|
| `EvidenceType` | Domain | Types of environmental evidence |
| `WorldEventType` | Domain | Types of world evolution events |
| `WorldEventStatus` | Domain | Event lifecycle states |
| `SeasonalEffect` | Domain | Seasonal modifiers |

### 11.4 PersistentChangeType Updates

**Updated File:** `src/Core/RuneAndRust.Domain/Enums/PersistentChangeType.cs`

Add the following values to support v0.1.4d:

```csharp
/// <summary>
/// Environmental evidence was added to a room.
/// </summary>
EvidenceAdded = 10,

/// <summary>
/// Environmental evidence was removed from a room (expired/decayed).
/// </summary>
EvidenceRemoved = 11,

/// <summary>
/// An exit was blocked (e.g., by cave-in).
/// </summary>
ExitBlocked = 12,

/// <summary>
/// A new exit was created (e.g., revealed by cave-in).
/// </summary>
ExitCreated = 13,

/// <summary>
/// Seasonal effect was applied to a room.
/// </summary>
SeasonChanged = 14
```

### 11.5 Room Entity Updates

The Room entity should be extended to support:

```csharp
/// <summary>
/// Gets the current seasonal effect affecting this room.
/// </summary>
public SeasonalEffect CurrentSeason { get; private set; } = SeasonalEffect.None;

/// <summary>
/// Sets the seasonal effect for this room.
/// </summary>
public void SetSeasonalEffect(SeasonalEffect effect)
{
    CurrentSeason = effect;
}
```

### 11.6 Save/Load Integration

The WorldStateService save/load must be updated to include:

- All EnvironmentalEvidence entities
- All WorldEvent entities (scheduled and completed)
- Active TimedChange records
- Room seasonal effects

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `EvolutionService` | Information | Event execution, evidence creation, migrations |
| `EvolutionService` | Debug | Phase progression, decay updates, calculations |
| `EvolutionService` | Warning | Invalid targets, missing rooms |
| `EvolutionService` | Error | Event processing failures |
| `WorldEvent` | Debug | Status transitions |
| `EnvironmentalEvidence` | Debug | Decay phase changes |

### 12.2 Logging Examples

```csharp
// Information - Major operations
_logger.LogInformation(
    "Created {Count} battle evidence items in room {RoomId}",
    evidence.Count, roomId);

_logger.LogInformation(
    "Faction {FactionId} migrated from {FromCount} rooms to {ToCount} rooms",
    factionId, from.Count, to.Count);

_logger.LogInformation(
    "Cave-in in room {RoomId}: {Summary}",
    roomId, result.GetSummary());

// Debug - Detailed operations
_logger.LogDebug(
    "Evidence {EvidenceId} progressed to decay phase {Phase}",
    evidence.Id, evidence.DecayPhase);

_logger.LogDebug(
    "Registered timed change {ChangeType} for target {TargetId}",
    change.ChangeType, change.TargetId);

// Warning - Recoverable issues
_logger.LogWarning(
    "Cannot trigger cave-in: room {RoomId} not tracked",
    roomId);

// Error - Failures
_logger.LogError(ex,
    "Failed to process {EventType} event {EventId}",
    evt.EventType, evt.Id);
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| EnvironmentalEvidence Entity | ~8 |
| WorldEvent Entity | ~6 |
| EvidenceType/WorldEventType Enums | ~2 |
| BattleSite/CaveInResult/MigrationPath Value Objects | ~6 |
| EvolutionService - Evidence | ~5 |
| EvolutionService - Events | ~4 |
| EvolutionService - Cave-Ins | ~4 |
| EvolutionService - Migrations | ~3 |
| EvolutionService - Seasons | ~2 |
| **Total** | **~40** |

### 13.2 Test Categories

#### 13.2.1 EnvironmentalEvidence Tests

```csharp
[Fact]
public void Create_WithValidParameters_CreatesEvidence()

[Fact]
public void Create_WithEmptyRoomId_ThrowsArgumentException()

[Fact]
public void CreateCorpse_GeneratesCorrectDescription()

[Fact]
public void CreateBattleSite_GeneratesCorrectDescription()

[Fact]
public void IsExpired_BeforeExpiresAt_ReturnsFalse()

[Fact]
public void IsExpired_AfterExpiresAt_ReturnsTrue()

[Fact]
public void UpdateDecayPhase_ProgressesCorrectly()

[Fact]
public void GetPhasedDescription_VariesByPhase()
```

#### 13.2.2 WorldEvent Tests

```csharp
[Fact]
public void Create_WithValidParameters_CreatesEvent()

[Fact]
public void CreateCaveIn_SetsCorrectParameters()

[Fact]
public void CreateMigration_SetsCorrectParameters()

[Fact]
public void Start_FromScheduled_TransitionsToInProgress()

[Fact]
public void Complete_FromInProgress_TransitionsToCompleted()

[Fact]
public void Cancel_FromScheduled_TransitionsToCancelled()
```

#### 13.2.3 EvolutionService Tests

```csharp
[Fact]
public void CreateBattleEvidence_GeneratesCorpses()

[Fact]
public void CreateBattleEvidence_GeneratesBloodStains_WhenDamageThresholdMet()

[Fact]
public void CreateBattleEvidence_GeneratesBattleSite_WhenEnoughCombatants()

[Fact]
public void TriggerCaveIn_CreatesDebrisEvidence()

[Fact]
public void TriggerCaveIn_MayBlockExits_AtHighSeverity()

[Fact]
public void TriggerMigration_ClearsSourceRoomControl()

[Fact]
public void TriggerMigration_EstablishesDestinationControl()

[Fact]
public void ProcessScheduledEvents_ProcessesDueEvents()

[Fact]
public void RemoveExpiredEvidence_RemovesExpiredItems()
```

---

## 14. Use Cases

### UC-001: Combat Creates Battle Evidence
**Actor:** System
**Flow:** Combat ends → EvolutionService.CreateBattleEvidence() → Corpses created for each killed monster → Blood stains if damage threshold met → Battle site if enough combatants → Evidence persisted

### UC-002: Player Observes Battle Aftermath
**Actor:** Player
**Flow:** Player enters room → System queries GetRoomEvidence() → Evidence descriptions added to room description → Player sees "The corpse of a goblin lies here" and similar

### UC-003: Evidence Decays Over Time
**Actor:** System
**Flow:** Time passes → ProcessTimeBasedChanges() called → Evidence phases progress → Descriptions update ("Fading corpse...") → Eventually evidence expires and is removed

### UC-004: Cave-In Blocks Path
**Actor:** System
**Flow:** Cave-in event triggers → TriggerCaveIn(roomId, 60) → Exit selected for blocking → Debris evidence created → Path blocked → WorldStateService records change

### UC-005: Faction Retreats After Loss
**Actor:** System
**Flow:** Faction loses territory → TerritoryService triggers retreat → TriggerMigration() called → Source rooms cleared → Destination rooms claimed → Evidence created in both locations

### UC-006: Fire Burns Out
**Actor:** System
**Flow:** Torch lit → TimedChange registered → ProcessTimeBasedChanges() called periodically → Phases progress (bright → dim → embers → cold) → CreateBurnedOutEvidence() called → Room light level changes

### UC-007: Seasonal Change Affects Dungeon
**Actor:** System
**Flow:** Seasonal event triggers → ApplySeasonalEffect(Winter, rooms) → Affected rooms marked → Environmental conditions change → Room descriptions updated

### UC-008: Admin Schedules Event
**Actor:** Admin/System
**Flow:** ScheduleEvent() called → Event created with future time → ProcessScheduledEvents() checks periodically → Event executes when due → Results recorded

---

## 15. Deliverable Checklist

### Environmental Evidence
- [ ] `EnvironmentalEvidence` entity created
- [ ] `EvidenceType` enum created
- [ ] Evidence factory methods implemented (CreateCorpse, CreateBattleSite, etc.)
- [ ] Decay phase progression implemented
- [ ] Evidence expiration logic implemented

### World Events
- [ ] `WorldEvent` entity created
- [ ] `WorldEventType` enum created
- [ ] `WorldEventStatus` enum created
- [ ] `SeasonalEffect` enum created
- [ ] Event scheduling and processing implemented

### Value Objects
- [ ] `BattleSite` value object created
- [ ] `TimedChange` value object created
- [ ] `MigrationPath` value object created
- [ ] `CaveInResult` value object created

### EvolutionService
- [ ] `IEvolutionService` interface created
- [ ] `EvolutionService` implementation created
- [ ] Battle evidence generation implemented
- [ ] Cave-in event processing implemented
- [ ] Migration event processing implemented
- [ ] Seasonal effect processing implemented
- [ ] Time-based change processing implemented

### Configuration
- [ ] `config/evolution-events.json` created
- [ ] `config/schemas/evolution-events-schema.json` created
- [ ] `EvolutionEventsConfigDto` created
- [ ] Configuration loading implemented

### Integration
- [ ] `PersistentChangeType` enum updated
- [ ] Room entity updated with seasonal effect support
- [ ] WorldStateService save/load updated for evidence and events
- [ ] TerritoryService integration for migrations
- [ ] RepopulationService integration for migrations

### Testing
- [ ] ~40 unit tests implemented
- [ ] All tests passing
- [ ] Configuration files validate against schemas

---

## 16. Acceptance Criteria

### Functional

- [ ] Battle evidence is created after combat (corpses, blood stains, battle sites)
- [ ] Evidence descriptions update as decay progresses
- [ ] Evidence is removed when expired
- [ ] Cave-in events create debris and may block/reveal exits
- [ ] Migration events move faction control between rooms
- [ ] Seasonal effects can be applied to rooms
- [ ] World events can be scheduled and process when due
- [ ] Events can be cancelled before execution
- [ ] All evidence and events persist through save/load

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~40 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on all public members
- [ ] No new analyzer warnings introduced
- [ ] Logging covers all major operations

### Integration

- [ ] WorldStateService properly tracks evidence changes
- [ ] TerritoryService integrates with migration events
- [ ] RepopulationService sets timers for migration destinations
- [ ] Evidence appears in room descriptions when queried
- [ ] Save/load preserves complete world evolution state

---

## 17. Dependencies

### 17.1 Prerequisites

| Dependency | Version | Purpose |
|------------|---------|---------|
| v0.1.4a | Complete | WorldStateService, PersistentChange, RoomState |
| v0.1.4b | Complete | RepopulationService, Spawner |
| v0.1.4c | Complete | TerritoryService, FactionDefinition |

### 17.2 This Version Provides

| Capability | Consumer |
|------------|----------|
| `IEvolutionService` | Any service needing evolution events |
| `EnvironmentalEvidence` | Presentation layer for room descriptions |
| `WorldEvent` | Admin/debug tools, scheduled event systems |
| Evidence generation | CombatService (after combat) |
| Migration triggering | TerritoryService (on territory loss) |

### 17.3 Integration Points

```
CombatService (existing)
    └── calls EvolutionService.CreateBattleEvidence() after combat

TerritoryService (v0.1.4c)
    └── calls EvolutionService.TriggerMigration() on faction retreat

WorldStateService (v0.1.4a)
    ├── saves/loads EnvironmentalEvidence
    ├── saves/loads WorldEvent
    └── tracks evidence changes as PersistentChange

RepopulationService (v0.1.4b)
    └── called by EvolutionService for migration destination setup

Room (existing)
    ├── extended with CurrentSeason property
    └── may have blocked/revealed exits from cave-ins
```

---

## 18. Future Considerations

### 18.1 Deferred to Future Versions

- **Quest Integration** - Evidence could trigger quest objectives (find the battle site)
- **NPC Reactions** - NPCs could comment on environmental evidence
- **Evidence Investigation** - Detailed examination mechanics for evidence
- **Weather System** - Real-time weather affecting seasonal effects
- **Dungeon Restoration** - NPCs or magic that repairs cave-in damage
- **Evidence Interaction** - Looting corpses, salvaging broken equipment

### 18.2 Out of Scope

- **Graphical Representation** - Visual assets for evidence types
- **Sound Effects** - Audio for cave-ins, seasonal ambience
- **Achievement System** - Awards for witnessing events
- **Multiplayer Synchronization** - Evidence sync between players

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
