# v0.1.4a Design Specification: Persistent World State

**Version:** 0.1.4a
**Phase Name:** Persistent World State
**Parent Version:** v0.1.4 (World Persistence & Evolution)
**Prerequisites:** v0.1.3d Complete (Dungeon Age & Coherence)
**Estimated Tests:** ~24 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [RoomState Entity](#4-roomstate-entity)
5. [RoomStateType Enum](#5-roomstatetype-enum)
6. [PersistentChange Value Object](#6-persistentchange-value-object)
7. [WorldStateService](#7-worldstateservice)
8. [Room Entity Integration](#8-room-entity-integration)
9. [Persistence Rules Configuration](#9-persistence-rules-configuration)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement the persistent world state system that tracks and maintains changes to dungeon rooms across play sessions. This phase establishes the foundation for living dungeons by ensuring that cleared rooms stay cleared, opened chests remain opened, solved puzzles stay solved, and destroyed barriers remain destroyed. The persistence layer enables meaningful player progression and environmental storytelling through permanent consequences.

### 1.2 Current State

| Area | Current State (v0.1.3d) | Target State (v0.1.4a) |
|------|-------------------------|------------------------|
| Room clearing | Not tracked | Cleared rooms stay cleared |
| Chest state | Ephemeral | Opened chests persist as opened |
| Puzzle state | Not tracked | Solved puzzles stay solved |
| Barrier state | Not tracked | Destroyed barriers remain destroyed |
| World changes | Session-only | Persisted across sessions |
| Room timestamps | None | LastCleared, LastVisited tracking |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `RoomState` |
| **Enums** | `RoomStateType` |
| **Value Objects** | `PersistentChange`, `PersistenceRule` |
| **Services** | `WorldStateService` (with `IWorldStateService` interface) |
| **Configuration** | `persistence-rules.json`, `persistence-rules-schema.json` |
| **Entity Updates** | `Room.LastCleared`, `Room.LastVisited`, `Room.PersistentChanges` |
| **Tests** | ~24 new unit tests |

### 1.4 Architectural Significance

This version establishes the **world persistence pattern** that will be extended throughout v0.1.4:
- State tracking for room-level changes
- Change categorization by type (cleared, looted, solved, destroyed)
- Configurable persistence rules per change type
- Timestamp tracking for time-based mechanics
- Foundation for respawn timers (v0.1.4b) and evolution events (v0.1.4c)

---

## 2. Feature Overview

```
v0.1.4a Persistent World State
├── RoomState Entity
│   ├── Unique identification (RoomId reference)
│   ├── Current state type
│   ├── Persistent changes collection
│   ├── LastCleared timestamp
│   ├── LastVisited timestamp
│   ├── ClearCount tracking
│   ├── IsFullyCleared flag
│   └── HasActiveSpawner flag (placeholder for v0.1.4b)
├── RoomStateType Enum
│   ├── Pristine (never entered)
│   ├── Visited (entered but not cleared)
│   ├── PartiallyCleared (some enemies defeated)
│   ├── Cleared (all enemies defeated)
│   └── Exhausted (cleared + looted + puzzles solved)
├── PersistentChange Value Object
│   ├── Change type (Cleared, Looted, Solved, Destroyed)
│   ├── Target identifier
│   ├── Timestamp
│   ├── Is permanent flag
│   └── Expiration time (optional)
├── PersistenceRule Value Object
│   ├── Change type reference
│   ├── Is permanent by default
│   ├── Default expiration duration
│   ├── Respawn eligible flag (placeholder)
│   └── Description
├── WorldStateService
│   ├── GetRoomState(roomId)
│   ├── SetRoomCleared(roomId)
│   ├── SetRoomVisited(roomId)
│   ├── RecordChange(roomId, change)
│   ├── HasChange(roomId, changeType, targetId)
│   ├── GetPersistentChanges(roomId)
│   ├── IsChestLooted(roomId, chestId)
│   ├── IsPuzzleSolved(roomId, puzzleId)
│   ├── IsBarrierDestroyed(roomId, barrierId)
│   ├── GetRoomClearCount(roomId)
│   └── ResetRoomState(roomId)
├── Room Entity Updates
│   ├── LastCleared property
│   ├── LastVisited property
│   ├── PersistentChanges collection
│   ├── SetCleared() method
│   ├── SetVisited() method
│   ├── AddPersistentChange(change) method
│   ├── HasPersistentChange(type, targetId) method
│   └── IsFullyCleared property (computed)
└── Configuration
    ├── persistence-rules.json (change type definitions)
    └── persistence-rules-schema.json (validation)
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Room state affects displayed content and available actions                  │
│  ├── GameView shows cleared/uncleared status                                │
│  ├── Map displays room state indicators                                     │
│  ├── Chest interactions check looted state                                  │
│  └── Puzzle interactions check solved state                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  WorldStateService                                                           │
│  ├── GetRoomState(roomId)          ├── RecordChange(roomId, change)         │
│  ├── SetRoomCleared(roomId)        ├── HasChange(roomId, type, targetId)    │
│  ├── SetRoomVisited(roomId)        ├── GetPersistentChanges(roomId)         │
│  ├── IsChestLooted(roomId, id)     ├── GetRoomClearCount(roomId)            │
│  ├── IsPuzzleSolved(roomId, id)    └── ResetRoomState(roomId)               │
│  └── IsBarrierDestroyed(roomId, id)                                         │
│                                                                              │
│  Interfaces:                        CombatService (Updated)                  │
│  └── IWorldStateService             └── Calls SetRoomCleared on victory     │
│                                                                              │
│  Configuration:                     LootService (Updated)                    │
│  └── PersistenceRulesConfigDto      └── Records chest looted changes        │
│                                                                              │
│                                     PuzzleService (Updated - future)         │
│                                     └── Records puzzle solved changes        │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Entities:                       Value Objects:                              │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                │
│  │ RoomState               │     │ PersistentChange        │                │
│  │ ├── RoomId: Guid        │     │ ├── ChangeType          │                │
│  │ ├── StateType           │     │ ├── TargetId: string    │                │
│  │ ├── Changes: List       │     │ ├── Timestamp: DateTime │                │
│  │ ├── LastCleared         │     │ ├── IsPermanent: bool   │                │
│  │ ├── LastVisited         │     │ └── ExpiresAt: DateTime?│                │
│  │ ├── ClearCount: int     │     └─────────────────────────┘                │
│  │ └── IsFullyCleared      │     ┌─────────────────────────┐                │
│  └─────────────────────────┘     │ PersistenceRule         │                │
│                                  │ ├── ChangeType          │                │
│  Enums:                          │ ├── IsPermanentDefault  │                │
│  ┌─────────────────────────┐     │ ├── DefaultExpiration   │                │
│  │ RoomStateType           │     │ └── RespawnEligible     │                │
│  │ ├── Pristine            │     └─────────────────────────┘                │
│  │ ├── Visited             │                                                │
│  │ ├── PartiallyCleared    │     ┌─────────────────────────┐                │
│  │ ├── Cleared             │     │ ChangeType (Enum)       │                │
│  │ └── Exhausted           │     │ ├── RoomCleared         │                │
│  └─────────────────────────┘     │ ├── ChestLooted         │                │
│                                  │ ├── PuzzleSolved        │                │
│  Entities (Updated):             │ ├── BarrierDestroyed    │                │
│  ┌─────────────────────────┐     │ ├── SecretDiscovered    │                │
│  │ Room                    │     │ └── TrapDisarmed        │                │
│  │ ├── LastCleared         │     └─────────────────────────┘                │
│  │ ├── LastVisited         │                                                │
│  │ ├── PersistentChanges   │                                                │
│  │ └── IsFullyCleared      │                                                │
│  └─────────────────────────┘                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetPersistenceRules(): IReadOnlyList<PersistenceRule>                  │
│  └── Loads and deserializes config/persistence-rules.json                   │
│                                                                              │
│  WorldStatePersistence (future)                                              │
│  ├── SaveWorldState(dungeon)                                                │
│  └── LoadWorldState(dungeonId)                                              │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/persistence-rules.json                                          │
│  └── config/schemas/persistence-rules-schema.json                           │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Room State Transition Flow

```
┌───────────────────────────────────────┐
│ Room created during dungeon generation │
│ Initial state: Pristine               │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Player enters room                                            │
├───────────────────────────────────────────────────────────────┤
│ WorldStateService.SetRoomVisited(roomId)                      │
│ ├── room.SetVisited()                                         │
│ ├── room.LastVisited = DateTime.UtcNow                        │
│ └── RoomState transitions: Pristine → Visited                 │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Room has enemies?                                             │
├───────────────┬───────────────────────────────────────────────┤
│     Yes       │                    No                         │
│       ▼       │                     ▼                         │
│ Combat begins │              Room is safe                     │
│       │       │              (skip to looting)                │
│       ▼       │                                               │
│ Some enemies  │                                               │
│ defeated      │                                               │
│       │       │                                               │
│       ▼       │                                               │
│ State →       │                                               │
│ PartiallyCleared                                              │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ All enemies defeated                                          │
├───────────────────────────────────────────────────────────────┤
│ CombatService calls:                                          │
│ WorldStateService.SetRoomCleared(roomId)                      │
│ ├── room.SetCleared()                                         │
│ ├── room.LastCleared = DateTime.UtcNow                        │
│ ├── room.ClearCount++                                         │
│ ├── RecordChange(roomId, RoomCleared)                         │
│ └── RoomState transitions: PartiallyCleared → Cleared         │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Player opens chest                                            │
├───────────────────────────────────────────────────────────────┤
│ LootService.OpenChest(roomId, chestId)                        │
│ ├── Check: WorldStateService.IsChestLooted(roomId, chestId)   │
│ │   └── If true: "This chest has already been opened"         │
│ ├── If not looted: Generate and give loot                     │
│ └── WorldStateService.RecordChange(roomId, change)            │
│     └── PersistentChange { ChestLooted, chestId, now, true }  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Player solves puzzle / destroys barrier                       │
├───────────────────────────────────────────────────────────────┤
│ Similar flow for puzzles and barriers:                        │
│ ├── PuzzleService.SolvePuzzle → RecordChange(PuzzleSolved)    │
│ └── BarrierService.DestroyBarrier → RecordChange(BarrierDestroyed)
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Check for Exhausted state                                     │
├───────────────────────────────────────────────────────────────┤
│ Room.IsFullyCleared computation:                              │
│ ├── State == Cleared                                          │
│ ├── All chests looted (check HasChange for each)              │
│ ├── All puzzles solved (check HasChange for each)             │
│ └── All barriers destroyed (check HasChange for each)         │
│                                                               │
│ If all true: State → Exhausted                                │
│ (Room has nothing left to interact with)                      │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Persistence Change Recording Flow

```
┌───────────────────────────────────────────────────────────────┐
│ Action triggers persistent change                             │
│ (e.g., chest opened, puzzle solved, barrier destroyed)        │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ WorldStateService.RecordChange(roomId, changeType, targetId)  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Get persistence rule for change type                  │
├───────────────────────────────────────────────────────────────┤
│ var rule = _config.GetPersistenceRules()                      │
│     .FirstOrDefault(r => r.ChangeType == changeType);         │
│                                                               │
│ Rule defines:                                                 │
│ ├── IsPermanentDefault: true/false                            │
│ ├── DefaultExpiration: TimeSpan? (if not permanent)           │
│ └── RespawnEligible: bool (for v0.1.4b)                       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Create PersistentChange                               │
├───────────────────────────────────────────────────────────────┤
│ var change = PersistentChange.Create(                         │
│     changeType: ChangeType.ChestLooted,                       │
│     targetId: "chest-001",                                    │
│     timestamp: DateTime.UtcNow,                               │
│     isPermanent: rule.IsPermanentDefault,                     │
│     expiresAt: rule.IsPermanentDefault                        │
│         ? null                                                │
│         : DateTime.UtcNow + rule.DefaultExpiration            │
│ );                                                            │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Add to room's persistent changes                      │
├───────────────────────────────────────────────────────────────┤
│ room.AddPersistentChange(change);                             │
│                                                               │
│ Room.PersistentChanges now contains:                          │
│ [                                                             │
│   { RoomCleared, null, 2024-01-15T10:30:00, true, null },    │
│   { ChestLooted, "chest-001", 2024-01-15T10:32:00, true, null }│
│ ]                                                             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: Log the change                                        │
├───────────────────────────────────────────────────────────────┤
│ _logger.LogInformation(                                       │
│     "Recorded {ChangeType} for {TargetId} in room {RoomId}",  │
│     changeType, targetId, roomId);                            │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 State Query Flow

```
┌───────────────────────────────────────────────────────────────┐
│ Player attempts to open chest "chest-002"                     │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ LootService.OpenChest(roomId, "chest-002")                    │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ WorldStateService.IsChestLooted(roomId, "chest-002")          │
├───────────────────────────────────────────────────────────────┤
│ Implementation:                                               │
│ return HasChange(roomId, ChangeType.ChestLooted, "chest-002");│
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ WorldStateService.HasChange(roomId, changeType, targetId)     │
├───────────────────────────────────────────────────────────────┤
│ var room = GetRoom(roomId);                                   │
│                                                               │
│ var change = room.PersistentChanges                           │
│     .FirstOrDefault(c =>                                      │
│         c.ChangeType == changeType &&                         │
│         c.TargetId == targetId);                              │
│                                                               │
│ if (change == null)                                           │
│     return false;                                             │
│                                                               │
│ // Check if change has expired                                │
│ if (!change.IsPermanent && change.ExpiresAt.HasValue)         │
│ {                                                             │
│     if (DateTime.UtcNow > change.ExpiresAt.Value)             │
│     {                                                         │
│         // Change has expired, remove it                      │
│         room.RemovePersistentChange(change);                  │
│         return false;                                         │
│     }                                                         │
│ }                                                             │
│                                                               │
│ return true;                                                  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Result determines behavior                                    │
├───────────────────────────────────────────────────────────────┤
│ if (isLooted)                                                 │
│ {                                                             │
│     // Show already-looted message                            │
│     return "This chest has already been opened. It is empty.";│
│ }                                                             │
│ else                                                          │
│ {                                                             │
│     // Generate loot and record change                        │
│     var loot = GenerateLoot(chestId);                         │
│     _worldStateService.RecordChange(                          │
│         roomId, ChangeType.ChestLooted, chestId);             │
│     return $"You find {loot} inside the chest!";              │
│ }                                                             │
└───────────────────────────────────────────────────────────────┘
```

---

## 4. RoomState Entity

### 4.1 Purpose

The `RoomState` entity tracks the persistent state of a room, including when it was cleared, when it was last visited, and all persistent changes that have occurred within it. This enables the game to maintain continuity across sessions.

### 4.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/RoomState.cs`

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks the persistent state of a room across play sessions.
/// </summary>
/// <remarks>
/// RoomState maintains information about room clearing, visits, and
/// persistent changes like looted chests, solved puzzles, and destroyed
/// barriers. This enables living dungeons that remember player actions.
/// </remarks>
public class RoomState
{
    /// <summary>
    /// Gets the unique identifier for this room state.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the ID of the room this state tracks.
    /// </summary>
    public Guid RoomId { get; private set; }

    /// <summary>
    /// Gets the current state type of the room.
    /// </summary>
    /// <remarks>
    /// Progresses from Pristine through Visited, PartiallyCleared,
    /// Cleared, and finally Exhausted as the player interacts with the room.
    /// </remarks>
    public RoomStateType StateType { get; private set; } = RoomStateType.Pristine;

    /// <summary>
    /// Gets the collection of persistent changes in this room.
    /// </summary>
    /// <remarks>
    /// Includes cleared status, looted chests, solved puzzles,
    /// destroyed barriers, discovered secrets, and disarmed traps.
    /// </remarks>
    public IReadOnlyList<PersistentChange> Changes => _changes.AsReadOnly();
    private readonly List<PersistentChange> _changes = new();

    /// <summary>
    /// Gets when this room was last cleared of enemies.
    /// </summary>
    /// <remarks>
    /// Null if the room has never been cleared. Used for respawn
    /// timer calculations in v0.1.4b.
    /// </remarks>
    public DateTime? LastCleared { get; private set; }

    /// <summary>
    /// Gets when this room was last visited by the player.
    /// </summary>
    /// <remarks>
    /// Updated each time the player enters the room.
    /// </remarks>
    public DateTime? LastVisited { get; private set; }

    /// <summary>
    /// Gets the number of times this room has been cleared.
    /// </summary>
    /// <remarks>
    /// Increments each time all enemies are defeated. Used for
    /// scaling respawns in v0.1.4b.
    /// </remarks>
    public int ClearCount { get; private set; }

    /// <summary>
    /// Gets whether this room has an active spawner.
    /// </summary>
    /// <remarks>
    /// Placeholder for v0.1.4b Monster Repopulation.
    /// Rooms with active spawners can repopulate over time.
    /// </remarks>
    public bool HasActiveSpawner { get; private set; }

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private RoomState() { }

    /// <summary>
    /// Creates a new room state for a room.
    /// </summary>
    /// <param name="roomId">The ID of the room to track.</param>
    /// <returns>A new RoomState instance.</returns>
    public static RoomState Create(Guid roomId)
    {
        if (roomId == Guid.Empty)
            throw new ArgumentException("Room ID cannot be empty.", nameof(roomId));

        return new RoomState
        {
            Id = Guid.NewGuid(),
            RoomId = roomId,
            StateType = RoomStateType.Pristine,
            ClearCount = 0,
            HasActiveSpawner = false
        };
    }

    /// <summary>
    /// Marks the room as visited.
    /// </summary>
    public void SetVisited()
    {
        LastVisited = DateTime.UtcNow;

        if (StateType == RoomStateType.Pristine)
        {
            StateType = RoomStateType.Visited;
        }
    }

    /// <summary>
    /// Marks the room as partially cleared (some enemies defeated).
    /// </summary>
    public void SetPartiallyCleared()
    {
        if (StateType == RoomStateType.Visited || StateType == RoomStateType.Pristine)
        {
            StateType = RoomStateType.PartiallyCleared;
        }
    }

    /// <summary>
    /// Marks the room as cleared (all enemies defeated).
    /// </summary>
    public void SetCleared()
    {
        LastCleared = DateTime.UtcNow;
        ClearCount++;

        if (StateType != RoomStateType.Exhausted)
        {
            StateType = RoomStateType.Cleared;
        }

        // Add the cleared change if not already present
        if (!HasChange(ChangeType.RoomCleared, null))
        {
            AddChange(PersistentChange.Create(
                ChangeType.RoomCleared,
                null,
                DateTime.UtcNow,
                true,
                null));
        }
    }

    /// <summary>
    /// Marks the room as exhausted (fully cleared with nothing left).
    /// </summary>
    public void SetExhausted()
    {
        StateType = RoomStateType.Exhausted;
    }

    /// <summary>
    /// Adds a persistent change to this room.
    /// </summary>
    /// <param name="change">The change to add.</param>
    public void AddChange(PersistentChange change)
    {
        // Don't add duplicate changes
        if (HasChange(change.ChangeType, change.TargetId))
            return;

        _changes.Add(change);
    }

    /// <summary>
    /// Removes a persistent change from this room.
    /// </summary>
    /// <param name="change">The change to remove.</param>
    /// <returns>True if the change was removed.</returns>
    public bool RemoveChange(PersistentChange change)
    {
        return _changes.Remove(change);
    }

    /// <summary>
    /// Checks if a specific change exists in this room.
    /// </summary>
    /// <param name="changeType">The type of change.</param>
    /// <param name="targetId">The target identifier (null for room-level changes).</param>
    /// <returns>True if the change exists and is valid.</returns>
    public bool HasChange(ChangeType changeType, string? targetId)
    {
        var change = _changes.FirstOrDefault(c =>
            c.ChangeType == changeType &&
            c.TargetId == targetId);

        if (change.Equals(default(PersistentChange)))
            return false;

        // Check expiration
        if (!change.IsPermanent && change.ExpiresAt.HasValue)
        {
            if (DateTime.UtcNow > change.ExpiresAt.Value)
            {
                _changes.Remove(change);
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// Gets all changes of a specific type.
    /// </summary>
    /// <param name="changeType">The type of changes to get.</param>
    /// <returns>All changes of the specified type.</returns>
    public IReadOnlyList<PersistentChange> GetChangesByType(ChangeType changeType)
    {
        return _changes
            .Where(c => c.ChangeType == changeType)
            .ToList();
    }

    /// <summary>
    /// Removes all expired changes from this room.
    /// </summary>
    /// <returns>The number of expired changes removed.</returns>
    public int CleanupExpiredChanges()
    {
        var now = DateTime.UtcNow;
        var expired = _changes
            .Where(c => !c.IsPermanent && c.ExpiresAt.HasValue && c.ExpiresAt.Value < now)
            .ToList();

        foreach (var change in expired)
        {
            _changes.Remove(change);
        }

        return expired.Count;
    }

    /// <summary>
    /// Resets the room state to pristine.
    /// </summary>
    /// <remarks>
    /// Used for dungeon regeneration or testing.
    /// </remarks>
    public void Reset()
    {
        StateType = RoomStateType.Pristine;
        _changes.Clear();
        LastCleared = null;
        LastVisited = null;
        ClearCount = 0;
    }

    /// <summary>
    /// Sets whether this room has an active spawner.
    /// </summary>
    /// <param name="hasSpawner">True if the room has an active spawner.</param>
    public void SetHasActiveSpawner(bool hasSpawner)
    {
        HasActiveSpawner = hasSpawner;
    }

    /// <summary>
    /// Gets a string representation of the room state.
    /// </summary>
    public override string ToString() =>
        $"RoomState[{RoomId}] {StateType} (Cleared: {ClearCount}x, Changes: {_changes.Count})";
}
```

### 4.4 Properties Summary

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `Id` | `Guid` | Unique identifier for the state record | Generated |
| `RoomId` | `Guid` | Reference to the room | Required |
| `StateType` | `RoomStateType` | Current room state | Pristine |
| `Changes` | `IReadOnlyList<PersistentChange>` | Persistent changes collection | Empty |
| `LastCleared` | `DateTime?` | When last cleared | null |
| `LastVisited` | `DateTime?` | When last visited | null |
| `ClearCount` | `int` | Times cleared | 0 |
| `HasActiveSpawner` | `bool` | Has spawner (placeholder) | false |

---

## 5. RoomStateType Enum

### 5.1 Purpose

The `RoomStateType` enum represents the progression of a room's state as the player interacts with it, from pristine (never entered) to exhausted (completely cleared and looted).

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Enums/RoomStateType.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the state of a room's exploration and clearing.
/// </summary>
/// <remarks>
/// Room states progress linearly from Pristine through Exhausted,
/// reflecting the player's interaction with the room contents.
/// States affect map display, respawn behavior, and available interactions.
/// </remarks>
public enum RoomStateType
{
    /// <summary>
    /// Room has never been entered by the player.
    /// </summary>
    /// <remarks>
    /// Initial state for all rooms. Room may contain enemies,
    /// loot, puzzles, and other content. Displayed as unexplored on map.
    /// </remarks>
    Pristine = 0,

    /// <summary>
    /// Room has been entered but not cleared of enemies.
    /// </summary>
    /// <remarks>
    /// Player has seen the room but enemies remain.
    /// May have partially interacted with content.
    /// </remarks>
    Visited = 1,

    /// <summary>
    /// Some enemies have been defeated but not all.
    /// </summary>
    /// <remarks>
    /// Combat was initiated but room is not safe.
    /// Player may have fled or enemies spawned mid-combat.
    /// </remarks>
    PartiallyCleared = 2,

    /// <summary>
    /// All enemies have been defeated.
    /// </summary>
    /// <remarks>
    /// Room is safe for exploration. May still contain
    /// unopened chests, unsolved puzzles, or intact barriers.
    /// Eligible for respawn if room has spawner (v0.1.4b).
    /// </remarks>
    Cleared = 3,

    /// <summary>
    /// Room is fully explored with no remaining interactions.
    /// </summary>
    /// <remarks>
    /// All enemies defeated, chests looted, puzzles solved,
    /// barriers destroyed. No reason to return unless respawns
    /// occur. May still be a travel corridor.
    /// </remarks>
    Exhausted = 4
}
```

### 5.4 State Characteristics Summary

| State | Enemies | Safe | Loot Available | Map Display |
|-------|---------|------|----------------|-------------|
| Pristine | Unknown | No | Unknown | Unexplored |
| Visited | Present | No | Unknown | Seen |
| PartiallyCleared | Some | No | Unknown | Partial |
| Cleared | None | Yes | Maybe | Cleared |
| Exhausted | None | Yes | No | Complete |

---

## 6. PersistentChange Value Object

### 6.1 Purpose

The `PersistentChange` value object represents a single persistent change that has occurred in a room, such as a chest being looted, a puzzle being solved, or a barrier being destroyed.

### 6.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/PersistentChange.cs`

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents a persistent change that occurred in a room.
/// </summary>
/// <remarks>
/// Persistent changes track specific interactions like looted chests,
/// solved puzzles, and destroyed barriers. Each change can be permanent
/// or have an expiration time for respawn mechanics.
/// </remarks>
public readonly record struct PersistentChange
{
    /// <summary>
    /// Gets the type of change.
    /// </summary>
    public ChangeType ChangeType { get; init; }

    /// <summary>
    /// Gets the target identifier for this change.
    /// </summary>
    /// <remarks>
    /// Null for room-level changes (RoomCleared).
    /// For object changes: chest ID, puzzle ID, barrier ID, etc.
    /// </remarks>
    public string? TargetId { get; init; }

    /// <summary>
    /// Gets when this change occurred.
    /// </summary>
    public DateTime Timestamp { get; init; }

    /// <summary>
    /// Gets whether this change is permanent.
    /// </summary>
    /// <remarks>
    /// Permanent changes never expire (e.g., destroyed barriers).
    /// Non-permanent changes may respawn (e.g., cleared enemies).
    /// </remarks>
    public bool IsPermanent { get; init; }

    /// <summary>
    /// Gets when this change expires.
    /// </summary>
    /// <remarks>
    /// Null for permanent changes. After expiration, the change
    /// is removed and the target can be interacted with again.
    /// </remarks>
    public DateTime? ExpiresAt { get; init; }

    /// <summary>
    /// Creates a new persistent change.
    /// </summary>
    /// <param name="changeType">The type of change.</param>
    /// <param name="targetId">The target identifier (null for room-level).</param>
    /// <param name="timestamp">When the change occurred.</param>
    /// <param name="isPermanent">Whether the change is permanent.</param>
    /// <param name="expiresAt">When the change expires (null if permanent).</param>
    /// <returns>A new PersistentChange instance.</returns>
    public static PersistentChange Create(
        ChangeType changeType,
        string? targetId,
        DateTime timestamp,
        bool isPermanent,
        DateTime? expiresAt)
    {
        if (!isPermanent && !expiresAt.HasValue)
            throw new ArgumentException(
                "Non-permanent changes must have an expiration time.",
                nameof(expiresAt));

        if (isPermanent && expiresAt.HasValue)
            throw new ArgumentException(
                "Permanent changes cannot have an expiration time.",
                nameof(expiresAt));

        return new PersistentChange
        {
            ChangeType = changeType,
            TargetId = targetId,
            Timestamp = timestamp,
            IsPermanent = isPermanent,
            ExpiresAt = expiresAt
        };
    }

    /// <summary>
    /// Creates a permanent change.
    /// </summary>
    public static PersistentChange Permanent(ChangeType changeType, string? targetId) =>
        Create(changeType, targetId, DateTime.UtcNow, true, null);

    /// <summary>
    /// Creates a temporary change with expiration.
    /// </summary>
    public static PersistentChange Temporary(
        ChangeType changeType,
        string? targetId,
        TimeSpan duration) =>
        Create(changeType, targetId, DateTime.UtcNow, false, DateTime.UtcNow + duration);

    /// <summary>
    /// Creates a room cleared change.
    /// </summary>
    public static PersistentChange RoomCleared(bool isPermanent = false, TimeSpan? respawnTime = null)
    {
        if (isPermanent)
            return Permanent(ChangeType.RoomCleared, null);

        return Temporary(ChangeType.RoomCleared, null, respawnTime ?? TimeSpan.FromMinutes(30));
    }

    /// <summary>
    /// Creates a chest looted change (always permanent).
    /// </summary>
    public static PersistentChange ChestLooted(string chestId) =>
        Permanent(ChangeType.ChestLooted, chestId);

    /// <summary>
    /// Creates a puzzle solved change (always permanent).
    /// </summary>
    public static PersistentChange PuzzleSolved(string puzzleId) =>
        Permanent(ChangeType.PuzzleSolved, puzzleId);

    /// <summary>
    /// Creates a barrier destroyed change (always permanent).
    /// </summary>
    public static PersistentChange BarrierDestroyed(string barrierId) =>
        Permanent(ChangeType.BarrierDestroyed, barrierId);

    /// <summary>
    /// Creates a secret discovered change (always permanent).
    /// </summary>
    public static PersistentChange SecretDiscovered(string secretId) =>
        Permanent(ChangeType.SecretDiscovered, secretId);

    /// <summary>
    /// Creates a trap disarmed change (always permanent).
    /// </summary>
    public static PersistentChange TrapDisarmed(string trapId) =>
        Permanent(ChangeType.TrapDisarmed, trapId);

    /// <summary>
    /// Checks if this change has expired.
    /// </summary>
    public bool IsExpired => !IsPermanent && ExpiresAt.HasValue && DateTime.UtcNow > ExpiresAt.Value;

    /// <summary>
    /// Gets the time remaining until expiration.
    /// </summary>
    public TimeSpan? TimeRemaining =>
        IsPermanent ? null :
        ExpiresAt.HasValue ? ExpiresAt.Value - DateTime.UtcNow :
        null;

    /// <summary>
    /// Gets a string representation of the change.
    /// </summary>
    public override string ToString()
    {
        var target = TargetId ?? "room";
        var expiry = IsPermanent ? "permanent" : $"expires {ExpiresAt:g}";
        return $"{ChangeType}({target}) @ {Timestamp:g} [{expiry}]";
    }
}
```

### 6.4 ChangeType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/ChangeType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of persistent changes that can occur in a room.
/// </summary>
/// <remarks>
/// Change types categorize what aspect of the room was modified.
/// Each type has different default persistence rules defined in configuration.
/// </remarks>
public enum ChangeType
{
    /// <summary>
    /// Room was cleared of all enemies.
    /// </summary>
    /// <remarks>
    /// May be temporary if room has respawn enabled.
    /// </remarks>
    RoomCleared = 0,

    /// <summary>
    /// A chest was opened and looted.
    /// </summary>
    /// <remarks>
    /// Always permanent. Chests do not respawn their contents.
    /// </remarks>
    ChestLooted = 1,

    /// <summary>
    /// A puzzle was solved.
    /// </summary>
    /// <remarks>
    /// Always permanent. Puzzles stay solved.
    /// </remarks>
    PuzzleSolved = 2,

    /// <summary>
    /// A barrier was destroyed.
    /// </summary>
    /// <remarks>
    /// Always permanent. Barriers do not regenerate.
    /// </remarks>
    BarrierDestroyed = 3,

    /// <summary>
    /// A secret area was discovered.
    /// </summary>
    /// <remarks>
    /// Always permanent. Secrets stay revealed.
    /// </remarks>
    SecretDiscovered = 4,

    /// <summary>
    /// A trap was disarmed.
    /// </summary>
    /// <remarks>
    /// Always permanent. Traps stay disarmed.
    /// </remarks>
    TrapDisarmed = 5
}
```

---

## 7. WorldStateService

### 7.1 Purpose

The `WorldStateService` provides centralized management of room states and persistent changes. It offers methods for recording changes, querying state, and managing the lifecycle of persistent world data.

### 7.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/IWorldStateService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/WorldStateService.cs`

### 7.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing persistent world state.
/// </summary>
public interface IWorldStateService
{
    /// <summary>
    /// Gets the state for a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>The room state, or a new pristine state if none exists.</returns>
    RoomState GetRoomState(Guid roomId);

    /// <summary>
    /// Marks a room as visited.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    void SetRoomVisited(Guid roomId);

    /// <summary>
    /// Marks a room as cleared of all enemies.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="isPermanent">Whether the clear is permanent (no respawn).</param>
    void SetRoomCleared(Guid roomId, bool isPermanent = false);

    /// <summary>
    /// Records a persistent change in a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="changeType">The type of change.</param>
    /// <param name="targetId">The target identifier (null for room-level changes).</param>
    void RecordChange(Guid roomId, ChangeType changeType, string? targetId = null);

    /// <summary>
    /// Checks if a specific change exists in a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="changeType">The type of change.</param>
    /// <param name="targetId">The target identifier.</param>
    /// <returns>True if the change exists and is valid.</returns>
    bool HasChange(Guid roomId, ChangeType changeType, string? targetId = null);

    /// <summary>
    /// Gets all persistent changes for a room.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>All persistent changes in the room.</returns>
    IReadOnlyList<PersistentChange> GetPersistentChanges(Guid roomId);

    /// <summary>
    /// Checks if a chest has been looted.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="chestId">The chest identifier.</param>
    /// <returns>True if the chest has been looted.</returns>
    bool IsChestLooted(Guid roomId, string chestId);

    /// <summary>
    /// Checks if a puzzle has been solved.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="puzzleId">The puzzle identifier.</param>
    /// <returns>True if the puzzle has been solved.</returns>
    bool IsPuzzleSolved(Guid roomId, string puzzleId);

    /// <summary>
    /// Checks if a barrier has been destroyed.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="barrierId">The barrier identifier.</param>
    /// <returns>True if the barrier has been destroyed.</returns>
    bool IsBarrierDestroyed(Guid roomId, string barrierId);

    /// <summary>
    /// Checks if a secret has been discovered.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="secretId">The secret identifier.</param>
    /// <returns>True if the secret has been discovered.</returns>
    bool IsSecretDiscovered(Guid roomId, string secretId);

    /// <summary>
    /// Checks if a trap has been disarmed.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <param name="trapId">The trap identifier.</param>
    /// <returns>True if the trap has been disarmed.</returns>
    bool IsTrapDisarmed(Guid roomId, string trapId);

    /// <summary>
    /// Gets the number of times a room has been cleared.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    /// <returns>The clear count.</returns>
    int GetRoomClearCount(Guid roomId);

    /// <summary>
    /// Resets a room's state to pristine.
    /// </summary>
    /// <param name="roomId">The room identifier.</param>
    void ResetRoomState(Guid roomId);

    /// <summary>
    /// Cleans up expired changes across all tracked rooms.
    /// </summary>
    /// <returns>The total number of expired changes removed.</returns>
    int CleanupExpiredChanges();

    /// <summary>
    /// Gets the persistence rule for a change type.
    /// </summary>
    /// <param name="changeType">The change type.</param>
    /// <returns>The persistence rule.</returns>
    PersistenceRule GetPersistenceRule(ChangeType changeType);
}
```

### 7.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing persistent world state.
/// </summary>
public class WorldStateService : IWorldStateService
{
    private readonly IConfigurationProvider _config;
    private readonly ILogger<WorldStateService> _logger;

    private readonly Dictionary<Guid, RoomState> _roomStates = new();

    /// <summary>
    /// Initializes a new instance of the WorldStateService.
    /// </summary>
    public WorldStateService(
        IConfigurationProvider config,
        ILogger<WorldStateService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public RoomState GetRoomState(Guid roomId)
    {
        if (!_roomStates.TryGetValue(roomId, out var state))
        {
            state = RoomState.Create(roomId);
            _roomStates[roomId] = state;

            _logger.LogDebug("Created new room state for room {RoomId}", roomId);
        }

        return state;
    }

    /// <inheritdoc />
    public void SetRoomVisited(Guid roomId)
    {
        var state = GetRoomState(roomId);
        state.SetVisited();

        _logger.LogDebug("Room {RoomId} marked as visited", roomId);
    }

    /// <inheritdoc />
    public void SetRoomCleared(Guid roomId, bool isPermanent = false)
    {
        var state = GetRoomState(roomId);
        state.SetCleared();

        // Record the change with appropriate persistence
        var rule = GetPersistenceRule(ChangeType.RoomCleared);
        var change = isPermanent || rule.IsPermanentDefault
            ? PersistentChange.Permanent(ChangeType.RoomCleared, null)
            : PersistentChange.Temporary(ChangeType.RoomCleared, null, rule.DefaultExpiration);

        state.AddChange(change);

        _logger.LogInformation(
            "Room {RoomId} marked as cleared (Clear #{ClearCount}, Permanent: {IsPermanent})",
            roomId,
            state.ClearCount,
            isPermanent || rule.IsPermanentDefault);
    }

    /// <inheritdoc />
    public void RecordChange(Guid roomId, ChangeType changeType, string? targetId = null)
    {
        var state = GetRoomState(roomId);
        var rule = GetPersistenceRule(changeType);

        var change = rule.IsPermanentDefault
            ? PersistentChange.Permanent(changeType, targetId)
            : PersistentChange.Temporary(changeType, targetId, rule.DefaultExpiration);

        state.AddChange(change);

        _logger.LogInformation(
            "Recorded {ChangeType} for {TargetId} in room {RoomId}",
            changeType,
            targetId ?? "room",
            roomId);

        // Check if room should transition to exhausted
        UpdateRoomExhaustedState(state);
    }

    /// <inheritdoc />
    public bool HasChange(Guid roomId, ChangeType changeType, string? targetId = null)
    {
        var state = GetRoomState(roomId);
        return state.HasChange(changeType, targetId);
    }

    /// <inheritdoc />
    public IReadOnlyList<PersistentChange> GetPersistentChanges(Guid roomId)
    {
        var state = GetRoomState(roomId);
        return state.Changes;
    }

    /// <inheritdoc />
    public bool IsChestLooted(Guid roomId, string chestId)
    {
        return HasChange(roomId, ChangeType.ChestLooted, chestId);
    }

    /// <inheritdoc />
    public bool IsPuzzleSolved(Guid roomId, string puzzleId)
    {
        return HasChange(roomId, ChangeType.PuzzleSolved, puzzleId);
    }

    /// <inheritdoc />
    public bool IsBarrierDestroyed(Guid roomId, string barrierId)
    {
        return HasChange(roomId, ChangeType.BarrierDestroyed, barrierId);
    }

    /// <inheritdoc />
    public bool IsSecretDiscovered(Guid roomId, string secretId)
    {
        return HasChange(roomId, ChangeType.SecretDiscovered, secretId);
    }

    /// <inheritdoc />
    public bool IsTrapDisarmed(Guid roomId, string trapId)
    {
        return HasChange(roomId, ChangeType.TrapDisarmed, trapId);
    }

    /// <inheritdoc />
    public int GetRoomClearCount(Guid roomId)
    {
        var state = GetRoomState(roomId);
        return state.ClearCount;
    }

    /// <inheritdoc />
    public void ResetRoomState(Guid roomId)
    {
        if (_roomStates.TryGetValue(roomId, out var state))
        {
            state.Reset();
            _logger.LogInformation("Reset room state for room {RoomId}", roomId);
        }
    }

    /// <inheritdoc />
    public int CleanupExpiredChanges()
    {
        var totalRemoved = 0;

        foreach (var state in _roomStates.Values)
        {
            var removed = state.CleanupExpiredChanges();
            if (removed > 0)
            {
                _logger.LogDebug(
                    "Removed {RemovedCount} expired changes from room {RoomId}",
                    removed,
                    state.RoomId);
            }
            totalRemoved += removed;
        }

        if (totalRemoved > 0)
        {
            _logger.LogInformation(
                "Cleaned up {TotalRemoved} expired changes across all rooms",
                totalRemoved);
        }

        return totalRemoved;
    }

    /// <inheritdoc />
    public PersistenceRule GetPersistenceRule(ChangeType changeType)
    {
        var rules = _config.GetPersistenceRules();
        var rule = rules.FirstOrDefault(r => r.ChangeType == changeType);

        if (rule.Equals(default(PersistenceRule)))
        {
            _logger.LogWarning(
                "No persistence rule found for {ChangeType}, using default",
                changeType);
            return PersistenceRule.Default;
        }

        return rule;
    }

    /// <summary>
    /// Updates the room's exhausted state if all interactions are complete.
    /// </summary>
    private void UpdateRoomExhaustedState(RoomState state)
    {
        // This is a simplified check. In a full implementation,
        // you'd check against the room's actual contents.
        // For now, we just log that exhausted state checking would occur.
        _logger.LogDebug(
            "Checking exhausted state for room {RoomId} (State: {State}, Changes: {ChangeCount})",
            state.RoomId,
            state.StateType,
            state.Changes.Count);
    }
}
```

---

## 8. Room Entity Integration

### 8.1 Purpose

Extend the `Room` entity to store persistence-related properties directly on the room, enabling quick access without querying the WorldStateService for common operations.

### 8.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modification)

### 8.3 Changes

```csharp
// Add to Room.cs - after existing Age property

/// <summary>
/// Gets when this room was last cleared of enemies.
/// </summary>
/// <remarks>
/// Null if the room has never been cleared. Used for determining
/// respawn eligibility and room state display.
/// </remarks>
public DateTime? LastCleared { get; private set; }

/// <summary>
/// Gets when this room was last visited by the player.
/// </summary>
/// <remarks>
/// Updated each time the player enters the room. Used for
/// tracking exploration and staleness of information.
/// </remarks>
public DateTime? LastVisited { get; private set; }

/// <summary>
/// Gets the collection of persistent changes in this room.
/// </summary>
/// <remarks>
/// Includes looted chests, solved puzzles, destroyed barriers,
/// discovered secrets, and disarmed traps.
/// </remarks>
public IReadOnlyList<PersistentChange> PersistentChanges => _persistentChanges.AsReadOnly();
private readonly List<PersistentChange> _persistentChanges = new();

/// <summary>
/// Gets the number of times this room has been cleared.
/// </summary>
public int ClearCount { get; private set; }

/// <summary>
/// Marks this room as visited.
/// </summary>
public void SetVisited()
{
    LastVisited = DateTime.UtcNow;
}

/// <summary>
/// Marks this room as cleared.
/// </summary>
public void SetCleared()
{
    LastCleared = DateTime.UtcNow;
    ClearCount++;
}

/// <summary>
/// Adds a persistent change to this room.
/// </summary>
/// <param name="change">The change to add.</param>
public void AddPersistentChange(PersistentChange change)
{
    // Avoid duplicates
    if (HasPersistentChange(change.ChangeType, change.TargetId))
        return;

    _persistentChanges.Add(change);
}

/// <summary>
/// Checks if a persistent change exists in this room.
/// </summary>
/// <param name="changeType">The type of change.</param>
/// <param name="targetId">The target identifier.</param>
/// <returns>True if the change exists.</returns>
public bool HasPersistentChange(ChangeType changeType, string? targetId)
{
    return _persistentChanges.Any(c =>
        c.ChangeType == changeType &&
        c.TargetId == targetId &&
        !c.IsExpired);
}

/// <summary>
/// Removes a persistent change from this room.
/// </summary>
/// <param name="changeType">The type of change.</param>
/// <param name="targetId">The target identifier.</param>
/// <returns>True if a change was removed.</returns>
public bool RemovePersistentChange(ChangeType changeType, string? targetId)
{
    var change = _persistentChanges.FirstOrDefault(c =>
        c.ChangeType == changeType &&
        c.TargetId == targetId);

    if (!change.Equals(default(PersistentChange)))
    {
        _persistentChanges.Remove(change);
        return true;
    }

    return false;
}

/// <summary>
/// Gets whether this room is fully cleared (no enemies, all loot taken, puzzles solved).
/// </summary>
/// <remarks>
/// A fully cleared room has nothing left to interact with.
/// This is a simplified check; full implementation would verify
/// against actual room contents.
/// </remarks>
public bool IsFullyCleared =>
    HasPersistentChange(ChangeType.RoomCleared, null) &&
    RoomType != RoomType.Boss; // Boss rooms have special handling
```

### 8.4 Data Model Change

```
MODIFY: Room
├── ADD: LastCleared: DateTime? (default: null)
├── ADD: LastVisited: DateTime? (default: null)
├── ADD: PersistentChanges: IReadOnlyList<PersistentChange>
├── ADD: ClearCount: int (default: 0)
├── ADD: SetVisited(): void
├── ADD: SetCleared(): void
├── ADD: AddPersistentChange(change): void
├── ADD: HasPersistentChange(type, targetId): bool
├── ADD: RemovePersistentChange(type, targetId): bool
└── ADD: IsFullyCleared: bool (computed)
```

---

## 9. Persistence Rules Configuration

### 9.1 PersistenceRule Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/PersistenceRule.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines persistence behavior for a change type.
/// </summary>
/// <remarks>
/// Persistence rules determine whether changes are permanent or temporary,
/// and how long temporary changes last before expiring.
/// </remarks>
public readonly record struct PersistenceRule
{
    /// <summary>
    /// Gets the change type this rule applies to.
    /// </summary>
    public ChangeType ChangeType { get; init; }

    /// <summary>
    /// Gets whether changes of this type are permanent by default.
    /// </summary>
    public bool IsPermanentDefault { get; init; }

    /// <summary>
    /// Gets the default expiration duration for non-permanent changes.
    /// </summary>
    public TimeSpan DefaultExpiration { get; init; }

    /// <summary>
    /// Gets whether this change type is eligible for respawn mechanics.
    /// </summary>
    /// <remarks>
    /// Placeholder for v0.1.4b Monster Repopulation.
    /// </remarks>
    public bool RespawnEligible { get; init; }

    /// <summary>
    /// Gets a description of this persistence rule.
    /// </summary>
    public string Description { get; init; }

    /// <summary>
    /// Gets the default persistence rule for unknown change types.
    /// </summary>
    public static PersistenceRule Default => new()
    {
        ChangeType = ChangeType.RoomCleared,
        IsPermanentDefault = false,
        DefaultExpiration = TimeSpan.FromMinutes(30),
        RespawnEligible = true,
        Description = "Default persistence rule"
    };

    /// <summary>
    /// Creates a permanent persistence rule.
    /// </summary>
    public static PersistenceRule Permanent(ChangeType changeType, string description) => new()
    {
        ChangeType = changeType,
        IsPermanentDefault = true,
        DefaultExpiration = TimeSpan.Zero,
        RespawnEligible = false,
        Description = description
    };

    /// <summary>
    /// Creates a temporary persistence rule with respawn.
    /// </summary>
    public static PersistenceRule Temporary(
        ChangeType changeType,
        TimeSpan expiration,
        string description) => new()
    {
        ChangeType = changeType,
        IsPermanentDefault = false,
        DefaultExpiration = expiration,
        RespawnEligible = true,
        Description = description
    };
}
```

---

## 10. Data Model Changes

### 10.1 Summary

```
NEW: RoomState (Entity)
├── Id: Guid
├── RoomId: Guid
├── StateType: RoomStateType
├── Changes: IReadOnlyList<PersistentChange>
├── LastCleared: DateTime?
├── LastVisited: DateTime?
├── ClearCount: int
├── HasActiveSpawner: bool
├── SetVisited(): void
├── SetPartiallyCleared(): void
├── SetCleared(): void
├── SetExhausted(): void
├── AddChange(change): void
├── RemoveChange(change): bool
├── HasChange(type, targetId): bool
├── GetChangesByType(type): IReadOnlyList<PersistentChange>
├── CleanupExpiredChanges(): int
├── Reset(): void
└── SetHasActiveSpawner(bool): void

NEW: RoomStateType (Enum)
├── Pristine
├── Visited
├── PartiallyCleared
├── Cleared
└── Exhausted

NEW: ChangeType (Enum)
├── RoomCleared
├── ChestLooted
├── PuzzleSolved
├── BarrierDestroyed
├── SecretDiscovered
└── TrapDisarmed

NEW: PersistentChange (Value Object)
├── ChangeType: ChangeType
├── TargetId: string?
├── Timestamp: DateTime
├── IsPermanent: bool
├── ExpiresAt: DateTime?
├── IsExpired: bool (computed)
├── TimeRemaining: TimeSpan? (computed)
└── Factory methods for each change type

NEW: PersistenceRule (Value Object)
├── ChangeType: ChangeType
├── IsPermanentDefault: bool
├── DefaultExpiration: TimeSpan
├── RespawnEligible: bool
└── Description: string

MODIFY: Room
├── ADD: LastCleared: DateTime?
├── ADD: LastVisited: DateTime?
├── ADD: PersistentChanges: IReadOnlyList<PersistentChange>
├── ADD: ClearCount: int
├── ADD: SetVisited(): void
├── ADD: SetCleared(): void
├── ADD: AddPersistentChange(change): void
├── ADD: HasPersistentChange(type, targetId): bool
├── ADD: RemovePersistentChange(type, targetId): bool
└── ADD: IsFullyCleared: bool (computed)

NEW: IWorldStateService (Interface)
├── GetRoomState(roomId): RoomState
├── SetRoomVisited(roomId): void
├── SetRoomCleared(roomId, isPermanent): void
├── RecordChange(roomId, changeType, targetId): void
├── HasChange(roomId, changeType, targetId): bool
├── GetPersistentChanges(roomId): IReadOnlyList<PersistentChange>
├── IsChestLooted(roomId, chestId): bool
├── IsPuzzleSolved(roomId, puzzleId): bool
├── IsBarrierDestroyed(roomId, barrierId): bool
├── IsSecretDiscovered(roomId, secretId): bool
├── IsTrapDisarmed(roomId, trapId): bool
├── GetRoomClearCount(roomId): int
├── ResetRoomState(roomId): void
├── CleanupExpiredChanges(): int
└── GetPersistenceRule(changeType): PersistenceRule

NEW: WorldStateService (Implementation)

MODIFY: IConfigurationProvider
└── ADD: GetPersistenceRules(): IReadOnlyList<PersistenceRule>
```

---

## 11. Configuration File Schemas

### 11.1 Persistence Rules Configuration

**File:** `config/persistence-rules.json`

```json
{
  "$schema": "schemas/persistence-rules-schema.json",
  "rules": [
    {
      "changeType": "RoomCleared",
      "isPermanentDefault": false,
      "defaultExpirationMinutes": 30,
      "respawnEligible": true,
      "description": "Cleared rooms can respawn enemies after expiration"
    },
    {
      "changeType": "ChestLooted",
      "isPermanentDefault": true,
      "defaultExpirationMinutes": null,
      "respawnEligible": false,
      "description": "Looted chests remain empty permanently"
    },
    {
      "changeType": "PuzzleSolved",
      "isPermanentDefault": true,
      "defaultExpirationMinutes": null,
      "respawnEligible": false,
      "description": "Solved puzzles stay solved permanently"
    },
    {
      "changeType": "BarrierDestroyed",
      "isPermanentDefault": true,
      "defaultExpirationMinutes": null,
      "respawnEligible": false,
      "description": "Destroyed barriers remain destroyed permanently"
    },
    {
      "changeType": "SecretDiscovered",
      "isPermanentDefault": true,
      "defaultExpirationMinutes": null,
      "respawnEligible": false,
      "description": "Discovered secrets stay revealed permanently"
    },
    {
      "changeType": "TrapDisarmed",
      "isPermanentDefault": true,
      "defaultExpirationMinutes": null,
      "respawnEligible": false,
      "description": "Disarmed traps stay disarmed permanently"
    }
  ]
}
```

### 11.2 JSON Schema

**File:** `config/schemas/persistence-rules-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "persistence-rules-schema.json",
  "title": "Persistence Rules Configuration",
  "description": "Schema for persistent world state rules",
  "type": "object",
  "required": ["rules"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "rules": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/persistenceRule"
      }
    }
  },
  "$defs": {
    "persistenceRule": {
      "type": "object",
      "required": ["changeType", "isPermanentDefault", "description"],
      "properties": {
        "changeType": {
          "type": "string",
          "enum": [
            "RoomCleared",
            "ChestLooted",
            "PuzzleSolved",
            "BarrierDestroyed",
            "SecretDiscovered",
            "TrapDisarmed"
          ],
          "description": "The type of change this rule applies to"
        },
        "isPermanentDefault": {
          "type": "boolean",
          "description": "Whether changes of this type are permanent by default"
        },
        "defaultExpirationMinutes": {
          "type": ["integer", "null"],
          "minimum": 0,
          "description": "Minutes until non-permanent changes expire (null for permanent)"
        },
        "respawnEligible": {
          "type": "boolean",
          "default": false,
          "description": "Whether this change type is eligible for respawn mechanics"
        },
        "description": {
          "type": "string",
          "minLength": 1,
          "description": "Human-readable description of this rule"
        }
      }
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `WorldStateService` | Information | Room cleared, change recorded, cleanup completed |
| `WorldStateService` | Debug | Room visited, state created, exhausted check |
| `WorldStateService` | Warning | Missing persistence rule, invalid state transition |
| `RoomState` | Debug | State transitions, change additions/removals |

### 12.2 Log Message Examples

```csharp
// Information
_logger.LogInformation(
    "Room {RoomId} marked as cleared (Clear #{ClearCount}, Permanent: {IsPermanent})",
    roomId, clearCount, isPermanent);

_logger.LogInformation(
    "Recorded {ChangeType} for {TargetId} in room {RoomId}",
    changeType, targetId, roomId);

_logger.LogInformation(
    "Cleaned up {TotalRemoved} expired changes across all rooms",
    totalRemoved);

// Debug
_logger.LogDebug("Created new room state for room {RoomId}", roomId);
_logger.LogDebug("Room {RoomId} marked as visited", roomId);
_logger.LogDebug(
    "Checking exhausted state for room {RoomId} (State: {State}, Changes: {ChangeCount})",
    roomId, state, changeCount);

// Warning
_logger.LogWarning(
    "No persistence rule found for {ChangeType}, using default",
    changeType);
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| RoomState entity | ~6 |
| RoomStateType transitions | ~4 |
| PersistentChange value object | ~4 |
| PersistenceRule value object | ~3 |
| WorldStateService | ~5 |
| Room integration | ~2 |
| **Total** | **~24** |

### 13.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `RoomStateTests.cs` | ~6 | Create, SetVisited, SetCleared, AddChange, HasChange, Reset |
| `RoomStateTypeTransitionTests.cs` | ~4 | State progression, valid transitions |
| `PersistentChangeTests.cs` | ~4 | Create, factory methods, IsExpired, TimeRemaining |
| `PersistenceRuleTests.cs` | ~3 | Create, Permanent, Temporary |
| `WorldStateServiceTests.cs` | ~5 | GetRoomState, SetRoomCleared, RecordChange, HasChange, CleanupExpiredChanges |
| `RoomPersistenceTests.cs` | ~2 | Room integration with persistent changes |

### 13.3 Test Categories

**RoomState Tests:**
```csharp
[Test]
public void Create_WithValidRoomId_CreatesRoomState()

[Test]
public void Create_WithEmptyRoomId_ThrowsArgumentException()

[Test]
public void SetVisited_FromPristine_TransitionsToVisited()

[Test]
public void SetCleared_IncrementsCount_AndSetsLastCleared()

[Test]
public void AddChange_PreventsDuplicates()

[Test]
public void HasChange_ReturnsFalse_WhenExpired()
```

**WorldStateService Tests:**
```csharp
[Test]
public void GetRoomState_ReturnsNewState_WhenNotExists()

[Test]
public void SetRoomCleared_RecordsChange_WithCorrectPersistence()

[Test]
public void RecordChange_UsesConfiguredRule()

[Test]
public void CleanupExpiredChanges_RemovesExpiredOnly()

[Test]
public void IsChestLooted_ReturnsTrue_AfterRecordingChange()
```

---

## 14. Use Cases

### UC-001: Clear Room of Enemies

**Actor:** Player
**Flow:** Player defeats all enemies → CombatService calls WorldStateService.SetRoomCleared(roomId) → Room state transitions to Cleared → LastCleared timestamp set → Clear count incremented → PersistentChange recorded

### UC-002: Loot Chest

**Actor:** Player
**Flow:** Player attempts to open chest → LootService checks WorldStateService.IsChestLooted() → If not looted: generate loot, record change → If looted: show "already empty" message

### UC-003: Return to Cleared Room

**Actor:** Player
**Flow:** Player enters previously cleared room → WorldStateService.GetRoomState() returns Cleared state → Room displays cleared description → No enemies spawn (if within respawn window)

### UC-004: Solve Puzzle

**Actor:** Player
**Flow:** Player solves puzzle → PuzzleService records WorldStateService.RecordChange(PuzzleSolved) → Puzzle remains solved on future visits

### UC-005: Destroy Barrier

**Actor:** Player
**Flow:** Player destroys barrier → WorldStateService.RecordChange(BarrierDestroyed) → Barrier remains destroyed permanently → Path stays open

### UC-006: Check Room State

**Actor:** System (Map Display)
**Flow:** Map requests room states → WorldStateService.GetRoomState() for each room → Returns state type (Pristine/Visited/Cleared/etc.) → Map displays appropriate icons

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `RoomState.cs` created
- [ ] `RoomStateType.cs` created
- [ ] `ChangeType.cs` created
- [ ] `PersistentChange.cs` created
- [ ] `PersistenceRule.cs` created
- [ ] `Room.cs` updated with persistence properties

### Application Layer
- [ ] `IWorldStateService.cs` created
- [ ] `WorldStateService.cs` created

### Infrastructure Layer
- [ ] `IConfigurationProvider.cs` updated with GetPersistenceRules()
- [ ] `JsonConfigurationProvider.cs` updated to load persistence rules

### Configuration Files
- [ ] `config/persistence-rules.json` created with 6 rule definitions
- [ ] `config/schemas/persistence-rules-schema.json` created

### Testing
- [ ] `RoomStateTests.cs` created (~6 tests)
- [ ] `RoomStateTypeTransitionTests.cs` created (~4 tests)
- [ ] `PersistentChangeTests.cs` created (~4 tests)
- [ ] `PersistenceRuleTests.cs` created (~3 tests)
- [ ] `WorldStateServiceTests.cs` created (~5 tests)
- [ ] `RoomPersistenceTests.cs` created (~2 tests)
- [ ] All ~24 tests passing

### Documentation
- [ ] XML documentation on all public members
- [ ] Code follows .editorconfig conventions

---

## 16. Acceptance Criteria

### Functional

- [ ] RoomState entity tracks room state progression (Pristine → Visited → Cleared → Exhausted)
- [ ] PersistentChange records individual changes with timestamps
- [ ] WorldStateService provides CRUD operations for room states
- [ ] WorldStateService.SetRoomCleared records change and updates timestamps
- [ ] WorldStateService.IsChestLooted returns true for previously looted chests
- [ ] WorldStateService.IsPuzzleSolved returns true for previously solved puzzles
- [ ] WorldStateService.IsBarrierDestroyed returns true for previously destroyed barriers
- [ ] Persistence rules load from JSON configuration
- [ ] Non-permanent changes expire after configured duration
- [ ] CleanupExpiredChanges removes expired changes correctly
- [ ] Room entity stores LastCleared, LastVisited, and ClearCount

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~24 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on public members
- [ ] Code follows .editorconfig conventions
- [ ] No hardcoded persistence durations outside configuration

---

## 17. Dependencies

### 17.1 Prerequisites (v0.1.3d)

| Component | Purpose for v0.1.4a |
|-----------|---------------------|
| `Room` entity | Base entity to extend with persistence |
| `RoomType` enum | Determines room clearing behavior |
| `IConfigurationProvider` | Pattern for loading persistence rules |
| `DungeonAge` | Context for how age affects persistence |

### 17.2 Provides to Future Phases

| Component | Used By |
|-----------|---------|
| `RoomState` | v0.1.4b (Monster Repopulation), v0.1.4c (Faction Control) |
| `WorldStateService` | All subsequent v0.1.4 phases |
| `PersistentChange` | v0.1.4b (respawn timers), v0.1.4c (territory changes) |
| `HasActiveSpawner` | v0.1.4b (spawner room detection) |
| `LastCleared` timestamp | v0.1.4b (respawn timer calculations) |
| `ClearCount` | v0.1.4b (respawn scaling) |

### 17.3 Dependency Diagram

```
v0.1.3d (Dungeon Age & Coherence)
    │
    ├── Room entity ─────────────────────────┐
    ├── RoomType enum ───────────────────────┤
    ├── IConfigurationProvider ──────────────┤
    └── DungeonAge ──────────────────────────┘
                                             │
                                             ▼
v0.1.4a (Persistent World State)
    │
    ├── RoomState ─────────────────────────────────────────────┐
    ├── WorldStateService ─────────────────────────────────────│
    ├── PersistentChange ──────────────────────────────────────│
    ├── PersistenceRule ───────────────────────────────────────┤
    └── Room.LastCleared, Room.ClearCount ─────────────────────┘
                                                               │
                                                               ▼
                                      ┌────────────────────────┴────────────────────────┐
                                      │                                                  │
                                      ▼                                                  ▼
                              v0.1.4b (Monster Repopulation)              v0.1.4c (Faction Control)
                                      │                                                  │
                                      └────────────────────────┬────────────────────────┘
                                                               │
                                                               ▼
                                                v0.1.4d (Evolution Events)
```

---

## 18. Future Considerations

### 18.1 Deferred to v0.1.4b

- **Respawn timers** - Timer-based enemy respawning using LastCleared
- **Spawner rooms** - Rooms that repopulate from spawner sources
- **Clear-all-spawners mechanics** - Permanent clearing by destroying spawn sources
- **Configurable respawn per room type** - Different respawn rules for different rooms

### 18.2 Deferred to v0.1.4c

- **FactionDefinition** - Monster group territories
- **TerritoryControl** - Faction zone ownership
- **Cross-faction conflict** - Factions fighting each other

### 18.3 Deferred to v0.1.4d

- **WorldEvent** - Scheduled world changes
- **EnvironmentalEvidence** - Battle sites, time-based decay
- **Dungeon evolution** - Cave-ins, migrations, seasonal effects

### 18.4 Out of Scope (Future Versions)

- **Save/Load persistence** - Actual file persistence of world state
- **Multi-dungeon state** - Tracking state across multiple dungeons
- **Player-specific state** - Different states for different players

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
