# v0.18.3d Design Specification: ITraumaService Interface

**Version:** 0.18.3d
**Parent:** v0.18.3 (Trauma System)
**Prerequisites:** v0.18.3a (Trauma Enums & Definitions), v0.18.3b (CharacterTrauma Entity), v0.18.3c (Trauma Check System)
**Status:** Design Complete
**Estimated Unit Tests:** ~0 (Interface only)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [ITraumaService Interface](#3-itraumaservice-interface)
4. [Method Definitions](#4-method-definitions)
5. [Usage Examples](#5-usage-examples)
6. [Design Rationale](#6-design-rationale)
7. [Dependencies](#7-dependencies)
8. [Future Considerations](#8-future-considerations)

---

## 1. Executive Summary

This design specification defines the `ITraumaService` interface — the service contract for all trauma management operations.

v0.18.3d establishes the **Service Contract Layer** for Trauma by defining:

- `ITraumaService` interface with 9 methods
- Complete XML documentation for all methods
- Usage patterns and design principles

### Key Deliverables

| Category          | Items                     |
| ----------------- | ------------------------- |
| **Service Interfaces** | `ITraumaService`         |
| **Tests**         | ~0 (interface only)       |

### Service Responsibilities

The `ITraumaService` provides:

- Trauma definition lookups
- Per-character trauma querying
- Trauma acquisition logic
- Retirement condition evaluation
- Active trauma effect retrieval
- Trauma check coordination

---

## 2. Feature Overview

```
v0.18.3d Features
└── Trauma Service Contract (Application Layer Interface)
    │
    ├── Trauma Definition Queries
    │   └── GetTraumaDefinition(traumaId)
    │
    ├── Character Trauma Queries
    │   ├── GetTraumas(characterId)
    │   ├── HasTrauma(characterId, traumaId)
    │   ├── GetTraumaCount(characterId)
    │   ├── GetTraumaStackCount(characterId, traumaId)
    │   └── GetActiveEffects(characterId)
    │
    ├── Trauma Acquisition
    │   └── AcquireTrauma(characterId, traumaId, source)
    │
    ├── Retirement Management
    │   └── CheckRetirementCondition(characterId)
    │
    └── Trauma Checking
        └── PerformTraumaCheck(characterId, trigger)
```

---

## 3. ITraumaService Interface

### 3.1 Purpose

Defines the complete contract for trauma management operations in the application layer. All trauma operations flow through this service.

### 3.2 Definition

**File:** `src/Core/RuneAndRust.Application/Services/Interfaces/ITraumaService.cs`

```csharp
namespace RuneAndRust.Application.Services.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Records;

/// <summary>
/// Service for managing character traumas and trauma mechanics.
/// </summary>
/// <remarks>
/// <para>
/// The ITraumaService coordinates all trauma system operations, including:
/// - Definition lookups (trauma blueprints)
/// - Per-character trauma tracking
/// - Trauma acquisition and stacking
/// - Retirement condition evaluation
/// - Trauma effect management
/// - Trauma check mechanics
/// </para>
/// <para>
/// All trauma operations should go through this service. It coordinates
/// between domain entities, repositories, and check systems.
/// </para>
/// </remarks>
public interface ITraumaService
{
    /// <summary>
    /// Gets all traumas currently affecting a character.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Returns all CharacterTrauma instances for the given character,
    /// including inactive/managed traumas. To get only active traumas,
    /// filter by IsActive.
    /// </para>
    /// <para>
    /// Traumas are ordered by AcquiredAt (earliest first).
    /// </para>
    /// </remarks>
    /// <param name="characterId">The character to query</param>
    /// <returns>List of all traumas (empty if none)</returns>
    /// <exception cref="ArgumentException">If characterId is empty Guid</exception>
    Task<IReadOnlyList<CharacterTrauma>> GetTraumasAsync(Guid characterId);

    /// <summary>
    /// Gets the definition of a specific trauma by ID.
    /// </summary>
    /// <remarks>
    /// <para>
    /// TraumaDefinition contains all mechanical properties of the trauma,
    /// including effects, triggers, and retirement conditions.
    /// Cached after initial load from configuration.
    /// </para>
    /// </remarks>
    /// <param name="traumaId">The trauma ID (e.g., "survivors-guilt")</param>
    /// <returns>The TraumaDefinition</returns>
    /// <exception cref="ArgumentException">If traumaId is null or empty</exception>
    /// <exception cref="KeyNotFoundException">If trauma not found in definitions</exception>
    Task<TraumaDefinition> GetTraumaDefinitionAsync(string traumaId);

    /// <summary>
    /// Acquires a trauma for the character.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Handles both new acquisitions and stacking:
    /// - If character doesn't have this trauma: create new instance
    /// - If stackable and character has it: increment StackCount
    /// - If non-stackable and character has it: return failure
    /// </para>
    /// <para>
    /// Process:
    /// 1. Load TraumaDefinition
    /// 2. Check if character already has this trauma
    /// 3. Create new or increment existing
    /// 4. Trigger retirement check if applicable
    /// 5. Return result with message
    /// </para>
    /// </remarks>
    /// <param name="characterId">Character acquiring trauma</param>
    /// <param name="traumaId">Trauma to acquire (e.g., "survivors-guilt")</param>
    /// <param name="source">What caused this trauma (e.g., "AllyDeath")</param>
    /// <returns>Result of acquisition attempt</returns>
    /// <exception cref="ArgumentException">If any parameter is invalid</exception>
    /// <exception cref="KeyNotFoundException">If trauma or character not found</exception>
    Task<TraumaAcquisitionResult> AcquireTraumaAsync(
        Guid characterId,
        string traumaId,
        string source);

    /// <summary>
    /// Checks whether a character has a specific trauma.
    /// </summary>
    /// <remarks>
    /// Checks only for active traumas by default. Ignores managed/suppressed traumas.
    /// </remarks>
    /// <param name="characterId">Character to check</param>
    /// <param name="traumaId">Trauma ID to look for</param>
    /// <returns>True if character has this trauma (and it's active), false otherwise</returns>
    /// <exception cref="ArgumentException">If parameters are invalid</exception>
    Task<bool> HasTraumaAsync(Guid characterId, string traumaId);

    /// <summary>
    /// Gets the total number of active traumas a character has.
    /// </summary>
    /// <remarks>
    /// Counts only active traumas. Managed/suppressed traumas are not counted.
    /// </remarks>
    /// <param name="characterId">Character to check</param>
    /// <returns>Count of active traumas (0 if none)</returns>
    /// <exception cref="ArgumentException">If characterId is invalid</exception>
    Task<int> GetTraumaCountAsync(Guid characterId);

    /// <summary>
    /// Gets the stack count for a specific trauma on a character.
    /// </summary>
    /// <remarks>
    /// <para>
    /// For stackable traumas: returns how many times acquired
    /// For non-stackable traumas: returns 0 or 1
    /// </para>
    /// </remarks>
    /// <param name="characterId">Character to check</param>
    /// <param name="traumaId">Trauma ID</param>
    /// <returns>Stack count (0 if character doesn't have this trauma)</returns>
    /// <exception cref="ArgumentException">If parameters are invalid</exception>
    Task<int> GetTraumaStackCountAsync(Guid characterId, string traumaId);

    /// <summary>
    /// Evaluates whether a character must retire due to trauma.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Checks all retirement conditions:
    /// - Immediate traumas (Survivor's Guilt, Machine Affinity, etc.)
    /// - Stacking traumas (Reality Doubt 5+, Hollow Resonance 3+)
    /// - Accumulation (3+ different moderate traumas)
    /// </para>
    /// <para>
    /// Returns RetirementCheckResult with:
    /// - MustRetire: true if forced to retire
    /// - CanContinueWithPermission: true if optional retirement
    /// - TraumasCausingRetirement: which traumas triggered it
    /// </para>
    /// </remarks>
    /// <param name="characterId">Character to evaluate</param>
    /// <returns>Complete retirement evaluation result</returns>
    /// <exception cref="ArgumentException">If characterId is invalid</exception>
    Task<RetirementCheckResult> CheckRetirementConditionAsync(Guid characterId);

    /// <summary>
    /// Gets all active mechanical effects from the character's traumas.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Returns flattened list of all TraumaEffect objects from all active traumas.
    /// Does not include effects from managed/suppressed traumas.
    /// </para>
    /// <para>
    /// Application layer uses this to apply modifiers to checks, rolls, etc.
    /// </para>
    /// </remarks>
    /// <param name="characterId">Character to query</param>
    /// <returns>List of active effects (empty if none)</returns>
    /// <exception cref="ArgumentException">If characterId is invalid</exception>
    Task<IReadOnlyList<TraumaEffect>> GetActiveEffectsAsync(Guid characterId);

    /// <summary>
    /// Performs a trauma check and acquires trauma on failure.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Full trauma check flow:
    /// 1. Check if character should have this check type
    /// 2. Get base RESOLVE dice pool
    /// 3. Apply corruption penalty
    /// 4. Roll dice using IDiceService
    /// 5. Count successes
    /// 6. If failed: acquire random trauma from category
    /// 7. Return complete result
    /// </para>
    /// <para>
    /// This method combines ITraumaCheckService logic with trauma acquisition.
    /// </para>
    /// </remarks>
    /// <param name="characterId">Character making the check</param>
    /// <param name="trigger">Type of trauma-inducing event</param>
    /// <returns>Check result with outcome</returns>
    /// <exception cref="ArgumentException">If parameters are invalid</exception>
    Task<TraumaCheckResult> PerformTraumaCheckAsync(
        Guid characterId,
        TraumaCheckTrigger trigger);
}
```

---

## 4. Method Definitions

### 4.1 Query Methods

#### GetTraumasAsync

```csharp
/// <summary>
/// Gets all traumas currently affecting a character.
/// </summary>
Task<IReadOnlyList<CharacterTrauma>> GetTraumasAsync(Guid characterId);
```

**Purpose:** Retrieve all trauma instances for a character, used for UI display and effect application.

**Returns:**
- Empty list if character has no traumas
- All traumas including managed ones
- Ordered by acquisition date (earliest first)

**Usage:**
```csharp
var traumas = await _traumaService.GetTraumasAsync(characterId);
var activeTraumas = traumas.Where(t => t.IsActive).ToList();
```

---

#### GetTraumaDefinitionAsync

```csharp
/// <summary>
/// Gets the definition of a specific trauma by ID.
/// </summary>
Task<TraumaDefinition> GetTraumaDefinitionAsync(string traumaId);
```

**Purpose:** Load trauma blueprint for mechanics, display, and effect application.

**Returns:**
- Complete TraumaDefinition with effects, triggers, retirement conditions
- Cached after initial load (minimizes config file reads)

**Usage:**
```csharp
var definition = await _traumaService.GetTraumaDefinitionAsync("survivors-guilt");
var effects = definition.Effects;
var isRetirement = definition.IsRetirementTrauma;
```

---

#### HasTraumaAsync

```csharp
/// <summary>
/// Checks whether a character has a specific trauma.
/// </summary>
Task<bool> HasTraumaAsync(Guid characterId, string traumaId);
```

**Purpose:** Quick check for trauma existence, used in event systems and conditionals.

**Returns:**
- True if character has this trauma and it's active
- False if character doesn't have it or it's managed/suppressed

**Usage:**
```csharp
if (await _traumaService.HasTraumaAsync(characterId, "machine-affinity"))
{
    // Apply special mechanics
}
```

---

#### GetTraumaCountAsync

```csharp
/// <summary>
/// Gets the total number of active traumas a character has.
/// </summary>
Task<int> GetTraumaCountAsync(Guid characterId);
```

**Purpose:** Count active traumas for UI display and narrative effects.

**Returns:**
- Integer count of active traumas
- 0 if character has no active traumas

**Usage:**
```csharp
int traumaCount = await _traumaService.GetTraumaCountAsync(characterId);
if (traumaCount >= 3)
{
    // Apply "Heavily Traumatized" debuff
}
```

---

#### GetTraumaStackCountAsync

```csharp
/// <summary>
/// Gets the stack count for a specific trauma on a character.
/// </summary>
Task<int> GetTraumaStackCountAsync(Guid characterId, string traumaId);
```

**Purpose:** Determine trauma intensity for effect scaling or retirement checks.

**Returns:**
- Stack count if character has trauma (1+)
- 0 if character doesn't have this trauma

**Usage:**
```csharp
int realityDoubtStack = await _traumaService.GetTraumaStackCountAsync(
    characterId, "reality-doubt"
);
if (realityDoubtStack >= 5)
{
    // Trigger retirement check
}
```

---

#### GetActiveEffectsAsync

```csharp
/// <summary>
/// Gets all active mechanical effects from the character's traumas.
/// </summary>
Task<IReadOnlyList<TraumaEffect>> GetActiveEffectsAsync(Guid characterId);
```

**Purpose:** Aggregate all trauma effects for modifier application.

**Returns:**
- Flattened list of all TraumaEffect objects from active traumas
- Empty list if no active traumas

**Usage:**
```csharp
var traumaEffects = await _traumaService.GetActiveEffectsAsync(characterId);
var socialPenalties = traumaEffects
    .Where(e => e.Target == "social-skills" && e.EffectType == "Penalty")
    .Sum(e => e.Value ?? 0);
```

---

### 4.2 Mutation Methods

#### AcquireTraumaAsync

```csharp
/// <summary>
/// Acquires a trauma for the character.
/// </summary>
Task<TraumaAcquisitionResult> AcquireTraumaAsync(
    Guid characterId,
    string traumaId,
    string source);
```

**Purpose:** Create or stack trauma on character, trigger retirement checks.

**Process:**
1. Load TraumaDefinition
2. Check if character already has this trauma
3. Create new CharacterTrauma or increment StackCount
4. Persist to database
5. Check retirement conditions if needed
6. Return detailed result

**Returns:**
- `TraumaAcquisitionResult.CreateNew()` for first acquisition
- `TraumaAcquisitionResult.CreateStacked()` for stacking
- `TraumaAcquisitionResult.CreateFailure()` if non-stackable and already has

**Usage:**
```csharp
var result = await _traumaService.AcquireTraumaAsync(
    characterId: characterId,
    traumaId: "survivors-guilt",
    source: "AllyDeath"
);

if (result.Success)
{
    _logger.LogInformation(result.Message);
    if (result.TriggersRetirementCheck)
    {
        var retirementResult = await _traumaService.CheckRetirementConditionAsync(characterId);
        // Handle retirement
    }
}
```

---

#### CheckRetirementConditionAsync

```csharp
/// <summary>
/// Evaluates whether a character must retire due to trauma.
/// </summary>
Task<RetirementCheckResult> CheckRetirementConditionAsync(Guid characterId);
```

**Purpose:** Determine if character must retire based on trauma accumulation.

**Evaluates:**
- Immediate retirement traumas
- Stacking trauma thresholds
- Accumulation conditions

**Returns:**
- `RetirementCheckResult.CreateMustRetire()` if mandatory
- `RetirementCheckResult.CreateOptional()` if player choice
- `RetirementCheckResult.CreateNoRetirement()` if no conditions met

**Usage:**
```csharp
var retirementCheck = await _traumaService.CheckRetirementConditionAsync(characterId);

if (retirementCheck.MustRetire)
{
    _logger.LogError($"Character must retire: {retirementCheck.RetirementReason}");
    // Initiate character loss procedures
}
else if (retirementCheck.CanContinueWithPermission)
{
    // Offer player optional retirement
}
```

---

### 4.3 Check Methods

#### PerformTraumaCheckAsync

```csharp
/// <summary>
/// Performs a trauma check and acquires trauma on failure.
/// </summary>
Task<TraumaCheckResult> PerformTraumaCheckAsync(
    Guid characterId,
    TraumaCheckTrigger trigger);
```

**Purpose:** Complete trauma check flow (roll + acquire on failure).

**Process:**
1. Call ITraumaCheckService.PerformTraumaCheckAsync()
2. If failed: acquire random trauma from category
3. Trigger retirement check if needed
4. Return complete result

**Returns:**
- `TraumaCheckResult` with full roll information
- TraumaAcquired field populated if failed
- Passed field indicates success/failure

**Usage:**
```csharp
var checkResult = await _traumaService.PerformTraumaCheckAsync(
    characterId: characterId,
    trigger: TraumaCheckTrigger.AllyDeath
);

if (!checkResult.Passed)
{
    _logger.LogWarning(
        $"Character acquired {checkResult.TraumaAcquired}: " +
        $"{checkResult.SuccessesAchieved}/{checkResult.SuccessesNeeded} successes"
    );
}
```

---

## 5. Usage Examples

### 5.1 Checking for Trauma Existence

```csharp
// Example: Apply modifier if character has specific trauma
var hasParanoia = await _traumaService.HasTraumaAsync(
    characterId,
    "paranoid-ideation"
);

if (hasParanoia)
{
    roll.ApplyPenalty(-2, "Paranoid");
}
```

### 5.2 Applying Trauma Effects to Rolls

```csharp
// Example: Get all social skill penalties from traumas
var traumaEffects = await _traumaService.GetActiveEffectsAsync(characterId);
var socialPenalties = traumaEffects
    .Where(e => e.Target == "social-skills" && e.EffectType == "Penalty")
    .Sum(e => e.Value ?? 0);

if (socialPenalties < 0)
{
    roll.ApplyPenalty(socialPenalties, "Trauma Effects");
}
```

### 5.3 Acquiring Trauma from Event

```csharp
// Example: Character witness traumatic event
if (witnessingHorror)
{
    var acquisitionResult = await _traumaService.AcquireTraumaAsync(
        characterId: character.Id,
        traumaId: "combat-flashbacks",
        source: "WitnessingHorror"
    );

    if (acquisitionResult.TriggersRetirementCheck)
    {
        var retirementCheck = await _traumaService.CheckRetirementConditionAsync(
            character.Id
        );

        if (retirementCheck.MustRetire)
        {
            await _characterService.RetireCharacterAsync(
                character.Id,
                retirementCheck.RetirementReason
            );
        }
    }
}
```

### 5.4 Performing Trauma Check (with Acquisition)

```csharp
// Example: Ally dies, trigger trauma check
var checkResult = await _traumaService.PerformTraumaCheckAsync(
    characterId: character.Id,
    trigger: TraumaCheckTrigger.AllyDeath
);

var message = checkResult.Passed
    ? $"Avoided trauma! ({checkResult.SuccessesAchieved}/{checkResult.SuccessesNeeded})"
    : $"Acquired {checkResult.TraumaAcquired} from {checkResult.Trigger}";

_gameRenderer.RenderMessage(message);
```

### 5.5 Retirement Check Flow

```csharp
// Example: After trauma acquisition, check if character must retire
var retirementResult = await _traumaService.CheckRetirementConditionAsync(
    character.Id
);

if (retirementResult.MustRetire)
{
    _gameRenderer.RenderError(
        $"RETIREMENT FORCED: {retirementResult.RetirementReason}"
    );

    foreach (var traumaId in retirementResult.TraumasCausingRetirement)
    {
        var definition = await _traumaService.GetTraumaDefinitionAsync(traumaId);
        _gameRenderer.RenderMessage($"• {definition.Name}");
    }

    // Retire character
    await _characterService.RetireCharacterAsync(character.Id, retirementResult.RetirementReason);
}
else if (retirementResult.CanContinueWithPermission)
{
    _gameRenderer.RenderWarning(
        $"Optional Retirement: Character has {retirementResult.TotalRetirementTraumas} severe traumas. " +
        "Player may choose to retire this character."
    );
}
```

---

## 6. Design Rationale

### 6.1 Single Service Interface

**Design:** All trauma operations through single `ITraumaService`

**Rationale:**
- Cohesion: Trauma is a unified domain concern
- Consistency: All trauma state changes go through one entry point
- Logging: Easy to add cross-cutting concerns
- Testing: Single mock for trauma operations

**Alternative Rejected:** Separate services for queries, acquisitions, and checks
- Would lead to circular dependencies
- Forces clients to coordinate between services
- Harder to maintain transactional consistency

### 6.2 Async/Await Pattern

**Design:** All methods are async (Task-based)

**Rationale:**
- Database operations (querying, persistence)
- Dice service calls (RNG from infrastructure)
- Future: potential for distributed caching
- Consistent with application layer patterns

### 6.3 Rich Return Types

**Design:** Returns domain records (`TraumaAcquisitionResult`, `RetirementCheckResult`)

**Rationale:**
- Encapsulates related data
- Immutable (records prevent accidental mutations)
- Type-safe over boolean returns
- Includes explanatory messages for UI display

**Example:** Instead of returning `bool` for acquisition, return `TraumaAcquisitionResult` with:
- Success flag
- IsNewTrauma vs stacked
- Message for player
- Retirement trigger flag

### 6.4 Separation of Concerns

**Design:** Interface only, implementation in v0.18.3e

**Rationale:**
- Allows multiple implementations (testing, different persistence strategies)
- Defines contract before implementation
- No implementation details leak into domain layer
- Supports dependency injection

---

## 7. Dependencies

### 7.1 Required Prerequisites

| Dependency                | Version | Usage                            |
| ------------------------- | ------- | -------------------------------- |
| Trauma Enums & Definitions | v0.18.3a | TraumaType, TraumaDefinition    |
| CharacterTrauma Entity    | v0.18.3b | CharacterTrauma in queries       |
| Trauma Check System       | v0.18.3c | TraumaCheckTrigger, TraumaCheckResult |
| ITraumaCheckService       | v0.18.3c | Dependency for check coordination |

### 7.2 Consumed by v0.18.3e

| Type | Usage |
| --- | --- |
| `ITraumaService` | Implemented by TraumaService |
| All methods | Called by TraumaService |

### 7.3 Consumed by Application/UI Layer

| Consumer | Methods |
| --- | --- |
| Combat System | PerformTraumaCheckAsync, GetActiveEffectsAsync |
| Character UI | GetTraumasAsync, GetTraumaCountAsync |
| Rest System | PerformTraumaCheckAsync |
| Event Systems | AcquireTraumaAsync, CheckRetirementConditionAsync |

---

## 8. Future Considerations

### 8.1 v0.18.3e (TraumaService & Config)

- Full implementation with database persistence
- Configuration loading from traumas.json
- Integration with ITraumaCheckService
- Caching of TraumaDefinitions

### 8.2 v0.18.5 (Trauma Integration)

- Integration with combat event system
- Integration with rest mechanics
- Trauma check triggering on specific game events
- Trauma effect application to character rolls

### 8.3 v0.22.x (Trauma Therapy)

- Therapy and recovery service
- Methods for managing/suppressing traumas
- Recovery progress tracking
- Interaction with ManagedSince timestamp

### 8.4 Future Enhancements

- Modifier system (traits affecting checks)
- Weighted random trauma selection
- Custom check logic per trauma type
- Trauma interaction matrix (triggering other checks)
- Streaming checks (multiple checks on single event)

---

## Interface Definition Summary

```csharp
public interface ITraumaService
{
    // Query Methods
    Task<IReadOnlyList<CharacterTrauma>> GetTraumasAsync(Guid characterId);
    Task<TraumaDefinition> GetTraumaDefinitionAsync(string traumaId);
    Task<bool> HasTraumaAsync(Guid characterId, string traumaId);
    Task<int> GetTraumaCountAsync(Guid characterId);
    Task<int> GetTraumaStackCountAsync(Guid characterId, string traumaId);
    Task<IReadOnlyList<TraumaEffect>> GetActiveEffectsAsync(Guid characterId);

    // Mutation Methods
    Task<TraumaAcquisitionResult> AcquireTraumaAsync(Guid characterId, string traumaId, string source);
    Task<RetirementCheckResult> CheckRetirementConditionAsync(Guid characterId);

    // Check Methods
    Task<TraumaCheckResult> PerformTraumaCheckAsync(Guid characterId, TraumaCheckTrigger trigger);
}
```

---

*This design specification provides the service contract for all trauma system operations. The interface serves as the boundary between the application layer and domain logic.*

---

## Changelog

| Version | Date       | Changes                        |
| ------- | ---------- | ------------------------------ |
| 1.0     | 2026-01-28 | Initial design specification   |
