> **Archived** - This changelog has been consolidated. See the complete version at [v0.1.3](../v0.1.x/v0.1.3.md).

# Changelog: v0.1.3c - The Journal UI (Terminal Interface)

**Release Date:** 2025-12-19

---

## Summary

Version 0.1.3c completes the **Codex Milestone (v0.1.3)** by implementing the terminal-based Journal UI for viewing discovered lore. Building on v0.1.3a's data foundation and v0.1.3b's capture generation logic, this release adds three new commands (`journal`, `codex <name>`, `fragments`) that render formatted Codex entries with progressive text redaction based on completion percentage. The implementation features a standalone `TextRedactor` service using stable pseudo-random word masking with prime-number-based indexing to ensure consistent redaction patterns at each completion level. The `JournalService` formats output with Spectre.Console markup, groups entries by category, displays completion percentages with visual indicators (★ for complete, ● for incomplete), and reveals unlocked threshold tags (e.g., "Weakness Revealed"). CommandParser was refactored to async to support journal queries, requiring cascading changes to GameService and all command parser tests. The system includes 26 new unit tests with 100% pass rate across the full 1,141-test suite.

---

## New Files Created

### Core Layer - Interfaces

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IJournalService.cs` | Service contract for Scavenger's Journal display formatting with three formatting methods |

### Engine Layer - Services

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/JournalService.cs` | Implementation of journal list, entry detail, and unassigned fragment views with Spectre.Console markup |
| `RuneAndRust.Engine/Services/TextRedactor.cs` | Standalone text masking service using stable pseudo-random word-level redaction based on completion percentage |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/JournalServiceTests.cs` | 14 unit tests for journal formatting, entry detail views, and fragment lists |
| `RuneAndRust.Tests/Engine/TextRedactorTests.cs` | 12 unit tests for text masking edge cases, stability, and progressive reveal behavior |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Interfaces/IDataCaptureRepository.cs` | Added `GetDiscoveredEntryIdsAsync(Guid characterId)` method to retrieve distinct entry IDs with at least one fragment |
| `RuneAndRust.Persistence/Repositories/DataCaptureRepository.cs` | Implemented `GetDiscoveredEntryIdsAsync` with LINQ `Distinct()` query and DEBUG logging |
| `RuneAndRust.Core/Interfaces/IDataCaptureService.cs` | Added `GetDiscoveredEntriesAsync(Guid characterId)` method returning `ValueTuple<CodexEntry, int>` collection |
| `RuneAndRust.Engine/Services/DataCaptureService.cs` | Implemented `GetDiscoveredEntriesAsync` by iterating entry IDs and assembling tuples with completion percentages |
| `RuneAndRust.Core/Interfaces/IGameService.cs` | Changed `Start()` to `Task StartAsync()` for async command support |
| `RuneAndRust.Engine/Services/GameService.cs` | Refactored `Start()` to `async Task StartAsync()` with `await` on parser calls |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Made `ParseAndExecute` fully async (`Task<ParseResult> ParseAndExecuteAsync`); added optional `IJournalService` constructor parameter; added `journal`, `codex <name>`, and `fragments` commands with async execution; updated help text |
| `RuneAndRust.Terminal/Program.cs` | Registered `IJournalService` in DI container; updated GameService call to `StartAsync().GetAwaiter().GetResult()` |
| `RuneAndRust.Tests/Engine/CommandParserTests.cs` | Updated all 48 tests to call `ParseAndExecuteAsync` and `await` results |
| `RuneAndRust.Tests/Engine/GameLoopTests.cs` | Updated tests to await `StartAsync()` calls |
| `RuneAndRust.Tests/Engine/GameServiceTests.cs` | Updated tests to use async patterns with `StartAsync()` |

---

## Code Implementation Details

### IJournalService Interface

```csharp
public interface IJournalService
{
    Task<string> FormatJournalListAsync(Guid characterId);
    Task<string> FormatEntryDetailAsync(Guid characterId, string entryTitle);
    Task<string> FormatUnassignedCapturesAsync(Guid characterId);
}
```

**Key Methods:**
- `FormatJournalListAsync`: Returns grouped journal view with category headers, completion percentages, and status icons
- `FormatEntryDetailAsync`: Returns single entry detail with redacted text, metadata, and unlocked threshold tags
- `FormatUnassignedCapturesAsync`: Returns list of unmatched fragments with truncated content preview

### TextRedactor Service

```csharp
public class TextRedactor
{
    private const string RedactedBlock = "[grey]████[/]";
    private const string FullyRedactedMessage = "[REDACTED]";

    public string RedactText(string fullText, int completionPct)
    {
        // Handle edge cases
        if (completionPct >= 100) return fullText;
        if (completionPct <= 0) return FullyRedactedMessage;
        if (string.IsNullOrWhiteSpace(fullText)) return fullText;

        var words = fullText.Split(' ');
        var result = new StringBuilder();

        for (int i = 0; i < words.Length; i++)
        {
            // Stable pseudo-random based on word index
            // Formula: ((i * 7 + 13) % 100) < completionPct
            // Primes 7 and 13 reduce visible patterns
            bool visible = ((i * 7 + 13) % 100) < completionPct;

            result.Append(visible ? words[i] : RedactedBlock);
            if (i < words.Length - 1) result.Append(' ');
        }

        return result.ToString();
    }
}
```

**Algorithm Behaviors:**
- Uses word-level masking (not character-level) for readability
- Pseudo-random visibility based on `(index * 7 + 13) % 100 < completionPct`
- Multiplier 7 and offset 13 are primes to reduce repeating patterns
- Same text at same completion percentage always produces identical output
- No internal state; thread-safe and deterministic

### JournalService Key Methods

**FormatJournalListAsync:**
```csharp
public async Task<string> FormatJournalListAsync(Guid characterId)
{
    var entries = await _captureService.GetDiscoveredEntriesAsync(characterId);
    var grouped = entries.GroupBy(e => e.Entry.Category).OrderBy(g => g.Key);

    foreach (var group in grouped)
    {
        sb.AppendLine($"[cyan]── {group.Key} ──[/]");
        foreach (var (entry, pct) in group.OrderBy(e => e.Entry.Title))
        {
            var statusIcon = pct >= 100 ? "[green]★[/]" : "[grey]●[/]";
            var pctColor = pct >= 100 ? "green" : pct >= 50 ? "yellow" : "grey";
            sb.AppendLine($"  {statusIcon} {entry.Title} [{pctColor}]({pct}%)[/]");
        }
    }
}
```

**Behaviors:**
- Groups entries by `CodexCategory` enum value
- Sorts entries alphabetically within each category
- Uses green star (★) for 100% completion, grey circle (●) for incomplete
- Color-codes percentages: green (100%), yellow (50-99%), grey (0-49%)

**FormatEntryDetailAsync:**
```csharp
public async Task<string> FormatEntryDetailAsync(Guid characterId, string entryTitle)
{
    var entry = await _codexRepository.GetByTitleAsync(entryTitle);
    if (entry == null) return $"[red]No entry found matching '{entryTitle}'.[/]";

    var pct = await _captureService.GetCompletionPercentageAsync(entry.Id, characterId);
    var thresholds = await _captureService.GetUnlockedThresholdsAsync(entry.Id, characterId);

    // Redact text based on completion
    var displayText = _redactor.RedactText(entry.FullText, pct);

    // Show unlocked threshold tags
    if (thresholds.Any())
    {
        foreach (var tag in thresholds)
        {
            sb.AppendLine($"  [green]✓[/] {FormatTag(tag)}");  // WEAKNESS_REVEALED → Weakness Revealed
        }
    }
}
```

**Behaviors:**
- Converts SCREAMING_SNAKE_CASE threshold tags to Title Case (e.g., `WEAKNESS_REVEALED` → "Weakness Revealed")
- Displays entry title in uppercase with category and completion metadata
- Shows redacted text with grey blocks for unrevealed words
- Lists unlocked discoveries with green checkmarks

**FormatUnassignedCapturesAsync:**
```csharp
private static string Truncate(string text, int maxLength)
{
    if (text.Length <= maxLength) return text;
    return text[..(maxLength - 3)] + "...";
}

foreach (var capture in captureList.OrderByDescending(c => c.DiscoveredAt))
{
    sb.AppendLine($"  [cyan]{capture.Type}[/] - {capture.Source}");
    sb.AppendLine($"    \"{Truncate(capture.FragmentContent, 60)}\"");
}
```

**Behaviors:**
- Truncates fragment content to 60 characters with ellipsis
- Orders fragments by discovery date (most recent first)
- Displays capture type (e.g., "TextFragment") and source context

### CommandParser Async Refactor

**Signature Change:**
```csharp
// Before
public ParseResult ParseAndExecute(string input, GameState state)

// After
public async Task<ParseResult> ParseAndExecuteAsync(string input, GameState state)
```

**New Journal Commands:**
```csharp
case "journal":
case "j":
    if (_journalService != null && _gameState.CurrentCharacter != null)
    {
        var journalOutput = await _journalService.FormatJournalListAsync(_gameState.CurrentCharacter.Id);
        _inputHandler.DisplayMessage(journalOutput);
    }
    return ParseResult.None;

case "fragments":
    var fragmentsOutput = await _journalService.FormatUnassignedCapturesAsync(_gameState.CurrentCharacter.Id);
    _inputHandler.DisplayMessage(fragmentsOutput);
    return ParseResult.None;

// codex <name> command
if (command.StartsWith("codex "))
{
    var entryName = command.Substring(6).Trim();
    var codexOutput = await _journalService.FormatEntryDetailAsync(_gameState.CurrentCharacter.Id, entryName);
    _inputHandler.DisplayMessage(codexOutput);
    return ParseResult.None;
}
```

**Help Text Additions:**
```
Journal:
  journal, j       - Open the Scavenger's Journal
  codex <name>     - View a specific journal entry
  fragments        - View unassigned knowledge fragments
```

### DataCaptureService.GetDiscoveredEntriesAsync

```csharp
public async Task<IEnumerable<(CodexEntry Entry, int CompletionPercent)>> GetDiscoveredEntriesAsync(Guid characterId)
{
    var entryIds = await _captureRepository.GetDiscoveredEntryIdsAsync(characterId);
    var results = new List<(CodexEntry, int)>();

    foreach (var entryId in entryIds)
    {
        var entry = await _codexRepository.GetByIdAsync(entryId);
        if (entry != null)
        {
            var pct = await GetCompletionPercentageAsync(entryId, characterId);
            results.Add((entry, pct));
        }
    }

    return results;
}
```

**Behaviors:**
- Returns `ValueTuple<CodexEntry, int>` for efficient paired data without creating a dedicated DTO
- Filters out entries where `GetByIdAsync` returns null (defensive programming)
- Logs warnings if discovered entry IDs don't resolve to valid entries

### DataCaptureRepository.GetDiscoveredEntryIdsAsync

```csharp
public async Task<IEnumerable<Guid>> GetDiscoveredEntryIdsAsync(Guid characterId)
{
    var entryIds = await _dbSet
        .Where(d => d.CharacterId == characterId && d.CodexEntryId != null)
        .Select(d => d.CodexEntryId!.Value)
        .Distinct()
        .ToListAsync();

    return entryIds;
}
```

**Behaviors:**
- Filters for captures with non-null `CodexEntryId` (excludes unassigned fragments)
- Uses `Distinct()` to ensure unique entry IDs
- Null-forgiving operator `!.Value` justified by preceding null check in LINQ `Where` clause

### GameService Async Refactor

```csharp
public async Task StartAsync()
{
    _logger.LogInformation("Game Loop Initialized.");

    while (_state.Phase != GamePhase.Quit)
    {
        string prompt = GetPhasePrompt();
        string input = _inputHandler.GetInput(prompt);
        await _parser.ParseAndExecuteAsync(input, _state);  // Now async
    }

    _logger.LogInformation("Game Loop Ended. Shutting down.");
}
```

**Behavioral Change:**
- Game loop now awaits command parsing to support async journal queries
- No other logic changes; purely async/await refactor

---

## Logging Matrix

### JournalService

| Method | Level | Template |
|--------|-------|----------|
| FormatJournalListAsync | Debug | `"Formatting journal list for Character {CharacterId}"` |
| FormatJournalListAsync | Debug | `"No discovered entries for Character {CharacterId}"` |
| FormatJournalListAsync | Trace | `"Processing category {Category} with {Count} entries"` |
| FormatJournalListAsync | Debug | `"Formatted {Count} entries for journal list"` |
| FormatEntryDetailAsync | Debug | `"Formatting entry detail for '{EntryTitle}'"` |
| FormatEntryDetailAsync | Debug | `"Entry '{EntryTitle}' not found"` |
| FormatEntryDetailAsync | Trace | `"Entry {EntryTitle} has {Pct}% completion and {ThresholdCount} unlocked thresholds"` |
| FormatEntryDetailAsync | Debug | `"Formatted entry detail for '{EntryTitle}' at {Pct}%"` |
| FormatUnassignedCapturesAsync | Debug | `"Formatting unassigned captures for Character {CharacterId}"` |
| FormatUnassignedCapturesAsync | Debug | `"No unassigned captures for Character {CharacterId}"` |
| FormatUnassignedCapturesAsync | Trace | `"Formatting unassigned capture {CaptureId}: {CaptureType}"` |
| FormatUnassignedCapturesAsync | Debug | `"Formatted {Count} unassigned captures"` |

### DataCaptureRepository (New)

| Method | Level | Template |
|--------|-------|----------|
| GetDiscoveredEntryIdsAsync | Debug | `"Fetching discovered entry IDs for Character {CharacterId}"` |
| GetDiscoveredEntryIdsAsync | Debug | `"Found {Count} discovered entries for Character {CharacterId}"` |

### DataCaptureService (New)

| Method | Level | Template |
|--------|-------|----------|
| GetDiscoveredEntriesAsync | Debug | `"Fetching discovered entries for Character {CharacterId}"` |
| GetDiscoveredEntriesAsync | Trace | `"Processing discovered entry {EntryId}"` |
| GetDiscoveredEntriesAsync | Trace | `"Added entry {EntryTitle} with {Pct}% completion"` |
| GetDiscoveredEntriesAsync | Warning | `"Discovered entry {EntryId} not found in CodexRepository"` |
| GetDiscoveredEntriesAsync | Debug | `"Retrieved {Count} discovered entries for Character {CharacterId}"` |

### CommandParser (New)

| Method | Level | Template |
|--------|-------|----------|
| HandleExplorationAsync | Debug | `"Handling codex command for entry '{EntryTitle}'"` |
| HandleExplorationAsync | Debug | `"Handling journal command for Character {CharacterId}"` |
| HandleExplorationAsync | Debug | `"Handling fragments command for Character {CharacterId}"` |

**Note:** TextRedactor has no logging as it is a pure stateless utility service with no I/O or side effects.

---

## Test Coverage

### JournalServiceTests.cs (14 tests)

#### FormatJournalListAsync Tests (6)

| Test Name | Description |
|-----------|-------------|
| `FormatJournalListAsync_NoEntries_ReturnsEmptyMessage` | Returns "No discoveries recorded yet" when character has zero entries |
| `FormatJournalListAsync_WithEntries_GroupsByCategory` | Groups entries by `CodexCategory` enum and displays category headers |
| `FormatJournalListAsync_ShowsCompletionPercentage` | Displays completion percentage in format "(75%)" |
| `FormatJournalListAsync_CompletedEntry_ShowsStarIcon` | Uses green star `[green]★[/]` for 100% completion |
| `FormatJournalListAsync_IncompleteEntry_ShowsCircleIcon` | Uses grey circle `[grey]●[/]` for incomplete entries |
| `FormatJournalListAsync_ShowsUsageHint` | Includes "codex <name>" usage hint at bottom |

#### FormatEntryDetailAsync Tests (5)

| Test Name | Description |
|-----------|-------------|
| `FormatEntryDetailAsync_EntryNotFound_ReturnsError` | Returns red error message when entry title doesn't exist |
| `FormatEntryDetailAsync_IncompleteEntry_RedactsText` | Applies text redaction for entries below 100% |
| `FormatEntryDetailAsync_CompleteEntry_ShowsFullText` | Displays unredacted text for 100% completion |
| `FormatEntryDetailAsync_ShowsUnlockedThresholds` | Lists threshold tags in "Discoveries:" section with green checkmarks |
| `FormatEntryDetailAsync_ShowsCategoryAndTitle` | Displays uppercase title, category label, and completion percentage |

#### FormatUnassignedCapturesAsync Tests (3)

| Test Name | Description |
|-----------|-------------|
| `FormatUnassignedCapturesAsync_NoCaptures_ReturnsEmpty` | Returns "No unassigned fragments" when no unmatched captures exist |
| `FormatUnassignedCapturesAsync_WithCaptures_ShowsDetails` | Displays capture type, source, and fragment content |
| `FormatUnassignedCapturesAsync_TruncatesLongContent` | Truncates content to 60 characters with ellipsis |

### TextRedactorTests.cs (12 tests)

#### Edge Case Tests (5)

| Test Name | Description |
|-----------|-------------|
| `RedactText_AtZeroPercent_ReturnsRedactedMessage` | Returns "[REDACTED]" string for 0% completion |
| `RedactText_AtHundredPercent_ReturnsFullText` | Returns unmodified full text for 100% completion |
| `RedactText_EmptyString_ReturnsEmpty` | Handles empty string input without throwing |
| `RedactText_WhitespaceOnly_ReturnsWhitespace` | Preserves whitespace-only strings unchanged |
| `RedactText_NullInput_ReturnsNull` | Handles null input without throwing (returns null) |

#### Partial Redaction Tests (2)

| Test Name | Description |
|-----------|-------------|
| `RedactText_AtFiftyPercent_ReturnsMixedText` | Contains both visible words and `[grey]████[/]` blocks |
| `RedactText_ContainsRedactedBlocks_UsesGreyMarkup` | Verifies Spectre.Console grey markup in redacted portions |

#### Stability Tests (2)

| Test Name | Description |
|-----------|-------------|
| `RedactText_SamePercentage_ProducesStableOutput` | Multiple calls with same input produce identical output |
| `RedactText_DifferentInstances_ProduceSameOutput` | Different TextRedactor instances produce identical output for same input |

#### Progressive Reveal Tests (2)

| Test Name | Description |
|-----------|-------------|
| `RedactText_ProgressiveReveal_ShowsMoreWordsAtHigherPercentage` | Asserts visibleWords25 < visibleWords50 < visibleWords75 |
| `RedactText_AtVariousPercentages_ProducesValidOutput` | Theory test with 1%, 10%, 25%, 50%, 75%, 90%, 99% completion values |

#### Single Word Tests (1)

| Test Name | Description |
|-----------|-------------|
| `RedactText_SingleWord_AtFiftyPercent_ReturnsWordOrRedacted` | Single word is either fully visible or fully redacted (no partial words) |

---

## Test Summary

| Category | Count | Status |
|----------|-------|--------|
| JournalServiceTests | 14 | Passed |
| TextRedactorTests | 12 | Passed |
| **v0.1.3c New Tests** | **26** | **All Passed** |
| **Full Suite Total** | **1,141** | **All Passed** |

**Test Execution:**
```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
Passed!  - Failed: 0, Passed: 1141, Skipped: 0, Total: 1141, Duration: 414 ms
```

---

## DI Registration

**Program.cs Changes:**
```csharp
// Register Journal Services
services.AddScoped<IJournalService, JournalService>();

// GameService now calls async
var game = host.Services.GetRequiredService<IGameService>();
game.StartAsync().GetAwaiter().GetResult();
```

**Registration Details:**
- `IJournalService` registered as Scoped (requires database access per request)
- `TextRedactor` instantiated directly within `JournalService` (stateless utility, no DI needed)
- `CommandParser` receives `IJournalService` as optional constructor parameter (nullable for backward compatibility)

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Interfaces/
│   ├── IDataCaptureRepository.cs     [MODIFIED]
│   ├── IDataCaptureService.cs        [MODIFIED]
│   ├── IGameService.cs               [MODIFIED]
│   └── IJournalService.cs            [NEW]

RuneAndRust.Engine/
└── Services/
    ├── CommandParser.cs              [MODIFIED]
    ├── DataCaptureService.cs         [MODIFIED]
    ├── GameService.cs                [MODIFIED]
    ├── JournalService.cs             [NEW]
    └── TextRedactor.cs               [NEW]

RuneAndRust.Persistence/
└── Repositories/
    └── DataCaptureRepository.cs      [MODIFIED]

RuneAndRust.Terminal/
└── Program.cs                        [MODIFIED]

RuneAndRust.Tests/
└── Engine/
    ├── CommandParserTests.cs         [MODIFIED]
    ├── GameLoopTests.cs              [MODIFIED]
    ├── GameServiceTests.cs           [MODIFIED]
    ├── JournalServiceTests.cs        [NEW]
    └── TextRedactorTests.cs          [NEW]
```

---

## Technical Highlights

### Stable Pseudo-Random Redaction Algorithm

The TextRedactor uses a deterministic formula to ensure consistency:

```csharp
bool visible = ((i * 7 + 13) % 100) < completionPct;
```

**Mathematical Properties:**
- **Index-based:** Each word's visibility depends only on its position, not random state
- **Prime multipliers:** 7 and 13 are coprime to 100, reducing repeating patterns
- **Percentage-aligned:** Direct comparison to completion percentage creates intuitive reveal curve
- **Deterministic:** Same text at same completion always produces identical output

**Example Redaction Pattern at 50%:**
```
Original: "The ancient servitor stands motionless, its joints rusted and seized."
At 50%: "████ ancient ████ stands ████ its joints ████ and ████."
```

### ValueTuple Return Type Pattern

The service uses C# 7.0 ValueTuples for lightweight DTO-free data transfer:

```csharp
// Efficient paired data without creating a dedicated class
Task<IEnumerable<(CodexEntry Entry, int CompletionPercent)>> GetDiscoveredEntriesAsync(Guid characterId);

// Usage
foreach (var (entry, pct) in entries)
{
    Console.WriteLine($"{entry.Title}: {pct}%");
}
```

**Advantages over DTO class:**
- No memory allocation for wrapper objects
- Compiler-enforced destructuring
- Inline property names via tuple syntax

### Optional Service Injection for Backward Compatibility

CommandParser uses nullable injection to maintain test compatibility:

```csharp
public CommandParser(
    ILogger<CommandParser> logger,
    IInputHandler inputHandler,
    GameState gameState,
    IJournalService? journalService = null)  // Optional
{
    _journalService = journalService;
}

// Usage with null-check
if (_journalService != null && _gameState.CurrentCharacter != null)
{
    var output = await _journalService.FormatJournalListAsync(_gameState.CurrentCharacter.Id);
}
```

This pattern allows existing tests without journal infrastructure to continue passing while enabling the feature in production.

### Spectre.Console Markup for Terminal Styling

All output uses Spectre.Console markup for consistent styling:

| Markup Pattern | Purpose |
|----------------|---------|
| `[yellow]═══[/]` | Section headers and dividers |
| `[cyan]──[/]` | Category headers |
| `[green]★[/]` | Completion indicator (100%) |
| `[grey]●[/]` | Incomplete indicator (<100%) |
| `[grey]████[/]` | Redacted text blocks |
| `[red]Error[/]` | Error messages |
| `[green]✓[/]` | Unlocked threshold checkmark |

### Async/Await Cascade Pattern

The async refactor demonstrates proper async propagation:

```
Terminal Program.Main
  └─> game.StartAsync().GetAwaiter().GetResult()  // Top-level sync wrapper
      └─> GameService.StartAsync()                // Entry point
          └─> await _parser.ParseAndExecuteAsync()
              └─> await _journalService.FormatJournalListAsync()
                  └─> await _captureService.GetDiscoveredEntriesAsync()
                      └─> await _captureRepository.GetDiscoveredEntryIdsAsync()
```

**Key Decision:** Kept `Main` synchronous and used `GetAwaiter().GetResult()` to avoid top-level async, which is idiomatic for console applications in .NET Framework compatibility scenarios.

---

## Verification Results

### Build Output

```bash
$ dotnet build
Microsoft (R) Build Engine version 17.12.0+5a0b09ad4 for .NET
Build started 2025-12-19
  RuneAndRust.Core -> bin/Debug/net9.0/RuneAndRust.Core.dll
  RuneAndRust.Persistence -> bin/Debug/net9.0/RuneAndRust.Persistence.dll
  RuneAndRust.Engine -> bin/Debug/net9.0/RuneAndRust.Engine.dll
  RuneAndRust.Terminal -> bin/Debug/net9.0/RuneAndRust.Terminal.dll
  RuneAndRust.Tests -> bin/Debug/net9.0/RuneAndRust.Tests.dll

Build succeeded. 0 Error(s)
Time Elapsed 00:00:03.42
```

### Test Execution

```bash
$ dotnet test --no-build --verbosity quiet
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
VSTest version 17.12.0 (arm64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed: 0, Passed: 1141, Skipped: 0, Total: 1141, Duration: 414 ms
```

### Filtered Test Execution (New Tests Only)

```bash
$ dotnet test --filter "FullyQualifiedName~JournalService|FullyQualifiedName~TextRedactor"
Passed!  - Failed: 0, Passed: 26, Skipped: 0, Total: 26, Duration: 125 ms
```

---

## Running Tests

### Run All Tests
```bash
dotnet test
```

### Run Journal-Specific Tests
```bash
dotnet test --filter "FullyQualifiedName~JournalServiceTests"
```

### Run Redaction-Specific Tests
```bash
dotnet test --filter "FullyQualifiedName~TextRedactorTests"
```

### Run v0.1.3c Tests Only
```bash
dotnet test --filter "FullyQualifiedName~JournalService|FullyQualifiedName~TextRedactor"
```

---

## Usage Examples

### Viewing the Journal
```
[EXPLORE] journal
═══ SCAVENGER'S JOURNAL ═══

── Bestiary ──
  ● Rusted Servitor (45%)

── FieldGuide ──
  ★ Burden and Carrying Capacity (100%)
  ★ Combat Basics (100%)
  ★ Psychic Stress (100%)

Use 'codex <name>' to view entry details.
```

### Viewing a Specific Entry (Incomplete)
```
[EXPLORE] codex Rusted Servitor
═══ RUSTED SERVITOR ═══
Category: Bestiary
Completion: 45%

████ ancient ████ stands ████ its joints ████ and seized. ████ chassis shows
evidence ████ mycelial ████ growing through ████ seams.

Discoveries:
  ✓ Weakness Revealed
```

### Viewing a Specific Entry (Complete)
```
[EXPLORE] codex Combat Basics
═══ COMBAT BASICS ═══
Category: FieldGuide
Completion: 100%

Violence in the ruined world is costly. Each blow struck drains stamina, and
exhaustion leaves you vulnerable. Strike with purpose, not panic. Retreat is
not cowardice—it is survival.

Discoveries:
  ✓ Full Entry
```

### Viewing Unassigned Fragments
```
[EXPLORE] fragments
── Unassigned Fragments ──
These fragments don't match any known entries yet.

  TextFragment - Old Container
    "...inscriptions speak of a time before the Glitch, wh..."
  EchoRecording - Servitor Remains
    "...auditory trace suggests mechanical speech patterns..."
```

---

## Next Steps

**v0.1.4: Combat System Foundation**
- Implement initiative system with AGILITY-based turn order
- Create CombatEncounter entity with combatant tracking
- Implement basic attack actions (Strike, Parry, Dodge)
- Add stamina costs and exhaustion thresholds
- Create combat log formatter for turn-by-turn narrative

**v0.1.5: Item System Expansion**
- Add weapon and armor items with stat modifiers
- Implement durability and repair mechanics
- Create crafting system with recipe definitions
- Add consumable effects (healing, stat buffs)

**Future Codex Enhancements:**
- Search/filter commands (`journal search <keyword>`)
- Completion statistics page (`journal stats`)
- Export journal to markdown file for offline reading
