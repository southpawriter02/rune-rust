# v0.3.7: The Ledger (Management UI)

> **Status:** Planned
> **Milestone:** Milestone 4.5 - Interface Polish
> **Theme:** Full-screen interactive management interfaces for inventory, crafting, and journal

## Table of Contents
- [Overview](#overview)
- [Phase A: The Pack (Inventory UI)](#phase-a-the-pack-inventory-ui)
- [Phase B: The Bench (Crafting UI)](#phase-b-the-bench-crafting-ui)
- [Phase C: The Archive (Journal UI)](#phase-c-the-archive-journal-ui)
- [Testing Strategy](#testing-strategy)
- [Changelog (v0.3.7)](#changelog-v037)

## Overview

This milestone transitions the inventory, crafting, and journal systems from simple text commands into full-screen, interactive Terminal User Interfaces (TUI). It leverages the Spectre.Console layout engine to create rich, dashboard-style management screens.

The Ledger is implemented across three phases:

- **Phase A (v0.3.7a): The Pack** - Split-screen inventory management with equipment slots and burden visualization
- **Phase B (v0.3.7b): The Bench** - Unified crafting interface with recipe filtering, ingredient checklists, and outcome previews
- **Phase C (v0.3.7c): The Archive** - Tabbed Scavenger's Journal for lore, bestiary, and quest tracking

---

## Phase A: The Pack (Inventory UI)

**Goal:** Implement `InventoryScreenRenderer` to display the player's loadout and backpack contents simultaneously, visualizing the Burden system defined in SPEC-UI-INVENTORY.

### 1. Architecture & Data Flow

The system uses a ViewModel Pattern to decouple the rendering logic from the game engine.

**Components:**

- **InventoryViewModel:** A Core-layer DTO containing pre-calculated display data (formatted strings, colors, lists).
- **InventoryService:** Responsible for building the ViewModel from the Character entity.
- **InventoryScreenRenderer:** Terminal-layer service that consumes the ViewModel and builds the Spectre.Console layout.

**Workflow:**

1. **Input:** User types `inventory` or presses `I`.
2. **State Retrieval:** `GameService` calls `_inventoryService.GetViewModel(character)`.
3. **Data Transformation:**
   - Inventory items are sorted (Equipped first, then by Category).
   - Burden is calculated as a percentage.
   - Equipment slots are mapped to display strings (e.g., "[Main Hand] Iron Sword").
4. **Rendering:** `GameService` passes the ViewModel to `_inventoryRenderer.Render()`.
5. **Draw:** The renderer clears the screen and draws the split-pane layout.

**Layout:**

- Root Layout split into `EquipmentColumn` (Left, 30%) and `InventoryColumn` (Right, 70%).
- **Equipment:** Visual list of slots (Head, Body, MainHand, etc.) showing equipped items or `(empty)`.
- **Inventory:** Scrollable table of items with Weight, Value, and Quantity.
- **Footer:** Burden Bar showing weight percentage and penalty thresholds.

### 2. Logic Decision Trees

#### A. Burden Bar Visualization

**Input:** CurrentWeight, MaxCapacity

1. **Calculate Ratio:** `Percent = (CurrentWeight / MaxCapacity) * 100`.
2. **Determine State & Color:**
   - 0% - 40% (Light): Color Green. Message: "Unencumbered".
   - 41% - 70% (Medium): Color Yellow. Message: "Noticeable weight".
   - 71% - 90% (Heavy): Color Orange. Message: "Movement slowed (-1 Speed)".
   - 91%+ (Overburdened): Color Red. Message: "Crushing weight (Immobile)".
3. **Render Bar:** Use ProgressBar or block characters â–ˆ proportional to percentage.

#### B. Equipment Slot Display

**Input:** Slot Enum, Item Entity

1. **Check Slot Content:**
   - If Empty: Return `[grey](empty)[/]`.
   - If Occupied: Get Item Name.
2. **Determine Rarity Color:**
   - JuryRigged: Grey
   - Scavenged: White
   - ClanForged: Green
   - Optimized: Blue
   - MythForged: Gold
3. **Format:** `"[bold]{SlotName}:[/] [{Color}]{ItemName}[/]"`

### 3. Code Implementation

**File:** `RuneAndRust.Core/ViewModels/InventoryViewModel.cs`

```csharp
public record InventoryViewModel(
    string CharacterName,
    int CurrentWeight,
    int MaxCapacity,
    double BurdenPercentage,
    string BurdenStatus,
    string BurdenColor,
    List<EquipmentSlotView> Equipment,
    List<InventoryItemView> Backpack
);

public record EquipmentSlotView(string SlotName, string ItemName, string Color);
public record InventoryItemView(string Name, int Quantity, string Weight, string Value, string Color);
```

**File:** `RuneAndRust.Terminal/Rendering/InventoryScreenRenderer.cs`

```csharp
using Spectre.Console;
using RuneAndRust.Core.ViewModels;

public class InventoryScreenRenderer : IInventoryScreenRenderer
{
    public void Render(InventoryViewModel vm)
    {
        var root = new Layout("Root")
            .SplitRows(
                new Layout("Header").Size(3),
                new Layout("Content").SplitColumns(
                    new Layout("Equipment").Ratio(1),
                    new Layout("Backpack").Ratio(2)
                ),
                new Layout("Footer").Size(3)
            );

        // 1. Header
        root["Header"].Update(new Panel($"[bold]{vm.CharacterName}'s Pack[/]")
            .Border(BoxBorder.None).Centered());

        // 2. Equipment Column
        var equipGrid = new Grid().AddColumns(2);
        equipGrid.AddColumn(new GridColumn().NoWrap().PadRight(2));
        foreach (var slot in vm.Equipment)
        {
            equipGrid.AddRow($"[grey]{slot.SlotName}:[/]", $"[{slot.Color}]{slot.ItemName}[/]");
        }
        root["Equipment"].Update(new Panel(equipGrid).Header("Wielded").Border(BoxBorder.Rounded));

        // 3. Backpack Column (Scrollable Table)
        var table = new Table().Expand().Border(TableBorder.None);
        table.AddColumns("Item", "Qty", "Wt", "Val");
        foreach (var item in vm.Backpack)
        {
            table.AddRow(
                $"[{item.Color}]{item.Name}[/]",
                item.Quantity.ToString(),
                item.Weight,
                item.Value
            );
        }
        root["Backpack"].Update(new Panel(table).Header("Backpack contents").Border(BoxBorder.Rounded));

        // 4. Footer (Burden Bar)
        var barLength = 50;
        var filled = (int)(barLength * (Math.Min(vm.BurdenPercentage, 100) / 100.0));
        var bar = new string('â–ˆ', filled).PadRight(barLength, 'â–‘');

        var burdenPanel = new Panel(
            new Markup($"[{vm.BurdenColor}]{bar}[/] {vm.CurrentWeight}/{vm.MaxCapacity}g - [bold]{vm.BurdenStatus}[/]")
        ).Border(BoxBorder.None);

        root["Footer"].Update(burdenPanel);

        AnsiConsole.Clear();
        AnsiConsole.Write(root);
    }
}
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Render | Trace | "Rendering inventory for {Character}. Items: {Count}, Burden: {Pct}%" | Character, Count, Pct |
| ModeSwitch | Info | "Switched to Inventory Mode" | - |
| View Build | Debug | "Built InventoryViewModel in {Elapsed}ms" | Elapsed |

### 5. Testing Requirements

**Unit Tests (InventoryScreenTests.cs)**

- **ViewModel_Generation:**
  - `GetViewModel_CalculatesBurdenCorrectly`: Mock weight 25kg/50kg â†’ Assert Pct 50.0.
  - `GetViewModel_MapsEmptySlots`: Character with no gear â†’ All slots return "(empty)".
  - `GetViewModel_ColorCoding`: MythForged item â†’ Returns "gold1".
- **Renderer_Layout:**
  - `Render_ContainsSplitColumns`: Verify layout tree contains "Equipment" and "Backpack".

**Integration Tests**

- **Full_Cycle:**
  - Add Item to Inventory â†’ Call GetViewModel â†’ Verify Item appears in Backpack list.
  - Equip Item â†’ Call GetViewModel â†’ Verify Item moves from Backpack to Equipment list.

### 6. Deliverable Checklist (Phase A)

- **Core:**
  - [ ] Define `InventoryViewModel` record.
  - [ ] Define `IInventoryScreenRenderer` interface.
- **Engine:**
  - [ ] Implement `InventoryService.GetViewModel(Character)`.
  - [ ] Implement `InventoryViewHelper` for color/string formatting.
- **Terminal:**
  - [ ] Implement `InventoryScreenRenderer` with Spectre Layouts.
  - [ ] Update `CommandParser` to trigger UI render on `inventory` command.
  - [ ] Add WaitForKey loop to keep UI open until closed.

---

## Phase B: The Bench (Crafting UI)

**Goal:** Implement `CraftingScreenRenderer` and `CraftingViewModel` to visualize recipes, ingredient availability, and crafting outcomes in a split-pane layout.

### 1. Architecture & Data Flow

The UI follows the ViewModel Pattern, aggregating data from `CraftingService` and `InventoryService` into a display-ready object.

**Components:**

- **CraftingViewModel:** Immutable record containing the active trade, list of known recipes, ingredient status for the selected recipe, and player's current resources.
- **CraftingScreenRenderer:** Spectre.Console service that renders the layout:
  - Header: Tab bar (e.g., `Bodging | Alchemy`).
  - Left Panel: Scrollable list of recipes (White = craftable, Grey = missing mats).
  - Right Panel: Blueprint view (Ingredients, Stats, Description).
  - Footer: Controls and Status Log.

**Workflow:**

1. **Input:** Player types `craft` or presses `C`.
2. **State Retrieval:** `GameService` calls `_craftingService.GetViewModel(character, activeTrade, selectedIndex)`.
3. **Validation:** Service checks inventory against recipe requirements.
4. **Rendering:** `CraftingScreenRenderer` draws the UI.
5. **Interaction:**
   - Tab/1-4: Switch Trade (Requests new VM with updated `ActiveTrade`).
   - Up/Down: Change Selection (Requests new VM with updated Index).
   - Enter: Execute Craft (Calls `CraftingService.CraftItem`).

### 2. Logic Decision Trees

#### A. Ingredient Availability Logic

**Input:** Recipe, PlayerInventory

1. **Iterate Ingredients:** For each ingredient I in `Recipe.Ingredients`:
   - Check Inventory: `Count = Inventory.Count(I.Id)`.
   - Compare:
     - If `Count >= Required`: Status = Available (Green check).
     - If `Count < Required`: Status = Missing (Red X).
2. **Determine Craftability:**
   - If ALL ingredients are Available â†’ `CanCraft = True`.
   - Else â†’ `CanCraft = False`.

#### B. Display Color Logic

**Input:** RecipeView

1. **Check Capability:** Does player have the required Specialization (e.g., Alka-hestur for advanced alchemy)?
   - No: Render Name in Dim Grey (Locked).
2. **Check Resources:** Is `CanCraft` true?
   - Yes: Render Name in White (Active).
   - No: Render Name in Grey (Insufficient materials).
3. **Check Selection:** Is this the currently selected row?
   - Yes: Invert colors (Black text on White background) or use `>` prefix.

### 3. Code Implementation

**File:** `RuneAndRust.Core/ViewModels/CraftingViewModel.cs`

```csharp
public record CraftingViewModel(
    CraftingTrade ActiveTrade,
    List<RecipeView> Recipes,
    RecipeDetailsView? SelectedRecipe,
    string StatusMessage
);

public record RecipeView(
    string Id,
    string Name,
    bool CanCraft,
    bool IsLocked
);

public record RecipeDetailsView(
    string Name,
    string Description,
    int Difficulty,
    List<IngredientView> Ingredients,
    string OutputPreview
);

public record IngredientView(
    string Name,
    int Required,
    int Available,
    bool IsMet
);
```

**File:** `RuneAndRust.Terminal/Rendering/CraftingScreenRenderer.cs`

```csharp
using Spectre.Console;
using RuneAndRust.Core.ViewModels;
using RuneAndRust.Core.Enums;

public class CraftingScreenRenderer : ICraftingScreenRenderer
{
    public void Render(CraftingViewModel vm)
    {
        var layout = new Layout("Root")
            .SplitRows(
                new Layout("Tabs").Size(3),
                new Layout("Workspace").SplitColumns(
                    new Layout("List").Ratio(4),
                    new Layout("Blueprint").Ratio(6)
                ),
                new Layout("Footer").Size(3)
            );

        layout["Tabs"].Update(RenderTabs(vm.ActiveTrade));

        var listGrid = new Grid().AddColumn();
        foreach (var recipe in vm.Recipes)
        {
            var style = recipe.Id == vm.SelectedRecipe?.Id ? "[inverse]" : "";
            var color = recipe.CanCraft ? "white" : "grey";
            var icon = recipe.IsLocked ? "ðŸ”’" : (recipe.CanCraft ? "ðŸ”¨" : " ");

            listGrid.AddRow($"{style}[{color}]{icon} {recipe.Name}[/][/]");
        }
        layout["List"].Update(new Panel(listGrid).Header("Recipes").Border(BoxBorder.Rounded));

        if (vm.SelectedRecipe != null)
        {
            layout["Blueprint"].Update(RenderBlueprint(vm.SelectedRecipe));
        }

        AnsiConsole.Clear();
        AnsiConsole.Write(layout);
    }

    private Panel RenderBlueprint(RecipeDetailsView details)
    {
        var grid = new Grid().AddColumns(2);
        grid.AddRow("[bold]Difficulty:[/]", $"{details.Difficulty} (WITS)");
        grid.AddRow(new Rule("[yellow]Ingredients[/]"), new Text(""));

        foreach (var ing in details.Ingredients)
        {
            string color = ing.IsMet ? "green" : "red";
            string icon = ing.IsMet ? "âœ”" : "âœ—";
            grid.AddRow(
                $"[{color}]{icon} {ing.Name}[/]",
                $"[grey]{ing.Available}/{ing.Required}[/]"
            );
        }

        return new Panel(grid)
            .Header($"[bold cyan]{details.Name}[/]")
            .Border(BoxBorder.Rounded);
    }
}
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Render | Trace | "Rendering Crafting UI: Trade {Trade}, Recipes {Count}" | Trade, Count |
| TabSwitch | Info | "Switched crafting tab to {Trade}" | Trade |
| Selection | Trace | "Selected recipe {RecipeId} (CanCraft: {CanCraft})" | RecipeId, CanCraft |

### 5. Testing Requirements

**Unit Tests (CraftingViewModelTests.cs)**

- **Availability:**
  - `GetViewModel_HasIngredients_SetsCanCraftTrue`: Add required mats â†’ Verify `CanCraft` is true.
  - `GetViewModel_MissingIngredients_SetsCanCraftFalse`: Empty inventory â†’ Verify `CanCraft` is false.
- **Filtering:**
  - `GetViewModel_FiltersByTrade`: Request Bodging â†’ Ensure no Alchemy recipes in list.

**Unit Tests (CraftingRendererTests.cs)**

- **Visuals:**
  - `Render_Ingredients_RedIfMissing`: Verify markup contains `[red]` for missing items.
  - `Render_Selected_InverseStyle`: Verify selected item has `[inverse]` tag.

**Integration Tests**

- **End-to-End:**
  - Open Crafting â†’ Select "Improvised Torch" â†’ Press Enter â†’ Verify Item added to Inventory and UI refreshes.

### 6. Deliverable Checklist (Phase B)

- **Core:**
  - [ ] Define `CraftingViewModel` records.
  - [ ] Define `ICraftingScreenRenderer`.
- **Engine:**
  - [ ] Implement `CraftingService.GetViewModelAsync`.
  - [ ] Update `CommandParser` to map `craft` command to the UI loop.
- **Terminal:**
  - [ ] Implement `CraftingScreenRenderer`.
  - [ ] Implement input loop for Tab/Arrow navigation.
- **Data:**
  - [ ] Verify Recipe Registry has data for all 4 trades.

---

## Phase C: The Archive (Journal UI)

**Goal:** Implement `JournalScreenRenderer` and `JournalViewModel` to create a multi-tab interface (Codex | Bestiary | Field Guide | Contracts) that renders redacted lore, tracks collection progress, and manages active quests.

### 1. Architecture & Data Flow

The system uses the ViewModel Pattern to aggregate data from `DataCaptureService`, `QuestService`, and `TraumaService`.

**Components:**

- **JournalViewModel:** Immutable state container for the UI, holding categorized entry lists, the currently selected entry's full detail, and player stress levels (for glitch effects).
- **JournalService:** Engine service that builds the ViewModel, handling pagination, filtering, and calling the `TextRedactor`.
- **TextRedactor:** Stateless utility that masks text based on completion percentage (implemented in v0.1.3c, now integrated into the full UI).
- **JournalScreenRenderer:** Terminal renderer using Spectre.Console layouts.

**Tabs:**

- Codex | Bestiary | Field Guide | Contracts

**Entry View:**

- **List (Left):** Entries grouped by category. Incomplete entries show `(45%)` progress.
- **Detail (Right):** The content viewer. Uses `TextRedactor` to render the entry text with missing words masked as `â–ˆâ–ˆâ–ˆâ–ˆ`.

**Workflow:**

1. **Input:** Player types `journal` or presses `J`.
2. **State Retrieval:** `GameService` calls `_journalService.GetViewModel(character, activeTab, selectionIndex)`.
3. **Data Processing:**
   - Fetch all `CodexEntries` and `DataCaptures`.
   - Calculate completion % for each entry.
   - Apply `TextRedactor` to the selected entry's text based on %.
   - Inject "Glitch" artifacts if Player Stress > 50.
4. **Rendering:** `JournalScreenRenderer` draws the split-pane interface.
5. **Interaction Loop:** Handle Tab (Switch Category) and Arrow Keys (Select Entry).

### 2. Logic Decision Trees

#### A. Redaction & Glitch Logic

**Input:** EntryText, CompletionPct, PlayerStress

1. **Redaction Pass:**
   - Split text into words.
   - For each word index `i`:
     - `Visible = ((i * 7 + 13) % 100) < CompletionPct`
     - If Visible: Keep word.
     - If Hidden: Replace with `[grey]â–ˆâ–ˆâ–ˆâ–ˆ[/]`.
2. **Glitch Pass (Trauma Integration):**
   - If Stress > 50 (Distressed): Randomly replace 5% of characters with "Zalgo" marks or static chars (#, %, &).
   - If Stress > 80 (Fractured): Invert colors on random words (`[invert]word[/]`).
3. **Output:** Final Markup string.

#### B. Unlock Threshold Logic

**Input:** Entry, CompletionPct

1. **Iterate Thresholds:** Check `Entry.UnlockThresholds` dictionary.
2. **Filter:** Select thresholds where `ThresholdPct <= CompletionPct`.
3. **Format:**
   - Create list of "Discoveries".
   - Example: `[green]âœ“[/] Weakness Revealed (25%)`.

### 3. Code Implementation

**File:** `RuneAndRust.Core/ViewModels/JournalViewModel.cs`

```csharp
public record JournalViewModel(
    string CharacterName,
    int PsychicStress,
    JournalTab ActiveTab,
    List<JournalEntryView> Entries,
    JournalEntryDetailView? SelectedEntry,
    int SelectedIndex
);

public record JournalEntryView(
    Guid Id,
    string Title,
    string Category,
    int CompletionPercentage,
    bool IsNew
);

public record JournalEntryDetailView(
    string Title,
    string Category,
    string RedactedText,
    List<string> UnlockedDiscoveries,
    int FragmentCount,
    int TotalFragments
);
```

**File:** `RuneAndRust.Terminal/Rendering/JournalScreenRenderer.cs`

```csharp
using Spectre.Console;
using RuneAndRust.Core.ViewModels;

public class JournalScreenRenderer : IJournalScreenRenderer
{
    public void Render(JournalViewModel vm)
    {
        var layout = new Layout("Root")
            .SplitRows(
                new Layout("Header").Size(3),
                new Layout("Content").SplitColumns(
                    new Layout("List").Ratio(4),
                    new Layout("Detail").Ratio(6)
                ),
                new Layout("Footer").Size(1)
            );

        layout["Header"].Update(RenderTabs(vm.ActiveTab));

        var listGrid = new Grid().AddColumn();
        foreach (var entry in vm.Entries)
        {
            var style = entry.Id == vm.SelectedEntry?.Id ? "[inverse]" : "";
            var icon = entry.CompletionPercentage >= 100 ? "[green]â˜…[/]" : "[grey]â—[/]";
            var text = $"{style}{icon} {entry.Title} [grey]({entry.CompletionPercentage}%)[/][/]";
            listGrid.AddRow(text);
        }
        layout["List"].Update(new Panel(listGrid).Header("Entries").Border(BoxBorder.Rounded));

        if (vm.SelectedEntry != null)
        {
            layout["Detail"].Update(RenderDetail(vm.SelectedEntry, vm.PsychicStress));
        }

        AnsiConsole.Clear();
        AnsiConsole.Write(layout);
    }

    private Panel RenderDetail(JournalEntryDetailView detail, int stress)
    {
        var grid = new Grid().AddColumn();

        grid.AddRow(new Markup($"[bold gold1]{detail.Title}[/]"));
        grid.AddRow(new Markup($"[italic grey]{detail.Category} â€¢ {detail.FragmentCount}/{detail.TotalFragments}[/]"));
        grid.AddRow(new Rule());

        grid.AddRow(new Markup(detail.RedactedText));

        if (detail.UnlockedDiscoveries.Any())
        {
            grid.AddRow(new Rule("[cyan]Insights[/]"));
            foreach(var disc in detail.UnlockedDiscoveries)
                grid.AddRow($"[green]âœ“[/] {disc}");
        }

        var border = stress > 80 ? BoxBorder.Double : BoxBorder.Rounded;
        var title = stress > 80 ? "[red]C0RRUPT3D D4TA[/]" : "[bold]Reading...[/]";

        return new Panel(grid).Header(title).Border(border);
    }
}
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Open | Info | "Journal opened. Tab: {Tab}, Stress: {Stress}" | Tab, Stress |
| Entry Select | Trace | "Selected entry {EntryId}: {Title} ({Pct}%)" | EntryId, Title, Pct |
| Process | Debug | "Redacted text for {Title}. Visible: {VisibleWords}/{TotalWords}" | Title, Counts |

### 5. Testing Requirements

**Unit Tests (JournalViewModelTests.cs)**

- **Filtering:**
  - `GetViewModel_FiltersByCategory`: Request "Bestiary" â†’ Ensure only Bestiary entries returned.
- **Progress Calculation:**
  - `GetViewModel_CalculatesPercentage`: 2 fragments out of 4 â†’ Assert `CompletionPercentage == 50`.
- **Selection:**
  - `GetViewModel_ValidSelection_PopulatesDetail`: Ensure `SelectedEntryDetails` is not null if index is valid.

**Unit Tests (TextRedactorTests.cs)**

- **Redaction Logic:**
  - `Redact_ZeroPercent_ReturnsBlocks`: Assert output contains only `â–ˆâ–ˆâ–ˆâ–ˆ`.
  - `Redact_FiftyPercent_ReturnsMix`: Assert output contains words and blocks.
  - `Redact_Full_ReturnsClean`: Assert output matches original string exactly.

**Integration Tests**

- **Visual Check:**
  - Open Journal â†’ Verify "Contracts" tab loads Quest data (linked to `QuestService`).
  - Verify high stress causes visual "noise" in the renderer.

### 6. Deliverable Checklist (Phase C)

- **Core:**
  - [ ] Define `JournalViewModel` and sub-records.
  - [ ] Define `JournalTab` enum.
- **Engine:**
  - [ ] Implement `JournalService.GetViewModel`.
  - [ ] Integrate `TextRedactor` service (from v0.1.3c).
  - [ ] Hook `QuestService` into the "Contracts" tab logic.
- **Terminal:**
  - [ ] Implement `JournalScreenRenderer`.
  - [ ] Update `CommandParser` to route `journal`/`j` to the UI loop.
  - [ ] Add keybinds: TAB (Switch Tab), ARROWS (Navigate), ESC (Close).

---

## Testing Strategy

### Unit Tests

- **InventoryScreenTests.cs:** ViewModel generation, color coding, layout structure
- **CraftingViewModelTests.cs:** Ingredient availability, trade filtering
- **CraftingRendererTests.cs:** Visual markup verification
- **JournalViewModelTests.cs:** Filtering, progress calculation
- **TextRedactorTests.cs:** Redaction percentages

### Integration Tests

- **Inventory Full Cycle:** Add/Equip item, verify UI updates
- **Crafting End-to-End:** Select recipe, craft, verify inventory change
- **Journal Visual Check:** Verify stress-based glitch effects

---

## Changelog (v0.3.7)

**Release Date:** 2025-XX-XX

### Summary

The "Ledger" update introduces a comprehensive suite of management interfaces. The command-line inventory list has been replaced with a rich, split-screen graphical terminal interface, alongside new dedicated screens for Crafting and the Scavenger's Journal.

### Features

- **Visual Inventory (The Pack):**
  - Split-screen view showing Equipment slots and Backpack contents side-by-side.
  - Live "Burden Bar" visualizes weight capacity and penalties.
  - Rarity Colors: Items are now color-coded by quality (Grey/White/Green/Blue/Gold).
- **Unified Crafting Bench:**
  - Tabbed interface for all four trades (Bodging, Alchemy, Runeforging, Medicine).
  - Ingredient checklists show exactly what you have and what you need.
  - Difficulty Class (DC) preview based on current stats and tools.
- **Scavenger's Journal UI:**
  - Interactive Codex with redacted text rendering for incomplete entries.
  - Dedicated Quest/Contracts tab for tracking objectives.
  - Psychic Feedback: High Stress levels cause the Journal UI to "glitch".
- **Progressive Unlocks:**
  - Entries show completion bars. Reaching thresholds (25%, 50%, 75%) unlocks specific insights.

### Technical

- Implemented `InventoryScreenRenderer`, `CraftingScreenRenderer`, and `JournalScreenRenderer`.
- Created ViewModel layer for all management screens to decouple logic from Spectre.Console rendering.
- Integrated `TextRedactor` service for dynamic string masking.
