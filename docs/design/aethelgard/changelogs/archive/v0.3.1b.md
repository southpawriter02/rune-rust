> **Archived** - This changelog has been consolidated. See the complete version at [v0.3.1](../v0.3.x/v0.3.1.md).

# v0.3.1b Changelog: The Tinkerer (Bodging & Medicine)

**Release Date:** December 20, 2025
**Total Tests:** 1692 (20 new tests added)

---

## Summary

Version 0.3.1b introduces the **Bodging System** - equipment durability tracking with WITS-based repair mechanics and salvage operations. This release establishes the foundation for equipment maintenance and material recycling in Rune & Rust.

Key architectural additions:
- **Durability System**: Equipment entities now track MaxDurability, CurrentDurability, and IsBroken state
- **IBodgingService**: Service contract with 5 methods for repair and salvage operations
- **BodgingService**: WITS-based repair with 4-tier outcomes, salvage with quality/weight-based yield
- **RepairResult/SalvageResult Records**: Operation result models with full roll details
- **Extended Command Parser**: New verbs (repair, fix, mend, salvage, scrap, dismantle)

---

## New Features

### Equipment Durability System
- **MaxDurability**: Maximum durability value (default 100)
- **CurrentDurability**: Current durability, decreased by damage
- **IsBroken**: Computed property, true when CurrentDurability <= 0
- **Permanent Damage**: Catastrophic repair failures reduce MaxDurability by 10

### WITS-Based Repair Mechanics
- **Dice Pool**: Character's WITS attribute determines number of d10s rolled
- **Success Threshold**: Rolls of 8+ count as successes; rolls of 1 count as botches
- **Dynamic DC**: DC = 8 + (damage / 5) - more damaged items are harder to repair
- **Scrap Cost**: Ceiling(damage / 5) Scrap consumed before rolling

### Four-Tier Repair Outcomes
- **Catastrophe (Net < 0)**: Materials lost, MaxDurability permanently reduced by 10
- **Failure (0 <= Net < DC)**: Materials lost, no repair performed
- **Success (Net >= DC)**: Durability restored by min(damage, net * 5)
- **Masterwork (Net >= DC + 5)**: Full restoration to MaxDurability

### Salvage System
- **Yield Formula**: (Weight / 100) * (QualityModifier + 1)
- **Quality Modifiers**: JuryRigged=0, Scavenged=1, ClanForged=2, Optimized=3, MythForged=4
- **Minimum Yield**: Always at least 1 Scrap
- **Item Destruction**: Salvaged equipment is permanently destroyed

---

## Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/Crafting/RepairResult.cs` | Record containing dice results, outcome, and durability changes |
| `RuneAndRust.Core/Models/Crafting/SalvageResult.cs` | Record containing salvage success status and Scrap yield |
| `RuneAndRust.Core/Interfaces/IBodgingService.cs` | Contract for repair and salvage operations (5 methods) |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/BodgingService.cs` | WITS-based repair logic with durability management and salvage yield |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/BodgingServiceTests.cs` | Repair and salvage mechanics validation (20 tests) |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/Equipment.cs` | Added MaxDurability, CurrentDurability, IsBroken properties |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Extended ParseResult with repair/salvage flags; added repair/fix/mend/salvage/scrap/dismantle commands |
| `RuneAndRust.Terminal/Program.cs` | Registered IBodgingService in DI; updated version to v0.3.1b |

---

## Code Implementation Details

### Equipment Durability Properties
```csharp
public class Equipment : Item
{
    // Existing properties...

    #region Durability Properties

    /// <summary>
    /// Gets or sets the maximum durability of this equipment.
    /// Equipment cannot be repaired beyond this value.
    /// </summary>
    public int MaxDurability { get; set; } = 100;

    /// <summary>
    /// Gets or sets the current durability of this equipment.
    /// Equipment becomes broken when this reaches 0.
    /// </summary>
    public int CurrentDurability { get; set; } = 100;

    /// <summary>
    /// Gets whether this equipment is broken and unusable.
    /// Broken equipment provides no bonuses and cannot be used in combat.
    /// </summary>
    public bool IsBroken => CurrentDurability <= 0;

    #endregion
}
```

### RepairResult Record
```csharp
public record RepairResult(
    bool IsSuccess,
    CraftingOutcome Outcome,
    string ItemName,
    int DiceRolled,
    int Successes,
    int Botches,
    int NetSuccesses,
    int DifficultyClass,
    int DurabilityRestored,
    int ScrapConsumed,
    int? MaxDurabilityLost,  // Only set on Catastrophe
    string Message,
    IReadOnlyList<int> Rolls
);
```

### SalvageResult Record
```csharp
public record SalvageResult(
    bool IsSuccess,
    string ItemName,
    int ScrapYield,
    string Message
);
```

### IBodgingService Interface
```csharp
public interface IBodgingService
{
    Task<RepairResult> RepairItemAsync(Character character, Guid itemId);
    Task<SalvageResult> SalvageItemAsync(Character character, Guid itemId);
    int CalculateRepairCost(Equipment equipment);
    int CalculateSalvageYield(Equipment equipment);
    bool CanRepair(Character character, Equipment equipment);
}
```

### BodgingService Core Constants
```csharp
private const int BaseRepairDc = 8;           // Base DC for repair
private const int DamageDivisor = 5;           // Divides damage for cost/DC calculation
private const int MasterworkThreshold = 5;     // DC + 5 for masterwork
private const int CatastrophePenalty = 10;     // MaxDurability reduction on fumble
private const int SalvageWeightDivisor = 100;  // Divides weight for yield calculation
```

### Repair DC Calculation
```csharp
private int CalculateDc(Equipment equipment)
{
    var damage = equipment.MaxDurability - equipment.CurrentDurability;
    return BaseRepairDc + (damage / DamageDivisor);
}
```

### Salvage Yield Calculation
```csharp
public int CalculateSalvageYield(Equipment equipment)
{
    var qualityMod = GetQualityModifier(equipment.Quality);
    var yield = (equipment.Weight / SalvageWeightDivisor) * (qualityMod + 1);
    return Math.Max(1, yield); // Minimum 1 Scrap
}

private static int GetQualityModifier(QualityTier tier) => tier switch
{
    QualityTier.JuryRigged => 0,
    QualityTier.Scavenged => 1,
    QualityTier.ClanForged => 2,
    QualityTier.Optimized => 3,
    QualityTier.MythForged => 4,
    _ => 0
};
```

### ParseResult Extensions
```csharp
public class ParseResult
{
    // Existing properties...

    // New repair properties
    public bool RequiresRepair { get; set; }
    public string? RepairTarget { get; set; }

    // New salvage properties
    public bool RequiresSalvage { get; set; }
    public string? SalvageTarget { get; set; }
}
```

---

## Commands Reference (Updated)

### Exploration Phase Commands
| Command | Aliases | Action |
|---------|---------|--------|
| `repair <item>` | `fix <item>`, `mend <item>` | Attempt to repair equipment using WITS roll |
| `salvage <item>` | `scrap <item>`, `dismantle <item>` | Destroy equipment to extract Scrap |

---

## Logging Matrix (v0.3.1b)

### BodgingService Logs
| Event | Level | Template |
|-------|-------|----------|
| Repair Start | Information | `"Repair attempt: {ItemName} by {CharacterName}"` |
| Repair Cost Calculated | Debug | `"Repair cost: {ScrapCost} Scrap for {Damage} damage"` |
| Scrap Consumed | Debug | `"Consumed: {Quantity}x Scrap for repair"` |
| Repair Roll | Debug | `"Repair roll: {Wits}d10 = {Successes}S/{Botches}B, Net={Net}, DC={DC}"` |
| Repair Success | Information | `"Repair SUCCESS: {ItemName} restored {Durability} points"` |
| Repair Masterwork | Information | `"Repair MASTERWORK: {ItemName} fully restored"` |
| Repair Failure | Information | `"Repair FAILURE: {ItemName} (Net {Net} < DC {DC})"` |
| Repair Catastrophe | Warning | `"Repair CATASTROPHE: {ItemName} - MaxDurability reduced by {Penalty}!"` |
| Salvage Start | Information | `"Salvage attempt: {ItemName} by {CharacterName}"` |
| Salvage Yield | Debug | `"Salvage yield: {Yield} Scrap from {Weight}g {Quality} item"` |
| Salvage Complete | Information | `"Salvage SUCCESS: {ItemName} -> {Yield}x Scrap"` |

### CommandParser Logs
| Event | Level | Template |
|-------|-------|----------|
| Repair Command | Debug | `"Repair command for target: {Target}"` |
| Salvage Command | Debug | `"Salvage command for target: {Target}"` |

---

## Complete Test Inventory

### Engine/BodgingServiceTests.cs (20 tests)

#### Validation Tests (4 tests)
| Test Name | Description |
|-----------|-------------|
| `RepairItem_WithNonEquipment_ReturnsFailure` | Non-equipment items cannot be repaired |
| `RepairItem_WithUndamagedItem_ReturnsFailure` | Pristine items don't need repair |
| `RepairItem_WithInsufficientScrap_ReturnsFailure` | Insufficient materials blocks repair |
| `RepairItem_WithUnknownItem_ReturnsFailure` | Unknown item ID returns failure |

#### Outcome Determination Tests (5 tests)
| Test Name | Description |
|-----------|-------------|
| `RepairItem_RollMeetsDc_RestoresDurability` | Net >= DC restores durability |
| `RepairItem_RollExceedsDcBy5_FullyRestores` | Net >= DC + 5 fully restores |
| `RepairItem_RollBelowDc_ReturnsFailure` | Net < DC returns Failure |
| `RepairItem_NetNegative_ReducesMaxDurability` | Net < 0 permanently reduces MaxDurability |
| `RepairItem_ConsumesScrap` | Verifies Scrap consumption |

#### Salvage Tests (5 tests)
| Test Name | Description |
|-----------|-------------|
| `SalvageItem_WithValidEquipment_YieldsScrap` | Valid salvage produces Scrap |
| `SalvageItem_WithNonEquipment_ReturnsFailure` | Non-equipment cannot be salvaged |
| `SalvageItem_RemovesItemFromInventory` | Item removed on salvage |
| `SalvageItem_HighQualityYieldsMoreScrap` | Higher quality = more Scrap |
| `SalvageItem_HeavyItemYieldsMoreScrap` | Heavier items = more Scrap |

#### Helper Method Tests (6 tests)
| Test Name | Description |
|-----------|-------------|
| `CalculateRepairCost_ReturnsCorrectValue` | Ceiling(damage / 5) |
| `CalculateRepairCost_MinimumOne` | Always at least 1 Scrap |
| `CalculateSalvageYield_ReturnsCorrectValue` | (Weight/100) * (QualityMod+1) |
| `CalculateSalvageYield_MinimumOne` | Always at least 1 Scrap |
| `CanRepair_WithSufficientScrap_ReturnsTrue` | Enough Scrap passes |
| `CanRepair_WithInsufficientScrap_ReturnsFalse` | Not enough Scrap fails |

---

## DI Registration

Added to `Program.cs`:
```csharp
// Register Bodging Services (v0.3.1b)
services.AddScoped<IBodgingService, BodgingService>();
```

---

## Build Verification

```
Build succeeded.
    0 Error(s)

Test run:
  Passed: 1692
  Failed: 0
  Skipped: 0
```

---

## Directory Structure After v0.3.1b

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Entities/
│   │   ├── Equipment.cs                       [MODIFIED - durability]
│   │   └── ... (existing entities)
│   ├── Interfaces/
│   │   ├── IBodgingService.cs                 [NEW]
│   │   └── ... (existing interfaces)
│   └── Models/
│       └── Crafting/
│           ├── CraftingResult.cs
│           ├── RepairResult.cs                [NEW]
│           └── SalvageResult.cs               [NEW]
├── RuneAndRust.Engine/
│   └── Services/
│       ├── BodgingService.cs                  [NEW]
│       ├── CommandParser.cs                   [MODIFIED]
│       └── ... (existing services)
├── RuneAndRust.Terminal/
│   └── Program.cs                             [MODIFIED]
├── RuneAndRust.Tests/
│   └── Engine/
│       ├── BodgingServiceTests.cs             [NEW]
│       └── ... (existing tests)
└── docs/
    └── changelogs/
        ├── v0.3.1a.md
        └── v0.3.1b.md                         [NEW]
```

---

## Dependencies

### Service Dependencies
| Service | Depends On |
|---------|------------|
| BodgingService | IDiceService, IInventoryService, IItemRepository, ILogger |

### Existing Infrastructure Used
| Component | Usage |
|-----------|-------|
| IDiceService | WITS pool rolling (d10 with 8+ success, 1 botch) |
| IInventoryService | Scrap consumption, item removal, Scrap addition |
| IItemRepository | Scrap item lookup for salvage output |
| QualityTier | Salvage yield calculation multiplier |
| CraftingOutcome | Reused for repair outcome classification |

---

## Test Summary by Category

| Category | Test Count |
|----------|------------|
| RepairItemAsync - Validation | 4 |
| RepairItemAsync - Outcomes | 5 |
| SalvageItemAsync | 5 |
| Helper Methods | 6 |
| **v0.3.1b New Tests** | **20** |
| **Total** | **1692** |

---

## Running Tests

```bash
# Run all tests
dotnet test RuneAndRust.Tests

# Run only v0.3.1b new tests
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~BodgingService"

# Run repair outcome tests specifically
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~BodgingService&FullyQualifiedName~Repair"

# Run salvage tests specifically
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~BodgingService&FullyQualifiedName~Salvage"
```

---

## Migration Notes

- **No database migrations required**: Durability properties are in-memory state
- **Existing Equipment unaffected**: Defaults to 100/100 durability (pristine condition)
- **IBodgingService registered as Scoped**: Inherits scope from IInventoryService dependency
- **Scrap item**: Created dynamically if not found in ItemRepository

---

## Next Steps (v0.3.1c: Crafting UI)

Potential features for the next sub-release:
- CraftingScreenRenderer for dedicated crafting interface
- Recipe list display with ingredient availability indicators
- Durability display in equipment UI
- Repair confirmation prompts with cost preview
- Location-restricted Field Medicine crafting
