# v0.15.3g Design Specification: Cultural Protocols

**Version:** 0.15.3g
**Theme:** Cultural Protocols
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.1 Complete (Skill Context, Outcome Classification, Master Abilities), v0.15.3a Complete (Social Interaction Framework), v0.15.3f Complete (Interrogation System)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [CantFluency Enum](#4-cantfluency-enum)
5. [VeilSpeechState Enum](#5-veilspeechstate-enum)
6. [ProtocolViolationType Enum](#6-protocolviolationtype-enum)
7. [CantModifier Value Object](#7-cantmodifier-value-object)
8. [ProtocolRequirement Value Object](#8-protocolrequirement-value-object)
9. [VeilSpeechContext Value Object](#9-veilspeechcontext-value-object)
10. [ProtocolCheckResult Value Object](#10-protocolcheckresult-value-object)
11. [CultureProtocol Entity](#11-cultureprotocol-entity)
12. [ICulturalProtocolService Interface](#12-iculturalprotocolservice-interface)
13. [CulturalProtocolService Implementation](#13-culturalprotocolservice-implementation)
14. [Configuration](#14-configuration)
15. [Commands](#15-commands)
16. [User-Facing Changes](#16-user-facing-changes)
17. [Logging Specifications](#17-logging-specifications)
18. [Unit Testing Requirements](#18-unit-testing-requirements)
19. [Use Cases](#19-use-cases)
20. [Deliverable Checklist](#20-deliverable-checklist)
21. [Acceptance Criteria](#21-acceptance-criteria)
22. [Future Considerations](#22-future-considerations)
23. [Implementation Notes](#23-implementation-notes)
24. [Document Metadata](#24-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.3g, the Cultural Protocols phase of the Rhetoric skill expansion. This phase transforms social interactions from generic skill checks into culturally-aware encounters by introducing formal behavioral rules and language fluency mechanics. The key components are:

1. **CultureProtocol Entity**: Defines the unique social requirements, difficulty classes, and violation consequences for each major culture in Aethelgard (Dvergr, Utgard, Gorge-Maw, Rune-Lupin, Iron-Bane).

2. **CantFluency System**: A three-tier language proficiency system (None, Basic, Fluent) that provides mechanical dice modifiers (-1d10 to +1d10) based on the character's knowledge of a culture's dialect or cant.

3. **Veil-Speech Mechanics**: Specialized rules for Utgard interactions where direct truth-telling is considered offensive and deception is a sign of respect, inverting normal social check assumptions.

4. **Protocol Violation Tracking**: Consequences for failing to observe cultural formalities, ranging from temporary DC increases to permanent relationship damage.

5. **Cultural Context Integration**: Seamless injection of protocol and cant modifiers into the existing `SocialContext` framework from v0.15.3a.

This infrastructure enables rich, culturally-differentiated social encounters where knowledge of local customs and languages provides tangible mechanical advantages, and ignorance carries real consequences.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation (v0.15.3f) | Target Implementation (v0.15.3g) |
|--------|-----------------------------------|----------------------------------|
| **Cultural Rules** | Social checks ignore cultural context | `CultureProtocol` entity defines unique requirements, DCs, and violation consequences per culture |
| **Language/Cants** | Cants are purely narrative flavor | `CantFluency` enum with mechanical modifiers (+1d10 to -1d10) applied to Rhetoric checks |
| **Utgard Interaction** | Standard social logic applies | Specialized `VeilSpeechContext` with inverted deception rules |
| **Protocol Compliance** | Not tracked | `ProtocolCheckResult` tracks compliance state and consequences |
| **Violation Consequences** | Not implemented | `ProtocolViolationType` enum with escalating penalties |
| **Social Modifiers** | Based on disposition and request only | Extended to include protocol compliance and cant fluency |
| **Cultural DC Adjustment** | Not implemented | Per-culture base DCs (12-18) applied automatically |
| **Offense State** | Not tracked | `VeilSpeechState` tracks offense/respect status with Utgard |

### 1.3 Scope

**In Scope:**
- Define `CantFluency` enum for language proficiency levels
- Define `VeilSpeechState` enum for Utgard interaction states
- Define `ProtocolViolationType` enum for violation categories
- Define `CantModifier` value object for fluency-based dice modifiers
- Define `ProtocolRequirement` value object for protocol rule encapsulation
- Define `VeilSpeechContext` value object for Utgard-specific logic
- Define `ProtocolCheckResult` value object for protocol compliance outcomes
- Define `CultureProtocol` entity for cultural rule definitions
- Create `ICulturalProtocolService` interface for protocol operations
- Implement `CulturalProtocolService` for protocol logic
- Configuration files `cultural-protocols.json` and `cant-modifiers.json`
- Integration with `SocialContext` from v0.15.3a
- Unit tests for cultural protocol logic (~4 tests)

**Out of Scope (Future Phases):**
- Extended Influence system (v0.15.3h) - Long-term belief change mechanics
- Specialization Integration (v0.15.3i) - Thul/Skald/Kupmaðr specific protocol bonuses
- Polyglot Master Ability (v0.15.3i) - Auto-knowledge of all common cants
- Cultural Diplomat Master Ability (v0.15.3i) - Auto-succeed protocol DC ≤ 14
- Dynamic protocol learning - Characters learning new protocols over time
- Protocol-specific dialogue trees - Branching conversations based on protocol state

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 3 | `CantFluency`, `VeilSpeechState`, `ProtocolViolationType` |
| Value Objects | 4 | `CantModifier`, `ProtocolRequirement`, `VeilSpeechContext`, `ProtocolCheckResult` |
| Entities | 1 | `CultureProtocol` |
| Interfaces | 1 | `ICulturalProtocolService` |
| Services | 1 | `CulturalProtocolService` |
| Configuration Files | 2 | `cultural-protocols.json`, `cant-modifiers.json` |
| Unit Tests | ~4 | Protocol DC, Veil-Speech, Cant modifiers, Violation consequences |

### 1.5 Design Principles

1. **Cultural Specificity**: Each major culture should feel mechanically distinct through its social requirements. Dvergr demand logical precision, Utgard expect veiled truths, Gorge-Maw require patience, Rune-Lupin need mental openness, and Iron-Bane respect martial tribute.

2. **Knowledge as Power**: Learning a faction's cant or studying their protocols provides tangible mechanical advantages (+1d10 for fluency, reduced DCs for proper protocol). This rewards player investment in cultural knowledge.

3. **High Stakes Formalities**: Violating a protocol isn't just a failed check—it's a social offense with lasting consequences. This creates meaningful tension in cross-cultural encounters.

4. **Graceful Degradation**: Characters without cultural knowledge can still attempt interactions, but at a disadvantage. The system penalizes ignorance without making interactions impossible.

5. **Data-Driven Design**: All protocol definitions, DCs, and modifiers are externalized to JSON configuration, enabling easy balancing and content expansion without code changes.

6. **Composable Modifiers**: Cultural modifiers integrate seamlessly with the existing `SocialModifier` system from v0.15.3a, stacking with disposition, evidence, and other factors.

---

## 2. Dependencies

### 2.1 Required from Previous Phases

| Type | Source | Location | Usage in v0.15.3g |
|------|--------|----------|-------------------|
| `SocialContext` | v0.15.3a | `Domain/ValueObjects/SocialContext.cs` | Extended with cultural protocol modifiers |
| `SocialModifier` | v0.15.3a | `Domain/ValueObjects/SocialModifier.cs` | Used to encapsulate protocol and cant bonuses |
| `SocialInteractionType` | v0.15.3a | `Domain/Enums/SocialInteractionType.cs` | Protocol applicability filtering |
| `NpcDisposition` | v0.15.3a | `Domain/Enums/NpcDisposition.cs` | Interaction with Veil-Speech offense state |
| `DispositionLevel` | v0.15.3a | `Domain/ValueObjects/DispositionLevel.cs` | Modified by protocol violations |
| `SocialResult` | v0.15.3a | `Domain/ValueObjects/SocialResult.cs` | Extended with protocol violation data |
| `ISocialContextBuilder` | v0.15.3a | `Application/Interfaces/ISocialContextBuilder.cs` | Extended with protocol methods |
| `SkillContext` | v0.15.1a | `Domain/ValueObjects/SkillContext.cs` | Base context pattern |
| `SkillOutcome` | v0.15.1a | `Domain/Enums/SkillOutcome.cs` | Protocol check outcomes |
| `FumbleConsequence` | v0.15.1b | `Domain/Entities/FumbleConsequence.cs` | Protocol violation consequences |
| `ISkillStressService` | v0.15.1e | `Application/Interfaces/ISkillStressService.cs` | Stress from protocol violations |

### 2.2 External Dependencies

| Dependency | Purpose |
|------------|---------|
| `Microsoft.Extensions.Logging` | Logging protocol checks and violations |
| `System.Text.Json` | Configuration file parsing |
| `Microsoft.Extensions.Options` | Configuration binding |

### 2.3 Provides to Future Phases

| Type | Consumer | Usage |
|------|----------|-------|
| `CultureProtocol` | v0.15.3h | Extended influence may be gated by protocol compliance |
| `CantFluency` | v0.15.3i | Polyglot ability grants automatic Fluent status |
| `ICulturalProtocolService` | v0.15.3i | Cultural Diplomat ability uses auto-succeed logic |
| `VeilSpeechContext` | v0.15.3i | Myrk-gengr specialization bonuses for Veil-Speech |
| `ProtocolCheckResult` | v0.16.x | Quest system may require protocol compliance |

---

## 3. Architecture Diagrams

### 3.1 Component Overview

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         CULTURAL PROTOCOLS SYSTEM                                │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│                              PRESENTATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────────┐  │
│  │  Protocol Display   │  │  Cant Status View   │  │  Violation Feedback     │  │
│  │  (Requirements,DC)  │  │  (Fluency Level)    │  │  (Consequence Text)     │  │
│  └─────────────────────┘  └─────────────────────┘  └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              APPLICATION LAYER                                   │
├─────────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │                      ICulturalProtocolService                            │    │
│  ├─────────────────────────────────────────────────────────────────────────┤    │
│  │  + GetProtocol(cultureId) : CultureProtocol?                            │    │
│  │  + GetAllProtocols() : IReadOnlyList<CultureProtocol>                   │    │
│  │  + GetCantModifier(fluency) : CantModifier                              │    │
│  │  + CheckProtocolCompliance(context) : ProtocolCheckResult               │    │
│  │  + ApplyVeilSpeechLogic(context, state) : VeilSpeechContext             │    │
│  │  + CalculateProtocolDcAdjustment(protocol, context) : int               │    │
│  │  + RecordProtocolViolation(characterId, cultureId, type) : void         │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│                                       │                                          │
│  ┌────────────────────────────────────┼────────────────────────────────────┐    │
│  │                                    ▼                                    │    │
│  │  ┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────┐ │    │
│  │  │ CulturalProtocol    │  │ VeilSpeechContext   │  │ ProtocolCheck   │ │    │
│  │  │ Service             │  │ Builder             │  │ ResultBuilder   │ │    │
│  │  └─────────────────────┘  └─────────────────────┘  └─────────────────┘ │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                DOMAIN LAYER                                      │
├─────────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐                  │
│  │   ENUMS         │  │  VALUE OBJECTS  │  │    ENTITIES     │                  │
│  ├─────────────────┤  ├─────────────────┤  ├─────────────────┤                  │
│  │ CantFluency     │  │ CantModifier    │  │ CultureProtocol │                  │
│  │ VeilSpeechState │  │ ProtocolReq     │  │                 │                  │
│  │ ProtocolViol    │  │ VeilSpeechCtx   │  │                 │                  │
│  │   ationType     │  │ ProtocolCheck   │  │                 │                  │
│  │                 │  │   Result        │  │                 │                  │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘                  │
└─────────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            INFRASTRUCTURE LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │                         Configuration Files                              │    │
│  ├─────────────────────────────────────────────────────────────────────────┤    │
│  │  cultural-protocols.json          │  cant-modifiers.json                │    │
│  │  - Protocol definitions           │  - Fluency level modifiers          │    │
│  │  - Base DCs per culture           │  - Dice pool adjustments            │    │
│  │  - Requirements text              │                                      │    │
│  │  - Violation consequences         │                                      │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Protocol Check Flow

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         PROTOCOL CHECK FLOW                                      │
└─────────────────────────────────────────────────────────────────────────────────┘

    [Social Interaction Initiated]
                │
                ▼
┌───────────────────────────────────┐
│  1. IDENTIFY CULTURE              │
├───────────────────────────────────┤
│  Extract CultureId from NPC       │
│  If no culture → skip protocol    │
└───────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────┐
│  2. FETCH PROTOCOL                │
├───────────────────────────────────┤
│  GetProtocol(cultureId)           │
│  Load requirements and base DC    │
└───────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────┐
│  3. CHECK CANT FLUENCY            │
├───────────────────────────────────┤
│  Get character's fluency level    │
│  Calculate dice modifier:         │
│  - Fluent: +1d10                  │
│  - Basic: +0                      │
│  - None: -1d10                    │
└───────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────┐
│  4. APPLY SPECIAL RULES           │
├───────────────────────────────────┤
│  If Utgard → ApplyVeilSpeechLogic │
│  - Direct truth: -2d10 penalty    │
│  - Deception: DC -4               │
│  - Proper Veil-Speech: +1d10      │
└───────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────┐
│  5. BUILD SOCIAL CONTEXT          │
├───────────────────────────────────┤
│  Inject protocol modifiers        │
│  Inject cant modifiers            │
│  Set adjusted DC                  │
└───────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────┐
│  6. EVALUATE COMPLIANCE           │
├───────────────────────────────────┤
│  Check if requirements met        │
│  Determine violation type if any  │
└───────────────────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
┌───────────────┐ ┌───────────────┐
│  COMPLIANT    │ │  VIOLATION    │
├───────────────┤ ├───────────────┤
│ Proceed with  │ │ Apply penalty │
│ social check  │ │ Record state  │
│ using context │ │ Notify player │
└───────────────┘ └───────────────┘
```

### 3.3 Veil-Speech Decision Tree

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         VEIL-SPEECH DECISION TREE                                │
└─────────────────────────────────────────────────────────────────────────────────┘

    [Interaction with Utgard NPC]
                │
                ▼
        ┌───────────────────┐
        │ Is this Deception │
        │ interaction type? │
        └───────────────────┘
                │
        ┌───────┴───────┐
        │ YES           │ NO
        ▼               ▼
┌───────────────┐ ┌───────────────────────┐
│ DC REDUCED    │ │ Is player telling     │
│ by 4          │ │ direct truth?         │
│ (Deception    │ └───────────────────────┘
│ respected)    │           │
└───────────────┘   ┌───────┴───────┐
                    │ YES           │ NO
                    ▼               ▼
            ┌───────────────┐ ┌───────────────────────┐
            │ OFFENSE       │ │ Is player using       │
            │ -2d10 on      │ │ proper Veil-Speech?   │
            │ future checks │ └───────────────────────┘
            │ with this NPC │           │
            └───────────────┘   ┌───────┴───────┐
                                │ YES           │ NO
                                ▼               ▼
                        ┌───────────────┐ ┌───────────────┐
                        │ RESPECTED     │ │ NEUTRAL       │
                        │ +1d10 bonus   │ │ No modifier   │
                        │ on this check │ │ Standard DC   │
                        └───────────────┘ └───────────────┘
```

### 3.4 Integration with SocialContext

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                    SOCIALCONTEXT INTEGRATION                                     │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│                         SocialContext (from v0.15.3a)                            │
├─────────────────────────────────────────────────────────────────────────────────┤
│  InteractionType          │  TargetId              │  TargetDisposition         │
│  TargetFactionId          │  CultureId ◄───────────┼── NEW: Links to protocol   │
│  BaseDc                   │  ModifierBreakdown     │                            │
└─────────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         ModifierBreakdown (extended)                             │
├─────────────────────────────────────────────────────────────────────────────────┤
│  Existing Modifiers:                                                             │
│  ├── Disposition Modifier (from NpcDisposition)                                 │
│  ├── Evidence Modifier (from PersuasionContext)                                 │
│  ├── Suspicion Modifier (from DeceptionContext)                                 │
│  └── Reputation Modifier (from IntimidationContext)                             │
│                                                                                  │
│  NEW Cultural Modifiers (v0.15.3g):                                             │
│  ├── CantModifier: +1d10 (Fluent) / +0 (Basic) / -1d10 (None)                  │
│  ├── ProtocolModifier: Based on compliance state                                │
│  └── VeilSpeechModifier: +1d10 (proper) / -2d10 (offense) / -4 DC (deception)  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. CantFluency Enum

### 4.1 Definition

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the level of proficiency a character has with a specific cultural cant (dialect/language).
/// </summary>
/// <remarks>
/// <para>
/// Cants are specialized dialects or coded languages used by different cultures in Aethelgard.
/// A character's fluency level directly affects their ability to communicate effectively
/// and navigate social interactions with members of that culture.
/// </para>
/// <para>
/// Fluency levels provide dice pool modifiers:
/// <list type="bullet">
///   <item><description><see cref="None"/>: -1d10 penalty (unfamiliar with the cant)</description></item>
///   <item><description><see cref="Basic"/>: No modifier (functional understanding)</description></item>
///   <item><description><see cref="Fluent"/>: +1d10 bonus (native-level proficiency)</description></item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var fluency = CantFluency.Fluent;
/// var modifier = fluency.GetDiceModifier(); // Returns +1
/// </code>
/// </example>
public enum CantFluency
{
    /// <summary>
    /// No knowledge of the cant. The character cannot understand or speak the dialect,
    /// resulting in communication difficulties and social penalties.
    /// </summary>
    /// <remarks>
    /// Applies a -1d10 penalty to all Rhetoric checks with members of this culture.
    /// The character may misinterpret idioms, miss cultural references, or accidentally
    /// cause offense through linguistic ignorance.
    /// </remarks>
    None = 0,

    /// <summary>
    /// Basic understanding of the cant. The character can communicate functional ideas
    /// but lacks nuance and may miss subtle meanings.
    /// </summary>
    /// <remarks>
    /// No modifier applied. The character can conduct basic social interactions but
    /// won't benefit from cultural linguistic advantages. Suitable for travelers
    /// who have spent limited time with the culture.
    /// </remarks>
    Basic = 1,

    /// <summary>
    /// Fluent in the cant. The character speaks with native-level proficiency,
    /// understanding idioms, cultural references, and subtle implications.
    /// </summary>
    /// <remarks>
    /// Applies a +1d10 bonus to all Rhetoric checks with members of this culture.
    /// The character can navigate complex social situations, use appropriate
    /// honorifics, and demonstrate cultural respect through language.
    /// </remarks>
    Fluent = 2
}
```

### 4.2 Extension Methods

```csharp
namespace RuneAndRust.Domain.Extensions;

/// <summary>
/// Extension methods for the <see cref="CantFluency"/> enum.
/// </summary>
public static class CantFluencyExtensions
{
    /// <summary>
    /// Gets the dice pool modifier associated with this fluency level.
    /// </summary>
    /// <param name="fluency">The fluency level.</param>
    /// <returns>
    /// The number of dice to add (positive) or remove (negative) from the pool.
    /// <list type="bullet">
    ///   <item><description><see cref="CantFluency.None"/>: -1</description></item>
    ///   <item><description><see cref="CantFluency.Basic"/>: 0</description></item>
    ///   <item><description><see cref="CantFluency.Fluent"/>: +1</description></item>
    /// </list>
    /// </returns>
    /// <example>
    /// <code>
    /// var modifier = CantFluency.Fluent.GetDiceModifier(); // Returns 1
    /// var penalty = CantFluency.None.GetDiceModifier();    // Returns -1
    /// </code>
    /// </example>
    public static int GetDiceModifier(this CantFluency fluency) => fluency switch
    {
        CantFluency.None => -1,
        CantFluency.Basic => 0,
        CantFluency.Fluent => 1,
        _ => 0
    };

    /// <summary>
    /// Gets a human-readable description of this fluency level.
    /// </summary>
    /// <param name="fluency">The fluency level.</param>
    /// <returns>A descriptive string suitable for display to the player.</returns>
    /// <example>
    /// <code>
    /// var description = CantFluency.Fluent.GetDescription(); // Returns "Fluent (+1d10)"
    /// </code>
    /// </example>
    public static string GetDescription(this CantFluency fluency) => fluency switch
    {
        CantFluency.None => "No Knowledge (-1d10)",
        CantFluency.Basic => "Basic Understanding (+0)",
        CantFluency.Fluent => "Fluent (+1d10)",
        _ => "Unknown"
    };

    /// <summary>
    /// Determines if this fluency level provides any bonus (not a penalty).
    /// </summary>
    /// <param name="fluency">The fluency level.</param>
    /// <returns><c>true</c> if the fluency provides a bonus or no penalty; otherwise, <c>false</c>.</returns>
    public static bool ProvidesBonus(this CantFluency fluency) => fluency >= CantFluency.Basic;

    /// <summary>
    /// Determines if this fluency level incurs a penalty.
    /// </summary>
    /// <param name="fluency">The fluency level.</param>
    /// <returns><c>true</c> if the fluency incurs a penalty; otherwise, <c>false</c>.</returns>
    public static bool IncursPenalty(this CantFluency fluency) => fluency == CantFluency.None;
}
```

---

## 5. VeilSpeechState Enum

### 5.1 Definition

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the current state of a character's Veil-Speech standing with Utgard NPCs.
/// </summary>
/// <remarks>
/// <para>
/// Veil-Speech is the Utgard cultural protocol where direct truth-telling is considered
/// offensive and deception is a sign of respect. This enum tracks the character's
/// current standing based on their adherence to (or violation of) this protocol.
/// </para>
/// <para>
/// State transitions:
/// <list type="bullet">
///   <item><description><see cref="Neutral"/> → <see cref="Respected"/>: Proper Veil-Speech used</description></item>
///   <item><description><see cref="Neutral"/> → <see cref="Offended"/>: Direct truth told</description></item>
///   <item><description><see cref="Offended"/> → <see cref="Neutral"/>: Requires apology or time</description></item>
///   <item><description><see cref="Respected"/> → <see cref="Neutral"/>: Decays over time without reinforcement</description></item>
/// </list>
/// </para>
/// </remarks>
public enum VeilSpeechState
{
    /// <summary>
    /// Default state. The character has neither impressed nor offended the Utgard NPC
    /// with their speech patterns. Standard interaction rules apply.
    /// </summary>
    Neutral = 0,

    /// <summary>
    /// The character has demonstrated proper Veil-Speech, layering truth within
    /// acceptable deception. This grants a +1d10 bonus on the current check.
    /// </summary>
    /// <remarks>
    /// This state is typically temporary, applying only to the current interaction.
    /// Sustained respect requires consistent Veil-Speech usage.
    /// </remarks>
    Respected = 1,

    /// <summary>
    /// The character has offended the Utgard NPC by speaking direct truth without
    /// the expected layers of deception. This applies a -2d10 penalty on future checks.
    /// </summary>
    /// <remarks>
    /// This state persists until the character makes amends or sufficient time passes.
    /// The penalty applies to all future Rhetoric checks with this specific NPC.
    /// </remarks>
    Offended = 2,

    /// <summary>
    /// The character has deeply offended the Utgard NPC through repeated or severe
    /// protocol violations. Social interaction may be impossible until resolved.
    /// </summary>
    /// <remarks>
    /// This state requires significant effort to recover from, potentially including
    /// gifts, intermediaries, or quest completion. Some NPCs may never forgive.
    /// </remarks>
    DeepOffense = 3
}
```

### 5.2 Extension Methods

```csharp
namespace RuneAndRust.Domain.Extensions;

/// <summary>
/// Extension methods for the <see cref="VeilSpeechState"/> enum.
/// </summary>
public static class VeilSpeechStateExtensions
{
    /// <summary>
    /// Gets the dice pool modifier associated with this Veil-Speech state.
    /// </summary>
    /// <param name="state">The Veil-Speech state.</param>
    /// <returns>
    /// The number of dice to add (positive) or remove (negative) from the pool.
    /// </returns>
    public static int GetDiceModifier(this VeilSpeechState state) => state switch
    {
        VeilSpeechState.Neutral => 0,
        VeilSpeechState.Respected => 1,
        VeilSpeechState.Offended => -2,
        VeilSpeechState.DeepOffense => -4,
        _ => 0
    };

    /// <summary>
    /// Determines if this state allows normal social interaction.
    /// </summary>
    /// <param name="state">The Veil-Speech state.</param>
    /// <returns><c>true</c> if interaction is possible; otherwise, <c>false</c>.</returns>
    public static bool AllowsInteraction(this VeilSpeechState state) => 
        state != VeilSpeechState.DeepOffense;

    /// <summary>
    /// Gets a human-readable description of this state.
    /// </summary>
    /// <param name="state">The Veil-Speech state.</param>
    /// <returns>A descriptive string suitable for display.</returns>
    public static string GetDescription(this VeilSpeechState state) => state switch
    {
        VeilSpeechState.Neutral => "Neutral",
        VeilSpeechState.Respected => "Respected (+1d10)",
        VeilSpeechState.Offended => "Offended (-2d10)",
        VeilSpeechState.DeepOffense => "Deeply Offended (interaction blocked)",
        _ => "Unknown"
    };

    /// <summary>
    /// Determines if this state represents an offense condition.
    /// </summary>
    /// <param name="state">The Veil-Speech state.</param>
    /// <returns><c>true</c> if the character has offended the NPC; otherwise, <c>false</c>.</returns>
    public static bool IsOffended(this VeilSpeechState state) => 
        state is VeilSpeechState.Offended or VeilSpeechState.DeepOffense;
}
```

---

## 6. ProtocolViolationType Enum

### 6.1 Definition

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categorizes the types of cultural protocol violations and their severity.
/// </summary>
/// <remarks>
/// <para>
/// Protocol violations occur when a character fails to observe the required
/// cultural formalities during social interactions. The type of violation
/// determines the consequences and recovery options.
/// </para>
/// <para>
/// Violation severity escalates from minor faux pas to severe cultural offenses:
/// <list type="bullet">
///   <item><description><see cref="None"/>: No violation occurred</description></item>
///   <item><description><see cref="Minor"/>: Small mistake, easily forgiven</description></item>
///   <item><description><see cref="Moderate"/>: Noticeable breach, requires acknowledgment</description></item>
///   <item><description><see cref="Severe"/>: Serious offense, lasting consequences</description></item>
///   <item><description><see cref="Unforgivable"/>: Permanent damage to relationship</description></item>
/// </list>
/// </para>
/// </remarks>
public enum ProtocolViolationType
{
    /// <summary>
    /// No violation occurred. The character successfully observed the protocol
    /// or the interaction did not require protocol compliance.
    /// </summary>
    None = 0,

    /// <summary>
    /// A minor violation such as incorrect honorifics or slight timing errors.
    /// Easily overlooked or forgiven with a brief apology.
    /// </summary>
    /// <remarks>
    /// Consequences: +2 DC on next check with this NPC.
    /// Recovery: Automatic after one successful interaction.
    /// </remarks>
    Minor = 1,

    /// <summary>
    /// A moderate violation such as skipping required formalities or showing
    /// impatience during required rituals.
    /// </summary>
    /// <remarks>
    /// Consequences: +4 DC on future checks, minor disposition loss.
    /// Recovery: Requires explicit acknowledgment or small gesture.
    /// </remarks>
    Moderate = 2,

    /// <summary>
    /// A severe violation such as direct insult to cultural values or
    /// complete disregard for sacred protocols.
    /// </summary>
    /// <remarks>
    /// Consequences: -2d10 on future checks, significant disposition loss, possible hostility.
    /// Recovery: Requires significant effort, gifts, or intermediary.
    /// </remarks>
    Severe = 3,

    /// <summary>
    /// An unforgivable violation that permanently damages the relationship.
    /// Examples include desecration of sacred objects or betrayal of trust.
    /// </summary>
    /// <remarks>
    /// Consequences: Permanent hostility, faction reputation loss, possible combat.
    /// Recovery: Generally impossible with this NPC; may affect entire faction.
    /// </remarks>
    Unforgivable = 4
}
```

### 6.2 Extension Methods

```csharp
namespace RuneAndRust.Domain.Extensions;

/// <summary>
/// Extension methods for the <see cref="ProtocolViolationType"/> enum.
/// </summary>
public static class ProtocolViolationTypeExtensions
{
    /// <summary>
    /// Gets the DC adjustment caused by this violation type.
    /// </summary>
    /// <param name="violation">The violation type.</param>
    /// <returns>The amount to add to future check DCs.</returns>
    public static int GetDcAdjustment(this ProtocolViolationType violation) => violation switch
    {
        ProtocolViolationType.None => 0,
        ProtocolViolationType.Minor => 2,
        ProtocolViolationType.Moderate => 4,
        ProtocolViolationType.Severe => 6,
        ProtocolViolationType.Unforgivable => int.MaxValue, // Interaction blocked
        _ => 0
    };

    /// <summary>
    /// Gets the dice pool penalty caused by this violation type.
    /// </summary>
    /// <param name="violation">The violation type.</param>
    /// <returns>The number of dice to remove from the pool (as a positive number).</returns>
    public static int GetDicePenalty(this ProtocolViolationType violation) => violation switch
    {
        ProtocolViolationType.None => 0,
        ProtocolViolationType.Minor => 0,
        ProtocolViolationType.Moderate => 1,
        ProtocolViolationType.Severe => 2,
        ProtocolViolationType.Unforgivable => 0, // N/A - interaction blocked
        _ => 0
    };

    /// <summary>
    /// Gets the disposition change caused by this violation.
    /// </summary>
    /// <param name="violation">The violation type.</param>
    /// <returns>The disposition change (negative values indicate loss).</returns>
    public static int GetDispositionChange(this ProtocolViolationType violation) => violation switch
    {
        ProtocolViolationType.None => 0,
        ProtocolViolationType.Minor => -5,
        ProtocolViolationType.Moderate => -15,
        ProtocolViolationType.Severe => -30,
        ProtocolViolationType.Unforgivable => -100,
        _ => 0
    };

    /// <summary>
    /// Determines if this violation blocks further interaction.
    /// </summary>
    /// <param name="violation">The violation type.</param>
    /// <returns><c>true</c> if interaction is blocked; otherwise, <c>false</c>.</returns>
    public static bool BlocksInteraction(this ProtocolViolationType violation) => 
        violation == ProtocolViolationType.Unforgivable;

    /// <summary>
    /// Determines if this violation can be recovered from.
    /// </summary>
    /// <param name="violation">The violation type.</param>
    /// <returns><c>true</c> if recovery is possible; otherwise, <c>false</c>.</returns>
    public static bool IsRecoverable(this ProtocolViolationType violation) => 
        violation != ProtocolViolationType.Unforgivable;

    /// <summary>
    /// Gets a human-readable description of this violation type.
    /// </summary>
    /// <param name="violation">The violation type.</param>
    /// <returns>A descriptive string suitable for display.</returns>
    public static string GetDescription(this ProtocolViolationType violation) => violation switch
    {
        ProtocolViolationType.None => "No violation",
        ProtocolViolationType.Minor => "Minor faux pas",
        ProtocolViolationType.Moderate => "Protocol breach",
        ProtocolViolationType.Severe => "Serious offense",
        ProtocolViolationType.Unforgivable => "Unforgivable transgression",
        _ => "Unknown"
    };
}
```

---

## 7. CantModifier Value Object

### 7.1 Definition

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the dice pool modifier applied based on a character's fluency in a cultural cant.
/// </summary>
/// <remarks>
/// <para>
/// This value object encapsulates the relationship between a <see cref="CantFluency"/> level
/// and its corresponding dice pool modifier. It provides a type-safe way to pass cant-based
/// modifiers through the social interaction system.
/// </para>
/// <para>
/// The modifier values are:
/// <list type="bullet">
///   <item><description>Fluent: +1 die to the pool</description></item>
///   <item><description>Basic: No modification</description></item>
///   <item><description>None: -1 die from the pool</description></item>
/// </list>
/// </para>
/// </remarks>
/// <param name="Fluency">The character's fluency level in the target culture's cant.</param>
/// <param name="DiceModifier">The number of dice to add (positive) or remove (negative).</param>
/// <param name="CultureId">The culture this modifier applies to.</param>
/// <param name="CantName">The name of the cant (e.g., "Dvergr Trade-Tongue").</param>
public readonly record struct CantModifier(
    CantFluency Fluency,
    int DiceModifier,
    string CultureId,
    string CantName)
{
    /// <summary>
    /// Creates a CantModifier from a fluency level, automatically calculating the dice modifier.
    /// </summary>
    /// <param name="fluency">The fluency level.</param>
    /// <param name="cultureId">The culture identifier.</param>
    /// <param name="cantName">The name of the cant.</param>
    /// <returns>A new CantModifier with the appropriate dice modifier.</returns>
    public static CantModifier FromFluency(CantFluency fluency, string cultureId, string cantName) =>
        new(fluency, fluency.GetDiceModifier(), cultureId, cantName);

    /// <summary>
    /// Creates a neutral modifier (no effect) for cultures without cant requirements.
    /// </summary>
    /// <param name="cultureId">The culture identifier.</param>
    /// <returns>A CantModifier with zero effect.</returns>
    public static CantModifier Neutral(string cultureId) =>
        new(CantFluency.Basic, 0, cultureId, "Common");

    /// <summary>
    /// Indicates whether this modifier provides a bonus to the dice pool.
    /// </summary>
    public bool IsBonus => DiceModifier > 0;

    /// <summary>
    /// Indicates whether this modifier applies a penalty to the dice pool.
    /// </summary>
    public bool IsPenalty => DiceModifier < 0;

    /// <summary>
    /// Indicates whether this modifier has no effect on the dice pool.
    /// </summary>
    public bool IsNeutral => DiceModifier == 0;

    /// <summary>
    /// Creates a display string for UI presentation.
    /// </summary>
    /// <returns>A formatted string showing the cant name and modifier.</returns>
    public string ToDisplayString() => DiceModifier switch
    {
        > 0 => $"{CantName}: +{DiceModifier}d10 (Fluent)",
        < 0 => $"{CantName}: {DiceModifier}d10 (Unfamiliar)",
        _ => $"{CantName}: No modifier (Basic)"
    };

    /// <summary>
    /// Converts this modifier to a <see cref="SocialModifier"/> for integration with the social context.
    /// </summary>
    /// <returns>A SocialModifier representing this cant bonus/penalty.</returns>
    public SocialModifier ToSocialModifier() => new(
        Source: $"Cant: {CantName}",
        DiceModifier: DiceModifier,
        DcModifier: 0,
        ApplicableTypes: null, // Applies to all social interaction types
        Description: Fluency.GetDescription());
}
```

---

## 8. ProtocolRequirement Value Object

### 8.1 Definition

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Encapsulates the requirements for observing a cultural protocol.
/// </summary>
/// <param name="RequirementText">Human-readable description of what the protocol requires.</param>
/// <param name="RequirementType">The category of requirement (behavioral, verbal, offering, etc.).</param>
/// <param name="IsMandatory">Whether failure to meet this requirement triggers a violation.</param>
/// <param name="SkillCheck">Optional skill check required to fulfill the requirement.</param>
public readonly record struct ProtocolRequirement(
    string RequirementText,
    ProtocolRequirementType RequirementType,
    bool IsMandatory,
    SkillCheckRequirement? SkillCheck)
{
    /// <summary>
    /// Creates a behavioral requirement (e.g., "Listen patiently").
    /// </summary>
    public static ProtocolRequirement Behavioral(string text, bool mandatory = true) =>
        new(text, ProtocolRequirementType.Behavioral, mandatory, null);

    /// <summary>
    /// Creates a verbal requirement (e.g., "Use formal address").
    /// </summary>
    public static ProtocolRequirement Verbal(string text, bool mandatory = true) =>
        new(text, ProtocolRequirementType.Verbal, mandatory, null);

    /// <summary>
    /// Creates an offering requirement (e.g., "Present martial tribute").
    /// </summary>
    public static ProtocolRequirement Offering(string text, bool mandatory = true) =>
        new(text, ProtocolRequirementType.Offering, mandatory, null);

    /// <summary>
    /// Creates a mental requirement (e.g., "Open mind to telepathy").
    /// </summary>
    public static ProtocolRequirement Mental(string text, bool mandatory = true) =>
        new(text, ProtocolRequirementType.Mental, mandatory, null);
}

/// <summary>
/// Categories of protocol requirements.
/// </summary>
public enum ProtocolRequirementType
{
    /// <summary>Actions or behaviors required (patience, posture, etc.).</summary>
    Behavioral,
    /// <summary>Speech patterns or verbal formulas required.</summary>
    Verbal,
    /// <summary>Physical offerings or gifts required.</summary>
    Offering,
    /// <summary>Mental state or openness required.</summary>
    Mental,
    /// <summary>Specific sequence of actions required.</summary>
    Ritual
}

/// <summary>
/// Optional skill check associated with a protocol requirement.
/// </summary>
public readonly record struct SkillCheckRequirement(
    string SkillId,
    int Dc,
    string FailureConsequence);
```

---

## 9. VeilSpeechContext Value Object

### 9.1 Definition

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Captures the context and modifiers for Utgard Veil-Speech interactions.
/// </summary>
/// <remarks>
/// <para>
/// Veil-Speech is the Utgard cultural protocol where direct truth-telling is offensive
/// and deception is respected. This value object tracks the current state and calculates
/// appropriate modifiers for social checks with Utgard NPCs.
/// </para>
/// </remarks>
/// <param name="CurrentState">The character's current Veil-Speech standing.</param>
/// <param name="IsUsingDeception">Whether the current interaction uses deception.</param>
/// <param name="IsTellingDirectTruth">Whether the character is speaking direct truth.</param>
/// <param name="IsUsingProperVeilSpeech">Whether the character is using proper Veil-Speech form.</param>
/// <param name="NpcId">The Utgard NPC being interacted with.</param>
public readonly record struct VeilSpeechContext(
    VeilSpeechState CurrentState,
    bool IsUsingDeception,
    bool IsTellingDirectTruth,
    bool IsUsingProperVeilSpeech,
    string NpcId)
{
    /// <summary>
    /// The DC reduction applied when using deception with Utgard NPCs.
    /// </summary>
    public const int DeceptionDcReduction = 4;

    /// <summary>
    /// The dice bonus for using proper Veil-Speech.
    /// </summary>
    public const int ProperVeilSpeechBonus = 1;

    /// <summary>
    /// The dice penalty for telling direct truth.
    /// </summary>
    public const int DirectTruthPenalty = -2;

    /// <summary>
    /// Calculates the DC adjustment for this Veil-Speech context.
    /// </summary>
    public int GetDcAdjustment() => IsUsingDeception ? -DeceptionDcReduction : 0;

    /// <summary>
    /// Calculates the dice pool modifier for this Veil-Speech context.
    /// </summary>
    public int GetDiceModifier()
    {
        if (IsTellingDirectTruth) return DirectTruthPenalty;
        if (IsUsingProperVeilSpeech) return ProperVeilSpeechBonus;
        return CurrentState.GetDiceModifier();
    }

    /// <summary>
    /// Determines the resulting Veil-Speech state after this interaction.
    /// </summary>
    public VeilSpeechState GetResultingState()
    {
        if (IsTellingDirectTruth)
            return CurrentState == VeilSpeechState.Offended 
                ? VeilSpeechState.DeepOffense 
                : VeilSpeechState.Offended;
        if (IsUsingProperVeilSpeech)
            return VeilSpeechState.Respected;
        return CurrentState;
    }

    /// <summary>
    /// Creates a neutral context for non-Utgard interactions.
    /// </summary>
    public static VeilSpeechContext NotApplicable() =>
        new(VeilSpeechState.Neutral, false, false, false, string.Empty);

    /// <summary>
    /// Converts to a SocialModifier for context integration.
    /// </summary>
    public SocialModifier ToSocialModifier() => new(
        Source: "Veil-Speech",
        DiceModifier: GetDiceModifier(),
        DcModifier: GetDcAdjustment(),
        ApplicableTypes: null,
        Description: GetDescription());

    private string GetDescription() => (IsTellingDirectTruth, IsUsingProperVeilSpeech, IsUsingDeception) switch
    {
        (true, _, _) => "Direct truth offends (-2d10)",
        (_, true, _) => "Proper Veil-Speech (+1d10)",
        (_, _, true) => "Deception respected (DC -4)",
        _ => CurrentState.GetDescription()
    };
}
```

---

## 10. ProtocolCheckResult Value Object

### 10.1 Definition

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Captures the result of evaluating protocol compliance for a social interaction.
/// </summary>
/// <param name="IsCompliant">Whether the character met the protocol requirements.</param>
/// <param name="ViolationType">The type of violation if non-compliant.</param>
/// <param name="Protocol">The protocol that was evaluated.</param>
/// <param name="AppliedModifiers">All modifiers applied from protocol evaluation.</param>
/// <param name="ConsequenceDescription">Human-readable description of consequences.</param>
/// <param name="DispositionChange">Change to NPC disposition from this check.</param>
/// <param name="DcAdjustment">Adjustment to the social check DC.</param>
public readonly record struct ProtocolCheckResult(
    bool IsCompliant,
    ProtocolViolationType ViolationType,
    CultureProtocol? Protocol,
    IReadOnlyList<SocialModifier> AppliedModifiers,
    string ConsequenceDescription,
    int DispositionChange,
    int DcAdjustment)
{
    /// <summary>
    /// Creates a successful compliance result.
    /// </summary>
    public static ProtocolCheckResult Compliant(CultureProtocol protocol, IReadOnlyList<SocialModifier> modifiers) =>
        new(true, ProtocolViolationType.None, protocol, modifiers, "Protocol observed correctly.", 0, 0);

    /// <summary>
    /// Creates a violation result with appropriate consequences.
    /// </summary>
    public static ProtocolCheckResult Violation(
        CultureProtocol protocol,
        ProtocolViolationType type,
        IReadOnlyList<SocialModifier> modifiers) =>
        new(
            false,
            type,
            protocol,
            modifiers,
            protocol.ViolationConsequence,
            type.GetDispositionChange(),
            type.GetDcAdjustment());

    /// <summary>
    /// Creates a result for interactions with no protocol requirements.
    /// </summary>
    public static ProtocolCheckResult NoProtocol() =>
        new(true, ProtocolViolationType.None, null, Array.Empty<SocialModifier>(), "No protocol required.", 0, 0);

    /// <summary>
    /// Indicates whether this result blocks further interaction.
    /// </summary>
    public bool BlocksInteraction => ViolationType.BlocksInteraction();

    /// <summary>
    /// Gets the total dice modifier from all applied modifiers.
    /// </summary>
    public int TotalDiceModifier => AppliedModifiers.Sum(m => m.DiceModifier);
}
```

---

## 11. CultureProtocol Entity

### 11.1 Definition

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a cultural protocol - the formal rules and requirements for social interaction
/// with members of a specific culture in Aethelgard.
/// </summary>
/// <remarks>
/// <para>
/// Each major culture has unique social protocols that characters must observe to interact
/// successfully. Failure to observe these protocols results in social penalties ranging
/// from minor embarrassment to permanent relationship damage.
/// </para>
/// <para>
/// Defined protocols:
/// <list type="bullet">
///   <item><description>Dvergr Logic-Chain (DC 18): Precise, non-contradictory argument sequences</description></item>
///   <item><description>Utgard Veil-Speech (DC 16): Layer truth within acceptable deception</description></item>
///   <item><description>Gorge-Maw Patience (DC 14): Listen to extended rumbling discourse</description></item>
///   <item><description>Rune-Lupin Telepathy (DC 12): Open mind and suppress hostility</description></item>
///   <item><description>Iron-Bane Tribute (DC 16): Offer martial tribute before speaking</description></item>
/// </list>
/// </para>
/// </remarks>
public class CultureProtocol
{
    /// <summary>
    /// Unique identifier for the culture (e.g., "Dvergr", "Utgard").
    /// </summary>
    public string CultureId { get; private set; } = string.Empty;

    /// <summary>
    /// The name of this protocol (e.g., "Logic-Chain", "Veil-Speech").
    /// </summary>
    public string ProtocolName { get; private set; } = string.Empty;

    /// <summary>
    /// The base difficulty class for successfully observing this protocol.
    /// </summary>
    public int BaseDc { get; private set; }

    /// <summary>
    /// Human-readable description of what the protocol requires.
    /// </summary>
    public string Requirements { get; private set; } = string.Empty;

    /// <summary>
    /// Description of consequences for violating this protocol.
    /// </summary>
    public string ViolationConsequence { get; private set; } = string.Empty;

    /// <summary>
    /// The name of the cant associated with this culture.
    /// </summary>
    public string CantName { get; private set; } = string.Empty;

    /// <summary>
    /// Whether this protocol has special rules (like Utgard Veil-Speech).
    /// </summary>
    public bool HasSpecialRules { get; private set; }

    /// <summary>
    /// The type of special rules, if any.
    /// </summary>
    public SpecialProtocolType? SpecialRuleType { get; private set; }

    /// <summary>
    /// Detailed requirements for this protocol.
    /// </summary>
    public IReadOnlyList<ProtocolRequirement> DetailedRequirements { get; private set; } = Array.Empty<ProtocolRequirement>();

    // Private constructor for EF Core
    private CultureProtocol() { }

    /// <summary>
    /// Creates a new CultureProtocol.
    /// </summary>
    public static CultureProtocol Create(
        string cultureId,
        string protocolName,
        int baseDc,
        string requirements,
        string violationConsequence,
        string cantName,
        SpecialProtocolType? specialRuleType = null,
        IReadOnlyList<ProtocolRequirement>? detailedRequirements = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(cultureId);
        ArgumentException.ThrowIfNullOrWhiteSpace(protocolName);
        ArgumentOutOfRangeException.ThrowIfLessThan(baseDc, 1);

        return new CultureProtocol
        {
            CultureId = cultureId,
            ProtocolName = protocolName,
            BaseDc = baseDc,
            Requirements = requirements,
            ViolationConsequence = violationConsequence,
            CantName = cantName,
            HasSpecialRules = specialRuleType.HasValue,
            SpecialRuleType = specialRuleType,
            DetailedRequirements = detailedRequirements ?? Array.Empty<ProtocolRequirement>()
        };
    }

    /// <summary>
    /// Determines if this is the Utgard Veil-Speech protocol.
    /// </summary>
    public bool IsVeilSpeech => SpecialRuleType == SpecialProtocolType.VeilSpeech;
}

/// <summary>
/// Types of special protocol rules.
/// </summary>
public enum SpecialProtocolType
{
    /// <summary>Utgard Veil-Speech: deception is respect, truth offends.</summary>
    VeilSpeech,
    /// <summary>Rune-Lupin Telepathy: requires mental openness.</summary>
    Telepathy,
    /// <summary>Dvergr Logic-Chain: requires logical consistency.</summary>
    LogicChain
}
```

---

## 12. ICulturalProtocolService Interface

### 12.1 Definition

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Manages cultural protocols and cant-based modifiers for social interactions.
/// </summary>
public interface ICulturalProtocolService
{
    /// <summary>
    /// Gets the protocol for a specific culture.
    /// </summary>
    /// <param name="cultureId">The culture identifier.</param>
    /// <returns>The protocol if found; otherwise, null.</returns>
    CultureProtocol? GetProtocol(string cultureId);

    /// <summary>
    /// Gets all defined cultural protocols.
    /// </summary>
    IReadOnlyList<CultureProtocol> GetAllProtocols();

    /// <summary>
    /// Calculates the cant modifier for a character's fluency level.
    /// </summary>
    /// <param name="fluency">The character's fluency level.</param>
    /// <param name="cultureId">The target culture.</param>
    /// <returns>The cant modifier to apply.</returns>
    CantModifier GetCantModifier(CantFluency fluency, string cultureId);

    /// <summary>
    /// Checks protocol compliance for a social interaction.
    /// </summary>
    /// <param name="characterId">The character attempting the interaction.</param>
    /// <param name="cultureId">The target culture.</param>
    /// <param name="context">The social context.</param>
    /// <returns>The result of the protocol compliance check.</returns>
    ProtocolCheckResult CheckProtocolCompliance(string characterId, string cultureId, SocialContext context);

    /// <summary>
    /// Applies Veil-Speech logic for Utgard interactions.
    /// </summary>
    /// <param name="npcId">The Utgard NPC.</param>
    /// <param name="isDeception">Whether using deception.</param>
    /// <param name="isDirectTruth">Whether telling direct truth.</param>
    /// <param name="isProperVeilSpeech">Whether using proper Veil-Speech.</param>
    /// <returns>The Veil-Speech context with modifiers.</returns>
    VeilSpeechContext ApplyVeilSpeechLogic(string npcId, bool isDeception, bool isDirectTruth, bool isProperVeilSpeech);

    /// <summary>
    /// Records a protocol violation for tracking.
    /// </summary>
    void RecordProtocolViolation(string characterId, string cultureId, ProtocolViolationType type);

    /// <summary>
    /// Gets the character's current Veil-Speech state with an NPC.
    /// </summary>
    VeilSpeechState GetVeilSpeechState(string characterId, string npcId);
}
```

---

## 13. CulturalProtocolService Implementation

### 13.1 Definition

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Implementation of cultural protocol management for social interactions.
/// </summary>
public class CulturalProtocolService : ICulturalProtocolService
{
    private readonly ILogger<CulturalProtocolService> _logger;
    private readonly IOptions<CulturalProtocolOptions> _options;
    private readonly Dictionary<string, CultureProtocol> _protocols;
    private readonly Dictionary<(string CharacterId, string NpcId), VeilSpeechState> _veilSpeechStates;

    public CulturalProtocolService(
        ILogger<CulturalProtocolService> logger,
        IOptions<CulturalProtocolOptions> options)
    {
        _logger = logger;
        _options = options;
        _protocols = LoadProtocols();
        _veilSpeechStates = new Dictionary<(string, string), VeilSpeechState>();
    }

    /// <inheritdoc />
    public CultureProtocol? GetProtocol(string cultureId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(cultureId);
        
        _protocols.TryGetValue(cultureId, out var protocol);
        
        _logger.LogDebug(
            "Retrieved protocol for culture {CultureId}: {Found}",
            cultureId,
            protocol != null);
            
        return protocol;
    }

    /// <inheritdoc />
    public IReadOnlyList<CultureProtocol> GetAllProtocols() => _protocols.Values.ToList();

    /// <inheritdoc />
    public CantModifier GetCantModifier(CantFluency fluency, string cultureId)
    {
        var protocol = GetProtocol(cultureId);
        var cantName = protocol?.CantName ?? "Common";
        
        var modifier = CantModifier.FromFluency(fluency, cultureId, cantName);
        
        _logger.LogDebug(
            "Calculated cant modifier for {CultureId}: {Fluency} = {Modifier}d10",
            cultureId,
            fluency,
            modifier.DiceModifier);
            
        return modifier;
    }

    /// <inheritdoc />
    public ProtocolCheckResult CheckProtocolCompliance(
        string characterId,
        string cultureId,
        SocialContext context)
    {
        var protocol = GetProtocol(cultureId);
        if (protocol == null)
        {
            _logger.LogDebug("No protocol found for culture {CultureId}", cultureId);
            return ProtocolCheckResult.NoProtocol();
        }

        var modifiers = new List<SocialModifier>();
        
        // Add cant modifier
        var cantFluency = GetCharacterCantFluency(characterId, cultureId);
        var cantModifier = GetCantModifier(cantFluency, cultureId);
        modifiers.Add(cantModifier.ToSocialModifier());

        // Check for Veil-Speech special rules
        if (protocol.IsVeilSpeech)
        {
            var veilSpeechContext = ApplyVeilSpeechLogic(
                context.TargetId,
                context.InteractionType == SocialInteractionType.Deception,
                false, // Would need to be determined from dialogue choice
                false);
            modifiers.Add(veilSpeechContext.ToSocialModifier());
        }

        // Evaluate compliance (simplified - full implementation would check requirements)
        var isCompliant = EvaluateRequirements(protocol, context);
        
        if (isCompliant)
        {
            _logger.LogInformation(
                "Character {CharacterId} complied with {Protocol} protocol",
                characterId,
                protocol.ProtocolName);
            return ProtocolCheckResult.Compliant(protocol, modifiers);
        }
        
        var violationType = DetermineViolationType(protocol, context);
        _logger.LogWarning(
            "Character {CharacterId} violated {Protocol} protocol: {ViolationType}",
            characterId,
            protocol.ProtocolName,
            violationType);
            
        return ProtocolCheckResult.Violation(protocol, violationType, modifiers);
    }

    /// <inheritdoc />
    public VeilSpeechContext ApplyVeilSpeechLogic(
        string npcId,
        bool isDeception,
        bool isDirectTruth,
        bool isProperVeilSpeech)
    {
        var currentState = GetVeilSpeechState(string.Empty, npcId);
        
        var context = new VeilSpeechContext(
            currentState,
            isDeception,
            isDirectTruth,
            isProperVeilSpeech,
            npcId);

        _logger.LogDebug(
            "Applied Veil-Speech logic for NPC {NpcId}: Deception={IsDeception}, " +
            "DirectTruth={IsDirectTruth}, ProperVeilSpeech={IsProper}, " +
            "DiceModifier={DiceMod}, DcAdjustment={DcAdj}",
            npcId,
            isDeception,
            isDirectTruth,
            isProperVeilSpeech,
            context.GetDiceModifier(),
            context.GetDcAdjustment());

        return context;
    }

    /// <inheritdoc />
    public void RecordProtocolViolation(
        string characterId,
        string cultureId,
        ProtocolViolationType type)
    {
        _logger.LogWarning(
            "Recording protocol violation: Character={CharacterId}, Culture={CultureId}, Type={Type}",
            characterId,
            cultureId,
            type);
            
        // Implementation would persist this to game state
    }

    /// <inheritdoc />
    public VeilSpeechState GetVeilSpeechState(string characterId, string npcId)
    {
        var key = (characterId, npcId);
        return _veilSpeechStates.TryGetValue(key, out var state) 
            ? state 
            : VeilSpeechState.Neutral;
    }

    private Dictionary<string, CultureProtocol> LoadProtocols()
    {
        var protocols = new Dictionary<string, CultureProtocol>(StringComparer.OrdinalIgnoreCase);
        
        foreach (var config in _options.Value.Protocols)
        {
            var protocol = CultureProtocol.Create(
                config.CultureId,
                config.ProtocolName,
                config.BaseDc,
                config.Requirements,
                config.ViolationConsequence,
                config.CantName,
                config.SpecialRuleType);
                
            protocols[config.CultureId] = protocol;
        }
        
        _logger.LogInformation("Loaded {Count} cultural protocols", protocols.Count);
        return protocols;
    }

    private CantFluency GetCharacterCantFluency(string characterId, string cultureId)
    {
        // Implementation would look up character's cant knowledge
        // For now, return Basic as default
        return CantFluency.Basic;
    }

    private bool EvaluateRequirements(CultureProtocol protocol, SocialContext context)
    {
        // Implementation would check each requirement against context
        return true;
    }

    private ProtocolViolationType DetermineViolationType(CultureProtocol protocol, SocialContext context)
    {
        // Implementation would analyze the nature of the violation
        return ProtocolViolationType.Minor;
    }
}
```

### 13.2 Configuration Options Class

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration options for cultural protocols.
/// </summary>
public class CulturalProtocolOptions
{
    /// <summary>
    /// Configuration section name.
    /// </summary>
    public const string SectionName = "CulturalProtocols";

    /// <summary>
    /// List of protocol configurations.
    /// </summary>
    public List<ProtocolConfig> Protocols { get; set; } = new();

    /// <summary>
    /// Cant modifier configurations.
    /// </summary>
    public CantModifierConfig CantModifiers { get; set; } = new();
}

/// <summary>
/// Configuration for a single protocol.
/// </summary>
public class ProtocolConfig
{
    public string CultureId { get; set; } = string.Empty;
    public string ProtocolName { get; set; } = string.Empty;
    public int BaseDc { get; set; }
    public string Requirements { get; set; } = string.Empty;
    public string ViolationConsequence { get; set; } = string.Empty;
    public string CantName { get; set; } = string.Empty;
    public SpecialProtocolType? SpecialRuleType { get; set; }
}

/// <summary>
/// Configuration for cant modifiers.
/// </summary>
public class CantModifierConfig
{
    public int None { get; set; } = -1;
    public int Basic { get; set; } = 0;
    public int Fluent { get; set; } = 1;
}
```

---

## 14. Configuration

### 14.1 cultural-protocols.json

```json
{
  "CulturalProtocols": {
    "Protocols": [
      {
        "CultureId": "Dvergr",
        "ProtocolName": "Logic-Chain",
        "BaseDc": 18,
        "Requirements": "Precise, non-contradictory sequences. Arguments must follow logical progression without emotional appeals or circular reasoning.",
        "ViolationConsequence": "Dismissal of argument as irrational. The Dvergr will refuse to engage further until you demonstrate logical competence.",
        "CantName": "Dvergr Trade-Tongue",
        "SpecialRuleType": "LogicChain",
        "DetailedRequirements": [
          {
            "RequirementText": "Present premises before conclusions",
            "RequirementType": "Verbal",
            "IsMandatory": true
          },
          {
            "RequirementText": "Avoid emotional appeals",
            "RequirementType": "Behavioral",
            "IsMandatory": true
          },
          {
            "RequirementText": "Acknowledge counterarguments",
            "RequirementType": "Verbal",
            "IsMandatory": false
          }
        ]
      },
      {
        "CultureId": "Utgard",
        "ProtocolName": "Veil-Speech",
        "BaseDc": 16,
        "Requirements": "Layer truth in deception. Direct statements are considered crude and offensive. Wrap your meaning in metaphor and misdirection.",
        "ViolationConsequence": "Social offense. Direct truth-telling marks you as unsophisticated. -2d10 on future checks with this NPC.",
        "CantName": "Utgard Shadow-Tongue",
        "SpecialRuleType": "VeilSpeech",
        "DetailedRequirements": [
          {
            "RequirementText": "Never state intentions directly",
            "RequirementType": "Verbal",
            "IsMandatory": true
          },
          {
            "RequirementText": "Use metaphor and allegory",
            "RequirementType": "Verbal",
            "IsMandatory": true
          },
          {
            "RequirementText": "Acknowledge the game being played",
            "RequirementType": "Behavioral",
            "IsMandatory": false
          }
        ]
      },
      {
        "CultureId": "Gorge-Maw",
        "ProtocolName": "Patience",
        "BaseDc": 14,
        "Requirements": "Listen to 10+ minute rumble. The Gorge-Maw communicate through extended, resonant vocalizations. Interruption is the gravest insult.",
        "ViolationConsequence": "Perceived arrogance triggers immediate hostility. The Gorge-Maw may attack or refuse all future interaction.",
        "CantName": "Gorge-Maw Rumble",
        "DetailedRequirements": [
          {
            "RequirementText": "Remain silent during rumble",
            "RequirementType": "Behavioral",
            "IsMandatory": true
          },
          {
            "RequirementText": "Maintain eye contact",
            "RequirementType": "Behavioral",
            "IsMandatory": true
          },
          {
            "RequirementText": "Respond with brief acknowledgment rumble",
            "RequirementType": "Verbal",
            "IsMandatory": false
          }
        ]
      },
      {
        "CultureId": "Rune-Lupin",
        "ProtocolName": "Telepathy",
        "BaseDc": 12,
        "Requirements": "Open mind, suppress hostility. The Rune-Lupin communicate through limited telepathy. Mental barriers or hostile thoughts cause painful feedback.",
        "ViolationConsequence": "Psychic feedback causes +2 Stress. Repeated violations may result in permanent telepathic block.",
        "CantName": "Lupin Mind-Speech",
        "SpecialRuleType": "Telepathy",
        "DetailedRequirements": [
          {
            "RequirementText": "Lower mental defenses",
            "RequirementType": "Mental",
            "IsMandatory": true
          },
          {
            "RequirementText": "Suppress hostile or deceptive thoughts",
            "RequirementType": "Mental",
            "IsMandatory": true
          },
          {
            "RequirementText": "Project calm emotional state",
            "RequirementType": "Mental",
            "IsMandatory": false
          }
        ]
      },
      {
        "CultureId": "Iron-Bane",
        "ProtocolName": "Tribute",
        "BaseDc": 16,
        "Requirements": "Offer martial tribute first. Before any negotiation, you must demonstrate martial worth through a gift of weapons, armor, or combat prowess.",
        "ViolationConsequence": "Viewed as weakling unworthy of respect. DC +4 on all checks. May be challenged to prove worth through combat.",
        "CantName": "Iron-Bane War-Cant",
        "DetailedRequirements": [
          {
            "RequirementText": "Present weapon or armor as gift",
            "RequirementType": "Offering",
            "IsMandatory": true
          },
          {
            "RequirementText": "Describe a personal battle victory",
            "RequirementType": "Verbal",
            "IsMandatory": false
          },
          {
            "RequirementText": "Accept challenge if offered",
            "RequirementType": "Behavioral",
            "IsMandatory": true
          }
        ]
      }
    ],
    "CantModifiers": {
      "None": -1,
      "Basic": 0,
      "Fluent": 1
    },
    "VeilSpeechRules": {
      "DeceptionDcReduction": 4,
      "ProperVeilSpeechBonus": 1,
      "DirectTruthPenalty": -2,
      "OffenseEscalationThreshold": 2
    }
  }
}
```

### 14.2 cant-modifiers.json

```json
{
  "CantModifiers": {
    "None": {
      "DiceModifier": -1,
      "Description": "No knowledge of the cant",
      "DisplayText": "Unfamiliar (-1d10)"
    },
    "Basic": {
      "DiceModifier": 0,
      "Description": "Basic understanding of the cant",
      "DisplayText": "Basic Understanding (+0)"
    },
    "Fluent": {
      "DiceModifier": 1,
      "Description": "Fluent in the cant",
      "DisplayText": "Fluent (+1d10)"
    }
  },
  "CultureCants": {
    "Dvergr": "Dvergr Trade-Tongue",
    "Utgard": "Utgard Shadow-Tongue",
    "Gorge-Maw": "Gorge-Maw Rumble",
    "Rune-Lupin": "Lupin Mind-Speech",
    "Iron-Bane": "Iron-Bane War-Cant"
  }
}
```

### 14.3 Configuration Schema

| Property | Type | Required | Default | Description |
|----------|------|----------|---------|-------------|
| `Protocols` | `ProtocolConfig[]` | Yes | - | Array of protocol definitions |
| `Protocols[].CultureId` | `string` | Yes | - | Unique culture identifier |
| `Protocols[].ProtocolName` | `string` | Yes | - | Display name of the protocol |
| `Protocols[].BaseDc` | `int` | Yes | - | Base difficulty class (1-30) |
| `Protocols[].Requirements` | `string` | Yes | - | Human-readable requirements |
| `Protocols[].ViolationConsequence` | `string` | Yes | - | Consequence description |
| `Protocols[].CantName` | `string` | Yes | - | Associated cant name |
| `Protocols[].SpecialRuleType` | `string?` | No | `null` | Special rule type if any |
| `CantModifiers.None` | `int` | Yes | `-1` | Dice modifier for no knowledge |
| `CantModifiers.Basic` | `int` | Yes | `0` | Dice modifier for basic knowledge |
| `CantModifiers.Fluent` | `int` | Yes | `1` | Dice modifier for fluent knowledge |
| `VeilSpeechRules.DeceptionDcReduction` | `int` | Yes | `4` | DC reduction for deception |
| `VeilSpeechRules.ProperVeilSpeechBonus` | `int` | Yes | `1` | Dice bonus for proper Veil-Speech |
| `VeilSpeechRules.DirectTruthPenalty` | `int` | Yes | `-2` | Dice penalty for direct truth |

---

## 15. Commands

### 15.1 Command Changes

No new commands are introduced in v0.15.3g. Cultural protocols are automatically applied when social interactions occur with NPCs that have an assigned `CultureId`. The existing social commands from v0.15.3a-f will now include cultural context.

### 15.2 Integration with Existing Commands

| Command | Integration |
|---------|-------------|
| `talk <npc>` | Displays protocol requirements if NPC has culture |
| `persuade <npc>` | Applies protocol DC and cant modifiers |
| `deceive <npc>` | Applies Veil-Speech rules for Utgard NPCs |
| `intimidate <npc>` | Applies protocol modifiers |
| `negotiate <npc>` | Applies protocol modifiers to all rounds |

### 15.3 Protocol Information Display

When initiating social interaction with a cultured NPC, the system automatically displays:

```
> talk utgard_elder

[Cultural Protocol Active]
Culture: Utgard
Protocol: Veil-Speech (DC 16)
Requirement: Layer truth in deception. Direct statements are offensive.
Your Cant Knowledge: Basic Understanding (+0)

The Utgard elder regards you with hooded eyes, waiting for you to speak...
```

---

## 16. User-Facing Changes

### 16.1 Social Interaction Display

When a protocol is active, the UI/TUI displays protocol information:

```
┌─────────────────────────────────────────────────────────────────┐
│                    SOCIAL INTERACTION                            │
├─────────────────────────────────────────────────────────────────┤
│  Target: Utgard Elder                                           │
│  Disposition: Neutral (+0)                                      │
├─────────────────────────────────────────────────────────────────┤
│  CULTURAL PROTOCOL: Veil-Speech                                 │
│  Base DC: 16                                                    │
│  Requirement: Layer truth in deception                          │
│  Warning: Direct truth-telling offends (-2d10 future checks)    │
├─────────────────────────────────────────────────────────────────┤
│  CANT STATUS                                                    │
│  Utgard Shadow-Tongue: Basic Understanding (+0)                 │
├─────────────────────────────────────────────────────────────────┤
│  MODIFIERS                                                      │
│  • Disposition: +0                                              │
│  • Cant Fluency: +0                                             │
│  • Protocol Compliance: Pending                                 │
│  ─────────────────────────────────────────────────────────────  │
│  Total Modifier: +0d10 | Adjusted DC: 16                        │
└─────────────────────────────────────────────────────────────────┘
```

### 16.2 Protocol Violation Feedback

```
┌─────────────────────────────────────────────────────────────────┐
│                    ⚠ PROTOCOL VIOLATION                         │
├─────────────────────────────────────────────────────────────────┤
│  You spoke directly to the Utgard elder, stating your          │
│  intentions plainly. This is considered crude and offensive    │
│  in Utgard culture.                                            │
│                                                                 │
│  Consequence: Social offense                                    │
│  Effect: -2d10 on future checks with this NPC                  │
│  Disposition Change: -15                                        │
│                                                                 │
│  The elder's expression hardens. "You speak like a child       │
│  who knows nothing of the shadows between words."              │
└─────────────────────────────────────────────────────────────────┘
```

### 16.3 Cant Fluency Display

```
┌─────────────────────────────────────────────────────────────────┐
│                    CANT KNOWLEDGE                                │
├─────────────────────────────────────────────────────────────────┤
│  Dvergr Trade-Tongue     ████████░░  Basic (+0)                │
│  Utgard Shadow-Tongue    ██████████  Fluent (+1d10)            │
│  Gorge-Maw Rumble        ░░░░░░░░░░  None (-1d10)              │
│  Lupin Mind-Speech       ████████░░  Basic (+0)                │
│  Iron-Bane War-Cant      ░░░░░░░░░░  None (-1d10)              │
└─────────────────────────────────────────────────────────────────┘
```

---

## 17. Logging Specifications

### 17.1 Log Categories

| Category | Level | Purpose |
|----------|-------|---------|
| `CulturalProtocol.Load` | Information | Protocol configuration loading |
| `CulturalProtocol.Check` | Debug | Protocol compliance checks |
| `CulturalProtocol.Violation` | Warning | Protocol violations |
| `CulturalProtocol.VeilSpeech` | Debug | Veil-Speech logic application |
| `CulturalProtocol.Cant` | Debug | Cant modifier calculations |

### 17.2 Log Message Templates

```csharp
// Protocol Loading
_logger.LogInformation(
    "Loaded {Count} cultural protocols from configuration",
    protocols.Count);

// Protocol Retrieval
_logger.LogDebug(
    "Retrieved protocol for culture {CultureId}: {ProtocolName} (DC {BaseDc})",
    cultureId,
    protocol?.ProtocolName ?? "None",
    protocol?.BaseDc ?? 0);

// Cant Modifier Calculation
_logger.LogDebug(
    "Calculated cant modifier for {CultureId}: Fluency={Fluency}, Modifier={Modifier}d10",
    cultureId,
    fluency,
    modifier.DiceModifier);

// Protocol Compliance Check
_logger.LogDebug(
    "Protocol compliance check: Character={CharacterId}, Culture={CultureId}, " +
    "Compliant={IsCompliant}, ViolationType={ViolationType}",
    characterId,
    cultureId,
    result.IsCompliant,
    result.ViolationType);

// Protocol Violation
_logger.LogWarning(
    "Protocol violation recorded: Character={CharacterId}, Culture={CultureId}, " +
    "Type={ViolationType}, Consequence={Consequence}",
    characterId,
    cultureId,
    type,
    consequence);

// Veil-Speech Logic
_logger.LogDebug(
    "Veil-Speech logic applied: NPC={NpcId}, Deception={IsDeception}, " +
    "DirectTruth={IsDirectTruth}, ProperVeilSpeech={IsProper}, " +
    "DiceModifier={DiceMod}, DcAdjustment={DcAdj}",
    npcId,
    isDeception,
    isDirectTruth,
    isProperVeilSpeech,
    context.GetDiceModifier(),
    context.GetDcAdjustment());
```

---

## 18. Unit Testing Requirements

### 18.1 Test Coverage Summary

| Test Class | Test Count | Coverage Area |
|------------|------------|---------------|
| `CantFluencyTests` | 4 | Enum values and extension methods |
| `VeilSpeechStateTests` | 3 | State transitions and modifiers |
| `ProtocolViolationTypeTests` | 3 | Violation consequences |
| `CantModifierTests` | 4 | Value object behavior |
| `VeilSpeechContextTests` | 5 | Veil-Speech logic |
| `ProtocolCheckResultTests` | 3 | Result creation and properties |
| `CultureProtocolTests` | 4 | Entity creation and validation |
| `CulturalProtocolServiceTests` | 6 | Service methods |
| **Total** | **~32** | |

### 18.2 CantFluencyTests.cs

```csharp
namespace RuneAndRust.Domain.UnitTests.Enums;

[TestFixture]
public class CantFluencyTests
{
    [Test]
    [TestCase(CantFluency.None, -1)]
    [TestCase(CantFluency.Basic, 0)]
    [TestCase(CantFluency.Fluent, 1)]
    public void GetDiceModifier_ReturnsCorrectValue_ForAllFluencyLevels(
        CantFluency fluency, int expectedModifier)
    {
        // Act
        var result = fluency.GetDiceModifier();
        
        // Assert
        Assert.That(result, Is.EqualTo(expectedModifier));
    }

    [Test]
    public void GetDescription_ReturnsNonEmptyString_ForAllValues()
    {
        // Arrange
        var values = Enum.GetValues<CantFluency>();
        
        // Act & Assert
        foreach (var value in values)
        {
            Assert.That(value.GetDescription(), Is.Not.Empty);
        }
    }

    [Test]
    [TestCase(CantFluency.None, true)]
    [TestCase(CantFluency.Basic, false)]
    [TestCase(CantFluency.Fluent, false)]
    public void IncursPenalty_ReturnsCorrectValue(CantFluency fluency, bool expected)
    {
        Assert.That(fluency.IncursPenalty(), Is.EqualTo(expected));
    }

    [Test]
    [TestCase(CantFluency.None, false)]
    [TestCase(CantFluency.Basic, true)]
    [TestCase(CantFluency.Fluent, true)]
    public void ProvidesBonus_ReturnsCorrectValue(CantFluency fluency, bool expected)
    {
        Assert.That(fluency.ProvidesBonus(), Is.EqualTo(expected));
    }
}
```

### 18.3 VeilSpeechContextTests.cs

```csharp
namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class VeilSpeechContextTests
{
    [Test]
    public void GetDcAdjustment_WhenUsingDeception_ReturnsNegativeFour()
    {
        // Arrange
        var context = new VeilSpeechContext(
            VeilSpeechState.Neutral,
            isUsingDeception: true,
            isDirectTruth: false,
            isProperVeilSpeech: false,
            "npc_1");
        
        // Act
        var result = context.GetDcAdjustment();
        
        // Assert
        Assert.That(result, Is.EqualTo(-4));
    }

    [Test]
    public void GetDiceModifier_WhenTellingDirectTruth_ReturnsNegativeTwo()
    {
        // Arrange
        var context = new VeilSpeechContext(
            VeilSpeechState.Neutral,
            isUsingDeception: false,
            isDirectTruth: true,
            isProperVeilSpeech: false,
            "npc_1");
        
        // Act
        var result = context.GetDiceModifier();
        
        // Assert
        Assert.That(result, Is.EqualTo(-2));
    }

    [Test]
    public void GetDiceModifier_WhenUsingProperVeilSpeech_ReturnsPositiveOne()
    {
        // Arrange
        var context = new VeilSpeechContext(
            VeilSpeechState.Neutral,
            isUsingDeception: false,
            isDirectTruth: false,
            isProperVeilSpeech: true,
            "npc_1");
        
        // Act
        var result = context.GetDiceModifier();
        
        // Assert
        Assert.That(result, Is.EqualTo(1));
    }

    [Test]
    public void GetResultingState_WhenTellingDirectTruth_ReturnsOffended()
    {
        // Arrange
        var context = new VeilSpeechContext(
            VeilSpeechState.Neutral,
            isUsingDeception: false,
            isDirectTruth: true,
            isProperVeilSpeech: false,
            "npc_1");
        
        // Act
        var result = context.GetResultingState();
        
        // Assert
        Assert.That(result, Is.EqualTo(VeilSpeechState.Offended));
    }

    [Test]
    public void GetResultingState_WhenAlreadyOffendedAndTellingTruth_ReturnsDeepOffense()
    {
        // Arrange
        var context = new VeilSpeechContext(
            VeilSpeechState.Offended,
            isUsingDeception: false,
            isDirectTruth: true,
            isProperVeilSpeech: false,
            "npc_1");
        
        // Act
        var result = context.GetResultingState();
        
        // Assert
        Assert.That(result, Is.EqualTo(VeilSpeechState.DeepOffense));
    }
}
```

### 18.4 CulturalProtocolServiceTests.cs

```csharp
namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class CulturalProtocolServiceTests
{
    private CulturalProtocolService _service;
    private Mock<ILogger<CulturalProtocolService>> _loggerMock;
    private Mock<IOptions<CulturalProtocolOptions>> _optionsMock;

    [SetUp]
    public void SetUp()
    {
        _loggerMock = new Mock<ILogger<CulturalProtocolService>>();
        _optionsMock = new Mock<IOptions<CulturalProtocolOptions>>();
        
        var options = new CulturalProtocolOptions
        {
            Protocols = new List<ProtocolConfig>
            {
                new() { CultureId = "Dvergr", ProtocolName = "Logic-Chain", BaseDc = 18, CantName = "Dvergr Trade-Tongue" },
                new() { CultureId = "Utgard", ProtocolName = "Veil-Speech", BaseDc = 16, CantName = "Utgard Shadow-Tongue", SpecialRuleType = SpecialProtocolType.VeilSpeech }
            }
        };
        _optionsMock.Setup(o => o.Value).Returns(options);
        
        _service = new CulturalProtocolService(_loggerMock.Object, _optionsMock.Object);
    }

    [Test]
    public void GetProtocol_WithValidCultureId_ReturnsProtocol()
    {
        // Act
        var result = _service.GetProtocol("Dvergr");
        
        // Assert
        Assert.That(result, Is.Not.Null);
        Assert.That(result!.ProtocolName, Is.EqualTo("Logic-Chain"));
        Assert.That(result.BaseDc, Is.EqualTo(18));
    }

    [Test]
    public void GetProtocol_WithInvalidCultureId_ReturnsNull()
    {
        // Act
        var result = _service.GetProtocol("Unknown");
        
        // Assert
        Assert.That(result, Is.Null);
    }

    [Test]
    public void GetAllProtocols_ReturnsAllLoadedProtocols()
    {
        // Act
        var result = _service.GetAllProtocols();
        
        // Assert
        Assert.That(result, Has.Count.EqualTo(2));
    }

    [Test]
    [TestCase(CantFluency.None, -1)]
    [TestCase(CantFluency.Basic, 0)]
    [TestCase(CantFluency.Fluent, 1)]
    public void GetCantModifier_ReturnsCorrectModifier(CantFluency fluency, int expected)
    {
        // Act
        var result = _service.GetCantModifier(fluency, "Dvergr");
        
        // Assert
        Assert.That(result.DiceModifier, Is.EqualTo(expected));
    }

    [Test]
    public void ApplyVeilSpeechLogic_WithDeception_ReducesDcByFour()
    {
        // Act
        var result = _service.ApplyVeilSpeechLogic("npc_1", isDeception: true, isDirectTruth: false, isProperVeilSpeech: false);
        
        // Assert
        Assert.That(result.GetDcAdjustment(), Is.EqualTo(-4));
    }

    [Test]
    public void ApplyVeilSpeechLogic_WithDirectTruth_AppliesPenalty()
    {
        // Act
        var result = _service.ApplyVeilSpeechLogic("npc_1", isDeception: false, isDirectTruth: true, isProperVeilSpeech: false);
        
        // Assert
        Assert.That(result.GetDiceModifier(), Is.EqualTo(-2));
    }
}
```

---

## 19. Use Cases

### 19.1 UC-001: Interact with Dvergr Using Logic-Chain Protocol

**Actor:** Player Character
**Precondition:** Player is in conversation with a Dvergr NPC
**Trigger:** Player initiates persuasion attempt

**Main Flow:**
1. System identifies NPC's culture as "Dvergr"
2. System retrieves Logic-Chain protocol (DC 18)
3. System checks player's Dvergr Trade-Tongue fluency
4. System applies cant modifier to dice pool
5. System displays protocol requirements to player
6. Player makes argument following logical structure
7. System evaluates protocol compliance
8. System performs skill check with modifiers
9. System displays result and any consequences

**Alternative Flow - Protocol Violation:**
7a. Player makes emotional appeal or contradicts self
7b. System detects protocol violation (Minor/Moderate)
7c. System applies violation consequences
7d. Dvergr dismisses argument as irrational

### 19.2 UC-002: Navigate Utgard Veil-Speech

**Actor:** Player Character
**Precondition:** Player is in conversation with an Utgard NPC
**Trigger:** Player chooses dialogue option

**Main Flow:**
1. System identifies NPC's culture as "Utgard"
2. System retrieves Veil-Speech protocol (DC 16)
3. System checks player's current Veil-Speech state with this NPC
4. Player selects dialogue option marked as "Veil-Speech"
5. System applies +1d10 bonus for proper Veil-Speech
6. System performs skill check
7. System updates Veil-Speech state to "Respected"

**Alternative Flow - Direct Truth:**
4a. Player selects dialogue option marked as "Direct"
4b. System applies -2d10 penalty
4c. System updates Veil-Speech state to "Offended"
4d. System displays offense feedback

**Alternative Flow - Deception:**
4a. Player selects deception interaction type
4b. System reduces DC by 4 (deception respected)
4c. System performs skill check with reduced DC

### 19.3 UC-003: Attempt Interaction Without Cant Knowledge

**Actor:** Player Character
**Precondition:** Player has no knowledge of target culture's cant
**Trigger:** Player initiates social interaction

**Main Flow:**
1. System identifies NPC's culture
2. System checks player's cant fluency (None)
3. System applies -1d10 penalty to dice pool
4. System displays warning about language barrier
5. Player proceeds with interaction at disadvantage
6. System performs skill check with penalty

---

## 20. Deliverable Checklist

### 20.1 Domain Layer

| Item | Status | File |
|------|--------|------|
| `CantFluency` enum | [ ] | `Domain/Enums/CantFluency.cs` |
| `VeilSpeechState` enum | [ ] | `Domain/Enums/VeilSpeechState.cs` |
| `ProtocolViolationType` enum | [ ] | `Domain/Enums/ProtocolViolationType.cs` |
| `ProtocolRequirementType` enum | [ ] | `Domain/Enums/ProtocolRequirementType.cs` |
| `SpecialProtocolType` enum | [ ] | `Domain/Enums/SpecialProtocolType.cs` |
| `CantFluencyExtensions` | [ ] | `Domain/Extensions/CantFluencyExtensions.cs` |
| `VeilSpeechStateExtensions` | [ ] | `Domain/Extensions/VeilSpeechStateExtensions.cs` |
| `ProtocolViolationTypeExtensions` | [ ] | `Domain/Extensions/ProtocolViolationTypeExtensions.cs` |
| `CantModifier` value object | [ ] | `Domain/ValueObjects/CantModifier.cs` |
| `ProtocolRequirement` value object | [ ] | `Domain/ValueObjects/ProtocolRequirement.cs` |
| `VeilSpeechContext` value object | [ ] | `Domain/ValueObjects/VeilSpeechContext.cs` |
| `ProtocolCheckResult` value object | [ ] | `Domain/ValueObjects/ProtocolCheckResult.cs` |
| `CultureProtocol` entity | [ ] | `Domain/Entities/CultureProtocol.cs` |

### 20.2 Application Layer

| Item | Status | File |
|------|--------|------|
| `ICulturalProtocolService` interface | [ ] | `Application/Interfaces/ICulturalProtocolService.cs` |
| `CulturalProtocolService` implementation | [ ] | `Application/Services/CulturalProtocolService.cs` |
| `CulturalProtocolOptions` configuration | [ ] | `Application/Configuration/CulturalProtocolOptions.cs` |

### 20.3 Infrastructure Layer

| Item | Status | File |
|------|--------|------|
| `cultural-protocols.json` config | [ ] | `config/cultural-protocols.json` |
| `cant-modifiers.json` config | [ ] | `config/cant-modifiers.json` |

### 20.4 Tests

| Item | Status | File |
|------|--------|------|
| `CantFluencyTests` | [ ] | `Tests/Domain/Enums/CantFluencyTests.cs` |
| `VeilSpeechStateTests` | [ ] | `Tests/Domain/Enums/VeilSpeechStateTests.cs` |
| `VeilSpeechContextTests` | [ ] | `Tests/Domain/ValueObjects/VeilSpeechContextTests.cs` |
| `CultureProtocolTests` | [ ] | `Tests/Domain/Entities/CultureProtocolTests.cs` |
| `CulturalProtocolServiceTests` | [ ] | `Tests/Application/Services/CulturalProtocolServiceTests.cs` |

---

## 21. Acceptance Criteria

### 21.1 Cultural Protocols

- [ ] `CultureProtocol` entity correctly stores DC and requirements for all 5 defined cultures
- [ ] `ICulturalProtocolService.GetProtocol` returns the correct protocol for a given `CultureId`
- [ ] `ICulturalProtocolService.GetAllProtocols` returns all 5 defined protocols
- [ ] Protocol DC (e.g., DC 18 for Dvergr) is correctly applied to the `SocialContext`
- [ ] Protocol requirements are displayed to the player before interaction
- [ ] Protocol violations are detected and recorded

### 21.2 Utgard Veil-Speech

- [ ] Direct truth-telling to Utgard NPCs applies a -2d10 modifier
- [ ] Deception DC against Utgard NPCs is reduced by 4
- [ ] Proper use of Veil-Speech grants +1d10 bonus
- [ ] Failed Veil-Speech attempt triggers "Offended" state
- [ ] Repeated offense escalates to "DeepOffense" state
- [ ] Veil-Speech state persists per NPC

### 21.3 Cant Fluency

- [ ] Fluent knowledge (+1d10) is correctly applied to Rhetoric checks
- [ ] Basic knowledge (+0) is correctly applied to Rhetoric checks
- [ ] No knowledge (-1d10) is correctly applied to Rhetoric checks
- [ ] Cant fluency is displayed in social interaction UI
- [ ] Cant modifiers stack with other social modifiers

### 21.4 Protocol Violations

- [ ] Minor violations apply +2 DC on next check
- [ ] Moderate violations apply +4 DC and disposition loss
- [ ] Severe violations apply -2d10 and significant disposition loss
- [ ] Unforgivable violations block further interaction
- [ ] Violation consequences are displayed to player

### 21.5 General

- [ ] ~32 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings
- [ ] Configuration files validate against schema
- [ ] All protocols load correctly from configuration

---

## 22. Future Considerations

### 22.1 Version Dependencies

This framework enables the following future features:

| Version | Feature | Uses From v0.15.3g |
|---------|---------|-------------------|
| v0.15.3h | Extended Influence | Protocol compliance may gate belief changes |
| v0.15.3i | Polyglot Ability | Grants automatic Fluent status for all cants |
| v0.15.3i | Cultural Diplomat | Auto-succeed protocol DC ≤ 14 |
| v0.15.3i | Myrk-gengr Bonuses | Enhanced Veil-Speech capabilities |
| v0.16.x | Quest System | Protocol compliance as quest objectives |

### 22.2 Potential Extensions

1. **Dynamic Protocol Learning**: Characters could learn protocols over time through repeated interaction, gradually reducing DC or gaining bonuses.

2. **Protocol Mastery Levels**: Beyond simple compliance, characters could achieve mastery levels that unlock special dialogue options or NPC reactions.

3. **Cultural Reputation**: Aggregate protocol compliance could affect faction-wide reputation, not just individual NPC relationships.

4. **Protocol Tutors**: NPCs who can teach protocols, reducing DC or granting cant fluency improvements.

5. **Cross-Cultural Protocols**: Interactions involving multiple cultures simultaneously, requiring navigation of potentially conflicting protocols.

6. **Protocol Artifacts**: Items that grant bonuses to specific protocols or cant fluency.

---

## 23. Implementation Notes

### 23.1 Integration with Existing Systems

The cultural protocol system integrates with established patterns:

1. **SocialContext Pattern**: `ProtocolCheckResult` modifiers integrate with `SocialContext.ModifierBreakdown` from v0.15.3a
2. **Fumble System**: Protocol violations can trigger `FumbleConsequence` entities from v0.15.1b
3. **Status Effects**: Veil-Speech states could be implemented as status effects from v0.10.x
4. **Stress Economy**: Protocol violations (especially Rune-Lupin telepathy) integrate with `ISkillStressService` from v0.15.1e

### 23.2 Extension Points

The framework is designed for extensibility:

1. **New Cultures**: Add new protocols via configuration without code changes
2. **Custom Special Rules**: Implement new `SpecialProtocolType` values for unique mechanics
3. **Requirement Types**: Extend `ProtocolRequirementType` for new requirement categories
4. **Violation Handlers**: Inject custom logic for processing violations

### 23.3 Performance Considerations

- Protocol definitions are loaded once at startup and cached
- Cant modifiers are calculated on-demand but are simple lookups
- Veil-Speech state is stored in memory per session (consider persistence for save/load)
- Configuration validation occurs at startup to fail fast on errors

### 23.4 Testing Strategy

1. **Unit Tests**: Focus on enum extensions, value object behavior, and service logic
2. **Integration Tests**: Verify configuration loading and service registration
3. **Scenario Tests**: End-to-end tests for complete social interactions with protocols

---

## 24. Document Metadata

| Field | Value |
|-------|-------|
| Version | 0.15.3g |
| Status | Draft |
| Author | Claude |
| Created | 2026-01-17 |
| Updated | 2026-01-17 |
| Review Status | Pending |
| Implementation Status | Not Started |

### 24.1 Change Log

| Date | Version | Changes |
|------|---------|---------|
| 2026-01-17 | 0.15.3g | Initial specification created |
| 2026-01-17 | 0.15.3g | Expanded with comprehensive details |

### 24.2 Related Documents

| Document | Relationship |
|----------|-------------|
| [v0.15.3-scope-breakdown.md](v0.15.3-scope-breakdown.md) | Parent scope document |
| [v0.15.3a-design-specification.md](v0.15.3a-design-specification.md) | Social framework foundation |
| [v0.15.3f-design-specification.md](v0.15.3f-design-specification.md) | Previous phase (Interrogation) |
| [v0.15.3h-design-specification.md](v0.15.3h-design-specification.md) | Next phase (Extended Influence) |
| [v0.15.x-overview.md](v0.15.x-overview.md) | Version series overview |
| [rhetoric.md](../../aethelgard/design/01-core/skills/rhetoric.md) | Source specification |

---

*This design specification provides the detailed blueprint for implementing v0.15.3g. See [v0.15.3g Implementation Plan](v0.15.3g-implementation-plan.md) for step-by-step implementation guidance.*
