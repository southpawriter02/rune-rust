# v0.4.2 Puzzles & Riddles - Scope Breakdown

**Version:** 0.4.2
**Theme:** Puzzles & Riddles
**Prerequisites:** v0.4.1 Complete (Traps & Environmental Hazards)
**Total Estimated Tests:** ~90 new tests

---

## Executive Summary

The Puzzles & Riddles version introduces brain teasers and logic challenges to dungeon exploration, providing non-combat encounters that reward clever thinking. Players will solve sequence puzzles by activating objects in order, crack combination locks, match patterns, and answer riddles posed by NPCs. This system builds on the interactive object foundation from v0.4.0 and integrates with existing room and reward systems.

Key focus areas:
- **Puzzle Entity**: Logic challenges with solution state tracking
- **Puzzle Types**: Sequence, combination, pattern, and riddle varieties
- **Riddle NPCs**: Characters that pose questions with configurable answers
- **Puzzle Rewards**: Items, access, and information granted on solve
- **Multi-Part Puzzles**: Complex challenges spanning multiple rooms

The work is divided into **three sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.4.2a | Puzzle Core | Puzzle entity, states, types, basic infrastructure | ~35 |
| v0.4.2b | Puzzle Types | Sequence, combination, and pattern puzzles | ~30 |
| v0.4.2c | Riddles & Advanced | Riddle NPCs, multi-part puzzles, hints, rewards | ~25 |

---

## Existing Infrastructure

### Already Implemented (from v0.4.0)

| Feature | Location | Notes |
|---------|----------|-------|
| InteractiveObject entity | `Domain/Entities/InteractiveObject.cs` | Puzzle components |
| ObjectState enum | `Domain/Enums/ObjectState.cs` | Active/Inactive states |
| ObjectEffect value object | `Domain/ValueObjects/ObjectEffect.cs` | Puzzle effects |
| InteractionService | `Application/Services/InteractionService.cs` | Interaction handling |
| Room.Interactables | `Domain/Entities/Room.cs` | Object collections |
| Lever activation | v0.4.0c | Sequence puzzle elements |
| Button mechanics | v0.4.0c | Pattern puzzle elements |

### Already Implemented (from v0.4.1)

| Feature | Location | Notes |
|---------|----------|-------|
| Trap entity | `Domain/Entities/Trap.cs` | Puzzle-trap integration |
| TrapService | `Application/Services/TrapService.cs` | Trap management |
| SavingThrow | `Domain/ValueObjects/SavingThrow.cs` | Dice checks |

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| DiceService | `Application/Services/DiceService.cs` | Hint rolls |
| LootService | `Application/Services/LootService.cs` | Puzzle rewards |
| LootDrop | `Domain/ValueObjects/LootDrop.cs` | Reward structure |
| Item entity | `Domain/Entities/Item.cs` | Key items |
| Room entity | `Domain/Entities/Room.cs` | Puzzle rooms |
| Monster entity (NPC base) | `Domain/Entities/Monster.cs` | Riddle NPC reference |

### Needs Implementation (v0.4.2)

| Feature | Phase | Notes |
|---------|-------|-------|
| Puzzle entity | v0.4.2a | Core puzzle logic |
| PuzzleState enum | v0.4.2a | Unsolved, InProgress, etc. |
| PuzzleType enum | v0.4.2a | Sequence, Combination, etc. |
| PuzzleDefinition | v0.4.2a | Configuration |
| PuzzleService | v0.4.2a | Puzzle logic |
| Room.Puzzles | v0.4.2a | Puzzle collection |
| PuzzleAttempt | v0.4.2a | Progress tracking |
| SequencePuzzle | v0.4.2b | Ordered step requirements |
| CombinationPuzzle | v0.4.2b | Code input tracking |
| PatternPuzzle | v0.4.2b | Pattern matching |
| RiddleDefinition | v0.4.2c | Riddle question/answers |
| RiddleNpc | v0.4.2c | NPC with riddles |
| PuzzleHint | v0.4.2c | Hint system |
| MultiPartPuzzle | v0.4.2c | Cross-room puzzles |

---

## Feature Analysis & Categorization

### Core Puzzle Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| Puzzle entity | High | InteractiveObject | **v0.4.2a** |
| PuzzleState enum | Low | None | **v0.4.2a** |
| PuzzleType enum | Low | None | **v0.4.2a** |
| PuzzleDefinition | Medium | Configuration | **v0.4.2a** |
| PuzzleAttempt | Medium | Puzzle | **v0.4.2a** |
| PuzzleService | High | All core types | **v0.4.2a** |
| Room.Puzzles collection | Medium | Room | **v0.4.2a** |
| Puzzle reset mechanics | Medium | Puzzle | **v0.4.2a** |
| `solve` command | Medium | PuzzleService | **v0.4.2a** |

### Puzzle Type Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| SequencePuzzle | High | Puzzle, InteractiveObject | **v0.4.2b** |
| CombinationPuzzle | Medium | Puzzle | **v0.4.2b** |
| PatternPuzzle | High | Puzzle | **v0.4.2b** |
| Sequence step tracking | Medium | SequencePuzzle | **v0.4.2b** |
| Combination input handling | Medium | CombinationPuzzle | **v0.4.2b** |
| Pattern display/input | Medium | PatternPuzzle | **v0.4.2b** |
| `input` command | Medium | CombinationPuzzle | **v0.4.2b** |

### Riddle & Advanced Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| RiddleDefinition | Medium | Configuration | **v0.4.2c** |
| RiddleNpc entity | High | Monster/NPC base | **v0.4.2c** |
| `answer` command | Medium | RiddleNpc | **v0.4.2c** |
| PuzzleHint | Medium | Puzzle | **v0.4.2c** |
| Hint dice checks | Medium | DiceService | **v0.4.2c** |
| MultiPartPuzzle | High | Puzzle, Room | **v0.4.2c** |
| Puzzle rewards | Medium | LootService | **v0.4.2c** |
| Puzzle rooms | Medium | Room | **v0.4.2c** |

---

## Phase Definitions

---

## v0.4.2a: Puzzle Core

[v0.4.2a Design Specification](v0.4.2a-design-specification.md)

### Overview

Establish the foundational `Puzzle` entity with state management, type classification, and attempt tracking. This phase creates the core puzzle infrastructure that specific puzzle types will extend.

### Scope

**In Scope:**
- `Puzzle` entity with state and solution tracking
- `PuzzleState` enum (Unsolved, InProgress, Solved, Failed, Locked)
- `PuzzleType` enum (Sequence, Combination, Pattern, Riddle, Logic)
- `PuzzleDefinition` for JSON configuration
- `PuzzleAttempt` for tracking player progress
- `PuzzleService` for puzzle logic and validation
- `Room.Puzzles` collection
- `solve` command for simple puzzles
- Puzzle reset mechanics (time-based or action-based)
- Puzzle completion tracking
- Basic puzzle examination

**Out of Scope:**
- Specific puzzle type implementations (v0.4.2b)
- Riddle NPCs (v0.4.2c)
- Hint system (v0.4.2c)
- Multi-part puzzles (v0.4.2c)
- Puzzle rewards beyond basic loot (v0.4.2c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 1 | `Puzzle` |
| Domain Enums | 2 | `PuzzleState`, `PuzzleType` |
| Domain Definitions | 1 | `PuzzleDefinition` |
| Domain Value Objects | 1 | `PuzzleAttempt` |
| Application Services | 1 | `PuzzleService` |
| Application Interfaces | 1 | `IPuzzleService` |
| Commands | 1 | `solve` |
| Room Updates | 1 | Add Puzzles collection |
| Configuration | 1 | `puzzles.json` |
| Unit Tests | ~35 | Entity, service, state tests |

### Puzzle Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a logic challenge that players can attempt to solve.
/// </summary>
public class Puzzle : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this puzzle.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the definition ID from configuration.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name of this puzzle.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description shown when examining the puzzle.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the current state of this puzzle.
    /// </summary>
    public PuzzleState State { get; private set; } = PuzzleState.Unsolved;

    /// <summary>
    /// Gets the type of this puzzle.
    /// </summary>
    public PuzzleType Type { get; private set; }

    /// <summary>
    /// Gets the maximum number of attempts allowed (-1 = unlimited).
    /// </summary>
    public int MaxAttempts { get; private set; } = -1;

    /// <summary>
    /// Gets the current attempt count.
    /// </summary>
    public int AttemptCount { get; private set; }

    /// <summary>
    /// Gets whether this puzzle can be reset after failure.
    /// </summary>
    public bool CanReset { get; private set; } = true;

    /// <summary>
    /// Gets the turns until reset after failure (-1 = manual reset only).
    /// </summary>
    public int ResetDelay { get; private set; } = -1;

    /// <summary>
    /// Gets turns remaining until reset.
    /// </summary>
    public int? TurnsUntilReset { get; private set; }

    /// <summary>
    /// Gets the difficulty rating (1-5 scale for UI display).
    /// </summary>
    public int Difficulty { get; private set; } = 1;

    /// <summary>
    /// Gets whether hints are available for this puzzle.
    /// </summary>
    public bool HasHints { get; private set; }

    /// <summary>
    /// Gets the number of hints revealed.
    /// </summary>
    public int HintsRevealed { get; private set; }

    /// <summary>
    /// Gets whether this puzzle is currently solvable.
    /// </summary>
    public bool IsSolvable => State == PuzzleState.Unsolved || State == PuzzleState.InProgress;

    /// <summary>
    /// Gets whether this puzzle has been solved.
    /// </summary>
    public bool IsSolved => State == PuzzleState.Solved;

    /// <summary>
    /// Gets whether this puzzle has failed.
    /// </summary>
    public bool IsFailed => State == PuzzleState.Failed;

    /// <summary>
    /// Gets whether this puzzle is locked (requires prerequisite).
    /// </summary>
    public bool IsLocked => State == PuzzleState.Locked;

    /// <summary>
    /// Gets whether attempts remain for this puzzle.
    /// </summary>
    public bool HasAttemptsRemaining => MaxAttempts < 0 || AttemptCount < MaxAttempts;

    /// <summary>
    /// Gets the associated reward definition ID (null if no reward).
    /// </summary>
    public string? RewardId { get; private set; }

    /// <summary>
    /// Gets the prerequisite puzzle ID that must be solved first.
    /// </summary>
    public string? PrerequisitePuzzleId { get; private set; }

    /// <summary>
    /// Gets IDs of objects affected when puzzle is solved.
    /// </summary>
    public IReadOnlyList<Guid> AffectedObjectIds { get; private set; } = Array.Empty<Guid>();

    private Puzzle() { }

    /// <summary>
    /// Creates a new puzzle.
    /// </summary>
    public static Puzzle Create(
        string definitionId,
        string name,
        string description,
        PuzzleType type,
        int maxAttempts = -1,
        bool canReset = true,
        int resetDelay = -1,
        int difficulty = 1,
        bool hasHints = false,
        string? rewardId = null,
        string? prerequisiteId = null,
        IEnumerable<Guid>? affectedObjects = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(definitionId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new Puzzle
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId,
            Name = name,
            Description = description,
            Type = type,
            MaxAttempts = maxAttempts,
            CanReset = canReset,
            ResetDelay = resetDelay,
            Difficulty = Math.Clamp(difficulty, 1, 5),
            HasHints = hasHints,
            RewardId = rewardId,
            PrerequisitePuzzleId = prerequisiteId,
            AffectedObjectIds = affectedObjects?.ToList() ?? Array.Empty<Guid>()
        };
    }

    /// <summary>
    /// Begins an attempt on this puzzle.
    /// </summary>
    public bool BeginAttempt()
    {
        if (!IsSolvable || !HasAttemptsRemaining)
            return false;

        if (State == PuzzleState.Unsolved)
            State = PuzzleState.InProgress;

        return true;
    }

    /// <summary>
    /// Records a failed attempt.
    /// </summary>
    public void RecordFailedAttempt()
    {
        AttemptCount++;

        if (MaxAttempts > 0 && AttemptCount >= MaxAttempts)
        {
            State = PuzzleState.Failed;
            if (CanReset && ResetDelay >= 0)
            {
                TurnsUntilReset = ResetDelay;
            }
        }
    }

    /// <summary>
    /// Marks this puzzle as solved.
    /// </summary>
    public void Solve()
    {
        State = PuzzleState.Solved;
    }

    /// <summary>
    /// Resets this puzzle to unsolved state.
    /// </summary>
    public bool Reset()
    {
        if (!CanReset || State == PuzzleState.Solved)
            return false;

        State = PuzzleState.Unsolved;
        AttemptCount = 0;
        TurnsUntilReset = null;
        return true;
    }

    /// <summary>
    /// Processes turn tick for resetting puzzles.
    /// </summary>
    public bool TickReset()
    {
        if (State != PuzzleState.Failed || !TurnsUntilReset.HasValue)
            return false;

        TurnsUntilReset--;

        if (TurnsUntilReset <= 0)
        {
            return Reset();
        }

        return false;
    }

    /// <summary>
    /// Reveals a hint for this puzzle.
    /// </summary>
    public bool RevealHint()
    {
        if (!HasHints)
            return false;

        HintsRevealed++;
        return true;
    }

    /// <summary>
    /// Locks this puzzle (requires prerequisite).
    /// </summary>
    public void Lock()
    {
        if (State == PuzzleState.Unsolved)
            State = PuzzleState.Locked;
    }

    /// <summary>
    /// Unlocks this puzzle when prerequisite is met.
    /// </summary>
    public void Unlock()
    {
        if (State == PuzzleState.Locked)
            State = PuzzleState.Unsolved;
    }
}
```

### PuzzleState Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the current state of a puzzle.
/// </summary>
public enum PuzzleState
{
    /// <summary>Puzzle has not been attempted.</summary>
    Unsolved,

    /// <summary>Puzzle attempt is in progress.</summary>
    InProgress,

    /// <summary>Puzzle has been successfully solved.</summary>
    Solved,

    /// <summary>Puzzle was failed (max attempts reached).</summary>
    Failed,

    /// <summary>Puzzle is locked (prerequisite not met).</summary>
    Locked
}
```

### PuzzleType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categories of puzzle mechanics.
/// </summary>
public enum PuzzleType
{
    /// <summary>Activate objects in a specific order.</summary>
    Sequence,

    /// <summary>Enter a correct combination/code.</summary>
    Combination,

    /// <summary>Match or reproduce a pattern.</summary>
    Pattern,

    /// <summary>Answer a riddle correctly.</summary>
    Riddle,

    /// <summary>General logic puzzle (custom validation).</summary>
    Logic
}
```

### PuzzleAttempt Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks the progress of a puzzle attempt.
/// </summary>
public class PuzzleAttempt
{
    /// <summary>
    /// Gets the puzzle ID being attempted.
    /// </summary>
    public Guid PuzzleId { get; private set; }

    /// <summary>
    /// Gets when the attempt started.
    /// </summary>
    public DateTime StartedAt { get; private set; }

    /// <summary>
    /// Gets the steps completed so far (for sequence puzzles).
    /// </summary>
    public IReadOnlyList<string> CompletedSteps { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the current input (for combination puzzles).
    /// </summary>
    public string CurrentInput { get; private set; } = string.Empty;

    /// <summary>
    /// Gets whether this attempt is still active.
    /// </summary>
    public bool IsActive { get; private set; } = true;

    /// <summary>
    /// Gets the result of this attempt (null if still active).
    /// </summary>
    public bool? Succeeded { get; private set; }

    private readonly List<string> _completedSteps = [];

    private PuzzleAttempt() { }

    /// <summary>
    /// Creates a new puzzle attempt.
    /// </summary>
    public static PuzzleAttempt Create(Guid puzzleId)
    {
        return new PuzzleAttempt
        {
            PuzzleId = puzzleId,
            StartedAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Adds a completed step (for sequence puzzles).
    /// </summary>
    public void AddStep(string stepId)
    {
        _completedSteps.Add(stepId);
        CompletedSteps = _completedSteps.ToList();
    }

    /// <summary>
    /// Sets the current input (for combination puzzles).
    /// </summary>
    public void SetInput(string input)
    {
        CurrentInput = input;
    }

    /// <summary>
    /// Appends to the current input.
    /// </summary>
    public void AppendInput(string value)
    {
        CurrentInput += value;
    }

    /// <summary>
    /// Clears the current input.
    /// </summary>
    public void ClearInput()
    {
        CurrentInput = string.Empty;
    }

    /// <summary>
    /// Marks this attempt as completed.
    /// </summary>
    public void Complete(bool succeeded)
    {
        IsActive = false;
        Succeeded = succeeded;
    }

    /// <summary>
    /// Resets this attempt for a retry.
    /// </summary>
    public void Reset()
    {
        _completedSteps.Clear();
        CompletedSteps = Array.Empty<string>();
        CurrentInput = string.Empty;
        IsActive = true;
        Succeeded = null;
    }
}
```

### PuzzleService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing puzzle interactions and validation.
/// </summary>
public interface IPuzzleService
{
    /// <summary>
    /// Gets a puzzle by ID from the current room.
    /// </summary>
    Puzzle? GetPuzzle(Room room, string puzzleKeyword);

    /// <summary>
    /// Gets all puzzles in a room.
    /// </summary>
    IEnumerable<Puzzle> GetPuzzles(Room room);

    /// <summary>
    /// Gets all unsolved puzzles in a room.
    /// </summary>
    IEnumerable<Puzzle> GetUnsolvedPuzzles(Room room);

    /// <summary>
    /// Begins an attempt on a puzzle.
    /// </summary>
    PuzzleAttemptResult BeginAttempt(Player player, Puzzle puzzle);

    /// <summary>
    /// Submits a solution attempt for a puzzle.
    /// </summary>
    PuzzleSolveResult AttemptSolve(Player player, Puzzle puzzle, string input);

    /// <summary>
    /// Validates a sequence step.
    /// </summary>
    PuzzleStepResult ValidateStep(Puzzle puzzle, PuzzleAttempt attempt, string stepId);

    /// <summary>
    /// Gets the current attempt for a puzzle (if any).
    /// </summary>
    PuzzleAttempt? GetCurrentAttempt(Player player, Puzzle puzzle);

    /// <summary>
    /// Requests a hint for a puzzle.
    /// </summary>
    PuzzleHintResult RequestHint(Player player, Puzzle puzzle);

    /// <summary>
    /// Processes puzzle resets at end of turn.
    /// </summary>
    IEnumerable<Puzzle> ProcessPuzzleResets(Room room);

    /// <summary>
    /// Checks and updates puzzle prerequisites.
    /// </summary>
    void UpdatePuzzleLocks(Room room);

    /// <summary>
    /// Applies puzzle completion effects.
    /// </summary>
    PuzzleRewardResult ApplyPuzzleReward(Player player, Puzzle puzzle);
}

/// <summary>
/// Result of beginning a puzzle attempt.
/// </summary>
public readonly record struct PuzzleAttemptResult
{
    public Puzzle Puzzle { get; init; }
    public bool Success { get; init; }
    public PuzzleAttempt? Attempt { get; init; }
    public string Message { get; init; }
}

/// <summary>
/// Result of attempting to solve a puzzle.
/// </summary>
public readonly record struct PuzzleSolveResult
{
    public Puzzle Puzzle { get; init; }
    public bool Solved { get; init; }
    public bool Failed { get; init; }
    public int AttemptsRemaining { get; init; }
    public string Message { get; init; }
}

/// <summary>
/// Result of validating a puzzle step.
/// </summary>
public readonly record struct PuzzleStepResult
{
    public Puzzle Puzzle { get; init; }
    public string StepId { get; init; }
    public bool Correct { get; init; }
    public bool SequenceComplete { get; init; }
    public bool SequenceFailed { get; init; }
    public int StepsRemaining { get; init; }
    public string Message { get; init; }
}
```

### Room Modifications

```
MODIFY: Room
├── ADD: _puzzles: List<Puzzle>
├── ADD: Puzzles: IReadOnlyList<Puzzle>
├── ADD: HasPuzzles: bool
├── ADD: HasUnsolvedPuzzles: bool
├── ADD: AddPuzzle(Puzzle): void
├── ADD: RemovePuzzle(Puzzle): bool
├── ADD: GetPuzzleByKeyword(string): Puzzle?
└── ADD: GetUnsolvedPuzzles(): IEnumerable<Puzzle>
```

### User-Facing Changes

**Commands:**
```
> examine <puzzle>        # View puzzle description and status
> solve <puzzle>          # Begin/continue puzzle attempt
> reset <puzzle>          # Reset a failed puzzle (if allowed)
```

**Examining a Puzzle:**
```
> examine stone altar

Stone Altar Puzzle
==================
A circular stone altar with four carved symbols around
its edge. The symbols appear to represent the four
elements: fire, water, earth, and air.

Type: Sequence
Status: Unsolved
Difficulty: ★★★☆☆
Attempts: 0

The symbols seem to need activation in a specific order.
```

**Beginning an Attempt:**
```
> solve stone altar

You focus on the Stone Altar Puzzle...

The altar glows faintly as you approach. You sense that
the symbols must be activated in the correct order.

[Puzzle: In Progress]
Remaining steps: 4
```

**Failed Attempt:**
```
> solve combination lock

You try the combination: 4-7-2-1

The lock mechanism clicks but doesn't open.
That combination was incorrect.

[Attempts: 2/3 remaining]

---

> solve combination lock

You try the combination: 1-2-3-4

The lock mechanism clicks but doesn't open.
That combination was incorrect.

[Attempts: 1/3 remaining]

---

> solve combination lock

You try the combination: 9-9-9-9

The lock mechanism clicks but doesn't open.
That combination was incorrect.

[PUZZLE FAILED]
You've exhausted your attempts.
The puzzle will reset in 5 turns.
```

### Configuration Example

```json
{
  "$schema": "../schemas/puzzles.schema.json",
  "puzzles": [
    {
      "id": "altar-sequence-fire",
      "name": "Elemental Altar",
      "description": "A circular stone altar with four carved symbols representing the elements.",
      "type": "Sequence",
      "difficulty": 3,
      "maxAttempts": -1,
      "canReset": true,
      "hasHints": true,
      "rewardId": "altar-treasure"
    },
    {
      "id": "vault-combination",
      "name": "Vault Lock",
      "description": "A complex combination lock with four rotating dials.",
      "type": "Combination",
      "difficulty": 2,
      "maxAttempts": 3,
      "canReset": true,
      "resetDelay": 5,
      "hasHints": true
    },
    {
      "id": "mirror-pattern",
      "name": "Mirror Puzzle",
      "description": "A series of mirrors that must be aligned to create a pattern of light.",
      "type": "Pattern",
      "difficulty": 4,
      "maxAttempts": -1,
      "canReset": true
    }
  ]
}
```

### Acceptance Criteria

- [ ] Puzzle entity stores state, type, and attempt information
- [ ] PuzzleState enum covers all necessary states
- [ ] PuzzleType enum categorizes all puzzle varieties
- [ ] PuzzleAttempt tracks progress through puzzle
- [ ] Room.Puzzles collection works correctly
- [ ] `solve` command begins puzzle attempts
- [ ] Failed puzzles track attempts remaining
- [ ] Puzzles can reset after configurable delay
- [ ] Locked puzzles require prerequisite completion
- [ ] Puzzles appear in room examination
- [ ] ~35 unit tests pass

---

## v0.4.2b: Puzzle Types

[v0.4.2b Design Specification](v0.4.2b-design-specification.md)

### Overview

Implement the three primary puzzle type mechanics: sequence puzzles requiring ordered object activation, combination puzzles with code input, and pattern puzzles requiring matching or reproduction. Each type has unique input handling and validation logic.

### Scope

**In Scope:**
- `SequencePuzzle` with ordered step requirements
- `CombinationPuzzle` with code and input tracking
- `PatternPuzzle` with pattern display and matching
- Sequence step tracking and validation
- Combination input handling
- Pattern display in TUI
- `input` command for combination entry
- `activate` integration for sequence steps
- Partial progress feedback
- Step-by-step sequence validation
- Sequence reset on wrong step

**Out of Scope:**
- Riddle puzzles (v0.4.2c)
- Multi-part puzzles (v0.4.2c)
- Hint system (v0.4.2c)
- Puzzle rewards (v0.4.2c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Value Objects | 3 | `SequencePuzzle`, `CombinationPuzzle`, `PatternPuzzle` |
| Puzzle Updates | 1 | Type-specific data |
| Service Updates | 1 | PuzzleService type handling |
| Commands | 1 | `input` |
| Configuration | 1 | Update `puzzles.json` |
| Unit Tests | ~30 | Type-specific validation tests |

### SequencePuzzle Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a sequence-based puzzle requiring ordered activation.
/// </summary>
public class SequencePuzzle
{
    /// <summary>
    /// Gets the ordered list of step IDs that must be activated.
    /// </summary>
    public IReadOnlyList<string> RequiredSequence { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets descriptions for each step (for feedback).
    /// </summary>
    public IReadOnlyDictionary<string, string> StepDescriptions { get; private set; }
        = new Dictionary<string, string>();

    /// <summary>
    /// Gets whether wrong steps reset the entire sequence.
    /// </summary>
    public bool ResetOnWrongStep { get; private set; } = true;

    /// <summary>
    /// Gets whether steps must be consecutive (no delays).
    /// </summary>
    public bool RequiresConsecutiveSteps { get; private set; }

    /// <summary>
    /// Gets the max turns between steps (0 = no limit).
    /// </summary>
    public int MaxTurnsBetweenSteps { get; private set; }

    /// <summary>
    /// Gets associated interactive object IDs for each step.
    /// </summary>
    public IReadOnlyDictionary<string, Guid> StepObjectIds { get; private set; }
        = new Dictionary<string, Guid>();

    private SequencePuzzle() { }

    /// <summary>
    /// Creates a sequence puzzle configuration.
    /// </summary>
    public static SequencePuzzle Create(
        IEnumerable<string> sequence,
        IDictionary<string, string>? stepDescriptions = null,
        bool resetOnWrongStep = true,
        bool requiresConsecutive = false,
        int maxTurnsBetween = 0,
        IDictionary<string, Guid>? stepObjectIds = null)
    {
        return new SequencePuzzle
        {
            RequiredSequence = sequence.ToList(),
            StepDescriptions = stepDescriptions?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value)
                ?? new Dictionary<string, string>(),
            ResetOnWrongStep = resetOnWrongStep,
            RequiresConsecutiveSteps = requiresConsecutive,
            MaxTurnsBetweenSteps = maxTurnsBetween,
            StepObjectIds = stepObjectIds?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value)
                ?? new Dictionary<string, Guid>()
        };
    }

    /// <summary>
    /// Validates if a step is the correct next step.
    /// </summary>
    public bool IsCorrectNextStep(IReadOnlyList<string> completedSteps, string stepId)
    {
        if (completedSteps.Count >= RequiredSequence.Count)
            return false;

        return RequiredSequence[completedSteps.Count] == stepId;
    }

    /// <summary>
    /// Checks if the sequence is complete.
    /// </summary>
    public bool IsComplete(IReadOnlyList<string> completedSteps)
    {
        if (completedSteps.Count != RequiredSequence.Count)
            return false;

        return completedSteps.SequenceEqual(RequiredSequence);
    }

    /// <summary>
    /// Gets the number of remaining steps.
    /// </summary>
    public int GetRemainingSteps(IReadOnlyList<string> completedSteps)
    {
        return Math.Max(0, RequiredSequence.Count - completedSteps.Count);
    }
}
```

### CombinationPuzzle Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a combination/code-based puzzle.
/// </summary>
public class CombinationPuzzle
{
    /// <summary>
    /// Gets the correct combination.
    /// </summary>
    public string Solution { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the length of the combination.
    /// </summary>
    public int Length { get; private set; }

    /// <summary>
    /// Gets the valid characters/digits for input.
    /// </summary>
    public string ValidCharacters { get; private set; } = "0123456789";

    /// <summary>
    /// Gets whether input is case-sensitive.
    /// </summary>
    public bool CaseSensitive { get; private set; }

    /// <summary>
    /// Gets whether to show partial feedback (correct digits).
    /// </summary>
    public bool ShowPartialFeedback { get; private set; }

    /// <summary>
    /// Gets the separator between input segments (null = none).
    /// </summary>
    public string? Separator { get; private set; }

    /// <summary>
    /// Gets alternate accepted solutions (if any).
    /// </summary>
    public IReadOnlyList<string> AlternateSolutions { get; private set; } = Array.Empty<string>();

    private CombinationPuzzle() { }

    /// <summary>
    /// Creates a combination puzzle configuration.
    /// </summary>
    public static CombinationPuzzle Create(
        string solution,
        string? validChars = null,
        bool caseSensitive = false,
        bool showPartialFeedback = false,
        string? separator = null,
        IEnumerable<string>? alternateSolutions = null)
    {
        return new CombinationPuzzle
        {
            Solution = solution,
            Length = solution.Length,
            ValidCharacters = validChars ?? "0123456789",
            CaseSensitive = caseSensitive,
            ShowPartialFeedback = showPartialFeedback,
            Separator = separator,
            AlternateSolutions = alternateSolutions?.ToList() ?? Array.Empty<string>()
        };
    }

    /// <summary>
    /// Validates if the input matches the solution.
    /// </summary>
    public bool Validate(string input)
    {
        var comparison = CaseSensitive
            ? StringComparison.Ordinal
            : StringComparison.OrdinalIgnoreCase;

        if (Solution.Equals(input, comparison))
            return true;

        return AlternateSolutions.Any(alt => alt.Equals(input, comparison));
    }

    /// <summary>
    /// Gets partial feedback showing correct positions.
    /// </summary>
    public CombinationFeedback GetFeedback(string input)
    {
        if (!ShowPartialFeedback)
            return new CombinationFeedback { CorrectPositions = 0, CorrectCharacters = 0 };

        var correctPositions = 0;
        var correctCharacters = 0;
        var solutionChars = Solution.ToList();

        var normalizedInput = CaseSensitive ? input : input.ToLowerInvariant();
        var normalizedSolution = CaseSensitive ? Solution : Solution.ToLowerInvariant();

        // Count exact position matches
        for (int i = 0; i < Math.Min(input.Length, Solution.Length); i++)
        {
            if (normalizedInput[i] == normalizedSolution[i])
                correctPositions++;
        }

        // Count correct characters in wrong positions
        var inputChars = normalizedInput.ToList();
        var solChars = normalizedSolution.ToList();

        foreach (var c in inputChars.Distinct())
        {
            var inInput = inputChars.Count(x => x == c);
            var inSolution = solChars.Count(x => x == c);
            correctCharacters += Math.Min(inInput, inSolution);
        }

        correctCharacters -= correctPositions;

        return new CombinationFeedback
        {
            CorrectPositions = correctPositions,
            CorrectCharacters = correctCharacters
        };
    }
}

/// <summary>
/// Feedback for a combination attempt.
/// </summary>
public readonly record struct CombinationFeedback
{
    /// <summary>Characters in correct position.</summary>
    public int CorrectPositions { get; init; }

    /// <summary>Correct characters in wrong position.</summary>
    public int CorrectCharacters { get; init; }
}
```

### PatternPuzzle Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a pattern matching puzzle.
/// </summary>
public class PatternPuzzle
{
    /// <summary>
    /// Gets the pattern to match (as string representation).
    /// </summary>
    public string TargetPattern { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the pattern grid dimensions.
    /// </summary>
    public int GridWidth { get; private set; }
    public int GridHeight { get; private set; }

    /// <summary>
    /// Gets the pattern elements/symbols available.
    /// </summary>
    public IReadOnlyList<string> PatternElements { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether the pattern is shown before solving.
    /// </summary>
    public bool ShowTargetPattern { get; private set; } = true;

    /// <summary>
    /// Gets how long the pattern is displayed (turns, 0 = always visible).
    /// </summary>
    public int PatternDisplayDuration { get; private set; }

    /// <summary>
    /// Gets whether rotations of the pattern are accepted.
    /// </summary>
    public bool AcceptRotations { get; private set; }

    /// <summary>
    /// Gets whether reflections of the pattern are accepted.
    /// </summary>
    public bool AcceptReflections { get; private set; }

    private PatternPuzzle() { }

    /// <summary>
    /// Creates a pattern puzzle configuration.
    /// </summary>
    public static PatternPuzzle Create(
        string targetPattern,
        int gridWidth,
        int gridHeight,
        IEnumerable<string> elements,
        bool showTarget = true,
        int displayDuration = 0,
        bool acceptRotations = false,
        bool acceptReflections = false)
    {
        return new PatternPuzzle
        {
            TargetPattern = targetPattern,
            GridWidth = gridWidth,
            GridHeight = gridHeight,
            PatternElements = elements.ToList(),
            ShowTargetPattern = showTarget,
            PatternDisplayDuration = displayDuration,
            AcceptRotations = acceptRotations,
            AcceptReflections = acceptReflections
        };
    }

    /// <summary>
    /// Validates if the input pattern matches the target.
    /// </summary>
    public bool Validate(string inputPattern)
    {
        if (inputPattern == TargetPattern)
            return true;

        if (AcceptRotations)
        {
            var rotations = GetRotations(inputPattern);
            if (rotations.Contains(TargetPattern))
                return true;
        }

        if (AcceptReflections)
        {
            var reflections = GetReflections(inputPattern);
            if (reflections.Contains(TargetPattern))
                return true;
        }

        return false;
    }

    private List<string> GetRotations(string pattern)
    {
        // Returns 90, 180, 270 degree rotations
        // Implementation depends on pattern encoding
        return new List<string>();
    }

    private List<string> GetReflections(string pattern)
    {
        // Returns horizontal and vertical reflections
        // Implementation depends on pattern encoding
        return new List<string>();
    }
}
```

### Puzzle Entity Updates

```
MODIFY: Puzzle
├── ADD: SequenceData: SequencePuzzle?
├── ADD: CombinationData: CombinationPuzzle?
├── ADD: PatternData: PatternPuzzle?
├── ADD: GetTypeData<T>(): T?
└── ADD: SetTypeData(object): void
```

### User-Facing Changes

**Commands:**
```
> input <code>             # Enter combination code
> activate <object>        # Activate sequence step
> pattern <input>          # Submit pattern answer
```

**Sequence Puzzle:**
```
> examine elemental altar

Elemental Altar Puzzle
======================
Four symbols glow around the altar's edge: Fire, Water,
Earth, and Air. They must be activated in the correct
order to unlock the altar's secret.

Type: Sequence
Status: In Progress
Progress: ██░░░░░░ 1/4 steps complete
Difficulty: ★★★☆☆

---

> activate fire symbol

The fire symbol blazes brightly!
[Step 1/4 correct]

---

> activate earth symbol

The earth symbol glows with a warm light.
[Step 2/4 correct]

---

> activate air symbol

The air symbol flickers... then goes dark.
[Wrong step! Sequence reset.]

Progress: ░░░░░░░░ 0/4 steps

---

> activate fire symbol

The fire symbol blazes brightly!
[Step 1/4 correct]

> activate water symbol

The water symbol shimmers.
[Step 2/4 correct]

> activate earth symbol

The earth symbol glows with a warm light.
[Step 3/4 correct]

> activate air symbol

The air symbol swirls with energy!
[Step 4/4 correct]

[PUZZLE SOLVED!]
The altar rumbles and reveals a hidden compartment!
```

**Combination Puzzle:**
```
> examine vault lock

Vault Lock
==========
A complex lock with four rotating dials, each marked
with numbers 0-9. The correct combination will open
the vault.

Type: Combination
Status: Unsolved
Attempts: 0/3 remaining
Difficulty: ★★☆☆☆

---

> input 1234

You enter: 1-2-3-4

The lock clicks but doesn't open.
[Feedback: 1 correct position, 2 correct digits]

[Attempts: 2/3 remaining]

---

> input 4231

You enter: 4-2-3-1

[PUZZLE SOLVED!]
The vault lock clicks open!
```

**Pattern Puzzle:**
```
> examine mirror puzzle

Mirror Puzzle
=============
A grid of adjustable mirrors that must be aligned to
direct light beams to the correct positions.

Target Pattern:
  ╔═══╦═══╦═══╗
  ║ / ║ \ ║ / ║
  ╠═══╬═══╬═══╣
  ║ \ ║ / ║ \ ║
  ╠═══╬═══╬═══╣
  ║ / ║ / ║ \ ║
  ╚═══╩═══╩═══╝

Type: Pattern
Status: Unsolved
Difficulty: ★★★★☆

---

> pattern /\/\//\/

You adjust the mirrors...

  ╔═══╦═══╦═══╗
  ║ / ║ \ ║ / ║
  ╠═══╬═══╬═══╣
  ║ \ ║ / ║ / ║
  ╠═══╬═══╬═══╣
  ║ \ ║ / ║ / ║
  ╚═══╩═══╩═══╝

The light beams don't align correctly.
[Pattern does not match]

---

> pattern /\\/\/\/\

You adjust the mirrors...

  ╔═══╦═══╦═══╗
  ║ / ║ \ ║ / ║
  ╠═══╬═══╬═══╣
  ║ \ ║ / ║ \ ║
  ╠═══╬═══╬═══╣
  ║ / ║ / ║ \ ║
  ╚═══╩═══╩═══╝

[PUZZLE SOLVED!]
The light beams converge on the central crystal,
which glows brilliantly!
```

### Configuration Example

```json
{
  "puzzles": [
    {
      "id": "altar-elements",
      "name": "Elemental Altar",
      "type": "Sequence",
      "sequenceData": {
        "requiredSequence": ["fire", "water", "earth", "air"],
        "stepDescriptions": {
          "fire": "The fire symbol blazes brightly!",
          "water": "The water symbol shimmers.",
          "earth": "The earth symbol glows with a warm light.",
          "air": "The air symbol swirls with energy!"
        },
        "resetOnWrongStep": true,
        "stepObjectIds": {
          "fire": "obj-fire-symbol",
          "water": "obj-water-symbol",
          "earth": "obj-earth-symbol",
          "air": "obj-air-symbol"
        }
      }
    },
    {
      "id": "vault-code",
      "name": "Vault Lock",
      "type": "Combination",
      "combinationData": {
        "solution": "4231",
        "validCharacters": "0123456789",
        "showPartialFeedback": true,
        "separator": "-"
      },
      "maxAttempts": 3
    },
    {
      "id": "mirror-grid",
      "name": "Mirror Puzzle",
      "type": "Pattern",
      "patternData": {
        "targetPattern": "/\\/\\/\\/\\",
        "gridWidth": 3,
        "gridHeight": 3,
        "elements": ["/", "\\"],
        "showTargetPattern": true,
        "acceptRotations": false
      }
    }
  ]
}
```

### Acceptance Criteria

- [ ] SequencePuzzle tracks ordered step requirements
- [ ] Sequence validates correct step order
- [ ] Wrong sequence steps reset progress (configurable)
- [ ] CombinationPuzzle validates code input
- [ ] Combination feedback shows correct positions (optional)
- [ ] `input` command handles combination entry
- [ ] PatternPuzzle validates pattern matching
- [ ] Pattern display renders in TUI
- [ ] `activate` integration works for sequence steps
- [ ] Puzzle type-specific data stored correctly
- [ ] ~30 unit tests pass

---

## v0.4.2c: Riddles & Advanced

[v0.4.2c Design Specification](v0.4.2c-design-specification.md)

### Overview

Implement riddle NPCs that pose questions, a hint system for all puzzle types, multi-part puzzles spanning multiple rooms, and the puzzle reward system. This phase completes the puzzle feature set with advanced mechanics.

### Scope

**In Scope:**
- `RiddleDefinition` with question, answers, and hints
- `RiddleNpc` entity for NPCs that pose riddles
- `answer` command for responding to riddles
- `PuzzleHint` value object
- Hint dice checks (optional Intelligence/Wits)
- `hint` command for requesting hints
- `MultiPartPuzzle` for cross-room puzzles
- Puzzle part tracking across rooms
- Puzzle rewards (items, currency, access)
- Puzzle completion effects (doors open, traps disable)
- Dedicated puzzle rooms with gated rewards

**Out of Scope:**
- Complex NPC dialogue trees (future)
- Puzzle generation/randomization (future)
- Time-limited puzzles (future)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Definitions | 1 | `RiddleDefinition` |
| Domain Entities | 1 | `RiddleNpc` |
| Domain Value Objects | 2 | `PuzzleHint`, `MultiPartPuzzle` |
| Commands | 2 | `answer`, `hint` |
| Service Updates | 2 | PuzzleService, LootService |
| Configuration | 2 | `riddles.json`, update `puzzles.json` |
| Unit Tests | ~25 | Riddle, hint, multi-part tests |

### RiddleDefinition

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration for a riddle with question and acceptable answers.
/// </summary>
public class RiddleDefinition
{
    /// <summary>
    /// Gets the unique identifier for this riddle.
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the riddle question text.
    /// </summary>
    public string Question { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the accepted answers (case-insensitive).
    /// </summary>
    public IReadOnlyList<string> AcceptedAnswers { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets optional hints for this riddle.
    /// </summary>
    public IReadOnlyList<PuzzleHint> Hints { get; private set; } = Array.Empty<PuzzleHint>();

    /// <summary>
    /// Gets the difficulty rating (1-5).
    /// </summary>
    public int Difficulty { get; private set; } = 1;

    /// <summary>
    /// Gets the category/theme of this riddle.
    /// </summary>
    public string? Category { get; private set; }

    /// <summary>
    /// Gets the message shown on correct answer.
    /// </summary>
    public string CorrectMessage { get; private set; } = "Correct!";

    /// <summary>
    /// Gets the message shown on wrong answer.
    /// </summary>
    public string WrongMessage { get; private set; } = "That is not correct.";

    private RiddleDefinition() { }

    /// <summary>
    /// Creates a riddle definition.
    /// </summary>
    public static RiddleDefinition Create(
        string id,
        string question,
        IEnumerable<string> acceptedAnswers,
        IEnumerable<PuzzleHint>? hints = null,
        int difficulty = 1,
        string? category = null,
        string? correctMessage = null,
        string? wrongMessage = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(question);

        return new RiddleDefinition
        {
            Id = id,
            Question = question,
            AcceptedAnswers = acceptedAnswers.ToList(),
            Hints = hints?.ToList() ?? Array.Empty<PuzzleHint>(),
            Difficulty = Math.Clamp(difficulty, 1, 5),
            Category = category,
            CorrectMessage = correctMessage ?? "Correct!",
            WrongMessage = wrongMessage ?? "That is not correct."
        };
    }

    /// <summary>
    /// Validates if an answer is correct.
    /// </summary>
    public bool ValidateAnswer(string answer)
    {
        return AcceptedAnswers.Any(a =>
            a.Equals(answer.Trim(), StringComparison.OrdinalIgnoreCase));
    }
}
```

### PuzzleHint Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// A hint that can be revealed for a puzzle.
/// </summary>
public class PuzzleHint
{
    /// <summary>
    /// Gets the hint text.
    /// </summary>
    public string Text { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the order in which this hint is revealed (1 = first).
    /// </summary>
    public int Order { get; private set; }

    /// <summary>
    /// Gets the DC for a dice check to reveal this hint (0 = free).
    /// </summary>
    public int RevealDC { get; private set; }

    /// <summary>
    /// Gets the attribute used for the reveal check.
    /// </summary>
    public string? RevealAttribute { get; private set; }

    /// <summary>
    /// Gets whether revealing this hint has a cost.
    /// </summary>
    public bool HasCost => RevealDC > 0;

    private PuzzleHint() { }

    /// <summary>
    /// Creates a free hint.
    /// </summary>
    public static PuzzleHint Free(string text, int order) => new()
    {
        Text = text,
        Order = order,
        RevealDC = 0
    };

    /// <summary>
    /// Creates a hint requiring a dice check.
    /// </summary>
    public static PuzzleHint WithCheck(string text, int order, int dc, string attribute) => new()
    {
        Text = text,
        Order = order,
        RevealDC = dc,
        RevealAttribute = attribute
    };
}
```

### RiddleNpc Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// An NPC that poses riddles to players.
/// </summary>
public class RiddleNpc : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this NPC.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the display name of this NPC.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description of this NPC.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the current riddle definition ID.
    /// </summary>
    public string CurrentRiddleId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets whether the current riddle has been solved.
    /// </summary>
    public bool RiddleSolved { get; private set; }

    /// <summary>
    /// Gets the number of wrong answers given.
    /// </summary>
    public int WrongAnswerCount { get; private set; }

    /// <summary>
    /// Gets the maximum wrong answers before consequences (-1 = unlimited).
    /// </summary>
    public int MaxWrongAnswers { get; private set; } = -1;

    /// <summary>
    /// Gets the reward given for solving the riddle.
    /// </summary>
    public string? RewardId { get; private set; }

    /// <summary>
    /// Gets the consequence for too many wrong answers.
    /// </summary>
    public RiddleConsequence? FailureConsequence { get; private set; }

    /// <summary>
    /// Gets the greeting message when first speaking.
    /// </summary>
    public string GreetingMessage { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the message when riddle is already solved.
    /// </summary>
    public string SolvedMessage { get; private set; } = string.Empty;

    /// <summary>
    /// Gets whether this NPC blocks passage until riddle is solved.
    /// </summary>
    public bool BlocksPassage { get; private set; }

    /// <summary>
    /// Gets the direction blocked (if blocking passage).
    /// </summary>
    public Direction? BlockedDirection { get; private set; }

    private RiddleNpc() { }

    /// <summary>
    /// Creates a riddle NPC.
    /// </summary>
    public static RiddleNpc Create(
        string name,
        string description,
        string riddleId,
        string greetingMessage,
        string solvedMessage,
        int maxWrongAnswers = -1,
        string? rewardId = null,
        RiddleConsequence? failureConsequence = null,
        bool blocksPassage = false,
        Direction? blockedDirection = null)
    {
        return new RiddleNpc
        {
            Id = Guid.NewGuid(),
            Name = name,
            Description = description,
            CurrentRiddleId = riddleId,
            GreetingMessage = greetingMessage,
            SolvedMessage = solvedMessage,
            MaxWrongAnswers = maxWrongAnswers,
            RewardId = rewardId,
            FailureConsequence = failureConsequence,
            BlocksPassage = blocksPassage,
            BlockedDirection = blockedDirection
        };
    }

    /// <summary>
    /// Records a wrong answer attempt.
    /// </summary>
    public bool RecordWrongAnswer()
    {
        WrongAnswerCount++;
        return MaxWrongAnswers > 0 && WrongAnswerCount >= MaxWrongAnswers;
    }

    /// <summary>
    /// Marks the riddle as solved.
    /// </summary>
    public void MarkSolved()
    {
        RiddleSolved = true;
    }

    /// <summary>
    /// Checks if passage is currently blocked.
    /// </summary>
    public bool IsPassageBlocked(Direction direction)
    {
        return BlocksPassage && !RiddleSolved && BlockedDirection == direction;
    }
}

/// <summary>
/// Consequence for failing a riddle NPC encounter.
/// </summary>
public enum RiddleConsequence
{
    /// <summary>NPC becomes hostile.</summary>
    BecomeHostile,

    /// <summary>NPC disappears.</summary>
    Disappear,

    /// <summary>NPC gives a penalty.</summary>
    ApplyPenalty,

    /// <summary>Riddle resets (can try again later).</summary>
    Reset
}
```

### MultiPartPuzzle Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a puzzle spanning multiple rooms or objects.
/// </summary>
public class MultiPartPuzzle
{
    /// <summary>
    /// Gets the master puzzle ID.
    /// </summary>
    public string MasterPuzzleId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the IDs of component puzzles that must be solved.
    /// </summary>
    public IReadOnlyList<string> ComponentPuzzleIds { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether components must be solved in order.
    /// </summary>
    public bool RequiresOrder { get; private set; }

    /// <summary>
    /// Gets the required order (if applicable).
    /// </summary>
    public IReadOnlyList<string> RequiredOrder { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets room IDs where components are located.
    /// </summary>
    public IReadOnlyDictionary<string, Guid> ComponentRooms { get; private set; }
        = new Dictionary<string, Guid>();

    /// <summary>
    /// Gets the number of components solved.
    /// </summary>
    public int SolvedCount { get; private set; }

    /// <summary>
    /// Gets IDs of solved components.
    /// </summary>
    private readonly List<string> _solvedComponents = [];
    public IReadOnlyList<string> SolvedComponents => _solvedComponents;

    private MultiPartPuzzle() { }

    /// <summary>
    /// Creates a multi-part puzzle configuration.
    /// </summary>
    public static MultiPartPuzzle Create(
        string masterPuzzleId,
        IEnumerable<string> componentIds,
        bool requiresOrder = false,
        IEnumerable<string>? requiredOrder = null,
        IDictionary<string, Guid>? componentRooms = null)
    {
        return new MultiPartPuzzle
        {
            MasterPuzzleId = masterPuzzleId,
            ComponentPuzzleIds = componentIds.ToList(),
            RequiresOrder = requiresOrder,
            RequiredOrder = requiredOrder?.ToList() ?? Array.Empty<string>(),
            ComponentRooms = componentRooms?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value)
                ?? new Dictionary<string, Guid>()
        };
    }

    /// <summary>
    /// Records a component as solved.
    /// </summary>
    public bool RecordComponentSolved(string componentId)
    {
        if (!ComponentPuzzleIds.Contains(componentId))
            return false;

        if (_solvedComponents.Contains(componentId))
            return false;

        if (RequiresOrder)
        {
            var expectedNext = RequiredOrder[SolvedCount];
            if (componentId != expectedNext)
                return false;
        }

        _solvedComponents.Add(componentId);
        SolvedCount++;
        return true;
    }

    /// <summary>
    /// Checks if the multi-part puzzle is complete.
    /// </summary>
    public bool IsComplete => SolvedCount == ComponentPuzzleIds.Count;

    /// <summary>
    /// Gets the next expected component (if ordered).
    /// </summary>
    public string? GetNextExpectedComponent()
    {
        if (!RequiresOrder || IsComplete)
            return null;

        return RequiredOrder[SolvedCount];
    }

    /// <summary>
    /// Gets remaining unsolved components.
    /// </summary>
    public IEnumerable<string> GetRemainingComponents()
    {
        return ComponentPuzzleIds.Except(_solvedComponents);
    }
}
```

### PuzzleHintResult

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of requesting a puzzle hint.
/// </summary>
public readonly record struct PuzzleHintResult
{
    public Puzzle Puzzle { get; init; }
    public bool Success { get; init; }
    public PuzzleHint? Hint { get; init; }
    public int? RollResult { get; init; }
    public int? DC { get; init; }
    public bool NoMoreHints { get; init; }
    public string Message { get; init; }
}

/// <summary>
/// Result of applying puzzle rewards.
/// </summary>
public readonly record struct PuzzleRewardResult
{
    public Puzzle Puzzle { get; init; }
    public LootDrop? Loot { get; init; }
    public IReadOnlyList<string> EffectsApplied { get; init; }
    public string Message { get; init; }
}
```

### Room Modifications (Riddle NPCs)

```
MODIFY: Room
├── ADD: _riddleNpcs: List<RiddleNpc>
├── ADD: RiddleNpcs: IReadOnlyList<RiddleNpc>
├── ADD: HasRiddleNpcs: bool
├── ADD: AddRiddleNpc(RiddleNpc): void
├── ADD: RemoveRiddleNpc(RiddleNpc): bool
├── ADD: GetRiddleNpcByKeyword(string): RiddleNpc?
└── ADD: IsDirectionBlockedByNpc(Direction): bool
```

### User-Facing Changes

**Commands:**
```
> talk <npc>              # Initiate conversation with riddle NPC
> answer <response>       # Answer a riddle
> hint                    # Request a hint for current puzzle
> hint <puzzle>           # Request hint for specific puzzle
```

**Riddle NPC Interaction:**
```
> talk sphinx

The ancient Sphinx regards you with knowing eyes.

"Traveler, I guard the passage to the eastern chambers.
Answer my riddle correctly, and you may pass.
Fail three times, and face my wrath."

The Sphinx poses its riddle:

"I have cities, but no houses.
 I have mountains, but no trees.
 I have water, but no fish.
 What am I?"

---

> answer ocean

The Sphinx shakes its head slowly.

"That is not correct, traveler. You have 2 attempts remaining."

---

> answer map

The Sphinx nods approvingly.

"Correct! You may pass, clever one."

[RIDDLE SOLVED]
The Sphinx steps aside, clearing the eastern passage.

You receive: Ancient Coin x3
```

**Hint System:**
```
> hint

You study the Vault Lock puzzle carefully...

[Rolling Intelligence: DC 12]
Roll: 2d6 + 2 = [4, 5] + 2 = 11

You fail to gain any insight.

---

> hint

You study the Vault Lock puzzle carefully...

[Rolling Intelligence: DC 12]
Roll: 2d6 + 2 = [6, 3] + 2 = 11

[HINT REVEALED]
"The first digit is even."

---

> hint

[HINT REVEALED - FREE]
"The digits are all different."

---

> hint

You've already revealed all available hints for this puzzle.
```

**Multi-Part Puzzle:**
```
> examine crystal fragments

Crystal Resonance Puzzle
========================
Three crystal fragments scattered across the dungeon
must be activated in the correct order to unlock
the treasure vault.

Type: Multi-Part Sequence
Status: In Progress
Progress: ██████░░ 2/3 fragments activated

Activated: Blue Crystal (Library), Red Crystal (Chapel)
Remaining: Green Crystal (location unknown)

---

[After finding and activating the green crystal]

> activate green crystal

The Green Crystal hums with energy!

[MULTI-PART PUZZLE COMPLETE]
All three crystals resonate in harmony!
A distant rumble echoes through the dungeon...

The Treasure Vault is now accessible!
```

### Configuration Example

```json
{
  "$schema": "../schemas/riddles.schema.json",
  "riddles": [
    {
      "id": "sphinx-riddle-map",
      "question": "I have cities, but no houses. I have mountains, but no trees. I have water, but no fish. What am I?",
      "acceptedAnswers": ["map", "a map"],
      "difficulty": 2,
      "category": "classic",
      "hints": [
        {
          "text": "Think about something you might find on a desk.",
          "order": 1,
          "revealDC": 10,
          "revealAttribute": "Intelligence"
        },
        {
          "text": "It represents something larger than itself.",
          "order": 2,
          "revealDC": 0
        }
      ],
      "correctMessage": "Correct! You may pass, clever one.",
      "wrongMessage": "That is not correct, traveler."
    }
  ],
  "riddleNpcs": [
    {
      "id": "sphinx-guardian",
      "name": "Ancient Sphinx",
      "description": "A stone sphinx with eyes that seem to follow your every move.",
      "riddleId": "sphinx-riddle-map",
      "greetingMessage": "Traveler, I guard the passage to the eastern chambers. Answer my riddle correctly, and you may pass.",
      "solvedMessage": "You have proven your wisdom. The path is open to you.",
      "maxWrongAnswers": 3,
      "failureConsequence": "BecomeHostile",
      "blocksPassage": true,
      "blockedDirection": "East",
      "rewardId": "sphinx-reward"
    }
  ],
  "multiPartPuzzles": [
    {
      "id": "crystal-resonance",
      "name": "Crystal Resonance Puzzle",
      "masterPuzzleId": "crystal-master",
      "componentPuzzleIds": ["crystal-blue", "crystal-red", "crystal-green"],
      "requiresOrder": true,
      "requiredOrder": ["crystal-blue", "crystal-red", "crystal-green"],
      "componentRooms": {
        "crystal-blue": "room-library",
        "crystal-red": "room-chapel",
        "crystal-green": "room-garden"
      }
    }
  ]
}
```

### Acceptance Criteria

- [ ] RiddleDefinition stores question and valid answers
- [ ] RiddleNpc can pose riddles to players
- [ ] `answer` command validates riddle responses
- [ ] Wrong answer limits trigger consequences
- [ ] Passage-blocking NPCs prevent movement until solved
- [ ] PuzzleHint reveals hints in order
- [ ] Hint dice checks use appropriate attribute
- [ ] `hint` command requests puzzle hints
- [ ] MultiPartPuzzle tracks components across rooms
- [ ] Ordered multi-part puzzles validate sequence
- [ ] Puzzle rewards grant items/currency on solve
- [ ] Puzzle completion can trigger object effects
- [ ] ~25 unit tests pass

---

## Dependencies & Prerequisites

```
v0.4.1 (Traps & Hazards) - REQUIRED
    │
    ├── Trap entity ──────────────────────┐
    ├── TrapService ──────────────────────┤
    ├── SavingThrow ──────────────────────┤
    └── HazardZone ───────────────────────┘
                                          │
v0.4.0 (Interactive Objects) - REQUIRED   │
    │                                     │
    ├── InteractiveObject ────────────────┤
    ├── ObjectState ──────────────────────┤
    ├── ObjectEffect ─────────────────────┤
    ├── Levers & Buttons ─────────────────┤
    └── InteractionService ───────────────┘
                                          │
                                          ▼
v0.4.2 (Puzzles & Riddles)
    │
    ├── v0.4.2a: Puzzle Core ─────────────────────────────┐
    │       Dependencies: Room, InteractiveObject         │
    │       Provides: Puzzle, PuzzleState, PuzzleService  │
    │                                                     │
    ├── v0.4.2b: Puzzle Types ────────────────────────────┤
    │       Dependencies: v0.4.2a, InteractiveObject      │
    │       Provides: Sequence, Combination, Pattern      │
    │                                                     │
    └── v0.4.2c: Riddles & Advanced ──────────────────────┘
            Dependencies: v0.4.2a, v0.4.2b, LootService
            Provides: RiddleNpc, Hints, MultiPart, Rewards
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.4.2a | ~7 | ~4 | ~35 | High |
| v0.4.2b | ~5 | ~4 | ~30 | High |
| v0.4.2c | ~6 | ~5 | ~25 | Medium |
| **Total** | **~18** | **~13** | **~90** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Puzzle difficulty tuning | Medium | Medium | Configurable attempts, hints |
| Pattern input complexity | Medium | Medium | Simple pattern encoding |
| Multi-room state sync | High | Low | Centralized puzzle state |
| Riddle answer matching | Low | Medium | Multiple accepted answers |
| Sequence timing issues | Medium | Low | Optional turn limits |
| Performance with many puzzles | Low | Low | Per-room puzzle lists |

---

## Design Decisions (Confirmed)

### Puzzle Architecture

| Decision | Value | Notes |
|----------|-------|-------|
| **Puzzle Storage** | Room.Puzzles collection | Per-room puzzle lists |
| **Type Data** | Nullable type-specific objects | SequencePuzzle, CombinationPuzzle, etc. |
| **State Machine** | Enum-based | Unsolved → InProgress → Solved/Failed |
| **Attempt Tracking** | Value object | PuzzleAttempt per active puzzle |

### Riddle System

| Decision | Value | Notes |
|----------|-------|-------|
| **Answer Matching** | Case-insensitive | Multiple accepted answers |
| **NPC Integration** | Separate entity | RiddleNpc with riddle reference |
| **Passage Blocking** | Direction-based | NPC blocks specific direction |

### Hint System

| Decision | Value | Notes |
|----------|-------|-------|
| **Hint Availability** | Per-puzzle configuration | Some puzzles have hints |
| **Reveal Mechanism** | Sequential order | First hint, then second, etc. |
| **Cost Model** | Optional dice check | DC-based or free hints |

### Multi-Part Puzzles

| Decision | Value | Notes |
|----------|-------|-------|
| **Component Tracking** | Centralized state | MultiPartPuzzle value object |
| **Order Requirement** | Optional | RequiresOrder flag |
| **Room Distribution** | Configuration-based | ComponentRooms dictionary |

---

## Integration Points

### From v0.4.0
- InteractiveObject for puzzle components (levers, buttons)
- ObjectState for puzzle element states
- ObjectEffect for puzzle completion effects
- Activation mechanics for sequence steps

### From v0.4.1
- Trap integration (puzzles can disable traps)
- SavingThrow for hint dice checks
- Hazard interaction (puzzle completion clears hazards)

### To v0.4.3 (Light & Environment)
- Light puzzles using darkness/light mechanics
- Environmental puzzle elements
- Perception affecting puzzle detection

### To Future Versions
- More complex NPC dialogue systems
- Procedural puzzle generation
- Timed puzzle challenges

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.4.2a Design Spec** - Create detailed design specification
3. **Implement v0.4.2a** - Build puzzle core system
4. **v0.4.2b Design Spec** - Puzzle types
5. **Implement v0.4.2b** - Build type-specific puzzles
6. **v0.4.2c Design Spec** - Riddles and advanced features
7. **Implement v0.4.2c** - Build riddles, hints, multi-part

---

*This scope breakdown provides a structured approach to implementing v0.4.2 Puzzles & Riddles. Each sub-phase builds on the previous, creating a comprehensive puzzle system that rewards player intelligence and provides non-combat challenges throughout the dungeon.*
