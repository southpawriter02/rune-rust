> **Archived** - This plan has been consolidated. See the complete version at [v0.3.23](../v0.3.x/v0.3.23.md).

Here is the comprehensive implementation plan for v0.3.23b: The Loop (Event-Driven Architecture).
This sub-version fundamentally restructures the engine's heartbeat. It transitions GameService from a blocking "wait-for-input" model to a non-blocking "Game Loop" pattern. This enables real-time features like animated text, environmental ambience, and visual effects to run smoothly while the game waits for player commands.

v0.3.23b: The Loop
Goal: Implement TerminalGameLoop to orchestrate a non-blocking update cycle (Input $\rightarrow$ Update $\rightarrow$ Render $\rightarrow$ Wait), allowing background services (IUpdatable) to tick independently of user input.
1. Architecture & Data Flow
	•	The Tick Cycle: Instead of halting execution at Console.ReadLine(), the application runs a continuous loop (approx. 20-30 ticks per second).
	•	IUpdatable Interface: A new Core interface for services that need per-tick updates (e.g., VisualEffectService, AmbienceService).
	•	Input Polling: The loop checks IInputService.HasInput (mapping to Console.KeyAvailable). If false, it performs updates and renders; if true, it processes the command.
Data Flow: The Non-Blocking Loop
	1	Cycle Start: GameLoop.RunAsync() begins.
	2	Input Phase:
	◦	Check _inputService.HasInput.
	◦	If True: Read InputEvent. Dispatch to CommandParser. Await result.
	3	Update Phase:
	◦	Iterate through registered IUpdatable services (e.g., Audio, VFX).
	◦	Call UpdateAsync(deltaTime).
	4	Render Phase:
	◦	Check if state is "Dirty" (Changed).
	◦	If Dirty: Call current IScreenRenderer.Render().
	5	Sync Phase:
	◦	Calculated elapsed time.
	◦	Task.Delay to maintain target framerate (e.g., 50ms).

2. Logic Decision Trees
A. Loop Tick Logic Input: Current Time, CancellationToken
	1	Check Cancellation: Is cancellation requested? $\rightarrow$ Exit Loop.
	2	Poll Input:
	◦	Is Key Available?
	▪	Yes: Read Key $\rightarrow$ Map to Action $\rightarrow$ Execute Command. Mark State Dirty.
	▪	No: Continue.
	3	Process Background Tasks:
	◦	Is VisualEffectService animating? $\rightarrow$ Tick. Mark State Dirty.
	◦	Is AmbienceService due for sound? $\rightarrow$ Tick.
	4	Render Guard:
	◦	Is State Dirty?
	▪	Yes: Render current View. Set Dirty = False.
	▪	No: Skip Render (prevents flicker).
	5	Throttle: Wait for remainder of Tick Budget (e.g., 33ms).
B. Input Prioritization Input: InputEvent
	1	Is System Event? (e.g., Resize, Force Quit)
	◦	Yes: Handle immediately.
	2	Is Game Action?
	◦	Yes:
	▪	Is Animation Playing? $\rightarrow$ Fast Forward Animation.
	▪	Is Animation Done? $\rightarrow$ Process Action.

3. Code Implementation
A. Core Interface File: RuneAndRust.Core/Interfaces/IUpdatable.cs
public interface IUpdatable
{
    // DeltaTime in milliseconds
    Task UpdateAsync(long deltaTime);
}
B. The Game Loop Implementation File: RuneAndRust.Terminal/Services/TerminalGameLoop.cs
public class TerminalGameLoop : IGameLoop
{
    private readonly IInputService _inputService;
    private readonly CommandParser _parser;
    private readonly IEnumerable<IUpdatable> _backgroundServices;
    private readonly ILogger _logger;
    private const int TargetFps = 30;
    private const int TickTimeMs = 1000 / TargetFps;

    public async Task RunAsync(CancellationToken ct)
    {
        _logger.LogInformation("[GameLoop] Starting non-blocking loop.");

        while (!ct.IsCancellationRequested)
        {
            var startTime = DateTime.UtcNow;

            // 1. Process Input
            if (_inputService.HasInput) // Checks Console.KeyAvailable
            {
                var inputEvent = _inputService.ReadNext();
                if (inputEvent is ActionEvent action)
                {
                    await _parser.ParseAndExecuteAsync(action.Action);
                    // Force render after input
                    Render();
                }
            }

            // 2. Update Background Services (VFX, Audio)
            foreach (var service in _backgroundServices)
            {
                await service.UpdateAsync(TickTimeMs);
            }

            // 3. Throttle
            var elapsed = (DateTime.UtcNow - startTime).TotalMilliseconds;
            var delay = (int)Math.Max(0, TickTimeMs - elapsed);

            if (delay > 0) await Task.Delay(delay, ct);
        }
    }
}

4. Deliverable Checklist (v0.3.23b)
	•	Core:
	◦	[ ] Define IUpdatable interface.
	◦	[ ] Define IGameLoop interface.
	•	Engine:
	◦	[ ] Update VisualEffectService to implement IUpdatable (handle frame ticks).
	◦	[ ] Update AmbienceService to implement IUpdatable (handle timers).
	•	Terminal:
	◦	[ ] Implement TerminalGameLoop.
	◦	[ ] Refactor TerminalInputProvider to expose HasInput property (non-blocking check).
	◦	[ ] Register TerminalGameLoop as Singleton.
	◦	[ ] Update Program.cs to await GameLoop.RunAsync() instead of GameService.Start().

5. Logging Requirements
Reference: logging.md
System
Event
Level
Message Template
Properties
GameLoop
Start
Info
"[Loop] Started. Target Tick: {Ms}ms"
Ms
GameLoop
Lag
Warn
"[Loop] Tick took {Elapsed}ms (Target: {Target}ms). System lagging."
Elapsed, Target
GameLoop
Exception
Fatal
"[Loop] Crash in update cycle: {Message}"
Message

6. Testing Strategy
Unit Tests (GameLoopTests.cs):
	•	Loop_RespectsCancellation:
	◦	Setup: CancellationTokenSource with 100ms timeout.
	◦	Act: RunAsync(cts.Token).
	◦	Assert: Task completes successfully (does not hang).
	•	Background_Service_Ticked:
	◦	Setup: Mock IUpdatable. Run loop for 5 ticks.
	◦	Assert: UpdateAsync called approx 5 times.
	•	Input_Triggers_Parser:
	◦	Setup: Mock IInputService to return HasInput = true once.
	◦	Assert: CommandParser was invoked.
Integration Tests:
	•	Responsiveness:
	◦	Simulate heavy background load (slow UpdateAsync).
	◦	Verify Input is still polled (or queued) correctly in the next tick.

7. Draft Changelog (v0.3.23b)
# Changelog: v0.3.23b - The Loop

**Release Date:** 2026-03-XX

## Summary
"The Loop" fundamentally changes the engine's heartbeat. By moving to a non-blocking event loop, the game can now process background tasks—like ambient audio and particle effects—while waiting for player input. This eliminates the "frozen world" effect during idle moments.

## Changes
- **Event Loop:** Replaced blocking input waits with a 30 FPS update loop.
- **Background Services:** `VisualEffectService` and `AmbienceService` now run continuously in the background, allowing for real-time effects.
- **Input Polling:** The game now polls for input every tick, ensuring immediate response to key presses even during animations.