# v0.18.4d Design Specification: Resource Service Interfaces

**Version:** 0.18.4d
**Parent:** v0.18.4 (Specialization-Specific Resources)
**Prerequisites:** v0.18.4a-c (Domain Models)
**Status:** Design Complete
**Estimated Unit Tests:** ~0 (Interface only)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Service Architecture](#3-service-architecture)
4. [Interface Definitions](#4-interface-definitions)
5. [Dependency Injection](#5-dependency-injection)
6. [Deliverable Checklist](#6-deliverable-checklist)
7. [Acceptance Criteria](#7-acceptance-criteria)
8. [Dependencies](#8-dependencies)
9. [Future Considerations](#9-future-considerations)

---

## 1. Executive Summary

This design specification defines the **Service Layer Interfaces** for all three specialization resource systems: Rage, Momentum, and Coherence. These interfaces form the contract between the domain layer and the application layer, enabling service implementations to interact with character resources.

v0.18.4d establishes the **Service Contracts** by defining:

- `IRageService` interface — 8 methods for rage management
- `IMomentumService` interface — 10 methods for momentum management
- `ICoherenceService` interface — 9 methods for coherence management

### Key Deliverables

| Category              | Items                                            |
| --------------------- | ----------------------------------------------- |
| **Service Interfaces** | `IRageService`, `IMomentumService`, `ICoherenceService` |
| **XML Documentation** | Complete method and parameter documentation     |
| **Tests**             | ~0 tests (interfaces only)                      |

---

## 2. Feature Overview

```
v0.18.4d Features
└── Service Layer Interfaces
    │
    ├── IRageService
    │   ├── GetRageState(Guid characterId)
    │   ├── GainRage(Guid characterId, int amount, RageSource source)
    │   ├── ApplyDecay(Guid characterId)
    │   ├── GetDamageBonus(Guid characterId)
    │   ├── GetSoakBonus(Guid characterId)
    │   ├── IsFearImmune(Guid characterId)
    │   ├── MustAttackNearest(Guid characterId)
    │   └── GetPartyStressReduction(Guid characterId)
    │
    ├── IMomentumService
    │   ├── GetMomentumState(Guid characterId)
    │   ├── GainMomentum(Guid characterId, int amount, MomentumSource source)
    │   ├── ApplyDecay(Guid characterId, string reason)
    │   ├── ResetMomentum(Guid characterId, string reason)
    │   ├── GetBonusAttacks(Guid characterId)
    │   ├── GetMovementBonus(Guid characterId)
    │   ├── GetAttackBonus(Guid characterId)
    │   ├── GetDefenseBonus(Guid characterId)
    │   ├── RecordHit(Guid characterId)
    │   └── RecordMiss(Guid characterId)
    │
    └── ICoherenceService
        ├── GetCoherenceState(Guid characterId)
        ├── GainCoherence(Guid characterId, int amount, CoherenceSource source)
        ├── LoseCoherence(Guid characterId, int amount, string reason)
        ├── CheckCascade(Guid characterId)
        ├── UpdateApotheosis(Guid characterId)
        ├── GetSpellPowerBonus(Guid characterId)
        ├── GetCriticalCastChance(Guid characterId)
        ├── CanMeditate(Guid characterId)
        └── Meditate(Guid characterId)
```

---

## 3. Service Architecture

### 3.1 Service Layer Integration

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐                    │
│  │   Combat    │  │   Abilities │  │    Spells    │                    │
│  │  Handler    │  │  Handler    │  │   Handler    │                    │
│  └──────┬──────┘  └──────┬──────┘  └──────┬───────┘                    │
│         │                 │                 │                           │
│         └─────────────────┼─────────────────┘                           │
│                           │                                             │
│                           ▼                                             │
│         ┌─────────────────────────────────────┐                        │
│         │   Specialization Resource Handlers    │                        │
│         │  (Uses IRage, IMomentum, ICoherence)│                        │
│         └─────────────────────────────────────┘                        │
│                           │                                             │
└───────────────────────────┼─────────────────────────────────────────────┘
                            │
┌───────────────────────────┼─────────────────────────────────────────────┐
│                      DOMAIN LAYER                                        │
├───────────────────────────┼─────────────────────────────────────────────┤
│                           │                                             │
│  ┌──────────────┐  ┌──────▼──────┐  ┌──────────────┐                   │
│  │  RageState   │  │MomentumState │  │ CoherenceState│                   │
│  │   (Entity)   │  │   (Entity)   │  │   (Entity)   │                   │
│  └──────────────┘  └──────────────┘  └──────────────┘                   │
│                                                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                   │
│  │RageThreshold │  │MomentumThresh│  │CoherenceThres│                   │
│  │   (Enum)     │  │   (Enum)     │  │   (Enum)     │                   │
│  └──────────────┘  └──────────────┘  └──────────────┘                   │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Service Responsibility Matrix

| Service          | Get State | Gain     | Lose/Decay | Bonuses | Special Effects |
| ---------------- | --------- | -------- | ---------- | ------- | --------------- |
| `IRageService`   | ✓         | ✓        | ✓          | ✓       | Fear, Attack    |
| `IMomentumService` | ✓       | ✓        | ✓          | ✓       | Chain, Bonus Atk|
| `ICoherenceService` | ✓      | ✓        | ✓          | ✓       | Cascade, Apo    |

---

## 4. Interface Definitions

### 4.1 IRageService

**File:** `src/Core/RuneAndRust.Application/Services/Interfaces/IRageService.cs`

```csharp
namespace RuneAndRust.Application.Services.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service contract for managing Rage resource for Berserker specialization.
/// </summary>
/// <remarks>
/// <para>
/// IRageService provides the application layer interface for all rage-related
/// operations: gaining rage, applying decay, and computing rage-based bonuses.
/// </para>
/// <para>
/// Key Responsibilities:
/// - Retrieve current rage state
/// - Process rage gain from various sources
/// - Apply non-combat decay
/// - Calculate threshold-based bonuses (damage, soak, fear, party stress)
/// </para>
/// </remarks>
public interface IRageService
{
    /// <summary>
    /// Gets the current rage state for a character.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// The character's RageState, or null if character has no rage state.
    /// </returns>
    /// <remarks>
    /// Returns the immutable snapshot of the character's current rage status.
    /// </remarks>
    RageState? GetRageState(Guid characterId);

    /// <summary>
    /// Applies rage gain from a specified source.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="amount">Amount of rage to gain (before caps).</param>
    /// <param name="source">The source of rage generation.</param>
    /// <returns>
    /// A RageGainResult containing the transaction details, including
    /// threshold change information.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Rage is capped at 100. If addition would exceed cap, result.NewRage == 100.
    /// </para>
    /// <para>
    /// Gain sources:
    /// - TakingDamage: floor(damage / 5)
    /// - DealingDamage: floor(damage / 10)
    /// - AllyDamaged: flat 5
    /// - EnemyKill: flat 15
    /// - RageMaintenance: flat 5 per turn at FrenzyBeyondReason
    /// </para>
    /// </remarks>
    RageGainResult GainRage(Guid characterId, int amount, RageSource source);

    /// <summary>
    /// Applies non-combat rage decay.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// A RageDecayResult containing the decay details.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Decay is 10 rage per non-combat turn.
    /// Checks LastCombatTime to determine eligibility.
    /// Only applies if >= 1 minute has passed since last combat.
    /// </para>
    /// </remarks>
    RageDecayResult ApplyDecay(Guid characterId);

    /// <summary>
    /// Gets the current damage bonus from rage.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// The damage bonus (0-10), or 0 if character has no rage state.
    /// </returns>
    /// <remarks>
    /// Calculated as floor(CurrentRage / 10).
    /// </remarks>
    int GetDamageBonus(Guid characterId);

    /// <summary>
    /// Gets the current soak (defense) bonus from rage threshold.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// The soak bonus (0-4), or 0 if character has no rage state.
    /// </returns>
    /// <remarks>
    /// Scales with threshold: Calm (0), Simmering (1), Burning (2),
    /// BerserkFury (3), FrenzyBeyondReason (4).
    /// </remarks>
    int GetSoakBonus(Guid characterId);

    /// <summary>
    /// Determines if the character is immune to fear effects.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// True if character is at FrenzyBeyondReason threshold, false otherwise.
    /// </returns>
    /// <remarks>
    /// Fear immunity is only active at the FrenzyBeyondReason threshold.
    /// </remarks>
    bool IsFearImmune(Guid characterId);

    /// <summary>
    /// Determines if the character must attack the nearest target.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// True if character is at BerserkFury or higher threshold, false otherwise.
    /// </returns>
    /// <remarks>
    /// Forced attack applies at BerserkFury and FrenzyBeyondReason thresholds.
    /// Should be checked during turn resolution to enforce behavior.
    /// </remarks>
    bool MustAttackNearest(Guid characterId);

    /// <summary>
    /// Gets the party stress reduction bonus at FrenzyBeyondReason.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// 10 if character is at FrenzyBeyondReason threshold, null otherwise.
    /// </returns>
    /// <remarks>
    /// When berserker enters FrenzyBeyondReason, the entire party gains
    /// 10 stress reduction at the next rest/recovery event.
    /// </remarks>
    int? GetPartyStressReduction(Guid characterId);
}
```

### 4.2 IMomentumService

**File:** `src/Core/RuneAndRust.Application/Services/Interfaces/IMomentumService.cs`

```csharp
namespace RuneAndRust.Application.Services.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service contract for managing Momentum resource for Storm Blade specialization.
/// </summary>
/// <remarks>
/// <para>
/// IMomentumService provides the application layer interface for all momentum-related
/// operations: gaining momentum, applying decay, tracking hits, and computing bonuses.
/// </para>
/// <para>
/// Key Responsibilities:
/// - Retrieve current momentum state
/// - Process momentum gain from various sources
/// - Apply decay on miss/stun
/// - Track consecutive hit chains
/// - Calculate threshold-based bonuses (attacks, defense, movement)
/// </para>
/// </remarks>
public interface IMomentumService
{
    /// <summary>
    /// Gets the current momentum state for a character.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// The character's MomentumState, or null if character has no momentum state.
    /// </returns>
    /// <remarks>
    /// Returns the immutable snapshot of the character's current momentum status.
    /// </remarks>
    MomentumState? GetMomentumState(Guid characterId);

    /// <summary>
    /// Applies momentum gain from a specified source.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="amount">Amount of momentum to gain (before chain bonuses).</param>
    /// <param name="source">The source of momentum generation.</param>
    /// <returns>
    /// A MomentumGainResult containing the transaction details, including
    /// chain bonus information and threshold change data.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Momentum is capped at 100. If addition would exceed cap, result.NewMomentum == 100.
    /// </para>
    /// <para>
    /// Gain sources:
    /// - SuccessfulAttack: flat 10
    /// - KillingBlow: flat 20
    /// - ChainAttack: ConsecutiveHits * 5
    /// - MovementAction: floor(DistanceMoved / 2)
    /// </para>
    /// </remarks>
    MomentumGainResult GainMomentum(Guid characterId, int amount, MomentumSource source);

    /// <summary>
    /// Applies momentum decay from a specified reason.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="reason">Description of why momentum is decaying (e.g., "Missed Attack").</param>
    /// <returns>
    /// A MomentumDecayResult containing the decay details and chain break status.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Decay amounts depend on reason:
    /// - Missed Attack: 25 flat
    /// - Stunned/Frozen: 100 (full reset)
    /// - No Action (idle turn): 15 flat
    /// </para>
    /// </remarks>
    MomentumDecayResult ApplyDecay(Guid characterId, string reason);

    /// <summary>
    /// Resets momentum to zero with a specified reason.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="reason">Reason for reset (e.g., "Stunned by spell").</param>
    /// <returns>
    /// A MomentumDecayResult with AmountDecayed == 100.
    /// </returns>
    /// <remarks>
    /// Used for hard resets (stun, freeze) vs gradual decay.
    /// Always resets ConsecutiveHits to 0.
    /// </remarks>
    MomentumDecayResult ResetMomentum(Guid characterId, string reason);

    /// <summary>
    /// Gets the number of bonus attacks from momentum.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// Bonus attack count (0-2), or 0 if character has no momentum state.
    /// </returns>
    /// <remarks>
    /// Scales with threshold: Stationary/Moving (0), Flowing/Surging (1), Unstoppable (2).
    /// </remarks>
    int GetBonusAttacks(Guid characterId);

    /// <summary>
    /// Gets the movement speed bonus from momentum.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// Movement bonus in squares (0-5), or 0 if character has no momentum state.
    /// </returns>
    /// <remarks>
    /// Calculated as floor(CurrentMomentum / 20).
    /// </remarks>
    int GetMovementBonus(Guid characterId);

    /// <summary>
    /// Gets the attack bonus from momentum.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// Attack bonus (0-4), or 0 if character has no momentum state.
    /// </returns>
    /// <remarks>
    /// Scales with threshold: Stationary (0), Moving (1), Flowing (2),
    /// Surging (3), Unstoppable (4).
    /// </remarks>
    int GetAttackBonus(Guid characterId);

    /// <summary>
    /// Gets the defense bonus from momentum.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// Defense bonus (0-4), or 0 if character has no momentum state.
    /// </returns>
    /// <remarks>
    /// Scales with threshold: Stationary (0), Moving (1), Flowing (2),
    /// Surging (3), Unstoppable (4).
    /// </remarks>
    int GetDefenseBonus(Guid characterId);

    /// <summary>
    /// Records a successful attack hit to build chain momentum.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <remarks>
    /// Increments ConsecutiveHits counter. Should be called after a successful attack hit.
    /// Also updates LastActionTime for idle tracking.
    /// </remarks>
    void RecordHit(Guid characterId);

    /// <summary>
    /// Records a failed attack to break momentum chain.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <remarks>
    /// Resets ConsecutiveHits to 0 and applies miss decay (25 momentum).
    /// Should be called after a failed attack roll.
    /// </remarks>
    void RecordMiss(Guid characterId);
}
```

### 4.3 ICoherenceService

**File:** `src/Core/RuneAndRust.Application/Services/Interfaces/ICoherenceService.cs`

```csharp
namespace RuneAndRust.Application.Services.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service contract for managing Coherence resource for Arcanist specialization.
/// </summary>
/// <remarks>
/// <para>
/// ICoherenceService provides the application layer interface for all coherence-related
/// operations: gaining/losing coherence, cascade checks, apotheosis management, and bonuses.
/// </para>
/// <para>
/// Key Responsibilities:
/// - Retrieve current coherence state
/// - Process coherence gain from various sources
/// - Apply coherence loss and decay
/// - Check cascade risk and apply effects
/// - Manage Apotheosis state transitions
/// - Calculate threshold-based bonuses (spell power, crit chance)
/// - Provide meditation interface
/// </para>
/// </remarks>
public interface ICoherenceService
{
    /// <summary>
    /// Gets the current coherence state for a character.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// The character's CoherenceState, or null if character has no coherence state.
    /// </returns>
    /// <remarks>
    /// Returns the immutable snapshot of the character's current coherence status.
    /// </remarks>
    CoherenceState? GetCoherenceState(Guid characterId);

    /// <summary>
    /// Applies coherence gain from a specified source.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="amount">Amount of coherence to gain.</param>
    /// <param name="source">The source of coherence generation.</param>
    /// <returns>
    /// True if gain was applied; false if character has no coherence state.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Coherence is capped at 100. Excess is discarded.
    /// </para>
    /// <para>
    /// Gain sources:
    /// - SuccessfulCast: flat 5
    /// - ControlledChannel: 3 per turn maintained
    /// - MeditationAction: flat 20 (outside combat only)
    /// - StabilityField: 1-10 variable
    /// </para>
    /// </remarks>
    bool GainCoherence(Guid characterId, int amount, CoherenceSource source);

    /// <summary>
    /// Applies coherence loss with a specified reason.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="amount">Amount of coherence to lose.</param>
    /// <param name="reason">Description of why coherence is being lost (e.g., "Failed Cast").</param>
    /// <returns>
    /// True if loss was applied; false if character has no coherence state.
    /// </returns>
    /// <remarks>
    /// Coherence cannot go below 0. Excess loss is clamped.
    /// Also updates LastCastTime if applicable.
    /// </remarks>
    bool LoseCoherence(Guid characterId, int amount, string reason);

    /// <summary>
    /// Checks whether a cascade effect should trigger.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// A CascadeResult indicating whether cascade triggered and its effects.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Cascade check:
    /// - Destabilized (0-20): 25% chance per cast
    /// - Unstable (21-40): 10% chance per cast
    /// - Balanced and above: 0% (no cascade)
    /// </para>
    /// <para>
    /// If cascade triggers, effect is determined from table (v0.19.x).
    /// This method only returns the result; actual effects applied by caller.
    /// </para>
    /// </remarks>
    CascadeResult CheckCascade(Guid characterId);

    /// <summary>
    /// Updates Apotheosis state and returns transition result.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// An ApotheosisResult indicating state changes and details.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Apotheosis Management:
    /// - Entry: When coherence >= 81, sets InApotheosis true
    /// - Maintenance: Costs 10 stress per turn
    /// - Exit: When coherence < 81, stress >= 100, or voluntary during non-combat
    /// </para>
    /// <para>
    /// Abilities are unlocked on first Apotheosis entry and persist.
    /// </para>
    /// </remarks>
    ApotheosisResult UpdateApotheosis(Guid characterId);

    /// <summary>
    /// Gets the spell power bonus from coherence.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// Spell power bonus (-2 to +5), or 0 if character has no coherence state.
    /// </returns>
    /// <remarks>
    /// Scales with threshold: Destabilized (-2), Unstable (-1), Balanced (0),
    /// Focused (+2), Apotheosis (+5).
    /// </remarks>
    int GetSpellPowerBonus(Guid characterId);

    /// <summary>
    /// Gets the critical casting chance bonus from coherence.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// Critical casting chance as percentage (0-20), or 0 if character has no coherence state.
    /// </returns>
    /// <remarks>
    /// Scales with threshold: Destabilized/Unstable (0%), Balanced (5%),
    /// Focused (10%), Apotheosis (20%).
    /// </remarks>
    int GetCriticalCastChance(Guid characterId);

    /// <summary>
    /// Determines if meditation is available for the character.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// True if meditation is available (outside combat), false otherwise.
    /// </returns>
    /// <remarks>
    /// Meditation is only available outside of combat.
    /// Apotheosis state does not prevent meditation outside combat.
    /// </remarks>
    bool CanMeditate(Guid characterId);

    /// <summary>
    /// Performs a meditation action to restore coherence.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// True if meditation was performed; false if not available or no coherence state.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Meditation grants 20 coherence and is only available outside combat.
    /// Can be interrupted by taking damage during meditation.
    /// </para>
    /// </remarks>
    bool Meditate(Guid characterId);
}
```

---

## 5. Dependency Injection

### 5.1 Service Registration

These services should be registered in the DI container during application startup:

```csharp
// In Startup.cs or Program.cs:

services.AddScoped<IRageService, RageService>();
services.AddScoped<IMomentumService, MomentumService>();
services.AddScoped<ICoherenceService, CoherenceService>();
```

### 5.2 Service Consumer Example

```csharp
// In handlers or other services:

public class CombatResolutionHandler
{
    private readonly IRageService _rageService;
    private readonly IMomentumService _momentumService;
    private readonly ICoherenceService _coherenceService;

    public CombatResolutionHandler(
        IRageService rageService,
        IMomentumService momentumService,
        ICoherenceService coherenceService)
    {
        _rageService = rageService;
        _momentumService = momentumService;
        _coherenceService = coherenceService;
    }

    public void ResolveDamage(Guid characterId, int damageAmount)
    {
        // Apply damage to health
        // ...

        // Update specialization resources
        _rageService.GainRage(characterId, damageAmount, RageSource.TakingDamage);
        _momentumService.RecordHit(characterId);
        // Coherence not affected by damage
    }
}
```

---

## 6. Deliverable Checklist

### 6.1 Service Interfaces

- [ ] `src/Core/RuneAndRust.Application/Services/Interfaces/IRageService.cs`
- [ ] `src/Core/RuneAndRust.Application/Services/Interfaces/IMomentumService.cs`
- [ ] `src/Core/RuneAndRust.Application/Services/Interfaces/ICoherenceService.cs`

### 6.2 Documentation

- [ ] Create `docs/design/v0.18.x/v0.18.4d-design-specification.md`
- [ ] Update `docs/design/v0.18.x/v0.18.4-scope-breakdown.md` (mark v0.18.4d complete)

---

## 7. Acceptance Criteria

### 7.1 Build Verification

- [ ] Solution builds without errors
- [ ] Solution builds without warnings in interface code

### 7.2 Interface Verification

- [ ] `IRageService` defines all 8 methods with full XML documentation
- [ ] `IMomentumService` defines all 10 methods with full XML documentation
- [ ] `ICoherenceService` defines all 9 methods with full XML documentation
- [ ] All parameters are documented with `<param>` tags
- [ ] All return values are documented with `<returns>` tags
- [ ] All exceptions are documented with `<exception>` tags where applicable
- [ ] Method names follow service conventions

### 7.3 Contract Verification

- [ ] Interfaces compile independently of implementations
- [ ] Interfaces reference correct domain types (enums, entities, value objects)
- [ ] Return types are consistent across similar operations
- [ ] Method signatures support async-ready return types

---

## 8. Dependencies

### 8.1 Required from Previous Phases

| Item                | Provided By | Used For                    |
| ------------------- | ----------- | --------------------------- |
| `RageState`         | v0.18.4a    | IRageService return type    |
| `RageSource`        | v0.18.4a    | GainRage source parameter   |
| `RageGainResult`    | v0.18.4a    | GainRage return type        |
| `MomentumState`     | v0.18.4b    | IMomentumService return type|
| `MomentumSource`    | v0.18.4b    | GainMomentum source param   |
| `MomentumGainResult`| v0.18.4b    | GainMomentum return type    |
| `CoherenceState`    | v0.18.4c    | ICoherenceService return    |
| `CoherenceSource`   | v0.18.4c    | GainCoherence source param  |
| `CascadeResult`     | v0.18.4c    | CheckCascade return type    |
| `ApotheosisResult`  | v0.18.4c    | UpdateApotheosis return     |

### 8.2 Deferred to Later Phases

| Item                         | Deferred To | Reason                  |
| ---------------------------- | ----------- | ----------------------- |
| Service implementations      | v0.18.4e    | Implementation separate |
| Configuration and persistence| v0.18.4f    | Infrastructure separate |

---

## 9. Future Considerations

### 9.1 v0.18.4e (Service Implementation)

- Full implementations of all three service interfaces
- Integration with persistence layer
- Logging and telemetry
- Event publishing for cascade/apotheosis triggers

### 9.2 v0.18.4f (Configuration & Persistence)

- Service-level configuration from JSON
- Database queries to load/persist resource state
- Service constructor dependency on `IConfigurationProvider`

### 9.3 v0.18.5 (Cross-Resource Interactions)

- Service methods for two-resource interactions
- Stress cost management (Apotheosis, panic effects)
- Party-wide effects (Party stress reduction from Rage)

---

## Changelog

| Version | Date       | Changes                              |
| ------- | ---------- | ------------------------------------ |
| 1.0     | 2026-01-28 | Initial interface design complete   |
