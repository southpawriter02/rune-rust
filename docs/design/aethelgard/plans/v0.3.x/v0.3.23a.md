# v0.3.23a: The Abstraction (Input Mapping) - Expanded Implementation Plan

## Overview

Replace all hardcoded `Console.ReadKey()` calls with a centralized `IInputService` that returns standardized `InputEvent` objects mapped to the `GameAction` enum (defined in v0.3.9c). This decouples the game engine from the physical keyboard, enabling:
- Key rebinding (already configured via `IInputConfigurationService`)
- Future macro support
- GUI integration pathway
- Testable input handling

**Parent Plan:** [v0.3.23](./v0.3.23.md)
**Status:** Planned

---

## Architecture Summary

### Key Design Decisions

1. **Create NEW `IInputService`** - Single entry point for all input reading
2. **Event Hierarchy** - `InputEvent` base with `ActionEvent`, `RawKeyEvent`, `MouseEvent` subtypes
3. **Integration with v0.3.9c** - Leverage existing `IInputConfigurationService` for key->command mapping
4. **Command to GameAction Translation** - Convert string commands ("north", "attack") to `GameAction` enum
5. **Preserve Raw Input Path** - `RawKeyEvent` for text entry (character names, debug console)
6. **Backward Compatible** - Existing `IInputHandler` unchanged; new system operates alongside

### Input Pipeline Architecture

```
+---------------------------------------------------------------------+
|                        INPUT PIPELINE                                |
+---------------------------------------------------------------------+
|                                                                      |
|  [Console.ReadKey()] -----> [IInputService.ReadNext()]              |
|         |                            |                               |
|         v                            v                               |
|  ConsoleKeyInfo              +------------------+                    |
|         |                    | IInputConfig     |                    |
|         |                    | Service          |                    |
|         |                    | GetCommandFor    |                    |
|         |                    | Key()            |                    |
|         |                    +--------+---------+                    |
|         |                             |                              |
|         v                             v                              |
|  +------------------------------------------------------+           |
|  |              INPUT EVENT RESOLUTION                   |           |
|  +------------------------------------------------------+           |
|  | 1. Is Global Hotkey? (~ for Debug Console)           |           |
|  |    +-- Yes -> SystemEvent(ToggleDebugConsole)        |           |
|  |    +-- No  -> Continue                               |           |
|  |                                                       |           |
|  | 2. Is Key Mapped? (via IInputConfigurationService)   |           |
|  |    +-- Yes -> Parse command string to GameAction     |           |
|  |    |          +-- Success -> ActionEvent(GameAction) |           |
|  |    |          +-- Fail    -> RawKeyEvent(key)        |           |
|  |    +-- No  -> RawKeyEvent(key)                       |           |
|  +------------------------------------------------------+           |
|                              |                                       |
|                              v                                       |
|                       [InputEvent]                                   |
|                    +---------+---------+                            |
|                    v         v         v                            |
|             ActionEvent  RawKeyEvent  MouseEvent                    |
|             (GameAction) (KeyInfo)    (X,Y,Click)                   |
|                                                                      |
+---------------------------------------------------------------------+
```

---

## Existing Infrastructure Analysis

### Current Console.ReadKey() Locations (9 total)

| File | Line(s) | Context | Refactor Strategy |
|------|---------|---------|-------------------|
| `Terminal/Services/OptionsController.cs` | 66, 467 | Menu navigation + key rebinding | Inject `IInputService`, switch on `ActionEvent` |
| `Terminal/Services/CreationWizard.cs` | 248, 306 | Selection steps (Lineage/Archetype) | Inject `IInputService`, handle both `ActionEvent` and `RawKeyEvent` |
| `Terminal/Rendering/DebugConsoleRenderer.cs` | 49 | Debug console modal loop | Inject `IInputService`, handle text input via `RawKeyEvent` |
| `Terminal/Rendering/TypewriterRenderer.cs` | 43 | Skip prologue on keypress | Use `IInputService.IsInputAvailable()` + `ReadNext()` |
| `Terminal/Helpers/ConsoleInputHelper.cs` | 19, 61 | Mouse event filtering | Wrap with `IInputService` internally |

### Existing Key Binding Infrastructure (v0.3.9c)

| Component | Location | Purpose |
|-----------|----------|---------|
| `IInputConfigurationService` | `Core/Interfaces/` | Load/save/query key bindings |
| `InputConfigurationService` | `Engine/Services/` | JSON-based binding storage |
| `GameAction` enum | `Core/Enums/GameAction.cs` | 22 semantic actions defined |
| Default bindings | `GetDefaults()` method | 22 keys -> command strings |

### GameAction Enum Coverage (v0.3.9c)

```csharp
// Movement (0-5)
MoveNorth, MoveSouth, MoveEast, MoveWest, MoveUp, MoveDown

// Core Actions (10-13)
Confirm, Cancel, Menu, Help

// Screen Navigation (20-23)
Inventory, Character, Journal, Crafting

// Gameplay Actions (30-33)
Interact, Look, Search, Wait

// Combat Actions (40-44)
Attack, LightAttack, HeavyAttack, UseAbility, Flee
```

### Command String to GameAction Mapping Required

| Command String | GameAction |
|----------------|------------|
| `"north"` | `GameAction.MoveNorth` |
| `"south"` | `GameAction.MoveSouth` |
| `"east"` | `GameAction.MoveEast` |
| `"west"` | `GameAction.MoveWest` |
| `"up"` | `GameAction.MoveUp` |
| `"down"` | `GameAction.MoveDown` |
| `"confirm"` | `GameAction.Confirm` |
| `"cancel"` | `GameAction.Cancel` |
| `"menu"` | `GameAction.Menu` |
| `"help"` | `GameAction.Help` |
| `"inventory"` | `GameAction.Inventory` |
| `"character"` | `GameAction.Character` |
| `"journal"` | `GameAction.Journal` |
| `"bench"` | `GameAction.Crafting` |
| `"interact"` | `GameAction.Interact` |
| `"look"` | `GameAction.Look` |
| `"search"` | `GameAction.Search` |
| `"wait"` | `GameAction.Wait` |
| `"attack"` | `GameAction.Attack` |
| `"light"` | `GameAction.LightAttack` |
| `"heavy"` | `GameAction.HeavyAttack` |

---

## Files to Create (5 new files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/Input/InputEvent.cs` | Base record + ActionEvent, RawKeyEvent, MouseEvent |
| `RuneAndRust.Core/Interfaces/IInputService.cs` | Input abstraction interface |
| `RuneAndRust.Engine/Services/InputService.cs` | Implementation with key->action mapping |
| `RuneAndRust.Engine/Helpers/CommandToActionMapper.cs` | Static utility to convert command strings to GameAction |
| `RuneAndRust.Tests/Engine/InputServiceTests.cs` | Unit tests for input mapping |

## Files to Modify (6 existing files)

| File | Changes |
|------|---------|
| `RuneAndRust.Terminal/Services/OptionsController.cs` | Replace `Console.ReadKey()` with `IInputService.ReadNext()` |
| `RuneAndRust.Terminal/Services/CreationWizard.cs` | Replace `Console.ReadKey()` in selection loops |
| `RuneAndRust.Terminal/Rendering/DebugConsoleRenderer.cs` | Replace `Console.ReadKey()` in modal loop |
| `RuneAndRust.Terminal/Rendering/TypewriterRenderer.cs` | Replace `Console.KeyAvailable` + `ReadKey()` with `IInputService` |
| `RuneAndRust.Terminal/Helpers/ConsoleInputHelper.cs` | Update to use `IInputService` internally |
| `RuneAndRust.Terminal/Program.cs` | Register `IInputService` in DI container |

---

## Implementation Order

1. Create `InputEvent` record hierarchy
2. Create `IInputService` interface
3. Create `CommandToActionMapper` helper
4. Implement `InputService`
5. Register in DI (`Program.cs`)
6. Create unit tests
7. Refactor `OptionsController` (simplest consumer)
8. Refactor `CreationWizard`
9. Refactor `DebugConsoleRenderer`
10. Refactor `TypewriterRenderer`
11. Update `ConsoleInputHelper` if needed
12. Build and verify all tests pass

---

## Detailed Code Specifications

### 1. InputEvent Record Hierarchy

**File:** `RuneAndRust.Core/Models/Input/InputEvent.cs`

```csharp
namespace RuneAndRust.Core.Models.Input;

using RuneAndRust.Core.Enums;

/// <summary>
/// Base record for all input events in the system.
/// Represents a single discrete input from the user.
/// </summary>
public abstract record InputEvent
{
    /// <summary>
    /// Timestamp when the input was captured.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Represents a semantic game action (e.g., MoveNorth, Attack, Confirm).
/// These are the primary events consumed by game logic.
/// </summary>
/// <param name="Action">The resolved game action.</param>
public record ActionEvent(GameAction Action) : InputEvent
{
    /// <summary>
    /// The original key that triggered this action (for debugging/rebind UI).
    /// </summary>
    public ConsoleKey? SourceKey { get; init; }
}

/// <summary>
/// Represents a raw key press that wasn't mapped to an action.
/// Used for text input scenarios (character names, debug console commands).
/// </summary>
/// <param name="KeyInfo">The raw console key information.</param>
public record RawKeyEvent(ConsoleKeyInfo KeyInfo) : InputEvent
{
    /// <summary>
    /// The printable character for this key press (if any).
    /// </summary>
    public char Character => KeyInfo.KeyChar;

    /// <summary>
    /// Whether this key produces a printable character.
    /// </summary>
    public bool IsPrintable => !char.IsControl(KeyInfo.KeyChar);
}

/// <summary>
/// Represents a system-level event (debug console toggle, screenshot, etc.).
/// These bypass normal action handling.
/// </summary>
/// <param name="EventType">The type of system event.</param>
public record SystemEvent(SystemEventType EventType) : InputEvent;

/// <summary>
/// Types of system-level input events.
/// </summary>
public enum SystemEventType
{
    /// <summary>Toggle the debug console (~ key).</summary>
    ToggleDebugConsole,

    /// <summary>Take a screenshot (future).</summary>
    Screenshot
}

/// <summary>
/// Represents a mouse interaction (v0.3.23c preparation).
/// </summary>
/// <param name="X">X coordinate in console cells.</param>
/// <param name="Y">Y coordinate in console cells.</param>
/// <param name="IsLeftClick">True for left click, false for right click.</param>
public record MouseEvent(int X, int Y, bool IsLeftClick) : InputEvent;
```

### 2. IInputService Interface

**File:** `RuneAndRust.Core/Interfaces/IInputService.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

using RuneAndRust.Core.Models.Input;

/// <summary>
/// Abstracted input service that converts raw keyboard input into semantic events.
/// Integrates with IInputConfigurationService for key binding resolution.
/// </summary>
/// <remarks>
/// See: SPEC-INPUT-001 for Input System design.
/// v0.3.23a: Initial blocking implementation.
/// v0.3.23b: Will add async/non-blocking support.
/// </remarks>
public interface IInputService
{
    /// <summary>
    /// Reads the next input event, blocking until input is available.
    /// </summary>
    /// <returns>The resolved input event (ActionEvent, RawKeyEvent, or SystemEvent).</returns>
    InputEvent ReadNext();

    /// <summary>
    /// Reads the next input event, blocking until input is available.
    /// Filters out mouse escape sequences and invalid keys.
    /// </summary>
    /// <param name="filterMouseEvents">If true, filters out mouse tracking escape sequences.</param>
    /// <returns>The resolved input event.</returns>
    InputEvent ReadNextFiltered(bool filterMouseEvents = true);

    /// <summary>
    /// Checks if input is available without blocking.
    /// </summary>
    /// <returns>True if a key press is waiting in the buffer.</returns>
    bool IsInputAvailable();

    /// <summary>
    /// Attempts to read input without blocking.
    /// </summary>
    /// <param name="inputEvent">The input event if available.</param>
    /// <returns>True if input was available and read.</returns>
    bool TryReadNext(out InputEvent? inputEvent);

    /// <summary>
    /// Clears any pending input from the buffer.
    /// Useful after screen transitions to prevent accidental actions.
    /// </summary>
    void ClearInputBuffer();
}
```

### 3. CommandToActionMapper Helper

**File:** `RuneAndRust.Engine/Helpers/CommandToActionMapper.cs`

```csharp
namespace RuneAndRust.Engine.Helpers;

using RuneAndRust.Core.Enums;

/// <summary>
/// Maps command strings (from key bindings) to GameAction enum values.
/// Provides the translation layer between IInputConfigurationService and GameAction.
/// </summary>
public static class CommandToActionMapper
{
    private static readonly Dictionary<string, GameAction> CommandMap = new(StringComparer.OrdinalIgnoreCase)
    {
        // Movement
        { "north", GameAction.MoveNorth },
        { "south", GameAction.MoveSouth },
        { "east", GameAction.MoveEast },
        { "west", GameAction.MoveWest },
        { "up", GameAction.MoveUp },
        { "down", GameAction.MoveDown },

        // Core Actions
        { "confirm", GameAction.Confirm },
        { "cancel", GameAction.Cancel },
        { "menu", GameAction.Menu },
        { "help", GameAction.Help },

        // Screen Navigation
        { "inventory", GameAction.Inventory },
        { "character", GameAction.Character },
        { "journal", GameAction.Journal },
        { "bench", GameAction.Crafting },

        // Gameplay
        { "interact", GameAction.Interact },
        { "look", GameAction.Look },
        { "search", GameAction.Search },
        { "wait", GameAction.Wait },

        // Combat
        { "attack", GameAction.Attack },
        { "light", GameAction.LightAttack },
        { "heavy", GameAction.HeavyAttack }
    };

    /// <summary>
    /// Attempts to map a command string to a GameAction.
    /// </summary>
    /// <param name="command">The command string (e.g., "north", "attack").</param>
    /// <param name="action">The resolved GameAction if successful.</param>
    /// <returns>True if mapping succeeded.</returns>
    public static bool TryMapCommand(string command, out GameAction action)
    {
        return CommandMap.TryGetValue(command, out action);
    }

    /// <summary>
    /// Gets all registered command-to-action mappings.
    /// </summary>
    public static IReadOnlyDictionary<string, GameAction> GetAllMappings() => CommandMap;
}
```

### 4. InputService Implementation

**File:** `RuneAndRust.Engine/Services/InputService.cs`

```csharp
namespace RuneAndRust.Engine.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Input;
using RuneAndRust.Engine.Helpers;

/// <summary>
/// Centralized input service that reads console input and converts it to semantic events.
/// Integrates with IInputConfigurationService for key binding lookup.
/// </summary>
/// <remarks>
/// See: SPEC-INPUT-001 for Input System design.
/// v0.3.23a: Blocking implementation.
/// </remarks>
public class InputService : IInputService
{
    private readonly ILogger<InputService> _logger;
    private readonly IInputConfigurationService _config;

    /// <summary>
    /// The debug console toggle key (tilde).
    /// </summary>
    private const ConsoleKey DebugConsoleKey = ConsoleKey.Oem3;

    /// <summary>
    /// Initializes a new instance of the <see cref="InputService"/> class.
    /// </summary>
    /// <param name="logger">The logger for traceability.</param>
    /// <param name="config">The input configuration service for key binding lookup.</param>
    public InputService(
        ILogger<InputService> logger,
        IInputConfigurationService config)
    {
        _logger = logger;
        _config = config;
    }

    /// <inheritdoc/>
    public InputEvent ReadNext()
    {
        var keyInfo = Console.ReadKey(intercept: true);
        return ResolveKeyToEvent(keyInfo);
    }

    /// <inheritdoc/>
    public InputEvent ReadNextFiltered(bool filterMouseEvents = true)
    {
        while (true)
        {
            var keyInfo = Console.ReadKey(intercept: true);

            if (filterMouseEvents)
            {
                // Filter out escape sequences from mouse events
                if (keyInfo.Key == ConsoleKey.Escape)
                {
                    DrainEscapeSequence();
                    continue;
                }

                // Filter out null/empty key events from mouse tracking
                if (keyInfo.KeyChar == '\0' && keyInfo.Key == 0)
                {
                    continue;
                }
            }

            return ResolveKeyToEvent(keyInfo);
        }
    }

    /// <inheritdoc/>
    public bool IsInputAvailable()
    {
        return Console.KeyAvailable;
    }

    /// <inheritdoc/>
    public bool TryReadNext(out InputEvent? inputEvent)
    {
        if (!Console.KeyAvailable)
        {
            inputEvent = null;
            return false;
        }

        inputEvent = ReadNext();
        return true;
    }

    /// <inheritdoc/>
    public void ClearInputBuffer()
    {
        while (Console.KeyAvailable)
        {
            Console.ReadKey(intercept: true);
        }
        _logger.LogTrace("[Input] Input buffer cleared");
    }

    /// <summary>
    /// Resolves a raw key press to an InputEvent.
    /// </summary>
    private InputEvent ResolveKeyToEvent(ConsoleKeyInfo keyInfo)
    {
        // 1. Check for system-level hotkeys
        if (keyInfo.Key == DebugConsoleKey)
        {
            _logger.LogTrace("[Input] System event: ToggleDebugConsole");
            return new SystemEvent(SystemEventType.ToggleDebugConsole);
        }

        // 2. Check for mapped actions via IInputConfigurationService
        var command = _config.GetCommandForKey(keyInfo.Key);

        if (command != null && CommandToActionMapper.TryMapCommand(command, out var action))
        {
            _logger.LogTrace("[Input] Mapped {Key} -> {Command} -> {Action}",
                keyInfo.Key, command, action);
            return new ActionEvent(action) { SourceKey = keyInfo.Key };
        }

        // 3. Fallback to raw key event
        _logger.LogTrace("[Input] Raw key: {Key} ('{Char}')",
            keyInfo.Key,
            char.IsControl(keyInfo.KeyChar) ? "\\0" : keyInfo.KeyChar.ToString());
        return new RawKeyEvent(keyInfo);
    }

    /// <summary>
    /// Drains any remaining characters from an escape sequence.
    /// </summary>
    private void DrainEscapeSequence()
    {
        Thread.Sleep(10);
        while (Console.KeyAvailable)
        {
            Console.ReadKey(intercept: true);
        }
    }
}
```

---

## Consumer Refactoring Patterns

### Pattern A: Menu Navigation (OptionsController, CreationWizard)

**Before:**
```csharp
var key = Console.ReadKey(intercept: true);
switch (key.Key)
{
    case ConsoleKey.UpArrow:
    case ConsoleKey.K:
        NavigateUp(vm);
        break;
    case ConsoleKey.Enter:
        HandleConfirm(vm);
        break;
    case ConsoleKey.Escape:
        return;
}
```

**After:**
```csharp
var inputEvent = _inputService.ReadNext();
switch (inputEvent)
{
    case ActionEvent { Action: GameAction.MoveNorth }:
        NavigateUp(vm);
        break;
    case ActionEvent { Action: GameAction.Confirm }:
        HandleConfirm(vm);
        break;
    case ActionEvent { Action: GameAction.Cancel }:
        return;
    case RawKeyEvent { KeyInfo.Key: ConsoleKey.K }:
        NavigateUp(vm); // Vim-style backup
        break;
}
```

### Pattern B: Text Input (DebugConsoleRenderer)

**Before:**
```csharp
var key = Console.ReadKey(intercept: true);
if (!char.IsControl(key.KeyChar))
{
    inputBuffer += key.KeyChar;
}
```

**After:**
```csharp
var inputEvent = _inputService.ReadNext();
switch (inputEvent)
{
    case RawKeyEvent rawKey when rawKey.IsPrintable:
        inputBuffer += rawKey.Character;
        break;
    case ActionEvent { Action: GameAction.Confirm }:
        ProcessCommand(inputBuffer);
        break;
    case SystemEvent { EventType: SystemEventType.ToggleDebugConsole }:
        _console.Toggle();
        break;
}
```

### Pattern C: Skip Functionality (TypewriterRenderer)

**Before:**
```csharp
if (Console.KeyAvailable)
{
    Console.ReadKey(intercept: true);
    // Skip to end
}
```

**After:**
```csharp
if (_inputService.IsInputAvailable())
{
    _inputService.ReadNext(); // Consume the skip input
    // Skip to end
}
```

---

## Context-Aware Action Handling

The same `GameAction` may have different meanings based on game phase:

| GameAction | Exploration Phase | Combat Phase | Menu Phase |
|------------|-------------------|--------------|------------|
| `MoveNorth` | Execute `go north` | Move cursor up | Navigate up |
| `Confirm` | Interact with object | Confirm target | Select option |
| `Cancel` | Open menu | Cancel targeting | Close menu |

This is handled at the **consumer level**, not in `InputService`. Each controller interprets `ActionEvent` based on its context.

---

## Test Coverage (~15 tests)

### InputServiceTests.cs

| Test Name | Description |
|-----------|-------------|
| `ReadNext_MappedKey_ReturnsActionEvent` | 'W' bound to "north" -> `ActionEvent(MoveNorth)` |
| `ReadNext_UnmappedKey_ReturnsRawKeyEvent` | Unbound 'Z' -> `RawKeyEvent` |
| `ReadNext_TildeKey_ReturnsSystemEvent` | '~' -> `SystemEvent(ToggleDebugConsole)` |
| `ReadNext_EnterKey_ReturnsConfirmAction` | Enter -> `ActionEvent(Confirm)` |
| `ReadNext_EscapeKey_ReturnsCancelAction` | Escape -> `ActionEvent(Cancel)` |
| `TryReadNext_NoInput_ReturnsFalse` | No key in buffer -> false |
| `TryReadNext_InputAvailable_ReturnsTrue` | Key in buffer -> true + event |
| `IsInputAvailable_NoInput_ReturnsFalse` | Empty buffer -> false |
| `ClearInputBuffer_ClearsAllPendingInput` | Multiple keys cleared |
| `ReadNext_PreservesSourceKey` | `ActionEvent.SourceKey` matches input |

### CommandToActionMapperTests.cs

| Test Name | Description |
|-----------|-------------|
| `TryMapCommand_ValidCommand_ReturnsTrue` | "north" -> `MoveNorth` |
| `TryMapCommand_InvalidCommand_ReturnsFalse` | "invalid" -> false |
| `TryMapCommand_CaseInsensitive` | "NORTH" = "north" = "North" |
| `GetAllMappings_Returns22Entries` | All GameAction values covered |

---

## Logging Matrix

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Input | Map Success | Trace | `[Input] Mapped {Key} -> {Command} -> {Action}` | Key, Command, Action |
| Input | Raw Key | Trace | `[Input] Raw key: {Key} ('{Char}')` | Key, Char |
| Input | System Event | Trace | `[Input] System event: {EventType}` | EventType |
| Input | Buffer Clear | Trace | `[Input] Input buffer cleared` | - |

---

## Deliverable Checklist (v0.3.23a)

### Core Layer
- [ ] Create `RuneAndRust.Core/Models/Input/InputEvent.cs`
- [ ] Create `RuneAndRust.Core/Interfaces/IInputService.cs`
- [ ] Add `SystemEventType` enum

### Engine Layer
- [ ] Create `RuneAndRust.Engine/Helpers/CommandToActionMapper.cs`
- [ ] Create `RuneAndRust.Engine/Services/InputService.cs`

### Terminal Layer
- [ ] Register `IInputService` in `Program.cs`
- [ ] Refactor `OptionsController.cs` to use `IInputService`
- [ ] Refactor `CreationWizard.cs` to use `IInputService`
- [ ] Refactor `DebugConsoleRenderer.cs` to use `IInputService`
- [ ] Refactor `TypewriterRenderer.cs` to use `IInputService`

### Testing
- [ ] Create `RuneAndRust.Tests/Engine/InputServiceTests.cs` (~10 tests)
- [ ] Create `RuneAndRust.Tests/Engine/CommandToActionMapperTests.cs` (~5 tests)

---

## Critical Files Reference

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/GameAction.cs` | Existing 22-value enum (read-only) |
| `RuneAndRust.Core/Interfaces/IInputConfigurationService.cs` | Key binding lookup interface |
| `RuneAndRust.Engine/Services/InputConfigurationService.cs` | JSON binding implementation |
| `RuneAndRust.Terminal/Services/OptionsController.cs` | Primary refactor target (66, 467) |
| `RuneAndRust.Terminal/Services/CreationWizard.cs` | Selection loop refactor (248, 306) |
| `RuneAndRust.Terminal/Rendering/DebugConsoleRenderer.cs` | Modal loop refactor (49) |
| `RuneAndRust.Terminal/Rendering/TypewriterRenderer.cs` | Skip logic refactor (43) |
| `RuneAndRust.Terminal/Program.cs` | DI registration |

---

## Migration Notes

### Backward Compatibility
- `IInputHandler` (GetInput, DisplayMessage, DisplayError) remains unchanged
- `ScriptedInputHandler` for testing continues to work
- `GameService` game loop still uses `IInputHandler.GetInput()` for command text

### v0.3.23b Preparation
- `IInputService` methods designed for easy async upgrade
- `ReadNextAsync()` and `TryReadNextAsync()` will be added
- Event loop will poll `IsInputAvailable()` with timeout

### v0.3.23c Preparation
- `MouseEvent` record already defined but not yet populated
- `InputService` will gain mouse sequence parsing in v0.3.23c

---

## Estimated Metrics

| Metric | Value |
|--------|-------|
| New Files | 5 |
| Modified Files | 6 |
| New Lines (Services) | ~250 |
| New Lines (Tests) | ~200 |
| New Unit Tests | ~15 |
| Console.ReadKey() Calls Replaced | 9 |

**End of Plan**
