# v0.15.1e Design Specification: Integration Points

**Version:** 0.15.1e
**Theme:** Integration Points
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0 Complete (Dice Pool Refactor), v0.15.1a-v0.15.1d Complete (Skill Infrastructure)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [SkillStressResult Value Object](#4-skillstressresult-value-object)
5. [StressSource Enum](#5-stresssource-enum)
6. [ITraumaIntegrationService Interface](#6-itraumaintegrationservice-interface)
7. [TraumaIntegrationService Implementation](#7-traumaintegrationservice-implementation)
8. [SpecializationSkillBonus Value Object](#8-specializationskillbonus-value-object)
9. [ISpecializationBonusProvider Interface](#9-ispecializationbonusprovider-interface)
10. [SpecializationBonusProvider Implementation](#10-specializationbonusprovider-implementation)
11. [SkillDescriptor Value Object](#11-skilldescriptor-value-object)
12. [IVoiceGuidanceService Interface](#12-ivoiceguidanceservice-interface)
13. [VoiceGuidanceService Implementation](#13-voiceguidanceservice-implementation)
14. [Configuration - Skill Descriptors](#14-configuration---skill-descriptors)
15. [Configuration - Specialization Bonuses](#15-configuration---specialization-bonuses)
16. [Data Model Changes](#16-data-model-changes)
17. [SkillCheckService Integration](#17-skillcheckservice-integration)
18. [Logging Specifications](#18-logging-specifications)
19. [Unit Testing Requirements](#19-unit-testing-requirements)
20. [Use Cases](#20-use-cases)
21. [Deliverable Checklist](#21-deliverable-checklist)
22. [Acceptance Criteria](#22-acceptance-criteria)
23. [Future Considerations](#23-future-considerations)
24. [Document Metadata](#24-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.1e, the Integration Points phase. This phase connects the skill system infrastructure (built in v0.15.1a-v0.15.1d) with three key game systems:

1. **Trauma Economy Integration**: Connects skill checks to the psychic stress system. Corrupted objects and areas inflict stress during skill interactions. Fumbles in stressful situations add bonus stress. Breaking point checks may trigger after particularly stressful skill checks.

2. **Specialization Bonus Hooks**: Provides archetype-specific modifiers to skill checks. Each specialization can grant skill bonuses that are conditionally evaluated based on context. For example, a Gantry-Runner gets climbing bonuses, while a Myrk-gengr maintains [Hidden] status more easily.

3. **Voice Guidance Integration**: Provides narrative descriptors for skill check outcomes. Each skill has pools of flavor text that vary by outcome category (Catastrophic through Masterful) and context (surface type, target disposition, etc.).

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Corruption Stress** | CorruptionTier affects DC only | CorruptionTier also inflicts `PsychicStress` |
| **Fumble Stress** | Fumbles create consequences only | Fumbles also inflict bonus stress |
| **Stress Triggers** | Not connected to skills | Breaking point checks after skill checks |
| **Specialization Bonuses** | Not implemented | `ISpecializationBonusProvider` with context-aware bonuses |
| **Skill Descriptors** | Not implemented | `IVoiceGuidanceService` with skill-specific text pools |
| **Context-Aware Text** | Generic outcomes | Surface, target, situation influence narrative |

### 1.3 Scope

**In Scope:**
- Define `SkillStressResult` value object for stress application results
- Define `StressSource` enum for categorizing stress origins
- Create `ITraumaIntegrationService` interface for stress application
- Implement `TraumaIntegrationService` for corruption and fumble stress
- Define `SpecializationSkillBonus` value object for archetype bonuses
- Create `ISpecializationBonusProvider` interface for bonus lookup
- Implement `SpecializationBonusProvider` with JSON configuration
- Define `SkillDescriptor` value object for narrative text
- Create `IVoiceGuidanceService` interface for descriptor lookup
- Implement `VoiceGuidanceService` with skill-specific pools
- Configuration file `skill-descriptors.json`
- Configuration file `specialization-bonuses.json`
- Unit tests for integration points (~3 tests per scope breakdown)

**Out of Scope:**
- Actual psychic stress meter implementation - requires v0.19.x Trauma System
- Breaking point check mechanics - requires v0.19.x Trauma System
- Wild magic surge integration - requires v0.17.x Magic System
- Skill-specific specialization abilities - v0.15.2-v0.15.5
- UI for displaying stress accumulation - future version
- Localization of descriptors - future version

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Value Objects | 3 | `SkillStressResult`, `SpecializationSkillBonus`, `SkillDescriptor` |
| Enums | 1 | `StressSource` |
| Interfaces | 3 | `ITraumaIntegrationService`, `ISpecializationBonusProvider`, `IVoiceGuidanceService` |
| Services | 3 | `TraumaIntegrationService`, `SpecializationBonusProvider`, `VoiceGuidanceService` |
| Configuration | 2 | `skill-descriptors.json`, `specialization-bonuses.json` |
| Unit Tests | ~3 | Corruption stress, specialization bonuses, voice guidance |

---

## 2. Dependencies

### 2.1 Required from v0.15.1a (Skill Context & Modifiers)

| Component | Location | Usage in v0.15.1e |
|-----------|----------|-------------------|
| `SkillContext` | `Domain/ValueObjects/SkillContext.cs` | Provides corruption tier and context for stress calculation |
| `EnvironmentModifier` | `Domain/ValueObjects/EnvironmentModifier.cs` | Contains `CorruptionTier` for stress calculation |
| `CorruptionTier` | `Domain/Enums/CorruptionTier.cs` | Determines stress cost from corrupted objects |
| `ISkillContextBuilder` | `Domain/Interfaces/ISkillContextBuilder.cs` | Extended to include specialization bonuses |

### 2.2 Required from v0.15.1b (Outcome Classification)

| Component | Location | Usage in v0.15.1e |
|-----------|----------|-------------------|
| `OutcomeDetails` | `Domain/ValueObjects/OutcomeDetails.cs` | Provides `IsFumble` flag for bonus stress |
| `DescriptorCategory` | `Domain/Enums/DescriptorCategory.cs` | Maps outcomes to descriptor pools |
| `SkillOutcome` | `Domain/Enums/SkillOutcome.cs` | Outcome tier for descriptor selection |
| `FumbleConsequence` | `Domain/Entities/FumbleConsequence.cs` | Fumble context for stress calculation |

### 2.3 Required from v0.15.0c (Skill Check Refactor)

| Component | Location | Usage in v0.15.1e |
|-----------|----------|-------------------|
| `SkillCheckResult` | `Domain/ValueObjects/SkillCheckResult.cs` | Extended to include stress and descriptor |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Integrated with all three systems |

### 2.4 Required from Existing Systems

| Component | Location | Usage in v0.15.1e |
|-----------|----------|-------------------|
| `Player.SpecializationId` | `Domain/Entities/Player.cs` | Lookup key for specialization bonuses |
| `SkillId` | Skills configuration | Skill identification for descriptors |

### 2.5 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.2 | Acrobatics | Uses voice guidance for climbing, leaping, stealth outcomes |
| v0.15.3 | Rhetoric | Uses voice guidance for persuasion, deception, intimidation outcomes |
| v0.15.4 | System Bypass | Uses voice guidance for lockpicking, hacking, trap outcomes |
| v0.15.5 | Wasteland Survival | Uses voice guidance for tracking, foraging, navigation outcomes |
| v0.19.x | Trauma System | Consumes `SkillStressResult` for actual stress meter updates |

---

## 3. Architecture Diagrams

### 3.1 Integration Points Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      SKILL SYSTEM INTEGRATION POINTS                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SKILL CHECK REQUEST                                                        │
│  Player performs skill check in corrupted area                              │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                     SKILL CHECK SERVICE                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  1. Build SkillContext (v0.15.1a)                                   │    │
│  │  2. Get Specialization Bonuses ────────→ ISpecializationBonusProvider│   │
│  │  3. Perform Dice Roll (v0.15.0)                                     │    │
│  │  4. Classify Outcome (v0.15.1b)                                     │    │
│  │  5. Calculate Stress ──────────────────→ ITraumaIntegrationService  │    │
│  │  6. Get Voice Descriptor ──────────────→ IVoiceGuidanceService      │    │
│  │  7. Return SkillCheckResult                                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    ENHANCED SKILL CHECK RESULT                       │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  DiceResult: { NetSuccesses: 2, IsFumble: false }                   │    │
│  │  OutcomeDetails: { Outcome: FullSuccess, Margin: 1 }                │    │
│  │  StressResult: { TotalStress: 4, Source: Corruption }        ← NEW  │    │
│  │  Descriptor: "The lock yields to your practiced fingers."   ← NEW  │    │
│  │  SpecializationBonus: +1d10 (Scrap-Tinker)                   ← NEW  │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Trauma Integration Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       TRAUMA INTEGRATION FLOW                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INPUT: SkillContext + OutcomeDetails                                       │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  1. CALCULATE CORRUPTION STRESS                                      │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  CorruptionTier → Stress Cost                                       │    │
│  │  ├── Normal     → 0 stress (no psychic interference)               │    │
│  │  ├── Glitched   → 2 stress (minor psychic noise)                   │    │
│  │  ├── Blighted   → 5 stress (significant corruption)                │    │
│  │  └── Resonance  → 10 stress (direct Blight exposure)               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  2. ADD FUMBLE BONUS STRESS                                          │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  if (OutcomeDetails.IsFumble)                                       │    │
│  │  {                                                                   │    │
│  │      // Fumble in corrupted area amplifies stress                   │    │
│  │      FumbleBonus = CorruptionTier switch                            │    │
│  │      {                                                               │    │
│  │          Normal     → 1 stress (baseline fumble stress)             │    │
│  │          Glitched   → 2 stress (corruption amplifies failure)       │    │
│  │          Blighted   → 4 stress (Blight punishes mistakes)           │    │
│  │          Resonance  → 8 stress (catastrophic psychic backlash)      │    │
│  │      };                                                              │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  3. CHECK FOR BREAKING POINT TRIGGER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  TotalStress = CorruptionStress + FumbleBonus                       │    │
│  │                                                                      │    │
│  │  TriggersBreakingPoint = TotalStress >= BreakingPointThreshold (8)  │    │
│  │                                                                      │    │
│  │  // Breaking point check is handled by v0.19.x Trauma System        │    │
│  │  // We only signal that a check may be needed                       │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  OUTPUT: SkillStressResult                                                  │
│  { TotalStress: 12, Source: Fumble, TriggersBreakingPoint: true }          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Specialization Bonus Resolution

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SPECIALIZATION BONUS RESOLUTION                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INPUT: SpecializationId + SkillId + SkillContext                          │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  1. LOOKUP SPECIALIZATION BONUSES                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Example: Player is "Gantry-Runner", attempting "climbing" check    │    │
│  │                                                                      │    │
│  │  specialization-bonuses.json:                                       │    │
│  │  {                                                                   │    │
│  │    "gantry-runner": {                                                │    │
│  │      "skills": {                                                     │    │
│  │        "climbing": { "diceBonus": 2 },                              │    │
│  │        "leaping": { "diceBonus": 1 }                                │    │
│  │      }                                                               │    │
│  │    }                                                                 │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  2. EVALUATE CONDITIONAL BONUSES                                     │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Some bonuses are conditional on context:                           │    │
│  │                                                                      │    │
│  │  "myr-stalker": {                                                   │    │
│  │    "skills": {                                                       │    │
│  │      "navigation": {                                                 │    │
│  │        "diceBonus": 2,                                              │    │
│  │        "condition": { "biome": ["swamp", "marsh", "bog"] }          │    │
│  │      }                                                               │    │
│  │    }                                                                 │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  │  if (SkillContext.Biome in ["swamp", "marsh", "bog"])               │    │
│  │      → Apply +2d10 bonus                                            │    │
│  │  else                                                                │    │
│  │      → No bonus (condition not met)                                 │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  3. CHECK FOR SPECIAL ABILITIES                                      │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  "thul": {                                                          │    │
│  │    "skills": {                                                       │    │
│  │      "persuasion": {                                                 │    │
│  │        "diceBonus": 1,                                              │    │
│  │        "special": "no-reputation-loss-on-failure"                   │    │
│  │      }                                                               │    │
│  │    }                                                                 │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  │  Special abilities are flagged for the skill system to handle      │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  OUTPUT: SpecializationSkillBonus                                           │
│  { SpecializationId: "gantry-runner", SkillId: "climbing",                 │
│    DiceBonus: 2, Description: "Gantry-Runner: Urban Acrobat" }             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Voice Guidance Resolution

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      VOICE GUIDANCE RESOLUTION                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INPUT: SkillId + DescriptorCategory + SkillContext                        │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  1. LOOKUP SKILL-SPECIFIC DESCRIPTOR POOL                            │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  skill-descriptors.json:                                            │    │
│  │  {                                                                   │    │
│  │    "lockpicking": {                                                  │    │
│  │      "competent": [                                                  │    │
│  │        "The lock yields to your practiced fingers.",                │    │
│  │        "Tumblers click into place with satisfying precision.",      │    │
│  │        "Your picks find the path through the mechanism."            │    │
│  │      ],                                                              │    │
│  │      "catastrophic": [                                               │    │
│  │        "The mechanism jams with a grinding screech.",               │    │
│  │        "Something snaps deep within the lock."                      │    │
│  │      ]                                                               │    │
│  │    }                                                                 │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  2. CHECK FOR CONTEXT-SPECIFIC VARIANTS                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Context: Corruption = Glitched                                     │    │
│  │                                                                      │    │
│  │  "lockpicking": {                                                    │    │
│  │    "competent": {                                                    │    │
│  │      "default": [...],                                              │    │
│  │      "glitched": [                                                   │    │
│  │        "Reality shudders as the lock opens unexpectedly.",          │    │
│  │        "The mechanism phases briefly before clicking open."         │    │
│  │      ]                                                               │    │
│  │    }                                                                 │    │
│  │  }                                                                   │    │
│  │                                                                      │    │
│  │  Priority: context-specific > default                               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  3. SELECT RANDOM DESCRIPTOR FROM POOL                               │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  // Use seeded random for deterministic testing                     │    │
│  │  var pool = GetDescriptorPool(skillId, category, context);          │    │
│  │  var descriptor = pool[random.Next(pool.Count)];                    │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  OUTPUT: SkillDescriptor                                                    │
│  { SkillId: "lockpicking", Category: Competent,                            │
│    Text: "Reality shudders as the lock opens unexpectedly.",               │
│    IsContextual: true, Context: "Glitched" }                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.5 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         V0.15.1E LAYER ARCHITECTURE                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      PRESENTATION LAYER                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Commands/                                                          │    │
│  │  └── SkillCheckCommand   ←── Displays descriptor in output         │    │
│  │                                                                      │    │
│  │  Rendering/                                                         │    │
│  │  └── SkillCheckRenderer  ←── Formats stress and descriptor display │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      APPLICATION LAYER                               │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Services/                                                          │    │
│  │  ├── TraumaIntegrationService.cs     ←── NEW                        │    │
│  │  ├── SpecializationBonusProvider.cs  ←── NEW                        │    │
│  │  ├── VoiceGuidanceService.cs         ←── NEW                        │    │
│  │  └── SkillCheckService.cs            ←── MODIFIED (integration)     │    │
│  │                                                                      │    │
│  │  Interfaces/                                                        │    │
│  │  ├── ITraumaIntegrationService.cs    ←── NEW                        │    │
│  │  ├── ISpecializationBonusProvider.cs ←── NEW                        │    │
│  │  └── IVoiceGuidanceService.cs        ←── NEW                        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        DOMAIN LAYER                                  │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  ValueObjects/                                                      │    │
│  │  ├── SkillStressResult.cs            ←── NEW                        │    │
│  │  ├── SpecializationSkillBonus.cs     ←── NEW                        │    │
│  │  └── SkillDescriptor.cs              ←── NEW                        │    │
│  │                                                                      │    │
│  │  Enums/                                                             │    │
│  │  ├── StressSource.cs                 ←── NEW                        │    │
│  │  ├── CorruptionTier.cs               ←── EXISTING (v0.15.1a)        │    │
│  │  └── DescriptorCategory.cs           ←── EXISTING (v0.15.1b)        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                     INFRASTRUCTURE LAYER                             │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Configuration/                                                     │    │
│  │  ├── skill-descriptors.json          ←── NEW                        │    │
│  │  ├── skill-descriptors.schema.json   ←── NEW                        │    │
│  │  ├── specialization-bonuses.json     ←── NEW                        │    │
│  │  └── specialization-bonuses.schema.json ←── NEW                     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. SkillStressResult Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SkillStressResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the psychic stress result from a skill check, calculated based on
/// corruption exposure and fumble severity.
/// </summary>
/// <remarks>
/// <para>
/// The Trauma Economy in Rune &amp; Rust links skill interactions with corrupted
/// objects and areas to psychic stress accumulation. This value object captures
/// the stress calculation result for consumption by the trauma system.
/// </para>
/// <para>
/// Stress accumulates from two sources:
/// <list type="bullet">
///   <item>Corruption exposure during the skill check (based on CorruptionTier)</item>
///   <item>Fumble bonus when a catastrophic failure occurs in a corrupted area</item>
/// </list>
/// </para>
/// <para>
/// When total stress exceeds the breaking point threshold (8), the trauma system
/// may trigger a breaking point check, risking permanent mental trauma.
/// </para>
/// </remarks>
/// <param name="TotalStress">The total psychic stress inflicted by this skill check.</param>
/// <param name="CorruptionStress">Stress from corruption tier exposure (0-10).</param>
/// <param name="FumbleStress">Additional stress from fumbling in corrupted area (0-8).</param>
/// <param name="Source">The primary source of stress for this check.</param>
/// <param name="TriggersBreakingPoint">Whether this stress level may trigger a breaking point check.</param>
/// <param name="CorruptionTier">The corruption tier that was active during the check.</param>
public readonly record struct SkillStressResult(
    int TotalStress,
    int CorruptionStress,
    int FumbleStress,
    StressSource Source,
    bool TriggersBreakingPoint,
    CorruptionTier CorruptionTier)
{
    /// <summary>
    /// The threshold at which a breaking point check may be triggered.
    /// </summary>
    public const int BreakingPointThreshold = 8;

    /// <summary>
    /// Gets a value indicating whether any stress was incurred from this check.
    /// </summary>
    public bool HasStress => TotalStress > 0;

    /// <summary>
    /// Gets a value indicating whether the check occurred in a corrupted area.
    /// </summary>
    public bool InCorruptedArea => CorruptionTier != CorruptionTier.Normal;

    /// <summary>
    /// Gets a value indicating whether fumble stress was applied.
    /// </summary>
    public bool HadFumble => FumbleStress > 0;

    /// <summary>
    /// Creates a SkillStressResult with no stress (normal area, no fumble).
    /// </summary>
    /// <returns>A zero-stress result.</returns>
    public static SkillStressResult None()
    {
        return new SkillStressResult(
            TotalStress: 0,
            CorruptionStress: 0,
            FumbleStress: 0,
            Source: StressSource.None,
            TriggersBreakingPoint: false,
            CorruptionTier: CorruptionTier.Normal);
    }

    /// <summary>
    /// Creates a SkillStressResult from corruption exposure without a fumble.
    /// </summary>
    /// <param name="tier">The corruption tier of the area.</param>
    /// <returns>A stress result based on corruption exposure.</returns>
    public static SkillStressResult FromCorruption(CorruptionTier tier)
    {
        var stress = GetCorruptionStress(tier);
        return new SkillStressResult(
            TotalStress: stress,
            CorruptionStress: stress,
            FumbleStress: 0,
            Source: stress > 0 ? StressSource.Corruption : StressSource.None,
            TriggersBreakingPoint: stress >= BreakingPointThreshold,
            CorruptionTier: tier);
    }

    /// <summary>
    /// Creates a SkillStressResult from both corruption exposure and a fumble.
    /// </summary>
    /// <param name="tier">The corruption tier of the area.</param>
    /// <returns>A stress result with corruption and fumble stress combined.</returns>
    public static SkillStressResult FromFumble(CorruptionTier tier)
    {
        var corruptionStress = GetCorruptionStress(tier);
        var fumbleStress = GetFumbleStress(tier);
        var totalStress = corruptionStress + fumbleStress;

        return new SkillStressResult(
            TotalStress: totalStress,
            CorruptionStress: corruptionStress,
            FumbleStress: fumbleStress,
            Source: StressSource.Fumble,
            TriggersBreakingPoint: totalStress >= BreakingPointThreshold,
            CorruptionTier: tier);
    }

    /// <summary>
    /// Gets the base stress cost for a corruption tier.
    /// </summary>
    /// <param name="tier">The corruption tier.</param>
    /// <returns>The stress cost (0-10).</returns>
    public static int GetCorruptionStress(CorruptionTier tier)
    {
        return tier switch
        {
            CorruptionTier.Normal => 0,
            CorruptionTier.Glitched => 2,
            CorruptionTier.Blighted => 5,
            CorruptionTier.Resonance => 10,
            _ => 0
        };
    }

    /// <summary>
    /// Gets the fumble bonus stress for a corruption tier.
    /// </summary>
    /// <param name="tier">The corruption tier where the fumble occurred.</param>
    /// <returns>The bonus stress from fumbling (1-8).</returns>
    public static int GetFumbleStress(CorruptionTier tier)
    {
        return tier switch
        {
            CorruptionTier.Normal => 1,     // Baseline fumble stress
            CorruptionTier.Glitched => 2,   // Corruption amplifies failure
            CorruptionTier.Blighted => 4,   // Blight punishes mistakes
            CorruptionTier.Resonance => 8,  // Catastrophic psychic backlash
            _ => 1
        };
    }

    /// <summary>
    /// Returns a human-readable description of the stress result.
    /// </summary>
    /// <returns>A formatted string describing the stress incurred.</returns>
    public string ToDescription()
    {
        if (!HasStress)
            return "No psychic stress incurred.";

        var parts = new List<string>();

        if (CorruptionStress > 0)
            parts.Add($"{CorruptionStress} from {CorruptionTier} corruption");

        if (FumbleStress > 0)
            parts.Add($"{FumbleStress} from fumble");

        var description = $"Psychic Stress: {TotalStress} ({string.Join(", ", parts)})";

        if (TriggersBreakingPoint)
            description += " [Breaking Point Risk]";

        return description;
    }
}
```

---

## 5. StressSource Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/StressSource.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Identifies the source of psychic stress from a skill check.
/// </summary>
/// <remarks>
/// <para>
/// Stress sources determine how the trauma system processes and displays
/// stress accumulation. Different sources may have different recovery
/// mechanisms or consequences.
/// </para>
/// </remarks>
public enum StressSource
{
    /// <summary>
    /// No stress was incurred from this skill check.
    /// </summary>
    None = 0,

    /// <summary>
    /// Stress from exposure to a corrupted area during the skill check.
    /// Scales with CorruptionTier: Glitched (2), Blighted (5), Resonance (10).
    /// </summary>
    Corruption = 1,

    /// <summary>
    /// Stress from a fumble (catastrophic failure) during a skill check.
    /// Combines corruption stress with fumble bonus stress.
    /// </summary>
    Fumble = 2,

    /// <summary>
    /// Stress from interacting with a corrupted object or artifact.
    /// Used when manipulating [Glitched Artifacts] or corrupted terminals.
    /// </summary>
    CorruptedObject = 3,

    /// <summary>
    /// Stress from prolonged exposure during extended skill checks.
    /// Applies to multi-stage procedures in corrupted areas.
    /// </summary>
    ExtendedExposure = 4
}
```

---

## 6. ITraumaIntegrationService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITraumaIntegrationService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Provides integration between the skill check system and the trauma economy.
/// </summary>
/// <remarks>
/// <para>
/// The Trauma Economy links skill interactions with corrupted objects and areas
/// to psychic stress accumulation. This service calculates the stress impact
/// of skill checks based on corruption exposure and fumble outcomes.
/// </para>
/// <para>
/// Stress costs scale with corruption tier:
/// <list type="bullet">
///   <item>Normal: 0 stress (no psychic interference)</item>
///   <item>Glitched: 2 stress (minor psychic noise)</item>
///   <item>Blighted: 5 stress (significant corruption)</item>
///   <item>Resonance: 10 stress (direct Blight exposure)</item>
/// </list>
/// </para>
/// <para>
/// Fumbles in corrupted areas add bonus stress, amplified by corruption tier.
/// </para>
/// </remarks>
public interface ITraumaIntegrationService
{
    /// <summary>
    /// Calculates the psychic stress result from a skill check.
    /// </summary>
    /// <param name="context">The skill context containing corruption tier information.</param>
    /// <param name="outcomeDetails">The outcome details including fumble status.</param>
    /// <returns>A <see cref="SkillStressResult"/> containing the calculated stress.</returns>
    SkillStressResult CalculateSkillStress(SkillContext context, OutcomeDetails outcomeDetails);

    /// <summary>
    /// Calculates stress from interacting with a corrupted object.
    /// </summary>
    /// <param name="objectCorruptionTier">The corruption tier of the object being manipulated.</param>
    /// <param name="isFumble">Whether the interaction resulted in a fumble.</param>
    /// <returns>A <see cref="SkillStressResult"/> containing the calculated stress.</returns>
    SkillStressResult CalculateObjectInteractionStress(
        CorruptionTier objectCorruptionTier,
        bool isFumble);

    /// <summary>
    /// Calculates cumulative stress from an extended skill check procedure.
    /// </summary>
    /// <param name="context">The skill context containing corruption tier information.</param>
    /// <param name="stepCount">The number of steps completed in the procedure.</param>
    /// <param name="fumbleCount">The number of fumbles that occurred during the procedure.</param>
    /// <returns>A <see cref="SkillStressResult"/> containing the accumulated stress.</returns>
    SkillStressResult CalculateExtendedCheckStress(
        SkillContext context,
        int stepCount,
        int fumbleCount);

    /// <summary>
    /// Gets the base stress cost for a corruption tier without fumble.
    /// </summary>
    /// <param name="tier">The corruption tier.</param>
    /// <returns>The base stress cost.</returns>
    int GetCorruptionStressCost(CorruptionTier tier);

    /// <summary>
    /// Gets the fumble bonus stress for a corruption tier.
    /// </summary>
    /// <param name="tier">The corruption tier where the fumble occurred.</param>
    /// <returns>The fumble bonus stress.</returns>
    int GetFumbleStressCost(CorruptionTier tier);
}
```

---

## 7. TraumaIntegrationService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/TraumaIntegrationService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Implements trauma economy integration for skill checks.
/// </summary>
/// <remarks>
/// <para>
/// Calculates psychic stress from skill checks based on corruption exposure
/// and fumble outcomes. This service bridges the skill system with the
/// trauma economy defined in the Rune &amp; Rust design specifications.
/// </para>
/// </remarks>
public class TraumaIntegrationService : ITraumaIntegrationService
{
    private readonly ILogger<TraumaIntegrationService> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="TraumaIntegrationService"/> class.
    /// </summary>
    /// <param name="logger">The logger for diagnostic output.</param>
    public TraumaIntegrationService(ILogger<TraumaIntegrationService> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc/>
    public SkillStressResult CalculateSkillStress(
        SkillContext context,
        OutcomeDetails outcomeDetails)
    {
        // Extract corruption tier from context
        var corruptionTier = ExtractCorruptionTier(context);

        // No stress in normal areas without fumble
        if (corruptionTier == CorruptionTier.Normal && !outcomeDetails.IsFumble)
        {
            _logger.LogTrace("No stress: normal area, no fumble");
            return SkillStressResult.None();
        }

        // Calculate stress based on fumble status
        var result = outcomeDetails.IsFumble
            ? SkillStressResult.FromFumble(corruptionTier)
            : SkillStressResult.FromCorruption(corruptionTier);

        if (result.HasStress)
        {
            _logger.LogDebug(
                "Skill stress calculated: {TotalStress} (corruption: {Corruption}, fumble: {Fumble})",
                result.TotalStress,
                result.CorruptionStress,
                result.FumbleStress);
        }

        if (result.TriggersBreakingPoint)
        {
            _logger.LogInformation(
                "Breaking point threshold reached: {TotalStress} stress from {Source}",
                result.TotalStress,
                result.Source);
        }

        return result;
    }

    /// <inheritdoc/>
    public SkillStressResult CalculateObjectInteractionStress(
        CorruptionTier objectCorruptionTier,
        bool isFumble)
    {
        var corruptionStress = GetCorruptionStressCost(objectCorruptionTier);
        var fumbleStress = isFumble ? GetFumbleStressCost(objectCorruptionTier) : 0;
        var totalStress = corruptionStress + fumbleStress;

        var source = isFumble
            ? StressSource.Fumble
            : objectCorruptionTier != CorruptionTier.Normal
                ? StressSource.CorruptedObject
                : StressSource.None;

        var result = new SkillStressResult(
            TotalStress: totalStress,
            CorruptionStress: corruptionStress,
            FumbleStress: fumbleStress,
            Source: source,
            TriggersBreakingPoint: totalStress >= SkillStressResult.BreakingPointThreshold,
            CorruptionTier: objectCorruptionTier);

        _logger.LogDebug(
            "Object interaction stress: {TotalStress} (tier: {Tier}, fumble: {IsFumble})",
            result.TotalStress,
            objectCorruptionTier,
            isFumble);

        return result;
    }

    /// <inheritdoc/>
    public SkillStressResult CalculateExtendedCheckStress(
        SkillContext context,
        int stepCount,
        int fumbleCount)
    {
        var corruptionTier = ExtractCorruptionTier(context);

        // Each step in a corrupted area incurs stress
        var perStepStress = GetCorruptionStressCost(corruptionTier);
        var accumulatedCorruptionStress = perStepStress * stepCount;

        // Fumbles add bonus stress
        var perFumbleStress = GetFumbleStressCost(corruptionTier);
        var accumulatedFumbleStress = perFumbleStress * fumbleCount;

        var totalStress = accumulatedCorruptionStress + accumulatedFumbleStress;

        var source = fumbleCount > 0
            ? StressSource.Fumble
            : corruptionTier != CorruptionTier.Normal
                ? StressSource.ExtendedExposure
                : StressSource.None;

        var result = new SkillStressResult(
            TotalStress: totalStress,
            CorruptionStress: accumulatedCorruptionStress,
            FumbleStress: accumulatedFumbleStress,
            Source: source,
            TriggersBreakingPoint: totalStress >= SkillStressResult.BreakingPointThreshold,
            CorruptionTier: corruptionTier);

        _logger.LogDebug(
            "Extended check stress: {TotalStress} ({Steps} steps, {Fumbles} fumbles in {Tier})",
            result.TotalStress,
            stepCount,
            fumbleCount,
            corruptionTier);

        return result;
    }

    /// <inheritdoc/>
    public int GetCorruptionStressCost(CorruptionTier tier)
    {
        return SkillStressResult.GetCorruptionStress(tier);
    }

    /// <inheritdoc/>
    public int GetFumbleStressCost(CorruptionTier tier)
    {
        return SkillStressResult.GetFumbleStress(tier);
    }

    /// <summary>
    /// Extracts the corruption tier from a skill context.
    /// </summary>
    /// <param name="context">The skill context to examine.</param>
    /// <returns>The highest corruption tier found in environment modifiers.</returns>
    private static CorruptionTier ExtractCorruptionTier(SkillContext context)
    {
        // Find the highest corruption tier from environment modifiers
        var highestTier = CorruptionTier.Normal;

        foreach (var modifier in context.EnvironmentModifiers)
        {
            if (modifier.CorruptionTier.HasValue &&
                modifier.CorruptionTier.Value > highestTier)
            {
                highestTier = modifier.CorruptionTier.Value;
            }
        }

        return highestTier;
    }
}
```

---

## 8. SpecializationSkillBonus Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SpecializationSkillBonus.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a skill bonus granted by a character's specialization (archetype).
/// </summary>
/// <remarks>
/// <para>
/// Specializations provide unique bonuses to specific skills. These bonuses
/// may be unconditional (always apply) or conditional (require specific context
/// such as biome, target type, or equipment).
/// </para>
/// <para>
/// Example specialization bonuses:
/// <list type="bullet">
///   <item>Gantry-Runner: +2d10 to climbing, +1d10 to leaping</item>
///   <item>Myr-Stalker: +2d10 to navigation in swamp biomes</item>
///   <item>Thul: +1d10 to persuasion, no reputation loss on failure</item>
/// </list>
/// </para>
/// </remarks>
/// <param name="SpecializationId">The ID of the specialization granting this bonus.</param>
/// <param name="SkillId">The ID of the skill receiving the bonus.</param>
/// <param name="DiceBonus">The dice pool bonus (positive or negative).</param>
/// <param name="DcModifier">Optional DC modifier (positive = harder, negative = easier).</param>
/// <param name="Description">Human-readable description of the bonus.</param>
/// <param name="IsConditional">Whether this bonus requires specific conditions to apply.</param>
/// <param name="ConditionMet">Whether the conditions for this bonus were met.</param>
/// <param name="SpecialAbility">Optional special ability flag (e.g., "no-reputation-loss-on-failure").</param>
public readonly record struct SpecializationSkillBonus(
    string SpecializationId,
    string SkillId,
    int DiceBonus,
    int DcModifier = 0,
    string Description = "",
    bool IsConditional = false,
    bool ConditionMet = true,
    string? SpecialAbility = null)
{
    /// <summary>
    /// Gets a value indicating whether this bonus has any effect.
    /// </summary>
    public bool HasEffect => DiceBonus != 0 || DcModifier != 0 || SpecialAbility != null;

    /// <summary>
    /// Gets a value indicating whether this bonus should be applied.
    /// </summary>
    /// <remarks>
    /// A bonus applies if it has an effect and either is unconditional or has its condition met.
    /// </remarks>
    public bool ShouldApply => HasEffect && (!IsConditional || ConditionMet);

    /// <summary>
    /// Gets a value indicating whether this bonus has a special ability component.
    /// </summary>
    public bool HasSpecialAbility => !string.IsNullOrEmpty(SpecialAbility);

    /// <summary>
    /// Creates a SpecializationSkillBonus with no effect.
    /// </summary>
    /// <param name="specializationId">The specialization ID.</param>
    /// <param name="skillId">The skill ID.</param>
    /// <returns>A bonus with no effect.</returns>
    public static SpecializationSkillBonus None(string specializationId, string skillId)
    {
        return new SpecializationSkillBonus(
            SpecializationId: specializationId,
            SkillId: skillId,
            DiceBonus: 0,
            Description: "No specialization bonus");
    }

    /// <summary>
    /// Creates a copy of this bonus with the condition evaluation result.
    /// </summary>
    /// <param name="conditionMet">Whether the condition was met.</param>
    /// <returns>A new bonus with the condition result set.</returns>
    public SpecializationSkillBonus WithConditionResult(bool conditionMet)
    {
        return this with { ConditionMet = conditionMet };
    }

    /// <summary>
    /// Returns a human-readable description of the bonus.
    /// </summary>
    /// <returns>A formatted string describing the bonus.</returns>
    public string ToDisplayString()
    {
        if (!ShouldApply)
            return IsConditional && !ConditionMet
                ? $"{Description} (condition not met)"
                : "No specialization bonus";

        var parts = new List<string>();

        if (DiceBonus > 0)
            parts.Add($"+{DiceBonus}d10");
        else if (DiceBonus < 0)
            parts.Add($"{DiceBonus}d10");

        if (DcModifier > 0)
            parts.Add($"DC +{DcModifier}");
        else if (DcModifier < 0)
            parts.Add($"DC {DcModifier}");

        var effect = parts.Count > 0 ? string.Join(", ", parts) : "special ability";
        return $"{Description}: {effect}";
    }
}
```

---

## 9. ISpecializationBonusProvider Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ISpecializationBonusProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Provides specialization-based skill bonuses for archetype-specific modifiers.
/// </summary>
/// <remarks>
/// <para>
/// Each specialization in Rune &amp; Rust grants unique bonuses to specific skills.
/// This provider looks up and evaluates these bonuses based on the character's
/// specialization and the current skill check context.
/// </para>
/// <para>
/// Specialization bonuses may be:
/// <list type="bullet">
///   <item>Unconditional: Always apply when using the skill</item>
///   <item>Conditional: Require specific context (biome, equipment, target)</item>
/// </list>
/// </para>
/// <para>
/// Some specializations also grant special abilities that modify skill behavior
/// beyond simple dice bonuses, such as the Thul's "no reputation loss on failure"
/// for persuasion checks.
/// </para>
/// </remarks>
public interface ISpecializationBonusProvider
{
    /// <summary>
    /// Gets the skill bonus for a character's specialization and skill combination.
    /// </summary>
    /// <param name="specializationId">The ID of the character's specialization.</param>
    /// <param name="skillId">The ID of the skill being used.</param>
    /// <param name="context">The skill context for conditional evaluation.</param>
    /// <returns>
    /// A <see cref="SpecializationSkillBonus"/> with the calculated bonus,
    /// or a zero bonus if no bonus applies.
    /// </returns>
    SpecializationSkillBonus GetSkillBonus(
        string specializationId,
        string skillId,
        SkillContext context);

    /// <summary>
    /// Gets all skill bonuses for a specialization.
    /// </summary>
    /// <param name="specializationId">The ID of the specialization to look up.</param>
    /// <returns>A collection of all skill bonuses for the specialization.</returns>
    IReadOnlyList<SpecializationSkillBonus> GetAllBonuses(string specializationId);

    /// <summary>
    /// Checks if a specialization has any bonus for a specific skill.
    /// </summary>
    /// <param name="specializationId">The ID of the specialization.</param>
    /// <param name="skillId">The ID of the skill.</param>
    /// <returns>True if the specialization grants a bonus to this skill.</returns>
    bool HasBonusForSkill(string specializationId, string skillId);

    /// <summary>
    /// Evaluates whether a conditional bonus's requirements are met.
    /// </summary>
    /// <param name="bonus">The bonus to evaluate.</param>
    /// <param name="context">The skill context for evaluation.</param>
    /// <returns>True if the bonus conditions are met.</returns>
    bool EvaluateCondition(SpecializationSkillBonus bonus, SkillContext context);

    /// <summary>
    /// Gets the list of all specialization IDs that have skill bonuses configured.
    /// </summary>
    /// <returns>A collection of specialization IDs.</returns>
    IReadOnlyList<string> GetSpecializationsWithBonuses();
}
```

---

## 10. SpecializationBonusProvider Implementation

**File:** `src/Core/RuneAndRust.Application/Services/SpecializationBonusProvider.cs`

```csharp
namespace RuneAndRust.Application.Services;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Provides specialization skill bonuses from JSON configuration.
/// </summary>
/// <remarks>
/// <para>
/// Loads specialization bonus definitions from <c>specialization-bonuses.json</c>
/// and evaluates conditional bonuses based on skill context.
/// </para>
/// </remarks>
public class SpecializationBonusProvider : ISpecializationBonusProvider
{
    private readonly ILogger<SpecializationBonusProvider> _logger;
    private readonly Dictionary<string, SpecializationConfig> _specializations = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="SpecializationBonusProvider"/> class.
    /// </summary>
    /// <param name="configurationPath">Path to the specialization-bonuses.json file.</param>
    /// <param name="logger">The logger for diagnostic output.</param>
    public SpecializationBonusProvider(
        string configurationPath,
        ILogger<SpecializationBonusProvider> logger)
    {
        _logger = logger;
        LoadConfiguration(configurationPath);
    }

    /// <inheritdoc/>
    public SpecializationSkillBonus GetSkillBonus(
        string specializationId,
        string skillId,
        SkillContext context)
    {
        var normalizedSpecId = specializationId.ToLowerInvariant();
        var normalizedSkillId = skillId.ToLowerInvariant();

        if (!_specializations.TryGetValue(normalizedSpecId, out var specConfig))
        {
            _logger.LogTrace("No bonuses configured for specialization: {SpecializationId}", specializationId);
            return SpecializationSkillBonus.None(specializationId, skillId);
        }

        if (!specConfig.Skills.TryGetValue(normalizedSkillId, out var skillConfig))
        {
            _logger.LogTrace(
                "No bonus for {SpecializationId} → {SkillId}",
                specializationId,
                skillId);
            return SpecializationSkillBonus.None(specializationId, skillId);
        }

        var bonus = new SpecializationSkillBonus(
            SpecializationId: specializationId,
            SkillId: skillId,
            DiceBonus: skillConfig.DiceBonus,
            DcModifier: skillConfig.DcModifier,
            Description: skillConfig.Description ?? specConfig.Name,
            IsConditional: skillConfig.Condition != null,
            ConditionMet: true,
            SpecialAbility: skillConfig.SpecialAbility);

        // Evaluate conditions if present
        if (bonus.IsConditional)
        {
            var conditionMet = EvaluateCondition(bonus, context);
            bonus = bonus.WithConditionResult(conditionMet);

            _logger.LogDebug(
                "Conditional bonus {SpecializationId} → {SkillId}: condition {ConditionResult}",
                specializationId,
                skillId,
                conditionMet ? "met" : "not met");
        }

        if (bonus.ShouldApply)
        {
            _logger.LogDebug(
                "Specialization bonus applied: {Description}",
                bonus.ToDisplayString());
        }

        return bonus;
    }

    /// <inheritdoc/>
    public IReadOnlyList<SpecializationSkillBonus> GetAllBonuses(string specializationId)
    {
        var normalizedSpecId = specializationId.ToLowerInvariant();

        if (!_specializations.TryGetValue(normalizedSpecId, out var specConfig))
            return Array.Empty<SpecializationSkillBonus>();

        return specConfig.Skills
            .Select(kvp => new SpecializationSkillBonus(
                SpecializationId: specializationId,
                SkillId: kvp.Key,
                DiceBonus: kvp.Value.DiceBonus,
                DcModifier: kvp.Value.DcModifier,
                Description: kvp.Value.Description ?? specConfig.Name,
                IsConditional: kvp.Value.Condition != null,
                ConditionMet: true,
                SpecialAbility: kvp.Value.SpecialAbility))
            .ToList();
    }

    /// <inheritdoc/>
    public bool HasBonusForSkill(string specializationId, string skillId)
    {
        var normalizedSpecId = specializationId.ToLowerInvariant();
        var normalizedSkillId = skillId.ToLowerInvariant();

        return _specializations.TryGetValue(normalizedSpecId, out var specConfig) &&
               specConfig.Skills.ContainsKey(normalizedSkillId);
    }

    /// <inheritdoc/>
    public bool EvaluateCondition(SpecializationSkillBonus bonus, SkillContext context)
    {
        if (!bonus.IsConditional)
            return true;

        var normalizedSpecId = bonus.SpecializationId.ToLowerInvariant();
        var normalizedSkillId = bonus.SkillId.ToLowerInvariant();

        if (!_specializations.TryGetValue(normalizedSpecId, out var specConfig))
            return false;

        if (!specConfig.Skills.TryGetValue(normalizedSkillId, out var skillConfig))
            return false;

        var condition = skillConfig.Condition;
        if (condition == null)
            return true;

        // Evaluate biome condition
        if (condition.Biomes != null && condition.Biomes.Count > 0)
        {
            // Check if any environment modifier has a matching biome
            var hasBiomeMatch = context.EnvironmentModifiers
                .Any(m => condition.Biomes.Contains(
                    m.ModifierId.ToLowerInvariant()));

            if (!hasBiomeMatch)
                return false;
        }

        // Evaluate surface condition
        if (condition.SurfaceTypes != null && condition.SurfaceTypes.Count > 0)
        {
            var hasSurfaceMatch = context.EnvironmentModifiers
                .Any(m => m.SurfaceType.HasValue &&
                         condition.SurfaceTypes.Contains(m.SurfaceType.Value.ToString().ToLowerInvariant()));

            if (!hasSurfaceMatch)
                return false;
        }

        // Evaluate equipment condition
        if (condition.RequiredEquipment != null && condition.RequiredEquipment.Count > 0)
        {
            var hasEquipment = context.EquipmentModifiers
                .Any(m => condition.RequiredEquipment.Contains(m.EquipmentId.ToLowerInvariant()));

            if (!hasEquipment)
                return false;
        }

        return true;
    }

    /// <inheritdoc/>
    public IReadOnlyList<string> GetSpecializationsWithBonuses()
    {
        return _specializations.Keys.ToList();
    }

    /// <summary>
    /// Loads specialization configuration from JSON file.
    /// </summary>
    private void LoadConfiguration(string configurationPath)
    {
        try
        {
            if (!File.Exists(configurationPath))
            {
                _logger.LogWarning(
                    "Specialization bonuses configuration not found at {Path}",
                    configurationPath);
                return;
            }

            var json = File.ReadAllText(configurationPath);
            var config = JsonSerializer.Deserialize<SpecializationBonusesConfig>(
                json,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (config?.Specializations != null)
            {
                foreach (var (specId, specConfig) in config.Specializations)
                {
                    _specializations[specId.ToLowerInvariant()] = specConfig;
                }

                _logger.LogInformation(
                    "Loaded specialization bonuses for {Count} specializations",
                    _specializations.Count);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load specialization bonuses configuration");
        }
    }

    #region Configuration DTOs

    private class SpecializationBonusesConfig
    {
        public Dictionary<string, SpecializationConfig> Specializations { get; set; } = new();
    }

    private class SpecializationConfig
    {
        public string Name { get; set; } = "";
        public Dictionary<string, SkillBonusConfig> Skills { get; set; } = new();
    }

    private class SkillBonusConfig
    {
        public int DiceBonus { get; set; }
        public int DcModifier { get; set; }
        public string? Description { get; set; }
        public string? SpecialAbility { get; set; }
        public ConditionConfig? Condition { get; set; }
    }

    private class ConditionConfig
    {
        public List<string>? Biomes { get; set; }
        public List<string>? SurfaceTypes { get; set; }
        public List<string>? RequiredEquipment { get; set; }
    }

    #endregion
}
```

---

## 11. SkillDescriptor Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SkillDescriptor.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents a narrative descriptor for a skill check outcome.
/// </summary>
/// <remarks>
/// <para>
/// Voice guidance provides flavor text that varies by skill, outcome category,
/// and context. Descriptors are selected from pools of text to provide variety
/// while maintaining thematic consistency.
/// </para>
/// <para>
/// Descriptor pools are organized by:
/// <list type="bullet">
///   <item>Skill ID: Each skill has its own descriptor pools</item>
///   <item>Category: Catastrophic, Failed, Marginal, Competent, Impressive, Masterful</item>
///   <item>Context: Optional variants for corruption, surface type, etc.</item>
/// </list>
/// </para>
/// </remarks>
/// <param name="SkillId">The ID of the skill this descriptor is for.</param>
/// <param name="Category">The descriptor category (maps from SkillOutcome).</param>
/// <param name="Text">The narrative text to display.</param>
/// <param name="IsContextual">Whether this descriptor is context-specific.</param>
/// <param name="ContextType">The type of context that influenced selection (e.g., "glitched", "hostile").</param>
public readonly record struct SkillDescriptor(
    string SkillId,
    DescriptorCategory Category,
    string Text,
    bool IsContextual = false,
    string? ContextType = null)
{
    /// <summary>
    /// Gets a value indicating whether this is a fallback (generic) descriptor.
    /// </summary>
    public bool IsFallback => !IsContextual && string.IsNullOrEmpty(ContextType);

    /// <summary>
    /// Gets a value indicating whether this descriptor has content.
    /// </summary>
    public bool HasContent => !string.IsNullOrWhiteSpace(Text);

    /// <summary>
    /// Creates an empty descriptor when no text is available.
    /// </summary>
    /// <param name="skillId">The skill ID.</param>
    /// <param name="category">The descriptor category.</param>
    /// <returns>An empty descriptor.</returns>
    public static SkillDescriptor Empty(string skillId, DescriptorCategory category)
    {
        return new SkillDescriptor(
            SkillId: skillId,
            Category: category,
            Text: string.Empty);
    }

    /// <summary>
    /// Creates a generic fallback descriptor.
    /// </summary>
    /// <param name="category">The descriptor category.</param>
    /// <returns>A generic descriptor for the category.</returns>
    public static SkillDescriptor GenericFallback(DescriptorCategory category)
    {
        var text = category switch
        {
            DescriptorCategory.Catastrophic => "Something goes terribly wrong.",
            DescriptorCategory.Failed => "The attempt fails.",
            DescriptorCategory.Marginal => "You barely succeed.",
            DescriptorCategory.Competent => "You succeed.",
            DescriptorCategory.Impressive => "You succeed impressively.",
            DescriptorCategory.Masterful => "You achieve a masterful success.",
            _ => "The check is resolved."
        };

        return new SkillDescriptor(
            SkillId: "generic",
            Category: category,
            Text: text);
    }

    /// <summary>
    /// Returns the descriptor text, suitable for display.
    /// </summary>
    /// <returns>The narrative text.</returns>
    public override string ToString() => Text;
}
```

---

## 12. IVoiceGuidanceService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IVoiceGuidanceService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Provides narrative descriptors for skill check outcomes.
/// </summary>
/// <remarks>
/// <para>
/// Voice guidance enriches skill check feedback with thematic, skill-specific
/// narrative text. Each skill has pools of descriptors for each outcome category,
/// with optional context-specific variants.
/// </para>
/// <para>
/// Descriptor selection considers:
/// <list type="bullet">
///   <item>Skill identity: Lockpicking has different flavor than persuasion</item>
///   <item>Outcome severity: Fumbles vs critical successes</item>
///   <item>Context: Corruption, target disposition, surface type, etc.</item>
/// </list>
/// </para>
/// </remarks>
public interface IVoiceGuidanceService
{
    /// <summary>
    /// Gets a narrative descriptor for a skill check outcome.
    /// </summary>
    /// <param name="skillId">The ID of the skill used.</param>
    /// <param name="category">The outcome category for descriptor lookup.</param>
    /// <param name="context">Optional skill context for context-specific variants.</param>
    /// <returns>A <see cref="SkillDescriptor"/> with narrative text.</returns>
    SkillDescriptor GetDescriptor(
        string skillId,
        DescriptorCategory category,
        SkillContext? context = null);

    /// <summary>
    /// Gets a descriptor using the outcome details to determine category.
    /// </summary>
    /// <param name="skillId">The ID of the skill used.</param>
    /// <param name="outcomeDetails">The outcome details from the skill check.</param>
    /// <param name="context">Optional skill context for context-specific variants.</param>
    /// <returns>A <see cref="SkillDescriptor"/> with narrative text.</returns>
    SkillDescriptor GetDescriptor(
        string skillId,
        OutcomeDetails outcomeDetails,
        SkillContext? context = null);

    /// <summary>
    /// Gets all available descriptor categories for a skill.
    /// </summary>
    /// <param name="skillId">The ID of the skill.</param>
    /// <returns>A collection of categories that have descriptors configured.</returns>
    IReadOnlyList<DescriptorCategory> GetAvailableCategories(string skillId);

    /// <summary>
    /// Checks if a skill has any descriptors configured.
    /// </summary>
    /// <param name="skillId">The ID of the skill.</param>
    /// <returns>True if the skill has descriptors configured.</returns>
    bool HasDescriptors(string skillId);

    /// <summary>
    /// Gets the count of descriptors in a pool.
    /// </summary>
    /// <param name="skillId">The ID of the skill.</param>
    /// <param name="category">The descriptor category.</param>
    /// <param name="contextType">Optional context type for context-specific pools.</param>
    /// <returns>The number of descriptors in the pool.</returns>
    int GetPoolSize(string skillId, DescriptorCategory category, string? contextType = null);
}
```

---

## 13. VoiceGuidanceService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/VoiceGuidanceService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Provides narrative descriptors for skill check outcomes from JSON configuration.
/// </summary>
/// <remarks>
/// <para>
/// Loads skill descriptor pools from <c>skill-descriptors.json</c> and selects
/// appropriate narrative text based on skill, outcome category, and context.
/// </para>
/// </remarks>
public class VoiceGuidanceService : IVoiceGuidanceService
{
    private readonly ILogger<VoiceGuidanceService> _logger;
    private readonly IRandomProvider _random;
    private readonly Dictionary<string, SkillDescriptorConfig> _skills = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="VoiceGuidanceService"/> class.
    /// </summary>
    /// <param name="configurationPath">Path to the skill-descriptors.json file.</param>
    /// <param name="random">Random provider for descriptor selection.</param>
    /// <param name="logger">The logger for diagnostic output.</param>
    public VoiceGuidanceService(
        string configurationPath,
        IRandomProvider random,
        ILogger<VoiceGuidanceService> logger)
    {
        _random = random;
        _logger = logger;
        LoadConfiguration(configurationPath);
    }

    /// <inheritdoc/>
    public SkillDescriptor GetDescriptor(
        string skillId,
        DescriptorCategory category,
        SkillContext? context = null)
    {
        var normalizedSkillId = skillId.ToLowerInvariant();
        var categoryKey = CategoryToKey(category);

        // Try to get skill-specific descriptors
        if (_skills.TryGetValue(normalizedSkillId, out var skillConfig))
        {
            // Try context-specific variant first
            if (context != null)
            {
                var contextDescriptor = TryGetContextualDescriptor(
                    skillId, skillConfig, category, context);

                if (contextDescriptor.HasContent)
                {
                    _logger.LogTrace(
                        "Using contextual descriptor for {SkillId}/{Category}",
                        skillId,
                        category);
                    return contextDescriptor;
                }
            }

            // Fall back to default pool
            if (skillConfig.Categories.TryGetValue(categoryKey, out var pool))
            {
                var text = SelectFromPool(pool.Default);
                if (!string.IsNullOrEmpty(text))
                {
                    return new SkillDescriptor(
                        SkillId: skillId,
                        Category: category,
                        Text: text);
                }
            }
        }

        // Fall back to generic descriptor
        _logger.LogTrace(
            "No descriptor found for {SkillId}/{Category}, using generic fallback",
            skillId,
            category);
        return SkillDescriptor.GenericFallback(category);
    }

    /// <inheritdoc/>
    public SkillDescriptor GetDescriptor(
        string skillId,
        OutcomeDetails outcomeDetails,
        SkillContext? context = null)
    {
        return GetDescriptor(skillId, outcomeDetails.DescriptorCategory, context);
    }

    /// <inheritdoc/>
    public IReadOnlyList<DescriptorCategory> GetAvailableCategories(string skillId)
    {
        var normalizedSkillId = skillId.ToLowerInvariant();

        if (!_skills.TryGetValue(normalizedSkillId, out var skillConfig))
            return Array.Empty<DescriptorCategory>();

        return skillConfig.Categories.Keys
            .Select(KeyToCategory)
            .Where(c => c.HasValue)
            .Select(c => c!.Value)
            .ToList();
    }

    /// <inheritdoc/>
    public bool HasDescriptors(string skillId)
    {
        return _skills.ContainsKey(skillId.ToLowerInvariant());
    }

    /// <inheritdoc/>
    public int GetPoolSize(string skillId, DescriptorCategory category, string? contextType = null)
    {
        var normalizedSkillId = skillId.ToLowerInvariant();
        var categoryKey = CategoryToKey(category);

        if (!_skills.TryGetValue(normalizedSkillId, out var skillConfig))
            return 0;

        if (!skillConfig.Categories.TryGetValue(categoryKey, out var pool))
            return 0;

        if (contextType != null &&
            pool.Contextual.TryGetValue(contextType.ToLowerInvariant(), out var contextPool))
            return contextPool.Count;

        return pool.Default.Count;
    }

    /// <summary>
    /// Attempts to get a context-specific descriptor.
    /// </summary>
    private SkillDescriptor TryGetContextualDescriptor(
        string skillId,
        SkillDescriptorConfig skillConfig,
        DescriptorCategory category,
        SkillContext context)
    {
        var categoryKey = CategoryToKey(category);

        if (!skillConfig.Categories.TryGetValue(categoryKey, out var pool))
            return SkillDescriptor.Empty(skillId, category);

        // Check for corruption context
        foreach (var envMod in context.EnvironmentModifiers)
        {
            if (envMod.CorruptionTier.HasValue &&
                envMod.CorruptionTier.Value != CorruptionTier.Normal)
            {
                var corruptionKey = envMod.CorruptionTier.Value.ToString().ToLowerInvariant();
                if (pool.Contextual.TryGetValue(corruptionKey, out var corruptionPool))
                {
                    var text = SelectFromPool(corruptionPool);
                    if (!string.IsNullOrEmpty(text))
                    {
                        return new SkillDescriptor(
                            SkillId: skillId,
                            Category: category,
                            Text: text,
                            IsContextual: true,
                            ContextType: corruptionKey);
                    }
                }
            }

            // Check for surface type context
            if (envMod.SurfaceType.HasValue)
            {
                var surfaceKey = envMod.SurfaceType.Value.ToString().ToLowerInvariant();
                if (pool.Contextual.TryGetValue(surfaceKey, out var surfacePool))
                {
                    var text = SelectFromPool(surfacePool);
                    if (!string.IsNullOrEmpty(text))
                    {
                        return new SkillDescriptor(
                            SkillId: skillId,
                            Category: category,
                            Text: text,
                            IsContextual: true,
                            ContextType: surfaceKey);
                    }
                }
            }
        }

        // Check for target disposition context
        foreach (var targetMod in context.TargetModifiers)
        {
            if (targetMod.Disposition.HasValue)
            {
                var dispositionKey = targetMod.Disposition.Value.ToString().ToLowerInvariant();
                if (pool.Contextual.TryGetValue(dispositionKey, out var dispositionPool))
                {
                    var text = SelectFromPool(dispositionPool);
                    if (!string.IsNullOrEmpty(text))
                    {
                        return new SkillDescriptor(
                            SkillId: skillId,
                            Category: category,
                            Text: text,
                            IsContextual: true,
                            ContextType: dispositionKey);
                    }
                }
            }
        }

        return SkillDescriptor.Empty(skillId, category);
    }

    /// <summary>
    /// Selects a random descriptor from a pool.
    /// </summary>
    private string SelectFromPool(List<string> pool)
    {
        if (pool == null || pool.Count == 0)
            return string.Empty;

        var index = _random.Next(pool.Count);
        return pool[index];
    }

    /// <summary>
    /// Converts a DescriptorCategory to a JSON key.
    /// </summary>
    private static string CategoryToKey(DescriptorCategory category)
    {
        return category.ToString().ToLowerInvariant();
    }

    /// <summary>
    /// Converts a JSON key to a DescriptorCategory.
    /// </summary>
    private static DescriptorCategory? KeyToCategory(string key)
    {
        return Enum.TryParse<DescriptorCategory>(key, true, out var category)
            ? category
            : null;
    }

    /// <summary>
    /// Loads descriptor configuration from JSON file.
    /// </summary>
    private void LoadConfiguration(string configurationPath)
    {
        try
        {
            if (!File.Exists(configurationPath))
            {
                _logger.LogWarning(
                    "Skill descriptors configuration not found at {Path}",
                    configurationPath);
                return;
            }

            var json = File.ReadAllText(configurationPath);
            var config = JsonSerializer.Deserialize<SkillDescriptorsRootConfig>(
                json,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (config?.Skills != null)
            {
                foreach (var (skillId, skillConfig) in config.Skills)
                {
                    _skills[skillId.ToLowerInvariant()] = skillConfig;
                }

                _logger.LogInformation(
                    "Loaded descriptors for {Count} skills",
                    _skills.Count);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load skill descriptors configuration");
        }
    }

    #region Configuration DTOs

    private class SkillDescriptorsRootConfig
    {
        public Dictionary<string, SkillDescriptorConfig> Skills { get; set; } = new();
    }

    private class SkillDescriptorConfig
    {
        public Dictionary<string, CategoryPool> Categories { get; set; } = new();
    }

    private class CategoryPool
    {
        public List<string> Default { get; set; } = new();
        public Dictionary<string, List<string>> Contextual { get; set; } = new();
    }

    #endregion
}
```

---

## 14. Configuration - Skill Descriptors

### 14.1 skill-descriptors.json

**File:** `src/Data/Configuration/skill-descriptors.json`

```json
{
  "$schema": "skill-descriptors.schema.json",
  "skills": {
    "lockpicking": {
      "categories": {
        "catastrophic": {
          "default": [
            "The mechanism jams with a grinding screech. Something inside has snapped beyond repair.",
            "Your pick breaks deep within the lock, its jagged end wedged immovably in place.",
            "A loud crack echoes as the lock's internal components shatter. This one isn't opening."
          ],
          "glitched": [
            "Reality shudders as the lock phases through your picks, reforming in a twisted configuration.",
            "The Blight's whispers crescendo as the mechanism seizes, its metal now running with corruption."
          ]
        },
        "failed": {
          "default": [
            "The tumblers resist your attempts, refusing to yield.",
            "Your picks find no purchase. The lock remains steadfastly closed.",
            "The mechanism's complexity exceeds your current approach."
          ]
        },
        "marginal": {
          "default": [
            "After several tense moments, the last tumbler finally clicks into place.",
            "The lock yields reluctantly, as if grudging your success.",
            "A final twist and the mechanism surrenders, though not without protest."
          ]
        },
        "competent": {
          "default": [
            "The lock yields to your practiced fingers.",
            "Tumblers click into place with satisfying precision.",
            "Your picks find the path through the mechanism with practiced ease."
          ],
          "glitched": [
            "Reality shudders as the lock opens unexpectedly, tumblers aligning of their own accord.",
            "The mechanism phases briefly before clicking open, corruption momentarily aiding your work."
          ]
        },
        "impressive": {
          "default": [
            "The lock practically opens itself under your expert ministrations.",
            "Each tumbler falls perfectly into place, your movements fluid and precise.",
            "A masterwork of locksmithing technique leaves the mechanism defeated in moments."
          ]
        },
        "masterful": {
          "default": [
            "The lock surrenders instantly to your legendary touch.",
            "Your understanding of the mechanism is so complete, it might as well have been unlocked.",
            "The Tinker-Saints themselves would nod in approval at this display of skill."
          ]
        }
      }
    },
    "persuasion": {
      "categories": {
        "catastrophic": {
          "default": [
            "Your words land like a physical blow. Any trust evaporates in an instant.",
            "Something in your argument strikes a nerve. Their expression hardens permanently.",
            "You've not just failed to persuade—you've made an enemy."
          ],
          "hostile": [
            "Your attempt at reason only deepens their hostility. Weapons are being drawn.",
            "They were already angry. Now they're furious. And looking for a target."
          ]
        },
        "failed": {
          "default": [
            "Your argument fails to find purchase. They remain unconvinced.",
            "Your words fall flat, meeting only skeptical silence.",
            "They listen, but clearly remain unswayed by your reasoning."
          ]
        },
        "marginal": {
          "default": [
            "After considerable effort, you see a grudging acceptance in their eyes.",
            "They're not happy about it, but your point finally lands.",
            "It takes everything you have, but they eventually come around."
          ]
        },
        "competent": {
          "default": [
            "Your argument resonates. They nod in understanding.",
            "Your words find fertile ground, and agreement blooms.",
            "A well-crafted appeal achieves the desired effect."
          ],
          "friendly": [
            "Your friend listens warmly and agrees readily.",
            "They were already inclined to help, and your words seal it."
          ]
        },
        "impressive": {
          "default": [
            "Your rhetoric is so compelling, they wonder why they ever doubted you.",
            "Not only do they agree—they're now eager to help.",
            "Your persuasion is so effective, they feel they've reached this conclusion themselves."
          ]
        },
        "masterful": {
          "default": [
            "Your words weave a spell of pure conviction. They would follow you anywhere.",
            "In a single conversation, you've transformed a stranger into a true believer.",
            "The Skalds would compose sagas about this display of rhetorical mastery."
          ]
        }
      }
    },
    "climbing": {
      "categories": {
        "catastrophic": {
          "default": [
            "Your grip fails catastrophically. The ground rushes up to meet you.",
            "The surface crumbles beneath your fingers. You're falling.",
            "A handhold snaps. For a sickening moment, you're weightless."
          ],
          "compromised": [
            "The already unstable surface gives way entirely, taking you with it.",
            "The corroded metal finally surrenders to your weight. Everything collapses."
          ]
        },
        "failed": {
          "default": [
            "You can find no safe path upward. The ascent eludes you.",
            "Every potential handhold proves treacherous. You're stuck.",
            "The surface offers nothing you can safely grip."
          ]
        },
        "marginal": {
          "default": [
            "By the narrowest of margins, you reach the next hold.",
            "A scrambling, undignified climb, but you make it.",
            "More luck than skill sees you to the next stage."
          ]
        },
        "competent": {
          "default": [
            "Your ascent is controlled and steady.",
            "Hands and feet find purchase with practiced reliability.",
            "A clean climb, nothing wasted."
          ],
          "stable": [
            "The solid surface makes your climb almost effortless.",
            "Reliable handholds guide your confident ascent."
          ]
        },
        "impressive": {
          "default": [
            "You flow up the surface like water running in reverse.",
            "Every movement is economical, every grip perfect.",
            "The climb is poetry in motion."
          ]
        },
        "masterful": {
          "default": [
            "You ascend with the grace of a Gantry-Runner born to the heights.",
            "The surface seems to welcome you, offering holds that others would never see.",
            "The ancestors of the Dvergr would mark you as one of their own."
          ]
        }
      }
    },
    "stealth": {
      "categories": {
        "catastrophic": {
          "default": [
            "A deafening clatter echoes through the space. Every eye turns your way.",
            "You couldn't have drawn more attention if you'd fired a flare.",
            "Alert klaxons begin to wail. So much for subtlety."
          ],
          "dark": [
            "You crash into something in the darkness. The noise seems impossibly loud.",
            "The shadows that were your ally have betrayed you. You've given yourself away."
          ]
        },
        "failed": {
          "default": [
            "Something gives your position away. You've been spotted.",
            "Despite your best efforts, you're not as hidden as you thought.",
            "A sound. A shadow. Something has revealed you."
          ]
        },
        "marginal": {
          "default": [
            "They heard something, but you freeze in time. They look away.",
            "A close call. You nearly gave yourself away.",
            "By sheer luck, you remain undetected. Barely."
          ]
        },
        "competent": {
          "default": [
            "Your movements produce no sound. The shadows embrace you.",
            "Like a ghost, you pass unseen and unheard.",
            "The space accepts your presence without complaint."
          ]
        },
        "impressive": {
          "default": [
            "You are one with the darkness. Nothing marks your passage.",
            "Even the most vigilant would struggle to detect you.",
            "Your stealth is so complete, you nearly startle yourself."
          ]
        },
        "masterful": {
          "default": [
            "The Myrk-gengr themselves would acknowledge you as kindred.",
            "You don't just hide—you cease to exist until you choose otherwise.",
            "Shadows knit themselves around you like a living cloak."
          ]
        }
      }
    }
  }
}
```

### 14.2 skill-descriptors.schema.json

**File:** `src/Data/Configuration/skill-descriptors.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "skill-descriptors.schema.json",
  "title": "Skill Descriptors Configuration",
  "description": "Schema for skill-specific voice guidance descriptors",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "skills": {
      "type": "object",
      "description": "Map of skill IDs to their descriptor pools",
      "additionalProperties": {
        "$ref": "#/$defs/skillConfig"
      }
    }
  },
  "required": ["skills"],
  "$defs": {
    "skillConfig": {
      "type": "object",
      "properties": {
        "categories": {
          "type": "object",
          "description": "Descriptor pools organized by outcome category",
          "additionalProperties": {
            "$ref": "#/$defs/categoryPool"
          }
        }
      },
      "required": ["categories"]
    },
    "categoryPool": {
      "type": "object",
      "properties": {
        "default": {
          "type": "array",
          "description": "Default descriptor pool for this category",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "contextual": {
          "type": "object",
          "description": "Context-specific descriptor pools (corruption, surface, disposition)",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1
          }
        }
      },
      "required": ["default"]
    }
  }
}
```

---

## 15. Configuration - Specialization Bonuses

### 15.1 specialization-bonuses.json

**File:** `src/Data/Configuration/specialization-bonuses.json`

```json
{
  "$schema": "specialization-bonuses.schema.json",
  "specializations": {
    "gantry-runner": {
      "name": "Gantry-Runner: Urban Acrobat",
      "skills": {
        "climbing": {
          "diceBonus": 2,
          "description": "Born to the Heights"
        },
        "leaping": {
          "diceBonus": 1,
          "description": "Gap Jumper"
        },
        "stealth": {
          "diceBonus": 1,
          "condition": {
            "surfaceTypes": ["metal", "industrial"]
          },
          "description": "Industrial Crawler"
        }
      }
    },
    "myrk-gengr": {
      "name": "Myrk-gengr: Shadow Walker",
      "skills": {
        "stealth": {
          "diceBonus": 2,
          "description": "Shadow Born"
        },
        "observation": {
          "diceBonus": 1,
          "condition": {
            "lightingLevel": ["dim", "dark"]
          },
          "description": "Dark-Adapted Eyes"
        }
      }
    },
    "thul": {
      "name": "Thul: Speaker of Truths",
      "skills": {
        "persuasion": {
          "diceBonus": 1,
          "specialAbility": "no-reputation-loss-on-failure",
          "description": "Protected Diplomat"
        },
        "deception": {
          "dcModifier": 2,
          "description": "Bound to Truth"
        }
      }
    },
    "skald": {
      "name": "Skald: Voice of Legend",
      "skills": {
        "intimidation": {
          "diceBonus": 1,
          "description": "Bardic Presence"
        },
        "persuasion": {
          "diceBonus": 1,
          "description": "Silver Tongue"
        }
      }
    },
    "kupmadr": {
      "name": "Kaupmaðr: Master Negotiator",
      "skills": {
        "negotiation": {
          "diceBonus": 2,
          "description": "Trade Mastery"
        },
        "persuasion": {
          "diceBonus": 1,
          "condition": {
            "targetDisposition": ["neutral", "friendly"]
          },
          "description": "Deal Maker"
        }
      }
    },
    "scrap-tinker": {
      "name": "Scrap-Tinker: Mechanical Savant",
      "skills": {
        "lockpicking": {
          "diceBonus": 1,
          "description": "Lock Sense"
        },
        "trap-disarmament": {
          "diceBonus": 2,
          "description": "Mechanical Intuition"
        },
        "jury-rigging": {
          "diceBonus": 2,
          "description": "Improvised Solutions"
        }
      }
    },
    "ruin-stalker": {
      "name": "Ruin-Stalker: Trap Master",
      "skills": {
        "trap-disarmament": {
          "diceBonus": 2,
          "specialAbility": "always-salvage-components",
          "description": "Expert Disarmer"
        },
        "trap-detection": {
          "diceBonus": 1,
          "description": "Danger Sense"
        }
      }
    },
    "jotun-reader": {
      "name": "Jötun-Reader: Terminal Master",
      "skills": {
        "terminal-hacking": {
          "diceBonus": 2,
          "description": "Data Communion"
        },
        "data-recovery": {
          "diceBonus": 1,
          "description": "Ancestral Whispers"
        }
      }
    },
    "veidimadr": {
      "name": "Veiðimaðr: Creature Tracker",
      "skills": {
        "tracking": {
          "diceBonus": 2,
          "condition": {
            "targetType": ["creature", "beast"]
          },
          "description": "Beast Hunter"
        },
        "foraging": {
          "diceBonus": 1,
          "description": "Hunter's Knowledge"
        }
      }
    },
    "myr-stalker": {
      "name": "Myr-Stalker: Wasteland Expert",
      "skills": {
        "navigation": {
          "diceBonus": 2,
          "condition": {
            "biomes": ["swamp", "marsh", "bog", "wetland"]
          },
          "description": "Mire Walker"
        },
        "hazard-detection": {
          "diceBonus": 1,
          "condition": {
            "biomes": ["swamp", "marsh", "bog", "wetland"]
          },
          "description": "Swamp Sense"
        },
        "foraging": {
          "diceBonus": 1,
          "condition": {
            "biomes": ["swamp", "marsh", "bog", "wetland"]
          },
          "description": "Mire Harvester"
        }
      }
    }
  }
}
```

### 15.2 specialization-bonuses.schema.json

**File:** `src/Data/Configuration/specialization-bonuses.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "specialization-bonuses.schema.json",
  "title": "Specialization Skill Bonuses Configuration",
  "description": "Schema for specialization (archetype) skill bonus definitions",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "specializations": {
      "type": "object",
      "description": "Map of specialization IDs to their configurations",
      "additionalProperties": {
        "$ref": "#/$defs/specializationConfig"
      }
    }
  },
  "required": ["specializations"],
  "$defs": {
    "specializationConfig": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Display name for the specialization"
        },
        "skills": {
          "type": "object",
          "description": "Map of skill IDs to bonus configurations",
          "additionalProperties": {
            "$ref": "#/$defs/skillBonusConfig"
          }
        }
      },
      "required": ["name", "skills"]
    },
    "skillBonusConfig": {
      "type": "object",
      "properties": {
        "diceBonus": {
          "type": "integer",
          "description": "Bonus dice to add to the pool (positive or negative)"
        },
        "dcModifier": {
          "type": "integer",
          "description": "DC modifier (positive = harder, negative = easier)"
        },
        "description": {
          "type": "string",
          "description": "Human-readable description of the bonus"
        },
        "specialAbility": {
          "type": "string",
          "description": "Special ability flag for non-standard effects"
        },
        "condition": {
          "$ref": "#/$defs/conditionConfig"
        }
      }
    },
    "conditionConfig": {
      "type": "object",
      "description": "Conditions that must be met for the bonus to apply",
      "properties": {
        "biomes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Required biome types"
        },
        "surfaceTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Required surface types"
        },
        "lightingLevel": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Required lighting levels"
        },
        "targetType": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Required target types"
        },
        "targetDisposition": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Required target dispositions"
        },
        "requiredEquipment": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Required equipment IDs"
        }
      }
    }
  }
}
```

---

## 16. Data Model Changes

### 16.1 SkillCheckResult Extension

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SkillCheckResult.cs`

```csharp
// Add to existing SkillCheckResult class:

/// <summary>
/// Gets the stress result from this skill check.
/// </summary>
/// <remarks>
/// Contains the psychic stress incurred from corruption exposure and/or fumble.
/// Will be null if no stress calculation was performed.
/// </remarks>
public SkillStressResult? StressResult { get; init; }

/// <summary>
/// Gets the voice guidance descriptor for this outcome.
/// </summary>
/// <remarks>
/// Contains narrative flavor text appropriate for the skill and outcome.
/// Will be null if no descriptor was available.
/// </remarks>
public SkillDescriptor? Descriptor { get; init; }

/// <summary>
/// Gets the specialization bonus that was applied to this check.
/// </summary>
/// <remarks>
/// Contains the bonus applied from the character's specialization.
/// Will be null if no specialization bonus applied.
/// </remarks>
public SpecializationSkillBonus? SpecializationBonus { get; init; }
```

### 16.2 Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    V0.15.1E DATA MODEL RELATIONSHIPS                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SkillCheckResult (Extended)                                                │
│  ├── DiceResult: DiceRollResult (v0.15.0a)                                  │
│  ├── OutcomeDetails: OutcomeDetails (v0.15.1b)                              │
│  ├── Context: SkillContext (v0.15.1a)                                       │
│  ├── StressResult: SkillStressResult? ←── NEW                               │
│  │   ├── TotalStress: int                                                   │
│  │   ├── CorruptionStress: int                                              │
│  │   ├── FumbleStress: int                                                  │
│  │   ├── Source: StressSource ←── NEW ENUM                                  │
│  │   └── TriggersBreakingPoint: bool                                        │
│  ├── Descriptor: SkillDescriptor? ←── NEW                                   │
│  │   ├── SkillId: string                                                    │
│  │   ├── Category: DescriptorCategory (v0.15.1b)                            │
│  │   ├── Text: string                                                       │
│  │   └── ContextType: string?                                               │
│  └── SpecializationBonus: SpecializationSkillBonus? ←── NEW                 │
│      ├── SpecializationId: string                                           │
│      ├── SkillId: string                                                    │
│      ├── DiceBonus: int                                                     │
│      ├── DcModifier: int                                                    │
│      └── SpecialAbility: string?                                            │
│                                                                              │
│  Consuming Systems:                                                         │
│  ├── Trauma System (v0.19.x) ──────────→ Consumes StressResult              │
│  ├── Renderer ───────────────────────────→ Displays Descriptor.Text         │
│  └── Skill System (v0.15.2-v0.15.5) ───→ Uses SpecializationBonus           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 17. SkillCheckService Integration

### 17.1 Integration Flow

```csharp
// Modifications to SkillCheckService.cs

/// <summary>
/// Performs a skill check with full integration point support.
/// </summary>
public SkillCheckResult PerformCheck(
    Player player,
    string skillId,
    int difficultyClass,
    SkillContext context)
{
    // 1. Get specialization bonus
    var specializationBonus = _specializationBonusProvider.GetSkillBonus(
        player.SpecializationId,
        skillId,
        context);

    // 2. Apply specialization bonus to context
    var modifiedContext = context;
    if (specializationBonus.ShouldApply)
    {
        modifiedContext = context.WithAdditionalDice(specializationBonus.DiceBonus);
        // Note: DC modifier applied to difficultyClass below
        difficultyClass += specializationBonus.DcModifier;
    }

    // 3. Calculate dice pool and perform roll
    var dicePool = CalculateDicePool(player, skillId, modifiedContext);
    var diceResult = _diceRoller.Roll(dicePool);

    // 4. Create outcome details
    var outcomeDetails = OutcomeDetails.FromDiceResult(diceResult, difficultyClass);

    // 5. Calculate stress from trauma integration
    var stressResult = _traumaIntegrationService.CalculateSkillStress(
        modifiedContext,
        outcomeDetails);

    // 6. Get voice guidance descriptor
    var descriptor = _voiceGuidanceService.GetDescriptor(
        skillId,
        outcomeDetails,
        modifiedContext);

    // 7. Build and return result
    return new SkillCheckResult
    {
        PlayerId = player.Id,
        SkillId = skillId,
        DifficultyClass = difficultyClass,
        DiceResult = diceResult,
        OutcomeDetails = outcomeDetails,
        Context = modifiedContext,
        StressResult = stressResult,
        Descriptor = descriptor,
        SpecializationBonus = specializationBonus.ShouldApply ? specializationBonus : null
    };
}
```

### 17.2 Dependency Injection Registration

```csharp
// In ServiceCollectionExtensions.cs or Startup.cs

services.AddSingleton<ITraumaIntegrationService, TraumaIntegrationService>();

services.AddSingleton<ISpecializationBonusProvider>(sp =>
{
    var logger = sp.GetRequiredService<ILogger<SpecializationBonusProvider>>();
    var configPath = Path.Combine(
        AppDomain.CurrentDomain.BaseDirectory,
        "Configuration",
        "specialization-bonuses.json");
    return new SpecializationBonusProvider(configPath, logger);
});

services.AddSingleton<IVoiceGuidanceService>(sp =>
{
    var logger = sp.GetRequiredService<ILogger<VoiceGuidanceService>>();
    var random = sp.GetRequiredService<IRandomProvider>();
    var configPath = Path.Combine(
        AppDomain.CurrentDomain.BaseDirectory,
        "Configuration",
        "skill-descriptors.json");
    return new VoiceGuidanceService(configPath, random, logger);
});
```

---

## 18. Logging Specifications

### 18.1 Log Categories and Levels

| Component | Log Level | Message Pattern |
|-----------|-----------|-----------------|
| TraumaIntegrationService | Debug | "Skill stress calculated: {TotalStress} (corruption: {Corruption}, fumble: {Fumble})" |
| TraumaIntegrationService | Information | "Breaking point threshold reached: {TotalStress} stress from {Source}" |
| SpecializationBonusProvider | Debug | "Specialization bonus applied: {Description}" |
| SpecializationBonusProvider | Trace | "No bonus for {SpecializationId} → {SkillId}" |
| VoiceGuidanceService | Trace | "Using contextual descriptor for {SkillId}/{Category}" |
| VoiceGuidanceService | Trace | "No descriptor found for {SkillId}/{Category}, using generic fallback" |

### 18.2 Structured Logging Example

```csharp
_logger.LogDebug(
    "Skill check completed: {SkillId} with {Outcome}, stress: {Stress}, descriptor: {HasDescriptor}",
    result.SkillId,
    result.OutcomeDetails.OutcomeType,
    result.StressResult?.TotalStress ?? 0,
    result.Descriptor?.HasContent ?? false);
```

---

## 19. Unit Testing Requirements

### 19.1 Unit Tests (~3 tests per scope breakdown)

#### TraumaIntegrationServiceTests.cs

```csharp
[TestFixture]
public class TraumaIntegrationServiceTests
{
    private TraumaIntegrationService _service;
    private Mock<ILogger<TraumaIntegrationService>> _loggerMock;

    [SetUp]
    public void Setup()
    {
        _loggerMock = new Mock<ILogger<TraumaIntegrationService>>();
        _service = new TraumaIntegrationService(_loggerMock.Object);
    }

    [Test]
    public void CalculateSkillStress_NormalArea_NoFumble_ReturnsZeroStress()
    {
        // Arrange
        var context = new SkillContextBuilder()
            .WithCorruption(CorruptionTier.Normal)
            .Build();
        var outcome = OutcomeDetails.FromDiceResult(
            new DiceRollResult(successes: 2, botches: 0),
            difficultyClass: 2);

        // Act
        var result = _service.CalculateSkillStress(context, outcome);

        // Assert
        Assert.That(result.TotalStress, Is.EqualTo(0));
        Assert.That(result.HasStress, Is.False);
        Assert.That(result.Source, Is.EqualTo(StressSource.None));
    }

    [Test]
    [TestCase(CorruptionTier.Glitched, 2)]
    [TestCase(CorruptionTier.Blighted, 5)]
    [TestCase(CorruptionTier.Resonance, 10)]
    public void CalculateSkillStress_CorruptedArea_NoFumble_ReturnsCorruptionStress(
        CorruptionTier tier,
        int expectedStress)
    {
        // Arrange
        var context = new SkillContextBuilder()
            .WithCorruption(tier)
            .Build();
        var outcome = OutcomeDetails.FromDiceResult(
            new DiceRollResult(successes: 2, botches: 0),
            difficultyClass: 2);

        // Act
        var result = _service.CalculateSkillStress(context, outcome);

        // Assert
        Assert.That(result.TotalStress, Is.EqualTo(expectedStress));
        Assert.That(result.CorruptionStress, Is.EqualTo(expectedStress));
        Assert.That(result.FumbleStress, Is.EqualTo(0));
        Assert.That(result.Source, Is.EqualTo(StressSource.Corruption));
    }

    [Test]
    [TestCase(CorruptionTier.Normal, 1)]
    [TestCase(CorruptionTier.Glitched, 4)]   // 2 corruption + 2 fumble
    [TestCase(CorruptionTier.Blighted, 9)]   // 5 corruption + 4 fumble
    [TestCase(CorruptionTier.Resonance, 18)] // 10 corruption + 8 fumble
    public void CalculateSkillStress_Fumble_ReturnsCombinedStress(
        CorruptionTier tier,
        int expectedTotal)
    {
        // Arrange
        var context = new SkillContextBuilder()
            .WithCorruption(tier)
            .Build();
        var outcome = OutcomeDetails.FromDiceResult(
            new DiceRollResult(successes: 0, botches: 1), // Fumble
            difficultyClass: 2);

        // Act
        var result = _service.CalculateSkillStress(context, outcome);

        // Assert
        Assert.That(result.TotalStress, Is.EqualTo(expectedTotal));
        Assert.That(result.HadFumble, Is.True);
        Assert.That(result.Source, Is.EqualTo(StressSource.Fumble));
    }

    [Test]
    public void CalculateSkillStress_HighStress_TriggersBreakingPoint()
    {
        // Arrange
        var context = new SkillContextBuilder()
            .WithCorruption(CorruptionTier.Resonance)
            .Build();
        var outcome = OutcomeDetails.FromDiceResult(
            new DiceRollResult(successes: 0, botches: 1), // Fumble in Resonance zone
            difficultyClass: 2);

        // Act
        var result = _service.CalculateSkillStress(context, outcome);

        // Assert
        Assert.That(result.TriggersBreakingPoint, Is.True);
        Assert.That(result.TotalStress, Is.GreaterThanOrEqualTo(
            SkillStressResult.BreakingPointThreshold));
    }
}
```

#### SpecializationBonusProviderTests.cs

```csharp
[TestFixture]
public class SpecializationBonusProviderTests
{
    private SpecializationBonusProvider _provider;

    [SetUp]
    public void Setup()
    {
        var loggerMock = new Mock<ILogger<SpecializationBonusProvider>>();
        var configPath = Path.Combine(
            TestContext.CurrentContext.TestDirectory,
            "TestData",
            "specialization-bonuses.json");
        _provider = new SpecializationBonusProvider(configPath, loggerMock.Object);
    }

    [Test]
    public void GetSkillBonus_GantryRunnerClimbing_ReturnsTwoDiceBonus()
    {
        // Arrange
        var context = new SkillContextBuilder().Build();

        // Act
        var bonus = _provider.GetSkillBonus("gantry-runner", "climbing", context);

        // Assert
        Assert.That(bonus.DiceBonus, Is.EqualTo(2));
        Assert.That(bonus.ShouldApply, Is.True);
        Assert.That(bonus.SpecializationId, Is.EqualTo("gantry-runner"));
    }

    [Test]
    public void GetSkillBonus_MyrStalkerInSwamp_ReturnsConditionalBonus()
    {
        // Arrange
        var context = new SkillContextBuilder()
            .WithEnvironment(new EnvironmentModifier("swamp", "Swamp", 0, 0))
            .Build();

        // Act
        var bonus = _provider.GetSkillBonus("myr-stalker", "navigation", context);

        // Assert
        Assert.That(bonus.DiceBonus, Is.EqualTo(2));
        Assert.That(bonus.IsConditional, Is.True);
        Assert.That(bonus.ConditionMet, Is.True);
    }

    [Test]
    public void GetSkillBonus_MyrStalkerNotInSwamp_ReturnsConditionNotMet()
    {
        // Arrange
        var context = new SkillContextBuilder()
            .WithEnvironment(new EnvironmentModifier("desert", "Desert", 0, 0))
            .Build();

        // Act
        var bonus = _provider.GetSkillBonus("myr-stalker", "navigation", context);

        // Assert
        Assert.That(bonus.IsConditional, Is.True);
        Assert.That(bonus.ConditionMet, Is.False);
        Assert.That(bonus.ShouldApply, Is.False);
    }

    [Test]
    public void GetSkillBonus_ThulPersuasion_ReturnsSpecialAbility()
    {
        // Arrange
        var context = new SkillContextBuilder().Build();

        // Act
        var bonus = _provider.GetSkillBonus("thul", "persuasion", context);

        // Assert
        Assert.That(bonus.HasSpecialAbility, Is.True);
        Assert.That(bonus.SpecialAbility, Is.EqualTo("no-reputation-loss-on-failure"));
    }

    [Test]
    public void GetSkillBonus_UnknownSpecialization_ReturnsNoBonus()
    {
        // Arrange
        var context = new SkillContextBuilder().Build();

        // Act
        var bonus = _provider.GetSkillBonus("unknown-spec", "climbing", context);

        // Assert
        Assert.That(bonus.HasEffect, Is.False);
        Assert.That(bonus.ShouldApply, Is.False);
    }
}
```

#### VoiceGuidanceServiceTests.cs

```csharp
[TestFixture]
public class VoiceGuidanceServiceTests
{
    private VoiceGuidanceService _service;
    private Mock<IRandomProvider> _randomMock;

    [SetUp]
    public void Setup()
    {
        _randomMock = new Mock<IRandomProvider>();
        _randomMock.Setup(r => r.Next(It.IsAny<int>())).Returns(0); // Always first item

        var loggerMock = new Mock<ILogger<VoiceGuidanceService>>();
        var configPath = Path.Combine(
            TestContext.CurrentContext.TestDirectory,
            "TestData",
            "skill-descriptors.json");
        _service = new VoiceGuidanceService(configPath, _randomMock.Object, loggerMock.Object);
    }

    [Test]
    public void GetDescriptor_LockpickingCompetent_ReturnsSkillSpecificText()
    {
        // Act
        var descriptor = _service.GetDescriptor(
            "lockpicking",
            DescriptorCategory.Competent);

        // Assert
        Assert.That(descriptor.HasContent, Is.True);
        Assert.That(descriptor.SkillId, Is.EqualTo("lockpicking"));
        Assert.That(descriptor.Category, Is.EqualTo(DescriptorCategory.Competent));
        Assert.That(descriptor.Text, Does.Contain("lock") | Does.Contain("tumbler"));
    }

    [Test]
    public void GetDescriptor_LockpickingInGlitchedArea_ReturnsContextualText()
    {
        // Arrange
        var context = new SkillContextBuilder()
            .WithCorruption(CorruptionTier.Glitched)
            .Build();

        // Act
        var descriptor = _service.GetDescriptor(
            "lockpicking",
            DescriptorCategory.Competent,
            context);

        // Assert
        Assert.That(descriptor.IsContextual, Is.True);
        Assert.That(descriptor.ContextType, Is.EqualTo("glitched"));
        Assert.That(descriptor.Text, Does.Contain("Reality") | Does.Contain("phase"));
    }

    [Test]
    public void GetDescriptor_UnknownSkill_ReturnsGenericFallback()
    {
        // Act
        var descriptor = _service.GetDescriptor(
            "unknown-skill",
            DescriptorCategory.Competent);

        // Assert
        Assert.That(descriptor.HasContent, Is.True);
        Assert.That(descriptor.SkillId, Is.EqualTo("generic"));
    }

    [Test]
    public void GetDescriptor_FromOutcomeDetails_UsesCorrectCategory()
    {
        // Arrange
        var outcome = OutcomeDetails.FromDiceResult(
            new DiceRollResult(successes: 3, botches: 0),
            difficultyClass: 2);
        // Margin 1 = FullSuccess = Competent

        // Act
        var descriptor = _service.GetDescriptor("lockpicking", outcome);

        // Assert
        Assert.That(descriptor.Category, Is.EqualTo(DescriptorCategory.Competent));
    }

    [Test]
    public void HasDescriptors_ConfiguredSkill_ReturnsTrue()
    {
        // Act & Assert
        Assert.That(_service.HasDescriptors("lockpicking"), Is.True);
        Assert.That(_service.HasDescriptors("persuasion"), Is.True);
    }

    [Test]
    public void HasDescriptors_UnconfiguredSkill_ReturnsFalse()
    {
        // Act & Assert
        Assert.That(_service.HasDescriptors("unknown-skill"), Is.False);
    }
}
```

---

## 20. Use Cases

### 20.1 Use Case: Lockpicking in Glitched Area

**Scenario:** A Scrap-Tinker attempts to pick a lock in a Glitched-corrupted area and fails catastrophically.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: LOCKPICKING IN GLITCHED AREA (FUMBLE)                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. PLAYER ACTION                                                           │
│     Player: "pick lock"                                                     │
│     Specialization: Scrap-Tinker                                            │
│     Location: Glitched corridor                                             │
│                                                                              │
│  2. SPECIALIZATION BONUS LOOKUP                                             │
│     SpecializationBonusProvider.GetSkillBonus("scrap-tinker", "lockpicking")│
│     → Returns: +1d10 (Lock Sense)                                           │
│                                                                              │
│  3. CONTEXT BUILT                                                           │
│     SkillContext:                                                           │
│       Equipment: [Tinker's Toolkit +2d10]                                   │
│       Environment: [Glitched Area DC+2]                                     │
│       Specialization: [+1d10 from Scrap-Tinker]                             │
│                                                                              │
│  4. DICE ROLL                                                               │
│     Pool: 4d10 (base) + 2 (tools) + 1 (specialization) = 7d10              │
│     DC: 2 (Moderate) + 2 (Glitched) = 4                                    │
│     Roll: [1, 2, 3, 4, 5, 6, 7] → 0 successes, 1 botch = FUMBLE            │
│                                                                              │
│  5. TRAUMA INTEGRATION                                                      │
│     TraumaIntegrationService.CalculateSkillStress(context, outcome)         │
│     Corruption stress: 2 (Glitched)                                         │
│     Fumble bonus: 2 (Glitched amplification)                                │
│     Total: 4 stress                                                         │
│     Breaking point: No (4 < 8)                                              │
│                                                                              │
│  6. VOICE GUIDANCE                                                          │
│     VoiceGuidanceService.GetDescriptor("lockpicking", Catastrophic, ctx)    │
│     Context: Glitched                                                       │
│     → "Reality shudders as the lock phases through your picks,              │
│        reforming in a twisted configuration."                               │
│                                                                              │
│  7. RESULT                                                                  │
│     SkillCheckResult:                                                       │
│       Outcome: CriticalFailure (Fumble)                                     │
│       StressResult: 4 (Glitched + Fumble)                                   │
│       Descriptor: [Contextual catastrophic text]                            │
│       SpecializationBonus: +1d10 (Scrap-Tinker: Lock Sense)                │
│                                                                              │
│  8. DISPLAY                                                                 │
│     "Reality shudders as the lock phases through your picks,                │
│      reforming in a twisted configuration."                                 │
│                                                                              │
│     Psychic Stress: 4 (2 from Glitched corruption, 2 from fumble)          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 20.2 Use Case: Myr-Stalker Navigation in Swamp

**Scenario:** A Myr-Stalker navigates through a swamp biome, benefiting from their conditional specialization bonus.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: MYR-STALKER NAVIGATION IN SWAMP                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. PLAYER ACTION                                                           │
│     Player: "navigate north"                                                │
│     Specialization: Myr-Stalker                                             │
│     Location: Fetid Marsh (swamp biome)                                     │
│                                                                              │
│  2. SPECIALIZATION BONUS LOOKUP                                             │
│     SpecializationBonusProvider.GetSkillBonus("myr-stalker", "navigation")  │
│     Condition: biomes = ["swamp", "marsh", "bog", "wetland"]               │
│     Current biome: "marsh" → Condition MET                                  │
│     → Returns: +2d10 (Mire Walker)                                          │
│                                                                              │
│  3. DICE ROLL                                                               │
│     Pool: 3d10 (base) + 2 (Myr-Stalker) = 5d10                             │
│     DC: 3 (Moderate terrain)                                                │
│     Roll: [8, 9, 4, 10, 6] → 3 successes = Exceptional Success (margin 2)  │
│                                                                              │
│  4. TRAUMA INTEGRATION                                                      │
│     CorruptionTier: Normal                                                  │
│     → 0 stress                                                              │
│                                                                              │
│  5. VOICE GUIDANCE                                                          │
│     VoiceGuidanceService.GetDescriptor("navigation", Impressive)            │
│     → "The marsh seems to part before you, its secrets laid bare."          │
│                                                                              │
│  6. DISPLAY                                                                 │
│     Navigation Check: Exceptional Success! (5d10 vs DC 3)                   │
│     [Myr-Stalker: Mire Walker +2d10]                                        │
│                                                                              │
│     "The marsh seems to part before you, its secrets laid bare."            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 20.3 Use Case: Thul Persuasion with Special Ability

**Scenario:** A Thul attempts persuasion and fails, but their special ability prevents reputation loss.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: THUL PERSUASION WITH SPECIAL ABILITY                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. PLAYER ACTION                                                           │
│     Player: "persuade merchant"                                             │
│     Specialization: Thul (Speaker of Truths)                                │
│     Target: Hostile merchant                                                │
│                                                                              │
│  2. SPECIALIZATION BONUS LOOKUP                                             │
│     SpecializationBonusProvider.GetSkillBonus("thul", "persuasion")         │
│     → Returns: +1d10, SpecialAbility: "no-reputation-loss-on-failure"       │
│                                                                              │
│  3. DICE ROLL                                                               │
│     Pool: 3d10 (base) + 1 (Thul) - 2 (Hostile disposition) = 2d10          │
│     DC: 3 (Moderate request)                                                │
│     Roll: [4, 7] → 0 successes = Failure                                   │
│                                                                              │
│  4. SPECIAL ABILITY CHECK                                                   │
│     SpecializationBonus.HasSpecialAbility = true                            │
│     SpecialAbility = "no-reputation-loss-on-failure"                        │
│     → Flag for reputation system: DO NOT reduce reputation                  │
│                                                                              │
│  5. VOICE GUIDANCE                                                          │
│     Context: hostile disposition                                            │
│     VoiceGuidanceService.GetDescriptor("persuasion", Failed, ctx)           │
│     → "Your words fall on deaf ears. They were never going to listen."      │
│                                                                              │
│  6. DISPLAY                                                                 │
│     Persuasion Check: Failed (2d10 vs DC 3)                                 │
│     [Thul: Protected Diplomat +1d10]                                        │
│                                                                              │
│     "Your words fall on deaf ears. They were never going to listen."        │
│                                                                              │
│     [Your diplomatic immunity prevents reputation loss]                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 20.4 Use Case: Extended Check in Resonance Zone

**Scenario:** A player attempts a multi-stage terminal hacking procedure in a highly corrupted Resonance zone.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: EXTENDED CHECK IN RESONANCE ZONE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. EXTENDED CHECK SETUP                                                    │
│     Procedure: Terminal Hacking (3 stages)                                  │
│     Location: Resonance Zone (highest corruption)                           │
│                                                                              │
│  2. STAGE RESULTS                                                           │
│     Stage 1 (Access): Success                                               │
│     Stage 2 (Authentication): Fumble                                        │
│     Stage 3 (Navigation): Success                                           │
│                                                                              │
│  3. TRAUMA INTEGRATION (Extended Check)                                     │
│     TraumaIntegrationService.CalculateExtendedCheckStress(                  │
│         context, stepCount: 3, fumbleCount: 1)                              │
│                                                                              │
│     Per-step stress: 10 (Resonance) × 3 steps = 30                         │
│     Fumble stress: 8 (Resonance fumble) × 1 = 8                            │
│     Total: 38 stress                                                        │
│     Breaking point: YES (38 >= 8)                                           │
│                                                                              │
│  4. RESULT                                                                  │
│     Extended check succeeded but at great cost:                             │
│     - 38 total psychic stress accumulated                                   │
│     - Breaking point check triggered                                        │
│     - Stage 2 fumble may have caused FumbleConsequence                     │
│                                                                              │
│  5. DISPLAY                                                                 │
│     Terminal Access: COMPLETE (3/3 stages)                                  │
│                                                                              │
│     "The data flows into your mind, but the Blight follows..."              │
│                                                                              │
│     Psychic Stress: 38 (30 from Resonance exposure, 8 from fumble)         │
│     [WARNING: Breaking Point Check Required]                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 20.5 Use Case: Voice Guidance Context Selection

**Scenario:** Showing how voice guidance selects descriptors based on context priority.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  USE CASE: VOICE GUIDANCE CONTEXT PRIORITY                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CONTEXT PRIORITY ORDER:                                                    │
│  1. Corruption (glitched > blighted > resonance)                           │
│  2. Surface type (wet, compromised, etc.)                                   │
│  3. Target disposition (hostile, friendly, etc.)                            │
│  4. Default pool                                                            │
│                                                                              │
│  EXAMPLE 1: Glitched climbing on wet surface                               │
│  Context: { Corruption: Glitched, Surface: Wet }                           │
│  Skill: climbing, Category: Catastrophic                                    │
│                                                                              │
│  Lookup order:                                                              │
│  1. climbing.catastrophic.contextual.glitched → FOUND → USE THIS           │
│                                                                              │
│  Result: "The Blight's touch makes the surface phase beneath you.           │
│           You fall through reality itself."                                 │
│                                                                              │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  EXAMPLE 2: Normal area, wet surface, climbing                             │
│  Context: { Corruption: Normal, Surface: Wet }                             │
│  Skill: climbing, Category: Catastrophic                                    │
│                                                                              │
│  Lookup order:                                                              │
│  1. climbing.catastrophic.contextual.normal → NOT FOUND                     │
│  2. climbing.catastrophic.contextual.wet → FOUND → USE THIS                │
│                                                                              │
│  Result: "The slick surface defeats your grip. You're falling."            │
│                                                                              │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  EXAMPLE 3: Normal area, stable surface, climbing                          │
│  Context: { Corruption: Normal, Surface: Stable }                          │
│  Skill: climbing, Category: Competent                                       │
│                                                                              │
│  Lookup order:                                                              │
│  1. climbing.competent.contextual.normal → NOT FOUND                        │
│  2. climbing.competent.contextual.stable → FOUND → USE THIS                │
│                                                                              │
│  Result: "The solid surface makes your climb almost effortless."           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 21. Deliverable Checklist

### 21.1 Domain Layer

- [ ] `SkillStressResult` value object created
- [ ] `StressSource` enum created
- [ ] `SpecializationSkillBonus` value object created
- [ ] `SkillDescriptor` value object created
- [ ] `SkillCheckResult` extended with new properties

### 21.2 Application Layer

- [ ] `ITraumaIntegrationService` interface created
- [ ] `TraumaIntegrationService` implementation created
- [ ] `ISpecializationBonusProvider` interface created
- [ ] `SpecializationBonusProvider` implementation created
- [ ] `IVoiceGuidanceService` interface created
- [ ] `VoiceGuidanceService` implementation created
- [ ] `SkillCheckService` integrated with all three services

### 21.3 Infrastructure Layer

- [ ] `skill-descriptors.json` configuration created
- [ ] `skill-descriptors.schema.json` schema created
- [ ] `specialization-bonuses.json` configuration created
- [ ] `specialization-bonuses.schema.json` schema created

### 21.4 Testing

- [ ] `TraumaIntegrationServiceTests` created (~5 tests)
- [ ] `SpecializationBonusProviderTests` created (~5 tests)
- [ ] `VoiceGuidanceServiceTests` created (~5 tests)
- [ ] All tests pass

### 21.5 Documentation

- [ ] Code documentation with XML comments
- [ ] Design specification complete

---

## 22. Acceptance Criteria

### 22.1 Trauma Integration

- [ ] Normal area skill checks incur 0 stress
- [ ] Glitched area skill checks incur 2 stress
- [ ] Blighted area skill checks incur 5 stress
- [ ] Resonance area skill checks incur 10 stress
- [ ] Fumbles add bonus stress (1-8 based on corruption tier)
- [ ] Breaking point flag set when total stress >= 8
- [ ] Extended checks accumulate stress per step

### 22.2 Specialization Bonuses

- [ ] Unconditional bonuses always apply
- [ ] Conditional bonuses evaluate context correctly
- [ ] Biome conditions check environment modifiers
- [ ] Surface conditions check surface type
- [ ] Equipment conditions check equipment modifiers
- [ ] Special abilities are flagged correctly
- [ ] Unknown specializations return no bonus

### 22.3 Voice Guidance

- [ ] Skill-specific descriptors returned for configured skills
- [ ] Context-specific variants selected when available
- [ ] Corruption context takes priority
- [ ] Generic fallback used for unconfigured skills
- [ ] Random selection from pools provides variety
- [ ] All 6 descriptor categories supported

### 22.4 Integration

- [ ] SkillCheckResult includes StressResult
- [ ] SkillCheckResult includes Descriptor
- [ ] SkillCheckResult includes SpecializationBonus
- [ ] All three services integrated in SkillCheckService
- [ ] Dependency injection configured correctly

### 22.5 General

- [ ] ~3 unit tests pass (per scope breakdown)
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## 23. Future Considerations

### 23.1 Deferred to v0.19.x (Trauma System)

- **Actual Stress Meter**: Persisting and displaying accumulated stress
- **Breaking Point Checks**: WILL skill checks when stress exceeds threshold
- **Trauma Acquisition**: Permanent mental conditions from breaking point failures
- **Stress Recovery**: Rest, stabilizing agents, abilities that reduce stress
- **UI Distortion**: Visual effects at high stress levels

### 23.2 Deferred to v0.15.2-v0.15.5 (Skill Expansions)

- **Skill-Specific Descriptors**: Complete pools for all skills
- **Skill-Specific Specialization Abilities**: Unique mechanics per archetype
- **Context Expansion**: More contextual variants (weather, time of day, etc.)

### 23.3 Deferred to Future Versions

- **Localization**: Multi-language support for descriptors
- **Dynamic Descriptors**: Procedurally generated text
- **Descriptor Learning**: AI-enhanced descriptor selection based on player preferences
- **Specialization Progression**: Unlockable higher-tier bonuses

---

## 24. Document Metadata

| Property | Value |
|----------|-------|
| Version | 0.15.1e |
| Theme | Integration Points |
| Author | Claude |
| Created | 2026-01-17 |
| Status | Draft |
| Prerequisites | v0.15.0 Complete, v0.15.1a-d Complete |
| Total Deliverables | 3 value objects, 1 enum, 3 interfaces, 3 services, 2 configs, ~3 tests |
| Document Length | ~2,500 lines |

---

*This design specification provides the detailed blueprint for implementing v0.15.1e, connecting the skill system infrastructure to the trauma economy, specialization system, and voice guidance.*
