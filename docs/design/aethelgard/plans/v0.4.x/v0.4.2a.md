# Implementation Plan: v0.4.2a - The Repute (Faction System Core)

**Status:** Ready for Implementation
**Theme:** "The Repute"
**Scope:** Faction data models, FactionService, reputation management, disposition events
**Depends On:** v0.4.1 (Specializations complete), Core Entity patterns

---

## Executive Summary

v0.4.2a establishes the **Faction System** foundation — the data structures, service layer, and event system for tracking player reputation with the factions of Aethelgard. This release enables NPCs and game systems to respond dynamically to the player's social standing.

**Key Features:**
- **Faction Definitions:** 4 canonical factions (Iron-Banes, Dvergr, The Bound, The Faceless)
- **Reputation Tracking:** -100 to +100 signed integer per faction per character
- **Disposition Tiers:** 5 tiers (Hated → Exalted) with threshold-based calculation
- **Event System:** `ReputationChangedEvent` and `DispositionChangedEvent` for reactive systems
- **Persistence:** Join table for Character ↔ Faction relationships with EF Core

**Layers Touched:** Core (Enums, Entities, Models, Events, Interfaces), Engine (Services), Persistence (Repositories, Migrations), Terminal (DI), Tests
**Patterns Used:** Result records, Event bus publishing, Repository pattern, Join entities
**Target Test Count:** 42 unit tests

---

## Table of Contents

1. [Decision Trees](#1-decision-trees)
2. [Deliverable Checklist](#2-deliverable-checklist)
3. [Enum Definitions](#3-enum-definitions)
4. [Entity Definitions](#4-entity-definitions)
5. [Result & Event Definitions](#5-result--event-definitions)
6. [Interface Definitions](#6-interface-definitions)
7. [Service Implementation](#7-service-implementation)
8. [Repository Implementation](#8-repository-implementation)
9. [Character Extensions](#9-character-extensions)
10. [Database Migration](#10-database-migration)
11. [DI Registration](#11-di-registration)
12. [Logging Matrix](#12-logging-matrix)
13. [Test Coverage Plan](#13-test-coverage-plan)
14. [Code Examples](#14-code-examples)
15. [Changelog Template](#15-changelog-template)
16. [Critical Files](#16-critical-files)
17. [Implementation Order](#17-implementation-order)
18. [Design Decisions](#18-design-decisions)

---

## 1. Decision Trees

### 1.1 ModifyReputation Flow

```
ModifyReputation(character, faction, amount, source)
                │
                ▼
    ┌───────────────────────────────┐
    │ Log entry at Trace level      │
    │ "[Faction] ModifyReputation:  │
    │  {CharName}, {Faction}, ±{N}" │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Get current reputation value  │
    │ from CharacterFactionStanding │
    │ (default 0 if not exists)     │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ amount == 0?                  │──Yes──► Return NoChange result
    └───────────────────────────────┘
                │ No
                ▼
    ┌───────────────────────────────┐
    │ Calculate raw new value:      │
    │ rawValue = current + amount   │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Clamp to [-100, +100]:        │
    │ newValue = Math.Clamp(raw,    │
    │            -100, 100)         │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ rawValue != newValue?         │──Yes──► Log clamp at Debug
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Get oldDisposition from       │
    │ current value via             │
    │ GetDisposition()              │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Get newDisposition from       │
    │ newValue via GetDisposition() │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Update or create standing:    │
    │ - If exists: update value     │
    │ - If new: create with value   │
    │ Set LastModifiedAt = UtcNow   │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Persist via repository        │
    │ SaveChangesAsync()            │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Log change at Info level      │
    │ "{CharName} rep with {Faction}│
    │  : {OldVal} → {NewVal}"       │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Publish ReputationChangedEvent│
    │ via IEventBus                 │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ oldDisposition != new?        │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌─────────────────┐
│ Log disposition │  │ (Skip event)    │
│ change at Info  │  │                 │
│                 │  │                 │
│ Publish         │  │                 │
│ Disposition     │  │                 │
│ ChangedEvent    │  │                 │
└─────────────────┘  └─────────────────┘
        │                │
        └───────┬────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Return ReputationChangeResult │
    │ with all metadata             │
    └───────────────────────────────┘
```

### 1.2 GetDisposition Flow

```
GetDisposition(reputationValue)
                │
                ▼
    ┌───────────────────────────────┐
    │ value <= -50?                 │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Return Hated    │  │ value <= -10?                 │
└─────────────────┘  └───────────────────────────────┘
                                │
                        ┌───────┴───────┐
                       Yes              No
                        │                │
                        ▼                ▼
                ┌─────────────────┐  ┌───────────────────────────────┐
                │ Return Hostile  │  │ value <= 9?                   │
                └─────────────────┘  └───────────────────────────────┘
                                                │
                                        ┌───────┴───────┐
                                       Yes              No
                                        │                │
                                        ▼                ▼
                                ┌─────────────────┐  ┌───────────────────────────────┐
                                │ Return Neutral  │  │ value <= 49?                  │
                                └─────────────────┘  └───────────────────────────────┘
                                                                │
                                                        ┌───────┴───────┐
                                                       Yes              No
                                                        │                │
                                                        ▼                ▼
                                                ┌─────────────────┐  ┌─────────────────┐
                                                │ Return Friendly │  │ Return Exalted  │
                                                └─────────────────┘  └─────────────────┘
```

### 1.3 GetReputation Flow

```
GetReputation(character, faction)
                │
                ▼
    ┌───────────────────────────────┐
    │ Query CharacterFactionStanding│
    │ by CharacterId + FactionType  │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Standing exists?              │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌─────────────────┐
│ Return standing │  │ Return 0        │
│ .Reputation     │  │ (default)       │
└─────────────────┘  └─────────────────┘
```

### 1.4 GetFactionDisposition Flow (Combined Helper)

```
GetFactionDisposition(character, faction)
                │
                ▼
    ┌───────────────────────────────┐
    │ reputation = GetReputation(   │
    │   character, faction)         │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ disposition = GetDisposition( │
    │   reputation)                 │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Return FactionStandingInfo(   │
    │   faction, reputation,        │
    │   disposition)                │
    └───────────────────────────────┘
```

---

## 2. Deliverable Checklist

### New Files to Create

| Layer | File Path | Purpose |
|-------|-----------|---------|
| Core | `RuneAndRust.Core/Enums/FactionType.cs` | Faction identifier enum |
| Core | `RuneAndRust.Core/Enums/Disposition.cs` | Disposition tier enum |
| Core | `RuneAndRust.Core/Entities/Faction.cs` | Faction metadata entity |
| Core | `RuneAndRust.Core/Entities/CharacterFactionStanding.cs` | Join entity for reputation |
| Core | `RuneAndRust.Core/Models/ReputationChangeResult.cs` | Result record for ModifyReputation |
| Core | `RuneAndRust.Core/Models/FactionStandingInfo.cs` | DTO for faction status |
| Core | `RuneAndRust.Core/Events/ReputationChangedEvent.cs` | Event for any rep change |
| Core | `RuneAndRust.Core/Events/DispositionChangedEvent.cs` | Event for tier change |
| Core | `RuneAndRust.Core/Interfaces/IFactionService.cs` | Service interface |
| Core | `RuneAndRust.Core/Interfaces/IFactionRepository.cs` | Repository interface |
| Engine | `RuneAndRust.Engine/Services/FactionService.cs` | Service implementation |
| Persistence | `RuneAndRust.Persistence/Repositories/FactionRepository.cs` | Repository implementation |
| Persistence | `Migrations/V0.4.2a__Faction_System.sql` | PostgreSQL migration |
| Tests | `RuneAndRust.Tests/Engine/FactionServiceTests.cs` | 42 unit tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/Character.cs` | Add `FactionStandings` navigation property |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Add `DbSet<Faction>`, `DbSet<CharacterFactionStanding>`, configure relationships |
| `RuneAndRust.Terminal/Program.cs` | Register `IFactionService`, `IFactionRepository` |

---

## 3. Enum Definitions

### 3.1 FactionType

**File:** `RuneAndRust.Core/Enums/FactionType.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Canonical faction identifiers in Aethelgard.
/// Each faction has distinct culture, territory, and player interaction patterns.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public enum FactionType
{
    /// <summary>
    /// Scavenger clans of the upper ruins.
    /// Pragmatic survivors who trade in salvage and information.
    /// Default disposition: Neutral.
    /// </summary>
    IronBanes = 0,

    /// <summary>
    /// Deep-dwelling master smiths and artificers.
    /// Secretive craftsmen who guard Pre-Glitch forging secrets.
    /// Default disposition: Neutral.
    /// </summary>
    Dvergr = 1,

    /// <summary>
    /// Cultists devoted to the Glitch.
    /// Believe the Glitch is divine transformation, not corruption.
    /// Default disposition: Hostile (starts at -25).
    /// </summary>
    TheBound = 2,

    /// <summary>
    /// Mysterious masked traders with unknown allegiances.
    /// Deal in rare artifacts and forbidden knowledge.
    /// Default disposition: Neutral.
    /// </summary>
    TheFaceless = 3
}
```

### 3.2 Disposition

**File:** `RuneAndRust.Core/Enums/Disposition.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Faction disposition tiers based on reputation value.
/// Determines NPC behavior, dialogue availability, and trade access.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public enum Disposition
{
    /// <summary>
    /// Reputation -100 to -50: Attack on sight, no trade, no dialogue.
    /// NPCs of this faction will initiate combat when encountered.
    /// </summary>
    Hated = 0,

    /// <summary>
    /// Reputation -49 to -10: Refuse dialogue, threatening barks.
    /// NPCs will not attack unprovoked but refuse all interaction.
    /// </summary>
    Hostile = 1,

    /// <summary>
    /// Reputation -9 to +9: Indifferent, basic services only.
    /// Standard interactions available, no bonuses or penalties.
    /// </summary>
    Neutral = 2,

    /// <summary>
    /// Reputation +10 to +49: Better prices, extra dialogue options.
    /// Faction members offer discounts and share additional information.
    /// </summary>
    Friendly = 3,

    /// <summary>
    /// Reputation +50 to +100: Unique items, special quests, faction benefits.
    /// Full access to faction resources and exclusive content.
    /// </summary>
    Exalted = 4
}
```

---

## 4. Entity Definitions

### 4.1 Faction Entity

**File:** `RuneAndRust.Core/Entities/Faction.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

/// <summary>
/// Represents a faction in the world of Aethelgard.
/// Contains metadata for display and default disposition rules.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public class Faction
{
    /// <summary>
    /// The faction type identifier (used as primary key).
    /// </summary>
    public FactionType Type { get; set; }

    /// <summary>
    /// The display name of the faction.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Flavor text describing the faction's culture and role.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// The default starting reputation for new characters.
    /// Most factions start at 0 (Neutral), but The Bound starts at -25 (Hostile).
    /// </summary>
    public int DefaultReputation { get; set; } = 0;

    /// <summary>
    /// When the faction record was seeded/created.
    /// </summary>
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// Navigation property: All character standings with this faction.
    /// </summary>
    public ICollection<CharacterFactionStanding> CharacterStandings { get; set; }
        = new List<CharacterFactionStanding>();
}
```

### 4.2 CharacterFactionStanding Entity

**File:** `RuneAndRust.Core/Entities/CharacterFactionStanding.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

/// <summary>
/// Join entity tracking a character's reputation with a specific faction.
/// Composite key: (CharacterId, FactionType).
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public class CharacterFactionStanding
{
    #region Composite Key

    /// <summary>
    /// Foreign key to the character.
    /// </summary>
    public Guid CharacterId { get; set; }

    /// <summary>
    /// The faction this standing tracks.
    /// </summary>
    public FactionType FactionType { get; set; }

    #endregion

    #region Properties

    /// <summary>
    /// Reputation value from -100 (Hated) to +100 (Exalted).
    /// </summary>
    public int Reputation { get; set; } = 0;

    /// <summary>
    /// When this standing was first established.
    /// </summary>
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// When this standing was last modified.
    /// </summary>
    public DateTime LastModifiedAt { get; set; } = DateTime.UtcNow;

    #endregion

    #region Navigation Properties

    /// <summary>
    /// Navigation property to the character.
    /// </summary>
    public Character Character { get; set; } = null!;

    /// <summary>
    /// Navigation property to the faction definition.
    /// </summary>
    public Faction Faction { get; set; } = null!;

    #endregion
}
```

### 4.3 Character Entity Modification

**File:** `RuneAndRust.Core/Entities/Character.cs`

Add to the existing Character class after the Specialization System region:

```csharp
#region Faction System (v0.4.2a)

/// <summary>
/// Navigation property: All faction standings for this character.
/// Tracks reputation with each faction the character has interacted with.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public ICollection<CharacterFactionStanding> FactionStandings { get; set; }
    = new List<CharacterFactionStanding>();

#endregion
```

---

## 5. Result & Event Definitions

### 5.1 ReputationChangeResult

**File:** `RuneAndRust.Core/Models/ReputationChangeResult.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of a reputation modification operation.
/// Contains before/after state for both reputation value and disposition tier.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public record ReputationChangeResult(
    bool Success,
    string Message,
    FactionType Faction,
    int OldValue,
    int NewValue,
    int Delta,
    Disposition OldDisposition,
    Disposition NewDisposition,
    bool DispositionChanged,
    string? Source = null)
{
    /// <summary>
    /// Creates a successful reputation change result.
    /// </summary>
    public static ReputationChangeResult Ok(
        FactionType faction,
        int oldVal,
        int newVal,
        Disposition oldDisp,
        Disposition newDisp,
        string? source = null)
    {
        var delta = newVal - oldVal;
        var direction = delta > 0 ? "increased" : "decreased";
        var message = $"Reputation with {faction} {direction} to {newVal}.";

        return new ReputationChangeResult(
            Success: true,
            Message: message,
            Faction: faction,
            OldValue: oldVal,
            NewValue: newVal,
            Delta: delta,
            OldDisposition: oldDisp,
            NewDisposition: newDisp,
            DispositionChanged: oldDisp != newDisp,
            Source: source);
    }

    /// <summary>
    /// Creates a no-change result (amount was 0 or already at boundary).
    /// </summary>
    public static ReputationChangeResult NoChange(
        FactionType faction,
        int value,
        Disposition disposition)
    {
        return new ReputationChangeResult(
            Success: true,
            Message: $"Reputation with {faction} unchanged at {value}.",
            Faction: faction,
            OldValue: value,
            NewValue: value,
            Delta: 0,
            OldDisposition: disposition,
            NewDisposition: disposition,
            DispositionChanged: false,
            Source: null);
    }

    /// <summary>
    /// Creates a failure result.
    /// </summary>
    public static ReputationChangeResult Failure(string reason, FactionType faction)
    {
        return new ReputationChangeResult(
            Success: false,
            Message: reason,
            Faction: faction,
            OldValue: 0,
            NewValue: 0,
            Delta: 0,
            OldDisposition: Disposition.Neutral,
            NewDisposition: Disposition.Neutral,
            DispositionChanged: false,
            Source: null);
    }

    /// <summary>
    /// Whether the disposition improved (moved toward Exalted).
    /// </summary>
    public bool DispositionImproved => DispositionChanged && NewDisposition > OldDisposition;

    /// <summary>
    /// Whether the disposition degraded (moved toward Hated).
    /// </summary>
    public bool DispositionDegraded => DispositionChanged && NewDisposition < OldDisposition;
}
```

### 5.2 FactionStandingInfo

**File:** `RuneAndRust.Core/Models/FactionStandingInfo.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Models;

/// <summary>
/// DTO containing a character's current standing with a faction.
/// Used for UI display and condition evaluation.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public record FactionStandingInfo(
    FactionType Faction,
    string FactionName,
    int Reputation,
    Disposition Disposition)
{
    /// <summary>
    /// Whether the faction is hostile (Hated or Hostile disposition).
    /// </summary>
    public bool IsHostile => Disposition <= Disposition.Hostile;

    /// <summary>
    /// Whether the faction is friendly (Friendly or Exalted disposition).
    /// </summary>
    public bool IsFriendly => Disposition >= Disposition.Friendly;

    /// <summary>
    /// Progress percentage toward the next positive tier (0-100).
    /// Returns 100 if already Exalted.
    /// </summary>
    public int ProgressToNextTier => Disposition switch
    {
        Disposition.Hated => Math.Max(0, (Reputation + 100) * 100 / 50),      // -100 to -50
        Disposition.Hostile => Math.Max(0, (Reputation + 49) * 100 / 40),     // -49 to -10
        Disposition.Neutral => Math.Max(0, (Reputation + 9) * 100 / 19),      // -9 to 9
        Disposition.Friendly => Math.Max(0, (Reputation - 10) * 100 / 40),    // 10 to 49
        Disposition.Exalted => 100,
        _ => 0
    };
}
```

### 5.3 ReputationChangedEvent

**File:** `RuneAndRust.Core/Events/ReputationChangedEvent.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Events;

/// <summary>
/// Published whenever a character's reputation with a faction changes.
/// Consumed by UI listeners for notifications and combat AI for aggression updates.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
/// <param name="CharacterId">The character whose reputation changed.</param>
/// <param name="CharacterName">The character's display name.</param>
/// <param name="Faction">The faction affected.</param>
/// <param name="OldValue">Previous reputation value.</param>
/// <param name="NewValue">New reputation value.</param>
/// <param name="Delta">The amount changed (positive or negative).</param>
/// <param name="Source">Optional source of the change (e.g., "Quest: Iron Bane Initiation").</param>
public record ReputationChangedEvent(
    Guid CharacterId,
    string CharacterName,
    FactionType Faction,
    int OldValue,
    int NewValue,
    int Delta,
    string? Source = null);
```

### 5.4 DispositionChangedEvent

**File:** `RuneAndRust.Core/Events/DispositionChangedEvent.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Events;

/// <summary>
/// Published when a character's disposition tier with a faction changes.
/// Only fires on threshold crossings (e.g., Neutral → Friendly).
/// Consumed by dialogue system for option unlocking and combat AI for aggression changes.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
/// <param name="CharacterId">The character whose disposition changed.</param>
/// <param name="CharacterName">The character's display name.</param>
/// <param name="Faction">The faction affected.</param>
/// <param name="OldDisposition">Previous disposition tier.</param>
/// <param name="NewDisposition">New disposition tier.</param>
/// <param name="Direction">Whether the change was an improvement or degradation.</param>
public record DispositionChangedEvent(
    Guid CharacterId,
    string CharacterName,
    FactionType Faction,
    Disposition OldDisposition,
    Disposition NewDisposition,
    DispositionChangeDirection Direction)
{
    /// <summary>
    /// Whether the disposition improved (moved toward Exalted).
    /// </summary>
    public bool IsImprovement => Direction == DispositionChangeDirection.Improved;

    /// <summary>
    /// Whether the disposition degraded (moved toward Hated).
    /// </summary>
    public bool IsDegradation => Direction == DispositionChangeDirection.Degraded;
}

/// <summary>
/// Direction of a disposition tier change.
/// </summary>
public enum DispositionChangeDirection
{
    /// <summary>Disposition moved toward Exalted (reputation increased).</summary>
    Improved = 1,

    /// <summary>Disposition moved toward Hated (reputation decreased).</summary>
    Degraded = -1
}
```

---

## 6. Interface Definitions

### 6.1 IFactionService

**File:** `RuneAndRust.Core/Interfaces/IFactionService.cs`

```csharp
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for managing faction reputation and disposition.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public interface IFactionService
{
    // ═══════════════════════════════════════════════════════════════════════
    // Reputation Modification
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Modifies a character's reputation with a faction.
    /// Clamps result to [-100, +100] and fires events as appropriate.
    /// </summary>
    /// <param name="character">The character to modify.</param>
    /// <param name="faction">The faction to modify reputation with.</param>
    /// <param name="amount">The amount to add (positive) or subtract (negative).</param>
    /// <param name="source">Optional source description for logging/events.</param>
    /// <returns>Result containing before/after state.</returns>
    Task<ReputationChangeResult> ModifyReputationAsync(
        Character character,
        FactionType faction,
        int amount,
        string? source = null);

    /// <summary>
    /// Sets a character's reputation to a specific value.
    /// Used for initialization or special game events.
    /// </summary>
    /// <param name="character">The character to modify.</param>
    /// <param name="faction">The faction to set reputation with.</param>
    /// <param name="value">The exact value to set (clamped to [-100, +100]).</param>
    /// <param name="source">Optional source description.</param>
    /// <returns>Result containing before/after state.</returns>
    Task<ReputationChangeResult> SetReputationAsync(
        Character character,
        FactionType faction,
        int value,
        string? source = null);

    // ═══════════════════════════════════════════════════════════════════════
    // Reputation Queries
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Gets a character's current reputation value with a faction.
    /// Returns 0 if no standing exists (or faction's default reputation).
    /// </summary>
    /// <param name="character">The character to query.</param>
    /// <param name="faction">The faction to query.</param>
    /// <returns>The reputation value (-100 to +100).</returns>
    Task<int> GetReputationAsync(Character character, FactionType faction);

    /// <summary>
    /// Gets the disposition tier for a given reputation value.
    /// Pure function, does not require database access.
    /// </summary>
    /// <param name="reputation">The reputation value.</param>
    /// <returns>The corresponding disposition tier.</returns>
    Disposition GetDisposition(int reputation);

    /// <summary>
    /// Gets complete faction standing info for a character.
    /// Combines reputation and disposition with faction metadata.
    /// </summary>
    /// <param name="character">The character to query.</param>
    /// <param name="faction">The faction to query.</param>
    /// <returns>Complete standing info.</returns>
    Task<FactionStandingInfo> GetFactionStandingAsync(Character character, FactionType faction);

    /// <summary>
    /// Gets all faction standings for a character.
    /// Returns standings for all factions, including defaults for untracked ones.
    /// </summary>
    /// <param name="character">The character to query.</param>
    /// <returns>Dictionary of faction type to standing info.</returns>
    Task<IReadOnlyDictionary<FactionType, FactionStandingInfo>> GetAllStandingsAsync(Character character);

    // ═══════════════════════════════════════════════════════════════════════
    // Convenience Checks
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Checks if a character is hostile with a faction (Hated or Hostile disposition).
    /// </summary>
    Task<bool> IsHostileAsync(Character character, FactionType faction);

    /// <summary>
    /// Checks if a character is friendly with a faction (Friendly or Exalted disposition).
    /// </summary>
    Task<bool> IsFriendlyAsync(Character character, FactionType faction);

    /// <summary>
    /// Checks if a character meets a minimum disposition requirement.
    /// </summary>
    /// <param name="character">The character to check.</param>
    /// <param name="faction">The faction to check.</param>
    /// <param name="minDisposition">The minimum required disposition.</param>
    /// <returns>True if character's disposition >= minDisposition.</returns>
    Task<bool> MeetsDispositionRequirementAsync(
        Character character,
        FactionType faction,
        Disposition minDisposition);

    // ═══════════════════════════════════════════════════════════════════════
    // Faction Metadata
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Gets metadata for a faction (name, description, default reputation).
    /// </summary>
    Task<Faction?> GetFactionAsync(FactionType faction);

    /// <summary>
    /// Gets all faction definitions.
    /// </summary>
    Task<IEnumerable<Faction>> GetAllFactionsAsync();
}
```

### 6.2 IFactionRepository

**File:** `RuneAndRust.Core/Interfaces/IFactionRepository.cs`

```csharp
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Repository for faction and character standing persistence.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public interface IFactionRepository
{
    // ═══════════════════════════════════════════════════════════════════════
    // Faction Queries
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Gets a faction definition by type.
    /// </summary>
    Task<Faction?> GetFactionAsync(FactionType type);

    /// <summary>
    /// Gets all faction definitions.
    /// </summary>
    Task<IEnumerable<Faction>> GetAllFactionsAsync();

    // ═══════════════════════════════════════════════════════════════════════
    // Standing Queries
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Gets a character's standing with a specific faction.
    /// Returns null if no standing exists.
    /// </summary>
    Task<CharacterFactionStanding?> GetStandingAsync(Guid characterId, FactionType faction);

    /// <summary>
    /// Gets all standings for a character.
    /// </summary>
    Task<IEnumerable<CharacterFactionStanding>> GetStandingsForCharacterAsync(Guid characterId);

    // ═══════════════════════════════════════════════════════════════════════
    // Standing Mutations
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Adds a new character faction standing.
    /// </summary>
    Task AddStandingAsync(CharacterFactionStanding standing);

    /// <summary>
    /// Updates an existing character faction standing.
    /// </summary>
    Task UpdateStandingAsync(CharacterFactionStanding standing);

    /// <summary>
    /// Persists all pending changes.
    /// </summary>
    Task SaveChangesAsync();
}
```

---

## 7. Service Implementation

**File:** `RuneAndRust.Engine/Services/FactionService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Service implementation for managing faction reputation and disposition.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public class FactionService : IFactionService
{
    private readonly IFactionRepository _repository;
    private readonly IEventBus _eventBus;
    private readonly ILogger<FactionService> _logger;

    /// <summary>
    /// Minimum reputation value.
    /// </summary>
    public const int MinReputation = -100;

    /// <summary>
    /// Maximum reputation value.
    /// </summary>
    public const int MaxReputation = 100;

    /// <summary>
    /// Initializes a new instance of the <see cref="FactionService"/> class.
    /// </summary>
    public FactionService(
        IFactionRepository repository,
        IEventBus eventBus,
        ILogger<FactionService> logger)
    {
        _repository = repository;
        _eventBus = eventBus;
        _logger = logger;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Reputation Modification
    // ═══════════════════════════════════════════════════════════════════════

    /// <inheritdoc/>
    public async Task<ReputationChangeResult> ModifyReputationAsync(
        Character character,
        FactionType faction,
        int amount,
        string? source = null)
    {
        _logger.LogTrace(
            "[Faction] ModifyReputationAsync: {CharName}, {Faction}, Amount={Amount}, Source={Source}",
            character.Name, faction, amount, source ?? "unspecified");

        // Get current standing
        var standing = await _repository.GetStandingAsync(character.Id, faction);
        var currentValue = standing?.Reputation ?? await GetDefaultReputationAsync(faction);
        var oldDisposition = GetDisposition(currentValue);

        // Check for no-op
        if (amount == 0)
        {
            _logger.LogTrace("[Faction] Amount is 0, no change");
            return ReputationChangeResult.NoChange(faction, currentValue, oldDisposition);
        }

        // Calculate new value with clamping
        var rawValue = currentValue + amount;
        var newValue = Math.Clamp(rawValue, MinReputation, MaxReputation);

        if (rawValue != newValue)
        {
            _logger.LogDebug(
                "[Faction] Reputation clamped: {RawValue} → {ClampedValue}",
                rawValue, newValue);
        }

        // Check if actually changed after clamping
        if (newValue == currentValue)
        {
            _logger.LogTrace("[Faction] No effective change after clamping");
            return ReputationChangeResult.NoChange(faction, currentValue, oldDisposition);
        }

        var newDisposition = GetDisposition(newValue);

        // Update or create standing
        if (standing != null)
        {
            standing.Reputation = newValue;
            standing.LastModifiedAt = DateTime.UtcNow;
            await _repository.UpdateStandingAsync(standing);
        }
        else
        {
            standing = new CharacterFactionStanding
            {
                CharacterId = character.Id,
                FactionType = faction,
                Reputation = newValue,
                CreatedAt = DateTime.UtcNow,
                LastModifiedAt = DateTime.UtcNow
            };
            await _repository.AddStandingAsync(standing);
        }

        await _repository.SaveChangesAsync();

        // Log the change
        _logger.LogInformation(
            "[Faction] {CharName} rep with {Faction}: {OldVal} → {NewVal} ({Delta:+#;-#;0})",
            character.Name, faction, currentValue, newValue, amount);

        // Publish reputation changed event
        var repEvent = new ReputationChangedEvent(
            character.Id,
            character.Name,
            faction,
            currentValue,
            newValue,
            newValue - currentValue,
            source);
        await _eventBus.PublishAsync(repEvent);

        // Check for disposition change
        if (oldDisposition != newDisposition)
        {
            _logger.LogInformation(
                "[Faction] {CharName} now {NewDisp} with {Faction} (was {OldDisp})",
                character.Name, newDisposition, faction, oldDisposition);

            var direction = newDisposition > oldDisposition
                ? DispositionChangeDirection.Improved
                : DispositionChangeDirection.Degraded;

            var dispEvent = new DispositionChangedEvent(
                character.Id,
                character.Name,
                faction,
                oldDisposition,
                newDisposition,
                direction);
            await _eventBus.PublishAsync(dispEvent);

            _logger.LogDebug(
                "[Faction] DispositionChangedEvent published: {CharName}, {Faction}, {Direction}",
                character.Name, faction, direction);
        }

        return ReputationChangeResult.Ok(
            faction, currentValue, newValue, oldDisposition, newDisposition, source);
    }

    /// <inheritdoc/>
    public async Task<ReputationChangeResult> SetReputationAsync(
        Character character,
        FactionType faction,
        int value,
        string? source = null)
    {
        var currentRep = await GetReputationAsync(character, faction);
        var delta = value - currentRep;
        return await ModifyReputationAsync(character, faction, delta, source);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Reputation Queries
    // ═══════════════════════════════════════════════════════════════════════

    /// <inheritdoc/>
    public async Task<int> GetReputationAsync(Character character, FactionType faction)
    {
        var standing = await _repository.GetStandingAsync(character.Id, faction);
        var value = standing?.Reputation ?? await GetDefaultReputationAsync(faction);

        _logger.LogTrace(
            "[Faction] GetReputation({CharName}, {Faction}) = {Value}",
            character.Name, faction, value);

        return value;
    }

    /// <inheritdoc/>
    public Disposition GetDisposition(int reputation)
    {
        var disposition = reputation switch
        {
            <= -50 => Disposition.Hated,
            <= -10 => Disposition.Hostile,
            <= 9 => Disposition.Neutral,
            <= 49 => Disposition.Friendly,
            _ => Disposition.Exalted
        };

        _logger.LogTrace("[Faction] GetDisposition({Reputation}) = {Disposition}",
            reputation, disposition);

        return disposition;
    }

    /// <inheritdoc/>
    public async Task<FactionStandingInfo> GetFactionStandingAsync(
        Character character,
        FactionType faction)
    {
        var reputation = await GetReputationAsync(character, faction);
        var disposition = GetDisposition(reputation);
        var factionDef = await _repository.GetFactionAsync(faction);
        var factionName = factionDef?.Name ?? faction.ToString();

        return new FactionStandingInfo(faction, factionName, reputation, disposition);
    }

    /// <inheritdoc/>
    public async Task<IReadOnlyDictionary<FactionType, FactionStandingInfo>> GetAllStandingsAsync(
        Character character)
    {
        var result = new Dictionary<FactionType, FactionStandingInfo>();

        foreach (FactionType faction in Enum.GetValues<FactionType>())
        {
            result[faction] = await GetFactionStandingAsync(character, faction);
        }

        return result;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Convenience Checks
    // ═══════════════════════════════════════════════════════════════════════

    /// <inheritdoc/>
    public async Task<bool> IsHostileAsync(Character character, FactionType faction)
    {
        var rep = await GetReputationAsync(character, faction);
        return GetDisposition(rep) <= Disposition.Hostile;
    }

    /// <inheritdoc/>
    public async Task<bool> IsFriendlyAsync(Character character, FactionType faction)
    {
        var rep = await GetReputationAsync(character, faction);
        return GetDisposition(rep) >= Disposition.Friendly;
    }

    /// <inheritdoc/>
    public async Task<bool> MeetsDispositionRequirementAsync(
        Character character,
        FactionType faction,
        Disposition minDisposition)
    {
        var rep = await GetReputationAsync(character, faction);
        var currentDisposition = GetDisposition(rep);
        return currentDisposition >= minDisposition;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Faction Metadata
    // ═══════════════════════════════════════════════════════════════════════

    /// <inheritdoc/>
    public async Task<Faction?> GetFactionAsync(FactionType faction)
    {
        return await _repository.GetFactionAsync(faction);
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<Faction>> GetAllFactionsAsync()
    {
        return await _repository.GetAllFactionsAsync();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Private Helpers
    // ═══════════════════════════════════════════════════════════════════════

    private async Task<int> GetDefaultReputationAsync(FactionType faction)
    {
        var factionDef = await _repository.GetFactionAsync(faction);
        return factionDef?.DefaultReputation ?? 0;
    }
}
```

---

## 8. Repository Implementation

**File:** `RuneAndRust.Persistence/Repositories/FactionRepository.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Persistence.Data;

namespace RuneAndRust.Persistence.Repositories;

/// <summary>
/// Repository implementation for Faction and CharacterFactionStanding persistence.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public class FactionRepository : IFactionRepository
{
    private readonly RuneAndRustDbContext _context;
    private readonly ILogger<FactionRepository> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="FactionRepository"/> class.
    /// </summary>
    public FactionRepository(
        RuneAndRustDbContext context,
        ILogger<FactionRepository> logger)
    {
        _context = context;
        _logger = logger;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Faction Queries
    // ═══════════════════════════════════════════════════════════════════════

    /// <inheritdoc/>
    public async Task<Faction?> GetFactionAsync(FactionType type)
    {
        _logger.LogDebug("[FactionRepo] GetFactionAsync: {Type}", type);
        return await _context.Factions.FirstOrDefaultAsync(f => f.Type == type);
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<Faction>> GetAllFactionsAsync()
    {
        _logger.LogDebug("[FactionRepo] GetAllFactionsAsync");
        return await _context.Factions.OrderBy(f => f.Type).ToListAsync();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Standing Queries
    // ═══════════════════════════════════════════════════════════════════════

    /// <inheritdoc/>
    public async Task<CharacterFactionStanding?> GetStandingAsync(
        Guid characterId,
        FactionType faction)
    {
        _logger.LogDebug(
            "[FactionRepo] GetStandingAsync: CharId={CharId}, Faction={Faction}",
            characterId, faction);

        return await _context.CharacterFactionStandings
            .FirstOrDefaultAsync(s =>
                s.CharacterId == characterId &&
                s.FactionType == faction);
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<CharacterFactionStanding>> GetStandingsForCharacterAsync(
        Guid characterId)
    {
        _logger.LogDebug("[FactionRepo] GetStandingsForCharacterAsync: {CharId}", characterId);

        return await _context.CharacterFactionStandings
            .Where(s => s.CharacterId == characterId)
            .Include(s => s.Faction)
            .OrderBy(s => s.FactionType)
            .ToListAsync();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Standing Mutations
    // ═══════════════════════════════════════════════════════════════════════

    /// <inheritdoc/>
    public async Task AddStandingAsync(CharacterFactionStanding standing)
    {
        _logger.LogDebug(
            "[FactionRepo] AddStandingAsync: CharId={CharId}, Faction={Faction}, Rep={Rep}",
            standing.CharacterId, standing.FactionType, standing.Reputation);

        await _context.CharacterFactionStandings.AddAsync(standing);
    }

    /// <inheritdoc/>
    public async Task UpdateStandingAsync(CharacterFactionStanding standing)
    {
        _logger.LogDebug(
            "[FactionRepo] UpdateStandingAsync: CharId={CharId}, Faction={Faction}, Rep={Rep}",
            standing.CharacterId, standing.FactionType, standing.Reputation);

        _context.CharacterFactionStandings.Update(standing);
        await Task.CompletedTask;
    }

    /// <inheritdoc/>
    public async Task SaveChangesAsync()
    {
        var changeCount = await _context.SaveChangesAsync();
        _logger.LogDebug("[FactionRepo] SaveChangesAsync: {Count} changes", changeCount);
    }
}
```

---

## 9. Character Extensions

Add convenience methods to Character or create static extension methods:

**Modification to `RuneAndRust.Core/Entities/Character.cs`:**

```csharp
#region Faction System (v0.4.2a)

/// <summary>
/// Navigation property: All faction standings for this character.
/// Tracks reputation with each faction the character has interacted with.
/// </summary>
/// <remarks>See: v0.4.2a (The Repute) for Faction System implementation.</remarks>
public ICollection<CharacterFactionStanding> FactionStandings { get; set; }
    = new List<CharacterFactionStanding>();

/// <summary>
/// Gets the cached reputation value for a faction from loaded standings.
/// Returns null if the standing is not loaded (use IFactionService for database queries).
/// </summary>
/// <param name="faction">The faction to query.</param>
/// <returns>The reputation value if loaded, otherwise null.</returns>
public int? GetCachedReputation(FactionType faction)
{
    return FactionStandings.FirstOrDefault(s => s.FactionType == faction)?.Reputation;
}

#endregion
```

---

## 10. Database Migration

**File:** `Migrations/V0.4.2a__Faction_System.sql`

```sql
-- ═══════════════════════════════════════════════════════════════════════════
-- v0.4.2a: Faction System Migration
-- Creates Faction and CharacterFactionStanding tables
-- ═══════════════════════════════════════════════════════════════════════════

-- Faction definitions table
CREATE TABLE IF NOT EXISTS factions (
    type INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT NOT NULL DEFAULT '',
    default_reputation INTEGER NOT NULL DEFAULT 0
        CHECK (default_reputation >= -100 AND default_reputation <= 100),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE factions IS 'Faction definitions for the world of Aethelgard (v0.4.2a)';
COMMENT ON COLUMN factions.type IS 'FactionType enum value (0=IronBanes, 1=Dvergr, 2=TheBound, 3=TheFaceless)';
COMMENT ON COLUMN factions.default_reputation IS 'Starting reputation for new characters (The Bound defaults to -25)';

-- Character faction standings (join table)
CREATE TABLE IF NOT EXISTS character_faction_standings (
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    faction_type INTEGER NOT NULL REFERENCES factions(type),
    reputation INTEGER NOT NULL DEFAULT 0
        CHECK (reputation >= -100 AND reputation <= 100),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    last_modified_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    PRIMARY KEY (character_id, faction_type)
);

COMMENT ON TABLE character_faction_standings IS 'Tracks character reputation with each faction (v0.4.2a)';
COMMENT ON COLUMN character_faction_standings.reputation IS 'Reputation value from -100 (Hated) to +100 (Exalted)';

-- Indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_faction_standings_character
    ON character_faction_standings(character_id);

CREATE INDEX IF NOT EXISTS idx_faction_standings_faction
    ON character_faction_standings(faction_type);

-- Seed faction definitions
INSERT INTO factions (type, name, description, default_reputation) VALUES
(0, 'Iron-Banes', 'Scavenger clans of the upper ruins. Pragmatic survivors who trade in salvage and information.', 0),
(1, 'Dvergr', 'Deep-dwelling master smiths and artificers. Secretive craftsmen who guard Pre-Glitch forging secrets.', 0),
(2, 'The Bound', 'Cultists devoted to the Glitch. Believe the Glitch is divine transformation, not corruption.', -25),
(3, 'The Faceless', 'Mysterious masked traders with unknown allegiances. Deal in rare artifacts and forbidden knowledge.', 0)
ON CONFLICT (type) DO NOTHING;
```

**DbContext Configuration:**

Add to `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs`:

```csharp
public DbSet<Faction> Factions { get; set; } = null!;
public DbSet<CharacterFactionStanding> CharacterFactionStandings { get; set; } = null!;

// In OnModelCreating:
modelBuilder.Entity<Faction>(entity =>
{
    entity.HasKey(f => f.Type);
    entity.Property(f => f.Type).HasConversion<int>();
    entity.Property(f => f.Name).IsRequired();
});

modelBuilder.Entity<CharacterFactionStanding>(entity =>
{
    entity.HasKey(s => new { s.CharacterId, s.FactionType });
    entity.Property(s => s.FactionType).HasConversion<int>();

    entity.HasOne(s => s.Character)
        .WithMany(c => c.FactionStandings)
        .HasForeignKey(s => s.CharacterId)
        .OnDelete(DeleteBehavior.Cascade);

    entity.HasOne(s => s.Faction)
        .WithMany(f => f.CharacterStandings)
        .HasForeignKey(s => s.FactionType)
        .OnDelete(DeleteBehavior.Restrict);
});
```

---

## 11. DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

Add after existing service registrations:

```csharp
// ═══════════════════════════════════════════════════════════════════════════
// Faction System (v0.4.2a)
// ═══════════════════════════════════════════════════════════════════════════
services.AddScoped<IFactionRepository, FactionRepository>();
services.AddScoped<IFactionService, FactionService>();
```

---

## 12. Logging Matrix

### FactionService Logging

| Event | Level | Template |
|-------|-------|----------|
| ModifyRep entry | Trace | `[Faction] ModifyReputationAsync: {CharName}, {Faction}, Amount={Amount}, Source={Source}` |
| Amount zero | Trace | `[Faction] Amount is 0, no change` |
| Rep clamped | Debug | `[Faction] Reputation clamped: {RawValue} → {ClampedValue}` |
| No change after clamp | Trace | `[Faction] No effective change after clamping` |
| Rep changed | Info | `[Faction] {CharName} rep with {Faction}: {OldVal} → {NewVal} ({Delta:+#;-#;0})` |
| Disposition changed | Info | `[Faction] {CharName} now {NewDisp} with {Faction} (was {OldDisp})` |
| Event published | Debug | `[Faction] DispositionChangedEvent published: {CharName}, {Faction}, {Direction}` |
| GetReputation | Trace | `[Faction] GetReputation({CharName}, {Faction}) = {Value}` |
| GetDisposition | Trace | `[Faction] GetDisposition({Reputation}) = {Disposition}` |

### FactionRepository Logging

| Event | Level | Template |
|-------|-------|----------|
| GetFaction | Debug | `[FactionRepo] GetFactionAsync: {Type}` |
| GetAllFactions | Debug | `[FactionRepo] GetAllFactionsAsync` |
| GetStanding | Debug | `[FactionRepo] GetStandingAsync: CharId={CharId}, Faction={Faction}` |
| GetStandingsForChar | Debug | `[FactionRepo] GetStandingsForCharacterAsync: {CharId}` |
| AddStanding | Debug | `[FactionRepo] AddStandingAsync: CharId={CharId}, Faction={Faction}, Rep={Rep}` |
| UpdateStanding | Debug | `[FactionRepo] UpdateStandingAsync: CharId={CharId}, Faction={Faction}, Rep={Rep}` |
| SaveChanges | Debug | `[FactionRepo] SaveChangesAsync: {Count} changes` |

---

## 13. Test Coverage Plan

### Test Class Structure

**File:** `RuneAndRust.Tests/Engine/FactionServiceTests.cs`

**Dependencies (Mocks):**
- `Mock<IFactionRepository>`
- `Mock<IEventBus>`
- `Mock<ILogger<FactionService>>`

### Test Inventory (42 tests)

#### ModifyReputationAsync Tests (18 tests)

| Test Name | Description |
|-----------|-------------|
| `ModifyReputationAsync_IncreasesValue_WhenPositiveAmount` | +10 from 0 → 10 |
| `ModifyReputationAsync_DecreasesValue_WhenNegativeAmount` | -10 from 0 → -10 |
| `ModifyReputationAsync_ClampsToMax_WhenExceedsUpperBound` | 50 + 60 → 100 |
| `ModifyReputationAsync_ClampsToMin_WhenExceedsLowerBound` | -50 - 60 → -100 |
| `ModifyReputationAsync_ReturnsNoChange_WhenAmountIsZero` | 0 amount |
| `ModifyReputationAsync_ReturnsNoChange_WhenAlreadyAtBoundary` | 100 + 10 = no change |
| `ModifyReputationAsync_InitializesAtZero_WhenNoStandingExists` | First interaction |
| `ModifyReputationAsync_UsesDefaultReputation_WhenFactionHasDefault` | The Bound starts at -25 |
| `ModifyReputationAsync_UpdatesExistingStanding_WhenExists` | Update path |
| `ModifyReputationAsync_CreatesNewStanding_WhenNotExists` | Create path |
| `ModifyReputationAsync_UpdatesLastModifiedAt` | Timestamp update |
| `ModifyReputationAsync_CallsSaveChangesAsync` | Persistence |
| `ModifyReputationAsync_PublishesReputationChangedEvent` | Event published |
| `ModifyReputationAsync_ReputationEventContainsCorrectDelta` | Event delta accuracy |
| `ModifyReputationAsync_PublishesDispositionChangedEvent_WhenTierChanges` | Disposition event |
| `ModifyReputationAsync_NoDispositionEvent_WhenTierUnchanged` | No event if same tier |
| `ModifyReputationAsync_SetsSourceInEvents` | Source propagation |
| `ModifyReputationAsync_LogsAtCorrectLevels` | Logging verification |

#### GetDisposition Tests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `GetDisposition_ReturnsHated_WhenNegative100` | -100 → Hated |
| `GetDisposition_ReturnsHated_WhenNegative50` | -50 → Hated (boundary) |
| `GetDisposition_ReturnsHostile_WhenNegative49` | -49 → Hostile |
| `GetDisposition_ReturnsHostile_WhenNegative10` | -10 → Hostile (boundary) |
| `GetDisposition_ReturnsNeutral_WhenNegative9` | -9 → Neutral |
| `GetDisposition_ReturnsNeutral_WhenZero` | 0 → Neutral |
| `GetDisposition_ReturnsNeutral_WhenPositive9` | 9 → Neutral (boundary) |
| `GetDisposition_ReturnsFriendly_WhenPositive10` | 10 → Friendly |
| `GetDisposition_ReturnsFriendly_WhenPositive49` | 49 → Friendly (boundary) |
| `GetDisposition_ReturnsExalted_WhenPositive50OrMore` | 50+ → Exalted |

#### GetReputationAsync Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `GetReputationAsync_ReturnsZero_WhenNoStandingExists` | Default behavior |
| `GetReputationAsync_ReturnsStoredValue_WhenStandingExists` | Retrieval |
| `GetReputationAsync_ReturnsFactionDefault_WhenNoStandingAndFactionHasDefault` | TheBound default |
| `GetReputationAsync_QueriesRepository` | Repository called |

#### GetFactionStandingAsync Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `GetFactionStandingAsync_ReturnsCompleteInfo` | All fields populated |
| `GetFactionStandingAsync_IncludesFactionName` | Name from definition |
| `GetFactionStandingAsync_CalculatesDispositionCorrectly` | Disposition derived |

#### GetAllStandingsAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetAllStandingsAsync_ReturnsAllFactions` | All 4 factions |
| `GetAllStandingsAsync_IncludesDefaultsForUntracked` | Defaults included |

#### Convenience Check Tests (5 tests)

| Test Name | Description |
|-----------|-------------|
| `IsHostileAsync_ReturnsTrue_WhenHated` | Hated = hostile |
| `IsHostileAsync_ReturnsTrue_WhenHostile` | Hostile = hostile |
| `IsHostileAsync_ReturnsFalse_WhenNeutralOrBetter` | Neutral = not hostile |
| `IsFriendlyAsync_ReturnsTrue_WhenFriendlyOrExalted` | Friendly+ = friendly |
| `MeetsDispositionRequirementAsync_ChecksCorrectly` | Requirement check |

---

## 14. Code Examples

### 14.1 Test Example

```csharp
public class FactionServiceTests
{
    private readonly Mock<IFactionRepository> _mockRepo;
    private readonly Mock<IEventBus> _mockEventBus;
    private readonly Mock<ILogger<FactionService>> _mockLogger;
    private readonly FactionService _sut;

    public FactionServiceTests()
    {
        _mockRepo = new Mock<IFactionRepository>();
        _mockEventBus = new Mock<IEventBus>();
        _mockLogger = new Mock<ILogger<FactionService>>();
        _sut = new FactionService(
            _mockRepo.Object,
            _mockEventBus.Object,
            _mockLogger.Object);
    }

    [Fact]
    public async Task ModifyReputationAsync_IncreasesValue_WhenPositiveAmount()
    {
        // Arrange
        var character = CreateTestCharacter();
        var faction = FactionType.IronBanes;
        var existingStanding = new CharacterFactionStanding
        {
            CharacterId = character.Id,
            FactionType = faction,
            Reputation = 0
        };

        _mockRepo.Setup(r => r.GetStandingAsync(character.Id, faction))
            .ReturnsAsync(existingStanding);
        _mockRepo.Setup(r => r.GetFactionAsync(faction))
            .ReturnsAsync(new Faction { Type = faction, Name = "Iron-Banes", DefaultReputation = 0 });

        // Act
        var result = await _sut.ModifyReputationAsync(character, faction, 10);

        // Assert
        result.Success.Should().BeTrue();
        result.OldValue.Should().Be(0);
        result.NewValue.Should().Be(10);
        result.Delta.Should().Be(10);
        existingStanding.Reputation.Should().Be(10);
        _mockRepo.Verify(r => r.SaveChangesAsync(), Times.Once);
    }

    [Theory]
    [InlineData(-100, Disposition.Hated)]
    [InlineData(-50, Disposition.Hated)]
    [InlineData(-49, Disposition.Hostile)]
    [InlineData(-10, Disposition.Hostile)]
    [InlineData(-9, Disposition.Neutral)]
    [InlineData(0, Disposition.Neutral)]
    [InlineData(9, Disposition.Neutral)]
    [InlineData(10, Disposition.Friendly)]
    [InlineData(49, Disposition.Friendly)]
    [InlineData(50, Disposition.Exalted)]
    [InlineData(100, Disposition.Exalted)]
    public void GetDisposition_ReturnsCorrectTier(int reputation, Disposition expected)
    {
        // Act
        var result = _sut.GetDisposition(reputation);

        // Assert
        result.Should().Be(expected);
    }

    [Fact]
    public async Task ModifyReputationAsync_PublishesDispositionChangedEvent_WhenTierChanges()
    {
        // Arrange
        var character = CreateTestCharacter();
        var faction = FactionType.Dvergr;
        var existingStanding = new CharacterFactionStanding
        {
            CharacterId = character.Id,
            FactionType = faction,
            Reputation = 9  // Neutral
        };

        _mockRepo.Setup(r => r.GetStandingAsync(character.Id, faction))
            .ReturnsAsync(existingStanding);
        _mockRepo.Setup(r => r.GetFactionAsync(faction))
            .ReturnsAsync(new Faction { Type = faction, Name = "Dvergr", DefaultReputation = 0 });

        DispositionChangedEvent? capturedEvent = null;
        _mockEventBus.Setup(e => e.PublishAsync(It.IsAny<DispositionChangedEvent>()))
            .Callback<DispositionChangedEvent>(evt => capturedEvent = evt)
            .Returns(Task.CompletedTask);

        // Act
        await _sut.ModifyReputationAsync(character, faction, 1);  // 9 → 10 = Neutral → Friendly

        // Assert
        capturedEvent.Should().NotBeNull();
        capturedEvent!.OldDisposition.Should().Be(Disposition.Neutral);
        capturedEvent.NewDisposition.Should().Be(Disposition.Friendly);
        capturedEvent.Direction.Should().Be(DispositionChangeDirection.Improved);
    }

    private static Character CreateTestCharacter() => new()
    {
        Id = Guid.NewGuid(),
        Name = "TestCharacter"
    };
}
```

---

## 15. Changelog Template

```markdown
# Changelog: v0.4.2a - The Repute (Faction System Core)

**Release Date:** [DATE]
**Total Tests:** [N] (42 new tests added)

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.2a](#directory-structure-after-v042a)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

Version 0.4.2a establishes the **Faction System** foundation for Rune & Rust...

[Continue following CHANGELOG_GENERATION_RULES.md format]
```

---

## 16. Critical Files

### Files to Create (Priority Order)

| Priority | File | Purpose |
|----------|------|---------|
| 1 | `RuneAndRust.Core/Enums/FactionType.cs` | Faction identifier enum |
| 2 | `RuneAndRust.Core/Enums/Disposition.cs` | Disposition tier enum |
| 3 | `RuneAndRust.Core/Entities/Faction.cs` | Faction metadata entity |
| 4 | `RuneAndRust.Core/Entities/CharacterFactionStanding.cs` | Join entity |
| 5 | `RuneAndRust.Core/Models/ReputationChangeResult.cs` | Result record |
| 6 | `RuneAndRust.Core/Models/FactionStandingInfo.cs` | DTO |
| 7 | `RuneAndRust.Core/Events/ReputationChangedEvent.cs` | Event record |
| 8 | `RuneAndRust.Core/Events/DispositionChangedEvent.cs` | Event record |
| 9 | `RuneAndRust.Core/Interfaces/IFactionRepository.cs` | Repository interface |
| 10 | `RuneAndRust.Core/Interfaces/IFactionService.cs` | Service interface |
| 11 | `RuneAndRust.Persistence/Repositories/FactionRepository.cs` | Repository impl |
| 12 | `RuneAndRust.Engine/Services/FactionService.cs` | Service impl |
| 13 | `Migrations/V0.4.2a__Faction_System.sql` | Database migration |
| 14 | `RuneAndRust.Tests/Engine/FactionServiceTests.cs` | Unit tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/Character.cs` | Add FactionStandings navigation property |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Add DbSets, configure relationships |
| `RuneAndRust.Terminal/Program.cs` | Register services |

---

## 17. Implementation Order

1. **Create Enums** (FactionType, Disposition)
2. **Create Entities** (Faction, CharacterFactionStanding)
3. **Modify Character** (add FactionStandings navigation)
4. **Create Models** (ReputationChangeResult, FactionStandingInfo)
5. **Create Events** (ReputationChangedEvent, DispositionChangedEvent)
6. **Create Interfaces** (IFactionRepository, IFactionService)
7. **Create Repository** (FactionRepository)
8. **Update DbContext** (DbSets, OnModelCreating)
9. **Create Migration** (SQL script)
10. **Create Service** (FactionService)
11. **Register in DI** (Program.cs)
12. **Write Unit Tests** (42 tests)
13. **Run Build and Tests**
14. **Generate Changelog**

---

## 18. Design Decisions

### Why FactionType Enum Instead of String IDs?

**Problem:** Need to identify factions consistently across code and database.

**Decision:** Use `FactionType` enum as primary identifier.

**Rationale:**
- Compile-time type safety prevents typos
- Efficient integer storage in database
- Switch expressions for disposition logic
- Easy iteration with `Enum.GetValues<FactionType>()`
- Extensible: new factions added to enum

### Why Separate Faction Entity from FactionType Enum?

**Problem:** Enum provides ID but we need metadata (name, description, defaults).

**Decision:** Faction entity keyed by FactionType enum, seeded in migration.

**Rationale:**
- Separation of identity (enum) from data (entity)
- Metadata can be updated without code changes
- Database can hold localized faction names
- Default reputation per faction (The Bound starts hostile)

### Why Two Events (ReputationChanged + DispositionChanged)?

**Problem:** Some systems care about any reputation change; others only about tier changes.

**Decision:** Publish both events, with DispositionChanged only on threshold crossing.

**Rationale:**
- UI notifications want every change ("+5 with Iron-Banes")
- Combat AI only cares about disposition thresholds
- Dialogue system needs disposition for option gating
- Separation of concerns for subscribers

### Why Default Reputation Per Faction?

**Problem:** Not all factions should start at 0 (Neutral).

**Decision:** Faction entity has `DefaultReputation` field used when no standing exists.

**Rationale:**
- The Bound are hostile by default (-25) — they're cultists
- Future factions might have varying defaults
- Allows faction-specific starting relationships
- Game can initialize standings explicitly for special starts

---

## Appendix A: Disposition Threshold Matrix

| Reputation Range | Disposition | NPC Behavior |
|------------------|-------------|--------------|
| -100 to -50 | Hated | Attack on sight |
| -49 to -10 | Hostile | Refuse all interaction |
| -9 to +9 | Neutral | Basic services only |
| +10 to +49 | Friendly | Discounts, extra dialogue |
| +50 to +100 | Exalted | Exclusive content access |

---

## Appendix B: Faction Default Values

| Faction | Default Rep | Default Disposition |
|---------|-------------|---------------------|
| Iron-Banes | 0 | Neutral |
| Dvergr | 0 | Neutral |
| The Bound | -25 | Hostile |
| The Faceless | 0 | Neutral |
