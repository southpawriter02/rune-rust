# v0.1.3: The Codex (Data Capture System)

> **Status:** Complete
> **Milestone:** 2 - The Explorer
> **Theme:** Scavenger's Journal and lore collection system

## Table of Contents
- [Overview](#overview)
- [Phase A: Data Foundation (Schema & Storage)](#phase-a-data-foundation-schema--storage)
  - [1. Implementation Workflow](#1-implementation-workflow)
  - [2. Architecture & Data Flow](#2-architecture--data-flow)
  - [3. Code Implementation](#3-code-implementation)
  - [4. Decision Tree](#4-decision-tree)
  - [5. Deliverable Checklist (Phase A)](#5-deliverable-checklist-phase-a)
- [Phase B: Capture Logic & Distribution](#phase-b-capture-logic--distribution)
  - [1. Implementation Workflow](#1-implementation-workflow-1)
  - [2. Architecture & Logic Flow](#2-architecture--logic-flow)
  - [3. Code Implementation](#3-code-implementation-1)
  - [4. Logic Decision Tree](#4-logic-decision-tree)
  - [5. Logging Matrix](#5-logging-matrix)
  - [6. Deliverable Checklist (Phase B)](#6-deliverable-checklist-phase-b)
- [Phase C: The Journal UI](#phase-c-the-journal-ui-the-scavengers-journal)
  - [1. Implementation Workflow](#1-implementation-workflow-2)
  - [2. Code Implementation](#2-code-implementation)
  - [3. Decision Tree](#3-decision-tree)
  - [4. Logging Matrix](#4-logging-matrix)
  - [5. Deliverable Checklist (Phase C)](#5-deliverable-checklist-phase-c)
- [Testing Strategy](#testing-strategy)
- [Draft Changelog](#draft-changelog)

## Overview

This version implements the "Scavenger's Journal" - a non-inventory progression system where players collect fragmented lore, assemble bestiary entries, and unlock mechanics explanations.

Consistent with our "Walking Skeleton" approach and the complexity of the Data Capture system (fragment assembly, redaction logic, and distinct UI), this version is split into three sub-milestones:

- **Phase A: Data Foundation** - Database schema and domain models
- **Phase B: Capture Logic** - Finding, generating, and assigning lore fragments
- **Phase C: Journal UI** - Terminal interface for reading and tracking lore

---

## Phase A: Data Foundation (Schema & Storage)

**Goal:** Establish the persistent data layer for the Scavenger's Journal. This entails defining the database schema for CodexEntry (the lore targets) and DataCapture (the collectible fragments), configuring their relationships in PostgreSQL, and seeding the initial "Field Guide" content.

### 1. Implementation Workflow

1. **Domain Definitions:** Create Enums for CaptureType and EntryCategory
2. **Entity Modeling:** Define CodexEntry (static lore data) and DataCapture (player-acquired fragments)
3. **Data Configuration:** Configure Entity Framework Core relationships (One-to-Many) and JSONB columns for unlock thresholds
4. **Repository Layer:** Implement CodexRepository to handle specialized queries
5. **Migration & Seeding:** Create the DB migration and populate the "Field Guide" via DataSeeder

### 2. Architecture & Data Flow

The core architectural decision is separating Static Content (The Entry) from Player Progress (The Captures).

```
Character "1" -- "many" DataCapture : Finds
CodexEntry "1" -- "many" DataCapture : Compiles
```

**Key Constraint:** Data Captures are NOT stored in the Inventory table. They live in their own table to ensure they never consume inventory weight or slots.

### 3. Code Implementation

#### A. Core Layer (Enums)

**File:** `RuneAndRust.Core/Enums/CaptureType.cs`
```csharp
namespace RuneAndRust.Core.Enums;

public enum CaptureType
{
    TextFragment = 0,    // Readable notes/slates
    EchoRecording = 1,   // Audio logs
    VisualRecord = 2,    // Schematics/Images
    Specimen = 3,        // Biological samples
    OralHistory = 4,     // Dialogue/Rumors
    RunicTrace = 5       // Magic/Tech analysis
}
```

**File:** `RuneAndRust.Core/Enums/EntryCategory.cs`
```csharp
namespace RuneAndRust.Core.Enums;

public enum EntryCategory
{
    FieldGuide = 0,      // Mechanics & Tutorials (Auto-unlocked)
    BlightOrigin = 1,    // Lore: The Glitch
    Bestiary = 2,        // Creature Data
    Factions = 3,        // Political/Social
    Technical = 4,       // Pre-Glitch Tech
    Geography = 5        // Locations
}
```

#### B. Core Layer (Entities)

**File:** `RuneAndRust.Core/Entities/CodexEntry.cs`
```csharp
namespace RuneAndRust.Core.Entities;

public class CodexEntry
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Title { get; set; } = string.Empty;
    public EntryCategory Category { get; set; }

    // The complete text. The UI will redact this based on fragment count.
    public string FullText { get; set; } = string.Empty;

    // JSONB: Key = % Completion (25, 50, 75), Value = Unlock Key/Text
    public Dictionary<int, string> UnlockThresholds { get; set; } = new();

    // Navigation Property
    public ICollection<DataCapture> Fragments { get; set; } = new List<DataCapture>();
}
```

**File:** `RuneAndRust.Core/Entities/DataCapture.cs`
```csharp
namespace RuneAndRust.Core.Entities;

public class DataCapture
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public Guid CharacterId { get; set; }
    public Guid? CodexEntryId { get; set; }
    public CaptureType Type { get; set; }
    public string FragmentContent { get; set; } = string.Empty;
    public string Source { get; set; } = string.Empty;
    public int Quality { get; set; }
    public DateTime DiscoveredAt { get; set; } = DateTime.UtcNow;
    public CodexEntry? CodexEntry { get; set; }
}
```

#### C. Persistence Layer (Configuration)

**File:** `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs`
```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<CodexEntry>(entity => {
        entity.HasKey(e => e.Id);
        entity.Property(e => e.UnlockThresholds).HasColumnType("jsonb");
    });

    modelBuilder.Entity<DataCapture>(entity => {
        entity.HasOne(d => d.CodexEntry)
              .WithMany(e => e.Fragments)
              .HasForeignKey(d => d.CodexEntryId);
        entity.HasIndex(d => d.CharacterId);
    });
}
```

### 4. Decision Tree

- **Q: Should DataCapture contain the full text or just a reference?**
  - A: Full Fragment Text. Each capture is unique. The CodexEntry contains the synthesis.

- **Q: How do we handle "Unknown" entries?**
  - A: UI Logic. If Fragments.Count == 0, display as "Unknown" or hide it.

- **Q: Are "Field Guide" entries different entities?**
  - A: No. They are CodexEntry items with Category = FieldGuide.

### 5. Deliverable Checklist (Phase A)

- [x] Core: CaptureType and EntryCategory enums defined
- [x] Core: CodexEntry and DataCapture entities defined
- [x] Persistence: EF Core Migration AddCodexSchema created
- [x] Persistence: DbContext updated with DbSet<CodexEntry> and DbSet<DataCapture>
- [x] Persistence: DataSeeder updated with Field Guide and Bestiary entries
- [x] Testing: CodexPersistenceTests.cs for fragment linking and JSONB serialization

---

## Phase B: Capture Logic & Distribution

**Goal:** Implement the "Engine" layer for the Codex. This includes the DataCaptureService to handle logic, integrating capture generation into the existing LootService and InteractionService, and defining the algorithms for auto-assignment and completion tracking.

### 1. Implementation Workflow

1. **Service Definition:** Create IDataCaptureService and DataCaptureService
2. **Generation Logic:** Implement CaptureGenerator to select appropriate fragments based on Biome/Enemy tags
3. **Loot Integration:** Update LootService to trigger capture rolls alongside item drops
4. **Interaction Integration:** Update InteractionService to reward captures on high-tier Examine results
5. **Assignment Logic:** Implement logic to link DataCapture to CodexEntry and recalculate completion
6. **Event System:** Publish CaptureDiscoveredEvent for the UI

### 2. Architecture & Logic Flow

Data Captures bypass InventoryService and go straight to the database.

```
Player -> InteractionService -> LootService (Physical)
                             -> DataCaptureService -> DB
```

### 3. Code Implementation

#### A. Core Layer (Contracts)

**File:** `RuneAndRust.Core/Interfaces/IDataCaptureService.cs`
```csharp
public interface IDataCaptureService
{
    Task<DataCapture?> TryGenerateCaptureAsync(LootGenerationContext context, Guid characterId);
    Task<bool> AssignFragmentAsync(Guid captureId, Guid entryId);
    Task<int> CalculateEntryCompletionAsync(Guid entryId, Guid characterId);
    Task<IEnumerable<DataCapture>> GetUnassignedCapturesAsync(Guid characterId);
}
```

#### B. Engine Layer (Service Logic)

**File:** `RuneAndRust.Engine/Services/DataCaptureService.cs`
```csharp
public class DataCaptureService : IDataCaptureService
{
    public async Task<DataCapture?> TryGenerateCaptureAsync(LootGenerationContext context, Guid characterId)
    {
        // 1. Base Chance: 15% + Wits Bonus
        int chance = 15 + (context.WitsBonus * 2);
        if (_random.Next(0, 100) > chance) return null;

        // 2. Select Entry Category based on Context
        var targetCategory = DetermineCategory(context.BiomeType);

        // 3. Create fragment
        var fragment = new DataCapture
        {
            CharacterId = characterId,
            Type = CaptureType.TextFragment,
            FragmentContent = "System logs indicate catastrophic failure...",
            Source = $"Salvaged from {context.BiomeType} ruins",
            Quality = 15
        };

        // 4. Auto-Assign Logic (90% Confidence threshold)
        // ...

        await _captureRepo.AddAsync(fragment);
        return fragment;
    }
}
```

### 4. Logic Decision Tree

- **Q: How do we determine fragment quality?**
  - A: Use the WITS check margin. 0-2 successes = Standard (15 Legend), 3+ = Specialist (30 Legend)

- **Q: Does every enemy drop a Bestiary fragment?**
  - A: No. Use the 1-3-5 Rule (Fragment 1: Common, Fragment 2: WITS exam, Fragment 3: Rare)

- **Q: How do we handle duplicate fragments?**
  - A: Convert to raw Legend or upgrade existing fragment quality

### 5. Logging Matrix

| System | Event | Level | Message Template |
|--------|-------|-------|------------------|
| DataCapture | Generation Success | Info | "Generated DataCapture {Id} for Char {CharId}. Context: {Biome}" |
| DataCapture | Auto-Assign | Debug | "Fragment {FragId} auto-assigned to Entry {EntryId}" |
| DataCapture | Completion Update | Info | "Codex Entry {EntryId} is now {Percent}% complete." |

### 6. Deliverable Checklist (Phase B)

- [x] Core: IDataCaptureService defined
- [x] Engine: DataCaptureService implemented
- [x] Engine: TryGenerateCaptureAsync with Biome/Danger weighting
- [x] Engine: CalculateEntryCompletionAsync logic
- [x] Integration: InteractionService triggers capture rolls
- [x] Testing: DataCaptureServiceTests for generation and assignment

---

## Phase C: The Journal UI (The Scavenger's Journal)

**Goal:** Implement the Terminal UI (TUI) for the Scavenger's Journal, enabling players to view collected lore, track bestiary progress, and access tutorials. This version introduces the Redaction Renderer to visually represent fragmented knowledge and integrates the "Glitch" aesthetic.

### 1. Implementation Workflow

1. **Command Integration:** Implement JournalCommand and CodexCommand
2. **Display Models:** Create JournalViewModel to decouple data from rendering
3. **Redaction Logic:** Implement TextRedactor service to mask text based on completion
4. **UI Construction:** Build JournalRenderer using Spectre.Console for tabbed views
5. **Glitch Integration:** Add visual text corruption based on Psychic Stress
6. **Verification:** Test rendering output and navigation flows

### 2. Code Implementation

#### A. Engine Layer (Display Logic)

**File:** `RuneAndRust.Engine/ViewModels/JournalViewModel.cs`
```csharp
public record JournalEntryDisplay(
    string Title,
    string Category,
    string DisplayText,
    int CompletionPercent,
    bool IsNew
);

public class JournalViewModel
{
    public List<JournalEntryDisplay> CodexEntries { get; set; } = new();
    public List<JournalEntryDisplay> BestiaryEntries { get; set; } = new();
    public List<JournalEntryDisplay> FieldGuideEntries { get; set; } = new();
}
```

**File:** `RuneAndRust.Engine/Services/TextRedactor.cs`
```csharp
public class TextRedactor
{
    public string RedactText(string fullText, int completionPct)
    {
        if (completionPct >= 100) return fullText;
        if (completionPct <= 0) return "[REDACTED]";

        // Pseudo-random masking based on completion percentage
        // ...
    }
}
```

#### B. Terminal Layer (Rendering)

**File:** `RuneAndRust.Terminal/Services/TerminalRenderer.cs`
```csharp
public void RenderJournal(JournalViewModel vm)
{
    AnsiConsole.Clear();
    AnsiConsole.Write(new FigletText("Scavenger's Journal").Color(Color.Cyan1));

    var table = new Table().Border(TableBorder.Rounded);
    table.AddColumn("Category");
    table.AddColumn("Entries");

    // Add Codex, Bestiary, Field Guide rows
    // ...

    AnsiConsole.Write(table);
}
```

### 3. Decision Tree

- **Q: Should the Journal stop the game loop?**
  - A: Yes. In Terminal phase, it acts as a modal screen. Future GUI will use overlay.

- **Q: How do we handle "Glitched" text effects?**
  - A: Generate at runtime in TextRedactor based on character's Stress level.

- **Q: How do players read a specific entry?**
  - A: Sub-commands. `journal` lists summaries, `codex "Name"` shows full redacted text.

### 4. Logging Matrix

| System | Event | Level | Message Template |
|--------|-------|-------|------------------|
| JournalCommand | Open | Info | "{Character} opened Scavenger's Journal." |
| TextRedactor | Redaction | Verbose | "Redacted text for {Title}. Completion: {Pct}%." |
| JournalCommand | Detail View | Debug | "Player viewing details for entry: {EntryTitle}" |

### 5. Deliverable Checklist (Phase C)

- [x] Engine: TextRedactor service implemented
- [x] Engine: JournalViewModel record defined
- [x] Engine: JournalCommand and CodexCommand registered in CommandParser
- [x] Terminal: RenderJournal using Spectre.Console.Table
- [x] Terminal: RenderEntryDetail for specific views
- [x] Testing: TextRedactorTests for 0% and 100% cases
- [x] Verification: `journal` shows Field Guide entries, `codex "Psychic Stress"` shows full text

---

## Testing Strategy

### Unit Tests

**DataCaptureServiceTests.cs:**
- Verify generation probabilities
- Verify auto-assignment logic

**TextRedactorTests.cs:**
- Verify 0% returns "[REDACTED]"
- Verify 100% returns full text

**JournalCommandTests.cs:**
- Verify data fetching from DataCaptureService

### Integration Tests

**CodexPersistenceTests.cs:**
- Saving DataCapture linked to Character
- Retrieving CodexEntry with Fragments
- JSON serialization of UnlockThresholds

---

## Draft Changelog

```markdown
# Changelog: v0.1.3 - The Codex

## Summary
The "Scavenger's Journal" is now live. Players can collect lore fragments during exploration,
assembling them into complete Codex entries. The system introduces progressive revelation
with redacted text that clears as fragments are discovered.

## Features
- **Data Capture System:** Collect lore fragments from containers, enemies, and examination
- **Codex Entries:** Bestiary, Field Guide, and Lore categories
- **Redaction Renderer:** Incomplete entries display partially masked text
- **Journal UI:** Tabbed interface for browsing collected knowledge

## Technical
- Implemented DataCaptureService for fragment generation and assignment
- Added CodexEntry and DataCapture entities with JSONB unlock thresholds
- Created TextRedactor for completion-based text masking
```

---

*This completes Milestone 2: The Explorer. The next phase, Milestone 3: The Warrior, begins with v0.2.0: Combat Resolution Core.*
