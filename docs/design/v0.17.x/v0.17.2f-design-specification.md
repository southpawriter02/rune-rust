# v0.17.2f Design Specification: Attribute Allocation Service

**Version:** 0.17.2f  
**Phase Name:** Attribute Allocation Service  
**Parent Version:** v0.17.2 (Attribute System)  
**Prerequisites:** v0.17.2e Complete (Attribute Provider Service)  
**Estimated Tests:** ~10 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [IAttributeAllocationService Interface](#4-iattributeallocationservice-interface)
5. [AttributeModificationResult Value Object](#5-attributemodificationresult-value-object)
6. [AttributeAllocationService Implementation](#6-attributeallocationservice-implementation)
7. [Data Model Changes](#7-data-model-changes)
8. [Logging Specifications](#8-logging-specifications)
9. [Unit Testing Requirements](#9-unit-testing-requirements)
10. [Use Cases](#10-use-cases)
11. [User Stories](#11-user-stories)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Dependencies](#14-dependencies)
15. [Future Considerations](#15-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification defines the `IAttributeAllocationService` interface and its implementation for managing attribute point allocation during character creation. The service handles both Simple (archetype-based) and Advanced (point-buy) allocation modes, including state creation, attribute modification, validation, and mode switching.

### 1.2 Key Deliverables

| Category          | Items                         |
| ----------------- | ----------------------------- |
| **Interfaces**    | `IAttributeAllocationService` |
| **Value Objects** | `AttributeModificationResult` |
| **Services**      | `AttributeAllocationService`  |
| **Tests**         | ~10 unit tests                |

### 1.3 Architectural Significance

- **State Management**: Immutable state transitions via `AttributeAllocationState`
- **Mode Support**: Handles both Simple and Advanced allocation modes
- **Cost Validation**: Enforces point-buy constraints using `PointBuyConfiguration`
- **Provider Integration**: Uses `IAttributeProvider` for configuration and builds

---

## 2. Feature Overview

```
v0.17.2f Attribute Allocation Service
├── IAttributeAllocationService Interface
│   ├── CreateAllocationState(mode, archetype?)
│   ├── TryModifyAttribute(state, attribute, newValue)
│   ├── CalculateCost(fromValue, toValue)
│   ├── ValidateAllocation(state)
│   ├── SwitchMode(state, newMode, archetype?)
│   └── ResetAllocation(mode, archetype?)
├── AttributeModificationResult Value Object
│   ├── Success: bool
│   ├── NewState: AttributeAllocationState?
│   ├── PointsSpent: int
│   ├── PointsRemaining: int
│   └── ErrorMessage: string?
└── AttributeAllocationService Implementation
    ├── Point constraint enforcement
    ├── Value range validation (1-10)
    └── Mode switching logic
```

### 2.1 Scope Alignment

**In Scope:**

- `IAttributeAllocationService` interface with 6 methods
- `AttributeModificationResult` value object
- `AttributeAllocationService` implementation
- Point-buy cost enforcement
- Mode switching with state preservation/reset

**Out of Scope:**

- Derived stat calculation → v0.17.2g
- UI integration → v0.17.5
- Persistence of allocation state → future version

---

## 3. Architecture Diagrams

### 3.1 Allocation Service Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                ATTRIBUTE ALLOCATION SERVICE OVERVIEW                 │
└─────────────────────────────────────────────────────────────────────┘

    Character Creation UI
           │
           │  User adjusts attributes
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                 IAttributeAllocationService                          │
├─────────────────────────────────────────────────────────────────────┤
│  + CreateAllocationState(mode, archetype?)                          │
│  + TryModifyAttribute(state, attribute, newValue)                   │
│  + CalculateCost(fromValue, toValue)                                │
│  + ValidateAllocation(state)                                        │
│  + SwitchMode(state, newMode, archetype?)                           │
│  + ResetAllocation(mode, archetype?)                                │
└─────────────────────────────────────────────────────────────────────┘
           │
           │  Uses
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     IAttributeProvider                               │
├─────────────────────────────────────────────────────────────────────┤
│  + GetRecommendedBuild(archetype)                                   │
│  + GetPointBuyConfiguration()                                       │
│  + GetStartingPoints(archetype?)                                    │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 TryModifyAttribute Decision Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│               TryModifyAttribute DECISION FLOW                       │
└─────────────────────────────────────────────────────────────────────┘

    TryModifyAttribute(state, attribute, newValue)
           │
           ▼
    ┌──────────────────────┐
    │ Mode == Simple?      │
    └──────────┬───────────┘
               │
        ┌──────┴──────┐
       YES            NO
        │              │
        ▼              ▼
    ┌────────────┐  ┌──────────────────────────────────────────────┐
    │ Return     │  │ ADVANCED MODE VALIDATION                     │
    │ Failure:   │  ├──────────────────────────────────────────────┤
    │ "Cannot    │  │ 1. Is newValue in [1, 10]?                   │
    │ modify in  │  │    NO → Return Failure: "Value out of range" │
    │ Simple     │  │                                              │
    │ mode"      │  │ 2. Calculate cost = CalculateCost(           │
    └────────────┘  │       state.GetAttributeValue(attr), newValue│
                    │    )                                         │
                    │                                              │
                    │ 3. Is cost > 0 AND cost > PointsRemaining?   │
                    │    YES → Return Failure: "Insufficient pts"  │
                    │                                              │
                    │ 4. Create new state with updated value       │
                    │    and adjusted points                       │
                    │                                              │
                    │ 5. Return Success with new state             │
                    └──────────────────────────────────────────────┘
```

### 3.3 Mode Switching Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MODE SWITCHING FLOW                               │
└─────────────────────────────────────────────────────────────────────┘

    SwitchMode(currentState, newMode, archetype?)
           │
           ▼
    ┌──────────────────────┐
    │ currentMode ==       │
    │ newMode?             │
    └──────────┬───────────┘
               │
        ┌──────┴──────┐
       YES            NO
        │              │
        ▼              ▼
    ┌────────────┐  ┌──────────────────────────────────────────────┐
    │ Return     │  │ MODE SWITCH LOGIC                            │
    │ current    │  ├──────────────────────────────────────────────┤
    │ state      │  │ Switching TO Simple:                         │
    │ unchanged  │  │   1. archetype required                      │
    └────────────┘  │   2. Get recommended build from provider     │
                    │   3. Return new state with build applied     │
                    │                                              │
                    │ Switching TO Advanced:                       │
                    │   1. Keep current attribute values           │
                    │   2. Calculate points spent from values      │
                    │   3. Return new state with Advanced mode     │
                    └──────────────────────────────────────────────┘
```

### 3.4 Allocation State Transitions

```
┌─────────────────────────────────────────────────────────────────────┐
│                ALLOCATION STATE TRANSITIONS                          │
└─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────┐
    │                       INITIAL STATES                             │
    ├───────────────────────────────┬─────────────────────────────────┤
    │        Simple Mode            │        Advanced Mode            │
    │ (archetype required)          │ (fresh start)                   │
    ├───────────────────────────────┼─────────────────────────────────┤
    │ M=?, F=?, Wi=?, Wl=?, S=?     │ M=1, F=1, Wi=1, Wl=1, S=1       │
    │ (from recommended build)      │ PointsRemaining = 15            │
    │ PointsRemaining = 0           │                                 │
    └───────────────────────────────┴─────────────────────────────────┘
           │                                    │
           │  SwitchMode                        │
           ▼                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                      MODIFICATIONS                               │
    ├─────────────────────────────────────────────────────────────────┤
    │  Simple Mode:                                                    │
    │    - NO modifications allowed                                   │
    │    - Can only switch archetype (gets new build)                 │
    │                                                                  │
    │  Advanced Mode:                                                  │
    │    - TryModifyAttribute(attr, newValue)                         │
    │    - Each modification returns NEW immutable state              │
    │    - Points tracked automatically                                │
    └─────────────────────────────────────────────────────────────────┘
           │
           │  ValidateAllocation
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                      VALIDATION                                  │
    ├─────────────────────────────────────────────────────────────────┤
    │  - All attributes in [1, 10]                                    │
    │  - Points spent <= Points available                             │
    │  - Simple mode has archetype selected                           │
    └─────────────────────────────────────────────────────────────────┘
```

---

## 4. IAttributeAllocationService Interface

### 4.1 Purpose

The `IAttributeAllocationService` interface defines the contract for managing attribute allocation state and modifications.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Interfaces/IAttributeAllocationService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Manages attribute point allocation during character creation.
/// </summary>
/// <remarks>
/// <para>
/// This service handles both Simple (archetype-based) and Advanced (point-buy)
/// allocation modes. It maintains immutable state and returns new state objects
/// for each modification.
/// </para>
/// </remarks>
public interface IAttributeAllocationService
{
    /// <summary>
    /// Creates the initial allocation state for a mode.
    /// </summary>
    /// <param name="mode">The allocation mode (Simple or Advanced).</param>
    /// <param name="archetypeId">Required for Simple mode; optional for Advanced.</param>
    /// <returns>A new allocation state.</returns>
    AttributeAllocationState CreateAllocationState(
        AttributeAllocationMode mode,
        string? archetypeId = null);

    /// <summary>
    /// Attempts to modify an attribute value.
    /// </summary>
    /// <param name="state">The current allocation state.</param>
    /// <param name="attribute">The attribute to modify.</param>
    /// <param name="newValue">The target value (1-10).</param>
    /// <returns>A result indicating success/failure with the new state.</returns>
    AttributeModificationResult TryModifyAttribute(
        AttributeAllocationState state,
        CoreAttribute attribute,
        int newValue);

    /// <summary>
    /// Calculates the cost to change an attribute value.
    /// </summary>
    /// <param name="fromValue">Current value.</param>
    /// <param name="toValue">Target value.</param>
    /// <returns>Points to spend (positive) or refund (negative).</returns>
    int CalculateCost(int fromValue, int toValue);

    /// <summary>
    /// Validates that the allocation is complete and valid.
    /// </summary>
    /// <param name="state">The state to validate.</param>
    /// <returns>Validation result with any errors.</returns>
    ValidationResult ValidateAllocation(AttributeAllocationState state);

    /// <summary>
    /// Switches the allocation mode.
    /// </summary>
    /// <param name="currentState">The current state.</param>
    /// <param name="newMode">The target mode.</param>
    /// <param name="archetypeId">Required when switching to Simple mode.</param>
    /// <returns>The new state in the target mode.</returns>
    AttributeAllocationState SwitchMode(
        AttributeAllocationState currentState,
        AttributeAllocationMode newMode,
        string? archetypeId = null);

    /// <summary>
    /// Resets allocation to initial defaults.
    /// </summary>
    /// <param name="mode">The mode to reset to.</param>
    /// <param name="archetypeId">Required for Simple mode.</param>
    /// <returns>A fresh allocation state.</returns>
    AttributeAllocationState ResetAllocation(
        AttributeAllocationMode mode,
        string? archetypeId = null);
}
```

---

## 5. AttributeModificationResult Value Object

### 5.1 Purpose

The `AttributeModificationResult` value object encapsulates the outcome of an attribute modification attempt.

### 5.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AttributeModificationResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// The result of an attribute modification attempt.
/// </summary>
/// <remarks>
/// <para>
/// This value object captures the outcome of TryModifyAttribute, including
/// the new state on success or an error message on failure.
/// </para>
/// </remarks>
public readonly record struct AttributeModificationResult
{
    /// <summary>Gets whether the modification succeeded.</summary>
    public bool Success { get; init; }

    /// <summary>Gets the new state after modification (null if failed).</summary>
    public AttributeAllocationState? NewState { get; init; }

    /// <summary>Gets the total points spent after modification.</summary>
    public int PointsSpent { get; init; }

    /// <summary>Gets the points remaining after modification.</summary>
    public int PointsRemaining { get; init; }

    /// <summary>Gets the error message if modification failed.</summary>
    public string? ErrorMessage { get; init; }

    /// <summary>Creates a successful result.</summary>
    public static AttributeModificationResult Succeeded(AttributeAllocationState newState) =>
        new()
        {
            Success = true,
            NewState = newState,
            PointsSpent = newState.PointsSpent,
            PointsRemaining = newState.PointsRemaining,
            ErrorMessage = null
        };

    /// <summary>Creates a failed result.</summary>
    public static AttributeModificationResult Failed(
        string errorMessage,
        AttributeAllocationState currentState) =>
        new()
        {
            Success = false,
            NewState = null,
            PointsSpent = currentState.PointsSpent,
            PointsRemaining = currentState.PointsRemaining,
            ErrorMessage = errorMessage
        };

    public override string ToString() =>
        Success
            ? $"Success: {PointsSpent} spent, {PointsRemaining} remaining"
            : $"Failed: {ErrorMessage}";
}
```

---

## 6. AttributeAllocationService Implementation

### 6.1 Purpose

The `AttributeAllocationService` implements the allocation logic using the provider for configuration.

### 6.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/AttributeAllocationService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Manages attribute allocation during character creation.
/// </summary>
public class AttributeAllocationService : IAttributeAllocationService
{
    private readonly IAttributeProvider _provider;
    private readonly ILogger<AttributeAllocationService> _logger;

    public AttributeAllocationService(
        IAttributeProvider provider,
        ILogger<AttributeAllocationService> logger)
    {
        _provider = provider;
        _logger = logger;
    }

    /// <inheritdoc />
    public AttributeAllocationState CreateAllocationState(
        AttributeAllocationMode mode,
        string? archetypeId = null)
    {
        _logger.LogDebug("Creating allocation state: Mode={Mode}, Archetype={Archetype}",
            mode, archetypeId);

        if (mode == AttributeAllocationMode.Simple)
        {
            ArgumentException.ThrowIfNullOrWhiteSpace(archetypeId);
            return _provider.GetRecommendedBuild(archetypeId);
        }

        var points = _provider.GetStartingPoints(archetypeId);
        return AttributeAllocationState.CreateAdvancedDefault(points);
    }

    /// <inheritdoc />
    public AttributeModificationResult TryModifyAttribute(
        AttributeAllocationState state,
        CoreAttribute attribute,
        int newValue)
    {
        _logger.LogDebug("TryModifyAttribute: {Attr} → {Value}", attribute, newValue);

        // Simple mode blocks modifications
        if (state.Mode == AttributeAllocationMode.Simple)
        {
            _logger.LogWarning("Cannot modify attributes in Simple mode");
            return AttributeModificationResult.Failed(
                "Cannot modify attributes in Simple mode", state);
        }

        // Validate range
        var config = _provider.GetPointBuyConfiguration();
        if (newValue < config.MinAttributeValue || newValue > config.MaxAttributeValue)
        {
            return AttributeModificationResult.Failed(
                $"Value must be between {config.MinAttributeValue} and {config.MaxAttributeValue}",
                state);
        }

        // Calculate cost
        var currentValue = state.GetAttributeValue(attribute);
        var cost = config.CalculateCost(currentValue, newValue);

        // Check affordability for increases
        if (cost > 0 && cost > state.PointsRemaining)
        {
            return AttributeModificationResult.Failed(
                $"Insufficient points: need {cost}, have {state.PointsRemaining}",
                state);
        }

        // Apply modification
        var newState = state.WithAttributeValue(attribute, newValue, cost);

        _logger.LogInformation(
            "Modified {Attr}: {OldValue} → {NewValue}, cost={Cost}",
            attribute, currentValue, newValue, cost);

        return AttributeModificationResult.Succeeded(newState);
    }

    /// <inheritdoc />
    public int CalculateCost(int fromValue, int toValue) =>
        _provider.GetPointBuyConfiguration().CalculateCost(fromValue, toValue);

    /// <inheritdoc />
    public ValidationResult ValidateAllocation(AttributeAllocationState state)
    {
        var errors = new List<string>();
        var config = _provider.GetPointBuyConfiguration();

        // Check all values in range
        foreach (CoreAttribute attr in Enum.GetValues<CoreAttribute>())
        {
            var value = state.GetAttributeValue(attr);
            if (value < config.MinAttributeValue || value > config.MaxAttributeValue)
                errors.Add($"{attr} value {value} is out of range");
        }

        // Check points not overspent
        if (state.PointsRemaining < 0)
            errors.Add($"Points overspent by {Math.Abs(state.PointsRemaining)}");

        // Simple mode must have archetype
        if (state.Mode == AttributeAllocationMode.Simple &&
            string.IsNullOrWhiteSpace(state.SelectedArchetypeId))
            errors.Add("Simple mode requires archetype selection");

        return errors.Count == 0
            ? ValidationResult.Valid()
            : ValidationResult.Invalid(errors);
    }

    /// <inheritdoc />
    public AttributeAllocationState SwitchMode(
        AttributeAllocationState currentState,
        AttributeAllocationMode newMode,
        string? archetypeId = null)
    {
        if (currentState.Mode == newMode)
            return currentState;

        _logger.LogInformation("Switching mode: {OldMode} → {NewMode}",
            currentState.Mode, newMode);

        if (newMode == AttributeAllocationMode.Simple)
        {
            ArgumentException.ThrowIfNullOrWhiteSpace(archetypeId);
            return _provider.GetRecommendedBuild(archetypeId);
        }

        // Switching to Advanced: keep values, calculate points spent
        var config = _provider.GetPointBuyConfiguration();
        var pointsSpent = 0;
        foreach (CoreAttribute attr in Enum.GetValues<CoreAttribute>())
        {
            pointsSpent += config.GetCumulativeCost(currentState.GetAttributeValue(attr));
        }

        return currentState.SwitchToAdvanced(pointsSpent);
    }

    /// <inheritdoc />
    public AttributeAllocationState ResetAllocation(
        AttributeAllocationMode mode,
        string? archetypeId = null) =>
        CreateAllocationState(mode, archetypeId);
}
```

---

## 7. Data Model Changes

### 7.1 New Types Summary

| Type                          | Layer       | Category     | Description                    |
| ----------------------------- | ----------- | ------------ | ------------------------------ |
| `IAttributeAllocationService` | Application | Interface    | Allocation management contract |
| `AttributeModificationResult` | Domain      | Value Object | Modification outcome           |
| `AttributeAllocationService`  | Application | Service      | Implementation                 |

### 7.2 File Locations

```
src/Core/RuneAndRust.Domain/
├── ValueObjects/
│   └── AttributeModificationResult.cs       ← NEW

src/Core/RuneAndRust.Application/
├── Interfaces/
│   └── IAttributeAllocationService.cs       ← NEW
├── Services/
│   └── AttributeAllocationService.cs        ← NEW
```

---

## 8. Logging Specifications

| Event                  | Level       | Template                                                        |
| ---------------------- | ----------- | --------------------------------------------------------------- |
| State created          | Debug       | "Creating allocation state: Mode={Mode}, Archetype={Archetype}" |
| Modification attempted | Debug       | "TryModifyAttribute: {Attr} → {Value}"                          |
| Modification succeeded | Information | "Modified {Attr}: {OldValue} → {NewValue}, cost={Cost}"         |
| Simple mode blocked    | Warning     | "Cannot modify attributes in Simple mode"                       |
| Mode switched          | Information | "Switching mode: {OldMode} → {NewMode}"                         |
| Validation failed      | Warning     | "Allocation validation failed: {Errors}"                        |

---

## 9. Unit Testing Requirements

### 9.1 Test Count: ~10 tests

```csharp
[TestFixture]
public class AttributeAllocationServiceTests
{
    private Mock<IAttributeProvider> _providerMock;
    private Mock<ILogger<AttributeAllocationService>> _loggerMock;
    private IAttributeAllocationService _service;

    [SetUp]
    public void Setup()
    {
        _providerMock = new Mock<IAttributeProvider>();
        _loggerMock = new Mock<ILogger<AttributeAllocationService>>();
        SetupDefaultMocks();
        _service = new AttributeAllocationService(_providerMock.Object, _loggerMock.Object);
    }

    [Test]
    public void CreateAllocationState_SimpleMode_ReturnsRecommendedBuild()
    {
        var state = _service.CreateAllocationState(
            AttributeAllocationMode.Simple, "warrior");

        state.Mode.Should().Be(AttributeAllocationMode.Simple);
        state.CurrentMight.Should().Be(4);
    }

    [Test]
    public void CreateAllocationState_AdvancedMode_ReturnsDefaultState()
    {
        var state = _service.CreateAllocationState(AttributeAllocationMode.Advanced);

        state.Mode.Should().Be(AttributeAllocationMode.Advanced);
        state.CurrentMight.Should().Be(1);
        state.PointsRemaining.Should().Be(15);
    }

    [Test]
    public void TryModifyAttribute_WithEnoughPoints_Succeeds()
    {
        var state = _service.CreateAllocationState(AttributeAllocationMode.Advanced);

        var result = _service.TryModifyAttribute(state, CoreAttribute.Might, 5);

        result.Success.Should().BeTrue();
        result.NewState!.Value.CurrentMight.Should().Be(5);
        result.PointsSpent.Should().Be(4);
    }

    [Test]
    public void TryModifyAttribute_InsufficientPoints_Fails()
    {
        var state = _service.CreateAllocationState(AttributeAllocationMode.Advanced);

        var result = _service.TryModifyAttribute(state, CoreAttribute.Might, 10);

        result.Success.Should().BeFalse();
        result.ErrorMessage.Should().Contain("Insufficient points");
    }

    [Test]
    public void TryModifyAttribute_InSimpleMode_Fails()
    {
        var state = _service.CreateAllocationState(
            AttributeAllocationMode.Simple, "warrior");

        var result = _service.TryModifyAttribute(state, CoreAttribute.Might, 5);

        result.Success.Should().BeFalse();
        result.ErrorMessage.Should().Contain("Simple mode");
    }

    [Test]
    public void TryModifyAttribute_ValueOutOfRange_Fails()
    {
        var state = _service.CreateAllocationState(AttributeAllocationMode.Advanced);

        var result = _service.TryModifyAttribute(state, CoreAttribute.Might, 11);

        result.Success.Should().BeFalse();
        result.ErrorMessage.Should().Contain("between");
    }

    [Test]
    public void SwitchMode_SimpleToAdvanced_PreservesValues()
    {
        var simpleState = _service.CreateAllocationState(
            AttributeAllocationMode.Simple, "warrior");

        var advancedState = _service.SwitchMode(
            simpleState, AttributeAllocationMode.Advanced);

        advancedState.Mode.Should().Be(AttributeAllocationMode.Advanced);
        advancedState.CurrentMight.Should().Be(4);
    }

    [Test]
    public void SwitchMode_AdvancedToSimple_AppliesRecommendedBuild()
    {
        var advancedState = _service.CreateAllocationState(AttributeAllocationMode.Advanced);

        var simpleState = _service.SwitchMode(
            advancedState, AttributeAllocationMode.Simple, "mystic");

        simpleState.Mode.Should().Be(AttributeAllocationMode.Simple);
        simpleState.CurrentWill.Should().Be(4);
    }

    [Test]
    public void ValidateAllocation_ValidState_ReturnsValid()
    {
        var state = _service.CreateAllocationState(
            AttributeAllocationMode.Simple, "warrior");

        var result = _service.ValidateAllocation(state);

        result.IsValid.Should().BeTrue();
    }

    [Test]
    public void ResetAllocation_ReturnsInitialState()
    {
        var state = _service.ResetAllocation(AttributeAllocationMode.Advanced);

        state.CurrentMight.Should().Be(1);
        state.PointsRemaining.Should().Be(15);
    }
}
```

---

## 10. Use Cases

| ID     | Use Case                 | Flow                                                         |
| ------ | ------------------------ | ------------------------------------------------------------ |
| UC-001 | Start Allocation         | Player selects mode → `CreateAllocationState()` → Display UI |
| UC-002 | Increase Attribute       | Click + → `TryModifyAttribute()` → Update if success         |
| UC-003 | Decrease Attribute       | Click - → `TryModifyAttribute()` → Refund points             |
| UC-004 | Switch to Simple         | Choose archetype → `SwitchMode()` → Apply build              |
| UC-005 | Validate Before Continue | Click Next → `ValidateAllocation()` → Allow/block            |

---

## 11. User Stories

**US-001:** As a player in Advanced mode, I want to increase an attribute and see my remaining points update.

**US-002:** As a player, I want to switch from Advanced to Simple mode and have the recommended build applied.

**US-003:** As a player, I want to be prevented from overspending my point pool.

---

## 12. Deliverable Checklist

- [ ] `IAttributeAllocationService` interface with 6 methods
- [ ] `AttributeModificationResult` value object
- [ ] `AttributeAllocationService` implementation
- [ ] Integration with `IAttributeProvider`
- [ ] Simple mode blocks modifications
- [ ] Mode switching preserves/resets state correctly
- [ ] ~10 unit tests implemented and passing
- [ ] XML documentation complete

---

## 13. Acceptance Criteria

### Functional

- [ ] `TryModifyAttribute()` succeeds with enough points
- [ ] `TryModifyAttribute()` fails when points insufficient
- [ ] `TryModifyAttribute()` fails in Simple mode
- [ ] `SwitchMode()` to Simple applies recommended build
- [ ] `SwitchMode()` to Advanced preserves attribute values
- [ ] `ValidateAllocation()` catches invalid states

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~10 unit tests pass
- [ ] XML documentation complete

---

## 14. Dependencies

### Required from Previous Phases

| Type                       | Phase    | Usage                    |
| -------------------------- | -------- | ------------------------ |
| `CoreAttribute`            | v0.17.2a | Attribute identifiers    |
| `AttributeAllocationState` | v0.17.2b | State management         |
| `PointBuyConfiguration`    | v0.17.2c | Cost calculation         |
| `IAttributeProvider`       | v0.17.2e | Configuration and builds |

### Provides to Future Phases

| Type                          | Phase   | Usage                 |
| ----------------------------- | ------- | --------------------- |
| `IAttributeAllocationService` | v0.17.5 | Character creation UI |

---

## 15. Future Considerations

### Deferred to v0.17.2g

- Integration with derived stat calculator

### Deferred to v0.17.5

- UI integration and real-time feedback

### Out of Scope for v0.17.2

- Undo/redo functionality
- Allocation history tracking
- Persistence of allocation state

---

_Document Version: 1.0_  
_Last Updated: 2025-01-27_
