# v0.10.3a Design Specification: Combo Definitions

**Version:** 0.10.3a
**Parent:** v0.10.3 (Combo System)
**Prerequisites:** v0.10.2c Complete (Ability Trees - Prerequisites & Respec)
**Status:** Design Complete
**Estimated Unit Tests:** ~12

---

## 1. Overview

### Purpose

Define the combo structure with sequences of abilities, timing windows, and bonus effects. Combos are loaded from JSON configuration and provide templates for the combo detection system. Players who execute specific ability sequences within a time window earn bonus effects like extra damage, status application, cooldown resets, or healing.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Entities** | `ComboDefinition`, `ComboStep`, `ComboBonusEffect` |
| **Enums** | `ComboTargetRequirement`, `ComboBonusType`, `ComboBonusTarget` |
| **Interfaces** | `IComboProvider` |
| **Infrastructure** | `ComboProvider` |
| **Configuration** | `combos.json` |
| **Tests** | ~12 unit tests |

---

## 2. Feature Overview

```
v0.10.3a Features
â”œâ”€â”€ ComboDefinition Entity
â”‚   â”œâ”€â”€ ComboId, Name, Description
â”‚   â”œâ”€â”€ WindowTurns (time limit)
â”‚   â”œâ”€â”€ RequiredClassIds (class filter)
â”‚   â”œâ”€â”€ Steps collection
â”‚   â”œâ”€â”€ BonusEffects collection
â”‚   â”œâ”€â”€ GetAbilityForStep()
â”‚   â””â”€â”€ ContainsAbility()
â”‚
â”œâ”€â”€ ComboStep Entity
â”‚   â”œâ”€â”€ StepNumber
â”‚   â”œâ”€â”€ AbilityId
â”‚   â”œâ”€â”€ TargetRequirement
â”‚   â”œâ”€â”€ CustomRequirement
â”‚   â””â”€â”€ Matches()
â”‚
â”œâ”€â”€ ComboBonusEffect Entity
â”‚   â”œâ”€â”€ EffectType
â”‚   â”œâ”€â”€ Value
â”‚   â”œâ”€â”€ DamageType
â”‚   â”œâ”€â”€ StatusEffectId
â”‚   â””â”€â”€ Target
â”‚
â”œâ”€â”€ ComboTargetRequirement Enum
â”‚   â”œâ”€â”€ Any
â”‚   â”œâ”€â”€ SameTarget
â”‚   â”œâ”€â”€ DifferentTarget
â”‚   â””â”€â”€ Self
â”‚
â”œâ”€â”€ ComboBonusType Enum
â”‚   â”œâ”€â”€ ExtraDamage
â”‚   â”œâ”€â”€ DamageMultiplier
â”‚   â”œâ”€â”€ ApplyStatus
â”‚   â”œâ”€â”€ Heal
â”‚   â”œâ”€â”€ ResetCooldown
â”‚   â”œâ”€â”€ RefundResource
â”‚   â””â”€â”€ AreaEffect
â”‚
â”œâ”€â”€ IComboProvider Interface
â”‚   â”œâ”€â”€ GetCombo(comboId)
â”‚   â”œâ”€â”€ GetAllCombos()
â”‚   â”œâ”€â”€ GetCombosForClass(classId)
â”‚   â””â”€â”€ GetCombosContaining(abilityId)
â”‚
â””â”€â”€ Configuration (combos.json)
    â”œâ”€â”€ Elemental Burst (mage)
    â”œâ”€â”€ Warrior's Onslaught (warrior)
    â”œâ”€â”€ Assassin's Dance (rogue)
    â””â”€â”€ Divine Judgment (paladin)
```

---

## 3. Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMBO DEFINITION ARCHITECTURE                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     Configuration                        Domain
     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”€â”€â”€â”€â”€â”€

   combos.json                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚      ComboDefinition        â”‚
   â”‚ {                â”‚          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚   "comboId": ...,â”‚  â”€â”€â”€â”€â”€â–¶  â”‚ + ComboId: string           â”‚
   â”‚   "name": ...,   â”‚          â”‚ + Name: string              â”‚
   â”‚   "steps": [...] â”‚          â”‚ + Description: string       â”‚
   â”‚   "bonus": {...} â”‚          â”‚ + WindowTurns: int          â”‚
   â”‚ }                â”‚          â”‚ + RequiredClassIds: list    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ + Steps: List<ComboStep>    â”‚
                                 â”‚ + BonusEffects: List<Effect>â”‚
                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                â”‚ contains
                                                â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚                                              â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”
          â”‚     ComboStep       â”‚              â”‚    ComboBonusEffect    â”‚
          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ + StepNumber: int   â”‚              â”‚ + EffectType: enum     â”‚
          â”‚ + AbilityId: string â”‚              â”‚ + Value: string        â”‚
          â”‚ + TargetReq: enum   â”‚              â”‚ + DamageType: string?  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ + StatusEffectId: str? â”‚
                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ELEMENTAL BURST COMBO EXAMPLE
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    Step 1              Step 2              Step 3           COMBO!
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”¥ Fire â”‚   +    â”‚ â„ Ice  â”‚   +    â”‚ âš¡Light â”‚  =   â”‚ğŸ’¥BURST! â”‚
    â”‚  Bolt   â”‚        â”‚  Shard  â”‚        â”‚  ning   â”‚      â”‚  x2 DMG â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Window: 3 turns                       Bonus: Double damage
                                                 + Elemental Overload
```

---

## 4. ComboDefinition Entity

**File:** `src/Core/RuneAndRust.Domain/Definitions/ComboDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines an ability combo with steps and bonus effects.
/// </summary>
public class ComboDefinition : IEntity
{
    public Guid Id { get; private set; }

    /// <summary>Unique identifier for the combo.</summary>
    public string ComboId { get; private set; } = null!;

    /// <summary>Display name.</summary>
    public string Name { get; private set; } = null!;

    /// <summary>Description of the combo.</summary>
    public string Description { get; private set; } = null!;

    /// <summary>Number of turns to complete the combo.</summary>
    public int WindowTurns { get; private set; }

    /// <summary>Classes that can use this combo (empty = all).</summary>
    public IReadOnlyList<string> RequiredClassIds { get; private set; } = [];

    /// <summary>Steps in the combo sequence.</summary>
    public IReadOnlyList<ComboStep> Steps { get; private set; } = [];

    /// <summary>Bonus effects applied on completion.</summary>
    public IReadOnlyList<ComboBonusEffect> BonusEffects { get; private set; } = [];

    /// <summary>Icon path.</summary>
    public string? IconPath { get; private set; }

    // EF Core constructor
    private ComboDefinition() { }

    public static ComboDefinition Create(
        string comboId,
        string name,
        string description,
        int windowTurns,
        IEnumerable<ComboStep> steps,
        IEnumerable<ComboBonusEffect>? bonusEffects = null,
        IEnumerable<string>? requiredClassIds = null,
        string? iconPath = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(comboId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(windowTurns);

        var stepList = steps.OrderBy(s => s.StepNumber).ToList();
        if (stepList.Count < 2)
            throw new ArgumentException("Combo must have at least 2 steps", nameof(steps));

        return new ComboDefinition
        {
            Id = Guid.NewGuid(),
            ComboId = comboId.ToLowerInvariant(),
            Name = name,
            Description = description,
            WindowTurns = windowTurns,
            Steps = stepList,
            BonusEffects = bonusEffects?.ToList() ?? [],
            RequiredClassIds = requiredClassIds?.Select(c => c.ToLowerInvariant()).ToList() ?? [],
            IconPath = iconPath
        };
    }

    /// <summary>Gets the total number of steps in the combo.</summary>
    public int StepCount => Steps.Count;

    /// <summary>Gets the first step's ability.</summary>
    public string FirstAbilityId => Steps.FirstOrDefault()?.AbilityId ?? string.Empty;

    /// <summary>Gets the ability ID for a specific step (1-indexed).</summary>
    public string? GetAbilityForStep(int stepNumber)
    {
        return Steps.FirstOrDefault(s => s.StepNumber == stepNumber)?.AbilityId;
    }

    /// <summary>Gets the step at a specific position (1-indexed).</summary>
    public ComboStep? GetStep(int stepNumber)
    {
        return Steps.FirstOrDefault(s => s.StepNumber == stepNumber);
    }

    /// <summary>Checks if an ability is part of this combo.</summary>
    public bool ContainsAbility(string abilityId)
    {
        return Steps.Any(s => s.AbilityId.Equals(abilityId, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>Checks if a class can use this combo.</summary>
    public bool IsAvailableForClass(string classId)
    {
        if (!RequiredClassIds.Any())
            return true; // No restriction = available to all

        return RequiredClassIds.Any(c => c.Equals(classId, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>Gets all unique ability IDs in this combo.</summary>
    public IReadOnlyList<string> GetAllAbilityIds()
    {
        return Steps.Select(s => s.AbilityId).Distinct(StringComparer.OrdinalIgnoreCase).ToList();
    }

    public override string ToString() => $"{Name} ({ComboId}): {StepCount} steps";
}
```

---

## 5. ComboStep Entity

**File:** `src/Core/RuneAndRust.Domain/Definitions/ComboStep.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// A single step in a combo sequence.
/// </summary>
public class ComboStep
{
    /// <summary>Step position (1-indexed).</summary>
    public int StepNumber { get; set; }

    /// <summary>The ability required for this step.</summary>
    public string AbilityId { get; set; } = null!;

    /// <summary>Target requirement for this step.</summary>
    public ComboTargetRequirement TargetRequirement { get; set; } = ComboTargetRequirement.Any;

    /// <summary>Optional custom requirement expression.</summary>
    public string? CustomRequirement { get; set; }

    /// <summary>Checks if an ability usage matches this step.</summary>
    /// <param name="abilityId">The ability used.</param>
    /// <param name="isSameTarget">Whether target matches previous step's target.</param>
    /// <param name="isSelfTarget">Whether target is the caster.</param>
    public bool Matches(string abilityId, bool isSameTarget, bool isSelfTarget)
    {
        // Check ability ID
        if (!AbilityId.Equals(abilityId, StringComparison.OrdinalIgnoreCase))
            return false;

        // Check target requirement
        return TargetRequirement switch
        {
            ComboTargetRequirement.Any => true,
            ComboTargetRequirement.SameTarget => isSameTarget,
            ComboTargetRequirement.DifferentTarget => !isSameTarget,
            ComboTargetRequirement.Self => isSelfTarget,
            _ => true
        };
    }

    public override string ToString() => $"Step {StepNumber}: {AbilityId}";
}
```

---

## 6. ComboTargetRequirement Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/ComboTargetRequirement.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Target requirements for combo steps.
/// </summary>
public enum ComboTargetRequirement
{
    /// <summary>Any target is acceptable.</summary>
    Any,

    /// <summary>Must target the same entity as the previous step.</summary>
    SameTarget,

    /// <summary>Must target a different entity than the previous step.</summary>
    DifferentTarget,

    /// <summary>Must target the caster (self).</summary>
    Self
}
```

---

## 7. ComboBonusEffect Entity

**File:** `src/Core/RuneAndRust.Domain/Definitions/ComboBonusEffect.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// A bonus effect applied when a combo completes.
/// </summary>
public class ComboBonusEffect
{
    /// <summary>Type of bonus effect.</summary>
    public ComboBonusType EffectType { get; set; }

    /// <summary>Value for the effect (dice notation, multiplier, or ID).</summary>
    public string Value { get; set; } = null!;

    /// <summary>Damage type for damage effects.</summary>
    public string? DamageType { get; set; }

    /// <summary>Status effect ID for ApplyStatus type.</summary>
    public string? StatusEffectId { get; set; }

    /// <summary>Target for this bonus effect.</summary>
    public ComboBonusTarget Target { get; set; } = ComboBonusTarget.LastTarget;

    /// <summary>Gets a description of this effect.</summary>
    public string GetDescription()
    {
        return EffectType switch
        {
            ComboBonusType.ExtraDamage => $"+{Value} {DamageType ?? "physical"} damage",
            ComboBonusType.DamageMultiplier => $"Ã—{Value} damage",
            ComboBonusType.ApplyStatus => $"Apply {StatusEffectId}",
            ComboBonusType.Heal => $"Heal {Value}",
            ComboBonusType.ResetCooldown => $"Reset {Value} cooldown",
            ComboBonusType.RefundResource => $"Refund {Value} resource",
            ComboBonusType.AreaEffect => $"Expand to {Value} cell radius",
            _ => Value
        };
    }

    public override string ToString() => GetDescription();
}
```

---

## 8. ComboBonusType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/ComboBonusType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of combo bonus effects.
/// </summary>
public enum ComboBonusType
{
    /// <summary>Deal additional damage (dice notation).</summary>
    ExtraDamage,

    /// <summary>Multiply the final ability's damage.</summary>
    DamageMultiplier,

    /// <summary>Apply a status effect to the target.</summary>
    ApplyStatus,

    /// <summary>Heal the caster (dice notation).</summary>
    Heal,

    /// <summary>Reset a specific ability's cooldown.</summary>
    ResetCooldown,

    /// <summary>Refund resource cost of abilities used.</summary>
    RefundResource,

    /// <summary>Expand the final effect to an area.</summary>
    AreaEffect
}
```

---

## 9. ComboBonusTarget Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/ComboBonusTarget.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Targets for combo bonus effects.
/// </summary>
public enum ComboBonusTarget
{
    /// <summary>Apply to the target of the final ability.</summary>
    LastTarget,

    /// <summary>Apply to all targets hit during the combo.</summary>
    AllHitTargets,

    /// <summary>Apply to the caster.</summary>
    Self,

    /// <summary>Apply to an area around the final target.</summary>
    Area
}
```

---

## 10. IComboProvider Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IComboProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides combo definitions from configuration.
/// </summary>
public interface IComboProvider
{
    /// <summary>Gets a combo by ID.</summary>
    /// <param name="comboId">The combo identifier.</param>
    /// <returns>The combo definition, or null if not found.</returns>
    ComboDefinition? GetCombo(string comboId);

    /// <summary>Gets all combo definitions.</summary>
    IReadOnlyList<ComboDefinition> GetAllCombos();

    /// <summary>Gets combos available to a specific class.</summary>
    /// <param name="classId">The class identifier.</param>
    /// <returns>Combos available to that class.</returns>
    IReadOnlyList<ComboDefinition> GetCombosForClass(string classId);

    /// <summary>Gets combos that contain a specific ability.</summary>
    /// <param name="abilityId">The ability identifier.</param>
    /// <returns>Combos containing that ability.</returns>
    IReadOnlyList<ComboDefinition> GetCombosContaining(string abilityId);

    /// <summary>Gets combos that start with a specific ability.</summary>
    /// <param name="abilityId">The ability identifier.</param>
    /// <returns>Combos starting with that ability.</returns>
    IReadOnlyList<ComboDefinition> GetCombosStartingWith(string abilityId);
}
```

---

## 11. ComboProvider Implementation

**File:** `src/Core/RuneAndRust.Infrastructure/Providers/ComboProvider.cs`

```csharp
namespace RuneAndRust.Infrastructure.Providers;

public class ComboProvider : IComboProvider
{
    private readonly Dictionary<string, ComboDefinition> _combos;
    private readonly ILogger<ComboProvider> _logger;

    public ComboProvider(
        IConfigurationProvider configProvider,
        ILogger<ComboProvider> logger)
    {
        _logger = logger;
        _combos = new Dictionary<string, ComboDefinition>(StringComparer.OrdinalIgnoreCase);
        LoadCombos(configProvider);
    }

    private void LoadCombos(IConfigurationProvider configProvider)
    {
        var config = configProvider.GetSection<CombosConfig>("combos.json");

        foreach (var comboData in config.Combos)
        {
            var steps = comboData.Steps.Select(s => new ComboStep
            {
                StepNumber = s.StepNumber,
                AbilityId = s.AbilityId.ToLowerInvariant(),
                TargetRequirement = ParseTargetRequirement(s.TargetRequirement),
                CustomRequirement = s.CustomRequirement
            }).ToList();

            var bonusEffects = comboData.BonusEffects?.Select(b => new ComboBonusEffect
            {
                EffectType = Enum.Parse<ComboBonusType>(b.EffectType, ignoreCase: true),
                Value = b.Value,
                DamageType = b.DamageType,
                StatusEffectId = b.StatusEffectId,
                Target = ParseBonusTarget(b.Target)
            }).ToList() ?? [];

            var combo = ComboDefinition.Create(
                comboData.ComboId,
                comboData.Name,
                comboData.Description,
                comboData.WindowTurns,
                steps,
                bonusEffects,
                comboData.RequiredClassIds,
                comboData.Icon
            );

            _combos[combo.ComboId] = combo;
            _logger.LogDebug("Loaded combo: {Name} ({Steps} steps)", combo.Name, combo.StepCount);
        }

        _logger.LogInformation("Loaded {Count} combo definitions", _combos.Count);
    }

    private static ComboTargetRequirement ParseTargetRequirement(string? value)
    {
        if (string.IsNullOrEmpty(value)) return ComboTargetRequirement.Any;
        return Enum.TryParse<ComboTargetRequirement>(value, ignoreCase: true, out var result)
            ? result
            : ComboTargetRequirement.Any;
    }

    private static ComboBonusTarget ParseBonusTarget(string? value)
    {
        if (string.IsNullOrEmpty(value)) return ComboBonusTarget.LastTarget;
        return Enum.TryParse<ComboBonusTarget>(value, ignoreCase: true, out var result)
            ? result
            : ComboBonusTarget.LastTarget;
    }

    public ComboDefinition? GetCombo(string comboId)
    {
        return _combos.GetValueOrDefault(comboId.ToLowerInvariant());
    }

    public IReadOnlyList<ComboDefinition> GetAllCombos()
    {
        return _combos.Values.ToList();
    }

    public IReadOnlyList<ComboDefinition> GetCombosForClass(string classId)
    {
        return _combos.Values
            .Where(c => c.IsAvailableForClass(classId))
            .ToList();
    }

    public IReadOnlyList<ComboDefinition> GetCombosContaining(string abilityId)
    {
        return _combos.Values
            .Where(c => c.ContainsAbility(abilityId))
            .ToList();
    }

    public IReadOnlyList<ComboDefinition> GetCombosStartingWith(string abilityId)
    {
        return _combos.Values
            .Where(c => c.FirstAbilityId.Equals(abilityId, StringComparison.OrdinalIgnoreCase))
            .ToList();
    }
}
```

---

## 12. Configuration File

**File:** `config/combos.json`

```json
{
  "$schema": "./schemas/combos.schema.json",
  "combos": [
    {
      "comboId": "elemental-burst",
      "name": "Elemental Burst",
      "description": "Chain fire, ice, and lightning for explosive damage",
      "windowTurns": 3,
      "requiredClassIds": ["mage", "sorcerer"],
      "steps": [
        { "stepNumber": 1, "abilityId": "fire-bolt", "targetRequirement": "any" },
        { "stepNumber": 2, "abilityId": "ice-shard", "targetRequirement": "sameTarget" },
        { "stepNumber": 3, "abilityId": "lightning", "targetRequirement": "sameTarget" }
      ],
      "bonusEffects": [
        {
          "effectType": "DamageMultiplier",
          "value": "2.0",
          "target": "lastTarget"
        },
        {
          "effectType": "ApplyStatus",
          "statusEffectId": "elemental-overload",
          "value": "",
          "target": "lastTarget"
        }
      ],
      "icon": "icons/combos/elemental-burst.png"
    },
    {
      "comboId": "warriors-onslaught",
      "name": "Warrior's Onslaught",
      "description": "Charge in, strike hard, finish them",
      "windowTurns": 2,
      "requiredClassIds": ["warrior", "paladin"],
      "steps": [
        { "stepNumber": 1, "abilityId": "charge", "targetRequirement": "any" },
        { "stepNumber": 2, "abilityId": "power-strike", "targetRequirement": "sameTarget" },
        { "stepNumber": 3, "abilityId": "execute", "targetRequirement": "sameTarget" }
      ],
      "bonusEffects": [
        {
          "effectType": "ApplyStatus",
          "statusEffectId": "stunned",
          "value": "",
          "target": "lastTarget"
        },
        {
          "effectType": "ApplyStatus",
          "statusEffectId": "bleeding",
          "value": "",
          "target": "lastTarget"
        }
      ],
      "icon": "icons/combos/warriors-onslaught.png"
    },
    {
      "comboId": "assassins-dance",
      "name": "Assassin's Dance",
      "description": "Strike from shadow, vanish, strike again",
      "windowTurns": 2,
      "requiredClassIds": ["rogue", "assassin"],
      "steps": [
        { "stepNumber": 1, "abilityId": "backstab", "targetRequirement": "any" },
        { "stepNumber": 2, "abilityId": "vanish", "targetRequirement": "self" },
        { "stepNumber": 3, "abilityId": "ambush", "targetRequirement": "any" }
      ],
      "bonusEffects": [
        {
          "effectType": "ExtraDamage",
          "value": "4d6",
          "damageType": "piercing",
          "target": "lastTarget"
        },
        {
          "effectType": "ResetCooldown",
          "value": "vanish",
          "target": "self"
        }
      ],
      "icon": "icons/combos/assassins-dance.png"
    },
    {
      "comboId": "divine-judgment",
      "name": "Divine Judgment",
      "description": "Smite the wicked with holy power",
      "windowTurns": 3,
      "requiredClassIds": ["paladin", "cleric"],
      "steps": [
        { "stepNumber": 1, "abilityId": "smite", "targetRequirement": "any" },
        { "stepNumber": 2, "abilityId": "holy-light", "targetRequirement": "sameTarget" }
      ],
      "bonusEffects": [
        {
          "effectType": "AreaEffect",
          "value": "2",
          "target": "area"
        },
        {
          "effectType": "Heal",
          "value": "2d8",
          "target": "self"
        }
      ],
      "icon": "icons/combos/divine-judgment.png"
    }
  ]
}
```

---

## 13. Combo Examples Visualization

```
COMBO EXAMPLES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    ELEMENTAL BURST (Mage/Sorcerer)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Window: 3 turns
    
    Step 1          Step 2          Step 3
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ğŸ”¥Fire   â”‚ â†’ â”‚â„Ice     â”‚ â†’ â”‚âš¡Light  â”‚ = â”‚ BONUS!          â”‚
    â”‚  Bolt   â”‚    â”‚  Shard  â”‚    â”‚  ning   â”‚    â”‚ Ã—2 Damage       â”‚
    â”‚ (any)   â”‚    â”‚ (same)  â”‚    â”‚ (same)  â”‚    â”‚ + Overload      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ASSASSIN'S DANCE (Rogue/Assassin)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Window: 2 turns
    
    Step 1          Step 2          Step 3
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ğŸ—¡Backstabâ”‚ â†’ â”‚ğŸŒ«Vanish â”‚ â†’ â”‚ğŸ—¡Ambush â”‚ = â”‚ BONUS!          â”‚
    â”‚ (any)   â”‚    â”‚ (self)  â”‚    â”‚ (any)   â”‚    â”‚ +4d6 piercing   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ Reset Vanish CD â”‚
                                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    DIVINE JUDGMENT (Paladin/Cleric)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Window: 3 turns (only 2 steps)
    
    Step 1          Step 2
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚âš”Smite  â”‚ â†’ â”‚âœ¨Holy   â”‚ = â”‚ BONUS!          â”‚
    â”‚ (any)   â”‚    â”‚  Light  â”‚    â”‚ 2-cell AoE      â”‚
    â”‚         â”‚    â”‚ (same)  â”‚    â”‚ Heal self 2d8   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


TARGET REQUIREMENT EXAMPLES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Requirement        â”‚ Example                                    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ any                â”‚ Can target any enemy                       â”‚
    â”‚ sameTarget         â”‚ Must hit same enemy as previous step       â”‚
    â”‚ differentTarget    â”‚ Must hit different enemy                   â”‚
    â”‚ self               â”‚ Must target yourself (buffs, vanish)       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


BONUS EFFECT TYPES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Effect Type        â”‚ Value Format                               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ ExtraDamage        â”‚ "4d6" (dice notation)                      â”‚
    â”‚ DamageMultiplier   â”‚ "2.0" (multiplier)                         â”‚
    â”‚ ApplyStatus        â”‚ statusEffectId = "stunned"                 â”‚
    â”‚ Heal               â”‚ "2d8" (dice notation)                      â”‚
    â”‚ ResetCooldown      â”‚ "vanish" (ability ID)                      â”‚
    â”‚ RefundResource     â”‚ "50" (percentage or flat)                  â”‚
    â”‚ AreaEffect         â”‚ "2" (radius in cells)                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 14. Unit Testing Requirements (~12 tests)

| Feature | Tests |
|---------|-------|
| ComboDefinition.Create valid combo | 1 |
| ComboDefinition.Create fails with < 2 steps | 1 |
| StepCount returns correct count | 1 |
| GetAbilityForStep returns correct ability | 1 |
| ContainsAbility returns true when present | 1 |
| ContainsAbility returns false when missing | 1 |
| IsAvailableForClass with matching class | 1 |
| IsAvailableForClass with empty classes (all) | 1 |
| ComboStep.Matches checks ability ID | 1 |
| ComboStep.Matches checks target requirement | 1 |
| ComboProvider loads from config | 1 |
| GetCombosForClass filters correctly | 1 |

---

## 15. Acceptance Criteria

- [ ] ComboDefinition loads from JSON
- [ ] Combo requires at least 2 steps
- [ ] Steps define ability sequence correctly
- [ ] StepNumber orders steps properly
- [ ] WindowTurns specifies timing limit
- [ ] RequiredClassIds filter class availability
- [ ] Empty RequiredClassIds = all classes
- [ ] BonusEffects define rewards
- [ ] ExtraDamage with dice notation works
- [ ] DamageMultiplier with multiplier works
- [ ] ApplyStatus with status ID works
- [ ] Heal with dice notation works
- [ ] ResetCooldown with ability ID works
- [ ] Target requirement validation works
- [ ] ContainsAbility finds abilities
- [ ] GetCombosForClass filters correctly
- [ ] GetCombosStartingWith finds combos
- [ ] ~12 unit tests pass

---

## 16. Dependencies

| From | Required |
|------|----------|
| Domain | `IEntity`, ability system |
| Application | `IConfigurationProvider` |
| v0.10.0 | Status effects for ApplyStatus |

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
