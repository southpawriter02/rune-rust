# v0.0.6b Design Specification: Monster AI & Flee System

**Version:** 0.0.6b
**Parent:** v0.0.6 (Enhanced Combat System)
**Prerequisites:** v0.0.6a Complete (Multi-Monster Combat Foundation)
**Status:** Design Complete

---

## Table of Contents

1. [Overview](#overview)
2. [Scope](#scope)
3. [Data Model](#data-model)
4. [AI Behavior System](#ai-behavior-system)
5. [AI Decision Logic](#ai-decision-logic)
6. [Flee System](#flee-system)
7. [Combat Log](#combat-log)
8. [Command Changes](#command-changes)
9. [Rendering Changes](#rendering-changes)
10. [Configuration](#configuration)
11. [Acceptance Criteria](#acceptance-criteria)
12. [Test Specifications](#test-specifications)

---

## Overview

### Purpose

v0.0.6b adds intelligence to monster behavior through configurable AI patterns and provides players the ability to flee from combat using skill checks. This phase transforms monsters from predictable attackers into tactical opponents that make decisions based on combat state, their health, and (in future phases) their active status effects.

### Key Changes

| Area | Current State (v0.0.6a) | Target State (v0.0.6b) |
|------|-------------------------|------------------------|
| Monster actions | Always attack player | AI-driven decisions |
| Monster targeting | Player only | Priority-based targeting |
| Player escape | Not possible | Flee command with skill check |
| Combat history | None | Scrollable combat log |
| Monster behavior | Identical for all | Behavior type per monster |
| Decision visibility | Hidden | AI decisions displayed |

### Design Principles

1. **Behavioral Variety**: Different monster types should feel distinct in combat
2. **Predictable Rules**: AI follows consistent, learnable patterns
3. **Player Agency**: Flee provides meaningful tactical choice
4. **Extensibility**: AI system designed for future status effect integration (v0.0.6d)

---

## Scope

### In Scope

- `AIBehavior` enum with 5 behavior types
- `MonsterAIService` for decision-making
- `AIDecision` value object representing chosen action
- `AIContext` value object providing decision inputs
- `FleeCommand` with skill check resolution
- Flee success/failure consequences
- Combat log system with timestamped entries
- AI behavior configuration per monster type
- AI behavior modification hooks for status effects (infrastructure only)

### Out of Scope (Future Phases)

- Status effect application (v0.0.6c)
- AI behavior modification by status effects (v0.0.6d)
- Complex group tactics
- Pathfinding or positioning

---

## Data Model

### New: AIBehavior (Enum)

```csharp
/// <summary>
/// Defines the behavioral pattern for monster AI decision-making.
/// </summary>
public enum AIBehavior
{
    /// <summary>
    /// Always attacks, prioritizes lowest HP target.
    /// Uses strongest available ability.
    /// </summary>
    Aggressive,

    /// <summary>
    /// Attacks when HP > 50%, otherwise heals/defends.
    /// Balanced between offense and self-preservation.
    /// </summary>
    Defensive,

    /// <summary>
    /// Attempts to flee when HP < 30%.
    /// Otherwise attacks weakest target.
    /// </summary>
    Cowardly,

    /// <summary>
    /// Prioritizes healing and buffing allies.
    /// Only attacks when alone or no allies need help.
    /// </summary>
    Support,

    /// <summary>
    /// Unpredictable random actions.
    /// May attack, heal, or do nothing.
    /// </summary>
    Chaotic
}
```

### New: AIAction (Enum)

```csharp
/// <summary>
/// Represents the type of action an AI can take.
/// </summary>
public enum AIAction
{
    /// <summary>Attack a target.</summary>
    Attack,

    /// <summary>Defend, gaining damage reduction.</summary>
    Defend,

    /// <summary>Heal self or ally.</summary>
    Heal,

    /// <summary>Apply buff to self or ally.</summary>
    Buff,

    /// <summary>Attempt to flee combat.</summary>
    Flee,

    /// <summary>Do nothing (skip turn).</summary>
    Wait
}
```

### New: AIDecision (Value Object)

```csharp
/// <summary>
/// Represents a decision made by the monster AI.
/// </summary>
/// <param name="Action">The type of action to take.</param>
/// <param name="Target">The target of the action (if applicable).</param>
/// <param name="AbilityId">The ability to use (if applicable).</param>
/// <param name="Reasoning">Human-readable explanation of the decision.</param>
public readonly record struct AIDecision(
    AIAction Action,
    Combatant? Target,
    string? AbilityId,
    string Reasoning)
{
    /// <summary>
    /// Creates an attack decision.
    /// </summary>
    public static AIDecision Attack(Combatant target, string reasoning) =>
        new(AIAction.Attack, target, null, reasoning);

    /// <summary>
    /// Creates a defend decision.
    /// </summary>
    public static AIDecision Defend(string reasoning) =>
        new(AIAction.Defend, null, null, reasoning);

    /// <summary>
    /// Creates a heal decision.
    /// </summary>
    public static AIDecision Heal(Combatant target, string? abilityId, string reasoning) =>
        new(AIAction.Heal, target, abilityId, reasoning);

    /// <summary>
    /// Creates a flee decision.
    /// </summary>
    public static AIDecision Flee(string reasoning) =>
        new(AIAction.Flee, null, null, reasoning);

    /// <summary>
    /// Creates a wait decision.
    /// </summary>
    public static AIDecision Wait(string reasoning) =>
        new(AIAction.Wait, null, null, reasoning);
}
```

### New: AIContext (Value Object)

```csharp
/// <summary>
/// Provides context for AI decision-making.
/// </summary>
public readonly record struct AIContext(
    Combatant Self,
    CombatEncounter Encounter,
    IReadOnlyList<Combatant> Allies,
    IReadOnlyList<Combatant> Enemies,
    int RoundNumber)
{
    /// <summary>
    /// The monster's current health percentage (0.0 to 1.0).
    /// </summary>
    public float HealthPercentage => (float)Self.CurrentHealth / Self.MaxHealth;

    /// <summary>
    /// Whether the monster is below 50% health.
    /// </summary>
    public bool IsLowHealth => HealthPercentage < 0.5f;

    /// <summary>
    /// Whether the monster is below 30% health.
    /// </summary>
    public bool IsCriticalHealth => HealthPercentage < 0.3f;

    /// <summary>
    /// Whether there are any active allies.
    /// </summary>
    public bool HasAllies => Allies.Count > 0;

    /// <summary>
    /// Gets allies that are below 50% health.
    /// </summary>
    public IEnumerable<Combatant> WoundedAllies =>
        Allies.Where(a => (float)a.CurrentHealth / a.MaxHealth < 0.5f);

    /// <summary>
    /// Gets the enemy with the lowest current health.
    /// </summary>
    public Combatant? WeakestEnemy =>
        Enemies.OrderBy(e => e.CurrentHealth).FirstOrDefault();

    /// <summary>
    /// Gets the enemy with the highest current health.
    /// </summary>
    public Combatant? StrongestEnemy =>
        Enemies.OrderByDescending(e => e.CurrentHealth).FirstOrDefault();
}
```

### New: FleeAttemptResult (Value Object)

```csharp
/// <summary>
/// Result of an attempt to flee combat.
/// </summary>
/// <param name="Success">Whether the flee attempt succeeded.</param>
/// <param name="SkillCheck">The skill check result.</param>
/// <param name="DifficultyClass">The DC that had to be beaten.</param>
/// <param name="OpportunityAttacks">Attacks taken while fleeing (on failure).</param>
/// <param name="TotalDamageTaken">Total damage from opportunity attacks.</param>
/// <param name="DestinationRoomId">The room fled to (if successful).</param>
public readonly record struct FleeAttemptResult(
    bool Success,
    SkillCheckResult SkillCheck,
    int DifficultyClass,
    IReadOnlyList<OpportunityAttackResult> OpportunityAttacks,
    int TotalDamageTaken,
    Guid? DestinationRoomId)
{
    /// <summary>
    /// Creates a successful flee result.
    /// </summary>
    public static FleeAttemptResult Succeeded(
        SkillCheckResult check,
        int dc,
        Guid destinationRoomId) =>
        new(true, check, dc, Array.Empty<OpportunityAttackResult>(), 0, destinationRoomId);

    /// <summary>
    /// Creates a failed flee result.
    /// </summary>
    public static FleeAttemptResult Failed(
        SkillCheckResult check,
        int dc,
        IReadOnlyList<OpportunityAttackResult> attacks,
        int totalDamage) =>
        new(false, check, dc, attacks, totalDamage, null);
}

/// <summary>
/// Result of an opportunity attack during a flee attempt.
/// </summary>
public readonly record struct OpportunityAttackResult(
    string AttackerName,
    int Damage,
    bool Hit);
```

### New: CombatLogEntry (Entity)

```csharp
/// <summary>
/// A single entry in the combat log.
/// </summary>
public class CombatLogEntry
{
    /// <summary>Unique identifier for this entry.</summary>
    public Guid Id { get; private set; }

    /// <summary>Timestamp when the event occurred.</summary>
    public DateTime Timestamp { get; private set; }

    /// <summary>The round number when this occurred.</summary>
    public int RoundNumber { get; private set; }

    /// <summary>The type of log entry.</summary>
    public CombatLogType Type { get; private set; }

    /// <summary>The message to display.</summary>
    public string Message { get; private set; }

    /// <summary>The combatant who performed the action (if any).</summary>
    public string? ActorName { get; private set; }

    /// <summary>The target of the action (if any).</summary>
    public string? TargetName { get; private set; }

    /// <summary>Damage dealt (if applicable).</summary>
    public int? Damage { get; private set; }

    /// <summary>Healing done (if applicable).</summary>
    public int? Healing { get; private set; }

    /// <summary>Whether this was a critical hit/success.</summary>
    public bool IsCritical { get; private set; }

    /// <summary>Whether this was a miss/failure.</summary>
    public bool IsMiss { get; private set; }

    // Private constructor for EF Core
    private CombatLogEntry() { }

    /// <summary>
    /// Creates a combat log entry.
    /// </summary>
    public static CombatLogEntry Create(
        int roundNumber,
        CombatLogType type,
        string message,
        string? actorName = null,
        string? targetName = null,
        int? damage = null,
        int? healing = null,
        bool isCritical = false,
        bool isMiss = false)
    {
        return new CombatLogEntry
        {
            Id = Guid.NewGuid(),
            Timestamp = DateTime.UtcNow,
            RoundNumber = roundNumber,
            Type = type,
            Message = message,
            ActorName = actorName,
            TargetName = targetName,
            Damage = damage,
            Healing = healing,
            IsCritical = isCritical,
            IsMiss = isMiss
        };
    }
}

/// <summary>
/// Types of combat log entries.
/// </summary>
public enum CombatLogType
{
    /// <summary>Combat has started.</summary>
    CombatStart,

    /// <summary>A new round has begun.</summary>
    RoundStart,

    /// <summary>A combatant's turn has started.</summary>
    TurnStart,

    /// <summary>An attack was made.</summary>
    Attack,

    /// <summary>Damage was dealt.</summary>
    Damage,

    /// <summary>Healing was done.</summary>
    Heal,

    /// <summary>A combatant defended.</summary>
    Defend,

    /// <summary>A flee attempt was made.</summary>
    Flee,

    /// <summary>A combatant was defeated.</summary>
    Defeat,

    /// <summary>Combat has ended.</summary>
    CombatEnd,

    /// <summary>A status effect was applied.</summary>
    StatusApplied,

    /// <summary>A status effect expired.</summary>
    StatusExpired,

    /// <summary>AI decision made (for debugging).</summary>
    AIDecision
}
```

### Modified: CombatEncounter

```csharp
// Add to existing CombatEncounter:

/// <summary>
/// The combat log for this encounter.
/// </summary>
public IReadOnlyList<CombatLogEntry> CombatLog => _combatLog.AsReadOnly();
private readonly List<CombatLogEntry> _combatLog = new();

/// <summary>
/// Adds an entry to the combat log.
/// </summary>
public void AddLogEntry(CombatLogEntry entry)
{
    _combatLog.Add(entry);
}

/// <summary>
/// Gets the most recent log entries.
/// </summary>
/// <param name="count">Maximum number of entries to return.</param>
public IEnumerable<CombatLogEntry> GetRecentLogEntries(int count = 10) =>
    _combatLog.TakeLast(count);

/// <summary>
/// Gets log entries for a specific round.
/// </summary>
public IEnumerable<CombatLogEntry> GetLogEntriesForRound(int round) =>
    _combatLog.Where(e => e.RoundNumber == round);
```

### Modified: Monster

```csharp
// Add to existing Monster entity:

/// <summary>
/// The AI behavior pattern for this monster.
/// </summary>
public AIBehavior Behavior { get; private set; } = AIBehavior.Aggressive;

/// <summary>
/// Whether this monster can heal itself or allies.
/// </summary>
public bool CanHeal { get; private set; } = false;

/// <summary>
/// The heal amount if the monster can heal.
/// </summary>
public int? HealAmount { get; private set; }

/// <summary>
/// Sets the AI behavior for this monster.
/// </summary>
public void SetBehavior(AIBehavior behavior)
{
    Behavior = behavior;
}

// Update factory methods:
public static Monster CreateGoblin()
{
    return new Monster
    {
        Id = Guid.NewGuid(),
        Name = "Goblin",
        Description = "A small, green-skinned creature with sharp teeth.",
        Health = 30,
        MaxHealth = 30,
        Stats = new Stats(30, 8, 2),
        InitiativeModifier = 1,
        MonsterDefinitionId = "goblin",
        Behavior = AIBehavior.Cowardly // Goblins flee when hurt
    };
}

public static Monster CreateOrc()
{
    return new Monster
    {
        Id = Guid.NewGuid(),
        Name = "Orc",
        Description = "A brutish green-skinned warrior.",
        Health = 50,
        MaxHealth = 50,
        Stats = new Stats(50, 15, 3),
        InitiativeModifier = 0,
        MonsterDefinitionId = "orc",
        Behavior = AIBehavior.Aggressive // Orcs fight to the death
    };
}

public static Monster CreateGoblinShaman()
{
    return new Monster
    {
        Id = Guid.NewGuid(),
        Name = "Goblin Shaman",
        Description = "A goblin with crude magical abilities.",
        Health = 25,
        MaxHealth = 25,
        Stats = new Stats(25, 6, 1),
        InitiativeModifier = 2,
        MonsterDefinitionId = "goblin_shaman",
        Behavior = AIBehavior.Support,
        CanHeal = true,
        HealAmount = 10
    };
}
```

### Modified: Combatant

```csharp
// Add to existing Combatant:

/// <summary>
/// The AI behavior of this combatant (for monsters).
/// </summary>
public AIBehavior? Behavior => Monster?.Behavior;

/// <summary>
/// Whether this combatant can heal.
/// </summary>
public bool CanHeal => Monster?.CanHeal ?? false;

/// <summary>
/// The heal amount for this combatant.
/// </summary>
public int? HealAmount => Monster?.HealAmount;

/// <summary>
/// Whether this combatant is defending (damage reduction active).
/// </summary>
public bool IsDefending { get; private set; }

/// <summary>
/// Sets the defending state.
/// </summary>
public void SetDefending(bool defending)
{
    IsDefending = defending;
}
```

---

## AI Behavior System

### MonsterAIService

```csharp
/// <summary>
/// Service for making AI decisions for monsters during combat.
/// </summary>
public class MonsterAIService
{
    private readonly ILogger<MonsterAIService> _logger;
    private readonly Random _random;

    public MonsterAIService(ILogger<MonsterAIService> logger, Random? random = null)
    {
        _logger = logger;
        _random = random ?? new Random();
    }

    /// <summary>
    /// Determines the action a monster should take.
    /// </summary>
    /// <param name="context">The AI decision context.</param>
    /// <returns>The decided action.</returns>
    public AIDecision DecideAction(AIContext context)
    {
        var behavior = context.Self.Behavior ?? AIBehavior.Aggressive;

        _logger.LogDebug(
            "AI deciding for {Monster} with behavior {Behavior}, HP: {HP}%",
            context.Self.DisplayName,
            behavior,
            context.HealthPercentage * 100);

        var decision = behavior switch
        {
            AIBehavior.Aggressive => DecideAggressive(context),
            AIBehavior.Defensive => DecideDefensive(context),
            AIBehavior.Cowardly => DecideCowardly(context),
            AIBehavior.Support => DecideSupport(context),
            AIBehavior.Chaotic => DecideChaotic(context),
            _ => DecideAggressive(context)
        };

        _logger.LogInformation(
            "AI {Monster} decided: {Action} - {Reasoning}",
            context.Self.DisplayName,
            decision.Action,
            decision.Reasoning);

        return decision;
    }

    private AIDecision DecideAggressive(AIContext context)
    {
        // Always attack, target lowest HP enemy
        var target = context.WeakestEnemy;

        if (target == null)
            return AIDecision.Wait("No targets available");

        return AIDecision.Attack(target,
            $"Aggressively targeting weakest enemy ({target.DisplayName})");
    }

    private AIDecision DecideDefensive(AIContext context)
    {
        // If health > 50%, attack normally
        if (!context.IsLowHealth)
        {
            var target = context.StrongestEnemy ?? context.WeakestEnemy;
            if (target != null)
                return AIDecision.Attack(target, "Health good, attacking");
        }

        // If can heal and low health, heal self
        if (context.Self.CanHeal)
        {
            return AIDecision.Heal(context.Self, null,
                "Low health, healing self");
        }

        // Otherwise defend
        return AIDecision.Defend("Low health, taking defensive stance");
    }

    private AIDecision DecideCowardly(AIContext context)
    {
        // If health < 30%, try to flee (50% chance)
        if (context.IsCriticalHealth && _random.NextDouble() < 0.5)
        {
            return AIDecision.Flee("Critically wounded, attempting to flee");
        }

        // Otherwise attack weakest target
        var target = context.WeakestEnemy;
        if (target != null)
            return AIDecision.Attack(target, "Attacking weakest target");

        return AIDecision.Wait("No targets available");
    }

    private AIDecision DecideSupport(AIContext context)
    {
        // Priority 1: Heal wounded allies
        if (context.Self.CanHeal)
        {
            var woundedAlly = context.WoundedAllies.FirstOrDefault();
            if (woundedAlly != null)
            {
                return AIDecision.Heal(woundedAlly, null,
                    $"Healing wounded ally {woundedAlly.DisplayName}");
            }

            // Heal self if low
            if (context.IsLowHealth)
            {
                return AIDecision.Heal(context.Self, null, "Healing self");
            }
        }

        // Priority 2: Attack if no one needs healing
        var target = context.StrongestEnemy;
        if (target != null)
            return AIDecision.Attack(target, "No healing needed, attacking");

        return AIDecision.Wait("Waiting for opportunity");
    }

    private AIDecision DecideChaotic(AIContext context)
    {
        var roll = _random.NextDouble();

        // 50% chance to attack
        if (roll < 0.5)
        {
            var target = context.Enemies.ElementAtOrDefault(
                _random.Next(context.Enemies.Count));
            if (target != null)
                return AIDecision.Attack(target, "Chaotic attack!");
        }

        // 20% chance to defend
        if (roll < 0.7)
            return AIDecision.Defend("Chaotic defense!");

        // 15% chance to heal if able
        if (roll < 0.85 && context.Self.CanHeal)
            return AIDecision.Heal(context.Self, null, "Chaotic healing!");

        // 15% chance to do nothing
        return AIDecision.Wait("Chaotically doing nothing!");
    }
}
```

### AI Decision Flow

```
MONSTER'S TURN
│
├─► Get AIContext (self, encounter, allies, enemies)
│
├─► Check for status effect overrides (v0.0.6d)
│   ├─► Feared → Force flee attempt
│   ├─► Stunned → Skip turn
│   └─► Silenced → Remove ability options
│
├─► Call MonsterAIService.DecideAction()
│   │
│   ├─► AGGRESSIVE
│   │   └─► Attack lowest HP enemy
│   │
│   ├─► DEFENSIVE
│   │   ├─► HP > 50%: Attack strongest enemy
│   │   ├─► HP < 50% & Can Heal: Heal self
│   │   └─► HP < 50% & No Heal: Defend
│   │
│   ├─► COWARDLY
│   │   ├─► HP < 30%: 50% flee, 50% attack
│   │   └─► HP >= 30%: Attack weakest enemy
│   │
│   ├─► SUPPORT
│   │   ├─► Ally < 50% HP & Can Heal: Heal ally
│   │   ├─► Self < 50% HP & Can Heal: Heal self
│   │   └─► Else: Attack
│   │
│   └─► CHAOTIC
│       └─► Random action selection
│
├─► Execute decided action
│
├─► Log action to combat log
│
└─► Advance turn
```

---

## AI Decision Logic

### Decision Priority Table

| Behavior | Priority 1 | Priority 2 | Priority 3 |
|----------|------------|------------|------------|
| Aggressive | Attack weakest | - | - |
| Defensive | Heal self (low HP) | Defend (low HP) | Attack |
| Cowardly | Flee (critical HP) | Attack weakest | - |
| Support | Heal wounded ally | Heal self | Attack |
| Chaotic | Random | Random | Random |

### Target Selection Logic

```csharp
/// <summary>
/// Selects a target based on behavior and available enemies.
/// </summary>
public class TargetSelectionStrategy
{
    /// <summary>
    /// Gets the preferred target for the given behavior.
    /// </summary>
    public static Combatant? GetPreferredTarget(
        AIBehavior behavior,
        IReadOnlyList<Combatant> enemies)
    {
        if (enemies.Count == 0) return null;

        return behavior switch
        {
            // Aggressive/Cowardly: Target weakest (lowest current HP)
            AIBehavior.Aggressive or AIBehavior.Cowardly =>
                enemies.OrderBy(e => e.CurrentHealth).First(),

            // Defensive/Support: Target strongest (highest current HP)
            AIBehavior.Defensive or AIBehavior.Support =>
                enemies.OrderByDescending(e => e.CurrentHealth).First(),

            // Chaotic: Random target
            AIBehavior.Chaotic =>
                enemies[Random.Shared.Next(enemies.Count)],

            _ => enemies.First()
        };
    }
}
```

---

## Flee System

### FleeService

```csharp
/// <summary>
/// Service for handling flee attempts in combat.
/// </summary>
public class FleeService
{
    private readonly ISkillCheckService _skillCheckService;
    private readonly ICombatService _combatService;
    private readonly ILogger<FleeService> _logger;

    /// <summary>
    /// Base difficulty class for fleeing.
    /// </summary>
    public const int BaseFleeDC = 12;

    /// <summary>
    /// Additional DC per enemy in combat.
    /// </summary>
    public const int DCPerEnemy = 2;

    /// <summary>
    /// Damage multiplier for opportunity attacks.
    /// </summary>
    public const float OpportunityAttackDamageMultiplier = 0.5f;

    public FleeService(
        ISkillCheckService skillCheckService,
        ICombatService combatService,
        ILogger<FleeService> logger)
    {
        _skillCheckService = skillCheckService;
        _combatService = combatService;
        _logger = logger;
    }

    /// <summary>
    /// Attempts to flee from combat.
    /// </summary>
    /// <param name="combatant">The combatant attempting to flee.</param>
    /// <param name="encounter">The current combat encounter.</param>
    /// <returns>The result of the flee attempt.</returns>
    public FleeAttemptResult AttemptFlee(Combatant combatant, CombatEncounter encounter)
    {
        // Cannot flee if no previous room
        if (encounter.PreviousRoomId == null)
        {
            _logger.LogWarning("Flee attempt failed: No previous room");
            throw new InvalidOperationException("Cannot flee - no escape route.");
        }

        var enemies = encounter.GetActiveMonsters().ToList();
        var dc = CalculateFleeDC(enemies.Count);

        _logger.LogDebug(
            "Flee attempt: DC {DC} ({Base} + {Enemies} enemies x {PerEnemy})",
            dc, BaseFleeDC, enemies.Count, DCPerEnemy);

        // Roll flee check (uses Finesse)
        var check = _skillCheckService.PerformCheck(
            "flee",
            combatant.Finesse,
            dc);

        if (check.IsSuccess)
        {
            _logger.LogInformation(
                "{Combatant} successfully fled combat (rolled {Roll} vs DC {DC})",
                combatant.DisplayName, check.Total, dc);

            return FleeAttemptResult.Succeeded(
                check,
                dc,
                encounter.PreviousRoomId.Value);
        }

        // Failed flee - take opportunity attacks
        var opportunityAttacks = new List<OpportunityAttackResult>();
        var totalDamage = 0;

        foreach (var enemy in enemies)
        {
            var attackResult = ResolveOpportunityAttack(enemy, combatant);
            opportunityAttacks.Add(attackResult);
            if (attackResult.Hit)
                totalDamage += attackResult.Damage;
        }

        _logger.LogInformation(
            "{Combatant} failed to flee (rolled {Roll} vs DC {DC}), took {Damage} damage",
            combatant.DisplayName, check.Total, dc, totalDamage);

        return FleeAttemptResult.Failed(check, dc, opportunityAttacks, totalDamage);
    }

    /// <summary>
    /// Calculates the difficulty class for fleeing.
    /// </summary>
    public int CalculateFleeDC(int enemyCount)
    {
        return BaseFleeDC + (enemyCount * DCPerEnemy);
    }

    private OpportunityAttackResult ResolveOpportunityAttack(
        Combatant attacker,
        Combatant target)
    {
        // Simplified attack - always hits, half damage
        var baseDamage = attacker.Monster?.Stats.Attack ?? 5;
        var damage = (int)(baseDamage * OpportunityAttackDamageMultiplier);

        return new OpportunityAttackResult(
            attacker.DisplayName,
            damage,
            Hit: true);
    }
}
```

### Flee Flow

```
PLAYER USES 'FLEE' COMMAND
│
├─► Validate: Is player in combat?
│   └─► No: "You're not in combat."
│
├─► Validate: Is there an escape route?
│   └─► No: "There's nowhere to run!"
│
├─► Calculate DC
│   └─► DC = 12 + (2 × number of enemies)
│
├─► Roll: 1d10 + Finesse vs DC
│
├─► SUCCESS
│   ├─► Display: "You disengage and flee!"
│   ├─► End combat (state = Fled)
│   ├─► Move player to previous room
│   └─► Monsters remain in original room
│
└─► FAILURE
    ├─► Display: "You fail to escape!"
    ├─► Each enemy gets opportunity attack
    │   └─► Deals 50% of normal damage
    ├─► Display damage taken
    └─► Player's turn is consumed
```

### Flee DC Table

| Enemies | DC | Success Rate (Finesse 5) | Success Rate (Finesse 10) |
|---------|------|--------------------------|---------------------------|
| 1 | 14 | 45% | 65% |
| 2 | 16 | 35% | 55% |
| 3 | 18 | 25% | 45% |
| 4 | 20 | 15% | 35% |
| 5 | 22 | 5% | 25% |

---

## Combat Log

### CombatLogService

```csharp
/// <summary>
/// Service for managing combat log entries.
/// </summary>
public class CombatLogService
{
    private readonly ILogger<CombatLogService> _logger;

    public CombatLogService(ILogger<CombatLogService> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Logs a combat start event.
    /// </summary>
    public CombatLogEntry LogCombatStart(CombatEncounter encounter, int monsterCount)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.CombatStart,
            $"Combat begins with {monsterCount} enemies!");

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs a round start event.
    /// </summary>
    public CombatLogEntry LogRoundStart(CombatEncounter encounter)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.RoundStart,
            $"─── Round {encounter.RoundNumber} ───");

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs an attack action.
    /// </summary>
    public CombatLogEntry LogAttack(
        CombatEncounter encounter,
        string attackerName,
        string targetName,
        int damage,
        bool isCritical,
        bool isMiss)
    {
        string message;
        if (isMiss)
            message = $"{attackerName} attacks {targetName} but misses!";
        else if (isCritical)
            message = $"{attackerName} critically hits {targetName} for {damage} damage!";
        else
            message = $"{attackerName} attacks {targetName} for {damage} damage.";

        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Attack,
            message,
            attackerName,
            targetName,
            damage,
            isCritical: isCritical,
            isMiss: isMiss);

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs a heal action.
    /// </summary>
    public CombatLogEntry LogHeal(
        CombatEncounter encounter,
        string healerName,
        string targetName,
        int healing)
    {
        var isSelfHeal = healerName == targetName;
        var message = isSelfHeal
            ? $"{healerName} heals for {healing} HP."
            : $"{healerName} heals {targetName} for {healing} HP.";

        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Heal,
            message,
            healerName,
            targetName,
            healing: healing);

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs a defend action.
    /// </summary>
    public CombatLogEntry LogDefend(
        CombatEncounter encounter,
        string defenderName)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Defend,
            $"{defenderName} takes a defensive stance.",
            defenderName);

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs a flee attempt.
    /// </summary>
    public CombatLogEntry LogFleeAttempt(
        CombatEncounter encounter,
        string combatantName,
        FleeAttemptResult result)
    {
        string message;
        if (result.Success)
        {
            message = $"{combatantName} successfully flees combat!";
        }
        else
        {
            var damage = result.TotalDamageTaken;
            message = damage > 0
                ? $"{combatantName} fails to flee and takes {damage} damage!"
                : $"{combatantName} fails to flee!";
        }

        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Flee,
            message,
            combatantName,
            damage: result.TotalDamageTaken);

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs a defeat event.
    /// </summary>
    public CombatLogEntry LogDefeat(
        CombatEncounter encounter,
        string defeatedName)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Defeat,
            $"{defeatedName} has been defeated!",
            targetName: defeatedName);

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs an AI decision (for debugging/display).
    /// </summary>
    public CombatLogEntry LogAIDecision(
        CombatEncounter encounter,
        string monsterName,
        AIDecision decision)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.AIDecision,
            $"[AI] {monsterName}: {decision.Reasoning}",
            monsterName);

        encounter.AddLogEntry(entry);
        return entry;
    }
}
```

---

## Command Changes

### New: FleeCommand

```csharp
/// <summary>
/// Command to attempt fleeing from combat.
/// </summary>
public record FleeCommand : GameCommand;
```

### Command Parsing Updates

```csharp
// In ConsoleInputHandler.ParseCommand():

"flee" or "run" or "escape" => new FleeCommand(),
```

### GameSessionService Updates

```csharp
/// <summary>
/// Attempts to flee from combat.
/// </summary>
/// <returns>Result of the flee attempt.</returns>
public FleeResult TryFlee()
{
    if (_currentSession == null)
        return FleeResult.Failure("No active game session.");

    if (!_currentSession.IsInCombat)
        return FleeResult.Failure("You're not in combat.");

    var encounter = _currentSession.ActiveEncounter!;

    // Check if player's turn
    if (!encounter.CurrentCombatant?.IsPlayer ?? true)
        return FleeResult.Failure("It's not your turn.");

    // Check for escape route
    if (encounter.PreviousRoomId == null)
        return FleeResult.Failure("There's nowhere to run!");

    // Attempt flee
    var playerCombatant = encounter.Combatants.First(c => c.IsPlayer);
    var result = _fleeService.AttemptFlee(playerCombatant, encounter);

    // Log the attempt
    _combatLogService.LogFleeAttempt(encounter, playerCombatant.DisplayName, result);

    if (result.Success)
    {
        // End combat
        encounter.EndByFlee();
        _currentSession.EndCombat();

        // Move player to previous room
        _currentSession.ForceMoveTo(result.DestinationRoomId!.Value);

        return FleeResult.Success(result);
    }
    else
    {
        // Apply damage from opportunity attacks
        foreach (var attack in result.OpportunityAttacks)
        {
            if (attack.Hit)
                _currentSession.Player.TakeDamage(attack.Damage);
        }

        // Check if player died
        if (_currentSession.Player.IsDead)
        {
            encounter.CheckForResolution();
            _currentSession.SetState(GameState.GameOver);
            return FleeResult.PlayerDied(result);
        }

        // Advance turn
        encounter.AdvanceTurn();

        return FleeResult.Failed(result);
    }
}

/// <summary>
/// Executes the monster AI's turn.
/// </summary>
private void ExecuteMonsterTurn(Combatant monster, CombatEncounter encounter)
{
    // Build AI context
    var allies = encounter.Combatants
        .Where(c => c.IsMonster && c.IsActive && c.Id != monster.Id)
        .ToList();
    var enemies = encounter.Combatants
        .Where(c => c.IsPlayer && c.IsActive)
        .ToList();

    var context = new AIContext(
        monster,
        encounter,
        allies,
        enemies,
        encounter.RoundNumber);

    // Get AI decision
    var decision = _monsterAIService.DecideAction(context);

    // Log decision
    _combatLogService.LogAIDecision(encounter, monster.DisplayName, decision);

    // Execute decision
    ExecuteAIDecision(monster, decision, encounter);

    // Advance turn
    encounter.AdvanceTurn();
}

private void ExecuteAIDecision(
    Combatant monster,
    AIDecision decision,
    CombatEncounter encounter)
{
    switch (decision.Action)
    {
        case AIAction.Attack when decision.Target != null:
            var attackResult = _combatService.ResolveAttack(
                monster.Monster!,
                decision.Target.Player!);
            _combatLogService.LogAttack(
                encounter,
                monster.DisplayName,
                decision.Target.DisplayName,
                attackResult.Damage,
                attackResult.IsCritical,
                attackResult.IsMiss);
            break;

        case AIAction.Defend:
            monster.SetDefending(true);
            _combatLogService.LogDefend(encounter, monster.DisplayName);
            break;

        case AIAction.Heal when decision.Target != null:
            var healAmount = monster.HealAmount ?? 0;
            decision.Target.Monster?.Heal(healAmount);
            _combatLogService.LogHeal(
                encounter,
                monster.DisplayName,
                decision.Target.DisplayName,
                healAmount);
            break;

        case AIAction.Flee:
            // Monster attempts to flee
            HandleMonsterFlee(monster, encounter);
            break;

        case AIAction.Wait:
            // Do nothing
            break;
    }
}
```

### FleeResult

```csharp
/// <summary>
/// Result of a flee command.
/// </summary>
public record FleeResult(
    bool Success,
    string Message,
    FleeAttemptResult? AttemptResult = null,
    bool PlayerDied = false)
{
    public static FleeResult Failure(string message) =>
        new(false, message);

    public static FleeResult Success(FleeAttemptResult result) =>
        new(true, "You successfully flee!", result);

    public static FleeResult Failed(FleeAttemptResult result) =>
        new(false, "You fail to escape!", result);

    public static FleeResult PlayerDied(FleeAttemptResult result) =>
        new(false, "You were struck down while fleeing!", result, PlayerDied: true);
}
```

---

## Rendering Changes

### IGameRenderer Additions

```csharp
/// <summary>
/// Renders the combat log.
/// </summary>
/// <param name="entries">Recent log entries to display.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatLogAsync(IReadOnlyList<CombatLogEntryDto> entries, CancellationToken ct = default);

/// <summary>
/// Renders a monster's AI decision.
/// </summary>
/// <param name="monsterName">Name of the monster.</param>
/// <param name="decision">The decision made.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderMonsterActionAsync(string monsterName, AIDecisionDto decision, CancellationToken ct = default);

/// <summary>
/// Renders a flee attempt result.
/// </summary>
/// <param name="result">The flee attempt result.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderFleeAttemptAsync(FleeAttemptResultDto result, CancellationToken ct = default);
```

### DTOs

```csharp
/// <summary>
/// Combat log entry for display.
/// </summary>
public record CombatLogEntryDto(
    DateTime Timestamp,
    int RoundNumber,
    string Type,
    string Message,
    bool IsCritical,
    bool IsMiss);

/// <summary>
/// AI decision for display.
/// </summary>
public record AIDecisionDto(
    string Action,
    string? TargetName,
    string Reasoning);

/// <summary>
/// Flee attempt result for display.
/// </summary>
public record FleeAttemptResultDto(
    bool Success,
    int RollValue,
    int Modifier,
    int Total,
    int DifficultyClass,
    IReadOnlyList<string> OpportunityAttackMessages,
    int TotalDamageTaken);
```

### SpectreGameRenderer Implementation

```csharp
public Task RenderCombatLogAsync(
    IReadOnlyList<CombatLogEntryDto> entries,
    CancellationToken ct = default)
{
    var panel = new Panel(BuildCombatLogText(entries))
        .Header("[grey]Combat Log[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(Color.Grey);

    AnsiConsole.Write(panel);
    return Task.CompletedTask;
}

private string BuildCombatLogText(IReadOnlyList<CombatLogEntryDto> entries)
{
    var lines = new List<string>();

    foreach (var entry in entries)
    {
        var timestamp = entry.Timestamp.ToString("HH:mm:ss");
        var color = GetLogEntryColor(entry);
        var message = entry.Message;

        if (entry.IsCritical)
            message = $"[yellow bold]{message}[/]";
        else if (entry.IsMiss)
            message = $"[grey]{message}[/]";

        lines.Add($"[grey][[{timestamp}]][/] [{color}]{message}[/]");
    }

    return string.Join("\n", lines);
}

private string GetLogEntryColor(CombatLogEntryDto entry)
{
    return entry.Type switch
    {
        "Attack" => "red",
        "Damage" => "red",
        "Heal" => "green",
        "Defend" => "blue",
        "Flee" => "yellow",
        "Defeat" => "red bold",
        "RoundStart" => "cyan",
        _ => "white"
    };
}

public Task RenderMonsterActionAsync(
    string monsterName,
    AIDecisionDto decision,
    CancellationToken ct = default)
{
    var actionColor = decision.Action switch
    {
        "Attack" => "red",
        "Heal" => "green",
        "Defend" => "blue",
        "Flee" => "yellow",
        _ => "white"
    };

    AnsiConsole.MarkupLine(
        $"\n[{actionColor}]{monsterName}'s turn:[/] {decision.Reasoning}");

    if (decision.TargetName != null)
        AnsiConsole.MarkupLine($"  Target: [cyan]{decision.TargetName}[/]");

    return Task.CompletedTask;
}

public Task RenderFleeAttemptAsync(
    FleeAttemptResultDto result,
    CancellationToken ct = default)
{
    var table = new Table()
        .Border(TableBorder.Rounded)
        .AddColumn("Flee Attempt")
        .AddColumn("Result");

    var modStr = result.Modifier >= 0 ? $"+{result.Modifier}" : result.Modifier.ToString();
    table.AddRow("Roll", $"[{result.RollValue}] {modStr} = {result.Total}");
    table.AddRow("DC", result.DifficultyClass.ToString());

    var resultColor = result.Success ? "green" : "red";
    var resultText = result.Success ? "SUCCESS!" : "FAILED!";
    table.AddRow("Result", $"[{resultColor} bold]{resultText}[/]");

    AnsiConsole.Write(table);

    if (!result.Success && result.OpportunityAttackMessages.Count > 0)
    {
        AnsiConsole.MarkupLine("\n[yellow]Opportunity Attacks:[/]");
        foreach (var msg in result.OpportunityAttackMessages)
        {
            AnsiConsole.MarkupLine($"  [red]• {msg}[/]");
        }
        AnsiConsole.MarkupLine($"\n[red]Total damage taken: {result.TotalDamageTaken}[/]");
    }

    return Task.CompletedTask;
}
```

### Combat Log Display

```
┌─ Combat Log ─────────────────────────────────────────────┐
│ [17:32:10] ─── Round 3 ───                               │
│ [17:32:11] You attack Goblin 1 for 12 damage             │
│ [17:32:11] Goblin 1 has been defeated!                   │
│ [17:32:12] Goblin Shaman heals Goblin 2 for 10 HP        │
│ [17:32:13] Goblin 2 attacks you for 5 damage             │
│ [17:32:14] You are now at 45/60 HP                       │
└──────────────────────────────────────────────────────────┘
```

---

## Configuration

### ai-behaviors.json

```json
{
  "aiBehaviors": {
    "aggressive": {
      "description": "Always attacks, prioritizes lowest HP target",
      "attackPriority": "lowestHealth",
      "fleeThreshold": 0,
      "healThreshold": 0
    },
    "defensive": {
      "description": "Attacks when healthy, heals/defends when low",
      "attackPriority": "highestHealth",
      "fleeThreshold": 0,
      "healThreshold": 0.5,
      "defendThreshold": 0.5
    },
    "cowardly": {
      "description": "Flees when hurt, attacks weakest otherwise",
      "attackPriority": "lowestHealth",
      "fleeThreshold": 0.3,
      "fleeChance": 0.5
    },
    "support": {
      "description": "Prioritizes healing allies over attacking",
      "attackPriority": "highestHealth",
      "healAllyThreshold": 0.5,
      "healSelfThreshold": 0.5
    },
    "chaotic": {
      "description": "Random unpredictable actions",
      "attackChance": 0.5,
      "defendChance": 0.2,
      "healChance": 0.15,
      "waitChance": 0.15
    }
  },
  "flee": {
    "baseDC": 12,
    "perEnemyDC": 2,
    "opportunityAttackDamageMultiplier": 0.5,
    "skillUsed": "finesse"
  }
}
```

### monsters.json (Updated)

```json
{
  "monsters": {
    "goblin": {
      "name": "Goblin",
      "description": "A small, green-skinned creature with sharp teeth.",
      "health": 30,
      "attack": 8,
      "defense": 2,
      "initiativeModifier": 1,
      "behavior": "cowardly"
    },
    "orc": {
      "name": "Orc",
      "description": "A brutish green-skinned warrior.",
      "health": 50,
      "attack": 15,
      "defense": 3,
      "initiativeModifier": 0,
      "behavior": "aggressive"
    },
    "goblin_shaman": {
      "name": "Goblin Shaman",
      "description": "A goblin with crude magical abilities.",
      "health": 25,
      "attack": 6,
      "defense": 1,
      "initiativeModifier": 2,
      "behavior": "support",
      "canHeal": true,
      "healAmount": 10
    },
    "skeleton": {
      "name": "Skeleton",
      "description": "An animated pile of bones.",
      "health": 20,
      "attack": 10,
      "defense": 0,
      "initiativeModifier": -1,
      "behavior": "aggressive"
    },
    "slime": {
      "name": "Slime",
      "description": "A gelatinous blob.",
      "health": 40,
      "attack": 5,
      "defense": 5,
      "initiativeModifier": -2,
      "behavior": "chaotic"
    }
  }
}
```

---

## Acceptance Criteria

### AI Behavior System
- [ ] Monsters have configurable AI behavior types
- [ ] Aggressive monsters always attack lowest HP enemy
- [ ] Defensive monsters heal when below 50% HP
- [ ] Defensive monsters defend when low HP and can't heal
- [ ] Cowardly monsters attempt flee when below 30% HP
- [ ] Support monsters prioritize healing wounded allies
- [ ] Chaotic monsters take random actions
- [ ] AI decisions are logged to combat log

### Flee System
- [ ] `flee` command initiates escape attempt
- [ ] `run` and `escape` also work as aliases
- [ ] Flee DC = 12 + (2 × enemy count)
- [ ] Flee uses Finesse for the skill check
- [ ] Successful flee moves player to previous room
- [ ] Successful flee ends combat
- [ ] Failed flee triggers opportunity attacks
- [ ] Opportunity attacks deal 50% damage
- [ ] Failed flee consumes player's turn
- [ ] Cannot flee if no previous room exists

### Combat Log
- [ ] Combat log records all actions
- [ ] Entries include timestamp and round number
- [ ] Attack entries show damage and critical/miss
- [ ] Heal entries show amount healed
- [ ] Defeat entries logged
- [ ] AI decisions logged (optional display)
- [ ] Most recent entries displayed
- [ ] Round separators visible

### Monster Behavior
- [ ] Goblins use Cowardly behavior
- [ ] Orcs use Aggressive behavior
- [ ] Goblin Shamans use Support behavior
- [ ] Support monsters can heal allies
- [ ] Monsters with healing prioritize wounded allies

---

## Test Specifications

### Unit Tests (~18 tests)

#### MonsterAIServiceTests.cs

```csharp
[TestFixture]
public class MonsterAIServiceTests
{
    [Test]
    public void DecideAction_Aggressive_AttacksWeakestEnemy();

    [Test]
    public void DecideAction_Aggressive_NoEnemies_ReturnsWait();

    [Test]
    public void DecideAction_Defensive_HighHealth_Attacks();

    [Test]
    public void DecideAction_Defensive_LowHealth_CanHeal_Heals();

    [Test]
    public void DecideAction_Defensive_LowHealth_NoHeal_Defends();

    [Test]
    public void DecideAction_Cowardly_CriticalHealth_Flees();

    [Test]
    public void DecideAction_Cowardly_HealthyEnough_Attacks();

    [Test]
    public void DecideAction_Support_WoundedAlly_HealsAlly();

    [Test]
    public void DecideAction_Support_NoWoundedAllies_Attacks();

    [Test]
    public void DecideAction_Chaotic_ProducesRandomActions();
}
```

#### FleeServiceTests.cs

```csharp
[TestFixture]
public class FleeServiceTests
{
    [Test]
    public void CalculateFleeDC_OneEnemy_Returns14();

    [Test]
    public void CalculateFleeDC_ThreeEnemies_Returns18();

    [Test]
    public void AttemptFlee_Success_ReturnsSuccessResult();

    [Test]
    public void AttemptFlee_Failure_ReturnsOpportunityAttacks();

    [Test]
    public void AttemptFlee_NoPreviousRoom_ThrowsException();

    [Test]
    public void AttemptFlee_Failure_AppliesHalfDamage();
}
```

#### CombatLogServiceTests.cs

```csharp
[TestFixture]
public class CombatLogServiceTests
{
    [Test]
    public void LogAttack_CreatesCorrectEntry();

    [Test]
    public void LogAttack_CriticalHit_MarksEntry();

    [Test]
    public void LogHeal_CreatesCorrectEntry();

    [Test]
    public void LogFleeAttempt_Success_CreatesCorrectMessage();

    [Test]
    public void LogFleeAttempt_Failure_IncludesDamage();

    [Test]
    public void LogDefeat_CreatesCorrectEntry();
}
```

---

## Dependencies

### Required from v0.0.6a
- `CombatEncounter` - For combat context
- `Combatant` - For combatant information
- Initiative system - For turn order
- Turn management - For action timing
- `TargetResolver` - For target validation

### Required from v0.0.5
- `ISkillCheckService` - For flee skill checks
- `ICombatService` - For attack resolution
- `IDiceService` - For AI random decisions

### Provides to v0.0.6c/d
- `AIContext` - For status effect AI modifications
- `AIDecision` - For status effect behavior overrides
- Combat log infrastructure - For status effect logging

---

*This design specification provides intelligent monster behavior and player escape options. The AI system is designed for extensibility, allowing future status effect integration (v0.0.6d) to modify AI decisions based on active effects.*
