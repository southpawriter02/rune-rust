# v0.4.3a: The Aether (Flux State & Service)

> **Status:** Planned
> **Parent:** v0.4.3 - The Weaver (Magic Core System)
> **Theme:** Environmental magic volatility tracking and the foundation for Aetheric manipulation.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Component Specifications](#component-specifications)
5. [Code Implementation](#code-implementation)
6. [Logging Matrix](#logging-matrix)
7. [Unit Testing Specification](#unit-testing-specification)
8. [Integration Points](#integration-points)
9. [Deliverable Checklist](#deliverable-checklist)
10. [Workflow](#workflow)
11. [Changelog](#changelog)

---

## Overview

v0.4.3a introduces **Flux**—the environmental magic volatility system that forms the foundation of The Weaver. Unlike character resources (Stamina, HP), Flux is a property of the current combat encounter, representing the thinning of reality as magic is used.

### Design Philosophy

Flux follows the "pressure cooker" model:
- **Accumulates** with each spell cast (based on spell's FluxCost)
- **Dissipates** naturally at end of each combat round
- **Creates tension** as higher Flux increases Backlash risk (implemented in v0.4.3d)

### Key Characteristics

| Property | Value | Notes |
|----------|-------|-------|
| **Range** | 0-100 | Clamped, never negative or exceeds 100 |
| **Default Dissipation** | 5 per round | Configurable per encounter |
| **Critical Threshold** | 50 | Point where Backlash checks begin |
| **Scope** | Per-encounter | Resets when combat ends |

### Flux Thresholds (Domain 4 Compliant)

| Threshold | Range | Description (Player-Facing) |
|-----------|-------|----------------------------|
| **Safe** | 0-24 | "The air feels normal. Magic flows freely." |
| **Elevated** | 25-49 | "A faint shimmer hangs in the air. Reality strains." |
| **Critical** | 50-74 | "The world feels thin here. Each spell tears at the veil." |
| **Overload** | 75-100 | "Reality screams. The boundary between worlds fractures." |

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                         GameState                               │
│  ┌─────────────────┐    ┌─────────────────┐                    │
│  │  CombatState    │    │   FluxState     │◄── NEW (v0.4.3a)   │
│  │  - TurnOrder    │    │  - CurrentValue │                    │
│  │  - RoundNumber  │    │  - DissipRate   │                    │
│  │  - TurnIndex    │    │  - CritThresh   │                    │
│  └─────────────────┘    └─────────────────┘                    │
└─────────────────────────────────────────────────────────────────┘
                                   ▲
                                   │ reads/writes
                                   │
┌─────────────────────────────────────────────────────────────────┐
│                       AetherService                             │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │ + GetCurrentFlux(): int                                   │ │
│  │ + GetThreshold(): FluxThreshold                           │ │
│  │ + ModifyFlux(amount: int, source: string): void           │ │
│  │ + DissipateFlux(): int (returns amount dissipated)        │ │
│  │ + Reset(): void                                           │ │
│  │ + SetDissipationRate(rate: int): void                     │ │
│  │ + SetCriticalThreshold(threshold: int): void              │ │
│  └───────────────────────────────────────────────────────────┘ │
│                              │                                  │
│                              │ publishes                        │
│                              ▼                                  │
│                     ┌─────────────────┐                        │
│                     │ FluxChangedEvent│                        │
│                     └─────────────────┘                        │
└─────────────────────────────────────────────────────────────────┘
                                   │
                                   │ subscribed by
                                   ▼
┌─────────────────────────────────────────────────────────────────┐
│                    UI / Audio Consumers                         │
│  - CombatHudRenderer (display Flux bar)                        │
│  - AudioEventListener (ambient sound cues)                     │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow: Spell Cast → Flux Increase

```
MagicService.CastSpell()          (v0.4.3c - future)
         │
         │ spell.FluxCost = 8
         │
         ▼
AetherService.ModifyFlux(8, "Cast Spark")
         │
         ├─── 1. Get current: 35
         ├─── 2. Calculate new: 35 + 8 = 43
         ├─── 3. Clamp to [0, 100]: 43
         ├─── 4. Detect threshold: Elevated (was Elevated, still Elevated)
         ├─── 5. Update FluxState.CurrentValue = 43
         ├─── 6. Log: "[Aether] Flux modified by Cast Spark: 35 -> 43"
         │
         └─── 7. Check significance:
                  │
                  ├─── Threshold changed? NO → no event
                  └─── Large change (≥15)? NO → no event

                  (If YES to either → publish FluxChangedEvent)
```

### Data Flow: Round End → Flux Dissipation

```
CombatService.NextTurn()
         │
         │ (detects round boundary: TurnIndex >= TurnOrder.Count)
         │
         ▼
    state.RoundNumber++
         │
         ├─── PlanEnemyActions()
         │
         └─── AetherService.DissipateFlux()    ◄── NEW HOOK (v0.4.3a)
                    │
                    ├─── 1. Get current: 65
                    ├─── 2. Get rate: 5
                    ├─── 3. Calculate new: 65 - 5 = 60
                    ├─── 4. Clamp to [0, 100]: 60
                    ├─── 5. Detect threshold: Critical (was Critical)
                    ├─── 6. Update FluxState.CurrentValue = 60
                    ├─── 7. Log: "[Aether] Flux dissipated: 65 -> 60"
                    │
                    └─── 8. Return dissipated amount: 5
```

---

## Decision Trees

### 1. ModifyFlux Decision Tree

```
ModifyFlux(amount: int, source: string)
│
├─── [GUARD] amount == 0?
│    └─── YES → Log Trace "No-op modification" → RETURN
│
├─── 1. CAPTURE old state
│    ├─── oldValue = _fluxState.CurrentValue
│    └─── oldThreshold = GetThreshold()
│
├─── 2. CALCULATE new value
│    ├─── rawNew = oldValue + amount
│    └─── newValue = Math.Clamp(rawNew, 0, 100)
│
├─── 3. CHECK for clamping
│    ├─── rawNew > 100?
│    │    └─── Log Warning "Flux capped at Critical Mass"
│    └─── rawNew < 0?
│         └─── Log Warning "Flux cannot go negative"
│
├─── 4. UPDATE state
│    └─── _fluxState.CurrentValue = newValue
│
├─── 5. DETERMINE new threshold
│    └─── newThreshold = GetThreshold()
│
├─── 6. LOG the change
│    └─── Log Debug "[Aether] Flux modified by {Source}: {Old} -> {New}"
│
├─── 7. CHECK for significant change
│    ├─── thresholdChanged = (oldThreshold != newThreshold)?
│    └─── largeChange = Math.Abs(amount) >= SignificantChangeAmount (15)?
│
└─── 8. PUBLISH event if significant
     └─── (thresholdChanged OR largeChange)?
          └─── YES → _eventBus.Publish(new FluxChangedEvent(...))
               └─── Log Info "[Aether] FluxChangedEvent published: {Details}"
```

### 2. DissipateFlux Decision Tree

```
DissipateFlux(): int
│
├─── [GUARD] CurrentValue == 0?
│    └─── YES → Log Trace "Flux already at 0, no dissipation" → RETURN 0
│
├─── 1. CAPTURE state
│    ├─── oldValue = _fluxState.CurrentValue
│    ├─── oldThreshold = GetThreshold()
│    └─── rate = _fluxState.DissipationRate
│
├─── 2. CALCULATE dissipation
│    ├─── rawNew = oldValue - rate
│    ├─── newValue = Math.Max(rawNew, 0)
│    └─── actualDissipated = oldValue - newValue
│
├─── 3. UPDATE state
│    └─── _fluxState.CurrentValue = newValue
│
├─── 4. DETERMINE new threshold
│    └─── newThreshold = GetThreshold()
│
├─── 5. LOG the dissipation
│    └─── Log Trace "[Aether] Flux dissipated: {Old} -> {New} (rate: {Rate})"
│
├─── 6. CHECK for threshold change
│    └─── (oldThreshold != newThreshold)?
│         └─── YES → _eventBus.Publish(new FluxChangedEvent(...))
│              └─── Log Info "[Aether] Flux dropped to {NewThreshold}"
│
└─── 7. RETURN dissipated amount
     └─── RETURN actualDissipated
```

### 3. GetThreshold Decision Tree

```
GetThreshold(): FluxThreshold
│
├─── value = _fluxState.CurrentValue
│
├─── value >= 75?
│    └─── RETURN FluxThreshold.Overload
│
├─── value >= 50?
│    └─── RETURN FluxThreshold.Critical
│
├─── value >= 25?
│    └─── RETURN FluxThreshold.Elevated
│
└─── RETURN FluxThreshold.Safe
```

### 4. Reset Decision Tree

```
Reset(): void
│
├─── 1. LOG reset initiation
│    └─── Log Debug "[Aether] Resetting Flux state"
│
├─── 2. RESET values
│    ├─── _fluxState.CurrentValue = 0
│    ├─── _fluxState.DissipationRate = DefaultDissipationRate (5)
│    └─── _fluxState.CriticalThreshold = DefaultCriticalThreshold (50)
│
└─── 3. LOG completion
     └─── Log Trace "[Aether] Flux state reset complete"
```

### 5. Event Publishing Decision Tree

```
ShouldPublishEvent(oldThreshold, newThreshold, changeAmount): bool
│
├─── Threshold changed?
│    └─── oldThreshold != newThreshold → RETURN true
│
├─── Large change?
│    └─── Math.Abs(changeAmount) >= 15 → RETURN true
│
├─── Hit boundary (0 or 100)?
│    └─── newValue == 0 OR newValue == 100 → RETURN true
│
└─── RETURN false
```

---

## Component Specifications

### 1. FluxState (Model)

**File:** `RuneAndRust.Core/Models/Magic/FluxState.cs`

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `CurrentValue` | `int` | 0 | Current Flux level (0-100) |
| `DissipationRate` | `int` | 5 | Amount reduced per round |
| `CriticalThreshold` | `int` | 50 | Point where Backlash checks begin |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `IsCritical` | `bool` | `CurrentValue >= CriticalThreshold` |
| `IsOverloaded` | `bool` | `CurrentValue >= 75` |
| `PercentFull` | `int` | `CurrentValue` (since max is 100) |

### 2. FluxThreshold (Enum)

**File:** `RuneAndRust.Core/Enums/FluxThreshold.cs`

| Value | Int | Range | Description |
|-------|-----|-------|-------------|
| `Safe` | 0 | 0-24 | No risk, magic flows freely |
| `Elevated` | 1 | 25-49 | Minor strain, no mechanical effect |
| `Critical` | 2 | 50-74 | Backlash checks required |
| `Overload` | 3 | 75-100 | Severe Backlash risk |

### 3. IAetherService (Interface)

**File:** `RuneAndRust.Core/Interfaces/IAetherService.cs`

| Method | Returns | Description |
|--------|---------|-------------|
| `GetCurrentFlux()` | `int` | Current Flux value |
| `GetThreshold()` | `FluxThreshold` | Current threshold category |
| `GetCriticalThreshold()` | `int` | Numeric critical threshold |
| `ModifyFlux(int amount, string source)` | `void` | Add/subtract Flux |
| `DissipateFlux()` | `int` | End-of-round reduction, returns amount |
| `Reset()` | `void` | Reset to defaults (combat end) |
| `SetDissipationRate(int rate)` | `void` | Configure per-encounter rate |
| `SetCriticalThreshold(int threshold)` | `void` | Configure per-encounter threshold |
| `GetFluxState()` | `FluxState` | Direct state access (for serialization) |

### 4. FluxChangedEvent (Event)

**File:** `RuneAndRust.Core/Events/FluxChangedEvent.cs`

| Property | Type | Description |
|----------|------|-------------|
| `OldValue` | `int` | Flux before change |
| `NewValue` | `int` | Flux after change |
| `ChangeAmount` | `int` | Delta (positive = increase) |
| `Source` | `string` | What caused the change |
| `OldThreshold` | `FluxThreshold` | Threshold before change |
| `NewThreshold` | `FluxThreshold` | Threshold after change |
| `ThresholdChanged` | `bool` | Computed: did threshold change? |

---

## Code Implementation

### 1. FluxState.cs

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Tracks environmental magic volatility (Flux) for the current combat encounter.
/// Flux accumulates with spellcasting and dissipates each round.
/// </summary>
/// <remarks>
/// See: v0.4.3a (The Aether) for Flux system implementation.
/// Domain 4 Compliant: Flux thresholds use qualitative descriptors, not precision values.
/// </remarks>
public class FluxState
{
    /// <summary>
    /// Default dissipation rate (Flux reduced per combat round).
    /// </summary>
    public const int DefaultDissipationRate = 5;

    /// <summary>
    /// Default critical threshold (point where Backlash checks begin).
    /// </summary>
    public const int DefaultCriticalThreshold = 50;

    /// <summary>
    /// Maximum Flux value (Critical Mass).
    /// </summary>
    public const int MaxFlux = 100;

    /// <summary>
    /// Minimum Flux value.
    /// </summary>
    public const int MinFlux = 0;

    /// <summary>
    /// Current Flux level (0-100). Represents environmental magic volatility.
    /// </summary>
    public int CurrentValue { get; set; } = MinFlux;

    /// <summary>
    /// Amount of Flux that dissipates each combat round.
    /// Can be modified per-encounter for high-magic zones.
    /// </summary>
    public int DissipationRate { get; set; } = DefaultDissipationRate;

    /// <summary>
    /// Flux level at which Backlash checks begin.
    /// Can be lowered for unstable areas or raised for ley line zones.
    /// </summary>
    public int CriticalThreshold { get; set; } = DefaultCriticalThreshold;

    /// <summary>
    /// Returns true if Flux is at or above the critical threshold.
    /// </summary>
    public bool IsCritical => CurrentValue >= CriticalThreshold;

    /// <summary>
    /// Returns true if Flux is in the Overload zone (75+).
    /// </summary>
    public bool IsOverloaded => CurrentValue >= 75;

    /// <summary>
    /// Returns the Flux as a percentage of maximum (0-100).
    /// </summary>
    public int PercentFull => CurrentValue;

    /// <summary>
    /// Resets all values to defaults. Called when combat ends.
    /// </summary>
    public void Reset()
    {
        CurrentValue = MinFlux;
        DissipationRate = DefaultDissipationRate;
        CriticalThreshold = DefaultCriticalThreshold;
    }
}
```

### 2. FluxThreshold.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Categorizes the current Flux level into qualitative thresholds.
/// Used for UI display and Backlash risk determination.
/// </summary>
/// <remarks>
/// See: v0.4.3a (The Aether) for Flux system implementation.
/// Domain 4 Compliant: Thresholds described qualitatively, not with precision values.
/// </remarks>
public enum FluxThreshold
{
    /// <summary>
    /// Flux 0-24: Magic flows freely with no risk.
    /// "The air feels normal. Magic flows freely."
    /// </summary>
    Safe = 0,

    /// <summary>
    /// Flux 25-49: Minor environmental strain, no mechanical effect.
    /// "A faint shimmer hangs in the air. Reality strains."
    /// </summary>
    Elevated = 1,

    /// <summary>
    /// Flux 50-74: Backlash checks required for each spell.
    /// "The world feels thin here. Each spell tears at the veil."
    /// </summary>
    Critical = 2,

    /// <summary>
    /// Flux 75-100: Severe Backlash risk, reality destabilizing.
    /// "Reality screams. The boundary between worlds fractures."
    /// </summary>
    Overload = 3
}
```

### 3. IAetherService.cs

```csharp
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Models.Magic;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service contract for managing environmental Flux (magic volatility).
/// Flux is a per-encounter property that accumulates with spellcasting
/// and dissipates each combat round.
/// </summary>
/// <remarks>
/// See: v0.4.3a (The Aether) for Flux system implementation.
/// Registered as Singleton in DI container.
/// </remarks>
public interface IAetherService
{
    /// <summary>
    /// Gets the current Flux value (0-100).
    /// </summary>
    int GetCurrentFlux();

    /// <summary>
    /// Gets the current Flux threshold category.
    /// </summary>
    FluxThreshold GetThreshold();

    /// <summary>
    /// Gets the numeric critical threshold value.
    /// </summary>
    int GetCriticalThreshold();

    /// <summary>
    /// Modifies Flux by the specified amount. Positive increases, negative decreases.
    /// Value is clamped to [0, 100]. Publishes FluxChangedEvent on significant changes.
    /// </summary>
    /// <param name="amount">Amount to add (positive) or subtract (negative).</param>
    /// <param name="source">Description of what caused the change (for logging).</param>
    void ModifyFlux(int amount, string source);

    /// <summary>
    /// Reduces Flux by the dissipation rate. Called at end of each combat round.
    /// </summary>
    /// <returns>The actual amount dissipated (may be less if Flux was low).</returns>
    int DissipateFlux();

    /// <summary>
    /// Resets Flux state to defaults. Called when combat ends.
    /// </summary>
    void Reset();

    /// <summary>
    /// Sets the dissipation rate for the current encounter.
    /// </summary>
    /// <param name="rate">New dissipation rate (must be >= 0).</param>
    void SetDissipationRate(int rate);

    /// <summary>
    /// Sets the critical threshold for the current encounter.
    /// </summary>
    /// <param name="threshold">New threshold (must be 1-99).</param>
    void SetCriticalThreshold(int threshold);

    /// <summary>
    /// Gets direct access to the FluxState for serialization/debugging.
    /// </summary>
    FluxState GetFluxState();
}
```

### 4. FluxChangedEvent.cs

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Events;

/// <summary>
/// Published when Flux changes significantly (threshold change or large delta).
/// Consumed by UI for Flux bar updates and audio for ambient sound cues.
/// </summary>
/// <remarks>
/// See: v0.4.3a (The Aether) for Flux system implementation.
/// </remarks>
/// <param name="OldValue">Flux value before the change.</param>
/// <param name="NewValue">Flux value after the change.</param>
/// <param name="ChangeAmount">Delta (positive = increase, negative = decrease).</param>
/// <param name="Source">Description of what caused the change.</param>
/// <param name="OldThreshold">Threshold category before the change.</param>
/// <param name="NewThreshold">Threshold category after the change.</param>
public record FluxChangedEvent(
    int OldValue,
    int NewValue,
    int ChangeAmount,
    string Source,
    FluxThreshold OldThreshold,
    FluxThreshold NewThreshold)
{
    /// <summary>
    /// Returns true if this change crossed a threshold boundary.
    /// </summary>
    public bool ThresholdChanged => OldThreshold != NewThreshold;

    /// <summary>
    /// Returns true if Flux increased (spell cast, typically).
    /// </summary>
    public bool IsIncrease => ChangeAmount > 0;

    /// <summary>
    /// Returns true if Flux decreased (dissipation, typically).
    /// </summary>
    public bool IsDecrease => ChangeAmount < 0;

    /// <summary>
    /// Returns true if Flux hit maximum (Critical Mass).
    /// </summary>
    public bool HitMaximum => NewValue >= FluxState.MaxFlux;

    /// <summary>
    /// Returns true if Flux hit minimum (fully dissipated).
    /// </summary>
    public bool HitMinimum => NewValue <= FluxState.MinFlux;
}
```

### 5. AetherService.cs

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Magic;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Manages environmental Flux (magic volatility) for combat encounters.
/// Flux accumulates with spellcasting and dissipates each round.
/// </summary>
/// <remarks>
/// See: v0.4.3a (The Aether) for Flux system implementation.
/// Registered as Singleton - Flux state persists across the combat encounter.
/// </remarks>
public class AetherService : IAetherService
{
    private readonly FluxState _fluxState;
    private readonly IEventBus _eventBus;
    private readonly ILogger<AetherService> _logger;

    /// <summary>
    /// Minimum change amount to trigger an event (unless threshold changes).
    /// </summary>
    private const int SignificantChangeThreshold = 15;

    /// <summary>
    /// Initializes a new instance of the <see cref="AetherService"/> class.
    /// </summary>
    /// <param name="eventBus">Event bus for publishing FluxChangedEvents.</param>
    /// <param name="logger">Logger for traceability.</param>
    public AetherService(IEventBus eventBus, ILogger<AetherService> logger)
    {
        _fluxState = new FluxState();
        _eventBus = eventBus;
        _logger = logger;

        _logger.LogDebug("[Aether] AetherService initialized. Flux: {Current}, Rate: {Rate}, Threshold: {Threshold}",
            _fluxState.CurrentValue, _fluxState.DissipationRate, _fluxState.CriticalThreshold);
    }

    /// <inheritdoc/>
    public int GetCurrentFlux()
    {
        _logger.LogTrace("[Aether] GetCurrentFlux called. Value: {Value}", _fluxState.CurrentValue);
        return _fluxState.CurrentValue;
    }

    /// <inheritdoc/>
    public FluxThreshold GetThreshold()
    {
        var threshold = CalculateThreshold(_fluxState.CurrentValue);
        _logger.LogTrace("[Aether] GetThreshold called. Value: {Value}, Threshold: {Threshold}",
            _fluxState.CurrentValue, threshold);
        return threshold;
    }

    /// <inheritdoc/>
    public int GetCriticalThreshold()
    {
        return _fluxState.CriticalThreshold;
    }

    /// <inheritdoc/>
    public void ModifyFlux(int amount, string source)
    {
        _logger.LogDebug("[Aether] ModifyFlux called. Amount: {Amount}, Source: {Source}",
            amount, source);

        // Guard: No-op for zero change
        if (amount == 0)
        {
            _logger.LogTrace("[Aether] No-op modification (amount = 0) from {Source}", source);
            return;
        }

        // 1. Capture old state
        var oldValue = _fluxState.CurrentValue;
        var oldThreshold = CalculateThreshold(oldValue);

        // 2. Calculate new value
        var rawNew = oldValue + amount;
        var newValue = Math.Clamp(rawNew, FluxState.MinFlux, FluxState.MaxFlux);

        // 3. Log clamping warnings
        if (rawNew > FluxState.MaxFlux)
        {
            _logger.LogWarning("[Aether] Flux capped at Critical Mass ({Max}). Attempted: {Attempted}",
                FluxState.MaxFlux, rawNew);
        }
        else if (rawNew < FluxState.MinFlux)
        {
            _logger.LogWarning("[Aether] Flux cannot go negative. Attempted: {Attempted}", rawNew);
        }

        // 4. Update state
        _fluxState.CurrentValue = newValue;

        // 5. Calculate new threshold
        var newThreshold = CalculateThreshold(newValue);

        // 6. Log the change
        var changeSign = amount > 0 ? "+" : "";
        _logger.LogDebug("[Aether] Flux modified by {Source}: {Old} -> {New} ({Sign}{Amount})",
            source, oldValue, newValue, changeSign, amount);

        // 7. Check for significant change
        var thresholdChanged = oldThreshold != newThreshold;
        var largeChange = Math.Abs(amount) >= SignificantChangeThreshold;
        var hitBoundary = newValue == FluxState.MinFlux || newValue == FluxState.MaxFlux;

        // 8. Publish event if significant
        if (thresholdChanged || largeChange || hitBoundary)
        {
            var fluxEvent = new FluxChangedEvent(
                oldValue,
                newValue,
                amount,
                source,
                oldThreshold,
                newThreshold);

            _eventBus.Publish(fluxEvent);

            if (thresholdChanged)
            {
                _logger.LogInformation("[Aether] Flux threshold changed: {Old} -> {New} (Value: {Value})",
                    oldThreshold, newThreshold, newValue);
            }
            else
            {
                _logger.LogDebug("[Aether] FluxChangedEvent published. Reason: {Reason}",
                    hitBoundary ? "Hit boundary" : "Large change");
            }
        }
    }

    /// <inheritdoc/>
    public int DissipateFlux()
    {
        _logger.LogTrace("[Aether] DissipateFlux called. Current: {Current}, Rate: {Rate}",
            _fluxState.CurrentValue, _fluxState.DissipationRate);

        // Guard: Already at zero
        if (_fluxState.CurrentValue == 0)
        {
            _logger.LogTrace("[Aether] Flux already at 0, no dissipation");
            return 0;
        }

        // 1. Capture old state
        var oldValue = _fluxState.CurrentValue;
        var oldThreshold = CalculateThreshold(oldValue);
        var rate = _fluxState.DissipationRate;

        // 2. Calculate dissipation
        var rawNew = oldValue - rate;
        var newValue = Math.Max(rawNew, FluxState.MinFlux);
        var actualDissipated = oldValue - newValue;

        // 3. Update state
        _fluxState.CurrentValue = newValue;

        // 4. Calculate new threshold
        var newThreshold = CalculateThreshold(newValue);

        // 5. Log the dissipation
        _logger.LogTrace("[Aether] Flux dissipated: {Old} -> {New} (rate: {Rate}, actual: {Actual})",
            oldValue, newValue, rate, actualDissipated);

        // 6. Publish event if threshold changed
        if (oldThreshold != newThreshold)
        {
            var fluxEvent = new FluxChangedEvent(
                oldValue,
                newValue,
                -actualDissipated,
                "Round Dissipation",
                oldThreshold,
                newThreshold);

            _eventBus.Publish(fluxEvent);

            _logger.LogInformation("[Aether] Flux dropped to {Threshold} (Value: {Value})",
                newThreshold, newValue);
        }

        // 7. Return actual amount dissipated
        return actualDissipated;
    }

    /// <inheritdoc/>
    public void Reset()
    {
        _logger.LogDebug("[Aether] Resetting Flux state");

        _fluxState.Reset();

        _logger.LogTrace("[Aether] Flux state reset complete. Value: {Value}, Rate: {Rate}, Threshold: {Threshold}",
            _fluxState.CurrentValue, _fluxState.DissipationRate, _fluxState.CriticalThreshold);
    }

    /// <inheritdoc/>
    public void SetDissipationRate(int rate)
    {
        if (rate < 0)
        {
            _logger.LogWarning("[Aether] Invalid dissipation rate {Rate}, must be >= 0. Using 0.", rate);
            rate = 0;
        }

        var oldRate = _fluxState.DissipationRate;
        _fluxState.DissipationRate = rate;

        _logger.LogDebug("[Aether] Dissipation rate changed: {Old} -> {New}", oldRate, rate);
    }

    /// <inheritdoc/>
    public void SetCriticalThreshold(int threshold)
    {
        if (threshold < 1 || threshold > 99)
        {
            _logger.LogWarning("[Aether] Invalid critical threshold {Threshold}, must be 1-99. Using 50.", threshold);
            threshold = FluxState.DefaultCriticalThreshold;
        }

        var oldThreshold = _fluxState.CriticalThreshold;
        _fluxState.CriticalThreshold = threshold;

        _logger.LogDebug("[Aether] Critical threshold changed: {Old} -> {New}", oldThreshold, threshold);
    }

    /// <inheritdoc/>
    public FluxState GetFluxState()
    {
        return _fluxState;
    }

    /// <summary>
    /// Calculates the threshold category for a given Flux value.
    /// </summary>
    /// <param name="value">The Flux value to categorize.</param>
    /// <returns>The appropriate FluxThreshold.</returns>
    private static FluxThreshold CalculateThreshold(int value)
    {
        return value switch
        {
            >= 75 => FluxThreshold.Overload,
            >= 50 => FluxThreshold.Critical,
            >= 25 => FluxThreshold.Elevated,
            _ => FluxThreshold.Safe
        };
    }
}
```

### 6. DI Registration (Program.cs Addition)

```csharp
// In ConfigureServices method, add after other singleton services:

// v0.4.3a: Aether Service (Flux management)
services.AddSingleton<IAetherService, AetherService>();
```

### 7. CombatService Integration (Modification)

**File:** `RuneAndRust.Engine/Services/CombatService.cs`

Add to constructor:
```csharp
private readonly IAetherService _aetherService;

public CombatService(
    // ... existing parameters ...
    IAetherService aetherService,  // ADD THIS
    ILogger<CombatService> logger)
{
    // ... existing assignments ...
    _aetherService = aetherService;
}
```

Modify `NextTurn()` method to add dissipation hook:
```csharp
public void NextTurn()
{
    if (_gameState.CombatState == null)
    {
        _logger.LogWarning("NextTurn called but no combat is active");
        return;
    }

    var state = _gameState.CombatState;
    state.TurnIndex++;

    // End-of-round detection
    if (state.TurnIndex >= state.TurnOrder.Count)
    {
        state.TurnIndex = 0;
        state.RoundNumber++;
        _logger.LogInformation("Round {Round} begins", state.RoundNumber);

        // ROUND START HOOKS
        PlanEnemyActions();

        // v0.4.3a: Dissipate Flux at round boundary
        var dissipated = _aetherService.DissipateFlux();
        if (dissipated > 0)
        {
            _logger.LogDebug("[Combat] Flux dissipated by {Amount} at round boundary", dissipated);
        }
    }

    // ... rest of existing NextTurn logic ...
}
```

Modify `StartCombat()` to reset Flux:
```csharp
public void StartCombat(List<Enemy> enemies)
{
    // ... existing combat setup logic ...

    // v0.4.3a: Reset Flux for new encounter
    _aetherService.Reset();
    _logger.LogDebug("[Combat] Flux reset for new encounter");

    // ... rest of existing StartCombat logic ...
}
```

Modify `EndCombat()` to reset Flux:
```csharp
public CombatResult? EndCombat()
{
    // ... existing combat end logic ...

    // v0.4.3a: Reset Flux when combat ends
    _aetherService.Reset();
    _logger.LogDebug("[Combat] Flux reset after combat end");

    // ... rest of existing EndCombat logic ...
}
```

---

## Logging Matrix

### AetherService Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| Constructor | Initialized | Debug | `"[Aether] AetherService initialized. Flux: {Current}, Rate: {Rate}, Threshold: {Threshold}"` | Current, Rate, Threshold |
| GetCurrentFlux | Read | Trace | `"[Aether] GetCurrentFlux called. Value: {Value}"` | Value |
| GetThreshold | Read | Trace | `"[Aether] GetThreshold called. Value: {Value}, Threshold: {Threshold}"` | Value, Threshold |
| ModifyFlux | Entry | Debug | `"[Aether] ModifyFlux called. Amount: {Amount}, Source: {Source}"` | Amount, Source |
| ModifyFlux | No-op | Trace | `"[Aether] No-op modification (amount = 0) from {Source}"` | Source |
| ModifyFlux | Capped High | Warning | `"[Aether] Flux capped at Critical Mass ({Max}). Attempted: {Attempted}"` | Max, Attempted |
| ModifyFlux | Capped Low | Warning | `"[Aether] Flux cannot go negative. Attempted: {Attempted}"` | Attempted |
| ModifyFlux | Changed | Debug | `"[Aether] Flux modified by {Source}: {Old} -> {New} ({Sign}{Amount})"` | Source, Old, New, Sign, Amount |
| ModifyFlux | ThresholdChanged | Info | `"[Aether] Flux threshold changed: {Old} -> {New} (Value: {Value})"` | Old, New, Value |
| ModifyFlux | EventPublished | Debug | `"[Aether] FluxChangedEvent published. Reason: {Reason}"` | Reason |
| DissipateFlux | Entry | Trace | `"[Aether] DissipateFlux called. Current: {Current}, Rate: {Rate}"` | Current, Rate |
| DissipateFlux | AlreadyZero | Trace | `"[Aether] Flux already at 0, no dissipation"` | - |
| DissipateFlux | Dissipated | Trace | `"[Aether] Flux dissipated: {Old} -> {New} (rate: {Rate}, actual: {Actual})"` | Old, New, Rate, Actual |
| DissipateFlux | ThresholdDropped | Info | `"[Aether] Flux dropped to {Threshold} (Value: {Value})"` | Threshold, Value |
| Reset | Entry | Debug | `"[Aether] Resetting Flux state"` | - |
| Reset | Complete | Trace | `"[Aether] Flux state reset complete. Value: {Value}, Rate: {Rate}, Threshold: {Threshold}"` | Value, Rate, Threshold |
| SetDissipationRate | Invalid | Warning | `"[Aether] Invalid dissipation rate {Rate}, must be >= 0. Using 0."` | Rate |
| SetDissipationRate | Changed | Debug | `"[Aether] Dissipation rate changed: {Old} -> {New}"` | Old, New |
| SetCriticalThreshold | Invalid | Warning | `"[Aether] Invalid critical threshold {Threshold}, must be 1-99. Using 50."` | Threshold |
| SetCriticalThreshold | Changed | Debug | `"[Aether] Critical threshold changed: {Old} -> {New}"` | Old, New |

### CombatService Integration Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| NextTurn | FluxDissipated | Debug | `"[Combat] Flux dissipated by {Amount} at round boundary"` | Amount |
| StartCombat | FluxReset | Debug | `"[Combat] Flux reset for new encounter"` | - |
| EndCombat | FluxReset | Debug | `"[Combat] Flux reset after combat end"` | - |

---

## Unit Testing Specification

### Test Class: AetherServiceTests.cs

**File:** `RuneAndRust.Tests/Engine/Services/AetherServiceTests.cs`

#### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| Constructor | 2 | Initialization and default state |
| GetCurrentFlux | 3 | Read operations |
| GetThreshold | 6 | All threshold boundaries |
| ModifyFlux | 10 | Add, subtract, clamping, events |
| DissipateFlux | 5 | Standard dissipation, boundary conditions |
| Reset | 2 | State reset verification |
| SetDissipationRate | 3 | Valid and invalid rates |
| SetCriticalThreshold | 3 | Valid and invalid thresholds |
| Event Publishing | 5 | Event trigger conditions |

**Total: 39 tests** (exceeds original estimate of 28)

#### Test Specifications

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using NSubstitute;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Magic;
using RuneAndRust.Engine.Services;
using Xunit;

namespace RuneAndRust.Tests.Engine.Services;

/// <summary>
/// Unit tests for AetherService (v0.4.3a - The Aether).
/// </summary>
public class AetherServiceTests
{
    private readonly IEventBus _mockEventBus;
    private readonly ILogger<AetherService> _mockLogger;
    private readonly AetherService _sut;

    public AetherServiceTests()
    {
        _mockEventBus = Substitute.For<IEventBus>();
        _mockLogger = Substitute.For<ILogger<AetherService>>();
        _sut = new AetherService(_mockEventBus, _mockLogger);
    }

    #region Constructor Tests

    [Fact]
    public void Constructor_InitializesWithDefaultValues()
    {
        // Assert
        _sut.GetCurrentFlux().Should().Be(0);
        _sut.GetThreshold().Should().Be(FluxThreshold.Safe);
        _sut.GetCriticalThreshold().Should().Be(50);
        _sut.GetFluxState().DissipationRate.Should().Be(5);
    }

    [Fact]
    public void Constructor_LogsInitialization()
    {
        // Assert - verify logger was called with Debug level
        _mockLogger.ReceivedWithAnyArgs().LogDebug(default!, default);
    }

    #endregion

    #region GetCurrentFlux Tests

    [Fact]
    public void GetCurrentFlux_ReturnsZero_WhenInitialized()
    {
        // Act
        var result = _sut.GetCurrentFlux();

        // Assert
        result.Should().Be(0);
    }

    [Fact]
    public void GetCurrentFlux_ReturnsModifiedValue_AfterModification()
    {
        // Arrange
        _sut.ModifyFlux(30, "Test");

        // Act
        var result = _sut.GetCurrentFlux();

        // Assert
        result.Should().Be(30);
    }

    [Fact]
    public void GetCurrentFlux_ReturnsClampedValue_WhenOverMax()
    {
        // Arrange
        _sut.ModifyFlux(150, "Test");

        // Act
        var result = _sut.GetCurrentFlux();

        // Assert
        result.Should().Be(100);
    }

    #endregion

    #region GetThreshold Tests

    [Theory]
    [InlineData(0, FluxThreshold.Safe)]
    [InlineData(24, FluxThreshold.Safe)]
    [InlineData(25, FluxThreshold.Elevated)]
    [InlineData(49, FluxThreshold.Elevated)]
    [InlineData(50, FluxThreshold.Critical)]
    [InlineData(74, FluxThreshold.Critical)]
    [InlineData(75, FluxThreshold.Overload)]
    [InlineData(100, FluxThreshold.Overload)]
    public void GetThreshold_ReturnsCorrectCategory(int fluxValue, FluxThreshold expected)
    {
        // Arrange
        _sut.ModifyFlux(fluxValue, "Test");

        // Act
        var result = _sut.GetThreshold();

        // Assert
        result.Should().Be(expected);
    }

    #endregion

    #region ModifyFlux Tests

    [Fact]
    public void ModifyFlux_IncreasesFlux_WhenPositiveAmount()
    {
        // Act
        _sut.ModifyFlux(25, "Spell Cast");

        // Assert
        _sut.GetCurrentFlux().Should().Be(25);
    }

    [Fact]
    public void ModifyFlux_DecreasesFlux_WhenNegativeAmount()
    {
        // Arrange
        _sut.ModifyFlux(50, "Setup");

        // Act
        _sut.ModifyFlux(-20, "Ability");

        // Assert
        _sut.GetCurrentFlux().Should().Be(30);
    }

    [Fact]
    public void ModifyFlux_ClampsToMax_WhenExceedsHundred()
    {
        // Act
        _sut.ModifyFlux(150, "Overload Spell");

        // Assert
        _sut.GetCurrentFlux().Should().Be(100);
    }

    [Fact]
    public void ModifyFlux_ClampsToZero_WhenBelowZero()
    {
        // Arrange
        _sut.ModifyFlux(10, "Setup");

        // Act
        _sut.ModifyFlux(-50, "Massive Reduction");

        // Assert
        _sut.GetCurrentFlux().Should().Be(0);
    }

    [Fact]
    public void ModifyFlux_NoOp_WhenAmountIsZero()
    {
        // Arrange
        _sut.ModifyFlux(25, "Setup");
        _mockEventBus.ClearReceivedCalls();

        // Act
        _sut.ModifyFlux(0, "No Change");

        // Assert
        _sut.GetCurrentFlux().Should().Be(25);
        _mockEventBus.DidNotReceive().Publish(Arg.Any<FluxChangedEvent>());
    }

    [Fact]
    public void ModifyFlux_PublishesEvent_WhenThresholdChanges()
    {
        // Act - cross from Safe to Elevated
        _sut.ModifyFlux(30, "Threshold Cross");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.OldThreshold == FluxThreshold.Safe &&
            e.NewThreshold == FluxThreshold.Elevated));
    }

    [Fact]
    public void ModifyFlux_PublishesEvent_WhenLargeChange()
    {
        // Arrange
        _sut.ModifyFlux(10, "Setup");
        _mockEventBus.ClearReceivedCalls();

        // Act - 15+ change within same threshold
        _sut.ModifyFlux(15, "Large Change");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.ChangeAmount == 15));
    }

    [Fact]
    public void ModifyFlux_DoesNotPublishEvent_WhenSmallChangeWithinThreshold()
    {
        // Arrange
        _sut.ModifyFlux(10, "Setup");
        _mockEventBus.ClearReceivedCalls();

        // Act - small change, no threshold cross
        _sut.ModifyFlux(5, "Small Change");

        // Assert
        _mockEventBus.DidNotReceive().Publish(Arg.Any<FluxChangedEvent>());
    }

    [Fact]
    public void ModifyFlux_PublishesEvent_WhenHittingMaximum()
    {
        // Arrange
        _sut.ModifyFlux(90, "Near Max");
        _mockEventBus.ClearReceivedCalls();

        // Act - hit exactly 100
        _sut.ModifyFlux(10, "Hit Max");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.NewValue == 100 && e.HitMaximum));
    }

    #endregion

    #region DissipateFlux Tests

    [Fact]
    public void DissipateFlux_ReducesByDissipationRate()
    {
        // Arrange
        _sut.ModifyFlux(30, "Setup");

        // Act
        var dissipated = _sut.DissipateFlux();

        // Assert
        dissipated.Should().Be(5);
        _sut.GetCurrentFlux().Should().Be(25);
    }

    [Fact]
    public void DissipateFlux_ReturnsZero_WhenAlreadyAtZero()
    {
        // Act
        var dissipated = _sut.DissipateFlux();

        // Assert
        dissipated.Should().Be(0);
        _sut.GetCurrentFlux().Should().Be(0);
    }

    [Fact]
    public void DissipateFlux_ClampsToZero_WhenFluxBelowRate()
    {
        // Arrange
        _sut.ModifyFlux(3, "Setup");

        // Act
        var dissipated = _sut.DissipateFlux();

        // Assert
        dissipated.Should().Be(3); // Only dissipates what's available
        _sut.GetCurrentFlux().Should().Be(0);
    }

    [Fact]
    public void DissipateFlux_PublishesEvent_WhenThresholdDrops()
    {
        // Arrange
        _sut.ModifyFlux(52, "Setup at Critical");
        _mockEventBus.ClearReceivedCalls();

        // Act - dissipate 5, drop from 52 to 47 (Critical -> Elevated)
        _sut.DissipateFlux();

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.OldThreshold == FluxThreshold.Critical &&
            e.NewThreshold == FluxThreshold.Elevated));
    }

    [Fact]
    public void DissipateFlux_UsesCustomRate_WhenSet()
    {
        // Arrange
        _sut.ModifyFlux(30, "Setup");
        _sut.SetDissipationRate(10);

        // Act
        var dissipated = _sut.DissipateFlux();

        // Assert
        dissipated.Should().Be(10);
        _sut.GetCurrentFlux().Should().Be(20);
    }

    #endregion

    #region Reset Tests

    [Fact]
    public void Reset_SetsFluxToZero()
    {
        // Arrange
        _sut.ModifyFlux(75, "Setup");

        // Act
        _sut.Reset();

        // Assert
        _sut.GetCurrentFlux().Should().Be(0);
        _sut.GetThreshold().Should().Be(FluxThreshold.Safe);
    }

    [Fact]
    public void Reset_RestoresDefaultRateAndThreshold()
    {
        // Arrange
        _sut.SetDissipationRate(10);
        _sut.SetCriticalThreshold(30);

        // Act
        _sut.Reset();

        // Assert
        _sut.GetFluxState().DissipationRate.Should().Be(5);
        _sut.GetCriticalThreshold().Should().Be(50);
    }

    #endregion

    #region SetDissipationRate Tests

    [Fact]
    public void SetDissipationRate_UpdatesRate_WhenValid()
    {
        // Act
        _sut.SetDissipationRate(10);

        // Assert
        _sut.GetFluxState().DissipationRate.Should().Be(10);
    }

    [Fact]
    public void SetDissipationRate_AllowsZero()
    {
        // Act
        _sut.SetDissipationRate(0);

        // Assert
        _sut.GetFluxState().DissipationRate.Should().Be(0);
    }

    [Fact]
    public void SetDissipationRate_ClampsNegative_ToZero()
    {
        // Act
        _sut.SetDissipationRate(-5);

        // Assert
        _sut.GetFluxState().DissipationRate.Should().Be(0);
    }

    #endregion

    #region SetCriticalThreshold Tests

    [Fact]
    public void SetCriticalThreshold_UpdatesThreshold_WhenValid()
    {
        // Act
        _sut.SetCriticalThreshold(60);

        // Assert
        _sut.GetCriticalThreshold().Should().Be(60);
    }

    [Fact]
    public void SetCriticalThreshold_UsesDefault_WhenTooLow()
    {
        // Act
        _sut.SetCriticalThreshold(0);

        // Assert
        _sut.GetCriticalThreshold().Should().Be(50); // Default
    }

    [Fact]
    public void SetCriticalThreshold_UsesDefault_WhenTooHigh()
    {
        // Act
        _sut.SetCriticalThreshold(100);

        // Assert
        _sut.GetCriticalThreshold().Should().Be(50); // Default
    }

    #endregion

    #region Event Content Tests

    [Fact]
    public void FluxChangedEvent_ContainsCorrectSource()
    {
        // Act
        _sut.ModifyFlux(30, "Cast Spark");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.Source == "Cast Spark"));
    }

    [Fact]
    public void FluxChangedEvent_ContainsCorrectChangeAmount()
    {
        // Act
        _sut.ModifyFlux(30, "Test");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.ChangeAmount == 30 &&
            e.OldValue == 0 &&
            e.NewValue == 30));
    }

    [Fact]
    public void FluxChangedEvent_ThresholdChanged_IsTrue_WhenCrossingBoundary()
    {
        // Act
        _sut.ModifyFlux(50, "Cross to Critical");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.ThresholdChanged == true));
    }

    [Fact]
    public void FluxChangedEvent_HitMaximum_IsTrue_WhenAtHundred()
    {
        // Act
        _sut.ModifyFlux(100, "Max Out");

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.HitMaximum == true));
    }

    [Fact]
    public void DissipateFlux_Event_ShowsNegativeChangeAmount()
    {
        // Arrange
        _sut.ModifyFlux(52, "Setup");
        _mockEventBus.ClearReceivedCalls();

        // Act
        _sut.DissipateFlux();

        // Assert
        _mockEventBus.Received(1).Publish(Arg.Is<FluxChangedEvent>(e =>
            e.ChangeAmount < 0 &&
            e.IsDecrease == true));
    }

    #endregion
}
```

---

## Integration Points

### 1. CombatService Integration

**Hook Points:**

| Method | Hook | Action |
|--------|------|--------|
| `StartCombat()` | Combat initialization | `_aetherService.Reset()` |
| `NextTurn()` | Round boundary | `_aetherService.DissipateFlux()` |
| `EndCombat()` | Combat cleanup | `_aetherService.Reset()` |

### 2. MagicService Integration (v0.4.3c - Future)

```csharp
// In MagicService.CastSpell():
_aetherService.ModifyFlux(spell.FluxCost, $"Cast {spell.Name}");
```

### 3. UI Integration (v0.4.3e - Future)

**FluxChangedEvent Subscription:**
```csharp
// In combat HUD renderer or similar:
_eventBus.Subscribe<FluxChangedEvent>(OnFluxChanged);

private void OnFluxChanged(FluxChangedEvent evt)
{
    // Update Flux bar display
    // Play threshold-appropriate ambient sound
}
```

### 4. High-Magic Zone Encounters (Future)

```csharp
// When entering a ley line zone:
_aetherService.SetDissipationRate(2);      // Slower dissipation
_aetherService.SetCriticalThreshold(40);   // Lower safety margin

// When entering a dead magic zone:
_aetherService.SetDissipationRate(10);     // Faster dissipation
_aetherService.SetCriticalThreshold(70);   // Higher safety margin
```

---

## Deliverable Checklist

### Core Components

- [ ] **FluxState.cs** - Model with CurrentValue, DissipationRate, CriticalThreshold
  - [ ] Constants: DefaultDissipationRate, DefaultCriticalThreshold, MaxFlux, MinFlux
  - [ ] Computed properties: IsCritical, IsOverloaded, PercentFull
  - [ ] Reset() method

- [ ] **FluxThreshold.cs** - Enum with Safe, Elevated, Critical, Overload
  - [ ] XML documentation with Domain 4 compliant descriptions

- [ ] **IAetherService.cs** - Service interface
  - [ ] GetCurrentFlux(), GetThreshold(), GetCriticalThreshold()
  - [ ] ModifyFlux(), DissipateFlux(), Reset()
  - [ ] SetDissipationRate(), SetCriticalThreshold()
  - [ ] GetFluxState()

- [ ] **FluxChangedEvent.cs** - Event record
  - [ ] Properties: OldValue, NewValue, ChangeAmount, Source, OldThreshold, NewThreshold
  - [ ] Computed: ThresholdChanged, IsIncrease, IsDecrease, HitMaximum, HitMinimum

- [ ] **AetherService.cs** - Full implementation
  - [ ] Constructor with IEventBus, ILogger
  - [ ] All interface methods implemented
  - [ ] Comprehensive logging at all levels
  - [ ] Event publishing logic

### Integration

- [ ] **Program.cs** - DI registration
  - [ ] `services.AddSingleton<IAetherService, AetherService>()`

- [ ] **CombatService.cs** - Integration hooks
  - [ ] Constructor: Add `IAetherService` dependency
  - [ ] StartCombat(): Add `_aetherService.Reset()`
  - [ ] NextTurn(): Add `_aetherService.DissipateFlux()` at round boundary
  - [ ] EndCombat(): Add `_aetherService.Reset()`

### Testing

- [ ] **AetherServiceTests.cs** - 39 unit tests
  - [ ] Constructor tests (2)
  - [ ] GetCurrentFlux tests (3)
  - [ ] GetThreshold tests (6)
  - [ ] ModifyFlux tests (10)
  - [ ] DissipateFlux tests (5)
  - [ ] Reset tests (2)
  - [ ] SetDissipationRate tests (3)
  - [ ] SetCriticalThreshold tests (3)
  - [ ] Event publishing tests (5)

### Documentation

- [ ] Update v0.4.3 master plan with completion status
- [ ] Add inline XML documentation to all public members

---

## Workflow

### Implementation Order

```
1. CREATE Core Models
   ├── FluxState.cs
   └── FluxThreshold.cs

2. CREATE Core Interfaces
   └── IAetherService.cs

3. CREATE Core Events
   └── FluxChangedEvent.cs

4. CREATE Engine Service
   └── AetherService.cs

5. REGISTER in DI
   └── Program.cs modification

6. CREATE Tests (TDD - can start earlier)
   └── AetherServiceTests.cs

7. INTEGRATE with CombatService
   ├── Constructor modification
   ├── StartCombat() hook
   ├── NextTurn() hook
   └── EndCombat() hook

8. VERIFY
   ├── Run all tests
   ├── Manual combat test
   └── Verify logging output
```

### File Creation Order

| Order | File | Layer | Dependencies |
|-------|------|-------|--------------|
| 1 | FluxState.cs | Core/Models/Magic | None |
| 2 | FluxThreshold.cs | Core/Enums | None |
| 3 | IAetherService.cs | Core/Interfaces | FluxState, FluxThreshold |
| 4 | FluxChangedEvent.cs | Core/Events | FluxState, FluxThreshold |
| 5 | AetherService.cs | Engine/Services | All above + IEventBus, ILogger |
| 6 | AetherServiceTests.cs | Tests/Engine/Services | All above + test frameworks |
| 7 | Program.cs (modify) | Terminal | AetherService |
| 8 | CombatService.cs (modify) | Engine/Services | IAetherService |

---

## Changelog

```markdown
## v0.4.3a - The Aether (Flux State & Service)

**Release Date:** TBD

### Summary
Introduced the environmental Flux system—the foundation for The Weaver magic mechanics.
Flux tracks magical volatility per-encounter, accumulating with spellcasting and
dissipating each round.

### Features
- **Flux State**: New `FluxState` model tracking CurrentValue (0-100), DissipationRate,
  and CriticalThreshold per encounter.
- **Flux Thresholds**: Four qualitative categories (Safe, Elevated, Critical, Overload)
  with Domain 4 compliant descriptions.
- **AetherService**: Singleton service managing Flux accumulation, dissipation, and
  threshold calculations.
- **Event Publishing**: `FluxChangedEvent` published on significant Flux changes for
  UI and audio integration.
- **Combat Integration**: Flux automatically resets at combat start/end and dissipates
  at each round boundary.

### Technical
- Implemented `IAetherService` interface with comprehensive Flux manipulation methods.
- Created `AetherService` with full logging at Trace, Debug, Info, and Warning levels.
- Integrated dissipation hook into `CombatService.NextTurn()` at round boundaries.
- Added reset hooks to `CombatService.StartCombat()` and `EndCombat()`.
- Registered `IAetherService` as Singleton in DI container.

### New Files
- `RuneAndRust.Core/Models/Magic/FluxState.cs`
- `RuneAndRust.Core/Enums/FluxThreshold.cs`
- `RuneAndRust.Core/Interfaces/IAetherService.cs`
- `RuneAndRust.Core/Events/FluxChangedEvent.cs`
- `RuneAndRust.Engine/Services/AetherService.cs`
- `RuneAndRust.Tests/Engine/Services/AetherServiceTests.cs`

### Modified Files
- `RuneAndRust.Terminal/Program.cs` - Added DI registration
- `RuneAndRust.Engine/Services/CombatService.cs` - Added Flux integration hooks

### Testing
- 39 new unit tests in `AetherServiceTests.cs`
- Coverage: Constructor, GetCurrentFlux, GetThreshold, ModifyFlux, DissipateFlux,
  Reset, SetDissipationRate, SetCriticalThreshold, Event Publishing

### Domain 4 Compliance
- Flux thresholds described qualitatively ("The air feels normal", "Reality screams")
- No precision measurements in player-facing descriptions
- Archaeologist perspective maintained in all documentation

### Dependencies
- This version provides foundation for v0.4.3c (MagicService) and v0.4.3d (BacklashService)
- Flux values will be consumed by spellcasting and risk mechanics in later sub-versions
```

---

## Next Steps

After v0.4.3a implementation:

1. **v0.4.3b (The Grimoire)**: Create Spell entity and SpellRepository
2. **v0.4.3c (The Incantation)**: Implement MagicService with `cast` command
3. **v0.4.3d (The Backlash)**: Add risk mechanics consuming Flux state
4. **v0.4.3e (The Resonance)**: TUI integration showing Flux bar in combat HUD
