# v0.0.7c Design Specification: Armor & Requirements

**Version:** 0.0.7c
**Parent:** v0.0.7 (Equipment System)
**Prerequisites:** v0.0.7a Complete (Core Equipment Infrastructure), v0.0.7b Complete (Weapon System)
**Status:** Design Complete

---

## Table of Contents

1. [Overview](#overview)
2. [Scope](#scope)
3. [Data Model](#data-model)
4. [Services](#services)
5. [Command Changes](#command-changes)
6. [Rendering Changes](#rendering-changes)
7. [Configuration](#configuration)
8. [Acceptance Criteria](#acceptance-criteria)
9. [Test Specifications](#test-specifications)
10. [Dependencies](#dependencies)

---

## Overview

### Purpose

Implement armor types with defense bonuses and stat modifiers, plus equipment requirements based on player attributes and class. This phase completes the v0.0.7 Equipment System by making armor meaningful in combat and introducing prerequisites for equipping powerful items.

### Key Changes

| Area | Current State (v0.0.7b) | Target State (v0.0.7c) |
|------|-------------------------|------------------------|
| Item Entity | Has weapon properties | Adds armor properties, stat modifiers, requirements |
| Defense Calculation | Static player defense | Base defense + equipped armor bonus |
| Equipment Validation | Check slot only | Check slot + attribute/class requirements |
| Player Stats | Base stats only | Effective stats = base + equipment bonuses |

### Design Principles

1. **Meaningful Choices**: Different armor types offer trade-offs (protection vs mobility)
2. **Progressive Gating**: Requirements create natural progression without hard level locks
3. **Composable Bonuses**: Stat modifiers stack from all equipped items consistently
4. **Clear Feedback**: Players understand why they can't equip items and what they need

---

## Scope

### In Scope

- `ArmorType` enum (Light, Medium, Heavy)
- `ArmorType?` property on `Item`
- `DefenseBonus` property on `Item`
- `StatModifiers` value object for general equipment stat bonuses
- `InitiativePenalty` property on `Item` (for heavy armor)
- `EquipmentRequirements` value object (attribute and class requirements)
- `Requirements` property on `Item`
- Update `EquipmentService` with requirement validation
- Update `Player` with `GetEffectiveStats()` and `GetEffectiveAttributes()`
- `armor.json` configuration file
- Clear error messages for unmet requirements

### Out of Scope (Future Phases)

- Damage resistance/immunity (v0.0.9)
- Set bonuses (future)
- Enchantments (future)
- Equipment durability (future)
- Equipment slots expanding (multiple rings, etc.) (future)

---

## Data Model

### New: ArmorType (Enum)

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the type of armor, affecting defense bonuses and restrictions.
/// </summary>
/// <remarks>
/// Armor types represent a trade-off between protection and mobility:
/// - Light: Low defense, no penalties, no requirements
/// - Medium: Moderate defense, slight penalty, some requirements
/// - Heavy: High defense, significant penalties, strict requirements
/// </remarks>
public enum ArmorType
{
    /// <summary>Light armor (leather, cloth). Minimal protection, no restrictions.</summary>
    Light,

    /// <summary>Medium armor (chain, scale). Balanced protection with minor penalties.</summary>
    Medium,

    /// <summary>Heavy armor (plate, full mail). Maximum protection, significant penalties.</summary>
    Heavy
}
```

### New: StatModifiers (Value Object)

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents stat modifiers provided by equipment when equipped.
/// </summary>
/// <remarks>
/// Unlike WeaponBonuses (which includes AttackModifier), StatModifiers is a general-purpose
/// value object for any equipment type. Multiple StatModifiers from different equipment
/// stack additively.
/// </remarks>
/// <param name="Might">Bonus to Might attribute.</param>
/// <param name="Fortitude">Bonus to Fortitude attribute.</param>
/// <param name="Will">Bonus to Will attribute.</param>
/// <param name="Wits">Bonus to Wits attribute.</param>
/// <param name="Finesse">Bonus to Finesse attribute.</param>
/// <param name="MaxHealth">Bonus to maximum health points.</param>
/// <param name="Defense">Bonus to defense (separate from armor defense bonus).</param>
public readonly record struct StatModifiers(
    int Might = 0,
    int Fortitude = 0,
    int Will = 0,
    int Wits = 0,
    int Finesse = 0,
    int MaxHealth = 0,
    int Defense = 0)
{
    /// <summary>
    /// Returns true if any modifier is non-zero.
    /// </summary>
    public bool HasModifiers => Might != 0 || Fortitude != 0 || Will != 0 ||
                                Wits != 0 || Finesse != 0 || MaxHealth != 0 || Defense != 0;

    /// <summary>
    /// Creates an empty modifiers instance.
    /// </summary>
    public static StatModifiers None => new();

    /// <summary>
    /// Combines two StatModifiers by adding their values.
    /// </summary>
    public static StatModifiers operator +(StatModifiers a, StatModifiers b) => new(
        Might: a.Might + b.Might,
        Fortitude: a.Fortitude + b.Fortitude,
        Will: a.Will + b.Will,
        Wits: a.Wits + b.Wits,
        Finesse: a.Finesse + b.Finesse,
        MaxHealth: a.MaxHealth + b.MaxHealth,
        Defense: a.Defense + b.Defense);

    /// <summary>
    /// Returns a display string of non-zero modifiers.
    /// </summary>
    public override string ToString()
    {
        var parts = new List<string>();
        if (Might != 0) parts.Add($"{FormatBonus(Might)} Might");
        if (Fortitude != 0) parts.Add($"{FormatBonus(Fortitude)} Fortitude");
        if (Will != 0) parts.Add($"{FormatBonus(Will)} Will");
        if (Wits != 0) parts.Add($"{FormatBonus(Wits)} Wits");
        if (Finesse != 0) parts.Add($"{FormatBonus(Finesse)} Finesse");
        if (MaxHealth != 0) parts.Add($"{FormatBonus(MaxHealth)} Max HP");
        if (Defense != 0) parts.Add($"{FormatBonus(Defense)} Defense");
        return parts.Count > 0 ? string.Join(", ", parts) : "None";
    }

    private static string FormatBonus(int value) => value > 0 ? $"+{value}" : value.ToString();
}
```

### New: EquipmentRequirements (Value Object)

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents requirements that must be met to equip an item.
/// </summary>
/// <remarks>
/// All specified requirements must be met. Null values indicate no requirement
/// for that attribute. Class requirements use class IDs from configuration.
/// </remarks>
/// <param name="MinMight">Minimum Might attribute required.</param>
/// <param name="MinFortitude">Minimum Fortitude attribute required.</param>
/// <param name="MinWill">Minimum Will attribute required.</param>
/// <param name="MinWits">Minimum Wits attribute required.</param>
/// <param name="MinFinesse">Minimum Finesse attribute required.</param>
/// <param name="RequiredClassIds">Class IDs that can equip this item. Null means any class.</param>
public readonly record struct EquipmentRequirements(
    int? MinMight = null,
    int? MinFortitude = null,
    int? MinWill = null,
    int? MinWits = null,
    int? MinFinesse = null,
    IReadOnlyList<string>? RequiredClassIds = null)
{
    /// <summary>
    /// Returns true if this item has any requirements.
    /// </summary>
    public bool HasRequirements => MinMight.HasValue || MinFortitude.HasValue ||
                                   MinWill.HasValue || MinWits.HasValue ||
                                   MinFinesse.HasValue || RequiredClassIds?.Count > 0;

    /// <summary>
    /// Creates a requirements instance with no requirements.
    /// </summary>
    public static EquipmentRequirements None => new();

    /// <summary>
    /// Creates requirements with Fortitude requirement only.
    /// </summary>
    public static EquipmentRequirements ForFortitude(int min) => new(MinFortitude: min);

    /// <summary>
    /// Creates requirements with Might requirement only.
    /// </summary>
    public static EquipmentRequirements ForMight(int min) => new(MinMight: min);

    /// <summary>
    /// Creates requirements with class restriction.
    /// </summary>
    public static EquipmentRequirements ForClasses(params string[] classIds) =>
        new(RequiredClassIds: classIds.ToList().AsReadOnly());

    /// <summary>
    /// Checks if a player meets these requirements.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>True if all requirements are met.</returns>
    public bool MeetsRequirements(Player player)
    {
        if (player == null) return false;

        if (MinMight.HasValue && player.Attributes.Might < MinMight.Value)
            return false;
        if (MinFortitude.HasValue && player.Attributes.Fortitude < MinFortitude.Value)
            return false;
        if (MinWill.HasValue && player.Attributes.Will < MinWill.Value)
            return false;
        if (MinWits.HasValue && player.Attributes.Wits < MinWits.Value)
            return false;
        if (MinFinesse.HasValue && player.Attributes.Finesse < MinFinesse.Value)
            return false;

        if (RequiredClassIds?.Count > 0)
        {
            // Check if player's class is in the required list
            if (string.IsNullOrEmpty(player.ClassId))
                return false;
            if (!RequiredClassIds.Contains(player.ClassId, StringComparer.OrdinalIgnoreCase))
                return false;
        }

        return true;
    }

    /// <summary>
    /// Gets a list of unmet requirements for a player.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>List of requirement descriptions that are not met.</returns>
    public IReadOnlyList<string> GetUnmetRequirements(Player player)
    {
        var unmet = new List<string>();

        if (player == null)
        {
            unmet.Add("No player specified");
            return unmet;
        }

        if (MinMight.HasValue && player.Attributes.Might < MinMight.Value)
            unmet.Add($"Might {MinMight.Value} required (you have {player.Attributes.Might})");
        if (MinFortitude.HasValue && player.Attributes.Fortitude < MinFortitude.Value)
            unmet.Add($"Fortitude {MinFortitude.Value} required (you have {player.Attributes.Fortitude})");
        if (MinWill.HasValue && player.Attributes.Will < MinWill.Value)
            unmet.Add($"Will {MinWill.Value} required (you have {player.Attributes.Will})");
        if (MinWits.HasValue && player.Attributes.Wits < MinWits.Value)
            unmet.Add($"Wits {MinWits.Value} required (you have {player.Attributes.Wits})");
        if (MinFinesse.HasValue && player.Attributes.Finesse < MinFinesse.Value)
            unmet.Add($"Finesse {MinFinesse.Value} required (you have {player.Attributes.Finesse})");

        if (RequiredClassIds?.Count > 0)
        {
            if (string.IsNullOrEmpty(player.ClassId) ||
                !RequiredClassIds.Contains(player.ClassId, StringComparer.OrdinalIgnoreCase))
            {
                var classes = string.Join(", ", RequiredClassIds);
                unmet.Add($"Class must be one of: {classes}");
            }
        }

        return unmet;
    }

    /// <summary>
    /// Returns a display string of all requirements.
    /// </summary>
    public override string ToString()
    {
        var parts = new List<string>();
        if (MinMight.HasValue) parts.Add($"Might {MinMight.Value}");
        if (MinFortitude.HasValue) parts.Add($"Fortitude {MinFortitude.Value}");
        if (MinWill.HasValue) parts.Add($"Will {MinWill.Value}");
        if (MinWits.HasValue) parts.Add($"Wits {MinWits.Value}");
        if (MinFinesse.HasValue) parts.Add($"Finesse {MinFinesse.Value}");
        if (RequiredClassIds?.Count > 0) parts.Add($"Class: {string.Join("/", RequiredClassIds)}");
        return parts.Count > 0 ? string.Join(", ", parts) : "None";
    }
}
```

### Modified: Item (Entity)

```csharp
// Add to existing Item entity:

/// <summary>
/// Gets the type of armor this item is, or null if not armor.
/// </summary>
/// <remarks>
/// Armor type affects defense bonus amounts and any associated penalties.
/// Items with ArmorType should have appropriate EquipmentSlot (Armor, Shield, Helmet, Boots).
/// </remarks>
public ArmorType? ArmorType { get; private set; }

/// <summary>
/// Gets the defense bonus provided by this item when equipped.
/// </summary>
/// <remarks>
/// Defense bonus is added to the player's base defense. Stacks with other
/// equipped items' defense bonuses.
/// </remarks>
public int DefenseBonus { get; private set; }

/// <summary>
/// Gets the stat modifiers provided by this item when equipped.
/// </summary>
/// <remarks>
/// General-purpose stat modifiers that apply while equipped.
/// Separate from weapon-specific bonuses (WeaponBonuses).
/// </remarks>
public StatModifiers StatModifiers { get; private set; } = StatModifiers.None;

/// <summary>
/// Gets the initiative penalty from this item (typically heavy armor).
/// </summary>
/// <remarks>
/// Penalty is subtracted from initiative rolls, making the wearer act later in combat.
/// Should be 0 or negative.
/// </remarks>
public int InitiativePenalty { get; private set; }

/// <summary>
/// Gets the requirements to equip this item.
/// </summary>
/// <remarks>
/// If requirements are set, player must meet all conditions to equip the item.
/// Null or empty requirements mean anyone can equip.
/// </remarks>
public EquipmentRequirements Requirements { get; private set; } = EquipmentRequirements.None;

/// <summary>
/// Gets whether this item is armor.
/// </summary>
public bool IsArmor => ArmorType.HasValue;

/// <summary>
/// Gets whether this item has any requirements.
/// </summary>
public bool HasRequirements => Requirements.HasRequirements;

// Update constructor to accept armor properties:
public Item(
    string name,
    string description,
    ItemType type,
    int value = 0,
    ItemEffect effect = ItemEffect.None,
    int effectValue = 0,
    int effectDuration = 0,
    EquipmentSlot? equipmentSlot = null,
    string? damageDice = null,
    WeaponType? weaponType = null,
    WeaponBonuses? weaponBonuses = null,
    ArmorType? armorType = null,             // NEW
    int defenseBonus = 0,                    // NEW
    StatModifiers? statModifiers = null,     // NEW
    int initiativePenalty = 0,               // NEW
    EquipmentRequirements? requirements = null) // NEW
{
    // ... existing assignments ...
    ArmorType = armorType;
    DefenseBonus = defenseBonus;
    StatModifiers = statModifiers ?? StatModifiers.None;
    InitiativePenalty = initiativePenalty;
    Requirements = requirements ?? EquipmentRequirements.None;
}

// Add factory methods for armor:
public static Item CreateLeatherArmor() => new(
    "Leather Armor",
    "Simple armor made of tanned leather. Provides basic protection.",
    ItemType.Armor,
    value: 30,
    equipmentSlot: Enums.EquipmentSlot.Armor,
    armorType: Enums.ArmorType.Light,
    defenseBonus: 2
);

public static Item CreateChainMail() => new(
    "Chain Mail",
    "Interlocking metal rings providing solid protection.",
    ItemType.Armor,
    value: 100,
    equipmentSlot: Enums.EquipmentSlot.Armor,
    armorType: Enums.ArmorType.Medium,
    defenseBonus: 4,
    initiativePenalty: -1,
    requirements: EquipmentRequirements.ForFortitude(12)
);

public static Item CreatePlateArmor() => new(
    "Plate Armor",
    "Full plate armor offering maximum protection at the cost of mobility.",
    ItemType.Armor,
    value: 500,
    equipmentSlot: Enums.EquipmentSlot.Armor,
    armorType: Enums.ArmorType.Heavy,
    defenseBonus: 6,
    initiativePenalty: -3,
    requirements: new EquipmentRequirements(MinFortitude: 14, MinMight: 12)
);

public static Item CreateRingOfStrength() => new(
    "Ring of Strength",
    "A silver ring that enhances the wearer's physical power.",
    ItemType.Misc,
    value: 200,
    equipmentSlot: Enums.EquipmentSlot.Ring,
    statModifiers: new StatModifiers(Might: 2)
);

public static Item CreateAmuletOfVitality() => new(
    "Amulet of Vitality",
    "A ruby amulet that bolsters the wearer's constitution.",
    ItemType.Misc,
    value: 250,
    equipmentSlot: Enums.EquipmentSlot.Amulet,
    statModifiers: new StatModifiers(Fortitude: 2, MaxHealth: 10)
);
```

### Modified: Player (Entity)

```csharp
// Add to existing Player entity:

/// <summary>
/// Calculates the player's effective stats including equipment bonuses.
/// </summary>
/// <returns>Stats with all equipment bonuses applied.</returns>
/// <remarks>
/// Defense is calculated as: Base Defense + Sum of all DefenseBonus from equipment + StatModifiers.Defense
/// </remarks>
public Stats GetEffectiveStats()
{
    var totalDefenseBonus = 0;
    var totalStatModifiers = StatModifiers.None;

    foreach (var (slot, item) in Equipment)
    {
        totalDefenseBonus += item.DefenseBonus;
        totalStatModifiers += item.StatModifiers;
    }

    return new Stats(
        Attack: Stats.Attack,
        Defense: Stats.Defense + totalDefenseBonus + totalStatModifiers.Defense,
        MaxHealth: Stats.MaxHealth + totalStatModifiers.MaxHealth
    );
}

/// <summary>
/// Calculates the player's effective attributes including equipment bonuses.
/// </summary>
/// <returns>Attributes with all equipment bonuses applied.</returns>
/// <remarks>
/// Combines base attributes with:
/// - WeaponBonuses from equipped weapon
/// - StatModifiers from all equipped items
/// </remarks>
public PlayerAttributes GetEffectiveAttributes()
{
    var totalStatModifiers = StatModifiers.None;
    var weaponBonuses = WeaponBonuses.None;

    foreach (var (slot, item) in Equipment)
    {
        totalStatModifiers += item.StatModifiers;

        if (slot == EquipmentSlot.Weapon && item.IsWeapon)
        {
            weaponBonuses = item.WeaponBonuses;
        }
    }

    return new PlayerAttributes(
        Might: Attributes.Might + totalStatModifiers.Might + weaponBonuses.Might,
        Fortitude: Attributes.Fortitude + totalStatModifiers.Fortitude + weaponBonuses.Fortitude,
        Will: Attributes.Will + totalStatModifiers.Will + weaponBonuses.Will,
        Wits: Attributes.Wits + totalStatModifiers.Wits + weaponBonuses.Wits,
        Finesse: Attributes.Finesse + totalStatModifiers.Finesse + weaponBonuses.Finesse
    );
}

/// <summary>
/// Gets the total initiative penalty from all equipped items.
/// </summary>
/// <returns>Total initiative penalty (should be 0 or negative).</returns>
public int GetTotalInitiativePenalty()
{
    var penalty = 0;
    foreach (var (_, item) in Equipment)
    {
        penalty += item.InitiativePenalty;
    }
    return penalty;
}

/// <summary>
/// Gets the total defense bonus from all equipped armor and items.
/// </summary>
/// <returns>Sum of all defense bonuses.</returns>
public int GetTotalDefenseBonus()
{
    var bonus = 0;
    foreach (var (_, item) in Equipment)
    {
        bonus += item.DefenseBonus;
        bonus += item.StatModifiers.Defense;
    }
    return bonus;
}
```

---

## Services

### Modified: EquipmentService

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Service for managing player equipment operations.
/// </summary>
public class EquipmentService
{
    private readonly ILogger<EquipmentService> _logger;

    public EquipmentService(ILogger<EquipmentService> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Checks if a player can equip an item, considering requirements.
    /// </summary>
    /// <param name="player">The player attempting to equip.</param>
    /// <param name="item">The item to equip.</param>
    /// <returns>A tuple of (canEquip, unmetRequirements).</returns>
    public (bool CanEquip, IReadOnlyList<string> UnmetRequirements) CanEquip(Player player, Item item)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(item);

        // Check if item is equippable
        if (!item.IsEquippable)
        {
            return (false, new[] { $"The {item.Name} cannot be equipped." });
        }

        // Check requirements
        if (item.HasRequirements)
        {
            var unmet = item.Requirements.GetUnmetRequirements(player);
            if (unmet.Count > 0)
            {
                _logger.LogDebug(
                    "Player {Player} does not meet requirements for {Item}: {Requirements}",
                    player.Name, item.Name, string.Join(", ", unmet));
                return (false, unmet);
            }
        }

        return (true, Array.Empty<string>());
    }

    /// <summary>
    /// Attempts to equip an item from the player's inventory.
    /// </summary>
    /// <param name="player">The player equipping the item.</param>
    /// <param name="itemName">The name of the item to equip.</param>
    /// <returns>The result of the equip operation.</returns>
    public EquipResult TryEquipByName(Player player, string itemName)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentException.ThrowIfNullOrWhiteSpace(itemName);

        _logger.LogDebug("Attempting to equip '{ItemName}' for player {Player}", itemName, player.Name);

        // Find item in inventory
        var item = player.Inventory.GetByName(itemName);
        if (item == null)
        {
            _logger.LogDebug("Item '{ItemName}' not found in inventory", itemName);
            return EquipResult.ItemNotFound(itemName);
        }

        return TryEquip(player, item);
    }

    /// <summary>
    /// Attempts to equip a specific item from the player's inventory.
    /// </summary>
    public EquipResult TryEquip(Player player, Item item)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(item);

        // Check if item is equippable
        if (!item.IsEquippable)
        {
            _logger.LogDebug("Item '{ItemName}' is not equippable", item.Name);
            return EquipResult.NotEquippable(item);
        }

        // Check requirements
        var (canEquip, unmetRequirements) = CanEquip(player, item);
        if (!canEquip)
        {
            _logger.LogDebug(
                "Player {Player} cannot equip {Item}: {Requirements}",
                player.Name, item.Name, string.Join(", ", unmetRequirements));
            return EquipResult.RequirementsNotMet(item, unmetRequirements);
        }

        var slot = item.EquipmentSlot!.Value;
        Item? replacedItem = null;

        // Check if slot is occupied
        if (player.IsSlotOccupied(slot))
        {
            var currentItem = player.GetEquippedItem(slot)!;

            if (player.Inventory.IsFull)
            {
                _logger.LogDebug("Cannot swap equipment - inventory is full");
                return EquipResult.InventoryFull();
            }

            player.Unequip(slot);
            player.Inventory.TryAdd(currentItem);
            replacedItem = currentItem;

            _logger.LogDebug("Unequipped '{OldItem}' to make room for '{NewItem}'",
                currentItem.Name, item.Name);
        }

        // Remove item from inventory and equip it
        player.Inventory.Remove(item);
        player.TryEquip(item);

        _logger.LogInformation("Player {Player} equipped '{Item}' to {Slot} slot",
            player.Name, item.Name, slot);

        return EquipResult.Equipped(item, replacedItem);
    }

    /// <summary>
    /// Attempts to unequip an item from the specified slot.
    /// </summary>
    public EquipResult TryUnequip(Player player, EquipmentSlot slot)
    {
        ArgumentNullException.ThrowIfNull(player);

        _logger.LogDebug("Attempting to unequip from {Slot} slot for player {Player}",
            slot, player.Name);

        if (!player.IsSlotOccupied(slot))
        {
            _logger.LogDebug("Slot {Slot} is empty", slot);
            return EquipResult.SlotEmpty(slot);
        }

        if (player.Inventory.IsFull)
        {
            _logger.LogDebug("Cannot unequip - inventory is full");
            return EquipResult.InventoryFull();
        }

        var item = player.Unequip(slot)!;
        player.Inventory.TryAdd(item);

        _logger.LogInformation("Player {Player} unequipped '{Item}' from {Slot} slot",
            player.Name, item.Name, slot);

        return EquipResult.Unequipped(item);
    }

    /// <summary>
    /// Parses a slot name string to an EquipmentSlot enum value.
    /// </summary>
    public static bool TryParseSlot(string? slotName, out EquipmentSlot slot)
    {
        slot = default;
        if (string.IsNullOrWhiteSpace(slotName))
            return false;
        return Enum.TryParse(slotName, ignoreCase: true, out slot);
    }
}
```

### Modified: EquipResult (Value Object)

```csharp
// Add to existing EquipResult:

/// <summary>
/// Creates a failure for unmet requirements.
/// </summary>
/// <param name="item">The item that couldn't be equipped.</param>
/// <param name="unmetRequirements">List of requirement descriptions.</param>
public static EquipResult RequirementsNotMet(Item item, IReadOnlyList<string> unmetRequirements)
{
    var message = $"You cannot equip {item.Name}.\nRequirements not met:\n" +
                  string.Join("\n", unmetRequirements.Select(r => $"  - {r}"));
    return new(false, message, null, null);
}
```

---

## Command Changes

### Updated Equipment Command Output

The `equipment` command now shows defense and stat bonuses:

```csharp
// In GameView or GameSessionService

/// <summary>
/// Gets equipment display data including stats.
/// </summary>
public EquipmentDisplayDto GetEquipmentDisplay(Player player)
{
    var effectiveStats = player.GetEffectiveStats();
    var effectiveAttributes = player.GetEffectiveAttributes();
    var initiativePenalty = player.GetTotalInitiativePenalty();
    var defenseBonus = player.GetTotalDefenseBonus();

    return new EquipmentDisplayDto(
        Slots: EquipmentSlotsDto.FromPlayer(player),
        BaseDefense: player.Stats.Defense,
        TotalDefense: effectiveStats.Defense,
        InitiativePenalty: initiativePenalty,
        AttributeBonuses: GetAttributeBonusesDisplay(player)
    );
}
```

### User Commands

| Command | Description | Example |
|---------|-------------|---------|
| `equip <item>` | Equip item (checks requirements) | `equip Plate Armor` |
| `unequip <slot>` | Remove equipment from slot | `unequip armor` |
| `equipment` | Shows all equipment with stats | `equipment` |
| `examine <item>` | Shows item details including requirements | `examine Plate Armor` |

---

## Rendering Changes

### IGameRenderer Updates

```csharp
/// <summary>
/// Renders equipment with stat summary.
/// </summary>
/// <param name="equipment">The equipment display data.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderEquipmentWithStatsAsync(EquipmentDisplayDto equipment, CancellationToken ct = default);

/// <summary>
/// Renders an equip failure due to unmet requirements.
/// </summary>
/// <param name="itemName">The item that couldn't be equipped.</param>
/// <param name="requirements">List of unmet requirements.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderRequirementsNotMetAsync(string itemName, IReadOnlyList<string> requirements, CancellationToken ct = default);
```

### DTOs

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying armor information.
/// </summary>
public record ArmorDto(
    string Name,
    string ArmorType,
    int DefenseBonus,
    int InitiativePenalty,
    string Description,
    string? StatBonuses = null,
    string? Requirements = null)
{
    public static ArmorDto? FromItem(Item item)
    {
        if (!item.IsArmor || item.ArmorType == null)
            return null;

        return new ArmorDto(
            item.Name,
            item.ArmorType.Value.ToString(),
            item.DefenseBonus,
            item.InitiativePenalty,
            item.Description,
            item.StatModifiers.HasModifiers ? item.StatModifiers.ToString() : null,
            item.HasRequirements ? item.Requirements.ToString() : null);
    }
}

/// <summary>
/// DTO for equipment display with stat summary.
/// </summary>
public record EquipmentDisplayDto(
    EquipmentSlotsDto Slots,
    int BaseDefense,
    int TotalDefense,
    int InitiativePenalty,
    string? AttributeBonuses = null);
```

### Display Examples

**Equipment Command with Stats:**
```
> equipment

╭─────────────────────────────────────────╮
│             ⚔ Equipment ⚔               │
├─────────────────────────────────────────┤
│  Weapon:  Iron Sword                    │
│           Type: Sword | Damage: 1d8     │
│                                         │
│  Armor:   Chain Mail                    │
│           Type: Medium | Defense: +4    │
│           Initiative: -1                │
│                                         │
│  Shield:  Wooden Shield                 │
│           Defense: +1                   │
│                                         │
│  Helmet:  (empty)                       │
│  Boots:   (empty)                       │
│                                         │
│  Ring:    Ring of Strength              │
│           +2 Might                      │
│                                         │
│  Amulet:  (empty)                       │
├─────────────────────────────────────────┤
│  STATS SUMMARY                          │
│  Defense: 5 base + 5 equipment = 10     │
│  Initiative: -1 (armor penalty)         │
│  Might: 12 base + 2 equipment = 14      │
╰─────────────────────────────────────────╯
```

**Status Command with Equipment Bonuses:**
```
> status

=== Hero (Level 1 Warrior) ===
HP: 100/100

Attributes:
  Might:     12 (+2) = 14
  Fortitude: 10
  Will:       8
  Wits:      10
  Finesse:   14

Combat:
  Defense:    5 (+5 from equipment) = 10
  Initiative: -1 (Chain Mail penalty)
```

**Equip Failure (Requirements):**
```
> equip Plate Armor

You cannot equip Plate Armor.
Requirements not met:
  - Fortitude 14 required (you have 10)
  - Might 12 required (you have 11)
```

**Item Examine (with Requirements):**
```
> examine Plate Armor

╭─────────────────────────────────────────╮
│  Plate Armor                            │
├─────────────────────────────────────────┤
│  Full plate armor offering maximum      │
│  protection at the cost of mobility.    │
│                                         │
│  Type: Heavy Armor                      │
│  Slot: Armor                            │
│  Defense: +6                            │
│  Initiative: -3                         │
│  Value: 500 gold                        │
│                                         │
│  REQUIREMENTS:                          │
│  ├─ Fortitude: 14                       │
│  └─ Might: 12                           │
╰─────────────────────────────────────────╯
```

---

## Configuration

### armor.json

```json
{
  "$schema": "armor.schema.json",
  "armor": [
    {
      "id": "cloth_robe",
      "name": "Cloth Robe",
      "description": "A simple cloth robe. Offers almost no protection.",
      "armorType": "Light",
      "slot": "Armor",
      "defenseBonus": 1,
      "initiativePenalty": 0,
      "value": 10
    },
    {
      "id": "leather_armor",
      "name": "Leather Armor",
      "description": "Simple armor made of tanned leather. Provides basic protection.",
      "armorType": "Light",
      "slot": "Armor",
      "defenseBonus": 2,
      "initiativePenalty": 0,
      "value": 30
    },
    {
      "id": "studded_leather",
      "name": "Studded Leather",
      "description": "Leather armor reinforced with metal studs.",
      "armorType": "Light",
      "slot": "Armor",
      "defenseBonus": 3,
      "initiativePenalty": 0,
      "value": 60
    },
    {
      "id": "chain_mail",
      "name": "Chain Mail",
      "description": "Interlocking metal rings providing solid protection.",
      "armorType": "Medium",
      "slot": "Armor",
      "defenseBonus": 4,
      "initiativePenalty": -1,
      "requirements": { "minFortitude": 12 },
      "value": 100
    },
    {
      "id": "scale_mail",
      "name": "Scale Mail",
      "description": "Overlapping metal scales on a leather backing.",
      "armorType": "Medium",
      "slot": "Armor",
      "defenseBonus": 5,
      "initiativePenalty": -2,
      "requirements": { "minFortitude": 13 },
      "value": 200
    },
    {
      "id": "plate_armor",
      "name": "Plate Armor",
      "description": "Full plate armor offering maximum protection at the cost of mobility.",
      "armorType": "Heavy",
      "slot": "Armor",
      "defenseBonus": 6,
      "initiativePenalty": -3,
      "requirements": { "minFortitude": 14, "minMight": 12 },
      "value": 500
    },
    {
      "id": "mithril_plate",
      "name": "Mithril Plate",
      "description": "Legendary armor forged from mithril. Strong as steel, light as cloth.",
      "armorType": "Heavy",
      "slot": "Armor",
      "defenseBonus": 7,
      "initiativePenalty": -1,
      "requirements": { "minFortitude": 12 },
      "value": 2000
    },
    {
      "id": "wooden_shield",
      "name": "Wooden Shield",
      "description": "A basic wooden shield. Better than nothing.",
      "armorType": "Light",
      "slot": "Shield",
      "defenseBonus": 1,
      "initiativePenalty": 0,
      "value": 15
    },
    {
      "id": "iron_shield",
      "name": "Iron Shield",
      "description": "A sturdy iron shield.",
      "armorType": "Medium",
      "slot": "Shield",
      "defenseBonus": 2,
      "initiativePenalty": 0,
      "requirements": { "minMight": 10 },
      "value": 50
    },
    {
      "id": "tower_shield",
      "name": "Tower Shield",
      "description": "A massive shield that covers most of the body.",
      "armorType": "Heavy",
      "slot": "Shield",
      "defenseBonus": 3,
      "initiativePenalty": -1,
      "requirements": { "minMight": 14, "minFortitude": 12 },
      "value": 150
    },
    {
      "id": "leather_helm",
      "name": "Leather Helm",
      "description": "A simple leather cap offering minimal head protection.",
      "armorType": "Light",
      "slot": "Helmet",
      "defenseBonus": 1,
      "initiativePenalty": 0,
      "value": 20
    },
    {
      "id": "iron_helmet",
      "name": "Iron Helmet",
      "description": "A solid iron helmet.",
      "armorType": "Medium",
      "slot": "Helmet",
      "defenseBonus": 2,
      "initiativePenalty": 0,
      "value": 40
    },
    {
      "id": "leather_boots",
      "name": "Leather Boots",
      "description": "Sturdy leather boots for travel.",
      "armorType": "Light",
      "slot": "Boots",
      "defenseBonus": 0,
      "initiativePenalty": 0,
      "statBonuses": { "finesse": 1 },
      "value": 25
    },
    {
      "id": "iron_boots",
      "name": "Iron Boots",
      "description": "Heavy iron boots. Protective but cumbersome.",
      "armorType": "Heavy",
      "slot": "Boots",
      "defenseBonus": 1,
      "initiativePenalty": -1,
      "requirements": { "minFortitude": 10 },
      "value": 60
    }
  ],
  "accessories": [
    {
      "id": "ring_of_strength",
      "name": "Ring of Strength",
      "description": "A silver ring that enhances the wearer's physical power.",
      "slot": "Ring",
      "statBonuses": { "might": 2 },
      "value": 200
    },
    {
      "id": "ring_of_protection",
      "name": "Ring of Protection",
      "description": "A gold ring enchanted to ward off harm.",
      "slot": "Ring",
      "statBonuses": { "defense": 1 },
      "value": 250
    },
    {
      "id": "amulet_of_vitality",
      "name": "Amulet of Vitality",
      "description": "A ruby amulet that bolsters the wearer's constitution.",
      "slot": "Amulet",
      "statBonuses": { "fortitude": 2, "maxHealth": 10 },
      "value": 250
    },
    {
      "id": "amulet_of_wisdom",
      "name": "Amulet of Wisdom",
      "description": "A sapphire amulet that sharpens the mind.",
      "slot": "Amulet",
      "statBonuses": { "will": 2, "wits": 1 },
      "value": 275
    }
  ]
}
```

### Configuration Schema

#### Armor Properties

| Property | Type | Required | Default | Description |
|----------|------|----------|---------|-------------|
| `id` | string | Yes | - | Unique identifier |
| `name` | string | Yes | - | Display name |
| `description` | string | Yes | - | Item description |
| `armorType` | string | Yes | - | One of: Light, Medium, Heavy |
| `slot` | string | Yes | - | Equipment slot (Armor, Shield, Helmet, Boots) |
| `defenseBonus` | int | No | 0 | Defense bonus when equipped |
| `initiativePenalty` | int | No | 0 | Initiative penalty (negative) |
| `value` | int | No | 0 | Gold value |
| `requirements` | object | No | null | Equip requirements |
| `statBonuses` | object | No | null | Stat bonuses when equipped |

#### Requirements Schema

| Property | Type | Description |
|----------|------|-------------|
| `minMight` | int | Minimum Might required |
| `minFortitude` | int | Minimum Fortitude required |
| `minWill` | int | Minimum Will required |
| `minWits` | int | Minimum Wits required |
| `minFinesse` | int | Minimum Finesse required |
| `requiredClasses` | string[] | List of class IDs that can equip |

---

## Acceptance Criteria

### ArmorType Enum
- [ ] `ArmorType` enum contains Light, Medium, Heavy
- [ ] Enum can be parsed from strings (case-insensitive)

### StatModifiers Value Object
- [ ] Can create modifiers with various attribute combinations
- [ ] `HasModifiers` correctly identifies non-zero modifiers
- [ ] Operator `+` correctly combines two StatModifiers
- [ ] `ToString()` formats modifiers for display

### EquipmentRequirements Value Object
- [ ] Can create requirements with attribute minimums
- [ ] Can create requirements with class restrictions
- [ ] `MeetsRequirements()` correctly validates player
- [ ] `GetUnmetRequirements()` returns descriptive list
- [ ] `HasRequirements` correctly identifies requirements

### Item Entity
- [ ] Items have `ArmorType` property (nullable)
- [ ] Items have `DefenseBonus` property
- [ ] Items have `StatModifiers` property
- [ ] Items have `InitiativePenalty` property
- [ ] Items have `Requirements` property
- [ ] `IsArmor` returns true for armor items
- [ ] Factory methods create correct armor items

### Player Entity
- [ ] `GetEffectiveStats()` includes equipment defense bonuses
- [ ] `GetEffectiveAttributes()` includes equipment stat bonuses
- [ ] `GetTotalInitiativePenalty()` sums all penalties
- [ ] `GetTotalDefenseBonus()` sums all defense bonuses

### EquipmentService
- [ ] `CanEquip()` validates item requirements
- [ ] `TryEquip()` fails with clear message when requirements not met
- [ ] `TryEquip()` succeeds when requirements are met
- [ ] Requirement failure shows all unmet requirements

### Configuration
- [ ] `armor.json` loads successfully
- [ ] All armor defined with correct properties
- [ ] Accessories defined with stat bonuses

### Display
- [ ] Equipment command shows defense totals
- [ ] Equipment command shows initiative penalties
- [ ] Equipment command shows stat bonuses
- [ ] Status command shows effective stats
- [ ] Equip failure clearly explains unmet requirements

### General
- [ ] ~12 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Test Specifications

### Unit Tests (~12 tests)

#### ArmorTypeTests.cs
```csharp
[TestFixture]
public class ArmorTypeTests
{
    [Test]
    public void ArmorType_ContainsAllExpectedValues();

    [Test]
    public void TryParse_ValidArmorType_ReturnsTrue();
}
```

#### StatModifiersTests.cs
```csharp
[TestFixture]
public class StatModifiersTests
{
    [Test]
    public void None_HasNoModifiers();

    [Test]
    public void HasModifiers_WithNonZeroValue_ReturnsTrue();

    [Test]
    public void AdditionOperator_CombinesModifiers();

    [Test]
    public void ToString_FormatsCorrectly();
}
```

#### EquipmentRequirementsTests.cs
```csharp
[TestFixture]
public class EquipmentRequirementsTests
{
    [Test]
    public void None_HasNoRequirements();

    [Test]
    public void MeetsRequirements_WhenMet_ReturnsTrue();

    [Test]
    public void MeetsRequirements_WhenNotMet_ReturnsFalse();

    [Test]
    public void GetUnmetRequirements_ReturnsDescriptiveList();

    [Test]
    public void ForClasses_CreatesClassRequirement();
}
```

#### PlayerEffectiveStatsTests.cs
```csharp
[TestFixture]
public class PlayerEffectiveStatsTests
{
    [Test]
    public void GetEffectiveStats_WithArmor_IncludesDefenseBonus();

    [Test]
    public void GetEffectiveAttributes_WithStatModifiers_IncludesBonuses();

    [Test]
    public void GetTotalInitiativePenalty_SumsAllPenalties();
}
```

#### EquipmentServiceRequirementsTests.cs
```csharp
[TestFixture]
public class EquipmentServiceRequirementsTests
{
    [Test]
    public void TryEquip_RequirementsMet_Succeeds();

    [Test]
    public void TryEquip_RequirementsNotMet_Fails();

    [Test]
    public void CanEquip_ReturnsUnmetRequirements();
}
```

---

## Dependencies

### Required from Previous Versions

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `EquipmentSlot` | `Domain/Enums/EquipmentSlot.cs` | Armor slots |
| `Player.Equipment` | `Domain/Entities/Player.cs` | Equipment dictionary |
| `EquipmentService` | `Domain/Services/EquipmentService.cs` | Extended with requirements |
| `EquipResult` | `Domain/ValueObjects/EquipResult.cs` | Extended with requirements failure |
| `WeaponBonuses` | `Domain/ValueObjects/WeaponBonuses.cs` | Combined with StatModifiers |

### Provides to Future Versions

| Type | Usage |
|------|-------|
| `StatModifiers` | General equipment bonuses |
| `EquipmentRequirements` | Reusable requirement validation |
| `GetEffectiveStats/Attributes` | Combat calculations, display |
| Configuration pattern | Other equipment types |

---

## Files Summary

### Files to Create (New)

| File | Purpose |
|------|---------|
| `src/Core/RuneAndRust.Domain/Enums/ArmorType.cs` | Armor type enum |
| `src/Core/RuneAndRust.Domain/ValueObjects/StatModifiers.cs` | Stat modifier value object |
| `src/Core/RuneAndRust.Domain/ValueObjects/EquipmentRequirements.cs` | Requirements value object |
| `src/Core/RuneAndRust.Application/DTOs/ArmorDto.cs` | Armor display DTO |
| `config/armor.json` | Armor and accessory definitions |
| `tests/RuneAndRust.Domain.UnitTests/Enums/ArmorTypeTests.cs` | Enum tests |
| `tests/RuneAndRust.Domain.UnitTests/ValueObjects/StatModifiersTests.cs` | Value object tests |
| `tests/RuneAndRust.Domain.UnitTests/ValueObjects/EquipmentRequirementsTests.cs` | Requirements tests |
| `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerEffectiveStatsTests.cs` | Effective stats tests |
| `tests/RuneAndRust.Domain.UnitTests/Services/EquipmentServiceRequirementsTests.cs` | Service tests |

### Files to Modify

| File | Changes |
|------|---------|
| `src/Core/RuneAndRust.Domain/Entities/Item.cs` | Add armor properties, requirements |
| `src/Core/RuneAndRust.Domain/Entities/Player.cs` | Add GetEffectiveStats/Attributes methods |
| `src/Core/RuneAndRust.Domain/Services/EquipmentService.cs` | Add requirement validation |
| `src/Core/RuneAndRust.Domain/ValueObjects/EquipResult.cs` | Add RequirementsNotMet result |
| `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs` | Show armor stats, requirements |

---

*This design specification completes the v0.0.7 Equipment System. With v0.0.7a (Core Infrastructure), v0.0.7b (Weapons), and v0.0.7c (Armor & Requirements), players now have a full equipment system that affects combat through damage dice, defense bonuses, stat modifiers, and progression-gated requirements.*
