# v0.13.2c Design Specification: Prerequisite Lines

**Version:** 0.13.2c
**Parent:** v0.13.2 (Ability Tree UI)
**Prerequisites:** v0.13.2a Complete (Tree Visualization), v0.13.2b Complete (Node Display & States)
**Status:** Design Complete
**Estimated Unit Tests:** ~4

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Prerequisite Lines Component](#4-prerequisite-lines-component)
   - 4.1 [PrerequisiteLines Class](#41-prerequisitelines-class)
   - 4.2 [Line State Determination](#42-line-state-determination)
   - 4.3 [Connection Rendering](#43-connection-rendering)
5. [Line Renderer](#5-line-renderer)
   - 5.1 [LineRenderer Class](#51-linerenderer-class)
   - 5.2 [Line Characters](#52-line-characters)
   - 5.3 [Path Calculation](#53-path-calculation)
6. [Line State Display](#6-line-state-display)
   - 6.1 [Satisfied Lines](#61-satisfied-lines)
   - 6.2 [Unsatisfied Lines](#62-unsatisfied-lines)
7. [Data Model Changes](#7-data-model-changes)
8. [Configuration File Schemas](#8-configuration-file-schemas)
9. [AbilityTreeView Integration](#9-abilitytreeview-integration)
10. [Logging Specifications](#10-logging-specifications)
11. [Unit Testing Requirements](#11-unit-testing-requirements)
12. [Use Cases](#12-use-cases)
13. [Deliverable Checklist](#13-deliverable-checklist)
14. [Acceptance Criteria](#14-acceptance-criteria)
15. [Dependencies](#15-dependencies)
16. [Future Considerations](#16-future-considerations)

---

## 1. Executive Summary

This version implements prerequisite connection lines between ability tree nodes, showing dependencies with different visual states. Lines indicate whether prerequisites are satisfied (solid green) or unsatisfied (dashed gray), helping players understand progression paths. The component integrates with the existing AbilityTreeView from v0.13.2a and uses node state information from v0.13.2b to determine line states.

### Key Deliverables

| Category | Items |
|----------|-------|
| **UI Components** | `PrerequisiteLines` |
| **Renderers** | `LineRenderer` |
| **DTOs** | `PrerequisiteLineDto`, `LineSegmentDto` |
| **View Updates** | `AbilityTreeView` integration |
| **Configuration** | `prerequisite-lines.json` |
| **Tests** | ~4 unit tests |

### Architectural Significance

This version establishes the **Prerequisite Line Pattern** for ability tree visualization:
- Lines connect nodes across tiers showing prerequisite relationships
- Line state reflects whether the prerequisite has been satisfied
- Horizontal routing draws lines between tier columns
- The pattern supports the existing node position system from v0.13.2a
- Line colors coordinate with node state colors from v0.13.2b

---

## 2. Feature Overview

```
v0.13.2c Features
├── PrerequisiteLines (UI Component)
│   ├── RenderConnections(AbilityTreeDefinition, PlayerAbilityProgress)
│   ├── GetLineState(NodePrerequisite, PlayerAbilityProgress)
│   ├── DrawLine(Position, Position, LineState)
│   └── ClearLines()
│
├── LineRenderer (Renderer)
│   ├── GetLineCharacter(Direction)
│   ├── GetLineColor(LineState)
│   ├── CalculatePath(Position, Position)
│   └── FormatConnectionPoint(Direction)
│
├── Line States
│   ├── Satisfied: ────────── (Solid, Green)
│   └── Unsatisfied: - - - - - (Dashed, DarkGray)
│
├── Line Routing
│   ├── Horizontal Lines Between Tiers
│   ├── Connection to Node Edges
│   └── Multi-Prerequisite Support
│
└── AbilityTreeView Integration
    ├── Line Layer Rendering
    ├── Node State Coordination
    └── Refresh on State Change
```

### Scope Verification

| Feature | Source | Included |
|---------|--------|----------|
| Visual connections between dependent nodes | v0.13.2-scope-breakdown.md | Yes |
| Satisfied prerequisite line state | v0.13.2-scope-breakdown.md | Yes |
| Unsatisfied prerequisite line state | v0.13.2-scope-breakdown.md | Yes |
| Line routing between tiers | v0.13.2-scope-breakdown.md | Yes |
| Tree layout | v0.13.2-scope-breakdown.md | No (v0.13.2a) |
| Node state rendering | v0.13.2-scope-breakdown.md | No (v0.13.2b) |
| Tooltips | v0.13.2-scope-breakdown.md | No (v0.13.2d) |

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          PRESENTATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────┐      ┌─────────────────────────┐               │
│  │    AbilityTreeView      │      │   PrerequisiteLines     │               │
│  │    (v0.13.2a)           │◄────▶│   (NEW)                 │               │
│  ├─────────────────────────┤      ├─────────────────────────┤               │
│  │ - RenderTree()          │      │ - RenderConnections()   │               │
│  │ - RenderTiers()         │      │ - GetLineState()        │               │
│  │ - RenderNodesWithState()│      │ - DrawLine()            │               │
│  │ - RenderPrerequisites() │      │ - ClearLines()          │               │
│  └─────────────────────────┘      └───────────┬─────────────┘               │
│                                                │                             │
│  ┌─────────────────────────┐                   │                             │
│  │   TreeNodeRenderer      │                   │                             │
│  │   (v0.13.2b)            │                   │                             │
│  ├─────────────────────────┤                   │                             │
│  │ - RenderNode()          │                   │                             │
│  │ - GetNodeState()        │                   │                             │
│  │ - GetNodeBounds()       │                   │                             │
│  └─────────────────────────┘                   │                             │
│                                                │                             │
│  ┌─────────────────────────────────────────────┴───────────────────────────┐ │
│  │                     LineRenderer (NEW)                                   │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │ - GetLineCharacter()      - GetLineColor()                              │ │
│  │ - CalculatePath()         - FormatConnectionPoint()                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          APPLICATION LAYER                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    IAbilityTreeProvider (existing v0.10.2a)         │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + GetTreeForClass(classId) : AbilityTreeDefinition?                 │    │
│  │ + FindNode(nodeId) : AbilityTreeNode?                               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    IPrerequisiteValidator (existing v0.10.2c)       │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + CanUnlock(player, nodeId) : PrerequisiteResult                    │    │
│  │ + GetPrerequisitesForNode(nodeId) : IReadOnlyList<NodePrerequisite> │    │
│  │ + ArePrerequisitesMet(player, nodeId) : bool                        │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN LAYER                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────┐      ┌─────────────────────────┐               │
│  │    AbilityTreeNode      │      │  PlayerAbilityProgress  │               │
│  │   (existing v0.10.2a)   │      │   (existing v0.10.2a)   │               │
│  ├─────────────────────────┤      ├─────────────────────────┤               │
│  │ + NodeId: string        │      │ + PlayerId: Guid        │               │
│  │ + Name: string          │      │ + UnlockedNodeIds: set  │               │
│  │ + Tier: int             │      │ + HasUnlocked(nodeId)   │               │
│  │ + Position: NodePosition│      │ + GetRank(nodeId): int  │               │
│  │ + PrerequisiteNodeIds   │      └─────────────────────────┘               │
│  │ + HasPrerequisites      │                                                 │
│  └─────────────────────────┘                                                 │
│                                                                              │
│  ┌─────────────────────────┐      ┌─────────────────────────┐               │
│  │    NodePrerequisite     │      │     NodePosition        │               │
│  │   (existing v0.10.2a)   │      │   (existing v0.10.2a)   │               │
│  ├─────────────────────────┤      ├─────────────────────────┤               │
│  │ + RequiredNodeId: string│      │ + X: int                │               │
│  │ + RequiredRank: int     │      │ + Y: int                │               │
│  │ + RequiredTier: int     │      └─────────────────────────┘               │
│  └─────────────────────────┘                                                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Line State Determination Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    LINE STATE DETERMINATION FLOW                             │
└─────────────────────────────────────────────────────────────────────────────┘

    AbilityTreeNode + PlayerAbilityProgress Input
           │
           ▼
┌─────────────────────────┐
│  Get Prerequisite Nodes │
│  node.PrerequisiteNodeIds│
└───────────┬─────────────┘
            │
            │ For each prerequisite...
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Check Prerequisite Satisfaction                             │
│                                                              │
│  progress.HasUnlocked(prerequisiteNodeId)                    │
│     AND                                                      │
│  progress.GetRank(prerequisiteNodeId) >= requiredRank        │
└───────────┬─────────────────────────────────────────────────┘
            │
            ├─── Satisfied ──────► LineState.Satisfied
            │                      (solid green line)
            │
            │ Not Satisfied
            ▼
      LineState.Unsatisfied
      (dashed gray line)
```

### 3.3 Line Rendering Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    LINE RENDERING FLOW                                       │
└─────────────────────────────────────────────────────────────────────────────┘

    RenderConnections() Called
           │
           ▼
┌─────────────────────────┐
│  Clear Previous Lines   │
│  ClearLines()           │
└───────────┬─────────────┘
            │
            │ For each node with prerequisites...
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Get Node Positions                                          │
│                                                              │
│  Source Node: prerequisiteNodeId                             │
│  Target Node: current node                                   │
│                                                              │
│  sourcePos = _nodePositions[prerequisiteNodeId]              │
│  targetPos = _nodePositions[nodeId]                          │
└───────────┬─────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Determine Line State                                        │
│                                                              │
│  IsSatisfied = progress.HasUnlocked(prerequisiteNodeId)     │
│                AND rank >= requiredRank                      │
│                                                              │
│  state = IsSatisfied ? LineState.Satisfied                  │
│                      : LineState.Unsatisfied                │
└───────────┬─────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Calculate Path                                              │
│                                                              │
│  Start: Right edge of source node                           │
│  End: Left edge of target node                              │
│                                                              │
│  Path = horizontal line from source to target               │
└───────────┬─────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Draw Line                                                   │
│                                                              │
│  Satisfied:   ──────────── (solid, green)                   │
│  Unsatisfied: - - - - - -  (dashed, gray)                   │
│                                                              │
│  Write characters to terminal at calculated positions       │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. Prerequisite Lines Component

### 4.1 PrerequisiteLines Class

**Purpose:** Renders prerequisite connection lines between ability tree nodes with state-specific styling.

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/UI/PrerequisiteLines.cs`

```csharp
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Presentation.Tui.Renderers;
using RuneAndRust.Presentation.Tui.Services;
using RuneAndRust.Presentation.Tui.DTOs;
using RuneAndRust.Presentation.Tui.Configuration;

namespace RuneAndRust.Presentation.Tui.UI;

/// <summary>
/// Renders prerequisite connection lines between ability tree nodes.
/// </summary>
/// <remarks>
/// Lines show the dependency relationships between nodes. Satisfied
/// prerequisites display as solid green lines, while unsatisfied
/// prerequisites display as dashed gray lines.
/// </remarks>
public class PrerequisiteLines
{
    private readonly LineRenderer _lineRenderer;
    private readonly ITerminalService _terminalService;
    private readonly PrerequisiteLinesConfig _config;
    private readonly ILogger<PrerequisiteLines> _logger;

    private Dictionary<string, NodeScreenPosition> _nodePositions = new();
    private Dictionary<string, NodeBounds> _nodeBounds = new();
    private List<PrerequisiteLineDto> _renderedLines = new();

    /// <summary>
    /// Creates a new instance of the PrerequisiteLines component.
    /// </summary>
    /// <param name="lineRenderer">The renderer for line formatting.</param>
    /// <param name="terminalService">The terminal output service.</param>
    /// <param name="config">Configuration for line display settings.</param>
    /// <param name="logger">Logger for diagnostic output.</param>
    public PrerequisiteLines(
        LineRenderer lineRenderer,
        ITerminalService terminalService,
        PrerequisiteLinesConfig config,
        ILogger<PrerequisiteLines> logger)
    {
        _lineRenderer = lineRenderer ?? throw new ArgumentNullException(nameof(lineRenderer));
        _terminalService = terminalService ?? throw new ArgumentNullException(nameof(terminalService));
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Sets the node positions for line routing.
    /// </summary>
    /// <param name="positions">Dictionary mapping node IDs to screen positions.</param>
    /// <param name="bounds">Dictionary mapping node IDs to node bounds.</param>
    public void SetNodePositions(
        Dictionary<string, NodeScreenPosition> positions,
        Dictionary<string, NodeBounds> bounds)
    {
        _nodePositions = positions ?? throw new ArgumentNullException(nameof(positions));
        _nodeBounds = bounds ?? throw new ArgumentNullException(nameof(bounds));
    }

    /// <summary>
    /// Renders all prerequisite connection lines for the tree.
    /// </summary>
    /// <param name="tree">The ability tree definition.</param>
    /// <param name="progress">The player's ability progress.</param>
    public void RenderConnections(
        AbilityTreeDefinition tree,
        PlayerAbilityProgress progress)
    {
        // Clear any previously rendered lines
        ClearLines();

        var allNodes = tree.GetAllNodes();
        var linesRendered = 0;

        foreach (var node in allNodes)
        {
            if (!node.HasPrerequisites)
            {
                continue;
            }

            foreach (var prerequisiteNodeId in node.PrerequisiteNodeIds)
            {
                var lineState = GetLineState(prerequisiteNodeId, progress);
                DrawLine(prerequisiteNodeId, node.NodeId, lineState);
                linesRendered++;
            }
        }

        _logger.LogDebug(
            "Rendered {LineCount} prerequisite lines for tree {TreeId}",
            linesRendered,
            tree.TreeId);
    }

    /// <summary>
    /// Determines the line state based on prerequisite satisfaction.
    /// </summary>
    /// <param name="prerequisiteNodeId">The required node ID.</param>
    /// <param name="progress">The player's ability progress.</param>
    /// <returns>The line state (satisfied or unsatisfied).</returns>
    public LineState GetLineState(
        string prerequisiteNodeId,
        PlayerAbilityProgress progress)
    {
        // A prerequisite is satisfied if the player has unlocked the required node
        var isUnlocked = progress.HasUnlocked(prerequisiteNodeId);

        if (isUnlocked)
        {
            _logger.LogDebug(
                "Prerequisite {NodeId} is satisfied",
                prerequisiteNodeId);
            return LineState.Satisfied;
        }

        _logger.LogDebug(
            "Prerequisite {NodeId} is unsatisfied",
            prerequisiteNodeId);
        return LineState.Unsatisfied;
    }

    /// <summary>
    /// Draws a line between two nodes with the specified state.
    /// </summary>
    /// <param name="sourceNodeId">The prerequisite (source) node ID.</param>
    /// <param name="targetNodeId">The dependent (target) node ID.</param>
    /// <param name="state">The line state.</param>
    public void DrawLine(string sourceNodeId, string targetNodeId, LineState state)
    {
        if (!_nodePositions.TryGetValue(sourceNodeId, out var sourcePos))
        {
            _logger.LogWarning("No position found for source node {NodeId}", sourceNodeId);
            return;
        }

        if (!_nodePositions.TryGetValue(targetNodeId, out var targetPos))
        {
            _logger.LogWarning("No position found for target node {NodeId}", targetNodeId);
            return;
        }

        // Get node bounds for edge calculation
        var sourceBounds = _nodeBounds.GetValueOrDefault(sourceNodeId);
        var targetBounds = _nodeBounds.GetValueOrDefault(targetNodeId);

        // Calculate line endpoints at node edges
        var startX = sourceBounds != null
            ? sourceBounds.X + sourceBounds.Width
            : sourcePos.X + _config.DefaultNodeWidth;
        var startY = sourceBounds != null
            ? sourceBounds.Y + (sourceBounds.Height / 2)
            : sourcePos.Y + 1;

        var endX = targetBounds != null
            ? targetBounds.X
            : targetPos.X;
        var endY = targetBounds != null
            ? targetBounds.Y + (targetBounds.Height / 2)
            : targetPos.Y + 1;

        // Calculate path segments
        var path = _lineRenderer.CalculatePath(
            new LinePoint(startX, startY),
            new LinePoint(endX, endY));

        // Get line color and character
        var color = _lineRenderer.GetLineColor(state);
        var lineChar = state == LineState.Satisfied
            ? _config.SatisfiedLineCharacter
            : _config.UnsatisfiedLineCharacter;

        // Draw the line
        foreach (var segment in path)
        {
            var displayChar = state == LineState.Unsatisfied && ShouldSkipForDash(segment.Index)
                ? ' '
                : lineChar;

            _terminalService.WriteColoredAt(
                segment.X,
                segment.Y,
                displayChar.ToString(),
                color);
        }

        // Track rendered line for clearing
        _renderedLines.Add(new PrerequisiteLineDto(
            SourceNodeId: sourceNodeId,
            TargetNodeId: targetNodeId,
            State: state,
            Path: path.ToList()));

        _logger.LogDebug(
            "Drew {State} line from {Source} to {Target}",
            state,
            sourceNodeId,
            targetNodeId);
    }

    /// <summary>
    /// Clears all rendered prerequisite lines.
    /// </summary>
    public void ClearLines()
    {
        foreach (var line in _renderedLines)
        {
            foreach (var segment in line.Path)
            {
                _terminalService.WriteAt(segment.X, segment.Y, " ");
            }
        }

        _renderedLines.Clear();
        _logger.LogDebug("Cleared all prerequisite lines");
    }

    #region Private Helper Methods

    private bool ShouldSkipForDash(int index)
    {
        // Create dashed effect by skipping every other character
        return index % 2 == 1;
    }

    #endregion
}
```

### 4.2 Line State Determination

**Purpose:** Determine whether a prerequisite line should be displayed as satisfied or unsatisfied.

The line state determination follows these rules:
1. **Satisfied**: The prerequisite node has been unlocked by the player
2. **Unsatisfied**: The prerequisite node has not been unlocked

**State Determination Logic:**

```csharp
/// <summary>
/// Determines line state with detailed prerequisite checking.
/// </summary>
/// <param name="prerequisiteNodeId">The required node ID.</param>
/// <param name="requiredRank">The required rank (default 1).</param>
/// <param name="progress">The player's ability progress.</param>
/// <returns>A tuple of state and reason.</returns>
public (LineState State, string Reason) GetLineStateWithReason(
    string prerequisiteNodeId,
    int requiredRank,
    PlayerAbilityProgress progress)
{
    // Check if node is unlocked
    if (!progress.HasUnlocked(prerequisiteNodeId))
    {
        return (LineState.Unsatisfied, $"Node {prerequisiteNodeId} not unlocked");
    }

    // Check if required rank is met (for multi-rank prerequisites)
    var currentRank = progress.GetRank(prerequisiteNodeId);
    if (currentRank < requiredRank)
    {
        return (LineState.Unsatisfied, $"Rank {currentRank}/{requiredRank} not met");
    }

    return (LineState.Satisfied, "Prerequisite satisfied");
}
```

### 4.3 Connection Rendering

**Purpose:** Render the visual connection between prerequisite and dependent nodes.

Lines are rendered as horizontal connections between tier columns:

**Connection Visual:**

```
┌─────────┐              ┌─────────┐
│ [x]Power│──────────────│ [x]Cleave│
│  Strike │              │         │
└─────────┘              └─────────┘

┌─────────┐              ┌─────────┐
│ [x]Iron │- - - - - - - │ ( )Shield│
│   Skin  │              │   Bash  │
└─────────┘              └─────────┘
```

**Connection Rules:**
- Lines start at the right edge of the source node
- Lines end at the left edge of the target node
- Lines are drawn horizontally between tiers
- If nodes are at different Y positions, lines may have vertical segments
- Satisfied lines use solid characters
- Unsatisfied lines use dashed pattern (alternating character/space)

---

## 5. Line Renderer

### 5.1 LineRenderer Class

**Purpose:** Handles line formatting, path calculation, and visual styling.

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Renderers/LineRenderer.cs`

```csharp
using RuneAndRust.Presentation.Tui.DTOs;
using RuneAndRust.Presentation.Tui.Configuration;

namespace RuneAndRust.Presentation.Tui.Renderers;

/// <summary>
/// Renders prerequisite lines with state-specific styling.
/// </summary>
/// <remarks>
/// Provides line characters, colors, and path calculation for
/// drawing connection lines between ability tree nodes.
/// </remarks>
public class LineRenderer
{
    private readonly PrerequisiteLinesConfig _config;

    /// <summary>
    /// Creates a new instance of the LineRenderer.
    /// </summary>
    /// <param name="config">Configuration for line display settings.</param>
    public LineRenderer(PrerequisiteLinesConfig config)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
    }

    /// <summary>
    /// Gets the line character for a given direction.
    /// </summary>
    /// <param name="direction">The line direction.</param>
    /// <returns>The character to use for the line segment.</returns>
    public char GetLineCharacter(LineDirection direction)
    {
        return direction switch
        {
            LineDirection.Horizontal => _config.HorizontalLineCharacter,
            LineDirection.Vertical => _config.VerticalLineCharacter,
            LineDirection.CornerTopRight => _config.CornerTopRightCharacter,
            LineDirection.CornerBottomRight => _config.CornerBottomRightCharacter,
            LineDirection.CornerTopLeft => _config.CornerTopLeftCharacter,
            LineDirection.CornerBottomLeft => _config.CornerBottomLeftCharacter,
            _ => _config.HorizontalLineCharacter
        };
    }

    /// <summary>
    /// Gets the color for a line state.
    /// </summary>
    /// <param name="state">The line state.</param>
    /// <returns>The console color for the line.</returns>
    public ConsoleColor GetLineColor(LineState state)
    {
        return state switch
        {
            LineState.Satisfied => _config.SatisfiedLineColor,
            LineState.Unsatisfied => _config.UnsatisfiedLineColor,
            _ => _config.UnsatisfiedLineColor
        };
    }

    /// <summary>
    /// Calculates the path between two points.
    /// </summary>
    /// <param name="start">The starting point.</param>
    /// <param name="end">The ending point.</param>
    /// <returns>A sequence of line segments forming the path.</returns>
    /// <remarks>
    /// For nodes at the same Y position, draws a straight horizontal line.
    /// For nodes at different Y positions, draws a path with a vertical segment.
    /// </remarks>
    public IEnumerable<LineSegmentDto> CalculatePath(LinePoint start, LinePoint end)
    {
        var segments = new List<LineSegmentDto>();
        var index = 0;

        if (start.Y == end.Y)
        {
            // Simple horizontal line
            for (var x = start.X; x < end.X; x++)
            {
                segments.Add(new LineSegmentDto(
                    X: x,
                    Y: start.Y,
                    Direction: LineDirection.Horizontal,
                    Index: index++));
            }
        }
        else
        {
            // Path with vertical segment
            // Draw horizontal to midpoint
            var midX = start.X + ((end.X - start.X) / 2);

            // First horizontal segment
            for (var x = start.X; x < midX; x++)
            {
                segments.Add(new LineSegmentDto(
                    X: x,
                    Y: start.Y,
                    Direction: LineDirection.Horizontal,
                    Index: index++));
            }

            // Corner from horizontal to vertical
            var verticalDirection = end.Y > start.Y
                ? LineDirection.CornerBottomRight
                : LineDirection.CornerTopRight;
            segments.Add(new LineSegmentDto(
                X: midX,
                Y: start.Y,
                Direction: verticalDirection,
                Index: index++));

            // Vertical segment
            var minY = Math.Min(start.Y, end.Y);
            var maxY = Math.Max(start.Y, end.Y);
            for (var y = minY + 1; y < maxY; y++)
            {
                segments.Add(new LineSegmentDto(
                    X: midX,
                    Y: y,
                    Direction: LineDirection.Vertical,
                    Index: index++));
            }

            // Corner from vertical to horizontal
            var cornerDirection = end.Y > start.Y
                ? LineDirection.CornerBottomLeft
                : LineDirection.CornerTopLeft;
            segments.Add(new LineSegmentDto(
                X: midX,
                Y: end.Y,
                Direction: cornerDirection,
                Index: index++));

            // Final horizontal segment
            for (var x = midX + 1; x < end.X; x++)
            {
                segments.Add(new LineSegmentDto(
                    X: x,
                    Y: end.Y,
                    Direction: LineDirection.Horizontal,
                    Index: index++));
            }
        }

        return segments;
    }

    /// <summary>
    /// Formats a connection point character for a node edge.
    /// </summary>
    /// <param name="direction">The direction the line exits/enters.</param>
    /// <returns>The connection point character.</returns>
    public string FormatConnectionPoint(LineDirection direction)
    {
        return direction switch
        {
            LineDirection.Horizontal => _config.ConnectionPointCharacter.ToString(),
            _ => _config.ConnectionPointCharacter.ToString()
        };
    }
}
```

### 5.2 Line Characters

**Purpose:** Define the ASCII characters used for line rendering.

| Line Type | Character | Unicode Name |
|-----------|-----------|--------------|
| Horizontal | `─` | Box Drawings Light Horizontal |
| Vertical | `│` | Box Drawings Light Vertical |
| Corner Top-Right | `┐` | Box Drawings Light Down and Left |
| Corner Bottom-Right | `┘` | Box Drawings Light Up and Left |
| Corner Top-Left | `┌` | Box Drawings Light Down and Right |
| Corner Bottom-Left | `└` | Box Drawings Light Up and Right |
| Connection Point | `─` | Same as horizontal |

**Dashed Line Pattern:**

For unsatisfied lines, the pattern alternates between character and space:
- Index 0: `─`
- Index 1: ` ` (space)
- Index 2: `─`
- Index 3: ` ` (space)
- etc.

Visual result: `─ ─ ─ ─ ─ ─`

### 5.3 Path Calculation

**Purpose:** Calculate the optimal path between two nodes.

**Path Calculation Rules:**

1. **Same Y Position**: Draw straight horizontal line
```
Node A ──────────────── Node B
```

2. **Different Y Positions**: Draw L-shaped or Z-shaped path
```
Node A ─────┐
            │
            └───── Node B
```

**Path Algorithm:**

```csharp
/// <summary>
/// Calculates path with simple horizontal routing.
/// </summary>
/// <param name="start">The starting point at source node edge.</param>
/// <param name="end">The ending point at target node edge.</param>
/// <returns>List of line segments forming the path.</returns>
public IEnumerable<LineSegmentDto> CalculateSimplePath(LinePoint start, LinePoint end)
{
    var segments = new List<LineSegmentDto>();
    var index = 0;

    // For simplicity, always draw horizontal line at the average Y
    // This works well for tier-based layouts where nodes align vertically
    var y = (start.Y + end.Y) / 2;

    // If same Y, just draw horizontal
    if (start.Y == end.Y)
    {
        y = start.Y;
    }

    // Draw horizontal line
    for (var x = start.X; x < end.X; x++)
    {
        segments.Add(new LineSegmentDto(
            X: x,
            Y: y,
            Direction: LineDirection.Horizontal,
            Index: index++));
    }

    return segments;
}
```

---

## 6. Line State Display

### 6.1 Satisfied Lines

**Purpose:** Display solid green lines for satisfied prerequisites.

**Visual Appearance:**
```
┌─────────┐              ┌─────────┐
│ [x]Power│──────────────│ [x]Cleave│
│  Strike │              │         │
└─────────┘              └─────────┘
```

**Satisfied Line Properties:**
- Character: `─` (solid horizontal line)
- Color: Green (configurable)
- Pattern: Continuous (no gaps)

**Rendering:**
```csharp
// Satisfied line rendering
if (state == LineState.Satisfied)
{
    foreach (var segment in path)
    {
        _terminalService.WriteColoredAt(
            segment.X,
            segment.Y,
            _config.SatisfiedLineCharacter.ToString(),
            _config.SatisfiedLineColor);
    }
}
```

### 6.2 Unsatisfied Lines

**Purpose:** Display dashed gray lines for unsatisfied prerequisites.

**Visual Appearance:**
```
┌─────────┐              ┌─────────┐
│ [x]Iron │- - - - - - - │ [L]Shield│
│   Skin  │              │   Bash  │
└─────────┘              └─────────┘
```

**Unsatisfied Line Properties:**
- Character: `─` alternating with space
- Color: DarkGray (configurable)
- Pattern: Dashed (character, space, character, space...)

**Rendering:**
```csharp
// Unsatisfied line rendering with dashed pattern
if (state == LineState.Unsatisfied)
{
    foreach (var segment in path)
    {
        var displayChar = segment.Index % 2 == 0
            ? _config.UnsatisfiedLineCharacter
            : ' ';

        _terminalService.WriteColoredAt(
            segment.X,
            segment.Y,
            displayChar.ToString(),
            _config.UnsatisfiedLineColor);
    }
}
```

---

## 7. Data Model Changes

### 7.1 New Enums

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/DTOs/LineState.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.DTOs;

/// <summary>
/// Represents the visual state of a prerequisite line.
/// </summary>
public enum LineState
{
    /// <summary>
    /// Prerequisite is satisfied - solid line.
    /// </summary>
    Satisfied,

    /// <summary>
    /// Prerequisite is unsatisfied - dashed line.
    /// </summary>
    Unsatisfied
}

/// <summary>
/// Represents the direction of a line segment.
/// </summary>
public enum LineDirection
{
    /// <summary>Horizontal line segment.</summary>
    Horizontal,

    /// <summary>Vertical line segment.</summary>
    Vertical,

    /// <summary>Corner turning from horizontal to down.</summary>
    CornerTopRight,

    /// <summary>Corner turning from up to horizontal.</summary>
    CornerBottomRight,

    /// <summary>Corner turning from horizontal to down.</summary>
    CornerTopLeft,

    /// <summary>Corner turning from up to horizontal.</summary>
    CornerBottomLeft
}
```

### 7.2 New DTOs

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/DTOs/PrerequisiteLineDtos.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.DTOs;

/// <summary>
/// Data transfer object for a prerequisite line between nodes.
/// </summary>
/// <param name="SourceNodeId">The prerequisite (source) node ID.</param>
/// <param name="TargetNodeId">The dependent (target) node ID.</param>
/// <param name="State">The current line state.</param>
/// <param name="Path">The calculated path segments.</param>
public record PrerequisiteLineDto(
    string SourceNodeId,
    string TargetNodeId,
    LineState State,
    IReadOnlyList<LineSegmentDto> Path);

/// <summary>
/// Data transfer object for a single line segment.
/// </summary>
/// <param name="X">The X coordinate of the segment.</param>
/// <param name="Y">The Y coordinate of the segment.</param>
/// <param name="Direction">The direction of this segment.</param>
/// <param name="Index">The index in the path (for dashed pattern).</param>
public record LineSegmentDto(
    int X,
    int Y,
    LineDirection Direction,
    int Index);

/// <summary>
/// Represents a point for line calculations.
/// </summary>
/// <param name="X">The X coordinate.</param>
/// <param name="Y">The Y coordinate.</param>
public record LinePoint(int X, int Y);
```

### 7.3 Configuration Classes

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/PrerequisiteLinesConfig.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.Configuration;

/// <summary>
/// Configuration for prerequisite line display settings.
/// </summary>
public class PrerequisiteLinesConfig
{
    /// <summary>
    /// Default node width for edge calculations when bounds unavailable.
    /// </summary>
    public int DefaultNodeWidth { get; set; } = 11;

    /// <summary>
    /// Default node height for edge calculations when bounds unavailable.
    /// </summary>
    public int DefaultNodeHeight { get; set; } = 3;

    /// <summary>
    /// Character for horizontal line segments.
    /// </summary>
    public char HorizontalLineCharacter { get; set; } = '─';

    /// <summary>
    /// Character for vertical line segments.
    /// </summary>
    public char VerticalLineCharacter { get; set; } = '│';

    /// <summary>
    /// Character for top-right corner.
    /// </summary>
    public char CornerTopRightCharacter { get; set; } = '┐';

    /// <summary>
    /// Character for bottom-right corner.
    /// </summary>
    public char CornerBottomRightCharacter { get; set; } = '┘';

    /// <summary>
    /// Character for top-left corner.
    /// </summary>
    public char CornerTopLeftCharacter { get; set; } = '┌';

    /// <summary>
    /// Character for bottom-left corner.
    /// </summary>
    public char CornerBottomLeftCharacter { get; set; } = '└';

    /// <summary>
    /// Character for connection points at node edges.
    /// </summary>
    public char ConnectionPointCharacter { get; set; } = '─';

    /// <summary>
    /// Character for satisfied (solid) lines.
    /// </summary>
    public char SatisfiedLineCharacter { get; set; } = '─';

    /// <summary>
    /// Character for unsatisfied (dashed) lines.
    /// </summary>
    public char UnsatisfiedLineCharacter { get; set; } = '─';

    /// <summary>
    /// Color for satisfied lines.
    /// </summary>
    public ConsoleColor SatisfiedLineColor { get; set; } = ConsoleColor.Green;

    /// <summary>
    /// Color for unsatisfied lines.
    /// </summary>
    public ConsoleColor UnsatisfiedLineColor { get; set; } = ConsoleColor.DarkGray;
}
```

---

## 8. Configuration File Schemas

### 8.1 prerequisite-lines.json

**File:** `config/prerequisite-lines.json`

```json
{
  "$schema": "./schemas/prerequisite-lines.schema.json",
  "defaultNodeWidth": 11,
  "defaultNodeHeight": 3,
  "horizontalLineCharacter": "─",
  "verticalLineCharacter": "│",
  "cornerTopRightCharacter": "┐",
  "cornerBottomRightCharacter": "┘",
  "cornerTopLeftCharacter": "┌",
  "cornerBottomLeftCharacter": "└",
  "connectionPointCharacter": "─",
  "satisfiedLineCharacter": "─",
  "unsatisfiedLineCharacter": "─",
  "satisfiedLineColor": "Green",
  "unsatisfiedLineColor": "DarkGray"
}
```

### 8.2 prerequisite-lines.schema.json

**File:** `config/schemas/prerequisite-lines.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "prerequisite-lines.schema.json",
  "title": "Prerequisite Lines Configuration",
  "description": "Configuration for ability tree prerequisite line display",
  "type": "object",
  "properties": {
    "defaultNodeWidth": {
      "type": "integer",
      "description": "Default node width for edge calculations",
      "minimum": 5,
      "maximum": 25,
      "default": 11
    },
    "defaultNodeHeight": {
      "type": "integer",
      "description": "Default node height for edge calculations",
      "minimum": 3,
      "maximum": 10,
      "default": 3
    },
    "horizontalLineCharacter": {
      "type": "string",
      "description": "Character for horizontal line segments",
      "minLength": 1,
      "maxLength": 1,
      "default": "─"
    },
    "verticalLineCharacter": {
      "type": "string",
      "description": "Character for vertical line segments",
      "minLength": 1,
      "maxLength": 1,
      "default": "│"
    },
    "cornerTopRightCharacter": {
      "type": "string",
      "description": "Character for top-right corner",
      "minLength": 1,
      "maxLength": 1,
      "default": "┐"
    },
    "cornerBottomRightCharacter": {
      "type": "string",
      "description": "Character for bottom-right corner",
      "minLength": 1,
      "maxLength": 1,
      "default": "┘"
    },
    "cornerTopLeftCharacter": {
      "type": "string",
      "description": "Character for top-left corner",
      "minLength": 1,
      "maxLength": 1,
      "default": "┌"
    },
    "cornerBottomLeftCharacter": {
      "type": "string",
      "description": "Character for bottom-left corner",
      "minLength": 1,
      "maxLength": 1,
      "default": "└"
    },
    "connectionPointCharacter": {
      "type": "string",
      "description": "Character for connection points at node edges",
      "minLength": 1,
      "maxLength": 1,
      "default": "─"
    },
    "satisfiedLineCharacter": {
      "type": "string",
      "description": "Character for satisfied lines",
      "minLength": 1,
      "maxLength": 1,
      "default": "─"
    },
    "unsatisfiedLineCharacter": {
      "type": "string",
      "description": "Character for unsatisfied lines",
      "minLength": 1,
      "maxLength": 1,
      "default": "─"
    },
    "satisfiedLineColor": {
      "$ref": "#/$defs/consoleColor",
      "default": "Green"
    },
    "unsatisfiedLineColor": {
      "$ref": "#/$defs/consoleColor",
      "default": "DarkGray"
    }
  },
  "$defs": {
    "consoleColor": {
      "type": "string",
      "enum": [
        "Black", "DarkBlue", "DarkGreen", "DarkCyan",
        "DarkRed", "DarkMagenta", "DarkYellow", "Gray",
        "DarkGray", "Blue", "Green", "Cyan",
        "Red", "Magenta", "Yellow", "White"
      ]
    }
  },
  "additionalProperties": false
}
```

---

## 9. AbilityTreeView Integration

### 9.1 Integration Points

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/UI/AbilityTreeView.cs` (modifications)

```csharp
// Add to AbilityTreeView class

private readonly PrerequisiteLines _prerequisiteLines;

/// <summary>
/// Renders the tree with prerequisite lines.
/// </summary>
/// <param name="treeDto">The tree display data.</param>
/// <param name="tree">The ability tree definition.</param>
/// <param name="progress">The player's ability progress.</param>
public void RenderTreeWithConnections(
    TreeDisplayDto treeDto,
    AbilityTreeDefinition tree,
    PlayerAbilityProgress progress)
{
    // Render the tree structure first
    RenderTree(treeDto);

    // Pass node positions and bounds to prerequisite lines component
    var nodeBounds = BuildNodeBoundsMap();
    _prerequisiteLines.SetNodePositions(_nodePositions, nodeBounds);

    // Render prerequisite lines
    _prerequisiteLines.RenderConnections(tree, progress);

    _logger.LogDebug("Rendered tree with prerequisite lines");
}

/// <summary>
/// Builds a map of node bounds for line routing.
/// </summary>
/// <returns>Dictionary mapping node IDs to their screen bounds.</returns>
private Dictionary<string, NodeBounds> BuildNodeBoundsMap()
{
    var bounds = new Dictionary<string, NodeBounds>();

    foreach (var (nodeId, position) in _nodePositions)
    {
        bounds[nodeId] = new NodeBounds(
            position.X,
            position.Y,
            _config.NodeWidth,
            _config.NodeHeight);
    }

    return bounds;
}

/// <summary>
/// Refreshes prerequisite lines when node states change.
/// </summary>
/// <param name="tree">The ability tree definition.</param>
/// <param name="progress">The updated player progress.</param>
public void RefreshConnections(
    AbilityTreeDefinition tree,
    PlayerAbilityProgress progress)
{
    _prerequisiteLines.ClearLines();
    _prerequisiteLines.RenderConnections(tree, progress);

    _logger.LogDebug("Refreshed prerequisite lines");
}
```

### 9.2 CharacterView Updates

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Views/CharacterView.cs` (modifications)

```csharp
// Add to CharacterView class

/// <summary>
/// Handles ability tree tab with complete rendering including lines.
/// </summary>
private void HandleAbilityTreeTabWithConnections()
{
    var player = _gameState.CurrentPlayer;
    if (player == null)
    {
        _logger.LogWarning("Cannot show ability tree - no current player");
        return;
    }

    var tree = _abilityTreeProvider.GetTreeForClass(player.ClassId);
    if (tree == null)
    {
        _logger.LogWarning("No ability tree found for class {ClassId}", player.ClassId);
        return;
    }

    var progress = _talentPointService.GetProgressForPlayer(player.Id);
    var unspentPoints = _talentPointService.GetUnspentPoints(player);

    // Create tree display DTO
    var treeDto = CreateTreeDisplayDto(tree);

    // Render tree with connections
    _abilityTreeView.RenderTreeWithConnections(treeDto, tree, progress);

    // Render node states
    var nodeStates = CreateNodeStatesDtos(tree, progress, unspentPoints);
    _abilityTreeView.RenderNodesWithState(nodeStates);

    _logger.LogDebug(
        "Rendered ability tree with connections for class {ClassId}",
        player.ClassId);
}
```

### 9.3 Line Layer Rendering Order

Lines are rendered between the tree structure and node states to appear behind the nodes:

```
1. Clear tree area
2. Render tree border
3. Render tree header
4. Render tier labels
5. Render node boxes (placeholder)
6. RENDER PREREQUISITE LINES  <-- v0.13.2c
7. Render node states (overlay on nodes)  <-- v0.13.2b
```

**Rendering Order in Code:**

```csharp
public void RenderTreeComplete(
    TreeDisplayDto treeDto,
    AbilityTreeDefinition tree,
    PlayerAbilityProgress progress,
    Dictionary<string, NodeStateDisplayDto> nodeStates)
{
    // 1-5. Render basic tree structure
    RenderTree(treeDto);

    // 6. Render prerequisite lines
    _prerequisiteLines.SetNodePositions(_nodePositions, BuildNodeBoundsMap());
    _prerequisiteLines.RenderConnections(tree, progress);

    // 7. Render node states on top
    RenderNodesWithState(nodeStates);
}
```

---

## 10. Logging Specifications

### 10.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `PrerequisiteLines` | Information | All lines rendered count |
| `PrerequisiteLines` | Debug | Individual line draws, state determinations, clears |
| `PrerequisiteLines` | Warning | Node position not found |
| `LineRenderer` | Debug | Path calculations, character lookups |
| `AbilityTreeView` | Debug | Tree with connections rendered, refreshes |
| `CharacterView` | Debug | Ability tree tab with connections opened |

### 10.2 Log Message Examples

```
[INF] PrerequisiteLines: Rendered 6 prerequisite lines for tree warrior-tree
[DBG] PrerequisiteLines: Prerequisite power-strike is satisfied
[DBG] PrerequisiteLines: Drew Satisfied line from power-strike to cleave
[DBG] PrerequisiteLines: Prerequisite iron-skin is unsatisfied
[DBG] PrerequisiteLines: Drew Unsatisfied line from iron-skin to shield-bash
[DBG] PrerequisiteLines: Cleared all prerequisite lines
[WRN] PrerequisiteLines: No position found for source node unknown-node
[DBG] LineRenderer: Calculated path with 14 segments from (21, 10) to (40, 10)
[DBG] AbilityTreeView: Rendered tree with prerequisite lines
[DBG] AbilityTreeView: Refreshed prerequisite lines
[DBG] CharacterView: Rendered ability tree with connections for class warrior
```

---

## 11. Unit Testing Requirements

### 11.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| LineRenderer | ~2 |
| PrerequisiteLines | ~2 |
| **Total** | **~4** |

### 11.2 Test Specifications

**File:** `tests/RuneAndRust.Presentation.Tui.Tests/Renderers/LineRendererTests.cs`

```csharp
[TestFixture]
public class LineRendererTests
{
    private LineRenderer _renderer;
    private PrerequisiteLinesConfig _config;

    [SetUp]
    public void Setup()
    {
        _config = new PrerequisiteLinesConfig();
        _renderer = new LineRenderer(_config);
    }

    [Test]
    [TestCase(LineState.Satisfied, ConsoleColor.Green)]
    [TestCase(LineState.Unsatisfied, ConsoleColor.DarkGray)]
    public void GetLineColor_WithState_ReturnsCorrectColor(
        LineState state, ConsoleColor expectedColor)
    {
        // Act
        var result = _renderer.GetLineColor(state);

        // Assert
        Assert.That(result, Is.EqualTo(expectedColor));
    }

    [Test]
    public void CalculatePath_WithSameYPosition_ReturnsStraightHorizontalLine()
    {
        // Arrange
        var start = new LinePoint(10, 5);
        var end = new LinePoint(20, 5);

        // Act
        var result = _renderer.CalculatePath(start, end).ToList();

        // Assert
        Assert.That(result.Count, Is.EqualTo(10));
        Assert.That(result.All(s => s.Y == 5), Is.True);
        Assert.That(result.All(s => s.Direction == LineDirection.Horizontal), Is.True);
    }

    [Test]
    public void CalculatePath_WithDifferentYPositions_ReturnsPathWithVerticalSegment()
    {
        // Arrange
        var start = new LinePoint(10, 5);
        var end = new LinePoint(20, 10);

        // Act
        var result = _renderer.CalculatePath(start, end).ToList();

        // Assert
        Assert.That(result.Count, Is.GreaterThan(10)); // Path includes vertical segment
        Assert.That(result.Any(s => s.Direction == LineDirection.Vertical), Is.True);
    }
}
```

**File:** `tests/RuneAndRust.Presentation.Tui.Tests/UI/PrerequisiteLinesTests.cs`

```csharp
[TestFixture]
public class PrerequisiteLinesTests
{
    private Mock<LineRenderer> _mockLineRenderer;
    private Mock<ITerminalService> _mockTerminal;
    private Mock<ILogger<PrerequisiteLines>> _mockLogger;
    private PrerequisiteLinesConfig _config;
    private PrerequisiteLines _prerequisiteLines;

    [SetUp]
    public void Setup()
    {
        _config = new PrerequisiteLinesConfig();
        _mockLineRenderer = new Mock<LineRenderer>(_config);
        _mockTerminal = new Mock<ITerminalService>();
        _mockLogger = new Mock<ILogger<PrerequisiteLines>>();

        _prerequisiteLines = new PrerequisiteLines(
            _mockLineRenderer.Object,
            _mockTerminal.Object,
            _config,
            _mockLogger.Object);
    }

    [Test]
    public void GetLineState_WhenPrerequisiteUnlocked_ReturnsSatisfied()
    {
        // Arrange
        var progress = CreateProgressWithUnlockedNode("power-strike");

        // Act
        var result = _prerequisiteLines.GetLineState("power-strike", progress);

        // Assert
        Assert.That(result, Is.EqualTo(LineState.Satisfied));
    }

    [Test]
    public void GetLineState_WhenPrerequisiteNotUnlocked_ReturnsUnsatisfied()
    {
        // Arrange
        var progress = CreateEmptyProgress();

        // Act
        var result = _prerequisiteLines.GetLineState("power-strike", progress);

        // Assert
        Assert.That(result, Is.EqualTo(LineState.Unsatisfied));
    }

    [Test]
    public void DrawLine_WithValidPositions_WritesToTerminal()
    {
        // Arrange
        var positions = new Dictionary<string, NodeScreenPosition>
        {
            { "power-strike", new NodeScreenPosition(10, 10) },
            { "cleave", new NodeScreenPosition(30, 10) }
        };
        var bounds = new Dictionary<string, NodeBounds>
        {
            { "power-strike", new NodeBounds(10, 10, 11, 3) },
            { "cleave", new NodeBounds(30, 10, 11, 3) }
        };

        _prerequisiteLines.SetNodePositions(positions, bounds);

        _mockLineRenderer.Setup(r => r.CalculatePath(It.IsAny<LinePoint>(), It.IsAny<LinePoint>()))
            .Returns(new List<LineSegmentDto>
            {
                new LineSegmentDto(21, 11, LineDirection.Horizontal, 0),
                new LineSegmentDto(22, 11, LineDirection.Horizontal, 1)
            });
        _mockLineRenderer.Setup(r => r.GetLineColor(It.IsAny<LineState>()))
            .Returns(ConsoleColor.Green);

        // Act
        _prerequisiteLines.DrawLine("power-strike", "cleave", LineState.Satisfied);

        // Assert
        _mockTerminal.Verify(t => t.WriteColoredAt(
            It.IsAny<int>(), It.IsAny<int>(),
            It.IsAny<string>(),
            ConsoleColor.Green), Times.AtLeastOnce);
    }

    #region Test Helpers

    private static PlayerAbilityProgress CreateProgressWithUnlockedNode(string nodeId)
    {
        var progress = PlayerAbilityProgress.Create(Guid.NewGuid());
        progress.UnlockNode(nodeId);
        return progress;
    }

    private static PlayerAbilityProgress CreateEmptyProgress()
    {
        return PlayerAbilityProgress.Create(Guid.NewGuid());
    }

    #endregion
}
```

---

## 12. Use Cases

### UC-001: View Prerequisite Connections

**Actor:** Player
**Flow:** Open ability tree → See lines connecting nodes → Identify which nodes are prerequisites for others → Understand progression paths → Plan unlock strategy

### UC-002: Identify Satisfied Prerequisites

**Actor:** Player
**Flow:** View tree with progress → See solid green lines from unlocked nodes → Understand which prerequisites are satisfied → Identify available nodes to unlock next

### UC-003: Identify Unsatisfied Prerequisites

**Actor:** Player
**Flow:** View tree as new character → See dashed gray lines between nodes → Understand which prerequisites need to be satisfied → Know what to unlock first

### UC-004: Track Progress Through Tree

**Actor:** Player
**Flow:** Unlock a node → Line from prerequisite changes from dashed to solid → Visual confirmation of progress → Continue unlocking along the path

### UC-005: View Multi-Prerequisite Node

**Actor:** Player
**Flow:** Select node with multiple prerequisites → See multiple lines connecting to node → Some lines solid (satisfied), some dashed (unsatisfied) → Understand remaining requirements

---

## 13. Deliverable Checklist

### UI Components
- [ ] `PrerequisiteLines` class implemented
- [ ] `RenderConnections()` method renders all lines
- [ ] `GetLineState()` method determines line state
- [ ] `DrawLine()` method draws individual lines
- [ ] `ClearLines()` method clears previous lines
- [ ] `SetNodePositions()` method sets position data

### Renderers
- [ ] `LineRenderer` class implemented
- [ ] `GetLineCharacter()` returns correct characters
- [ ] `GetLineColor()` returns correct colors
- [ ] `CalculatePath()` calculates line segments
- [ ] `FormatConnectionPoint()` formats edge connections

### DTOs
- [ ] `LineState` enum created
- [ ] `LineDirection` enum created
- [ ] `PrerequisiteLineDto` record created
- [ ] `LineSegmentDto` record created
- [ ] `LinePoint` record created

### Configuration
- [ ] `PrerequisiteLinesConfig` class created
- [ ] `config/prerequisite-lines.json` created
- [ ] `config/schemas/prerequisite-lines.schema.json` created

### View Integration
- [ ] `AbilityTreeView` updated with `RenderTreeWithConnections()`
- [ ] `AbilityTreeView` updated with `RefreshConnections()`
- [ ] `AbilityTreeView` builds node bounds map
- [ ] `CharacterView` renders tree with connections

### Testing
- [ ] ~4 unit tests implemented
- [ ] All tests passing

---

## 14. Acceptance Criteria

### Functional
- [ ] Prerequisite lines connect dependent nodes
- [ ] Satisfied prerequisites show solid green lines
- [ ] Unsatisfied prerequisites show dashed gray lines
- [ ] Lines route horizontally between tier columns
- [ ] Lines connect at node edges correctly
- [ ] Lines clear and redraw on state changes
- [ ] Multi-prerequisite nodes show multiple lines

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~4 unit tests pass
- [ ] Configuration file validates against schema
- [ ] XML documentation complete on all public members
- [ ] No hardcoded values (all configurable)

---

## 15. Dependencies

### Required from v0.13.2a

| Type | Location | Usage in v0.13.2c |
|------|----------|-------------------|
| `AbilityTreeView` | `Presentation.Tui/UI/` | Integration point for line rendering |
| `TreeLayoutRenderer` | `Presentation.Tui/Renderers/` | Node position calculations |
| `NodeLayoutDto` | `Presentation.Tui/DTOs/` | Node information |
| `NodeScreenPosition` | `Presentation.Tui/DTOs/` | Screen coordinates |
| `AbilityTreeDisplayConfig` | `Presentation.Tui/Configuration/` | Shared layout settings |

### Required from v0.13.2b

| Type | Location | Usage in v0.13.2c |
|------|----------|-------------------|
| `TreeNodeRenderer` | `Presentation.Tui/UI/` | Node bounds for line routing |
| `NodeState` enum | `Presentation.Tui/DTOs/` | Coordination with node states |
| `NodeBounds` | `Presentation.Tui/DTOs/` | Node edge positions |

### Required from v0.10.2a

| Type | Location | Usage in v0.13.2c |
|------|----------|-------------------|
| `AbilityTreeDefinition` | `Domain/Definitions/` | Tree structure |
| `AbilityTreeNode` | `Domain/Definitions/` | PrerequisiteNodeIds property |
| `PlayerAbilityProgress` | `Domain/Entities/` | HasUnlocked, GetRank methods |
| `NodePrerequisite` | `Domain/ValueObjects/` | Prerequisite requirements |

### Provides to v0.13.2d

| Type | Usage |
|------|-------|
| `PrerequisiteLines` | Line state for tooltip display |
| `LineState` enum | Prerequisite satisfaction indicator |
| `PrerequisiteLineDto` | Line information for interactions |

---

## 16. Future Considerations

### Deferred to v0.13.2d
- **Node Tooltips**: Show prerequisite satisfaction details
- **Unlock Action**: Spending talent points to unlock nodes
- **Talent Point Display**: Available/spent point counter

### Out of Scope
- **Animated Lines**: Line drawing animations
- **Line Highlighting**: Highlight lines when selecting nodes
- **Complex Routing**: Avoiding line collisions with other elements
- **Curved Lines**: Using curved paths instead of straight lines
- **Line Labels**: Text annotations on lines

### Potential Enhancements (Future Versions)
- **Line Hover Effects**: Highlight line on mouse hover (GUI only)
- **Prerequisite Details**: Show required rank/tier on line
- **Path Animation**: Animate lines when unlocking nodes
- **Alternative Routing**: Support for non-horizontal line paths

---

*Document Version: 1.0*
*Last Updated: 2026-01-16*
*Author: Claude (AI Assistant)*
