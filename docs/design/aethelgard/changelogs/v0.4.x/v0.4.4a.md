# Changelog: v0.4.4a - The Attunement
**Release Date:** 2026-01-05

---

## Summary

v0.4.4a "The Attunement" introduces the **Aetheric Resonance System**, a per-character Flux attunement mechanic for Mystic characters that amplifies spell potency at escalating risk. Unlike environmental Flux (v0.4.3a) which is shared across encounters, Resonance tracks each Mystic's personal attunement to ambient aetheric energy, granting potency bonuses at higher thresholds while introducing Overflow and Soul Fracture mechanics.

This release implements a comprehensive **Core Layer** with enums, models, events, and interface contracts, followed by an **Engine Layer** service with full event publication. The implementation includes 61 unit tests achieving 100% coverage, and full integration with MagicService to apply potency modifiers to spell damage and healing.

Key architectural patterns applied:
- **Service Pattern**: IResonanceService interface with ResonanceService implementation
- **Event-Driven Architecture**: ResonanceChangedEvent and OverflowTriggeredEvent publication via IEventBus
- **Combatant-Oriented Design**: All operations work through Combatant wrapper accessing CharacterSource
- **Defensive Programming**: Non-Mystic handling, null ResonanceState initialization, boundary clamping

---

## New Files Created

### Core Layer - Enums

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/ResonanceThreshold.cs` | 5-value enum defining Mystic attunement thresholds (Dim, Steady, Bright, Blazing, Overflow) with potency modifier documentation |
| `RuneAndRust.Core/Enums/CastingMode.cs` | 4-value enum defining spell casting modes (Quick, Standard, Channeled, Ritual) with resonance/flux modifier documentation |

### Core Layer - Models

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/Magic/ResonanceState.cs` | State model tracking CurrentValue, DecayRate, OverflowCount, IsOverflowActive with computed Threshold and PotencyModifier properties |
| `RuneAndRust.Core/Models/Magic/ResonanceResult.cs` | Record type result with computed properties for ThresholdChanged, OverflowTriggered, WasClamped, and static NoChange factory |
| `RuneAndRust.Core/Models/Magic/CastingModeResult.cs` | Record type result with ResonanceGain, CastTimeModifier, FluxModifier, and computed mode-specific properties |
| `RuneAndRust.Core/Models/Magic/OverflowResult.cs` | Record type result with PotencyBonus, DurationTurns, DischargeAmount, SoulFractureRisk, and static None factory |

### Core Layer - Events

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Events/ResonanceChangedEvent.cs` | Record type event with computed properties for ThresholdChanged, IsIncrease, HitMaximum, Delta, ThresholdDirection |
| `RuneAndRust.Core/Events/OverflowTriggeredEvent.cs` | Record type event with OverflowCount, SoulFractureRisk, computed IsFirstOverflow and IsHighRisk |

### Core Layer - Interfaces

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IResonanceService.cs` | Service contract with methods for ModifyResonance, GetResonance, GetThreshold, GetPotencyModifier, ApplyCastingModeModifiers, ProcessResonanceDecay, TriggerOverflow, ProcessOverflowDischarge, Reset |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/ResonanceService.cs` | Singleton service implementing resonance accumulation, threshold detection, potency calculation, overflow mechanics, and event publication |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/Services/ResonanceServiceTests.cs` | Comprehensive test suite with 61 unit tests covering ModifyResonance, threshold detection, potency calculation, casting modes, overflow mechanics, event publication, and integration scenarios |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/Character.cs` | Added `using RuneAndRust.Core.Models.Magic` import; Added `#region Resonance System (v0.4.4a)` with `ResonanceState?` property and computed `Resonance` getter |
| `RuneAndRust.Terminal/Program.cs` | Registered `IResonanceService` → `ResonanceService` as Singleton in DI container (line 177) with version comment |
| `RuneAndRust.Engine/Services/MagicService.cs` | Added `IResonanceService` dependency; Updated `CastSpell()` and `ReleaseCharge()` to integrate resonance gain and potency modifiers; Updated `ExecuteSpellEffect()` to accept and apply potency modifier parameter |
| `RuneAndRust.Tests/Engine/Services/MagicServiceTests.cs` | Added `Mock<IResonanceService>` field and default setup for resonance service methods |

---

## Code Implementation Details

### Enums

#### `ResonanceThreshold.cs`

```csharp
public enum ResonanceThreshold
{
    /// <summary>
    /// 0-24: Minimal attunement. -10% spell potency. Safe casting.
    /// </summary>
    Dim = 0,

    /// <summary>
    /// 25-49: Balanced attunement. Normal spell potency. Minor risk.
    /// </summary>
    Steady = 1,

    /// <summary>
    /// 50-74: Elevated attunement. +15% spell potency. Moderate risk.
    /// </summary>
    Bright = 2,

    /// <summary>
    /// 75-99: Intense attunement. +30% spell potency. High risk.
    /// </summary>
    Blazing = 3,

    /// <summary>
    /// 100: Critical attunement. +50% potency for 1 turn, then forced discharge.
    /// </summary>
    Overflow = 4
}
```

**Threshold Ranges and Potency Modifiers:**
- Dim: 0-24 (0.90x potency, -10%)
- Steady: 25-49 (1.00x potency, baseline)
- Bright: 50-74 (1.15x potency, +15%)
- Blazing: 75-99 (1.30x potency, +30%)
- Overflow: 100 (1.50x potency, +50%, then forced discharge)

#### `CastingMode.cs`

```csharp
public enum CastingMode
{
    /// <summary>
    /// Instant cast as bonus action. +15 Resonance, +5 Flux.
    /// </summary>
    Quick = 0,

    /// <summary>
    /// Standard single-turn cast. +10 Resonance, normal Flux.
    /// </summary>
    Standard = 1,

    /// <summary>
    /// Extended two-turn cast. +5 Resonance, -5 Flux.
    /// </summary>
    Channeled = 2,

    /// <summary>
    /// Out-of-combat ritual. +0 Resonance, -10 Flux. Cannot be used in combat.
    /// </summary>
    Ritual = 3
}
```

**Casting Mode Modifiers:**

| Mode | Resonance Gain | Cast Time | Flux Modifier |
|------|----------------|-----------|---------------|
| Quick | +15 | Bonus action (0) | +5 |
| Standard | +10 | 1 turn (1) | 0 |
| Channeled | +5 | 2 turns (2) | -5 |
| Ritual | +0 | Out of combat (-1) | -10 |

---

### Models

#### `ResonanceState.cs`

**Constants:**

| Constant | Value | Description |
|----------|-------|-------------|
| `MinResonance` | 0 | Minimum resonance value |
| `MaxResonance` | 100 | Maximum resonance value (Overflow threshold) |
| `DefaultDecayRate` | 10 | Default resonance lost per rest period |
| `DimUpperBound` | 24 | Upper boundary of Dim threshold |
| `SteadyUpperBound` | 49 | Upper boundary of Steady threshold |
| `BrightUpperBound` | 74 | Upper boundary of Bright threshold |
| `BlazingUpperBound` | 99 | Upper boundary of Blazing threshold |

**Properties:**

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `CurrentValue` | `int` | 0 | Current resonance level (0-100) |
| `DecayRate` | `int` | 10 | Resonance lost per rest period |
| `OverflowCount` | `int` | 0 | Number of times Overflow has been triggered |
| `IsOverflowActive` | `bool` | false | Whether currently in Overflow state |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `Threshold` | `ResonanceThreshold` | Switch expression: >= 100 → Overflow, >= 75 → Blazing, >= 50 → Bright, >= 25 → Steady, else Dim |
| `PotencyModifier` | `decimal` | Overflow → 1.50m, Blazing → 1.30m, Bright → 1.15m, Steady → 1.00m, Dim → 0.90m |
| `IsElevatedRisk` | `bool` | `CurrentValue >= 50` |
| `IsHighRisk` | `bool` | `CurrentValue >= 75` |
| `IsAtMaximum` | `bool` | `CurrentValue >= MaxResonance` |
| `IsAtMinimum` | `bool` | `CurrentValue <= MinResonance` |
| `PercentFull` | `int` | `CurrentValue` (0-100) |

**Methods:**
- `Reset()` → `void`: Sets CurrentValue to 0 and clears IsOverflowActive
- `Clone()` → `ResonanceState`: Creates immutable copy for external retrieval

---

#### `ResonanceResult.cs`

**Primary Constructor Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `PreviousValue` | `int` | Resonance level before change |
| `NewValue` | `int` | Resonance level after change |
| `RequestedAmount` | `int` | Amount of change requested |
| `ActualAmount` | `int` | Actual amount changed (may differ due to clamping) |
| `PreviousThreshold` | `ResonanceThreshold` | Threshold tier before change |
| `NewThreshold` | `ResonanceThreshold` | Threshold tier after change |
| `Source` | `string` | Event trigger description |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `ThresholdChanged` | `bool` | `PreviousThreshold != NewThreshold` |
| `IsIncrease` | `bool` | `ActualAmount > 0` |
| `IsDecrease` | `bool` | `ActualAmount < 0` |
| `OverflowTriggered` | `bool` | `NewValue >= ResonanceState.MaxResonance` |
| `FullyDissipated` | `bool` | `NewValue <= ResonanceState.MinResonance` |
| `WasClamped` | `bool` | `RequestedAmount != ActualAmount` |
| `Delta` | `int` | `Math.Abs(ActualAmount)` |

**Static Factories:**
- `NoChange(string source)` → `ResonanceResult`: Creates result for non-Mystic combatants

---

#### `CastingModeResult.cs`

**Primary Constructor Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `Mode` | `CastingMode` | The casting mode selected |
| `ResonanceGain` | `int` | Amount of resonance gained from this cast |
| `CastTimeModifier` | `int` | Cast time modifier (0=bonus, 1=standard, 2=extended, -1=out of combat) |
| `FluxModifier` | `int` | Modifier to base flux cost |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `IsOutOfCombatOnly` | `bool` | `Mode == CastingMode.Ritual` |
| `IsBonusAction` | `bool` | `Mode == CastingMode.Quick` |
| `IsExtendedCast` | `bool` | `Mode == CastingMode.Channeled` |
| `IsStandardCast` | `bool` | `Mode == CastingMode.Standard` |
| `Description` | `string` | Human-readable description of casting mode |

---

#### `OverflowResult.cs`

**Primary Constructor Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `PotencyBonus` | `decimal` | Potency multiplier during overflow (1.50) |
| `DurationTurns` | `int` | Turns the overflow state lasts (1) |
| `DischargeAmount` | `int` | Resonance lost after overflow ends (50) |
| `SoulFractureRisk` | `bool` | Whether this overflow risks Soul Fracture |
| `TotalOverflowCount` | `int` | Total overflows this character has triggered |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `IsHighRisk` | `bool` | `SoulFractureRisk` |
| `IsFirstOverflow` | `bool` | `TotalOverflowCount == 1` |

**Static Factories:**
- `None` → `OverflowResult`: Returns result for non-overflow scenarios

---

### Events

#### `ResonanceChangedEvent.cs`

**Primary Constructor Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `CharacterId` | `Guid` | Unique identifier of the character |
| `CharacterName` | `string` | Display name of the character |
| `OldValue` | `int` | Resonance level before change |
| `NewValue` | `int` | Resonance level after change |
| `ChangeAmount` | `int` | Actual amount of change |
| `Source` | `string` | Event trigger description |
| `OldThreshold` | `ResonanceThreshold` | Threshold tier before change |
| `NewThreshold` | `ResonanceThreshold` | Threshold tier after change |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `ThresholdChanged` | `bool` | `OldThreshold != NewThreshold` |
| `IsIncrease` | `bool` | `ChangeAmount > 0` |
| `IsDecrease` | `bool` | `ChangeAmount < 0` |
| `HitMaximum` | `bool` | `NewValue >= ResonanceState.MaxResonance` |
| `HitMinimum` | `bool` | `NewValue <= ResonanceState.MinResonance` |
| `Delta` | `int` | `Math.Abs(ChangeAmount)` |
| `IsSignificantChange` | `bool` | `Delta >= 15` |
| `ThresholdDirection` | `string` | "Ascending", "Descending", or "Stable" |

**Event Publication Triggers:**
1. Threshold changes (e.g., Dim → Steady)
2. Resonance change ≥ 15 points in single operation
3. Resonance hits boundary (0 or MaxResonance)

---

#### `OverflowTriggeredEvent.cs`

**Primary Constructor Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `CharacterId` | `Guid` | Unique identifier of the character |
| `CharacterName` | `string` | Display name of the character |
| `OverflowCount` | `int` | Total overflows this character has triggered |
| `SoulFractureRisk` | `bool` | Whether this overflow risks Soul Fracture |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `IsFirstOverflow` | `bool` | `OverflowCount == 1` |
| `IsHighRisk` | `bool` | `SoulFractureRisk` |

---

### Services

#### `ResonanceService.cs`

**Constructor Dependencies:**
- `ILogger<ResonanceService>` (for structured logging)
- `IEventBus` (for ResonanceChangedEvent and OverflowTriggeredEvent publication)

**Constants:**

| Constant | Value | Description |
|----------|-------|-------------|
| `SignificantChangeThreshold` | 15 | Minimum delta for event publication |
| `OverflowDischargeAmount` | 50 | Resonance lost when overflow ends |
| `SoulFractureRiskThreshold` | 3 | Overflows required to trigger Soul Fracture risk |

**Key Method Signatures and Behaviors:**

```csharp
public ResonanceResult ModifyResonance(Combatant combatant, int amount, string source)
```
- Returns `NoChange` result if combatant is not a Mystic
- Initializes ResonanceState if null
- Clamps result to `[MinResonance, MaxResonance]`
- Publishes event if threshold crossed, boundary hit, or delta ≥ 15
- Returns ResonanceResult with all metadata

```csharp
public int GetResonance(Combatant combatant)
```
- Returns 0 if not a Mystic
- Returns `CharacterSource.ResonanceState.CurrentValue` or 0 if null

```csharp
public ResonanceThreshold GetThreshold(Combatant combatant)
```
- Returns Dim if not a Mystic
- Calculates threshold from current resonance value

```csharp
public decimal GetPotencyModifier(Combatant combatant)
```
- Returns threshold-based potency multiplier (0.90m to 1.50m)
- Non-Mystics return 0.90m (Dim threshold default)

```csharp
public CastingModeResult ApplyCastingModeModifiers(CastingMode mode)
```
- Returns CastingModeResult with resonance gain, cast time, and flux modifiers
- Pure function, no side effects

```csharp
public int ProcessResonanceDecay(Combatant combatant)
```
- Returns 0 if not a Mystic or no resonance to decay
- Applies decay via ModifyResonance (handles events)
- Returns actual decay amount

```csharp
public OverflowResult TriggerOverflow(Combatant combatant)
```
- Returns `OverflowResult.None` if not a Mystic or resonance < 100
- Sets `IsOverflowActive = true`
- Increments `OverflowCount`
- Calculates Soul Fracture risk (3+ overflows)
- Publishes OverflowTriggeredEvent
- Returns OverflowResult with all metadata

```csharp
public int ProcessOverflowDischarge(Combatant combatant)
```
- Returns 0 if not a Mystic or no active overflow
- Clears `IsOverflowActive`
- Applies 50-point discharge via ModifyResonance
- Returns actual discharge amount (negative)

```csharp
public void Reset(Combatant combatant)
```
- Calls `ResonanceState.Reset()` if Mystic with ResonanceState
- Logs reset operation

**Helper Methods:**

```csharp
private bool IsMystic(Combatant combatant)
```
- Returns `combatant.IsPlayer && combatant.CharacterSource != null && combatant.CharacterSource.Archetype == ArchetypeType.Mystic`

```csharp
private static ResonanceThreshold CalculateThreshold(int resonanceValue)
```
- Pure function mapping resonance value to threshold enum

---

### MagicService Integration

**Constructor Signature Change:**

Added parameter:
```csharp
IResonanceService resonanceService
```

**CastSpell() Integration:**

```csharp
// After flux generation (line 226)
// v0.4.4a: Apply resonance gain for Mystics (Standard casting mode)
var castingModeResult = _resonanceService.ApplyCastingModeModifiers(CastingMode.Standard);
var resonanceResult = _resonanceService.ModifyResonance(
    caster,
    castingModeResult.ResonanceGain,
    $"Cast: {spell.Name}");

// v0.4.4a: Get potency modifier based on resonance threshold
var potencyModifier = _resonanceService.GetPotencyModifier(caster);

// v0.4.4a: Check if overflow was triggered
if (resonanceResult.OverflowTriggered)
{
    _resonanceService.TriggerOverflow(caster);
    _logger.LogWarning("[Magic] {Caster} triggered Aetheric Overflow!", caster.Name);
}

// Execute effect script with potency modifier
var result = ExecuteSpellEffect(caster, target, spell, fluxGenerated, potencyModifier);
```

**ReleaseCharge() Integration:**

```csharp
// After backlash check (line 332)
// v0.4.4a: Apply resonance gain for Mystics (Channeled casting mode - reduced resonance)
var castingModeResult = _resonanceService.ApplyCastingModeModifiers(CastingMode.Channeled);
var resonanceResult = _resonanceService.ModifyResonance(
    caster,
    castingModeResult.ResonanceGain,
    $"Channeled cast: {spell.Name}");

// v0.4.4a: Get potency modifier based on resonance threshold
var potencyModifier = _resonanceService.GetPotencyModifier(caster);

// v0.4.4a: Check if overflow was triggered
if (resonanceResult.OverflowTriggered)
{
    _resonanceService.TriggerOverflow(caster);
    _logger.LogWarning("[Magic] {Caster} triggered Aetheric Overflow during charged release!", caster.Name);
}

// Execute the actual effect with potency modifier
var result = ExecuteSpellEffect(caster, target, spell, fluxGenerated: 0, potencyModifier);
```

**ExecuteSpellEffect() Signature Change:**

```csharp
private MagicResult ExecuteSpellEffect(
    Combatant caster,
    Combatant target,
    Spell spell,
    int fluxGenerated,
    decimal potencyModifier = 1.0m)
```

**Potency Application:**

```csharp
// v0.4.4a: Apply potency modifier to damage and healing
var modifiedDamage = (int)(scriptResult.TotalDamage * potencyModifier);
var modifiedHealing = (int)(scriptResult.TotalHealing * potencyModifier);

if (potencyModifier != 1.0m)
{
    _logger.LogDebug(
        "[Magic] Potency modifier {Modifier}x applied: Damage {BaseDmg} -> {ModDmg}, Healing {BaseHeal} -> {ModHeal}",
        potencyModifier,
        scriptResult.TotalDamage, modifiedDamage,
        scriptResult.TotalHealing, modifiedHealing);
}
```

---

### Character.cs Integration

**New Region:**

```csharp
#region Resonance System (v0.4.4a)

/// <summary>
/// Resonance state for Mystic characters tracking personal Flux attunement.
/// Null for non-Mystic archetypes.
/// </summary>
/// <remarks>See: v0.4.4a (The Attunement) for Resonance System design.</remarks>
public ResonanceState? ResonanceState { get; set; }

/// <summary>
/// Current resonance value (0 for non-Mystics).
/// </summary>
public int Resonance => ResonanceState?.CurrentValue ?? 0;

#endregion
```

**Location:** After Faction System region (line 281), before Attribute Methods region

---

## Logging Matrix

### ResonanceService Logs

| Event | Level | Template |
|-------|-------|----------|
| Service initialization | Debug | `[Resonance] ResonanceService initialized` |
| ModifyResonance called | Debug | `[Resonance] ModifyResonance called: Combatant={Name}, Amount={Amount}, Source={Source}` |
| Non-Mystic modify attempt | Warning | `[Resonance] ModifyResonance called for non-Mystic combatant {Name}` |
| Previous state | Trace | `[Resonance] Previous state: Value={Value}, Threshold={Threshold}` |
| New state | Trace | `[Resonance] New state: Value={Value}, Threshold={Threshold}, ActualChange={Actual}` |
| Threshold change | Information | `[Resonance] Threshold changed for {Name}: {OldThreshold} -> {NewThreshold} (Value: {Value})` |
| Event publication | Debug | `[Resonance] Published ResonanceChangedEvent: {OldValue} -> {NewValue} ({Source})` |
| Overflow warning | Warning | `[Resonance] OVERFLOW TRIGGERED: {Name} resonance reached {Value}!` |
| ModifyResonance completed | Debug | `[Resonance] ModifyResonance completed: {PrevValue} -> {NewValue}, ThresholdChanged={Changed}` |
| GetResonance | Trace | `[Resonance] GetResonance called for {Name}` / `Resonance for {Name}: {Value}` |
| GetThreshold | Trace | `[Resonance] GetThreshold called for {Name}` / `Threshold for {Name}: {Threshold}` |
| GetPotencyModifier | Debug | `[Resonance] Potency modifier for {Name}: {Modifier}x at {Threshold} threshold` |
| ApplyCastingModeModifiers | Debug | `[Resonance] Casting mode {Mode}: ResonanceGain={Res}, CastTime={Time}, FluxMod={Flux}` |
| ProcessResonanceDecay | Debug/Info | `[Resonance] ProcessResonanceDecay called for {Name}` / `Resonance decayed for {Name}: {OldValue} -> {NewValue} (-{Decay})` |
| TriggerOverflow | Warning/Critical | `[Resonance] AETHERIC OVERFLOW: {Name} resonance peaked!` / `[Resonance] SOUL FRACTURE RISK: {Name} has triggered {Count} overflows!` |
| ProcessOverflowDischarge | Information | `[Resonance] Overflow discharged for {Name}: Reduced by {Amount} to {NewValue}` |
| Reset | Information | `[Resonance] Resonance reset for {Name}: {OldValue} -> 0` |

### MagicService Integration Logs

| Event | Level | Template |
|-------|-------|----------|
| Overflow triggered | Warning | `[Magic] {Caster} triggered Aetheric Overflow!` |
| Overflow during release | Warning | `[Magic] {Caster} triggered Aetheric Overflow during charged release!` |
| Potency modifier applied | Debug | `[Magic] Potency modifier {Modifier}x applied: Damage {BaseDmg} -> {ModDmg}, Healing {BaseHeal} -> {ModHeal}` |

---

## Test Coverage

### Test Summary

```
Total: 61 | Passed: 61 | Failed: 0 | Duration: ~50ms
```

### Complete Test Inventory

#### ResonanceServiceTests (61 tests)

##### ModifyResonance Tests (8 tests)

| Test Name | Description |
|-----------|-------------|
| `ModifyResonance_WithPositiveAmount_IncreasesResonance` | Verifies adding 15 resonance increases CurrentValue from 20 to 35 |
| `ModifyResonance_WithNegativeAmount_DecreasesResonance` | Verifies removing 20 resonance decreases CurrentValue from 50 to 30 |
| `ModifyResonance_ExceedingMax_ClampsTo100` | Verifies adding 20 resonance from 90 clamps to 100, sets WasClamped and OverflowTriggered |
| `ModifyResonance_BelowMin_ClampsTo0` | Verifies removing 30 resonance from 15 clamps to 0, sets WasClamped and FullyDissipated |
| `ModifyResonance_ForNonMystic_ReturnsNoChange` | Verifies Warrior combatant returns NoChange result |
| `ModifyResonance_WithNullResonanceState_InitializesState` | Verifies null ResonanceState is initialized on first modification |
| `ModifyResonance_WithZeroAmount_ReturnsCurrentState` | Verifies zero amount produces no change |
| `ModifyResonance_RecordsSource` | Verifies source string is recorded in result |

##### Threshold Detection Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `GetThreshold_ReturnsCorrectThreshold` (Theory) | InlineData(0-100) verifies all threshold boundaries: 0→Dim, 24→Dim, 25→Steady, 49→Steady, 50→Bright, 74→Bright, 75→Blazing, 99→Blazing, 100→Overflow |
| `ModifyResonance_CrossingThresholdUp_SetsThresholdChanged` | Verifies 24→25 transition sets ThresholdChanged=true, Dim→Steady |
| `ModifyResonance_CrossingThresholdDown_SetsThresholdChanged` | Verifies 50→49 transition sets ThresholdChanged=true, Bright→Steady |
| `ModifyResonance_WithinSameThreshold_ThresholdUnchanged` | Verifies 30→40 does not change threshold (both Steady) |
| `ModifyResonance_CrossingMultipleThresholds_ReportsCorrectThresholds` | Verifies 20→80 reports Dim→Blazing |
| `GetThreshold_ForNonMystic_ReturnsDim` | Verifies Warrior returns Dim threshold |

##### Potency Calculation Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `GetPotencyModifier_ReturnsCorrectMultiplier` (Theory) | InlineData(0-100) verifies all potency values: 0→0.90, 24→0.90, 25→1.00, 49→1.00, 50→1.15, 74→1.15, 75→1.30, 99→1.30, 100→1.50 |
| `GetPotencyModifier_ForNonMystic_Returns090` | Verifies Warrior returns 0.90 (Dim default) |
| `GetPotencyModifier_AtDimThreshold_AppliesPenalty` | Verifies 10 resonance results in 90 damage from 100 base |
| `GetPotencyModifier_AtOverflow_GrantsMaxBonus` | Verifies 100 resonance results in 150 damage from 100 base |
| `ResonanceState_PotencyModifier_MatchesServiceCalculation` | Verifies state computed property matches service calculation |

##### Casting Mode Tests (8 tests)

| Test Name | Description |
|-----------|-------------|
| `ApplyCastingModeModifiers_Quick_ReturnsCorrectValues` | Verifies Quick: +15 resonance, 0 cast time, +5 flux, IsBonusAction=true |
| `ApplyCastingModeModifiers_Standard_ReturnsCorrectValues` | Verifies Standard: +10 resonance, 1 cast time, 0 flux |
| `ApplyCastingModeModifiers_Channeled_ReturnsCorrectValues` | Verifies Channeled: +5 resonance, 2 cast time, -5 flux, IsExtendedCast=true |
| `ApplyCastingModeModifiers_Ritual_ReturnsCorrectValues` | Verifies Ritual: +0 resonance, -1 cast time, -10 flux, IsOutOfCombatOnly=true |
| `CastingModeResult_Description_ReturnsCorrectText` | Verifies Description contains "bonus action" and "out of combat" |
| `ApplyCastingModeModifiers_Quick_AddsExtraFlux` | Verifies Quick FluxModifier > 0 |
| `ApplyCastingModeModifiers_Channeled_ReducesFlux` | Verifies Channeled FluxModifier < 0 |
| `ApplyCastingModeModifiers_Ritual_HasZeroResonanceGain` | Verifies Ritual ResonanceGain = 0 |

##### Overflow & Decay Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `TriggerOverflow_AtMax_ReturnsOverflowResult` | Verifies at 100: PotencyBonus=1.50, DurationTurns=1, DischargeAmount=50, OverflowCount=1, IsOverflowActive=true |
| `TriggerOverflow_BelowMax_ReturnsNone` | Verifies at 99: returns OverflowResult.None |
| `TriggerOverflow_ThirdTime_SetsSoulFractureRisk` | Verifies 3rd overflow: SoulFractureRisk=true, TotalOverflowCount=3 |
| `ProcessOverflowDischarge_ReducesResonanceBy50` | Verifies discharge: 100→50, IsOverflowActive=false |
| `ProcessResonanceDecay_ReducesByDecayRate` | Verifies decay: 50→40 (default 10 decay) |
| `ProcessResonanceDecay_AtLowResonance_DecaysToZero` | Verifies decay: 5→0 (clamped) |

##### Event Publishing Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `ModifyResonance_OnThresholdChange_PublishesEvent` | Verifies event published with ThresholdChanged=true on 24→25 |
| `ModifyResonance_OnLargeChange_PublishesEvent` | Verifies event published on >= 15 point change |
| `ModifyResonance_OnSmallChangeWithinThreshold_DoesNotPublishEvent` | Verifies no event on 5 point change within threshold |
| `TriggerOverflow_PublishesOverflowEvent` | Verifies OverflowTriggeredEvent published with correct CharacterId and OverflowCount |

##### Integration Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `FullCastingCycle_Quick_AppliesCorrectResonance` | Verifies Quick cast: 20→35, Dim→Steady threshold change |
| `FullCastingCycle_Channeled_AppliesReducedResonance` | Verifies Channeled cast: 40→45, no threshold change |
| `PotencyCalculation_IntegratesWithResonance` | Verifies 60 resonance → 1.15x modifier → 115 damage from 100 base |
| `OverflowCycle_TriggerAndDischarge_CompletesCorrectly` | Verifies full overflow cycle: 95→100 (overflow), discharge→50, IsOverflowActive=false |

##### Reset Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `Reset_ClearsResonanceToZero` | Verifies 75→0 |
| `Reset_ClearsOverflowState` | Verifies IsOverflowActive=false after reset |
| `Reset_ForNonMystic_DoesNothing` | Verifies no exception for Warrior |
| `GetResonance_ForEnemy_ReturnsZero` | Verifies enemy combatant returns 0 |

---

## DI Registration

### Program.cs (Terminal)

```csharp
// Register Resonance Service (v0.4.4a - The Attunement)
services.AddSingleton<IResonanceService, ResonanceService>();
```

**Location:** After MagicService registration (line 177)
**Lifetime:** Singleton (resonance state is per-character, but service is stateless)

### MagicServiceTests.cs (Test Infrastructure)

```csharp
_mockResonance = new Mock<IResonanceService>();

// Configure resonance service to return neutral values by default (v0.4.4a)
_mockResonance.Setup(r => r.ApplyCastingModeModifiers(It.IsAny<CastingMode>()))
    .Returns(new CastingModeResult(CastingMode.Standard, 10, 1, 0));
_mockResonance.Setup(r => r.ModifyResonance(It.IsAny<Combatant>(), It.IsAny<int>(), It.IsAny<string>()))
    .Returns(ResonanceResult.NoChange("Test"));
_mockResonance.Setup(r => r.GetPotencyModifier(It.IsAny<Combatant>()))
    .Returns(1.0m);
```

**Purpose:** Ensures existing MagicService tests continue to pass with neutral resonance behavior

---

## Verification Results

### Build Output

```
Build succeeded.
    0 Error(s)

Time Elapsed 00:00:02.28
```

**Note:** Pre-existing warnings (MSB3277, CS1998, etc.) are unrelated to this release.

### Test Output

**ResonanceServiceTests:**
```
Passed!  - Failed:     0, Passed:    61, Skipped:     0, Total:    61, Duration: ~50 ms
```

**MagicServiceTests:**
```
Passed!  - Failed:     0, Passed:    35, Skipped:     0, Total:    35, Duration: 70 ms
```

**Note:** All existing MagicService tests continue to pass with the new IResonanceService integration.

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   ├── Character.cs [MODIFIED - added ResonanceState property]
│   └── (existing entities...)
├── Enums/
│   ├── CastingMode.cs [NEW]
│   ├── ResonanceThreshold.cs [NEW]
│   └── (existing enums...)
├── Events/
│   ├── OverflowTriggeredEvent.cs [NEW]
│   ├── ResonanceChangedEvent.cs [NEW]
│   └── (existing events...)
├── Interfaces/
│   ├── IResonanceService.cs [NEW]
│   └── (existing interfaces...)
└── Models/
    └── Magic/
        ├── CastingModeResult.cs [NEW]
        ├── FluxState.cs (existing - v0.4.3a)
        ├── OverflowResult.cs [NEW]
        ├── ResonanceResult.cs [NEW]
        ├── ResonanceState.cs [NEW]
        └── (existing magic models...)

RuneAndRust.Engine/
└── Services/
    ├── MagicService.cs [MODIFIED - resonance integration]
    ├── ResonanceService.cs [NEW]
    └── (existing services...)

RuneAndRust.Terminal/
├── Program.cs [MODIFIED - IResonanceService registration]
└── (existing files...)

RuneAndRust.Tests/
└── Engine/
    └── Services/
        ├── MagicServiceTests.cs [MODIFIED - IResonanceService mock]
        ├── ResonanceServiceTests.cs [NEW]
        └── (existing service tests...)

docs/changelogs/v0.4.x/
├── v0.4.4a.md [NEW]
└── (existing changelogs...)
```

---

## Running Tests

### Run ResonanceService Tests Only

```bash
dotnet test --filter "FullyQualifiedName~ResonanceServiceTests"
```

**Expected Output:**
```
Passed!  - Failed:     0, Passed:    61, Skipped:     0, Total:    61
```

### Run All Magic-Related Tests

```bash
dotnet test --filter "FullyQualifiedName~MagicServiceTests|FullyQualifiedName~ResonanceServiceTests"
```

### Run All Engine Service Tests

```bash
dotnet test --filter "FullyQualifiedName~Engine.Services"
```

---

## Next Steps

The following work is planned for subsequent releases:

1. **v0.4.4b: GaldrService (Spell Words)**
   - Implement Galdr (verbal spell components) system
   - Add Galdr cost to spells alongside AP cost
   - Create GaldrState model tracking available spell words
   - Integrate with MagicService for Galdr expenditure

2. **v0.4.4c: Ritual Casting Mode Integration**
   - Implement out-of-combat ritual casting
   - Add UI for selecting casting mode before spell cast
   - Apply CastingMode flux modifiers to environmental flux
   - Create rest period resonance decay integration

3. **v0.4.4d: ParadoxService (Soul Fracture)**
   - Implement Soul Fracture mechanics for high-overflow Mystics
   - Create Paradox events and penalties
   - Add permanent corruption gain on Soul Fracture
   - Integrate with BacklashService for compound effects

4. **v0.4.5: Resonance UI Display**
   - Add ResonanceBar component to CombatScreenRenderer
   - Implement color-coded threshold visualization
   - Add resonance change animations and threshold alerts
   - Display current threshold tier and potency modifier

---

## Design Decisions & Rationale

### Per-Character vs Per-Encounter State

**Decision:** Resonance is stored in Character.ResonanceState (per-character) rather than a service singleton
**Rationale:** Unlike environmental Flux which is shared, Resonance represents each Mystic's personal attunement. Different Mystics can have different resonance levels in the same encounter.

### Combatant-Oriented Interface

**Decision:** IResonanceService methods accept Combatant rather than Character
**Rationale:** Maintains consistency with MagicService interface. Combatant wrapper provides combat-time state while accessing CharacterSource for persistent data.

### Automatic ResonanceState Initialization

**Decision:** ModifyResonance initializes null ResonanceState automatically
**Rationale:** Defensive programming prevents null reference exceptions. First spell cast by a Mystic creates their resonance tracking.

### Potency Modifier Application Location

**Decision:** Apply potency modifier in ExecuteSpellEffect rather than before script execution
**Rationale:** Keeps effect script execution unchanged. Modifier is applied to final damage/healing output, maintaining compatibility with existing spell scripts.

### Standard Mode Default for CastSpell

**Decision:** CastSpell uses Standard casting mode, ReleaseCharge uses Channeled mode
**Rationale:** Standard is the default single-turn cast. Channeled spells already use extended cast times via ChargeTurns, so they receive reduced resonance gain.

### Non-Mystic Handling

**Decision:** Return NoChange/default values for non-Mystics rather than throwing exceptions
**Rationale:** MagicService serves both Adepts and Mystics. Resonance only affects Mystics, but the service integration should be transparent for Adepts.

### Overflow Mechanics Split

**Decision:** TriggerOverflow and ProcessOverflowDischarge are separate methods
**Rationale:** Overflow grants a 1-turn potency bonus before discharge. Separating allows combat system to process the bonus turn, then discharge at turn end.

### Soul Fracture Risk Threshold

**Decision:** Soul Fracture risk activates at 3+ overflows
**Rationale:** Provides meaningful risk without being too punishing. Players have two "safe" overflows before facing permanent consequences.

### Event Publication Criteria

**Decision:** Publish events on threshold change, significant change (≥15), or boundary hit
**Rationale:** Consistent with FluxChangedEvent criteria from v0.4.3a. Balances informativeness with event bus noise reduction.

---

## Dependencies and Integration

### Required by This Release
- v0.4.3a (IAetherService, IEventBus) - Flux system foundation
- v0.4.3c (IMagicService, MagicService) - Spell casting integration point

### Will Be Used By
- v0.4.4b (GaldrService) - Will coordinate with resonance for spell word costs
- v0.4.4d (ParadoxService) - Will consume overflow events for Soul Fracture mechanics
- v0.4.5 (UI) - Will display resonance bar and threshold indicators

---

**End of Changelog v0.4.4a**
