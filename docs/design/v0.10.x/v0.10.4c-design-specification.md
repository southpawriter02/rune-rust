# v0.10.4c Design Specification: Monster Groups

**Version:** 0.10.4c
**Parent:** v0.10.4 (Advanced Encounters)
**Prerequisites:** v0.10.4b Complete (Boss Mechanics)
**Status:** Design Complete
**Estimated Unit Tests:** ~11

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [GroupTactic Enum](#4-grouptactic-enum)
5. [SynergyTrigger Enum](#5-synergytrigger-enum)
6. [GroupMember Class](#6-groupmember-class)
7. [GroupSynergy Class](#7-groupsynergy-class)
8. [MonsterGroupDefinition Entity](#8-monstergroupdefinition-entity)
9. [MonsterGroupInstance Class](#9-monstergroupinstance-class)
10. [GroupMoveDecision Value Object](#10-groupmovedecision-value-object)
11. [IMonsterGroupProvider Interface](#11-imonstergrouprovider-interface)
12. [MonsterGroupProvider Implementation](#12-monstergrouprovider-implementation)
13. [IMonsterGroupService Interface](#13-imonstergroupservice-interface)
14. [MonsterGroupService Implementation](#14-monstergroupservice-implementation)
15. [Configuration Schema](#15-configuration-schema)
16. [Configuration File](#16-configuration-file)
17. [Unit Testing Requirements](#17-unit-testing-requirements)
18. [Use Cases](#18-use-cases)
19. [Deliverable Checklist](#19-deliverable-checklist)
20. [Acceptance Criteria](#20-acceptance-criteria)
21. [Dependencies](#21-dependencies)
22. [Future Considerations](#22-future-considerations)
23. [Logging Specifications](#23-logging-specifications)

---

## 1. Executive Summary

### Purpose

This version implements coordinated monster group behaviors with tactical AI patterns. Building upon the existing monster AI and combat grid systems, this phase adds group definitions with member compositions, tactical behaviors (flanking, focus fire, protect leader), and synergy effects that provide bonuses when group conditions are met. The `MonsterGroupService` coordinates group member actions, determines optimal positioning based on tactics, and applies synergy bonuses during combat.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Enums** | `GroupTactic`, `SynergyTrigger` |
| **Domain Classes** | `GroupMember`, `GroupSynergy`, `MonsterGroupDefinition` |
| **Tracking Classes** | `MonsterGroupInstance`, `GroupMoveDecision` |
| **Interfaces** | `IMonsterGroupProvider`, `IMonsterGroupService` |
| **Services** | `MonsterGroupProvider`, `MonsterGroupService` |
| **Configuration** | `monster-groups.json`, `monster-groups.schema.json` |
| **Tests** | ~11 unit tests |

### Architectural Significance

This version establishes the **Coordinated Group Tactics Pattern** for AI encounters:

- Group definitions separate from individual monster definitions
- Tactical behavior priorities (Flank > FocusFire > ProtectLeader)
- Synergy triggers that provide combat bonuses based on group state
- Active group instance tracking for runtime state
- Position-based tactics integration with existing FlankingService
- The pattern enables challenging coordinated encounters that require tactical responses

---

## 2. Feature Overview

```
v0.10.4c Features
├── MonsterGroupDefinition Entity
│   ├── GroupId (unique identifier)
│   ├── Name (display name)
│   ├── Description
│   ├── Members (list of GroupMember)
│   │   ├── MonsterDefinitionId
│   │   ├── Count
│   │   ├── Role (melee, ranged, leader, striker)
│   │   └── PreferredPosition (optional GridOffset)
│   ├── Tactics (priority-ordered list)
│   ├── Synergies (list of GroupSynergy)
│   ├── LeaderRole (which role is leader)
│   └── MinSize / MaxSize constraints
│
├── GroupTactic Enum
│   ├── Flank (surround target for flanking bonus)
│   ├── FocusFire (all attack same target)
│   ├── ProtectLeader (defend group leader)
│   ├── ProtectCaster (defend spellcasters)
│   ├── Swarm (close in from all sides)
│   ├── Retreat (fall back when damaged)
│   ├── Ambush (wait for opportunity)
│   └── HitAndRun (attack then disengage)
│
├── SynergyTrigger Enum
│   ├── Always (passive bonus)
│   ├── OnAllyHit (when ally lands attack)
│   ├── OnAllyDamaged (when ally takes damage)
│   ├── OnLeaderCommand (leader uses command ability)
│   └── PerAdjacentAlly (scales with nearby allies)
│
├── GroupSynergy Class
│   ├── SynergyId
│   ├── Name / Description
│   ├── Trigger (SynergyTrigger)
│   ├── SourceRole (optional role requirement)
│   ├── StatusEffectId (optional buff to apply)
│   ├── AttackBonus / DamageBonus
│   └── AppliesToAllMembers flag
│
├── IMonsterGroupProvider Interface
│   ├── GetGroup(groupId) → MonsterGroupDefinition?
│   ├── GetAllGroups() → List
│   ├── GroupExists(groupId) → bool
│   └── GetGroupsByTag(tag) → List
│
├── MonsterGroupProvider Implementation
│   ├── JSON configuration loading
│   ├── Schema validation
│   └── Caching for performance
│
├── IMonsterGroupService Interface
│   ├── SpawnGroup(groupId, centerPosition) → List<Monster>
│   ├── GetGroupForMonster(monster) → MonsterGroupInstance?
│   ├── DetermineMove(monster) → GroupMoveDecision
│   ├── DetermineTarget(monster, possibleTargets) → ICombatant?
│   ├── ApplySynergies(group)
│   ├── OnGroupMemberHit(attacker, target)
│   ├── OnGroupMemberDeath(monster)
│   └── GetFlankingPositions(target, groupSize) → List<GridPosition>
│
├── MonsterGroupService Implementation
│   ├── Active group instance tracking
│   ├── Monster-to-group mapping
│   ├── Tactic execution by priority
│   │   ├── Flank: GetBestFlankingPosition()
│   │   ├── FocusFire: Track shared target
│   │   ├── ProtectLeader: GetProtectionPosition()
│   │   ├── Swarm: GetClosestPositionToTarget()
│   │   └── HitAndRun: Attack + Disengage
│   ├── Synergy application
│   │   ├── Always: Apply on spawn
│   │   ├── OnAllyHit: Temporary bonus
│   │   └── PerAdjacentAlly: Calculate adjacency
│   └── Group state updates on member death
│
├── MonsterGroupInstance Tracking
│   ├── Instance ID
│   ├── GroupId reference
│   ├── Definition reference
│   ├── AliveMembers list
│   ├── CurrentTarget tracking
│   └── Leader tracking
│
└── Configuration
    ├── monster-groups.json
    │   ├── goblin-warband (4 members)
    │   ├── skeleton-patrol (4 members)
    │   └── bandit-ambush (4 members)
    └── monster-groups.schema.json
```

---

## 3. Architecture Diagrams

### 3.1 Monster Group Service Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    MONSTER GROUP ARCHITECTURE                            │
└─────────────────────────────────────────────────────────────────────────┘

                      ┌───────────────────────────┐
                      │      Encounter System      │
                      │    (Spawn group events)    │
                      └───────────────┬───────────┘
                                      │ SpawnGroup(groupId, position)
                                      ▼
                      ┌───────────────────────────┐
                      │   IMonsterGroupService     │
                      ├───────────────────────────┤
                      │ + SpawnGroup(id, pos)     │
                      │ + GetGroupForMonster(m)   │
                      │ + DetermineMove(m)        │
                      │ + DetermineTarget(m,tgts) │
                      │ + ApplySynergies(group)   │
                      │ + OnGroupMemberHit(a,t)   │
                      │ + OnGroupMemberDeath(m)   │
                      │ + GetFlankingPositions()  │
                      └───────────────┬───────────┘
                                      │
        ┌─────────────────────────────┴─────────────────────────────┐
        │                    MonsterGroupService                     │
        ├───────────────────────────────────────────────────────────┤
        │  Dependencies:                                             │
        │  ├── IMonsterGroupProvider (group definitions)            │
        │  ├── IMonsterSpawnService (monster spawning)              │
        │  ├── ICombatGrid (grid access)                            │
        │  ├── IFlankingService (flanking positions)                │
        │  ├── IBuffDebuffService (synergy buffs)                   │
        │  └── IEventBus (group events)                             │
        │                                                           │
        │  State:                                                   │
        │  ├── _activeGroups: Dictionary<Guid, MonsterGroupInstance>│
        │  └── _monsterToGroup: Dictionary<Guid, Guid>              │
        │                                                           │
        │  Methods:                                                 │
        │  ├── GetSpawnPositions(center, count) → List<GridPosition>│
        │  ├── GetBestFlankingPosition(monster, target, group)      │
        │  ├── GetProtectionPosition(monster, leader)               │
        │  ├── GetClosestPositionToTarget(monster, target)          │
        │  ├── ApplyAlwaysSynergies(group)                          │
        │  ├── ApplyOnAllyHitSynergies(attacker, group)             │
        │  └── CalculateAdjacentAllyBonus(monster, group, synergy)  │
        └───────────────────────────────────────────────────────────┘
```

### 3.2 Group Tactic Decision Flow

```
    GROUP TACTIC DECISION FLOW
    ═══════════════════════════════════════════════════════════════════

    Monster turn begins (AI Service requests move)
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 1. GET GROUP FOR MONSTER                                         │
    │    → GetGroupForMonster(monster)                                │
    │    → Returns MonsterGroupInstance or null                       │
    │    → If no group: Return GroupMoveDecision.NoGroup()            │
    └──────────────────────────────────────────────────────────────────┘
            │ Has group
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 2. GET GROUP TARGET                                              │
    │    → Get group's current shared target                          │
    │    → If no target: Return GroupMoveDecision.NoTarget()          │
    └──────────────────────────────────────────────────────────────────┘
            │ Has target
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 3. EVALUATE TACTICS IN PRIORITY ORDER                            │
    │                                                                  │
    │    for each tactic in groupDef.Tactics:                         │
    │        switch (tactic)                                          │
    └──────────────────────────────────────────────────────────────────┘
            │
            ├──────────────────────────────────────────────────────────┐
            │ GroupTactic.Flank                                        │
            ▼                                                          │
    ┌───────────────────────────────────────┐                          │
    │ FLANK TACTIC                          │                          │
    ├───────────────────────────────────────┤                          │
    │ 1. Get flanking positions for target  │                          │
    │ 2. Filter occupied positions          │                          │
    │ 3. Find best unoccupied position      │                          │
    │ 4. If found: Return MoveTo(pos,Flank) │                          │
    │ 5. If not found: Continue to next     │                          │
    └───────────────────────────────────────┘                          │
            │                                                          │
            ├──────────────────────────────────────────────────────────┤
            │ GroupTactic.ProtectLeader                                │
            ▼                                                          │
    ┌───────────────────────────────────────┐                          │
    │ PROTECT LEADER TACTIC                 │                          │
    ├───────────────────────────────────────┤                          │
    │ 1. Get group leader                   │                          │
    │ 2. If monster IS leader: Skip         │                          │
    │ 3. Get position between leader/enemy  │                          │
    │ 4. Return MoveTo(pos, ProtectLeader)  │                          │
    └───────────────────────────────────────┘                          │
            │                                                          │
            ├──────────────────────────────────────────────────────────┤
            │ GroupTactic.Swarm                                        │
            ▼                                                          │
    ┌───────────────────────────────────────┐                          │
    │ SWARM TACTIC                          │                          │
    ├───────────────────────────────────────┤                          │
    │ 1. Get closest position to target     │                          │
    │ 2. Return MoveTo(pos, Swarm)          │                          │
    └───────────────────────────────────────┘                          │
            │                                                          │
            └──────────────────────────────────────────────────────────┘
            │ No tactic found valid position
            ▼
    ┌───────────────────────────────────────┐
    │ DEFAULT: NO ACTION                    │
    │ Return GroupMoveDecision.NoAction()   │
    └───────────────────────────────────────┘
```

### 3.3 Flanking Position Calculation

```
    FLANKING POSITION CALCULATION
    ═══════════════════════════════════════════════════════════════════

    Target Position: (5, 5) = @
    Flanking Positions: Adjacent cells around target

        FLANKING GRID                      PRIORITY ORDER
    ┌───┬───┬───┬───┬───┐             ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │             │   │   │ 1 │   │   │
    ├───┼───┼───┼───┼───┤             ├───┼───┼───┼───┼───┤
    │   │   │ F │   │   │             │   │ 4 │ @ │ 2 │   │
    ├───┼───┼───┼───┼───┤             ├───┼───┼───┼───┼───┤
    │   │ F │ @ │ F │   │   ────▶     │   │   │ 3 │   │   │
    ├───┼───┼───┼───┼───┤             ├───┼───┼───┼───┼───┤
    │   │   │ F │   │   │             │   │   │   │   │   │
    ├───┼───┼───┼───┼───┤             └───┴───┴───┴───┴───┘
    │   │   │   │   │   │
    └───┴───┴───┴───┴───┘             1 = North (5,4)
                                      2 = East  (6,5)
    F = Flanking position             3 = South (5,6)
    @ = Target                        4 = West  (4,5)


    GOBLIN WARBAND FLANKING EXECUTION
    ─────────────────────────────────────

    Initial State:                    After Flank Tactic:
    ┌───┬───┬───┬───┬───┐            ┌───┬───┬───┬───┬───┐
    │ G1│   │   │   │   │            │   │   │ G1│   │   │
    ├───┼───┼───┼───┼───┤            ├───┼───┼───┼───┼───┤
    │ G2│   │ @ │   │   │   ────▶    │   │ G2│ @ │ G3│   │
    ├───┼───┼───┼───┼───┤            ├───┼───┼───┼───┼───┤
    │ G3│   │   │   │   │            │   │   │ S │   │   │
    ├───┼───┼───┼───┼───┤            ├───┼───┼───┼───┼───┤
    │ S │   │   │   │   │            │   │   │   │   │   │
    └───┴───┴───┴───┴───┘            └───┴───┴───┴───┴───┘

    G1, G2, G3 = Goblin Warriors      Player now surrounded!
    S = Shaman (Leader)               Flanking bonuses apply
    @ = Player target                 Shaman stays protected
```

### 3.4 Synergy Trigger Flow

```
    SYNERGY TRIGGER FLOW
    ═══════════════════════════════════════════════════════════════════

    ┌─────────────────────────────────────────────────────────────────┐
    │                    SYNERGY TYPES & TRIGGERS                      │
    └─────────────────────────────────────────────────────────────────┘

    ┌───────────────────────────────────────────────────────────────┐
    │ SynergyTrigger.Always                                         │
    ├───────────────────────────────────────────────────────────────┤
    │ When: On group spawn                                          │
    │ Duration: Permanent while source alive                        │
    │ Example: "Shaman's Blessing" - Shaman buffs all allies +1 atk │
    │                                                               │
    │ Flow:                                                         │
    │   SpawnGroup() → ApplySynergies() → For each Always synergy:  │
    │   → If sourceRole matches member role                         │
    │   → Apply buff to all/affected members                        │
    └───────────────────────────────────────────────────────────────┘
            │
            ▼
    ┌───────────────────────────────────────────────────────────────┐
    │ SynergyTrigger.OnAllyHit                                      │
    ├───────────────────────────────────────────────────────────────┤
    │ When: A group member lands a hit                              │
    │ Duration: 1 turn (temporary bonus)                            │
    │ Example: "Pack Tactics" - When ally hits, others get +2 atk   │
    │                                                               │
    │ Flow:                                                         │
    │   OnGroupMemberHit(attacker, target)                          │
    │   → Get group for attacker                                    │
    │   → For each OnAllyHit synergy:                               │
    │   → Apply temporary bonus to other members                    │
    └───────────────────────────────────────────────────────────────┘
            │
            ▼
    ┌───────────────────────────────────────────────────────────────┐
    │ SynergyTrigger.OnAllyDamaged                                  │
    ├───────────────────────────────────────────────────────────────┤
    │ When: A group member takes damage                             │
    │ Duration: Varies (1-3 turns)                                  │
    │ Example: "Rage" - When ally hurt, others get damage bonus     │
    │                                                               │
    │ Flow:                                                         │
    │   OnGroupMemberDamaged(target, damage)                        │
    │   → Get group for target                                      │
    │   → For each OnAllyDamaged synergy:                           │
    │   → Apply buff to other members                               │
    └───────────────────────────────────────────────────────────────┘
            │
            ▼
    ┌───────────────────────────────────────────────────────────────┐
    │ SynergyTrigger.PerAdjacentAlly                                │
    ├───────────────────────────────────────────────────────────────┤
    │ When: Calculated per attack                                   │
    │ Duration: Instant (per-attack calculation)                    │
    │ Example: "Pack Mentality" - +1 damage per adjacent ally       │
    │                                                               │
    │ Flow:                                                         │
    │   GetSynergyBonus(monster, synergy)                           │
    │   → Count adjacent allies in group                            │
    │   → Multiply count by bonus value                             │
    │   → Return total bonus                                        │
    │                                                               │
    │   Example: 3 adjacent allies × +1 damage = +3 damage          │
    └───────────────────────────────────────────────────────────────┘


    SYNERGY STATE DIAGRAM
    ─────────────────────

    ┌──────────────┐  SpawnGroup   ┌──────────────────────────────────┐
    │  No Synergy  │ ───────────▶  │  Always Synergies Applied        │
    │              │               │  (Shaman buff active)            │
    └──────────────┘               └──────────────┬───────────────────┘
                                                  │
                           Ally lands hit         │
                                                  ▼
                                   ┌──────────────────────────────────┐
                                   │  OnAllyHit Bonus Active (1 turn) │
                                   │  +2 attack to other members      │
                                   └──────────────┬───────────────────┘
                                                  │
                           Turn ends              │
                                                  ▼
                                   ┌──────────────────────────────────┐
                                   │  Bonus Expires                   │
                                   │  Returns to base synergy state   │
                                   └──────────────────────────────────┘
```

### 3.5 Clean Architecture Layers

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      CLEAN ARCHITECTURE LAYERS                           │
└─────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────┐
    │                        PRESENTATION                              │
    │  (Consumes events for UI display)                               │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Event Handlers (via IEventBus)                          │    │
    │  │ └── Renders group spawn, synergy activation indicators  │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
                                    │ subscribes to events
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                        APPLICATION                               │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Interfaces/                                              │    │
    │  │ ├── IMonsterGroupProvider.cs  [NEW]                     │    │
    │  │ └── IMonsterGroupService.cs  [NEW]                      │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Services/                                                │    │
    │  │ └── MonsterGroupService.cs  [NEW]                       │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Tracking/                                                │    │
    │  │ ├── MonsterGroupInstance.cs  [NEW]                      │    │
    │  │ └── GroupMoveDecision.cs  [NEW]                         │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
                                    │ uses
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                          DOMAIN                                  │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Definitions/                                             │    │
    │  │ └── MonsterGroupDefinition.cs  [NEW]                    │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Enums/                                                   │    │
    │  │ ├── GroupTactic.cs  [NEW]                               │    │
    │  │ └── SynergyTrigger.cs  [NEW]                            │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ ValueObjects/                                            │    │
    │  │ ├── GroupMember.cs  [NEW]                               │    │
    │  │ ├── GroupSynergy.cs  [NEW]                              │    │
    │  │ └── GridOffset.cs  [NEW]                                │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
                                    │ uses
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                      INFRASTRUCTURE                              │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Providers/                                               │    │
    │  │ └── MonsterGroupProvider.cs  [NEW]                      │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │ Configuration/                                           │    │
    │  │ ├── monster-groups.json  [NEW]                          │    │
    │  │ └── schemas/monster-groups.schema.json  [NEW]           │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
```

### 3.6 Focus Fire Target Selection Decision Tree

```
    FOCUS FIRE TARGET SELECTION
    ═══════════════════════════════════════════════════════════════════

    DetermineTarget(monster, possibleTargets) called
            │
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 1. GET GROUP FOR MONSTER                                         │
    │    → GetGroupForMonster(monster)                                │
    │    → If no group: Return nearest target (default AI)            │
    └──────────────────────────────────────────────────────────────────┘
            │ Has group
            ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │ 2. CHECK FOR FOCUS FIRE TACTIC                                   │
    │    → groupDef.Tactics.Contains(GroupTactic.FocusFire)           │
    └──────────────────────────────────────────────────────────────────┘
            │
            ├─── Has FocusFire ─────────────────────────────────────────┐
            │                                                           │
            ▼                                                           │
    ┌───────────────────────────────────────┐                          │
    │ 3a. CHECK EXISTING GROUP TARGET       │                          │
    │     → groupInstance.CurrentTarget     │                          │
    │     → If target alive: Return target  │                          │
    └───────────────────────────────────────┘                          │
            │ No/dead target                                           │
            ▼                                                           │
    ┌───────────────────────────────────────┐                          │
    │ 3b. SELECT NEW TARGET (LOWEST HP)     │                          │
    │     → targets.OrderBy(t => t.Health)  │                          │
    │     → FirstOrDefault()                │                          │
    │     → Set as groupInstance.Target     │                          │
    │     → Return selected target          │                          │
    └───────────────────────────────────────┘                          │
            │                                                           │
            └───────────────────────────────────────────────────────────┤
                                                                        │
            ├─── No FocusFire ──────────────────────────────────────────┘
            │
            ▼
    ┌───────────────────────────────────────┐
    │ 4. DEFAULT: NEAREST TARGET            │
    │    → targets.OrderBy(distance)        │
    │    → Return nearest                   │
    └───────────────────────────────────────┘


    FOCUS FIRE EXAMPLE
    ──────────────────

    Skeleton Patrol targeting decision:

    Possible targets:            Group decision:
    ┌────────────────────┐       ┌────────────────────┐
    │ Player A: 80/100 HP│       │ All 4 skeletons    │
    │ Player B: 25/100 HP│ ────▶ │ target Player B    │
    │ Player C: 60/100 HP│       │ (lowest HP = 25)   │
    └────────────────────┘       └────────────────────┘

    Result: Coordinated attack on weakest target
```

---

## 4. GroupTactic Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/GroupTactic.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Tactical behaviors for coordinated monster groups.
/// </summary>
/// <remarks>
/// Tactics are evaluated in priority order. The first tactic that
/// produces a valid action is used. Groups can have multiple tactics
/// to fall back on if preferred tactics are not possible.
/// </remarks>
public enum GroupTactic
{
    /// <summary>
    /// Attempt to surround the target for flanking bonuses.
    /// </summary>
    /// <remarks>
    /// Group members move to cardinal positions around the target.
    /// Provides flanking attack bonuses when multiple members adjacent.
    /// Best used by melee-focused groups.
    /// </remarks>
    Flank,

    /// <summary>
    /// All group members attack the same target.
    /// </summary>
    /// <remarks>
    /// Target is typically the lowest HP enemy.
    /// Shared target tracking ensures coordination.
    /// Effective for quickly eliminating threats.
    /// </remarks>
    FocusFire,

    /// <summary>
    /// Non-leader members protect the group leader.
    /// </summary>
    /// <remarks>
    /// Members position between leader and nearest threat.
    /// Leader typically provides buffs or ranged support.
    /// Used by groups with designated leader roles.
    /// </remarks>
    ProtectLeader,

    /// <summary>
    /// Melee members protect spellcasters/ranged units.
    /// </summary>
    /// <remarks>
    /// Similar to ProtectLeader but for any caster role.
    /// Allows casters to maintain distance for ranged attacks.
    /// </remarks>
    ProtectCaster,

    /// <summary>
    /// Close in on targets from all available directions.
    /// </summary>
    /// <remarks>
    /// Less coordinated than Flank - all members move toward target.
    /// Simple but effective for overwhelming single targets.
    /// Good fallback when flanking positions unavailable.
    /// </remarks>
    Swarm,

    /// <summary>
    /// Fall back when group is damaged.
    /// </summary>
    /// <remarks>
    /// Triggered when group health drops below threshold.
    /// Members move away from enemies to regroup.
    /// Can transition to other tactics after repositioning.
    /// </remarks>
    Retreat,

    /// <summary>
    /// Wait in ambush for targets to come into range.
    /// </summary>
    /// <remarks>
    /// Members hold position until enemy enters range.
    /// Often combined with surprise attack bonuses.
    /// Requires terrain or initial positioning setup.
    /// </remarks>
    Ambush,

    /// <summary>
    /// Attack and immediately disengage.
    /// </summary>
    /// <remarks>
    /// Members attack then move away from target.
    /// Prevents counterattacks and maintains distance.
    /// Effective for ranged or highly mobile groups.
    /// </remarks>
    HitAndRun
}
```

---

## 5. SynergyTrigger Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/SynergyTrigger.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines when a group synergy effect is triggered.
/// </summary>
/// <remarks>
/// Synergy triggers determine the timing and conditions for
/// applying bonus effects to group members during combat.
/// </remarks>
public enum SynergyTrigger
{
    /// <summary>
    /// Synergy is always active while conditions are met.
    /// </summary>
    /// <remarks>
    /// Applied on group spawn and maintained while source is alive.
    /// Example: Leader provides passive buff to all members.
    /// </remarks>
    Always,

    /// <summary>
    /// Triggered when any group member lands a hit on an enemy.
    /// </summary>
    /// <remarks>
    /// Provides temporary bonus to other group members.
    /// Encourages coordinated attacks.
    /// Duration: Typically 1 turn.
    /// </remarks>
    OnAllyHit,

    /// <summary>
    /// Triggered when any group member takes damage.
    /// </summary>
    /// <remarks>
    /// Can provide defensive buffs or offensive "rage" bonuses.
    /// Rewards groups for staying engaged in combat.
    /// </remarks>
    OnAllyDamaged,

    /// <summary>
    /// Triggered when the leader uses a command ability.
    /// </summary>
    /// <remarks>
    /// Requires leader to have command-type abilities.
    /// Provides coordinated burst effects.
    /// Future: Integrate with ability system.
    /// </remarks>
    OnLeaderCommand,

    /// <summary>
    /// Bonus scales with the number of adjacent allies.
    /// </summary>
    /// <remarks>
    /// Calculated per-attack based on current positions.
    /// Rewards tight formations and flanking setups.
    /// Example: +1 damage per adjacent group member.
    /// </remarks>
    PerAdjacentAlly
}
```

---

## 6. GroupMember Class

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/GroupMember.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a member slot within a monster group.
/// </summary>
/// <remarks>
/// Specifies which monster type fills this slot, how many
/// spawn, and the role they play in the group's tactics.
/// </remarks>
public class GroupMember
{
    /// <summary>
    /// The monster definition ID for this member type.
    /// </summary>
    /// <remarks>
    /// References an existing monster in monsters.json.
    /// </remarks>
    public string MonsterDefinitionId { get; set; } = null!;

    /// <summary>
    /// Number of this monster type in the group.
    /// </summary>
    /// <remarks>
    /// Typically 1-4. Total group size is sum of all member counts.
    /// </remarks>
    public int Count { get; set; } = 1;

    /// <summary>
    /// The tactical role of this member in the group.
    /// </summary>
    /// <remarks>
    /// Used by tactics like ProtectLeader to identify targets.
    /// Common roles: "melee", "ranged", "leader", "striker", "caster".
    /// </remarks>
    public string? Role { get; set; }

    /// <summary>
    /// Preferred spawn position offset from group center.
    /// </summary>
    /// <remarks>
    /// Optional. If specified, member spawns at center + offset.
    /// Useful for pre-positioning leaders behind melee.
    /// </remarks>
    public GridOffset? PreferredPosition { get; set; }

    /// <summary>
    /// Gets whether this member has a defined role.
    /// </summary>
    public bool HasRole => !string.IsNullOrEmpty(Role);

    /// <summary>
    /// Checks if this member matches a specific role.
    /// </summary>
    /// <param name="role">The role to check.</param>
    /// <returns>True if roles match (case-insensitive).</returns>
    public bool IsRole(string role)
    {
        return string.Equals(Role, role, StringComparison.OrdinalIgnoreCase);
    }
}
```

---

## 7. GroupSynergy Class

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/GroupSynergy.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines a synergy effect that applies to monster group members.
/// </summary>
/// <remarks>
/// Synergies provide combat bonuses based on group composition
/// and combat events. They encourage coordinated group tactics.
/// </remarks>
public class GroupSynergy
{
    /// <summary>
    /// Unique identifier for this synergy.
    /// </summary>
    public string SynergyId { get; set; } = null!;

    /// <summary>
    /// Display name for the synergy.
    /// </summary>
    public string Name { get; set; } = null!;

    /// <summary>
    /// Description of what the synergy does.
    /// </summary>
    public string Description { get; set; } = null!;

    /// <summary>
    /// When this synergy effect triggers.
    /// </summary>
    public SynergyTrigger Trigger { get; set; }

    /// <summary>
    /// Optional role requirement for the synergy source.
    /// </summary>
    /// <remarks>
    /// If specified, only members with this role can provide the synergy.
    /// Example: "leader" for Shaman's Blessing.
    /// </remarks>
    public string? SourceRole { get; set; }

    /// <summary>
    /// Optional status effect to apply when synergy triggers.
    /// </summary>
    /// <remarks>
    /// References status effect definitions from the buff/debuff system.
    /// </remarks>
    public string? StatusEffectId { get; set; }

    /// <summary>
    /// Bonus to attack rolls provided by this synergy.
    /// </summary>
    public int? AttackBonus { get; set; }

    /// <summary>
    /// Bonus to damage rolls provided by this synergy.
    /// </summary>
    public int? DamageBonus { get; set; }

    /// <summary>
    /// Whether the synergy applies to all group members.
    /// </summary>
    /// <remarks>
    /// If false, only applies to members other than the source.
    /// </remarks>
    public bool AppliesToAllMembers { get; set; }

    /// <summary>
    /// Gets whether this synergy has any combat bonuses.
    /// </summary>
    public bool HasBonuses => AttackBonus.HasValue || DamageBonus.HasValue || !string.IsNullOrEmpty(StatusEffectId);

    /// <summary>
    /// Gets whether this synergy requires a specific source role.
    /// </summary>
    public bool RequiresSourceRole => !string.IsNullOrEmpty(SourceRole);
}
```

---

## 8. MonsterGroupDefinition Entity

**File:** `src/Core/RuneAndRust.Domain/Definitions/MonsterGroupDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a coordinated group of monsters with shared tactics and synergies.
/// </summary>
/// <remarks>
/// Groups spawn together and coordinate their combat behavior.
/// Tactics determine movement and targeting priorities.
/// Synergies provide bonuses based on group composition and events.
/// </remarks>
public class MonsterGroupDefinition : IEntity
{
    /// <summary>
    /// Unique entity identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Unique string identifier for this group definition.
    /// </summary>
    public string GroupId { get; private set; } = null!;

    /// <summary>
    /// Display name for the group.
    /// </summary>
    public string Name { get; private set; } = null!;

    /// <summary>
    /// Description of the group's composition and behavior.
    /// </summary>
    public string Description { get; private set; } = null!;

    /// <summary>
    /// The members that make up this group.
    /// </summary>
    public IReadOnlyList<GroupMember> Members { get; private set; } = [];

    /// <summary>
    /// Tactical behaviors in priority order.
    /// </summary>
    /// <remarks>
    /// First tactic that produces valid action is used.
    /// </remarks>
    public IReadOnlyList<GroupTactic> Tactics { get; private set; } = [];

    /// <summary>
    /// Synergy effects for group coordination.
    /// </summary>
    public IReadOnlyList<GroupSynergy> Synergies { get; private set; } = [];

    /// <summary>
    /// The role designated as group leader.
    /// </summary>
    /// <remarks>
    /// Used by ProtectLeader tactic and leader-based synergies.
    /// </remarks>
    public string? LeaderRole { get; private set; }

    /// <summary>
    /// Minimum number of members for a valid group spawn.
    /// </summary>
    public int MinSize { get; private set; }

    /// <summary>
    /// Maximum number of members the group can have.
    /// </summary>
    public int MaxSize { get; private set; }

    /// <summary>
    /// Optional tags for categorizing groups.
    /// </summary>
    public IReadOnlyList<string> Tags { get; private set; } = [];

    private MonsterGroupDefinition() { }

    /// <summary>
    /// Creates a new monster group definition.
    /// </summary>
    /// <param name="groupId">Unique identifier.</param>
    /// <param name="name">Display name.</param>
    /// <param name="description">Group description.</param>
    /// <param name="members">Member definitions.</param>
    /// <returns>A new MonsterGroupDefinition instance.</returns>
    /// <exception cref="ArgumentException">If groupId is null/empty or no members provided.</exception>
    public static MonsterGroupDefinition Create(
        string groupId,
        string name,
        string description,
        IEnumerable<GroupMember> members)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(groupId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        var memberList = members.ToList();
        if (memberList.Count == 0)
        {
            throw new ArgumentException("Group must have at least one member", nameof(members));
        }

        var totalCount = memberList.Sum(m => m.Count);

        return new MonsterGroupDefinition
        {
            Id = Guid.NewGuid(),
            GroupId = groupId.ToLowerInvariant(),
            Name = name,
            Description = description ?? string.Empty,
            Members = memberList,
            MinSize = totalCount,
            MaxSize = totalCount
        };
    }

    /// <summary>
    /// Sets the tactics for this group.
    /// </summary>
    /// <param name="tactics">Tactics in priority order.</param>
    /// <returns>This instance for fluent configuration.</returns>
    public MonsterGroupDefinition WithTactics(IEnumerable<GroupTactic> tactics)
    {
        Tactics = tactics.ToList();
        return this;
    }

    /// <summary>
    /// Sets the synergies for this group.
    /// </summary>
    /// <param name="synergies">Synergy definitions.</param>
    /// <returns>This instance for fluent configuration.</returns>
    public MonsterGroupDefinition WithSynergies(IEnumerable<GroupSynergy> synergies)
    {
        Synergies = synergies.ToList();
        return this;
    }

    /// <summary>
    /// Sets the leader role for this group.
    /// </summary>
    /// <param name="leaderRole">The role that acts as leader.</param>
    /// <returns>This instance for fluent configuration.</returns>
    public MonsterGroupDefinition WithLeader(string leaderRole)
    {
        LeaderRole = leaderRole;
        return this;
    }

    /// <summary>
    /// Gets the total number of monsters in a full group.
    /// </summary>
    public int TotalMemberCount => Members.Sum(m => m.Count);

    /// <summary>
    /// Gets the leader member definition if one exists.
    /// </summary>
    /// <returns>The member with the leader role, or null.</returns>
    public GroupMember? GetLeaderMember()
    {
        if (string.IsNullOrEmpty(LeaderRole))
        {
            return null;
        }
        return Members.FirstOrDefault(m => m.IsRole(LeaderRole));
    }

    /// <summary>
    /// Gets members with a specific role.
    /// </summary>
    /// <param name="role">The role to filter by.</param>
    /// <returns>Members matching the role.</returns>
    public IEnumerable<GroupMember> GetMembersByRole(string role)
    {
        return Members.Where(m => m.IsRole(role));
    }

    /// <summary>
    /// Checks if the group has a specific tactic.
    /// </summary>
    /// <param name="tactic">The tactic to check.</param>
    /// <returns>True if the tactic is in the group's tactics list.</returns>
    public bool HasTactic(GroupTactic tactic)
    {
        return Tactics.Contains(tactic);
    }

    /// <summary>
    /// Gets synergies with a specific trigger type.
    /// </summary>
    /// <param name="trigger">The trigger to filter by.</param>
    /// <returns>Synergies matching the trigger.</returns>
    public IEnumerable<GroupSynergy> GetSynergiesByTrigger(SynergyTrigger trigger)
    {
        return Synergies.Where(s => s.Trigger == trigger);
    }
}
```

---

## 9. MonsterGroupInstance Class

**File:** `src/Core/RuneAndRust.Application/Tracking/MonsterGroupInstance.cs`

```csharp
namespace RuneAndRust.Application.Tracking;

using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;

/// <summary>
/// Tracks the runtime state of an active monster group in combat.
/// </summary>
/// <remarks>
/// Maintains:
/// - List of alive group members
/// - Shared target for focus fire
/// - Leader reference
/// - Group definition reference
/// </remarks>
public class MonsterGroupInstance
{
    /// <summary>
    /// Unique identifier for this group instance.
    /// </summary>
    public Guid Id { get; }

    /// <summary>
    /// The group definition ID this instance is based on.
    /// </summary>
    public string GroupId { get; }

    /// <summary>
    /// Reference to the group definition.
    /// </summary>
    public MonsterGroupDefinition Definition { get; }

    /// <summary>
    /// All monsters that were spawned as part of this group.
    /// </summary>
    private readonly List<Monster> _members;

    /// <summary>
    /// The current shared target for focus fire tactics.
    /// </summary>
    public ICombatant? CurrentTarget { get; set; }

    /// <summary>
    /// Gets all alive members of the group.
    /// </summary>
    public IReadOnlyList<Monster> AliveMembers => _members.Where(m => m.IsAlive).ToList();

    /// <summary>
    /// Gets all members (alive and dead) of the group.
    /// </summary>
    public IReadOnlyList<Monster> AllMembers => _members.AsReadOnly();

    /// <summary>
    /// Creates a new monster group instance.
    /// </summary>
    /// <param name="groupId">The definition group ID.</param>
    /// <param name="definition">The group definition.</param>
    /// <param name="members">The spawned monster members.</param>
    public MonsterGroupInstance(
        string groupId,
        MonsterGroupDefinition definition,
        IEnumerable<Monster> members)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(groupId);
        ArgumentNullException.ThrowIfNull(definition);

        Id = Guid.NewGuid();
        GroupId = groupId;
        Definition = definition;
        _members = members.ToList();
    }

    /// <summary>
    /// Gets the group leader monster if one exists.
    /// </summary>
    /// <returns>The leader monster, or null if no leader role defined or leader is dead.</returns>
    public Monster? GetLeader()
    {
        if (string.IsNullOrEmpty(Definition.LeaderRole))
        {
            return null;
        }

        return AliveMembers.FirstOrDefault(m =>
            string.Equals(m.GroupRole, Definition.LeaderRole, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Gets members with a specific role that are alive.
    /// </summary>
    /// <param name="role">The role to filter by.</param>
    /// <returns>Alive members matching the role.</returns>
    public IEnumerable<Monster> GetMembersByRole(string role)
    {
        return AliveMembers.Where(m =>
            string.Equals(m.GroupRole, role, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Checks if this group has any alive members.
    /// </summary>
    public bool HasAliveMembers => _members.Any(m => m.IsAlive);

    /// <summary>
    /// Gets the count of alive members.
    /// </summary>
    public int AliveCount => _members.Count(m => m.IsAlive);

    /// <summary>
    /// Checks if the group's leader is still alive.
    /// </summary>
    public bool HasAliveLeader => GetLeader() is not null;

    /// <summary>
    /// Checks if the current target is still valid (alive).
    /// </summary>
    public bool HasValidTarget => CurrentTarget is not null && CurrentTarget.IsAlive;

    /// <summary>
    /// Clears the current target, forcing re-selection.
    /// </summary>
    public void ClearTarget()
    {
        CurrentTarget = null;
    }

    /// <summary>
    /// Removes a member from tracking (on death).
    /// </summary>
    /// <param name="monster">The monster to remove.</param>
    /// <remarks>
    /// Does not actually remove from list, just marks for filtering.
    /// Monster.IsAlive will be false.
    /// </remarks>
    public void OnMemberDeath(Monster monster)
    {
        // Clear target if it was the current target (shouldn't happen for group members)
        if (CurrentTarget == monster)
        {
            ClearTarget();
        }
    }
}
```

---

## 10. GroupMoveDecision Value Object

**File:** `src/Core/RuneAndRust.Application/Tracking/GroupMoveDecision.cs`

```csharp
namespace RuneAndRust.Application.Tracking;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a movement decision made by the group service.
/// </summary>
/// <remarks>
/// Returned by DetermineMove to indicate what action the monster
/// should take based on group tactics.
/// </remarks>
public readonly record struct GroupMoveDecision
{
    /// <summary>
    /// The type of decision.
    /// </summary>
    public GroupMoveDecisionType Type { get; init; }

    /// <summary>
    /// Target position to move to (if Type is MoveTo).
    /// </summary>
    public GridPosition? TargetPosition { get; init; }

    /// <summary>
    /// The tactic that produced this decision.
    /// </summary>
    public GroupTactic? Tactic { get; init; }

    /// <summary>
    /// Creates a decision to move to a specific position.
    /// </summary>
    /// <param name="position">The target position.</param>
    /// <param name="tactic">The tactic that determined this move.</param>
    /// <returns>A MoveTo decision.</returns>
    public static GroupMoveDecision MoveTo(GridPosition position, GroupTactic tactic)
    {
        return new GroupMoveDecision
        {
            Type = GroupMoveDecisionType.MoveTo,
            TargetPosition = position,
            Tactic = tactic
        };
    }

    /// <summary>
    /// Creates a decision indicating no group membership.
    /// </summary>
    /// <returns>A NoGroup decision.</returns>
    public static GroupMoveDecision NoGroup()
    {
        return new GroupMoveDecision { Type = GroupMoveDecisionType.NoGroup };
    }

    /// <summary>
    /// Creates a decision indicating no valid target.
    /// </summary>
    /// <returns>A NoTarget decision.</returns>
    public static GroupMoveDecision NoTarget()
    {
        return new GroupMoveDecision { Type = GroupMoveDecisionType.NoTarget };
    }

    /// <summary>
    /// Creates a decision indicating no tactical action needed.
    /// </summary>
    /// <returns>A NoAction decision.</returns>
    public static GroupMoveDecision NoAction()
    {
        return new GroupMoveDecision { Type = GroupMoveDecisionType.NoAction };
    }

    /// <summary>
    /// Creates a decision to hold position (for Ambush tactic).
    /// </summary>
    /// <returns>A HoldPosition decision.</returns>
    public static GroupMoveDecision HoldPosition(GroupTactic tactic)
    {
        return new GroupMoveDecision
        {
            Type = GroupMoveDecisionType.HoldPosition,
            Tactic = tactic
        };
    }

    /// <summary>
    /// Gets whether this decision indicates a position to move to.
    /// </summary>
    public bool HasMoveTarget => Type == GroupMoveDecisionType.MoveTo && TargetPosition.HasValue;
}

/// <summary>
/// Types of movement decisions from group tactics.
/// </summary>
public enum GroupMoveDecisionType
{
    /// <summary>Monster is not in a group.</summary>
    NoGroup,

    /// <summary>Group has no valid target.</summary>
    NoTarget,

    /// <summary>No tactical action needed.</summary>
    NoAction,

    /// <summary>Move to specific position.</summary>
    MoveTo,

    /// <summary>Hold current position (ambush).</summary>
    HoldPosition
}
```

---

## 11. IMonsterGroupProvider Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IMonsterGroupProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Definitions;

/// <summary>
/// Provider for loading monster group definitions from configuration.
/// </summary>
public interface IMonsterGroupProvider
{
    /// <summary>
    /// Gets a monster group definition by ID.
    /// </summary>
    /// <param name="groupId">The group definition ID.</param>
    /// <returns>The group definition, or null if not found.</returns>
    MonsterGroupDefinition? GetGroup(string groupId);

    /// <summary>
    /// Gets all available monster group definitions.
    /// </summary>
    /// <returns>All loaded group definitions.</returns>
    IReadOnlyList<MonsterGroupDefinition> GetAllGroups();

    /// <summary>
    /// Checks if a group definition exists.
    /// </summary>
    /// <param name="groupId">The group definition ID.</param>
    /// <returns>True if the group exists.</returns>
    bool GroupExists(string groupId);

    /// <summary>
    /// Gets groups that have a specific tag.
    /// </summary>
    /// <param name="tag">The tag to filter by.</param>
    /// <returns>Groups with the specified tag.</returns>
    IReadOnlyList<MonsterGroupDefinition> GetGroupsByTag(string tag);

    /// <summary>
    /// Reloads group definitions from configuration.
    /// </summary>
    void Reload();
}
```

---

## 12. MonsterGroupProvider Implementation

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Providers/MonsterGroupProvider.cs`

```csharp
namespace RuneAndRust.Infrastructure.Providers;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Loads and caches monster group definitions from JSON configuration.
/// </summary>
public class MonsterGroupProvider : IMonsterGroupProvider
{
    private readonly string _configPath;
    private readonly ILogger<MonsterGroupProvider> _logger;
    private Dictionary<string, MonsterGroupDefinition> _groups = new();
    private bool _loaded;

    /// <summary>
    /// Creates a new MonsterGroupProvider.
    /// </summary>
    /// <param name="configPath">Path to monster-groups.json file.</param>
    /// <param name="logger">Logger instance.</param>
    public MonsterGroupProvider(string configPath, ILogger<MonsterGroupProvider> logger)
    {
        _configPath = configPath;
        _logger = logger;
    }

    /// <inheritdoc />
    public MonsterGroupDefinition? GetGroup(string groupId)
    {
        EnsureLoaded();
        return _groups.GetValueOrDefault(groupId.ToLowerInvariant());
    }

    /// <inheritdoc />
    public IReadOnlyList<MonsterGroupDefinition> GetAllGroups()
    {
        EnsureLoaded();
        return _groups.Values.ToList();
    }

    /// <inheritdoc />
    public bool GroupExists(string groupId)
    {
        EnsureLoaded();
        return _groups.ContainsKey(groupId.ToLowerInvariant());
    }

    /// <inheritdoc />
    public IReadOnlyList<MonsterGroupDefinition> GetGroupsByTag(string tag)
    {
        EnsureLoaded();
        return _groups.Values
            .Where(g => g.Tags.Contains(tag, StringComparer.OrdinalIgnoreCase))
            .ToList();
    }

    /// <inheritdoc />
    public void Reload()
    {
        _loaded = false;
        _groups.Clear();
        EnsureLoaded();
    }

    /// <summary>
    /// Ensures group definitions are loaded from configuration.
    /// </summary>
    private void EnsureLoaded()
    {
        if (_loaded)
        {
            return;
        }

        try
        {
            var json = File.ReadAllText(_configPath);
            var config = JsonSerializer.Deserialize<MonsterGroupConfig>(json, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });

            if (config?.MonsterGroups is null)
            {
                _logger.LogWarning("No monster groups found in configuration: {Path}", _configPath);
                _loaded = true;
                return;
            }

            foreach (var groupData in config.MonsterGroups)
            {
                var group = CreateGroupFromConfig(groupData);
                if (group is not null)
                {
                    _groups[group.GroupId] = group;
                }
            }

            _logger.LogInformation("Loaded {Count} monster group definitions", _groups.Count);
            _loaded = true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load monster groups from {Path}", _configPath);
            throw;
        }
    }

    /// <summary>
    /// Creates a MonsterGroupDefinition from JSON configuration data.
    /// </summary>
    private MonsterGroupDefinition? CreateGroupFromConfig(MonsterGroupData data)
    {
        try
        {
            var members = data.Members.Select(m => new GroupMember
            {
                MonsterDefinitionId = m.MonsterDefinitionId,
                Count = m.Count,
                Role = m.Role,
                PreferredPosition = m.PreferredPosition is not null
                    ? new GridOffset(m.PreferredPosition.DeltaX, m.PreferredPosition.DeltaY)
                    : null
            }).ToList();

            var tactics = data.Tactics?
                .Select(t => Enum.Parse<GroupTactic>(t, ignoreCase: true))
                .ToList() ?? [];

            var synergies = data.Synergies?.Select(s => new GroupSynergy
            {
                SynergyId = s.SynergyId,
                Name = s.Name,
                Description = s.Description ?? string.Empty,
                Trigger = Enum.Parse<SynergyTrigger>(s.Trigger, ignoreCase: true),
                SourceRole = s.SourceRole,
                StatusEffectId = s.StatusEffectId,
                AttackBonus = s.AttackBonus,
                DamageBonus = s.DamageBonus,
                AppliesToAllMembers = s.AppliesToAllMembers
            }).ToList() ?? [];

            var group = MonsterGroupDefinition.Create(
                data.GroupId,
                data.Name,
                data.Description ?? string.Empty,
                members);

            group.WithTactics(tactics)
                 .WithSynergies(synergies);

            if (!string.IsNullOrEmpty(data.LeaderRole))
            {
                group.WithLeader(data.LeaderRole);
            }

            return group;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to parse monster group: {GroupId}", data.GroupId);
            return null;
        }
    }

    // Configuration data classes for JSON deserialization
    private class MonsterGroupConfig
    {
        public List<MonsterGroupData> MonsterGroups { get; set; } = [];
    }

    private class MonsterGroupData
    {
        public string GroupId { get; set; } = null!;
        public string Name { get; set; } = null!;
        public string? Description { get; set; }
        public List<MemberData> Members { get; set; } = [];
        public List<string>? Tactics { get; set; }
        public List<SynergyData>? Synergies { get; set; }
        public string? LeaderRole { get; set; }
    }

    private class MemberData
    {
        public string MonsterDefinitionId { get; set; } = null!;
        public int Count { get; set; } = 1;
        public string? Role { get; set; }
        public GridOffsetData? PreferredPosition { get; set; }
    }

    private class GridOffsetData
    {
        public int DeltaX { get; set; }
        public int DeltaY { get; set; }
    }

    private class SynergyData
    {
        public string SynergyId { get; set; } = null!;
        public string Name { get; set; } = null!;
        public string? Description { get; set; }
        public string Trigger { get; set; } = "Always";
        public string? SourceRole { get; set; }
        public string? StatusEffectId { get; set; }
        public int? AttackBonus { get; set; }
        public int? DamageBonus { get; set; }
        public bool AppliesToAllMembers { get; set; }
    }
}
```

---

## 13. IMonsterGroupService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IMonsterGroupService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Application.Tracking;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for coordinating monster group behaviors during combat.
/// </summary>
/// <remarks>
/// Handles:
/// - Group spawning with position distribution
/// - Tactical movement decisions
/// - Target selection coordination
/// - Synergy effect application
/// - Group state tracking
/// </remarks>
public interface IMonsterGroupService
{
    /// <summary>
    /// Spawns a monster group at a center position.
    /// </summary>
    /// <param name="groupId">The group definition ID.</param>
    /// <param name="centerPosition">Center position for spawn distribution.</param>
    /// <returns>List of spawned monster instances.</returns>
    /// <exception cref="ArgumentException">If group definition not found.</exception>
    IReadOnlyList<Monster> SpawnGroup(string groupId, GridPosition centerPosition);

    /// <summary>
    /// Gets the group instance a monster belongs to.
    /// </summary>
    /// <param name="monster">The monster to look up.</param>
    /// <returns>The group instance, or null if monster is not in a group.</returns>
    MonsterGroupInstance? GetGroupForMonster(Monster monster);

    /// <summary>
    /// Determines the best move for a group member based on tactics.
    /// </summary>
    /// <param name="monster">The monster requesting a move decision.</param>
    /// <returns>A GroupMoveDecision indicating what action to take.</returns>
    GroupMoveDecision DetermineMove(Monster monster);

    /// <summary>
    /// Determines the target for a group member based on tactics.
    /// </summary>
    /// <param name="monster">The monster selecting a target.</param>
    /// <param name="possibleTargets">Available targets to choose from.</param>
    /// <returns>The selected target, or null if no valid target.</returns>
    ICombatant? DetermineTarget(Monster monster, IEnumerable<ICombatant> possibleTargets);

    /// <summary>
    /// Applies synergy effects to group members.
    /// </summary>
    /// <param name="group">The group to apply synergies for.</param>
    /// <remarks>
    /// Called on group spawn for Always synergies.
    /// </remarks>
    void ApplySynergies(MonsterGroupInstance group);

    /// <summary>
    /// Called when a group member successfully hits a target.
    /// </summary>
    /// <param name="attacker">The monster that hit.</param>
    /// <param name="target">The target that was hit.</param>
    /// <remarks>
    /// Triggers OnAllyHit synergies for other group members.
    /// </remarks>
    void OnGroupMemberHit(Monster attacker, ICombatant target);

    /// <summary>
    /// Called when a group member takes damage.
    /// </summary>
    /// <param name="target">The monster that took damage.</param>
    /// <param name="damage">Amount of damage taken.</param>
    /// <remarks>
    /// Triggers OnAllyDamaged synergies for other group members.
    /// </remarks>
    void OnGroupMemberDamaged(Monster target, int damage);

    /// <summary>
    /// Called when a group member dies.
    /// </summary>
    /// <param name="monster">The monster that died.</param>
    /// <remarks>
    /// Updates group state and may trigger retreat tactics.
    /// </remarks>
    void OnGroupMemberDeath(Monster monster);

    /// <summary>
    /// Gets optimal flanking positions around a target.
    /// </summary>
    /// <param name="target">The target to flank.</param>
    /// <param name="groupSize">Number of positions needed.</param>
    /// <returns>List of flanking positions.</returns>
    IReadOnlyList<GridPosition> GetFlankingPositions(ICombatant target, int groupSize);

    /// <summary>
    /// Gets the damage bonus from PerAdjacentAlly synergies.
    /// </summary>
    /// <param name="monster">The attacking monster.</param>
    /// <returns>Total damage bonus from adjacency.</returns>
    int GetAdjacentAllyDamageBonus(Monster monster);

    /// <summary>
    /// Gets the attack bonus from PerAdjacentAlly synergies.
    /// </summary>
    /// <param name="monster">The attacking monster.</param>
    /// <returns>Total attack bonus from adjacency.</returns>
    int GetAdjacentAllyAttackBonus(Monster monster);

    /// <summary>
    /// Checks if a monster is part of any group.
    /// </summary>
    /// <param name="monster">The monster to check.</param>
    /// <returns>True if the monster is in a group.</returns>
    bool IsInGroup(Monster monster);

    /// <summary>
    /// Gets all active group instances.
    /// </summary>
    /// <returns>All active monster group instances.</returns>
    IReadOnlyList<MonsterGroupInstance> GetActiveGroups();
}
```

---

## 14. MonsterGroupService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/MonsterGroupService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Tracking;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Coordinates monster group behaviors during combat.
/// </summary>
public class MonsterGroupService : IMonsterGroupService
{
    private readonly IMonsterGroupProvider _groupProvider;
    private readonly IMonsterSpawnService _spawnService;
    private readonly ICombatGrid _grid;
    private readonly IFlankingService _flankingService;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<MonsterGroupService> _logger;

    /// <summary>
    /// Active group instances keyed by instance ID.
    /// </summary>
    private readonly Dictionary<Guid, MonsterGroupInstance> _activeGroups = new();

    /// <summary>
    /// Mapping from monster ID to group instance ID.
    /// </summary>
    private readonly Dictionary<Guid, Guid> _monsterToGroup = new();

    /// <summary>
    /// Creates a new MonsterGroupService.
    /// </summary>
    public MonsterGroupService(
        IMonsterGroupProvider groupProvider,
        IMonsterSpawnService spawnService,
        ICombatGrid grid,
        IFlankingService flankingService,
        IBuffDebuffService buffDebuffService,
        IEventBus eventBus,
        ILogger<MonsterGroupService> logger)
    {
        _groupProvider = groupProvider;
        _spawnService = spawnService;
        _grid = grid;
        _flankingService = flankingService;
        _buffDebuffService = buffDebuffService;
        _eventBus = eventBus;
        _logger = logger;
    }

    /// <inheritdoc />
    public IReadOnlyList<Monster> SpawnGroup(string groupId, GridPosition centerPosition)
    {
        var groupDef = _groupProvider.GetGroup(groupId);
        if (groupDef is null)
        {
            throw new ArgumentException($"Monster group not found: {groupId}", nameof(groupId));
        }

        var spawnedMonsters = new List<Monster>();
        var totalCount = groupDef.TotalMemberCount;
        var positions = GetSpawnPositions(centerPosition, totalCount);
        var posIndex = 0;

        foreach (var member in groupDef.Members)
        {
            for (int i = 0; i < member.Count; i++)
            {
                if (posIndex >= positions.Count)
                {
                    _logger.LogWarning(
                        "Not enough spawn positions for group {GroupId}, spawned {Count}/{Total}",
                        groupId, posIndex, totalCount);
                    break;
                }

                var monster = _spawnService.SpawnByDefinitionId(
                    member.MonsterDefinitionId,
                    positions[posIndex++]);

                if (monster is not null)
                {
                    monster.SetGroupRole(member.Role);
                    spawnedMonsters.Add(monster);
                }
            }
        }

        // Create group instance
        var groupInstance = new MonsterGroupInstance(groupId, groupDef, spawnedMonsters);
        _activeGroups[groupInstance.Id] = groupInstance;

        // Map monsters to group
        foreach (var monster in spawnedMonsters)
        {
            _monsterToGroup[monster.Id] = groupInstance.Id;
        }

        // Apply initial synergies
        ApplySynergies(groupInstance);

        _logger.LogInformation(
            "Spawned group {GroupName} ({GroupId}) with {Count} members at {Position}",
            groupDef.Name, groupId, spawnedMonsters.Count, centerPosition);

        _eventBus.Publish(new MonsterGroupSpawnedEvent(groupInstance.Id, groupId, spawnedMonsters.Count));

        return spawnedMonsters;
    }

    /// <inheritdoc />
    public MonsterGroupInstance? GetGroupForMonster(Monster monster)
    {
        if (_monsterToGroup.TryGetValue(monster.Id, out var groupId))
        {
            return _activeGroups.GetValueOrDefault(groupId);
        }
        return null;
    }

    /// <inheritdoc />
    public GroupMoveDecision DetermineMove(Monster monster)
    {
        var groupInstance = GetGroupForMonster(monster);
        if (groupInstance is null)
        {
            return GroupMoveDecision.NoGroup();
        }

        var groupDef = groupInstance.Definition;
        var target = groupInstance.CurrentTarget;

        if (target is null || !target.IsAlive)
        {
            return GroupMoveDecision.NoTarget();
        }

        // Evaluate tactics in priority order
        foreach (var tactic in groupDef.Tactics)
        {
            var decision = EvaluateTactic(monster, groupInstance, target, tactic);
            if (decision.HasMoveTarget || decision.Type == GroupMoveDecisionType.HoldPosition)
            {
                return decision;
            }
        }

        return GroupMoveDecision.NoAction();
    }

    /// <summary>
    /// Evaluates a single tactic for a monster.
    /// </summary>
    private GroupMoveDecision EvaluateTactic(
        Monster monster,
        MonsterGroupInstance group,
        ICombatant target,
        GroupTactic tactic)
    {
        switch (tactic)
        {
            case GroupTactic.Flank:
                var flankPos = GetBestFlankingPosition(monster, target, group);
                if (flankPos.HasValue)
                {
                    return GroupMoveDecision.MoveTo(flankPos.Value, tactic);
                }
                break;

            case GroupTactic.FocusFire:
                // FocusFire affects targeting, not movement
                // Continue to next tactic
                break;

            case GroupTactic.ProtectLeader:
                var leader = group.GetLeader();
                if (leader is not null && monster.Id != leader.Id)
                {
                    var protectPos = GetProtectionPosition(monster, leader, target);
                    if (protectPos.HasValue)
                    {
                        return GroupMoveDecision.MoveTo(protectPos.Value, tactic);
                    }
                }
                break;

            case GroupTactic.ProtectCaster:
                var casters = group.GetMembersByRole("caster").Where(c => c.Id != monster.Id);
                foreach (var caster in casters)
                {
                    var casterProtectPos = GetProtectionPosition(monster, caster, target);
                    if (casterProtectPos.HasValue)
                    {
                        return GroupMoveDecision.MoveTo(casterProtectPos.Value, tactic);
                    }
                }
                break;

            case GroupTactic.Swarm:
                var swarmPos = GetClosestPositionToTarget(monster, target);
                if (swarmPos.HasValue)
                {
                    return GroupMoveDecision.MoveTo(swarmPos.Value, tactic);
                }
                break;

            case GroupTactic.Retreat:
                // Check if group health is below retreat threshold
                var groupHealthPercent = CalculateGroupHealthPercent(group);
                if (groupHealthPercent < 30) // Retreat below 30% group health
                {
                    var retreatPos = GetRetreatPosition(monster, target);
                    if (retreatPos.HasValue)
                    {
                        return GroupMoveDecision.MoveTo(retreatPos.Value, tactic);
                    }
                }
                break;

            case GroupTactic.Ambush:
                // Hold position until target comes into range
                var distanceToTarget = GridPosition.Distance(monster.Position, target.Position);
                if (distanceToTarget > monster.AttackRange)
                {
                    return GroupMoveDecision.HoldPosition(tactic);
                }
                break;

            case GroupTactic.HitAndRun:
                // After attacking, disengage
                // This is handled in post-attack movement
                break;
        }

        return GroupMoveDecision.NoAction();
    }

    /// <inheritdoc />
    public ICombatant? DetermineTarget(Monster monster, IEnumerable<ICombatant> possibleTargets)
    {
        var groupInstance = GetGroupForMonster(monster);
        var targets = possibleTargets.Where(t => t.IsAlive).ToList();

        if (targets.Count == 0)
        {
            return null;
        }

        if (groupInstance is null)
        {
            // No group - use nearest target
            return targets
                .OrderBy(t => GridPosition.Distance(monster.Position, t.Position))
                .FirstOrDefault();
        }

        var groupDef = groupInstance.Definition;

        // Focus Fire: all attack same target (lowest HP)
        if (groupDef.HasTactic(GroupTactic.FocusFire))
        {
            // Use existing target if still valid
            if (groupInstance.HasValidTarget)
            {
                return groupInstance.CurrentTarget;
            }

            // Select new target (lowest HP)
            var newTarget = targets
                .OrderBy(t => t.Health)
                .FirstOrDefault();

            if (newTarget is not null)
            {
                groupInstance.CurrentTarget = newTarget;
                _logger.LogDebug(
                    "Group {GroupId} focused on new target: {Target} ({HP} HP)",
                    groupInstance.GroupId, newTarget.Name, newTarget.Health);
            }

            return newTarget;
        }

        // Default: nearest target
        return targets
            .OrderBy(t => GridPosition.Distance(monster.Position, t.Position))
            .FirstOrDefault();
    }

    /// <inheritdoc />
    public void ApplySynergies(MonsterGroupInstance group)
    {
        foreach (var synergy in group.Definition.GetSynergiesByTrigger(SynergyTrigger.Always))
        {
            ApplyAlwaysSynergy(group, synergy);
        }
    }

    /// <summary>
    /// Applies an Always-type synergy to group members.
    /// </summary>
    private void ApplyAlwaysSynergy(MonsterGroupInstance group, GroupSynergy synergy)
    {
        // Check if source role requirement is met
        if (synergy.RequiresSourceRole)
        {
            var sourceExists = group.GetMembersByRole(synergy.SourceRole!).Any();
            if (!sourceExists)
            {
                return;
            }
        }

        var targets = synergy.AppliesToAllMembers
            ? group.AliveMembers
            : group.AliveMembers.Where(m => !m.IsRole(synergy.SourceRole));

        foreach (var target in targets)
        {
            if (synergy.AttackBonus.HasValue)
            {
                _buffDebuffService.ApplyStatModifier(
                    target, "attack", synergy.AttackBonus.Value,
                    source: $"synergy:{synergy.SynergyId}");
            }

            if (synergy.DamageBonus.HasValue)
            {
                _buffDebuffService.ApplyStatModifier(
                    target, "damage", synergy.DamageBonus.Value,
                    source: $"synergy:{synergy.SynergyId}");
            }

            if (!string.IsNullOrEmpty(synergy.StatusEffectId))
            {
                _buffDebuffService.ApplyStatusEffect(target, synergy.StatusEffectId);
            }
        }

        _logger.LogDebug(
            "Applied synergy {SynergyName} to {Count} members of group {GroupId}",
            synergy.Name, targets.Count(), group.GroupId);
    }

    /// <inheritdoc />
    public void OnGroupMemberHit(Monster attacker, ICombatant target)
    {
        var groupInstance = GetGroupForMonster(attacker);
        if (groupInstance is null)
        {
            return;
        }

        // Apply OnAllyHit synergies to other members
        foreach (var synergy in groupInstance.Definition.GetSynergiesByTrigger(SynergyTrigger.OnAllyHit))
        {
            foreach (var member in groupInstance.AliveMembers.Where(m => m.Id != attacker.Id))
            {
                if (synergy.AttackBonus.HasValue)
                {
                    member.AddTemporaryBonus("attack", synergy.AttackBonus.Value, durationTurns: 1);
                }

                if (synergy.DamageBonus.HasValue)
                {
                    member.AddTemporaryBonus("damage", synergy.DamageBonus.Value, durationTurns: 1);
                }
            }

            _logger.LogDebug(
                "Triggered OnAllyHit synergy {SynergyName} from {Attacker}",
                synergy.Name, attacker.Name);
        }
    }

    /// <inheritdoc />
    public void OnGroupMemberDamaged(Monster target, int damage)
    {
        var groupInstance = GetGroupForMonster(target);
        if (groupInstance is null)
        {
            return;
        }

        // Apply OnAllyDamaged synergies to other members
        foreach (var synergy in groupInstance.Definition.GetSynergiesByTrigger(SynergyTrigger.OnAllyDamaged))
        {
            foreach (var member in groupInstance.AliveMembers.Where(m => m.Id != target.Id))
            {
                if (synergy.AttackBonus.HasValue)
                {
                    member.AddTemporaryBonus("attack", synergy.AttackBonus.Value, durationTurns: 2);
                }

                if (synergy.DamageBonus.HasValue)
                {
                    member.AddTemporaryBonus("damage", synergy.DamageBonus.Value, durationTurns: 2);
                }
            }
        }
    }

    /// <inheritdoc />
    public void OnGroupMemberDeath(Monster monster)
    {
        var groupInstance = GetGroupForMonster(monster);
        if (groupInstance is null)
        {
            return;
        }

        groupInstance.OnMemberDeath(monster);

        // Remove mapping if group is empty
        if (!groupInstance.HasAliveMembers)
        {
            _activeGroups.Remove(groupInstance.Id);
            _logger.LogInformation("Group {GroupId} eliminated", groupInstance.GroupId);
        }
        else
        {
            _logger.LogDebug(
                "Group {GroupId} lost member {Monster}, {Count} remaining",
                groupInstance.GroupId, monster.Name, groupInstance.AliveCount);
        }

        // Remove monster from mapping
        _monsterToGroup.Remove(monster.Id);
    }

    /// <inheritdoc />
    public IReadOnlyList<GridPosition> GetFlankingPositions(ICombatant target, int groupSize)
    {
        return _flankingService.GetFlankingPositions(target.Position)
            .Where(p => _grid.IsValidPosition(p) && _grid.IsPassable(p))
            .Take(groupSize)
            .ToList();
    }

    /// <inheritdoc />
    public int GetAdjacentAllyDamageBonus(Monster monster)
    {
        var groupInstance = GetGroupForMonster(monster);
        if (groupInstance is null)
        {
            return 0;
        }

        var perAdjacentSynergies = groupInstance.Definition
            .GetSynergiesByTrigger(SynergyTrigger.PerAdjacentAlly)
            .Where(s => s.DamageBonus.HasValue);

        if (!perAdjacentSynergies.Any())
        {
            return 0;
        }

        var adjacentCount = CountAdjacentAllies(monster, groupInstance);
        return perAdjacentSynergies.Sum(s => s.DamageBonus!.Value * adjacentCount);
    }

    /// <inheritdoc />
    public int GetAdjacentAllyAttackBonus(Monster monster)
    {
        var groupInstance = GetGroupForMonster(monster);
        if (groupInstance is null)
        {
            return 0;
        }

        var perAdjacentSynergies = groupInstance.Definition
            .GetSynergiesByTrigger(SynergyTrigger.PerAdjacentAlly)
            .Where(s => s.AttackBonus.HasValue);

        if (!perAdjacentSynergies.Any())
        {
            return 0;
        }

        var adjacentCount = CountAdjacentAllies(monster, groupInstance);
        return perAdjacentSynergies.Sum(s => s.AttackBonus!.Value * adjacentCount);
    }

    /// <inheritdoc />
    public bool IsInGroup(Monster monster)
    {
        return _monsterToGroup.ContainsKey(monster.Id);
    }

    /// <inheritdoc />
    public IReadOnlyList<MonsterGroupInstance> GetActiveGroups()
    {
        return _activeGroups.Values.ToList();
    }

    // ===== Helper Methods =====

    /// <summary>
    /// Gets spawn positions distributed around a center point.
    /// </summary>
    private List<GridPosition> GetSpawnPositions(GridPosition center, int count)
    {
        var positions = new List<GridPosition>();
        var radius = 1;

        // Start with center
        if (_grid.IsValidPosition(center) && _grid.IsEmpty(center))
        {
            positions.Add(center);
        }

        // Expand outward in rings until we have enough positions
        while (positions.Count < count && radius < 5)
        {
            for (int dx = -radius; dx <= radius; dx++)
            {
                for (int dy = -radius; dy <= radius; dy++)
                {
                    if (Math.Abs(dx) != radius && Math.Abs(dy) != radius)
                    {
                        continue; // Only ring positions
                    }

                    var pos = new GridPosition(center.X + dx, center.Y + dy);
                    if (_grid.IsValidPosition(pos) && _grid.IsEmpty(pos))
                    {
                        positions.Add(pos);
                        if (positions.Count >= count)
                        {
                            return positions;
                        }
                    }
                }
            }
            radius++;
        }

        return positions;
    }

    /// <summary>
    /// Gets the best flanking position for a monster.
    /// </summary>
    private GridPosition? GetBestFlankingPosition(
        Monster monster,
        ICombatant target,
        MonsterGroupInstance group)
    {
        var flankPositions = _flankingService.GetFlankingPositions(target.Position);
        var allyPositions = group.AliveMembers
            .Where(m => m.Id != monster.Id)
            .Select(m => m.Position)
            .ToHashSet();

        // Find unoccupied flanking position
        foreach (var pos in flankPositions)
        {
            if (_grid.IsValidPosition(pos) && _grid.IsPassable(pos) && !allyPositions.Contains(pos))
            {
                return pos;
            }
        }

        return null;
    }

    /// <summary>
    /// Gets a position between the protected unit and the threat.
    /// </summary>
    private GridPosition? GetProtectionPosition(Monster protector, Monster protected_, ICombatant threat)
    {
        // Get position between protected and threat
        var direction = GetDirectionToward(protected_.Position, threat.Position);
        var protectPos = new GridPosition(protected_.Position.X + direction.X, protected_.Position.Y + direction.Y);

        if (_grid.IsValidPosition(protectPos) && _grid.IsPassable(protectPos))
        {
            return protectPos;
        }

        return null;
    }

    /// <summary>
    /// Gets the closest passable position to a target.
    /// </summary>
    private GridPosition? GetClosestPositionToTarget(Monster monster, ICombatant target)
    {
        var direction = GetDirectionToward(monster.Position, target.Position);
        var nextPos = new GridPosition(monster.Position.X + direction.X, monster.Position.Y + direction.Y);

        if (_grid.IsValidPosition(nextPos) && _grid.IsPassable(nextPos))
        {
            return nextPos;
        }

        return null;
    }

    /// <summary>
    /// Gets a position moving away from the threat.
    /// </summary>
    private GridPosition? GetRetreatPosition(Monster monster, ICombatant threat)
    {
        var direction = GetDirectionToward(monster.Position, threat.Position);
        // Retreat is opposite direction
        var retreatPos = new GridPosition(monster.Position.X - direction.X, monster.Position.Y - direction.Y);

        if (_grid.IsValidPosition(retreatPos) && _grid.IsPassable(retreatPos))
        {
            return retreatPos;
        }

        return null;
    }

    /// <summary>
    /// Gets a normalized direction vector from one position toward another.
    /// </summary>
    private static GridOffset GetDirectionToward(GridPosition from, GridPosition to)
    {
        var dx = Math.Sign(to.X - from.X);
        var dy = Math.Sign(to.Y - from.Y);
        return new GridOffset(dx, dy);
    }

    /// <summary>
    /// Counts adjacent allies in the same group.
    /// </summary>
    private int CountAdjacentAllies(Monster monster, MonsterGroupInstance group)
    {
        var adjacentPositions = GetAdjacentPositions(monster.Position);
        return group.AliveMembers
            .Where(m => m.Id != monster.Id)
            .Count(m => adjacentPositions.Contains(m.Position));
    }

    /// <summary>
    /// Gets the four cardinal adjacent positions.
    /// </summary>
    private static HashSet<GridPosition> GetAdjacentPositions(GridPosition center)
    {
        return new HashSet<GridPosition>
        {
            new(center.X - 1, center.Y),
            new(center.X + 1, center.Y),
            new(center.X, center.Y - 1),
            new(center.X, center.Y + 1)
        };
    }

    /// <summary>
    /// Calculates the group's overall health percentage.
    /// </summary>
    private static int CalculateGroupHealthPercent(MonsterGroupInstance group)
    {
        var totalHealth = group.AliveMembers.Sum(m => m.Health);
        var totalMaxHealth = group.AliveMembers.Sum(m => m.MaxHealth);
        if (totalMaxHealth == 0) return 0;
        return (int)((totalHealth / (float)totalMaxHealth) * 100);
    }
}

/// <summary>
/// Event fired when a monster group spawns.
/// </summary>
public record MonsterGroupSpawnedEvent(
    Guid GroupInstanceId,
    string GroupId,
    int MemberCount) : IGameEvent
{
    public DateTime Timestamp { get; } = DateTime.UtcNow;
}
```

---

## 15. Configuration Schema

**File:** `config/schemas/monster-groups.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft-07/schema#",
  "$id": "monster-groups.schema.json",
  "title": "Monster Groups Configuration",
  "description": "Schema for monster group definitions with coordinated tactics and synergies",
  "type": "object",
  "required": ["monsterGroups"],
  "properties": {
    "$schema": {
      "type": "string",
      "description": "Reference to this schema file"
    },
    "monsterGroups": {
      "type": "array",
      "description": "List of monster group definitions",
      "items": {
        "$ref": "#/definitions/monsterGroup"
      },
      "minItems": 1
    }
  },
  "definitions": {
    "monsterGroup": {
      "type": "object",
      "required": ["groupId", "name", "members"],
      "properties": {
        "groupId": {
          "type": "string",
          "description": "Unique identifier for this group",
          "pattern": "^[a-z0-9-]+$"
        },
        "name": {
          "type": "string",
          "description": "Display name for the group"
        },
        "description": {
          "type": "string",
          "description": "Description of the group's composition and behavior"
        },
        "members": {
          "type": "array",
          "description": "Members that make up this group",
          "items": {
            "$ref": "#/definitions/groupMember"
          },
          "minItems": 1
        },
        "tactics": {
          "type": "array",
          "description": "Tactical behaviors in priority order",
          "items": {
            "type": "string",
            "enum": ["Flank", "FocusFire", "ProtectLeader", "ProtectCaster", "Swarm", "Retreat", "Ambush", "HitAndRun"]
          }
        },
        "synergies": {
          "type": "array",
          "description": "Synergy effects for group coordination",
          "items": {
            "$ref": "#/definitions/groupSynergy"
          }
        },
        "leaderRole": {
          "type": "string",
          "description": "The role designated as group leader"
        },
        "tags": {
          "type": "array",
          "description": "Optional tags for categorization",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "groupMember": {
      "type": "object",
      "required": ["monsterDefinitionId"],
      "properties": {
        "monsterDefinitionId": {
          "type": "string",
          "description": "Reference to monster definition"
        },
        "count": {
          "type": "integer",
          "description": "Number of this monster type in the group",
          "minimum": 1,
          "default": 1
        },
        "role": {
          "type": "string",
          "description": "Tactical role (melee, ranged, leader, striker, caster)"
        },
        "preferredPosition": {
          "type": "object",
          "description": "Preferred spawn position offset",
          "properties": {
            "deltaX": { "type": "integer" },
            "deltaY": { "type": "integer" }
          }
        }
      }
    },
    "groupSynergy": {
      "type": "object",
      "required": ["synergyId", "name", "trigger"],
      "properties": {
        "synergyId": {
          "type": "string",
          "description": "Unique identifier for this synergy"
        },
        "name": {
          "type": "string",
          "description": "Display name"
        },
        "description": {
          "type": "string",
          "description": "Description of the synergy effect"
        },
        "trigger": {
          "type": "string",
          "description": "When the synergy activates",
          "enum": ["Always", "OnAllyHit", "OnAllyDamaged", "OnLeaderCommand", "PerAdjacentAlly"]
        },
        "sourceRole": {
          "type": "string",
          "description": "Optional role requirement for synergy source"
        },
        "statusEffectId": {
          "type": "string",
          "description": "Optional status effect to apply"
        },
        "attackBonus": {
          "type": "integer",
          "description": "Bonus to attack rolls"
        },
        "damageBonus": {
          "type": "integer",
          "description": "Bonus to damage rolls"
        },
        "appliesToAllMembers": {
          "type": "boolean",
          "description": "Whether synergy applies to all members including source",
          "default": false
        }
      }
    }
  }
}
```

---

## 16. Configuration File

**File:** `config/monster-groups.json`

```json
{
  "$schema": "./schemas/monster-groups.schema.json",
  "monsterGroups": [
    {
      "groupId": "goblin-warband",
      "name": "Goblin Warband",
      "description": "A coordinated group of goblin raiders led by a shaman",
      "members": [
        { "monsterDefinitionId": "goblin-warrior", "count": 3, "role": "melee" },
        { "monsterDefinitionId": "goblin-shaman", "count": 1, "role": "leader" }
      ],
      "tactics": ["Flank", "FocusFire", "ProtectLeader"],
      "leaderRole": "leader",
      "synergies": [
        {
          "synergyId": "shaman-blessing",
          "name": "Shaman's Blessing",
          "description": "The shaman's presence empowers all goblins with +1 attack",
          "trigger": "Always",
          "sourceRole": "leader",
          "attackBonus": 1,
          "appliesToAllMembers": true
        },
        {
          "synergyId": "pack-tactics",
          "name": "Pack Tactics",
          "description": "When one goblin lands a hit, others gain advantage",
          "trigger": "OnAllyHit",
          "attackBonus": 2
        },
        {
          "synergyId": "pack-mentality",
          "name": "Pack Mentality",
          "description": "+1 damage per adjacent ally",
          "trigger": "PerAdjacentAlly",
          "damageBonus": 1
        }
      ],
      "tags": ["goblin", "coordinated", "common"]
    },
    {
      "groupId": "skeleton-patrol",
      "name": "Skeleton Patrol",
      "description": "Undead warriors protecting their domain with coordinated attacks",
      "members": [
        { "monsterDefinitionId": "skeleton-warrior", "count": 2, "role": "melee" },
        { "monsterDefinitionId": "skeleton-archer", "count": 2, "role": "ranged" }
      ],
      "tactics": ["FocusFire", "ProtectCaster"],
      "synergies": [
        {
          "synergyId": "undead-coordination",
          "name": "Undead Coordination",
          "description": "The patrol moves with unnatural coordination, always targeting the same enemy",
          "trigger": "Always"
        },
        {
          "synergyId": "death-frenzy",
          "name": "Death Frenzy",
          "description": "When an ally is destroyed, survivors gain +2 damage",
          "trigger": "OnAllyDamaged",
          "damageBonus": 2
        }
      ],
      "tags": ["undead", "ranged", "common"]
    },
    {
      "groupId": "bandit-ambush",
      "name": "Bandit Ambush Team",
      "description": "Opportunistic bandits who strike from hiding and flank their prey",
      "members": [
        { "monsterDefinitionId": "bandit-rogue", "count": 2, "role": "striker" },
        { "monsterDefinitionId": "bandit-thug", "count": 2, "role": "melee" }
      ],
      "tactics": ["Ambush", "Flank", "HitAndRun"],
      "synergies": [
        {
          "synergyId": "sneak-attack-setup",
          "name": "Sneak Attack Setup",
          "description": "When an ally hits, strikers gain +3 damage on next attack",
          "trigger": "OnAllyHit",
          "damageBonus": 3,
          "sourceRole": "striker"
        },
        {
          "synergyId": "opportunist",
          "name": "Opportunist",
          "description": "+1 attack per adjacent ally for flanking bonuses",
          "trigger": "PerAdjacentAlly",
          "attackBonus": 1
        }
      ],
      "tags": ["human", "ambush", "uncommon"]
    },
    {
      "groupId": "wolf-pack",
      "name": "Wolf Pack",
      "description": "A pack of wolves that hunt as a coordinated unit",
      "members": [
        { "monsterDefinitionId": "dire-wolf", "count": 1, "role": "leader" },
        { "monsterDefinitionId": "wolf", "count": 3, "role": "melee" }
      ],
      "tactics": ["Flank", "FocusFire", "Swarm"],
      "leaderRole": "leader",
      "synergies": [
        {
          "synergyId": "alpha-howl",
          "name": "Alpha's Howl",
          "description": "The alpha wolf inspires the pack with +1 attack and damage",
          "trigger": "Always",
          "sourceRole": "leader",
          "attackBonus": 1,
          "damageBonus": 1,
          "appliesToAllMembers": true
        },
        {
          "synergyId": "pack-hunter",
          "name": "Pack Hunter",
          "description": "+2 damage per adjacent pack member",
          "trigger": "PerAdjacentAlly",
          "damageBonus": 2
        }
      ],
      "tags": ["beast", "pack", "common"]
    },
    {
      "groupId": "cultist-cell",
      "name": "Cultist Cell",
      "description": "Dark cultists protecting their leader during rituals",
      "members": [
        { "monsterDefinitionId": "cultist-acolyte", "count": 3, "role": "melee" },
        { "monsterDefinitionId": "cultist-priest", "count": 1, "role": "caster" }
      ],
      "tactics": ["ProtectCaster", "Swarm", "Retreat"],
      "synergies": [
        {
          "synergyId": "dark-blessing",
          "name": "Dark Blessing",
          "description": "The priest's dark magic bolsters all cultists",
          "trigger": "Always",
          "sourceRole": "caster",
          "statusEffectId": "dark-ward",
          "appliesToAllMembers": true
        },
        {
          "synergyId": "fanatical-devotion",
          "name": "Fanatical Devotion",
          "description": "When the priest is damaged, cultists gain fury (+3 damage)",
          "trigger": "OnAllyDamaged",
          "damageBonus": 3
        }
      ],
      "tags": ["humanoid", "caster", "uncommon"]
    }
  ]
}
```

---

## 17. Unit Testing Requirements

### Test Count by Feature

| Feature | Tests |
|---------|-------|
| SpawnGroup validation and positioning | 2 |
| DetermineMove tactic evaluation | 3 |
| DetermineTarget focus fire logic | 2 |
| Synergy application and triggers | 2 |
| OnGroupMemberDeath state updates | 2 |
| **Total** | **~11** |

### Test Specifications

**File:** `tests/RuneAndRust.Application.UnitTests/Services/MonsterGroupServiceTests.cs`

```csharp
[TestFixture]
public class MonsterGroupServiceTests
{
    private Mock<IMonsterGroupProvider> _groupProviderMock = null!;
    private Mock<IMonsterSpawnService> _spawnServiceMock = null!;
    private Mock<ICombatGrid> _gridMock = null!;
    private Mock<IFlankingService> _flankingServiceMock = null!;
    private Mock<IBuffDebuffService> _buffDebuffServiceMock = null!;
    private Mock<IEventBus> _eventBusMock = null!;
    private Mock<ILogger<MonsterGroupService>> _loggerMock = null!;
    private MonsterGroupService _service = null!;

    [SetUp]
    public void Setup()
    {
        _groupProviderMock = new Mock<IMonsterGroupProvider>();
        _spawnServiceMock = new Mock<IMonsterSpawnService>();
        _gridMock = new Mock<ICombatGrid>();
        _flankingServiceMock = new Mock<IFlankingService>();
        _buffDebuffServiceMock = new Mock<IBuffDebuffService>();
        _eventBusMock = new Mock<IEventBus>();
        _loggerMock = new Mock<ILogger<MonsterGroupService>>();

        _service = new MonsterGroupService(
            _groupProviderMock.Object,
            _spawnServiceMock.Object,
            _gridMock.Object,
            _flankingServiceMock.Object,
            _buffDebuffServiceMock.Object,
            _eventBusMock.Object,
            _loggerMock.Object);
    }

    // ===== SpawnGroup Tests =====

    [Test]
    public void SpawnGroup_WithValidGroupId_ReturnsSpawnedMonstersAndInitializesInstance()
    {
        // Arrange
        var groupDef = CreateTestGroupDefinition("test-group", memberCount: 4);
        var monsters = CreateTestMonsters(4);

        _groupProviderMock.Setup(x => x.GetGroup("test-group")).Returns(groupDef);
        SetupGridAndSpawnService(4, monsters);

        // Act
        var result = _service.SpawnGroup("test-group", new GridPosition(5, 5));

        // Assert
        result.Should().HaveCount(4);
        _service.IsInGroup(result[0]).Should().BeTrue();
        _service.GetGroupForMonster(result[0]).Should().NotBeNull();
        _eventBusMock.Verify(x => x.Publish(It.IsAny<MonsterGroupSpawnedEvent>()), Times.Once);
    }

    [Test]
    public void SpawnGroup_WithInvalidGroupId_ThrowsArgumentException()
    {
        // Arrange
        _groupProviderMock.Setup(x => x.GetGroup("invalid")).Returns((MonsterGroupDefinition?)null);

        // Act
        var act = () => _service.SpawnGroup("invalid", new GridPosition(5, 5));

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithMessage("*Monster group not found*");
    }

    // ===== DetermineMove Tests =====

    [Test]
    public void DetermineMove_WithFlankTactic_ReturnsFlankingPosition()
    {
        // Arrange
        var (group, monsters) = SetupActiveGroupWithFlankTactic();
        var target = CreateTestPlayer();
        group.CurrentTarget = target;

        var flankPositions = new[] { new GridPosition(4, 5), new GridPosition(6, 5) };
        _flankingServiceMock.Setup(x => x.GetFlankingPositions(target.Position))
            .Returns(flankPositions);
        SetupGridAsPassable(flankPositions);

        // Act
        var decision = _service.DetermineMove(monsters[0]);

        // Assert
        decision.Type.Should().Be(GroupMoveDecisionType.MoveTo);
        decision.Tactic.Should().Be(GroupTactic.Flank);
        decision.TargetPosition.Should().NotBeNull();
    }

    [Test]
    public void DetermineMove_WithNoGroup_ReturnsNoGroupDecision()
    {
        // Arrange
        var monster = CreateTestMonster();

        // Act
        var decision = _service.DetermineMove(monster);

        // Assert
        decision.Type.Should().Be(GroupMoveDecisionType.NoGroup);
    }

    [Test]
    public void DetermineMove_WithNoTarget_ReturnsNoTargetDecision()
    {
        // Arrange
        var (group, monsters) = SetupActiveGroupWithFlankTactic();
        group.CurrentTarget = null;

        // Act
        var decision = _service.DetermineMove(monsters[0]);

        // Assert
        decision.Type.Should().Be(GroupMoveDecisionType.NoTarget);
    }

    // ===== DetermineTarget Tests =====

    [Test]
    public void DetermineTarget_WithFocusFireTactic_SelectsLowestHPTarget()
    {
        // Arrange
        var (group, monsters) = SetupActiveGroupWithFocusFireTactic();
        var targets = new[]
        {
            CreateTestPlayer(health: 50, name: "Player1"),
            CreateTestPlayer(health: 20, name: "Player2"),
            CreateTestPlayer(health: 80, name: "Player3")
        };

        // Act
        var target = _service.DetermineTarget(monsters[0], targets);

        // Assert
        target.Should().NotBeNull();
        target!.Name.Should().Be("Player2"); // Lowest HP
        group.CurrentTarget.Should().Be(target);
    }

    [Test]
    public void DetermineTarget_WithFocusFire_UsesExistingTargetIfValid()
    {
        // Arrange
        var (group, monsters) = SetupActiveGroupWithFocusFireTactic();
        var existingTarget = CreateTestPlayer(health: 50, name: "ExistingTarget");
        group.CurrentTarget = existingTarget;

        var targets = new[]
        {
            existingTarget,
            CreateTestPlayer(health: 10, name: "LowerHP")
        };

        // Act
        var target = _service.DetermineTarget(monsters[0], targets);

        // Assert
        target.Should().Be(existingTarget); // Uses existing, doesn't switch to lower HP
    }

    // ===== Synergy Tests =====

    [Test]
    public void ApplySynergies_WithAlwaysSynergy_AppliesBonusToAllMembers()
    {
        // Arrange
        var (group, monsters) = SetupActiveGroupWithAlwaysSynergy();

        // Act
        _service.ApplySynergies(group);

        // Assert
        _buffDebuffServiceMock.Verify(
            x => x.ApplyStatModifier(It.IsAny<Monster>(), "attack", 1, It.IsAny<string>()),
            Times.AtLeast(3)); // 3 non-leader members + possibly leader
    }

    [Test]
    public void OnGroupMemberHit_WithOnAllyHitSynergy_AppliesTemporaryBonusToOthers()
    {
        // Arrange
        var (group, monsters) = SetupActiveGroupWithOnAllyHitSynergy();
        var target = CreateTestPlayer();

        // Act
        _service.OnGroupMemberHit(monsters[0], target);

        // Assert
        foreach (var monster in monsters.Skip(1))
        {
            monster.Received().AddTemporaryBonus("attack", 2, 1);
        }
    }

    // ===== OnGroupMemberDeath Tests =====

    [Test]
    public void OnGroupMemberDeath_RemovesMemberFromGroupTracking()
    {
        // Arrange
        var (group, monsters) = SetupActiveGroupWithFlankTactic();
        var dyingMonster = monsters[0];
        dyingMonster.IsAlive.Returns(false);

        // Act
        _service.OnGroupMemberDeath(dyingMonster);

        // Assert
        _service.IsInGroup(dyingMonster).Should().BeFalse();
        group.AliveCount.Should().BeLessThan(monsters.Count);
    }

    [Test]
    public void OnGroupMemberDeath_WhenLastMember_RemovesGroupInstance()
    {
        // Arrange
        var groupDef = CreateTestGroupDefinition("small-group", memberCount: 1);
        var monster = CreateTestMonster();
        monster.IsAlive.Returns(true);

        _groupProviderMock.Setup(x => x.GetGroup("small-group")).Returns(groupDef);
        SetupGridAndSpawnService(1, new[] { monster });

        _service.SpawnGroup("small-group", new GridPosition(5, 5));

        // Kill the monster
        monster.IsAlive.Returns(false);

        // Act
        _service.OnGroupMemberDeath(monster);

        // Assert
        _service.GetActiveGroups().Should().BeEmpty();
    }

    // ===== Helper Methods =====

    private MonsterGroupDefinition CreateTestGroupDefinition(string groupId, int memberCount = 4)
    {
        var members = Enumerable.Range(0, memberCount)
            .Select(i => new GroupMember
            {
                MonsterDefinitionId = $"monster-{i}",
                Count = 1,
                Role = i == 0 ? "leader" : "melee"
            })
            .ToList();

        return MonsterGroupDefinition.Create(groupId, "Test Group", "A test group", members);
    }

    private Monster CreateTestMonster()
    {
        var monster = Substitute.For<Monster>();
        monster.Id.Returns(Guid.NewGuid());
        monster.IsAlive.Returns(true);
        monster.Position.Returns(new GridPosition(0, 0));
        return monster;
    }

    private Monster[] CreateTestMonsters(int count)
    {
        return Enumerable.Range(0, count).Select(_ => CreateTestMonster()).ToArray();
    }

    private ICombatant CreateTestPlayer(int health = 100, string name = "Player")
    {
        var player = Substitute.For<ICombatant>();
        player.Health.Returns(health);
        player.Name.Returns(name);
        player.IsAlive.Returns(health > 0);
        player.Position.Returns(new GridPosition(5, 5));
        return player;
    }

    private void SetupGridAndSpawnService(int count, Monster[] monsters)
    {
        _gridMock.Setup(x => x.IsValidPosition(It.IsAny<GridPosition>())).Returns(true);
        _gridMock.Setup(x => x.IsEmpty(It.IsAny<GridPosition>())).Returns(true);
        _gridMock.Setup(x => x.IsPassable(It.IsAny<GridPosition>())).Returns(true);

        var monsterIndex = 0;
        _spawnServiceMock.Setup(x => x.SpawnByDefinitionId(It.IsAny<string>(), It.IsAny<GridPosition>()))
            .Returns(() => monsters[monsterIndex++]);
    }

    private void SetupGridAsPassable(GridPosition[] positions)
    {
        foreach (var pos in positions)
        {
            _gridMock.Setup(x => x.IsValidPosition(pos)).Returns(true);
            _gridMock.Setup(x => x.IsPassable(pos)).Returns(true);
        }
    }

    private (MonsterGroupInstance group, Monster[] monsters) SetupActiveGroupWithFlankTactic()
    {
        var groupDef = CreateTestGroupDefinition("flank-group")
            .WithTactics(new[] { GroupTactic.Flank });

        var monsters = CreateTestMonsters(4);
        _groupProviderMock.Setup(x => x.GetGroup("flank-group")).Returns(groupDef);
        SetupGridAndSpawnService(4, monsters);

        _service.SpawnGroup("flank-group", new GridPosition(0, 0));
        var group = _service.GetGroupForMonster(monsters[0])!;

        return (group, monsters);
    }

    private (MonsterGroupInstance group, Monster[] monsters) SetupActiveGroupWithFocusFireTactic()
    {
        var groupDef = CreateTestGroupDefinition("focusfire-group")
            .WithTactics(new[] { GroupTactic.FocusFire });

        var monsters = CreateTestMonsters(4);
        _groupProviderMock.Setup(x => x.GetGroup("focusfire-group")).Returns(groupDef);
        SetupGridAndSpawnService(4, monsters);

        _service.SpawnGroup("focusfire-group", new GridPosition(0, 0));
        var group = _service.GetGroupForMonster(monsters[0])!;

        return (group, monsters);
    }

    private (MonsterGroupInstance group, Monster[] monsters) SetupActiveGroupWithAlwaysSynergy()
    {
        var synergy = new GroupSynergy
        {
            SynergyId = "test-synergy",
            Name = "Test Synergy",
            Trigger = SynergyTrigger.Always,
            AttackBonus = 1,
            AppliesToAllMembers = true
        };

        var groupDef = CreateTestGroupDefinition("synergy-group")
            .WithSynergies(new[] { synergy });

        var monsters = CreateTestMonsters(4);
        _groupProviderMock.Setup(x => x.GetGroup("synergy-group")).Returns(groupDef);
        SetupGridAndSpawnService(4, monsters);

        _service.SpawnGroup("synergy-group", new GridPosition(0, 0));
        var group = _service.GetGroupForMonster(monsters[0])!;

        return (group, monsters);
    }

    private (MonsterGroupInstance group, Monster[] monsters) SetupActiveGroupWithOnAllyHitSynergy()
    {
        var synergy = new GroupSynergy
        {
            SynergyId = "ally-hit-synergy",
            Name = "Pack Tactics",
            Trigger = SynergyTrigger.OnAllyHit,
            AttackBonus = 2
        };

        var groupDef = CreateTestGroupDefinition("allyhit-group")
            .WithSynergies(new[] { synergy });

        var monsters = CreateTestMonsters(4);
        _groupProviderMock.Setup(x => x.GetGroup("allyhit-group")).Returns(groupDef);
        SetupGridAndSpawnService(4, monsters);

        _service.SpawnGroup("allyhit-group", new GridPosition(0, 0));
        var group = _service.GetGroupForMonster(monsters[0])!;

        return (group, monsters);
    }
}
```

---

## 18. Use Cases

### UC-001: Spawn Monster Group

**Actor:** Encounter System
**Flow:** Encounter triggers group spawn → `IMonsterGroupService.SpawnGroup(groupId, centerPosition)` called → Group definition loaded from provider → Spawn positions calculated around center → Each member spawned with role assignment → `MonsterGroupInstance` created → Members mapped to group → Always synergies applied → `MonsterGroupSpawnedEvent` published

### UC-002: Group Member Determines Move (Flank Tactic)

**Actor:** AI System
**Flow:** Monster turn begins → AI requests move from group service → `DetermineMove(monster)` called → Group instance retrieved → Current target validated → Flank tactic evaluated → `GetBestFlankingPosition()` finds unoccupied flanking cell → Returns `GroupMoveDecision.MoveTo(position, Flank)` → AI moves monster to flanking position

### UC-003: Group Selects Focus Fire Target

**Actor:** AI System
**Flow:** Monster needs target → `DetermineTarget(monster, possibleTargets)` called → Group has FocusFire tactic → Check existing group target → If no valid target, select lowest HP enemy → Set as `group.CurrentTarget` → All group members receive same target → Coordinated attack on weak enemy

### UC-004: OnAllyHit Synergy Triggers

**Actor:** Combat System
**Flow:** Goblin warrior attacks player → Hit successful → Combat calls `OnGroupMemberHit(attacker, target)` → Group has "Pack Tactics" synergy (OnAllyHit) → For each other group member → Apply temporary +2 attack bonus (1 turn) → Other goblins attack with advantage

### UC-005: PerAdjacentAlly Damage Calculation

**Actor:** Combat System
**Flow:** Monster attacks → Combat system calculates damage → Calls `GetAdjacentAllyDamageBonus(monster)` → Group has "Pack Mentality" synergy (PerAdjacentAlly, +1 damage) → Count adjacent group allies = 2 → Return bonus: 2 × 1 = +2 damage → Damage calculation includes +2 bonus

### UC-006: Group Member Death

**Actor:** Combat System
**Flow:** Goblin warrior dies → Combat calls `OnGroupMemberDeath(monster)` → Group instance updated → Monster removed from tracking → If last member, group instance removed → If leader died, ProtectLeader tactic no longer active → Group continues with remaining members

### UC-007: Protect Leader Positioning

**Actor:** AI System
**Flow:** Goblin warrior turn → `DetermineMove(warrior)` called → Group has ProtectLeader tactic → Get group leader (shaman) → Warrior is not leader → Calculate position between shaman and nearest threat → Return `GroupMoveDecision.MoveTo(protectPosition, ProtectLeader)` → Warrior moves to shield shaman

---

## 19. Deliverable Checklist

### Domain Layer - Enums

- [ ] `GroupTactic` enum created at `src/Core/RuneAndRust.Domain/Enums/GroupTactic.cs`
- [ ] 8 tactic values: Flank, FocusFire, ProtectLeader, ProtectCaster, Swarm, Retreat, Ambush, HitAndRun
- [ ] XML documentation on each value

- [ ] `SynergyTrigger` enum created at `src/Core/RuneAndRust.Domain/Enums/SynergyTrigger.cs`
- [ ] 5 trigger values: Always, OnAllyHit, OnAllyDamaged, OnLeaderCommand, PerAdjacentAlly
- [ ] XML documentation on each value

### Domain Layer - Value Objects

- [ ] `GroupMember` class created at `src/Core/RuneAndRust.Domain/ValueObjects/GroupMember.cs`
- [ ] Properties: MonsterDefinitionId, Count, Role, PreferredPosition
- [ ] Methods: HasRole, IsRole

- [ ] `GroupSynergy` class created at `src/Core/RuneAndRust.Domain/ValueObjects/GroupSynergy.cs`
- [ ] Properties: SynergyId, Name, Description, Trigger, SourceRole, StatusEffectId, AttackBonus, DamageBonus, AppliesToAllMembers
- [ ] Properties: HasBonuses, RequiresSourceRole

- [ ] `GridOffset` record created at `src/Core/RuneAndRust.Domain/ValueObjects/GridOffset.cs`

### Domain Layer - Entities

- [ ] `MonsterGroupDefinition` entity created at `src/Core/RuneAndRust.Domain/Definitions/MonsterGroupDefinition.cs`
- [ ] Properties: GroupId, Name, Description, Members, Tactics, Synergies, LeaderRole, MinSize, MaxSize, Tags
- [ ] Factory method: Create(groupId, name, description, members)
- [ ] Fluent methods: WithTactics, WithSynergies, WithLeader
- [ ] Query methods: GetLeaderMember, GetMembersByRole, HasTactic, GetSynergiesByTrigger

### Application Layer - Tracking

- [ ] `MonsterGroupInstance` class created at `src/Core/RuneAndRust.Application/Tracking/MonsterGroupInstance.cs`
- [ ] Properties: Id, GroupId, Definition, AliveMembers, AllMembers, CurrentTarget
- [ ] Methods: GetLeader, GetMembersByRole, OnMemberDeath, ClearTarget

- [ ] `GroupMoveDecision` struct created at `src/Core/RuneAndRust.Application/Tracking/GroupMoveDecision.cs`
- [ ] Properties: Type, TargetPosition, Tactic
- [ ] Factory methods: MoveTo, NoGroup, NoTarget, NoAction, HoldPosition

### Application Layer - Interfaces

- [ ] `IMonsterGroupProvider` interface created at `src/Core/RuneAndRust.Application/Interfaces/IMonsterGroupProvider.cs`
- [ ] Methods: GetGroup, GetAllGroups, GroupExists, GetGroupsByTag, Reload

- [ ] `IMonsterGroupService` interface created at `src/Core/RuneAndRust.Application/Interfaces/IMonsterGroupService.cs`
- [ ] 12 methods defined with XML documentation

### Application Layer - Services

- [ ] `MonsterGroupService` implementation created at `src/Core/RuneAndRust.Application/Services/MonsterGroupService.cs`
- [ ] All 12 interface methods implemented
- [ ] Tactic evaluation logic for all 8 tactics
- [ ] Synergy application for all 5 trigger types
- [ ] Helper methods for positioning and bonus calculation

### Infrastructure Layer

- [ ] `MonsterGroupProvider` implementation created at `src/Infrastructure/RuneAndRust.Infrastructure/Providers/MonsterGroupProvider.cs`
- [ ] JSON deserialization with proper data classes
- [ ] Enum parsing for tactics and triggers
- [ ] Caching and reload support

### Configuration Files

- [ ] `monster-groups.json` created at `config/monster-groups.json`
- [ ] 5 sample groups: goblin-warband, skeleton-patrol, bandit-ambush, wolf-pack, cultist-cell
- [ ] Schema reference included

- [ ] `monster-groups.schema.json` created at `config/schemas/monster-groups.schema.json`
- [ ] All properties defined with types and descriptions
- [ ] Enum values validated

### Testing

- [ ] `MonsterGroupServiceTests.cs` created (~11 tests)
- [ ] SpawnGroup tests (2 tests)
- [ ] DetermineMove tests (3 tests)
- [ ] DetermineTarget tests (2 tests)
- [ ] Synergy tests (2 tests)
- [ ] OnGroupMemberDeath tests (2 tests)
- [ ] All ~11 tests passing

### Documentation

- [ ] Design specification complete (this document)
- [ ] All code snippets include file paths
- [ ] XML documentation complete on all public members

---

## 20. Acceptance Criteria

### Functional

- [ ] SpawnGroup creates monsters from group definition members
- [ ] SpawnGroup assigns roles to spawned monsters
- [ ] SpawnGroup distributes monsters around center position
- [ ] SpawnGroup creates MonsterGroupInstance with correct tracking
- [ ] SpawnGroup fires MonsterGroupSpawnedEvent
- [ ] DetermineMove returns NoGroup for non-grouped monsters
- [ ] DetermineMove returns NoTarget when group has no target
- [ ] Flank tactic returns unoccupied flanking position
- [ ] ProtectLeader tactic returns position between leader and threat
- [ ] Swarm tactic returns closest position to target
- [ ] Ambush tactic returns HoldPosition when out of range
- [ ] FocusFire tactic selects lowest HP target
- [ ] FocusFire uses existing target if still valid
- [ ] Always synergies applied on group spawn
- [ ] OnAllyHit synergies provide temporary bonus to other members
- [ ] PerAdjacentAlly synergies scale with adjacent ally count
- [ ] OnGroupMemberDeath removes monster from group tracking
- [ ] OnGroupMemberDeath removes group when last member dies
- [ ] GetAdjacentAllyDamageBonus calculates correct bonus
- [ ] GetAdjacentAllyAttackBonus calculates correct bonus
- [ ] IsInGroup correctly identifies grouped monsters
- [ ] Configuration loads from monster-groups.json
- [ ] Configuration validates against schema

### Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~11 unit tests pass
- [ ] XML documentation complete on all public members
- [ ] Service follows dependency injection pattern
- [ ] Enums have descriptive XML documentation
- [ ] Configuration file has realistic sample data (5 groups)
- [ ] Schema validates all configuration properties

---

## 21. Dependencies

### Required From

| Layer | Dependency | Usage |
|-------|------------|-------|
| Domain | `Monster` entity | Group member representation |
| Domain | `GridPosition` | Position calculations |
| Domain | `ICombatant` | Target interface |
| Application | `IMonsterSpawnService` | Member spawning |
| Application | `ICombatGrid` | Position validation |
| Application | `IFlankingService` | Flanking position calculation |
| Application | `IBuffDebuffService` | Synergy buff application |
| Application | `IEventBus` | Event publishing |

### Provides To

| Consumer | Dependency | Usage |
|----------|------------|-------|
| AI Service | `IMonsterGroupService.DetermineMove` | Group-coordinated movement |
| AI Service | `IMonsterGroupService.DetermineTarget` | Group target selection |
| Combat Service | `IMonsterGroupService.OnGroupMemberHit` | Synergy triggers |
| Combat Service | `IMonsterGroupService.OnGroupMemberDamaged` | Synergy triggers |
| Combat Service | `IMonsterGroupService.GetAdjacentAllyDamageBonus` | Damage calculation |
| Encounter System | `IMonsterGroupService.SpawnGroup` | Group spawning |
| UI/Renderer | `MonsterGroupSpawnedEvent` | Group spawn display |

---

## 22. Future Considerations

### Deferred to Future Versions

- **Dynamic Group Formation**: Monsters join groups during combat
- **Group Morale System**: Group effectiveness based on morale
- **Retreat Destination**: Specific retreat points for groups
- **Group Communication**: Visible coordination between members

### Out of Scope for v0.10.4

- **Group Audio**: Coordinated war cries or communication sounds
- **Group Formations**: Predefined formation patterns
- **Inter-Group Coordination**: Multiple groups working together
- **Group Scaling**: Dynamic difficulty based on player count

### Potential Enhancements (Future Versions)

- **Tactic Switching**: Groups change tactics based on combat state
- **Leader Death Effects**: Special events when leader dies
- **Reinforcement Calling**: Groups call for backup
- **Group Experience**: Groups become more coordinated over time

---

## 23. Logging Specifications

### Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `MonsterGroupService` | Information | Group spawned, group eliminated |
| `MonsterGroupService` | Debug | Tactic evaluation, synergy application, target selection, member death |
| `MonsterGroupService` | Warning | Insufficient spawn positions, missing definitions |
| `MonsterGroupProvider` | Information | Groups loaded count |
| `MonsterGroupProvider` | Warning | Failed to parse group |
| `MonsterGroupProvider` | Error | Configuration load failure |

### Log Message Examples

```
[Information] Spawned group Goblin Warband (goblin-warband) with 4 members at (5, 5)
[Information] Group goblin-warband eliminated
[Information] Loaded 5 monster group definitions

[Debug] Group goblin-warband focused on new target: Player2 (20 HP)
[Debug] Applied synergy Shaman's Blessing to 4 members of group goblin-warband
[Debug] Triggered OnAllyHit synergy Pack Tactics from Goblin Warrior
[Debug] Group goblin-warband lost member Goblin Warrior, 3 remaining
[Debug] Calculated 2 adjacent allies for Pack Mentality bonus

[Warning] Not enough spawn positions for group large-group, spawned 4/6
[Warning] Failed to parse monster group: invalid-group
[Error] Failed to load monster groups from config/monster-groups.json
```

---

*Document Version: 1.0*
*Last Updated: 2026-01-16*
