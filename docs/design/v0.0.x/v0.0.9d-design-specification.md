# v0.0.9d Design Specification: Loot & Currency

**Version:** 0.0.9d
**Phase Name:** Loot & Currency
**Parent Version:** v0.0.9 (Monster Variety & Loot)
**Prerequisites:** v0.0.9a (Monster Definitions), v0.0.9c (Monster Tiers - for LootMultiplier)
**Estimated Tests:** ~16 unit tests

---

## 1. Overview

### 1.1 Purpose

Implement a loot table system for monster drops and a configurable currency system. Players can collect gold and items from defeated monsters, creating a rewarding combat loop and foundation for future economic systems.

### 1.2 Scope

**In Scope:**
- `CurrencyDefinition` entity loaded from JSON configuration
- `LootTable` entity with weighted drop entries
- `LootEntry` and `CurrencyDrop` value objects
- `LootDrop` value object for generated loot results
- `ILootService` interface and `LootService` implementation
- Currency tracking on Player entity
- Loot drops on monster defeat
- Loot display after combat victory
- `loot` / `take` command to collect dropped items and currency
- Room storage for uncollected loot (persists until collected)
- `config/currency.json` configuration
- Loot tables embedded in `config/monsters.json`
- Tier-based loot bonuses using `Monster.LootMultiplier` from v0.0.9c
- Status command showing player currency

**Out of Scope:**
- Shops and vendors (future version)
- Item crafting (future version)
- Rare/legendary item quality tiers (future version)
- Trading between players (future version)
- Currency spending mechanics (future version)

### 1.3 Design Goals

1. **Rewarding Combat**: Every monster defeat provides meaningful loot
2. **Data-Driven**: Currency and loot tables defined in JSON configuration
3. **Tier Scaling**: Higher tier monsters drop proportionally better loot
4. **Persistence**: Uncollected loot remains in room until collected
5. **Extensible**: Foundation for shops, crafting, and economy systems
6. **Clear Feedback**: Players always know what dropped and what they collected

---

## 2. Data Model

### 2.1 New Definitions

#### CurrencyDefinition

A configuration-driven definition for a currency type.

**File:** `src/Core/RuneAndRust.Domain/Definitions/CurrencyDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a currency type that players can collect and spend.
/// </summary>
/// <remarks>
/// Currency definitions are loaded from configuration. The system supports
/// multiple currencies, though Gold is the default and primary currency.
/// </remarks>
public class CurrencyDefinition
{
    /// <summary>
    /// Gets the unique identifier for this currency.
    /// </summary>
    /// <example>"gold", "souls", "gems"</example>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the singular display name.
    /// </summary>
    /// <example>"Gold", "Soul", "Gem"</example>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the plural display name.
    /// </summary>
    /// <example>"Gold", "Souls", "Gems"</example>
    public string PluralName { get; init; } = string.Empty;

    /// <summary>
    /// Gets the symbol used for compact display.
    /// </summary>
    /// <example>"G", "S", "ðŸ’Ž"</example>
    public string Symbol { get; init; } = string.Empty;

    /// <summary>
    /// Gets the color used for displaying this currency.
    /// </summary>
    public string Color { get; init; } = "yellow";

    /// <summary>
    /// Gets the display sort order.
    /// </summary>
    public int SortOrder { get; init; } = 0;

    /// <summary>
    /// Creates a validated CurrencyDefinition.
    /// </summary>
    public static CurrencyDefinition Create(
        string id,
        string name,
        string pluralName,
        string symbol,
        string color = "yellow",
        int sortOrder = 0)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentException.ThrowIfNullOrWhiteSpace(pluralName);
        ArgumentException.ThrowIfNullOrWhiteSpace(symbol);

        return new CurrencyDefinition
        {
            Id = id.ToLowerInvariant(),
            Name = name,
            PluralName = pluralName,
            Symbol = symbol,
            Color = color,
            SortOrder = sortOrder
        };
    }

    /// <summary>
    /// Gets the appropriate display name based on amount.
    /// </summary>
    /// <param name="amount">The amount of currency.</param>
    /// <returns>Singular or plural name.</returns>
    public string GetDisplayName(int amount)
    {
        return amount == 1 ? Name : PluralName;
    }

    /// <summary>
    /// Gets the default Gold currency.
    /// </summary>
    public static CurrencyDefinition Gold => Create(
        "gold", "Gold", "Gold", "G", "yellow", 0);
}
```

#### LootTable

A configuration-driven loot table with weighted entries and currency drops.

**File:** `src/Core/RuneAndRust.Domain/Definitions/LootTable.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a loot table containing possible item and currency drops.
/// </summary>
/// <remarks>
/// Loot tables are embedded within MonsterDefinition and determine
/// what items and currency drop when a monster is defeated.
/// </remarks>
public class LootTable
{
    /// <summary>
    /// Gets the list of possible item drops.
    /// </summary>
    public IReadOnlyList<LootEntry> Entries { get; init; } = [];

    /// <summary>
    /// Gets the list of possible currency drops.
    /// </summary>
    public IReadOnlyList<CurrencyDrop> CurrencyDrops { get; init; } = [];

    /// <summary>
    /// Gets whether this loot table has any entries.
    /// </summary>
    public bool HasEntries => Entries.Count > 0 || CurrencyDrops.Count > 0;

    /// <summary>
    /// Gets an empty loot table.
    /// </summary>
    public static LootTable Empty => new();

    /// <summary>
    /// Creates a loot table with the specified entries.
    /// </summary>
    public static LootTable Create(
        IEnumerable<LootEntry>? entries = null,
        IEnumerable<CurrencyDrop>? currencyDrops = null)
    {
        return new LootTable
        {
            Entries = entries?.ToList() ?? [],
            CurrencyDrops = currencyDrops?.ToList() ?? []
        };
    }
}
```

### 2.2 New Value Objects

#### LootEntry

A single item entry in a loot table.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LootEntry.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a possible item drop in a loot table.
/// </summary>
/// <remarks>
/// Each entry has a drop chance (0.0-1.0) and a weight for
/// selection when multiple items could drop.
/// </remarks>
public readonly record struct LootEntry
{
    /// <summary>
    /// Gets the ID of the item to drop.
    /// </summary>
    /// <remarks>
    /// References an Item entity or ItemDefinition.
    /// </remarks>
    public string ItemId { get; init; }

    /// <summary>
    /// Gets the relative weight for selection among entries.
    /// </summary>
    /// <remarks>
    /// Higher weights are more likely to be selected when
    /// determining which item drops.
    /// </remarks>
    public int Weight { get; init; }

    /// <summary>
    /// Gets the minimum quantity to drop.
    /// </summary>
    public int MinQuantity { get; init; }

    /// <summary>
    /// Gets the maximum quantity to drop.
    /// </summary>
    public int MaxQuantity { get; init; }

    /// <summary>
    /// Gets the chance (0.0-1.0) that this entry drops at all.
    /// </summary>
    /// <remarks>
    /// 1.0 = always drops (if selected), 0.25 = 25% chance.
    /// </remarks>
    public float DropChance { get; init; }

    /// <summary>
    /// Creates a validated LootEntry.
    /// </summary>
    public static LootEntry Create(
        string itemId,
        int weight = 100,
        int minQuantity = 1,
        int maxQuantity = 1,
        float dropChance = 1.0f)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(itemId);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(weight);
        ArgumentOutOfRangeException.ThrowIfNegative(minQuantity);
        ArgumentOutOfRangeException.ThrowIfLessThan(maxQuantity, minQuantity);

        return new LootEntry
        {
            ItemId = itemId.ToLowerInvariant(),
            Weight = weight,
            MinQuantity = minQuantity,
            MaxQuantity = maxQuantity,
            DropChance = Math.Clamp(dropChance, 0f, 1f)
        };
    }
}
```

#### CurrencyDrop

A currency drop configuration in a loot table.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CurrencyDrop.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a possible currency drop in a loot table.
/// </summary>
public readonly record struct CurrencyDrop
{
    /// <summary>
    /// Gets the ID of the currency to drop.
    /// </summary>
    public string CurrencyId { get; init; }

    /// <summary>
    /// Gets the minimum amount to drop.
    /// </summary>
    public int MinAmount { get; init; }

    /// <summary>
    /// Gets the maximum amount to drop.
    /// </summary>
    public int MaxAmount { get; init; }

    /// <summary>
    /// Gets the chance (0.0-1.0) that this currency drops.
    /// </summary>
    public float DropChance { get; init; }

    /// <summary>
    /// Creates a validated CurrencyDrop.
    /// </summary>
    public static CurrencyDrop Create(
        string currencyId,
        int minAmount,
        int maxAmount,
        float dropChance = 1.0f)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(currencyId);
        ArgumentOutOfRangeException.ThrowIfNegative(minAmount);
        ArgumentOutOfRangeException.ThrowIfLessThan(maxAmount, minAmount);

        return new CurrencyDrop
        {
            CurrencyId = currencyId.ToLowerInvariant(),
            MinAmount = minAmount,
            MaxAmount = maxAmount,
            DropChance = Math.Clamp(dropChance, 0f, 1f)
        };
    }
}
```

#### LootDrop

The result of generating loot from a monster defeat.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LootDrop.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the generated loot from defeating a monster.
/// </summary>
public readonly record struct LootDrop
{
    /// <summary>
    /// Gets the items that dropped.
    /// </summary>
    public IReadOnlyList<DroppedItem> Items { get; init; }

    /// <summary>
    /// Gets the currency amounts that dropped.
    /// </summary>
    /// <remarks>
    /// Dictionary of currency ID to amount.
    /// </remarks>
    public IReadOnlyDictionary<string, int> Currency { get; init; }

    /// <summary>
    /// Gets whether this loot drop is empty.
    /// </summary>
    public bool IsEmpty => (Items == null || Items.Count == 0) &&
                          (Currency == null || Currency.Count == 0);

    /// <summary>
    /// Gets whether this drop contains any items.
    /// </summary>
    public bool HasItems => Items != null && Items.Count > 0;

    /// <summary>
    /// Gets whether this drop contains any currency.
    /// </summary>
    public bool HasCurrency => Currency != null && Currency.Count > 0;

    /// <summary>
    /// Gets an empty loot drop.
    /// </summary>
    public static LootDrop Empty => new()
    {
        Items = [],
        Currency = new Dictionary<string, int>()
    };

    /// <summary>
    /// Creates a loot drop with the specified contents.
    /// </summary>
    public static LootDrop Create(
        IEnumerable<DroppedItem>? items = null,
        IDictionary<string, int>? currency = null)
    {
        return new LootDrop
        {
            Items = items?.ToList() ?? [],
            Currency = currency != null
                ? new Dictionary<string, int>(currency)
                : new Dictionary<string, int>()
        };
    }

    /// <summary>
    /// Combines this loot drop with another.
    /// </summary>
    public LootDrop CombineWith(LootDrop other)
    {
        var combinedItems = new List<DroppedItem>(Items ?? []);
        if (other.Items != null)
        {
            combinedItems.AddRange(other.Items);
        }

        var combinedCurrency = new Dictionary<string, int>(Currency ?? new Dictionary<string, int>());
        if (other.Currency != null)
        {
            foreach (var kvp in other.Currency)
            {
                if (combinedCurrency.TryGetValue(kvp.Key, out var existing))
                {
                    combinedCurrency[kvp.Key] = existing + kvp.Value;
                }
                else
                {
                    combinedCurrency[kvp.Key] = kvp.Value;
                }
            }
        }

        return new LootDrop
        {
            Items = combinedItems,
            Currency = combinedCurrency
        };
    }
}

/// <summary>
/// Represents a single dropped item with quantity.
/// </summary>
public readonly record struct DroppedItem
{
    /// <summary>
    /// Gets the ID of the dropped item.
    /// </summary>
    public string ItemId { get; init; }

    /// <summary>
    /// Gets the display name of the item.
    /// </summary>
    public string Name { get; init; }

    /// <summary>
    /// Gets the quantity dropped.
    /// </summary>
    public int Quantity { get; init; }

    /// <summary>
    /// Creates a DroppedItem.
    /// </summary>
    public static DroppedItem Create(string itemId, string name, int quantity = 1)
    {
        return new DroppedItem
        {
            ItemId = itemId,
            Name = name,
            Quantity = quantity
        };
    }
}
```

### 2.3 Modified Definitions

#### MonsterDefinition (from v0.0.9a)

Add loot table reference.

**File:** `src/Core/RuneAndRust.Domain/Definitions/MonsterDefinition.cs`

**Add property:**

```csharp
/// <summary>
/// Gets the loot table for this monster type.
/// </summary>
/// <remarks>
/// Defines what items and currency drop when this monster is defeated.
/// Null means no loot drops.
/// </remarks>
public LootTable? LootTable { get; init; }
```

### 2.4 Modified Entities

#### Player

Add currency tracking to the player entity.

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

**Add properties and methods:**

```csharp
/// <summary>
/// Dictionary of currency amounts owned by the player.
/// </summary>
private readonly Dictionary<string, int> _currency = new(StringComparer.OrdinalIgnoreCase);

/// <summary>
/// Gets a read-only view of the player's currency.
/// </summary>
public IReadOnlyDictionary<string, int> Currency => _currency.AsReadOnly();

/// <summary>
/// Gets the amount of a specific currency the player has.
/// </summary>
/// <param name="currencyId">The currency ID.</param>
/// <returns>The amount, or 0 if the player has none.</returns>
public int GetCurrency(string currencyId)
{
    if (string.IsNullOrWhiteSpace(currencyId))
        return 0;

    return _currency.TryGetValue(currencyId.ToLowerInvariant(), out var amount)
        ? amount
        : 0;
}

/// <summary>
/// Adds currency to the player.
/// </summary>
/// <param name="currencyId">The currency ID.</param>
/// <param name="amount">The amount to add.</param>
/// <exception cref="ArgumentOutOfRangeException">Thrown when amount is negative.</exception>
public void AddCurrency(string currencyId, int amount)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(currencyId);
    ArgumentOutOfRangeException.ThrowIfNegative(amount);

    if (amount == 0) return;

    var id = currencyId.ToLowerInvariant();
    if (_currency.TryGetValue(id, out var current))
    {
        _currency[id] = current + amount;
    }
    else
    {
        _currency[id] = amount;
    }
}

/// <summary>
/// Removes currency from the player.
/// </summary>
/// <param name="currencyId">The currency ID.</param>
/// <param name="amount">The amount to remove.</param>
/// <returns>True if the player had enough currency; false otherwise.</returns>
public bool RemoveCurrency(string currencyId, int amount)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(currencyId);
    ArgumentOutOfRangeException.ThrowIfNegative(amount);

    if (amount == 0) return true;

    var id = currencyId.ToLowerInvariant();
    var current = GetCurrency(id);

    if (current < amount)
        return false;

    _currency[id] = current - amount;
    return true;
}

/// <summary>
/// Checks if the player can afford a specific amount of currency.
/// </summary>
/// <param name="currencyId">The currency ID.</param>
/// <param name="amount">The amount needed.</param>
/// <returns>True if the player has enough.</returns>
public bool CanAfford(string currencyId, int amount)
{
    return GetCurrency(currencyId) >= amount;
}
```

#### Room

Add dropped loot storage to rooms.

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

**Add fields and methods:**

```csharp
/// <summary>
/// List of items dropped as loot in this room.
/// </summary>
private readonly List<DroppedItem> _droppedItems = [];

/// <summary>
/// Dictionary of currency dropped in this room.
/// </summary>
private readonly Dictionary<string, int> _droppedCurrency = new(StringComparer.OrdinalIgnoreCase);

/// <summary>
/// Gets a read-only list of dropped items in this room.
/// </summary>
public IReadOnlyList<DroppedItem> DroppedItems => _droppedItems.AsReadOnly();

/// <summary>
/// Gets a read-only dictionary of dropped currency in this room.
/// </summary>
public IReadOnlyDictionary<string, int> DroppedCurrency => _droppedCurrency.AsReadOnly();

/// <summary>
/// Gets whether there is any uncollected loot in this room.
/// </summary>
public bool HasDroppedLoot => _droppedItems.Count > 0 || _droppedCurrency.Count > 0;

/// <summary>
/// Adds a loot drop to this room.
/// </summary>
/// <param name="loot">The loot to add.</param>
public void AddLoot(LootDrop loot)
{
    if (loot.IsEmpty) return;

    // Add items
    if (loot.Items != null)
    {
        _droppedItems.AddRange(loot.Items);
    }

    // Add currency
    if (loot.Currency != null)
    {
        foreach (var kvp in loot.Currency)
        {
            if (_droppedCurrency.TryGetValue(kvp.Key, out var existing))
            {
                _droppedCurrency[kvp.Key] = existing + kvp.Value;
            }
            else
            {
                _droppedCurrency[kvp.Key] = kvp.Value;
            }
        }
    }
}

/// <summary>
/// Collects all dropped loot from this room.
/// </summary>
/// <returns>The collected loot, or empty if none.</returns>
public LootDrop CollectAllLoot()
{
    if (!HasDroppedLoot)
        return LootDrop.Empty;

    var loot = LootDrop.Create(
        _droppedItems.ToList(),
        new Dictionary<string, int>(_droppedCurrency));

    _droppedItems.Clear();
    _droppedCurrency.Clear();

    return loot;
}

/// <summary>
/// Clears all dropped loot from this room without collecting it.
/// </summary>
public void ClearDroppedLoot()
{
    _droppedItems.Clear();
    _droppedCurrency.Clear();
}
```

---

## 3. Service Interfaces

### 3.1 ILootService

**File:** `src/Core/RuneAndRust.Application/Interfaces/ILootService.cs`

```csharp
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for generating and managing loot drops.
/// </summary>
public interface ILootService
{
    /// <summary>
    /// Generates loot from a defeated monster.
    /// </summary>
    /// <param name="monster">The defeated monster.</param>
    /// <returns>The generated loot drop.</returns>
    LootDrop GenerateLoot(Monster monster);

    /// <summary>
    /// Generates loot from a monster definition with tier multiplier.
    /// </summary>
    /// <param name="definition">The monster definition.</param>
    /// <param name="lootMultiplier">The tier-based loot multiplier.</param>
    /// <returns>The generated loot drop.</returns>
    LootDrop GenerateLoot(MonsterDefinition definition, float lootMultiplier);

    /// <summary>
    /// Collects all loot from a room and gives it to the player.
    /// </summary>
    /// <param name="player">The player collecting loot.</param>
    /// <param name="room">The room to collect from.</param>
    /// <returns>The collected loot, or empty if none available.</returns>
    LootDrop CollectLoot(Player player, Room room);

    /// <summary>
    /// Gets a currency definition by ID.
    /// </summary>
    /// <param name="currencyId">The currency ID.</param>
    /// <returns>The currency definition, or null if not found.</returns>
    CurrencyDefinition? GetCurrency(string currencyId);

    /// <summary>
    /// Gets all currency definitions.
    /// </summary>
    /// <returns>Read-only list of all currency definitions.</returns>
    IReadOnlyList<CurrencyDefinition> GetAllCurrencies();
}
```

### 3.2 IGameConfigurationProvider Updates

**File:** `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs`

**Add to interface:**

```csharp
/// <summary>
/// Gets all currency definitions.
/// </summary>
/// <returns>Read-only list of currency definitions.</returns>
IReadOnlyList<CurrencyDefinition> GetCurrencies();

/// <summary>
/// Gets a currency definition by ID.
/// </summary>
/// <param name="currencyId">The currency identifier.</param>
/// <returns>The currency definition or null if not found.</returns>
CurrencyDefinition? GetCurrencyById(string currencyId);
```

---

## 4. Service Implementations

### 4.1 LootService

**File:** `src/Core/RuneAndRust.Application/Services/LootService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for generating and managing loot drops.
/// </summary>
public class LootService : ILootService
{
    private readonly ILogger<LootService> _logger;
    private readonly IGameConfigurationProvider _configProvider;
    private readonly IMonsterService _monsterService;
    private readonly Random _random;

    public LootService(
        ILogger<LootService> logger,
        IGameConfigurationProvider configProvider,
        IMonsterService monsterService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _monsterService = monsterService ?? throw new ArgumentNullException(nameof(monsterService));
        _random = new Random();
    }

    /// <summary>
    /// Constructor for testing with specific random instance.
    /// </summary>
    internal LootService(
        ILogger<LootService> logger,
        IGameConfigurationProvider configProvider,
        IMonsterService monsterService,
        Random random)
    {
        _logger = logger;
        _configProvider = configProvider;
        _monsterService = monsterService;
        _random = random;
    }

    /// <inheritdoc />
    public LootDrop GenerateLoot(Monster monster)
    {
        ArgumentNullException.ThrowIfNull(monster);

        if (string.IsNullOrEmpty(monster.DefinitionId))
        {
            _logger.LogDebug("Monster {Name} has no definition, no loot generated", monster.Name);
            return LootDrop.Empty;
        }

        var definition = _monsterService.GetDefinition(monster.DefinitionId);
        if (definition == null)
        {
            _logger.LogWarning("Monster definition {Id} not found", monster.DefinitionId);
            return LootDrop.Empty;
        }

        return GenerateLoot(definition, monster.LootMultiplier);
    }

    /// <inheritdoc />
    public LootDrop GenerateLoot(MonsterDefinition definition, float lootMultiplier)
    {
        ArgumentNullException.ThrowIfNull(definition);

        if (definition.LootTable == null || !definition.LootTable.HasEntries)
        {
            _logger.LogDebug("Monster {Id} has no loot table", definition.Id);
            return LootDrop.Empty;
        }

        var items = GenerateItemDrops(definition.LootTable, lootMultiplier);
        var currency = GenerateCurrencyDrops(definition.LootTable, lootMultiplier);

        var loot = LootDrop.Create(items, currency);

        _logger.LogDebug(
            "Generated loot for {Monster}: {ItemCount} items, {CurrencyCount} currency types (multiplier: {Multiplier}x)",
            definition.Name, items.Count, currency.Count, lootMultiplier);

        return loot;
    }

    /// <inheritdoc />
    public LootDrop CollectLoot(Player player, Room room)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(room);

        if (!room.HasDroppedLoot)
        {
            _logger.LogDebug("No loot to collect in room {Room}", room.Name);
            return LootDrop.Empty;
        }

        var loot = room.CollectAllLoot();

        // Add currency to player
        foreach (var kvp in loot.Currency)
        {
            player.AddCurrency(kvp.Key, kvp.Value);
            _logger.LogDebug("Player collected {Amount} {Currency}", kvp.Value, kvp.Key);
        }

        // Add items to player inventory
        // Note: In a full implementation, items would be created and added to inventory
        // For now, we just log the collection
        foreach (var item in loot.Items)
        {
            _logger.LogDebug("Player collected {Quantity}x {Item}", item.Quantity, item.Name);
            // TODO: Create actual Item entities and add to player.Inventory
        }

        _logger.LogInformation(
            "Player {Player} collected loot: {Items} items, {Currency} currency",
            player.Name,
            loot.Items.Count,
            loot.Currency.Sum(c => c.Value));

        return loot;
    }

    /// <inheritdoc />
    public CurrencyDefinition? GetCurrency(string currencyId)
    {
        if (string.IsNullOrWhiteSpace(currencyId))
            return null;

        return _configProvider.GetCurrencyById(currencyId.ToLowerInvariant());
    }

    /// <inheritdoc />
    public IReadOnlyList<CurrencyDefinition> GetAllCurrencies()
    {
        return _configProvider.GetCurrencies();
    }

    private List<DroppedItem> GenerateItemDrops(LootTable lootTable, float multiplier)
    {
        var items = new List<DroppedItem>();

        foreach (var entry in lootTable.Entries)
        {
            // Apply multiplier to drop chance
            var adjustedChance = Math.Min(1.0f, entry.DropChance * multiplier);

            // Roll for drop
            if (_random.NextSingle() > adjustedChance)
                continue;

            // Determine quantity
            var baseQuantity = _random.Next(entry.MinQuantity, entry.MaxQuantity + 1);
            var quantity = Math.Max(1, (int)Math.Round(baseQuantity * multiplier));

            // Get item name (would use ItemService in full implementation)
            var itemName = GetItemDisplayName(entry.ItemId);

            items.Add(DroppedItem.Create(entry.ItemId, itemName, quantity));

            _logger.LogDebug(
                "Item drop: {Item} x{Quantity} (chance: {Chance}%, rolled)",
                itemName, quantity, adjustedChance * 100);
        }

        return items;
    }

    private Dictionary<string, int> GenerateCurrencyDrops(LootTable lootTable, float multiplier)
    {
        var currency = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        foreach (var drop in lootTable.CurrencyDrops)
        {
            // Roll for drop
            if (_random.NextSingle() > drop.DropChance)
                continue;

            // Calculate amount with multiplier
            var baseAmount = _random.Next(drop.MinAmount, drop.MaxAmount + 1);
            var amount = (int)Math.Round(baseAmount * multiplier);

            if (amount > 0)
            {
                if (currency.TryGetValue(drop.CurrencyId, out var existing))
                {
                    currency[drop.CurrencyId] = existing + amount;
                }
                else
                {
                    currency[drop.CurrencyId] = amount;
                }

                _logger.LogDebug(
                    "Currency drop: {Amount} {Currency} (base: {Base}, multiplier: {Mult}x)",
                    amount, drop.CurrencyId, baseAmount, multiplier);
            }
        }

        return currency;
    }

    private string GetItemDisplayName(string itemId)
    {
        // In a full implementation, this would look up the item definition
        // For now, convert ID to display name
        return itemId
            .Replace("_", " ")
            .Split(' ')
            .Select(w => char.ToUpper(w[0]) + w[1..].ToLower())
            .Aggregate((a, b) => $"{a} {b}");
    }
}
```

---

## 5. Command Implementation

### 5.1 Loot Command

The `loot` or `take` command collects dropped loot from the current room.

**Integration in GameSessionService:**

```csharp
private async Task<string> HandleLootCommand(GameSession session)
{
    var room = session.CurrentRoom;

    if (!room.HasDroppedLoot)
    {
        return "There is nothing to collect here.";
    }

    var loot = _lootService.CollectLoot(session.Player, room);

    if (loot.IsEmpty)
    {
        return "There is nothing to collect here.";
    }

    var sb = new StringBuilder();
    sb.AppendLine("You collected:");

    // List items
    foreach (var item in loot.Items)
    {
        if (item.Quantity > 1)
        {
            sb.AppendLine($"  â€¢ {item.Name} x{item.Quantity}");
        }
        else
        {
            sb.AppendLine($"  â€¢ {item.Name}");
        }
    }

    // List currency
    foreach (var kvp in loot.Currency)
    {
        var currencyDef = _lootService.GetCurrency(kvp.Key);
        var name = currencyDef?.GetDisplayName(kvp.Value) ?? kvp.Key;
        sb.AppendLine($"  â€¢ {kvp.Value} {name}");
    }

    // Show new gold total
    var goldAmount = session.Player.GetCurrency("gold");
    if (goldAmount > 0)
    {
        sb.AppendLine();
        sb.AppendLine($"Your gold: {goldAmount}");
    }

    return sb.ToString();
}
```

---

## 6. Configuration

### 6.1 Currency Configuration

**File:** `config/currency.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "currencies": [
    {
      "id": "gold",
      "name": "Gold",
      "pluralName": "Gold",
      "symbol": "G",
      "color": "yellow",
      "sortOrder": 0
    }
  ]
}
```

### 6.2 Monster Loot Tables

**File:** `config/monsters.json` (updated with loot tables)

```json
{
  "monsters": [
    {
      "id": "goblin",
      "name": "Goblin",
      "description": "A small, green creature with sharp teeth and beady eyes.",
      "examineText": "This goblin clutches a rusty dagger...",
      "baseHealth": 30,
      "baseAttack": 8,
      "baseDefense": 2,
      "baseExperienceValue": 25,
      "aiBehavior": "Aggressive",
      "tags": ["humanoid"],
      "spawnWeight": 100,
      "baseResistances": {},
      "possibleTiers": ["common", "named"],
      "possibleTraits": ["berserker"],
      "lootTable": {
        "currencyDrops": [
          { "currencyId": "gold", "minAmount": 5, "maxAmount": 15, "dropChance": 0.8 }
        ],
        "entries": [
          { "itemId": "health_potion", "weight": 30, "minQuantity": 1, "maxQuantity": 1, "dropChance": 0.15 },
          { "itemId": "rusty_dagger", "weight": 10, "minQuantity": 1, "maxQuantity": 1, "dropChance": 0.05 }
        ]
      }
    },
    {
      "id": "skeleton",
      "name": "Skeleton",
      "description": "An animated pile of bones held together by dark magic.",
      "examineText": "Dark magic holds these bones together...",
      "baseHealth": 25,
      "baseAttack": 10,
      "baseDefense": 1,
      "baseExperienceValue": 30,
      "aiBehavior": "Aggressive",
      "tags": ["undead"],
      "spawnWeight": 80,
      "baseResistances": {
        "physical": 25,
        "fire": -50,
        "poison": 100,
        "holy": -50,
        "dark": 50
      },
      "possibleTiers": ["common", "named", "elite"],
      "possibleTraits": [],
      "lootTable": {
        "currencyDrops": [
          { "currencyId": "gold", "minAmount": 8, "maxAmount": 20, "dropChance": 0.9 }
        ],
        "entries": [
          { "itemId": "bone_dust", "weight": 50, "minQuantity": 1, "maxQuantity": 3, "dropChance": 0.3 },
          { "itemId": "ancient_coin", "weight": 20, "minQuantity": 1, "maxQuantity": 1, "dropChance": 0.1 }
        ]
      }
    },
    {
      "id": "orc",
      "name": "Orc",
      "description": "A hulking, brutish warrior with green skin and tusks.",
      "examineText": "This orc towers over you, muscles rippling...",
      "baseHealth": 50,
      "baseAttack": 12,
      "baseDefense": 4,
      "baseExperienceValue": 50,
      "aiBehavior": "Aggressive",
      "tags": ["humanoid"],
      "spawnWeight": 50,
      "baseResistances": {},
      "possibleTiers": ["common", "named", "elite", "boss"],
      "possibleTraits": ["berserker", "armored"],
      "lootTable": {
        "currencyDrops": [
          { "currencyId": "gold", "minAmount": 15, "maxAmount": 35, "dropChance": 1.0 }
        ],
        "entries": [
          { "itemId": "health_potion", "weight": 30, "minQuantity": 1, "maxQuantity": 2, "dropChance": 0.25 },
          { "itemId": "iron_sword", "weight": 15, "minQuantity": 1, "maxQuantity": 1, "dropChance": 0.10 },
          { "itemId": "orcish_helm", "weight": 5, "minQuantity": 1, "maxQuantity": 1, "dropChance": 0.05 }
        ]
      }
    },
    {
      "id": "giant_spider",
      "name": "Giant Spider",
      "description": "A horse-sized spider with glistening fangs.",
      "examineText": "Eight multi-faceted eyes gleam...",
      "baseHealth": 20,
      "baseAttack": 6,
      "baseDefense": 1,
      "baseExperienceValue": 20,
      "aiBehavior": "Defensive",
      "tags": ["beast"],
      "spawnWeight": 60,
      "baseResistances": {},
      "possibleTiers": ["common", "named", "elite"],
      "possibleTraits": ["venomous"],
      "lootTable": {
        "currencyDrops": [
          { "currencyId": "gold", "minAmount": 3, "maxAmount": 10, "dropChance": 0.5 }
        ],
        "entries": [
          { "itemId": "spider_silk", "weight": 60, "minQuantity": 1, "maxQuantity": 3, "dropChance": 0.4 },
          { "itemId": "venom_sac", "weight": 20, "minQuantity": 1, "maxQuantity": 1, "dropChance": 0.15 }
        ]
      }
    },
    {
      "id": "slime",
      "name": "Slime",
      "description": "A quivering mass of translucent, acidic gel.",
      "examineText": "This gelatinous creature pulses and wobbles...",
      "baseHealth": 40,
      "baseAttack": 4,
      "baseDefense": 0,
      "baseExperienceValue": 15,
      "aiBehavior": "Chaotic",
      "tags": ["ooze"],
      "spawnWeight": 40,
      "baseResistances": {
        "physical": 50,
        "fire": -25,
        "ice": -25,
        "lightning": -50,
        "poison": 100
      },
      "possibleTiers": ["common", "named"],
      "possibleTraits": ["regenerating"],
      "lootTable": {
        "currencyDrops": [
          { "currencyId": "gold", "minAmount": 1, "maxAmount": 5, "dropChance": 0.3 }
        ],
        "entries": [
          { "itemId": "slime_residue", "weight": 70, "minQuantity": 1, "maxQuantity": 2, "dropChance": 0.5 }
        ]
      }
    }
  ]
}
```

### 6.3 Configuration DTOs

**File:** `src/Core/RuneAndRust.Application/Configuration/CurrencyConfigurationDto.cs`

```csharp
using System.Text.Json.Serialization;

namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Root configuration object for currency.json.
/// </summary>
public class CurrencyConfiguration
{
    [JsonPropertyName("currencies")]
    public List<CurrencyDefinitionDto> Currencies { get; set; } = [];
}

/// <summary>
/// DTO for deserializing currency definitions from JSON.
/// </summary>
public class CurrencyDefinitionDto
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;

    [JsonPropertyName("name")]
    public string Name { get; set; } = string.Empty;

    [JsonPropertyName("pluralName")]
    public string PluralName { get; set; } = string.Empty;

    [JsonPropertyName("symbol")]
    public string Symbol { get; set; } = string.Empty;

    [JsonPropertyName("color")]
    public string Color { get; set; } = "yellow";

    [JsonPropertyName("sortOrder")]
    public int SortOrder { get; set; } = 0;
}
```

**File:** `src/Core/RuneAndRust.Application/Configuration/LootTableDto.cs`

```csharp
using System.Text.Json.Serialization;

namespace RuneAndRust.Application.Configuration;

/// <summary>
/// DTO for deserializing loot tables from JSON.
/// </summary>
public class LootTableDto
{
    [JsonPropertyName("currencyDrops")]
    public List<CurrencyDropDto> CurrencyDrops { get; set; } = [];

    [JsonPropertyName("entries")]
    public List<LootEntryDto> Entries { get; set; } = [];
}

/// <summary>
/// DTO for deserializing loot entries.
/// </summary>
public class LootEntryDto
{
    [JsonPropertyName("itemId")]
    public string ItemId { get; set; } = string.Empty;

    [JsonPropertyName("weight")]
    public int Weight { get; set; } = 100;

    [JsonPropertyName("minQuantity")]
    public int MinQuantity { get; set; } = 1;

    [JsonPropertyName("maxQuantity")]
    public int MaxQuantity { get; set; } = 1;

    [JsonPropertyName("dropChance")]
    public float DropChance { get; set; } = 1.0f;
}

/// <summary>
/// DTO for deserializing currency drops.
/// </summary>
public class CurrencyDropDto
{
    [JsonPropertyName("currencyId")]
    public string CurrencyId { get; set; } = string.Empty;

    [JsonPropertyName("minAmount")]
    public int MinAmount { get; set; } = 0;

    [JsonPropertyName("maxAmount")]
    public int MaxAmount { get; set; } = 0;

    [JsonPropertyName("dropChance")]
    public float DropChance { get; set; } = 1.0f;
}
```

**Update MonsterDefinitionDto:**

```csharp
// Add to existing MonsterDefinitionDto class
[JsonPropertyName("lootTable")]
public LootTableDto? LootTable { get; set; }
```

---

## 7. Rendering Changes

### 7.1 Combat Victory with Loot

**Update combat result rendering:**

```csharp
public Task RenderCombatVictoryWithLootAsync(
    string monsterName,
    int experienceGained,
    LootDrop loot,
    CancellationToken ct = default)
{
    AnsiConsole.MarkupLine($"[green]The {monsterName} has been defeated![/]");
    AnsiConsole.MarkupLine($"[yellow]â˜…[/] You gained [green]{experienceGained} XP[/]!");

    if (!loot.IsEmpty)
    {
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[yellow]Loot dropped:[/]");

        // Currency
        foreach (var kvp in loot.Currency)
        {
            var currency = _lootService.GetCurrency(kvp.Key);
            var color = currency?.Color ?? "yellow";
            var name = currency?.GetDisplayName(kvp.Value) ?? kvp.Key;
            AnsiConsole.MarkupLine($"  â€¢ [{color}]{kvp.Value} {name}[/]");
        }

        // Items
        foreach (var item in loot.Items)
        {
            if (item.Quantity > 1)
            {
                AnsiConsole.MarkupLine($"  â€¢ {item.Name} x{item.Quantity}");
            }
            else
            {
                AnsiConsole.MarkupLine($"  â€¢ {item.Name}");
            }
        }

        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[dim]Use 'loot' or 'take' to collect.[/]");
    }

    return Task.CompletedTask;
}
```

### 7.2 Room Display with Dropped Loot

**Update room rendering:**

```csharp
private void RenderDroppedLoot(Room room)
{
    if (!room.HasDroppedLoot) return;

    AnsiConsole.WriteLine();
    AnsiConsole.MarkupLine("[yellow]Dropped loot:[/]");

    // Currency
    foreach (var kvp in room.DroppedCurrency)
    {
        var currency = _lootService.GetCurrency(kvp.Key);
        var color = currency?.Color ?? "yellow";
        var name = currency?.GetDisplayName(kvp.Value) ?? kvp.Key;
        AnsiConsole.MarkupLine($"  â€¢ [{color}]{kvp.Value} {name}[/]");
    }

    // Items
    foreach (var item in room.DroppedItems)
    {
        if (item.Quantity > 1)
        {
            AnsiConsole.MarkupLine($"  â€¢ {item.Name} x{item.Quantity}");
        }
        else
        {
            AnsiConsole.MarkupLine($"  â€¢ {item.Name}");
        }
    }
}
```

### 7.3 Status with Currency

**Update status rendering:**

```csharp
private void RenderPlayerCurrency(Player player)
{
    var gold = player.GetCurrency("gold");
    if (gold > 0)
    {
        AnsiConsole.MarkupLine($"[yellow]Gold:[/] {gold}");
    }
}
```

### 7.4 Display Examples

**Combat Victory with Loot:**
```
The Orc has been defeated!
â˜… You gained 50 XP!

Loot dropped:
  â€¢ 23 Gold
  â€¢ Health Potion

Use 'loot' or 'take' to collect.
```

**Loot Command:**
```
> loot

You collected:
  â€¢ 23 Gold
  â€¢ Health Potion

Your gold: 143
```

**Room with Dropped Loot:**
```
You enter the Goblin Camp.
A small clearing with crude tents and a smoldering fire pit.

Dropped loot:
  â€¢ 12 Gold
  â€¢ Rusty Dagger

Exits: north, east, west
```

**Status with Currency:**
```
> status

=== Hero (Level 3 Warrior) ===
HP: 110/110
XP: 380/500 (76%)
Gold: 143
Attack: 14  Defense: 11
```

---

## 8. Acceptance Criteria

### 8.1 Functional Requirements

- [ ] Currency definitions load from `config/currency.json`
- [ ] Default Gold currency defined and functional
- [ ] Loot tables load from monster definitions in `config/monsters.json`
- [ ] `LootService.GenerateLoot(monster)` produces correct drops
- [ ] Tier multiplier (from v0.0.9c) affects currency amounts
- [ ] Tier multiplier affects item drop chances
- [ ] Loot drops to room on monster defeat
- [ ] Dropped loot displays in room description
- [ ] `loot` / `take` command collects all dropped loot
- [ ] Collected currency adds to player total
- [ ] Player currency displays in status command
- [ ] Uncollected loot persists in room
- [ ] Empty loot tables produce no drops
- [ ] Drop chance properly rolls (0.25 = 25% chance)

### 8.2 Non-Functional Requirements

- [ ] Configuration loading is performant (cached after first load)
- [ ] Invalid configuration produces clear error messages
- [ ] Services are testable with mock dependencies

---

## 9. Test Specifications

### 9.1 CurrencyDefinition Tests (~2 tests)

| Test Name | Description |
|-----------|-------------|
| `Create_ValidInput_ReturnsCurrencyDefinition` | Valid parameters create currency |
| `GetDisplayName_ReturnsCorrectForm` | Singular/plural names correct |

### 9.2 LootDrop Tests (~3 tests)

| Test Name | Description |
|-----------|-------------|
| `Empty_HasCorrectProperties` | Empty drop has no items/currency |
| `Create_WithItems_StoresCorrectly` | Items stored correctly |
| `CombineWith_MergesLoot` | Two drops combine properly |

### 9.3 LootService Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `GenerateLoot_NoLootTable_ReturnsEmpty` | No table returns empty |
| `GenerateLoot_AppliesTierMultiplier` | Multiplier affects currency amount |
| `GenerateLoot_RollsDropChance` | Low chance items don't always drop |
| `GenerateLoot_RespectsCurrencyRange` | Currency within min/max range |
| `CollectLoot_AddsCurrencyToPlayer` | Player gains currency |
| `CollectLoot_ClearsRoomLoot` | Room loot cleared after collection |

### 9.4 Player Currency Tests (~3 tests)

| Test Name | Description |
|-----------|-------------|
| `AddCurrency_IncreasesAmount` | Adding currency works |
| `RemoveCurrency_DecreasesAmount` | Removing currency works |
| `RemoveCurrency_InsufficientFunds_ReturnsFalse` | Can't remove more than have |

### 9.5 Room Loot Tests (~2 tests)

| Test Name | Description |
|-----------|-------------|
| `AddLoot_StoresLoot` | Loot added to room |
| `CollectAllLoot_ClearsAndReturns` | Collection clears room |

---

## 10. Dependencies

### 10.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| MonsterDefinition | v0.0.9a | Required | Extended with LootTable |
| MonsterService | v0.0.9a | Required | Get definition for loot lookup |
| Monster.LootMultiplier | v0.0.9c | Required | Tier-based loot scaling |
| Room entity | v0.0.1 | Complete | Extended with dropped loot storage |
| Player entity | v0.0.1 | Complete | Extended with currency tracking |
| Configuration system | v0.0.3 | Complete | JSON loading infrastructure |

### 10.2 External Dependencies

None new - uses existing System.Text.Json for configuration loading.

---

## 11. Files Summary

### 11.1 New Files

| File | Purpose |
|------|---------|
| `src/Core/RuneAndRust.Domain/Definitions/CurrencyDefinition.cs` | Currency entity |
| `src/Core/RuneAndRust.Domain/Definitions/LootTable.cs` | Loot table entity |
| `src/Core/RuneAndRust.Domain/ValueObjects/LootEntry.cs` | Loot entry value object |
| `src/Core/RuneAndRust.Domain/ValueObjects/CurrencyDrop.cs` | Currency drop value object |
| `src/Core/RuneAndRust.Domain/ValueObjects/LootDrop.cs` | Loot drop result value object |
| `src/Core/RuneAndRust.Application/Interfaces/ILootService.cs` | Loot service interface |
| `src/Core/RuneAndRust.Application/Services/LootService.cs` | Loot service implementation |
| `src/Core/RuneAndRust.Application/Configuration/CurrencyConfigurationDto.cs` | Currency config DTOs |
| `src/Core/RuneAndRust.Application/Configuration/LootTableDto.cs` | Loot table config DTOs |
| `config/currency.json` | Currency definitions |
| `tests/RuneAndRust.Domain.Tests/ValueObjects/LootDropTests.cs` | LootDrop tests |
| `tests/RuneAndRust.Application.Tests/Services/LootServiceTests.cs` | LootService tests |

### 11.2 Modified Files

| File | Changes |
|------|---------|
| `MonsterDefinition.cs` | Add LootTable property |
| `MonsterDefinitionDto.cs` | Add LootTable JSON property |
| `Player.cs` | Add currency tracking (Dictionary, methods) |
| `Room.cs` | Add dropped loot storage and collection |
| `IGameConfigurationProvider.cs` | Add GetCurrencies, GetCurrencyById |
| `JsonConfigurationProvider.cs` | Implement currency and loot table loading |
| `GameSessionService.cs` | Add loot command handling, loot on combat victory |
| `SpectreGameRenderer.cs` | Display loot drops, room loot, player currency |
| `config/monsters.json` | Add lootTable to each monster |

---

## 12. Future Considerations

### 12.1 Shop System

Future shop/vendor features would use:
- `Player.GetCurrency()` to check affordability
- `Player.RemoveCurrency()` for purchases
- `CurrencyDefinition` for display

### 12.2 Item Definitions

A future ItemDefinition system would:
- Replace hardcoded item names in loot tables
- Enable procedurally generated item stats
- Support item quality tiers (common, rare, epic, legendary)

### 12.3 Crafting System

Future crafting would use:
- Loot materials (spider silk, bone dust, etc.)
- Multiple currency types
- Item recipes

---

## 13. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Loot balance too generous/stingy | High | Medium | Start conservative, iterate based on testing |
| Item IDs don't match actual items | Medium | Medium | Validate IDs during config loading |
| Currency overflow at high amounts | Low | Low | Use int (2B max), monitor |
| Performance with many loot drops | Low | Low | Simple calculations, no complex logic |
| Breaking changes to Room/Player | Low | Medium | Add properties, don't modify existing |

---

## 14. Integration Points

### 14.1 Combat Flow Integration

```csharp
// In GameSessionService after monster defeat:
if (monster.IsDefeated)
{
    // Award XP (existing)
    player.AddExperience(monster.ExperienceValue);

    // Generate and drop loot (NEW)
    var loot = _lootService.GenerateLoot(monster);
    room.AddLoot(loot);

    // Render victory with loot
    await _renderer.RenderCombatVictoryWithLootAsync(
        monster.DisplayName,
        monster.ExperienceValue,
        loot);
}
```

### 14.2 Command Registration

```csharp
// Add command aliases
_commands["loot"] = HandleLootCommand;
_commands["take"] = HandleLootCommand;
_commands["collect"] = HandleLootCommand;
```

---

*This design specification completes the v0.0.9 Monster Variety & Loot system, providing a rewarding combat loop with currency and item drops that scale with monster difficulty.*
