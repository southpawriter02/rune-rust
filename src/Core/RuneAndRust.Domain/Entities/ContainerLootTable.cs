using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a container instance in the game world with its loot state.
/// </summary>
/// <remarks>
/// <para>
/// The <see cref="ContainerLootTable"/> entity tracks the lifecycle of a container from
/// placement through looting. Contents are lazily generated on first access
/// via the container loot service (v0.16.4d).
/// </para>
/// <para>
/// State transitions follow a defined flow:
/// <list type="bullet">
/// <item>Undiscovered → Discovered (via <see cref="Discover"/>)</item>
/// <item>Discovered → Open (via <see cref="Open"/>) or Locked (initial for locked containers)</item>
/// <item>Locked → Open (via <see cref="Unlock"/>)</item>
/// <item>Open → Looted (via <see cref="Loot"/>)</item>
/// </list>
/// </para>
/// <para>
/// Once looted, a container returns empty contents on subsequent access and cannot
/// be looted again within the same game run.
/// </para>
/// </remarks>
public class ContainerLootTable : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this container instance.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the type of container (e.g., SmallChest, HiddenCache).
    /// </summary>
    /// <remarks>
    /// The container type determines loot generation parameters including
    /// item count range, quality tier range, and currency amounts.
    /// </remarks>
    public ContainerType Type { get; private set; }

    /// <summary>
    /// Gets the current state of the container in its lifecycle.
    /// </summary>
    /// <remarks>
    /// State changes are managed through the entity's transition methods:
    /// <see cref="Discover"/>, <see cref="Unlock"/>, <see cref="Open"/>, and <see cref="Loot"/>.
    /// </remarks>
    public ContainerLootState State { get; private set; }

    /// <summary>
    /// Gets the contents of the container, if generated.
    /// </summary>
    /// <remarks>
    /// <para>
    /// <c>null</c> until contents are generated by the loot service via <see cref="SetContents"/>.
    /// After looting, this preserves the original contents for reference/logging purposes
    /// but <see cref="Loot"/> and <see cref="GetDisplayContents"/> return empty.
    /// </para>
    /// </remarks>
    public ContainerContents? Contents { get; private set; }

    /// <summary>
    /// Gets the room ID where this container is located.
    /// </summary>
    /// <remarks>
    /// Used for persistence and room integration (v0.16.4e, v0.16.4f).
    /// May be <c>null</c> for containers not yet placed in a room.
    /// </remarks>
    public Guid? RoomId { get; private set; }

    /// <summary>
    /// Gets the UTC timestamp when this container was looted.
    /// </summary>
    /// <remarks>
    /// <c>null</c> until the container is looted. Used for persistence
    /// and analytics purposes.
    /// </remarks>
    public DateTime? LootedAt { get; private set; }

    /// <summary>
    /// Gets whether this container has been looted.
    /// </summary>
    /// <value>
    /// <c>true</c> if <see cref="State"/> is <see cref="ContainerLootState.Looted"/>;
    /// otherwise, <c>false</c>.
    /// </value>
    public bool IsLooted => State == ContainerLootState.Looted;

    /// <summary>
    /// Gets whether this container can be looted in its current state.
    /// </summary>
    /// <value>
    /// <c>true</c> if <see cref="State"/> is <see cref="ContainerLootState.Open"/>;
    /// otherwise, <c>false</c>.
    /// </value>
    public bool CanLoot => State == ContainerLootState.Open;

    /// <summary>
    /// Gets whether this container needs to be discovered first.
    /// </summary>
    /// <value>
    /// <c>true</c> if <see cref="State"/> is <see cref="ContainerLootState.Undiscovered"/>;
    /// otherwise, <c>false</c>.
    /// </value>
    public bool NeedsDiscovery => State == ContainerLootState.Undiscovered;

    /// <summary>
    /// Gets whether this container is locked.
    /// </summary>
    /// <value>
    /// <c>true</c> if <see cref="State"/> is <see cref="ContainerLootState.Locked"/>;
    /// otherwise, <c>false</c>.
    /// </value>
    public bool IsLocked => State == ContainerLootState.Locked;

    /// <summary>
    /// Gets whether contents have been generated for this container.
    /// </summary>
    /// <value>
    /// <c>true</c> if <see cref="Contents"/> has a value; otherwise, <c>false</c>.
    /// </value>
    public bool HasGeneratedContents => Contents.HasValue;

    /// <summary>
    /// Private constructor for EF Core and internal use.
    /// </summary>
    private ContainerLootTable()
    {
    }

    /// <summary>
    /// Creates a new container loot table instance.
    /// </summary>
    /// <param name="type">The type of container (determines loot parameters).</param>
    /// <param name="initialState">
    /// The initial state of the container. Defaults to <see cref="ContainerLootState.Discovered"/>.
    /// </param>
    /// <param name="roomId">Optional room ID where container is located.</param>
    /// <returns>A new <see cref="ContainerLootTable"/> instance.</returns>
    /// <example>
    /// <code>
    /// var chest = ContainerLootTable.Create(ContainerType.SmallChest);
    /// var bossChest = ContainerLootTable.Create(
    ///     ContainerType.BossChest,
    ///     roomId: bossRoomId);
    /// </code>
    /// </example>
    public static ContainerLootTable Create(
        ContainerType type,
        ContainerLootState initialState = ContainerLootState.Discovered,
        Guid? roomId = null)
    {
        return new ContainerLootTable
        {
            Id = Guid.NewGuid(),
            Type = type,
            State = initialState,
            Contents = null,
            RoomId = roomId,
            LootedAt = null
        };
    }

    /// <summary>
    /// Creates a hidden container that must be discovered via perception check.
    /// </summary>
    /// <param name="type">
    /// The type of container. Typically <see cref="ContainerType.HiddenCache"/>
    /// but any type can be hidden.
    /// </param>
    /// <param name="roomId">Optional room ID where container is located.</param>
    /// <returns>
    /// A new <see cref="ContainerLootTable"/> in <see cref="ContainerLootState.Undiscovered"/> state.
    /// </returns>
    /// <example>
    /// <code>
    /// var hiddenCache = ContainerLootTable.CreateHidden(
    ///     ContainerType.HiddenCache,
    ///     roomId: secretRoomId);
    /// </code>
    /// </example>
    public static ContainerLootTable CreateHidden(
        ContainerType type,
        Guid? roomId = null)
    {
        return Create(type, ContainerLootState.Undiscovered, roomId);
    }

    /// <summary>
    /// Creates a locked container that must be unlocked before opening.
    /// </summary>
    /// <param name="type">The type of container.</param>
    /// <param name="roomId">Optional room ID where container is located.</param>
    /// <returns>
    /// A new <see cref="ContainerLootTable"/> in <see cref="ContainerLootState.Locked"/> state.
    /// </returns>
    /// <example>
    /// <code>
    /// var lockedChest = ContainerLootTable.CreateLocked(
    ///     ContainerType.LargeChest,
    ///     roomId: treasureRoomId);
    /// </code>
    /// </example>
    public static ContainerLootTable CreateLocked(
        ContainerType type,
        Guid? roomId = null)
    {
        return Create(type, ContainerLootState.Locked, roomId);
    }

    /// <summary>
    /// Discovers a hidden container, making it visible to the player.
    /// </summary>
    /// <returns>
    /// <c>true</c> if discovery succeeded (container was in <see cref="ContainerLootState.Undiscovered"/> state);
    /// <c>false</c> if already discovered or in another state.
    /// </returns>
    /// <remarks>
    /// This method should be called after a successful Perception check.
    /// Transitions the container from <see cref="ContainerLootState.Undiscovered"/>
    /// to <see cref="ContainerLootState.Discovered"/>.
    /// </remarks>
    public bool Discover()
    {
        if (State != ContainerLootState.Undiscovered)
        {
            return false;
        }

        State = ContainerLootState.Discovered;
        return true;
    }

    /// <summary>
    /// Unlocks a locked container, allowing it to be opened.
    /// </summary>
    /// <returns>
    /// <c>true</c> if unlock succeeded (container was in <see cref="ContainerLootState.Locked"/> state);
    /// <c>false</c> if not locked or in another state.
    /// </returns>
    /// <remarks>
    /// This method should be called after a key is used or lockpicking succeeds.
    /// Transitions the container from <see cref="ContainerLootState.Locked"/>
    /// to <see cref="ContainerLootState.Open"/>.
    /// </remarks>
    public bool Unlock()
    {
        if (State != ContainerLootState.Locked)
        {
            return false;
        }

        State = ContainerLootState.Open;
        return true;
    }

    /// <summary>
    /// Opens a discovered container, revealing its contents.
    /// </summary>
    /// <returns>
    /// <c>true</c> if open succeeded (container was in <see cref="ContainerLootState.Discovered"/> state);
    /// <c>false</c> if not in discovered state (e.g., locked, already open).
    /// </returns>
    /// <remarks>
    /// Transitions the container from <see cref="ContainerLootState.Discovered"/>
    /// to <see cref="ContainerLootState.Open"/>. Locked containers must use
    /// <see cref="Unlock"/> instead.
    /// </remarks>
    public bool Open()
    {
        if (State != ContainerLootState.Discovered)
        {
            return false;
        }

        State = ContainerLootState.Open;
        return true;
    }

    /// <summary>
    /// Sets the generated contents for this container.
    /// </summary>
    /// <param name="contents">The generated contents from the loot service.</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown if contents have already been generated (called twice).
    /// </exception>
    /// <remarks>
    /// <para>
    /// This method is called by the container loot service (v0.16.4d) when
    /// contents are generated. Contents can only be set once per container instance.
    /// </para>
    /// <para>
    /// The contents remain stored in the entity even after looting for
    /// logging and analytics purposes.
    /// </para>
    /// </remarks>
    public void SetContents(ContainerContents contents)
    {
        if (Contents.HasValue)
        {
            throw new InvalidOperationException(
                "Container contents have already been generated.");
        }

        Contents = contents;
    }

    /// <summary>
    /// Loots the container, returning its contents and marking it as looted.
    /// </summary>
    /// <returns>
    /// The container contents if successfully looted;
    /// <see cref="ContainerContents.Empty"/> if already looted, not open, or no contents.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This is the primary method for players to collect loot. It:
    /// <list type="number">
    /// <item>Checks if container is already looted (returns empty)</item>
    /// <item>Checks if container is in Open state (returns empty if not)</item>
    /// <item>Transitions state to Looted</item>
    /// <item>Records the loot timestamp</item>
    /// <item>Returns the contents (or empty if none)</item>
    /// </list>
    /// </para>
    /// </remarks>
    public ContainerContents Loot()
    {
        if (State == ContainerLootState.Looted)
        {
            return ContainerContents.Empty;
        }

        if (State != ContainerLootState.Open)
        {
            return ContainerContents.Empty;
        }

        State = ContainerLootState.Looted;
        LootedAt = DateTime.UtcNow;

        return Contents ?? ContainerContents.Empty;
    }

    /// <summary>
    /// Gets the current contents for display purposes without looting.
    /// </summary>
    /// <returns>
    /// The container contents if not looted and contents exist;
    /// <see cref="ContainerContents.Empty"/> if looted or contents not generated.
    /// </returns>
    /// <remarks>
    /// Use this method for UI display when the player views an open container
    /// without taking the contents. Does not change container state.
    /// </remarks>
    public ContainerContents GetDisplayContents()
    {
        if (State == ContainerLootState.Looted)
        {
            return ContainerContents.Empty;
        }

        return Contents ?? ContainerContents.Empty;
    }
}
