# v0.1.1a Design Specification: Room Template System

**Version:** 0.1.1a
**Phase Name:** Room Template System
**Parent Version:** v0.1.1 (Template-Based Generation)
**Prerequisites:** v0.1.0d Complete (Map Command & Polish)
**Estimated Tests:** ~20 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [RoomTemplate Entity](#4-roomtemplate-entity)
5. [TemplateSlot Value Object](#5-templateslot-value-object)
6. [SlotType Enum](#6-slottype-enum)
7. [Template Selection Service](#7-template-selection-service)
8. [Template Validation Service](#8-template-validation-service)
9. [SlotFillResult Value Object](#9-slotfillresult-value-object)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement a comprehensive room template system with variable content slots that enables flexible, context-aware room generation. Templates define structural patterns with named slots that can be filled with different content based on biome, depth, and other contextual factors, creating varied room generation while maintaining coherent design patterns.

### 1.2 Current State

| Area | Current State (v0.1.0d) | Target State (v0.1.1a) |
|------|-------------------------|------------------------|
| Room templates | Basic `RoomTemplate` configuration class | Full `RoomTemplate` domain entity |
| Content placement | Fixed spawn chances per template | Slot-based variable content positions |
| Description generation | Static patterns with pool references | Pattern variables with slot filling |
| Template selection | Biome + depth filtering | Enhanced context-aware selection service |
| Validation | Basic depth range checks | Comprehensive template validation |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `RoomTemplate` |
| **Value Objects** | `TemplateSlot`, `SlotFillResult` |
| **Enums** | `SlotType` |
| **Services** | `TemplateSelectionService`, `TemplateValidationService` |
| **Configuration** | Enhanced `room-templates.json` |
| **Tests** | ~20 new unit tests |

### 1.4 Architectural Significance

This version establishes the **template slot pattern** that enables rich procedural generation:
- Declarative slot definitions for variable content
- Constraint-based content selection
- Probability-driven optional content
- Pattern-based description generation with descriptor pool integration

---

## 2. Feature Overview

```
v0.1.1a Room Template System
├── RoomTemplate Entity
│   ├── Template identification (TemplateId)
│   ├── Name/description patterns with placeholders
│   ├── Biome and depth restrictions
│   ├── Room type assignment
│   ├── Weighted selection support
│   └── Tag-based filtering
├── TemplateSlot Value Object
│   ├── Slot identification (SlotId)
│   ├── Content type specification (SlotType)
│   ├── Required vs optional slots
│   ├── Quantity ranges (min/max)
│   ├── Fill probability (0.0-1.0)
│   ├── Content constraints dictionary
│   └── Descriptor pool reference
├── SlotType Enum
│   ├── Monster (spawn points)
│   ├── Item (placement points)
│   ├── Feature (interactive elements)
│   ├── Exit (directional connections)
│   ├── Description (text variables)
│   ├── Hazard (traps/dangers)
│   └── Container (loot sources)
├── Template Selection Service
│   ├── Context-based filtering
│   ├── Weighted random selection
│   └── Fallback template handling
├── Template Validation Service
│   ├── Structural validation
│   ├── Reference validation
│   └── Configuration error reporting
└── SlotFillResult Value Object
    ├── Success/failure tracking
    ├── Filled content references
    └── Unfilled slot reporting
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  No direct presentation changes - consumed by existing handlers              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  TemplateSelectionService              TemplateValidationService             │
│  ├── SelectTemplate()                  ├── ValidateTemplate()                │
│  ├── GetValidTemplates()               ├── ValidateAllTemplates()            │
│  ├── FilterByContext()                 ├── ValidateSlot()                    │
│  └── WeightedSelect()                  └── GetValidationErrors()             │
│                                                                              │
│  Configuration:                        Interfaces:                           │
│  └── RoomTemplateConfiguration         ├── ITemplateSelectionService         │
│      (loads from JSON)                 └── ITemplateValidationService        │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Entities:                       Value Objects:             Enums:           │
│  ┌─────────────────────┐        ┌─────────────────────┐   ┌───────────────┐ │
│  │ RoomTemplate        │        │ TemplateSlot        │   │ SlotType      │ │
│  │ ├── Id (Guid)       │        │ ├── SlotId          │   │ ├── Monster   │ │
│  │ ├── TemplateId      │        │ ├── Type            │   │ ├── Item      │ │
│  │ ├── NamePattern     │        │ ├── IsRequired      │   │ ├── Feature   │ │
│  │ ├── DescPattern     │        │ ├── MinQuantity     │   │ ├── Exit      │ │
│  │ ├── ValidBiomes     │        │ ├── MaxQuantity     │   │ ├── Description│ │
│  │ ├── RoomType        │        │ ├── FillProbability │   │ ├── Hazard    │ │
│  │ ├── Slots           │        │ ├── Constraints     │   │ └── Container │ │
│  │ ├── Weight          │        │ └── DescriptorPool  │   └───────────────┘ │
│  │ ├── MinDepth        │        └─────────────────────┘                     │
│  │ ├── MaxDepth        │        ┌─────────────────────┐                     │
│  │ └── Tags            │        │ SlotFillResult      │                     │
│  └─────────────────────┘        │ ├── IsSuccess       │                     │
│                                 │ ├── FilledSlots     │                     │
│                                 │ └── UnfilledSlots   │                     │
│                                 └─────────────────────┘                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  └── GetRoomTemplateConfiguration()                                          │
│      └── Loads and deserializes config/room-templates.json                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Template Selection Flow

```
┌───────────────────────────────────────┐
│ RoomGeneratorService needs template   │
│ for position (X, Y, Z)                │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ TemplateSelectionService.SelectTemplate(context)              │
├───────────────────────────────────────────────────────────────┤
│ SelectionContext:                                             │
│ ├── Biome: string (e.g., "dungeon", "cave")                   │
│ ├── Depth: int (Z-level)                                      │
│ ├── RequiredTags: string[] (filtering tags)                   │
│ └── ExcludedTags: string[] (exclusion tags)                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Filter by Biome                                       │
├───────────────────────────────────────────────────────────────┤
│ template.ValidBiomes.Contains(context.Biome)                  │
│                                                               │
│ Example: Biome = "dungeon"                                    │
│ ├── dungeon-corridor-narrow ✓ (has "dungeon")                 │
│ ├── dungeon-treasure-vault ✓ (has "dungeon")                  │
│ ├── cave-crystal-chamber ✗ (only "cave")                      │
│ └── volcanic-lava-bridge ✗ (only "volcanic")                  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Filter by Depth                                       │
├───────────────────────────────────────────────────────────────┤
│ template.MinDepth <= depth && (MaxDepth == null || depth <= MaxDepth) │
│                                                               │
│ Example: Depth = 3                                            │
│ ├── dungeon-corridor-narrow ✓ (0 to ∞)                        │
│ ├── dungeon-treasure-vault ✓ (2 to ∞)                         │
│ └── dungeon-starter-room ✗ (0 to 1)                           │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: Filter by Tags (if specified)                         │
├───────────────────────────────────────────────────────────────┤
│ RequiredTags.All(tag => template.Tags.Contains(tag))          │
│ ExcludedTags.None(tag => template.Tags.Contains(tag))         │
│                                                               │
│ Example: RequiredTags = ["corridor"], ExcludedTags = []       │
│ ├── dungeon-corridor-narrow ✓ (has "corridor")                │
│ └── dungeon-treasure-vault ✗ (no "corridor")                  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: Weighted Random Selection                             │
├───────────────────────────────────────────────────────────────┤
│ Remaining templates with their weights:                       │
│ ├── dungeon-corridor-narrow: 40                               │
│ ├── dungeon-corridor-wide: 30                                 │
│ └── dungeon-corridor-twisted: 20                              │
│                                                               │
│ Total weight = 90                                             │
│ Roll 0-89, select based on cumulative weight                  │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Return selected RoomTemplate                                  │
│ (or fallback template if no matches)                          │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Slot Filling Flow

```
┌───────────────────────────────────────┐
│ Template selected, need to fill slots │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ For each TemplateSlot in template.Slots                       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Check: Should this slot be filled?                            │
├───────────────────────────────────────────────────────────────┤
│ if (slot.IsRequired)                                          │
│     → Must fill                                               │
│ else                                                          │
│     → Roll random(0.0-1.0) < slot.FillProbability?            │
│       ├── Yes → Fill slot                                     │
│       └── No  → Skip slot                                     │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Determine quantity to fill                                    │
├───────────────────────────────────────────────────────────────┤
│ quantity = Random(slot.MinQuantity, slot.MaxQuantity + 1)     │
│                                                               │
│ Example: MinQuantity = 1, MaxQuantity = 3                     │
│ → Could generate 1, 2, or 3 items                             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Fill based on SlotType                                        │
├───────────────────────────────────────────────────────────────┤
│ Monster → Select from monster pool with constraints           │
│           (maxTier, categories, etc.)                         │
│                                                               │
│ Item → Select from item pool with constraints                 │
│        (types, rarity, etc.)                                  │
│                                                               │
│ Description → Get descriptor from pool                        │
│               (slot.DescriptorPool reference)                 │
│                                                               │
│ Container → Create container with loot quality                │
│                                                               │
│ Feature → Place interactive feature                           │
│                                                               │
│ Exit → Add potential exit direction                           │
│                                                               │
│ Hazard → Place environmental hazard                           │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Return SlotFillResult                                         │
├───────────────────────────────────────────────────────────────┤
│ IsSuccess: true if all required slots filled                  │
│ FilledSlots: Dictionary<slotId, content>                      │
│ UnfilledSlots: List of unfilled optional slots                │
└───────────────────────────────────────────────────────────────┘
```

---

## 4. RoomTemplate Entity

### 4.1 Purpose

Define a reusable room pattern with variable content slots that can be instantiated into concrete rooms during procedural generation.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Entities/RoomTemplate.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Defines a reusable room pattern with variable content slots.
/// </summary>
/// <remarks>
/// Room templates specify the structure and possible content of generated rooms.
/// They include name/description patterns with placeholder variables that are
/// filled during room instantiation, along with typed slots for placing
/// monsters, items, features, and other content.
/// </remarks>
public class RoomTemplate : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this template instance.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the template's configuration ID (e.g., "dungeon-corridor-01").
    /// </summary>
    /// <remarks>
    /// This ID is used for referencing the template in configuration
    /// and for deterministic selection based on context.
    /// </remarks>
    public string TemplateId { get; private set; }

    /// <summary>
    /// Gets the display name pattern (may contain {variables}).
    /// </summary>
    /// <remarks>
    /// Variables are resolved during room instantiation using slot values
    /// or descriptor pool lookups. Example: "{adjective} Corridor"
    /// </remarks>
    public string NamePattern { get; private set; }

    /// <summary>
    /// Gets the description pattern with descriptor pool references.
    /// </summary>
    /// <remarks>
    /// Supports complex patterns with multiple placeholders that resolve
    /// to descriptor pools or slot values. Example:
    /// "A {width} {material} corridor stretches {direction}. {atmosphere}"
    /// </remarks>
    public string DescriptionPattern { get; private set; }

    /// <summary>
    /// Gets the biomes this template can be used in.
    /// </summary>
    /// <remarks>
    /// Templates are filtered by biome during selection. A template
    /// must list all biomes where it should appear.
    /// </remarks>
    public IReadOnlyList<string> ValidBiomes { get; private set; }

    /// <summary>
    /// Gets the room type this template produces.
    /// </summary>
    public RoomType RoomType { get; private set; }

    /// <summary>
    /// Gets the content slots defined in this template.
    /// </summary>
    public IReadOnlyList<TemplateSlot> Slots { get; private set; }

    /// <summary>
    /// Gets the selection weight for random template selection.
    /// </summary>
    /// <remarks>
    /// Higher weights make the template more likely to be selected
    /// when multiple valid templates exist for a context.
    /// </remarks>
    public int Weight { get; private set; }

    /// <summary>
    /// Gets the minimum depth (Z-level) where this template can appear.
    /// </summary>
    public int MinDepth { get; private set; }

    /// <summary>
    /// Gets the maximum depth (Z-level) where this template can appear.
    /// </summary>
    /// <remarks>
    /// Null indicates no maximum depth restriction.
    /// </remarks>
    public int? MaxDepth { get; private set; }

    /// <summary>
    /// Gets tags for additional filtering during selection.
    /// </summary>
    /// <remarks>
    /// Tags allow fine-grained template filtering beyond biome and depth.
    /// Examples: "corridor", "treasure", "guarded", "boss-room"
    /// </remarks>
    public IReadOnlyList<string> Tags { get; private set; }

    /// <summary>
    /// Private parameterless constructor for Entity Framework Core.
    /// </summary>
    private RoomTemplate()
    {
        TemplateId = string.Empty;
        NamePattern = string.Empty;
        DescriptionPattern = string.Empty;
        ValidBiomes = [];
        Slots = [];
        Tags = [];
    }

    /// <summary>
    /// Creates a new room template with the specified properties.
    /// </summary>
    /// <param name="templateId">The unique template identifier.</param>
    /// <param name="namePattern">The name pattern with placeholders.</param>
    /// <param name="descriptionPattern">The description pattern with placeholders.</param>
    /// <param name="validBiomes">Biomes where this template can appear.</param>
    /// <param name="roomType">The type of room this template produces.</param>
    /// <param name="slots">The content slots for this template.</param>
    /// <param name="weight">Selection weight (default 10).</param>
    /// <param name="minDepth">Minimum depth restriction (default 0).</param>
    /// <param name="maxDepth">Maximum depth restriction (null = no limit).</param>
    /// <param name="tags">Additional filtering tags.</param>
    public RoomTemplate(
        string templateId,
        string namePattern,
        string descriptionPattern,
        IReadOnlyList<string> validBiomes,
        RoomType roomType,
        IReadOnlyList<TemplateSlot> slots,
        int weight = 10,
        int minDepth = 0,
        int? maxDepth = null,
        IReadOnlyList<string>? tags = null)
    {
        if (string.IsNullOrWhiteSpace(templateId))
            throw new ArgumentException("Template ID cannot be empty.", nameof(templateId));

        if (string.IsNullOrWhiteSpace(namePattern))
            throw new ArgumentException("Name pattern cannot be empty.", nameof(namePattern));

        if (validBiomes == null || validBiomes.Count == 0)
            throw new ArgumentException("At least one valid biome is required.", nameof(validBiomes));

        if (weight <= 0)
            throw new ArgumentOutOfRangeException(nameof(weight), "Weight must be positive.");

        if (minDepth < 0)
            throw new ArgumentOutOfRangeException(nameof(minDepth), "Minimum depth cannot be negative.");

        if (maxDepth.HasValue && maxDepth < minDepth)
            throw new ArgumentException("Maximum depth cannot be less than minimum depth.", nameof(maxDepth));

        Id = Guid.NewGuid();
        TemplateId = templateId;
        NamePattern = namePattern;
        DescriptionPattern = descriptionPattern;
        ValidBiomes = validBiomes;
        RoomType = roomType;
        Slots = slots ?? [];
        Weight = weight;
        MinDepth = minDepth;
        MaxDepth = maxDepth;
        Tags = tags ?? [];
    }

    /// <summary>
    /// Checks if this template is valid for the specified biome.
    /// </summary>
    /// <param name="biome">The biome to check.</param>
    /// <returns>True if the template can be used in this biome.</returns>
    public bool IsValidForBiome(string biome) =>
        ValidBiomes.Contains(biome, StringComparer.OrdinalIgnoreCase);

    /// <summary>
    /// Checks if this template is valid for the specified depth.
    /// </summary>
    /// <param name="depth">The Z-level depth to check.</param>
    /// <returns>True if the template can be used at this depth.</returns>
    public bool IsValidForDepth(int depth)
    {
        if (depth < MinDepth) return false;
        if (MaxDepth.HasValue && depth > MaxDepth.Value) return false;
        return true;
    }

    /// <summary>
    /// Checks if this template has all the specified tags.
    /// </summary>
    /// <param name="requiredTags">Tags that must be present.</param>
    /// <returns>True if all required tags are present.</returns>
    public bool HasAllTags(IEnumerable<string> requiredTags) =>
        requiredTags.All(tag => Tags.Contains(tag, StringComparer.OrdinalIgnoreCase));

    /// <summary>
    /// Checks if this template has none of the specified tags.
    /// </summary>
    /// <param name="excludedTags">Tags that must not be present.</param>
    /// <returns>True if none of the excluded tags are present.</returns>
    public bool HasNoTags(IEnumerable<string> excludedTags) =>
        !excludedTags.Any(tag => Tags.Contains(tag, StringComparer.OrdinalIgnoreCase));

    /// <summary>
    /// Gets all required slots in this template.
    /// </summary>
    /// <returns>Slots where IsRequired is true.</returns>
    public IEnumerable<TemplateSlot> GetRequiredSlots() =>
        Slots.Where(s => s.IsRequired);

    /// <summary>
    /// Gets all optional slots in this template.
    /// </summary>
    /// <returns>Slots where IsRequired is false.</returns>
    public IEnumerable<TemplateSlot> GetOptionalSlots() =>
        Slots.Where(s => !s.IsRequired);

    /// <summary>
    /// Gets slots of a specific type.
    /// </summary>
    /// <param name="type">The slot type to filter by.</param>
    /// <returns>All slots of the specified type.</returns>
    public IEnumerable<TemplateSlot> GetSlotsByType(SlotType type) =>
        Slots.Where(s => s.Type == type);

    /// <summary>
    /// Gets a specific slot by its ID.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <returns>The slot if found; null otherwise.</returns>
    public TemplateSlot? GetSlot(string slotId) =>
        Slots.FirstOrDefault(s => s.SlotId.Equals(slotId, StringComparison.OrdinalIgnoreCase));

    /// <inheritdoc/>
    public override string ToString() =>
        $"RoomTemplate[{TemplateId}]: {RoomType} ({ValidBiomes.Count} biomes, {Slots.Count} slots)";
}
```

---

## 5. TemplateSlot Value Object

### 5.1 Purpose

Define a variable content position within a room template, specifying what type of content can fill the slot and under what conditions.

### 5.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TemplateSlot.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a variable content position within a room template.
/// </summary>
/// <remarks>
/// Template slots specify points where content can be placed during
/// room instantiation. Each slot has a type, quantity constraints,
/// fill probability, and optional content-specific constraints.
/// </remarks>
public readonly record struct TemplateSlot
{
    /// <summary>
    /// Gets the slot identifier within the template.
    /// </summary>
    /// <remarks>
    /// Used for referencing the slot in patterns (e.g., "{adjective}")
    /// and for tracking filled content.
    /// </remarks>
    public string SlotId { get; init; }

    /// <summary>
    /// Gets the type of content this slot accepts.
    /// </summary>
    public SlotType Type { get; init; }

    /// <summary>
    /// Gets whether this slot must be filled.
    /// </summary>
    /// <remarks>
    /// Required slots are always filled during room instantiation.
    /// If a required slot cannot be filled, room generation fails.
    /// </remarks>
    public bool IsRequired { get; init; }

    /// <summary>
    /// Gets the minimum quantity to place (default 1 if required).
    /// </summary>
    public int MinQuantity { get; init; }

    /// <summary>
    /// Gets the maximum quantity to place.
    /// </summary>
    public int MaxQuantity { get; init; }

    /// <summary>
    /// Gets the probability this slot is filled (0.0-1.0).
    /// </summary>
    /// <remarks>
    /// Only applies to optional slots. A value of 0.5 means the slot
    /// has a 50% chance of being filled during room instantiation.
    /// Required slots always have an effective probability of 1.0.
    /// </remarks>
    public float FillProbability { get; init; }

    /// <summary>
    /// Gets constraints for content selection.
    /// </summary>
    /// <remarks>
    /// Constraint interpretation depends on slot type:
    /// - Monster: "maxTier", "minTier", "categories"
    /// - Item: "types", "rarity", "maxValue"
    /// - Container: "containerType", "lootQuality"
    /// - Feature: "featureType", "interactive"
    /// </remarks>
    public IReadOnlyDictionary<string, string> Constraints { get; init; }

    /// <summary>
    /// Gets the descriptor pool for description slots.
    /// </summary>
    /// <remarks>
    /// Only used for SlotType.Description. References a descriptor
    /// pool path (e.g., "room.adjectives.corridor").
    /// </remarks>
    public string? DescriptorPool { get; init; }

    /// <summary>
    /// Creates a monster spawn slot.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <param name="required">Whether the slot must be filled.</param>
    /// <param name="min">Minimum monster count.</param>
    /// <param name="max">Maximum monster count.</param>
    /// <param name="probability">Fill probability for optional slots.</param>
    /// <param name="constraints">Monster selection constraints.</param>
    public static TemplateSlot Monster(
        string slotId,
        bool required = false,
        int min = 1,
        int max = 1,
        float probability = 0.5f,
        IReadOnlyDictionary<string, string>? constraints = null) => new()
    {
        SlotId = slotId,
        Type = SlotType.Monster,
        IsRequired = required,
        MinQuantity = min,
        MaxQuantity = max,
        FillProbability = probability,
        Constraints = constraints ?? new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates an item placement slot.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <param name="required">Whether the slot must be filled.</param>
    /// <param name="min">Minimum item count.</param>
    /// <param name="max">Maximum item count.</param>
    /// <param name="probability">Fill probability for optional slots.</param>
    /// <param name="constraints">Item selection constraints.</param>
    public static TemplateSlot Item(
        string slotId,
        bool required = false,
        int min = 1,
        int max = 1,
        float probability = 0.3f,
        IReadOnlyDictionary<string, string>? constraints = null) => new()
    {
        SlotId = slotId,
        Type = SlotType.Item,
        IsRequired = required,
        MinQuantity = min,
        MaxQuantity = max,
        FillProbability = probability,
        Constraints = constraints ?? new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates a description variable slot.
    /// </summary>
    /// <param name="slotId">The slot identifier (matches pattern variable).</param>
    /// <param name="descriptorPool">The descriptor pool path.</param>
    /// <param name="required">Whether the slot must be filled (default true).</param>
    public static TemplateSlot Description(
        string slotId,
        string descriptorPool,
        bool required = true) => new()
    {
        SlotId = slotId,
        Type = SlotType.Description,
        IsRequired = required,
        MinQuantity = 1,
        MaxQuantity = 1,
        FillProbability = 1.0f,
        DescriptorPool = descriptorPool,
        Constraints = new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates a container slot.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <param name="required">Whether the slot must be filled.</param>
    /// <param name="probability">Fill probability for optional slots.</param>
    /// <param name="constraints">Container constraints (type, loot quality).</param>
    public static TemplateSlot Container(
        string slotId,
        bool required = false,
        float probability = 0.25f,
        IReadOnlyDictionary<string, string>? constraints = null) => new()
    {
        SlotId = slotId,
        Type = SlotType.Container,
        IsRequired = required,
        MinQuantity = 1,
        MaxQuantity = 1,
        FillProbability = probability,
        Constraints = constraints ?? new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates a feature slot.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <param name="required">Whether the slot must be filled.</param>
    /// <param name="probability">Fill probability for optional slots.</param>
    /// <param name="constraints">Feature constraints.</param>
    public static TemplateSlot Feature(
        string slotId,
        bool required = false,
        float probability = 0.2f,
        IReadOnlyDictionary<string, string>? constraints = null) => new()
    {
        SlotId = slotId,
        Type = SlotType.Feature,
        IsRequired = required,
        MinQuantity = 1,
        MaxQuantity = 1,
        FillProbability = probability,
        Constraints = constraints ?? new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates a hazard slot.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <param name="required">Whether the slot must be filled.</param>
    /// <param name="probability">Fill probability for optional slots.</param>
    /// <param name="constraints">Hazard constraints.</param>
    public static TemplateSlot Hazard(
        string slotId,
        bool required = false,
        float probability = 0.15f,
        IReadOnlyDictionary<string, string>? constraints = null) => new()
    {
        SlotId = slotId,
        Type = SlotType.Hazard,
        IsRequired = required,
        MinQuantity = 1,
        MaxQuantity = 1,
        FillProbability = probability,
        Constraints = constraints ?? new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates an exit slot.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <param name="required">Whether the slot must be filled.</param>
    /// <param name="probability">Fill probability for optional slots.</param>
    /// <param name="constraints">Exit constraints (direction, hidden, etc.).</param>
    public static TemplateSlot Exit(
        string slotId,
        bool required = false,
        float probability = 0.5f,
        IReadOnlyDictionary<string, string>? constraints = null) => new()
    {
        SlotId = slotId,
        Type = SlotType.Exit,
        IsRequired = required,
        MinQuantity = 1,
        MaxQuantity = 1,
        FillProbability = probability,
        Constraints = constraints ?? new Dictionary<string, string>()
    };

    /// <summary>
    /// Gets a constraint value by key.
    /// </summary>
    /// <param name="key">The constraint key.</param>
    /// <returns>The constraint value if present; null otherwise.</returns>
    public string? GetConstraint(string key) =>
        Constraints.TryGetValue(key, out var value) ? value : null;

    /// <summary>
    /// Checks if a constraint matches a specified value.
    /// </summary>
    /// <param name="key">The constraint key.</param>
    /// <param name="value">The expected value.</param>
    /// <returns>True if the constraint matches.</returns>
    public bool HasConstraint(string key, string value) =>
        Constraints.TryGetValue(key, out var actual) &&
        actual.Equals(value, StringComparison.OrdinalIgnoreCase);

    /// <summary>
    /// Gets the effective fill probability (1.0 for required slots).
    /// </summary>
    public float EffectiveFillProbability => IsRequired ? 1.0f : FillProbability;
}
```

---

## 6. SlotType Enum

### 6.1 Purpose

Categorize the types of content that can fill template slots, enabling type-specific content selection and validation.

### 6.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/SlotType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of content that can fill template slots.
/// </summary>
/// <remarks>
/// Each slot type has associated selection logic and constraints:
/// - Monster: Uses monster pools with tier/category filtering
/// - Item: Uses item pools with type/rarity filtering
/// - Feature: Places interactive room features
/// - Exit: Creates room connections
/// - Description: Resolves to descriptor pool text
/// - Hazard: Places environmental dangers
/// - Container: Places lootable containers
/// </remarks>
public enum SlotType
{
    /// <summary>
    /// Monster spawn point.
    /// </summary>
    /// <remarks>
    /// Constraints: maxTier, minTier, categories (comma-separated)
    /// Example: { "maxTier": "elite", "categories": "humanoid,beast" }
    /// </remarks>
    Monster,

    /// <summary>
    /// Item placement point.
    /// </summary>
    /// <remarks>
    /// Constraints: types (comma-separated), rarity, maxValue
    /// Example: { "types": "consumable,treasure", "rarity": "uncommon" }
    /// </remarks>
    Item,

    /// <summary>
    /// Interactive feature (lever, altar, statue, etc.).
    /// </summary>
    /// <remarks>
    /// Constraints: featureType, interactive (true/false)
    /// Example: { "featureType": "altar", "interactive": "true" }
    /// </remarks>
    Feature,

    /// <summary>
    /// Potential exit direction.
    /// </summary>
    /// <remarks>
    /// Constraints: direction, hidden (true/false), discoveryDC
    /// Example: { "direction": "north", "hidden": "true", "discoveryDC": "15" }
    /// </remarks>
    Exit,

    /// <summary>
    /// Variable description segment.
    /// </summary>
    /// <remarks>
    /// Uses DescriptorPool property to reference a descriptor pool path.
    /// The slot ID matches the placeholder in the pattern.
    /// Example: SlotId="adjective", DescriptorPool="room.adjectives.corridor"
    /// </remarks>
    Description,

    /// <summary>
    /// Environmental hazard or trap.
    /// </summary>
    /// <remarks>
    /// Constraints: hazardType, damage, triggerType
    /// Example: { "hazardType": "pit_trap", "damage": "2d6" }
    /// </remarks>
    Hazard,

    /// <summary>
    /// Loot container (chest, barrel, crate, etc.).
    /// </summary>
    /// <remarks>
    /// Constraints: containerType, lootQuality, locked (true/false)
    /// Example: { "containerType": "chest", "lootQuality": "high" }
    /// </remarks>
    Container
}
```

---

## 7. Template Selection Service

### 7.1 Purpose

Provide context-aware template selection using biome, depth, tags, and weighted random selection.

### 7.2 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITemplateSelectionService.cs`

```csharp
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for selecting room templates based on context.
/// </summary>
public interface ITemplateSelectionService
{
    /// <summary>
    /// Selects a room template based on the provided context.
    /// </summary>
    /// <param name="context">The selection context (biome, depth, tags).</param>
    /// <returns>The selected template, or null if no valid templates exist.</returns>
    RoomTemplate? SelectTemplate(TemplateSelectionContext context);

    /// <summary>
    /// Gets all templates valid for the specified context.
    /// </summary>
    /// <param name="context">The selection context.</param>
    /// <returns>All templates matching the context criteria.</returns>
    IReadOnlyList<RoomTemplate> GetValidTemplates(TemplateSelectionContext context);

    /// <summary>
    /// Gets the fallback template for when no matches are found.
    /// </summary>
    /// <param name="biome">The biome to get a fallback for.</param>
    /// <returns>A generic fallback template.</returns>
    RoomTemplate GetFallbackTemplate(string biome);
}

/// <summary>
/// Context for template selection decisions.
/// </summary>
public record TemplateSelectionContext
{
    /// <summary>
    /// The current biome for filtering.
    /// </summary>
    public required string Biome { get; init; }

    /// <summary>
    /// The current depth (Z-level) for filtering.
    /// </summary>
    public required int Depth { get; init; }

    /// <summary>
    /// Tags that must be present on the template.
    /// </summary>
    public IReadOnlyList<string> RequiredTags { get; init; } = [];

    /// <summary>
    /// Tags that must not be present on the template.
    /// </summary>
    public IReadOnlyList<string> ExcludedTags { get; init; } = [];

    /// <summary>
    /// Optional seed for deterministic selection.
    /// </summary>
    public int? Seed { get; init; }
}
```

### 7.3 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/TemplateSelectionService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Configuration;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for selecting room templates based on context.
/// </summary>
public class TemplateSelectionService : ITemplateSelectionService
{
    private readonly RoomTemplateConfiguration _configuration;
    private readonly ILogger<TemplateSelectionService> _logger;
    private readonly Random _random = new();

    public TemplateSelectionService(
        RoomTemplateConfiguration configuration,
        ILogger<TemplateSelectionService> logger)
    {
        _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogDebug("TemplateSelectionService initialized with {Count} templates",
            _configuration.Templates.Count);
    }

    /// <inheritdoc/>
    public RoomTemplate? SelectTemplate(TemplateSelectionContext context)
    {
        ArgumentNullException.ThrowIfNull(context);

        var validTemplates = GetValidTemplates(context);

        if (validTemplates.Count == 0)
        {
            _logger.LogWarning(
                "No valid templates for context: Biome={Biome}, Depth={Depth}",
                context.Biome, context.Depth);
            return null;
        }

        var selected = WeightedSelect(validTemplates, context.Seed);

        _logger.LogDebug(
            "Selected template {TemplateId} from {Count} valid templates",
            selected.TemplateId, validTemplates.Count);

        return selected;
    }

    /// <inheritdoc/>
    public IReadOnlyList<RoomTemplate> GetValidTemplates(TemplateSelectionContext context)
    {
        ArgumentNullException.ThrowIfNull(context);

        var templates = _configuration.Templates.Values
            .Where(t => t.IsValidForBiome(context.Biome))
            .Where(t => t.IsValidForDepth(context.Depth))
            .Where(t => context.RequiredTags.Count == 0 || t.HasAllTags(context.RequiredTags))
            .Where(t => context.ExcludedTags.Count == 0 || t.HasNoTags(context.ExcludedTags))
            .ToList();

        _logger.LogDebug(
            "Found {Count} valid templates for Biome={Biome}, Depth={Depth}",
            templates.Count, context.Biome, context.Depth);

        return templates;
    }

    /// <inheritdoc/>
    public RoomTemplate GetFallbackTemplate(string biome)
    {
        // Create a generic fallback template for the biome
        return new RoomTemplate(
            templateId: $"fallback-{biome}",
            namePattern: "Chamber",
            descriptionPattern: "A nondescript chamber.",
            validBiomes: [biome],
            roomType: RoomType.Standard,
            slots: [],
            weight: 1,
            minDepth: 0,
            maxDepth: null,
            tags: ["fallback"]);
    }

    private RoomTemplate WeightedSelect(IReadOnlyList<RoomTemplate> templates, int? seed)
    {
        var random = seed.HasValue ? new Random(seed.Value) : _random;
        var totalWeight = templates.Sum(t => t.Weight);
        var roll = random.Next(totalWeight);
        var cumulative = 0;

        foreach (var template in templates)
        {
            cumulative += template.Weight;
            if (roll < cumulative)
                return template;
        }

        // Fallback (shouldn't reach here if weights > 0)
        return templates[0];
    }
}
```

---

## 8. Template Validation Service

### 8.1 Purpose

Validate room templates for structural integrity, reference validity, and configuration correctness.

### 8.2 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITemplateValidationService.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for validating room template configurations.
/// </summary>
public interface ITemplateValidationService
{
    /// <summary>
    /// Validates a single template.
    /// </summary>
    /// <param name="template">The template to validate.</param>
    /// <returns>Validation result with any errors found.</returns>
    TemplateValidationResult ValidateTemplate(RoomTemplate template);

    /// <summary>
    /// Validates all loaded templates.
    /// </summary>
    /// <returns>Validation results for all templates.</returns>
    IReadOnlyList<TemplateValidationResult> ValidateAllTemplates();

    /// <summary>
    /// Validates a single slot definition.
    /// </summary>
    /// <param name="slot">The slot to validate.</param>
    /// <param name="templateId">The parent template ID for error reporting.</param>
    /// <returns>List of validation errors.</returns>
    IReadOnlyList<string> ValidateSlot(TemplateSlot slot, string templateId);
}

/// <summary>
/// Result of template validation.
/// </summary>
public record TemplateValidationResult
{
    /// <summary>
    /// The template ID that was validated.
    /// </summary>
    public required string TemplateId { get; init; }

    /// <summary>
    /// Whether the template is valid.
    /// </summary>
    public bool IsValid => Errors.Count == 0;

    /// <summary>
    /// List of validation errors.
    /// </summary>
    public IReadOnlyList<string> Errors { get; init; } = [];

    /// <summary>
    /// List of validation warnings (non-fatal issues).
    /// </summary>
    public IReadOnlyList<string> Warnings { get; init; } = [];
}
```

### 8.3 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/TemplateValidationService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Configuration;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for validating room template configurations.
/// </summary>
public class TemplateValidationService : ITemplateValidationService
{
    private readonly RoomTemplateConfiguration _configuration;
    private readonly IReadOnlySet<string> _validBiomes;
    private readonly IReadOnlySet<string> _validDescriptorPools;
    private readonly ILogger<TemplateValidationService> _logger;

    public TemplateValidationService(
        RoomTemplateConfiguration configuration,
        IReadOnlySet<string> validBiomes,
        IReadOnlySet<string> validDescriptorPools,
        ILogger<TemplateValidationService> logger)
    {
        _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        _validBiomes = validBiomes ?? throw new ArgumentNullException(nameof(validBiomes));
        _validDescriptorPools = validDescriptorPools ?? throw new ArgumentNullException(nameof(validDescriptorPools));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public TemplateValidationResult ValidateTemplate(RoomTemplate template)
    {
        ArgumentNullException.ThrowIfNull(template);

        var errors = new List<string>();
        var warnings = new List<string>();

        // Validate template ID
        if (string.IsNullOrWhiteSpace(template.TemplateId))
        {
            errors.Add("Template ID is required.");
        }

        // Validate name pattern
        if (string.IsNullOrWhiteSpace(template.NamePattern))
        {
            errors.Add("Name pattern is required.");
        }

        // Validate biomes
        if (template.ValidBiomes.Count == 0)
        {
            errors.Add("At least one valid biome is required.");
        }
        else
        {
            foreach (var biome in template.ValidBiomes)
            {
                if (!_validBiomes.Contains(biome))
                {
                    warnings.Add($"Biome '{biome}' is not in the known biome list.");
                }
            }
        }

        // Validate depth range
        if (template.MinDepth < 0)
        {
            errors.Add("Minimum depth cannot be negative.");
        }

        if (template.MaxDepth.HasValue && template.MaxDepth < template.MinDepth)
        {
            errors.Add("Maximum depth cannot be less than minimum depth.");
        }

        // Validate weight
        if (template.Weight <= 0)
        {
            errors.Add("Weight must be positive.");
        }

        // Validate slots
        var slotIds = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var slot in template.Slots)
        {
            // Check for duplicate slot IDs
            if (!slotIds.Add(slot.SlotId))
            {
                errors.Add($"Duplicate slot ID: '{slot.SlotId}'.");
            }

            // Validate individual slot
            var slotErrors = ValidateSlot(slot, template.TemplateId);
            errors.AddRange(slotErrors);
        }

        // Validate pattern placeholders match slots
        ValidatePatternPlaceholders(template, errors, warnings);

        _logger.LogDebug(
            "Validated template {TemplateId}: {ErrorCount} errors, {WarningCount} warnings",
            template.TemplateId, errors.Count, warnings.Count);

        return new TemplateValidationResult
        {
            TemplateId = template.TemplateId,
            Errors = errors,
            Warnings = warnings
        };
    }

    /// <inheritdoc/>
    public IReadOnlyList<TemplateValidationResult> ValidateAllTemplates()
    {
        var results = new List<TemplateValidationResult>();

        foreach (var template in _configuration.Templates.Values)
        {
            results.Add(ValidateTemplate(template));
        }

        var errorCount = results.Count(r => !r.IsValid);
        _logger.LogInformation(
            "Validated {Count} templates: {ErrorCount} with errors",
            results.Count, errorCount);

        return results;
    }

    /// <inheritdoc/>
    public IReadOnlyList<string> ValidateSlot(TemplateSlot slot, string templateId)
    {
        var errors = new List<string>();
        var prefix = $"[{templateId}/{slot.SlotId}]";

        // Validate slot ID
        if (string.IsNullOrWhiteSpace(slot.SlotId))
        {
            errors.Add($"{prefix} Slot ID is required.");
        }

        // Validate quantity range
        if (slot.MinQuantity < 0)
        {
            errors.Add($"{prefix} Minimum quantity cannot be negative.");
        }

        if (slot.MaxQuantity < slot.MinQuantity)
        {
            errors.Add($"{prefix} Maximum quantity cannot be less than minimum.");
        }

        // Validate fill probability
        if (slot.FillProbability < 0 || slot.FillProbability > 1)
        {
            errors.Add($"{prefix} Fill probability must be between 0.0 and 1.0.");
        }

        // Type-specific validation
        switch (slot.Type)
        {
            case SlotType.Description:
                if (string.IsNullOrWhiteSpace(slot.DescriptorPool))
                {
                    errors.Add($"{prefix} Description slots require a descriptor pool.");
                }
                else if (!_validDescriptorPools.Contains(slot.DescriptorPool))
                {
                    errors.Add($"{prefix} Unknown descriptor pool: '{slot.DescriptorPool}'.");
                }
                break;

            case SlotType.Monster:
                ValidateMonsterConstraints(slot, prefix, errors);
                break;

            case SlotType.Container:
                ValidateContainerConstraints(slot, prefix, errors);
                break;
        }

        return errors;
    }

    private void ValidatePatternPlaceholders(RoomTemplate template, List<string> errors, List<string> warnings)
    {
        // Extract placeholders from patterns
        var namePlaceholders = ExtractPlaceholders(template.NamePattern);
        var descPlaceholders = ExtractPlaceholders(template.DescriptionPattern);
        var allPlaceholders = namePlaceholders.Union(descPlaceholders).ToHashSet(StringComparer.OrdinalIgnoreCase);

        // Get description slot IDs
        var descriptionSlotIds = template.Slots
            .Where(s => s.Type == SlotType.Description)
            .Select(s => s.SlotId)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        // Check for placeholders without corresponding slots
        foreach (var placeholder in allPlaceholders)
        {
            if (!descriptionSlotIds.Contains(placeholder))
            {
                warnings.Add($"Placeholder '{{{placeholder}}}' has no corresponding Description slot.");
            }
        }

        // Check for description slots without placeholders
        foreach (var slotId in descriptionSlotIds)
        {
            if (!allPlaceholders.Contains(slotId))
            {
                warnings.Add($"Description slot '{slotId}' is not referenced in any pattern.");
            }
        }
    }

    private static HashSet<string> ExtractPlaceholders(string pattern)
    {
        var placeholders = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var matches = System.Text.RegularExpressions.Regex.Matches(pattern, @"\{([^}]+)\}");

        foreach (System.Text.RegularExpressions.Match match in matches)
        {
            placeholders.Add(match.Groups[1].Value);
        }

        return placeholders;
    }

    private static void ValidateMonsterConstraints(TemplateSlot slot, string prefix, List<string> errors)
    {
        // Validate tier constraints if present
        var minTier = slot.GetConstraint("minTier");
        var maxTier = slot.GetConstraint("maxTier");

        var validTiers = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "minion", "standard", "elite", "named", "boss"
        };

        if (minTier != null && !validTiers.Contains(minTier))
        {
            errors.Add($"{prefix} Invalid minTier: '{minTier}'.");
        }

        if (maxTier != null && !validTiers.Contains(maxTier))
        {
            errors.Add($"{prefix} Invalid maxTier: '{maxTier}'.");
        }
    }

    private static void ValidateContainerConstraints(TemplateSlot slot, string prefix, List<string> errors)
    {
        var lootQuality = slot.GetConstraint("lootQuality");

        var validQualities = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "low", "medium", "high", "treasure"
        };

        if (lootQuality != null && !validQualities.Contains(lootQuality))
        {
            errors.Add($"{prefix} Invalid lootQuality: '{lootQuality}'.");
        }
    }
}
```

---

## 9. SlotFillResult Value Object

### 9.1 Purpose

Track the results of filling template slots during room instantiation, including which slots were filled and what content was placed.

### 9.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SlotFillResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of filling template slots during room instantiation.
/// </summary>
/// <remarks>
/// Tracks which slots were successfully filled, what content was placed,
/// and which optional slots were skipped.
/// </remarks>
public readonly record struct SlotFillResult
{
    /// <summary>
    /// Gets whether all required slots were successfully filled.
    /// </summary>
    public bool IsSuccess { get; init; }

    /// <summary>
    /// Gets the filled slots with their content.
    /// </summary>
    /// <remarks>
    /// Key: SlotId, Value: Content reference (varies by slot type)
    /// - Description: string text
    /// - Monster: Monster ID or list
    /// - Item: Item ID or list
    /// - Container: Container definition
    /// </remarks>
    public IReadOnlyDictionary<string, object> FilledSlots { get; init; }

    /// <summary>
    /// Gets the slot IDs that were not filled (optional slots that were skipped).
    /// </summary>
    public IReadOnlyList<string> UnfilledSlots { get; init; }

    /// <summary>
    /// Gets the slot IDs that failed to fill (required slots that couldn't be filled).
    /// </summary>
    public IReadOnlyList<string> FailedSlots { get; init; }

    /// <summary>
    /// Gets error messages for failed slots.
    /// </summary>
    public IReadOnlyDictionary<string, string> Errors { get; init; }

    /// <summary>
    /// Creates a successful result with the specified filled slots.
    /// </summary>
    /// <param name="filledSlots">The slots that were filled.</param>
    /// <param name="unfilledSlots">Optional slots that were skipped.</param>
    public static SlotFillResult Success(
        IReadOnlyDictionary<string, object> filledSlots,
        IReadOnlyList<string>? unfilledSlots = null) => new()
    {
        IsSuccess = true,
        FilledSlots = filledSlots,
        UnfilledSlots = unfilledSlots ?? [],
        FailedSlots = [],
        Errors = new Dictionary<string, string>()
    };

    /// <summary>
    /// Creates a failed result with the specified errors.
    /// </summary>
    /// <param name="failedSlots">Slots that failed to fill.</param>
    /// <param name="errors">Error messages by slot ID.</param>
    /// <param name="filledSlots">Slots that were filled before failure.</param>
    public static SlotFillResult Failure(
        IReadOnlyList<string> failedSlots,
        IReadOnlyDictionary<string, string> errors,
        IReadOnlyDictionary<string, object>? filledSlots = null) => new()
    {
        IsSuccess = false,
        FilledSlots = filledSlots ?? new Dictionary<string, object>(),
        UnfilledSlots = [],
        FailedSlots = failedSlots,
        Errors = errors
    };

    /// <summary>
    /// Gets the filled content for a specific slot.
    /// </summary>
    /// <typeparam name="T">The expected content type.</typeparam>
    /// <param name="slotId">The slot identifier.</param>
    /// <returns>The content if found and of correct type; default otherwise.</returns>
    public T? GetContent<T>(string slotId) where T : class
    {
        if (FilledSlots.TryGetValue(slotId, out var content) && content is T typed)
            return typed;
        return null;
    }

    /// <summary>
    /// Gets the filled string content for a description slot.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <returns>The description text if found; empty string otherwise.</returns>
    public string GetDescriptionContent(string slotId)
    {
        if (FilledSlots.TryGetValue(slotId, out var content) && content is string text)
            return text;
        return string.Empty;
    }

    /// <summary>
    /// Checks if a specific slot was filled.
    /// </summary>
    /// <param name="slotId">The slot identifier.</param>
    /// <returns>True if the slot has content.</returns>
    public bool HasContent(string slotId) => FilledSlots.ContainsKey(slotId);
}
```

---

## 10. Data Model Changes

### 10.1 New Entities

| Entity | Layer | Description |
|--------|-------|-------------|
| `RoomTemplate` | Domain | Reusable room pattern with variable content slots |

#### RoomTemplate

**File:** `src/Core/RuneAndRust.Domain/Entities/RoomTemplate.cs`

| Property | Type | Description |
|----------|------|-------------|
| `Id` | `Guid` | Unique identifier for template instance |
| `TemplateId` | `string` | Configuration ID (e.g., "dungeon-corridor-01") |
| `NamePattern` | `string` | Display name with {placeholders} |
| `DescriptionPattern` | `string` | Description with {placeholders} |
| `ValidBiomes` | `IReadOnlyList<string>` | Biomes where template can appear |
| `RoomType` | `RoomType` | Type of room produced |
| `Slots` | `IReadOnlyList<TemplateSlot>` | Content slots |
| `Weight` | `int` | Selection weight |
| `MinDepth` | `int` | Minimum depth restriction |
| `MaxDepth` | `int?` | Maximum depth restriction |
| `Tags` | `IReadOnlyList<string>` | Filtering tags |

### 10.2 New Value Objects

| Value Object | Layer | Description |
|--------------|-------|-------------|
| `TemplateSlot` | Domain | Variable content position within a template |
| `SlotFillResult` | Domain | Result of filling template slots |

### 10.3 New Enums

| Enum | Layer | Values |
|------|-------|--------|
| `SlotType` | Domain | Monster, Item, Feature, Exit, Description, Hazard, Container |

---

## 11. Configuration File Schemas

### 11.1 Room Templates Configuration

**File:** `config/room-templates.json`

```json
{
  "$schema": "schemas/room-templates.schema.json",
  "version": "1.1",
  "templates": [
    {
      "templateId": "dungeon-corridor-narrow",
      "namePattern": "{adjective} Corridor",
      "descriptionPattern": "A {width} {material} corridor stretches {direction}. {atmosphere} {detail}",
      "validBiomes": ["dungeon", "ruins", "cave"],
      "roomType": "Standard",
      "weight": 40,
      "minDepth": 0,
      "maxDepth": null,
      "tags": ["corridor", "passage"],
      "slots": [
        {
          "slotId": "adjective",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.adjectives.corridor"
        },
        {
          "slotId": "width",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.dimensions.width"
        },
        {
          "slotId": "material",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.materials.wall"
        },
        {
          "slotId": "direction",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.directions"
        },
        {
          "slotId": "atmosphere",
          "type": "Description",
          "isRequired": false,
          "fillProbability": 0.7,
          "descriptorPool": "environmental.atmosphere"
        },
        {
          "slotId": "detail",
          "type": "Description",
          "isRequired": false,
          "fillProbability": 0.5,
          "descriptorPool": "room.details.corridor"
        },
        {
          "slotId": "monster_01",
          "type": "Monster",
          "isRequired": false,
          "fillProbability": 0.35,
          "minQuantity": 1,
          "maxQuantity": 2,
          "constraints": {
            "maxTier": "standard",
            "categories": "humanoid,beast"
          }
        },
        {
          "slotId": "item_01",
          "type": "Item",
          "isRequired": false,
          "fillProbability": 0.15,
          "constraints": {
            "types": "consumable,treasure"
          }
        }
      ]
    },
    {
      "templateId": "dungeon-treasure-vault",
      "namePattern": "{guardian}'s {container_type}",
      "descriptionPattern": "A {size} chamber filled with {treasure_description}. {guardian_hint}",
      "validBiomes": ["dungeon", "ruins"],
      "roomType": "Treasure",
      "weight": 8,
      "minDepth": 2,
      "maxDepth": null,
      "tags": ["treasure", "vault", "guarded"],
      "slots": [
        {
          "slotId": "guardian",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "npcs.guardian_types"
        },
        {
          "slotId": "container_type",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.container_names"
        },
        {
          "slotId": "size",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.dimensions.size"
        },
        {
          "slotId": "treasure_description",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.treasure_descriptions"
        },
        {
          "slotId": "guardian_hint",
          "type": "Description",
          "isRequired": false,
          "fillProbability": 0.8,
          "descriptorPool": "room.guardian_hints"
        },
        {
          "slotId": "guardian_monster",
          "type": "Monster",
          "isRequired": true,
          "fillProbability": 1.0,
          "minQuantity": 1,
          "maxQuantity": 1,
          "constraints": {
            "minTier": "elite"
          }
        },
        {
          "slotId": "main_container",
          "type": "Container",
          "isRequired": true,
          "fillProbability": 1.0,
          "constraints": {
            "containerType": "chest",
            "lootQuality": "high"
          }
        },
        {
          "slotId": "bonus_loot",
          "type": "Item",
          "isRequired": false,
          "fillProbability": 0.5,
          "minQuantity": 1,
          "maxQuantity": 3
        }
      ]
    },
    {
      "templateId": "cave-crystal-chamber",
      "namePattern": "Crystal {chamber_type}",
      "descriptionPattern": "{crystal_description} {lighting_effect} {sound_description}",
      "validBiomes": ["cave"],
      "roomType": "Standard",
      "weight": 25,
      "minDepth": 1,
      "maxDepth": 5,
      "tags": ["crystal", "natural"],
      "slots": [
        {
          "slotId": "chamber_type",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.cave_chamber_types"
        },
        {
          "slotId": "crystal_description",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.crystal_descriptions"
        },
        {
          "slotId": "lighting_effect",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "environmental.lighting.crystal"
        },
        {
          "slotId": "sound_description",
          "type": "Description",
          "isRequired": false,
          "fillProbability": 0.6,
          "descriptorPool": "environmental.sounds.cave"
        },
        {
          "slotId": "monster_01",
          "type": "Monster",
          "isRequired": false,
          "fillProbability": 0.25,
          "minQuantity": 1,
          "maxQuantity": 3,
          "constraints": {
            "categories": "beast,elemental"
          }
        }
      ]
    },
    {
      "templateId": "volcanic-lava-bridge",
      "namePattern": "{condition} Bridge",
      "descriptionPattern": "A {material} bridge spans a {chasm_type}. {heat_description} {danger_warning}",
      "validBiomes": ["volcanic"],
      "roomType": "Standard",
      "weight": 20,
      "minDepth": 4,
      "maxDepth": null,
      "tags": ["bridge", "dangerous", "lava"],
      "slots": [
        {
          "slotId": "condition",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.conditions.structure"
        },
        {
          "slotId": "material",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.materials.volcanic"
        },
        {
          "slotId": "chasm_type",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.chasms.volcanic"
        },
        {
          "slotId": "heat_description",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "environmental.temperature.volcanic"
        },
        {
          "slotId": "danger_warning",
          "type": "Description",
          "isRequired": false,
          "fillProbability": 0.7,
          "descriptorPool": "room.danger_warnings"
        },
        {
          "slotId": "hazard_01",
          "type": "Hazard",
          "isRequired": false,
          "fillProbability": 0.4,
          "constraints": {
            "hazardType": "environmental",
            "element": "fire"
          }
        }
      ]
    }
  ]
}
```

### 11.2 JSON Schema

**File:** `config/schemas/room-templates.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "room-templates.schema.json",
  "title": "Room Templates Configuration",
  "description": "Schema for room template definitions with variable content slots",
  "type": "object",
  "required": ["version", "templates"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+$"
    },
    "templates": {
      "type": "array",
      "items": {
        "$ref": "#/$defs/roomTemplate"
      }
    }
  },
  "$defs": {
    "roomTemplate": {
      "type": "object",
      "required": ["templateId", "namePattern", "descriptionPattern", "validBiomes", "roomType", "weight"],
      "properties": {
        "templateId": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "description": "Unique template identifier"
        },
        "namePattern": {
          "type": "string",
          "description": "Room name with {placeholders}"
        },
        "descriptionPattern": {
          "type": "string",
          "description": "Room description with {placeholders}"
        },
        "validBiomes": {
          "type": "array",
          "items": { "type": "string" },
          "minItems": 1,
          "description": "Biomes where template can appear"
        },
        "roomType": {
          "type": "string",
          "enum": ["Standard", "Entrance", "Exit", "Treasure", "Boss", "Safe"],
          "description": "Type of room this template produces"
        },
        "weight": {
          "type": "integer",
          "minimum": 1,
          "description": "Selection weight for random selection"
        },
        "minDepth": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Minimum depth (Z-level)"
        },
        "maxDepth": {
          "type": ["integer", "null"],
          "minimum": 0,
          "default": null,
          "description": "Maximum depth (null = no limit)"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "default": [],
          "description": "Filtering tags"
        },
        "slots": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/templateSlot"
          },
          "default": [],
          "description": "Content slots"
        }
      }
    },
    "templateSlot": {
      "type": "object",
      "required": ["slotId", "type"],
      "properties": {
        "slotId": {
          "type": "string",
          "description": "Unique slot identifier within template"
        },
        "type": {
          "type": "string",
          "enum": ["Monster", "Item", "Feature", "Exit", "Description", "Hazard", "Container"],
          "description": "Type of content this slot accepts"
        },
        "isRequired": {
          "type": "boolean",
          "default": false,
          "description": "Whether slot must be filled"
        },
        "fillProbability": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "default": 0.5,
          "description": "Probability of filling optional slots"
        },
        "minQuantity": {
          "type": "integer",
          "minimum": 0,
          "default": 1,
          "description": "Minimum content quantity"
        },
        "maxQuantity": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "Maximum content quantity"
        },
        "constraints": {
          "type": "object",
          "additionalProperties": { "type": "string" },
          "default": {},
          "description": "Content selection constraints"
        },
        "descriptorPool": {
          "type": "string",
          "description": "Descriptor pool path for Description slots"
        }
      }
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `TemplateSelectionService` | Information | Template selected for context |
| `TemplateSelectionService` | Debug | Filter results, weight calculations |
| `TemplateSelectionService` | Warning | No valid templates, using fallback |
| `TemplateValidationService` | Information | Validation summary |
| `TemplateValidationService` | Debug | Individual validation checks |
| `TemplateValidationService` | Warning | Non-fatal validation issues |
| `TemplateValidationService` | Error | Critical validation failures |

### 12.2 Log Message Examples

```
// Information
[TemplateSelectionService] Selected template 'dungeon-corridor-narrow' for Biome=dungeon, Depth=2

// Debug
[TemplateSelectionService] Found 5 valid templates for Biome=dungeon, Depth=2
[TemplateSelectionService] Weighted selection: total=100, roll=45, selected='dungeon-chamber'
[TemplateValidationService] Validated template 'dungeon-corridor-narrow': 0 errors, 1 warning

// Warning
[TemplateSelectionService] No valid templates for Biome=volcanic, Depth=1, using fallback
[TemplateValidationService] Biome 'ancient-ruins' is not in the known biome list

// Error
[TemplateValidationService] Template 'broken-template' has invalid configuration: negative weight
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| RoomTemplate entity | 6 |
| TemplateSlot value object | 5 |
| TemplateSelectionService | 5 |
| TemplateValidationService | 4 |
| **Total** | **~20** |

### 13.2 Test Categories

#### RoomTemplate Tests

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/RoomTemplateTests.cs`

1. `Constructor_WithValidParameters_CreatesTemplate`
2. `Constructor_WithEmptyTemplateId_ThrowsArgumentException`
3. `Constructor_WithNoValidBiomes_ThrowsArgumentException`
4. `IsValidForBiome_WithMatchingBiome_ReturnsTrue`
5. `IsValidForDepth_WithinRange_ReturnsTrue`
6. `HasAllTags_WithAllTagsPresent_ReturnsTrue`

#### TemplateSlot Tests

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/TemplateSlotTests.cs`

1. `Monster_CreatesCorrectSlotType`
2. `Description_WithPool_SetsDescriptorPool`
3. `GetConstraint_WithExistingKey_ReturnsValue`
4. `EffectiveFillProbability_Required_ReturnsOne`
5. `EffectiveFillProbability_Optional_ReturnsProbability`

#### TemplateSelectionService Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/TemplateSelectionServiceTests.cs`

1. `SelectTemplate_WithValidContext_ReturnsMatchingTemplate`
2. `SelectTemplate_WithNoMatches_ReturnsNull`
3. `GetValidTemplates_FiltersByBiome_ReturnsOnlyMatching`
4. `GetValidTemplates_FiltersByDepth_ReturnsOnlyInRange`
5. `WeightedSelect_HigherWeight_MoreLikelySelected`

#### TemplateValidationService Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/TemplateValidationServiceTests.cs`

1. `ValidateTemplate_ValidTemplate_ReturnsSuccess`
2. `ValidateTemplate_MissingBiomes_ReturnsError`
3. `ValidateSlot_DescriptionWithoutPool_ReturnsError`
4. `ValidateAllTemplates_ReturnsResultsForAllTemplates`

---

## 14. Use Cases

### UC-001: Select Template for Room Generation
**Actor:** RoomGeneratorService (System)
**Flow:** Determine context (biome, depth) → Call TemplateSelectionService.SelectTemplate() → Receive matching template → Use template for room creation

### UC-002: Fill Template Slots
**Actor:** RoomGeneratorService (System)
**Flow:** Iterate template slots → Check fill probability → For each filled slot: determine quantity → Select content based on type and constraints → Return SlotFillResult

### UC-003: Validate Template Configuration
**Actor:** Configuration System (Startup)
**Flow:** Load room-templates.json → Call TemplateValidationService.ValidateAllTemplates() → Log warnings/errors → Fail startup if critical errors

### UC-004: Generate Room Name from Pattern
**Actor:** RoomGeneratorService (System)
**Flow:** Get template name pattern → Fill description slots → Replace {placeholders} with slot content → Return generated name

### UC-005: Filter Templates by Tags
**Actor:** RoomGeneratorService (System)
**Flow:** Create context with required/excluded tags → Call GetValidTemplates() → Receive filtered list → Select from filtered templates

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `RoomTemplate` entity created with all properties
- [ ] `TemplateSlot` value object with factory methods
- [ ] `SlotFillResult` value object for tracking results
- [ ] `SlotType` enum with all content types

### Application Layer
- [ ] `ITemplateSelectionService` interface defined
- [ ] `TemplateSelectionService` implementation
- [ ] `ITemplateValidationService` interface defined
- [ ] `TemplateValidationService` implementation
- [ ] `TemplateSelectionContext` record defined
- [ ] `TemplateValidationResult` record defined

### Configuration
- [ ] `config/room-templates.json` created with 4+ templates
- [ ] `config/schemas/room-templates.schema.json` created
- [ ] JSON validates against schema

### Infrastructure
- [ ] `JsonConfigurationProvider` loads room templates
- [ ] DI registration for new services

### Testing
- [ ] ~20 unit tests implemented
- [ ] All tests passing
- [ ] Test coverage for all services

---

## 16. Acceptance Criteria

### Functional
- [ ] RoomTemplate entity created with all specified properties
- [ ] TemplateSlot value object supports all 7 slot types
- [ ] SlotType enum covers Monster, Item, Feature, Exit, Description, Hazard, Container
- [ ] Templates load from JSON configuration
- [ ] Template selection filters by biome correctly
- [ ] Template selection filters by depth correctly
- [ ] Template selection respects tag requirements
- [ ] Weighted random selection works correctly
- [ ] Required slots must always be filled
- [ ] Optional slots respect fill probability
- [ ] Description patterns resolve descriptor pool references
- [ ] Validation detects missing required fields
- [ ] Validation detects invalid slot configurations

### Quality
- [ ] Build succeeds with 0 errors and 0 warnings
- [ ] All ~20 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete for all public APIs
- [ ] Logging follows specified patterns

---

## 17. Dependencies

### Requires (from prior versions)
- v0.1.0d: Map Command & Polish complete
- v0.1.0b: `RoomTemplateConfiguration` class (to be enhanced)
- v0.0.11a: `EnvironmentContext`, biome system
- v0.0.4a: `DescriptorService` for pool references

### Provides (for future versions)
- `RoomTemplate` entity for v0.1.1b seeded generation
- `TemplateSelectionService` for v0.1.1c difficulty scaling
- Slot system for v0.1.1d branch generation

---

## 18. Future Considerations

### Deferred to v0.1.1b: Seeded Generation
- `SeededRandom` wrapper for reproducible selection
- Position-based sub-seed derivation
- Seed display and input commands

### Deferred to v0.1.1c: Difficulty Scaling
- Depth-based content difficulty modifiers
- Template difficulty ratings
- Scaled monster/loot selection

### Deferred to v0.1.1d: Branch Generation
- Multi-path dungeon layouts
- Branch template connections
- Dead-end probability

### Out of Scope
- Visual template editor (potential future tool)
- Runtime template hot-reloading
- Template inheritance/composition

---

*Document Version: 1.0*
*Last Updated: 2026-01-08*
*Author: Claude*
