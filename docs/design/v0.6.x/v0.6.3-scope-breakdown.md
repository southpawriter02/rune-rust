# v0.6.3 Input Enhancements - Scope Breakdown

**Version:** 0.6.3
**Theme:** Input Enhancements
**Prerequisites:** v0.6.2b Complete (Combat Display - Combat Animations)
**Total Estimated Tests:** ~25 new tests

---

## Executive Summary

The Input Enhancements sub-version improves user input handling with command history navigation (arrow keys to recall previous commands) and tab completion for auto-completing commands, item names, and target names. These quality-of-life features reduce typing errors and speed up gameplay.

Key focus areas:
- **Command History**: Arrow key navigation through previously entered commands
- **Tab Completion**: Auto-complete for commands, items, targets, and directions

The work is divided into **two sub-parts**:

| Part | Name | Focus | Est. Tests |
|------|------|-------|------------|
| v0.6.3a | Command History | History storage, arrow key navigation, recall | ~10 |
| v0.6.2b | Tab Completion | Completion sources, matching, popup display | ~15 |

---

## Existing Infrastructure

### Already Implemented (from v0.6.1-v0.6.3)

| Feature | Location | Notes |
|---------|----------|-------|
| ScreenLayout | `Presentation/UI/ScreenLayout.cs` | Input panel |
| ITerminalService | `Application/Interfaces/ITerminalService.cs` | Console operations |
| CommandHandler | `Presentation/Commands/CommandHandler.cs` | Input processing |
| Panel (Input) | `Presentation/UI/Panel.cs` | Input area |

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| Command parsing | `Presentation/Commands/*` | Command definitions |
| Item names | `Domain/Entities/Item.cs` | Item references |
| Monster names | `Domain/Entities/Monster.cs` | Target names |
| Direction enum | `Domain/Enums/Direction.cs` | Movement directions |

### Needs Implementation (v0.6.3)

| Feature | Part | Notes |
|---------|------|-------|
| ICommandHistoryService | v0.6.3a | History interface |
| CommandHistoryService | v0.6.3a | History management |
| InputHandler updates | v0.6.3a | Arrow key handling |
| ITabCompletionService | v0.6.2b | Completion interface |
| TabCompletionService | v0.6.2b | Completion logic |
| ICompletionSource | v0.6.2b | Completion data sources |
| CompletionPopup | v0.6.2b | Suggestion display |

---

## Feature Analysis & Categorization

### Command History Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| History storage | Low | None | **v0.6.3a** |
| Arrow key navigation | Medium | InputHandler | **v0.6.3a** |
| History size limit | Low | Configuration | **v0.6.3a** |
| Duplicate prevention | Low | History service | **v0.6.3a** |

### Tab Completion Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| Completion framework | Medium | InputHandler | **v0.6.2b** |
| Command completion | Medium | Command list | **v0.6.2b** |
| Item name completion | Medium | Inventory | **v0.6.2b** |
| Target name completion | Medium | Current room/combat | **v0.6.2b** |
| Direction completion | Low | Direction enum | **v0.6.2b** |
| Suggestion popup | Medium | Terminal service | **v0.6.2b** |

---

## Part Definitions

---

## v0.6.3a: Command History

[v0.6.3a Design Specification](v0.6.3a-design-specification.md)

### Overview

Implement command history functionality that stores previously entered commands and allows navigation through them using arrow keys. This enables quick repetition of commands without retyping.

### Scope

**In Scope:**
- `ICommandHistoryService` interface
- `CommandHistoryService` implementation
- History storage (in-memory, session-based)
- Up arrow to recall previous command
- Down arrow to move forward in history
- Configurable history size limit (default 100)
- Duplicate command handling (move to front)
- Empty command exclusion
- History position tracking
- Current input preservation when navigating

**Out of Scope:**
- Persistent history across sessions (future)
- History search (Ctrl+R style, future)
- Tab completion (v0.6.2b)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Application Interfaces | 1 | `ICommandHistoryService` |
| Application Services | 1 | `CommandHistoryService` |
| Presentation Updates | 1 | `InputHandler` arrow key support |
| Configuration | 1 | `input.json` (history section) |
| Unit Tests | ~10 | History navigation, storage tests |

### Command History Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                  COMMAND HISTORY ARCHITECTURE                        │
└─────────────────────────────────────────────────────────────────────┘

    User Input                   History Service              Display
    ──────────                   ───────────────              ───────

    [Enter "attack skeleton"] ──────────┐
                                        │
                               ┌────────▼────────────────┐
                               │  CommandHistoryService  │
                               ├─────────────────────────┤
                               │  History:               │
                               │    [0] "attack skeleton"│◄── Most recent
                               │    [1] "look"           │
                               │    [2] "inventory"      │
                               │    [3] "go north"       │
                               │    ...                  │
                               │  CurrentIndex: -1       │◄── -1 = new input
                               └─────────────────────────┘
    
    [UP ARROW] ─────────────────────────▶ CurrentIndex: 0
                                         ──────────────────▶ "attack skeleton"
    
    [UP ARROW] ─────────────────────────▶ CurrentIndex: 1
                                         ──────────────────▶ "look"
    
    [DOWN ARROW] ───────────────────────▶ CurrentIndex: 0
                                         ──────────────────▶ "attack skeleton"
    
    [DOWN ARROW] ───────────────────────▶ CurrentIndex: -1
                                         ──────────────────▶ "" (empty/new)
```

### ICommandHistoryService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Manages command history for input recall.
/// </summary>
public interface ICommandHistoryService
{
    /// <summary>Adds a command to history.</summary>
    void Add(string command);
    
    /// <summary>Gets the previous command (up arrow).</summary>
    string? GetPrevious();
    
    /// <summary>Gets the next command (down arrow).</summary>
    string? GetNext();
    
    /// <summary>Resets navigation to the end (new command position).</summary>
    void ResetNavigation();
    
    /// <summary>Gets the current history count.</summary>
    int Count { get; }
    
    /// <summary>Gets the maximum history size.</summary>
    int MaxSize { get; }
    
    /// <summary>Clears all history.</summary>
    void Clear();
    
    /// <summary>Gets all commands in history (newest first).</summary>
    IReadOnlyList<string> GetAll();
}
```

### CommandHistoryService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class CommandHistoryService : ICommandHistoryService
{
    private readonly List<string> _history = new();
    private int _currentIndex = -1;
    private string? _tempInput;  // Stores current input when navigating
    
    public int MaxSize { get; }
    public int Count => _history.Count;
    
    public CommandHistoryService(int maxSize = 100)
    {
        MaxSize = maxSize;
    }
    
    public void Add(string command)
    {
        if (string.IsNullOrWhiteSpace(command))
            return;
        
        // Remove duplicate if exists
        _history.Remove(command);
        
        // Add to front
        _history.Insert(0, command);
        
        // Trim to max size
        while (_history.Count > MaxSize)
            _history.RemoveAt(_history.Count - 1);
        
        ResetNavigation();
    }
    
    public string? GetPrevious()
    {
        if (_history.Count == 0)
            return null;
        
        if (_currentIndex < _history.Count - 1)
        {
            _currentIndex++;
            return _history[_currentIndex];
        }
        
        return _history[_currentIndex];  // Stay at oldest
    }
    
    public string? GetNext()
    {
        if (_currentIndex > 0)
        {
            _currentIndex--;
            return _history[_currentIndex];
        }
        
        if (_currentIndex == 0)
        {
            _currentIndex = -1;
            return _tempInput ?? "";  // Return to new input
        }
        
        return null;
    }
    
    public void ResetNavigation()
    {
        _currentIndex = -1;
        _tempInput = null;
    }
    
    // ... remaining implementation
}
```

### Command History Usage Flow

```
USAGE EXAMPLE:
──────────────

1. User types and executes commands:
   > attack skeleton     [Enter]  → Added to history
   > look               [Enter]  → Added to history  
   > inventory          [Enter]  → Added to history
   > go north           [Enter]  → Added to history

   History: ["go north", "inventory", "look", "attack skeleton"]
            (newest first)

2. User navigates with arrow keys:
   > _                          ← Current input (empty)
   
   [UP ARROW]
   > go north                   ← Recalled from history
   
   [UP ARROW]
   > inventory                  ← Previous command
   
   [UP ARROW]
   > look                       ← Previous command
   
   [DOWN ARROW]
   > inventory                  ← Move forward
   
   [DOWN ARROW]
   > go north                   ← Move forward
   
   [DOWN ARROW]
   > _                          ← Back to empty (new)


DUPLICATE HANDLING:
───────────────────

History: ["go north", "inventory", "look"]

User types: > look [Enter]

History becomes: ["look", "go north", "inventory"]
                 (look moved to front, not duplicated)


CURRENT INPUT PRESERVATION:
───────────────────────────

> atta_                         ← User typing (cursor at _)

[UP ARROW]
> go north                      ← History recalled

[DOWN ARROW]  
> atta_                         ← Original input restored!
```

### History Configuration

```json
{
  "$schema": "./schemas/input.schema.json",
  "commandHistory": {
    "enabled": true,
    "maxEntries": 100,
    "excludeEmpty": true,
    "moveDuplicatesToFront": true,
    "persistSession": false
  }
}
```

### Acceptance Criteria

- [ ] Commands are added to history on Enter
- [ ] Up arrow recalls previous command
- [ ] Down arrow moves forward in history
- [ ] Down arrow at end returns to new input
- [ ] History has configurable max size
- [ ] Duplicates are moved to front (not duplicated)
- [ ] Empty commands are not added
- [ ] Current input is preserved when navigating
- [ ] History resets after command execution
- [ ] ~10 unit tests pass

---

## v0.6.2b: Tab Completion

[v0.6.2b Design Specification](v0.6.2b-design-specification.md)

### Overview

Implement tab completion functionality that auto-completes partial input for commands, item names, target names, and directions. When multiple matches exist, a popup displays available options.

### Scope

**In Scope:**
- `ITabCompletionService` interface
- `TabCompletionService` implementation
- `ICompletionSource` interface for data sources
- `CommandCompletionSource` for commands
- `ItemCompletionSource` for inventory items
- `TargetCompletionSource` for valid targets
- `DirectionCompletionSource` for movement
- Single match: complete inline
- Multiple matches: show popup
- Case-insensitive matching
- Context-aware completion (e.g., attack → targets)
- Tab cycles through multiple matches
- Escape to cancel completion

**Out of Scope:**
- Fuzzy matching (future)
- Command history completion (future)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Application Interfaces | 2 | `ITabCompletionService`, `ICompletionSource` |
| Application Services | 1 | `TabCompletionService` |
| Completion Sources | 4 | Commands, Items, Targets, Directions |
| Presentation Classes | 1 | `CompletionPopup` |
| Configuration | 1 | `input.json` (completion section) |
| Unit Tests | ~15 | Completion matching, popup tests |

### Tab Completion Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                  TAB COMPLETION ARCHITECTURE                         │
└─────────────────────────────────────────────────────────────────────┘

    Partial Input                Completion Service           Sources
    ─────────────                ──────────────────           ───────
    
    "att"  ──────────────────┐
           [TAB]             │   ┌─────────────────────────┐
                             └──▶│  TabCompletionService   │
                                 ├─────────────────────────┤
                                 │ GetCompletions(input)   │
                                 └───────────┬─────────────┘
                                             │
             ┌───────────────────────────────┼───────────────────────────────┐
             ▼                               ▼                               ▼
    ┌─────────────────┐           ┌─────────────────┐           ┌─────────────────┐
    │ CommandSource   │           │  ItemSource     │           │ TargetSource    │
    ├─────────────────┤           ├─────────────────┤           ├─────────────────┤
    │ attack          │           │ (not contextual)│           │ (not contextual)│
    │ ✓ matches!      │           └─────────────────┘           └─────────────────┘
    └─────────────────┘
             │
             ▼
    Single match: "attack" ──────────────────────────────▶ Complete inline
    
    
    "attack sk"  ────────────┐
              [TAB]          │   ┌─────────────────────────┐
                             └──▶│  TabCompletionService   │
                                 │  Context: "attack"      │◄─ Knows we need target
                                 └───────────┬─────────────┘
                                             │
                                             ▼
                                  ┌─────────────────┐
                                  │ TargetSource    │
                                  ├─────────────────┤
                                  │ skeleton        │
                                  │ ✓ matches!      │
                                  └─────────────────┘
                                             │
                                             ▼
    Single match: "attack skeleton" ─────────────────────▶ Complete inline
```

### ITabCompletionService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides tab completion for user input.
/// </summary>
public interface ITabCompletionService
{
    /// <summary>Gets all completions for partial input.</summary>
    IReadOnlyList<string> GetCompletions(string partialInput, CompletionContext context);
    
    /// <summary>Gets the best single completion, or null if multiple/none.</summary>
    string? GetBestCompletion(string partialInput, CompletionContext context);
    
    /// <summary>Registers a completion source.</summary>
    void RegisterSource(ICompletionSource source);
    
    /// <summary>Unregisters a completion source.</summary>
    void UnregisterSource(ICompletionSource source);
}

/// <summary>
/// Provides completion candidates for a category.
/// </summary>
public interface ICompletionSource
{
    /// <summary>Gets the category this source provides (commands, items, etc.).</summary>
    string Category { get; }
    
    /// <summary>Gets the priority (higher = checked first).</summary>
    int Priority { get; }
    
    /// <summary>Checks if this source applies to the current context.</summary>
    bool AppliesTo(CompletionContext context);
    
    /// <summary>Gets matching completions for a prefix.</summary>
    IEnumerable<string> GetMatches(string prefix, CompletionContext context);
}

/// <summary>
/// Context information for completion.
/// </summary>
public record CompletionContext(
    string FullInput,           // Full input text
    string CurrentWord,         // Word being completed
    int WordIndex,              // Which word (0 = command, 1+ = arguments)
    string? CommandName,        // If known, the command being completed
    IReadOnlyList<string>? AvailableTargets,  // Valid targets in context
    IReadOnlyList<string>? InventoryItems     // Items player has
);
```

### Completion Sources

```csharp
namespace RuneAndRust.Application.Services.Completion;

/// <summary>
/// Provides command name completions.
/// </summary>
public class CommandCompletionSource : ICompletionSource
{
    private readonly IReadOnlyList<string> _commands;
    
    public string Category => "commands";
    public int Priority => 100;  // Highest for first word
    
    public bool AppliesTo(CompletionContext context) => context.WordIndex == 0;
    
    public IEnumerable<string> GetMatches(string prefix, CompletionContext context)
    {
        return _commands
            .Where(c => c.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            .OrderBy(c => c);
    }
}

/// <summary>
/// Provides target name completions (for attack, examine, etc.).
/// </summary>
public class TargetCompletionSource : ICompletionSource
{
    private static readonly HashSet<string> TargetCommands = 
        new() { "attack", "examine", "talk", "interact" };
    
    public string Category => "targets";
    public int Priority => 90;
    
    public bool AppliesTo(CompletionContext context) =>
        context.WordIndex == 1 && 
        TargetCommands.Contains(context.CommandName ?? "", StringComparer.OrdinalIgnoreCase);
    
    public IEnumerable<string> GetMatches(string prefix, CompletionContext context)
    {
        return context.AvailableTargets?
            .Where(t => t.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            .OrderBy(t => t) ?? Enumerable.Empty<string>();
    }
}

/// <summary>
/// Provides inventory item completions (for use, equip, drop, etc.).
/// </summary>
public class ItemCompletionSource : ICompletionSource
{
    private static readonly HashSet<string> ItemCommands = 
        new() { "use", "equip", "unequip", "drop", "examine" };
    
    public string Category => "items";
    public int Priority => 90;
    
    public bool AppliesTo(CompletionContext context) =>
        context.WordIndex == 1 && 
        ItemCommands.Contains(context.CommandName ?? "", StringComparer.OrdinalIgnoreCase);
    
    // ...
}

/// <summary>
/// Provides direction completions (for move, go, etc.).
/// </summary>
public class DirectionCompletionSource : ICompletionSource
{
    private static readonly string[] Directions = 
        { "north", "south", "east", "west", "up", "down" };
    
    public string Category => "directions";
    public int Priority => 90;
    
    public bool AppliesTo(CompletionContext context) =>
        context.WordIndex == 1 && 
        (context.CommandName?.Equals("move", StringComparison.OrdinalIgnoreCase) ?? false ||
         context.CommandName?.Equals("go", StringComparison.OrdinalIgnoreCase) ?? false);
    
    // ...
}
```

### Tab Completion Usage Flow

```
SINGLE MATCH - COMPLETE INLINE:
───────────────────────────────

> att[TAB]
> attack_                        ← Completes to "attack"

> attack sk[TAB]
> attack skeleton_               ← Completes to "attack skeleton"

> use hea[TAB]
> use healing-potion_            ← Completes item name


MULTIPLE MATCHES - SHOW POPUP:
──────────────────────────────

> a[TAB]
  ┌────────────────────┐
  │ attack             │
  │ abilities          │
  │ armor              │
  └────────────────────┘
> a_                             ← Popup shows options

> at[TAB]
> attack_                        ← Only one match now, completes


CYCLING THROUGH MATCHES:
────────────────────────

> use [TAB]                      ← Multiple items
  ┌────────────────────┐
  │ healing-potion     │◄─ Selected
  │ mana-potion        │
  │ antidote           │
  │ torch              │
  └────────────────────┘

> use [TAB]                      ← Tab again cycles
  ┌────────────────────┐
  │ healing-potion     │
  │ mana-potion        │◄─ Selected
  │ antidote           │
  │ torch              │
  └────────────────────┘

> use mana-potion_               ← Enter to accept

> use [ESC]                      ← Escape cancels popup
> use _


CONTEXT-AWARE COMPLETION:
─────────────────────────

After "attack ", only valid targets complete:

Room contains: Skeleton, Goblin

> attack [TAB]
  ┌────────────────────┐
  │ skeleton           │
  │ goblin             │
  └────────────────────┘

> attack s[TAB]
> attack skeleton_               ← Completes to skeleton


DIRECTION COMPLETION:
─────────────────────

> go [TAB]
  ┌────────────────────┐
  │ north              │
  │ south              │
  │ east               │
  │ west               │
  │ up                 │
  │ down               │
  └────────────────────┘

> go n[TAB]
> go north_
```

### Completion Popup Component

```csharp
namespace RuneAndRust.Presentation.UI;

/// <summary>
/// Displays completion suggestions as a popup.
/// </summary>
public class CompletionPopup
{
    private readonly ITerminalService _terminal;
    private readonly IColorThemeService _colorService;
    
    private int _selectedIndex = 0;
    private IReadOnlyList<string> _suggestions = Array.Empty<string>();
    private bool _isVisible = false;
    
    /// <summary>Shows the popup with suggestions.</summary>
    public void Show(IReadOnlyList<string> suggestions, int inputX, int inputY);
    
    /// <summary>Hides the popup.</summary>
    public void Hide();
    
    /// <summary>Moves selection up.</summary>
    public void SelectPrevious();
    
    /// <summary>Moves selection down.</summary>
    public void SelectNext();
    
    /// <summary>Gets the currently selected suggestion.</summary>
    public string? GetSelected();
    
    /// <summary>Gets whether the popup is visible.</summary>
    public bool IsVisible => _isVisible;
}
```

### Completion Configuration

```json
{
  "$schema": "./schemas/input.schema.json",
  "tabCompletion": {
    "enabled": true,
    "caseSensitive": false,
    "showPopup": true,
    "maxSuggestions": 10,
    "popupStyle": {
      "backgroundColor": "DarkGray",
      "textColor": "White",
      "selectedBackground": "Blue",
      "selectedText": "White"
    },
    "triggerKey": "Tab",
    "cancelKey": "Escape",
    "acceptKey": "Enter"
  }
}
```

### Acceptance Criteria

- [ ] Tab completes partial commands
- [ ] Single match completes inline
- [ ] Multiple matches show popup
- [ ] Popup displays up to max suggestions
- [ ] Arrow keys navigate popup
- [ ] Enter accepts selected completion
- [ ] Escape cancels popup
- [ ] Tab cycles through matches
- [ ] Completion is case-insensitive
- [ ] Context-aware (attack → targets)
- [ ] Item completion from inventory
- [ ] Direction completion for movement
- [ ] ~15 unit tests pass

---

## Dependencies & Prerequisites

```
v0.6.2b (Combat Animations) - REQUIRED
    │
    └── ScreenLayout, ITerminalService, InputHandler ─────────────────┐
                                                                      │
v0.6.3 (Input Enhancements)                                           │
    │                                                                 │
    ├── v0.6.3a: Command History ─────────────────────────────────────┤
    │       Dependencies: InputHandler                                │
    │       Provides: ICommandHistoryService, arrow key support       │
    │                                                                 │
    └── v0.6.2b: Tab Completion ──────────────────────────────────────┘
            Dependencies: v0.6.3a (InputHandler updates), game state
            Provides: ITabCompletionService, CompletionPopup
```

---

## Estimated Effort Summary

| Part | New Files | Modified Files | Est. Tests | Complexity |
|------|-----------|----------------|------------|------------|
| v0.6.3a | ~2 | ~1 | ~10 | Medium |
| v0.6.2b | ~5 | ~1 | ~15 | High |
| **Total** | **~7** | **~2** | **~25** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Key handling across terminals | Medium | Medium | Abstract via ITerminalService |
| Popup positioning edge cases | Low | Medium | Bounds checking |
| Context detection complexity | Medium | Low | Clear command categorization |
| Performance with many completions | Low | Low | Limit display count |

---

## Design Decisions (Confirmed)

### Command History

| Decision | Value | Notes |
|----------|-------|-------|
| **Storage** | In-memory | Session-only |
| **Max Size** | 100 entries | Configurable |
| **Duplicates** | Move to front | Don't create duplicates |
| **Navigation** | Up/Down arrows | Standard convention |

### Tab Completion

| Decision | Value | Notes |
|----------|-------|-------|
| **Trigger** | Tab key | Standard convention |
| **Case Sensitivity** | Insensitive | User-friendly |
| **Max Suggestions** | 10 | Avoid clutter |
| **Cycling** | Tab cycles selection | Common pattern |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.6.3a Design Spec** - Create detailed design for Command History
3. **v0.6.3a Implementation** - Build history service and arrow key handling
4. **v0.6.2b Design Spec** - Create specification for Tab Completion
5. **v0.6.2b Implementation** - Build completion service, sources, and popup

---

*This scope breakdown completes the v0.6.0 TUI Enhancements series. The input enhancements significantly improve the user experience by reducing typing and enabling quick command recall. v0.6.3 completion marks the transition point to v0.7.0 GUI Foundation.*
