# Version 0.3.0: The Trauma Economy

**Status:** Complete
**Milestone:** Milestone 4 - Core Systems Layer
**Theme:** Psychological Horror Mechanics

## Table of Contents
- [Overview](#overview)
- [Phase A: The Weight (Psychic Stress & Resolve)](#phase-a-the-weight-psychic-stress--resolve)
- [Phase B: The Stain (Corruption & Tiers)](#phase-b-the-stain-corruption--tiers)
- [Phase C: The Scar (Consequences)](#phase-c-the-scar-consequences)
- [Changelog (v0.3.0)](#changelog-v030)

## Overview

This milestone introduces the psychological horror engine of Aethelgard. Unlike standard RPGs where health is the only survival metric, Rune & Rust tracks **Psychic Stress** (volatile, recoverable) and **Runic Blight Corruption** (permanent, transformative).

The Trauma Economy is implemented across three phases:

- **Phase A (v0.3.0a): The Weight** - Psychic Stress resource and Resolve Check mechanic
- **Phase B (v0.3.0b): The Stain** - Corruption tiers and permanent penalties
- **Phase C (v0.3.0c): The Scar** - Breaking Points and permanent Traumas

---

## Phase A: The Weight (Psychic Stress & Resolve)

**Goal:** Implement the PsychicStress resource (0-100), the TraumaService to handle accumulation via WILL-based Resolve Checks, and update the UI to visualize mental state.

### Architecture & Data Flow

**Concept:** Unlike Health (which depletes), Stress accumulates. The "Armor" against Stress is Resolve—a reactive check made at the moment of exposure.

**Workflow: Stress Application**

1. **Trigger:** An event (Enemy Ability, Environmental Hazard, Spell Cast) calls `TraumaService.InflictStress(target, amount, source)`.
2. **Validation:** Service checks if target is immune or dead.
3. **Resolve Check:**
   - Retrieve Target's WILL attribute.
   - Call `DiceService.Roll(WILL)`.
   - Calculate Mitigation = Successes (rolls ≥ 8).
4. **Net Calculation:** `NetStress = Math.Max(0, RawAmount - Mitigation)`.
5. **Application:** `Target.PsychicStress += NetStress` (Clamped to 100).
6. **Feedback:** Log the interaction and return the result.
7. **Notification:** If Stress reaches 100, flag BreakingPointReached (logic stub for v0.3.0c).

### Logic Decision Trees

#### A. Resolve Check Logic
**Input:** Character, RawStressAmount

1. **Get Dice Pool:**
   - Base = Character.Attributes.WILL.
   - Bonus: +2 if [Fortified] (Mental).
   - Penalty: -2 if [Disoriented] or Fury > 0 (Berserkr).
2. **Roll:** Execute standard d10 pool. Count Successes.
3. **Calculate Net:** RawStress - SuccessCount.
4. **Is Net > 0?**
   - Yes: Apply to Character. Return "Character takes X Stress."
   - No: Return "Character resists the madness."

#### B. Stress Tier Calculation (UI Display)
**Input:** CurrentStress (0-100)

1. **0-19:** Stable (No effect).
2. **20-39:** Unsettled (UI text occasionally flickers/leetspeak substitutions).
3. **40-59:** Shaken (Minor visual glitches).
4. **60-79:** Distressed (Purple UI tint/warnings).
5. **80-99:** Fractured (Severe visual distortion).
6. **100:** BREAKING POINT (Flashing/Inverted colors).

### Code Implementation

#### A. Core Layer (Entity Update)
Update the Character model to track stress.

**File:** `RuneAndRust.Core/Entities/Character.cs`

```csharp
public partial class Character
{
    // 0 = Stable, 100 = Breaking Point
    public int PsychicStress { get; set; } = 0;
    public const int MaxPsychicStress = 100;

    // Helper to determine visual tier
    public string StressStatus => PsychicStress switch
    {
        >= 100 => "BREAKING",
        >= 80 => "Fractured",
        >= 60 => "Distressed",
        >= 40 => "Shaken",
        >= 20 => "Unsettled",
        _ => "Stable"
    };
}
```

#### B. Engine Layer (Trauma Service)
Implement the logic for resisting and applying stress.

**File:** `RuneAndRust.Engine/Services/TraumaService.cs`

```csharp
public class TraumaService : ITraumaService
{
    private readonly IDiceService _dice;
    private readonly ILogger _logger;

    public TraumaService(IDiceService dice, ILogger logger)
    {
        _dice = dice;
        _logger = logger;
    }

    public StressResult InflictStress(Character target, int rawAmount, string source)
    {
        // 1. Resolve Check (WILL check)
        var will = target.GetAttribute(Attribute.Will);
        // Future: Check for [Disoriented] or other modifiers here

        var roll = _dice.RollSingle(10, $"Resolve Check ({source})");
        // Simplified: In standard d10 pool, we roll 'will' number of dice.
        // For v0.3.0a, we assume IDiceService supports RollPool(int diceCount)
        var poolResult = _dice.RollPool(will, $"Resolve vs {source}");

        int mitigated = poolResult.Successes;
        int netStress = Math.Max(0, rawAmount - mitigated);

        // 2. Application
        int oldStress = target.PsychicStress;
        target.PsychicStress = Math.Clamp(target.PsychicStress + netStress, 0, Character.MaxPsychicStress);

        // 3. Logging
        _logger.LogInformation(
            "{Name} Resolve Check vs {Source}: Rolled {Successes} successes. Stress {Old}->{New} (+{Net}).",
            target.Name, source, mitigated, oldStress, target.PsychicStress, netStress);

        return new StressResult(
            Raw: rawAmount,
            Mitigated: mitigated,
            NetApplied: netStress,
            CurrentTotal: target.PsychicStress,
            IsBreakingPoint: target.PsychicStress >= Character.MaxPsychicStress
        );
    }
}
```

#### C. Terminal Layer (Renderer Update)
Update the HUD to show the new bar.

**File:** `RuneAndRust.Terminal/Services/TuiRenderer.cs`

```csharp
// Inside RenderHeader()
var stressColor = character.PsychicStress switch
{
    >= 80 => "red",
    >= 50 => "magenta",
    >= 20 => "plum2",
    _ => "grey"
};

// Render bar: [=====     ] 50%
// Uses Spectre.Console markup
var stressBar = CreateProgressBar(character.PsychicStress, 100, stressColor);
table.AddRow("Stress", stressBar, $"[{stressColor}]{character.StressStatus}[/]");
```

### Logging Requirements

**Reference:** logging-matrix.md

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Trauma | Resolve Check | Debug | "Rolled WILL ({Pool}d10) vs Stress: {Successes} successes." | Pool, Successes |
| Trauma | Stress Applied | Info | "{Name} gained {Net} stress from {Source} (Raw: {Raw}). Total: {Current}." | Name, Net, Source, Raw, Current |
| Trauma | Breaking Point | Warning | "{Name} reached BREAKING POINT (100 Stress)!" | Name |

### Testing Requirements

#### Unit Tests (TraumaServiceTests.cs)

- **Resolve_Calculation:**
  - Mock DiceService to return 2 successes.
  - Call `InflictStress(target, 5, "Test")`.
  - Assert NetApplied is 3 (5 - 2).
- **Clamping_Max:**
  - Set Target Stress to 95.
  - Inflict 10 Net Stress.
  - Assert CurrentTotal is 100 (not 105).
- **Zero_Stress:**
  - Inflict 5 Stress, Mock 6 Successes.
  - Assert NetApplied is 0 (no negative stress).

#### Integration Tests

- **Persistence:**
  - Set Stress to 45. Save Game. Load Game.
  - Assert Stress is 45.
- **Combat Flow:**
  - Simulate enemy attack with "Psychic" damage type.
  - Ensure TraumaService is triggered alongside/instead of Health damage.

### Deliverable Checklist (Phase A)

- **Core:**
  - [ ] Add PsychicStress property to Character entity.
  - [ ] Add StressResult record.
  - [ ] Define ITraumaService interface.
- **Engine:**
  - [ ] Implement TraumaService.
  - [ ] Integrate DiceService into TraumaService for WILL checks.
  - [ ] Register ITraumaService in DI container.
- **Terminal:**
  - [ ] Update Character Sheet UI to display Stress Bar.
  - [ ] Update HUD to show Stress status (Stable/Shaken/etc.).
- **Testing:**
  - [ ] Write unit tests for mitigation logic.
  - [ ] Verify stress does not reset on combat end.

---

## Phase B: The Stain (Corruption & Tiers)

**Goal:** Implement the Corruption resource (0-100), the tiered penalty system affecting Max AP and Attributes, and the "Terminal Error" state that permanently retires a character.

### Architecture & Data Flow

**Concept:** Corruption is a "High Water Mark" mechanic. It scales up easily but requires significant, rare resources to lower. It acts as a global modifier on the character's effectiveness.

**Workflow: The Corruption Cycle**

1. **Trigger:** Event (Heretical Spell, Artifact Backfire, Enemy Attack) calls `TraumaService.AddCorruption(amount)`.
2. **State Update:**
   - Character.Corruption increases.
   - Tier Check: Determine if a threshold (20, 40, 60, 80) was crossed.
3. **Penalty Recalculation:**
   - StatCalculationService observes the change.
   - Recalculates MaxAp and Attribute effective values based on the new Tier.
4. **Terminal Check:**
   - If Corruption >= 100: Trigger TerminalErrorEvent.
   - Game Loop catches event → Initiates "Forlorn Transformation" sequence (Game Over/Character Loss).

### Logic Decision Trees

#### A. Corruption Tier Logic
**Input:** Current Corruption Value (0-100)

1. **0-20 (Pristine):** No penalties.
2. **21-40 (Tainted):** Visual glitches in UI.
3. **41-60 (Corrupted):** -10% Max AP.
4. **61-80 (Blighted):** -20% Max AP, -1 WILL.
5. **81-99 (Fractured):** -40% Max AP, -2 WILL, -1 WITS.
6. **100+ (Terminal):** Character enters Terminal State (Unplayable).

#### B. Terminal Error Logic
**Input:** AddCorruption call results in >= 100

1. **Lock State:** Set `Character.IsDead = true` (or specific IsForlorn flag).
2. **Narrative:** Display "Terminal Error" modal window.
3. **Data:** Flag save file as "Lost to Blight".
4. **Action:** Force return to Main Menu.

### Code Implementation

#### A. Core Layer (Corruption State Model)
We encapsulate the tier logic in a Value Object to keep the Entity clean.

**File:** `RuneAndRust.Core/Models/CorruptionState.cs`

```csharp
public enum CorruptionTier
{
    Pristine = 0,
    Tainted = 1,
    Corrupted = 2,
    Blighted = 3,
    Fractured = 4,
    Terminal = 5
}

public record CorruptionState(int Value)
{
    public CorruptionTier Tier => Value switch
    {
        >= 100 => CorruptionTier.Terminal,
        >= 81 => CorruptionTier.Fractured,
        >= 61 => CorruptionTier.Blighted,
        >= 41 => CorruptionTier.Corrupted,
        >= 21 => CorruptionTier.Tainted,
        _ => CorruptionTier.Pristine
    };

    public double MaxApMultiplier => Tier switch
    {
        CorruptionTier.Corrupted => 0.90,
        CorruptionTier.Blighted => 0.80,
        CorruptionTier.Fractured => 0.60,
        _ => 1.0
    };

    public int AttributePenalty => Tier switch
    {
        CorruptionTier.Blighted => 1, // -1 WILL
        CorruptionTier.Fractured => 2, // -2 WILL, -1 WITS
        _ => 0
    };
}
```

#### B. Engine Layer (Trauma Service Update)
Extending the service started in v0.3.0a.

**File:** `RuneAndRust.Engine/Services/TraumaService.cs`

```csharp
public void AddCorruption(Character character, int amount, string source)
{
    if (amount <= 0) return;

    int oldVal = character.Corruption;
    // Corruption creates permanent scars; it does not check Resolve/WILL.
    character.Corruption = Math.Min(100, character.Corruption + amount);

    var state = new CorruptionState(character.Corruption);
    var oldState = new CorruptionState(oldVal);

    _logger.LogWarning("{Name} gained {Amount} Corruption from {Source}. Total: {Total} ({Tier})",
        character.Name, amount, source, character.Corruption, state.Tier);

    // Tier Transition Event
    if (state.Tier != oldState.Tier)
    {
        _eventBus.Publish(new CorruptionTierChangedEvent(character.Id, oldState.Tier, state.Tier));

        // Recalculate stats immediately due to new penalties
        _statCalculator.RecalculateDerivedStats(character);
    }

    // Terminal State
    if (state.Tier == CorruptionTier.Terminal)
    {
        _logger.LogCritical("TERMINAL ERROR: {Name} has succumbed to the Blight.", character.Name);
        _eventBus.Publish(new TerminalErrorEvent(character.Id, source));
    }
}
```

#### C. Engine Layer (Stat Integration)
Update the calculation service to respect the new penalties.

**File:** `RuneAndRust.Engine/Services/StatCalculationService.cs` (Snippet)

```csharp
public void RecalculateDerivedStats(Character character)
{
    var corruption = new CorruptionState(character.Corruption);

    // Calculate Base Max AP
    int baseAp = GetBaseAp(character); // Archetype logic

    // Apply Corruption Penalty
    character.MaxAp = (int)(baseAp * corruption.MaxApMultiplier);

    // Clamp current if max dropped below it
    if (character.CurrentAp > character.MaxAp)
        character.CurrentAp = character.MaxAp;

    // ... calculate HP/Stamina ...
}
```

### Logging Requirements

**Reference:** logging-matrix.md

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Corruption Gain | Warning | "{Name} corrupted: +{Amount} (Total: {Total}, Source: {Source})" | Name, Amount, Total, Source |
| Tier Change | Info | "{Name} corruption threshold reached: {OldTier} -> {NewTier}" | Name, OldTier, NewTier |
| Penalty Calc | Debug | "Applied corruption penalty: MaxAP x{Mult}, Attributes -{AttrPen}" | Mult, AttrPen |
| Terminal Error | Critical | "TERMINAL ERROR: {Name} reached 100 Corruption. Entity Lost." | Name |

### Testing Strategy

#### Unit Tests (TraumaServiceTests.cs)

- **Accumulation:** `AddCorruption_IncreasesValue_WithoutMitigation` (Unlike stress, WILL does not reduce it).
- **Clamping:** `AddCorruption_ClampsAt100`.
- **Tier Logic:**
  - `CorruptionState_20_IsPristine`
  - `CorruptionState_21_IsTainted`
  - `CorruptionState_100_IsTerminal`
- **Stat Penalties:**
  - `Multiplier_AtBlighted_Is0.8`

#### Integration Tests

- **Death Spiral:**
  1. Create Mystic with 100 Max AP.
  2. Add 50 Corruption (Tier: Corrupted).
  3. Call RecalculateDerivedStats.
  4. Assert Max AP is now 90.
- **Terminal Event:**
  1. Add 100 Corruption.
  2. Verify TerminalErrorEvent was published to EventBus.

### Deliverable Checklist (Phase B)

- **Core:**
  - [ ] Add Corruption (int) to Character entity.
  - [ ] Define CorruptionTier enum.
  - [ ] Create CorruptionState record logic.
  - [ ] Define CorruptionTierChangedEvent and TerminalErrorEvent.
- **Engine:**
  - [ ] Implement TraumaService.AddCorruption.
  - [ ] Update StatCalculationService to apply CorruptionState.MaxApMultiplier.
- **UI:**
  - [ ] Add Corruption Bar to Character Sheet (Dark Red/Black).
  - [ ] Implement visual "Glitch" markers for Tainted tier (text artifacts).
- **Tests:**
  - [ ] Corruption_Reduces_MaxAP.
  - [ ] Terminal_Threshold_Triggers_Event.

---

## Phase C: The Scar (Consequences)

**Goal:** Implement the BreakingPoint event flow, the Trauma registry, and the mechanics for acquiring permanent psychological scars.

### Architecture & Data Flow

This introduces a "Interrupt" in the standard gameplay loop. A Breaking Point stops the action to resolve a critical mental crisis.

**Workflow: The Breaking Point Cycle**

1. **Trigger:** `TraumaService.InflictStress()` results in Stress >= 100.
2. **Interrupt:** The service pauses normal flow and raises a BreakingPointTriggeredEvent.
3. **UI Response:** The UI displays a modal: "BREAKING POINT! Roll Resolve?"
4. **Resolution:**
   - Player confirms.
   - System rolls WILL (Dice Pool) against Difficulty 3.
5. **Outcome Application:**
   - **Success:** Stabilized. Stress resets to 75. Character gains [Disoriented] (2 turns).
   - **Failure:** Broken. Stress resets to 50. Character acquires a permanent Trauma (randomly selected).
   - **Fumble:** Shattered. Stress resets to 90. Character acquires Trauma AND takes HP damage.
6. **Persistence:** The new Trauma is saved to the Character.Traumas list.
7. **Resume:** Gameplay continues.

### Logic Decision Trees

#### A. Breaking Point Resolution
**Input:** Character WILL Attribute

1. **Roll:** `DiceService.Roll(WILL)`
2. **Evaluate:**
   - **Successes >= 3:** STABILIZED.
     - Stress = 75
     - Log: "Held it together."
   - **Successes < 3 AND Botches == 0:** TRAUMA.
     - Stress = 50 (Release of tension through break).
     - Select Random Trauma from Registry.
     - Apply to Character.
     - Log: "Mind fractured. Gained {Trauma}."
   - **Successes == 0 AND Botches > 0:** CATASTROPHE.
     - Stress = 50.
     - Select Random Trauma.
     - Apply [Stunned] status.
     - Log: "Total collapse."

#### B. Trauma Effect Logic
Traumas are permanent passive debuffs or triggers.

- **Example: Nyctophobia (Fear of Dark)**
  - Check: Is Room.LightLevel == Dark?
  - If Yes: Apply -2 dice to all checks.
- **Example: Paranoid (Trust Issues)**
  - Check: Is Help Action used on Character?
  - If Yes: 50% chance to reject help.

### Code Implementation

#### A. Core Layer (Models)

**File:** `RuneAndRust.Core/Entities/Trauma.cs`

```csharp
public record Trauma(
    string Id,
    string Name,
    string Description,
    TraumaType Type, // Phobia, Compulsion, Delusion
    Action<Character> OnAcquire,
    Action<Character, GameState> OnTurnStart // Runtime hook
);

public enum TraumaType { Phobia, Compulsion, Delusion, Somatic }
```

**File:** `RuneAndRust.Core/Entities/Character.cs` (Update)

```csharp
public List<Trauma> ActiveTraumas { get; set; } = new();
```

#### B. Engine Layer (Trauma Registry)

**File:** `RuneAndRust.Engine/Services/TraumaRegistry.cs`

```csharp
public static class TraumaRegistry
{
    public static readonly List<Trauma> All = new()
    {
        new Trauma("TRM_NYCTO", "Nyctophobia", "Terror in the dark.", TraumaType.Phobia,
            _ => {},
            (c, state) => {
                if (state.CurrentRoom.IsDark)
                    c.PsychicStress += 1; // Gain stress every turn in dark
            }),

        new Trauma("TRM_SHAKES", "The Shakes", "-1 FINESSE due to tremors.", TraumaType.Somatic,
            c => c.Attributes[Attribute.Finesse] -= 1, // Permanent stat penalty
            (_, _) => { })
    };

    public static Trauma GetRandom()
    {
        var rng = new Random();
        return All[rng.Next(All.Count)];
    }
}
```

#### C. Engine Layer (Service Update)

**File:** `RuneAndRust.Engine/Services/TraumaService.cs`

```csharp
public BreakingPointResult ResolveBreakingPoint(Character character)
{
    // 1. The Roll (Difficulty 3)
    var result = _dice.Roll(character.GetAttribute(Attribute.Will), "Breaking Point");
    var outcome = BreakingPointOutcome.Trauma;

    if (result.Successes >= 3) outcome = BreakingPointOutcome.Stabilized;
    else if (result.IsFumble) outcome = BreakingPointOutcome.Catastrophe;

    // 2. Apply Consequences
    var acquiredTrauma = (Trauma?)null;

    switch (outcome)
    {
        case BreakingPointOutcome.Stabilized:
            character.PsychicStress = 75;
            _statusEffects.Apply(character, StatusEffectType.Disoriented, 2);
            break;

        case BreakingPointOutcome.Trauma:
            character.PsychicStress = 50;
            acquiredTrauma = _traumaRegistry.GetRandom();
            character.ActiveTraumas.Add(acquiredTrauma);
            acquiredTrauma.OnAcquire(character);
            break;

        case BreakingPointOutcome.Catastrophe:
            character.PsychicStress = 50;
            acquiredTrauma = _traumaRegistry.GetRandom();
            character.ActiveTraumas.Add(acquiredTrauma);
            acquiredTrauma.OnAcquire(character);
            _statusEffects.Apply(character, StatusEffectType.Stunned, 1);
            break;
    }

    // 3. Log and Return
    _logger.LogInformation("Breaking Point Resolved: {Outcome}. Stress reset to {NewStress}.",
        outcome, character.PsychicStress);

    return new BreakingPointResult(outcome, acquiredTrauma, character.PsychicStress);
}
```

### Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Trauma | Break Start | Warn | "{Name} reached BREAKING POINT (100 Stress). Rolling resolve..." | Name |
| Trauma | Roll Result | Info | "Breaking Point Roll: {Successes} successes. Result: {Outcome}" | Successes, Outcome |
| Trauma | Acquired | Error | "{Name} acquired permanent trauma: {TraumaName}" | Name, TraumaName |
| Trauma | Trigger | Debug | "Trauma {TraumaId} triggered effect on {Name}" | TraumaId, Name |

### Testing Strategy

#### Unit Tests (TraumaServiceTests.cs)

- **Stabilize:** Mock dice to return 3 successes. Verify Stress → 75 and NO trauma added.
- **Fail:** Mock dice to return 1 success. Verify Stress → 50 and Trauma Count increases by 1.
- **Fumble:** Mock dice to return 0 success, 1 botch. Verify Stunned status applied.
- **Registry:** Verify GetRandom() returns a valid object (not null).

#### Integration Tests

- **Stat Penalty:** Acquire "The Shakes". Verify GetAttribute(Finesse) returns (Base - 1).
- **Loop Integration:**
  1. Set Stress to 99.
  2. Call InflictStress(1).
  3. Verify BreakingPointTriggered event fires.
  4. Call ResolveBreakingPoint.
  5. Verify Stress resets to 50/75.

### Deliverable Checklist (Phase C)

- **Core:**
  - [ ] Define Trauma record and BreakingPointOutcome enum.
  - [ ] Add List<Trauma> to Character entity.
- **Engine:**
  - [ ] Create TraumaRegistry with at least 5 starter traumas.
  - [ ] Implement TraumaService.ResolveBreakingPoint.
  - [ ] Integrate OnTurnStart trauma hooks into CombatService.
- **UI:**
  - [ ] Create "Breaking Point" Modal in TUI (Red border, dramatic text).
  - [ ] Update Character Sheet to list active Traumas.
- **Tests:**
  - [ ] BreakingPoint_Success_Stabilizes
  - [ ] BreakingPoint_Failure_AddsTrauma

---

## Changelog (v0.3.0)

**Release Date:** 2025-XX-XX

### Summary
The "Trauma Economy" is now live. Players must now manage **Psychic Stress** and **Corruption** alongside HP and Stamina. Mental health is no longer flavor text—it is a survival metric.

### Features
- **Psychic Stress (0-100):** Volatile mental damage. Accumulates from horrors and magic usage.
  - **Resolve Checks:** High WILL allows characters to resist incoming stress.
- **The Breaking Point:** Reaching 100 Stress triggers a critical resolve check. Failure results in permanent **Traumas**.
- **Corruption System:** Permanent spiritual decay from heretical actions.
  - **Tiers:** Tainted → Corrupted → Blighted → Fractured → Terminal.
  - **Penalties:** Corruption permanently reduces Max AP and Attributes.
- **Trauma Registry:** Added 10 permanent traumas (e.g., Paranoia, Hypervigilance) that alter gameplay rules.

### Technical
- Implemented `TraumaService` and `CorruptionState`.
- Updated `StatCalculationService` to apply Corruption penalties.
- Integrated `ResolveCheck` into damage pipelines.
