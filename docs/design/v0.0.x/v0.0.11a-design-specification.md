# v0.0.11a Design Specification: Descriptor Framework Expansion

**Version:** 0.0.11a
**Phase Name:** Descriptor Framework Expansion
**Parent Version:** v0.0.11 (Descriptors & Ambience)
**Prerequisites:** v0.0.10 Complete (Documentation & Polish)
**Estimated Tests:** ~18 unit tests

---

## 1. Overview

### 1.1 Purpose

Expand the descriptor framework to support environment categories, coherence validation, and biome-based descriptor selection. This prevents incoherent environmental descriptions (rooms that are simultaneously frozen and volcanic) and enables consistent, immersive atmosphere generation by grouping descriptors into mutually exclusive categories.

### 1.2 Current State

| Area | Current State (v0.0.10) | Target State (v0.0.11a) |
|------|-------------------------|-------------------------|
| Descriptor selection | Tag-based filtering only | Category + biome + tag filtering |
| Environment coherence | No validation | Exclusion rules prevent conflicts |
| Room atmosphere | Random 2-3 elements | Biome-coherent elements |
| Context tracking | `DamagePercent`, `HealthPercent`, `Tags` | Add `EnvironmentContext` with biome, climate, era, condition, lighting |
| Configuration | Per-pool descriptors | Biome definitions with default pools |

### 1.3 Design Principles

1. **Data-Driven**: All categories, biomes, and exclusion rules loaded from JSON configuration
2. **Coherence First**: Invalid environment combinations rejected before descriptor selection
3. **Backwards Compatible**: Existing `DescriptorService` methods continue to work
4. **Extensible**: Easy to add new categories, biomes, and rules via configuration

---

## 2. Scope

### 2.1 In Scope

- `EnvironmentCategory` configuration class for category definitions
- `CategoryValue` configuration class for values within categories
- `CategoryExclusionRule` configuration class for conflict definitions
- `BiomeDefinition` configuration class for biome-specific defaults
- `EnvironmentContext` value object for room-level environment state
- `EnvironmentCoherenceService` for validation and context management
- Extension of `DescriptorContext` to include environment state
- Biome-aware descriptor pool selection
- Category-based filtering in `DescriptorService`
- Configuration files: `environment-categories.json`, `biomes.json`

### 2.2 Out of Scope (Future Phases)

- Combat descriptors (v0.0.11b)
- Sensory descriptors (v0.0.11c)
- Interactive objects (v0.0.11d)
- Game mechanics based on environment (future version)

---

## 3. Data Model

### 3.1 New: EnvironmentCategory (Configuration)

**File:** `src/Core/RuneAndRust.Application/Configuration/EnvironmentCategoryConfiguration.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration for environment category definitions loaded from JSON.
/// </summary>
public class EnvironmentCategoryConfiguration
{
    /// <summary>
    /// Schema version for configuration validation.
    /// </summary>
    public string Version { get; init; } = "1.0";

    /// <summary>
    /// Available environment categories keyed by category ID.
    /// </summary>
    public IReadOnlyDictionary<string, EnvironmentCategory> Categories { get; init; } =
        new Dictionary<string, EnvironmentCategory>();

    /// <summary>
    /// Rules defining which category values cannot coexist.
    /// </summary>
    public IReadOnlyList<CategoryExclusionRule> ExclusionRules { get; init; } = [];
}

/// <summary>
/// Defines a category of mutually exclusive environment values.
/// </summary>
/// <remarks>
/// Categories group related environment aspects (e.g., Biome, Climate, Lighting).
/// A room can only have one value per category. Some values within the same or
/// different categories may conflict based on exclusion rules.
/// </remarks>
public class EnvironmentCategory
{
    /// <summary>
    /// Category identifier (e.g., "biome", "climate", "lighting").
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Display name for the category.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Description of what this category represents.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Whether this category is required for a valid environment context.
    /// </summary>
    public bool IsRequired { get; init; }

    /// <summary>
    /// Default value for this category if not specified.
    /// </summary>
    public string? DefaultValue { get; init; }

    /// <summary>
    /// Available values within this category.
    /// </summary>
    public IReadOnlyList<CategoryValue> Values { get; init; } = [];
}

/// <summary>
/// A specific value within an environment category.
/// </summary>
public class CategoryValue
{
    /// <summary>
    /// Value identifier (e.g., "cave", "freezing", "dim").
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Display name for this value.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Description of what this value represents.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Tags automatically applied when this value is active.
    /// </summary>
    /// <remarks>
    /// These tags are added to descriptor filtering, ensuring descriptors
    /// with matching tags are preferred.
    /// </remarks>
    public IReadOnlyList<string> ImpliedTags { get; init; } = [];
}

/// <summary>
/// Defines a rule preventing specific category values from coexisting.
/// </summary>
/// <remarks>
/// Exclusion rules can be within the same category (implicit) or across
/// different categories (explicit). For example, "volcanic" biome excludes
/// "freezing" climate.
/// </remarks>
public class CategoryExclusionRule
{
    /// <summary>
    /// Unique identifier for this rule.
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable description of why this conflict exists.
    /// </summary>
    public string Reason { get; init; } = string.Empty;

    /// <summary>
    /// First category in the conflict.
    /// </summary>
    public string Category1 { get; init; } = string.Empty;

    /// <summary>
    /// Values in Category1 that participate in this conflict.
    /// </summary>
    public IReadOnlyList<string> Values1 { get; init; } = [];

    /// <summary>
    /// Second category in the conflict (can be same as Category1).
    /// </summary>
    public string Category2 { get; init; } = string.Empty;

    /// <summary>
    /// Values in Category2 that conflict with Values1.
    /// </summary>
    public IReadOnlyList<string> Values2 { get; init; } = [];

    /// <summary>
    /// Whether to log a warning (soft) or throw an error (hard) on violation.
    /// </summary>
    public bool IsHardRule { get; init; } = true;
}
```

### 3.2 New: BiomeDefinition (Configuration)

**File:** `src/Core/RuneAndRust.Application/Configuration/BiomeConfiguration.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration for biome definitions loaded from JSON.
/// </summary>
public class BiomeConfiguration
{
    /// <summary>
    /// Schema version for configuration validation.
    /// </summary>
    public string Version { get; init; } = "1.0";

    /// <summary>
    /// Available biome definitions keyed by biome ID.
    /// </summary>
    public IReadOnlyDictionary<string, BiomeDefinition> Biomes { get; init; } =
        new Dictionary<string, BiomeDefinition>();
}

/// <summary>
/// Defines a biome with default environment values and descriptor preferences.
/// </summary>
/// <remarks>
/// Biomes provide sensible defaults for environment categories and specify
/// which descriptor pools should be preferred for atmosphere generation.
/// </remarks>
public class BiomeDefinition
{
    /// <summary>
    /// Biome identifier (e.g., "cave", "dungeon", "volcanic").
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Display name for this biome.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Description of this biome type.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Default category values for this biome.
    /// Key is category ID, value is the default value ID.
    /// </summary>
    public IReadOnlyDictionary<string, string> DefaultCategoryValues { get; init; } =
        new Dictionary<string, string>();

    /// <summary>
    /// Tags automatically applied when in this biome.
    /// </summary>
    public IReadOnlyList<string> ImpliedTags { get; init; } = [];

    /// <summary>
    /// Preferred descriptor pools for this biome.
    /// Key is pool path, value is biome-specific pool path override.
    /// </summary>
    public IReadOnlyDictionary<string, string> DescriptorPoolOverrides { get; init; } =
        new Dictionary<string, string>();

    /// <summary>
    /// Terms to emphasize in this biome (higher weight).
    /// </summary>
    public IReadOnlyList<string> EmphasizedTerms { get; init; } = [];

    /// <summary>
    /// Terms to exclude from this biome.
    /// </summary>
    public IReadOnlyList<string> ExcludedTerms { get; init; } = [];
}
```

### 3.3 New: EnvironmentContext (Value Object)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EnvironmentContext.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the environmental state of a location.
/// </summary>
/// <remarks>
/// EnvironmentContext captures the current environment category values for a room,
/// enabling coherent descriptor selection. Values are stored as a dictionary of
/// category ID to value ID pairs.
/// </remarks>
public readonly record struct EnvironmentContext
{
    /// <summary>
    /// Category values keyed by category ID.
    /// </summary>
    public IReadOnlyDictionary<string, string> CategoryValues { get; init; }

    /// <summary>
    /// Tags derived from category values and biome.
    /// </summary>
    public IReadOnlyList<string> DerivedTags { get; init; }

    /// <summary>
    /// Creates an empty environment context.
    /// </summary>
    public EnvironmentContext()
    {
        CategoryValues = new Dictionary<string, string>();
        DerivedTags = [];
    }

    /// <summary>
    /// Creates an environment context with the specified category values.
    /// </summary>
    /// <param name="categoryValues">Category ID to value ID mappings.</param>
    /// <param name="derivedTags">Tags derived from the environment.</param>
    public EnvironmentContext(
        IReadOnlyDictionary<string, string> categoryValues,
        IReadOnlyList<string> derivedTags)
    {
        CategoryValues = categoryValues;
        DerivedTags = derivedTags;
    }

    /// <summary>
    /// Gets the value for a specific category.
    /// </summary>
    /// <param name="categoryId">The category identifier.</param>
    /// <returns>The value ID if set, otherwise null.</returns>
    public string? GetValue(string categoryId) =>
        CategoryValues.TryGetValue(categoryId, out var value) ? value : null;

    /// <summary>
    /// Gets the biome value if set.
    /// </summary>
    public string? Biome => GetValue("biome");

    /// <summary>
    /// Gets the climate value if set.
    /// </summary>
    public string? Climate => GetValue("climate");

    /// <summary>
    /// Gets the lighting value if set.
    /// </summary>
    public string? Lighting => GetValue("lighting");

    /// <summary>
    /// Gets the era value if set.
    /// </summary>
    public string? Era => GetValue("era");

    /// <summary>
    /// Gets the condition value if set.
    /// </summary>
    public string? Condition => GetValue("condition");

    /// <summary>
    /// Checks if this context has a value for the specified category.
    /// </summary>
    /// <param name="categoryId">The category identifier.</param>
    /// <returns>True if a value is set for this category.</returns>
    public bool HasCategory(string categoryId) =>
        CategoryValues.ContainsKey(categoryId);

    /// <summary>
    /// Creates a new context with an additional or updated category value.
    /// </summary>
    /// <param name="categoryId">The category to set.</param>
    /// <param name="valueId">The value to set.</param>
    /// <returns>A new EnvironmentContext with the updated value.</returns>
    public EnvironmentContext WithValue(string categoryId, string valueId)
    {
        var newValues = new Dictionary<string, string>(CategoryValues)
        {
            [categoryId] = valueId
        };
        return new EnvironmentContext(newValues, DerivedTags);
    }

    /// <summary>
    /// Creates a display string for debugging.
    /// </summary>
    public override string ToString()
    {
        var values = string.Join(", ", CategoryValues.Select(kv => $"{kv.Key}:{kv.Value}"));
        return $"Environment({values})";
    }
}
```

### 3.4 Modified: DescriptorContext (Existing Class)

**File:** `src/Core/RuneAndRust.Application/Services/DescriptorService.cs`

```csharp
// Update existing DescriptorContext class:

/// <summary>
/// Context information for descriptor selection.
/// </summary>
public class DescriptorContext
{
    /// <summary>
    /// Damage percentage for combat descriptors (0.0 to 1.0).
    /// </summary>
    public double? DamagePercent { get; set; }

    /// <summary>
    /// Health percentage for condition-based descriptors (0.0 to 1.0).
    /// </summary>
    public double? HealthPercent { get; set; }

    /// <summary>
    /// Currently active theme ID.
    /// </summary>
    public string? ActiveTheme { get; set; }

    /// <summary>
    /// Explicit tags to filter descriptors.
    /// </summary>
    public IReadOnlyList<string> Tags { get; set; } = [];

    // NEW: v0.0.11a additions

    /// <summary>
    /// Environment context for coherent descriptor selection.
    /// </summary>
    public EnvironmentContext? Environment { get; set; }

    /// <summary>
    /// Whether to include derived tags from environment context.
    /// Defaults to true.
    /// </summary>
    public bool IncludeEnvironmentTags { get; set; } = true;

    /// <summary>
    /// Gets all effective tags including environment-derived tags.
    /// </summary>
    public IEnumerable<string> GetEffectiveTags()
    {
        if (IncludeEnvironmentTags && Environment.HasValue)
        {
            return Tags.Concat(Environment.Value.DerivedTags).Distinct();
        }
        return Tags;
    }
}
```

### 3.5 Modified: Room (Entity)

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

```csharp
// Add to existing Room entity:

/// <summary>
/// Gets or sets the environment context for this room.
/// </summary>
/// <remarks>
/// Environment context controls which descriptors are selected for
/// atmosphere generation and ensures environmental coherence.
/// </remarks>
public EnvironmentContext? Environment { get; private set; }

/// <summary>
/// Sets the environment context for this room.
/// </summary>
/// <param name="environment">The environment context to set.</param>
public void SetEnvironment(EnvironmentContext environment)
{
    Environment = environment;
}
```

---

## 4. Services

### 4.1 EnvironmentCoherenceService

**File:** `src/Core/RuneAndRust.Application/Services/EnvironmentCoherenceService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Configuration;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Validates environment contexts and builds coherent environments from biomes.
/// </summary>
public class EnvironmentCoherenceService
{
    private readonly EnvironmentCategoryConfiguration _categoryConfig;
    private readonly BiomeConfiguration _biomeConfig;
    private readonly ILogger<EnvironmentCoherenceService> _logger;

    public EnvironmentCoherenceService(
        EnvironmentCategoryConfiguration categoryConfig,
        BiomeConfiguration biomeConfig,
        ILogger<EnvironmentCoherenceService> logger)
    {
        _categoryConfig = categoryConfig ?? throw new ArgumentNullException(nameof(categoryConfig));
        _biomeConfig = biomeConfig ?? throw new ArgumentNullException(nameof(biomeConfig));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        _logger.LogDebug(
            "EnvironmentCoherenceService initialized with {CategoryCount} categories, {RuleCount} exclusion rules, {BiomeCount} biomes",
            _categoryConfig.Categories.Count,
            _categoryConfig.ExclusionRules.Count,
            _biomeConfig.Biomes.Count);
    }

    /// <summary>
    /// Validates that an environment context has no conflicting values.
    /// </summary>
    /// <param name="context">The environment context to validate.</param>
    /// <returns>A validation result with any violations found.</returns>
    public EnvironmentValidationResult Validate(EnvironmentContext context)
    {
        var violations = new List<EnvironmentViolation>();

        foreach (var rule in _categoryConfig.ExclusionRules)
        {
            if (ViolatesRule(context, rule, out var violation))
            {
                violations.Add(violation);

                if (rule.IsHardRule)
                {
                    _logger.LogWarning(
                        "Environment violation (hard): {RuleId} - {Reason}",
                        rule.Id, rule.Reason);
                }
                else
                {
                    _logger.LogDebug(
                        "Environment violation (soft): {RuleId} - {Reason}",
                        rule.Id, rule.Reason);
                }
            }
        }

        return new EnvironmentValidationResult(violations);
    }

    /// <summary>
    /// Creates an environment context from a biome with default values.
    /// </summary>
    /// <param name="biomeId">The biome identifier.</param>
    /// <param name="overrides">Optional category value overrides.</param>
    /// <returns>A coherent environment context.</returns>
    /// <exception cref="ArgumentException">Thrown if biome is not found.</exception>
    public EnvironmentContext CreateFromBiome(
        string biomeId,
        IReadOnlyDictionary<string, string>? overrides = null)
    {
        if (!_biomeConfig.Biomes.TryGetValue(biomeId, out var biome))
        {
            _logger.LogError("Biome not found: {BiomeId}", biomeId);
            throw new ArgumentException($"Biome not found: {biomeId}", nameof(biomeId));
        }

        _logger.LogDebug("Creating environment context from biome: {BiomeId}", biomeId);

        // Start with biome defaults
        var categoryValues = new Dictionary<string, string>(biome.DefaultCategoryValues)
        {
            ["biome"] = biomeId
        };

        // Apply category defaults for any missing required categories
        foreach (var (categoryId, category) in _categoryConfig.Categories)
        {
            if (category.IsRequired && !categoryValues.ContainsKey(categoryId))
            {
                if (category.DefaultValue != null)
                {
                    categoryValues[categoryId] = category.DefaultValue;
                }
            }
        }

        // Apply overrides
        if (overrides != null)
        {
            foreach (var (categoryId, valueId) in overrides)
            {
                categoryValues[categoryId] = valueId;
            }
        }

        // Collect derived tags
        var derivedTags = CollectDerivedTags(categoryValues, biome);

        var context = new EnvironmentContext(categoryValues, derivedTags);

        // Validate result
        var validation = Validate(context);
        if (validation.HasHardViolations)
        {
            _logger.LogError(
                "Created environment context has violations: {ViolationCount} violations",
                validation.Violations.Count);
            throw new InvalidOperationException(
                $"Environment context violates exclusion rules: {validation.Violations[0].Reason}");
        }

        _logger.LogDebug(
            "Created environment context: {Context} with {TagCount} derived tags",
            context, derivedTags.Count);

        return context;
    }

    /// <summary>
    /// Gets all valid values for a category given the current context.
    /// </summary>
    /// <param name="categoryId">The category to query.</param>
    /// <param name="currentContext">The current environment context.</param>
    /// <returns>Values that would not violate any hard exclusion rules.</returns>
    public IEnumerable<CategoryValue> GetValidValues(
        string categoryId,
        EnvironmentContext currentContext)
    {
        if (!_categoryConfig.Categories.TryGetValue(categoryId, out var category))
        {
            _logger.LogWarning("Category not found: {CategoryId}", categoryId);
            return [];
        }

        return category.Values.Where(value =>
        {
            var testContext = currentContext.WithValue(categoryId, value.Id);
            var validation = Validate(testContext);
            return !validation.HasHardViolations;
        });
    }

    /// <summary>
    /// Gets a biome definition by ID.
    /// </summary>
    /// <param name="biomeId">The biome identifier.</param>
    /// <returns>The biome definition if found, otherwise null.</returns>
    public BiomeDefinition? GetBiome(string biomeId)
    {
        return _biomeConfig.Biomes.TryGetValue(biomeId, out var biome) ? biome : null;
    }

    /// <summary>
    /// Gets all available biome definitions.
    /// </summary>
    public IEnumerable<BiomeDefinition> GetAllBiomes() => _biomeConfig.Biomes.Values;

    /// <summary>
    /// Gets all environment categories.
    /// </summary>
    public IEnumerable<EnvironmentCategory> GetAllCategories() => _categoryConfig.Categories.Values;

    private bool ViolatesRule(
        EnvironmentContext context,
        CategoryExclusionRule rule,
        out EnvironmentViolation violation)
    {
        var value1 = context.GetValue(rule.Category1);
        var value2 = context.GetValue(rule.Category2);

        if (value1 != null && value2 != null &&
            rule.Values1.Contains(value1) && rule.Values2.Contains(value2))
        {
            violation = new EnvironmentViolation(
                rule.Id,
                rule.Reason,
                rule.Category1, value1,
                rule.Category2, value2,
                rule.IsHardRule);
            return true;
        }

        violation = default;
        return false;
    }

    private List<string> CollectDerivedTags(
        Dictionary<string, string> categoryValues,
        BiomeDefinition biome)
    {
        var tags = new List<string>();

        // Add biome-implied tags
        tags.AddRange(biome.ImpliedTags);

        // Add category value-implied tags
        foreach (var (categoryId, valueId) in categoryValues)
        {
            if (_categoryConfig.Categories.TryGetValue(categoryId, out var category))
            {
                var value = category.Values.FirstOrDefault(v => v.Id == valueId);
                if (value != null)
                {
                    tags.AddRange(value.ImpliedTags);
                }
            }
        }

        return tags.Distinct().ToList();
    }
}

/// <summary>
/// Result of environment context validation.
/// </summary>
/// <param name="Violations">List of exclusion rule violations.</param>
public record EnvironmentValidationResult(IReadOnlyList<EnvironmentViolation> Violations)
{
    /// <summary>
    /// Returns true if the environment is valid (no violations).
    /// </summary>
    public bool IsValid => Violations.Count == 0;

    /// <summary>
    /// Returns true if there are any hard rule violations.
    /// </summary>
    public bool HasHardViolations => Violations.Any(v => v.IsHardRule);

    /// <summary>
    /// Returns true if there are only soft rule violations.
    /// </summary>
    public bool HasSoftViolationsOnly => Violations.Count > 0 && !HasHardViolations;
}

/// <summary>
/// Represents a violation of an exclusion rule.
/// </summary>
/// <param name="RuleId">The violated rule identifier.</param>
/// <param name="Reason">Human-readable explanation of the conflict.</param>
/// <param name="Category1">First conflicting category.</param>
/// <param name="Value1">First conflicting value.</param>
/// <param name="Category2">Second conflicting category.</param>
/// <param name="Value2">Second conflicting value.</param>
/// <param name="IsHardRule">Whether this is a hard (error) or soft (warning) rule.</param>
public record EnvironmentViolation(
    string RuleId,
    string Reason,
    string Category1,
    string Value1,
    string Category2,
    string Value2,
    bool IsHardRule);
```

### 4.2 Modified: DescriptorService

**File:** `src/Core/RuneAndRust.Application/Services/DescriptorService.cs`

```csharp
// Add to existing DescriptorService:

private readonly EnvironmentCoherenceService? _coherenceService;

// Update constructor to optionally accept coherence service:
public DescriptorService(
    IReadOnlyDictionary<string, DescriptorPool> pools,
    ThemeConfiguration theme,
    ILogger<DescriptorService> logger,
    EnvironmentCoherenceService? coherenceService = null)
{
    _pools = pools ?? throw new ArgumentNullException(nameof(pools));
    _theme = theme ?? throw new ArgumentNullException(nameof(theme));
    _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    _coherenceService = coherenceService;

    _logger.LogDebug("DescriptorService initialized with {PoolCount} pools", pools.Count);
}

/// <summary>
/// Gets a descriptor with environment context awareness.
/// </summary>
/// <param name="poolPath">The pool path (e.g., "environmental.lighting").</param>
/// <param name="context">Context including environment for selection.</param>
/// <returns>The selected descriptor text.</returns>
public string GetDescriptorWithEnvironment(string poolPath, DescriptorContext context)
{
    // Apply biome pool overrides if environment is set
    var actualPath = poolPath;
    if (context.Environment.HasValue && _coherenceService != null)
    {
        var biome = _coherenceService.GetBiome(context.Environment.Value.Biome ?? "");
        if (biome?.DescriptorPoolOverrides.TryGetValue(poolPath, out var overridePath) == true)
        {
            actualPath = overridePath;
            _logger.LogDebug(
                "Pool override for biome {Biome}: {Original} -> {Override}",
                biome.Id, poolPath, overridePath);
        }
    }

    // Use effective tags including environment-derived tags
    var tags = context.GetEffectiveTags().ToList();

    return GetDescriptor(actualPath, tags, context);
}

/// <summary>
/// Generates room atmosphere using environment context.
/// </summary>
/// <param name="environment">The room's environment context.</param>
/// <returns>A coherent atmospheric description.</returns>
public string GenerateRoomAtmosphereWithEnvironment(EnvironmentContext environment)
{
    var context = new DescriptorContext
    {
        Environment = environment,
        IncludeEnvironmentTags = true
    };

    var lighting = GetDescriptorWithEnvironment("environmental.lighting", context);
    var sound = GetDescriptorWithEnvironment("environmental.sounds", context);
    var smell = GetDescriptorWithEnvironment("environmental.smells", context);
    var temp = GetDescriptorWithEnvironment("environmental.temperature", context);

    // Combine 2-3 elements for variety, ensuring coherence
    var elements = new[] { lighting, sound, smell, temp }
        .Where(e => !string.IsNullOrEmpty(e))
        .OrderBy(_ => _random.Next())
        .Take(_random.Next(2, 4))
        .ToList();

    if (elements.Count == 0) return string.Empty;

    _logger.LogDebug(
        "Generated atmosphere for {Biome}: {ElementCount} elements",
        environment.Biome, elements.Count);

    return string.Join(" ", elements);
}
```

### 4.3 Service Flow Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                 ENVIRONMENT CONTEXT CREATION                     │
└─────────────────────────────────────────────────────────────────┘

    CreateFromBiome(biomeId, overrides)
           │
           ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. LOAD BIOME DEFAULTS                                         │
├─────────────────────────────────────────────────────────────────┤
│  - Get BiomeDefinition from configuration                       │
│  - Copy DefaultCategoryValues to working dictionary             │
│  - Set biome category value                                     │
└─────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. APPLY CATEGORY DEFAULTS                                     │
├─────────────────────────────────────────────────────────────────┤
│  - For each required category without a value:                  │
│    - Apply category default if defined                          │
└─────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. APPLY OVERRIDES                                             │
├─────────────────────────────────────────────────────────────────┤
│  - Override category values with caller-provided values         │
└─────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. COLLECT DERIVED TAGS                                        │
├─────────────────────────────────────────────────────────────────┤
│  - Add biome implied tags                                       │
│  - Add category value implied tags                              │
│  - Remove duplicates                                            │
└─────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. VALIDATE COHERENCE                                          │
├─────────────────────────────────────────────────────────────────┤
│  - Check all exclusion rules                                    │
│  - If hard violation: throw exception                           │
│  - If soft violation: log warning, continue                     │
└─────────────────────────────────────────────────────────────────┘
           │
           ▼
    Return EnvironmentContext
```

---

## 5. Command Changes

### 5.1 No New Commands

This phase does not introduce new player commands. The environment context is set during room generation and dungeon creation.

### 5.2 Internal Usage

Room generation and dungeon building services will use `EnvironmentCoherenceService` to create coherent environment contexts for rooms:

```csharp
// Example usage in room generation:
var environment = _coherenceService.CreateFromBiome("cave", new Dictionary<string, string>
{
    ["lighting"] = "dim",
    ["condition"] = "flooded"
});

room.SetEnvironment(environment);
```

---

## 6. Rendering Changes

### 6.1 No Direct Rendering Changes

Rendering continues to use `DescriptorService`. The new environment-aware methods provide better descriptor selection, but the output format remains unchanged.

### 6.2 Enhanced Atmosphere Display

The `GenerateRoomAtmosphereWithEnvironment` method produces coherent descriptions that naturally fit together based on the biome and environment context.

**Example Output (Cave Biome):**
```
The chamber is dimly lit by phosphorescent fungi. The sound of dripping water echoes
from somewhere deeper in the tunnels. A damp chill clings to your skin.
```

**Example Output (Volcanic Biome):**
```
Oppressive heat radiates from fissures in the stone. The air shimmers with heat haze.
A sulfurous stench burns your nostrils.
```

---

## 7. Configuration

### 7.1 environment-categories.json

**File:** `config/environment-categories.json`

```json
{
  "version": "1.0",
  "categories": {
    "biome": {
      "id": "biome",
      "name": "Biome",
      "description": "The fundamental environment type of a location",
      "isRequired": true,
      "defaultValue": "dungeon",
      "values": [
        {
          "id": "cave",
          "name": "Cave",
          "description": "Natural underground caverns",
          "impliedTags": ["underground", "natural", "cave"]
        },
        {
          "id": "dungeon",
          "name": "Dungeon",
          "description": "Constructed underground passages",
          "impliedTags": ["underground", "constructed", "dungeon"]
        },
        {
          "id": "volcanic",
          "name": "Volcanic",
          "description": "Areas of volcanic activity",
          "impliedTags": ["volcanic", "danger", "heat"]
        },
        {
          "id": "frozen",
          "name": "Frozen",
          "description": "Ice-covered or extremely cold areas",
          "impliedTags": ["frozen", "cold", "ice"]
        },
        {
          "id": "swamp",
          "name": "Swamp",
          "description": "Waterlogged, decaying wetlands",
          "impliedTags": ["swamp", "wet", "decay"]
        },
        {
          "id": "ruins",
          "name": "Ruins",
          "description": "Crumbling ancient structures",
          "impliedTags": ["ruins", "ancient", "decay"]
        },
        {
          "id": "forest",
          "name": "Forest",
          "description": "Dense woodland areas",
          "impliedTags": ["forest", "natural", "outdoor"]
        },
        {
          "id": "desert",
          "name": "Desert",
          "description": "Arid wasteland or sandy expanses",
          "impliedTags": ["desert", "dry", "heat"]
        }
      ]
    },
    "climate": {
      "id": "climate",
      "name": "Climate",
      "description": "The temperature and weather conditions",
      "isRequired": false,
      "defaultValue": "temperate",
      "values": [
        {
          "id": "freezing",
          "name": "Freezing",
          "description": "Dangerously cold temperatures",
          "impliedTags": ["freezing", "cold"]
        },
        {
          "id": "cold",
          "name": "Cold",
          "description": "Uncomfortably cold",
          "impliedTags": ["cold"]
        },
        {
          "id": "temperate",
          "name": "Temperate",
          "description": "Moderate temperatures",
          "impliedTags": []
        },
        {
          "id": "warm",
          "name": "Warm",
          "description": "Pleasantly warm",
          "impliedTags": ["warm"]
        },
        {
          "id": "hot",
          "name": "Hot",
          "description": "Uncomfortably hot",
          "impliedTags": ["hot"]
        },
        {
          "id": "scorching",
          "name": "Scorching",
          "description": "Dangerously hot temperatures",
          "impliedTags": ["scorching", "hot", "danger"]
        }
      ]
    },
    "lighting": {
      "id": "lighting",
      "name": "Lighting",
      "description": "The illumination level of the area",
      "isRequired": true,
      "defaultValue": "dim",
      "values": [
        {
          "id": "pitch_black",
          "name": "Pitch Black",
          "description": "Complete absence of light",
          "impliedTags": ["dark", "blind"]
        },
        {
          "id": "dim",
          "name": "Dim",
          "description": "Faint, flickering light",
          "impliedTags": ["dim", "shadows"]
        },
        {
          "id": "normal",
          "name": "Normal",
          "description": "Adequate lighting",
          "impliedTags": []
        },
        {
          "id": "bright",
          "name": "Bright",
          "description": "Well-lit area",
          "impliedTags": ["bright", "visible"]
        },
        {
          "id": "blinding",
          "name": "Blinding",
          "description": "Painfully bright light",
          "impliedTags": ["blinding", "bright"]
        }
      ]
    },
    "era": {
      "id": "era",
      "name": "Era",
      "description": "The age and condition of structures",
      "isRequired": false,
      "defaultValue": null,
      "values": [
        {
          "id": "ancient",
          "name": "Ancient",
          "description": "Millennia-old construction",
          "impliedTags": ["ancient", "old"]
        },
        {
          "id": "medieval",
          "name": "Medieval",
          "description": "Historic but not ancient",
          "impliedTags": ["medieval"]
        },
        {
          "id": "decayed",
          "name": "Decayed",
          "description": "Crumbling, deteriorated",
          "impliedTags": ["decayed", "ruined"]
        },
        {
          "id": "pristine",
          "name": "Pristine",
          "description": "Well-maintained or new",
          "impliedTags": ["pristine", "clean"]
        }
      ]
    },
    "condition": {
      "id": "condition",
      "name": "Condition",
      "description": "Special environmental conditions",
      "isRequired": false,
      "defaultValue": null,
      "values": [
        {
          "id": "flooded",
          "name": "Flooded",
          "description": "Partially or fully submerged",
          "impliedTags": ["flooded", "wet", "water"]
        },
        {
          "id": "burning",
          "name": "Burning",
          "description": "Active fires present",
          "impliedTags": ["burning", "fire", "danger"]
        },
        {
          "id": "collapsed",
          "name": "Collapsed",
          "description": "Structural damage, rubble",
          "impliedTags": ["collapsed", "rubble", "danger"]
        },
        {
          "id": "overgrown",
          "name": "Overgrown",
          "description": "Vegetation reclaiming the area",
          "impliedTags": ["overgrown", "nature", "plants"]
        },
        {
          "id": "infested",
          "name": "Infested",
          "description": "Overrun with creatures",
          "impliedTags": ["infested", "creatures", "danger"]
        }
      ]
    }
  },
  "exclusionRules": [
    {
      "id": "volcanic_freezing",
      "reason": "Volcanic areas cannot have freezing temperatures",
      "category1": "biome",
      "values1": ["volcanic"],
      "category2": "climate",
      "values2": ["freezing", "cold"],
      "isHardRule": true
    },
    {
      "id": "frozen_hot",
      "reason": "Frozen areas cannot have hot temperatures",
      "category1": "biome",
      "values1": ["frozen"],
      "category2": "climate",
      "values2": ["hot", "scorching"],
      "isHardRule": true
    },
    {
      "id": "flooded_burning",
      "reason": "An area cannot be both flooded and burning",
      "category1": "condition",
      "values1": ["flooded"],
      "category2": "condition",
      "values2": ["burning"],
      "isHardRule": true
    },
    {
      "id": "desert_flooded",
      "reason": "Desert areas cannot be flooded",
      "category1": "biome",
      "values1": ["desert"],
      "category2": "condition",
      "values2": ["flooded"],
      "isHardRule": true
    },
    {
      "id": "pitch_black_blinding",
      "reason": "Cannot be both pitch black and blinding",
      "category1": "lighting",
      "values1": ["pitch_black"],
      "category2": "lighting",
      "values2": ["blinding", "bright"],
      "isHardRule": true
    },
    {
      "id": "ancient_pristine",
      "reason": "Ancient structures are unlikely to be pristine",
      "category1": "era",
      "values1": ["ancient"],
      "category2": "era",
      "values2": ["pristine"],
      "isHardRule": false
    },
    {
      "id": "volcanic_forest",
      "reason": "Active volcanic areas typically lack dense vegetation",
      "category1": "biome",
      "values1": ["volcanic"],
      "category2": "condition",
      "values2": ["overgrown"],
      "isHardRule": false
    }
  ]
}
```

### 7.2 biomes.json

**File:** `config/biomes.json`

```json
{
  "version": "1.0",
  "biomes": {
    "cave": {
      "id": "cave",
      "name": "Cave",
      "description": "Natural underground cavern system",
      "defaultCategoryValues": {
        "climate": "cold",
        "lighting": "dim",
        "era": "ancient"
      },
      "impliedTags": ["underground", "natural", "stone", "cave"],
      "descriptorPoolOverrides": {
        "environmental.lighting": "environmental.lighting.cave",
        "environmental.sounds": "environmental.sounds.cave"
      },
      "emphasizedTerms": ["dripping", "echo", "stone", "stalactite"],
      "excludedTerms": ["sunlight", "breeze", "grass"]
    },
    "dungeon": {
      "id": "dungeon",
      "name": "Dungeon",
      "description": "Constructed underground passages and chambers",
      "defaultCategoryValues": {
        "climate": "cold",
        "lighting": "dim",
        "era": "medieval"
      },
      "impliedTags": ["underground", "constructed", "stone", "dungeon"],
      "descriptorPoolOverrides": {
        "environmental.lighting": "environmental.lighting.dungeon"
      },
      "emphasizedTerms": ["torch", "chains", "iron", "stone"],
      "excludedTerms": ["sunlight", "trees", "grass"]
    },
    "volcanic": {
      "id": "volcanic",
      "name": "Volcanic",
      "description": "Areas of active or dormant volcanic activity",
      "defaultCategoryValues": {
        "climate": "scorching",
        "lighting": "dim"
      },
      "impliedTags": ["volcanic", "heat", "danger", "fire"],
      "descriptorPoolOverrides": {
        "environmental.lighting": "environmental.lighting.volcanic",
        "environmental.temperature": "environmental.temperature.volcanic",
        "environmental.smells": "environmental.smells.volcanic"
      },
      "emphasizedTerms": ["lava", "sulfur", "heat", "glow", "magma"],
      "excludedTerms": ["cold", "ice", "frost", "chill", "freezing"]
    },
    "frozen": {
      "id": "frozen",
      "name": "Frozen",
      "description": "Ice-covered or extremely cold regions",
      "defaultCategoryValues": {
        "climate": "freezing",
        "lighting": "bright"
      },
      "impliedTags": ["frozen", "ice", "cold", "snow"],
      "descriptorPoolOverrides": {
        "environmental.temperature": "environmental.temperature.frozen",
        "environmental.sounds": "environmental.sounds.frozen"
      },
      "emphasizedTerms": ["ice", "frost", "frozen", "cold", "chill"],
      "excludedTerms": ["warm", "heat", "fire", "lava", "sweat"]
    },
    "swamp": {
      "id": "swamp",
      "name": "Swamp",
      "description": "Waterlogged wetlands with decaying vegetation",
      "defaultCategoryValues": {
        "climate": "warm",
        "lighting": "dim",
        "condition": "flooded"
      },
      "impliedTags": ["swamp", "wet", "decay", "water", "muck"],
      "descriptorPoolOverrides": {
        "environmental.smells": "environmental.smells.swamp",
        "environmental.sounds": "environmental.sounds.swamp"
      },
      "emphasizedTerms": ["murky", "rotting", "mud", "stagnant", "squelch"],
      "excludedTerms": ["dry", "arid", "dusty", "clean"]
    },
    "ruins": {
      "id": "ruins",
      "name": "Ruins",
      "description": "Crumbling remains of ancient structures",
      "defaultCategoryValues": {
        "climate": "temperate",
        "lighting": "normal",
        "era": "ancient",
        "condition": "collapsed"
      },
      "impliedTags": ["ruins", "ancient", "stone", "decay"],
      "descriptorPoolOverrides": {},
      "emphasizedTerms": ["crumbling", "ancient", "worn", "faded", "forgotten"],
      "excludedTerms": ["new", "pristine", "polished"]
    },
    "forest": {
      "id": "forest",
      "name": "Forest",
      "description": "Dense woodland area",
      "defaultCategoryValues": {
        "climate": "temperate",
        "lighting": "dim",
        "condition": "overgrown"
      },
      "impliedTags": ["forest", "outdoor", "natural", "trees"],
      "descriptorPoolOverrides": {
        "environmental.sounds": "environmental.sounds.forest",
        "environmental.smells": "environmental.smells.forest"
      },
      "emphasizedTerms": ["leaves", "bark", "branches", "canopy", "undergrowth"],
      "excludedTerms": ["stone", "dungeon", "torch"]
    },
    "desert": {
      "id": "desert",
      "name": "Desert",
      "description": "Arid wasteland or sandy expanse",
      "defaultCategoryValues": {
        "climate": "hot",
        "lighting": "bright"
      },
      "impliedTags": ["desert", "outdoor", "dry", "sand"],
      "descriptorPoolOverrides": {
        "environmental.temperature": "environmental.temperature.desert"
      },
      "emphasizedTerms": ["sand", "sun", "dry", "parched", "dune"],
      "excludedTerms": ["wet", "damp", "moist", "water"]
    }
  }
}
```

### 7.3 Configuration Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `categories.<id>.id` | string | Yes | Unique category identifier |
| `categories.<id>.name` | string | Yes | Display name |
| `categories.<id>.isRequired` | boolean | No | Whether rooms must have this category |
| `categories.<id>.defaultValue` | string | No | Default value if not specified |
| `categories.<id>.values` | array | Yes | Available values in this category |
| `categories.<id>.values[].impliedTags` | array | No | Tags added when this value is active |
| `exclusionRules[].category1` | string | Yes | First category in conflict |
| `exclusionRules[].values1` | array | Yes | Values in category1 that conflict |
| `exclusionRules[].category2` | string | Yes | Second category in conflict |
| `exclusionRules[].values2` | array | Yes | Values in category2 that conflict |
| `exclusionRules[].isHardRule` | boolean | No | True = error, False = warning |
| `biomes.<id>.defaultCategoryValues` | object | No | Default values by category |
| `biomes.<id>.descriptorPoolOverrides` | object | No | Pool path overrides |

---

## 8. Acceptance Criteria

### 8.1 Environment Categories

- [ ] Environment categories load from `environment-categories.json`
- [ ] Category values include implied tags
- [ ] Required categories validated on context creation
- [ ] Default values applied when not specified

### 8.2 Coherence Validation

- [ ] Exclusion rules detect conflicting category values
- [ ] Hard rule violations throw exceptions
- [ ] Soft rule violations log warnings but proceed
- [ ] `Validate()` returns detailed violation information

### 8.3 Biome System

- [ ] Biomes load from `biomes.json`
- [ ] `CreateFromBiome()` creates valid environment contexts
- [ ] Biome defaults applied correctly
- [ ] Biome overrides respected during creation
- [ ] Biome pool overrides affect descriptor selection

### 8.4 Descriptor Integration

- [ ] `DescriptorContext` includes `EnvironmentContext`
- [ ] Derived tags from environment used in filtering
- [ ] `GenerateRoomAtmosphereWithEnvironment()` produces coherent output
- [ ] Biome-specific pool overrides work correctly

### 8.5 General

- [ ] ~18 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings
- [ ] Existing `DescriptorService` methods unchanged (backwards compatible)

---

## 9. Test Specifications

### 9.1 Unit Tests (~18 tests)

#### EnvironmentContextTests.cs

```csharp
[TestFixture]
public class EnvironmentContextTests
{
    [Test]
    public void GetValue_WhenCategoryExists_ReturnsValue();

    [Test]
    public void GetValue_WhenCategoryMissing_ReturnsNull();

    [Test]
    public void WithValue_AddsNewCategory_PreservesExisting();

    [Test]
    public void Biome_Property_ReturnsBiomeValue();

    [Test]
    public void HasCategory_WhenExists_ReturnsTrue();
}
```

#### EnvironmentCoherenceServiceTests.cs

```csharp
[TestFixture]
public class EnvironmentCoherenceServiceTests
{
    [Test]
    public void Validate_WithNoConflicts_ReturnsValid();

    [Test]
    public void Validate_WithHardConflict_ReturnsViolation();

    [Test]
    public void Validate_WithSoftConflict_ReturnsWarningViolation();

    [Test]
    public void CreateFromBiome_WithValidBiome_CreatesContext();

    [Test]
    public void CreateFromBiome_WithUnknownBiome_ThrowsException();

    [Test]
    public void CreateFromBiome_AppliesDefaultValues();

    [Test]
    public void CreateFromBiome_AppliesOverrides();

    [Test]
    public void CreateFromBiome_WithConflictingOverride_ThrowsException();

    [Test]
    public void CreateFromBiome_CollectsDerivedTags();

    [Test]
    public void GetValidValues_ExcludesConflictingValues();

    [Test]
    public void GetBiome_WhenExists_ReturnsBiome();

    [Test]
    public void GetBiome_WhenMissing_ReturnsNull();
}
```

#### DescriptorServiceEnvironmentTests.cs

```csharp
[TestFixture]
public class DescriptorServiceEnvironmentTests
{
    [Test]
    public void GetDescriptorWithEnvironment_AppliesBiomeOverrides();

    [Test]
    public void GetDescriptorWithEnvironment_IncludesDerivedTags();

    [Test]
    public void GenerateRoomAtmosphereWithEnvironment_ProducesCoherentOutput();

    [Test]
    public void GetEffectiveTags_CombinesExplicitAndDerivedTags();

    [Test]
    public void GetEffectiveTags_WhenEnvironmentTagsDisabled_OnlyExplicitTags();
}
```

---

## 10. Dependencies

### 10.1 Required from Previous Versions

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `DescriptorService` | `Application/Services/DescriptorService.cs` | Extended with environment methods |
| `DescriptorConfiguration` | `Application/Configuration/DescriptorConfiguration.cs` | Unchanged, still used |
| `ThemeConfiguration` | `Application/Configuration/ThemeConfiguration.cs` | Theme overrides still apply |
| `Room` | `Domain/Entities/Room.cs` | Add `Environment` property |
| `IGameConfigurationProvider` | `Application/Interfaces/IGameConfigurationProvider.cs` | Extended for new configs |

### 10.2 Provides to v0.0.11b

| Type | Usage |
|------|-------|
| `EnvironmentContext` | Context for combat descriptor selection |
| `EnvironmentCoherenceService` | Biome info for combat flavor |
| `DescriptorContext.Environment` | Pass environment to combat descriptors |

### 10.3 Provides to v0.0.11c

| Type | Usage |
|------|-------|
| `EnvironmentContext` | Context for sensory descriptor selection |
| `BiomeDefinition` | Sensory defaults by biome |
| `EnvironmentCoherenceService` | Validate sensory combinations |

---

## 11. Files Summary

### 11.1 New Files

| File | Purpose |
|------|---------|
| `src/Core/RuneAndRust.Application/Configuration/EnvironmentCategoryConfiguration.cs` | Category definitions |
| `src/Core/RuneAndRust.Application/Configuration/BiomeConfiguration.cs` | Biome definitions |
| `src/Core/RuneAndRust.Domain/ValueObjects/EnvironmentContext.cs` | Environment value object |
| `src/Core/RuneAndRust.Application/Services/EnvironmentCoherenceService.cs` | Validation service |
| `config/environment-categories.json` | Category configuration |
| `config/biomes.json` | Biome configuration |
| `tests/RuneAndRust.Domain.UnitTests/ValueObjects/EnvironmentContextTests.cs` | Context tests |
| `tests/RuneAndRust.Application.UnitTests/Services/EnvironmentCoherenceServiceTests.cs` | Service tests |
| `tests/RuneAndRust.Application.UnitTests/Services/DescriptorServiceEnvironmentTests.cs` | Integration tests |

### 11.2 Modified Files

| File | Changes |
|------|---------|
| `DescriptorService.cs` | Add environment-aware methods, update constructor |
| `DescriptorContext` class | Add `Environment`, `IncludeEnvironmentTags`, `GetEffectiveTags()` |
| `Room.cs` | Add `Environment` property and `SetEnvironment()` method |
| `IGameConfigurationProvider.cs` | Add methods for new configurations |
| `JsonConfigurationProvider.cs` | Load new configuration files |
| `DependencyInjection.cs` | Register `EnvironmentCoherenceService` |

---

*This design specification establishes the foundation for coherent environmental descriptors by introducing categories, exclusion rules, and biome definitions. The framework prevents incoherent descriptions while enabling rich, varied atmosphere generation based on environment context.*
