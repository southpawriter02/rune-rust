# v0.4.4a: The Attunement (Aetheric Resonance)

> **Status:** Planned
> **Parent:** v0.4.4 - The Mystic (Archetype Specialization)
> **Theme:** Personal Flux attunement that amplifies spell potency at escalating risk.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Deliverables Checklist](#deliverables-checklist)
5. [Implementation Workflow](#implementation-workflow)
6. [Code Examples](#code-examples)
7. [Logging Specification](#logging-specification)
8. [Unit Testing](#unit-testing)
9. [Integration Points](#integration-points)
10. [Domain 4 Compliance](#domain-4-compliance)
11. [Changelog Template](#changelog-template)

---

## Overview

v0.4.4a introduces **Aetheric Resonance**—the Mystic's personal attunement to ambient magical energy. While environmental **Flux** (v0.4.3) represents the instability of reality itself, **Resonance** measures how deeply a Mystic has synchronized with that instability.

### Core Concept

> *"The Aether does not merely flow through you—it remembers you. Each spell cast leaves an echo in your soul, a vibration that amplifies the next incantation. The wise Mystic rides this resonance like a wave; the foolish drowns in it."*
> — Jötun-Reader Field Notes, Codex Entry #447

### Key Distinctions from Flux

| Aspect | Flux (v0.4.3) | Resonance (v0.4.4a) |
|--------|---------------|---------------------|
| **Scope** | Environmental (shared by all) | Personal (per Mystic character) |
| **Source** | Spell casting adds to location | Spell casting + proximity to high Flux |
| **Decay** | Per combat round (~5/round) | Per rest period (slower, ~10/rest) |
| **Effect** | Backlash risk threshold | Spell potency modifier |
| **Cap** | 100 (Overload) | 100 (Overflow) |
| **Consequence** | Random backlash effects | Paradox (amplified backlash) + Soul Fracture |

### Resonance Thresholds

| Threshold | Range | Potency Modifier | Risk Level | Visual Indicator |
|-----------|-------|------------------|------------|------------------|
| **Dim** | 0-24 | -10% (0.90x) | Safe | No indicator |
| **Steady** | 25-49 | 0% (1.00x) | Low | Faint shimmer |
| **Bright** | 50-74 | +15% (1.15x) | Elevated | Visible aura |
| **Blazing** | 75-99 | +30% (1.30x) | High | Intense glow + particle effects |
| **Overflow** | 100 | +50% (1.50x) | Critical | One turn of power, then forced discharge |

### Casting Mode Modifiers

| Mode | Resonance Gain | Cast Time | Use Case |
|------|----------------|-----------|----------|
| **Quick** | +15 | Instant (bonus action) | Emergency, rapid response |
| **Standard** | +10 | 1 turn | Normal casting |
| **Channeled** | +5 | 2 turns | Reduced risk, preparation time |
| **Ritual** | +0 | 5+ minutes (out of combat) | Zero risk, narrative casting |

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        MagicService                              │
│   (Orchestrates spell casting, calls ResonanceService)          │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      IResonanceService                           │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ + ModifyResonance(character, amount, source): ResonanceResult│
│  │ + GetResonance(character): int                               │
│  │ + GetThreshold(character): ResonanceThreshold                │
│  │ + GetPotencyModifier(character): decimal                     │
│  │ + ApplyCastingModeModifiers(mode): CastingModeResult         │
│  │ + ProcessResonanceDecay(character): int                      │
│  │ + TriggerOverflow(character): OverflowResult                 │
│  │ + Reset(character): void                                     │
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      ResonanceService                            │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ - _logger: ILogger<ResonanceService>                        ││
│  │ - _eventBus: IEventBus                                      ││
│  │ - _diceService: IDiceService                                ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────┬───────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  ResonanceState │ │ResonanceThreshold│ │  CastingMode   │
│    (Model)      │ │     (Enum)       │ │    (Enum)      │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

### Layer Distribution

| Component | Layer | Namespace |
|-----------|-------|-----------|
| `ResonanceState` | Core | `RuneAndRust.Core.Models.Magic` |
| `ResonanceThreshold` | Core | `RuneAndRust.Core.Enums` |
| `CastingMode` | Core | `RuneAndRust.Core.Enums` |
| `ResonanceResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `CastingModeResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `OverflowResult` | Core | `RuneAndRust.Core.Models.Magic` |
| `ResonanceChangedEvent` | Core | `RuneAndRust.Core.Events` |
| `IResonanceService` | Core | `RuneAndRust.Core.Interfaces` |
| `ResonanceService` | Engine | `RuneAndRust.Engine.Services` |
| `ResonanceServiceTests` | Tests | `RuneAndRust.Tests.Services` |

---

## Decision Trees

### DT-1: ModifyResonance

```
ModifyResonance(character, amount, source)
│
├─► [1] Validate Character is Mystic?
│   ├─ NO → Log Warning, Return NoChange result
│   └─ YES → Continue
│
├─► [2] Capture Previous State
│   ├─ previousValue = character.Resonance
│   └─ previousThreshold = CalculateThreshold(previousValue)
│
├─► [3] Calculate New Value
│   ├─ rawNew = previousValue + amount
│   └─ clampedNew = Math.Clamp(rawNew, 0, 100)
│
├─► [4] Apply Change
│   └─ character.Resonance = clampedNew
│
├─► [5] Calculate New Threshold
│   └─ newThreshold = CalculateThreshold(clampedNew)
│
├─► [6] Check for Overflow (100)?
│   ├─ YES → Set OverflowTriggered = true
│   └─ NO → Continue
│
├─► [7] Determine Event Significance
│   ├─ thresholdChanged = previousThreshold != newThreshold
│   ├─ largeChange = Math.Abs(amount) >= 15
│   └─ hitBoundary = clampedNew == 0 || clampedNew == 100
│
├─► [8] Publish Event if Significant?
│   ├─ (thresholdChanged OR largeChange OR hitBoundary)
│   │   └─ Publish ResonanceChangedEvent
│   └─ ELSE → No event
│
└─► [9] Return ResonanceResult
    ├─ PreviousValue, NewValue, Amount
    ├─ PreviousThreshold, NewThreshold
    ├─ ThresholdChanged, OverflowTriggered
    └─ Source
```

### DT-2: GetPotencyModifier

```
GetPotencyModifier(character)
│
├─► [1] Get Current Resonance
│   └─ resonance = character.Resonance
│
├─► [2] Calculate Threshold
│   └─ threshold = CalculateThreshold(resonance)
│
├─► [3] Return Modifier Based on Threshold
│   ├─ Dim (0-24)      → return 0.90m
│   ├─ Steady (25-49)  → return 1.00m
│   ├─ Bright (50-74)  → return 1.15m
│   ├─ Blazing (75-99) → return 1.30m
│   └─ Overflow (100)  → return 1.50m
│
└─► [4] Log Result
    └─ Debug: "Potency modifier for {Name}: {Modifier}x at {Threshold}"
```

### DT-3: ApplyCastingModeModifiers

```
ApplyCastingModeModifiers(mode)
│
├─► [1] Determine Resonance Gain
│   ├─ Quick      → resonanceGain = 15
│   ├─ Standard   → resonanceGain = 10
│   ├─ Channeled  → resonanceGain = 5
│   └─ Ritual     → resonanceGain = 0
│
├─► [2] Determine Cast Time Modifier
│   ├─ Quick      → castTimeModifier = 0 (bonus action)
│   ├─ Standard   → castTimeModifier = 1 (standard)
│   ├─ Channeled  → castTimeModifier = 2 (extended)
│   └─ Ritual     → castTimeModifier = -1 (out of combat)
│
├─► [3] Determine Flux Modifier
│   ├─ Quick      → fluxModifier = +5 (adds extra Flux)
│   ├─ Standard   → fluxModifier = 0
│   ├─ Channeled  → fluxModifier = -5 (reduces Flux)
│   └─ Ritual     → fluxModifier = -10 (significant reduction)
│
├─► [4] Log Selection
│   └─ Debug: "Casting mode {Mode}: +{Res} resonance, {Time} turns, {Flux} flux"
│
└─► [5] Return CastingModeResult
    ├─ Mode, ResonanceGain
    ├─ CastTimeModifier, FluxModifier
    └─ IsOutOfCombat (Ritual only)
```

### DT-4: ProcessResonanceDecay

```
ProcessResonanceDecay(character)
│
├─► [1] Validate Character is Mystic?
│   ├─ NO → Return 0
│   └─ YES → Continue
│
├─► [2] Check Rest State
│   ├─ NOT Resting → Return 0 (no decay during active play)
│   └─ Resting → Continue
│
├─► [3] Capture Current State
│   └─ currentResonance = character.Resonance
│
├─► [4] Calculate Decay Amount
│   ├─ baseDecay = 10
│   ├─ (Optional) Apply modifiers from traits/equipment
│   └─ actualDecay = Math.Min(baseDecay, currentResonance)
│
├─► [5] Apply Decay
│   └─ character.Resonance = currentResonance - actualDecay
│
├─► [6] Check Threshold Change
│   ├─ oldThreshold = CalculateThreshold(currentResonance)
│   ├─ newThreshold = CalculateThreshold(character.Resonance)
│   └─ IF changed → Publish ResonanceChangedEvent
│
└─► [7] Return Amount Decayed
    └─ return actualDecay
```

### DT-5: TriggerOverflow

```
TriggerOverflow(character)
│
├─► [1] Validate Resonance == 100?
│   ├─ NO → Log Warning, Return NoOverflow result
│   └─ YES → Continue
│
├─► [2] Mark Overflow Active
│   └─ character.OverflowActive = true
│
├─► [3] Log Critical Event
│   └─ Warning: "OVERFLOW: {Name} resonance peaked at 100!"
│
├─► [4] Calculate Discharge Amount
│   └─ dischargeAmount = 50 (forced reduction after 1 turn)
│
├─► [5] Check for Soul Fracture Risk
│   ├─ IF character.OverflowCount >= 3 → highRisk = true
│   └─ ELSE → highRisk = false
│
├─► [6] Publish OverflowTriggeredEvent
│   └─ Include potency bonus, duration, soul fracture risk
│
└─► [7] Return OverflowResult
    ├─ PotencyBonus = 1.50m
    ├─ DurationTurns = 1
    ├─ DischargeAmount = 50
    ├─ SoulFractureRisk = highRisk
    └─ OverflowCount = character.OverflowCount + 1
```

### DT-6: CalculateThreshold (Internal)

```
CalculateThreshold(resonanceValue)
│
├─► Switch on Value
│   ├─ >= 100 → return ResonanceThreshold.Overflow
│   ├─ >= 75  → return ResonanceThreshold.Blazing
│   ├─ >= 50  → return ResonanceThreshold.Bright
│   ├─ >= 25  → return ResonanceThreshold.Steady
│   └─ < 25   → return ResonanceThreshold.Dim
```

---

## Deliverables Checklist

### Core Layer (`RuneAndRust.Core`)

- [ ] **Enums**
  - [ ] `ResonanceThreshold.cs` - Dim, Steady, Bright, Blazing, Overflow
  - [ ] `CastingMode.cs` - Quick, Standard, Channeled, Ritual

- [ ] **Models**
  - [ ] `ResonanceState.cs` - State tracking model
  - [ ] `ResonanceResult.cs` - Modification result record
  - [ ] `CastingModeResult.cs` - Mode modifier result record
  - [ ] `OverflowResult.cs` - Overflow event result record

- [ ] **Events**
  - [ ] `ResonanceChangedEvent.cs` - Published on threshold change
  - [ ] `OverflowTriggeredEvent.cs` - Published when resonance hits 100

- [ ] **Interfaces**
  - [ ] `IResonanceService.cs` - Service contract

### Engine Layer (`RuneAndRust.Engine`)

- [ ] **Services**
  - [ ] `ResonanceService.cs` - Full implementation with logging

- [ ] **Integration**
  - [ ] `MagicService` integration - Call `GetPotencyModifier()` during spell resolution
  - [ ] `RestService` integration - Call `ProcessResonanceDecay()` during rest

### Infrastructure Layer

- [ ] **DI Registration**
  - [ ] Register `IResonanceService` → `ResonanceService` in `Program.cs`

### Test Layer (`RuneAndRust.Tests`)

- [ ] **Unit Tests**
  - [ ] `ResonanceServiceTests.cs` - 32+ unit tests

### Documentation

- [ ] Update `docs/design/01-core/resources/aether.md` with Resonance section
- [ ] Add Resonance to Character creation flow documentation

---

## Implementation Workflow

### Phase 1: Foundation (Enums & Models)

```
Step 1.1: Create ResonanceThreshold enum
Step 1.2: Create CastingMode enum
Step 1.3: Create ResonanceState model
Step 1.4: Create ResonanceResult record
Step 1.5: Create CastingModeResult record
Step 1.6: Create OverflowResult record
Step 1.7: Build and verify Core compiles
```

### Phase 2: Events

```
Step 2.1: Create ResonanceChangedEvent record
Step 2.2: Create OverflowTriggeredEvent record
Step 2.3: Verify event bus compatibility
```

### Phase 3: Interface

```
Step 3.1: Create IResonanceService interface
Step 3.2: Define all method signatures
Step 3.3: Add XML documentation
```

### Phase 4: Service Implementation

```
Step 4.1: Create ResonanceService class skeleton
Step 4.2: Implement CalculateThreshold (private)
Step 4.3: Implement GetResonance
Step 4.4: Implement GetThreshold
Step 4.5: Implement GetPotencyModifier
Step 4.6: Implement ModifyResonance
Step 4.7: Implement ApplyCastingModeModifiers
Step 4.8: Implement ProcessResonanceDecay
Step 4.9: Implement TriggerOverflow
Step 4.10: Implement Reset
Step 4.11: Add comprehensive logging throughout
```

### Phase 5: Testing

```
Step 5.1: Create ResonanceServiceTests class
Step 5.2: Implement ModifyResonance tests (8)
Step 5.3: Implement Threshold Detection tests (6)
Step 5.4: Implement Potency Calculation tests (6)
Step 5.5: Implement Casting Mode tests (8)
Step 5.6: Implement Integration tests (4)
Step 5.7: Verify 80%+ code coverage
```

### Phase 6: Integration

```
Step 6.1: Register ResonanceService in DI container
Step 6.2: Integrate with MagicService (potency calculation)
Step 6.3: Integrate with RestService (decay processing)
Step 6.4: End-to-end manual testing
```

---

## Code Examples

### ResonanceThreshold.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Represents the intensity level of a Mystic's Aetheric Resonance.
/// Higher thresholds grant greater spell potency but increase Paradox risk.
/// </summary>
public enum ResonanceThreshold
{
    /// <summary>
    /// 0-24: Minimal attunement. -10% spell potency. Safe casting.
    /// </summary>
    Dim = 0,

    /// <summary>
    /// 25-49: Balanced attunement. Normal spell potency. Minor risk.
    /// </summary>
    Steady = 1,

    /// <summary>
    /// 50-74: Elevated attunement. +15% spell potency. Moderate risk.
    /// </summary>
    Bright = 2,

    /// <summary>
    /// 75-99: Intense attunement. +30% spell potency. High risk.
    /// </summary>
    Blazing = 3,

    /// <summary>
    /// 100: Critical attunement. +50% potency for 1 turn, then forced discharge.
    /// </summary>
    Overflow = 4
}
```

### CastingMode.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Determines how a Mystic casts a spell, affecting resonance gain and cast time.
/// </summary>
public enum CastingMode
{
    /// <summary>
    /// Instant cast as bonus action. +15 Resonance, +5 Flux.
    /// </summary>
    Quick = 0,

    /// <summary>
    /// Standard single-turn cast. +10 Resonance, normal Flux.
    /// </summary>
    Standard = 1,

    /// <summary>
    /// Extended two-turn cast. +5 Resonance, -5 Flux.
    /// </summary>
    Channeled = 2,

    /// <summary>
    /// Out-of-combat ritual. +0 Resonance, -10 Flux. Cannot be used in combat.
    /// </summary>
    Ritual = 3
}
```

### ResonanceState.cs

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Tracks a Mystic's personal Aetheric Resonance—their attunement to ambient Flux.
/// </summary>
public class ResonanceState
{
    public const int MinResonance = 0;
    public const int MaxResonance = 100;
    public const int DefaultDecayRate = 10;

    // Threshold boundaries
    public const int DimUpperBound = 24;
    public const int SteadyUpperBound = 49;
    public const int BrightUpperBound = 74;
    public const int BlazingUpperBound = 99;

    /// <summary>
    /// Current resonance value (0-100).
    /// </summary>
    public int CurrentValue { get; set; } = MinResonance;

    /// <summary>
    /// Amount of resonance lost per rest period.
    /// </summary>
    public int DecayRate { get; set; } = DefaultDecayRate;

    /// <summary>
    /// Number of times this character has triggered Overflow.
    /// Used to calculate Soul Fracture risk.
    /// </summary>
    public int OverflowCount { get; set; } = 0;

    /// <summary>
    /// Whether the character is currently in Overflow state (1 turn of +50% potency).
    /// </summary>
    public bool IsOverflowActive { get; set; } = false;

    /// <summary>
    /// Current threshold based on resonance value.
    /// </summary>
    public ResonanceThreshold Threshold => CurrentValue switch
    {
        >= MaxResonance => ResonanceThreshold.Overflow,
        >= 75 => ResonanceThreshold.Blazing,
        >= 50 => ResonanceThreshold.Bright,
        >= 25 => ResonanceThreshold.Steady,
        _ => ResonanceThreshold.Dim
    };

    /// <summary>
    /// Potency multiplier based on current threshold.
    /// </summary>
    public decimal PotencyModifier => Threshold switch
    {
        ResonanceThreshold.Overflow => 1.50m,
        ResonanceThreshold.Blazing => 1.30m,
        ResonanceThreshold.Bright => 1.15m,
        ResonanceThreshold.Steady => 1.00m,
        ResonanceThreshold.Dim => 0.90m,
        _ => 1.00m
    };

    /// <summary>
    /// True if resonance is at or above Bright threshold (elevated risk).
    /// </summary>
    public bool IsElevatedRisk => CurrentValue >= 50;

    /// <summary>
    /// True if resonance is at or above Blazing threshold (high risk).
    /// </summary>
    public bool IsHighRisk => CurrentValue >= 75;

    /// <summary>
    /// True if resonance has reached maximum (Overflow imminent).
    /// </summary>
    public bool IsAtMaximum => CurrentValue >= MaxResonance;

    /// <summary>
    /// Percentage of maximum resonance (0-100).
    /// </summary>
    public int PercentFull => CurrentValue;

    /// <summary>
    /// Resets resonance to minimum value.
    /// </summary>
    public void Reset()
    {
        CurrentValue = MinResonance;
        IsOverflowActive = false;
    }
}
```

### ResonanceResult.cs

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Result of a resonance modification operation.
/// </summary>
public record ResonanceResult(
    int PreviousValue,
    int NewValue,
    int RequestedAmount,
    int ActualAmount,
    ResonanceThreshold PreviousThreshold,
    ResonanceThreshold NewThreshold,
    string Source)
{
    /// <summary>
    /// True if the modification crossed a threshold boundary.
    /// </summary>
    public bool ThresholdChanged => PreviousThreshold != NewThreshold;

    /// <summary>
    /// True if resonance increased.
    /// </summary>
    public bool IsIncrease => ActualAmount > 0;

    /// <summary>
    /// True if resonance decreased.
    /// </summary>
    public bool IsDecrease => ActualAmount < 0;

    /// <summary>
    /// True if resonance hit maximum (100).
    /// </summary>
    public bool OverflowTriggered => NewValue >= ResonanceState.MaxResonance;

    /// <summary>
    /// True if resonance hit minimum (0).
    /// </summary>
    public bool FullyDissipated => NewValue <= ResonanceState.MinResonance;

    /// <summary>
    /// True if the requested amount was clamped (hit boundary).
    /// </summary>
    public bool WasClamped => RequestedAmount != ActualAmount;

    /// <summary>
    /// Factory for creating a "no change" result (non-Mystic characters).
    /// </summary>
    public static ResonanceResult NoChange(string source) => new(
        PreviousValue: 0,
        NewValue: 0,
        RequestedAmount: 0,
        ActualAmount: 0,
        PreviousThreshold: ResonanceThreshold.Dim,
        NewThreshold: ResonanceThreshold.Dim,
        Source: source);
}
```

### CastingModeResult.cs

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Modifiers applied based on the selected casting mode.
/// </summary>
public record CastingModeResult(
    CastingMode Mode,
    int ResonanceGain,
    int CastTimeModifier,
    int FluxModifier)
{
    /// <summary>
    /// True if this mode can only be used outside of combat.
    /// </summary>
    public bool IsOutOfCombatOnly => Mode == CastingMode.Ritual;

    /// <summary>
    /// True if this mode grants bonus action casting.
    /// </summary>
    public bool IsBonusAction => Mode == CastingMode.Quick;

    /// <summary>
    /// True if this mode requires multiple turns.
    /// </summary>
    public bool IsExtendedCast => Mode == CastingMode.Channeled;

    /// <summary>
    /// Descriptive text for the casting mode.
    /// </summary>
    public string Description => Mode switch
    {
        CastingMode.Quick => "Quick cast (bonus action, +15 resonance)",
        CastingMode.Standard => "Standard cast (1 turn, +10 resonance)",
        CastingMode.Channeled => "Channeled cast (2 turns, +5 resonance)",
        CastingMode.Ritual => "Ritual cast (out of combat, +0 resonance)",
        _ => "Unknown casting mode"
    };
}
```

### OverflowResult.cs

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Result of an Aetheric Overflow event (resonance reaching 100).
/// </summary>
public record OverflowResult(
    decimal PotencyBonus,
    int DurationTurns,
    int DischargeAmount,
    bool SoulFractureRisk,
    int TotalOverflowCount)
{
    /// <summary>
    /// True if this overflow carries risk of permanent Soul Fracture.
    /// </summary>
    public bool IsHighRisk => SoulFractureRisk;

    /// <summary>
    /// Factory for creating a "no overflow" result.
    /// </summary>
    public static OverflowResult None => new(
        PotencyBonus: 1.0m,
        DurationTurns: 0,
        DischargeAmount: 0,
        SoulFractureRisk: false,
        TotalOverflowCount: 0);
}
```

### ResonanceChangedEvent.cs

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Published when a character's Aetheric Resonance changes significantly.
/// </summary>
public record ResonanceChangedEvent(
    Guid CharacterId,
    string CharacterName,
    int OldValue,
    int NewValue,
    int ChangeAmount,
    string Source,
    ResonanceThreshold OldThreshold,
    ResonanceThreshold NewThreshold)
{
    /// <summary>
    /// True if a threshold boundary was crossed.
    /// </summary>
    public bool ThresholdChanged => OldThreshold != NewThreshold;

    /// <summary>
    /// True if resonance increased.
    /// </summary>
    public bool IsIncrease => ChangeAmount > 0;

    /// <summary>
    /// True if resonance decreased.
    /// </summary>
    public bool IsDecrease => ChangeAmount < 0;

    /// <summary>
    /// True if resonance hit maximum.
    /// </summary>
    public bool HitMaximum => NewValue >= ResonanceState.MaxResonance;

    /// <summary>
    /// True if resonance hit minimum.
    /// </summary>
    public bool HitMinimum => NewValue <= ResonanceState.MinResonance;

    /// <summary>
    /// Direction of the threshold change (up, down, or none).
    /// </summary>
    public string ThresholdDirection => ThresholdChanged
        ? (NewThreshold > OldThreshold ? "Ascending" : "Descending")
        : "Stable";
}
```

### IResonanceService.cs

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for managing Mystic Aetheric Resonance—personal attunement to ambient Flux.
/// </summary>
public interface IResonanceService
{
    /// <summary>
    /// Modifies a character's resonance by the specified amount.
    /// </summary>
    /// <param name="character">The character whose resonance to modify.</param>
    /// <param name="amount">Amount to add (positive) or subtract (negative).</param>
    /// <param name="source">Description of what caused the change.</param>
    /// <returns>Result containing old/new values and threshold information.</returns>
    ResonanceResult ModifyResonance(Character character, int amount, string source);

    /// <summary>
    /// Gets the current resonance value for a character.
    /// </summary>
    /// <param name="character">The character to query.</param>
    /// <returns>Current resonance (0-100), or 0 if not a Mystic.</returns>
    int GetResonance(Character character);

    /// <summary>
    /// Gets the current resonance threshold for a character.
    /// </summary>
    /// <param name="character">The character to query.</param>
    /// <returns>Current threshold enum value.</returns>
    ResonanceThreshold GetThreshold(Character character);

    /// <summary>
    /// Gets the spell potency modifier based on current resonance.
    /// </summary>
    /// <param name="character">The character to query.</param>
    /// <returns>Multiplier (0.90 to 1.50).</returns>
    decimal GetPotencyModifier(Character character);

    /// <summary>
    /// Gets the modifiers for a specific casting mode.
    /// </summary>
    /// <param name="mode">The casting mode to evaluate.</param>
    /// <returns>Result containing resonance gain, cast time, and flux modifiers.</returns>
    CastingModeResult ApplyCastingModeModifiers(CastingMode mode);

    /// <summary>
    /// Processes resonance decay during rest.
    /// </summary>
    /// <param name="character">The character whose resonance should decay.</param>
    /// <returns>Amount of resonance that decayed.</returns>
    int ProcessResonanceDecay(Character character);

    /// <summary>
    /// Triggers the Overflow state when resonance reaches 100.
    /// </summary>
    /// <param name="character">The character experiencing overflow.</param>
    /// <returns>Result containing potency bonus, duration, and risk information.</returns>
    OverflowResult TriggerOverflow(Character character);

    /// <summary>
    /// Processes the end of an Overflow state (forced discharge).
    /// </summary>
    /// <param name="character">The character to discharge.</param>
    /// <returns>Amount of resonance discharged.</returns>
    int ProcessOverflowDischarge(Character character);

    /// <summary>
    /// Resets a character's resonance to zero.
    /// </summary>
    /// <param name="character">The character to reset.</param>
    void Reset(Character character);
}
```

### ResonanceService.cs

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Events;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models;
using RuneAndRust.Core.Models.Magic;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Manages Mystic Aetheric Resonance—personal attunement to ambient Flux.
/// </summary>
public class ResonanceService : IResonanceService
{
    private readonly ILogger<ResonanceService> _logger;
    private readonly IEventBus _eventBus;

    private const int SignificantChangeThreshold = 15;
    private const int OverflowDischargeAmount = 50;
    private const int SoulFractureRiskThreshold = 3;

    public ResonanceService(
        ILogger<ResonanceService> logger,
        IEventBus eventBus)
    {
        _logger = logger;
        _eventBus = eventBus;

        _logger.LogDebug("ResonanceService initialized");
    }

    /// <inheritdoc />
    public ResonanceResult ModifyResonance(Character character, int amount, string source)
    {
        _logger.LogDebug(
            "ModifyResonance called: Character={Name}, Amount={Amount}, Source={Source}",
            character.Name, amount, source);

        // Validate character is a Mystic
        if (character.Archetype != ArchetypeType.Mystic)
        {
            _logger.LogWarning(
                "ModifyResonance called for non-Mystic character {Name} (Archetype={Archetype})",
                character.Name, character.Archetype);
            return ResonanceResult.NoChange(source);
        }

        // Ensure ResonanceState exists
        character.ResonanceState ??= new ResonanceState();

        // Capture previous state
        var previousValue = character.ResonanceState.CurrentValue;
        var previousThreshold = CalculateThreshold(previousValue);

        _logger.LogTrace(
            "Previous state: Value={Value}, Threshold={Threshold}",
            previousValue, previousThreshold);

        // Calculate new value with clamping
        var rawNewValue = previousValue + amount;
        var clampedNewValue = Math.Clamp(rawNewValue, ResonanceState.MinResonance, ResonanceState.MaxResonance);
        var actualAmount = clampedNewValue - previousValue;

        // Apply change
        character.ResonanceState.CurrentValue = clampedNewValue;

        // Calculate new threshold
        var newThreshold = CalculateThreshold(clampedNewValue);

        _logger.LogTrace(
            "New state: Value={Value}, Threshold={Threshold}, ActualChange={Actual}",
            clampedNewValue, newThreshold, actualAmount);

        // Determine if event should be published
        var thresholdChanged = previousThreshold != newThreshold;
        var largeChange = Math.Abs(actualAmount) >= SignificantChangeThreshold;
        var hitBoundary = clampedNewValue == ResonanceState.MinResonance ||
                          clampedNewValue == ResonanceState.MaxResonance;

        if (thresholdChanged)
        {
            _logger.LogInformation(
                "Resonance threshold changed for {Name}: {OldThreshold} -> {NewThreshold} (Value: {Value})",
                character.Name, previousThreshold, newThreshold, clampedNewValue);
        }

        // Publish event if significant
        if (thresholdChanged || largeChange || hitBoundary)
        {
            var resonanceEvent = new ResonanceChangedEvent(
                CharacterId: character.Id,
                CharacterName: character.Name,
                OldValue: previousValue,
                NewValue: clampedNewValue,
                ChangeAmount: actualAmount,
                Source: source,
                OldThreshold: previousThreshold,
                NewThreshold: newThreshold);

            _eventBus.Publish(resonanceEvent);

            _logger.LogDebug(
                "Published ResonanceChangedEvent: {OldValue} -> {NewValue} ({Source})",
                previousValue, clampedNewValue, source);
        }

        // Check for overflow trigger
        if (clampedNewValue >= ResonanceState.MaxResonance && previousValue < ResonanceState.MaxResonance)
        {
            _logger.LogWarning(
                "OVERFLOW TRIGGERED: {Name} resonance reached {Value}!",
                character.Name, clampedNewValue);
        }

        var result = new ResonanceResult(
            PreviousValue: previousValue,
            NewValue: clampedNewValue,
            RequestedAmount: amount,
            ActualAmount: actualAmount,
            PreviousThreshold: previousThreshold,
            NewThreshold: newThreshold,
            Source: source);

        _logger.LogDebug(
            "ModifyResonance completed: {PrevValue} -> {NewValue}, ThresholdChanged={Changed}",
            previousValue, clampedNewValue, thresholdChanged);

        return result;
    }

    /// <inheritdoc />
    public int GetResonance(Character character)
    {
        _logger.LogTrace("GetResonance called for {Name}", character.Name);

        if (character.Archetype != ArchetypeType.Mystic)
        {
            _logger.LogTrace("Character {Name} is not a Mystic, returning 0", character.Name);
            return 0;
        }

        var resonance = character.ResonanceState?.CurrentValue ?? 0;
        _logger.LogTrace("Resonance for {Name}: {Value}", character.Name, resonance);
        return resonance;
    }

    /// <inheritdoc />
    public ResonanceThreshold GetThreshold(Character character)
    {
        _logger.LogTrace("GetThreshold called for {Name}", character.Name);

        var resonance = GetResonance(character);
        var threshold = CalculateThreshold(resonance);

        _logger.LogTrace("Threshold for {Name}: {Threshold} (Value={Value})",
            character.Name, threshold, resonance);
        return threshold;
    }

    /// <inheritdoc />
    public decimal GetPotencyModifier(Character character)
    {
        _logger.LogTrace("GetPotencyModifier called for {Name}", character.Name);

        var threshold = GetThreshold(character);
        var modifier = threshold switch
        {
            ResonanceThreshold.Overflow => 1.50m,
            ResonanceThreshold.Blazing => 1.30m,
            ResonanceThreshold.Bright => 1.15m,
            ResonanceThreshold.Steady => 1.00m,
            ResonanceThreshold.Dim => 0.90m,
            _ => 1.00m
        };

        _logger.LogDebug(
            "Potency modifier for {Name}: {Modifier}x at {Threshold} threshold",
            character.Name, modifier, threshold);

        return modifier;
    }

    /// <inheritdoc />
    public CastingModeResult ApplyCastingModeModifiers(CastingMode mode)
    {
        _logger.LogDebug("ApplyCastingModeModifiers called for mode: {Mode}", mode);

        var (resonanceGain, castTimeModifier, fluxModifier) = mode switch
        {
            CastingMode.Quick => (15, 0, 5),
            CastingMode.Standard => (10, 1, 0),
            CastingMode.Channeled => (5, 2, -5),
            CastingMode.Ritual => (0, -1, -10),
            _ => (10, 1, 0) // Default to Standard
        };

        var result = new CastingModeResult(
            Mode: mode,
            ResonanceGain: resonanceGain,
            CastTimeModifier: castTimeModifier,
            FluxModifier: fluxModifier);

        _logger.LogDebug(
            "Casting mode {Mode}: ResonanceGain={Res}, CastTime={Time}, FluxMod={Flux}",
            mode, resonanceGain, castTimeModifier, fluxModifier);

        return result;
    }

    /// <inheritdoc />
    public int ProcessResonanceDecay(Character character)
    {
        _logger.LogDebug("ProcessResonanceDecay called for {Name}", character.Name);

        if (character.Archetype != ArchetypeType.Mystic)
        {
            _logger.LogTrace("Character {Name} is not a Mystic, no decay", character.Name);
            return 0;
        }

        if (character.ResonanceState == null || character.ResonanceState.CurrentValue == 0)
        {
            _logger.LogTrace("Character {Name} has no resonance to decay", character.Name);
            return 0;
        }

        var currentValue = character.ResonanceState.CurrentValue;
        var decayRate = character.ResonanceState.DecayRate;
        var actualDecay = Math.Min(decayRate, currentValue);

        // Apply decay through ModifyResonance to handle events properly
        var result = ModifyResonance(character, -actualDecay, "Rest decay");

        _logger.LogInformation(
            "Resonance decayed for {Name}: {OldValue} -> {NewValue} (-{Decay})",
            character.Name, currentValue, result.NewValue, actualDecay);

        return actualDecay;
    }

    /// <inheritdoc />
    public OverflowResult TriggerOverflow(Character character)
    {
        _logger.LogDebug("TriggerOverflow called for {Name}", character.Name);

        if (character.Archetype != ArchetypeType.Mystic)
        {
            _logger.LogWarning("TriggerOverflow called for non-Mystic {Name}", character.Name);
            return OverflowResult.None;
        }

        if (character.ResonanceState == null ||
            character.ResonanceState.CurrentValue < ResonanceState.MaxResonance)
        {
            _logger.LogWarning(
                "TriggerOverflow called but resonance is not at max for {Name} (Current={Value})",
                character.Name, character.ResonanceState?.CurrentValue ?? 0);
            return OverflowResult.None;
        }

        // Mark overflow active
        character.ResonanceState.IsOverflowActive = true;
        character.ResonanceState.OverflowCount++;

        var overflowCount = character.ResonanceState.OverflowCount;
        var soulFractureRisk = overflowCount >= SoulFractureRiskThreshold;

        _logger.LogWarning(
            "AETHERIC OVERFLOW: {Name} resonance peaked! Count={Count}, SoulFractureRisk={Risk}",
            character.Name, overflowCount, soulFractureRisk);

        if (soulFractureRisk)
        {
            _logger.LogCritical(
                "SOUL FRACTURE RISK: {Name} has triggered {Count} overflows! Permanent damage imminent.",
                character.Name, overflowCount);
        }

        var result = new OverflowResult(
            PotencyBonus: 1.50m,
            DurationTurns: 1,
            DischargeAmount: OverflowDischargeAmount,
            SoulFractureRisk: soulFractureRisk,
            TotalOverflowCount: overflowCount);

        // Publish overflow event
        _eventBus.Publish(new OverflowTriggeredEvent(
            CharacterId: character.Id,
            CharacterName: character.Name,
            OverflowCount: overflowCount,
            SoulFractureRisk: soulFractureRisk));

        return result;
    }

    /// <inheritdoc />
    public int ProcessOverflowDischarge(Character character)
    {
        _logger.LogDebug("ProcessOverflowDischarge called for {Name}", character.Name);

        if (character.ResonanceState == null || !character.ResonanceState.IsOverflowActive)
        {
            _logger.LogTrace("No active overflow for {Name}", character.Name);
            return 0;
        }

        // Clear overflow state
        character.ResonanceState.IsOverflowActive = false;

        // Apply forced discharge
        var result = ModifyResonance(character, -OverflowDischargeAmount, "Overflow discharge");

        _logger.LogInformation(
            "Overflow discharged for {Name}: Reduced by {Amount} to {NewValue}",
            character.Name, OverflowDischargeAmount, result.NewValue);

        return result.ActualAmount;
    }

    /// <inheritdoc />
    public void Reset(Character character)
    {
        _logger.LogDebug("Reset called for {Name}", character.Name);

        if (character.ResonanceState == null)
        {
            _logger.LogTrace("No ResonanceState to reset for {Name}", character.Name);
            return;
        }

        var previousValue = character.ResonanceState.CurrentValue;
        character.ResonanceState.Reset();

        _logger.LogInformation(
            "Resonance reset for {Name}: {OldValue} -> 0",
            character.Name, previousValue);
    }

    /// <summary>
    /// Calculates the threshold for a given resonance value.
    /// </summary>
    private static ResonanceThreshold CalculateThreshold(int resonanceValue)
    {
        return resonanceValue switch
        {
            >= 100 => ResonanceThreshold.Overflow,
            >= 75 => ResonanceThreshold.Blazing,
            >= 50 => ResonanceThreshold.Bright,
            >= 25 => ResonanceThreshold.Steady,
            _ => ResonanceThreshold.Dim
        };
    }
}
```

### OverflowTriggeredEvent.cs

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Published when a Mystic's Aetheric Resonance reaches 100 (Overflow).
/// </summary>
public record OverflowTriggeredEvent(
    Guid CharacterId,
    string CharacterName,
    int OverflowCount,
    bool SoulFractureRisk)
{
    /// <summary>
    /// True if this is the first overflow for this character.
    /// </summary>
    public bool IsFirstOverflow => OverflowCount == 1;

    /// <summary>
    /// True if this overflow puts the character at risk of Soul Fracture (3+ overflows).
    /// </summary>
    public bool IsHighRisk => SoulFractureRisk;
}
```

---

## Logging Specification

### Log Levels by Operation

| Operation | Level | Trigger Condition |
|-----------|-------|-------------------|
| Service initialization | Debug | Always |
| Method entry | Debug | Always |
| Method exit | Debug | Always |
| Parameter validation | Trace | Always |
| State capture (before) | Trace | Always |
| State calculation | Trace | Always |
| Non-Mystic access | Warning | When non-Mystic calls resonance methods |
| Threshold change | Information | When threshold boundary crossed |
| Significant change | Debug | When change >= 15 |
| Overflow triggered | Warning | When resonance hits 100 |
| Soul Fracture risk | Critical | When overflow count >= 3 |
| Event published | Debug | Always on publish |
| Decay applied | Information | On rest decay |
| Reset | Information | When reset called |

### Structured Logging Properties

```csharp
// Standard properties for all resonance logs
_logger.LogInformation(
    "Resonance modified for {CharacterName}: {OldValue} -> {NewValue} ({Source})",
    character.Name,           // CharacterName
    previousValue,            // OldValue
    newValue,                 // NewValue
    source);                  // Source

// Threshold change properties
_logger.LogInformation(
    "Threshold changed for {CharacterName}: {OldThreshold} -> {NewThreshold}",
    character.Name,           // CharacterName
    previousThreshold,        // OldThreshold
    newThreshold);            // NewThreshold

// Overflow properties
_logger.LogWarning(
    "OVERFLOW: {CharacterName} reached {Value}, Count={OverflowCount}, Risk={SoulFractureRisk}",
    character.Name,           // CharacterName
    resonanceValue,           // Value
    overflowCount,            // OverflowCount
    soulFractureRisk);        // SoulFractureRisk
```

### Log Message Templates

```
// Entry/Exit
"ModifyResonance called: Character={Name}, Amount={Amount}, Source={Source}"
"ModifyResonance completed: {PrevValue} -> {NewValue}, ThresholdChanged={Changed}"

// Validation
"ModifyResonance called for non-Mystic character {Name} (Archetype={Archetype})"
"TriggerOverflow called but resonance is not at max for {Name} (Current={Value})"

// State Changes
"Previous state: Value={Value}, Threshold={Threshold}"
"New state: Value={Value}, Threshold={Threshold}, ActualChange={Actual}"
"Resonance threshold changed for {Name}: {OldThreshold} -> {NewThreshold} (Value: {Value})"

// Events
"Published ResonanceChangedEvent: {OldValue} -> {NewValue} ({Source})"
"OVERFLOW TRIGGERED: {Name} resonance reached {Value}!"
"SOUL FRACTURE RISK: {Name} has triggered {Count} overflows! Permanent damage imminent."

// Decay
"Resonance decayed for {Name}: {OldValue} -> {NewValue} (-{Decay})"
"Overflow discharged for {Name}: Reduced by {Amount} to {NewValue}"
"Resonance reset for {Name}: {OldValue} -> 0"

// Casting Mode
"Casting mode {Mode}: ResonanceGain={Res}, CastTime={Time}, FluxMod={Flux}"
"Potency modifier for {Name}: {Modifier}x at {Threshold} threshold"
```

---

## Unit Testing

### Test Class Structure

```csharp
namespace RuneAndRust.Tests.Services;

public class ResonanceServiceTests
{
    private readonly Mock<ILogger<ResonanceService>> _loggerMock;
    private readonly Mock<IEventBus> _eventBusMock;
    private readonly ResonanceService _sut;

    public ResonanceServiceTests()
    {
        _loggerMock = new Mock<ILogger<ResonanceService>>();
        _eventBusMock = new Mock<IEventBus>();
        _sut = new ResonanceService(_loggerMock.Object, _eventBusMock.Object);
    }

    private static Character CreateMystic(string name = "TestMystic", int resonance = 0)
    {
        return new Character
        {
            Id = Guid.NewGuid(),
            Name = name,
            Archetype = ArchetypeType.Mystic,
            ResonanceState = new ResonanceState { CurrentValue = resonance }
        };
    }

    private static Character CreateWarrior(string name = "TestWarrior")
    {
        return new Character
        {
            Id = Guid.NewGuid(),
            Name = name,
            Archetype = ArchetypeType.Warrior
        };
    }
}
```

### Test Categories

#### Category 1: ModifyResonance (8 tests)

```csharp
#region ModifyResonance Tests

[Fact]
public void ModifyResonance_WithPositiveAmount_IncreasesResonance()
{
    // Arrange
    var character = CreateMystic(resonance: 20);

    // Act
    var result = _sut.ModifyResonance(character, 15, "Spell cast");

    // Assert
    result.NewValue.Should().Be(35);
    result.ActualAmount.Should().Be(15);
    result.IsIncrease.Should().BeTrue();
    character.ResonanceState!.CurrentValue.Should().Be(35);
}

[Fact]
public void ModifyResonance_WithNegativeAmount_DecreasesResonance()
{
    // Arrange
    var character = CreateMystic(resonance: 50);

    // Act
    var result = _sut.ModifyResonance(character, -20, "Decay");

    // Assert
    result.NewValue.Should().Be(30);
    result.ActualAmount.Should().Be(-20);
    result.IsDecrease.Should().BeTrue();
}

[Fact]
public void ModifyResonance_ExceedingMax_ClampsTo100()
{
    // Arrange
    var character = CreateMystic(resonance: 90);

    // Act
    var result = _sut.ModifyResonance(character, 20, "Power surge");

    // Assert
    result.NewValue.Should().Be(100);
    result.ActualAmount.Should().Be(10);
    result.WasClamped.Should().BeTrue();
    result.OverflowTriggered.Should().BeTrue();
}

[Fact]
public void ModifyResonance_BelowMin_ClampsTo0()
{
    // Arrange
    var character = CreateMystic(resonance: 15);

    // Act
    var result = _sut.ModifyResonance(character, -30, "Purge");

    // Assert
    result.NewValue.Should().Be(0);
    result.ActualAmount.Should().Be(-15);
    result.WasClamped.Should().BeTrue();
    result.FullyDissipated.Should().BeTrue();
}

[Fact]
public void ModifyResonance_ForNonMystic_ReturnsNoChange()
{
    // Arrange
    var character = CreateWarrior();

    // Act
    var result = _sut.ModifyResonance(character, 10, "Test");

    // Assert
    result.Should().Be(ResonanceResult.NoChange("Test"));
}

[Fact]
public void ModifyResonance_WithNullResonanceState_InitializesState()
{
    // Arrange
    var character = CreateMystic();
    character.ResonanceState = null;

    // Act
    var result = _sut.ModifyResonance(character, 25, "First cast");

    // Assert
    character.ResonanceState.Should().NotBeNull();
    result.NewValue.Should().Be(25);
}

[Fact]
public void ModifyResonance_WithZeroAmount_ReturnsCurrentState()
{
    // Arrange
    var character = CreateMystic(resonance: 40);

    // Act
    var result = _sut.ModifyResonance(character, 0, "No change");

    // Assert
    result.NewValue.Should().Be(40);
    result.ActualAmount.Should().Be(0);
    result.ThresholdChanged.Should().BeFalse();
}

[Fact]
public void ModifyResonance_RecordsSource()
{
    // Arrange
    var character = CreateMystic(resonance: 30);
    var source = "Fireball cast";

    // Act
    var result = _sut.ModifyResonance(character, 10, source);

    // Assert
    result.Source.Should().Be(source);
}

#endregion
```

#### Category 2: Threshold Detection (6 tests)

```csharp
#region Threshold Detection Tests

[Theory]
[InlineData(0, ResonanceThreshold.Dim)]
[InlineData(24, ResonanceThreshold.Dim)]
[InlineData(25, ResonanceThreshold.Steady)]
[InlineData(49, ResonanceThreshold.Steady)]
[InlineData(50, ResonanceThreshold.Bright)]
[InlineData(74, ResonanceThreshold.Bright)]
[InlineData(75, ResonanceThreshold.Blazing)]
[InlineData(99, ResonanceThreshold.Blazing)]
[InlineData(100, ResonanceThreshold.Overflow)]
public void GetThreshold_ReturnsCorrectThreshold(int resonance, ResonanceThreshold expected)
{
    // Arrange
    var character = CreateMystic(resonance: resonance);

    // Act
    var result = _sut.GetThreshold(character);

    // Assert
    result.Should().Be(expected);
}

[Fact]
public void ModifyResonance_CrossingThresholdUp_SetsThresholdChanged()
{
    // Arrange
    var character = CreateMystic(resonance: 24); // Dim

    // Act
    var result = _sut.ModifyResonance(character, 1, "Test"); // -> 25 (Steady)

    // Assert
    result.ThresholdChanged.Should().BeTrue();
    result.PreviousThreshold.Should().Be(ResonanceThreshold.Dim);
    result.NewThreshold.Should().Be(ResonanceThreshold.Steady);
}

[Fact]
public void ModifyResonance_CrossingThresholdDown_SetsThresholdChanged()
{
    // Arrange
    var character = CreateMystic(resonance: 50); // Bright

    // Act
    var result = _sut.ModifyResonance(character, -1, "Test"); // -> 49 (Steady)

    // Assert
    result.ThresholdChanged.Should().BeTrue();
    result.PreviousThreshold.Should().Be(ResonanceThreshold.Bright);
    result.NewThreshold.Should().Be(ResonanceThreshold.Steady);
}

[Fact]
public void ModifyResonance_WithinSameThreshold_ThresholdUnchanged()
{
    // Arrange
    var character = CreateMystic(resonance: 30); // Steady

    // Act
    var result = _sut.ModifyResonance(character, 10, "Test"); // -> 40 (still Steady)

    // Assert
    result.ThresholdChanged.Should().BeFalse();
    result.PreviousThreshold.Should().Be(ResonanceThreshold.Steady);
    result.NewThreshold.Should().Be(ResonanceThreshold.Steady);
}

[Fact]
public void ModifyResonance_CrossingMultipleThresholds_ReportsCorrectThresholds()
{
    // Arrange
    var character = CreateMystic(resonance: 20); // Dim

    // Act
    var result = _sut.ModifyResonance(character, 60, "Power surge"); // -> 80 (Blazing)

    // Assert
    result.ThresholdChanged.Should().BeTrue();
    result.PreviousThreshold.Should().Be(ResonanceThreshold.Dim);
    result.NewThreshold.Should().Be(ResonanceThreshold.Blazing);
}

[Fact]
public void GetThreshold_ForNonMystic_ReturnsDim()
{
    // Arrange
    var character = CreateWarrior();

    // Act
    var result = _sut.GetThreshold(character);

    // Assert
    result.Should().Be(ResonanceThreshold.Dim);
}

#endregion
```

#### Category 3: Potency Calculation (6 tests)

```csharp
#region Potency Calculation Tests

[Theory]
[InlineData(0, 0.90)]
[InlineData(24, 0.90)]
[InlineData(25, 1.00)]
[InlineData(49, 1.00)]
[InlineData(50, 1.15)]
[InlineData(74, 1.15)]
[InlineData(75, 1.30)]
[InlineData(99, 1.30)]
[InlineData(100, 1.50)]
public void GetPotencyModifier_ReturnsCorrectMultiplier(int resonance, decimal expected)
{
    // Arrange
    var character = CreateMystic(resonance: resonance);

    // Act
    var result = _sut.GetPotencyModifier(character);

    // Assert
    result.Should().Be(expected);
}

[Fact]
public void GetPotencyModifier_ForNonMystic_Returns090()
{
    // Arrange
    var character = CreateWarrior();

    // Act
    var result = _sut.GetPotencyModifier(character);

    // Assert
    result.Should().Be(0.90m); // Dim threshold default
}

[Fact]
public void GetPotencyModifier_AtDimThreshold_AppliesPenalty()
{
    // Arrange
    var character = CreateMystic(resonance: 10);

    // Act
    var modifier = _sut.GetPotencyModifier(character);
    var baseDamage = 100;
    var modifiedDamage = (int)(baseDamage * modifier);

    // Assert
    modifier.Should().Be(0.90m);
    modifiedDamage.Should().Be(90);
}

[Fact]
public void GetPotencyModifier_AtOverflow_GrantsMaxBonus()
{
    // Arrange
    var character = CreateMystic(resonance: 100);

    // Act
    var modifier = _sut.GetPotencyModifier(character);
    var baseDamage = 100;
    var modifiedDamage = (int)(baseDamage * modifier);

    // Assert
    modifier.Should().Be(1.50m);
    modifiedDamage.Should().Be(150);
}

[Fact]
public void ResonanceState_PotencyModifier_MatchesServiceCalculation()
{
    // Arrange
    var character = CreateMystic(resonance: 60);

    // Act
    var serviceModifier = _sut.GetPotencyModifier(character);
    var stateModifier = character.ResonanceState!.PotencyModifier;

    // Assert
    serviceModifier.Should().Be(stateModifier);
    serviceModifier.Should().Be(1.15m);
}

#endregion
```

#### Category 4: Casting Mode Effects (8 tests)

```csharp
#region Casting Mode Tests

[Fact]
public void ApplyCastingModeModifiers_Quick_ReturnsCorrectValues()
{
    // Act
    var result = _sut.ApplyCastingModeModifiers(CastingMode.Quick);

    // Assert
    result.Mode.Should().Be(CastingMode.Quick);
    result.ResonanceGain.Should().Be(15);
    result.CastTimeModifier.Should().Be(0);
    result.FluxModifier.Should().Be(5);
    result.IsBonusAction.Should().BeTrue();
}

[Fact]
public void ApplyCastingModeModifiers_Standard_ReturnsCorrectValues()
{
    // Act
    var result = _sut.ApplyCastingModeModifiers(CastingMode.Standard);

    // Assert
    result.Mode.Should().Be(CastingMode.Standard);
    result.ResonanceGain.Should().Be(10);
    result.CastTimeModifier.Should().Be(1);
    result.FluxModifier.Should().Be(0);
    result.IsBonusAction.Should().BeFalse();
}

[Fact]
public void ApplyCastingModeModifiers_Channeled_ReturnsCorrectValues()
{
    // Act
    var result = _sut.ApplyCastingModeModifiers(CastingMode.Channeled);

    // Assert
    result.Mode.Should().Be(CastingMode.Channeled);
    result.ResonanceGain.Should().Be(5);
    result.CastTimeModifier.Should().Be(2);
    result.FluxModifier.Should().Be(-5);
    result.IsExtendedCast.Should().BeTrue();
}

[Fact]
public void ApplyCastingModeModifiers_Ritual_ReturnsCorrectValues()
{
    // Act
    var result = _sut.ApplyCastingModeModifiers(CastingMode.Ritual);

    // Assert
    result.Mode.Should().Be(CastingMode.Ritual);
    result.ResonanceGain.Should().Be(0);
    result.CastTimeModifier.Should().Be(-1);
    result.FluxModifier.Should().Be(-10);
    result.IsOutOfCombatOnly.Should().BeTrue();
}

[Fact]
public void CastingModeResult_Description_ReturnsCorrectText()
{
    // Arrange & Act
    var quick = _sut.ApplyCastingModeModifiers(CastingMode.Quick);
    var ritual = _sut.ApplyCastingModeModifiers(CastingMode.Ritual);

    // Assert
    quick.Description.Should().Contain("bonus action");
    ritual.Description.Should().Contain("out of combat");
}

[Fact]
public void ApplyCastingModeModifiers_Quick_AddsExtraFlux()
{
    // Act
    var result = _sut.ApplyCastingModeModifiers(CastingMode.Quick);

    // Assert
    result.FluxModifier.Should().BePositive();
    result.FluxModifier.Should().Be(5);
}

[Fact]
public void ApplyCastingModeModifiers_Channeled_ReducesFlux()
{
    // Act
    var result = _sut.ApplyCastingModeModifiers(CastingMode.Channeled);

    // Assert
    result.FluxModifier.Should().BeNegative();
    result.FluxModifier.Should().Be(-5);
}

[Fact]
public void ApplyCastingModeModifiers_Ritual_HasZeroResonanceGain()
{
    // Act
    var result = _sut.ApplyCastingModeModifiers(CastingMode.Ritual);

    // Assert
    result.ResonanceGain.Should().Be(0);
}

#endregion
```

#### Category 5: Overflow & Decay (6 tests)

```csharp
#region Overflow & Decay Tests

[Fact]
public void TriggerOverflow_AtMax_ReturnsOverflowResult()
{
    // Arrange
    var character = CreateMystic(resonance: 100);

    // Act
    var result = _sut.TriggerOverflow(character);

    // Assert
    result.PotencyBonus.Should().Be(1.50m);
    result.DurationTurns.Should().Be(1);
    result.DischargeAmount.Should().Be(50);
    character.ResonanceState!.IsOverflowActive.Should().BeTrue();
    character.ResonanceState.OverflowCount.Should().Be(1);
}

[Fact]
public void TriggerOverflow_BelowMax_ReturnsNone()
{
    // Arrange
    var character = CreateMystic(resonance: 99);

    // Act
    var result = _sut.TriggerOverflow(character);

    // Assert
    result.Should().Be(OverflowResult.None);
}

[Fact]
public void TriggerOverflow_ThirdTime_SetsSoulFractureRisk()
{
    // Arrange
    var character = CreateMystic(resonance: 100);
    character.ResonanceState!.OverflowCount = 2; // Already triggered twice

    // Act
    var result = _sut.TriggerOverflow(character);

    // Assert
    result.SoulFractureRisk.Should().BeTrue();
    result.TotalOverflowCount.Should().Be(3);
}

[Fact]
public void ProcessOverflowDischarge_ReducesResonanceBy50()
{
    // Arrange
    var character = CreateMystic(resonance: 100);
    character.ResonanceState!.IsOverflowActive = true;

    // Act
    var discharged = _sut.ProcessOverflowDischarge(character);

    // Assert
    discharged.Should().Be(-50); // Negative because it's a reduction
    character.ResonanceState.CurrentValue.Should().Be(50);
    character.ResonanceState.IsOverflowActive.Should().BeFalse();
}

[Fact]
public void ProcessResonanceDecay_ReducesByDecayRate()
{
    // Arrange
    var character = CreateMystic(resonance: 50);

    // Act
    var decayed = _sut.ProcessResonanceDecay(character);

    // Assert
    decayed.Should().Be(10); // Default decay rate
    character.ResonanceState!.CurrentValue.Should().Be(40);
}

[Fact]
public void ProcessResonanceDecay_AtLowResonance_DecaysToZero()
{
    // Arrange
    var character = CreateMystic(resonance: 5);

    // Act
    var decayed = _sut.ProcessResonanceDecay(character);

    // Assert
    decayed.Should().Be(5); // Can only decay what's there
    character.ResonanceState!.CurrentValue.Should().Be(0);
}

#endregion
```

#### Category 6: Event Publishing (4 tests)

```csharp
#region Event Publishing Tests

[Fact]
public void ModifyResonance_OnThresholdChange_PublishesEvent()
{
    // Arrange
    var character = CreateMystic(resonance: 24);

    // Act
    _sut.ModifyResonance(character, 1, "Test");

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.Is<ResonanceChangedEvent>(evt =>
            evt.ThresholdChanged == true &&
            evt.OldThreshold == ResonanceThreshold.Dim &&
            evt.NewThreshold == ResonanceThreshold.Steady)),
        Times.Once);
}

[Fact]
public void ModifyResonance_OnLargeChange_PublishesEvent()
{
    // Arrange
    var character = CreateMystic(resonance: 30);

    // Act
    _sut.ModifyResonance(character, 15, "Power surge"); // >= 15 is significant

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.IsAny<ResonanceChangedEvent>()),
        Times.Once);
}

[Fact]
public void ModifyResonance_OnSmallChangeWithinThreshold_DoesNotPublishEvent()
{
    // Arrange
    var character = CreateMystic(resonance: 30);

    // Act
    _sut.ModifyResonance(character, 5, "Small change"); // < 15, within threshold

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.IsAny<ResonanceChangedEvent>()),
        Times.Never);
}

[Fact]
public void TriggerOverflow_PublishesOverflowEvent()
{
    // Arrange
    var character = CreateMystic(resonance: 100);

    // Act
    _sut.TriggerOverflow(character);

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.Is<OverflowTriggeredEvent>(evt =>
            evt.CharacterId == character.Id &&
            evt.OverflowCount == 1)),
        Times.Once);
}

#endregion
```

#### Category 7: Integration Tests (4 tests)

```csharp
#region Integration Tests

[Fact]
public void FullCastingCycle_Quick_AppliesCorrectResonance()
{
    // Arrange
    var character = CreateMystic(resonance: 20);
    var modeResult = _sut.ApplyCastingModeModifiers(CastingMode.Quick);

    // Act
    var resonanceResult = _sut.ModifyResonance(
        character,
        modeResult.ResonanceGain,
        "Quick cast: Fireball");

    // Assert
    resonanceResult.NewValue.Should().Be(35); // 20 + 15
    resonanceResult.PreviousThreshold.Should().Be(ResonanceThreshold.Dim);
    resonanceResult.NewThreshold.Should().Be(ResonanceThreshold.Steady);
}

[Fact]
public void FullCastingCycle_Channeled_AppliesReducedResonance()
{
    // Arrange
    var character = CreateMystic(resonance: 40);
    var modeResult = _sut.ApplyCastingModeModifiers(CastingMode.Channeled);

    // Act
    var resonanceResult = _sut.ModifyResonance(
        character,
        modeResult.ResonanceGain,
        "Channeled cast: Heal");

    // Assert
    resonanceResult.NewValue.Should().Be(45); // 40 + 5
    resonanceResult.ThresholdChanged.Should().BeFalse();
}

[Fact]
public void PotencyCalculation_IntegratesWithResonance()
{
    // Arrange
    var character = CreateMystic(resonance: 60); // Bright threshold
    var baseDamage = 100;

    // Act
    var modifier = _sut.GetPotencyModifier(character);
    var finalDamage = (int)(baseDamage * modifier);

    // Assert
    modifier.Should().Be(1.15m);
    finalDamage.Should().Be(115);
}

[Fact]
public void OverflowCycle_TriggerAndDischarge_CompletesCorrectly()
{
    // Arrange
    var character = CreateMystic(resonance: 95);

    // Act - Push to overflow
    _sut.ModifyResonance(character, 5, "Final cast");
    var overflowResult = _sut.TriggerOverflow(character);

    // Assert overflow state
    overflowResult.PotencyBonus.Should().Be(1.50m);
    character.ResonanceState!.IsOverflowActive.Should().BeTrue();

    // Act - Discharge
    var discharged = _sut.ProcessOverflowDischarge(character);

    // Assert post-discharge
    character.ResonanceState.CurrentValue.Should().Be(50);
    character.ResonanceState.IsOverflowActive.Should().BeFalse();
}

#endregion
```

### Test Summary

| Category | Test Count | Coverage Focus |
|----------|------------|----------------|
| ModifyResonance | 8 | Core modification logic, clamping, non-Mystic handling |
| Threshold Detection | 6 | Boundary conditions, all 5 thresholds |
| Potency Calculation | 6 | Multiplier accuracy, damage integration |
| Casting Mode Effects | 8 | All 4 modes, properties, flux modifiers |
| Overflow & Decay | 6 | Overflow trigger, Soul Fracture risk, decay |
| Event Publishing | 4 | Conditional publishing, event properties |
| Integration | 4 | End-to-end casting cycles |

**Total: 42 tests** (exceeds the estimated 32)

---

## Integration Points

### MagicService Integration

```csharp
// In MagicService.CastSpell()
public SpellCastResult CastSpell(Character caster, Spell spell, CastingMode mode, IEntity? target)
{
    // ... existing validation ...

    // Get casting mode modifiers
    var modeResult = _resonanceService.ApplyCastingModeModifiers(mode);

    // Apply resonance gain from casting
    var resonanceResult = _resonanceService.ModifyResonance(
        caster,
        modeResult.ResonanceGain,
        $"{mode} cast: {spell.Name}");

    // Get potency modifier
    var potencyModifier = _resonanceService.GetPotencyModifier(caster);

    // Apply modified flux (base + mode modifier)
    var totalFluxGain = spell.FluxCost + modeResult.FluxModifier;
    _aetherService.ModifyFlux(totalFluxGain, $"Cast: {spell.Name}");

    // Calculate modified damage/healing
    var baseEffect = spell.BasePower;
    var modifiedEffect = (int)(baseEffect * potencyModifier);

    // Check for overflow trigger
    if (resonanceResult.OverflowTriggered)
    {
        var overflowResult = _resonanceService.TriggerOverflow(caster);
        // Handle overflow state...
    }

    // ... continue with spell execution ...
}
```

### RestService Integration

```csharp
// In RestService.ProcessRest()
public RestResult ProcessRest(Character character, RestType restType)
{
    // ... existing rest processing ...

    // Process resonance decay for Mystics
    var resonanceDecayed = _resonanceService.ProcessResonanceDecay(character);

    if (resonanceDecayed > 0)
    {
        _logger.LogInformation(
            "Resonance decayed during rest for {Name}: -{Amount}",
            character.Name, resonanceDecayed);
    }

    // ... continue with rest completion ...
}
```

### Character Model Extension

```csharp
// Add to Character.cs
public class Character
{
    // ... existing properties ...

    /// <summary>
    /// Resonance state for Mystic characters. Null for non-Mystics.
    /// </summary>
    public ResonanceState? ResonanceState { get; set; }

    /// <summary>
    /// Current resonance value (0 for non-Mystics).
    /// </summary>
    public int Resonance => ResonanceState?.CurrentValue ?? 0;
}
```

### DI Registration

```csharp
// In Program.cs or ServiceRegistration.cs
services.AddScoped<IResonanceService, ResonanceService>();
```

---

## Domain 4 Compliance

### Forbidden Terms (DO NOT USE)

| Forbidden | Compliant Alternative |
|-----------|----------------------|
| "15% increase" | "Noticeable amplification" |
| "90% potency" | "Diminished potency" |
| "100 resonance" | "Overwhelming attunement" |
| "50 points of discharge" | "Violent release of accumulated power" |
| "1.5x multiplier" | "Greatly enhanced" |

### Compliant Narrative Examples

**Overflow Event (TUI Display):**
```
❌ "Your resonance has reached 100. Next spell deals 150% damage."
✅ "The Aether screams through your veins. Your next incantation will
    carry terrible power—but the spirits demand balance."
```

**Threshold Change (Combat Log):**
```
❌ "Resonance increased from 49 to 51. Potency modifier now 1.15."
✅ "A shimmer surrounds you as your attunement to the Weave deepens.
    Your spells grow more potent, but the spirits watch closer now."
```

**Decay Notification (Rest Screen):**
```
❌ "Resonance decayed by 10 points during rest. Current: 40."
✅ "As you rest, the echoes of your castings fade from your soul.
    The Aether's grip loosens, though its memory lingers."
```

### AAM Voice Guidelines

- **Observer Perspective**: The TUI narrates as the Jötun-Reader observing effects
- **Epistemic Uncertainty**: Use "appears to," "seems to," "as if"
- **Qualitative Descriptions**: Use "faint," "intense," "overwhelming" instead of numbers
- **Archetypal Language**: Reference "the Weave," "spirits," "echoes," "attunement"

---

## Changelog Template

```markdown
## [v0.4.4a] - YYYY-MM-DD

### Added
- **ResonanceThreshold enum** (`RuneAndRust.Core/Enums/ResonanceThreshold.cs`)
  - Defines 5 attunement levels: Dim, Steady, Bright, Blazing, Overflow
  - Maps to potency modifiers: 0.90x → 1.50x

- **CastingMode enum** (`RuneAndRust.Core/Enums/CastingMode.cs`)
  - Quick: Bonus action, +15 resonance, +5 flux
  - Standard: 1 turn, +10 resonance
  - Channeled: 2 turns, +5 resonance, -5 flux
  - Ritual: Out of combat, +0 resonance, -10 flux

- **ResonanceState model** (`RuneAndRust.Core/Models/Magic/ResonanceState.cs`)
  - Tracks personal Flux attunement (0-100)
  - Computed properties: Threshold, PotencyModifier, IsHighRisk
  - Overflow tracking: OverflowCount, IsOverflowActive

- **ResonanceResult record** (`RuneAndRust.Core/Models/Magic/ResonanceResult.cs`)
  - Returns before/after values and threshold changes
  - Properties: ThresholdChanged, OverflowTriggered, WasClamped

- **CastingModeResult record** (`RuneAndRust.Core/Models/Magic/CastingModeResult.cs`)
  - Encapsulates all casting mode modifiers
  - Properties: ResonanceGain, CastTimeModifier, FluxModifier

- **OverflowResult record** (`RuneAndRust.Core/Models/Magic/OverflowResult.cs`)
  - Captures overflow event details
  - Properties: PotencyBonus (1.50m), SoulFractureRisk

- **ResonanceChangedEvent** (`RuneAndRust.Core/Events/ResonanceChangedEvent.cs`)
  - Published on threshold crossing or significant change (±15)
  - Includes before/after thresholds for UI/audio triggers

- **OverflowTriggeredEvent** (`RuneAndRust.Core/Events/OverflowTriggeredEvent.cs`)
  - Published when resonance reaches 100
  - Tracks overflow count for Soul Fracture risk calculation

- **IResonanceService interface** (`RuneAndRust.Core/Interfaces/IResonanceService.cs`)
  - Contract for resonance manipulation
  - Methods: ModifyResonance, GetPotencyModifier, ApplyCastingModeModifiers, etc.

- **ResonanceService implementation** (`RuneAndRust.Engine/Services/ResonanceService.cs`)
  - Full service with comprehensive Serilog logging
  - Handles non-Mystic validation, clamping, event publishing
  - Implements overflow trigger and discharge mechanics

### Changed
- **Character model** - Added `ResonanceState` property for Mystic characters
- **MagicService** - Integrated `GetPotencyModifier()` into spell resolution
- **RestService** - Added `ProcessResonanceDecay()` call during rest

### Tests
- Added `ResonanceServiceTests.cs` with 42 unit tests
  - ModifyResonance: 8 tests
  - Threshold Detection: 6 tests
  - Potency Calculation: 6 tests
  - Casting Mode Effects: 8 tests
  - Overflow & Decay: 6 tests
  - Event Publishing: 4 tests
  - Integration: 4 tests
- Code coverage: 95%+ for ResonanceService

### Technical Notes
- Resonance is per-character (unlike environmental Flux)
- Decay occurs only during rest, not per-combat-round
- Overflow grants +50% potency for 1 turn, then forces 50-point discharge
- Soul Fracture risk triggers at 3+ overflows (handled in v0.4.4d)

### Dependencies
- Requires: v0.4.3a (AetherService, FluxState)
- Required by: v0.4.4b (GaldrService uses resonance), v0.4.4d (ParadoxService)
```

---

## Summary

v0.4.4a "The Attunement" establishes the **Aetheric Resonance** system—the Mystic's personal connection to ambient magical energy. This system:

1. **Tracks personal attunement** (0-100) separate from environmental Flux
2. **Modifies spell potency** based on resonance threshold (-10% to +50%)
3. **Provides casting mode flexibility** (Quick/Standard/Channeled/Ritual)
4. **Introduces Overflow mechanics** with Soul Fracture risk at 3+ overflows
5. **Integrates with MagicService** for potency calculation during spell resolution
6. **Decays during rest** rather than per-round (slower than Flux)

**Estimated Implementation Time:** 2-3 development sessions
**Test Coverage Target:** 80%+ (42 tests planned)
**Dependencies:** v0.4.3a (AetherService), v0.4.3c (MagicService)
