# Design Specification: v0.20.7b - Veiðimaðr Tier 2 Abilities

**Version:** v0.20.7b
**Status:** Design Phase
**Last Updated:** 2026-01-28
**Target Tests:** ~8 unit and integration tests
**Specialization:** Veiðimaðr (Hunter)
**Path Type:** Coherent (NO Corruption Risk)
**Archetype:** Skirmisher

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Tier 2 Overview](#2-tier-2-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Domain Model Specifications](#4-domain-model-specifications)
5. [Hunter's Eye Ability Specification](#5-hunters-eye-ability-specification)
6. [Trap Mastery Ability Specification](#6-trap-mastery-ability-specification)
7. [Predator's Patience Ability Specification](#7-predators-patience-ability-specification)
8. [User Stories](#8-user-stories)
9. [Application Service Layer](#9-application-service-layer)
10. [Configuration Specifications](#10-configuration-specifications)
11. [Code Examples & Implementation](#11-code-examples--implementation)
12. [State Machine Diagrams](#12-state-machine-diagrams)
13. [Interaction Matrix](#13-interaction-matrix)
14. [Logging Specifications](#14-logging-specifications)
15. [Unit Testing Requirements](#15-unit-testing-requirements)
16. [Deliverable Checklist](#16-deliverable-checklist)
17. [Acceptance Criteria](#17-acceptance-criteria)
18. [Dependencies & Prerequisites](#18-dependencies--prerequisites)
19. [Design Decisions & Rationale](#19-design-decisions--rationale)

---

## 1. Executive Summary

Version 0.20.7b introduces **Tier 2 Abilities** for the Veiðimaðr specialization, expanding tactical options for skilled hunters. This phase focuses on:

- **Hunter's Eye:** Ignore partial cover, gaining tactical flexibility against entrenched foes
- **Trap Mastery:** Place sophisticated traps with 1d8+immobilize and detect enemy traps
- **Predator's Patience:** Stance that grants +3 to hit when stationary (stance replacement with bonuses)

### Key Deliverables

| Category | Count | Details |
|----------|-------|---------|
| **Domain Value Objects** | 4 | HuntersEyeResult, TrapInstance, TrapMasteryResult, PredatorsPatienceState |
| **Domain Enums** | 3 | TrapType, TrapStatus, StanceType |
| **Application Services** | 2 | TrapMasteryService, PredatorsPatienceService (enhancement to existing) |
| **Ability Implementations** | 3 | Hunter's Eye, Trap Mastery, Predator's Patience |
| **Configuration Files** | 2 | abilities.json (Tier 2 entries), trap-templates.json |
| **Unit Tests** | ~8 | Comprehensive coverage of Tier 2 mechanics |

### Specialization Tier Progression

| Tier | Abilities | Focus | Design Goal |
|------|-----------|-------|------------|
| **T1** | Mark Quarry, Keen Senses, Read the Signs | Target tracking & perception | Foundation |
| **T2** | Hunter's Eye, Trap Mastery, Predator's Patience | Positioning & denial tactics | Tactical depth |
| **T3** | Apex Predator, Crippling Shot | Marked target exploitation | Capstone payoff |

---

## 2. Tier 2 Overview

### 2.1 Thematic Integration

Tier 2 represents the evolved hunter who understands:
- **Sight Lines:** Cover is no obstacle when you know how to shoot around it
- **Environmental Mastery:** Ability to shape the battlefield with prepared traps
- **Patience as Weapon:** Standing still becomes a combat advantage

### 2.2 Action Economy at Tier 2

| Ability | Type | AP | Cost | Duration | Key Mechanic |
|---------|------|----|----|----------|--------------|
| Hunter's Eye | Passive | — | — | Permanent | Ignore cover, see through walls |
| Trap Mastery | Active | 2 AP | 1 Resource | Instant | 1d8+immobilize; detect enemy traps |
| Predator's Patience | Stance | 1 AP | 0 | Stance/turn | +3 to hit while stationary |

### 2.3 Tier 2 Design Principles

1. **Cover Negation:** Hunter's Eye eliminates tactical disadvantage
2. **Environment Control:** Traps force enemies into chosen positioning
3. **Reward Patience:** Predator's Patience encourages tactical waiting over spam
4. **Stack with Tier 1:** All Tier 2 abilities work with Quarry Marks (+2 → potential +5 to hit)

---

## 3. Architecture Diagrams

### 3.1 Tier 2 Domain Extensions

```
┌─────────────────────────────────────────────────────────────┐
│        v0.20.7b - Domain Model Extensions                   │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────┐  ┌──────────────────────────────┐  │
│  │ HuntersEyeResult    │  │ TrapInstance                 │  │
│  │ (Value Object)      │  │ (Value Object)               │  │
│  ├─────────────────────┤  ├──────────────────────────────┤  │
│  │ + HunterId: Guid    │  │ + TrapId: Guid               │  │
│  │ + TargetId: Guid    │  │ + PlacedBy: Guid             │  │
│  │ + OriginalCover     │  │ + Location: (X, Y)           │  │
│  │ + CoverIgnored: bool│  │ + Type: TrapType             │  │
│  │ + ActualBonus: int  │  │ + Status: TrapStatus         │  │
│  │ + Distance: int     │  │ + DamageRoll: 1d8            │  │
│  │ + Resolved: bool    │  │ + ImmobilizeTurns: int       │  │
│  ├─────────────────────┤  │ + DetectionDC: int           │  │
│  │ + GetDescription()  │  │ + TriggeredAt: DateTime?     │  │
│  │ + WasCoverIgnored() │  │ + TriggeringTarget: Guid?    │  │
│  └─────────────────────┘  ├──────────────────────────────┤  │
│                           │ + Activate()                 │  │
│                           │ + Trigger()                  │  │
│                           │ + GetDescription()           │  │
│                           │ + GetDamageText()            │  │
│                           └──────────────────────────────┘  │
│                                                               │
│  ┌─────────────────────┐  ┌──────────────────────────────┐  │
│  │TrapMasteryResult    │  │PredatorsPatienceState        │  │
│  │(Value Object)       │  │(Value Object)                │  │
│  ├─────────────────────┤  ├──────────────────────────────┤  │
│  │ + PlacedTrap: Trap  │  │ + HunterId: Guid             │  │
│  │ + Location: (X, Y)  │  │ + IsActive: bool             │  │
│  │ + Success: bool     │  │ + TurnsStanceActive: int     │  │
│  │ + DetectedTraps: int│  │ + HitBonus: int (+3)         │  │
│  │ + EnemyTrapsFound   │  │ + MovementCost: int          │  │
│  │ + Message: string   │  │ + LastMovedAt: DateTime?     │  │
│  ├─────────────────────┤  │ + BreaksOn: enum             │  │
│  │ + GetDescription()  │  ├──────────────────────────────┤  │
│  │ + GetTrapCount()    │  │ + DeactivateOnMovement()     │  │
│  │ + WasSuccessful()   │  │ + GetActiveBonus()           │  │
│  └─────────────────────┘  │ + GetDescription()           │  │
│                           └──────────────────────────────┘  │
│                                                               │
│  ┌───────────────────────────┬────────────────────────────┐  │
│  │ TrapType (Enum)           │ TrapStatus (Enum)          │  │
│  ├───────────────────────────┼────────────────────────────┤  │
│  │ - Spike                   │ - Armed                    │  │
│  │ - Net                     │ - Triggered                │  │
│  │ - PitFall                 │ - Disarmed                 │  │
│  │ - Deadfall                │ - Destroyed                │  │
│  │ - Snare                   │                            │  │
│  └───────────────────────────┴────────────────────────────┘  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 Service Layer Architecture (Tier 2 Expansion)

```
┌────────────────────────────────────────────────────────────┐
│      v0.20.7b - Service Layer Expansion                    │
├────────────────────────────────────────────────────────────┤
│                                                              │
│  IVeiðimaðrAbilityService (v0.20.7a)                       │
│  ├─ ExecuteMarkQuarry()                                    │
│  ├─ ApplyKeenSenses()                                      │
│  ├─ ExecuteReadTheSigns()                                  │
│  └─ [+ NEW v0.20.7b METHODS:]                              │
│     ├─ ExecuteHuntersEye()                                 │
│     ├─ ExecuteTrapMastery()                                │
│     └─ TogglePredatorPatience()                            │
│                                                              │
│  ┌──────────────────────────────┐                           │
│  │ ITrapMasteryService (NEW)    │                           │
│  ├──────────────────────────────┤                           │
│  │ + PlaceTrap()                │                           │
│  │ + DetectNearbyTraps()         │                           │
│  │ + TriggerTrap()               │                           │
│  │ + DisarmTrap()                │                           │
│  │ + GetPlacedTrapsFor()         │                           │
│  │ + GetTrapAt()                 │                           │
│  │ + ResolveEnemyTrapDetection() │                           │
│  └──────────────────────────────┘                           │
│                                                              │
│  ┌──────────────────────────────┐                           │
│  │ IPredatorsPatienceService    │                           │
│  │ (Enhancement)                │                           │
│  ├──────────────────────────────┤                           │
│  │ + ActivateStance()            │                           │
│  │ + DeactivateStance()          │                           │
│  │ + IsStanceActive()            │                           │
│  │ + GetHitBonus()               │                           │
│  │ + CheckMovement()             │                           │
│  │ + ApplyBreakConditions()      │                           │
│  └──────────────────────────────┘                           │
│                                                              │
└────────────────────────────────────────────────────────────┘
```

### 3.3 Predator's Patience Stance Flow

```
                         ┌──────────────────┐
                         │ Stance Available │
                         │ (Not in stance)  │
                         └────────┬─────────┘
                                  │
                                  │ Toggle Predator's Patience (1 AP)
                                  ▼
┌─────────────────────────────────────────────────────────────┐
│                    STANCE ACTIVE                            │
│  +3 to hit / Movement breaks stance / Lasts 1 turn max      │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ Each Turn:                                             │ │
│  │ • Check for movement (breaks stance)                  │ │
│  │ • Apply +3 bonus to attacks                           │ │
│  │ • Can attack, interact, but NOT move                  │ │
│  │ • Mark interaction: Targets get +3 bonus (stacks)     │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                               │
└─────────────────┬──────────────────────────┬────────────────┘
                  │                          │
        ┌─────────▼─────────┐      ┌────────▼─────────┐
        │ Hunter moves      │      │ Turn ends        │
        │ OR takes action   │      │ (not moving)     │
        │ with movement     │      │                  │
        └────────┬──────────┘      │                  │
                 │                 │                  │
        ┌────────▼──────────┐      │                  │
        │ STANCE BROKEN     │      │                  │
        │ Lose +3 bonus     │      │                  │
        │ Free to move next │      │                  │
        └────────┬──────────┘      │                  │
                 │                 │                  │
                 └────────┬────────┘                  │
                          │                          │
                          ▼                          ▼
                  ┌────────────────────────────────────┐
                  │ Stance Inactive                    │
                  │ (Can re-activate next turn)        │
                  └────────────────────────────────────┘
```

---

## 4. Domain Model Specifications

### 4.1 HuntersEyeResult (Value Object)

**Purpose:** Encapsulates the result of using Hunter's Eye on an attack roll.

**Properties:**

```csharp
/// <summary>
/// Result of Hunter's Eye application to a ranged attack.
/// </summary>
public sealed record HuntersEyeResult
{
    /// <summary>ID of the hunter using the ability.</summary>
    public Guid HunterId { get; init; }

    /// <summary>ID of the target being attacked.</summary>
    public Guid TargetId { get; init; }

    /// <summary>Target's name (for UI).</summary>
    public string TargetName { get; init; } = string.Empty;

    /// <summary>The cover originally blocking shot.</summary>
    public string OriginalCover { get; init; } = string.Empty;

    /// <summary>Whether the cover was successfully ignored.</summary>
    public bool CoverIgnored { get; init; }

    /// <summary>Actual hit bonus applied (from ignoring cover penalty).</summary>
    public int ActualBonus { get; init; }

    /// <summary>Distance to target (in spaces).</summary>
    public int Distance { get; init; }

    /// <summary>Whether this result has been used to modify an attack.</summary>
    public bool Resolved { get; init; }

    /// <summary>When the result was generated.</summary>
    public DateTime GeneratedAt { get; init; } = DateTime.UtcNow;
}
```

**Methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| GetDescription | `string` | Narrative description (e.g., "You see through the doorway") |
| WasCoverIgnored | `bool` | True if cover was successfully ignored |

### 4.2 TrapInstance (Value Object)

**Purpose:** Represents a single trap placed in the environment.

**Properties:**

```csharp
/// <summary>
/// Represents a single trap instance placed by a hunter.
/// </summary>
public sealed record TrapInstance
{
    /// <summary>Unique ID for this trap.</summary>
    public Guid TrapId { get; init; } = Guid.NewGuid();

    /// <summary>ID of hunter who placed the trap.</summary>
    public Guid PlacedBy { get; init; }

    /// <summary>X coordinate on map.</summary>
    public int X { get; init; }

    /// <summary>Y coordinate on map.</summary>
    public int Y { get; init; }

    /// <summary>Type of trap (Spike, Net, PitFall, Deadfall, Snare).</summary>
    public TrapType Type { get; init; }

    /// <summary>Current status (Armed, Triggered, Disarmed, Destroyed).</summary>
    public TrapStatus Status { get; private set; } = TrapStatus.Armed;

    /// <summary>Damage dice (1d8 for traps).</summary>
    public string DamageRoll { get; init; } = "1d8";

    /// <summary>Number of turns victim is immobilized (depends on trap type).</summary>
    public int ImmobilizeTurns { get; init; } = 1;

    /// <summary>DC to detect or disarm the trap.</summary>
    public int DetectionDC { get; init; } = 13;

    /// <summary>When trap was triggered; null if not yet triggered.</summary>
    public DateTime? TriggeredAt { get; private set; }

    /// <summary>ID of target that triggered trap; null if not triggered.</summary>
    public Guid? TriggeringTarget { get; private set; }

    /// <summary>Turn count since trap was placed (for duration tracking).</summary>
    public int TurnsPlaced { get; private set; }
}
```

**Methods:**

| Method | Signature | Returns | Purpose |
|--------|-----------|---------|---------|
| Activate | `()` | `void` | Sets trap to Armed status |
| Trigger | `(Guid target, DateTime time)` | `void` | Marks trap as triggered |
| Disarm | `()` | `void` | Safely disarms trap |
| Destroy | `()` | `void` | Trap destroyed (falls apart, can't rearm) |
| GetDescription | `()` | `string` | Narrative description |
| GetDamageText | `()` | `string` | "1d8 damage + 1-turn immobilize" |

**Invariants:**

- Once triggered, status cannot change to Armed
- Once destroyed, trap cannot be triggered
- X, Y must be valid map coordinates

### 4.3 TrapMasteryResult (Value Object)

**Purpose:** Result of Trap Mastery ability execution (placing or detecting traps).

**Properties:**

```csharp
/// <summary>
/// Result of Trap Mastery ability, covering trap placement or enemy trap detection.
/// </summary>
public sealed record TrapMasteryResult
{
    /// <summary>Enum for result type.</summary>
    public enum ResultType { TrapPlaced, TrapsDetected }

    /// <summary>Type of result (placement or detection).</summary>
    public ResultType Type { get; init; }

    /// <summary>Trap that was placed; null if detection result.</summary>
    public TrapInstance? PlacedTrap { get; init; }

    /// <summary>Location where trap was placed.</summary>
    public (int X, int Y) Location { get; init; }

    /// <summary>Whether the action succeeded.</summary>
    public bool Success { get; init; }

    /// <summary>Number of enemy traps detected nearby (within 5 spaces).</summary>
    public int DetectedTrapsCount { get; init; }

    /// <summary>Details of detected enemy traps.</summary>
    public IReadOnlyList<(TrapType Type, int Distance)> DetectedTraps { get; init; } = new List<(TrapType, int)>();

    /// <summary>Human-readable message for player.</summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>When the action was executed.</summary>
    public DateTime ExecutedAt { get; init; } = DateTime.UtcNow;
}
```

**Methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| GetDescription | `string` | Narrative result message |
| GetTrapCount | `int` | Total traps found (placement or detection) |
| WasSuccessful | `bool` | True if action succeeded |

### 4.4 PredatorsPatienceState (Value Object)

**Purpose:** Tracks the state of the Predator's Patience stance.

**Properties:**

```csharp
/// <summary>
/// Tracks state of Predator's Patience stance.
/// </summary>
public sealed record PredatorsPatienceState
{
    /// <summary>Reason why stance breaks.</summary>
    public enum BreakReason
    {
        MovementDetected,
        TurnEnded,
        StanceToggled,
        Incapacitated,
        Displaced
    }

    /// <summary>ID of hunter in stance.</summary>
    public Guid HunterId { get; init; }

    /// <summary>Whether stance is currently active.</summary>
    public bool IsActive { get; private set; }

    /// <summary>Number of turns stance has been active.</summary>
    public int TurnsActive { get; private set; }

    /// <summary>Hit bonus provided by stance (+3).</summary>
    public int HitBonus { get; init; } = 3;

    /// <summary>Movement cost check this turn (has hunter moved?).</summary>
    public bool HasMovedThisTurn { get; private set; }

    /// <summary>When stance was activated.</summary>
    public DateTime? ActivatedAt { get; private set; }

    /// <summary>When stance was last checked for break conditions.</summary>
    public DateTime? LastCheckedAt { get; private set; }

    /// <summary>If stance broke, the reason why.</summary>
    public BreakReason? BrokeReason { get; private set; }
}
```

**Methods:**

| Method | Signature | Returns | Purpose |
|--------|-----------|---------|---------|
| Activate | `()` | `void` | Activates stance |
| Deactivate | `()` | `void` | Deactivates stance |
| CheckMovement | `(bool hasMoved)` | `bool` | Returns true if stance should break |
| ApplyBreakCondition | `(BreakReason reason)` | `void` | Applies break condition |
| GetActiveBonus | `()` | `int` | Returns +3 if active, 0 if inactive |
| GetDescription | `()` | `string` | Status description |

---

## 5. Hunter's Eye Ability Specification

### 5.1 Mechanics

**Ability ID:** `VeiðimaðrAbilityId.HuntersEye`

**Type:** Passive (always active ability)

**Action Economy:**
- **Cost:** 0 AP (passive)
- **Range:** Self
- **Duration:** Permanent
- **Effect Type:** Passive modifier

**Mechanical Effects:**

```
Effect: Ignore partial cover restrictions
• Cover Negation: Any attack ignores partial cover penalties
• Cover Types Negated:
  ✓ Half cover: Normally -2 to hit; now 0 penalty
  ✓ Three-quarters cover: Normally -5 to hit; now 0 penalty
• Full Cover: CANNOT be bypassed (4 walls, 100% obstruction)
• Line of Sight: Must still have visual line to target

Interaction with Terrain:
• Trees/Bushes (partial cover): Ignored by Hunter's Eye
• Doors/Walls (half cover): Ignored by Hunter's Eye
• Stone Walls (three-quarters): Ignored by Hunter's Eye
• Underground/Sealed room (full cover): Cannot shoot through

Stack Behavior:
• Works with Predator's Patience (+3 stance bonus)
• Works with Quarry Mark (+2 hit bonus)
• Works with Keen Senses (+1 perception bonus) for detection
```

**Application Rules:**

When making a ranged attack roll against a partially-covered target:

```
Standard Attack with cover:
Roll = 1d20 + [Dex mod] - [Cover penalty]

With Hunter's Eye:
Roll = 1d20 + [Dex mod] + [No cover penalty] + [Any other bonuses]
     = 1d20 + [Dex mod] + 0 + [Quarry Mark: +2] + [Patience: +3]
```

**Implementation:**

```csharp
public class HuntersEyeAbility : IAbility
{
    public bool ShouldIgnoreCover(CoverType coverType)
    {
        return coverType switch
        {
            CoverType.Half => true,
            CoverType.ThreeQuarters => true,
            CoverType.Full => false, // Cannot ignore full cover
            CoverType.None => false,
            _ => false
        };
    }

    public int GetCoverModifier(CoverType coverType)
    {
        // Instead of cover penalty, Hunter's Eye returns 0
        return 0;
    }
}
```

**User-Facing Message:**

```
> attack corrupted_wolf with bow
> [Attack vs Corrupted Wolf behind the doorway]
> [Normally: -2 from half cover]
> [Hunter's Eye: Cover is no obstacle]
> [1d20 + 4 (Dex) + 2 (Mark) + 3 (Patience) = 18 vs AC 14]
> [Hit! Dealing 2d6+2 = 9 damage]
```

---

## 5.2 Design Rationale

**Why not make it reduce cover instead of ignore it?**

Thematic consistency: A master hunter literally "sees through" obstacles via skill and experience, not by "getting better at shooting around them." Ignoring cover entirely is the right narrative.

**Why can't it ignore full cover?**

Balance preservation: If a target is in a sealed vault, no amount of skill can help. This creates meaningful tactical decisions about positioning.

---

## 6. Trap Mastery Ability Specification

### 6.1 Mechanics

**Ability ID:** `VeiðimaðrAbilityId.TrapMastery`

**Type:** Active (dual-purpose)

**Action Economy:**
- **Cost:** 2 AP per use
- **Range:** 5 spaces (trap placement) or Touch (enemy trap detection)
- **Duration:** Until encounter end (trap) or instant (detection)
- **Key Mechanic:** Can place OR detect traps in same turn

**Mechanical Effects:**

```
Two Modes: Trap Placement OR Enemy Trap Detection

MODE 1: PLACE TRAP (Requires adjacent empty space)
├─ Costs 2 AP
├─ Range: 5 spaces (must be able to reach and see placement area)
├─ Creates TrapInstance with:
│  ├─ Damage: 1d8
│  ├─ Effect: 1-turn immobilize
│  ├─ Detection DC: 13
│  └─ Status: Armed
├─ Trap remains until:
│  ├─ Triggered by enemy
│  ├─ Encounter ends
│  ├─ Dispelled by spell
│  └─ Disarmed by enemy
│
│ Trap Types (all have same stats):
│ • Spike: Spikes protrude from ground
│ • Net: Entangling webbing
│ • PitFall: Concealed pit trap
│ • Deadfall: Logs/debris fall on trigger
│ • Snare: Wire snare at foot level

MODE 2: DETECT ENEMY TRAPS
├─ Costs 2 AP
├─ Range: 5 spaces radius around hunter
├─ Makes perception check: 1d20 + [Keen Senses +1] + [Trap bonus +3]
│  (Total: +4 passive bonus from Veiðimaðr abilities)
├─ DC = 13 for well-hidden enemy traps
├─ Success reveals:
│  ├─ Number of traps
│  ├─ Approximate location ("near the doorway")
│  └─ Trap type if 12+ on skill check
├─ Failure:
│  └─ No information about traps
```

**Trap Instance Details:**

```csharp
TrapInstance
├── TrapId: Guid (unique)
├── PlacedBy: Guid (hunter who placed)
├── X, Y: int (map coordinates)
├── Type: TrapType (Spike, Net, etc.)
├── Status: TrapStatus (Armed → Triggered or Disarmed)
├── DamageRoll: "1d8"
├── ImmobilizeTurns: 1
├── DetectionDC: 13
├── TriggeredAt: DateTime? (null until triggered)
├── TurningTarget: Guid? (target hit by trap)
└── TurnsPlaced: int (age of trap)
```

**Trigger Mechanics:**

When an enemy enters trap's space:

```
1. Skill Check: Enemy makes DC 13 Reflex save
   - Success: Enemy avoids trap, trap disarmed
   - Failure: Trap triggers

2. On Trigger:
   - Damage: Roll 1d8, apply to enemy
   - Effect: Enemy immobilized for 1 turn
   - Status: Trap destroyed (single-use)

3. Display:
   > [Corrupted Wolf steps on hidden spike trap]
   > [Enemy fails to avoid (rolled 8 vs DC 13)]
   > [Trap deals 6 damage! Wolf is immobilized for 1 turn]
```

**Abilities Stack Interaction:**

- Cannot place trap on occupied space
- Cannot place trap in wall/solid object
- Trap placement is silent (enemy doesn't know)
- Multiple traps stack damage (each is separate trigger)
- Mark Quarry + Trap Mastery = enemies trapped and marked

### 6.2 Detection Check Resolution

**Player uses Trap Mastery to detect nearby traps:**

```
Skill Check: 1d20 + [Perception modifier] + [Keen Senses +1] + [Trap Mastery bonus +3]
DC: 13 (for well-hidden traps; varies by trap quality)

Success:
- Reveals: "There are 2 traps nearby"
- If roll >= 15: "One appears to be a spike trap east of here"
- If roll >= 18: "There's also a net trap south of here"

Failure:
- No information; hunter suspects nothing
```

**Implementation:**

```csharp
public class TrapMasteryService : ITrapMasteryService
{
    public async Task<TrapMasteryResult> DetectTrapsAsync(
        Guid hunterId,
        int centerX, int centerY,
        int detectionRange = 5)
    {
        // Get all traps within 5 spaces
        var nearbyTraps = await _trapRepository.GetTrapsInRangeAsync(
            centerX, centerY, detectionRange);

        // Make perception check
        var skillCheck = _skillResolver.Resolve1d20Check(
            hunterId,
            SkillType.Perception,
            bonusFromKeenSenses: 1,
            bonusFromAbility: 3); // +4 total

        var detectionDC = 13;
        bool success = skillCheck >= detectionDC;

        var result = new TrapMasteryResult
        {
            Type = TrapMasteryResult.ResultType.TrapsDetected,
            Success = success,
            DetectedTrapsCount = success ? nearbyTraps.Count : 0,
            DetectedTraps = success ? nearbyTraps
                .Select(t => (t.Type, Distance: CalculateDistance(centerX, centerY, t.X, t.Y)))
                .ToList() : new List<(TrapType, int)>(),
            Message = success ?
                $"You detect {nearbyTraps.Count} traps nearby" :
                "You don't sense any traps nearby"
        };

        return result;
    }
}
```

---

## 7. Predator's Patience Ability Specification

### 7.1 Mechanics

**Ability ID:** `VeiðimaðrAbilityId.PredatorPatience`

**Type:** Stance (toggle ability)

**Action Economy:**
- **Cost:** 1 AP to activate/deactivate
- **Range:** Self
- **Duration:** Lasts while stance is active (until broken)
- **Replacement:** Cannot be in multiple stances simultaneously

**Mechanical Effects:**

```
Effect: Stance that grants +3 to hit while stationary
├─ Hit Bonus: +3 to all attack rolls while in stance
├─ Duration: Entire turn (or until broken)
├─ Breaks On:
│  ├─ Movement (10+ feet/2 spaces)
│  ├─ Starting new turn (stance ends)
│  ├─ Toggle off (1 AP)
│  └─ Incapacitation/displacement
│
├─ While Active:
│  ├─ Can Attack normally (+3 bonus)
│  ├─ Can interact with objects
│  ├─ Can speak/communicate
│  └─ CANNOT move (any movement ends stance)
│
├─ Stack Behavior:
│  ├─ Works with Hunter's Eye (ignore cover)
│  ├─ Works with Quarry Mark (+2 hit, total +5)
│  └─ Works with Keen Senses (+1 perception)

Movement Threshold:
• Standing still: 0 spaces movement = stance active
• Moving 1 space: Stance broken (even moving 1 space)
• Diagonal movement: Counts as movement
• Being shoved/displaced: Also breaks stance
```

**Stance Toggle Sequence:**

```
Turn N:
> toggle predator-patience
> [Predator's Patience: ACTIVATED]
> [Stance grants +3 to hit. Moving will end the stance.]
>
> attack corrupted_wolf (1 AP)
> [Attack: 1d20 + 4 (Dex) + 2 (Mark) + 3 (Stance) = rolls 18 vs AC 14]
> [Hit! Damage: 2d6+2 = 9 damage]
>
> (Implicitly: Hunter does NOT move)

Turn N+1:
> [Predator's Patience has ended at end of turn]
> [Stance no longer active]
```

**Example: Stance Break on Movement**

```
Turn N:
> toggle predator-patience
> [Predator's Patience: ACTIVATED (+3 to hit)]

Turn N (same turn):
> move south 2 spaces
> [Predator's Patience: BROKEN by movement]
> [Stance deactivated. Lost +3 bonus.]

Turn N+1:
> (Stance is off; can activate again if desired)
```

### 7.2 Mechanical Implementation

**Activation:**

```csharp
public class PredatorsPatienceService : IPredatorsPatienceService
{
    public async Task<bool> ActivateStanceAsync(Guid hunterId)
    {
        var character = await _characterRepository.GetByIdAsync(hunterId);

        var state = new PredatorsPatienceState
        {
            HunterId = hunterId,
            IsActive = true,
            TurnsActive = 1,
            ActivatedAt = DateTime.UtcNow,
            LastCheckedAt = DateTime.UtcNow
        };

        await _stanceRepository.SaveAsync(state);

        _logger.LogInformation(
            "Character {HunterId} activated Predator's Patience stance",
            hunterId);

        return true;
    }
}
```

**Movement Check:**

```csharp
public async Task<bool> CheckMovementAsync(Guid hunterId, Movement movement)
{
    var state = await _stanceRepository.GetActiveStanceAsync(hunterId);
    if (state?.IsActive != true)
        return false; // Stance not active, no break

    // Any movement breaks stance
    if (movement.DistanceMoved > 0)
    {
        state.ApplyBreakCondition(PredatorsPatienceState.BreakReason.MovementDetected);
        await _stanceRepository.SaveAsync(state);

        _logger.LogInformation(
            "Predator's Patience stance broken for {HunterId} due to movement",
            hunterId);

        return true; // Stance was broken
    }

    return false; // Stance remains active
}
```

**Hit Bonus Application:**

```csharp
public int GetHitBonusForAttack(Guid hunterId, Attack attack)
{
    var state = _stanceRepository.GetActiveStanceAsync(hunterId).Result;

    if (state?.IsActive != true)
        return 0; // Not in stance

    // Verify no movement detected this turn
    if (state.HasMovedThisTurn)
        return 0; // Stance broken by movement

    return state.HitBonus; // +3
}
```

**End of Turn Processing:**

```csharp
public async Task ProcessEndOfTurnAsync(Guid hunterId)
{
    var state = await _stanceRepository.GetActiveStanceAsync(hunterId);
    if (state?.IsActive != true)
        return;

    // Automatically deactivate at end of turn
    state.Deactivate();
    await _stanceRepository.SaveAsync(state);

    _logger.LogInformation(
        "Predator's Patience stance ended for {HunterId} at end of turn",
        hunterId);
}
```

---

## 8. User Stories

### User Story 1: Master of Sightlines

**As a** Veiðimaðr player,
**I want to** ignore partial cover when making ranged attacks,
**So that** entrenched enemies can't hide behind obstacles.

**Acceptance Criteria:**
- [ ] Half cover no longer applies -2 penalty
- [ ] Three-quarters cover no longer applies -5 penalty
- [ ] Full cover cannot be bypassed (tactical limitation)
- [ ] Hunter's Eye is passive (always active)
- [ ] Works with Predator's Patience and Quarry Marks

### User Story 2: Battlefield Architect

**As a** Veiðimaðr player,
**I want to** place traps that damage and immobilize enemies,
**So that** I can control the battlefield and punish poor positioning.

**Acceptance Criteria:**
- [ ] Trap Mastery costs 2 AP to place trap
- [ ] Trap deals 1d8 damage on trigger
- [ ] Trap immobilizes for 1 turn on trigger
- [ ] Trap has DC 13 to avoid/disarm
- [ ] Multiple traps can be placed (multiple traps stack)
- [ ] Traps persist until encounter end

### User Story 3: Sensing Danger

**As a** Veiðimaðr player,
**I want to** detect enemy traps nearby,
**So that** I can protect my team and plan around threats.

**Acceptance Criteria:**
- [ ] Trap Mastery costs 2 AP to detect
- [ ] Detection search 5-space radius
- [ ] Skill check: 1d20 + bonuses vs DC 13
- [ ] Success reveals trap count and types
- [ ] Failure reveals nothing
- [ ] Can detect and place traps in same turn (different 2 AP uses)

### User Story 4: Patience as Weapon

**As a** Veiðimaðr player,
**I want to** enter a stance that grants +3 to hit while I stay still,
**So that** I can maximize damage output by sacrificing mobility.

**Acceptance Criteria:**
- [ ] Predator's Patience costs 1 AP to activate
- [ ] Provides +3 to all attacks while active
- [ ] Ends if hunter moves at all
- [ ] Ends at end of turn (must reactivate)
- [ ] Works with other bonuses (+2 mark, +1 perception)
- [ ] Clear UI feedback when stance breaks

---

## 9. Application Service Layer

### 9.1 Extended IVeiðimaðrAbilityService

```csharp
/// <summary>
/// Extended service interface with Tier 2 ability methods.
/// </summary>
public interface IVeiðimaðrAbilityService
{
    // [v0.20.7a methods]
    Task<MarkQuarryResult> ExecuteMarkQuarryAsync(...);
    int ApplyKeenSenses(Guid hunterId);
    Task<ReadTheSignsResult> ExecuteReadTheSignsAsync(...);

    // [NEW v0.20.7b methods]

    /// <summary>
    /// Applies Hunter's Eye passive to attack roll.
    /// </summary>
    bool ShouldIgnoreCover(CoverType coverType);

    /// <summary>
    /// Executes Trap Mastery to place a trap at location.
    /// </summary>
    Task<TrapMasteryResult> PlaceTrapAsync(
        Guid hunterId,
        int x, int y,
        TrapType trapType = TrapType.Spike);

    /// <summary>
    /// Executes Trap Mastery to detect enemy traps.
    /// </summary>
    Task<TrapMasteryResult> DetectNearbyTrapsAsync(
        Guid hunterId,
        int centerX, int centerY,
        int detectionRange = 5);

    /// <summary>
    /// Activates Predator's Patience stance.
    /// </summary>
    Task<bool> ActivatePredatorsPatienceAsync(Guid hunterId);

    /// <summary>
    /// Deactivates Predator's Patience stance.
    /// </summary>
    Task<bool> DeactivatePredatorsPatienceAsync(Guid hunterId);

    /// <summary>
    /// Gets hit bonus from Predator's Patience if active.
    /// </summary>
    Task<int> GetPredatorsPatienceBonusAsync(Guid hunterId);

    /// <summary>
    /// Checks if stance breaks due to movement.
    /// </summary>
    Task<bool> CheckMovementBreaksStanceAsync(Guid hunterId, int distanceMoved);
}
```

### 9.2 ITrapMasteryService Interface

```csharp
/// <summary>
/// Service for managing trap placement and detection mechanics.
/// </summary>
public interface ITrapMasteryService
{
    /// <summary>
    /// Places a trap at specified location.
    /// </summary>
    Task<TrapMasteryResult> PlaceTrapAsync(
        Guid hunterId,
        int x, int y,
        TrapType trapType = TrapType.Spike);

    /// <summary>
    /// Detects traps within range using skill check.
    /// </summary>
    Task<TrapMasteryResult> DetectTrapsAsync(
        Guid hunterId,
        int centerX, int centerY,
        int detectionRange = 5);

    /// <summary>
    /// Triggers a trap when enemy steps on it.
    /// </summary>
    Task<(int Damage, int ImmobilizeTurns, bool Hit)> TriggerTrapAsync(
        Guid trapId,
        Guid targetId,
        int targetReflex);

    /// <summary>
    /// Disarms or destroys a trap.
    /// </summary>
    Task<bool> DisarmTrapAsync(Guid trapId);

    /// <summary>
    /// Gets all traps placed by a hunter.
    /// </summary>
    Task<IReadOnlyList<TrapInstance>> GetPlacedTrapsForAsync(Guid hunterId);

    /// <summary>
    /// Gets trap at specific location.
    /// </summary>
    Task<TrapInstance?> GetTrapAtAsync(int x, int y);
}
```

### 9.3 IPredatorsPatienceService Interface

```csharp
/// <summary>
/// Service for managing Predator's Patience stance mechanics.
/// </summary>
public interface IPredatorsPatienceService
{
    /// <summary>
    /// Activates Predator's Patience stance.
    /// </summary>
    Task<bool> ActivateStanceAsync(Guid hunterId);

    /// <summary>
    /// Deactivates Predator's Patience stance.
    /// </summary>
    Task<bool> DeactivateStanceAsync(Guid hunterId);

    /// <summary>
    /// Checks if stance is currently active.
    /// </summary>
    Task<bool> IsStanceActiveAsync(Guid hunterId);

    /// <summary>
    /// Gets hit bonus (+3 if active, 0 otherwise).
    /// </summary>
    Task<int> GetHitBonusAsync(Guid hunterId);

    /// <summary>
    /// Checks for movement and breaks stance if needed.
    /// Returns true if stance was broken.
    /// </summary>
    Task<bool> CheckMovementAsync(Guid hunterId, int distanceMoved);

    /// <summary>
    /// Applies end-of-turn break condition.
    /// </summary>
    Task ApplyEndOfTurnAsync(Guid hunterId);

    /// <summary>
    /// Gets current stance state.
    /// </summary>
    Task<PredatorsPatienceState?> GetStateAsync(Guid hunterId);
}
```

---

## 10. Configuration Specifications

### 10.1 abilities.json Tier 2 Entries

```json
[
  {
    "id": "hunters-eye",
    "displayName": "Hunter's Eye",
    "abilityType": "Passive",
    "tier": 2,
    "specialization": "veiðimaðr",
    "description": "Always active. Ignore partial cover when making ranged attacks.",
    "actionPointCost": 0,
    "resourceCost": null,
    "range": 0,
    "rangeType": "Self",
    "targetType": "Self",
    "resolution": "Passive",
    "effects": [
      {
        "type": "PassiveAbility",
        "mechanic": "IgnoreCover",
        "applicableTo": "PartialCover",
        "modifierApplied": 0
      }
    ],
    "corruptionRisk": 0,
    "tags": ["passive", "ranged-attack", "cover-negation", "coherent"],
    "prerequisites": ["tier1-completed"],
    "notes": "Cannot ignore full cover (sealed rooms, etc). Works with Predator's Patience and Quarry Marks."
  },
  {
    "id": "trap-mastery",
    "displayName": "Trap Mastery",
    "abilityType": "Active",
    "tier": 2,
    "specialization": "veiðimaðr",
    "description": "Place a trap (1d8 damage + 1-turn immobilize) or detect enemy traps nearby. Costs 2 AP per use.",
    "actionPointCost": 2,
    "resourceCost": null,
    "range": 5,
    "rangeType": "spaces",
    "targetType": "Location or AreaDetection",
    "resolution": "TrapPlacementOrDetection",
    "effects": [
      {
        "type": "TrapPlacement",
        "damageRoll": "1d8",
        "immobilizeDuration": 1,
        "detectionDC": 13
      },
      {
        "type": "TrapDetection",
        "searchRadius": 5,
        "skillCheckBonus": 3,
        "baseDC": 13
      }
    ],
    "trapTypes": ["Spike", "Net", "PitFall", "Deadfall", "Snare"],
    "corruptionRisk": 0,
    "tags": ["active", "tactical", "battlefield-control", "detection", "coherent"],
    "prerequisites": ["tier1-completed"],
    "notes": "Can place or detect in same turn (separate 2 AP uses). Traps persist until encounter end."
  },
  {
    "id": "predators-patience",
    "displayName": "Predator's Patience",
    "abilityType": "Stance",
    "tier": 2,
    "specialization": "veiðimaðr",
    "description": "Enter a stance granting +3 to hit. Ends if you move or at end of turn.",
    "actionPointCost": 1,
    "resourceCost": null,
    "range": 0,
    "rangeType": "Self",
    "targetType": "Self",
    "resolution": "StanceToggle",
    "effects": [
      {
        "type": "StanceBuff",
        "stanceName": "Predator's Patience",
        "hitBonus": 3,
        "breakConditions": ["Movement", "EndOfTurn"],
        "canStack": false
      }
    ],
    "corruptionRisk": 0,
    "tags": ["stance", "hit-bonus", "tactical-patience", "coherent"],
    "prerequisites": ["tier1-completed"],
    "notes": "Cannot move while stance is active. Resets at end of turn (must reactivate). Works with Hunter's Eye and Quarry Marks."
  }
]
```

### 10.2 trap-templates.json Entry

```json
{
  "trapTemplates": [
    {
      "id": "spike",
      "displayName": "Spike Trap",
      "type": "Spike",
      "description": "Spikes protrude from the ground, causing piercing wounds.",
      "damageRoll": "1d8",
      "damageType": "Piercing",
      "effects": {
        "immobilize": {
          "duration": 1,
          "durationUnit": "turns"
        }
      },
      "detectionDC": 13,
      "disarmDC": 13,
      "activationRequirement": "Target enters space",
      "activationCheck": {
        "type": "Reflex",
        "dc": 13
      }
    },
    {
      "id": "net",
      "displayName": "Net Trap",
      "type": "Net",
      "description": "Entangling webbing catches and holds targets.",
      "damageRoll": "1d8",
      "damageType": "Blunt",
      "effects": {
        "immobilize": {
          "duration": 1,
          "durationUnit": "turns"
        },
        "entangle": {
          "duration": 1,
          "durationUnit": "turns"
        }
      },
      "detectionDC": 13,
      "disarmDC": 13,
      "activationRequirement": "Target enters space"
    },
    {
      "id": "pitfall",
      "displayName": "Pitfall Trap",
      "type": "PitFall",
      "description": "A concealed pit causes falling damage and immobilization.",
      "damageRoll": "1d8",
      "damageType": "Blunt",
      "effects": {
        "immobilize": {
          "duration": 1,
          "durationUnit": "turns"
        }
      },
      "detectionDC": 15,
      "disarmDC": 15,
      "activationRequirement": "Target enters space"
    }
  ]
}
```

---

## 11. Code Examples & Implementation

### 11.1 HuntersEyePassive Implementation

```csharp
/// <summary>
/// Hunter's Eye passive ability implementation.
/// Allows ranged attacks to ignore partial cover.
/// </summary>
public class HuntersEyeAbility : IPassiveAbility
{
    private readonly ILogger<HuntersEyeAbility> _logger;

    public HuntersEyeAbility(ILogger<HuntersEyeAbility> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public VeiðimaðrAbilityId AbilityId => VeiðimaðrAbilityId.HuntersEye;

    /// <summary>
    /// Determines if cover penalty should be applied.
    /// Hunter's Eye ignores partial cover.
    /// </summary>
    public bool ShouldApplyCoverPenalty(CoverType coverType)
    {
        return coverType switch
        {
            CoverType.Half => false,           // Ignored
            CoverType.ThreeQuarters => false,  // Ignored
            CoverType.Full => true,             // Cannot ignore
            CoverType.None => false,            // No penalty anyway
            _ => false
        };
    }

    /// <summary>
    /// Gets the cover modifier for Hunter's Eye.
    /// Returns 0 for partial cover (no penalty).
    /// </summary>
    public int GetCoverModifier(CoverType coverType)
    {
        if (ShouldApplyCoverPenalty(coverType))
        {
            // For full cover, return standard penalty (effectively blocks attack)
            return -99; // Cannot shoot through
        }

        return 0; // No penalty from partial cover
    }

    /// <summary>
    /// Called before attack resolution to apply effect.
    /// </summary>
    public HuntersEyeResult ApplyToAttack(
        Guid hunterId,
        Guid targetId,
        string targetName,
        CoverType targetCover,
        int distance)
    {
        var coverIgnored = ShouldApplyCoverPenalty(targetCover) == false
            && targetCover != CoverType.None;

        var result = new HuntersEyeResult
        {
            HunterId = hunterId,
            TargetId = targetId,
            TargetName = targetName,
            OriginalCover = targetCover.ToString(),
            CoverIgnored = coverIgnored,
            ActualBonus = coverIgnored ? GetCoverBonus(targetCover) : 0,
            Distance = distance,
            Resolved = false,
            GeneratedAt = DateTime.UtcNow
        };

        if (coverIgnored)
        {
            _logger.LogInformation(
                "Hunter's Eye: Cover ignored for attack on {TargetName} ({OriginalCover})",
                targetName, targetCover);
        }

        return result;
    }

    private int GetCoverBonus(CoverType coverType) =>
        coverType switch
        {
            CoverType.Half => 2,          // Negates -2 penalty = +2 bonus
            CoverType.ThreeQuarters => 5, // Negates -5 penalty = +5 bonus
            _ => 0
        };

    public string GetDescription() =>
        "Ignore partial cover when making ranged attacks.";
}
```

### 11.2 TrapMasteryService Implementation

```csharp
/// <summary>
/// Service for trap placement and detection mechanics.
/// </summary>
public class TrapMasteryService : ITrapMasteryService
{
    private readonly ITrapRepository _trapRepository;
    private readonly ISkillResolver _skillResolver;
    private readonly ILogger<TrapMasteryService> _logger;

    public TrapMasteryService(
        ITrapRepository trapRepository,
        ISkillResolver skillResolver,
        ILogger<TrapMasteryService> logger)
    {
        _trapRepository = trapRepository ?? throw new ArgumentNullException(nameof(trapRepository));
        _skillResolver = skillResolver ?? throw new ArgumentNullException(nameof(skillResolver));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<TrapMasteryResult> PlaceTrapAsync(
        Guid hunterId,
        int x, int y,
        TrapType trapType = TrapType.Spike)
    {
        // Verify location is empty
        var existingTrap = await _trapRepository.GetTrapAtAsync(x, y);
        if (existingTrap != null)
        {
            return new TrapMasteryResult
            {
                Type = TrapMasteryResult.ResultType.TrapPlaced,
                Success = false,
                Location = (x, y),
                Message = "That space is already occupied."
            };
        }

        // Create trap instance
        var trap = new TrapInstance
        {
            TrapId = Guid.NewGuid(),
            PlacedBy = hunterId,
            X = x,
            Y = y,
            Type = trapType,
            Status = TrapStatus.Armed,
            DamageRoll = "1d8",
            ImmobilizeTurns = 1,
            DetectionDC = 13
        };

        await _trapRepository.SaveAsync(trap);

        _logger.LogInformation(
            "Trap placed by hunter {HunterId} at ({X}, {Y}): {TrapType}",
            hunterId, x, y, trapType);

        return new TrapMasteryResult
        {
            Type = TrapMasteryResult.ResultType.TrapPlaced,
            PlacedTrap = trap,
            Location = (x, y),
            Success = true,
            Message = $"You carefully place a {trapType} trap here."
        };
    }

    public async Task<TrapMasteryResult> DetectTrapsAsync(
        Guid hunterId,
        int centerX, int centerY,
        int detectionRange = 5)
    {
        // Get nearby traps
        var nearbyTraps = await _trapRepository.GetTrapsInRangeAsync(
            centerX, centerY, detectionRange);

        // Make perception check with bonuses
        var skillCheck = _skillResolver.Resolve1d20Check(
            hunterId,
            SkillType.Perception,
            bonusFromAbilities: 4); // +1 Keen Senses + +3 Trap Mastery

        const int detectionDC = 13;
        bool success = skillCheck >= detectionDC;

        var detectedTraps = nearbyTraps
            .Select(t => (
                Type: t.Type,
                Distance: CalculateDistance(centerX, centerY, t.X, t.Y)
            ))
            .ToList();

        _logger.LogInformation(
            "Trap detection by hunter {HunterId}: {Count} traps detected (roll {Roll} vs DC {DC})",
            hunterId, success ? detectedTraps.Count : 0, skillCheck, detectionDC);

        return new TrapMasteryResult
        {
            Type = TrapMasteryResult.ResultType.TrapsDetected,
            Success = success,
            DetectedTrapsCount = success ? detectedTraps.Count : 0,
            DetectedTraps = detectedTraps,
            Message = success ?
                $"You detect {detectedTraps.Count} trap{(detectedTraps.Count != 1 ? "s" : "")} nearby." :
                "You don't sense any obvious traps nearby."
        };
    }

    public async Task<(int Damage, int ImmobilizeTurns, bool Hit)> TriggerTrapAsync(
        Guid trapId,
        Guid targetId,
        int targetReflex)
    {
        var trap = await _trapRepository.GetByIdAsync(trapId);
        if (trap == null)
            throw new InvalidOperationException($"Trap {trapId} not found");

        // Roll damage
        var damage = DiceRoller.Roll("1d8");

        // Target makes reflex save
        const int trapDC = 13;
        bool hitTarget = targetReflex < trapDC;

        if (hitTarget)
        {
            trap.Trigger(targetId, DateTime.UtcNow);
            trap.Status = TrapStatus.Triggered;

            _logger.LogInformation(
                "Trap {TrapId} triggered on target {TargetId}. Damage: {Damage}, Reflex: {Reflex}",
                trapId, targetId, damage, targetReflex);
        }
        else
        {
            trap.Status = TrapStatus.Disarmed;

            _logger.LogInformation(
                "Trap {TrapId} avoided by target {TargetId}. Reflex: {Reflex} vs DC {DC}",
                trapId, targetId, targetReflex, trapDC);
        }

        return (damage, trap.ImmobilizeTurns, hitTarget);
    }

    public async Task<bool> DisarmTrapAsync(Guid trapId)
    {
        var trap = await _trapRepository.GetByIdAsync(trapId);
        if (trap == null)
            return false;

        trap.Disarm();
        await _trapRepository.SaveAsync(trap);

        _logger.LogInformation("Trap {TrapId} disarmed", trapId);

        return true;
    }

    public async Task<IReadOnlyList<TrapInstance>> GetPlacedTrapsForAsync(Guid hunterId)
    {
        return await _trapRepository.GetTrapsByPlacerAsync(hunterId);
    }

    public async Task<TrapInstance?> GetTrapAtAsync(int x, int y)
    {
        return await _trapRepository.GetTrapAtAsync(x, y);
    }

    private int CalculateDistance(int fromX, int fromY, int toX, int toY)
    {
        return Math.Max(Math.Abs(toX - fromX), Math.Abs(toY - fromY)); // Chebyshev distance
    }
}
```

---

## 12. State Machine Diagrams

### 12.1 Trap Lifecycle

```
┌──────────────────┐
│   UNDEPLOYED     │
│  (Not placed)    │
└────────┬─────────┘
         │
         │ PlaceTrap (2 AP)
         │
         ▼
┌──────────────────┐
│   ARMED          │
│  (Hidden, ready) │
└────────┬─────────┘
         │
    ┌────┴────────┬────────────┐
    │             │            │
    ▼             ▼            ▼
┌──────────┐ ┌───────────┐ ┌─────────────┐
│TRIGGERED │ │ DISARMED  │ │ Encounter   │
│ (Hit!)   │ │(Detected) │ │ Ends        │
└────┬─────┘ └─────┬─────┘ └──────┬──────┘
     │             │              │
     │             │              │
     └─────────────┴──────────────┘
                   │
                   ▼
          ┌────────────────┐
          │   DESTROYED    │
          │  (Gone, can't  │
          │  rearm)        │
          └────────────────┘
```

### 12.2 Stance State Machine

```
┌──────────────────┐
│ STANCE INACTIVE  │
│ (No bonus)       │
└────────┬─────────┘
         │
         │ Toggle Predator's Patience (1 AP)
         │
         ▼
┌──────────────────────────────┐
│   STANCE ACTIVE              │
│   +3 to hit                  │
│   Cannot move                │
├──────────────────────────────┤
│  While Active:               │
│  • Can attack               │
│  • Can interact             │
│  • CANNOT move              │
└────────┬──────────┬──────────┘
         │          │
    ┌────▼─────┐    │
    │ Hunter   │    │ Turn
    │ Moves    │    │ Ends
    │ (1+ space)    │
    │              │
┌───▼──────────────▼───┐
│  STANCE BROKEN        │
│  (Lost +3 bonus)      │
│  Now can move         │
└───┬──────────────────┘
    │
    │ End of processing
    │
    ▼
┌──────────────────┐
│ STANCE INACTIVE  │
│ (Ready to toggle)│
└──────────────────┘
```

---

## 13. Interaction Matrix

### 13.1 Tier 2 with Tier 1 Stacking

| Tier 1 | Hunter's Eye | Trap Mastery | Patience |
|--------|--------------|--------------|----------|
| **Mark Quarry (+2)** | Works together | Marked → trap → marked | +2 + 3 = +5 |
| **Keen Senses (+1)** | Works together | +1 to trap detection | +1 to perception |
| **Read the Signs** | N/A (passive) | Traps create new signs | N/A (passive) |

### 13.2 Tier 2 Cross-Ability Interactions

**Hunter's Eye + Trap Mastery:**
```
Scenario: Enemy behind partial cover, hunter has trap nearby
1. Hunter places trap between self and enemy
2. Hunter ignores cover when attacking (Hunter's Eye)
3. If enemy moves toward hunter, triggers trap
Result: +3 (cover ignored), potential trap damage
```

**Trap Mastery + Predator's Patience:**
```
Scenario: Hunter places trap, then activates Patience stance
1. Hunter places trap (2 AP)
2. Hunter activates Patience (+1 AP) = 3 AP total
3. Hunter stays still (+3 bonus)
4. Enemies hit by trap and hunted with bonus
Result: Trap damage + immobilize + +3 to hit on marked targets
```

**All Three Tier 2 + Quarry Marks:**
```
Best Case Scenario:
• Target is marked: +2
• Predator's Patience active: +3
• Hunter's Eye ignores cover: removes penalty (may net +2-5)
• Total: +5 to +10 before attack roll

Limitations:
- Patience ends if hunter moves
- Must have line of sight for Hunter's Eye
- Traps are limited resource
```

---

## 14. Logging Specifications

```csharp
// INFO: Hunter's Eye applied
_logger.LogInformation(
    "Hunter {HunterId} attacked {TargetId} ({TargetName}) ignoring {CoverType} cover",
    hunterId, targetId, targetName, coverType);

// INFO: Trap placed
_logger.LogInformation(
    "Trap {TrapId} placed by {HunterId} at ({X}, {Y}): {TrapType}",
    trapId, hunterId, x, y, trapType);

// INFO: Trap triggered
_logger.LogInformation(
    "Trap {TrapId} triggered on target {TargetId}. Damage: {Damage}",
    trapId, targetId, damage);

// INFO: Trap detected
_logger.LogInformation(
    "Hunter {HunterId} detected {Count} traps at ({X}, {Y}). Roll: {Roll} vs DC {DC}",
    hunterId, count, x, y, roll, dc);

// INFO: Stance activated
_logger.LogInformation(
    "Predator's Patience stance activated for {HunterId}. +3 to hit.",
    hunterId);

// INFO: Stance broken
_logger.LogInformation(
    "Predator's Patience stance broken for {HunterId}. Reason: {Reason}",
    hunterId, reason);
```

---

## 15. Unit Testing Requirements

### 15.1 Test Classes

```csharp
public class HuntersEyeAbilityTests
{
    [Fact]
    public void ApplyToAttack_PartialCover_IgnoresCover()

    [Fact]
    public void ApplyToAttack_FullCover_CannotIgnore()

    [Fact]
    public void GetCoverModifier_HalfCover_ReturnsZero()

    [Theory]
    [InlineData(CoverType.Half, 2)]
    [InlineData(CoverType.ThreeQuarters, 5)]
    public void GetCoverBonus_CorrectBonusApplied(CoverType cover, int expectedBonus)
}

public class TrapMasteryServiceTests
{
    [Fact]
    public async Task PlaceTrapAsync_ValidLocation_TrapArmed()

    [Fact]
    public async Task PlaceTrapAsync_OccupiedLocation_FailsPlacement()

    [Fact]
    public async Task TriggerTrapAsync_TargetFailsReflex_TakesFullDamage()

    [Fact]
    public async Task TriggerTrapAsync_TargetSucceedsReflex_TrapDisarmed()

    [Fact]
    public async Task DetectTrapsAsync_SuccessfulRoll_RevealsTraps()

    [Fact]
    public async Task DetectTrapsAsync_FailedRoll_NoTrapsRevealed()
}

public class PredatorsPatienceStanceTests
{
    [Fact]
    public async Task ActivateStanceAsync_SetsIsActiveTrue()

    [Fact]
    public async Task GetHitBonusAsync_StanceActive_Returns3()

    [Fact]
    public async Task GetHitBonusAsync_StanceInactive_Returns0()

    [Fact]
    public async Task CheckMovementAsync_AnyMovement_BreaksStance()

    [Fact]
    public async Task ApplyEndOfTurnAsync_StanceEnds()
}
```

---

## 16. Deliverable Checklist

- [ ] **Domain Value Objects**
  - [ ] HuntersEyeResult implemented
  - [ ] TrapInstance implemented with all methods
  - [ ] TrapMasteryResult implemented
  - [ ] PredatorsPatienceState implemented with all methods

- [ ] **Domain Enums**
  - [ ] TrapType enum (5 trap types)
  - [ ] TrapStatus enum (4 statuses)
  - [ ] Stance-related enums

- [ ] **Application Services**
  - [ ] ITrapMasteryService interface
  - [ ] TrapMasteryService implementation
  - [ ] IPredatorsPatienceService interface
  - [ ] PredatorsPatienceService implementation
  - [ ] IVeiðimaðrAbilityService extended with Tier 2 methods

- [ ] **Ability Implementations**
  - [ ] Hunter's Eye passive (passive)
  - [ ] Trap Mastery active (placement & detection)
  - [ ] Predator's Patience stance (toggle)

- [ ] **Configuration**
  - [ ] abilities.json entries for all 3 Tier 2 abilities
  - [ ] trap-templates.json with trap definitions

- [ ] **Tests**
  - [ ] ~8 unit tests covering services and abilities
  - [ ] Hunter's Eye cover negation tests
  - [ ] Trap placement and triggering tests
  - [ ] Trap detection tests
  - [ ] Stance activation and break tests

---

## 17. Acceptance Criteria

- [ ] Hunter's Eye ignores all partial cover (half, three-quarters)
- [ ] Hunter's Eye does NOT ignore full cover
- [ ] Trap Mastery places traps (1d8 + 1-turn immobilize)
- [ ] Trap Mastery detects enemy traps (skill check vs DC 13)
- [ ] Predator's Patience grants +3 to hit while stationary
- [ ] Predator's Patience breaks on any movement
- [ ] Predator's Patience resets at end of turn
- [ ] All abilities have zero corruption risk
- [ ] Tier 2 abilities stack with Tier 1 abilities correctly
- [ ] All code follows established patterns
- [ ] XML documentation complete
- [ ] Unit tests cover all code paths

---

## 18. Dependencies & Prerequisites

- v0.20.7a (Tier 1 framework)
- v0.17.4 Specialization Framework
- Combat system (for cover mechanics)
- Position/map system (for trap placement)
- Skill resolution system
- Stance management system

---

## 19. Design Decisions & Rationale

### Decision 1: Cover Complete Negation vs Reduction

**Decision:** Hunter's Eye completely ignores partial cover rather than reducing penalties.

**Rationale:** Thematically, a "master hunter" doesn't "shoot better around obstacles" but rather "sees through them" via skill. Complete negation is cleaner mechanically and more satisfying narratively.

### Decision 2: Traps as Single-Use Consumables

**Decision:** Traps trigger once then are destroyed; cannot rearm in combat.

**Rationale:** Prevents exploit of reusing traps. Encourages placement strategy and limits spam.

### Decision 3: Predator's Patience as Turn-Limited Stance

**Decision:** Stance automatically ends at end of turn; must reactivate each turn.

**Rationale:** Prevents permanent +3 bonus. Encourages dynamic tactical play (activate, use, move).

---

## 20. Risk Assessment

| Risk | Severity | Likelihood | Mitigation |
|------|----------|-----------|-----------|
| **Hunter's Eye breaks cover logic** | High | Low | Unit test all cover types; verify full cover cannot be ignored |
| **Traps exploited for infinite damage** | High | Medium | Cap trap count; test trigger mechanics thoroughly |
| **Predator's Patience +3 bonus too strong** | Medium | Medium | Playtest; verify stacking with other bonuses capped |
| **Trap detection DC too easy** | Low | Medium | Adjust to DC 15+ if needed; playtest with varying skills |
| **Stance break conditions confuse players** | Medium | Medium | Clear UI feedback; include in tooltip |

---

**End of v0.20.7b Design Specification**
