# v0.15.0e Design Specification: Dice Roll Logging

**Version:** 0.15.0e
**Theme:** Dice Roll Logging
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0a Complete (Core Dice Mechanics Refactor), v0.15.0b Complete (Seeded Random Provider), v0.15.0c Complete (Skill Check Refactor), v0.15.0d Complete (Contested & Extended Checks)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [DiceRollLog Record](#4-dicerolllog-record)
5. [RollContexts Static Class](#5-rollcontexts-static-class)
6. [IDiceRollLogger Interface](#6-idicerolllogger-interface)
7. [InMemoryDiceRollLogger Implementation](#7-inmemorydicellogger-implementation)
8. [DiceService Integration](#8-diceservice-integration)
9. [Data Model Changes](#9-data-model-changes)
10. [Configuration](#10-configuration)
11. [Commands](#11-commands)
12. [User-Facing Changes](#12-user-facing-changes)
13. [Logging Specifications](#13-logging-specifications)
14. [Unit Testing Requirements](#14-unit-testing-requirements)
15. [Use Cases](#15-use-cases)
16. [Deliverable Checklist](#16-deliverable-checklist)
17. [Acceptance Criteria](#17-acceptance-criteria)
18. [Future Considerations](#18-future-considerations)
19. [Implementation Notes](#19-implementation-notes)
20. [Document Metadata](#20-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.0e, the Dice Roll Logging phase. This part introduces a structured logging system for dice rolls that enables:

1. **Roll History Tracking**: Every dice roll is recorded with full metadata including seed, pool size, individual results, net successes, and context.

2. **Context-Aware Queries**: Rolls can be filtered by context prefix (e.g., all "Combat:" rolls or all "Skill:Acrobatics" rolls).

3. **Debugging and Replay**: The combination of seed and pool size allows deterministic reproduction of any logged roll for debugging purposes.

4. **Analytics Foundation**: Logged data supports future analytics features like success rate tracking, fumble frequency analysis, and balance tuning.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Roll Recording** | Logged via `IGameEventLogger` (generic) | Dedicated `IDiceRollLogger` with structured `DiceRollLog` records |
| **Context Tracking** | Optional `context` string parameter | Standardized `RollContexts` constants with helper methods |
| **History Retrieval** | Not available | `GetRollHistory()` returns recent rolls |
| **Context Filtering** | Not available | `GetRollsByContext()` filters by prefix |
| **Actor/Target Tracking** | Not tracked | `ActorId` and `TargetId` fields |
| **Seed Storage** | Not stored with roll | `Seed` field captures RNG state |
| **Outcome Flags** | Not stored | `IsFumble` and `IsCriticalSuccess` flags |

### 1.3 Scope

**In Scope:**
- Define `DiceRollLog` record with complete roll metadata
- Create `RollContexts` static class with standardized context constants
- Define `IDiceRollLogger` interface with logging and query methods
- Implement `InMemoryDiceRollLogger` as default implementation
- Integrate logging into `DiceService.Roll()` method
- Unit tests for logging and retrieval (~4-5 tests)

**Out of Scope:**
- Persistent roll storage (database) - future version
- Roll analytics and statistics - future version
- Roll visualization/UI - future version
- Combat hit quality integration - v0.15.0f
- Replay system using logged seeds - future version
- Export functionality - future version

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Records | 1 | `DiceRollLog` (complete roll metadata) |
| Static Classes | 1 | `RollContexts` (context constants and helpers) |
| Interfaces | 1 | `IDiceRollLogger` (logging and query contract) |
| Services | 1 | `InMemoryDiceRollLogger` (in-memory implementation) |
| Unit Tests | ~5 | Logging, history retrieval, context filtering, flag storage |

---

## 2. Dependencies

### 2.1 Required from v0.15.0a (Core Dice Mechanics)

| Component | Location | Usage in v0.15.0e |
|-----------|----------|-------------------|
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Provides `NetSuccesses`, `IsFumble`, `IsCriticalSuccess`, `Rolls` |
| `DiceConstants` | `Domain/Constants/DiceConstants.cs` | Success threshold values for documentation |
| `DiceService` | `Application/Services/DiceService.cs` | Modified to call `IDiceRollLogger.LogRoll()` |

### 2.2 Required from v0.15.0b (Seeded Random Provider)

| Component | Location | Usage in v0.15.0e |
|-----------|----------|-------------------|
| `IRandomProvider` | `Domain/Interfaces/IRandomProvider.cs` | Provides `GetCurrentSeed()` for logging |
| `SeededRandomProvider` | `Application/Services/SeededRandomProvider.cs` | Seed capture for reproducibility |

### 2.3 Required from v0.15.0c (Skill Check Refactor)

| Component | Location | Usage in v0.15.0e |
|-----------|----------|-------------------|
| `SkillCheckResult` | `Domain/ValueObjects/SkillCheckResult.cs` | Source of skill context strings |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Passes context to dice rolls |

### 2.4 Required from v0.15.0d (Contested & Extended Checks)

| Component | Location | Usage in v0.15.0e |
|-----------|----------|-------------------|
| `ContestedCheckResult` | `Domain/ValueObjects/ContestedCheckResult.cs` | Contested roll logging context |
| `ExtendedCheckState` | `Domain/Entities/ExtendedCheckState.cs` | Extended check round logging |

### 2.5 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.0f | `CombatService` | Logs combat rolls with `Combat:Attack`, `Combat:Damage` contexts |
| v0.15.1+ | Analytics | Roll history for balance analysis and tuning |
| Future | Replay System | Seed + pool size allows deterministic replay |
| Future | Debug Tools | Roll inspection and reproduction |

---

## 3. Architecture Diagrams

### 3.1 Dice Roll Logging Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        DICE ROLL LOGGING FLOW                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CALLER (e.g., SkillCheckService, CombatService)                            │
│           │                                                                  │
│           │ Roll(pool, context: "Skill:Acrobatics")                         │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        DiceService                                   │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  1. Capture seed from IRandomProvider.GetCurrentSeed()              │    │
│  │     seed = 12345                                                     │    │
│  │                                                                      │    │
│  │  2. Roll dice pool                                                   │    │
│  │     5d10 → [8, 9, 1, 4, 3] → 2S - 1B = 1 net                       │    │
│  │                                                                      │    │
│  │  3. Create DiceRollResult                                           │    │
│  │     { NetSuccesses: 1, IsFumble: false, IsCriticalSuccess: false }  │    │
│  │                                                                      │    │
│  │  4. Create DiceRollLog                                              │    │
│  │     {                                                                │    │
│  │       RollId: new Guid(),                                           │    │
│  │       Timestamp: DateTime.UtcNow,                                   │    │
│  │       Seed: 12345,                                                  │    │
│  │       PoolSize: 5,                                                  │    │
│  │       Results: [8, 9, 1, 4, 3],                                     │    │
│  │       NetSuccesses: 1,                                              │    │
│  │       Context: "Skill:Acrobatics",                                  │    │
│  │       ActorId: <caller-provided>,                                   │    │
│  │       TargetId: null,                                               │    │
│  │       IsFumble: false,                                              │    │
│  │       IsCriticalSuccess: false                                      │    │
│  │     }                                                                │    │
│  │                                                                      │    │
│  │  5. Call IDiceRollLogger.LogRoll(diceRollLog)                       │    │
│  │                                                                      │    │
│  │  6. Return DiceRollResult to caller                                 │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                               │                                              │
│                               │                                              │
│                               ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                     IDiceRollLogger                                  │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  LogRoll(DiceRollLog)                                               │    │
│  │  GetRollHistory(count = 100)                                        │    │
│  │  GetRollsByContext("Skill:")                                        │    │
│  │  ClearHistory()                                                      │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                               │                                              │
│                               │ (implemented by)                             │
│                               ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  InMemoryDiceRollLogger                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  private Queue<DiceRollLog> _rollHistory (capped at MaxHistorySize) │    │
│  │                                                                      │    │
│  │  LogRoll: Enqueue log, trim if over capacity                        │    │
│  │  GetRollHistory: Return from queue as list                          │    │
│  │  GetRollsByContext: Filter by prefix                                │    │
│  │  ClearHistory: Clear queue                                          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Roll Context Hierarchy

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       ROLL CONTEXT HIERARCHY                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  COMBAT CONTEXTS                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  Combat:Attack      → Attack roll to determine hit                  │    │
│  │  Combat:Damage      → Damage roll after successful hit              │    │
│  │  Combat:Defense     → Defense roll to avoid or mitigate             │    │
│  │  Combat:Initiative  → Initiative roll for turn order                │    │
│  │  Combat:Resolve     → Resolution roll (e.g., contested grapple)     │    │
│  │                                                                      │    │
│  │  Query: GetRollsByContext("Combat:") returns ALL combat rolls       │    │
│  │  Query: GetRollsByContext("Combat:Attack") returns attack rolls only│    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  SKILL CONTEXTS                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  Skill:Acrobatics   → RollContexts.Skill("Acrobatics")              │    │
│  │  Skill:Stealth      → RollContexts.Skill("Stealth")                 │    │
│  │  Skill:Lockpicking  → RollContexts.Skill("Lockpicking")             │    │
│  │  Skill:Perception   → RollContexts.Skill("Perception")              │    │
│  │  Skill:*            → Any skill-based roll                          │    │
│  │                                                                      │    │
│  │  Query: GetRollsByContext("Skill:") returns ALL skill rolls         │    │
│  │  Query: GetRollsByContext("Skill:Stealth") returns Stealth only     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  DIALOGUE CONTEXTS                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  Dialogue:Persuasion   → RollContexts.Dialogue("Persuasion")        │    │
│  │  Dialogue:Intimidation → RollContexts.Dialogue("Intimidation")      │    │
│  │  Dialogue:Deception    → RollContexts.Dialogue("Deception")         │    │
│  │  Dialogue:Insight      → RollContexts.Dialogue("Insight")           │    │
│  │                                                                      │    │
│  │  Query: GetRollsByContext("Dialogue:") returns ALL dialogue rolls   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  CRAFTING CONTEXTS                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  Crafting:Forge     → RollContexts.Crafting("Forge")                │    │
│  │  Crafting:Alchemy   → RollContexts.Crafting("Alchemy")              │    │
│  │  Crafting:Enchant   → RollContexts.Crafting("Enchant")              │    │
│  │                                                                      │    │
│  │  Query: GetRollsByContext("Crafting:") returns ALL crafting rolls   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  SPECIAL CONTEXTS                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  Contested:*        → Contested check rolls                         │    │
│  │  Extended:*         → Extended check round rolls                    │    │
│  │  Random:*           → Random encounter or event rolls               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Query Example Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         QUERY EXAMPLE FLOW                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  STORED ROLL HISTORY (most recent at bottom):                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  [0] Context: "Skill:Stealth",     Net: 2, Fumble: false            │    │
│  │  [1] Context: "Combat:Attack",     Net: 3, Fumble: false            │    │
│  │  [2] Context: "Combat:Damage",     Net: 0, Fumble: false (sum=14)   │    │
│  │  [3] Context: "Skill:Perception",  Net: 0, Fumble: true             │    │
│  │  [4] Context: "Dialogue:Persuade", Net: 5, Critical: true           │    │
│  │  [5] Context: "Combat:Attack",     Net: 1, Fumble: false            │    │
│  │  [6] Context: "Skill:Stealth",     Net: 4, Fumble: false            │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  QUERY: GetRollHistory(3)                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Returns 3 most recent rolls:                                       │    │
│  │  [4] Dialogue:Persuade, Net: 5, Critical                            │    │
│  │  [5] Combat:Attack, Net: 1                                          │    │
│  │  [6] Skill:Stealth, Net: 4                                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  QUERY: GetRollsByContext("Combat:")                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Returns all rolls with "Combat:" prefix:                           │    │
│  │  [1] Combat:Attack, Net: 3                                          │    │
│  │  [2] Combat:Damage, Net: 0                                          │    │
│  │  [5] Combat:Attack, Net: 1                                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  QUERY: GetRollsByContext("Skill:Stealth")                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Returns rolls with exact "Skill:Stealth" prefix:                   │    │
│  │  [0] Skill:Stealth, Net: 2                                          │    │
│  │  [6] Skill:Stealth, Net: 4                                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Records/                                                            │    │
│  │  └── DiceRollLog.cs          ←── NEW (complete roll metadata)       │    │
│  │                                                                      │    │
│  │  Constants/                                                          │    │
│  │  └── RollContexts.cs         ←── NEW (context constants + helpers)  │    │
│  │                                                                      │    │
│  │  Interfaces/                                                         │    │
│  │  └── IDiceRollLogger.cs      ←── NEW (logging + query contract)     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ implements                                │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Services/                                                           │    │
│  │  ├── InMemoryDiceRollLogger.cs ←── NEW (in-memory implementation)  │    │
│  │  └── DiceService.cs            ←── MODIFIED (calls logger)         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  DEPENDENCY INJECTION                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  services.AddSingleton<IDiceRollLogger, InMemoryDiceRollLogger>();  │    │
│  │                                                                      │    │
│  │  // DiceService receives IDiceRollLogger via constructor            │    │
│  │  services.AddScoped<DiceService>();                                 │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. DiceRollLog Record

### 4.1 Record Definition

**File:** `src/Core/RuneAndRust.Domain/Records/DiceRollLog.cs`

```csharp
namespace RuneAndRust.Domain.Records;

/// <summary>
/// Represents a complete log entry for a dice roll with full metadata.
/// </summary>
/// <remarks>
/// <para>
/// Immutable record capturing all details of a dice roll for history,
/// debugging, replay, and analytics purposes.
/// </para>
/// <para>
/// Key Features:
/// <list type="bullet">
///   <item><description>Unique RollId for identification</description></item>
///   <item><description>Timestamp for ordering and time-based queries</description></item>
///   <item><description>Seed for deterministic replay</description></item>
///   <item><description>Context string for categorized filtering</description></item>
///   <item><description>Actor/Target IDs for attribution</description></item>
///   <item><description>Fumble/Critical flags for special outcome tracking</description></item>
/// </list>
/// </para>
/// </remarks>
public record DiceRollLog
{
    /// <summary>
    /// Unique identifier for this roll.
    /// </summary>
    /// <remarks>
    /// Generated at log creation time. Used to reference specific rolls.
    /// </remarks>
    public Guid RollId { get; init; }

    /// <summary>
    /// UTC timestamp when the roll was made.
    /// </summary>
    /// <remarks>
    /// Used for chronological ordering and time-based queries.
    /// </remarks>
    public DateTime Timestamp { get; init; }

    /// <summary>
    /// RNG seed used for this roll.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Combined with PoolSize, allows deterministic reproduction of the roll.
    /// </para>
    /// <para>
    /// For debugging and replay functionality.
    /// </para>
    /// </remarks>
    public int Seed { get; init; }

    /// <summary>
    /// Number of dice in the pool.
    /// </summary>
    /// <remarks>
    /// Combined with Seed, allows deterministic reproduction.
    /// </remarks>
    public int PoolSize { get; init; }

    /// <summary>
    /// Individual die results.
    /// </summary>
    /// <remarks>
    /// Ordered list of each die's value in the roll.
    /// Includes explosion dice if any occurred.
    /// </remarks>
    public IReadOnlyList<int> Results { get; init; } = Array.Empty<int>();

    /// <summary>
    /// Net successes (successes - botches, minimum 0).
    /// </summary>
    /// <remarks>
    /// The primary success-counting metric for skill checks.
    /// </remarks>
    public int NetSuccesses { get; init; }

    /// <summary>
    /// Context string identifying the type of roll.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Uses hierarchical format with colon separator:
    /// <list type="bullet">
    ///   <item><description>"Combat:Attack" - Attack roll</description></item>
    ///   <item><description>"Skill:Acrobatics" - Skill check</description></item>
    ///   <item><description>"Dialogue:Persuasion" - Social roll</description></item>
    ///   <item><description>"Crafting:Forge" - Crafting roll</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// Use <see cref="RollContexts"/> constants for standard contexts.
    /// </para>
    /// </remarks>
    public string Context { get; init; } = string.Empty;

    /// <summary>
    /// ID of the actor making the roll (optional).
    /// </summary>
    /// <remarks>
    /// <para>
    /// Typically the player or NPC character ID.
    /// </para>
    /// <para>
    /// Null for rolls not associated with a specific actor (e.g., random events).
    /// </para>
    /// </remarks>
    public Guid? ActorId { get; init; }

    /// <summary>
    /// ID of the target of the roll (optional).
    /// </summary>
    /// <remarks>
    /// <para>
    /// For attack rolls, the target being attacked.
    /// For contested checks, the opposing party.
    /// </para>
    /// <para>
    /// Null for self-targeted or non-targeted rolls.
    /// </para>
    /// </remarks>
    public Guid? TargetId { get; init; }

    /// <summary>
    /// Whether the roll was a fumble.
    /// </summary>
    /// <remarks>
    /// True when 0 successes AND at least 1 botch.
    /// </remarks>
    public bool IsFumble { get; init; }

    /// <summary>
    /// Whether the roll was a critical success.
    /// </summary>
    /// <remarks>
    /// True when net successes >= 5.
    /// </remarks>
    public bool IsCriticalSuccess { get; init; }

    /// <summary>
    /// Total successes before botch subtraction.
    /// </summary>
    /// <remarks>
    /// Count of dice showing 8, 9, or 10.
    /// </remarks>
    public int TotalSuccesses { get; init; }

    /// <summary>
    /// Total botches.
    /// </summary>
    /// <remarks>
    /// Count of dice showing 1.
    /// </remarks>
    public int TotalBotches { get; init; }

    /// <summary>
    /// Raw sum of all dice values.
    /// </summary>
    /// <remarks>
    /// Preserved for damage rolls and sum-based calculations.
    /// </remarks>
    public int RawTotal { get; init; }

    /// <summary>
    /// Creates a log entry from a DiceRollResult and context.
    /// </summary>
    /// <param name="rollResult">The dice roll result to log.</param>
    /// <param name="seed">The RNG seed used for the roll.</param>
    /// <param name="context">The roll context string.</param>
    /// <param name="actorId">Optional actor ID.</param>
    /// <param name="targetId">Optional target ID.</param>
    /// <returns>A new DiceRollLog entry.</returns>
    public static DiceRollLog FromRollResult(
        DiceRollResult rollResult,
        int seed,
        string context,
        Guid? actorId = null,
        Guid? targetId = null)
    {
        return new DiceRollLog
        {
            RollId = Guid.NewGuid(),
            Timestamp = DateTime.UtcNow,
            Seed = seed,
            PoolSize = rollResult.Pool.Count,
            Results = rollResult.Rolls.Concat(rollResult.ExplosionRolls).ToList().AsReadOnly(),
            NetSuccesses = rollResult.NetSuccesses,
            TotalSuccesses = rollResult.TotalSuccesses,
            TotalBotches = rollResult.TotalBotches,
            RawTotal = rollResult.RawTotal,
            Context = context,
            ActorId = actorId,
            TargetId = targetId,
            IsFumble = rollResult.IsFumble,
            IsCriticalSuccess = rollResult.IsCriticalSuccess
        };
    }

    /// <summary>
    /// Returns a formatted string showing the roll summary.
    /// </summary>
    /// <example>
    /// "[Skill:Acrobatics] 5d10: [8,9,1,4,3] → 1 net (2S-1B)"
    /// "[Combat:Attack] 4d10: [10,8,8,5] → 3 net [CRITICAL!]"
    /// </example>
    public override string ToString()
    {
        var resultsStr = $"[{string.Join(",", Results)}]";
        var outcomeStr = $"{NetSuccesses} net ({TotalSuccesses}S-{TotalBotches}B)";

        var result = $"[{Context}] {PoolSize}d10: {resultsStr} → {outcomeStr}";

        if (IsFumble)
            result += " [FUMBLE!]";
        else if (IsCriticalSuccess)
            result += " [CRITICAL!]";

        return result;
    }

    /// <summary>
    /// Returns a detailed multi-line string for debugging.
    /// </summary>
    public string ToDetailedString()
    {
        return $"""
            Roll ID: {RollId}
            Timestamp: {Timestamp:O}
            Context: {Context}
            Pool Size: {PoolSize}d10
            Seed: {Seed}
            Results: [{string.Join(", ", Results)}]
            Total Successes: {TotalSuccesses}
            Total Botches: {TotalBotches}
            Net Successes: {NetSuccesses}
            Raw Total: {RawTotal}
            Is Fumble: {IsFumble}
            Is Critical: {IsCriticalSuccess}
            Actor ID: {ActorId?.ToString() ?? "None"}
            Target ID: {TargetId?.ToString() ?? "None"}
            """;
    }
}
```

### 4.2 Property Summary Table

| Property | Type | Description | Required |
|----------|------|-------------|----------|
| `RollId` | `Guid` | Unique identifier | Yes |
| `Timestamp` | `DateTime` | UTC time of roll | Yes |
| `Seed` | `int` | RNG seed for replay | Yes |
| `PoolSize` | `int` | Number of dice | Yes |
| `Results` | `IReadOnlyList<int>` | Individual die values | Yes |
| `NetSuccesses` | `int` | Successes - Botches | Yes |
| `TotalSuccesses` | `int` | Raw success count | Yes |
| `TotalBotches` | `int` | Raw botch count | Yes |
| `RawTotal` | `int` | Sum of dice | Yes |
| `Context` | `string` | Roll type identifier | Yes |
| `ActorId` | `Guid?` | Rolling entity | No |
| `TargetId` | `Guid?` | Target entity | No |
| `IsFumble` | `bool` | Fumble flag | Yes |
| `IsCriticalSuccess` | `bool` | Critical flag | Yes |

---

## 5. RollContexts Static Class

### 5.1 Constants Definition

**File:** `src/Core/RuneAndRust.Domain/Constants/RollContexts.cs`

```csharp
namespace RuneAndRust.Domain.Constants;

/// <summary>
/// Standard context strings for categorizing dice rolls.
/// </summary>
/// <remarks>
/// <para>
/// Context strings use a hierarchical format with colon separators:
/// [Category]:[Subcategory]
/// </para>
/// <para>
/// This allows filtering by:
/// <list type="bullet">
///   <item><description>Full context: "Combat:Attack" returns only attack rolls</description></item>
///   <item><description>Category prefix: "Combat:" returns all combat rolls</description></item>
///   <item><description>Empty prefix: "" returns all rolls</description></item>
/// </list>
/// </para>
/// <para>
/// Use the helper methods <see cref="Skill"/>, <see cref="Dialogue"/>, and
/// <see cref="Crafting"/> to generate context strings for dynamic values.
/// </para>
/// </remarks>
public static class RollContexts
{
    #region Combat Contexts

    /// <summary>
    /// Attack roll to determine if a hit lands.
    /// </summary>
    /// <remarks>
    /// Uses success-counting to determine hit quality.
    /// </remarks>
    public const string CombatAttack = "Combat:Attack";

    /// <summary>
    /// Damage roll after a successful hit.
    /// </summary>
    /// <remarks>
    /// Uses sum-based mechanics (RawTotal) for damage value.
    /// </remarks>
    public const string CombatDamage = "Combat:Damage";

    /// <summary>
    /// Defense roll to avoid or mitigate an attack.
    /// </summary>
    public const string CombatDefense = "Combat:Defense";

    /// <summary>
    /// Initiative roll for turn order determination.
    /// </summary>
    public const string CombatInitiative = "Combat:Initiative";

    /// <summary>
    /// Resolution roll for contested combat actions.
    /// </summary>
    /// <remarks>
    /// Used for grapple, shove, and similar maneuvers.
    /// </remarks>
    public const string CombatResolve = "Combat:Resolve";

    /// <summary>
    /// Prefix for all combat-related rolls.
    /// </summary>
    public const string CombatPrefix = "Combat:";

    #endregion

    #region Skill Contexts

    /// <summary>
    /// Prefix for all skill check rolls.
    /// </summary>
    /// <remarks>
    /// Combined with skill ID: "Skill:Acrobatics", "Skill:Stealth", etc.
    /// </remarks>
    public const string SkillPrefix = "Skill:";

    /// <summary>
    /// Generates a skill context string for the given skill ID.
    /// </summary>
    /// <param name="skillId">The skill identifier (e.g., "Acrobatics", "Stealth").</param>
    /// <returns>A context string in format "Skill:{skillId}".</returns>
    /// <example>
    /// RollContexts.Skill("Acrobatics") returns "Skill:Acrobatics"
    /// </example>
    public static string Skill(string skillId) => $"{SkillPrefix}{skillId}";

    #endregion

    #region Dialogue Contexts

    /// <summary>
    /// Prefix for all dialogue/social rolls.
    /// </summary>
    public const string DialoguePrefix = "Dialogue:";

    /// <summary>
    /// Persuasion dialogue roll.
    /// </summary>
    public const string DialoguePersuasion = "Dialogue:Persuasion";

    /// <summary>
    /// Intimidation dialogue roll.
    /// </summary>
    public const string DialogueIntimidation = "Dialogue:Intimidation";

    /// <summary>
    /// Deception dialogue roll.
    /// </summary>
    public const string DialogueDeception = "Dialogue:Deception";

    /// <summary>
    /// Insight (detecting lies/motives) dialogue roll.
    /// </summary>
    public const string DialogueInsight = "Dialogue:Insight";

    /// <summary>
    /// Generates a dialogue context string for the given type.
    /// </summary>
    /// <param name="type">The dialogue type (e.g., "Persuasion", "Barter").</param>
    /// <returns>A context string in format "Dialogue:{type}".</returns>
    /// <example>
    /// RollContexts.Dialogue("Barter") returns "Dialogue:Barter"
    /// </example>
    public static string Dialogue(string type) => $"{DialoguePrefix}{type}";

    #endregion

    #region Crafting Contexts

    /// <summary>
    /// Prefix for all crafting rolls.
    /// </summary>
    public const string CraftingPrefix = "Crafting:";

    /// <summary>
    /// Forge crafting roll.
    /// </summary>
    public const string CraftingForge = "Crafting:Forge";

    /// <summary>
    /// Alchemy crafting roll.
    /// </summary>
    public const string CraftingAlchemy = "Crafting:Alchemy";

    /// <summary>
    /// Enchantment crafting roll.
    /// </summary>
    public const string CraftingEnchant = "Crafting:Enchant";

    /// <summary>
    /// Generates a crafting context string for the given craft type.
    /// </summary>
    /// <param name="craftType">The craft type (e.g., "Forge", "Repair").</param>
    /// <returns>A context string in format "Crafting:{craftType}".</returns>
    /// <example>
    /// RollContexts.Crafting("Repair") returns "Crafting:Repair"
    /// </example>
    public static string Crafting(string craftType) => $"{CraftingPrefix}{craftType}";

    #endregion

    #region Special Contexts

    /// <summary>
    /// Prefix for contested check rolls.
    /// </summary>
    public const string ContestedPrefix = "Contested:";

    /// <summary>
    /// Generates a contested check context.
    /// </summary>
    /// <param name="checkType">Type of contested check.</param>
    /// <returns>A context string in format "Contested:{checkType}".</returns>
    public static string Contested(string checkType) => $"{ContestedPrefix}{checkType}";

    /// <summary>
    /// Prefix for extended check rolls.
    /// </summary>
    public const string ExtendedPrefix = "Extended:";

    /// <summary>
    /// Generates an extended check round context.
    /// </summary>
    /// <param name="checkType">Type of extended check.</param>
    /// <returns>A context string in format "Extended:{checkType}".</returns>
    public static string Extended(string checkType) => $"{ExtendedPrefix}{checkType}";

    /// <summary>
    /// Prefix for random event rolls.
    /// </summary>
    public const string RandomPrefix = "Random:";

    /// <summary>
    /// Random encounter roll.
    /// </summary>
    public const string RandomEncounter = "Random:Encounter";

    /// <summary>
    /// Random weather roll.
    /// </summary>
    public const string RandomWeather = "Random:Weather";

    /// <summary>
    /// Random loot roll.
    /// </summary>
    public const string RandomLoot = "Random:Loot";

    /// <summary>
    /// Default context for unspecified rolls.
    /// </summary>
    public const string Default = "General";

    #endregion

    #region Utility Methods

    /// <summary>
    /// Determines if a context string matches a given prefix.
    /// </summary>
    /// <param name="context">The context string to check.</param>
    /// <param name="prefix">The prefix to match against.</param>
    /// <returns>True if context starts with prefix (case-insensitive).</returns>
    /// <example>
    /// MatchesPrefix("Combat:Attack", "Combat:") returns true
    /// MatchesPrefix("Skill:Stealth", "Combat:") returns false
    /// </example>
    public static bool MatchesPrefix(string context, string prefix)
    {
        if (string.IsNullOrEmpty(prefix))
            return true;

        return context.StartsWith(prefix, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Extracts the category from a context string.
    /// </summary>
    /// <param name="context">The context string.</param>
    /// <returns>The category portion before the colon, or the full string if no colon.</returns>
    /// <example>
    /// GetCategory("Combat:Attack") returns "Combat"
    /// GetCategory("General") returns "General"
    /// </example>
    public static string GetCategory(string context)
    {
        var colonIndex = context.IndexOf(':');
        return colonIndex > 0 ? context[..colonIndex] : context;
    }

    /// <summary>
    /// Extracts the subcategory from a context string.
    /// </summary>
    /// <param name="context">The context string.</param>
    /// <returns>The subcategory portion after the colon, or empty string if no colon.</returns>
    /// <example>
    /// GetSubcategory("Combat:Attack") returns "Attack"
    /// GetSubcategory("General") returns ""
    /// </example>
    public static string GetSubcategory(string context)
    {
        var colonIndex = context.IndexOf(':');
        return colonIndex > 0 && colonIndex < context.Length - 1
            ? context[(colonIndex + 1)..]
            : string.Empty;
    }

    /// <summary>
    /// Validates that a context string follows the expected format.
    /// </summary>
    /// <param name="context">The context string to validate.</param>
    /// <returns>True if the context is valid (non-empty, no leading/trailing whitespace).</returns>
    public static bool IsValidContext(string context)
    {
        if (string.IsNullOrWhiteSpace(context))
            return false;

        return context == context.Trim();
    }

    #endregion
}
```

### 5.2 Context Constants Summary

| Constant | Value | Description |
|----------|-------|-------------|
| `CombatAttack` | "Combat:Attack" | Attack roll |
| `CombatDamage` | "Combat:Damage" | Damage roll |
| `CombatDefense` | "Combat:Defense" | Defense roll |
| `CombatInitiative` | "Combat:Initiative" | Initiative roll |
| `CombatResolve` | "Combat:Resolve" | Contested combat |
| `SkillPrefix` | "Skill:" | Skill check prefix |
| `DialoguePrefix` | "Dialogue:" | Dialogue roll prefix |
| `CraftingPrefix` | "Crafting:" | Crafting roll prefix |
| `ContestedPrefix` | "Contested:" | Contested check prefix |
| `ExtendedPrefix` | "Extended:" | Extended check prefix |
| `RandomPrefix` | "Random:" | Random event prefix |
| `Default` | "General" | Unspecified context |

### 5.3 Helper Methods Summary

| Method | Purpose | Example |
|--------|---------|---------|
| `Skill(string)` | Generate skill context | `Skill("Stealth")` → "Skill:Stealth" |
| `Dialogue(string)` | Generate dialogue context | `Dialogue("Barter")` → "Dialogue:Barter" |
| `Crafting(string)` | Generate crafting context | `Crafting("Repair")` → "Crafting:Repair" |
| `Contested(string)` | Generate contested context | `Contested("Grapple")` → "Contested:Grapple" |
| `Extended(string)` | Generate extended context | `Extended("Lockpick")` → "Extended:Lockpick" |
| `MatchesPrefix(string, string)` | Check prefix match | `MatchesPrefix("Combat:Attack", "Combat:")` → true |
| `GetCategory(string)` | Extract category | `GetCategory("Combat:Attack")` → "Combat" |
| `GetSubcategory(string)` | Extract subcategory | `GetSubcategory("Combat:Attack")` → "Attack" |
| `IsValidContext(string)` | Validate context | `IsValidContext("Combat:Attack")` → true |

---

## 6. IDiceRollLogger Interface

### 6.1 Interface Definition

**File:** `src/Core/RuneAndRust.Domain/Interfaces/IDiceRollLogger.cs`

```csharp
using RuneAndRust.Domain.Records;

namespace RuneAndRust.Domain.Interfaces;

/// <summary>
/// Interface for logging and querying dice rolls.
/// </summary>
/// <remarks>
/// <para>
/// Provides methods for:
/// <list type="bullet">
///   <item><description>Logging rolls with full metadata</description></item>
///   <item><description>Retrieving recent roll history</description></item>
///   <item><description>Filtering rolls by context prefix</description></item>
///   <item><description>Clearing roll history</description></item>
/// </list>
/// </para>
/// <para>
/// Implementations may store rolls in memory, database, or external systems.
/// </para>
/// </remarks>
public interface IDiceRollLogger
{
    /// <summary>
    /// Logs a dice roll with full metadata.
    /// </summary>
    /// <param name="log">The roll log entry to store.</param>
    /// <remarks>
    /// <para>
    /// Implementations should:
    /// <list type="bullet">
    ///   <item><description>Store the log for later retrieval</description></item>
    ///   <item><description>Enforce any storage limits (e.g., max history size)</description></item>
    ///   <item><description>Be thread-safe if used in concurrent contexts</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    void LogRoll(DiceRollLog log);

    /// <summary>
    /// Retrieves the most recent rolls from history.
    /// </summary>
    /// <param name="count">Maximum number of rolls to return (default 100).</param>
    /// <returns>
    /// A read-only list of roll logs, ordered from oldest to newest.
    /// Returns fewer than <paramref name="count"/> if history is smaller.
    /// </returns>
    /// <remarks>
    /// <para>
    /// The returned list is ordered chronologically (oldest first).
    /// </para>
    /// <para>
    /// If count exceeds available history, returns all available rolls.
    /// </para>
    /// </remarks>
    IReadOnlyList<DiceRollLog> GetRollHistory(int count = 100);

    /// <summary>
    /// Retrieves rolls matching a specific context prefix.
    /// </summary>
    /// <param name="contextPrefix">
    /// The context prefix to filter by (e.g., "Combat:", "Skill:Acrobatics").
    /// </param>
    /// <returns>
    /// A read-only list of matching roll logs, ordered from oldest to newest.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Context matching is case-insensitive.
    /// </para>
    /// <para>
    /// Examples:
    /// <list type="bullet">
    ///   <item><description>"Combat:" matches "Combat:Attack", "Combat:Damage", etc.</description></item>
    ///   <item><description>"Skill:Stealth" matches only "Skill:Stealth" rolls</description></item>
    ///   <item><description>"" (empty) matches all rolls</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    IReadOnlyList<DiceRollLog> GetRollsByContext(string contextPrefix);

    /// <summary>
    /// Clears all stored roll history.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Use with caution - this permanently removes all logged rolls.
    /// </para>
    /// <para>
    /// Useful for:
    /// <list type="bullet">
    ///   <item><description>Starting a new game session</description></item>
    ///   <item><description>Memory management</description></item>
    ///   <item><description>Testing scenarios</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    void ClearHistory();

    /// <summary>
    /// Gets the current number of rolls in history.
    /// </summary>
    int HistoryCount { get; }

    /// <summary>
    /// Gets the maximum number of rolls stored before oldest are discarded.
    /// </summary>
    int MaxHistorySize { get; }
}
```

### 6.2 Interface Method Summary

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `LogRoll` | `DiceRollLog log` | `void` | Store a roll entry |
| `GetRollHistory` | `int count = 100` | `IReadOnlyList<DiceRollLog>` | Get recent rolls |
| `GetRollsByContext` | `string contextPrefix` | `IReadOnlyList<DiceRollLog>` | Filter by context |
| `ClearHistory` | None | `void` | Clear all history |
| `HistoryCount` | Property | `int` | Current roll count |
| `MaxHistorySize` | Property | `int` | Maximum storage limit |

---

## 7. InMemoryDiceRollLogger Implementation

### 7.1 Implementation Definition

**File:** `src/Core/RuneAndRust.Application/Services/InMemoryDiceRollLogger.cs`

```csharp
using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.Records;

namespace RuneAndRust.Application.Services;

/// <summary>
/// In-memory implementation of <see cref="IDiceRollLogger"/>.
/// </summary>
/// <remarks>
/// <para>
/// Stores roll history in a thread-safe queue with a configurable maximum size.
/// When the limit is reached, oldest rolls are automatically discarded.
/// </para>
/// <para>
/// Suitable for:
/// <list type="bullet">
///   <item><description>Single-session game play</description></item>
///   <item><description>Development and testing</description></item>
///   <item><description>Scenarios where persistence is not required</description></item>
/// </list>
/// </para>
/// <para>
/// For persistent storage, implement a database-backed version of
/// <see cref="IDiceRollLogger"/> in a future version.
/// </para>
/// </remarks>
public class InMemoryDiceRollLogger : IDiceRollLogger
{
    private readonly ConcurrentQueue<DiceRollLog> _rollHistory = new();
    private readonly ILogger<InMemoryDiceRollLogger> _logger;
    private readonly object _trimLock = new();

    /// <summary>
    /// Default maximum history size.
    /// </summary>
    public const int DefaultMaxHistorySize = 1000;

    /// <summary>
    /// Gets the maximum number of rolls stored before oldest are discarded.
    /// </summary>
    public int MaxHistorySize { get; }

    /// <summary>
    /// Gets the current number of rolls in history.
    /// </summary>
    public int HistoryCount => _rollHistory.Count;

    /// <summary>
    /// Creates a new in-memory dice roll logger.
    /// </summary>
    /// <param name="logger">Logger for diagnostics.</param>
    /// <param name="maxHistorySize">Maximum rolls to retain (default 1000).</param>
    public InMemoryDiceRollLogger(
        ILogger<InMemoryDiceRollLogger> logger,
        int maxHistorySize = DefaultMaxHistorySize)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        MaxHistorySize = maxHistorySize > 0 ? maxHistorySize : DefaultMaxHistorySize;

        _logger.LogInformation(
            "InMemoryDiceRollLogger initialized with max history size: {MaxSize}",
            MaxHistorySize);
    }

    /// <summary>
    /// Logs a dice roll with full metadata.
    /// </summary>
    /// <param name="log">The roll log entry to store.</param>
    public void LogRoll(DiceRollLog log)
    {
        ArgumentNullException.ThrowIfNull(log);

        _rollHistory.Enqueue(log);

        _logger.LogDebug(
            "Logged roll: {Context} → {Net} net ({Successes}S-{Botches}B){Special}",
            log.Context,
            log.NetSuccesses,
            log.TotalSuccesses,
            log.TotalBotches,
            log.IsFumble ? " [FUMBLE]" : log.IsCriticalSuccess ? " [CRITICAL]" : "");

        // Trim if over capacity
        TrimIfNeeded();
    }

    /// <summary>
    /// Retrieves the most recent rolls from history.
    /// </summary>
    /// <param name="count">Maximum number of rolls to return (default 100).</param>
    /// <returns>A read-only list of roll logs, ordered oldest to newest.</returns>
    public IReadOnlyList<DiceRollLog> GetRollHistory(int count = 100)
    {
        if (count <= 0)
            return Array.Empty<DiceRollLog>();

        var allRolls = _rollHistory.ToArray();
        var startIndex = Math.Max(0, allRolls.Length - count);
        var result = allRolls.Skip(startIndex).ToList();

        _logger.LogDebug("Retrieved {Count} rolls from history", result.Count);

        return result.AsReadOnly();
    }

    /// <summary>
    /// Retrieves rolls matching a specific context prefix.
    /// </summary>
    /// <param name="contextPrefix">The context prefix to filter by.</param>
    /// <returns>A read-only list of matching roll logs, ordered oldest to newest.</returns>
    public IReadOnlyList<DiceRollLog> GetRollsByContext(string contextPrefix)
    {
        var result = _rollHistory
            .Where(log => RollContexts.MatchesPrefix(log.Context, contextPrefix))
            .ToList();

        _logger.LogDebug(
            "Retrieved {Count} rolls matching context prefix '{Prefix}'",
            result.Count, contextPrefix);

        return result.AsReadOnly();
    }

    /// <summary>
    /// Clears all stored roll history.
    /// </summary>
    public void ClearHistory()
    {
        var count = _rollHistory.Count;

        // Drain the queue
        while (_rollHistory.TryDequeue(out _)) { }

        _logger.LogInformation("Cleared {Count} rolls from history", count);
    }

    /// <summary>
    /// Trims the history if it exceeds the maximum size.
    /// </summary>
    private void TrimIfNeeded()
    {
        if (_rollHistory.Count <= MaxHistorySize)
            return;

        lock (_trimLock)
        {
            var trimCount = 0;
            while (_rollHistory.Count > MaxHistorySize && _rollHistory.TryDequeue(out _))
            {
                trimCount++;
            }

            if (trimCount > 0)
            {
                _logger.LogDebug("Trimmed {Count} oldest rolls from history", trimCount);
            }
        }
    }

    /// <summary>
    /// Gets all rolls that were fumbles.
    /// </summary>
    /// <returns>All fumble rolls in history.</returns>
    public IReadOnlyList<DiceRollLog> GetFumbles()
    {
        return _rollHistory
            .Where(log => log.IsFumble)
            .ToList()
            .AsReadOnly();
    }

    /// <summary>
    /// Gets all rolls that were critical successes.
    /// </summary>
    /// <returns>All critical success rolls in history.</returns>
    public IReadOnlyList<DiceRollLog> GetCriticalSuccesses()
    {
        return _rollHistory
            .Where(log => log.IsCriticalSuccess)
            .ToList()
            .AsReadOnly();
    }

    /// <summary>
    /// Gets rolls for a specific actor.
    /// </summary>
    /// <param name="actorId">The actor's ID.</param>
    /// <returns>All rolls by the specified actor.</returns>
    public IReadOnlyList<DiceRollLog> GetRollsByActor(Guid actorId)
    {
        return _rollHistory
            .Where(log => log.ActorId == actorId)
            .ToList()
            .AsReadOnly();
    }

    /// <summary>
    /// Gets rolls within a time range.
    /// </summary>
    /// <param name="start">Start time (inclusive).</param>
    /// <param name="end">End time (inclusive).</param>
    /// <returns>Rolls within the time range.</returns>
    public IReadOnlyList<DiceRollLog> GetRollsByTimeRange(DateTime start, DateTime end)
    {
        return _rollHistory
            .Where(log => log.Timestamp >= start && log.Timestamp <= end)
            .ToList()
            .AsReadOnly();
    }

    /// <summary>
    /// Gets aggregate statistics for the roll history.
    /// </summary>
    /// <returns>A summary of roll statistics.</returns>
    public RollStatistics GetStatistics()
    {
        var rolls = _rollHistory.ToArray();

        if (rolls.Length == 0)
        {
            return new RollStatistics(
                TotalRolls: 0,
                TotalFumbles: 0,
                TotalCriticals: 0,
                AverageNetSuccesses: 0,
                FumbleRate: 0,
                CriticalRate: 0);
        }

        var totalFumbles = rolls.Count(r => r.IsFumble);
        var totalCriticals = rolls.Count(r => r.IsCriticalSuccess);
        var averageNet = rolls.Average(r => r.NetSuccesses);

        return new RollStatistics(
            TotalRolls: rolls.Length,
            TotalFumbles: totalFumbles,
            TotalCriticals: totalCriticals,
            AverageNetSuccesses: averageNet,
            FumbleRate: (double)totalFumbles / rolls.Length,
            CriticalRate: (double)totalCriticals / rolls.Length);
    }
}

/// <summary>
/// Aggregate statistics for roll history.
/// </summary>
/// <param name="TotalRolls">Total number of rolls.</param>
/// <param name="TotalFumbles">Number of fumble rolls.</param>
/// <param name="TotalCriticals">Number of critical success rolls.</param>
/// <param name="AverageNetSuccesses">Average net successes across all rolls.</param>
/// <param name="FumbleRate">Fumble rate as a decimal (0-1).</param>
/// <param name="CriticalRate">Critical success rate as a decimal (0-1).</param>
public record RollStatistics(
    int TotalRolls,
    int TotalFumbles,
    int TotalCriticals,
    double AverageNetSuccesses,
    double FumbleRate,
    double CriticalRate);
```

### 7.2 Implementation Features

| Feature | Description |
|---------|-------------|
| Thread-safe | Uses `ConcurrentQueue` for concurrent access |
| Auto-trim | Automatically discards oldest rolls when limit reached |
| Configurable size | `MaxHistorySize` parameter (default 1000) |
| Bonus methods | `GetFumbles()`, `GetCriticalSuccesses()`, `GetRollsByActor()` |
| Statistics | `GetStatistics()` returns aggregate roll data |

---

## 8. DiceService Integration

### 8.1 Updated DiceService

**File:** `src/Core/RuneAndRust.Application/Services/DiceService.cs`

The `DiceService` must be updated to integrate with `IDiceRollLogger`. Key changes:

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Records;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Core dice rolling service with integrated roll logging.
/// </summary>
public class DiceService : IDiceService
{
    private readonly IRandomProvider _randomProvider;
    private readonly ILogger<DiceService> _logger;
    private readonly IGameEventLogger? _eventLogger;
    private readonly IDiceRollLogger? _rollLogger;

    /// <summary>
    /// Creates a new DiceService with optional roll logging.
    /// </summary>
    /// <param name="randomProvider">Random number provider.</param>
    /// <param name="logger">Logger for diagnostics.</param>
    /// <param name="eventLogger">Optional game event logger.</param>
    /// <param name="rollLogger">Optional dice roll logger for history tracking.</param>
    public DiceService(
        IRandomProvider randomProvider,
        ILogger<DiceService> logger,
        IGameEventLogger? eventLogger = null,
        IDiceRollLogger? rollLogger = null)
    {
        _randomProvider = randomProvider ?? throw new ArgumentNullException(nameof(randomProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _eventLogger = eventLogger;
        _rollLogger = rollLogger;

        _logger.LogInformation(
            "DiceService initialized with roll logging: {HasLogger}",
            _rollLogger != null);
    }

    /// <summary>
    /// Rolls a dice pool with optional context and actor information.
    /// </summary>
    /// <param name="pool">The dice pool to roll.</param>
    /// <param name="advantageType">Advantage/disadvantage type.</param>
    /// <param name="context">Roll context for logging (default: General).</param>
    /// <param name="actorId">Optional actor ID for attribution.</param>
    /// <param name="targetId">Optional target ID for attribution.</param>
    /// <returns>The complete roll result.</returns>
    public DiceRollResult Roll(
        DicePool pool,
        AdvantageType advantageType = AdvantageType.Normal,
        string context = RollContexts.Default,
        Guid? actorId = null,
        Guid? targetId = null)
    {
        _logger.LogDebug("Rolling {Pool} with {AdvantageType}, context: {Context}",
            pool, advantageType, context);

        // Capture seed before rolling
        var seed = _randomProvider.GetCurrentSeed();

        DiceRollResult result;

        if (advantageType == AdvantageType.Normal)
        {
            result = RollOnce(pool, advantageType);
        }
        else
        {
            // Roll twice for advantage/disadvantage
            var roll1 = RollOnce(pool, advantageType);
            var roll2 = RollOnce(pool, advantageType);

            // Compare NetSuccesses for selection
            var allTotals = new[] { roll1.NetSuccesses, roll2.NetSuccesses };
            var selectedIndex = advantageType == AdvantageType.Advantage
                ? (roll1.NetSuccesses >= roll2.NetSuccesses ? 0 : 1)
                : (roll1.NetSuccesses <= roll2.NetSuccesses ? 0 : 1);

            var selectedRoll = selectedIndex == 0 ? roll1 : roll2;

            result = new DiceRollResult(
                pool,
                selectedRoll.Rolls,
                advantageType,
                selectedRoll.ExplosionRolls,
                allTotals,
                selectedIndex);
        }

        // Log the roll
        LogRoll(result, seed, context, actorId, targetId);

        return result;
    }

    /// <summary>
    /// Logs the roll to both event logger and roll history.
    /// </summary>
    private void LogRoll(
        DiceRollResult result,
        int seed,
        string context,
        Guid? actorId,
        Guid? targetId)
    {
        // Log to roll history
        if (_rollLogger != null)
        {
            var rollLog = DiceRollLog.FromRollResult(result, seed, context, actorId, targetId);
            _rollLogger.LogRoll(rollLog);
        }

        // Log to event logger (existing behavior)
        _eventLogger?.LogDice("DiceRolled", $"{result.Pool} → {result.NetSuccesses} net successes",
            data: new Dictionary<string, object>
            {
                ["pool"] = result.Pool.ToString(),
                ["rolls"] = result.Rolls.ToArray(),
                ["totalSuccesses"] = result.TotalSuccesses,
                ["totalBotches"] = result.TotalBotches,
                ["netSuccesses"] = result.NetSuccesses,
                ["isFumble"] = result.IsFumble,
                ["isCriticalSuccess"] = result.IsCriticalSuccess,
                ["rawTotal"] = result.RawTotal,
                ["advantageType"] = result.AdvantageType.ToString(),
                ["context"] = context
            });

        _logger.LogInformation(
            "Roll [{Context}] {Pool}: {Net} net ({Successes}S-{Botches}B){Special}",
            context,
            result.Pool,
            result.NetSuccesses,
            result.TotalSuccesses,
            result.TotalBotches,
            result.IsFumble ? " [FUMBLE]" : result.IsCriticalSuccess ? " [CRITICAL]" : "");
    }

    // ... rest of existing DiceService implementation
}
```

### 8.2 Method Signature Changes

| Method | Before | After |
|--------|--------|-------|
| `Roll(DicePool, AdvantageType)` | Two params | Five params: `pool`, `advantageType`, `context`, `actorId`, `targetId` |
| Constructor | No `IDiceRollLogger` | Optional `IDiceRollLogger` parameter |

### 8.3 Backward Compatibility

The new parameters have default values, so existing code continues to work:

```csharp
// Old code still works
var result = _diceService.Roll(pool);

// New code can provide context
var result = _diceService.Roll(pool, context: RollContexts.CombatAttack);

// Full usage
var result = _diceService.Roll(
    pool,
    AdvantageType.Normal,
    RollContexts.Skill("Acrobatics"),
    playerId,
    targetId);
```

---

## 9. Data Model Changes

### 9.1 New Types Summary

| Type | Layer | File | Description |
|------|-------|------|-------------|
| `DiceRollLog` | Domain | `Records/DiceRollLog.cs` | Complete roll metadata record |
| `RollContexts` | Domain | `Constants/RollContexts.cs` | Context constants and helpers |
| `IDiceRollLogger` | Domain | `Interfaces/IDiceRollLogger.cs` | Logging/query interface |
| `InMemoryDiceRollLogger` | Application | `Services/InMemoryDiceRollLogger.cs` | In-memory implementation |
| `RollStatistics` | Application | `Services/InMemoryDiceRollLogger.cs` | Statistics record |

### 9.2 Modified Types Summary

| Type | Layer | File | Changes |
|------|-------|------|---------|
| `DiceService` | Application | `Services/DiceService.cs` | Added `IDiceRollLogger` integration, new Roll parameters |

### 9.3 Dependency Injection Registration

```csharp
// In DI configuration
services.AddSingleton<IDiceRollLogger, InMemoryDiceRollLogger>();
services.AddScoped<DiceService>();
```

---

## 10. Configuration

### 10.1 No New Configuration Files

v0.15.0e does not introduce new configuration files. The `InMemoryDiceRollLogger` uses compile-time defaults.

### 10.2 Configuration Constants

| Constant | Value | Description |
|----------|-------|-------------|
| `DefaultMaxHistorySize` | 1000 | Maximum rolls stored in memory |

### 10.3 Future Configuration (Deferred)

A future version may introduce `dice-logging.json`:

```json
{
  "$schema": "./schemas/dice-logging.schema.json",
  "maxHistorySize": 1000,
  "persistToDisk": false,
  "persistPath": "./logs/dice-rolls.json",
  "enableStatistics": true
}
```

This is documented for context but is **out of scope** for v0.15.0e.

---

## 11. Commands

### 11.1 No Command Changes

v0.15.0e does not modify user-facing commands. Roll logging operates transparently.

### 11.2 Potential Future Commands (Deferred)

A future version may add:
- `rollhistory` - View recent roll history
- `rollstats` - View roll statistics
- `clearrolls` - Clear roll history

These are **out of scope** for v0.15.0e.

---

## 12. User-Facing Changes

### 12.1 No Visible Changes

v0.15.0e operates entirely behind the scenes. Users will not see any changes in the command output or game behavior.

### 12.2 Debugging Benefits

Developers and advanced users gain:
- Roll history inspection via debug tools
- Seed-based roll reproduction for bug reports
- Context-filtered roll analysis

---

## 13. Logging Specifications

### 13.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `InMemoryDiceRollLogger` | Information | Initialization, clear history |
| `InMemoryDiceRollLogger` | Debug | Roll logged, history retrieval, trim |
| `DiceService` | Information | Roll result with context |
| `DiceService` | Debug | Roll initiation |

### 13.2 Log Message Formats

```
[Information] InMemoryDiceRollLogger initialized with max history size: 1000
[Debug] Logged roll: Combat:Attack → 3 net (4S-1B)
[Debug] Logged roll: Skill:Stealth → 0 net (0S-1B) [FUMBLE]
[Debug] Retrieved 50 rolls from history
[Debug] Retrieved 12 rolls matching context prefix 'Combat:'
[Debug] Trimmed 5 oldest rolls from history
[Information] Cleared 1000 rolls from history
[Information] Roll [Combat:Attack] 5d10: 3 net (4S-1B)
[Information] Roll [Skill:Stealth] 4d10: 0 net (0S-1B) [FUMBLE]
```

---

## 14. Unit Testing Requirements

### 14.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Roll logging | 1 |
| History retrieval | 1 |
| Context filtering | 1 |
| Fumble/critical flags | 1 |
| History trimming | 1 |
| **Total** | **~5** |

### 14.2 Test Specifications

**File:** `tests/RuneAndRust.Application.UnitTests/Services/InMemoryDiceRollLoggerTests.cs`

```csharp
using Microsoft.Extensions.Logging;
using Moq;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Records;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class InMemoryDiceRollLoggerTests
{
    private Mock<ILogger<InMemoryDiceRollLogger>> _mockLogger = null!;
    private InMemoryDiceRollLogger _logger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<InMemoryDiceRollLogger>>();
        _logger = new InMemoryDiceRollLogger(_mockLogger.Object);
    }

    [Test]
    public void LogRoll_StoresRollWithCorrectData()
    {
        // Arrange
        var pool = new DicePool(5, DiceType.D10);
        var rolls = new[] { 8, 9, 1, 4, 3 };
        var diceResult = new DiceRollResult(pool, rolls);
        var rollLog = DiceRollLog.FromRollResult(
            diceResult,
            seed: 12345,
            context: RollContexts.CombatAttack,
            actorId: Guid.NewGuid());

        // Act
        _logger.LogRoll(rollLog);

        // Assert
        Assert.That(_logger.HistoryCount, Is.EqualTo(1));

        var history = _logger.GetRollHistory(1);
        Assert.That(history, Has.Count.EqualTo(1));
        Assert.That(history[0].Context, Is.EqualTo(RollContexts.CombatAttack));
        Assert.That(history[0].Seed, Is.EqualTo(12345));
        Assert.That(history[0].PoolSize, Is.EqualTo(5));
        Assert.That(history[0].NetSuccesses, Is.EqualTo(diceResult.NetSuccesses));
    }

    [Test]
    public void GetRollHistory_ReturnsRequestedCount()
    {
        // Arrange: Log 10 rolls
        for (int i = 0; i < 10; i++)
        {
            var pool = new DicePool(3, DiceType.D10);
            var rolls = new[] { 5, 6, 7 };
            var diceResult = new DiceRollResult(pool, rolls);
            var rollLog = DiceRollLog.FromRollResult(diceResult, seed: i, context: $"Test:{i}");
            _logger.LogRoll(rollLog);
        }

        // Act
        var history = _logger.GetRollHistory(5);

        // Assert
        Assert.That(history, Has.Count.EqualTo(5));
        // Should be the 5 most recent (oldest to newest: 5, 6, 7, 8, 9)
        Assert.That(history[0].Seed, Is.EqualTo(5));
        Assert.That(history[4].Seed, Is.EqualTo(9));
    }

    [Test]
    public void GetRollsByContext_FiltersCorrectly()
    {
        // Arrange
        var pool = new DicePool(3, DiceType.D10);
        var rolls = new[] { 8, 5, 3 };

        // Log rolls with different contexts
        _logger.LogRoll(DiceRollLog.FromRollResult(
            new DiceRollResult(pool, rolls), 1, RollContexts.CombatAttack));
        _logger.LogRoll(DiceRollLog.FromRollResult(
            new DiceRollResult(pool, rolls), 2, RollContexts.CombatDamage));
        _logger.LogRoll(DiceRollLog.FromRollResult(
            new DiceRollResult(pool, rolls), 3, RollContexts.Skill("Stealth")));
        _logger.LogRoll(DiceRollLog.FromRollResult(
            new DiceRollResult(pool, rolls), 4, RollContexts.CombatAttack));

        // Act
        var combatRolls = _logger.GetRollsByContext(RollContexts.CombatPrefix);
        var attackRolls = _logger.GetRollsByContext(RollContexts.CombatAttack);
        var skillRolls = _logger.GetRollsByContext(RollContexts.SkillPrefix);

        // Assert
        Assert.That(combatRolls, Has.Count.EqualTo(3));  // Attack, Damage, Attack
        Assert.That(attackRolls, Has.Count.EqualTo(2));  // Just attacks
        Assert.That(skillRolls, Has.Count.EqualTo(1));   // Just Stealth
    }

    [Test]
    public void LogRoll_StoresFumbleAndCriticalFlagsCorrectly()
    {
        // Arrange: Fumble roll (0 successes, 1+ botch)
        var pool = new DicePool(3, DiceType.D10);
        var fumbleRolls = new[] { 1, 4, 2 };  // 0S, 1B = fumble
        var fumbleResult = new DiceRollResult(pool, fumbleRolls);

        // Critical roll (5+ net successes)
        var criticalRolls = new[] { 8, 9, 10, 8, 9, 10 };  // 6S, 0B = critical
        var criticalPool = new DicePool(6, DiceType.D10);
        var criticalResult = new DiceRollResult(criticalPool, criticalRolls);

        // Act
        _logger.LogRoll(DiceRollLog.FromRollResult(fumbleResult, 1, "Test:Fumble"));
        _logger.LogRoll(DiceRollLog.FromRollResult(criticalResult, 2, "Test:Critical"));

        // Assert
        var fumbles = _logger.GetFumbles();
        var criticals = _logger.GetCriticalSuccesses();

        Assert.That(fumbles, Has.Count.EqualTo(1));
        Assert.That(fumbles[0].IsFumble, Is.True);
        Assert.That(fumbles[0].IsCriticalSuccess, Is.False);

        Assert.That(criticals, Has.Count.EqualTo(1));
        Assert.That(criticals[0].IsCriticalSuccess, Is.True);
        Assert.That(criticals[0].IsFumble, Is.False);
    }

    [Test]
    public void LogRoll_TrimsOldestWhenOverCapacity()
    {
        // Arrange: Create logger with small capacity
        var smallLogger = new InMemoryDiceRollLogger(_mockLogger.Object, maxHistorySize: 5);
        var pool = new DicePool(3, DiceType.D10);
        var rolls = new[] { 5, 6, 7 };

        // Act: Log 10 rolls (5 over capacity)
        for (int i = 0; i < 10; i++)
        {
            var diceResult = new DiceRollResult(pool, rolls);
            var rollLog = DiceRollLog.FromRollResult(diceResult, seed: i, context: $"Test:{i}");
            smallLogger.LogRoll(rollLog);
        }

        // Assert: Only 5 most recent remain
        Assert.That(smallLogger.HistoryCount, Is.EqualTo(5));

        var history = smallLogger.GetRollHistory(10);
        Assert.That(history, Has.Count.EqualTo(5));
        Assert.That(history[0].Seed, Is.EqualTo(5));  // Oldest remaining
        Assert.That(history[4].Seed, Is.EqualTo(9));  // Newest
    }
}
```

**File:** `tests/RuneAndRust.Domain.UnitTests/Records/DiceRollLogTests.cs`

```csharp
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Records;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.UnitTests.Records;

[TestFixture]
public class DiceRollLogTests
{
    [Test]
    public void FromRollResult_CreatesLogWithCorrectProperties()
    {
        // Arrange
        var pool = new DicePool(4, DiceType.D10);
        var rolls = new[] { 8, 1, 5, 10 };  // 2 successes, 1 botch = 1 net
        var diceResult = new DiceRollResult(pool, rolls);
        var actorId = Guid.NewGuid();
        var targetId = Guid.NewGuid();

        // Act
        var log = DiceRollLog.FromRollResult(
            diceResult,
            seed: 54321,
            context: RollContexts.CombatAttack,
            actorId: actorId,
            targetId: targetId);

        // Assert
        Assert.That(log.RollId, Is.Not.EqualTo(Guid.Empty));
        Assert.That(log.Timestamp, Is.LessThanOrEqualTo(DateTime.UtcNow));
        Assert.That(log.Seed, Is.EqualTo(54321));
        Assert.That(log.PoolSize, Is.EqualTo(4));
        Assert.That(log.Results, Is.EqualTo(rolls));
        Assert.That(log.NetSuccesses, Is.EqualTo(1));
        Assert.That(log.TotalSuccesses, Is.EqualTo(2));
        Assert.That(log.TotalBotches, Is.EqualTo(1));
        Assert.That(log.Context, Is.EqualTo(RollContexts.CombatAttack));
        Assert.That(log.ActorId, Is.EqualTo(actorId));
        Assert.That(log.TargetId, Is.EqualTo(targetId));
        Assert.That(log.IsFumble, Is.False);
        Assert.That(log.IsCriticalSuccess, Is.False);
    }

    [Test]
    public void ToString_FormatsCorrectly()
    {
        // Arrange
        var pool = new DicePool(3, DiceType.D10);
        var rolls = new[] { 8, 9, 1 };
        var diceResult = new DiceRollResult(pool, rolls);
        var log = DiceRollLog.FromRollResult(diceResult, 123, "Skill:Acrobatics");

        // Act
        var result = log.ToString();

        // Assert
        Assert.That(result, Does.Contain("[Skill:Acrobatics]"));
        Assert.That(result, Does.Contain("3d10"));
        Assert.That(result, Does.Contain("[8,9,1]"));
        Assert.That(result, Does.Contain("1 net"));
        Assert.That(result, Does.Contain("(2S-1B)"));
    }
}
```

**File:** `tests/RuneAndRust.Domain.UnitTests/Constants/RollContextsTests.cs`

```csharp
using RuneAndRust.Domain.Constants;

namespace RuneAndRust.Domain.UnitTests.Constants;

[TestFixture]
public class RollContextsTests
{
    [Test]
    public void Skill_GeneratesCorrectContext()
    {
        Assert.That(RollContexts.Skill("Acrobatics"), Is.EqualTo("Skill:Acrobatics"));
        Assert.That(RollContexts.Skill("Stealth"), Is.EqualTo("Skill:Stealth"));
    }

    [Test]
    public void Dialogue_GeneratesCorrectContext()
    {
        Assert.That(RollContexts.Dialogue("Persuasion"), Is.EqualTo("Dialogue:Persuasion"));
        Assert.That(RollContexts.Dialogue("Barter"), Is.EqualTo("Dialogue:Barter"));
    }

    [Test]
    public void MatchesPrefix_WorksCorrectly()
    {
        Assert.That(RollContexts.MatchesPrefix("Combat:Attack", "Combat:"), Is.True);
        Assert.That(RollContexts.MatchesPrefix("Combat:Attack", "Combat:Attack"), Is.True);
        Assert.That(RollContexts.MatchesPrefix("Combat:Attack", "Skill:"), Is.False);
        Assert.That(RollContexts.MatchesPrefix("Combat:Attack", ""), Is.True);
    }

    [Test]
    public void GetCategory_ExtractsCategoryCorrectly()
    {
        Assert.That(RollContexts.GetCategory("Combat:Attack"), Is.EqualTo("Combat"));
        Assert.That(RollContexts.GetCategory("Skill:Acrobatics"), Is.EqualTo("Skill"));
        Assert.That(RollContexts.GetCategory("General"), Is.EqualTo("General"));
    }

    [Test]
    public void GetSubcategory_ExtractsSubcategoryCorrectly()
    {
        Assert.That(RollContexts.GetSubcategory("Combat:Attack"), Is.EqualTo("Attack"));
        Assert.That(RollContexts.GetSubcategory("Skill:Acrobatics"), Is.EqualTo("Acrobatics"));
        Assert.That(RollContexts.GetSubcategory("General"), Is.EqualTo(""));
    }
}
```

---

## 15. Use Cases

### 15.1 UC-150e-001: Log Skill Check Roll

**Actor:** System (via SkillCheckService)
**Flow:** Skill check initiated → DiceService rolls → Roll logged → Result returned

**Details:**
1. Player initiates skill check (e.g., `check acrobatics moderate`)
2. SkillCheckService calls `DiceService.Roll()` with context `Skill:Acrobatics`
3. DiceService captures seed, rolls dice, creates result
4. DiceService creates `DiceRollLog` and calls `IDiceRollLogger.LogRoll()`
5. DiceService returns `DiceRollResult` to caller
6. Roll is now in history for later retrieval

### 15.2 UC-150e-002: Retrieve Roll History

**Actor:** Developer/Debug Tool
**Flow:** Request history → Logger returns rolls → Display to user

**Details:**
1. Debug tool calls `GetRollHistory(50)`
2. Logger returns 50 most recent rolls
3. Tool displays rolls with context, results, and flags
4. Developer can inspect roll details for debugging

### 15.3 UC-150e-003: Filter Rolls by Context

**Actor:** Developer/Analytics Tool
**Flow:** Request filtered rolls → Logger filters → Return matches

**Details:**
1. Analytics tool calls `GetRollsByContext("Combat:")`
2. Logger filters history for matching prefix
3. Tool receives all combat-related rolls
4. Tool can analyze combat roll statistics

### 15.4 UC-150e-004: Reproduce Roll for Bug Report

**Actor:** Player/Developer
**Flow:** Retrieve roll → Note seed and pool → Reproduce with same seed

**Details:**
1. Player reports unexpected roll behavior
2. Developer retrieves roll from history
3. Roll shows seed=12345, poolSize=5
4. Developer sets RNG seed to 12345, rolls 5d10
5. Identical results produced for debugging

---

## 16. Deliverable Checklist

### 16.1 Domain Layer

- [ ] `DiceRollLog.cs` created in `Domain/Records/`
- [ ] `RollContexts.cs` created in `Domain/Constants/`
- [ ] `IDiceRollLogger.cs` created in `Domain/Interfaces/`
- [ ] All combat context constants defined
- [ ] All skill context helpers implemented
- [ ] Context matching utilities implemented

### 16.2 Application Layer

- [ ] `InMemoryDiceRollLogger.cs` created
- [ ] `DiceService.cs` modified to use `IDiceRollLogger`
- [ ] Roll method signature updated with context parameters
- [ ] Statistics helper methods implemented
- [ ] Thread-safe implementation verified

### 16.3 Unit Tests

- [ ] `InMemoryDiceRollLoggerTests.cs` created (~3 tests)
- [ ] `DiceRollLogTests.cs` created (~2 tests)
- [ ] `RollContextsTests.cs` created (~4 tests)
- [ ] Roll logging verified
- [ ] History retrieval verified
- [ ] Context filtering verified
- [ ] Fumble/critical flags verified
- [ ] Trimming behavior verified

### 16.4 Documentation

- [ ] This design specification complete
- [ ] Code XML documentation complete

---

## 17. Acceptance Criteria

### 17.1 Functional

- [ ] All dice rolls are logged with complete metadata
- [ ] Roll history is retrievable by count
- [ ] Rolls can be filtered by context prefix
- [ ] Context prefix matching is case-insensitive
- [ ] Fumble flag is correctly stored
- [ ] Critical success flag is correctly stored
- [ ] Seed is captured for each roll
- [ ] Actor and target IDs are optionally stored
- [ ] History is trimmed when max size exceeded
- [ ] Oldest rolls are discarded during trimming
- [ ] Clear history removes all stored rolls

### 17.2 Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~5 new unit tests pass
- [ ] All existing dice-related tests pass
- [ ] Thread-safety verified for concurrent access
- [ ] XML documentation complete on all public members

---

## 18. Future Considerations

### 18.1 Deferred to v0.15.0f (Combat Integration)

- Combat rolls use `Combat:Attack`, `Combat:Damage` contexts
- Hit quality logging
- Damage roll logging with sum-based total

### 18.2 Deferred to Future Versions

**Persistent Storage:**
- Database-backed `IDiceRollLogger` implementation
- Roll history survives application restart
- Long-term analytics data

**Analytics Features:**
- Success rate by context
- Fumble frequency analysis
- Pool size vs. net success correlation
- Balance tuning reports

**Replay System:**
- Deterministic replay using logged seeds
- Encounter replay for testing
- Tutorial replay functionality

**Export Functionality:**
- Export roll history to JSON/CSV
- Integration with external analytics tools
- Debug report generation

**User Commands:**
- `rollhistory` command for viewing recent rolls
- `rollstats` command for statistics
- Roll filtering in debug console

---

## 19. Implementation Notes

### 19.1 Thread Safety

The `InMemoryDiceRollLogger` uses `ConcurrentQueue<T>` for thread-safe access. The `_trimLock` object synchronizes trimming operations to prevent race conditions during capacity management.

### 19.2 Memory Management

The default `MaxHistorySize` of 1000 rolls provides reasonable history depth while limiting memory usage. Each `DiceRollLog` consumes approximately:
- Guid: 16 bytes
- DateTime: 8 bytes
- Ints: ~20 bytes (5 int fields)
- List<int>: ~40 bytes (typical 10 dice)
- Strings: ~100 bytes (context + null refs)
- Total: ~200 bytes per roll
- 1000 rolls: ~200 KB

### 19.3 Backward Compatibility

The `DiceService.Roll()` method signature change is backward compatible:
- New parameters have default values
- Existing code without context works unchanged
- New code can provide full context

### 19.4 Testing Strategy

Use the `InMemoryDiceRollLogger` in tests to verify roll logging without external dependencies. Create logs manually with `DiceRollLog.FromRollResult()` for precise control over test data.

### 19.5 Integration with Existing Event Logger

The `IDiceRollLogger` supplements but does not replace `IGameEventLogger`. Both receive roll events:
- `IGameEventLogger`: General game event stream
- `IDiceRollLogger`: Structured roll history for queries

---

## 20. Document Metadata

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*

---

*This design specification provides the detailed blueprint for implementing v0.15.0e Dice Roll Logging. This introduces structured roll history tracking with context-aware filtering, building on the success-counting mechanics from v0.15.0a-d.*
