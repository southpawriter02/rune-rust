# Changelog: v0.3.3 - Environmental Systems (The Ground, The Haze, The Ecosystem)

**Versions:** v0.3.3a through v0.3.3c

**Release Dates:** 2025-12-21

## Table of Contents

- [Overview](#overview)
- [Part A: The Ground (Dynamic Hazards)](#part-a-the-ground-dynamic-hazards)
  - [Summary](#summary)
  - [New Files Created](#new-files-created)
  - [Files Modified](#files-modified)
  - [Code Implementation Details](#code-implementation-details)
  - [Logging Matrix](#logging-matrix)
  - [Test Coverage](#test-coverage)
  - [DI Registration](#di-registration)
  - [Seed Data Examples](#seed-data-examples)
  - [Deferred to Later Versions](#deferred-to-later-versions)
  - [Breaking Changes](#breaking-changes)
  - [Migration Notes](#migration-notes)
  - [Contributors](#contributors)
- [Part B: The Haze (Ambient Conditions)](#part-b-the-haze-ambient-conditions)
  - [Summary](#summary-1)
  - [New Files Created](#new-files-created-1)
  - [Files Modified](#files-modified-1)
  - [Code Implementation Details](#code-implementation-details-1)
  - [Logging Matrix](#logging-matrix-1)
  - [Test Coverage](#test-coverage-1)
  - [DI Registration](#di-registration-1)
  - [Verification Results](#verification-results)
  - [Running Tests](#running-tests)
  - [Next Steps](#next-steps)
  - [Breaking Changes](#breaking-changes-1)
  - [Migration Notes](#migration-notes-1)
  - [Contributors](#contributors-1)
- [Part C: The Ecosystem (Integration)](#part-c-the-ecosystem-integration)
  - [Summary](#summary-2)
  - [New Files Created](#new-files-created-2)
  - [Files Modified](#files-modified-2)
  - [Code Implementation Details](#code-implementation-details-2)
  - [Logging Matrix](#logging-matrix-2)
  - [Test Coverage](#test-coverage-2)
  - [DI Registration](#di-registration-2)
  - [Verification Results](#verification-results-1)
  - [Running Tests](#running-tests-1)
  - [Next Steps](#next-steps-1)
  - [Breaking Changes](#breaking-changes-2)
  - [Migration Notes](#migration-notes-2)
  - [Contributors](#contributors-2)

---

## Overview

The v0.3.3 release cycle introduces comprehensive environmental systems that transform static rooms into dynamic, hostile battlefields. This three-part release implements:

1. **Dynamic Hazards (v0.3.3a)**: Interactive environmental objects (traps, vents, spore pods) that trigger based on player/enemy actions with effects like damage, status application, and cooldown management.

2. **Ambient Conditions (v0.3.3b)**: Room-wide persistent environmental effects (Toxic Atmosphere, Psychic Resonance, etc.) that apply passive stat penalties and active turn-based damage/stress/corruption to all combatants.

3. **Biome Integration (v0.3.3c)**: Procedural assignment of hazards and conditions during dungeon generation based on BiomeType (Ruin, Industrial, Organic, Void) and DangerLevel (Safe, Unstable, Hostile, Lethal).

Together, these systems create a cohesive environmental layer that affects exploration, combat tactics, and world atmosphere, all while maintaining Domain 4 compliance in narrative descriptions.

---

## Part A: The Ground (Dynamic Hazards)

**Release Date:** 2025-12-21

### Summary

This release introduces the Dynamic Hazard system - interactive environmental objects that transform static rooms into reactive battlefields. Hazards (traps, vents, spore pods) trigger based on player/enemy actions: movement, damage taken, turn start, or manual interaction. The system leverages a shared EffectScriptExecutor utility extracted from AbilityService, enabling consistent "DAMAGE:Fire:2d6;STATUS:Bleeding:2" parsing across abilities and hazards. DynamicHazard extends InteractableObject via TPH inheritance, gaining hazard-specific properties (HazardState, TriggerType, cooldowns, effect scripts). HazardService handles trigger detection, effect execution, and lifecycle state management (Dormant -> Triggered -> Cooldown -> Dormant or Destroyed for one-time hazards). Integration hooks in CombatService and NavigationService enable automatic hazard triggering on damage dealt and room entry. This release includes 28 new unit tests (21 EffectScriptExecutorTests + 28 HazardServiceTests) validating the hazard system.

---

### New Files Created

#### Core Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/HazardState.cs` | Lifecycle states: Dormant, Triggered, Cooldown, Destroyed |
| `RuneAndRust.Core/Enums/TriggerType.cs` | Trigger conditions: Movement, DamageTaken, TurnStart, ManualInteraction |
| `RuneAndRust.Core/Enums/HazardType.cs` | Classification: Mechanical, Environmental, Biological |
| `RuneAndRust.Core/Enums/DamageType.cs` | Damage types: Physical, Fire, Ice, Lightning, Poison, Acid, Psychic, Blight |
| `RuneAndRust.Core/Entities/DynamicHazard.cs` | Entity extending InteractableObject with hazard-specific properties |
| `RuneAndRust.Core/Models/HazardResult.cs` | Result record for hazard activation with damage, healing, statuses, state |
| `RuneAndRust.Core/Interfaces/IHazardService.cs` | Service contract for hazard processing |

#### Engine Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/EffectScriptExecutor.cs` | Shared utility for parsing and executing effect scripts ("DAMAGE:Fire:2d6;STATUS:Bleeding:2") |
| `RuneAndRust.Engine/Services/HazardService.cs` | Core hazard trigger logic and lifecycle state management |

#### Test Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/EffectScriptExecutorTests.cs` | 21 unit tests for effect script parsing (DAMAGE, HEAL, STATUS commands) |
| `RuneAndRust.Tests/Engine/HazardServiceTests.cs` | 28 unit tests for hazard triggers, cooldowns, state transitions |

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/ObjectType.cs` | Added `Hazard = 5` enum value |
| `RuneAndRust.Core/Entities/Room.cs` | Added `Hazards` collection property (List<DynamicHazard>) |
| `RuneAndRust.Engine/Services/AbilityService.cs` | Refactored to use EffectScriptExecutor instead of inline parsing |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added IHazardService/IRoomRepository dependencies, ProcessDamageHazardsAsync() and TickHazardCooldownsAsync() methods |
| `RuneAndRust.Engine/Services/NavigationService.cs` | Added IHazardService/IInputHandler dependencies, hazard trigger on room entry |
| `RuneAndRust.Engine/Services/ObjectSpawner.cs` | Excluded Hazard type from random spawning (hazards are placed intentionally) |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Configured TPH discriminator for DynamicHazard, added DbSet<DynamicHazard> |
| `RuneAndRust.Terminal/Program.cs` | Registered EffectScriptExecutor (Singleton) and HazardService (Scoped), updated version to v0.3.3a |
| `RuneAndRust.Tests/Engine/AbilityServiceTests.cs` | Updated constructor to use EffectScriptExecutor |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added IHazardService and IRoomRepository mocks |
| `RuneAndRust.Tests/Engine/NavigationServiceTests.cs` | Added IHazardService and IInputHandler mocks |
| `RuneAndRust.Tests/Core/ObjectTypeTests.cs` | Updated count from 5 to 6 values |

---

### Code Implementation Details

#### HazardState Enum

```csharp
public enum HazardState
{
    Dormant = 0,    // Ready to trigger
    Triggered = 1,  // Currently activating (transient)
    Cooldown = 2,   // Recharging
    Destroyed = 3   // One-time use, consumed
}
```

#### TriggerType Enum

```csharp
public enum TriggerType
{
    Movement = 0,        // Triggered when entering room
    DamageTaken = 1,     // Triggered when damage dealt in room
    TurnStart = 2,       // Triggered at combat turn start
    ManualInteraction = 3 // Triggered by explicit "activate" command
}
```

#### DynamicHazard Entity

**Key Properties:**
- `HazardType`: Classification (Mechanical, Environmental, Biological)
- `State`: Current lifecycle state (Dormant/Triggered/Cooldown/Destroyed)
- `CooldownRemaining`/`MaxCooldown`: Cooldown tracking
- `OneTimeUse`: If true, transitions to Destroyed after trigger
- `Trigger`: What activates this hazard
- `RequiredDamageType`: Optional filter for damage-triggered hazards
- `DamageThreshold`: Minimum damage required to trigger
- `EffectScript`: Command string (e.g., "DAMAGE:Fire:2d6;STATUS:Bleeding:2")
- `TriggerMessage`: Custom activation message

**Constructor:**
```csharp
public DynamicHazard()
{
    ObjectType = ObjectType.Hazard;
}
```

#### EffectScriptExecutor

**Constructor:**
```csharp
public EffectScriptExecutor(
    IDiceService diceService,
    IStatusEffectService statusEffectService,
    ILogger<EffectScriptExecutor> logger)
```

**Execute Method:**
```csharp
public EffectScriptResult Execute(
    string effectScript,
    Combatant target,
    string sourceName,
    Guid? sourceId = null)
```

**Supported Commands:**
- `DAMAGE:Type:Dice` - Deal damage (e.g., "DAMAGE:Fire:2d6")
- `HEAL:Amount` - Restore HP (e.g., "HEAL:15" or "HEAL:2d4")
- `STATUS:Type:Duration:Stacks` - Apply status effect (e.g., "STATUS:Bleeding:3:2")

**Damage Soak Logic:**
- Physical damage: Reduced by ArmorSoak + status modifiers
- Elemental damage (Fire, Ice, Lightning, etc.): Bypasses armor soak

#### HazardService

**Constructor:**
```csharp
public HazardService(
    IInteractableObjectRepository objectRepository,
    EffectScriptExecutor scriptExecutor,
    ILogger<HazardService> logger)
```

**Key Methods:**

**TriggerOnRoomEnterAsync(Room room, Combatant? entrant)**
- Finds all Dormant hazards with TriggerType.Movement
- Activates each, executing EffectScript against entrant
- Returns list of HazardResult records

**TriggerOnDamageAsync(Room room, DamageType damageType, int amount, Combatant? target)**
- Finds all Dormant hazards with TriggerType.DamageTaken
- Filters by RequiredDamageType and DamageThreshold
- Activates matching hazards

**ProcessTurnStartHazardsAsync(Room room, List<Combatant> combatants)**
- Finds all Dormant hazards with TriggerType.TurnStart
- Applies effects to ALL combatants in room

**TickCooldownsAsync(Room room)**
- Decrements CooldownRemaining for hazards in Cooldown state
- Transitions to Dormant when cooldown reaches 0

**ManualActivateAsync(DynamicHazard hazard, Combatant activator)**
- Allows explicit activation of ManualInteraction hazards
- Validates trigger type and Dormant state

**ActivateHazardAsync (Private):**
```csharp
private async Task<HazardResult> ActivateHazardAsync(DynamicHazard hazard, Combatant? target)
{
    hazard.State = HazardState.Triggered;

    // Execute effect script if target provided
    if (target != null && !string.IsNullOrWhiteSpace(hazard.EffectScript))
    {
        var scriptResult = _scriptExecutor.Execute(
            hazard.EffectScript,
            target,
            hazard.Name,
            hazard.Id);
        // Aggregate results...
    }

    // Update state
    if (hazard.OneTimeUse)
    {
        hazard.State = HazardState.Destroyed;
    }
    else
    {
        hazard.State = HazardState.Cooldown;
        hazard.CooldownRemaining = hazard.MaxCooldown;
    }

    await _objectRepository.UpdateAsync(hazard);
    return new HazardResult(...);
}
```

#### CombatService Integration

**New Dependencies:**
```csharp
private readonly IHazardService _hazardService;
private readonly IRoomRepository _roomRepository;
```

**Hazard Processing Region:**
```csharp
#region Hazard System (v0.3.3a)

private async Task ProcessDamageHazardsAsync(DamageType damageType, int amount, Combatant target)
{
    if (_gameState.CurrentRoomId == null) return;

    var room = await _roomRepository.GetByIdAsync(_gameState.CurrentRoomId.Value);
    if (room == null) return;

    var hazardResults = await _hazardService.TriggerOnDamageAsync(room, damageType, amount, target);
    foreach (var result in hazardResults.Where(r => r.WasTriggered))
    {
        _inputHandler.DisplayMessage($"[HAZARD] {result.Message}");
    }
}

private async Task TickHazardCooldownsAsync()
{
    if (_gameState.CurrentRoomId == null) return;

    var room = await _roomRepository.GetByIdAsync(_gameState.CurrentRoomId.Value);
    if (room != null)
    {
        await _hazardService.TickCooldownsAsync(room);
    }
}

#endregion
```

#### NavigationService Integration

**New Dependencies:**
```csharp
private readonly IHazardService _hazardService;
private readonly IInputHandler _inputHandler;
```

**Hazard Trigger on Room Entry:**
```csharp
// After room change:
_gameState.CurrentRoomId = nextRoomId;
_gameState.TurnCount++;

// Trigger movement hazards (v0.3.3a)
var hazardResults = await _hazardService.TriggerOnRoomEnterAsync(nextRoom);
foreach (var result in hazardResults.Where(r => r.WasTriggered))
{
    _inputHandler.DisplayMessage($"[HAZARD] {result.Message}");
}
```

#### Database Configuration (TPH)

**RuneAndRustDbContext OnModelCreating:**
```csharp
// TPH Discriminator for InteractableObject hierarchy
modelBuilder.Entity<InteractableObject>()
    .HasDiscriminator<ObjectType>("ObjectType")
    .HasValue<InteractableObject>(ObjectType.Furniture)
    .HasValue<DynamicHazard>(ObjectType.Hazard);

// DynamicHazard-specific columns
modelBuilder.Entity<DynamicHazard>(entity =>
{
    entity.Property(e => e.HazardType).HasConversion<int>();
    entity.Property(e => e.State).HasConversion<int>();
    entity.Property(e => e.Trigger).HasConversion<int>();
    entity.Property(e => e.RequiredDamageType).HasConversion<int?>();
    entity.Property(e => e.EffectScript).HasMaxLength(500);
    entity.Property(e => e.TriggerMessage).HasMaxLength(500);
});
```

---

### Logging Matrix

| Context | Level | Template |
|---------|-------|----------|
| Hazard Triggered | Info | `"[Hazard] [{Hazard}] triggered by {Trigger} in {Room}"` |
| Hazard Effect | Debug | `"[Hazard] [{Hazard}] executing script: {Script}"` |
| Hazard Destroyed | Debug | `"[Hazard] [{Hazard}] destroyed after one-time trigger"` |
| Hazard Cooldown | Debug | `"[Hazard] [{Hazard}] entering cooldown: {Cooldown} turns"` |
| Hazard Reset | Trace | `"[Hazard] [{Hazard}] cooldown complete, returning to Dormant"` |
| EffectScript Parse | Debug | `"[EffectScript] Executing script: {Script} on {Target} from {Source}"` |
| EffectScript Command | Debug | `"[EffectScript] Executing command: {Command}"` |
| EffectScript Complete | Info | `"[EffectScript] Execution complete. Damage: {Damage}, Healing: {Healing}, Statuses: [{Statuses}]"` |
| Unknown Command | Warning | `"[EffectScript] Unknown command type: {CommandType}"` |

---

### Test Coverage

#### EffectScriptExecutorTests (21 tests)

| Test | Description |
|------|-------------|
| Execute_EmptyScript_ReturnsEmptyResult | Empty string returns zero damage/healing |
| Execute_NullScript_ReturnsEmptyResult | Null script handled gracefully |
| Execute_WhitespaceScript_ReturnsEmptyResult | Whitespace-only script returns empty |
| Execute_DamageCommand_RollsDiceAndAppliesDamage | Fire damage rolls dice and applies |
| Execute_PhysicalDamage_AppliesArmorSoak | Physical damage reduced by armor |
| Execute_PhysicalDamage_SoakCapsAtZero | Soak can't make damage negative |
| Execute_FireDamage_BypassesArmorSoak | Elemental damage ignores soak |
| Execute_DamageCommand_AppliesVulnerabilityMultiplier | Vulnerability increases damage |
| Execute_DamageCommand_IncludesNarrative | Result includes narrative text |
| Execute_DamageCommand_MissingParameters_ReturnsZeroDamage | Missing params handled |
| Execute_DamageCommand_InvalidDiceNotation_ReturnsZeroDamage | Bad notation handled |
| Execute_HealCommand_FlatValue_RestoresHP | Flat healing works |
| Execute_HealCommand_ClampsToMaxHP | Healing capped at max HP |
| Execute_HealCommand_AtFullHP_ReturnsZeroHealing | Full HP returns 0 heal |
| Execute_HealCommand_DiceNotation_RollsAndHeals | Dice-based healing works |
| Execute_HealCommand_MissingAmount_ReturnsZeroHealing | Missing amount handled |
| Execute_StatusCommand_AppliesEffect | Status applied via service |
| Execute_StatusCommand_WithStacks_AppliesMultipleTimes | Stacks call ApplyEffect multiple times |
| Execute_StatusCommand_UnknownStatusType_DoesNotApply | Unknown status skipped |
| Execute_StatusCommand_MissingDuration_DoesNotApply | Missing duration handled |
| Execute_MultipleCommands_AllExecute | Multiple commands in one script |
| Execute_MultipleCommands_AggregatesDamage | Damage aggregates across commands |
| Execute_MultipleCommands_CombinesNarratives | Narratives combined |
| Execute_UnknownCommand_SkippedAndLogged | Unknown commands skipped |

#### HazardServiceTests (28 tests)

| Test | Description |
|------|-------------|
| TriggerOnRoomEnterAsync_DormantMovementHazard_TriggersAndAppliesDamage | Movement trigger activates |
| TriggerOnRoomEnterAsync_CooldownHazard_DoesNotTrigger | Cooldown hazards skipped |
| TriggerOnRoomEnterAsync_DestroyedHazard_NotIncluded | Destroyed excluded |
| TriggerOnRoomEnterAsync_DamageTriggerHazard_DoesNotTriggerOnMovement | Wrong trigger type skipped |
| TriggerOnRoomEnterAsync_NoEntrant_TriggersWithoutApplyingDamage | No target = no damage |
| TriggerOnDamageAsync_MatchingDamageType_Triggers | Matching type triggers |
| TriggerOnDamageAsync_WrongDamageType_DoesNotTrigger | Wrong type filtered |
| TriggerOnDamageAsync_AnyDamageType_TriggersOnAnyType | Null RequiredDamageType = any |
| TriggerOnDamageAsync_BelowThreshold_DoesNotTrigger | Below threshold skipped |
| TriggerOnDamageAsync_AtThreshold_Triggers | At threshold triggers |
| ActivateHazard_OneTimeUse_SetsDestroyedState | OneTimeUse -> Destroyed |
| ActivateHazard_Reusable_SetsCooldownState | Reusable -> Cooldown |
| TickCooldownsAsync_DecrementsCooldown | Cooldown decrements |
| TickCooldownsAsync_ZeroCooldown_ReturnsToDormant | 0 cooldown -> Dormant |
| TickCooldownsAsync_DormantHazard_NoChange | Dormant unaffected |
| TickCooldownsAsync_MultipleCooldownHazards_AllTicked | All hazards ticked |
| ProcessTurnStartHazardsAsync_ActiveHazard_AppliesEffectToAllCombatants | Applies to all |
| ManualActivateAsync_ManualTriggerHazard_Activates | Manual activation works |
| ManualActivateAsync_NotManualTriggerHazard_DoesNotActivate | Wrong trigger rejected |
| ManualActivateAsync_NotDormantHazard_DoesNotActivate | Non-dormant rejected |
| GetActiveHazardsAsync_ReturnsOnlyNonDestroyedHazards | Destroyed filtered |
| ActivateHazard_MechanicalType_ReturnsGrindingMessage | Mechanical message |
| ActivateHazard_EnvironmentalType_ReturnsEruptsMessage | Environmental message |
| ActivateHazard_BiologicalType_ReturnsNoxiousMessage | Biological message |
| ActivateHazard_CustomTriggerMessage_UsesCustomMessage | Custom message used |

---

### DI Registration

**Program.cs Additions:**
```csharp
// Register Hazard Services (v0.3.3a)
services.AddSingleton<EffectScriptExecutor>();
services.AddScoped<IHazardService, HazardService>();
```

---

### Seed Data Examples

Three starter hazards for testing (not seeded in this release, for manual testing):

#### Steam Vent
- **Trigger:** DamageTaken (any type, threshold 5)
- **Effect:** "DAMAGE:Fire:2d6"
- **Cooldown:** 2 turns
- **OneTimeUse:** false

#### Pressure Plate
- **Trigger:** Movement
- **Effect:** "DAMAGE:Physical:1d8"
- **Cooldown:** 0 (instant reset)
- **OneTimeUse:** false

#### Volatile Spore Pod
- **Trigger:** DamageTaken (any type, threshold 1)
- **Effect:** "DAMAGE:Poison:1d6;STATUS:Poisoned:3"
- **Cooldown:** N/A
- **OneTimeUse:** true

---

### Deferred to Later Versions

The following features are planned for later versions in the v0.3.3 cycle:

#### v0.3.3b - The Haze (Ambient Conditions)
- **Ambient Conditions System**: Room-wide buffs/debuffs affecting all combatants
- **Condition Types**: Low Visibility, Toxic Atmosphere, Extreme Cold, etc.
- **Duration Management**: Temporary vs. permanent room conditions
- **UI Integration**: Condition display in exploration and combat

#### v0.3.3c - The Mind (AI Hazard Awareness)
- **AI Hazard Awareness**: Enemies can detect and avoid traps
- **Tactical AI Updates**: Smarter enemy positioning around hazards
- **Chain Reactions**: Explosions triggering nearby hazards
- **UI Hazard Rendering**: Visual representation of hazards in TUI

#### Future Milestone
- **Tile-Based Positioning**: Spatial hazard placement on room grid
- **Area of Effect**: Hazards affecting specific tiles vs. room-wide
- **Player Hazard Interaction**: Disarm, trigger, or leverage hazards tactically

---

### Breaking Changes

None. This release is backward compatible.

---

### Migration Notes

#### Database
A new migration may be required to add the DynamicHazard columns to the InteractableObjects table (using TPH inheritance). The discriminator column `ObjectType` should already exist; new columns include:
- `HazardType` (int)
- `State` (int)
- `Trigger` (int)
- `RequiredDamageType` (int, nullable)
- `DamageThreshold` (int)
- `EffectScript` (varchar 500)
- `TriggerMessage` (varchar 500)
- `OneTimeUse` (bit)
- `MaxCooldown` (int)
- `CooldownRemaining` (int)

---

### Contributors

- Claude Code (Architect Agent)

---

## Part B: The Haze (Ambient Conditions)

**Release Date:** 2025-12-21

### Summary

This release introduces the Ambient Condition system - persistent room-wide environmental effects that apply passive stat penalties and active turn-based damage/stress/corruption. Conditions (Psychic Resonance, Toxic Atmosphere, Deep Cold, Scorching Heat, Low Visibility, Blighted Ground, Static Field, Dread Presence) transform rooms into hostile zones affecting all combatants equally. The system leverages a two-tier penalty model: passive modifiers applied at combat start (e.g., -1 WILL for Psychic Resonance) and active tick effects processed each turn (e.g., +2 Stress per turn). ConditionService handles stat modifier lookups via ConditionTypeExtensions, passive penalty application to Combatant instances, and tick script parsing (DAMAGE/STRESS/CORRUPTION commands). Integration in CombatService applies penalties at combat start and processes ticks at turn start. NavigationService displays condition information when entering rooms. The Room entity gained a ConditionId property for database persistence, and Combatant gained four new condition modifier properties plus ActiveCondition tracking. This release includes 24 new unit tests validating stat modifiers, passive penalty application, and tick effects with chance-based triggers.

---

### New Files Created

#### Core Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/AmbientCondition.cs` | Entity representing room-wide environmental conditions with Type, Name, Description, Color, TickScript, TickChance properties |
| `RuneAndRust.Core/Models/Combat/ConditionTickResult.cs` | Result record for condition tick processing with WasApplied, ConditionName, Message, DamageDealt, StressApplied, CorruptionApplied fields |
| `RuneAndRust.Core/Interfaces/IConditionService.cs` | Service contract defining GetRoomConditionAsync, GetStatModifiers, ApplyPassiveModifiers, ProcessTurnTickAsync methods |

#### Engine Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/ConditionService.cs` | Core condition processing logic with passive modifier application and tick script parsing |

#### Persistence Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Data/ConditionSeeder.cs` | Seeds 8 condition definitions with AAM-VOICE compliant descriptions |

#### Test Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/ConditionServiceTests.cs` | 24 unit tests validating condition stat modifiers, passive penalties, and tick effects |

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/ConditionType.cs` | Added ConditionTypeExtensions static class with GetPassivePenalties() method returning attribute penalty dictionaries |
| `RuneAndRust.Core/Entities/Room.cs` | Added ConditionId nullable Guid property for FK relationship to AmbientCondition |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added ActiveCondition, ConditionSturdinessModifier, ConditionFinesseModifier, ConditionWitsModifier, ConditionWillModifier properties |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added IConditionService dependency, ApplyConditionPenalties() method at combat start, ProcessConditionTick() method at turn start |
| `RuneAndRust.Engine/Services/NavigationService.cs` | Added IConditionService dependency, integrated condition display in FormatRoomDescriptionAsync() |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Configured AmbientCondition entity with unique index on Type, added Room -> Condition FK relationship |
| `RuneAndRust.Terminal/Program.cs` | Registered IConditionService as Scoped, updated version string to v0.3.3b |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added IConditionService mock to constructor |
| `RuneAndRust.Tests/Engine/NavigationServiceTests.cs` | Added IConditionService mock to constructor |

---

### Code Implementation Details

#### ConditionType Enum (Extended)

**Enum Values:**
```csharp
public enum ConditionType
{
    PsychicResonance = 0,  // -1 WILL, +2 Stress/turn
    ToxicAtmosphere = 1,   // No passive, 1d4 Poison/turn
    DeepCold = 2,          // -1 FINESSE, 1 Ice/turn
    ScorchingHeat = 3,     // -1 STURDINESS, 1 Fire/turn
    LowVisibility = 4,     // -2 WITS, No active
    BlightedGround = 5,    // -1 WILL, -1 WITS, +1 Corruption/turn
    StaticField = 6,       // -1 FINESSE, 1d6 Lightning (25% chance)
    DreadPresence = 7      // -2 WILL, +3 Stress/turn
}
```

**ConditionTypeExtensions:**
```csharp
public static class ConditionTypeExtensions
{
    public static Dictionary<Attribute, int> GetPassivePenalties(this ConditionType type) => type switch
    {
        ConditionType.PsychicResonance => new Dictionary<Attribute, int> { { Attribute.Will, -1 } },
        ConditionType.DeepCold => new Dictionary<Attribute, int> { { Attribute.Finesse, -1 } },
        ConditionType.ScorchingHeat => new Dictionary<Attribute, int> { { Attribute.Sturdiness, -1 } },
        ConditionType.LowVisibility => new Dictionary<Attribute, int> { { Attribute.Wits, -2 } },
        ConditionType.BlightedGround => new Dictionary<Attribute, int>
        {
            { Attribute.Will, -1 },
            { Attribute.Wits, -1 }
        },
        ConditionType.StaticField => new Dictionary<Attribute, int> { { Attribute.Finesse, -1 } },
        ConditionType.DreadPresence => new Dictionary<Attribute, int> { { Attribute.Will, -2 } },
        ConditionType.ToxicAtmosphere => new Dictionary<Attribute, int>(), // No passive
        _ => new Dictionary<Attribute, int>()
    };
}
```

#### AmbientCondition Entity

**Key Properties:**
- `Id` (Guid): Unique identifier
- `Type` (ConditionType): Enum type for passive penalty lookup
- `Name` (string): Display name
- `Description` (string): AAM-VOICE compliant narrative description
- `Color` (string): Spectre.Console color for UI rendering (e.g., "purple", "green", "cyan")
- `TickScript` (string): Command script for turn-based effects (e.g., "STRESS:2", "DAMAGE:Poison:1d4", "CORRUPTION:1")
- `TickChance` (float): Probability (0.0-1.0) that tick triggers each turn, default 1.0 (always)

**Supported TickScript Commands:**
- `DAMAGE:Type:Dice` - Deal typed damage using EffectScriptExecutor
- `STRESS:Amount` - Apply stress to combatant (capped at MaxStress)
- `CORRUPTION:Amount` - Apply corruption to combatant (capped at MaxCorruption)

#### ConditionTickResult Record

```csharp
public record ConditionTickResult(
    bool WasApplied,
    string ConditionName,
    string Message,
    int DamageDealt,
    int StressApplied,
    int CorruptionApplied
)
{
    public static ConditionTickResult None => new(false, string.Empty, string.Empty, 0, 0, 0);
}
```

#### IConditionService Interface

**Method Signatures:**
```csharp
Task<AmbientCondition?> GetRoomConditionAsync(Guid roomId);
Dictionary<CharacterAttribute, int> GetStatModifiers(ConditionType type);
void ApplyPassiveModifiers(Combatant combatant, ConditionType? conditionType);
Task<ConditionTickResult> ProcessTurnTickAsync(Combatant combatant, AmbientCondition condition);
```

#### ConditionService Implementation

**Constructor:**
```csharp
public ConditionService(
    IRepository<AmbientCondition> conditionRepository,
    IRoomRepository roomRepository,
    EffectScriptExecutor effectScriptExecutor,
    IDiceService diceService,
    ILogger<ConditionService> logger)
```

**GetRoomConditionAsync:**
- Retrieves Room by roomId
- If Room.ConditionId is null, returns null
- Otherwise, loads AmbientCondition from repository
- Logs condition lookup at Trace/Debug levels

**GetStatModifiers:**
- Calls ConditionType.GetPassivePenalties() extension method
- Returns dictionary of attribute penalties
- Logs penalty count at Debug level

**ApplyPassiveModifiers:**
- If conditionType is null, no-op
- Retrieves penalties via GetStatModifiers()
- Iterates penalties and applies to Combatant:
  - `Attribute.Sturdiness` -> `ConditionSturdinessModifier`
  - `Attribute.Finesse` -> `ConditionFinesseModifier`
  - `Attribute.Wits` -> `ConditionWitsModifier`
  - `Attribute.Will` -> `ConditionWillModifier`
- Sets `ActiveCondition` property on Combatant
- Logs each penalty application at Debug level
- Logs zone entry at Info level

**ProcessTurnTickAsync:**
- Returns ConditionTickResult.None if TickScript is empty
- Checks TickChance via dice roll (d100 vs threshold)
- Parses TickScript commands separated by `;`
- Executes each command:
  - `DAMAGE:Type:Dice` -> Delegates to EffectScriptExecutor
  - `STRESS:Amount` -> Calls ParseStressCommand()
  - `CORRUPTION:Amount` -> Calls ParseCorruptionCommand()
- Aggregates damage, stress, corruption across all commands
- Builds display message from narratives
- Logs tick processing at Trace/Debug/Info levels

**ParseStressCommand (Private):**
- Validates command has amount parameter (2 parts)
- Parses amount as integer
- Applies stress to Combatant.CurrentStress, clamped to MaxStress
- Returns actual stress applied (handles cap overflow)
- Logs stress change at Debug level

**ParseCorruptionCommand (Private):**
- Validates command has amount parameter (2 parts)
- Parses amount as integer
- Applies corruption to Combatant.CurrentCorruption, clamped to MaxCorruption
- Returns actual corruption applied (handles cap overflow)
- Logs corruption change at Debug level

#### Combatant Modifications

**New Properties:**
```csharp
public ConditionType? ActiveCondition { get; set; }
public int ConditionSturdinessModifier { get; set; } = 0;
public int ConditionFinesseModifier { get; set; } = 0;
public int ConditionWitsModifier { get; set; } = 0;
public int ConditionWillModifier { get; set; } = 0;
```

**Usage:**
- Set at combat start via ConditionService.ApplyPassiveModifiers()
- Read during attribute calculations (integrated with existing stat systems)
- Condition modifiers are combat-volatile, not persisted to Character entity

#### CombatService Integration

**New Dependency:**
```csharp
private readonly IConditionService _conditionService;
```

**ApplyConditionPenalties (Combat Start):**
```csharp
// In StartCombat method, after building TurnOrder:
if (_gameState.CurrentRoomId.HasValue)
{
    var room = await _roomRepository.GetByIdAsync(_gameState.CurrentRoomId.Value);
    var condition = await _conditionService.GetRoomConditionAsync(_gameState.CurrentRoomId.Value);

    if (condition != null)
    {
        foreach (var combatant in state.TurnOrder)
        {
            _conditionService.ApplyPassiveModifiers(combatant, condition.Type);
        }

        _logger.LogInformation(
            "[Condition] Combat starting in [{ConditionName}] zone. {Count} combatants affected.",
            condition.Name, state.TurnOrder.Count);
    }
}
```

**ProcessConditionTick (Turn Start):**
```csharp
// In NextTurn method, after determining active combatant:
private void ProcessConditionTick(Combatant combatant)
{
    if (!_gameState.CurrentRoomId.HasValue || combatant.ActiveCondition == null)
    {
        return;
    }

    // Retrieve room and condition from database
    var room = _roomRepository.GetByIdAsync(_gameState.CurrentRoomId.Value).Result;
    var condition = _conditionService.GetRoomConditionAsync(_gameState.CurrentRoomId.Value).Result;

    if (condition == null) return;

    // Process tick effect
    var tickResult = _conditionService.ProcessTurnTickAsync(combatant, condition).Result;

    if (tickResult.WasApplied)
    {
        _inputHandler.DisplayMessage($"[CONDITION] {tickResult.Message}");

        // Sync effects to player source if player combatant
        if (combatant.IsPlayer && combatant.CharacterSource != null)
        {
            combatant.CharacterSource.CurrentHP = combatant.CurrentHp;
            combatant.CharacterSource.PsychicStress = combatant.CurrentStress;
            combatant.CharacterSource.Corruption = combatant.CurrentCorruption;

            _characterRepository.UpdateAsync(combatant.CharacterSource).Wait();

            _logger.LogDebug(
                "[Condition] Synced condition effects to player source. HP: {HP}, Stress: {Stress}, Corruption: {Corruption}",
                combatant.CharacterSource.CurrentHP, combatant.CharacterSource.PsychicStress, combatant.CharacterSource.Corruption);
        }
    }
}
```

#### NavigationService Integration

**New Dependency:**
```csharp
private readonly IConditionService _conditionService;
```

**FormatRoomDescriptionAsync (Condition Display):**
```csharp
// After exit text formatting:
var conditionText = string.Empty;
var condition = await _conditionService.GetRoomConditionAsync(room.Id);
if (condition != null)
{
    conditionText = $"\n[AMBIENT] [{condition.Color}]{condition.Name}[/]: {condition.Description}";
    _logger.LogDebug(
        "[Condition] Room {RoomName} has condition [{ConditionName}]",
        room.Name, condition.Name);
}

return $"{prefix}[{room.Name}]\n{room.Description}{conditionText}\n\n{exitText}";
```

#### Database Configuration

**DbContext Changes:**
```csharp
public DbSet<AmbientCondition> AmbientConditions { get; set; } = null!;

// In OnModelCreating:
modelBuilder.Entity<AmbientCondition>(entity =>
{
    entity.ToTable("AmbientConditions");
    entity.HasKey(c => c.Id);

    entity.Property(c => c.Type)
        .HasConversion<int>()
        .IsRequired();

    // Unique constraint on Type (only one definition per condition type)
    entity.HasIndex(c => c.Type)
        .IsUnique();

    entity.Property(c => c.Name)
        .HasMaxLength(100)
        .IsRequired();

    entity.Property(c => c.Description)
        .HasMaxLength(1000)
        .IsRequired();

    entity.Property(c => c.Color)
        .HasMaxLength(50)
        .IsRequired();

    entity.Property(c => c.TickScript)
        .HasMaxLength(500)
        .IsRequired();

    entity.Property(c => c.TickChance)
        .HasColumnType("real")
        .IsRequired();
});

// Room -> Condition FK relationship
modelBuilder.Entity<Room>()
    .HasOne<AmbientCondition>()
    .WithMany()
    .HasForeignKey(r => r.ConditionId)
    .IsRequired(false);
```

#### ConditionSeeder

**Seed Data (8 Conditions):**

All descriptions are Domain 4 compliant (no precision measurements, JÃ¶tun-Reader voice).

1. **Psychic Resonance** (purple)
   - Passive: -1 WILL
   - Active: STRESS:2
   - Description: "A low hum permeates the air, pressing against your thoughts. The walls themselves seem to whisper."

2. **Toxic Atmosphere** (green)
   - Passive: None
   - Active: DAMAGE:Poison:1d4
   - Description: "The air shimmers with chemical haze. Each breath burns the lungs and corrodes the throat."

3. **Deep Cold** (cyan)
   - Passive: -1 FINESSE
   - Active: DAMAGE:Ice:1d1
   - Description: "Numbing frost clings to every surface. Your fingers grow stiff, and your breath hangs frozen in the air."

4. **Scorching Heat** (red)
   - Passive: -1 STURDINESS
   - Active: DAMAGE:Fire:1d1
   - Description: "Oppressive heat radiates from the walls. Sweat beads instantly, and the air itself seems to shimmer."

5. **Low Visibility** (grey)
   - Passive: -2 WITS
   - Active: None (TickScript empty, TickChance 0)
   - Description: "Thick dust or fog obscures the path ahead. Shapes loom and fade in the murk."

6. **Blighted Ground** (darkred)
   - Passive: -1 WILL, -1 WITS
   - Active: CORRUPTION:1
   - Description: "Runic corruption seeps from cracks in the floor. The air tastes of rust and old blood."

7. **Static Field** (yellow)
   - Passive: -1 FINESSE
   - Active: DAMAGE:Lightning:1d6
   - TickChance: 0.25 (25% chance per turn)
   - Description: "Electrical discharge crackles through the air. Your hair stands on end, and the taste of ozone fills your mouth."

8. **Dread Presence** (darkmagenta)
   - Passive: -2 WILL
   - Active: STRESS:3
   - Description: "Something ancient and terrible watches from the shadows. Your heart pounds, and primal fear claws at your spine."

---

### Logging Matrix

| Context | Level | Template |
|---------|-------|----------|
| Service Init | Trace | `"[Condition] ConditionService initialized"` |
| Room Lookup | Trace | `"[Condition] Getting condition for room {RoomId}"` |
| No Condition | Trace | `"[Condition] Room {RoomId} has no active condition"` |
| Condition Found | Debug | `"[Condition] Room {RoomId} has condition [{ConditionName}] ({ConditionType})"` |
| Stat Modifiers | Trace | `"[Condition] Getting stat modifiers for {ConditionType}"` |
| Penalty Count | Debug | `"[Condition] {ConditionType} has {Count} passive penalties"` |
| No Modifiers | Trace | `"[Condition] No condition to apply to {Combatant}"` |
| Sturdiness Penalty | Debug | `"[Condition] {Combatant} affected by STURDINESS {Penalty} from {Condition}"` |
| Finesse Penalty | Debug | `"[Condition] {Combatant} affected by FINESSE {Penalty} from {Condition}"` |
| Wits Penalty | Debug | `"[Condition] {Combatant} affected by WITS {Penalty} from {Condition}"` |
| Will Penalty | Debug | `"[Condition] {Combatant} affected by WILL {Penalty} from {Condition}"` |
| Might Unimplemented | Warning | `"[Condition] MIGHT modifier from {Condition} not implemented"` |
| Zone Entry | Info | `"[Condition] {Combatant} entered [{Condition}] zone"` |
| Tick Processing | Trace | `"[Condition] Processing tick for {Combatant} in [{ConditionName}]"` |
| No Tick Effect | Trace | `"[Condition] {Condition} has no tick effect"` |
| Tick Skipped | Trace | `"[Condition] {Condition} tick skipped (rolled {Roll} vs threshold {Threshold})"` |
| Tick Triggered | Debug | `"[Condition] {Condition} tick triggered (rolled {Roll} vs threshold {Threshold})"` |
| Tick Complete | Info | `"[Condition] {Condition} affects {Combatant}: Damage={Damage}, Stress={Stress}, Corruption={Corruption}"` |
| Stress Parse Error | Warning | `"[Condition] STRESS command missing amount parameter"` |
| Stress Invalid | Warning | `"[Condition] STRESS command has invalid amount: {Amount}"` |
| Stress Applied | Debug | `"[Condition] STRESS: {Combatant} gained {Stress} stress ({Previous} -> {Current})"` |
| Corruption Parse Error | Warning | `"[Condition] CORRUPTION command missing amount parameter"` |
| Corruption Invalid | Warning | `"[Condition] CORRUPTION command has invalid amount: {Amount}"` |
| Corruption Applied | Debug | `"[Condition] CORRUPTION: {Combatant} gained {Corruption} corruption ({Previous} -> {Current})"` |
| Unknown Command | Warning | `"[Condition] Unknown tick command type: {CommandType}"` |
| Combat Start Zone | Info | `"[Condition] Combat starting in [{ConditionName}] zone. {Count} combatants affected."` |
| Effect Sync | Debug | `"[Condition] Synced condition effects to player source. HP: {HP}, Stress: {Stress}, Corruption: {Corruption}"` |
| Nav Condition | Debug | `"[Condition] Room {RoomName} has condition [{ConditionName}]"` |

---

### Test Coverage

**Total: 24 tests | Passed: 24 | Failed: 0 | Duration: 67ms**

#### ConditionServiceTests (24 tests)

##### GetStatModifiers Tests (7 tests)

| Test Name | Description |
|-----------|-------------|
| GetStatModifiers_PsychicResonance_ReturnsMinusOneWill | PsychicResonance returns {Will: -1} |
| GetStatModifiers_LowVisibility_ReturnsMinusTwoWits | LowVisibility returns {Wits: -2} |
| GetStatModifiers_BlightedGround_ReturnsBothPenalties | BlightedGround returns {Will: -1, Wits: -1} |
| GetStatModifiers_ToxicAtmosphere_ReturnsEmpty | ToxicAtmosphere returns empty dictionary |
| GetStatModifiers_DeepCold_ReturnsMinusOneFinesse | DeepCold returns {Finesse: -1} |
| GetStatModifiers_ScorchingHeat_ReturnsMinusOneSturdiness | ScorchingHeat returns {Sturdiness: -1} |
| GetStatModifiers_DreadPresence_ReturnsMinusTwoWill | DreadPresence returns {Will: -2} |

##### ApplyPassiveModifiers Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| ApplyPassiveModifiers_SetsWillModifier | Applies -1 Will modifier, sets ActiveCondition |
| ApplyPassiveModifiers_SetsWitsModifier | Applies -2 Wits modifier, sets ActiveCondition |
| ApplyPassiveModifiers_SetsFinesseModifier | Applies -1 Finesse modifier, sets ActiveCondition |
| ApplyPassiveModifiers_SetsSturdinessModifier | Applies -1 Sturdiness modifier, sets ActiveCondition |
| ApplyPassiveModifiers_BlightedGround_SetsBothModifiers | Applies -1 Will and -1 Wits, sets ActiveCondition |
| ApplyPassiveModifiers_NullCondition_NoEffect | Null condition leaves all modifiers at 0, ActiveCondition null |

##### ProcessTurnTick Tests (8 tests)

| Test Name | Description |
|-----------|-------------|
| ProcessTurnTick_DamageScript_AppliesDamage | DAMAGE:Poison:1d4 script deals 4 damage, reduces CurrentHp |
| ProcessTurnTick_StressScript_AppliesStress | STRESS:2 script applies 2 stress, increases CurrentStress |
| ProcessTurnTick_CorruptionScript_AppliesCorruption | CORRUPTION:1 script applies 1 corruption, increases CurrentCorruption |
| ProcessTurnTick_EmptyScript_ReturnsNone | Empty TickScript returns ConditionTickResult.None |
| ProcessTurnTick_LowChance_SkipsOnFailedRoll | TickChance 0.25, roll 80 > 25 threshold, no effect applied |
| ProcessTurnTick_LowChance_AppliesOnSuccessfulRoll | TickChance 0.25, roll 20 <= 25 threshold, effect applied |
| ProcessTurnTick_StressCappedAtMax | STRESS:3 at CurrentStress 99 caps at 100, returns StressApplied 1 |
| ProcessTurnTick_CorruptionCappedAtMax | CORRUPTION:5 at CurrentCorruption 99 caps at 100, returns CorruptionApplied 1 |

##### GetRoomCondition Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| GetRoomCondition_NoCondition_ReturnsNull | Room with ConditionId null returns null |
| GetRoomCondition_WithCondition_ReturnsCondition | Room with valid ConditionId returns AmbientCondition entity |
| GetRoomCondition_RoomNotFound_ReturnsNull | Non-existent roomId returns null |

---

### DI Registration

**Program.cs Additions:**
```csharp
// Register Condition Services (v0.3.3b)
services.AddScoped<IConditionService, ConditionService>();
```

**Lifetime Rationale:**
- `ConditionService` registered as Scoped (per-request lifecycle, matches CombatService/NavigationService)
- Uses existing Singleton `EffectScriptExecutor` for damage command parsing

---

### Verification Results

#### Build Output
```
Build succeeded.

/usr/local/share/dotnet/sdk/9.0.306/Microsoft.Common.CurrentVersion.targets(2433,5): warning MSB3277: Found conflicts between different versions of "Microsoft.EntityFrameworkCore.Relational" that could not be resolved.
    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.13
```

#### Test Output
```
Test run for /Volumes/GitHub/github/southpawriter02/rune-rust/RuneAndRust.Tests/bin/Debug/net9.0/RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)

Passed!  - Failed:     0, Passed:    24, Skipped:     0, Total:    24, Duration: 67 ms - RuneAndRust.Tests.dll (net9.0)
```

---

### Running Tests

#### All Condition Tests
```bash
dotnet test --filter "FullyQualifiedName~ConditionServiceTests"
```

#### Specific Test Categories
```bash
# Stat modifier tests
dotnet test --filter "FullyQualifiedName~ConditionServiceTests&Name~GetStatModifiers"

# Passive penalty application tests
dotnet test --filter "FullyQualifiedName~ConditionServiceTests&Name~ApplyPassiveModifiers"

# Tick processing tests
dotnet test --filter "FullyQualifiedName~ConditionServiceTests&Name~ProcessTurnTick"

# Room lookup tests
dotnet test --filter "FullyQualifiedName~ConditionServiceTests&Name~GetRoomCondition"
```

---

### Next Steps

The following features are planned for later versions in the v0.3.3 cycle:

#### v0.3.3c - The Mind (AI Hazard Awareness)
- **AI Condition Awareness**: Enemies can detect and react to room conditions
- **Tactical AI Updates**: Condition-based behavior modifiers (e.g., avoid Blighted Ground)
- **Condition Combos**: Hazards + Conditions synergy (e.g., Fire hazard in Toxic Atmosphere)
- **UI Condition Rendering**: Visual representation of active conditions in TUI

#### v0.4.0 - Worldbuilding Milestone
- **Condition Persistence**: Save/load room conditions across sessions
- **Dynamic Condition Application**: Events/items that apply temporary conditions to rooms
- **Condition Intensity Levels**: Tiered severity (Mild/Moderate/Severe variants)
- **Player Condition Mitigation**: Equipment/abilities that reduce condition penalties

---

### Breaking Changes

None. This release is backward compatible.

---

### Migration Notes

#### Database
A new migration is required to add the AmbientConditions table and Room.ConditionId FK.

**New Table: AmbientConditions**
- `Id` (Guid, PK)
- `Type` (int, Unique Index)
- `Name` (varchar 100)
- `Description` (varchar 1000)
- `Color` (varchar 50)
- `TickScript` (varchar 500)
- `TickChance` (real)

**Room Table Alteration**
- Add `ConditionId` (Guid, nullable, FK to AmbientConditions)

**Seeding**
Run `ConditionSeeder.SeedAsync()` to populate 8 base condition definitions.

---

### Contributors

- Claude Code (Chronicle-Smith Agent)

---

## Part C: The Ecosystem (Integration)

**Release Date:** 2025-12-21

### Summary

This release integrates hazards and conditions into the procedural dungeon generation system via biome-based theming. The EnvironmentPopulator service assigns hazards and conditions to rooms based on their BiomeType (Ruin, Industrial, Organic, Void) and DangerLevel (Safe, Unstable, Hostile, Lethal). HazardTemplate entities define spawnable hazard types with BiomeTags for biome-filtered selection. BiomeEnvironmentMapping provides static mappings from biome types to valid condition types and danger level multipliers. During dungeon generation, DungeonGenerator calls EnvironmentPopulator.PopulateDungeonAsync() to roll for hazard/condition placement per room based on calculated spawn chances. The system creates DynamicHazard instances from HazardTemplate records, allowing for template-based hazard spawning. All 12 hazard templates are seeded via HazardTemplateSeeder with Domain 4 compliant descriptions. This release includes 21 new unit tests validating biome mappings, spawn chance calculations, and template-to-hazard conversion.

---

### New Files Created

#### Core Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/HazardTemplate.cs` | Template entity for hazard definitions with BiomeTags, seeded at startup |
| `RuneAndRust.Core/Models/BiomeEnvironmentMapping.cs` | Static mapping of BiomeType to valid ConditionTypes and DangerLevel to spawn multipliers |
| `RuneAndRust.Core/Interfaces/IEnvironmentPopulator.cs` | Interface for environment population service with PopulateRoomAsync and PopulateDungeonAsync |

#### Engine Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/EnvironmentPopulator.cs` | Core service for assigning hazards/conditions to rooms based on biome and danger level |

#### Persistence Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Data/HazardTemplateSeeder.cs` | Seeds 12 hazard templates across 4 biomes with Domain 4 compliant descriptions |

#### Test Layer
| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/EnvironmentPopulatorTests.cs` | 21 unit tests validating biome mappings, spawn chances, and template-to-hazard conversion |

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/AmbientCondition.cs` | Added BiomeTags property (List<BiomeType>) for biome-filtered spawning |
| `RuneAndRust.Engine/Services/DungeonGenerator.cs` | Added IEnvironmentPopulator dependency, calls PopulateDungeonAsync() after room creation |
| `RuneAndRust.Persistence/Data/ConditionSeeder.cs` | Added BiomeTags to all 8 existing condition seeds |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Added HazardTemplates DbSet, configured BiomeTags JSONB columns for both HazardTemplate and AmbientCondition |
| `RuneAndRust.Terminal/Program.cs` | Registered IEnvironmentPopulator, added HazardTemplateSeeder call, updated version to v0.3.3c |
| `RuneAndRust.Tests/Engine/DungeonGeneratorTests.cs` | Added IEnvironmentPopulator mock to constructor |

---

### Code Implementation Details

#### HazardTemplate Entity

**Key Properties:**
```csharp
public class HazardTemplate
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public HazardType HazardType { get; set; } = HazardType.Environmental;
    public TriggerType Trigger { get; set; } = TriggerType.Movement;
    public string EffectScript { get; set; } = string.Empty;
    public int MaxCooldown { get; set; } = 2;
    public bool OneTimeUse { get; set; } = false;
    public List<BiomeType> BiomeTags { get; set; } = new();
}
```

**Usage:**
- Seeded at startup via HazardTemplateSeeder
- Queried by EnvironmentPopulator during dungeon generation
- DynamicHazard instances are created from templates (copies all properties)

#### BiomeEnvironmentMapping Static Class

**GetConditionTypes:**
```csharp
public static List<ConditionType> GetConditionTypes(BiomeType biome) => biome switch
{
    BiomeType.Ruin => new List<ConditionType> { ConditionType.LowVisibility, ConditionType.DreadPresence },
    BiomeType.Industrial => new List<ConditionType> { ConditionType.ToxicAtmosphere, ConditionType.StaticField, ConditionType.ScorchingHeat },
    BiomeType.Organic => new List<ConditionType> { ConditionType.BlightedGround, ConditionType.PsychicResonance, ConditionType.ToxicAtmosphere },
    BiomeType.Void => new List<ConditionType> { ConditionType.PsychicResonance, ConditionType.DreadPresence, ConditionType.DeepCold },
    _ => new List<ConditionType> { ConditionType.LowVisibility }
};
```

**GetDangerMultiplier:**
```csharp
public static float GetDangerMultiplier(DangerLevel level) => level switch
{
    DangerLevel.Safe => 0.1f,
    DangerLevel.Unstable => 0.3f,
    DangerLevel.Hostile => 0.5f,
    DangerLevel.Lethal => 0.7f,
    _ => 0.2f
};
```

#### IEnvironmentPopulator Interface

```csharp
public interface IEnvironmentPopulator
{
    Task<Room> PopulateRoomAsync(Room room);
    Task PopulateDungeonAsync(IEnumerable<Room> rooms);
}
```

#### EnvironmentPopulator Implementation

**Constants:**
```csharp
private const float BaseHazardChance = 0.2f;    // 20% base chance
private const float BaseConditionChance = 0.15f; // 15% base chance
```

**Spawn Chance Calculation:**
```csharp
var hazardChance = BaseHazardChance + BiomeEnvironmentMapping.GetDangerMultiplier(room.DangerLevel);
var conditionChance = BaseConditionChance + BiomeEnvironmentMapping.GetDangerMultiplier(room.DangerLevel);
```

| DangerLevel | Hazard Chance | Condition Chance |
|-------------|---------------|------------------|
| Safe | 30% | 25% |
| Unstable | 50% | 45% |
| Hostile | 70% | 65% |
| Lethal | 90% | 85% |

**PopulateRoomAsync Logic:**
1. Get room's BiomeType and DangerLevel
2. Calculate hazardChance and conditionChance
3. Roll d100 for hazard (if roll/100 <= chance, spawn hazard)
4. Query HazardTemplates filtered by BiomeTags matching room biome
5. Randomly select a template and create DynamicHazard instance
6. Roll d100 for condition (if roll/100 <= chance and room has no condition)
7. Query AmbientConditions filtered by BiomeTags and BiomeEnvironmentMapping
8. Randomly select a condition and assign to room.ConditionId

**PopulateDungeonAsync:**
- Iterates all rooms and calls PopulateRoomAsync for each
- Logs summary count of hazards and conditions assigned

**AssignHazardAsync:**
```csharp
private async Task AssignHazardAsync(Room room, BiomeType biome)
{
    var templates = await _hazardTemplateRepo.GetAllAsync();
    var validTemplates = templates
        .Where(t => t.BiomeTags.Count == 0 || t.BiomeTags.Contains(biome))
        .ToList();

    if (validTemplates.Count == 0) return;

    var template = validTemplates[_diceService.RollSingle(validTemplates.Count, "Hazard selection") - 1];

    var hazard = new DynamicHazard
    {
        Id = Guid.NewGuid(),
        RoomId = room.Id,
        Name = template.Name,
        Description = template.Description,
        HazardType = template.HazardType,
        Trigger = template.Trigger,
        EffectScript = template.EffectScript,
        MaxCooldown = template.MaxCooldown,
        OneTimeUse = template.OneTimeUse,
        State = HazardState.Dormant
    };

    room.Hazards.Add(hazard);
}
```

#### AmbientCondition BiomeTags Addition

```csharp
public List<BiomeType> BiomeTags { get; set; } = new();
```

#### DungeonGenerator Integration

**New Dependency:**
```csharp
private readonly IEnvironmentPopulator _environmentPopulator;
```

**GenerateTestMapAsync Update:**
```csharp
public async Task<Guid> GenerateTestMapAsync()
{
    await _roomRepository.ClearAllRoomsAsync();
    var rooms = CreateTestRooms();
    LinkRooms(rooms);

    // NEW: Populate with environmental hazards (v0.3.3c)
    await _environmentPopulator.PopulateDungeonAsync(rooms.Values);

    await _roomRepository.AddRangeAsync(rooms.Values);
    await _roomRepository.SaveChangesAsync();
    // ...
}
```

#### Database Configuration

**HazardTemplate Entity Configuration:**
```csharp
modelBuilder.Entity<HazardTemplate>(entity =>
{
    entity.ToTable("HazardTemplates");
    entity.HasKey(t => t.Id);
    entity.HasIndex(t => t.Name).IsUnique();

    entity.Property(t => t.Name).HasMaxLength(100).IsRequired();
    entity.Property(t => t.Description).HasMaxLength(500).IsRequired();
    entity.Property(t => t.HazardType).HasConversion<int>().IsRequired();
    entity.Property(t => t.Trigger).HasConversion<int>().IsRequired();
    entity.Property(t => t.EffectScript).HasMaxLength(500).IsRequired();
    entity.Property(t => t.MaxCooldown).IsRequired();
    entity.Property(t => t.OneTimeUse).IsRequired();

    entity.Property(t => t.BiomeTags)
        .HasColumnType("jsonb")
        .HasConversion(
            v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
            v => JsonSerializer.Deserialize<List<BiomeType>>(v, (JsonSerializerOptions?)null) ?? new List<BiomeType>()
        )
        .IsRequired();
});
```

**AmbientCondition BiomeTags Configuration:**
```csharp
entity.Property(c => c.BiomeTags)
    .HasColumnType("jsonb")
    .HasConversion(
        v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
        v => JsonSerializer.Deserialize<List<BiomeType>>(v, (JsonSerializerOptions?)null) ?? new List<BiomeType>()
    )
    .IsRequired();
```

#### HazardTemplateSeeder

**Seeded Hazard Templates (12 total):**

##### Ruin Biome (3 hazards)
| Name | Type | Trigger | Effect |
|------|------|---------|--------|
| Pressure Plate | Mechanical | Movement | DAMAGE:Physical:1d6 |
| Collapsing Floor | Environmental | Movement | DAMAGE:Physical:2d6 (one-time) |
| Dart Trap | Mechanical | Movement | DAMAGE:Physical:1d4;STATUS:Poisoned:2 |

##### Industrial Biome (3 hazards)
| Name | Type | Trigger | Effect |
|------|------|---------|--------|
| Steam Vent | Environmental | TurnStart | DAMAGE:Fire:1d4 |
| Electrified Floor | Mechanical | Movement | DAMAGE:Lightning:1d6;STATUS:Stunned:1 |
| Unstable Machinery | Mechanical | DamageTaken | DAMAGE:Physical:2d4 (one-time) |

##### Organic Biome (3 hazards)
| Name | Type | Trigger | Effect |
|------|------|---------|--------|
| Spore Pod | Biological | Movement | DAMAGE:Poison:1d4;STATUS:Poisoned:2 |
| Corruption Pool | Biological | Movement | CORRUPTION:2 |
| Grasping Tendrils | Biological | TurnStart | DAMAGE:Physical:1d4;STATUS:Slowed:1 |

##### Void Biome (3 hazards)
| Name | Type | Trigger | Effect |
|------|------|---------|--------|
| Reality Fissure | Environmental | TurnStart | STRESS:2;DAMAGE:Psychic:1d4 |
| Entropy Field | Environmental | Movement | DAMAGE:Cold:1d6 |
| Echoing Whispers | Environmental | TurnStart | STRESS:3 |

#### ConditionSeeder BiomeTags Update

| Condition | BiomeTags |
|-----------|-----------|
| Psychic Resonance | Organic, Void |
| Toxic Atmosphere | Industrial, Organic |
| Deep Cold | Void |
| Scorching Heat | Industrial |
| Low Visibility | Ruin |
| Blighted Ground | Organic |
| Static Field | Industrial |
| Dread Presence | Ruin, Void |

---

### Logging Matrix

| Context | Level | Template |
|---------|-------|----------|
| Room Population Start | Debug | `"[Environment] Populating {RoomName} (Biome: {Biome}, Danger: {Danger}, HazardChance: {HazardChance:P0}, ConditionChance: {ConditionChance:P0})"` |
| Hazard Assigned | Info | `"[Environment] Assigned hazard [{HazardName}] to room {RoomName}"` |
| Condition Assigned | Info | `"[Environment] Assigned condition [{ConditionName}] to room {RoomName}"` |
| No Valid Templates | Warning | `"[Environment] No valid hazard templates for biome {Biome}"` |
| No Valid Conditions | Debug | `"[Environment] No valid conditions for biome {Biome}"` |
| Dungeon Population Start | Info | `"[Environment] Populating dungeon rooms"` |
| Dungeon Population Complete | Info | `"[Environment] Dungeon population complete. Assigned {HazardCount} hazards and {ConditionCount} conditions to {RoomCount} rooms"` |

---

### Test Coverage

**Total: 21 tests | Passed: 21 | Failed: 0 | Duration: 71ms**

#### EnvironmentPopulatorTests (21 tests)

##### BiomeEnvironmentMapping Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| GetConditionTypes_AllBiomes_ReturnsNonEmptyList | All biomes return at least one valid condition |
| GetConditionTypes_RuinBiome_ReturnsCorrectTypes | Ruin returns LowVisibility, DreadPresence |
| GetConditionTypes_IndustrialBiome_ReturnsCorrectTypes | Industrial returns ToxicAtmosphere, StaticField, ScorchingHeat |
| GetConditionTypes_OrganicBiome_ReturnsCorrectTypes | Organic returns BlightedGround, PsychicResonance, ToxicAtmosphere |
| GetConditionTypes_VoidBiome_ReturnsCorrectTypes | Void returns PsychicResonance, DreadPresence, DeepCold |
| GetDangerMultiplier_ReturnsCorrectValue | Theory test for all danger levels |

##### PopulateRoomAsync Tests (9 tests)

| Test Name | Description |
|-----------|-------------|
| PopulateRoom_HighChanceRoll_AssignsHazard | Lethal danger with passing roll assigns hazard |
| PopulateRoom_LowChanceRoll_NoHazard | Safe danger with failing roll assigns no hazard |
| PopulateRoom_BiomeFiltersTemplates | Industrial room only gets Industrial hazards |
| PopulateRoom_NoMatchingTemplates_NoHazard | Void room with only Ruin templates assigns nothing |
| PopulateRoom_AssignsCondition | Passing condition roll assigns condition |
| PopulateRoom_ExistingCondition_NotOverwritten | Room with existing ConditionId is not modified |
| PopulateRoom_CreatesHazardFromTemplate | DynamicHazard copies all HazardTemplate properties |
| PopulateRoom_HazardHasDormantState | Created hazard starts in Dormant state |
| PopulateRoom_HazardHasCorrectRoomId | Created hazard has correct RoomId |

##### PopulateDungeonAsync Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| PopulateDungeon_ProcessesAllRooms | All rooms in list are populated |
| PopulateDungeon_EmptyRoomList_NoErrors | Empty room list doesn't throw |

##### DungeonGeneratorTests Updates (4 affected tests)

| Test Name | Change |
|-----------|--------|
| All 25 tests | Added IEnvironmentPopulator mock to constructor |

---

### DI Registration

**Program.cs Additions:**
```csharp
// Register Environment Ecosystem Services (v0.3.3c)
services.AddScoped<IEnvironmentPopulator, EnvironmentPopulator>();

// Seed data (added HazardTemplateSeeder)
HazardTemplateSeeder.SeedAsync(context).GetAwaiter().GetResult();
```

**Lifetime Rationale:**
- `EnvironmentPopulator` registered as Scoped (per-request lifecycle, matches DungeonGenerator)
- Uses existing repositories and DiceService

---

### Verification Results

#### Build Output
```
Build succeeded.
    0 Error(s)
    73 Warning(s)

Time Elapsed 00:00:01.87
```

#### Test Output
```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)

Passed!  - Failed:     0, Passed:    21, Skipped:     0, Total:    21, Duration: 71 ms
```

---

### Running Tests

#### All EnvironmentPopulator Tests
```bash
dotnet test --filter "FullyQualifiedName~EnvironmentPopulatorTests"
```

#### Specific Test Categories
```bash
# BiomeEnvironmentMapping tests
dotnet test --filter "FullyQualifiedName~EnvironmentPopulatorTests&Name~GetConditionTypes"

# PopulateRoom tests
dotnet test --filter "FullyQualifiedName~EnvironmentPopulatorTests&Name~PopulateRoom"

# PopulateDungeon tests
dotnet test --filter "FullyQualifiedName~EnvironmentPopulatorTests&Name~PopulateDungeon"
```

---

### Next Steps

The following features are planned for later versions:

#### v0.4.0 - Worldbuilding Milestone
- **Room Biome Assignment**: DungeonGenerator assigns BiomeType and DangerLevel to generated rooms
- **Condition Persistence**: Save/load room conditions across sessions
- **Dynamic Condition Application**: Events/items that apply temporary conditions to rooms
- **Condition Intensity Levels**: Tiered severity (Mild/Moderate/Severe variants)
- **Player Condition Mitigation**: Equipment/abilities that reduce condition penalties

#### Deferred: AI Environmental Awareness
AI hazard avoidance was originally planned for this version but is incompatible with the current combat architecture:
- Combat is action-based, not tile-based
- Enemies select attack types, not movement destinations
- No spatial movement system exists for AI to avoid hazards

This feature is deferred to a future version that introduces tactical movement (e.g., v0.5.x).

---

### Breaking Changes

None. This release is backward compatible.

---

### Migration Notes

#### Database
A new migration is required to add the HazardTemplates table and BiomeTags columns.

**New Table: HazardTemplates**
- `Id` (Guid, PK)
- `Name` (varchar 100, Unique Index)
- `Description` (varchar 500)
- `HazardType` (int)
- `Trigger` (int)
- `EffectScript` (varchar 500)
- `MaxCooldown` (int)
- `OneTimeUse` (bool)
- `BiomeTags` (jsonb)

**AmbientConditions Table Alteration**
- Add `BiomeTags` (jsonb)

**Seeding**
Run `HazardTemplateSeeder.SeedAsync()` to populate 12 hazard templates.
Re-run `ConditionSeeder.SeedAsync()` to update condition BiomeTags (requires clearing existing data or manual update).

---

### Contributors

- Claude Code (Chronicle-Smith Agent)
