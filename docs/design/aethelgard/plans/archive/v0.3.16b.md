> **Archived** - This plan has been consolidated. See the complete version at [v0.3.16](../v0.3.x/v0.3.16.md).

# v0.3.16b: The Black Box (Emergency Save)

This sub-version implements the "Panic Save" protocol. It acts as the final line of defense against data loss. When the global exception handler (v0.3.16a) catches a critical failure, this service attempts to serialize the current game state to a separate recovery file before the process terminates.

Goal: Implement EmergencySaveService to perform a robust, synchronous serialization of the GameState during a crash event, ensuring players lose minimal progress even during fatal errors.

1. Architecture & Data Flow
The Panic Pipeline Unlike standard saving, which is asynchronous and safe, the Panic Save operates in a volatile environment where the application is actively dying.
	1	Trigger: Program.cs enters the catch block.
	2	Snapshot: The EmergencySaveService receives the in-memory GameState singleton.
	3	Validation: Checks if the state is viable (i.e., CurrentCharacter is not null).
	4	Serialization:
	◦	Clones critical data (Character, Inventory, Location).
	◦	Serializes to JSON using System.Text.Json (synchronously to avoid thread context switching issues during a crash).
	5	Persistence: Writes to data/saves/emergency.json.
	6	Feedback: Returns a boolean success flag to the CrashScreenRenderer.

2. Logic Decision Trees
A. Emergency Save Logic Input: GameState
	1	Viability Check:
	◦	Is GameState null? -> Abort.
	◦	Is GameState.CurrentCharacter null? -> Abort (Nothing to save).
	2	Pathing:
	◦	Ensure data/saves/ directory exists.
	3	Execution (Try/Catch):
	◦	Attempt: Write JSON text to emergency.json.
	◦	Success: Return true. Log to crash report.
	◦	Fail (IOException/SecurityException): Return false. Log specific error to crash report. Do not re-throw (this would hide the Crash Screen).
B. Load Game Logic (Update) Input: Load Game Menu
	1	Scan: Check for emergency.json.
	2	Display: If found, display as a distinct slot: "⚠ RECOVERY SAVE".
	3	Load: If selected, load normally but force an immediate autosave to a standard slot upon loading to clear the volatile status.

3. Deliverable Checklist
	•	Engine:
	◦	[ ] Implement EmergencySaveService.
	◦	[ ] Implement synchronous JSON serialization logic (bypassing the async SaveManager).
	•	Terminal:
	◦	[ ] Update Program.cs catch block to resolve and call EmergencySaveService.
	◦	[ ] Update CrashScreenRenderer to accept and display "Backup Status" (Saved/Failed).
	•	Core:
	◦	[ ] Update SaveGame model to allow null SlotNumber (representing emergency/file-based saves).

4. Code Implementation
A. The Emergency Service (RuneAndRust.Engine/Services/EmergencySaveService.cs)
public class EmergencySaveService
{
    private readonly string _backupPath = Path.Combine("data", "saves", "emergency.json");

    public bool TryEmergencySave(GameState state)
    {
        try
        {
            if (state?.CurrentCharacter == null) return false;

            // Manual mapping to SaveGame entity to ensure clean state
            var saveGame = new SaveGame
            {
                Id = Guid.NewGuid(),
                CharacterName = state.CurrentCharacter.Name,
                CreatedAt = DateTime.UtcNow,
                LastPlayed = DateTime.UtcNow,
                SerializedState = JsonSerializer.Serialize(state),
                SlotNumber = -1 // Indicator for Emergency Save
            };

            var json = JsonSerializer.Serialize(saveGame);

            // Synchronous write to ensure completion before process death
            File.WriteAllText(_backupPath, json);
            return true;
        }
        catch (Exception ex)
        {
            // Log locally or to console, but do not throw
            Console.WriteLine($"[System] Emergency save failed: {ex.Message}");
            return false;
        }
    }
}
B. Integration in Program.cs
catch (Exception ex)
{
    // 1. Attempt Save
    var gameState = host.Services.GetService<GameState>(); // Resolve directly if possible
    var emergencySvc = new EmergencySaveService(); // Or resolve if container is healthy
    bool saved = emergencySvc.TryEmergencySave(gameState);

    // 2. Render Crash Screen
    CrashScreenRenderer.Render(ex, saved);

    // 3. Log
    var crashSvc = new CrashService();
    crashSvc.LogCrash(ex);
}

5. Logging Requirements
Since the logger might be disposed or corrupted during a crash, EmergencySaveService relies on System.Console fallback or writes directly to the crash report text file handled by v0.3.16a.
System
Event
Level
Message Template
Properties
Recovery
Success
System
"Emergency state preserved to data/saves/emergency.json"
-
Recovery
Failure
System
"Emergency save failed. Error: {Exception}"
Exception

6. Testing Strategy
Unit Tests (EmergencySaveTests.cs)
	•	Save_WritesFile: Create a dummy GameState. Call TryEmergencySave. Assert File.Exists("data/saves/emergency.json").
	•	NullState_ReturnsFalse: Call with null state. Assert returns false and no file created.
Integration Test (The "Chaos Monkey"):
	•	Scenario:
	1	Start Game.
	2	Use debug command /crash_now.
	3	Verify Red Screen appears with "Backup: Success".
	4	Restart Game.
	5	Verify "Recovery Save" appears in Load menu.

7. Draft Changelog (v0.3.16b)
# v0.3.16b Changelog: The Black Box
**Release Date:** 2026-03-05

## Summary
This release implements the "Black Box" recovery system. In the event of a critical application crash, the engine now attempts a high-priority synchronous save of the current character state. This ensures that even if the game fails, the player's progress is not lost.

## New Features
*   **Panic Save:** Automatically serializes game state to `emergency.json` upon unhandled exceptions.
*   **Recovery Loader:** The Load Game menu now detects and offers to restore emergency saves.

## Technical Changes
*   Implemented `EmergencySaveService` for synchronous, fail-safe serialization.
*   Updated `CrashScreenRenderer` to display backup status.
*   Refactored `Program.cs` exception handling to prioritize data preservation.