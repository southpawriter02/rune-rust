# v0.0.5c Implementation Plan: Combat Integration

**Version:** 0.0.5c
**Parent:** v0.0.5 (Dice Pool System)
**Prerequisites:** v0.0.5a (Core Dice Engine) Complete, v0.0.5b (Skill Check System) Complete
**Status:** Ready for Implementation
**Target Tests:** 240 → 255 (+15 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current Combat System Analysis](#current-combat-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
5. [Combat Flow Diagrams](#combat-flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose
Phase 5c transforms the current static damage calculation combat system into a dice-based system where attack rolls determine hit/miss and damage rolls determine injury. This provides transparency, excitement, and tactical depth through visible randomization.

### Scope
- **In Scope:**
  - New `CombatRoundResult` and `MonsterCounterAttackResult` value objects with dice breakdown
  - Refactored `CombatService` to use `DiceService` for attack/damage rolls
  - Attack roll mechanics (1d10 + Finesse vs Defense)
  - Damage roll mechanics (weapon dice + Might)
  - Critical hit (natural 10) and critical miss (natural 1) support
  - Monster counterattack with dice
  - Updated `GameSessionService.TryAttack()` integration
  - Combat DTOs for dice display

- **Out of Scope:**
  - Presentation layer rendering (Phase 5d)
  - New combat commands (Phase 5d)
  - Multi-monster targeting (v0.0.6)
  - Status effects (v0.0.6)
  - Weapon equipment system (v0.0.7)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Attack roll dice | 1d10 | Consistent with d10-based resolution system |
| Attack modifier | Finesse | Represents precision and combat skill |
| Damage modifier | Might | Represents raw physical power |
| Default weapon dice | 1d6 | Balanced baseline for unarmed/basic weapon |
| Critical hit effect | Double damage dice | Standard RPG convention, exciting moments |
| Critical miss effect | Always miss | Prevents impossible hits, adds risk |
| Armor damage reduction | Defense / 2 | Partial mitigation, not full negation |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.5a (Core Dice Engine)

| Type | Location | Usage in 5c |
|------|----------|-------------|
| `DicePool` | `Domain/ValueObjects/DicePool.cs` | Create attack/damage dice pools |
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Store attack/damage roll results |
| `DiceService` | `Application/Services/DiceService.cs` | Roll attack and damage dice |
| `DiceType` | `Domain/Enums/DiceType.cs` | D10 for attacks, D6/D8 for damage |
| `AdvantageType` | `Domain/Enums/AdvantageType.cs` | Future: advantage on attacks |

### Dependencies from v0.0.5b (Skill Check System)

| Type | Location | Usage in 5c |
|------|----------|-------------|
| `SuccessLevel` | `Domain/Enums/SuccessLevel.cs` | Determine combat outcome levels |
| Attribute mapping pattern | `SkillCheckService.cs` | Map player attributes to combat bonuses |

### Dependencies from v0.0.4 Series

| Type | Location | Usage in 5c |
|------|----------|-------------|
| `Player` | `Domain/Entities/Player.cs` | Get attributes, apply damage |
| `PlayerAttributes` | `Domain/ValueObjects/PlayerAttributes.cs` | Finesse for attack, Might for damage |
| `Monster` | `Domain/Entities/Monster.cs` | Get Stats.Defense, apply damage |
| `Stats` | `Domain/ValueObjects/Stats.cs` | Monster attack/defense values |
| `CombatService` | `Domain/Services/CombatService.cs` | **MODIFY** - Add dice integration |
| `GameSessionService` | `Application/Services/GameSessionService.cs` | **MODIFY** - Pass DiceService |

---

## Current Combat System Analysis

### Existing CombatService

**Location:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs`

**Current Flow:**
```
ResolveCombatRound(Player, Monster)
    ├── Player attacks first
    │   ├── CalculateDamage(player.Stats.Attack, monster.Stats.Defense)
    │   │   └── baseDamage = max(1, attack - defense)
    │   │   └── variance = random(-2, +2)
    │   │   └── finalDamage = max(1, baseDamage + variance)
    │   └── monster.TakeDamage(playerDamage)
    │
    └── Monster counterattacks (if alive)
        ├── CalculateDamage(monster.Stats.Attack, player.Stats.Defense)
        └── player.TakeDamage(monsterDamage)
```

**Current Result Types:**
```csharp
// Current simple result
public record CombatResult(
    int DamageDealt,
    int DamageReceived,
    bool MonsterDefeated,
    bool PlayerDefeated);

public record MonsterAttackResult(
    int Damage,
    bool PlayerDefeated);
```

### New Dice-Based Flow

```
ResolveCombatRound(Player, Monster, DiceService)
    ├── Player Attack Phase
    │   ├── AttackRoll = DiceService.Roll(DicePool.D10())
    │   ├── AttackTotal = AttackRoll.Total + player.Attributes.Finesse
    │   ├── IsHit = (AttackTotal >= monster.Stats.Defense) || AttackRoll.IsNaturalMax
    │   ├── IsCriticalHit = AttackRoll.IsNaturalMax (natural 10)
    │   ├── IsCriticalMiss = AttackRoll.IsNaturalOne (natural 1)
    │   │
    │   └── If Hit (and not CriticalMiss):
    │       ├── DamagePool = GetPlayerDamagePool(player) // Default: 1d6
    │       ├── If CriticalHit: DamagePool.Count *= 2
    │       ├── DamageRoll = DiceService.Roll(DamagePool)
    │       ├── RawDamage = DamageRoll.Total + player.Attributes.Might
    │       ├── FinalDamage = max(1, RawDamage - monster.Stats.Defense / 2)
    │       └── monster.TakeDamage(FinalDamage)
    │
    └── Monster Counterattack Phase (if monster alive)
        ├── MonsterAttackRoll = DiceService.Roll(DicePool.D10())
        ├── MonsterAttackTotal = MonsterAttackRoll.Total + monster.Stats.Attack
        ├── MonsterIsHit = (MonsterAttackTotal >= player.Stats.Defense) || MonsterAttackRoll.IsNaturalMax
        │
        └── If Monster Hits:
            ├── MonsterDamagePool = GetMonsterDamagePool(monster) // Default: 1d6
            ├── MonsterDamageRoll = DiceService.Roll(MonsterDamagePool)
            ├── MonsterRawDamage = MonsterDamageRoll.Total
            ├── MonsterFinalDamage = max(1, MonsterRawDamage - player.Stats.Defense / 2)
            └── player.TakeDamage(MonsterFinalDamage)
```

---

## Detailed Implementation

### Domain Layer

#### 1. CombatResults.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CombatResults.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Detailed result of a single combat round with complete dice breakdown.
/// Includes both player attack and monster counterattack phases.
/// </summary>
/// <remarks>
/// <para>This record provides full transparency into combat resolution by exposing
/// all dice rolls, modifiers, and calculations.</para>
/// <para>Critical hits occur on natural 10 (max on d10) and double the damage dice.</para>
/// <para>Critical misses occur on natural 1 and always miss regardless of modifiers.</para>
/// </remarks>
/// <example>
/// <code>
/// var result = combatService.ResolveCombatRound(player, monster, diceService);
/// Console.WriteLine($"Attack: {result.AttackRoll.Total} + {player.Attributes.Finesse} = {result.AttackTotal}");
/// if (result.IsHit)
///     Console.WriteLine($"Damage: {result.DamageRoll?.Total} + {might} = {result.DamageDealt}");
/// </code>
/// </example>
public record CombatRoundResult
{
    // ===== Player Attack Phase =====

    /// <summary>
    /// Gets the player's attack roll result (1d10).
    /// </summary>
    public DiceRollResult AttackRoll { get; init; }

    /// <summary>
    /// Gets the total attack value (roll + Finesse modifier).
    /// </summary>
    public int AttackTotal { get; init; }

    /// <summary>
    /// Gets whether the attack hit the target.
    /// </summary>
    /// <remarks>
    /// True if AttackTotal >= monster's Defense, or if natural 10 was rolled.
    /// Always false if natural 1 was rolled (critical miss).
    /// </remarks>
    public bool IsHit { get; init; }

    /// <summary>
    /// Gets whether this was a critical hit (natural 10 on attack roll).
    /// </summary>
    /// <remarks>
    /// Critical hits automatically hit and double the damage dice.
    /// </remarks>
    public bool IsCriticalHit { get; init; }

    /// <summary>
    /// Gets whether this was a critical miss (natural 1 on attack roll).
    /// </summary>
    /// <remarks>
    /// Critical misses always miss regardless of modifiers.
    /// </remarks>
    public bool IsCriticalMiss { get; init; }

    /// <summary>
    /// Gets the player's damage roll result (if attack hit).
    /// </summary>
    /// <remarks>
    /// Null if the attack missed. Dice count is doubled on critical hits.
    /// </remarks>
    public DiceRollResult? DamageRoll { get; init; }

    /// <summary>
    /// Gets the final damage dealt to the monster after armor reduction.
    /// </summary>
    /// <remarks>
    /// Calculated as: max(1, DamageRoll.Total + Might - Defense/2)
    /// </remarks>
    public int DamageDealt { get; init; }

    // ===== Monster Counterattack Phase =====

    /// <summary>
    /// Gets the monster's counterattack result (if monster survived).
    /// </summary>
    /// <remarks>
    /// Null if the monster was defeated before counterattacking.
    /// </remarks>
    public MonsterCounterAttackResult? MonsterCounterAttack { get; init; }

    // ===== Combat Outcome =====

    /// <summary>
    /// Gets whether the monster was defeated this round.
    /// </summary>
    public bool MonsterDefeated { get; init; }

    /// <summary>
    /// Gets whether the player was defeated this round.
    /// </summary>
    public bool PlayerDefeated { get; init; }

    // ===== Computed Properties =====

    /// <summary>
    /// Gets the total damage received from the monster's counterattack.
    /// </summary>
    public int DamageReceived => MonsterCounterAttack?.DamageDealt ?? 0;

    /// <summary>
    /// Gets whether the combat round resulted in any damage to the monster.
    /// </summary>
    public bool DealtDamage => DamageDealt > 0;

    /// <summary>
    /// Gets whether the combat round resulted in any damage to the player.
    /// </summary>
    public bool ReceivedDamage => DamageReceived > 0;

    /// <summary>
    /// Gets whether either combatant was defeated this round.
    /// </summary>
    public bool CombatEnded => MonsterDefeated || PlayerDefeated;

    /// <summary>
    /// Gets the success level of the player's attack.
    /// </summary>
    public SuccessLevel AttackSuccessLevel
    {
        get
        {
            if (IsCriticalMiss) return SuccessLevel.CriticalFailure;
            if (IsCriticalHit) return SuccessLevel.CriticalSuccess;
            if (IsHit) return SuccessLevel.Success;
            return SuccessLevel.Failure;
        }
    }

    /// <summary>
    /// Creates a new combat round result.
    /// </summary>
    public CombatRoundResult(
        DiceRollResult attackRoll,
        int attackTotal,
        bool isHit,
        bool isCriticalHit,
        bool isCriticalMiss,
        DiceRollResult? damageRoll,
        int damageDealt,
        MonsterCounterAttackResult? monsterCounterAttack,
        bool monsterDefeated,
        bool playerDefeated)
    {
        AttackRoll = attackRoll;
        AttackTotal = attackTotal;
        IsHit = isHit;
        IsCriticalHit = isCriticalHit;
        IsCriticalMiss = isCriticalMiss;
        DamageRoll = damageRoll;
        DamageDealt = damageDealt;
        MonsterCounterAttack = monsterCounterAttack;
        MonsterDefeated = monsterDefeated;
        PlayerDefeated = playerDefeated;
    }

    /// <summary>
    /// Returns a formatted string summarizing the combat round.
    /// </summary>
    public override string ToString()
    {
        var attackDesc = IsCriticalHit ? "CRITICAL HIT!" :
                        IsCriticalMiss ? "CRITICAL MISS!" :
                        IsHit ? "Hit" : "Miss";

        var damageDesc = IsHit ? $" for {DamageDealt} damage" : "";
        var counterDesc = MonsterCounterAttack != null ?
            $" | Monster: {(MonsterCounterAttack.IsHit ? $"Hit for {MonsterCounterAttack.DamageDealt}" : "Miss")}" : "";

        return $"Attack: [{AttackRoll.Rolls[0]}] + mod = {AttackTotal} -> {attackDesc}{damageDesc}{counterDesc}";
    }
}

/// <summary>
/// Detailed result of a monster's counterattack with dice breakdown.
/// </summary>
/// <remarks>
/// Mirrors the player attack structure but for monster attacks.
/// Monsters use their Stats.Attack as their attack modifier.
/// </remarks>
public record MonsterCounterAttackResult
{
    /// <summary>
    /// Gets the monster's attack roll result (1d10).
    /// </summary>
    public DiceRollResult AttackRoll { get; init; }

    /// <summary>
    /// Gets the total attack value (roll + monster's Attack stat).
    /// </summary>
    public int AttackTotal { get; init; }

    /// <summary>
    /// Gets whether the monster's attack hit the player.
    /// </summary>
    public bool IsHit { get; init; }

    /// <summary>
    /// Gets whether this was a critical hit (natural 10).
    /// </summary>
    public bool IsCriticalHit { get; init; }

    /// <summary>
    /// Gets whether this was a critical miss (natural 1).
    /// </summary>
    public bool IsCriticalMiss { get; init; }

    /// <summary>
    /// Gets the monster's damage roll result (if attack hit).
    /// </summary>
    public DiceRollResult? DamageRoll { get; init; }

    /// <summary>
    /// Gets the final damage dealt to the player after armor reduction.
    /// </summary>
    public int DamageDealt { get; init; }

    /// <summary>
    /// Gets whether the player was defeated by this attack.
    /// </summary>
    public bool PlayerDefeated { get; init; }

    /// <summary>
    /// Gets the success level of the monster's attack.
    /// </summary>
    public SuccessLevel AttackSuccessLevel
    {
        get
        {
            if (IsCriticalMiss) return SuccessLevel.CriticalFailure;
            if (IsCriticalHit) return SuccessLevel.CriticalSuccess;
            if (IsHit) return SuccessLevel.Success;
            return SuccessLevel.Failure;
        }
    }

    /// <summary>
    /// Creates a new monster counterattack result.
    /// </summary>
    public MonsterCounterAttackResult(
        DiceRollResult attackRoll,
        int attackTotal,
        bool isHit,
        bool isCriticalHit,
        bool isCriticalMiss,
        DiceRollResult? damageRoll,
        int damageDealt,
        bool playerDefeated)
    {
        AttackRoll = attackRoll;
        AttackTotal = attackTotal;
        IsHit = isHit;
        IsCriticalHit = isCriticalHit;
        IsCriticalMiss = isCriticalMiss;
        DamageRoll = damageRoll;
        DamageDealt = damageDealt;
        PlayerDefeated = playerDefeated;
    }

    /// <summary>
    /// Returns a formatted string summarizing the counterattack.
    /// </summary>
    public override string ToString()
    {
        var attackDesc = IsCriticalHit ? "CRITICAL HIT!" :
                        IsCriticalMiss ? "CRITICAL MISS!" :
                        IsHit ? "Hit" : "Miss";

        var damageDesc = IsHit ? $" for {DamageDealt} damage" : "";

        return $"Monster Attack: [{AttackRoll.Rolls[0]}] + mod = {AttackTotal} -> {attackDesc}{damageDesc}";
    }
}
```

#### 2. Update CombatService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs`

```csharp
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Represents the outcome of a single round of combat (legacy simple result).
/// </summary>
/// <remarks>
/// Maintained for backwards compatibility. Consider using <see cref="CombatRoundResult"/>
/// for detailed dice breakdown.
/// </remarks>
/// <param name="DamageDealt">The amount of damage the player dealt to the monster.</param>
/// <param name="DamageReceived">The amount of damage the player received from the monster.</param>
/// <param name="MonsterDefeated">True if the monster was defeated this round.</param>
/// <param name="PlayerDefeated">True if the player was defeated this round.</param>
public record CombatResult(
    int DamageDealt,
    int DamageReceived,
    bool MonsterDefeated,
    bool PlayerDefeated
);

/// <summary>
/// Represents the outcome of a monster's attack on a player (legacy simple result).
/// </summary>
/// <param name="Damage">The amount of damage dealt to the player.</param>
/// <param name="PlayerDefeated">True if the player was defeated by this attack.</param>
public record MonsterAttackResult(
    int Damage,
    bool PlayerDefeated
);

/// <summary>
/// Handles combat resolution between players and monsters using dice-based mechanics.
/// </summary>
/// <remarks>
/// <para>The CombatService implements a turn-based combat system where the player
/// always attacks first. Attack and damage are determined by dice rolls:</para>
/// <list type="bullet">
///   <item><description>Attack: 1d10 + Finesse vs target Defense</description></item>
///   <item><description>Damage: weapon dice (default 1d6) + Might - armor</description></item>
///   <item><description>Critical hit on natural 10: always hits, double damage dice</description></item>
///   <item><description>Critical miss on natural 1: always misses</description></item>
/// </list>
/// </remarks>
public class CombatService
{
    /// <summary>
    /// Random number generator for legacy damage variance calculations.
    /// </summary>
    private readonly Random _random = new();

    /// <summary>
    /// Logger instance for combat diagnostics.
    /// </summary>
    private readonly ILogger<CombatService> _logger;

    /// <summary>
    /// Default damage dice pool for player attacks (1d6).
    /// </summary>
    private static readonly DicePool DefaultPlayerDamagePool = DicePool.D6();

    /// <summary>
    /// Default damage dice pool for monster attacks (1d6).
    /// </summary>
    private static readonly DicePool DefaultMonsterDamagePool = DicePool.D6();

    /// <summary>
    /// Creates a new combat service instance.
    /// </summary>
    /// <param name="logger">Optional logger for combat diagnostics. If null, a no-op logger is used.</param>
    public CombatService(ILogger<CombatService>? logger = null)
    {
        _logger = logger ?? NullLogger<CombatService>.Instance;
        _logger.LogDebug("CombatService initialized");
    }

    /// <summary>
    /// Resolves a single round of combat between a player and a monster using dice-based mechanics.
    /// </summary>
    /// <param name="player">The player engaging in combat.</param>
    /// <param name="monster">The monster being fought.</param>
    /// <param name="diceService">The dice rolling service.</param>
    /// <returns>A <see cref="CombatRoundResult"/> containing the detailed outcome of the combat round.</returns>
    /// <exception cref="ArgumentNullException">Thrown when player, monster, or diceService is null.</exception>
    /// <remarks>
    /// Combat proceeds as follows:
    /// <list type="number">
    /// <item>Player makes attack roll (1d10 + Finesse) vs monster's Defense.</item>
    /// <item>If hit, player rolls damage (weapon dice + Might - monster armor).</item>
    /// <item>If the monster survives, it counterattacks with the same mechanics.</item>
    /// <item>The result indicates all dice rolls, damage dealt/received, and defeat status.</item>
    /// </list>
    /// </remarks>
    public CombatRoundResult ResolveCombatRound(Player player, Monster monster, IDiceService diceService)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(monster);
        ArgumentNullException.ThrowIfNull(diceService);

        _logger.LogDebug(
            "Resolving dice-based combat round - Player: {PlayerName} (HP:{PlayerHP}, Finesse:{Finesse}, Might:{Might}) vs " +
            "Monster: {MonsterName} (HP:{MonsterHP}, ATK:{MonsterATK}, DEF:{MonsterDEF})",
            player.Name,
            player.Health,
            player.Attributes.Finesse,
            player.Attributes.Might,
            monster.Name,
            monster.Health,
            monster.Stats.Attack,
            monster.Stats.Defense);

        // ===== Player Attack Phase =====
        var playerAttackResult = ResolvePlayerAttack(player, monster, diceService);

        // Apply player damage to monster
        if (playerAttackResult.IsHit && playerAttackResult.DamageDealt > 0)
        {
            monster.TakeDamage(playerAttackResult.DamageDealt);
            _logger.LogDebug(
                "Player dealt {Damage} damage to {Monster} (HP: {OldHP} -> {NewHP})",
                playerAttackResult.DamageDealt,
                monster.Name,
                monster.Health + playerAttackResult.DamageDealt,
                monster.Health);
        }

        // ===== Monster Counterattack Phase =====
        MonsterCounterAttackResult? monsterCounterAttack = null;

        if (monster.IsAlive)
        {
            monsterCounterAttack = ResolveMonsterCounterAttack(monster, player, diceService);

            // Apply monster damage to player
            if (monsterCounterAttack.IsHit && monsterCounterAttack.DamageDealt > 0)
            {
                player.TakeDamage(monsterCounterAttack.DamageDealt);
                _logger.LogDebug(
                    "{Monster} dealt {Damage} damage to {Player} (HP: {OldHP} -> {NewHP})",
                    monster.Name,
                    monsterCounterAttack.DamageDealt,
                    player.Name,
                    player.Health + monsterCounterAttack.DamageDealt,
                    player.Health);
            }
        }
        else
        {
            _logger.LogDebug("Monster defeated before counterattack");
        }

        // ===== Create Result =====
        var result = new CombatRoundResult(
            attackRoll: playerAttackResult.AttackRoll,
            attackTotal: playerAttackResult.AttackTotal,
            isHit: playerAttackResult.IsHit,
            isCriticalHit: playerAttackResult.IsCriticalHit,
            isCriticalMiss: playerAttackResult.IsCriticalMiss,
            damageRoll: playerAttackResult.DamageRoll,
            damageDealt: playerAttackResult.DamageDealt,
            monsterCounterAttack: monsterCounterAttack,
            monsterDefeated: monster.IsDefeated,
            playerDefeated: player.IsDead
        );

        LogCombatRoundResult(result, player.Name, monster.Name);

        return result;
    }

    /// <summary>
    /// Resolves the player's attack against a monster.
    /// </summary>
    private (DiceRollResult AttackRoll, int AttackTotal, bool IsHit, bool IsCriticalHit, bool IsCriticalMiss, DiceRollResult? DamageRoll, int DamageDealt)
        ResolvePlayerAttack(Player player, Monster monster, IDiceService diceService)
    {
        // Roll attack (1d10)
        var attackRoll = diceService.Roll(DicePool.D10());
        var attackModifier = player.Attributes.Finesse;
        var attackTotal = attackRoll.Total + attackModifier;

        // Determine hit/critical
        var isCriticalHit = attackRoll.IsNaturalMax; // Natural 10
        var isCriticalMiss = attackRoll.IsNaturalOne; // Natural 1
        var isHit = !isCriticalMiss && (attackTotal >= monster.Stats.Defense || isCriticalHit);

        _logger.LogDebug(
            "Player attack roll: [{Roll}] + {Modifier} (Finesse) = {Total} vs DEF {Defense} -> {Result}",
            attackRoll.Rolls[0],
            attackModifier,
            attackTotal,
            monster.Stats.Defense,
            isCriticalHit ? "CRITICAL HIT!" : isCriticalMiss ? "CRITICAL MISS!" : isHit ? "Hit" : "Miss");

        DiceRollResult? damageRoll = null;
        int damageDealt = 0;

        if (isHit)
        {
            // Roll damage
            var damagePool = GetPlayerDamagePool(player);

            // Critical hit doubles damage dice
            if (isCriticalHit)
            {
                damagePool = damagePool with { Count = damagePool.Count * 2 };
                _logger.LogDebug("Critical hit! Damage dice doubled to {Pool}", damagePool);
            }

            damageRoll = diceService.Roll(damagePool);
            var mightBonus = player.Attributes.Might;
            var rawDamage = damageRoll.Total + mightBonus;
            var armorReduction = monster.Stats.Defense / 2;
            damageDealt = Math.Max(1, rawDamage - armorReduction);

            _logger.LogDebug(
                "Player damage roll: [{Rolls}] + {Might} (Might) = {Raw} - {Armor} (armor) = {Final} damage",
                string.Join(", ", damageRoll.Rolls),
                mightBonus,
                rawDamage,
                armorReduction,
                damageDealt);
        }

        return (attackRoll, attackTotal, isHit, isCriticalHit, isCriticalMiss, damageRoll, damageDealt);
    }

    /// <summary>
    /// Resolves the monster's counterattack against the player.
    /// </summary>
    private MonsterCounterAttackResult ResolveMonsterCounterAttack(Monster monster, Player player, IDiceService diceService)
    {
        // Roll attack (1d10)
        var attackRoll = diceService.Roll(DicePool.D10());
        var attackModifier = monster.Stats.Attack;
        var attackTotal = attackRoll.Total + attackModifier;

        // Determine hit/critical
        var isCriticalHit = attackRoll.IsNaturalMax; // Natural 10
        var isCriticalMiss = attackRoll.IsNaturalOne; // Natural 1
        var isHit = !isCriticalMiss && (attackTotal >= player.Stats.Defense || isCriticalHit);

        _logger.LogDebug(
            "Monster attack roll: [{Roll}] + {Modifier} (ATK) = {Total} vs DEF {Defense} -> {Result}",
            attackRoll.Rolls[0],
            attackModifier,
            attackTotal,
            player.Stats.Defense,
            isCriticalHit ? "CRITICAL HIT!" : isCriticalMiss ? "CRITICAL MISS!" : isHit ? "Hit" : "Miss");

        DiceRollResult? damageRoll = null;
        int damageDealt = 0;

        if (isHit)
        {
            // Roll damage
            var damagePool = GetMonsterDamagePool(monster);

            // Critical hit doubles damage dice
            if (isCriticalHit)
            {
                damagePool = damagePool with { Count = damagePool.Count * 2 };
                _logger.LogDebug("Monster critical hit! Damage dice doubled to {Pool}", damagePool);
            }

            damageRoll = diceService.Roll(damagePool);
            var rawDamage = damageRoll.Total;
            var armorReduction = player.Stats.Defense / 2;
            damageDealt = Math.Max(1, rawDamage - armorReduction);

            _logger.LogDebug(
                "Monster damage roll: [{Rolls}] = {Raw} - {Armor} (armor) = {Final} damage",
                string.Join(", ", damageRoll.Rolls),
                rawDamage,
                armorReduction,
                damageDealt);
        }

        return new MonsterCounterAttackResult(
            attackRoll: attackRoll,
            attackTotal: attackTotal,
            isHit: isHit,
            isCriticalHit: isCriticalHit,
            isCriticalMiss: isCriticalMiss,
            damageRoll: damageRoll,
            damageDealt: damageDealt,
            playerDefeated: player.IsDead
        );
    }

    /// <summary>
    /// Gets the damage dice pool for a player's attack.
    /// </summary>
    /// <param name="player">The attacking player.</param>
    /// <returns>The dice pool to roll for damage.</returns>
    /// <remarks>
    /// Currently returns default 1d6. Future versions will derive this from equipped weapon.
    /// </remarks>
    private DicePool GetPlayerDamagePool(Player player)
    {
        // TODO: In v0.0.7, derive from equipped weapon
        // For now, use default 1d6
        return DefaultPlayerDamagePool;
    }

    /// <summary>
    /// Gets the damage dice pool for a monster's attack.
    /// </summary>
    /// <param name="monster">The attacking monster.</param>
    /// <returns>The dice pool to roll for damage.</returns>
    /// <remarks>
    /// Currently returns default 1d6. Future versions may derive from monster type/level.
    /// </remarks>
    private DicePool GetMonsterDamagePool(Monster monster)
    {
        // TODO: In future version, derive from monster type/level
        // For now, use default 1d6
        return DefaultMonsterDamagePool;
    }

    /// <summary>
    /// Logs the complete combat round result.
    /// </summary>
    private void LogCombatRoundResult(CombatRoundResult result, string playerName, string monsterName)
    {
        var attackResult = result.IsCriticalHit ? "Critical Hit" :
                          result.IsCriticalMiss ? "Critical Miss" :
                          result.IsHit ? "Hit" : "Miss";

        _logger.LogInformation(
            "Combat round complete - {Player} {AttackResult}: [{AttackRoll}]+{Mod}={Total} vs DEF, " +
            "Dealt: {DamageDealt}, Received: {DamageReceived}, " +
            "MonsterDefeated: {MonsterDefeated}, PlayerDefeated: {PlayerDefeated}",
            playerName,
            attackResult,
            result.AttackRoll.Rolls[0],
            result.AttackTotal - result.AttackRoll.Total,
            result.AttackTotal,
            result.DamageDealt,
            result.DamageReceived,
            result.MonsterDefeated,
            result.PlayerDefeated);
    }

    /// <summary>
    /// Generates a human-readable description of a dice-based combat round's outcome.
    /// </summary>
    /// <param name="result">The combat round result to describe.</param>
    /// <param name="playerName">The name of the player for the description.</param>
    /// <param name="monsterName">The name of the monster for the description.</param>
    /// <returns>A multi-line string describing what happened during combat.</returns>
    public string GetCombatDescription(CombatRoundResult result, string playerName, string monsterName)
    {
        var lines = new List<string>();

        // Player attack description
        if (result.IsCriticalHit)
        {
            lines.Add($"{playerName} lands a CRITICAL HIT on the {monsterName}!");
            if (result.DamageDealt > 0)
                lines.Add($"Rolling double damage dice: {result.DamageDealt} damage!");
        }
        else if (result.IsCriticalMiss)
        {
            lines.Add($"{playerName} fumbles! The attack goes wide.");
        }
        else if (result.IsHit)
        {
            lines.Add($"{playerName} hits the {monsterName} for {result.DamageDealt} damage!");
        }
        else
        {
            lines.Add($"{playerName} swings at the {monsterName} but misses!");
        }

        // Monster defeat
        if (result.MonsterDefeated)
        {
            lines.Add($"The {monsterName} has been defeated!");
        }
        // Monster counterattack
        else if (result.MonsterCounterAttack != null)
        {
            var counter = result.MonsterCounterAttack;
            if (counter.IsCriticalHit)
            {
                lines.Add($"The {monsterName} lands a CRITICAL HIT!");
                lines.Add($"Rolling double damage dice: {counter.DamageDealt} damage!");
            }
            else if (counter.IsCriticalMiss)
            {
                lines.Add($"The {monsterName} stumbles and misses!");
            }
            else if (counter.IsHit)
            {
                lines.Add($"The {monsterName} strikes back for {counter.DamageDealt} damage!");
            }
            else
            {
                lines.Add($"The {monsterName} attacks but {playerName} dodges!");
            }
        }

        // Player defeat
        if (result.PlayerDefeated)
        {
            lines.Add($"{playerName} has fallen in battle...");
        }

        return string.Join(Environment.NewLine, lines);
    }

    // ===== Legacy Methods (Backwards Compatibility) =====

    /// <summary>
    /// Resolves a single round of combat between a player and a monster using legacy static calculations.
    /// </summary>
    /// <param name="player">The player engaging in combat.</param>
    /// <param name="monster">The monster being fought.</param>
    /// <returns>A <see cref="CombatResult"/> containing the outcome of the combat round.</returns>
    /// <exception cref="ArgumentNullException">Thrown when player or monster is null.</exception>
    /// <remarks>
    /// This is the legacy method maintained for backwards compatibility.
    /// New code should use <see cref="ResolveCombatRound(Player, Monster, IDiceService)"/>.
    /// </remarks>
    [Obsolete("Use ResolveCombatRound(Player, Monster, IDiceService) for dice-based combat")]
    public CombatResult ResolveCombatRound(Player player, Monster monster)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(monster);

        _logger.LogDebug(
            "Resolving legacy combat round - Player: {PlayerName} vs Monster: {MonsterName}",
            player.Name,
            monster.Name);

        // Player attacks first
        var playerDamage = CalculateDamage(player.Stats.Attack, monster.Stats.Defense);
        var actualPlayerDamage = monster.TakeDamage(playerDamage);

        var monsterDamage = 0;
        var actualMonsterDamage = 0;

        // Monster attacks if still alive
        if (monster.IsAlive)
        {
            monsterDamage = CalculateDamage(monster.Stats.Attack, player.Stats.Defense);
            actualMonsterDamage = player.TakeDamage(monsterDamage);
        }

        return new CombatResult(
            DamageDealt: actualPlayerDamage,
            DamageReceived: actualMonsterDamage,
            MonsterDefeated: monster.IsDefeated,
            PlayerDefeated: player.IsDead
        );
    }

    /// <summary>
    /// Calculates the damage dealt based on attack and defense values (legacy).
    /// </summary>
    private int CalculateDamage(int attack, int defense)
    {
        var baseDamage = Math.Max(1, attack - defense);
        var variance = _random.Next(-2, 3);
        return Math.Max(1, baseDamage + variance);
    }

    /// <summary>
    /// Resolves a monster's attack against a player (legacy).
    /// </summary>
    [Obsolete("Use dice-based combat resolution")]
    public MonsterAttackResult MonsterAttack(Monster monster, Player player)
    {
        ArgumentNullException.ThrowIfNull(monster);
        ArgumentNullException.ThrowIfNull(player);

        if (!monster.IsAlive)
        {
            return new MonsterAttackResult(0, false);
        }

        var damage = CalculateDamage(monster.Stats.Attack, player.Stats.Defense);
        var actualDamage = player.TakeDamage(damage);

        return new MonsterAttackResult(actualDamage, player.IsDead);
    }

    /// <summary>
    /// Generates a description of a monster's attack (legacy).
    /// </summary>
    [Obsolete("Use GetCombatDescription with CombatRoundResult")]
    public string GetMonsterAttackDescription(MonsterAttackResult result, string monsterName, string playerName)
    {
        if (result.Damage == 0)
            return $"The {monsterName} misses!";

        var description = $"The {monsterName} strikes back for {result.Damage} damage!";

        if (result.PlayerDefeated)
            description += $" {playerName} has fallen in battle...";

        return description;
    }

    /// <summary>
    /// Generates a human-readable description of a legacy combat round's outcome.
    /// </summary>
    [Obsolete("Use GetCombatDescription with CombatRoundResult")]
    public string GetCombatDescription(CombatResult result, string playerName, string monsterName)
    {
        var lines = new List<string>();

        if (result.DamageDealt > 0)
        {
            lines.Add($"{playerName} attacks the {monsterName} for {result.DamageDealt} damage!");
        }

        if (result.MonsterDefeated)
        {
            lines.Add($"The {monsterName} has been defeated!");
        }
        else if (result.DamageReceived > 0)
        {
            lines.Add($"The {monsterName} strikes back for {result.DamageReceived} damage!");
        }

        if (result.PlayerDefeated)
        {
            lines.Add($"{playerName} has fallen in battle...");
        }

        return string.Join(Environment.NewLine, lines);
    }
}
```

#### 3. IDiceService Interface (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IDiceService.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Interface for dice rolling services.
/// </summary>
/// <remarks>
/// Abstraction allows for mock implementations in testing and alternative
/// implementations (e.g., seeded random, fixed rolls for testing).
/// </remarks>
public interface IDiceService
{
    /// <summary>
    /// Rolls a dice pool and returns the result.
    /// </summary>
    /// <param name="pool">The dice pool to roll.</param>
    /// <param name="advantageType">Whether to roll with advantage or disadvantage.</param>
    /// <returns>The complete roll result with breakdown.</returns>
    DiceRollResult Roll(DicePool pool, AdvantageType advantageType = AdvantageType.Normal);

    /// <summary>
    /// Parses dice notation and rolls.
    /// </summary>
    /// <param name="notation">Dice notation (e.g., "3d6+5").</param>
    /// <param name="advantageType">Advantage/disadvantage.</param>
    /// <returns>Roll result.</returns>
    DiceRollResult Roll(string notation, AdvantageType advantageType = AdvantageType.Normal);

    /// <summary>
    /// Convenience method for rolling a single die type.
    /// </summary>
    DiceRollResult Roll(DiceType diceType, int count = 1, int modifier = 0);

    /// <summary>
    /// Quick roll returning just the total.
    /// </summary>
    int RollTotal(DicePool pool);

    /// <summary>
    /// Quick roll returning just the total from notation.
    /// </summary>
    int RollTotal(string notation);
}
```

### Application Layer

#### 4. Update DiceService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/DiceService.cs`

Add interface implementation:

```csharp
// Change class declaration to implement interface:
public class DiceService : IDiceService
{
    // ... existing implementation unchanged ...
}
```

#### 5. Combat DTOs (NEW)

**File:** `src/Core/RuneAndRust.Application/DTOs/CombatDtos.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for combat round results displayed to the player.
/// </summary>
/// <param name="AttackRoll">The attack dice roll details.</param>
/// <param name="AttackTotal">Total attack value including modifiers.</param>
/// <param name="IsHit">Whether the attack hit.</param>
/// <param name="IsCriticalHit">Whether this was a critical hit.</param>
/// <param name="IsCriticalMiss">Whether this was a critical miss.</param>
/// <param name="DamageRoll">The damage dice roll details (null if miss).</param>
/// <param name="DamageDealt">Final damage dealt.</param>
/// <param name="MonsterCounterAttack">Monster's counterattack details.</param>
/// <param name="MonsterDefeated">Whether the monster was defeated.</param>
/// <param name="PlayerDefeated">Whether the player was defeated.</param>
/// <param name="AttackSuccessLevel">The success level of the attack.</param>
/// <param name="Descriptor">Optional flavor text.</param>
public record CombatRoundResultDto(
    DiceRollDto AttackRoll,
    int AttackTotal,
    bool IsHit,
    bool IsCriticalHit,
    bool IsCriticalMiss,
    DiceRollDto? DamageRoll,
    int DamageDealt,
    MonsterCounterAttackResultDto? MonsterCounterAttack,
    bool MonsterDefeated,
    bool PlayerDefeated,
    string AttackSuccessLevel,
    string? Descriptor = null)
{
    /// <summary>
    /// Creates a DTO from a domain combat round result.
    /// </summary>
    public static CombatRoundResultDto FromDomainResult(
        CombatRoundResult result,
        string? descriptor = null)
    {
        return new CombatRoundResultDto(
            DiceRollDto.FromDomainResult(result.AttackRoll),
            result.AttackTotal,
            result.IsHit,
            result.IsCriticalHit,
            result.IsCriticalMiss,
            result.DamageRoll != null ? DiceRollDto.FromDomainResult(result.DamageRoll.Value) : null,
            result.DamageDealt,
            result.MonsterCounterAttack != null
                ? MonsterCounterAttackResultDto.FromDomainResult(result.MonsterCounterAttack)
                : null,
            result.MonsterDefeated,
            result.PlayerDefeated,
            result.AttackSuccessLevel.ToString(),
            descriptor);
    }

    /// <summary>
    /// Gets the total damage received from the monster's counterattack.
    /// </summary>
    public int DamageReceived => MonsterCounterAttack?.DamageDealt ?? 0;

    /// <summary>
    /// Gets whether combat ended this round.
    /// </summary>
    public bool CombatEnded => MonsterDefeated || PlayerDefeated;
}

/// <summary>
/// DTO for monster counterattack results.
/// </summary>
/// <param name="AttackRoll">The attack dice roll details.</param>
/// <param name="AttackTotal">Total attack value including modifiers.</param>
/// <param name="IsHit">Whether the attack hit.</param>
/// <param name="IsCriticalHit">Whether this was a critical hit.</param>
/// <param name="IsCriticalMiss">Whether this was a critical miss.</param>
/// <param name="DamageRoll">The damage dice roll details (null if miss).</param>
/// <param name="DamageDealt">Final damage dealt.</param>
/// <param name="PlayerDefeated">Whether the player was defeated.</param>
/// <param name="AttackSuccessLevel">The success level of the attack.</param>
public record MonsterCounterAttackResultDto(
    DiceRollDto AttackRoll,
    int AttackTotal,
    bool IsHit,
    bool IsCriticalHit,
    bool IsCriticalMiss,
    DiceRollDto? DamageRoll,
    int DamageDealt,
    bool PlayerDefeated,
    string AttackSuccessLevel)
{
    /// <summary>
    /// Creates a DTO from a domain monster counterattack result.
    /// </summary>
    public static MonsterCounterAttackResultDto FromDomainResult(MonsterCounterAttackResult result)
    {
        return new MonsterCounterAttackResultDto(
            DiceRollDto.FromDomainResult(result.AttackRoll),
            result.AttackTotal,
            result.IsHit,
            result.IsCriticalHit,
            result.IsCriticalMiss,
            result.DamageRoll != null ? DiceRollDto.FromDomainResult(result.DamageRoll.Value) : null,
            result.DamageDealt,
            result.PlayerDefeated,
            result.AttackSuccessLevel.ToString());
    }
}
```

#### 6. Update GameSessionService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

Update `TryAttack()` method to use dice-based combat:

```csharp
// Add field for DiceService
private readonly IDiceService _diceService;

// Update constructor to accept DiceService
public GameSessionService(
    IGameConfigurationProvider configProvider,
    ILogger<GameSessionService> logger,
    IDiceService diceService,
    // ... other dependencies ...
)
{
    // ... existing initialization ...
    _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
}

/// <summary>
/// Attempts to attack the first alive monster in the current room using dice-based combat.
/// </summary>
/// <returns>A tuple with success status and combat description.</returns>
public (bool Success, string Message, CombatRoundResult? Result) TryAttack()
{
    if (_currentSession == null)
    {
        _logger.LogWarning("TryAttack called with no active session");
        return (false, "No active game session.", null);
    }

    var currentRoom = GetCurrentRoom();
    if (currentRoom == null)
    {
        return (false, "You are nowhere.", null);
    }

    var monster = currentRoom.GetAliveMonsters().FirstOrDefault();
    if (monster == null)
    {
        return (false, "There's nothing to attack here.", null);
    }

    var player = _currentSession.Player;

    _logger.LogInformation(
        "Combat initiated: {Player} (HP:{PlayerHP}, Finesse:{Finesse}, Might:{Might}) attacks {Monster} (HP:{MonsterHP}, DEF:{MonsterDef})",
        player.Name,
        player.Health,
        player.Attributes.Finesse,
        player.Attributes.Might,
        monster.Name,
        monster.Health,
        monster.Stats.Defense);

    // Use dice-based combat
    var result = _combatService.ResolveCombatRound(player, monster, _diceService);
    var description = _combatService.GetCombatDescription(result, player.Name, monster.Name);

    if (result.MonsterDefeated)
    {
        _logger.LogInformation(
            "{Player} defeated {Monster}!",
            player.Name,
            monster.Name);
    }

    if (result.PlayerDefeated)
    {
        _logger.LogInformation(
            "{Player} was defeated by {Monster}",
            player.Name,
            monster.Name);
        _currentSession.GameState = GameState.GameOver;
    }

    return (true, description, result);
}
```

---

## Combat Flow Diagrams

### Complete Combat Round Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        DICE-BASED COMBAT ROUND                               │
└─────────────────────────────────────────────────────────────────────────────┘

    TryAttack() called
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         PLAYER ATTACK PHASE                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────┐                                                     │
│  │ 1. ATTACK ROLL     │                                                     │
│  │    Roll 1d10       │                                                     │
│  │    + Finesse       │                                                     │
│  └──────────┬─────────┘                                                     │
│             │                                                               │
│             ▼                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 2. CRITICAL CHECK                                                   │    │
│  │    Natural 10? → CRITICAL HIT (auto-hit, double damage dice)       │    │
│  │    Natural 1?  → CRITICAL MISS (auto-miss)                         │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│             │                                                               │
│             ▼                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 3. HIT DETERMINATION                                                │    │
│  │    If not Critical Miss:                                           │    │
│  │    AttackTotal >= Monster.Defense? → HIT                           │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│             │                                                               │
│             ▼                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 4. DAMAGE ROLL (if hit)                                             │    │
│  │    Roll weapon dice (default 1d6, 2d6 if critical)                 │    │
│  │    + Might bonus                                                    │    │
│  │    - (Monster.Defense / 2) armor reduction                         │    │
│  │    = Final Damage (minimum 1)                                      │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│             │                                                               │
│             ▼                                                               │
│  ┌────────────────────┐                                                     │
│  │ 5. APPLY DAMAGE    │                                                     │
│  │    monster.TakeDamage(damage)                                           │
│  │    Check: monster.IsDefeated?                                           │
│  └──────────┬─────────┘                                                     │
│             │                                                               │
└─────────────┼───────────────────────────────────────────────────────────────┘
              │
              ▼
     ┌────────────────┐
     │ Monster Alive? │
     └────────┬───────┘
              │
    ┌─────────┴─────────┐
    │ NO                │ YES
    ▼                   ▼
┌──────────┐   ┌───────────────────────────────────────────────────────────────┐
│ Monster  │   │                   MONSTER COUNTERATTACK                        │
│ Defeated │   ├───────────────────────────────────────────────────────────────┤
│ Skip     │   │  Same flow as player attack:                                  │
│ Counter  │   │  1. Attack Roll (1d10 + Monster.Attack)                       │
└──────────┘   │  2. Critical Check (natural 10/1)                             │
               │  3. Hit Determination vs Player.Defense                        │
               │  4. Damage Roll if hit (1d6, 2d6 if critical)                 │
               │     - (Player.Defense / 2) armor reduction                    │
               │  5. Apply Damage to Player                                    │
               │  6. Check: player.IsDead?                                     │
               └───────────────────────────────────────────────────────────────┘
                            │
                            ▼
              ┌───────────────────────────────┐
              │ CREATE CombatRoundResult      │
              │ - AttackRoll, AttackTotal     │
              │ - IsHit, IsCriticalHit/Miss   │
              │ - DamageRoll, DamageDealt     │
              │ - MonsterCounterAttack        │
              │ - MonsterDefeated/PlayerDefeated │
              └───────────────────────────────┘
```

### Attack Resolution Decision Tree

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      ATTACK RESOLUTION DECISION TREE                         │
└─────────────────────────────────────────────────────────────────────────────┘

                         ┌─────────────────┐
                         │   Roll 1d10     │
                         └────────┬────────┘
                                  │
                    ┌─────────────┼─────────────┐
                    │             │             │
                    ▼             ▼             ▼
             ┌───────────┐ ┌───────────┐ ┌───────────┐
             │ Roll = 1  │ │ Roll 2-9  │ │ Roll = 10 │
             └─────┬─────┘ └─────┬─────┘ └─────┬─────┘
                   │             │             │
                   ▼             ▼             ▼
    ┌─────────────────────┐   ┌─────────────────────┐   ┌─────────────────────┐
    │   CRITICAL MISS     │   │   CALCULATE TOTAL   │   │   CRITICAL HIT      │
    │   Always fails      │   │   Roll + Modifier   │   │   Always hits       │
    │   IsHit = false     │   │   vs Defense        │   │   IsHit = true      │
    │   No damage roll    │   └──────────┬──────────┘   │   Double damage dice│
    └─────────────────────┘              │              └─────────────────────┘
                                         │
                           ┌─────────────┴─────────────┐
                           │                           │
                           ▼                           ▼
                 ┌───────────────────┐      ┌───────────────────┐
                 │ Total >= Defense  │      │ Total < Defense   │
                 │     HIT           │      │     MISS          │
                 │ → Roll Damage     │      │ → No Damage       │
                 └───────────────────┘      └───────────────────┘
```

### Damage Calculation Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      DAMAGE CALCULATION FLOW                                 │
└─────────────────────────────────────────────────────────────────────────────┘

    Attack Hit!
         │
         ▼
┌─────────────────────────────────────┐
│ 1. GET WEAPON DICE POOL             │
│    Default: 1d6                     │
│    Future: From equipped weapon     │
└────────────────┬────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────┐
│ 2. CHECK CRITICAL HIT               │
│    If Critical: Double dice count   │
│    1d6 → 2d6                        │
└────────────────┬────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────┐
│ 3. ROLL DAMAGE DICE                 │
│    Example: 2d6 = [4, 3] = 7        │
└────────────────┬────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────┐
│ 4. ADD MIGHT BONUS (Player only)    │
│    Example: 7 + 3 (Might) = 10      │
└────────────────┬────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────┐
│ 5. SUBTRACT ARMOR                   │
│    Armor = Defense / 2              │
│    Example: 10 - 2 (DEF 4/2) = 8    │
└────────────────┬────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────┐
│ 6. ENFORCE MINIMUM DAMAGE           │
│    Final = max(1, calculated)       │
│    Example: Final = 8               │
└─────────────────────────────────────┘
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── ValueObjects/
│   │   └── CombatResultsTests.cs           (5 tests)
│   └── Services/
│       └── CombatServiceDiceTests.cs       (10 tests)
```

### Test Files

#### 1. CombatResultsTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/CombatResultsTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class CombatResultsTests
{
    [Test]
    public void CombatRoundResult_WhenHit_SetsPropertiesCorrectly()
    {
        // Arrange
        var attackPool = DicePool.D10();
        var attackRoll = new DiceRollResult(attackPool, new[] { 8 }, 8);
        var damagePool = DicePool.D6();
        var damageRoll = new DiceRollResult(damagePool, new[] { 5 }, 5);

        // Act
        var result = new CombatRoundResult(
            attackRoll: attackRoll,
            attackTotal: 12,
            isHit: true,
            isCriticalHit: false,
            isCriticalMiss: false,
            damageRoll: damageRoll,
            damageDealt: 6,
            monsterCounterAttack: null,
            monsterDefeated: false,
            playerDefeated: false);

        // Assert
        result.IsHit.Should().BeTrue();
        result.DamageDealt.Should().Be(6);
        result.AttackSuccessLevel.Should().Be(SuccessLevel.Success);
    }

    [Test]
    public void CombatRoundResult_WhenCriticalHit_SetsSuccessLevel()
    {
        // Arrange
        var attackPool = DicePool.D10();
        var attackRoll = new DiceRollResult(attackPool, new[] { 10 }, 10);

        // Act
        var result = new CombatRoundResult(
            attackRoll: attackRoll,
            attackTotal: 15,
            isHit: true,
            isCriticalHit: true,
            isCriticalMiss: false,
            damageRoll: null,
            damageDealt: 12,
            monsterCounterAttack: null,
            monsterDefeated: false,
            playerDefeated: false);

        // Assert
        result.IsCriticalHit.Should().BeTrue();
        result.AttackSuccessLevel.Should().Be(SuccessLevel.CriticalSuccess);
    }

    [Test]
    public void CombatRoundResult_WhenCriticalMiss_SetsSuccessLevel()
    {
        // Arrange
        var attackPool = DicePool.D10();
        var attackRoll = new DiceRollResult(attackPool, new[] { 1 }, 1);

        // Act
        var result = new CombatRoundResult(
            attackRoll: attackRoll,
            attackTotal: 6,
            isHit: false,
            isCriticalHit: false,
            isCriticalMiss: true,
            damageRoll: null,
            damageDealt: 0,
            monsterCounterAttack: null,
            monsterDefeated: false,
            playerDefeated: false);

        // Assert
        result.IsCriticalMiss.Should().BeTrue();
        result.AttackSuccessLevel.Should().Be(SuccessLevel.CriticalFailure);
        result.DamageDealt.Should().Be(0);
    }

    [Test]
    public void CombatRoundResult_DamageReceived_ReturnsMonsterDamage()
    {
        // Arrange
        var attackPool = DicePool.D10();
        var attackRoll = new DiceRollResult(attackPool, new[] { 5 }, 5);
        var monsterAttackRoll = new DiceRollResult(attackPool, new[] { 7 }, 7);
        var monsterDamageRoll = new DiceRollResult(DicePool.D6(), new[] { 4 }, 4);

        var monsterCounter = new MonsterCounterAttackResult(
            attackRoll: monsterAttackRoll,
            attackTotal: 12,
            isHit: true,
            isCriticalHit: false,
            isCriticalMiss: false,
            damageRoll: monsterDamageRoll,
            damageDealt: 3,
            playerDefeated: false);

        // Act
        var result = new CombatRoundResult(
            attackRoll: attackRoll,
            attackTotal: 10,
            isHit: true,
            isCriticalHit: false,
            isCriticalMiss: false,
            damageRoll: null,
            damageDealt: 5,
            monsterCounterAttack: monsterCounter,
            monsterDefeated: false,
            playerDefeated: false);

        // Assert
        result.DamageReceived.Should().Be(3);
    }

    [Test]
    public void MonsterCounterAttackResult_ToString_FormatsCorrectly()
    {
        // Arrange
        var attackPool = DicePool.D10();
        var attackRoll = new DiceRollResult(attackPool, new[] { 8 }, 8);

        var result = new MonsterCounterAttackResult(
            attackRoll: attackRoll,
            attackTotal: 13,
            isHit: true,
            isCriticalHit: false,
            isCriticalMiss: false,
            damageRoll: null,
            damageDealt: 4,
            playerDefeated: false);

        // Act
        var str = result.ToString();

        // Assert
        str.Should().Contain("Monster Attack");
        str.Should().Contain("Hit");
        str.Should().Contain("4");
    }
}
```

#### 2. CombatServiceDiceTests.cs

**File:** `tests/RuneAndRust.Domain.UnitTests/Services/CombatServiceDiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Services;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Services;

[TestFixture]
public class CombatServiceDiceTests
{
    private CombatService _combatService = null!;
    private Mock<ILogger<CombatService>> _mockCombatLogger = null!;
    private Mock<ILogger<DiceService>> _mockDiceLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockCombatLogger = new Mock<ILogger<CombatService>>();
        _mockDiceLogger = new Mock<ILogger<DiceService>>();
        _combatService = new CombatService(_mockCombatLogger.Object);
    }

    private static Player CreateTestPlayer(int finesse = 5, int might = 5, int health = 100)
    {
        var attributes = new PlayerAttributes(might, 10, 10, 10, finesse);
        return new Player("TestPlayer", "human", "soldier", attributes, "Test");
    }

    private static Monster CreateTestMonster(int defense = 10, int attack = 5, int health = 30)
    {
        return Monster.CreateGoblin(); // Uses default stats
    }

    private DiceService CreateDiceService(int seed)
    {
        return new DiceService(_mockDiceLogger.Object, new Random(seed));
    }

    [Test]
    public void ResolveCombatRound_WithDice_ReturnsDetailedResult()
    {
        // Arrange
        var player = CreateTestPlayer();
        var monster = CreateTestMonster();
        var diceService = CreateDiceService(42);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, diceService);

        // Assert
        result.Should().NotBeNull();
        result.AttackRoll.Should().NotBeNull();
        result.AttackRoll.Pool.DiceType.Should().Be(DiceType.D10);
    }

    [Test]
    public void ResolveCombatRound_AttackRollIncludesFinesseModifier()
    {
        // Arrange
        var player = CreateTestPlayer(finesse: 8);
        var monster = CreateTestMonster();
        var diceService = CreateDiceService(42);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, diceService);

        // Assert
        var expectedTotal = result.AttackRoll.Total + 8;
        result.AttackTotal.Should().Be(expectedTotal);
    }

    [Test]
    public void ResolveCombatRound_WhenRollMeetsDefense_IsHit()
    {
        // Arrange - Use seed that produces a roll that will hit
        var player = CreateTestPlayer(finesse: 10);
        var monster = CreateTestMonster(defense: 5);

        // Use mock that returns high roll
        var mockDiceService = new Mock<IDiceService>();
        var highRoll = new DiceRollResult(DicePool.D10(), new[] { 8 }, 8);
        var damageRoll = new DiceRollResult(DicePool.D6(), new[] { 4 }, 4);
        mockDiceService.SetupSequence(d => d.Roll(It.IsAny<DicePool>(), It.IsAny<AdvantageType>()))
            .Returns(highRoll)
            .Returns(damageRoll);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, mockDiceService.Object);

        // Assert
        result.IsHit.Should().BeTrue();
        result.AttackTotal.Should().BeGreaterThanOrEqualTo(monster.Stats.Defense);
    }

    [Test]
    public void ResolveCombatRound_WhenNatural10_IsCriticalHit()
    {
        // Arrange
        var player = CreateTestPlayer();
        var monster = CreateTestMonster(defense: 100); // Very high defense

        var mockDiceService = new Mock<IDiceService>();
        var critRoll = new DiceRollResult(DicePool.D10(), new[] { 10 }, 10); // Natural 10
        var damageRoll = new DiceRollResult(new DicePool(2, DiceType.D6), new[] { 4, 5 }, 9);
        mockDiceService.SetupSequence(d => d.Roll(It.IsAny<DicePool>(), It.IsAny<AdvantageType>()))
            .Returns(critRoll)
            .Returns(damageRoll);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, mockDiceService.Object);

        // Assert
        result.IsCriticalHit.Should().BeTrue();
        result.IsHit.Should().BeTrue(); // Critical always hits
    }

    [Test]
    public void ResolveCombatRound_WhenNatural1_IsCriticalMiss()
    {
        // Arrange
        var player = CreateTestPlayer(finesse: 100); // Very high modifier
        var monster = CreateTestMonster(defense: 1); // Very low defense

        var mockDiceService = new Mock<IDiceService>();
        var fumbleRoll = new DiceRollResult(DicePool.D10(), new[] { 1 }, 1); // Natural 1
        mockDiceService.Setup(d => d.Roll(It.IsAny<DicePool>(), It.IsAny<AdvantageType>()))
            .Returns(fumbleRoll);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, mockDiceService.Object);

        // Assert
        result.IsCriticalMiss.Should().BeTrue();
        result.IsHit.Should().BeFalse(); // Critical miss always misses
        result.DamageDealt.Should().Be(0);
    }

    [Test]
    public void ResolveCombatRound_CriticalHit_DoublesDamageDice()
    {
        // Arrange
        var player = CreateTestPlayer(might: 0);
        var monster = CreateTestMonster(defense: 0);

        var mockDiceService = new Mock<IDiceService>();
        var critRoll = new DiceRollResult(DicePool.D10(), new[] { 10 }, 10);
        // Expect 2d6 (doubled) damage roll
        var damageRoll = new DiceRollResult(new DicePool(2, DiceType.D6), new[] { 4, 5 }, 9);
        mockDiceService.SetupSequence(d => d.Roll(It.IsAny<DicePool>(), It.IsAny<AdvantageType>()))
            .Returns(critRoll)
            .Returns(damageRoll);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, mockDiceService.Object);

        // Assert
        result.DamageRoll.Should().NotBeNull();
        result.DamageRoll!.Value.Pool.Count.Should().Be(2); // Doubled from 1d6 to 2d6
    }

    [Test]
    public void ResolveCombatRound_DamageIncludesMightBonus()
    {
        // Arrange
        var player = CreateTestPlayer(might: 5);
        var monster = CreateTestMonster(defense: 0);

        var mockDiceService = new Mock<IDiceService>();
        var hitRoll = new DiceRollResult(DicePool.D10(), new[] { 8 }, 8);
        var damageRoll = new DiceRollResult(DicePool.D6(), new[] { 3 }, 3);
        mockDiceService.SetupSequence(d => d.Roll(It.IsAny<DicePool>(), It.IsAny<AdvantageType>()))
            .Returns(hitRoll)
            .Returns(damageRoll);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, mockDiceService.Object);

        // Assert
        // Damage = 3 (roll) + 5 (might) - 0 (armor) = 8
        result.DamageDealt.Should().Be(8);
    }

    [Test]
    public void ResolveCombatRound_MonsterCounterattacks_WhenAlive()
    {
        // Arrange
        var player = CreateTestPlayer();
        var monster = CreateTestMonster(health: 100); // High HP to survive

        var mockDiceService = new Mock<IDiceService>();
        var playerHit = new DiceRollResult(DicePool.D10(), new[] { 8 }, 8);
        var playerDamage = new DiceRollResult(DicePool.D6(), new[] { 3 }, 3);
        var monsterHit = new DiceRollResult(DicePool.D10(), new[] { 7 }, 7);
        var monsterDamage = new DiceRollResult(DicePool.D6(), new[] { 4 }, 4);

        mockDiceService.SetupSequence(d => d.Roll(It.IsAny<DicePool>(), It.IsAny<AdvantageType>()))
            .Returns(playerHit)
            .Returns(playerDamage)
            .Returns(monsterHit)
            .Returns(monsterDamage);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, mockDiceService.Object);

        // Assert
        result.MonsterCounterAttack.Should().NotBeNull();
        result.MonsterCounterAttack!.AttackRoll.Should().NotBeNull();
    }

    [Test]
    public void ResolveCombatRound_NoCounterattack_WhenMonsterDefeated()
    {
        // Arrange
        var player = CreateTestPlayer(might: 100); // Very high damage
        var monster = CreateTestMonster(health: 1); // Very low HP

        var mockDiceService = new Mock<IDiceService>();
        var hitRoll = new DiceRollResult(DicePool.D10(), new[] { 10 }, 10); // Crit for max damage
        var damageRoll = new DiceRollResult(new DicePool(2, DiceType.D6), new[] { 6, 6 }, 12);
        mockDiceService.SetupSequence(d => d.Roll(It.IsAny<DicePool>(), It.IsAny<AdvantageType>()))
            .Returns(hitRoll)
            .Returns(damageRoll);

        // Act
        var result = _combatService.ResolveCombatRound(player, monster, mockDiceService.Object);

        // Assert
        result.MonsterDefeated.Should().BeTrue();
        result.MonsterCounterAttack.Should().BeNull();
    }

    [Test]
    public void GetCombatDescription_FormatsCorrectly()
    {
        // Arrange
        var attackRoll = new DiceRollResult(DicePool.D10(), new[] { 8 }, 8);
        var damageRoll = new DiceRollResult(DicePool.D6(), new[] { 5 }, 5);

        var result = new CombatRoundResult(
            attackRoll: attackRoll,
            attackTotal: 13,
            isHit: true,
            isCriticalHit: false,
            isCriticalMiss: false,
            damageRoll: damageRoll,
            damageDealt: 6,
            monsterCounterAttack: null,
            monsterDefeated: true,
            playerDefeated: false);

        // Act
        var description = _combatService.GetCombatDescription(result, "Hero", "Goblin");

        // Assert
        description.Should().Contain("Hero hits the Goblin");
        description.Should().Contain("6 damage");
        description.Should().Contain("defeated");
    }
}
```

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Combat initiation | Information | "Combat initiated: Hero (HP:100) attacks Goblin (HP:30)" |
| Attack roll | Debug | "Player attack roll: [8] + 5 (Finesse) = 13 vs DEF 10 -> Hit" |
| Critical result | Information | "CRITICAL HIT! Damage dice doubled" |
| Damage roll | Debug | "Player damage roll: [4, 3] + 5 (Might) = 12 - 2 (armor) = 10 damage" |
| Damage applied | Debug | "Player dealt 10 damage to Goblin (HP: 30 -> 20)" |
| Monster counterattack | Debug | "Monster attack roll: [6] + 8 (ATK) = 14 vs DEF 5 -> Hit" |
| Combat round complete | Information | "Combat round complete - Hero Hit: [8]+5=13 vs DEF, Dealt: 10, Received: 4" |
| Combat end | Information | "Hero defeated Goblin!" |

### Structured Logging Format

```csharp
_logger.LogDebug(
    "Player attack roll: [{Roll}] + {Modifier} (Finesse) = {Total} vs DEF {Defense} -> {Result}",
    attackRoll.Rolls[0],
    attackModifier,
    attackTotal,
    monster.Stats.Defense,
    isHit ? "Hit" : "Miss");

_logger.LogDebug(
    "Player damage roll: [{Rolls}] + {Might} (Might) = {Raw} - {Armor} (armor) = {Final} damage",
    string.Join(", ", damageRoll.Rolls),
    mightBonus,
    rawDamage,
    armorReduction,
    damageDealt);

_logger.LogInformation(
    "Combat round complete - {Player} {AttackResult}: [{AttackRoll}]+{Mod}={Total} vs DEF, " +
    "Dealt: {DamageDealt}, Received: {DamageReceived}",
    playerName,
    attackResult,
    result.AttackRoll.Rolls[0],
    result.AttackTotal - result.AttackRoll.Total,
    result.AttackTotal,
    result.DamageDealt,
    result.DamageReceived);
```

---

## Implementation Checklist

### Domain Layer
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/CombatResults.cs`
  - [ ] `CombatRoundResult` record with attack/damage breakdown
  - [ ] `MonsterCounterAttackResult` record
  - [ ] Computed properties (DamageReceived, AttackSuccessLevel, etc.)
  - [ ] ToString() methods for debugging
  - [ ] XML documentation

### Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/Interfaces/IDiceService.cs`
  - [ ] Interface for dice rolling abstraction
  - [ ] All Roll method signatures
  - [ ] XML documentation
- [ ] Update `src/Core/RuneAndRust.Application/Services/DiceService.cs`
  - [ ] Implement `IDiceService` interface
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/CombatDtos.cs`
  - [ ] `CombatRoundResultDto` record
  - [ ] `MonsterCounterAttackResultDto` record
  - [ ] `FromDomainResult()` factory methods
  - [ ] XML documentation

### Domain Services
- [ ] Update `src/Core/RuneAndRust.Domain/Services/CombatService.cs`
  - [ ] Add `ResolveCombatRound(Player, Monster, IDiceService)` method
  - [ ] Add `ResolvePlayerAttack()` private method
  - [ ] Add `ResolveMonsterCounterAttack()` private method
  - [ ] Add `GetPlayerDamagePool()` method
  - [ ] Add `GetMonsterDamagePool()` method
  - [ ] Add `GetCombatDescription(CombatRoundResult, ...)` overload
  - [ ] Mark legacy methods as `[Obsolete]`
  - [ ] Update logging for dice-based combat
  - [ ] XML documentation

### Application Services
- [ ] Update `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`
  - [ ] Add `IDiceService` dependency
  - [ ] Update constructor
  - [ ] Update `TryAttack()` to use dice-based combat
  - [ ] Return `CombatRoundResult` from `TryAttack()`

### Tests
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/CombatResultsTests.cs` (5 tests)
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Services/CombatServiceDiceTests.cs` (10 tests)

### Validation
- [ ] All 15 new tests pass
- [ ] All existing tests pass (may need updates to use new method signature)
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | Attack rolls use 1d10 | Unit test |
| AC-2 | Attack total = roll + Finesse | Unit test |
| AC-3 | Attack hits when total >= Defense | Unit test |
| AC-4 | Critical hit on natural 10 | Unit test |
| AC-5 | Critical miss on natural 1 | Unit test |
| AC-6 | Critical hit always hits | Unit test |
| AC-7 | Critical miss always misses | Unit test |
| AC-8 | Critical hit doubles damage dice | Unit test |
| AC-9 | Damage includes Might bonus | Unit test |
| AC-10 | Armor reduces damage by Defense/2 | Unit test |
| AC-11 | Minimum damage is 1 | Unit test |
| AC-12 | Monster counterattacks if alive | Unit test |
| AC-13 | No counterattack if monster defeated | Unit test |
| AC-14 | Combat result includes full dice breakdown | Unit test |
| AC-15 | Combat description includes dice results | Manual verification |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | CombatRoundResult is immutable | Code review |
| NF-2 | MonsterCounterAttackResult is immutable | Code review |
| NF-3 | Legacy CombatResult methods marked [Obsolete] | Code review |
| NF-4 | All public APIs documented with XML | Code review |
| NF-5 | Logging at appropriate levels | Code review |
| NF-6 | IDiceService interface enables testing | Unit tests use mock |
| NF-7 | No breaking changes to existing API (deprecated, not removed) | Test suite |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Breaking existing combat tests | High | Medium | Mark old methods [Obsolete], don't remove |
| Combat balance changes | Medium | High | Keep damage range similar to current system |
| DiceService dependency not injected | Medium | Low | Add IDiceService interface for DI |
| Monster.TakeDamage changes | Medium | Low | No changes to entity method signatures |
| GameSessionService signature changes | Medium | Medium | Add new overload, don't modify existing |
| Test flakiness with random dice | Medium | Medium | Use seeded Random and mock services |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Domain/ValueObjects/CombatResults.cs` | Combat result value objects | ~200 |
| `Application/Interfaces/IDiceService.cs` | Dice service interface | ~40 |
| `Application/DTOs/CombatDtos.cs` | Combat DTOs for presentation | ~100 |
| `Tests/.../CombatResultsTests.cs` | Value object tests | ~120 |
| `Tests/.../CombatServiceDiceTests.cs` | Service tests | ~250 |

### Files to Modify

| File | Changes |
|------|---------|
| `Domain/Services/CombatService.cs` | Add dice-based combat resolution (~150 lines) |
| `Application/Services/DiceService.cs` | Implement IDiceService interface |
| `Application/Services/GameSessionService.cs` | Add IDiceService dependency, update TryAttack() |

### Final Metrics

| Metric | Before v0.0.5c | After v0.0.5c |
|--------|----------------|---------------|
| Domain Value Objects | 9 | 10 |
| Application Interfaces | 6 | 7 |
| Application DTOs | 16 | 17 |
| Unit Tests | ~240 | ~255 |

---

## Next Steps

After completing v0.0.5c:

1. **v0.0.5d (Configuration & Polish)** - Add `roll` and `check` commands, rendering, descriptors
2. **v0.0.6 (Enhanced Combat)** - Multi-target, target selection, status effects
3. **v0.0.7 (Equipment System)** - Weapon dice pools, armor defense values

The combat dice integration provides the foundation for all future combat mechanics including weapon specialization, critical effects, and combat abilities.
