> **Archived** - This plan has been consolidated. See the complete version at [v0.3.15](../v0.3.x/v0.3.15.md).

# v0.3.15b: The Translator (Locale Service)

This version implements the engine logic required to load, parse, and serve localized text. It transforms the static JSON files created in v0.3.15a into a high-performance, in-memory dictionary that supports variable interpolation (e.g., "Hit for {0} damage").

Goal: Implement LocalizationService to deserialize hierarchical JSON files into a flat key-value cache, handle string formatting, and manage fallback logic for missing keys.

1. Architecture & Data Flow
The Loading Pipeline
	1	Trigger: Application startup (or Language change event).
	2	File Access: Service reads data/locales/{CurrentCulture}.json.
	3	Deserialization: Parse JSON into a JsonElement (System.Text.Json).
	4	Flattening: Recursively walk the JSON tree to build dot-notation keys.
	◦	Input: {"UI": {"Title": "Hello"}}
	◦	Output: Key: "UI.Title", Value: "Hello"
	5	Cache: Store in Dictionary<string, string> _translations.
	6	Fallback Load: (Optional) If current culture $\neq$ Default, also load en-US.json into a separate _fallbackTranslationsdictionary.
The Retrieval Pipeline
	1	Call: _loc.Get("Log.Combat.Hit", "Draugr", "5").
	2	Lookup:
	◦	Check _translations. Found? Use it.
	◦	Check _fallbackTranslations. Found? Use it.
	◦	Missing? Return "[Log.Combat.Hit]".
	3	Format: Apply string.Format(template, args).
	4	Return: "Draugr takes 5 damage."

2. Logic Decision Trees
A. Flattening Logic (Recursive) Input: Current JSON Element, Parent Key Prefix
	1	Is Object?
	◦	Loop through properties.
	◦	New Prefix = ParentKey + . + PropertyName.
	◦	Recurse.
	2	Is String?
	◦	Add to Dictionary: Key = ParentKey, Value = StringContent.
	3	Is Array?
	◦	(Decision: Arrays usually map to indexed keys or joined strings. For now, treat as unsupported or join with newline).
B. Get String Logic Input: Key, Args
	1	Dictionary Lookup: Does Key exist?
	◦	Yes: template = value.
	◦	No: Log Warning -> Return Key (fail loudly in Dev, softly in Prod).
	2	Formatting Check: Are there Args?
	◦	No: Return template.
	◦	Yes: Wrap string.Format in Try/Catch (to catch malformed templates like "Hello {1}").
	▪	Success: Return formatted string.
	▪	Fail: Log Error -> Return template (unformatted).

3. Deliverable Checklist
	•	Core:
	◦	[ ] Update GameSettings to include string Language { get; set; } = "en-US";.
	•	Engine:
	◦	[ ] Implement LocalizationService class.
	◦	[ ] Implement JsonFlattener helper (private method or static utility).
	◦	[ ] Implement LoadLocaleAsync(string culture) method.
	◦	[ ] Implement Get(string key, params object[] args) method.
	•	Terminal:
	◦	[ ] Update Program.cs to register ILocalizationService as Singleton.
	◦	[ ] Call LoadLocaleAsync during startup sequence.

4. Code Implementation
A. Service Implementation (RuneAndRust.Engine/Services/LocalizationService.cs)
using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Interfaces;

public class LocalizationService : ILocalizationService
{
    private readonly ILogger<LocalizationService> _logger;
    private Dictionary<string, string> _translations = new();
    private Dictionary<string, string> _fallbackTranslations = new();
    private const string DefaultCulture = "en-US";

    public LocalizationService(ILogger<LocalizationService> logger)
    {
        _logger = logger;
    }

    public async Task LoadLocaleAsync(string cultureCode)
    {
        _logger.LogInformation("Loading locale: {Culture}", cultureCode);

        // 1. Load active language
        _translations = await LoadFileAsync(cultureCode);

        // 2. Load fallback if different
        if (!cultureCode.Equals(DefaultCulture, StringComparison.OrdinalIgnoreCase))
        {
            _fallbackTranslations = await LoadFileAsync(DefaultCulture);
        }
    }

    private async Task<Dictionary<string, string>> LoadFileAsync(string culture)
    {
        var path = Path.Combine("data", "locales", $"{culture}.json");
        if (!File.Exists(path))
        {
            _logger.LogError("Locale file not found: {Path}", path);
            return new Dictionary<string, string>();
        }

        try
        {
            var jsonString = await File.ReadAllTextAsync(path);
            var doc = JsonDocument.Parse(jsonString);
            return FlattenJson(doc.RootElement);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to parse locale: {Path}", path);
            return new Dictionary<string, string>();
        }
    }

    public string Get(string key, params object[] args)
    {
        if (!_translations.TryGetValue(key, out var template))
        {
            if (!_fallbackTranslations.TryGetValue(key, out template))
            {
                _logger.LogWarning("Missing translation key: {Key}", key);
                return $"[{key}]";
            }
        }

        if (args.Length == 0) return template;

        try
        {
            return string.Format(template, args);
        }
        catch (FormatException)
        {
            _logger.LogError("Format error for key: {Key} with args: {Args}", key, string.Join(",", args));
            return template;
        }
    }

    private Dictionary<string, string> FlattenJson(JsonElement element, string prefix = "")
    {
        var dict = new Dictionary<string, string>();

        foreach (var prop in element.EnumerateObject())
        {
            string key = string.IsNullOrEmpty(prefix) ? prop.Name : $"{prefix}.{prop.Name}";

            if (prop.Value.ValueKind == JsonValueKind.Object)
            {
                var nested = FlattenJson(prop.Value, key);
                foreach (var kvp in nested) dict.Add(kvp.Key, kvp.Value);
            }
            else if (prop.Value.ValueKind == JsonValueKind.String)
            {
                dict.Add(key, prop.Value.GetString() ?? "");
            }
        }
        return dict;
    }
}

5. Logging Requirements
System
Event
Level
Message Template
Properties
Loc
Load Start
Info
"Loading locale: {Culture}"
Culture
Loc
File Missing
Error
"Locale file not found: {Path}. Fallback may fail."
Path
Loc
Key Missing
Warn
"Missing translation key: {Key}"
Key
Loc
Format Error
Error
"Format error for key: {Key} with args: {Args}"
Key, Args

6. Testing Strategy
Unit Tests (LocalizationServiceTests.cs)
	•	Load_FlattensJsonCorrectly:
	◦	Arrange: Create temporary JSON {"Parent": {"Child": "Value"}}.
	◦	Act: Load file.
	◦	Assert: Get("Parent.Child") returns "Value".
	•	Get_ReturnsFormattedString:
	◦	Arrange: JSON has "Key": "Hello {0}".
	◦	Act: Get("Key", "World").
	◦	Assert: Returns "Hello World".
	•	Get_FallsBackToDefault:
	◦	Arrange: Load "fr-FR" (empty) and "en-US" (has key).
	◦	Act: Get("Key").
	◦	Assert: Returns value from en-US.
	•	Get_MissingReturnsKey:
	◦	Act: Get("NonExistent").
	◦	Assert: Returns "[NonExistent]".

7. Draft Changelog (v0.3.15b)
# v0.3.15b Changelog: The Translator
**Release Date:** 2026-02-25

## Summary
This release implements the engine logic for the Localization System. The `LocalizationService` now dynamically loads JSON resource files, flattens them into an efficient lookup cache, and handles string interpolation. This enables the game to support multiple languages and separates text content from code logic.

## New Features
*   **JSON Locale Loading:** Support for hierarchical JSON string tables.
*   **Key Flattening:** Automatic conversion of nested JSON (e.g., `UI -> Menu -> Title`) into dot-notation keys (`UI.Menu.Title`).
*   **Graceful Fallback:** Missing keys in a target language automatically fall back to English (en-US).

## Technical Changes
*   Implemented `LocalizationService`.
*   Added `System.Text.Json` logic for recursive object flattening.
*   Integrated logging for missing keys and malformed string templates.