# v0.3.9: The Feedback (FX & Polish)

> **Status:** Planned
> **Milestone:** 4.5 - Interface Polish
> **Theme:** Game feel, accessibility, and user customization

## Table of Contents
- [Overview](#overview)
- [Phase A: The Impact (Visual FX)](#phase-a-the-impact-visual-fx)
- [Phase B: The Lens (Accessibility & Themes)](#phase-b-the-lens-accessibility--themes)
- [Phase C: The Guide (Context Help & Controls)](#phase-c-the-guide-context-help--controls)
- [Testing Strategy](#testing-strategy)
- [Changelog](#changelog-v039---the-feedback)

## Overview

This milestone focuses on "game feel," accessibility, and user customization. It bridges the gap between raw functionality and a polished user experience, ensuring the TUI is responsive, readable, and satisfying to interact with before we dive into the complex progression systems of v0.4.0.

To manage the distinct domains of visual rendering, configuration, and input handling, this version is split into three sub-versions:

| Phase | Codename | Focus |
|-------|----------|-------|
| A | The Impact | Visual FX - Combat feedback, screen shake, and animations |
| B | The Lens | Accessibility & Themes - Color configuration, high contrast modes, text scaling |
| C | The Guide | Context Help & Controls - Dynamic help system and input rebinding |

---

## Phase A: The Impact (Visual FX)

**Goal:** Implement the VisualEffectService to provide visceral feedback for game events (Damage, Crits, Trauma) without breaking the TUI format.

### 1. Architecture & Data Flow

The Feedback Loop:
1. **Trigger:** CombatService or TraumaService publishes a domain event (e.g., `EntityDamagedEvent`).
2. **Filter:** VisualEffectService (Terminal Layer) intercepts the event.
3. **Guard:** Service checks `Settings.ReduceMotion`.
   - If True: Abort visual FX (Audio cue only, future).
   - If False: Proceed.
4. **Selection:** Map Event Magnitude to Effect Intensity (e.g., Damage > 20% HP -> Heavy Shake).
5. **Execution:**
   - Shake: Manipulate RootLayout.Padding asynchronously over time.
   - Flash: Temporarily override BorderColor properties in CombatScreenRenderer.
6. **Restoration:** Reset layout/colors to default state.

### 2. Logic Decision Trees

#### A. Damage Feedback Logic
Input: DamageAmount, MaxHP, IsCritical

1. Calculate Ratio: `Percent = DamageAmount / MaxHP`
2. Determine Intensity:
   - Crit OR Percent > 0.25: Effect = HeavyShake (3 cycles, Red Flash).
   - Percent > 0.10: Effect = MediumShake (2 cycles, Orange Flash).
   - Else: Effect = TextPulseOnly (No screen movement).
3. Execute: Call `TriggerShakeAsync(intensity)`.

#### B. Shake Execution Logic (TUI)
Input: Intensity (Low/Med/High)

1. Save State: Store current Padding.
2. Loop (N times based on Intensity):
   - Set Padding: (Left+2, Top, Right, Bottom).
   - Render.
   - Delay: 30ms.
   - Set Padding: (Left, Top, Right+2, Bottom).
   - Render.
   - Delay: 30ms.
3. Reset: Restore original Padding. Render.

### 3. Code Implementation

#### A. Core Layer (Events & Interfaces)
File: `RuneAndRust.Core/Interfaces/IVisualEffectService.cs`
```csharp
public interface IVisualEffectService
{
    Task TriggerShakeAsync(int intensity, int durationMs);
    Task TriggerFlashAsync(string colorName, int durationMs);
    Task PulseElementAsync(string elementId);
}
```

#### B. Terminal Layer (Service Implementation)
File: `RuneAndRust.Terminal/Services/VisualEffectService.cs`
```csharp
using Spectre.Console;
using RuneAndRust.Core.Events;

public class VisualEffectService : IVisualEffectService, IDisposable
{
    private readonly Layout _rootLayout; // Injected reference to main screen
    private readonly GameSettings _settings;
    private readonly ILogger _logger;

    // Subscribe to events
    public void OnDamageTaken(EntityDamagedEvent e)
    {
        if (_settings.ReduceMotion) return;

        float ratio = (float)e.Damage / e.MaxHp;

        if (e.IsCritical || ratio > 0.25f)
            _ = TriggerShakeAsync(3, 150);
        else if (ratio > 0.10f)
            _ = TriggerShakeAsync(1, 100);

        if (e.IsPlayer)
            _ = TriggerFlashAsync("red", 200);
    }

    public async Task TriggerShakeAsync(int intensity, int durationMs)
    {
        var original = _rootLayout.Padding;
        int steps = durationMs / 30;

        for(int i = 0; i < steps; i++)
        {
            // Simple X-axis shake
            int offset = (i % 2 == 0) ? 2 : 0;
            _rootLayout.Padding = new Padding(original.Left + offset, original.Top, original.Right + (2 - offset), original.Bottom);
            AnsiConsole.Write(_rootLayout);
            await Task.Delay(30);
        }

        _rootLayout.Padding = original; // Reset
        AnsiConsole.Write(_rootLayout);
    }
}
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| FX | Trigger | Trace | "FX Triggered: {Type} (Intensity: {Intensity})" | Type, Intensity |
| FX | Skip | Trace | "FX Skipped: {Type} (ReduceMotion enabled)" | Type |
| FX | Flash | Trace | "Screen Flash: {Color}" | Color |

### 5. Testing Requirements

**Unit Tests (VisualEffectServiceTests.cs)**
- **ReduceMotion_RespectsSetting:**
  - Set Settings.ReduceMotion = true.
  - Call OnDamageTaken with massive damage.
  - Assert TriggerShakeAsync logic is not executed (Mock layout verify no padding change).
- **Intensity_Calculation:**
  - Input: 5 damage to 100 HP (5%).
  - Assert: No Shake triggered.
  - Input: 30 damage to 100 HP (30%).
  - Assert: High Intensity Shake triggered.

**Integration Tests**
- **Event_Wiring:**
  - Publish EntityDamagedEvent via EventBus.
  - Verify VisualEffectService receives event.

### 6. Deliverable Checklist (v0.3.9a)

- [ ] Core: Define `IVisualEffectService`.
- [ ] Core: Define `ThemeType` and `VisualEffectType` enums.
- [ ] Terminal: Implement `VisualEffectService` with TriggerShake and TriggerFlash.
- [ ] Terminal: Inject VisualEffectService into GameService.
- [ ] Terminal: Bind EventBus events (Damage, Crit, Death) to FX triggers.
- [ ] Config: Add `ReduceMotion` boolean to GameSettings.

---

## Phase B: The Lens (Accessibility & Themes)

**Goal:** Implement ThemeService to centralize color management, enabling colorblind modes (Protanopia, Deuteranopia, Tritanopia) and High Contrast mode.

### 1. Architecture & Data Flow

**The Semantic Palette System:** Instead of renderers deciding that "Low HP is Red," they now request the color for "HealthCritical". The ThemeService resolves this request based on the active user profile.

1. **Configuration:** GameSettings holds the active ThemeType.
2. **Service:** ThemeService initializes dictionaries (Palettes) for each ThemeType.
3. **Consumption:** Renderers inject IThemeService and call `GetColor(key)`.
4. **Updates:** Changing the theme triggers a UI refresh event, causing all renderers to redraw using new values.

**Semantic Keys:**
- **State:** Good, Warning, Danger, Critical.
- **Entity:** Player, Enemy, NPC, Object.
- **UI:** Border, Highlight, Selection, TextMuted.
- **Rarity:** Common, Uncommon, Rare, Epic, Legendary.

### 2. Logic Decision Trees

#### A. Color Resolution Logic
Input: SemanticKey (string), ActiveTheme

1. Select Palette: Retrieve dictionary for ActiveTheme.
2. Lookup Key: Does palette contain SemanticKey?
   - Yes: Return mapped Color.
   - No: Fallback.
3. Fallback Check:
   - Is ActiveTheme == Standard?
     - Yes: Return Color.White (Safety default) & Log Warning.
     - No: Lookup SemanticKey in Standard palette.
       - Found: Return Standard Color.
       - Missing: Return Color.White.

#### B. Theme Application Flow
Input: User selects "High Contrast"

1. Update Settings: Set `GameSettings.CurrentTheme = ThemeType.HighContrast`.
2. Notify: ThemeService fires ThemeChangedEvent.
3. Refresh: GameLoop detects event/flag and forces a full `AnsiConsole.Clear()` and redraw of the current screen.

### 3. Code Implementation

#### A. Core Layer (Enums)
File: `RuneAndRust.Core/Enums/ThemeType.cs`
```csharp
public enum ThemeType
{
    Standard = 0,
    HighContrast = 1, // Black/White/Yellow only
    Protanopia = 2,   // Red-Blind safe
    Deuteranopia = 3, // Green-Blind safe
    Tritanopia = 4    // Blue-Blind safe
}
```

#### B. Terminal Layer (Theme Service)
File: `RuneAndRust.Terminal/Services/ThemeService.cs`
```csharp
using Spectre.Console;

public class ThemeService : IThemeService
{
    private readonly Dictionary<ThemeType, Dictionary<string, Color>> _palettes;
    private ThemeType _currentTheme = ThemeType.Standard;

    public ThemeService()
    {
        _palettes = new Dictionary<ThemeType, Dictionary<string, Color>>();
        InitializePalettes();
    }

    public void SetTheme(ThemeType type) => _currentTheme = type;

    public Color GetColor(string key)
    {
        var palette = _palettes.ContainsKey(_currentTheme)
            ? _palettes[_currentTheme]
            : _palettes[ThemeType.Standard];

        if (palette.TryGetValue(key, out var color))
            return color;

        // Fallback to standard if missing in specific theme
        if (_currentTheme != ThemeType.Standard &&
            _palettes[ThemeType.Standard].TryGetValue(key, out var stdColor))
            return stdColor;

        return Color.White; // Ultimate fallback
    }

    private void InitializePalettes()
    {
        // Standard
        _palettes[ThemeType.Standard] = new Dictionary<string, Color>
        {
            { "Good", Color.Green },
            { "Warning", Color.Yellow },
            { "Danger", Color.Red },
            { "Player", Color.Cyan1 },
            { "Enemy", Color.Red1 },
            { "Border", Color.Grey },
            { "Highlight", Color.Gold1 }
        };

        // High Contrast (Accessibility)
        _palettes[ThemeType.HighContrast] = new Dictionary<string, Color>
        {
            { "Good", Color.White },      // Use symbols + white
            { "Warning", Color.Yellow },
            { "Danger", Color.White },    // Rely on symbols/bold
            { "Player", Color.White },
            { "Enemy", Color.White },
            { "Border", Color.White },
            { "Highlight", Color.Yellow }
        };

        // Protanopia (Avoid Red/Green distinction)
        _palettes[ThemeType.Protanopia] = new Dictionary<string, Color>
        {
            { "Good", Color.Blue },       // Blue instead of Green
            { "Warning", Color.Yellow },
            { "Danger", Color.Orange1 },  // Distinct from Yellow
            { "Enemy", Color.Magenta1 }   // Distinct from Blue
        };
    }
}
```

#### C. Refactoring Example (Combat Renderer)
File: `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs`
```csharp
// OLD
// table.AddRow(new Markup($"[cyan]{player.Name}[/]"), new Markup($"[red]{enemy.Name}[/]"));

// NEW
var pColor = _theme.GetColor("Player").ToMarkup();
var eColor = _theme.GetColor("Enemy").ToMarkup();
table.AddRow(new Markup($"[{pColor}]{player.Name}[/]"), new Markup($"[{eColor}]{enemy.Name}[/]"));
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Theme | Lookup | Trace | "Theme lookup: {Key} -> {Color}" | Key, Color |
| Theme | Missing | Warning | "Missing theme key: {Key} in {Theme}" | Key, Theme |
| Theme | Change | Info | "User switched theme to {Theme}" | Theme |

### 5. Testing Requirements

**Unit Tests (ThemeServiceTests.cs)**
- **Resolution_Standard:** Set Theme Standard. Call GetColor("Danger"). Assert Color.Red.
- **Resolution_HighContrast:** Set Theme HighContrast. Call GetColor("Danger"). Assert Color.White.
- **Fallback_Logic:** Set Theme Protanopia. Request key "Border" (not defined in Protanopia, but in Standard). Assert returns Standard["Border"].
- **Missing_Key:** Request "NonExistentKey". Assert returns Color.White.

**Integration Tests**
- **Visual_Safety:** Loop through ALL keys in Standard palette. Ensure every other palette either defines them OR the fallback system works without crashing.

### 6. Deliverable Checklist (v0.3.9b)

- [ ] Core: Add `ThemeType` enum.
- [ ] Core: Add `IThemeService` interface.
- [ ] Terminal: Implement ThemeService with 5 palettes.
- [ ] Terminal: Inject IThemeService into GameService.
- [ ] Refactoring (The "Big Switch"):
  - [ ] Update StatusWidget (HP/Stamina bars).
  - [ ] Update CombatScreenRenderer (Player/Enemy names, Health status).
  - [ ] Update InventoryViewHelper (Rarity colors).
  - [ ] Update MinimapRenderer (Tile colors).
- [ ] UI: Add "Toggle Theme" command/hotkey (e.g., F2) to InputHandler.

---

## Phase C: The Guide (Context Help & Controls)

**Goal:** Implement InputConfigurationService for JSON-based key rebinding and ContextHelpService to display reactive gameplay tips based on current state (status effects, enemy types, room hazards).

### 1. Architecture & Data Flow

#### A. Dynamic Input System
Instead of hardcoded switch statements in TerminalInputHandler, we introduce an intermediary mapping layer.

1. **Configuration:** `input_bindings.json` stores Key-to-Action mappings.
2. **Service:** InputConfigurationService loads this map at startup.
3. **Interception:** When a key is pressed in TerminalInputHandler:
   - Check InputConfigurationService for a binding.
   - If found, translate Key -> Command String (e.g., F -> "interact").
   - Return string to GameLoop.

#### B. Contextual Help Engine
A passive analysis engine that runs before rendering to populate a "Help" side-panel.

1. **Trigger:** GameLoop calls `ContextHelpService.Analyze(GameState)`.
2. **Analysis:** The service evaluates a list of HelpTrigger predicates against the state.
   - Example: `Player.HasStatus(Bleeding)` -> True.
3. **Output:** Returns a list of HelpTip objects (Text, Priority, Color).
4. **Render:** The active ScreenRenderer draws these tips in a dedicated pane.

### 2. Logic Decision Trees

#### A. Input Resolution Logic
Input: ConsoleKeyInfo

1. Is Rebinding Active? (In Options Menu)
   - Yes: Consume key, assign to selected Action. Save JSON.
2. Lookup Binding: Query InputMap dictionary.
3. Match Found?
   - Yes: Return associated Command Verb (e.g., "inventory").
   - No: Check Default Hardcoded Bindings (Safe fallback).
   - Else: Return null (ignore input).

#### B. Context Tip Generation
Input: GameState

1. Check Status Effects:
   - Bleeding? -> Tip: "Use Bandage or Tourniquet to stop bleeding."
   - Stunned? -> Tip: "You cannot act this turn."
2. Check Environment:
   - LightLevel < 0.2? -> Tip: "It is dark. Accuracy reduced. Light a torch."
   - Hazard Present? -> Tip: "Steam vents deal Fire damage. Timing is key."
3. Check Enemy:
   - Armor > 10? -> Tip: "Enemy heavily armored. Use Sunder or Magic."
   - Flying? -> Tip: "Melee attacks have -20% accuracy."
4. Sort & Prune: Sort by Priority (Critical > Warning > Info). Take top 3.

### 3. Code Implementation

#### A. Core Layer (Enums)
File: `RuneAndRust.Core/Enums/GameAction.cs`
```csharp
public enum GameAction
{
    MoveNorth, MoveSouth, MoveEast, MoveWest,
    Confirm, Cancel, Menu, Inventory, Character,
    Interact, Attack, Wait
}
```

#### B. Engine Layer (Input Configuration)
File: `RuneAndRust.Engine/Services/InputConfigurationService.cs`
```csharp
public class InputConfigurationService : IInputConfigurationService
{
    private Dictionary<ConsoleKey, string> _keyMap;

    public void LoadBindings()
    {
        if (File.Exists("input_bindings.json"))
        {
            var json = File.ReadAllText("input_bindings.json");
            _keyMap = JsonSerializer.Deserialize<Dictionary<ConsoleKey, string>>(json);
        }
        else
        {
            _keyMap = GetDefaults();
        }
    }

    public string? GetCommandForKey(ConsoleKey key)
    {
        return _keyMap.TryGetValue(key, out var command) ? command : null;
    }

    private Dictionary<ConsoleKey, string> GetDefaults()
    {
        return new Dictionary<ConsoleKey, string>
        {
            { ConsoleKey.I, "inventory" },
            { ConsoleKey.C, "character" },
            { ConsoleKey.Spacebar, "wait" },
            // ... movement keys ...
        };
    }
}
```

#### C. Engine Layer (Context Help)
File: `RuneAndRust.Engine/Services/ContextHelpService.cs`
```csharp
public List<HelpTip> Analyze(GameState state)
{
    var tips = new List<HelpTip>();
    var player = state.CurrentCharacter;

    // Status Checks
    if (player.StatusEffects.Any(e => e.Type == StatusEffectType.Bleeding))
        tips.Add(new HelpTip("Bleeding", "Use [green]Bandage[/] to stop HP loss.", 10));

    // Environmental Checks (v0.3.3)
    if (state.CurrentRoom.Hazards.Any(h => h.State == HazardState.Active))
        tips.Add(new HelpTip("Hazard", "Wait for the hazard to enter Cooldown.", 8));

    // Enemy Checks
    if (state.CombatState?.Enemies.Any(e => e.Tags.Contains("Mechanical")) == true)
        tips.Add(new HelpTip("Tactic", "Mechanical foes are weak to [blue]Shock[/].", 5));

    return tips.OrderByDescending(t => t.Priority).Take(3).ToList();
}
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Input | Config Loaded | Info | "Input bindings loaded. {Count} keys mapped." | Count |
| Input | Rebind | Info | "Rebound action {Action} to {Key}." | Action, Key |
| Help | Tip Generated | Verbose | "Generated context tip: {Title}" | Title |

### 5. Testing Requirements

**Unit Tests (InputServiceTests.cs)**
- **Load_Defaults:** Verify default map is loaded if JSON missing.
- **Resolve_Key:** Given Key I, returns string "inventory".
- **Rebind_Persists:** Change binding, Save, Reload -> Verify new key works.

**Unit Tests (ContextHelpTests.cs)**
- **Trigger_Bleeding:** Add Bleeding status -> Assert tip list contains "Bleeding".
- **Priority_Sorting:** Add 5 tips -> Verify top 3 are highest priority.
- **Empty_State:** No active conditions -> Assert tip list is empty (or shows generic controls).

**Integration Tests**
- **Gameplay_Loop:** Press Custom Key -> InputHandler resolves via Service -> CommandParser executes command.

### 6. Deliverable Checklist (v0.3.9c)

- [ ] Core: Define `GameAction` enum.
- [ ] Core: Define `HelpTip` record.
- [ ] Engine: Implement InputConfigurationService (Load/Save JSON).
- [ ] Engine: Implement ContextHelpService (Analysis Logic).
- [ ] Terminal: Refactor TerminalInputHandler to use InputConfigurationService.
- [ ] Terminal: Update ExplorationScreenRenderer to render a "Guide" panel (Side or Footer).
- [ ] Terminal: Update CombatScreenRenderer to render "Combat Tips".
- [ ] Data: Create default `input_bindings.json`.

---

## Testing Strategy

### Unit Tests
| Test Class | Focus | Key Scenarios |
|------------|-------|---------------|
| VisualEffectServiceTests | FX triggering | ReduceMotion respects setting, Intensity calculation |
| ThemeServiceTests | Color resolution | Standard/HighContrast colors, Fallback logic, Missing keys |
| InputServiceTests | Key binding | Load defaults, Key resolution, Rebind persistence |
| ContextHelpTests | Tip generation | Status triggers, Priority sorting, Empty state |

### Integration Tests
| Scenario | Components | Validation |
|----------|------------|------------|
| Event Wiring | EventBus -> VisualEffectService | FX receives damage events |
| Visual Safety | ThemeService + All Renderers | No crashes on any theme/key combo |
| Gameplay Loop | InputHandler -> CommandParser | Custom keybinds work end-to-end |

---

## Changelog: v0.3.9 - The Feedback

**Release Date:** 2025-XX-XX

### Summary
The "Feedback" update focuses on game feel and accessibility. It introduces a new Visual FX engine for the terminal, adding impact to combat with screen shakes and flash effects. A comprehensive theming system now supports High Contrast and Colorblind modes, and the new Context Help system guides players through complex mechanics as they encounter them.

### Features
- **Visual FX Engine:**
  - **Screen Shake:** Terminal layout shifts dynamically on heavy hits or critical damage.
  - **Flash Effects:** UI borders pulse red/gold on damage or level ups.
  - **Note:** All effects can be disabled via "Reduce Motion" in settings.
- **Accessibility Suite:**
  - **Color Themes:** Full support for Protanopia, Deuteranopia, Tritanopia, and High Contrast modes.
  - **Text Scaling:** Adjustable UI density.
- **Dynamic Input:**
  - Key bindings are now fully remappable via configuration files.
- **Contextual Help:**
  - The sidebar now displays tips relevant to your current situation (e.g., explaining "Soak" when you hit an armored enemy).

### Technical
- Implemented `VisualEffectService` and `ThemeService`.
- Refactored all Renderers to use semantic color lookups instead of hardcoded values.
- Implemented `InputConfigurationService` to decouple hardcoded keys from actions.
- Implemented `ContextHelpService` to analyze GameState and generate prioritized `HelpTip` records.
