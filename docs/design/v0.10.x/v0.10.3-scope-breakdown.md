# v0.10.3 Ability Trees - Scope Breakdown

**Version:** 0.10.3
**Theme:** Combo System
**Prerequisites:** v0.10.2c Complete (Ability Trees - Prerequisites & Respec)
**Total Estimated Tests:** ~35 new tests

---

## Executive Summary

The Combo System sub-version implements ability combos where chaining specific abilities provides bonus effects, and zone control abilities that create persistent effects on grid areas. Combos encourage strategic ability sequencing, while zone control adds battlefield manipulation through persistent area effects.

Key focus areas:
- **Combo Definitions**: Ability sequences that trigger bonus effects
- **Combo Detection**: Tracking ability usage and sequence matching
- **Zone Control**: Persistent grid-based area effects

The work is divided into **three sub-parts**:

| Part | Name | Focus | Est. Tests |
|------|------|-------|------------|
| v0.10.3a | Combo Definitions | ComboDefinition, sequences, bonus effects, config | ~12 |
| v0.10.3b | Combo Detection | ComboService, sequence tracking, window timing | ~12 |
| v0.10.3c | Zone Control | ZoneEffectService, persistent zones, ticking | ~11 |

---

## Existing Infrastructure

### Already Implemented (from v0.5.x)

| Feature | Location | Notes |
|---------|----------|-------|
| CombatGrid | `Domain/Entities/CombatGrid.cs` | Grid-based combat |
| AreaEffectService | `Application/Services/AreaEffectService.cs` | AoE targeting |
| AbilityService | `Application/Services/AbilityService.cs` | Ability execution |
| GridPosition | `Domain/ValueObjects/GridPosition.cs` | Position tracking |

### Already Implemented (from v0.10.1-v0.10.3)

| Feature | Location | Notes |
|---------|----------|-------|
| IBuffDebuffService | `Application/Interfaces/IBuffDebuffService.cs` | Status effects |
| AbilityTreeService | `Application/Services/AbilityTreeService.cs` | Ability trees |
| DamageService | `Application/Services/DamageService.cs` | Damage application |
| EventBus | `Application/Services/EventBus.cs` | Event system |

### Needs Implementation (v0.10.3)

| Feature | Part | Notes |
|---------|------|-------|
| ComboDefinition | v0.10.3a | Combo templates |
| ComboStep | v0.10.3a | Sequence steps |
| ComboBonusEffect | v0.10.3a | Bonus effects |
| IComboService | v0.10.3b | Combo interface |
| ComboService | v0.10.3b | Combo tracking |
| ZoneEffect | v0.10.2c | Zone instances |
| IZoneEffectService | v0.10.2c | Zone interface |
| ZoneEffectService | v0.10.2c | Zone management |

---

## Feature Analysis & Categorization

### Combo Definition Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| ComboDefinition entity | Medium | Domain | **v0.10.3a** |
| ComboStep entity | Low | Combo def | **v0.10.3a** |
| ComboBonusEffect entity | Medium | Effects | **v0.10.3a** |
| combos.json config | Medium | Config | **v0.10.3a** |
| IComboProvider interface | Low | Config | **v0.10.3a** |
| Combo requirements | Low | Steps | **v0.10.3a** |

### Combo Detection Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| IComboService interface | Medium | Application | **v0.10.3b** |
| ComboService impl | High | Service | **v0.10.3b** |
| Ability sequence tracking | High | Abilities | **v0.10.3b** |
| Combo window timing | Medium | Time | **v0.10.3b** |
| Combo completion detection | High | Tracking | **v0.10.3b** |
| Combo UI feedback | Medium | Events | **v0.10.3b** |

### Zone Control Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| ZoneEffect entity | Medium | Domain | **v0.10.2c** |
| IZoneEffectService | Medium | Application | **v0.10.2c** |
| ZoneEffectService | High | Grid, Effects | **v0.10.2c** |
| Zone types | Medium | Config | **v0.10.2c** |
| Zone duration/ticking | Medium | Turn system | **v0.10.2c** |
| Zone damage/buff/debuff | High | Effects | **v0.10.2c** |

---

## Part Definitions

---

## v0.10.3a: Combo Definitions

[v0.10.3a Design Specification](v0.10.3a-design-specification.md)

### Overview

Define the combo structure with sequences of abilities, timing windows, and bonus effects. Combos are loaded from JSON configuration and provide templates for the combo detection system.

### Scope

**In Scope:**
- `ComboDefinition` entity
- `ComboStep` entity
- `ComboBonusEffect` entity
- Ability sequence specification
- Window timing (turns or seconds)
- Bonus effect types (damage, status, reset)
- Class/ability requirements
- `IComboProvider` interface
- `ComboProvider` implementation
- `combos.json` configuration

**Out of Scope:**
- Combo detection/tracking (v0.10.3b)
- Zone control (v0.10.2c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 3 | `ComboDefinition`, `ComboStep`, `ComboBonusEffect` |
| Interfaces | 1 | `IComboProvider` |
| Infrastructure | 1 | `ComboProvider` |
| Configuration | 1 | `combos.json` |
| Unit Tests | ~12 | Combo loading, validation |

### Combo System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMBO DEFINITION ARCHITECTURE                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     Configuration                        Domain
     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”€â”€â”€â”€â”€â”€

   combos.json                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚      ComboDefinition        â”‚
   â”‚ {                â”‚          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚   "comboId": ...,â”‚  â”€â”€â”€â”€â”€â–¶  â”‚ + ComboId: string           â”‚
   â”‚   "name": ...,   â”‚          â”‚ + Name: string              â”‚
   â”‚   "steps": [...] â”‚          â”‚ + Description: string       â”‚
   â”‚   "bonus": {...} â”‚          â”‚ + WindowTurns: int          â”‚
   â”‚ }                â”‚          â”‚ + RequiredClassIds: list    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ + Steps: List<ComboStep>    â”‚
                                 â”‚ + BonusEffects: List<Effect>â”‚
                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                â”‚ contains
                                                â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚                                              â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”
          â”‚     ComboStep       â”‚              â”‚    ComboBonusEffect    â”‚
          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚ + StepNumber: int   â”‚              â”‚ + EffectType: enum     â”‚
          â”‚ + AbilityId: string â”‚              â”‚ + Value: string        â”‚
          â”‚ + TargetReq: enum   â”‚              â”‚ + DamageType: string?  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ + StatusEffectId: str? â”‚
                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ELEMENTAL BURST COMBO EXAMPLE
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    Step 1              Step 2              Step 3           COMBO!
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”¥ Fire â”‚   +    â”‚ â„ Ice  â”‚   +    â”‚ âš¡Light â”‚  =   â”‚ğŸ’¥BURST! â”‚
    â”‚  Bolt   â”‚        â”‚  Shard  â”‚        â”‚  ning   â”‚      â”‚  x2 DMG â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Window: 3 turns                       Bonus: Double damage
```

### ComboDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines an ability combo with steps and bonus effects.
/// </summary>
public class ComboDefinition : IEntity
{
    public Guid Id { get; private set; }
    public string ComboId { get; private set; } = null!;
    public string Name { get; private set; } = null!;
    public string Description { get; private set; } = null!;
    public int WindowTurns { get; private set; }
    public IReadOnlyList<string> RequiredClassIds { get; private set; } = [];
    public IReadOnlyList<ComboStep> Steps { get; private set; } = [];
    public IReadOnlyList<ComboBonusEffect> BonusEffects { get; private set; } = [];
    public string? IconPath { get; private set; }
    
    private ComboDefinition() { }
    
    public static ComboDefinition Create(
        string comboId,
        string name,
        string description,
        int windowTurns,
        IEnumerable<ComboStep> steps,
        IEnumerable<ComboBonusEffect> bonusEffects)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(comboId);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(windowTurns);
        
        var stepList = steps.ToList();
        if (stepList.Count < 2)
            throw new ArgumentException("Combo must have at least 2 steps");
        
        return new ComboDefinition
        {
            Id = Guid.NewGuid(),
            ComboId = comboId.ToLowerInvariant(),
            Name = name,
            Description = description,
            WindowTurns = windowTurns,
            Steps = stepList,
            BonusEffects = bonusEffects.ToList()
        };
    }
    
    /// <summary>Gets the total number of steps in the combo.</summary>
    public int StepCount => Steps.Count;
    
    /// <summary>Gets the ability ID for a specific step.</summary>
    public string GetAbilityForStep(int stepNumber)
    {
        return Steps.FirstOrDefault(s => s.StepNumber == stepNumber)?.AbilityId 
            ?? throw new ArgumentOutOfRangeException(nameof(stepNumber));
    }
    
    /// <summary>Checks if an ability is part of this combo.</summary>
    public bool ContainsAbility(string abilityId)
    {
        return Steps.Any(s => s.AbilityId.Equals(abilityId, StringComparison.OrdinalIgnoreCase));
    }
}
```

### ComboStep Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// A single step in a combo sequence.
/// </summary>
public class ComboStep
{
    public int StepNumber { get; set; }
    public string AbilityId { get; set; } = null!;
    public ComboTargetRequirement TargetRequirement { get; set; } = ComboTargetRequirement.Any;
    public string? CustomRequirement { get; set; }
    
    /// <summary>Checks if this step matches an ability usage.</summary>
    public bool Matches(string abilityId, ICombatant? target, ComboTargetRequirement actualTarget)
    {
        if (!AbilityId.Equals(abilityId, StringComparison.OrdinalIgnoreCase))
            return false;
        
        if (TargetRequirement != ComboTargetRequirement.Any && TargetRequirement != actualTarget)
            return false;
        
        return true;
    }
}

/// <summary>
/// Target requirements for combo steps.
/// </summary>
public enum ComboTargetRequirement
{
    Any,         // Any target
    SameTarget,  // Must be same target as previous step
    DifferentTarget, // Must be different target
    Self         // Must target self
}
```

### ComboBonusEffect Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// A bonus effect applied when a combo completes.
/// </summary>
public class ComboBonusEffect
{
    public ComboBonusType EffectType { get; set; }
    public string Value { get; set; } = null!;
    public string? DamageType { get; set; }
    public string? StatusEffectId { get; set; }
    public ComboBonusTarget Target { get; set; } = ComboBonusTarget.LastTarget;
}

/// <summary>
/// Types of combo bonus effects.
/// </summary>
public enum ComboBonusType
{
    ExtraDamage,      // Deal bonus damage
    DamageMultiplier, // Multiply final step damage
    ApplyStatus,      // Apply a status effect
    Heal,             // Heal the caster
    ResetCooldown,    // Reset ability cooldowns
    RefundResource,   // Refund resource cost
    AreaEffect        // Expand to area
}

/// <summary>
/// Targets for combo bonus effects.
/// </summary>
public enum ComboBonusTarget
{
    LastTarget,   // Target of the final ability
    AllHitTargets, // All targets hit during combo
    Self,          // The caster
    Area           // Area around final target
}
```

### Combo Configuration

```json
{
  "$schema": "./schemas/combos.schema.json",
  "combos": [
    {
      "comboId": "elemental-burst",
      "name": "Elemental Burst",
      "description": "Chain fire, ice, and lightning for explosive damage",
      "windowTurns": 3,
      "requiredClassIds": ["mage", "sorcerer"],
      "steps": [
        { "stepNumber": 1, "abilityId": "fire-bolt", "targetRequirement": "any" },
        { "stepNumber": 2, "abilityId": "ice-shard", "targetRequirement": "sameTarget" },
        { "stepNumber": 3, "abilityId": "lightning", "targetRequirement": "sameTarget" }
      ],
      "bonusEffects": [
        {
          "effectType": "DamageMultiplier",
          "value": "2.0",
          "target": "lastTarget"
        },
        {
          "effectType": "ApplyStatus",
          "statusEffectId": "elemental-overload",
          "target": "lastTarget"
        }
      ],
      "icon": "icons/combos/elemental-burst.png"
    },
    {
      "comboId": "warriors-onslaught",
      "name": "Warrior's Onslaught",
      "description": "Charge in, strike hard, finish them",
      "windowTurns": 2,
      "requiredClassIds": ["warrior", "paladin"],
      "steps": [
        { "stepNumber": 1, "abilityId": "charge", "targetRequirement": "any" },
        { "stepNumber": 2, "abilityId": "power-strike", "targetRequirement": "sameTarget" },
        { "stepNumber": 3, "abilityId": "execute", "targetRequirement": "sameTarget" }
      ],
      "bonusEffects": [
        {
          "effectType": "ApplyStatus",
          "statusEffectId": "stunned",
          "target": "lastTarget"
        },
        {
          "effectType": "ApplyStatus",
          "statusEffectId": "bleeding",
          "target": "lastTarget"
        }
      ],
      "icon": "icons/combos/warriors-onslaught.png"
    },
    {
      "comboId": "assassins-dance",
      "name": "Assassin's Dance",
      "description": "Strike from shadow, vanish, strike again",
      "windowTurns": 2,
      "requiredClassIds": ["rogue", "assassin"],
      "steps": [
        { "stepNumber": 1, "abilityId": "backstab", "targetRequirement": "any" },
        { "stepNumber": 2, "abilityId": "vanish", "targetRequirement": "self" },
        { "stepNumber": 3, "abilityId": "ambush", "targetRequirement": "any" }
      ],
      "bonusEffects": [
        {
          "effectType": "ExtraDamage",
          "value": "4d6",
          "damageType": "piercing",
          "target": "lastTarget"
        },
        {
          "effectType": "ResetCooldown",
          "value": "vanish",
          "target": "self"
        }
      ],
      "icon": "icons/combos/assassins-dance.png"
    },
    {
      "comboId": "divine-judgment",
      "name": "Divine Judgment",
      "description": "Smite the wicked with holy power",
      "windowTurns": 3,
      "requiredClassIds": ["paladin", "cleric"],
      "steps": [
        { "stepNumber": 1, "abilityId": "smite", "targetRequirement": "any" },
        { "stepNumber": 2, "abilityId": "holy-light", "targetRequirement": "sameTarget" }
      ],
      "bonusEffects": [
        {
          "effectType": "AreaEffect",
          "value": "2",
          "target": "area"
        },
        {
          "effectType": "Heal",
          "value": "2d8",
          "target": "self"
        }
      ],
      "icon": "icons/combos/divine-judgment.png"
    }
  ]
}
```

### Acceptance Criteria

- [ ] ComboDefinition loads from JSON
- [ ] Steps define ability sequence
- [ ] WindowTurns specifies timing
- [ ] RequiredClassIds filter availability
- [ ] BonusEffects define rewards
- [ ] ExtraDamage bonus type works
- [ ] DamageMultiplier bonus type works
- [ ] ApplyStatus bonus type works
- [ ] Heal bonus type works
- [ ] ResetCooldown bonus type works
- [ ] Target requirements enforced
- [ ] ~12 unit tests pass

---

## v0.10.3b: Combo Detection

[v0.10.3b Design Specification](v0.10.3b-design-specification.md)

### Overview

Implement the combo tracking system that monitors ability usage, detects sequences matching combo definitions, and applies bonus effects when combos complete. The system tracks progress per combatant and handles timing windows.

### Scope

**In Scope:**
- `IComboService` interface
- `ComboService` implementation
- Per-combatant combo tracking
- Ability usage monitoring
- Sequence matching logic
- Window timing enforcement
- Combo progress tracking
- Combo completion detection
- Bonus effect application
- Combo events (started, progressed, completed, failed)
- Combo UI feedback integration
- GetActiveComboProgress method

**Out of Scope:**
- Combo definitions (v0.10.3a)
- Zone control (v0.10.2c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Interfaces | 1 | `IComboService` |
| Services | 1 | `ComboService` |
| Tracking Entities | 1 | `ComboProgress` |
| Events | 4 | Started, Progressed, Completed, Failed |
| Unit Tests | ~12 | Sequence matching, timing tests |

### Combo Detection Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMBO DETECTION ARCHITECTURE                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   Ability Used Event       â”‚
                      â”‚  (AbilityId, Target, User) â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚       IComboService        â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ + OnAbilityUsed(event)    â”‚
                      â”‚ + GetActiveProgress()     â”‚
                      â”‚ + GetAvailableCombos()    â”‚
                      â”‚ + GetComboHints()         â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚        ComboService        â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ - _comboProvider          â”‚
                      â”‚ - _activeProgress: Dict   â”‚
                      â”‚                           â”‚
                      â”‚ + CheckComboStart         â”‚
                      â”‚ + AdvanceComboProgress    â”‚
                      â”‚ + CheckComboComplete      â”‚
                      â”‚ + ApplyBonusEffects       â”‚
                      â”‚ + ExpireOldProgress       â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    COMBO PROGRESS TRACKING
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    Active Progress for Player "Hero":
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ComboId            â”‚ CurrentStep â”‚ WindowRemaining â”‚ TargetId  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ elemental-burst    â”‚ 2/3         â”‚ 2 turns         â”‚ Goblin-1  â”‚
    â”‚ warriors-onslaught â”‚ 1/3         â”‚ 2 turns         â”‚ Orc-2     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    DETECTION FLOW
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    Ability Used: "ice-shard" on "Goblin-1"
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 1. Check if starts any new combos   â”‚
    â”‚    â†’ "ice-shard" is step 1 of "frost-combo" âœ“
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 2. Check if advances active combos  â”‚
    â”‚    â†’ "elemental-burst" at step 2    â”‚
    â”‚    â†’ Matches! Advance to step 2/3   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 3. Check for combo completions      â”‚
    â”‚    â†’ "elemental-burst" at 3/3?      â”‚
    â”‚    â†’ No, still need "lightning"     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 4. Fire progress event              â”‚
    â”‚    â†’ ComboProgressedEvent           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### IComboService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for tracking and detecting ability combos.
/// </summary>
public interface IComboService
{
    /// <summary>Called when an ability is used, checks for combo progress.</summary>
    /// <param name="user">The combatant using the ability.</param>
    /// <param name="abilityId">The ability used.</param>
    /// <param name="target">The target of the ability.</param>
    /// <returns>Result of combo processing.</returns>
    ComboResult OnAbilityUsed(ICombatant user, string abilityId, ICombatant? target);
    
    /// <summary>Gets active combo progress for a combatant.</summary>
    IReadOnlyList<ComboProgress> GetActiveProgress(ICombatant combatant);
    
    /// <summary>Gets combos available to a combatant based on class.</summary>
    IReadOnlyList<ComboDefinition> GetAvailableCombos(ICombatant combatant);
    
    /// <summary>Gets hints for next abilities to complete active combos.</summary>
    IReadOnlyList<ComboHint> GetComboHints(ICombatant combatant);
    
    /// <summary>Called at turn start to expire old combo progress.</summary>
    void TickCombos(ICombatant combatant);
    
    /// <summary>Resets all combo progress for a combatant.</summary>
    void ResetProgress(ICombatant combatant);
}
```

### ComboService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class ComboService : IComboService
{
    private readonly IComboProvider _comboProvider;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IDamageService _damageService;
    private readonly IDiceService _diceService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<ComboService> _logger;
    
    // Track active combo progress per combatant
    private readonly Dictionary<Guid, List<ComboProgress>> _activeProgress = new();
    
    public ComboService(
        IComboProvider comboProvider,
        IBuffDebuffService buffDebuffService,
        IDamageService damageService,
        IDiceService diceService,
        IEventBus eventBus,
        ILogger<ComboService> logger)
    {
        _comboProvider = comboProvider;
        _buffDebuffService = buffDebuffService;
        _damageService = damageService;
        _diceService = diceService;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public ComboResult OnAbilityUsed(ICombatant user, string abilityId, ICombatant? target)
    {
        var results = new List<ComboActionResult>();
        var completedCombos = new List<ComboDefinition>();
        
        // Get or create progress list for user
        if (!_activeProgress.TryGetValue(user.Id, out var progressList))
        {
            progressList = new List<ComboProgress>();
            _activeProgress[user.Id] = progressList;
        }
        
        // 1. Check if this ability can start any new combos
        var availableCombos = GetAvailableCombos(user);
        foreach (var combo in availableCombos)
        {
            if (combo.Steps[0].AbilityId.Equals(abilityId, StringComparison.OrdinalIgnoreCase))
            {
                // Check if already tracking this combo
                if (!progressList.Any(p => p.ComboId == combo.ComboId))
                {
                    var newProgress = ComboProgress.Start(combo, target?.Id);
                    progressList.Add(newProgress);
                    
                    _logger.LogDebug("{User} started combo {Combo} (step 1/{Total})",
                        user.Name, combo.Name, combo.StepCount);
                    
                    _eventBus.Publish(new ComboStartedEvent(user.Id, combo.ComboId));
                    results.Add(ComboActionResult.Started(combo.ComboId));
                }
            }
        }
        
        // 2. Check if this advances any active combos
        foreach (var progress in progressList.ToList())
        {
            var combo = _comboProvider.GetCombo(progress.ComboId);
            if (combo is null) continue;
            
            var nextStep = combo.Steps.FirstOrDefault(s => s.StepNumber == progress.CurrentStep + 1);
            if (nextStep is null) continue;
            
            // Check if ability matches next step
            var targetReq = target?.Id == progress.LastTargetId 
                ? ComboTargetRequirement.SameTarget 
                : ComboTargetRequirement.DifferentTarget;
            
            if (nextStep.Matches(abilityId, target, targetReq))
            {
                progress.AdvanceStep(target?.Id);
                
                _logger.LogDebug("{User} advanced {Combo} to step {Step}/{Total}",
                    user.Name, combo.Name, progress.CurrentStep, combo.StepCount);
                
                // Check if combo is complete
                if (progress.CurrentStep >= combo.StepCount)
                {
                    completedCombos.Add(combo);
                    ApplyBonusEffects(user, combo, target);
                    progressList.Remove(progress);
                    
                    _logger.LogInformation("{User} completed combo {Combo}!",
                        user.Name, combo.Name);
                    
                    _eventBus.Publish(new ComboCompletedEvent(user.Id, combo.ComboId));
                    results.Add(ComboActionResult.Completed(combo.ComboId));
                }
                else
                {
                    _eventBus.Publish(new ComboProgressedEvent(
                        user.Id, combo.ComboId, progress.CurrentStep, combo.StepCount));
                    results.Add(ComboActionResult.Progressed(combo.ComboId, progress.CurrentStep));
                }
            }
        }
        
        return new ComboResult(results, completedCombos);
    }
    
    private void ApplyBonusEffects(ICombatant user, ComboDefinition combo, ICombatant? target)
    {
        foreach (var bonus in combo.BonusEffects)
        {
            var effectTarget = bonus.Target switch
            {
                ComboBonusTarget.Self => user,
                ComboBonusTarget.LastTarget => target,
                _ => target
            };
            
            if (effectTarget is null) continue;
            
            switch (bonus.EffectType)
            {
                case ComboBonusType.ExtraDamage:
                    var damage = _diceService.Roll(bonus.Value);
                    _damageService.ApplyDamage(effectTarget, 
                        new DamageInstance(damage, bonus.DamageType ?? "physical"));
                    break;
                
                case ComboBonusType.DamageMultiplier:
                    // Applied during ability execution via modifier
                    break;
                
                case ComboBonusType.ApplyStatus:
                    if (bonus.StatusEffectId is not null)
                    {
                        _buffDebuffService.ApplyEffect(effectTarget, bonus.StatusEffectId, user);
                    }
                    break;
                
                case ComboBonusType.Heal:
                    var heal = _diceService.Roll(bonus.Value);
                    effectTarget.Heal(heal);
                    break;
                
                case ComboBonusType.ResetCooldown:
                    user.ResetCooldown(bonus.Value);
                    break;
            }
        }
    }
    
    public void TickCombos(ICombatant combatant)
    {
        if (!_activeProgress.TryGetValue(combatant.Id, out var progressList))
            return;
        
        foreach (var progress in progressList.ToList())
        {
            progress.DecrementWindow();
            
            if (progress.WindowRemaining <= 0)
            {
                progressList.Remove(progress);
                _eventBus.Publish(new ComboFailedEvent(combatant.Id, progress.ComboId, "Window expired"));
                
                _logger.LogDebug("{User} combo {Combo} expired",
                    combatant.Name, progress.ComboId);
            }
        }
    }
    
    public IReadOnlyList<ComboHint> GetComboHints(ICombatant combatant)
    {
        var hints = new List<ComboHint>();
        
        if (!_activeProgress.TryGetValue(combatant.Id, out var progressList))
            return hints;
        
        foreach (var progress in progressList)
        {
            var combo = _comboProvider.GetCombo(progress.ComboId);
            if (combo is null) continue;
            
            var nextStep = combo.Steps.FirstOrDefault(s => s.StepNumber == progress.CurrentStep + 1);
            if (nextStep is not null)
            {
                hints.Add(new ComboHint(
                    combo.ComboId, 
                    combo.Name, 
                    nextStep.AbilityId,
                    progress.WindowRemaining));
            }
        }
        
        return hints;
    }
}
```

### ComboProgress Class

```csharp
namespace RuneAndRust.Application.Tracking;

/// <summary>
/// Tracks progress through a combo for a combatant.
/// </summary>
public class ComboProgress
{
    public string ComboId { get; private set; } = null!;
    public int CurrentStep { get; private set; }
    public int WindowRemaining { get; private set; }
    public Guid? LastTargetId { get; private set; }
    public DateTime StartedAt { get; private set; }
    
    private ComboProgress() { }
    
    public static ComboProgress Start(ComboDefinition combo, Guid? targetId)
    {
        return new ComboProgress
        {
            ComboId = combo.ComboId,
            CurrentStep = 1,
            WindowRemaining = combo.WindowTurns,
            LastTargetId = targetId,
            StartedAt = DateTime.UtcNow
        };
    }
    
    public void AdvanceStep(Guid? targetId)
    {
        CurrentStep++;
        LastTargetId = targetId;
    }
    
    public void DecrementWindow()
    {
        WindowRemaining--;
    }
}
```

### Acceptance Criteria

- [ ] OnAbilityUsed tracks new combos
- [ ] Sequence matching detects progress
- [ ] Window timing expires old progress
- [ ] SameTarget requirement enforced
- [ ] Combo completion detected
- [ ] Bonus effects applied on complete
- [ ] ExtraDamage bonus works
- [ ] ApplyStatus bonus works
- [ ] Heal bonus works
- [ ] ResetCooldown bonus works
- [ ] GetComboHints shows next ability
- [ ] Events fire (started, progressed, completed)
- [ ] ~12 unit tests pass

---

## v0.10.2c: Zone Control

[v0.10.2c Design Specification](v0.10.2c-design-specification.md)

### Overview

Implement zone control abilities that create persistent area effects on the combat grid. Zones can deal damage, apply buffs/debuffs, or modify terrain. Zones tick each turn and expire after their duration.

### Scope

**In Scope:**
- `ZoneEffect` entity
- `ZoneEffectType` enum
- `IZoneEffectService` interface
- `ZoneEffectService` implementation
- Zone creation from abilities
- Zone shapes (circle, line, cone)
- Zone types (damage, buff, debuff, terrain)
- Zone duration tracking
- Zone ticking (apply effects each turn)
- Zone expiration
- Zone overlap handling
- Zone visualization support
- Configuration in `zones.json`

**Out of Scope:**
- Combo definitions (v0.10.3a)
- Combo detection (v0.10.3b)
- Zone creation abilities (defined in abilities.json)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 1 | `ZoneEffect` |
| Domain Enums | 2 | `ZoneEffectType`, `ZoneShape` |
| Interfaces | 1 | `IZoneEffectService` |
| Services | 1 | `ZoneEffectService` |
| Configuration | 1 | `zones.json` |
| Unit Tests | ~11 | Zone creation, ticking, effects |

### Zone Control Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ZONE CONTROL ARCHITECTURE                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      Ability Service       â”‚
                      â”‚   (Zone-creating ability)  â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚ CreateZone
                                      â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚     IZoneEffectService     â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ + CreateZone(def, pos)    â”‚
                      â”‚ + TickZones()             â”‚
                      â”‚ + GetZonesAt(position)    â”‚
                      â”‚ + RemoveZone(zoneId)      â”‚
                      â”‚ + GetAllActiveZones()     â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      ZoneEffectService     â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ - _activeZones: List      â”‚
                      â”‚ - _grid                   â”‚
                      â”‚                           â”‚
                      â”‚ + CalculateAffectedCells  â”‚
                      â”‚ + ApplyZoneEffect         â”‚
                      â”‚ + CheckForEntities        â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ZONE TYPES
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    WALL OF FIRE (Damage)              HEALING CIRCLE (Buff)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”             â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚ğŸ”¥ â”‚ğŸ”¥ â”‚ğŸ”¥ â”‚   â”‚             â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤             â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚             â”‚   â”‚ âœš â”‚ âœš â”‚ âœš â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜             â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
                                       â”‚   â”‚ âœš â”‚ âœš â”‚ âœš â”‚   â”‚
    Deals 2d6 fire/turn               â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    Duration: 5 turns                  
                                       Heals 1d6/turn
                                       Duration: 3 turns


    SLOW FIELD (Debuff)                WEB (Terrain)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”             â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚ ğŸŒâ”‚ ğŸŒâ”‚ ğŸŒâ”‚   â”‚             â”‚   â”‚ ğŸ•¸â”‚ ğŸ•¸â”‚ ğŸ•¸â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤             â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚ ğŸŒâ”‚ ğŸŒâ”‚ ğŸŒâ”‚   â”‚             â”‚   â”‚ ğŸ•¸â”‚ ğŸ•¸â”‚ ğŸ•¸â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜             â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    
    -50% movement speed               Difficult terrain
    Duration: 4 turns                  Immobilize on fail
                                       Duration: 6 turns
```

### ZoneEffect Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// A persistent area effect on the combat grid.
/// </summary>
public class ZoneEffect : IEntity
{
    public Guid Id { get; private set; }
    public string ZoneId { get; private set; } = null!;
    public string Name { get; private set; } = null!;
    public ZoneEffectType EffectType { get; private set; }
    public ZoneShape Shape { get; private set; }
    public GridPosition Center { get; private set; }
    public int Radius { get; private set; }
    public int RemainingDuration { get; private set; }
    public Guid CasterId { get; private set; }
    public string? DamageValue { get; private set; }
    public string? DamageType { get; private set; }
    public string? HealValue { get; private set; }
    public string? StatusEffectId { get; private set; }
    public bool AffectsFriendly { get; private set; }
    public bool AffectsEnemy { get; private set; }
    public IReadOnlyList<GridPosition> AffectedCells { get; private set; } = [];
    
    private ZoneEffect() { }
    
    public static ZoneEffect Create(
        ZoneDefinition definition,
        GridPosition center,
        Guid casterId,
        IEnumerable<GridPosition> affectedCells)
    {
        return new ZoneEffect
        {
            Id = Guid.NewGuid(),
            ZoneId = definition.ZoneId,
            Name = definition.Name,
            EffectType = definition.EffectType,
            Shape = definition.Shape,
            Center = center,
            Radius = definition.Radius,
            RemainingDuration = definition.Duration,
            CasterId = casterId,
            DamageValue = definition.DamageValue,
            DamageType = definition.DamageType,
            HealValue = definition.HealValue,
            StatusEffectId = definition.StatusEffectId,
            AffectsFriendly = definition.AffectsFriendly,
            AffectsEnemy = definition.AffectsEnemy,
            AffectedCells = affectedCells.ToList()
        };
    }
    
    /// <summary>Decrements duration, returns true if expired.</summary>
    public bool Tick()
    {
        RemainingDuration--;
        return RemainingDuration <= 0;
    }
    
    /// <summary>Checks if a position is within this zone.</summary>
    public bool ContainsPosition(GridPosition position)
    {
        return AffectedCells.Contains(position);
    }
}
```

### Zone Enums

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of zone effects.
/// </summary>
public enum ZoneEffectType
{
    Damage,        // Deals damage each turn
    Healing,       // Heals each turn
    Buff,          // Applies a buff while in zone
    Debuff,        // Applies a debuff while in zone
    Terrain,       // Modifies terrain (difficult, blocking)
    Mixed          // Multiple effect types
}

/// <summary>
/// Shapes for zone effects.
/// </summary>
public enum ZoneShape
{
    Circle,        // Circular area
    Square,        // Square area
    Line,          // Line from caster
    Cone,          // Cone from caster
    Ring           // Ring around center (hollow circle)
}
```

### IZoneEffectService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing persistent zone effects.
/// </summary>
public interface IZoneEffectService
{
    /// <summary>Creates a new zone effect.</summary>
    /// <param name="zoneId">The zone definition ID.</param>
    /// <param name="center">Center position of the zone.</param>
    /// <param name="caster">The entity creating the zone.</param>
    /// <returns>The created zone effect.</returns>
    ZoneEffect CreateZone(string zoneId, GridPosition center, ICombatant caster);
    
    /// <summary>Removes a zone by ID.</summary>
    bool RemoveZone(Guid zoneEffectId);
    
    /// <summary>Gets all zones affecting a position.</summary>
    IReadOnlyList<ZoneEffect> GetZonesAt(GridPosition position);
    
    /// <summary>Gets all active zones.</summary>
    IReadOnlyList<ZoneEffect> GetAllActiveZones();
    
    /// <summary>Gets zones created by a specific caster.</summary>
    IReadOnlyList<ZoneEffect> GetZonesByCaster(Guid casterId);
    
    /// <summary>Ticks all zones and applies effects to entities within.</summary>
    ZoneTickResult TickZones(IEnumerable<ICombatant> combatants);
    
    /// <summary>Called when an entity enters a zone.</summary>
    void OnEntityEntered(ICombatant entity, GridPosition position);
    
    /// <summary>Called when an entity exits a zone.</summary>
    void OnEntityExited(ICombatant entity, GridPosition position);
}
```

### ZoneEffectService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class ZoneEffectService : IZoneEffectService
{
    private readonly IZoneProvider _zoneProvider;
    private readonly ICombatGrid _grid;
    private readonly IDamageService _damageService;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IDiceService _diceService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<ZoneEffectService> _logger;
    
    private readonly List<ZoneEffect> _activeZones = new();
    
    public ZoneEffectService(
        IZoneProvider zoneProvider,
        ICombatGrid grid,
        IDamageService damageService,
        IBuffDebuffService buffDebuffService,
        IDiceService diceService,
        IEventBus eventBus,
        ILogger<ZoneEffectService> logger)
    {
        _zoneProvider = zoneProvider;
        _grid = grid;
        _damageService = damageService;
        _buffDebuffService = buffDebuffService;
        _diceService = diceService;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public ZoneEffect CreateZone(string zoneId, GridPosition center, ICombatant caster)
    {
        var definition = _zoneProvider.GetZone(zoneId);
        if (definition is null)
        {
            throw new ArgumentException($"Zone definition not found: {zoneId}");
        }
        
        var affectedCells = CalculateAffectedCells(center, definition.Shape, definition.Radius);
        var zone = ZoneEffect.Create(definition, center, caster.Id, affectedCells);
        
        _activeZones.Add(zone);
        
        _logger.LogInformation("{Caster} created zone {Zone} at {Position}",
            caster.Name, zone.Name, center);
        
        _eventBus.Publish(new ZoneCreatedEvent(zone.Id, zone.ZoneId, center, caster.Id));
        
        return zone;
    }
    
    public ZoneTickResult TickZones(IEnumerable<ICombatant> combatants)
    {
        var result = new ZoneTickResult();
        var combatantList = combatants.ToList();
        var zonesToRemove = new List<ZoneEffect>();
        
        foreach (var zone in _activeZones)
        {
            // Find entities in this zone
            foreach (var combatant in combatantList)
            {
                if (!zone.ContainsPosition(combatant.Position))
                    continue;
                
                // Check if this zone affects this combatant
                var isFriendly = combatant.Id == zone.CasterId || 
                    combatant.TeamId == GetCasterTeam(zone.CasterId);
                
                if (isFriendly && !zone.AffectsFriendly) continue;
                if (!isFriendly && !zone.AffectsEnemy) continue;
                
                // Apply zone effect
                ApplyZoneEffect(zone, combatant, result);
            }
            
            // Tick duration
            if (zone.Tick())
            {
                zonesToRemove.Add(zone);
                result.ExpiredZones.Add(zone.ZoneId);
            }
        }
        
        // Remove expired zones
        foreach (var zone in zonesToRemove)
        {
            _activeZones.Remove(zone);
            _eventBus.Publish(new ZoneExpiredEvent(zone.Id, zone.ZoneId));
        }
        
        return result;
    }
    
    private void ApplyZoneEffect(ZoneEffect zone, ICombatant target, ZoneTickResult result)
    {
        switch (zone.EffectType)
        {
            case ZoneEffectType.Damage:
                if (zone.DamageValue is not null)
                {
                    var damage = _diceService.Roll(zone.DamageValue);
                    _damageService.ApplyDamage(target, 
                        new DamageInstance(damage, zone.DamageType ?? "magic"));
                    result.DamageDealt += damage;
                    
                    _logger.LogDebug("{Zone} dealt {Damage} to {Target}",
                        zone.Name, damage, target.Name);
                }
                break;
            
            case ZoneEffectType.Healing:
                if (zone.HealValue is not null)
                {
                    var heal = _diceService.Roll(zone.HealValue);
                    target.Heal(heal);
                    result.HealingDone += heal;
                }
                break;
            
            case ZoneEffectType.Buff:
            case ZoneEffectType.Debuff:
                if (zone.StatusEffectId is not null)
                {
                    _buffDebuffService.ApplyEffect(target, zone.StatusEffectId);
                }
                break;
            
            case ZoneEffectType.Terrain:
                // Terrain effects handled by movement service
                break;
        }
    }
    
    private IReadOnlyList<GridPosition> CalculateAffectedCells(
        GridPosition center, ZoneShape shape, int radius)
    {
        var cells = new List<GridPosition>();
        
        switch (shape)
        {
            case ZoneShape.Circle:
                for (int x = -radius; x <= radius; x++)
                {
                    for (int y = -radius; y <= radius; y++)
                    {
                        if (x * x + y * y <= radius * radius)
                        {
                            cells.Add(new GridPosition(center.X + x, center.Y + y));
                        }
                    }
                }
                break;
            
            case ZoneShape.Square:
                for (int x = -radius; x <= radius; x++)
                {
                    for (int y = -radius; y <= radius; y++)
                    {
                        cells.Add(new GridPosition(center.X + x, center.Y + y));
                    }
                }
                break;
            
            case ZoneShape.Line:
                // Line from center in direction (simplified: horizontal)
                for (int x = 0; x <= radius; x++)
                {
                    cells.Add(new GridPosition(center.X + x, center.Y));
                }
                break;
        }
        
        // Filter to valid grid cells
        return cells.Where(c => _grid.IsValidPosition(c)).ToList();
    }
}
```

### Zone Configuration

```json
{
  "$schema": "./schemas/zones.schema.json",
  "zones": [
    {
      "zoneId": "wall-of-fire",
      "name": "Wall of Fire",
      "description": "A blazing wall that burns enemies",
      "effectType": "Damage",
      "shape": "Line",
      "radius": 4,
      "duration": 5,
      "damageValue": "2d6",
      "damageType": "fire",
      "affectsFriendly": false,
      "affectsEnemy": true,
      "icon": "icons/zones/wall-of-fire.png"
    },
    {
      "zoneId": "healing-circle",
      "name": "Healing Circle",
      "description": "An area of divine healing",
      "effectType": "Healing",
      "shape": "Circle",
      "radius": 2,
      "duration": 3,
      "healValue": "1d6+2",
      "affectsFriendly": true,
      "affectsEnemy": false,
      "icon": "icons/zones/healing-circle.png"
    },
    {
      "zoneId": "slow-field",
      "name": "Slow Field",
      "description": "Time distortion slows movement",
      "effectType": "Debuff",
      "shape": "Circle",
      "radius": 3,
      "duration": 4,
      "statusEffectId": "slowed",
      "affectsFriendly": false,
      "affectsEnemy": true,
      "icon": "icons/zones/slow-field.png"
    },
    {
      "zoneId": "web",
      "name": "Web",
      "description": "Sticky webs that entangle enemies",
      "effectType": "Terrain",
      "shape": "Circle",
      "radius": 2,
      "duration": 6,
      "statusEffectId": "entangled",
      "terrainModifier": "DifficultTerrain",
      "affectsFriendly": false,
      "affectsEnemy": true,
      "icon": "icons/zones/web.png"
    },
    {
      "zoneId": "consecration",
      "name": "Consecration",
      "description": "Holy ground that damages undead and heals allies",
      "effectType": "Mixed",
      "shape": "Circle",
      "radius": 2,
      "duration": 5,
      "damageValue": "1d8",
      "damageType": "radiant",
      "healValue": "1d4",
      "affectsFriendly": true,
      "affectsEnemy": true,
      "monsterTypes": ["undead", "demon"],
      "icon": "icons/zones/consecration.png"
    }
  ]
}
```

### Acceptance Criteria

- [ ] CreateZone creates zone at position
- [ ] Zone shapes calculated correctly
- [ ] Circle shape uses radius
- [ ] Line shape extends from center
- [ ] TickZones applies effects to entities
- [ ] Damage zones deal damage each turn
- [ ] Healing zones heal each turn
- [ ] Buff/debuff zones apply status
- [ ] Zone duration decrements
- [ ] Expired zones removed
- [ ] GetZonesAt returns affecting zones
- [ ] AffectsFriendly/Enemy respected
- [ ] ~11 unit tests pass

---

## Dependencies & Prerequisites

```
v0.10.2c (Prerequisites & Respec) - REQUIRED
    â”‚
    â””â”€â”€ Ability Trees complete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                                          â”‚
v0.10.3 (Combo System)                                                    â”‚
    â”‚                                                                     â”‚
    â”œâ”€â”€ v0.10.3a: Combo Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚       Dependencies: Domain, Configuration                           â”‚
    â”‚       Provides: ComboDefinition, steps, bonus effects               â”‚
    â”‚                                                                     â”‚
    â”œâ”€â”€ v0.10.3b: Combo Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚       Dependencies: v0.10.3a (combos), AbilityService, EventBus     â”‚
    â”‚       Provides: IComboService, sequence tracking                    â”‚
    â”‚                                                                     â”‚
    â””â”€â”€ v0.10.2c: Zone Control â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            Dependencies: Grid, DamageService, BuffDebuffService
            Provides: IZoneEffectService, persistent zones
```

---

## Estimated Effort Summary

| Part | New Files | Modified Files | Est. Tests | Complexity |
|------|-----------|----------------|------------|------------|
| v0.10.3a | ~4 | ~1 | ~12 | Medium |
| v0.10.3b | ~3 | ~2 | ~12 | High |
| v0.10.2c | ~4 | ~2 | ~11 | High |
| **Total** | **~11** | **~5** | **~35** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Combo timing edge cases | Medium | Medium | Clear window rules |
| Sequence matching complexity | Medium | Low | Thorough testing |
| Zone performance (many zones) | Low | Low | Limit active zones |
| Zone overlap effects | Medium | Medium | Define stacking rules |

---

## Design Decisions (Confirmed)

### Combo System

| Decision | Value | Notes |
|----------|-------|-------|
| **Window Unit** | Turns | Simpler than real-time |
| **Same Target** | Tracked per combo | For targeting chains |
| **Multi-combo** | Allowed | Track multiple simultaneously |

### Bonus Effects

| Decision | Value | Notes |
|----------|-------|-------|
| **Multiplier Timing** | On complete | Before damage calc |
| **Status Apply** | After complete | Immediate application |
| **Cooldown Reset** | Specific ability | Named in value |

### Zone Control

| Decision | Value | Notes |
|----------|-------|-------|
| **Max Zones** | 10 per caster | Performance limit |
| **Overlap** | All apply | Multiple zones stack |
| **Tick Timing** | Turn start | Before movement |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.10.3a Design Spec** - Create detailed design for Combo Definitions
3. **v0.10.3a Implementation** - Build combo structure
4. **v0.10.3b Design Spec** - Create specification for Combo Detection
5. **v0.10.3b Implementation** - Build tracking system
6. **v0.10.2c Design Spec** - Create specification for Zone Control
7. **v0.10.2c Implementation** - Build zone management

---

*This scope breakdown provides a structured approach to implementing v0.10.3 Combo System. Ability combos encourage strategic sequencing with bonus rewards, while zone control adds battlefield manipulation through persistent area effects.*
