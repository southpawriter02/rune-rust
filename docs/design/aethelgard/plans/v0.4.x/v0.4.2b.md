# Implementation Plan: v0.4.2b - The Lexicon (Dialogue Data Models & Conditions)

**Status:** Ready for Implementation
**Theme:** "The Lexicon"
**Scope:** Dialogue tree entities, polymorphic condition system, condition evaluator service
**Depends On:** v0.4.2a (Faction System - for ReputationCondition)

---

## Executive Summary

v0.4.2b establishes the **Dialogue Data Model** — the entity structure for branching conversations and the polymorphic condition system that gates dialogue options. This release creates the foundation for NPCs to have dynamic, context-sensitive conversations.

**Key Features:**
- **Dialogue Tree Structure:** `DialogueTree` → `DialogueNode` → `DialogueOption` hierarchy
- **Polymorphic Conditions:** 8 condition types (Attribute, Level, Reputation, Flag, Item, Specialization, Node, SkillCheck)
- **Condition Evaluator:** Service to check if a character meets dialogue option requirements
- **Visibility Modes:** Hidden vs Locked-with-reason display strategies
- **JSONB Storage:** Conditions and effects stored as JSONB arrays in PostgreSQL

**Layers Touched:** Core (Enums, Entities, Models, Interfaces), Engine (Services), Persistence (Repositories, DbContext, Migrations), Tests
**Patterns Used:** Polymorphic type hierarchy, Strategy pattern, JSONB serialization, Result records
**Target Test Count:** 48 unit tests

---

## Table of Contents

1. [Decision Trees](#1-decision-trees)
2. [Deliverable Checklist](#2-deliverable-checklist)
3. [Enum Definitions](#3-enum-definitions)
4. [Entity Definitions](#4-entity-definitions)
5. [Condition Type Hierarchy](#5-condition-type-hierarchy)
6. [Effect Type Hierarchy](#6-effect-type-hierarchy)
7. [Result & DTO Definitions](#7-result--dto-definitions)
8. [Interface Definitions](#8-interface-definitions)
9. [Condition Evaluator Service](#9-condition-evaluator-service)
10. [Repository Implementation](#10-repository-implementation)
11. [Database Migration](#11-database-migration)
12. [DbContext Configuration](#12-dbcontext-configuration)
13. [DI Registration](#13-di-registration)
14. [Logging Matrix](#14-logging-matrix)
15. [Test Coverage Plan](#15-test-coverage-plan)
16. [Code Examples](#16-code-examples)
17. [Changelog Template](#17-changelog-template)
18. [Critical Files](#18-critical-files)
19. [Implementation Order](#19-implementation-order)
20. [Design Decisions](#20-design-decisions)

---

## 1. Decision Trees

### 1.1 Condition Evaluation Flow

```
EvaluateCondition(character, condition)
                │
                ▼
    ┌───────────────────────────────┐
    │ Log entry at Trace level      │
    │ "[Dialogue] Evaluating        │
    │  {ConditionType} condition"   │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ condition.Type?               │
    └───────────────────────────────┘
                │
    ┌───────────┼───────────┬───────────┬───────────┬───────────┐
    │           │           │           │           │           │
Attribute    Level      Reputation    Flag       Item      SkillCheck
    │           │           │           │           │           │
    ▼           ▼           ▼           ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│Evaluate │ │Evaluate │ │Evaluate │ │Evaluate │ │Evaluate │ │Evaluate │
│Attribute│ │Level    │ │Reputation│ │Flag    │ │Item     │ │SkillChk │
│Condition│ │Condition│ │Condition│ │Condition│ │Condition│ │Condition│
└─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘
    │           │           │           │           │           │
    └───────────┴───────────┴─────┬─────┴───────────┴───────────┘
                                  │
                                  ▼
                    ┌───────────────────────────────┐
                    │ Return ConditionResult        │
                    │ (Success, FailureReason,      │
                    │  DisplayHint)                 │
                    └───────────────────────────────┘
```

### 1.2 Attribute Condition Evaluation

```
EvaluateAttributeCondition(character, condition)
                │
                ▼
    ┌───────────────────────────────┐
    │ Get attribute value from      │
    │ character.GetAttribute(attr)  │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ condition.ComparisonType?     │
    └───────────────────────────────┘
                │
    ┌───────────┼───────────┐
    │           │           │
   >=          ==          >
    │           │           │
    ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│ value   │ │ value   │ │ value   │
│   >=    │ │   ==    │ │   >     │
│threshold│ │threshold│ │threshold│
└─────────┘ └─────────┘ └─────────┘
    │           │           │
    └─────┬─────┴───────────┘
          │
          ▼
    ┌───────────────────────────────┐
    │ Passed?                       │
    └───────────────────────────────┘
          │
    ┌─────┴─────┐
   Yes          No
    │            │
    ▼            ▼
┌─────────┐  ┌─────────────────────────────────────┐
│ Return  │  │ Return ConditionResult.Fail(        │
│ Success │  │   $"Requires {Attr} {Op} {Val}",    │
│         │  │   $"[{Attr} {threshold}]")          │
└─────────┘  └─────────────────────────────────────┘
```

### 1.3 Reputation Condition Evaluation

```
EvaluateReputationCondition(character, condition)
                │
                ▼
    ┌───────────────────────────────┐
    │ Get reputation from           │
    │ IFactionService.              │
    │ GetReputationAsync(char, fac) │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Get current disposition from  │
    │ IFactionService.              │
    │ GetDisposition(reputation)    │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ currentDisposition >=         │
    │ condition.MinDisposition?     │
    └───────────────────────────────┘
          │
    ┌─────┴─────┐
   Yes          No
    │            │
    ▼            ▼
┌─────────┐  ┌─────────────────────────────────────┐
│ Return  │  │ Return ConditionResult.Fail(        │
│ Success │  │   $"Requires {MinDisp} with {Fac}", │
│         │  │   $"[{Faction}: {MinDisp}]")        │
└─────────┘  └─────────────────────────────────────┘
```

### 1.4 Skill Check Condition Evaluation

```
EvaluateSkillCheckCondition(character, condition)
                │
                ▼
    ┌───────────────────────────────┐
    │ Get attribute pool size from  │
    │ character.GetAttribute(attr)  │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Roll dice pool via            │
    │ IDiceService.Roll(pool, ctx)  │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ netSuccesses = successes -    │
    │                botches        │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ netSuccesses >= DC?           │
    └───────────────────────────────┘
          │
    ┌─────┴─────┐
   Yes          No
    │            │
    ▼            ▼
┌─────────┐  ┌─────────────────────────────────────┐
│ Return  │  │ Return ConditionResult.Fail(        │
│ Success │  │   "Skill check failed",             │
│ (+ roll │  │   $"[{Attr} DC {DC}]",              │
│  info)  │  │   rollResult)                       │
└─────────┘  └─────────────────────────────────────┘
```

### 1.5 Option Visibility Decision

```
DetermineOptionVisibility(character, option)
                │
                ▼
    ┌───────────────────────────────┐
    │ option.Conditions empty?      │
    └───────────────────────────────┘
          │
    ┌─────┴─────┐
   Yes          No
    │            │
    ▼            ▼
┌─────────┐  ┌───────────────────────────────┐
│ Return  │  │ Evaluate all conditions       │
│ Visible │  │ (AND logic - all must pass)   │
│         │  └───────────────────────────────┘
└─────────┘                │
                           ▼
               ┌───────────────────────────────┐
               │ All conditions passed?        │
               └───────────────────────────────┘
                           │
                   ┌───────┴───────┐
                  Yes              No
                   │                │
                   ▼                ▼
           ┌─────────────┐  ┌───────────────────────────────┐
           │ Return      │  │ option.VisibilityMode?        │
           │ Visible +   │  └───────────────────────────────┘
           │ Available   │              │
           └─────────────┘      ┌───────┴───────┐
                            Hidden          ShowLocked
                               │                │
                               ▼                ▼
                       ┌─────────────┐  ┌─────────────────┐
                       │ Return      │  │ Return          │
                       │ Hidden      │  │ Visible +       │
                       │ (omit from  │  │ Locked +        │
                       │  display)   │  │ FailureReason   │
                       └─────────────┘  └─────────────────┘
```

---

## 2. Deliverable Checklist

### New Files to Create

| Layer | File Path | Purpose |
|-------|-----------|---------|
| Core | `RuneAndRust.Core/Enums/ConditionType.cs` | Condition type discriminator |
| Core | `RuneAndRust.Core/Enums/ComparisonType.cs` | Comparison operators |
| Core | `RuneAndRust.Core/Enums/OptionVisibility.cs` | Display modes for locked options |
| Core | `RuneAndRust.Core/Enums/EffectType.cs` | Effect type discriminator |
| Core | `RuneAndRust.Core/Entities/DialogueTree.cs` | Root dialogue container |
| Core | `RuneAndRust.Core/Entities/DialogueNode.cs` | Single conversation node |
| Core | `RuneAndRust.Core/Entities/DialogueOption.cs` | Player choice with conditions |
| Core | `RuneAndRust.Core/Conditions/DialogueCondition.cs` | Base condition class |
| Core | `RuneAndRust.Core/Conditions/AttributeCondition.cs` | Attribute check condition |
| Core | `RuneAndRust.Core/Conditions/LevelCondition.cs` | Level requirement condition |
| Core | `RuneAndRust.Core/Conditions/ReputationCondition.cs` | Faction reputation condition |
| Core | `RuneAndRust.Core/Conditions/FlagCondition.cs` | Game flag condition |
| Core | `RuneAndRust.Core/Conditions/ItemCondition.cs` | Item possession condition |
| Core | `RuneAndRust.Core/Conditions/SpecializationCondition.cs` | Specialization check |
| Core | `RuneAndRust.Core/Conditions/NodeCondition.cs` | Spec node unlocked check |
| Core | `RuneAndRust.Core/Conditions/SkillCheckCondition.cs` | Dice roll skill check |
| Core | `RuneAndRust.Core/Effects/DialogueEffect.cs` | Base effect class |
| Core | `RuneAndRust.Core/Effects/ModifyReputationEffect.cs` | Rep change effect |
| Core | `RuneAndRust.Core/Effects/GiveItemEffect.cs` | Item grant effect |
| Core | `RuneAndRust.Core/Effects/SetFlagEffect.cs` | Flag set effect |
| Core | `RuneAndRust.Core/Models/ConditionResult.cs` | Evaluation result record |
| Core | `RuneAndRust.Core/Models/OptionVisibilityResult.cs` | Option display state |
| Core | `RuneAndRust.Core/Interfaces/IDialogueConditionEvaluator.cs` | Evaluator interface |
| Core | `RuneAndRust.Core/Interfaces/IDialogueRepository.cs` | Repository interface |
| Core | `RuneAndRust.Core/Serialization/ConditionJsonConverter.cs` | Polymorphic JSON converter |
| Core | `RuneAndRust.Core/Serialization/EffectJsonConverter.cs` | Polymorphic JSON converter |
| Engine | `RuneAndRust.Engine/Services/DialogueConditionEvaluator.cs` | Evaluator implementation |
| Persistence | `RuneAndRust.Persistence/Repositories/DialogueRepository.cs` | Repository implementation |
| Persistence | `Migrations/V0.4.2b__Dialogue_System.sql` | PostgreSQL migration |
| Tests | `RuneAndRust.Tests/Engine/DialogueConditionEvaluatorTests.cs` | 48 unit tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Add DbSets, configure JSONB conversions |
| `RuneAndRust.Terminal/Program.cs` | Register services |
| `RuneAndRust.Core/Serialization/GameStateContext.cs` | Add condition/effect type info (if needed) |

---

## 3. Enum Definitions

### 3.1 ConditionType

**File:** `RuneAndRust.Core/Enums/ConditionType.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Discriminator for polymorphic dialogue condition types.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public enum ConditionType
{
    /// <summary>Check a character attribute (e.g., WITS >= 6).</summary>
    Attribute = 0,

    /// <summary>Check character level (e.g., Level >= 5).</summary>
    Level = 1,

    /// <summary>Check faction reputation/disposition (e.g., Iron-Banes: Friendly).</summary>
    Reputation = 2,

    /// <summary>Check a game flag value (e.g., HasCompletedTutorial).</summary>
    Flag = 3,

    /// <summary>Check item possession (e.g., Has: Iron Key x1).</summary>
    Item = 4,

    /// <summary>Check specialization access (e.g., Is: Berserkr).</summary>
    Specialization = 5,

    /// <summary>Check specialization node unlocked (e.g., Has: Rage ability).</summary>
    Node = 6,

    /// <summary>Dice roll skill check (e.g., Roll WITS DC 3).</summary>
    SkillCheck = 7
}
```

### 3.2 ComparisonType

**File:** `RuneAndRust.Core/Enums/ComparisonType.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Comparison operators for numeric condition checks.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public enum ComparisonType
{
    /// <summary>Greater than or equal to (>=).</summary>
    GreaterThanOrEqual = 0,

    /// <summary>Exactly equal to (==).</summary>
    Equal = 1,

    /// <summary>Greater than (>).</summary>
    GreaterThan = 2,

    /// <summary>Less than (<).</summary>
    LessThan = 3,

    /// <summary>Less than or equal to (<=).</summary>
    LessThanOrEqual = 4,

    /// <summary>Not equal to (!=).</summary>
    NotEqual = 5
}
```

### 3.3 OptionVisibility

**File:** `RuneAndRust.Core/Enums/OptionVisibility.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Controls how a dialogue option is displayed when conditions fail.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public enum OptionVisibility
{
    /// <summary>
    /// Option is always visible. If conditions fail, show as locked with reason.
    /// Example: "[LOCKED: Friendly] Trade supplies"
    /// </summary>
    ShowLocked = 0,

    /// <summary>
    /// Option is hidden entirely when conditions fail.
    /// Player doesn't know the option exists until they qualify.
    /// </summary>
    Hidden = 1
}
```

### 3.4 EffectType

**File:** `RuneAndRust.Core/Enums/EffectType.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Discriminator for polymorphic dialogue effect types.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public enum EffectType
{
    /// <summary>Modify faction reputation (e.g., +10 with Iron-Banes).</summary>
    ModifyReputation = 0,

    /// <summary>Give item to character (e.g., Receive: Rusty Key x1).</summary>
    GiveItem = 1,

    /// <summary>Remove item from character (e.g., Remove: Gold x50).</summary>
    RemoveItem = 2,

    /// <summary>Set a game flag (e.g., Set: MetOldScavenger = true).</summary>
    SetFlag = 3,

    /// <summary>Start a quest (e.g., Start: quest_iron_bane_intro).</summary>
    StartQuest = 4,

    /// <summary>Trigger combat encounter (e.g., Combat: ambush_bound_cultist).</summary>
    TriggerCombat = 5,

    /// <summary>Heal the character (e.g., Heal: 10 HP).</summary>
    Heal = 6,

    /// <summary>Grant experience/legend points (e.g., Grant: 50 Legend).</summary>
    GiveXP = 7
}
```

---

## 4. Entity Definitions

### 4.1 DialogueTree

**File:** `RuneAndRust.Core/Entities/DialogueTree.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

/// <summary>
/// Root container for an NPC's dialogue content.
/// Contains all nodes and tracks metadata for the conversation.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class DialogueTree
{
    /// <summary>
    /// Unique database identifier.
    /// </summary>
    public Guid Id { get; set; } = Guid.NewGuid();

    /// <summary>
    /// Unique string identifier for lookups (e.g., "npc_old_scavenger").
    /// </summary>
    public string TreeId { get; set; } = string.Empty;

    /// <summary>
    /// The NPC's display name shown in dialogue UI.
    /// </summary>
    public string NpcName { get; set; } = string.Empty;

    /// <summary>
    /// Optional NPC title shown below name (e.g., "Iron-Bane Elder").
    /// </summary>
    public string? NpcTitle { get; set; }

    /// <summary>
    /// ID of the starting node when dialogue begins.
    /// </summary>
    public string RootNodeId { get; set; } = "root";

    /// <summary>
    /// Optional faction association for this NPC.
    /// Used for reputation-based dialogue gating.
    /// </summary>
    public FactionType? AssociatedFaction { get; set; }

    /// <summary>
    /// When this dialogue tree was created.
    /// </summary>
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// Navigation property: All nodes in this tree.
    /// </summary>
    public ICollection<DialogueNode> Nodes { get; set; } = new List<DialogueNode>();
}
```

### 4.2 DialogueNode

**File:** `RuneAndRust.Core/Entities/DialogueNode.cs`

```csharp
namespace RuneAndRust.Core.Entities;

/// <summary>
/// A single node in a dialogue tree, representing one "screen" of conversation.
/// Contains the NPC's text and available player responses.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class DialogueNode
{
    /// <summary>
    /// Unique database identifier.
    /// </summary>
    public Guid Id { get; set; } = Guid.NewGuid();

    /// <summary>
    /// Foreign key to the parent DialogueTree.
    /// </summary>
    public Guid TreeId { get; set; }

    /// <summary>
    /// String identifier within the tree (e.g., "greeting", "quest_offer").
    /// Must be unique within the tree.
    /// </summary>
    public string NodeId { get; set; } = string.Empty;

    /// <summary>
    /// Name of the speaker for this node (usually NPC name, but can be others).
    /// </summary>
    public string SpeakerName { get; set; } = string.Empty;

    /// <summary>
    /// The dialogue text displayed to the player.
    /// Supports basic markdown formatting.
    /// </summary>
    public string Text { get; set; } = string.Empty;

    /// <summary>
    /// Whether this node ends the conversation.
    /// Terminal nodes have no options or only "goodbye" options.
    /// </summary>
    public bool IsTerminal { get; set; } = false;

    /// <summary>
    /// Navigation property to the parent tree.
    /// </summary>
    public DialogueTree Tree { get; set; } = null!;

    /// <summary>
    /// Navigation property: Available player responses.
    /// </summary>
    public ICollection<DialogueOption> Options { get; set; } = new List<DialogueOption>();
}
```

### 4.3 DialogueOption

**File:** `RuneAndRust.Core/Entities/DialogueOption.cs`

```csharp
using RuneAndRust.Core.Conditions;
using RuneAndRust.Core.Effects;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

/// <summary>
/// A player response choice within a dialogue node.
/// Contains conditions for availability and effects on selection.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class DialogueOption
{
    /// <summary>
    /// Unique database identifier.
    /// </summary>
    public Guid Id { get; set; } = Guid.NewGuid();

    /// <summary>
    /// Foreign key to the parent DialogueNode.
    /// </summary>
    public Guid NodeId { get; set; }

    /// <summary>
    /// The text displayed for this choice.
    /// </summary>
    public string Text { get; set; } = string.Empty;

    /// <summary>
    /// The NodeId to navigate to when selected.
    /// Null for terminal options (ends conversation).
    /// </summary>
    public string? NextNodeId { get; set; }

    /// <summary>
    /// Display order (lower numbers appear first).
    /// </summary>
    public int DisplayOrder { get; set; } = 0;

    /// <summary>
    /// How to display this option when conditions fail.
    /// </summary>
    public OptionVisibility VisibilityMode { get; set; } = OptionVisibility.ShowLocked;

    /// <summary>
    /// Conditions that must ALL be met to select this option.
    /// Stored as JSONB in PostgreSQL.
    /// </summary>
    public List<DialogueCondition> Conditions { get; set; } = new();

    /// <summary>
    /// Effects to execute when this option is selected.
    /// Stored as JSONB in PostgreSQL.
    /// </summary>
    public List<DialogueEffect> Effects { get; set; } = new();

    /// <summary>
    /// Navigation property to the parent node.
    /// </summary>
    public DialogueNode Node { get; set; } = null!;

    /// <summary>
    /// Whether this option has any conditions.
    /// </summary>
    public bool HasConditions => Conditions.Count > 0;

    /// <summary>
    /// Whether this option has any effects.
    /// </summary>
    public bool HasEffects => Effects.Count > 0;

    /// <summary>
    /// Whether this option ends the conversation.
    /// </summary>
    public bool IsTerminal => NextNodeId == null;
}
```

---

## 5. Condition Type Hierarchy

### 5.1 Base DialogueCondition

**File:** `RuneAndRust.Core/Conditions/DialogueCondition.cs`

```csharp
using System.Text.Json.Serialization;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Base class for all dialogue condition types.
/// Conditions determine whether a dialogue option is available.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
[JsonPolymorphic(TypeDiscriminatorPropertyName = "$type")]
[JsonDerivedType(typeof(AttributeCondition), "attribute")]
[JsonDerivedType(typeof(LevelCondition), "level")]
[JsonDerivedType(typeof(ReputationCondition), "reputation")]
[JsonDerivedType(typeof(FlagCondition), "flag")]
[JsonDerivedType(typeof(ItemCondition), "item")]
[JsonDerivedType(typeof(SpecializationCondition), "specialization")]
[JsonDerivedType(typeof(NodeCondition), "node")]
[JsonDerivedType(typeof(SkillCheckCondition), "skillcheck")]
public abstract class DialogueCondition
{
    /// <summary>
    /// The type of this condition for polymorphic handling.
    /// </summary>
    public abstract ConditionType Type { get; }

    /// <summary>
    /// If true, option is hidden when condition fails.
    /// If false, option shows as locked with requirement hint.
    /// </summary>
    public bool HideWhenFailed { get; set; } = false;

    /// <summary>
    /// Gets the display string shown when condition fails (e.g., "[WITS 6]").
    /// </summary>
    public abstract string GetDisplayHint();
}
```

### 5.2 AttributeCondition

**File:** `RuneAndRust.Core/Conditions/AttributeCondition.cs`

```csharp
using RuneAndRust.Core.Enums;
using CharacterAttribute = RuneAndRust.Core.Enums.Attribute;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Condition that checks a character attribute against a threshold.
/// Example: [WITS >= 6] for perception-based dialogue.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class AttributeCondition : DialogueCondition
{
    /// <inheritdoc/>
    public override ConditionType Type => ConditionType.Attribute;

    /// <summary>
    /// The attribute to check (e.g., Wits, Might, Will).
    /// </summary>
    public CharacterAttribute Attribute { get; set; }

    /// <summary>
    /// The comparison operator (default: >=).
    /// </summary>
    public ComparisonType Comparison { get; set; } = ComparisonType.GreaterThanOrEqual;

    /// <summary>
    /// The threshold value to compare against.
    /// </summary>
    public int Threshold { get; set; }

    /// <inheritdoc/>
    public override string GetDisplayHint()
    {
        var op = Comparison switch
        {
            ComparisonType.GreaterThanOrEqual => "",  // Default, no symbol needed
            ComparisonType.Equal => "=",
            ComparisonType.GreaterThan => ">",
            ComparisonType.LessThan => "<",
            ComparisonType.LessThanOrEqual => "<=",
            ComparisonType.NotEqual => "!=",
            _ => ""
        };
        return $"[{Attribute.ToString().ToUpperInvariant()} {op}{Threshold}]";
    }
}
```

### 5.3 LevelCondition

**File:** `RuneAndRust.Core/Conditions/LevelCondition.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Condition that checks character level.
/// Example: [Level >= 5] for advanced dialogue.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class LevelCondition : DialogueCondition
{
    /// <inheritdoc/>
    public override ConditionType Type => ConditionType.Level;

    /// <summary>
    /// Minimum level required.
    /// </summary>
    public int MinLevel { get; set; } = 1;

    /// <inheritdoc/>
    public override string GetDisplayHint() => $"[Level {MinLevel}]";
}
```

### 5.4 ReputationCondition

**File:** `RuneAndRust.Core/Conditions/ReputationCondition.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Condition that checks faction reputation/disposition.
/// Example: [Iron-Banes: Friendly] for faction-gated dialogue.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class ReputationCondition : DialogueCondition
{
    /// <inheritdoc/>
    public override ConditionType Type => ConditionType.Reputation;

    /// <summary>
    /// The faction to check reputation with.
    /// </summary>
    public FactionType Faction { get; set; }

    /// <summary>
    /// The minimum disposition tier required.
    /// </summary>
    public Disposition MinDisposition { get; set; } = Disposition.Neutral;

    /// <inheritdoc/>
    public override string GetDisplayHint() => $"[{Faction}: {MinDisposition}]";
}
```

### 5.5 FlagCondition

**File:** `RuneAndRust.Core/Conditions/FlagCondition.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Condition that checks a game flag value.
/// Example: [HasCompletedTutorial] for progression-gated dialogue.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class FlagCondition : DialogueCondition
{
    /// <inheritdoc/>
    public override ConditionType Type => ConditionType.Flag;

    /// <summary>
    /// The flag key to check.
    /// </summary>
    public string FlagKey { get; set; } = string.Empty;

    /// <summary>
    /// The required value (default: true).
    /// </summary>
    public bool RequiredValue { get; set; } = true;

    /// <inheritdoc/>
    public override string GetDisplayHint() =>
        RequiredValue ? $"[{FlagKey}]" : $"[NOT {FlagKey}]";
}
```

### 5.6 ItemCondition

**File:** `RuneAndRust.Core/Conditions/ItemCondition.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Condition that checks item possession.
/// Example: [Has: Iron Key] for key-gated dialogue.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class ItemCondition : DialogueCondition
{
    /// <inheritdoc/>
    public override ConditionType Type => ConditionType.Item;

    /// <summary>
    /// The item ID or name to check for.
    /// </summary>
    public string ItemId { get; set; } = string.Empty;

    /// <summary>
    /// Minimum quantity required (default: 1).
    /// </summary>
    public int MinQuantity { get; set; } = 1;

    /// <inheritdoc/>
    public override string GetDisplayHint() =>
        MinQuantity > 1 ? $"[Has: {ItemId} x{MinQuantity}]" : $"[Has: {ItemId}]";
}
```

### 5.7 SpecializationCondition

**File:** `RuneAndRust.Core/Conditions/SpecializationCondition.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Condition that checks specialization access.
/// Example: [Is: Berserkr] for class-specific dialogue.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class SpecializationCondition : DialogueCondition
{
    /// <inheritdoc/>
    public override ConditionType Type => ConditionType.Specialization;

    /// <summary>
    /// The specialization ID to check for.
    /// </summary>
    public Guid SpecializationId { get; set; }

    /// <summary>
    /// Display name for the hint (cached from spec).
    /// </summary>
    public string SpecializationName { get; set; } = string.Empty;

    /// <inheritdoc/>
    public override string GetDisplayHint() => $"[Is: {SpecializationName}]";
}
```

### 5.8 NodeCondition

**File:** `RuneAndRust.Core/Conditions/NodeCondition.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Condition that checks if a specialization node is unlocked.
/// Example: [Has: Rage ability] for ability-gated dialogue.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class NodeCondition : DialogueCondition
{
    /// <inheritdoc/>
    public override ConditionType Type => ConditionType.Node;

    /// <summary>
    /// The specialization node ID to check for.
    /// </summary>
    public Guid NodeId { get; set; }

    /// <summary>
    /// Display name for the hint (cached from node/ability).
    /// </summary>
    public string NodeName { get; set; } = string.Empty;

    /// <inheritdoc/>
    public override string GetDisplayHint() => $"[Has: {NodeName}]";
}
```

### 5.9 SkillCheckCondition

**File:** `RuneAndRust.Core/Conditions/SkillCheckCondition.cs`

```csharp
using RuneAndRust.Core.Enums;
using CharacterAttribute = RuneAndRust.Core.Enums.Attribute;

namespace RuneAndRust.Core.Conditions;

/// <summary>
/// Condition that requires a dice roll skill check.
/// Unlike AttributeCondition, this involves randomness.
/// Example: [Roll WITS DC 3] for uncertain outcomes.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class SkillCheckCondition : DialogueCondition
{
    /// <inheritdoc/>
    public override ConditionType Type => ConditionType.SkillCheck;

    /// <summary>
    /// The attribute to use for the dice pool.
    /// </summary>
    public CharacterAttribute Attribute { get; set; }

    /// <summary>
    /// The difficulty class (required net successes).
    /// </summary>
    public int DifficultyClass { get; set; } = 1;

    /// <summary>
    /// Optional description of what the check represents.
    /// </summary>
    public string? CheckDescription { get; set; }

    /// <inheritdoc/>
    public override string GetDisplayHint() =>
        $"[{Attribute.ToString().ToUpperInvariant()} DC {DifficultyClass}]";
}
```

---

## 6. Effect Type Hierarchy

### 6.1 Base DialogueEffect

**File:** `RuneAndRust.Core/Effects/DialogueEffect.cs`

```csharp
using System.Text.Json.Serialization;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Effects;

/// <summary>
/// Base class for all dialogue effect types.
/// Effects are executed when a dialogue option is selected.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
[JsonPolymorphic(TypeDiscriminatorPropertyName = "$type")]
[JsonDerivedType(typeof(ModifyReputationEffect), "modifyreputation")]
[JsonDerivedType(typeof(GiveItemEffect), "giveitem")]
[JsonDerivedType(typeof(SetFlagEffect), "setflag")]
public abstract class DialogueEffect
{
    /// <summary>
    /// The type of this effect for polymorphic handling.
    /// </summary>
    public abstract EffectType Type { get; }

    /// <summary>
    /// Gets a human-readable description of this effect.
    /// </summary>
    public abstract string GetDescription();
}
```

### 6.2 ModifyReputationEffect

**File:** `RuneAndRust.Core/Effects/ModifyReputationEffect.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Effects;

/// <summary>
/// Effect that modifies faction reputation.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class ModifyReputationEffect : DialogueEffect
{
    /// <inheritdoc/>
    public override EffectType Type => EffectType.ModifyReputation;

    /// <summary>
    /// The faction to modify reputation with.
    /// </summary>
    public FactionType Faction { get; set; }

    /// <summary>
    /// The amount to add (positive) or subtract (negative).
    /// </summary>
    public int Amount { get; set; }

    /// <inheritdoc/>
    public override string GetDescription() =>
        Amount >= 0 ? $"+{Amount} with {Faction}" : $"{Amount} with {Faction}";
}
```

### 6.3 GiveItemEffect

**File:** `RuneAndRust.Core/Effects/GiveItemEffect.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Effects;

/// <summary>
/// Effect that gives an item to the character.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class GiveItemEffect : DialogueEffect
{
    /// <inheritdoc/>
    public override EffectType Type => EffectType.GiveItem;

    /// <summary>
    /// The item ID to give.
    /// </summary>
    public Guid ItemId { get; set; }

    /// <summary>
    /// Display name for logging.
    /// </summary>
    public string ItemName { get; set; } = string.Empty;

    /// <summary>
    /// Quantity to give (default: 1).
    /// </summary>
    public int Quantity { get; set; } = 1;

    /// <inheritdoc/>
    public override string GetDescription() =>
        Quantity > 1 ? $"Receive: {ItemName} x{Quantity}" : $"Receive: {ItemName}";
}
```

### 6.4 SetFlagEffect

**File:** `RuneAndRust.Core/Effects/SetFlagEffect.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Effects;

/// <summary>
/// Effect that sets a game flag.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class SetFlagEffect : DialogueEffect
{
    /// <inheritdoc/>
    public override EffectType Type => EffectType.SetFlag;

    /// <summary>
    /// The flag key to set.
    /// </summary>
    public string FlagKey { get; set; } = string.Empty;

    /// <summary>
    /// The value to set (default: true).
    /// </summary>
    public bool Value { get; set; } = true;

    /// <inheritdoc/>
    public override string GetDescription() =>
        Value ? $"Set: {FlagKey}" : $"Clear: {FlagKey}";
}
```

---

## 7. Result & DTO Definitions

### 7.1 ConditionResult

**File:** `RuneAndRust.Core/Models/ConditionResult.cs`

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of evaluating a single dialogue condition.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public record ConditionResult(
    bool Passed,
    ConditionType ConditionType,
    string DisplayHint,
    string? FailureReason = null,
    IReadOnlyList<int>? DiceRolls = null,
    int? NetSuccesses = null)
{
    /// <summary>
    /// Creates a successful condition result.
    /// </summary>
    public static ConditionResult Success(ConditionType type, string hint) =>
        new(true, type, hint);

    /// <summary>
    /// Creates a successful skill check result with roll details.
    /// </summary>
    public static ConditionResult SkillCheckSuccess(
        string hint,
        IReadOnlyList<int> rolls,
        int netSuccesses) =>
        new(true, ConditionType.SkillCheck, hint, null, rolls, netSuccesses);

    /// <summary>
    /// Creates a failed condition result.
    /// </summary>
    public static ConditionResult Fail(
        ConditionType type,
        string hint,
        string reason) =>
        new(false, type, hint, reason);

    /// <summary>
    /// Creates a failed skill check result with roll details.
    /// </summary>
    public static ConditionResult SkillCheckFail(
        string hint,
        string reason,
        IReadOnlyList<int> rolls,
        int netSuccesses) =>
        new(false, ConditionType.SkillCheck, hint, reason, rolls, netSuccesses);
}
```

### 7.2 OptionVisibilityResult

**File:** `RuneAndRust.Core/Models/OptionVisibilityResult.cs`

```csharp
namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of determining a dialogue option's visibility and availability.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public record OptionVisibilityResult(
    Guid OptionId,
    bool IsVisible,
    bool IsAvailable,
    string? LockReason,
    string? LockHint,
    IReadOnlyList<ConditionResult>? ConditionResults = null)
{
    /// <summary>
    /// Creates a visible and available result.
    /// </summary>
    public static OptionVisibilityResult Available(Guid optionId) =>
        new(optionId, true, true, null, null);

    /// <summary>
    /// Creates a visible but locked result (shows requirement).
    /// </summary>
    public static OptionVisibilityResult Locked(
        Guid optionId,
        string reason,
        string hint,
        IReadOnlyList<ConditionResult> results) =>
        new(optionId, true, false, reason, hint, results);

    /// <summary>
    /// Creates a hidden result (conditions failed, hidden mode).
    /// </summary>
    public static OptionVisibilityResult Hidden(Guid optionId) =>
        new(optionId, false, false, null, null);
}
```

---

## 8. Interface Definitions

### 8.1 IDialogueConditionEvaluator

**File:** `RuneAndRust.Core/Interfaces/IDialogueConditionEvaluator.cs`

```csharp
using RuneAndRust.Core.Conditions;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for evaluating dialogue conditions against a character.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public interface IDialogueConditionEvaluator
{
    /// <summary>
    /// Evaluates a single condition.
    /// </summary>
    /// <param name="character">The character to evaluate against.</param>
    /// <param name="condition">The condition to evaluate.</param>
    /// <returns>The evaluation result.</returns>
    Task<ConditionResult> EvaluateConditionAsync(Character character, DialogueCondition condition);

    /// <summary>
    /// Evaluates all conditions on a dialogue option.
    /// All conditions must pass for the option to be available (AND logic).
    /// </summary>
    /// <param name="character">The character to evaluate against.</param>
    /// <param name="option">The dialogue option to evaluate.</param>
    /// <returns>The visibility result for the option.</returns>
    Task<OptionVisibilityResult> EvaluateOptionAsync(Character character, DialogueOption option);

    /// <summary>
    /// Evaluates all options on a dialogue node.
    /// Returns visibility results for each option.
    /// </summary>
    /// <param name="character">The character to evaluate against.</param>
    /// <param name="node">The dialogue node containing options.</param>
    /// <returns>Visibility results for all options.</returns>
    Task<IReadOnlyList<OptionVisibilityResult>> EvaluateNodeOptionsAsync(
        Character character,
        DialogueNode node);
}
```

### 8.2 IDialogueRepository

**File:** `RuneAndRust.Core/Interfaces/IDialogueRepository.cs`

```csharp
using RuneAndRust.Core.Entities;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Repository for dialogue tree persistence.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public interface IDialogueRepository
{
    /// <summary>
    /// Gets a dialogue tree by its string identifier.
    /// </summary>
    Task<DialogueTree?> GetTreeByIdAsync(string treeId);

    /// <summary>
    /// Gets a dialogue tree by database ID.
    /// </summary>
    Task<DialogueTree?> GetTreeByGuidAsync(Guid id);

    /// <summary>
    /// Gets a specific node from a tree.
    /// </summary>
    Task<DialogueNode?> GetNodeAsync(Guid treeId, string nodeId);

    /// <summary>
    /// Gets all dialogue trees.
    /// </summary>
    Task<IEnumerable<DialogueTree>> GetAllTreesAsync();

    /// <summary>
    /// Adds a new dialogue tree.
    /// </summary>
    Task AddTreeAsync(DialogueTree tree);

    /// <summary>
    /// Persists changes.
    /// </summary>
    Task SaveChangesAsync();
}
```

---

## 9. Condition Evaluator Service

**File:** `RuneAndRust.Engine/Services/DialogueConditionEvaluator.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Conditions;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models;
using CharacterAttribute = RuneAndRust.Core.Enums.Attribute;

namespace RuneAndRust.Engine.Services;

/// <summary>
/// Service for evaluating dialogue conditions against a character.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class DialogueConditionEvaluator : IDialogueConditionEvaluator
{
    private readonly IFactionService _factionService;
    private readonly IDiceService _diceService;
    private readonly IInventoryService _inventoryService;
    private readonly GameState _gameState;
    private readonly ILogger<DialogueConditionEvaluator> _logger;

    public DialogueConditionEvaluator(
        IFactionService factionService,
        IDiceService diceService,
        IInventoryService inventoryService,
        GameState gameState,
        ILogger<DialogueConditionEvaluator> logger)
    {
        _factionService = factionService;
        _diceService = diceService;
        _inventoryService = inventoryService;
        _gameState = gameState;
        _logger = logger;
    }

    /// <inheritdoc/>
    public async Task<ConditionResult> EvaluateConditionAsync(
        Character character,
        DialogueCondition condition)
    {
        _logger.LogTrace("[Dialogue] Evaluating {ConditionType} condition for {CharName}",
            condition.Type, character.Name);

        return condition switch
        {
            AttributeCondition attr => EvaluateAttributeCondition(character, attr),
            LevelCondition level => EvaluateLevelCondition(character, level),
            ReputationCondition rep => await EvaluateReputationConditionAsync(character, rep),
            FlagCondition flag => EvaluateFlagCondition(flag),
            ItemCondition item => await EvaluateItemConditionAsync(character, item),
            SpecializationCondition spec => EvaluateSpecializationCondition(character, spec),
            NodeCondition node => EvaluateNodeCondition(character, node),
            SkillCheckCondition skill => EvaluateSkillCheckCondition(character, skill),
            _ => throw new ArgumentException($"Unknown condition type: {condition.GetType()}")
        };
    }

    /// <inheritdoc/>
    public async Task<OptionVisibilityResult> EvaluateOptionAsync(
        Character character,
        DialogueOption option)
    {
        if (!option.HasConditions)
        {
            return OptionVisibilityResult.Available(option.Id);
        }

        var results = new List<ConditionResult>();
        ConditionResult? firstFailure = null;

        foreach (var condition in option.Conditions)
        {
            var result = await EvaluateConditionAsync(character, condition);
            results.Add(result);

            if (!result.Passed && firstFailure == null)
            {
                firstFailure = result;
            }
        }

        // All passed
        if (firstFailure == null)
        {
            _logger.LogDebug("[Dialogue] Option '{OptionText}' is available",
                TruncateText(option.Text, 30));
            return OptionVisibilityResult.Available(option.Id);
        }

        // At least one failed - check visibility mode
        var hiddenCondition = option.Conditions
            .FirstOrDefault(c => c.HideWhenFailed);

        if (option.VisibilityMode == OptionVisibility.Hidden || hiddenCondition != null)
        {
            _logger.LogDebug("[Dialogue] Option '{OptionText}' is hidden (condition failed)",
                TruncateText(option.Text, 30));
            return OptionVisibilityResult.Hidden(option.Id);
        }

        _logger.LogDebug("[Dialogue] Option '{OptionText}' is locked: {Reason}",
            TruncateText(option.Text, 30), firstFailure.FailureReason);

        return OptionVisibilityResult.Locked(
            option.Id,
            firstFailure.FailureReason ?? "Requirements not met",
            firstFailure.DisplayHint,
            results);
    }

    /// <inheritdoc/>
    public async Task<IReadOnlyList<OptionVisibilityResult>> EvaluateNodeOptionsAsync(
        Character character,
        DialogueNode node)
    {
        _logger.LogDebug("[Dialogue] Evaluating {Count} options for node '{NodeId}'",
            node.Options.Count, node.NodeId);

        var results = new List<OptionVisibilityResult>();

        foreach (var option in node.Options.OrderBy(o => o.DisplayOrder))
        {
            var result = await EvaluateOptionAsync(character, option);
            results.Add(result);
        }

        return results;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Private Evaluation Methods
    // ═══════════════════════════════════════════════════════════════════════

    private ConditionResult EvaluateAttributeCondition(
        Character character,
        AttributeCondition condition)
    {
        var value = character.GetAttribute(condition.Attribute);
        var passed = EvaluateComparison(value, condition.Comparison, condition.Threshold);
        var hint = condition.GetDisplayHint();

        if (passed)
        {
            _logger.LogTrace("[Dialogue] Attribute check passed: {Attr} {Value} vs {Threshold}",
                condition.Attribute, value, condition.Threshold);
            return ConditionResult.Success(ConditionType.Attribute, hint);
        }

        var reason = $"Requires {condition.Attribute} {GetComparisonSymbol(condition.Comparison)} {condition.Threshold} (have {value})";
        return ConditionResult.Fail(ConditionType.Attribute, hint, reason);
    }

    private ConditionResult EvaluateLevelCondition(
        Character character,
        LevelCondition condition)
    {
        var passed = character.Level >= condition.MinLevel;
        var hint = condition.GetDisplayHint();

        if (passed)
        {
            return ConditionResult.Success(ConditionType.Level, hint);
        }

        return ConditionResult.Fail(
            ConditionType.Level,
            hint,
            $"Requires Level {condition.MinLevel} (current: {character.Level})");
    }

    private async Task<ConditionResult> EvaluateReputationConditionAsync(
        Character character,
        ReputationCondition condition)
    {
        var passed = await _factionService.MeetsDispositionRequirementAsync(
            character,
            condition.Faction,
            condition.MinDisposition);

        var hint = condition.GetDisplayHint();

        if (passed)
        {
            return ConditionResult.Success(ConditionType.Reputation, hint);
        }

        var standing = await _factionService.GetFactionStandingAsync(character, condition.Faction);
        return ConditionResult.Fail(
            ConditionType.Reputation,
            hint,
            $"Requires {condition.MinDisposition} with {condition.Faction} (current: {standing.Disposition})");
    }

    private ConditionResult EvaluateFlagCondition(FlagCondition condition)
    {
        var flagValue = _gameState.GetFlag(condition.FlagKey);
        var passed = flagValue == condition.RequiredValue;
        var hint = condition.GetDisplayHint();

        if (passed)
        {
            return ConditionResult.Success(ConditionType.Flag, hint);
        }

        return ConditionResult.Fail(
            ConditionType.Flag,
            hint,
            condition.RequiredValue
                ? $"Requires: {condition.FlagKey}"
                : $"Blocked by: {condition.FlagKey}");
    }

    private async Task<ConditionResult> EvaluateItemConditionAsync(
        Character character,
        ItemCondition condition)
    {
        var hasItem = await _inventoryService.HasItemAsync(
            character.Id,
            condition.ItemId,
            condition.MinQuantity);

        var hint = condition.GetDisplayHint();

        if (hasItem)
        {
            return ConditionResult.Success(ConditionType.Item, hint);
        }

        return ConditionResult.Fail(
            ConditionType.Item,
            hint,
            $"Requires: {condition.ItemId}" + (condition.MinQuantity > 1 ? $" x{condition.MinQuantity}" : ""));
    }

    private ConditionResult EvaluateSpecializationCondition(
        Character character,
        SpecializationCondition condition)
    {
        var passed = character.HasSpecialization(condition.SpecializationId);
        var hint = condition.GetDisplayHint();

        if (passed)
        {
            return ConditionResult.Success(ConditionType.Specialization, hint);
        }

        return ConditionResult.Fail(
            ConditionType.Specialization,
            hint,
            $"Requires specialization: {condition.SpecializationName}");
    }

    private ConditionResult EvaluateNodeCondition(
        Character character,
        NodeCondition condition)
    {
        var passed = character.HasNode(condition.NodeId);
        var hint = condition.GetDisplayHint();

        if (passed)
        {
            return ConditionResult.Success(ConditionType.Node, hint);
        }

        return ConditionResult.Fail(
            ConditionType.Node,
            hint,
            $"Requires ability: {condition.NodeName}");
    }

    private ConditionResult EvaluateSkillCheckCondition(
        Character character,
        SkillCheckCondition condition)
    {
        var poolSize = character.GetAttribute(condition.Attribute);
        var context = condition.CheckDescription ?? $"Dialogue {condition.Attribute} check";
        var rollResult = _diceService.Roll(poolSize, context);
        var netSuccesses = rollResult.Successes - rollResult.Botches;
        var passed = netSuccesses >= condition.DifficultyClass;
        var hint = condition.GetDisplayHint();

        _logger.LogDebug(
            "[Dialogue] Skill check: {Attr} DC {DC}, rolled {Net} net successes ({Successes}s - {Botches}b)",
            condition.Attribute, condition.DifficultyClass,
            netSuccesses, rollResult.Successes, rollResult.Botches);

        if (passed)
        {
            return ConditionResult.SkillCheckSuccess(hint, rollResult.Rolls, netSuccesses);
        }

        return ConditionResult.SkillCheckFail(
            hint,
            $"Skill check failed ({netSuccesses} vs DC {condition.DifficultyClass})",
            rollResult.Rolls,
            netSuccesses);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Private Helpers
    // ═══════════════════════════════════════════════════════════════════════

    private static bool EvaluateComparison(int value, ComparisonType comparison, int threshold)
    {
        return comparison switch
        {
            ComparisonType.GreaterThanOrEqual => value >= threshold,
            ComparisonType.Equal => value == threshold,
            ComparisonType.GreaterThan => value > threshold,
            ComparisonType.LessThan => value < threshold,
            ComparisonType.LessThanOrEqual => value <= threshold,
            ComparisonType.NotEqual => value != threshold,
            _ => false
        };
    }

    private static string GetComparisonSymbol(ComparisonType comparison) => comparison switch
    {
        ComparisonType.GreaterThanOrEqual => ">=",
        ComparisonType.Equal => "==",
        ComparisonType.GreaterThan => ">",
        ComparisonType.LessThan => "<",
        ComparisonType.LessThanOrEqual => "<=",
        ComparisonType.NotEqual => "!=",
        _ => "?"
    };

    private static string TruncateText(string text, int maxLength)
    {
        if (text.Length <= maxLength) return text;
        return text[..(maxLength - 3)] + "...";
    }
}
```

---

## 10. Repository Implementation

**File:** `RuneAndRust.Persistence/Repositories/DialogueRepository.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Persistence.Data;

namespace RuneAndRust.Persistence.Repositories;

/// <summary>
/// Repository implementation for DialogueTree persistence.
/// </summary>
/// <remarks>See: v0.4.2b (The Lexicon) for Dialogue System implementation.</remarks>
public class DialogueRepository : IDialogueRepository
{
    private readonly RuneAndRustDbContext _context;
    private readonly ILogger<DialogueRepository> _logger;

    public DialogueRepository(
        RuneAndRustDbContext context,
        ILogger<DialogueRepository> logger)
    {
        _context = context;
        _logger = logger;
    }

    /// <inheritdoc/>
    public async Task<DialogueTree?> GetTreeByIdAsync(string treeId)
    {
        _logger.LogDebug("[DialogueRepo] GetTreeByIdAsync: {TreeId}", treeId);

        return await _context.DialogueTrees
            .Include(t => t.Nodes)
                .ThenInclude(n => n.Options)
            .FirstOrDefaultAsync(t => t.TreeId == treeId);
    }

    /// <inheritdoc/>
    public async Task<DialogueTree?> GetTreeByGuidAsync(Guid id)
    {
        _logger.LogDebug("[DialogueRepo] GetTreeByGuidAsync: {Id}", id);

        return await _context.DialogueTrees
            .Include(t => t.Nodes)
                .ThenInclude(n => n.Options)
            .FirstOrDefaultAsync(t => t.Id == id);
    }

    /// <inheritdoc/>
    public async Task<DialogueNode?> GetNodeAsync(Guid treeId, string nodeId)
    {
        _logger.LogDebug("[DialogueRepo] GetNodeAsync: TreeId={TreeId}, NodeId={NodeId}",
            treeId, nodeId);

        return await _context.DialogueNodes
            .Include(n => n.Options)
            .FirstOrDefaultAsync(n => n.TreeId == treeId && n.NodeId == nodeId);
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<DialogueTree>> GetAllTreesAsync()
    {
        _logger.LogDebug("[DialogueRepo] GetAllTreesAsync");

        return await _context.DialogueTrees
            .Include(t => t.Nodes)
            .OrderBy(t => t.NpcName)
            .ToListAsync();
    }

    /// <inheritdoc/>
    public async Task AddTreeAsync(DialogueTree tree)
    {
        _logger.LogDebug("[DialogueRepo] AddTreeAsync: {TreeId}", tree.TreeId);
        await _context.DialogueTrees.AddAsync(tree);
    }

    /// <inheritdoc/>
    public async Task SaveChangesAsync()
    {
        var count = await _context.SaveChangesAsync();
        _logger.LogDebug("[DialogueRepo] SaveChangesAsync: {Count} changes", count);
    }
}
```

---

## 11. Database Migration

**File:** `Migrations/V0.4.2b__Dialogue_System.sql`

```sql
-- ═══════════════════════════════════════════════════════════════════════════
-- v0.4.2b: Dialogue System Migration
-- Creates DialogueTree, DialogueNode, and DialogueOption tables
-- ═══════════════════════════════════════════════════════════════════════════

-- Dialogue Trees (root container)
CREATE TABLE IF NOT EXISTS dialogue_trees (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tree_id TEXT NOT NULL UNIQUE,
    npc_name TEXT NOT NULL,
    npc_title TEXT,
    root_node_id TEXT NOT NULL DEFAULT 'root',
    associated_faction INTEGER,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE dialogue_trees IS 'Root containers for NPC dialogue content (v0.4.2b)';
COMMENT ON COLUMN dialogue_trees.tree_id IS 'Unique string identifier (e.g., npc_old_scavenger)';
COMMENT ON COLUMN dialogue_trees.associated_faction IS 'Optional FactionType for reputation-based gating';

CREATE INDEX IF NOT EXISTS idx_dialogue_trees_tree_id ON dialogue_trees(tree_id);

-- Dialogue Nodes (conversation screens)
CREATE TABLE IF NOT EXISTS dialogue_nodes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tree_id UUID NOT NULL REFERENCES dialogue_trees(id) ON DELETE CASCADE,
    node_id TEXT NOT NULL,
    speaker_name TEXT NOT NULL,
    text TEXT NOT NULL,
    is_terminal BOOLEAN NOT NULL DEFAULT FALSE,
    UNIQUE(tree_id, node_id)
);

COMMENT ON TABLE dialogue_nodes IS 'Individual conversation nodes within a dialogue tree (v0.4.2b)';
COMMENT ON COLUMN dialogue_nodes.node_id IS 'String identifier within tree (e.g., greeting, quest_offer)';
COMMENT ON COLUMN dialogue_nodes.is_terminal IS 'Whether this node ends the conversation';

CREATE INDEX IF NOT EXISTS idx_dialogue_nodes_tree ON dialogue_nodes(tree_id);

-- Dialogue Options (player choices)
CREATE TABLE IF NOT EXISTS dialogue_options (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    node_id UUID NOT NULL REFERENCES dialogue_nodes(id) ON DELETE CASCADE,
    text TEXT NOT NULL,
    next_node_id TEXT,
    display_order INTEGER NOT NULL DEFAULT 0,
    visibility_mode INTEGER NOT NULL DEFAULT 0,
    conditions JSONB NOT NULL DEFAULT '[]',
    effects JSONB NOT NULL DEFAULT '[]'
);

COMMENT ON TABLE dialogue_options IS 'Player response choices within dialogue nodes (v0.4.2b)';
COMMENT ON COLUMN dialogue_options.next_node_id IS 'NodeId to navigate to (null = terminal)';
COMMENT ON COLUMN dialogue_options.visibility_mode IS '0=ShowLocked, 1=Hidden';
COMMENT ON COLUMN dialogue_options.conditions IS 'JSONB array of DialogueCondition objects';
COMMENT ON COLUMN dialogue_options.effects IS 'JSONB array of DialogueEffect objects';

CREATE INDEX IF NOT EXISTS idx_dialogue_options_node ON dialogue_options(node_id);
CREATE INDEX IF NOT EXISTS idx_dialogue_options_conditions ON dialogue_options USING GIN (conditions);
```

---

## 12. DbContext Configuration

Add to `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs`:

```csharp
// DbSets
public DbSet<DialogueTree> DialogueTrees { get; set; } = null!;
public DbSet<DialogueNode> DialogueNodes { get; set; } = null!;
public DbSet<DialogueOption> DialogueOptions { get; set; } = null!;

// In OnModelCreating:
ConfigureDialogueEntities(modelBuilder);

// Private method:
private void ConfigureDialogueEntities(ModelBuilder modelBuilder)
{
    // DialogueTree
    modelBuilder.Entity<DialogueTree>(entity =>
    {
        entity.HasKey(t => t.Id);

        entity.Property(t => t.TreeId)
            .HasMaxLength(100)
            .IsRequired();

        entity.HasIndex(t => t.TreeId)
            .IsUnique();

        entity.Property(t => t.NpcName)
            .HasMaxLength(100)
            .IsRequired();

        entity.Property(t => t.NpcTitle)
            .HasMaxLength(100);

        entity.Property(t => t.AssociatedFaction)
            .HasConversion<int?>();

        entity.HasMany(t => t.Nodes)
            .WithOne(n => n.Tree)
            .HasForeignKey(n => n.TreeId)
            .OnDelete(DeleteBehavior.Cascade);
    });

    // DialogueNode
    modelBuilder.Entity<DialogueNode>(entity =>
    {
        entity.HasKey(n => n.Id);

        entity.Property(n => n.NodeId)
            .HasMaxLength(100)
            .IsRequired();

        entity.HasIndex(n => new { n.TreeId, n.NodeId })
            .IsUnique();

        entity.Property(n => n.SpeakerName)
            .HasMaxLength(100)
            .IsRequired();

        entity.Property(n => n.Text)
            .IsRequired();

        entity.HasMany(n => n.Options)
            .WithOne(o => o.Node)
            .HasForeignKey(o => o.NodeId)
            .OnDelete(DeleteBehavior.Cascade);
    });

    // DialogueOption
    modelBuilder.Entity<DialogueOption>(entity =>
    {
        entity.HasKey(o => o.Id);

        entity.Property(o => o.Text)
            .IsRequired();

        entity.Property(o => o.NextNodeId)
            .HasMaxLength(100);

        entity.Property(o => o.VisibilityMode)
            .HasConversion<int>();

        // Conditions stored as JSONB
        entity.Property(o => o.Conditions)
            .HasColumnType("jsonb")
            .HasConversion(
                v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
                v => JsonSerializer.Deserialize<List<DialogueCondition>>(v, (JsonSerializerOptions?)null)
                    ?? new List<DialogueCondition>()
            )
            .IsRequired();

        // Effects stored as JSONB
        entity.Property(o => o.Effects)
            .HasColumnType("jsonb")
            .HasConversion(
                v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
                v => JsonSerializer.Deserialize<List<DialogueEffect>>(v, (JsonSerializerOptions?)null)
                    ?? new List<DialogueEffect>()
            )
            .IsRequired();
    });
}
```

---

## 13. DI Registration

Add to `RuneAndRust.Terminal/Program.cs`:

```csharp
// ═══════════════════════════════════════════════════════════════════════════
// Dialogue System (v0.4.2b)
// ═══════════════════════════════════════════════════════════════════════════
services.AddScoped<IDialogueRepository, DialogueRepository>();
services.AddScoped<IDialogueConditionEvaluator, DialogueConditionEvaluator>();
```

---

## 14. Logging Matrix

### DialogueConditionEvaluator Logging

| Event | Level | Template |
|-------|-------|----------|
| Condition evaluation entry | Trace | `[Dialogue] Evaluating {ConditionType} condition for {CharName}` |
| Attribute check passed | Trace | `[Dialogue] Attribute check passed: {Attr} {Value} vs {Threshold}` |
| Skill check result | Debug | `[Dialogue] Skill check: {Attr} DC {DC}, rolled {Net} net successes ({Successes}s - {Botches}b)` |
| Option available | Debug | `[Dialogue] Option '{OptionText}' is available` |
| Option hidden | Debug | `[Dialogue] Option '{OptionText}' is hidden (condition failed)` |
| Option locked | Debug | `[Dialogue] Option '{OptionText}' is locked: {Reason}` |
| Node options evaluated | Debug | `[Dialogue] Evaluating {Count} options for node '{NodeId}'` |

### DialogueRepository Logging

| Event | Level | Template |
|-------|-------|----------|
| GetTreeByIdAsync | Debug | `[DialogueRepo] GetTreeByIdAsync: {TreeId}` |
| GetTreeByGuidAsync | Debug | `[DialogueRepo] GetTreeByGuidAsync: {Id}` |
| GetNodeAsync | Debug | `[DialogueRepo] GetNodeAsync: TreeId={TreeId}, NodeId={NodeId}` |
| GetAllTreesAsync | Debug | `[DialogueRepo] GetAllTreesAsync` |
| AddTreeAsync | Debug | `[DialogueRepo] AddTreeAsync: {TreeId}` |
| SaveChangesAsync | Debug | `[DialogueRepo] SaveChangesAsync: {Count} changes` |

---

## 15. Test Coverage Plan

### Test Class Structure

**File:** `RuneAndRust.Tests/Engine/DialogueConditionEvaluatorTests.cs`

**Dependencies (Mocks):**
- `Mock<IFactionService>`
- `Mock<IDiceService>`
- `Mock<IInventoryService>`
- `GameState` (real instance)
- `Mock<ILogger<DialogueConditionEvaluator>>`

### Test Inventory (48 tests)

#### AttributeCondition Tests (8 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateAttributeCondition_Passes_WhenValueMeetsThreshold` | >= passes |
| `EvaluateAttributeCondition_Fails_WhenValueBelowThreshold` | >= fails |
| `EvaluateAttributeCondition_Equal_PassesOnExactMatch` | == passes |
| `EvaluateAttributeCondition_Equal_FailsOnMismatch` | == fails |
| `EvaluateAttributeCondition_GreaterThan_PassesWhenAbove` | > passes |
| `EvaluateAttributeCondition_GreaterThan_FailsOnEqual` | > fails on equal |
| `EvaluateAttributeCondition_ReturnsCorrectDisplayHint` | Hint format |
| `EvaluateAttributeCondition_ReturnsCorrectFailureReason` | Reason format |

#### LevelCondition Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateLevelCondition_Passes_WhenLevelMet` | Level met |
| `EvaluateLevelCondition_Passes_WhenLevelExceeds` | Level exceeds |
| `EvaluateLevelCondition_Fails_WhenLevelTooLow` | Level insufficient |
| `EvaluateLevelCondition_ReturnsCorrectDisplayHint` | Hint format |

#### ReputationCondition Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateReputationCondition_Passes_WhenDispositionMet` | Disposition met |
| `EvaluateReputationCondition_Passes_WhenDispositionExceeds` | Disposition exceeds |
| `EvaluateReputationCondition_Fails_WhenDispositionTooLow` | Disposition insufficient |
| `EvaluateReputationCondition_CallsFactionService` | Service called |
| `EvaluateReputationCondition_IncludesCurrentDispositionInReason` | Reason has current |
| `EvaluateReputationCondition_ReturnsCorrectDisplayHint` | Hint format |

#### FlagCondition Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateFlagCondition_Passes_WhenFlagTrue` | Flag true |
| `EvaluateFlagCondition_Fails_WhenFlagFalse` | Flag false |
| `EvaluateFlagCondition_Passes_WhenRequiredValueFalseAndFlagFalse` | Inverse check |
| `EvaluateFlagCondition_ReturnsCorrectDisplayHint` | Hint format |

#### ItemCondition Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateItemCondition_Passes_WhenItemOwned` | Has item |
| `EvaluateItemCondition_Fails_WhenItemMissing` | Missing item |
| `EvaluateItemCondition_Passes_WhenQuantityMet` | Quantity met |
| `EvaluateItemCondition_Fails_WhenQuantityInsufficient` | Quantity insufficient |

#### SpecializationCondition Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateSpecializationCondition_Passes_WhenUnlocked` | Spec unlocked |
| `EvaluateSpecializationCondition_Fails_WhenNotUnlocked` | Spec locked |
| `EvaluateSpecializationCondition_ReturnsCorrectDisplayHint` | Hint format |

#### NodeCondition Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateNodeCondition_Passes_WhenNodeUnlocked` | Node unlocked |
| `EvaluateNodeCondition_Fails_WhenNodeLocked` | Node locked |
| `EvaluateNodeCondition_ReturnsCorrectDisplayHint` | Hint format |

#### SkillCheckCondition Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateSkillCheckCondition_Passes_WhenDCMet` | DC met |
| `EvaluateSkillCheckCondition_Passes_WhenDCExceeded` | DC exceeded |
| `EvaluateSkillCheckCondition_Fails_WhenDCNotMet` | DC not met |
| `EvaluateSkillCheckCondition_IncludesRollsInResult` | Rolls in result |
| `EvaluateSkillCheckCondition_AccountsForBotches` | Botches subtract |
| `EvaluateSkillCheckCondition_LogsRollDetails` | Logging |

#### EvaluateOptionAsync Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateOptionAsync_ReturnsAvailable_WhenNoConditions` | No conditions |
| `EvaluateOptionAsync_ReturnsAvailable_WhenAllConditionsPass` | All pass |
| `EvaluateOptionAsync_ReturnsLocked_WhenAnyConditionFails` | One fails |
| `EvaluateOptionAsync_ReturnsHidden_WhenHiddenMode` | Hidden mode |
| `EvaluateOptionAsync_ReturnsHidden_WhenConditionHasHideFlag` | Hide flag |
| `EvaluateOptionAsync_ReturnsFirstFailureReason` | First failure |

#### EvaluateNodeOptionsAsync Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `EvaluateNodeOptionsAsync_EvaluatesAllOptions` | All evaluated |
| `EvaluateNodeOptionsAsync_ReturnsResultsInDisplayOrder` | Order preserved |
| `EvaluateNodeOptionsAsync_LogsOptionCount` | Logging |
| `EvaluateNodeOptionsAsync_HandlesEmptyOptions` | Empty list |

---

## 16. Code Examples

### 16.1 Test Example

```csharp
public class DialogueConditionEvaluatorTests
{
    private readonly Mock<IFactionService> _mockFactionService;
    private readonly Mock<IDiceService> _mockDiceService;
    private readonly Mock<IInventoryService> _mockInventoryService;
    private readonly GameState _gameState;
    private readonly Mock<ILogger<DialogueConditionEvaluator>> _mockLogger;
    private readonly DialogueConditionEvaluator _sut;

    public DialogueConditionEvaluatorTests()
    {
        _mockFactionService = new Mock<IFactionService>();
        _mockDiceService = new Mock<IDiceService>();
        _mockInventoryService = new Mock<IInventoryService>();
        _gameState = new GameState();
        _mockLogger = new Mock<ILogger<DialogueConditionEvaluator>>();

        _sut = new DialogueConditionEvaluator(
            _mockFactionService.Object,
            _mockDiceService.Object,
            _mockInventoryService.Object,
            _gameState,
            _mockLogger.Object);
    }

    [Fact]
    public async Task EvaluateAttributeCondition_Passes_WhenValueMeetsThreshold()
    {
        // Arrange
        var character = CreateTestCharacter(wits: 6);
        var condition = new AttributeCondition
        {
            Attribute = CharacterAttribute.Wits,
            Comparison = ComparisonType.GreaterThanOrEqual,
            Threshold = 6
        };

        // Act
        var result = await _sut.EvaluateConditionAsync(character, condition);

        // Assert
        result.Passed.Should().BeTrue();
        result.ConditionType.Should().Be(ConditionType.Attribute);
        result.DisplayHint.Should().Be("[WITS 6]");
    }

    [Fact]
    public async Task EvaluateReputationCondition_Fails_WhenDispositionTooLow()
    {
        // Arrange
        var character = CreateTestCharacter();
        var condition = new ReputationCondition
        {
            Faction = FactionType.IronBanes,
            MinDisposition = Disposition.Friendly
        };

        _mockFactionService
            .Setup(f => f.MeetsDispositionRequirementAsync(
                character, FactionType.IronBanes, Disposition.Friendly))
            .ReturnsAsync(false);

        _mockFactionService
            .Setup(f => f.GetFactionStandingAsync(character, FactionType.IronBanes))
            .ReturnsAsync(new FactionStandingInfo(
                FactionType.IronBanes, "Iron-Banes", 0, Disposition.Neutral));

        // Act
        var result = await _sut.EvaluateConditionAsync(character, condition);

        // Assert
        result.Passed.Should().BeFalse();
        result.FailureReason.Should().Contain("Neutral");
        result.DisplayHint.Should().Be("[IronBanes: Friendly]");
    }

    [Fact]
    public async Task EvaluateSkillCheckCondition_IncludesRollsInResult()
    {
        // Arrange
        var character = CreateTestCharacter(wits: 5);
        var condition = new SkillCheckCondition
        {
            Attribute = CharacterAttribute.Wits,
            DifficultyClass = 2
        };

        _mockDiceService
            .Setup(d => d.Roll(5, It.IsAny<string>()))
            .Returns(new DiceResult(3, 0, new[] { 8, 9, 10, 4, 3 }));

        // Act
        var result = await _sut.EvaluateConditionAsync(character, condition);

        // Assert
        result.Passed.Should().BeTrue();
        result.DiceRolls.Should().HaveCount(5);
        result.NetSuccesses.Should().Be(3);
    }

    private static Character CreateTestCharacter(int wits = 5) => new()
    {
        Id = Guid.NewGuid(),
        Name = "TestCharacter",
        Wits = wits,
        Level = 1
    };
}
```

---

## 17. Changelog Template

```markdown
# Changelog: v0.4.2b - The Lexicon (Dialogue Data Models & Conditions)

**Release Date:** [DATE]
**Total Tests:** [N] (48 new tests added)

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.2b](#directory-structure-after-v042b)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

Version 0.4.2b establishes the **Dialogue Data Model** and **Condition Evaluation System**...

[Continue following CHANGELOG_GENERATION_RULES.md format]
```

---

## 18. Critical Files

### Files to Create (Priority Order)

| Priority | File | Purpose |
|----------|------|---------|
| 1 | `RuneAndRust.Core/Enums/ConditionType.cs` | Condition discriminator |
| 2 | `RuneAndRust.Core/Enums/ComparisonType.cs` | Comparison operators |
| 3 | `RuneAndRust.Core/Enums/OptionVisibility.cs` | Display modes |
| 4 | `RuneAndRust.Core/Enums/EffectType.cs` | Effect discriminator |
| 5 | `RuneAndRust.Core/Conditions/DialogueCondition.cs` | Base condition |
| 6 | `RuneAndRust.Core/Conditions/AttributeCondition.cs` | Attribute check |
| 7 | `RuneAndRust.Core/Conditions/LevelCondition.cs` | Level check |
| 8 | `RuneAndRust.Core/Conditions/ReputationCondition.cs` | Reputation check |
| 9 | `RuneAndRust.Core/Conditions/FlagCondition.cs` | Flag check |
| 10 | `RuneAndRust.Core/Conditions/ItemCondition.cs` | Item check |
| 11 | `RuneAndRust.Core/Conditions/SpecializationCondition.cs` | Spec check |
| 12 | `RuneAndRust.Core/Conditions/NodeCondition.cs` | Node check |
| 13 | `RuneAndRust.Core/Conditions/SkillCheckCondition.cs` | Skill check |
| 14 | `RuneAndRust.Core/Effects/DialogueEffect.cs` | Base effect |
| 15 | `RuneAndRust.Core/Effects/ModifyReputationEffect.cs` | Rep effect |
| 16 | `RuneAndRust.Core/Effects/GiveItemEffect.cs` | Item effect |
| 17 | `RuneAndRust.Core/Effects/SetFlagEffect.cs` | Flag effect |
| 18 | `RuneAndRust.Core/Entities/DialogueTree.cs` | Tree entity |
| 19 | `RuneAndRust.Core/Entities/DialogueNode.cs` | Node entity |
| 20 | `RuneAndRust.Core/Entities/DialogueOption.cs` | Option entity |
| 21 | `RuneAndRust.Core/Models/ConditionResult.cs` | Result record |
| 22 | `RuneAndRust.Core/Models/OptionVisibilityResult.cs` | Visibility result |
| 23 | `RuneAndRust.Core/Interfaces/IDialogueConditionEvaluator.cs` | Evaluator interface |
| 24 | `RuneAndRust.Core/Interfaces/IDialogueRepository.cs` | Repository interface |
| 25 | `RuneAndRust.Engine/Services/DialogueConditionEvaluator.cs` | Evaluator impl |
| 26 | `RuneAndRust.Persistence/Repositories/DialogueRepository.cs` | Repository impl |
| 27 | `Migrations/V0.4.2b__Dialogue_System.sql` | Migration |
| 28 | `RuneAndRust.Tests/Engine/DialogueConditionEvaluatorTests.cs` | Tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Add DbSets, JSONB config |
| `RuneAndRust.Terminal/Program.cs` | Register services |

---

## 19. Implementation Order

1. **Create Enums** (ConditionType, ComparisonType, OptionVisibility, EffectType)
2. **Create Base Conditions** (DialogueCondition abstract class)
3. **Create Condition Types** (8 derived condition classes)
4. **Create Base Effects** (DialogueEffect abstract class)
5. **Create Effect Types** (3 derived effect classes)
6. **Create Entities** (DialogueTree, DialogueNode, DialogueOption)
7. **Create Results** (ConditionResult, OptionVisibilityResult)
8. **Create Interfaces** (IDialogueConditionEvaluator, IDialogueRepository)
9. **Create Repository** (DialogueRepository)
10. **Update DbContext** (DbSets, JSONB configuration)
11. **Create Migration** (SQL script)
12. **Create Evaluator Service** (DialogueConditionEvaluator)
13. **Register in DI** (Program.cs)
14. **Write Unit Tests** (48 tests)
15. **Run Build and Tests**
16. **Generate Changelog**

---

## 20. Design Decisions

### Why Polymorphic Conditions with JsonDerivedType?

**Problem:** Conditions need different data (attribute checks need attribute + threshold; reputation checks need faction + disposition).

**Decision:** Use C# 11+ `[JsonPolymorphic]` attributes for native System.Text.Json polymorphism.

**Rationale:**
- Type-safe evaluation in C# with pattern matching
- Native JSON serialization without custom converters
- `$type` discriminator in JSONB is clear and queryable
- Extensible for future condition types
- Works with EF Core JSONB columns

### Why Separate ConditionResult Record?

**Problem:** Need to communicate pass/fail plus additional context (hints, roll details).

**Decision:** `ConditionResult` record with optional fields for skill check rolls.

**Rationale:**
- Rich result type for UI display
- Skill checks need roll details for player feedback
- Pattern matches existing `ExaminationResult`, `ReputationChangeResult` patterns
- Factory methods enforce valid states

### Why AND Logic for Multiple Conditions?

**Problem:** Dialogue options can have multiple conditions. How should they combine?

**Decision:** All conditions must pass (AND logic).

**Rationale:**
- Simplest mental model for designers
- OR logic can be achieved with separate options
- Matches common RPG dialogue patterns
- Complex logic can be built with Flag conditions

### Why Two Visibility Modes (ShowLocked vs Hidden)?

**Problem:** Some gated dialogue should tease players; some should be secret.

**Decision:** Per-option `VisibilityMode` and per-condition `HideWhenFailed` flag.

**Rationale:**
- `[WITS 6]` hints encourage character building
- Secret faction quests shouldn't be visible until earned
- Condition-level hide flag allows mixed visibility
- Matches player expectations from other RPGs

---

## Appendix A: Condition Type Quick Reference

| Type | Parameters | Example Display |
|------|------------|-----------------|
| Attribute | Attribute, Comparison, Threshold | `[WITS 6]` |
| Level | MinLevel | `[Level 5]` |
| Reputation | Faction, MinDisposition | `[Iron-Banes: Friendly]` |
| Flag | FlagKey, RequiredValue | `[HasCompletedTutorial]` |
| Item | ItemId, MinQuantity | `[Has: Iron Key]` |
| Specialization | SpecializationId, SpecializationName | `[Is: Berserkr]` |
| Node | NodeId, NodeName | `[Has: Rage]` |
| SkillCheck | Attribute, DifficultyClass | `[WITS DC 3]` |

---

## Appendix B: JSONB Condition Example

```json
[
  {
    "$type": "attribute",
    "attribute": 2,
    "comparison": 0,
    "threshold": 6,
    "hideWhenFailed": false
  },
  {
    "$type": "reputation",
    "faction": 0,
    "minDisposition": 3,
    "hideWhenFailed": false
  }
]
```
