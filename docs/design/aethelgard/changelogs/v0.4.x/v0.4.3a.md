# Changelog: v0.4.3a - The Aether
**Release Date:** 2025-12-31

---

## Summary

v0.4.3a "The Aether" introduces the Flux State & Service, an environmental magic volatility tracking system that accumulates during spellcasting and dissipates naturally over combat rounds. This release implements a comprehensive **Domain Layer** model, **Engine Layer** service with event publication, and full integration with the existing combat lifecycle. The flux system tracks aetheric volatility using a threshold-based classification (Safe → Elevated → Critical → Overload), publishes FluxChangedEvent when significant changes occur, and automatically dissipates at round boundaries. The implementation includes 43 comprehensive unit tests with 100% coverage and integration into the CombatService for lifecycle management.

Key architectural patterns applied:
- **Service Pattern**: IAetherService interface with AetherService implementation
- **Event-Driven Architecture**: FluxChangedEvent publication via IEventBus
- **Singleton Lifecycle**: Shared per-encounter flux state management
- **Defensive Programming**: Negative input handling, boundary clamping, zero-delta event suppression

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/FluxThreshold.cs` | 4-value enum defining aetheric volatility thresholds (Safe, Elevated, Critical, Overload) with range documentation |
| `RuneAndRust.Core/Models/Magic/FluxState.cs` | State model tracking CurrentFlux, MaxFlux, DefaultDissipationRate with computed Threshold and boundary properties |
| `RuneAndRust.Core/Interfaces/IAetherService.cs` | Service contract with methods for AddFlux, RemoveFlux, DissipateFlux, ResetFlux, GetFluxState, GetThreshold |
| `RuneAndRust.Core/Events/FluxChangedEvent.cs` | Record type event with computed properties for Delta, CrossedThreshold, HitBoundary, IsSignificantChange analysis |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/AetherService.cs` | Singleton service implementing flux accumulation, dissipation, threshold detection, and event publication logic |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/Services/AetherServiceTests.cs` | Comprehensive test suite with 43 unit tests covering AddFlux, RemoveFlux, DissipateFlux, ResetFlux, state retrieval, threshold transitions, event publication, and edge cases |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Terminal/Program.cs` | Registered `IAetherService` → `AetherService` as Singleton in DI container (line 166) with version comment |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `IAetherService` constructor parameter, field, and assignment; integrated flux reset in `StartCombat()` and `EndCombat()`; integrated flux dissipation in `NextTurn()` at round boundaries |
| `RuneAndRust.Tests/Infrastructure/TestGameHost.cs` | Registered `IAetherService` → `AetherService` as Singleton for test environment consistency |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added `Mock<IAetherService>` field and constructor initialization to satisfy updated CombatService dependency |
| `RuneAndRust.Tests/Engine/IntentSystemTests.cs` | Added `Mock<IAetherService>` field and constructor initialization to satisfy updated CombatService dependency |
| `RuneAndRust.Tests/Engine/RowAssignmentTests.cs` | Added `Mock<IAetherService>` field and constructor initialization to satisfy updated CombatService dependency |
| `RuneAndRust.Tests/Engine/TimelineProjectionTests.cs` | Added `Mock<IAetherService>` field and constructor initialization to satisfy updated CombatService dependency |

---

## Code Implementation Details

### Enums

#### `FluxThreshold.cs`

```csharp
public enum FluxThreshold
{
    /// <summary>
    /// Flux level 0-24. Stable aetheric field with no adverse effects.
    /// </summary>
    Safe = 0,

    /// <summary>
    /// Flux level 25-49. Minor instability detected; caution advised.
    /// </summary>
    Elevated = 1,

    /// <summary>
    /// Flux level 50-74. Significant instability; magical effects may behave erratically.
    /// </summary>
    Critical = 2,

    /// <summary>
    /// Flux level 75-100. Maximum danger; the boundary between realms grows thin.
    /// </summary>
    Overload = 3
}
```

**Threshold Ranges:**
- Safe: 0-24 (stable aetheric field)
- Elevated: 25-49 (minor instability)
- Critical: 50-74 (significant instability)
- Overload: 75-100 (maximum danger, reality fraying)

---

### Models

#### `FluxState.cs`

**Properties:**

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `CurrentFlux` | `int` | 0 | Current flux level (0 to MaxFlux) |
| `MaxFlux` | `int` | 100 | Maximum flux capacity |
| `DefaultDissipationRate` | `int` | 5 | Dissipation amount per round |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `Threshold` | `FluxThreshold` | Switch expression: >= 75 → Overload, >= 50 → Critical, >= 25 → Elevated, else Safe |
| `FluxPercentage` | `double` | `(double)CurrentFlux / MaxFlux` (0.0 to 1.0), returns 0 if MaxFlux is 0 |
| `IsAtMax` | `bool` | `CurrentFlux >= MaxFlux` |
| `IsAtZero` | `bool` | `CurrentFlux <= 0` |

**Methods:**
- `Clone()` → `FluxState`: Creates immutable copy for external retrieval

---

### Events

#### `FluxChangedEvent.cs`

**Primary Constructor Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `PreviousFlux` | `int` | Flux level before change |
| `CurrentFlux` | `int` | Flux level after change |
| `MaxFlux` | `int` | Maximum flux capacity |
| `PreviousThreshold` | `FluxThreshold` | Threshold tier before change |
| `CurrentThreshold` | `FluxThreshold` | Threshold tier after change |
| `ChangeReason` | `string` | Event trigger ("AddFlux", "RemoveFlux", "Dissipation", "Reset") |

**Computed Properties:**

| Property | Type | Logic |
|----------|------|-------|
| `Delta` | `int` | `Math.Abs(CurrentFlux - PreviousFlux)` |
| `CrossedThreshold` | `bool` | `PreviousThreshold != CurrentThreshold` |
| `HitBoundary` | `bool` | `CurrentFlux == 0 || CurrentFlux == MaxFlux` |
| `IsSignificantChange` | `bool` | `Delta >= 15` |
| `IsIncrease` | `bool` | `CurrentFlux > PreviousFlux` |
| `IsDecrease` | `bool` | `CurrentFlux < PreviousFlux` |

**Event Publication Triggers:**
1. Threshold changes (e.g., Safe → Elevated)
2. Flux change ≥ 15 points in single operation
3. Flux hits boundary (0 or MaxFlux)
4. Delta > 0 (suppresses spurious events on no-op operations)

---

### Services

#### `AetherService.cs`

**Constructor Dependencies:**
- `IEventBus` (for FluxChangedEvent publication)
- `ILogger<AetherService>` (for structured logging)

**Private State:**
- `FluxState _fluxState` (initialized with default values: CurrentFlux=0, MaxFlux=100, DefaultDissipationRate=5)

**Constants:**
- `SignificantChangeThreshold = 15` (minimum delta for event publication)

**Key Method Signatures and Behaviors:**

```csharp
public int AddFlux(int amount)
```
- Clamps amount to `[0, MaxFlux - CurrentFlux]`
- Treats negative input as 0 with warning log
- Early returns if amount == 0 (no change, no event)
- Publishes event if threshold crossed, boundary hit, or delta ≥ 15
- Returns new CurrentFlux value

```csharp
public int RemoveFlux(int amount)
```
- Clamps result to `[0, CurrentFlux]`
- Treats negative input as 0 with warning log
- Early returns if amount == 0 (no change, no event)
- Publishes event if threshold crossed, boundary hit, or delta ≥ 15
- Returns new CurrentFlux value

```csharp
public int DissipateFlux(int? amount = null)
```
- Uses `DefaultDissipationRate` (5) if amount is null
- Treats negative input as 0 with warning log
- Early returns if CurrentFlux == 0 (no dissipation needed)
- Clamps result to `[0, CurrentFlux]`
- Publishes event if threshold crossed, boundary hit, or delta ≥ 15
- Returns new CurrentFlux value

```csharp
public void ResetFlux()
```
- Sets CurrentFlux to 0
- Only publishes event if previousFlux > 0 (prevents spurious events on already-zero state)
- Always logs reset with previous value

```csharp
public FluxState GetFluxState()
```
- Returns `_fluxState.Clone()` for immutable external access
- Prevents external modification of internal state

```csharp
public FluxThreshold GetThreshold()
```
- Returns `_fluxState.Threshold` (computed property)
- No side effects

```csharp
private void PublishEventIfSignificant(int previousFlux, FluxThreshold previousThreshold, string reason)
```
- Early returns if delta == 0 (prevents spurious events)
- Checks three conditions: threshold changed, boundary hit, significant change (≥15)
- Creates FluxChangedEvent with all metadata
- Publishes via IEventBus
- Logs Information-level message with trigger details

**Defensive Programming Measures:**
- Negative input treated as 0 (with warning log)
- Boundary clamping prevents invalid flux states
- Zero-delta suppression prevents unnecessary events
- Reset-on-zero suppression prevents spurious events

---

### CombatService Integration

**Constructor Signature Change:**

Added parameter:
```csharp
IAetherService aetherService
```

**StartCombat() Integration:**

```csharp
// After clearing combat log (line 564)
_aetherService.ResetFlux();
_logger.LogDebug("[Aether] Flux reset at combat start");
```

**Behavior:**
- Resets flux to 0 at combat start
- Publishes FluxChangedEvent only if previousFlux > 0

**NextTurn() Integration:**

```csharp
// After incrementing RoundNumber at round boundary (lines 595-602)
if (state.TurnIndex >= state.TurnOrder.Count)
{
    state.TurnIndex = 0;
    state.RoundNumber++;
    _logger.LogInformation("Round {Round} begins", state.RoundNumber);

    // Dissipate environmental flux at round boundary
    var fluxBefore = _aetherService.CurrentFlux;
    var fluxAfter = _aetherService.DissipateFlux();
    if (fluxBefore > 0)
    {
        _logger.LogDebug("[Aether] Flux dissipated at round boundary: {Before} -> {After}",
            fluxBefore, fluxAfter);
    }

    // Replan enemy actions...
}
```

**Behavior:**
- Dissipates flux by default rate (5) when TurnIndex wraps to 0 (new round)
- Only logs if fluxBefore > 0 (prevents log spam on zero flux)
- Uses default dissipation rate from FluxState

**EndCombat() Integration:**

```csharp
// Before phase transition to Exploration (line 744)
_aetherService.ResetFlux();
_logger.LogDebug("[Aether] Flux reset at combat end");
```

**Behavior:**
- Resets flux to 0 at combat end
- Publishes FluxChangedEvent only if previousFlux > 0

---

## Logging Matrix

### AetherService Logs

| Event | Level | Template |
|-------|-------|----------|
| Service initialization | Debug | `[Aether] Service initialized. MaxFlux={MaxFlux}, DefaultDissipation={Rate}` |
| AddFlux negative input | Warning | `[Aether] AddFlux called with negative amount {Amount}. Treating as 0.` |
| AddFlux zero input | Debug | `[Aether] AddFlux called with 0. No change.` |
| AddFlux successful | Debug | `[Aether] Added {Amount} flux. {Previous} -> {Current} ({Threshold})` |
| RemoveFlux negative input | Warning | `[Aether] RemoveFlux called with negative amount {Amount}. Treating as 0.` |
| RemoveFlux zero input | Debug | `[Aether] RemoveFlux called with 0. No change.` |
| RemoveFlux successful | Debug | `[Aether] Removed {Amount} flux. {Previous} -> {Current} ({Threshold})` |
| DissipateFlux negative input | Warning | `[Aether] DissipateFlux called with negative amount {Amount}. Treating as 0.` |
| DissipateFlux at zero | Debug | `[Aether] DissipateFlux called but flux is already at 0. No change.` |
| DissipateFlux successful | Debug | `[Aether] Dissipated {Amount} flux. {Previous} -> {Current} ({Threshold})` |
| ResetFlux | Debug | `[Aether] Reset flux to 0. Previous={Previous}` |
| Event publication | Information | `[Aether] Publishing FluxChangedEvent: {Previous} -> {Current} ({PrevThreshold} -> {CurrThreshold}). Reason={Reason}, ThresholdChanged={ThresholdChanged}, HitBoundary={HitBoundary}, Significant={Significant}` |

### CombatService Integration Logs

| Event | Level | Template |
|-------|-------|----------|
| StartCombat flux reset | Debug | `[Aether] Flux reset at combat start` |
| NextTurn flux dissipation | Debug | `[Aether] Flux dissipated at round boundary: {Before} -> {After}` |
| EndCombat flux reset | Debug | `[Aether] Flux reset at combat end` |

---

## Test Coverage

### Test Summary

```
Total: 43 | Passed: 43 | Failed: 0 | Duration: 125ms
```

### Complete Test Inventory

#### AetherServiceTests (43 tests)

##### AddFlux Tests (8 tests)

| Test Name | Description |
|-----------|-------------|
| `AddFlux_WithPositiveAmount_IncreasesCurrentFlux` | Verifies adding 10 flux increases CurrentFlux to 10 |
| `AddFlux_WhenExceedingMax_ClampsToMaxFlux` | Verifies adding flux beyond MaxFlux clamps to 100 |
| `AddFlux_WithZeroAmount_DoesNotChangeFlux` | Verifies zero input produces no change and no event |
| `AddFlux_WithNegativeAmount_TreatsAsZero` | Verifies negative input is treated as 0 with warning log |
| `AddFlux_CrossingThreshold_PublishesEvent` | Verifies threshold transition (Safe → Elevated at 25) publishes event |
| `AddFlux_WithSignificantChange_PublishesEvent` | Verifies delta ≥ 15 triggers event publication |
| `AddFlux_HittingMaxBoundary_PublishesEvent` | Verifies reaching MaxFlux (100) publishes boundary event |
| `AddFlux_SmallChangeWithinThreshold_DoesNotPublishEvent` | Verifies small changes (5 flux) within same threshold do not publish |

##### RemoveFlux Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `RemoveFlux_WithPositiveAmount_DecreasesCurrentFlux` | Verifies removing 10 flux from 50 results in 40 |
| `RemoveFlux_WhenGoingBelowZero_ClampsToZero` | Verifies removing more than CurrentFlux clamps to 0 |
| `RemoveFlux_WithZeroAmount_DoesNotChangeFlux` | Verifies zero input produces no change |
| `RemoveFlux_WithNegativeAmount_TreatsAsZero` | Verifies negative input is treated as 0 with warning log |
| `RemoveFlux_CrossingThreshold_PublishesEvent` | Verifies threshold transition (Elevated → Safe at 20) publishes event |
| `RemoveFlux_HittingZeroBoundary_PublishesEvent` | Verifies reaching 0 publishes boundary event |

##### DissipateFlux Tests (5 tests)

| Test Name | Description |
|-----------|-------------|
| `DissipateFlux_WithoutAmount_UsesDefaultRate` | Verifies null amount uses DefaultDissipationRate (5) |
| `DissipateFlux_WithCustomAmount_UsesCustomRate` | Verifies custom dissipation amount (10) is applied |
| `DissipateFlux_AtZero_ReturnsZero` | Verifies dissipation at zero flux returns 0 with early exit |
| `DissipateFlux_WhenExceedingCurrent_ClampsToZero` | Verifies dissipating more than CurrentFlux clamps to 0 |
| `DissipateFlux_WithNegativeAmount_TreatsAsZero` | Verifies negative input is treated as 0 with warning log |

##### ResetFlux Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `ResetFlux_ResetsToZero` | Verifies flux is set to 0 after reset |
| `ResetFlux_WhenAlreadyZero_DoesNotPublishEvent` | Verifies no event published when resetting already-zero flux |
| `ResetFlux_WhenAboveZero_PublishesEvent` | Verifies event published with ChangeReason="Reset" when flux > 0 |

##### GetFluxState Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `GetFluxState_ReturnsCurrentState` | Verifies returned state contains correct CurrentFlux, MaxFlux, Threshold |
| `GetFluxState_ReturnsClone` | Verifies two calls return different instances (not same reference) |
| `GetFluxState_ModifyingCloneDoesNotAffectService` | Verifies modifying returned clone does not mutate service state |

##### GetThreshold Tests (5 tests)

| Test Name | Description |
|-----------|-------------|
| `GetThreshold_InSafeRange_ReturnsSafe` | Theory with InlineData(0, Safe), (24, Safe) verifies Safe threshold |
| `GetThreshold_InElevatedRange_ReturnsElevated` | Theory with InlineData(25, Elevated), (49, Elevated) verifies Elevated threshold |
| `GetThreshold_InCriticalRange_ReturnsCritical` | Theory with InlineData(50, Critical), (74, Critical) verifies Critical threshold |
| `GetThreshold_InOverloadRange_ReturnsOverload` | Theory with InlineData(75, Overload), (100, Overload) verifies Overload threshold |
| `GetThreshold_AtBoundaries_ReturnsCorrectThreshold` | Verifies all threshold transition boundaries (24→25, 49→50, 74→75) |

##### Event Publication Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `FluxChangedEvent_ContainsCorrectPreviousAndCurrentFlux` | Verifies event contains PreviousFlux=0, CurrentFlux=30 |
| `FluxChangedEvent_ContainsCorrectDelta` | Verifies event.Delta computed property equals 20 |
| `FluxChangedEvent_IdentifiesThresholdCrossing` | Verifies event.CrossedThreshold=true when Safe → Critical |
| `FluxChangedEvent_IdentifiesBoundaryHit` | Verifies event.HitBoundary=true when reaching MaxFlux |
| `FluxChangedEvent_ContainsChangeReason` | Verifies event.ChangeReason="AddFlux" |
| `FluxChangedEvent_IsIncreaseIsDecrease_AreCorrect` | Verifies IsIncrease=true for AddFlux, IsDecrease=true for RemoveFlux |

##### Edge Case Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `AddFlux_AtMaxFlux_RemainsAtMax` | Verifies adding flux when already at 100 produces no change or event |
| `RemoveFlux_AtZeroFlux_RemainsAtZero` | Verifies removing flux when already at 0 produces no change |
| `Properties_CurrentFluxAndMaxFlux_AreAccessible` | Verifies public properties CurrentFlux and MaxFlux are readable |

---

## DI Registration

### Program.cs (Terminal)

```csharp
// Register Aether Service (v0.4.3a - The Aether)
services.AddSingleton<IAetherService, AetherService>();
```

**Location:** After CombatService registration (line 166)
**Lifetime:** Singleton (flux is per-encounter, shared across combat)

### TestGameHost.cs (Test Infrastructure)

```csharp
services.AddSingleton<IAetherService, AetherService>();
```

**Location:** After LootService, before CombatService registration
**Purpose:** Ensures test environment mirrors production DI configuration

---

## Verification Results

### Build Output

```
Build succeeded.
    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:02.28
```

**Note:** MSB3277 warning regarding EntityFrameworkCore.Relational version conflict is pre-existing and unrelated to this release.

### Test Output

**AetherServiceTests:**
```
Passed!  - Failed:     0, Passed:    43, Skipped:     0, Total:    43, Duration: 125 ms
```

**Full Test Suite:**
```
Passed: 3700 | Failed: 59 | Total: 3759 | Duration: 7s
```

**Note:** 59 pre-existing failures in PostgreSQL integration tests and VisualEffectServiceTests are unrelated to this release. No new test failures introduced.

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Enums/
│   ├── FluxThreshold.cs [NEW]
│   └── (existing enums...)
├── Events/
│   ├── FluxChangedEvent.cs [NEW]
│   └── (existing events...)
├── Interfaces/
│   ├── IAetherService.cs [NEW]
│   └── (existing interfaces...)
└── Models/
    ├── Magic/ [NEW DIRECTORY]
    │   └── FluxState.cs [NEW]
    └── (existing model directories...)

RuneAndRust.Engine/
└── Services/
    ├── AetherService.cs [NEW]
    ├── CombatService.cs [MODIFIED]
    └── (existing services...)

RuneAndRust.Terminal/
├── Program.cs [MODIFIED]
└── (existing files...)

RuneAndRust.Tests/
├── Engine/
│   ├── Services/
│   │   ├── AetherServiceTests.cs [NEW]
│   │   └── (existing service tests...)
│   ├── CombatServiceTests.cs [MODIFIED]
│   ├── IntentSystemTests.cs [MODIFIED]
│   ├── RowAssignmentTests.cs [MODIFIED]
│   └── TimelineProjectionTests.cs [MODIFIED]
└── Infrastructure/
    ├── TestGameHost.cs [MODIFIED]
    └── (existing infrastructure...)

docs/changelogs/v0.4.x/
├── v0.4.3a.md [NEW]
└── (existing changelogs...)
```

---

## Running Tests

### Run AetherService Tests Only

```bash
dotnet test --filter "FullyQualifiedName~AetherServiceTests"
```

**Expected Output:**
```
Passed!  - Failed:     0, Passed:    43, Skipped:     0, Total:    43
```

### Run All Engine Service Tests

```bash
dotnet test --filter "FullyQualifiedName~Engine.Services"
```

### Run Flux-Related Integration Tests

```bash
dotnet test --filter "FullyQualifiedName~CombatServiceTests"
```

---

## Next Steps

The following work is planned for subsequent releases:

1. **v0.4.3b: Spell Flux Integration**
   - Modify AbilityService to call `_aetherService.AddFlux()` when casting spells
   - Add `FluxCost` property to ActiveAbility model
   - Implement flux cost calculation based on spell power tier
   - Add combat log messages for flux accumulation during spellcasting

2. **v0.4.3c: Flux Effects System**
   - Implement FluxEffectService to apply threshold-based modifiers
   - Create FluxEffect model with threshold triggers and stat adjustments
   - Add status effects for Critical/Overload thresholds (e.g., "Aetheric Instability")
   - Implement spell outcome randomization at Overload threshold

3. **v0.4.3d: UI Flux Display**
   - Add FluxBar component to CombatScreenRenderer
   - Implement color-coded threshold visualization (green/yellow/red/purple)
   - Add flux change animations and threshold crossing alerts
   - Display current threshold tier and percentage

4. **v0.4.4: Ability Cooldown System**
   - Implement cooldown tracking for abilities
   - Add cooldown reduction mechanics
   - Integrate cooldowns with turn advancement

5. **v0.5.0: Major Combat UI Overhaul**
   - Redesign combat screen layout with spatial positioning
   - Implement row-based visual representation
   - Add enemy intent preview UI
   - Enhance visual effect rendering

---

## Design Decisions & Rationale

### Singleton Registration

**Decision:** Register AetherService as Singleton
**Rationale:** Flux is per-encounter state shared across all combat participants. Using Singleton ensures a single source of truth and prevents desynchronization.

### Event Publication Suppression

**Decision:** Do not publish FluxChangedEvent when delta == 0
**Rationale:** Prevents spurious events from no-op operations (e.g., adding 0 flux, resetting already-zero flux). Reduces event bus noise and improves performance.

### Record Type for FluxChangedEvent

**Decision:** Use `record` type with primary constructor
**Rationale:** Provides immutable event data, concise syntax, value equality semantics, and automatic ToString() implementation for logging.

### Clone Method for FluxState

**Decision:** Implement Clone() method returning new instance
**Rationale:** Prevents external code from mutating internal service state. Ensures immutability of exposed state while avoiding reference leaks.

### Negative Amount Handling

**Decision:** Treat negative amounts as 0 with warning log
**Rationale:** Defensive programming prevents invalid states. Warning log aids debugging while maintaining service stability.

### Significant Change Threshold

**Decision:** Set threshold at 15 points
**Rationale:** Balances event publication frequency with informativeness. Captures meaningful flux changes without overwhelming event bus. Approximately 15% of MaxFlux (100).

### Default Dissipation Rate

**Decision:** Default dissipation of 5 per round
**Rationale:** Provides gradual flux reduction over ~20 rounds (100 flux ÷ 5 per round). Balances flux persistence with natural decay. Configurable via FluxState property for future tuning.

### Threshold Boundary Alignment

**Decision:** Use inclusive lower bounds (>= 25, >= 50, >= 75)
**Rationale:** Ensures no flux values are uncategorized. Provides clear, consistent threshold transitions at multiples of 25.

---

**End of Changelog v0.4.3a**
