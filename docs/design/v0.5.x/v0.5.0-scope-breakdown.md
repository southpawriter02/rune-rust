# v0.5.0 Combat Grid Foundation - Scope Breakdown

**Version:** 0.5.0
**Theme:** Combat Grid Foundation
**Prerequisites:** v0.4.3 Complete (Light & Environment Systems)
**Total Estimated Tests:** ~80 new tests

---

## Executive Summary

The Combat Grid Foundation version introduces the core tactical positioning system that transforms combat from abstract exchanges into spatial tactical encounters. Players and monsters are positioned on a 2D grid during combat, with movement governed by movement points and turn tracking. This version establishes the grid infrastructure that range, terrain, and advanced positioning mechanics will build upon.

Key focus areas:
- **Combat Grid Entity**: 2D grid with configurable dimensions and cell tracking
- **Grid Position System**: X,Y coordinate tracking for all combatants
- **Movement Mechanics**: Movement points, directional movement, turn tracking
- **ASCII Display**: Visual grid representation showing positions

The work is divided into **three sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.5.0a | Grid Core | CombatGrid, GridPosition, GridCell value objects | ~30 |
| v0.5.0b | Movement System | MovementSpeed, movement points, directional movement | ~30 |
| v0.5.0c | Grid Display & Integration | ASCII rendering, combat integration, commands | ~20 |

---

## Existing Infrastructure

### Already Implemented (from v0.4.3)

| Feature | Location | Notes |
|---------|----------|-------|
| SkillService | `Application/Services/SkillService.cs` | Movement skill checks |
| LightLevel | `Domain/Enums/LightLevel.cs` | Grid visibility |
| Room entity | `Domain/Entities/Room.cs` | Combat room context |
| VisionType | `Domain/Enums/VisionType.cs` | Grid visibility |

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| Player entity | `Domain/Entities/Player.cs` | Position tracking |
| Monster entity | `Domain/Entities/Monster.cs` | Position tracking |
| CombatService | `Application/Services/CombatService.cs` | Combat integration |
| TurnManager | `Application/Services/TurnManager.cs` | Turn tracking |
| DiceService | `Application/Services/DiceService.cs` | Movement rolls |
| GameRenderer | `Presentation/Adapters/SpectreGameRenderer.cs` | Grid display |

### Needs Implementation (v0.5.0)

| Feature | Phase | Notes |
|---------|-------|-------|
| CombatGrid entity | v0.5.0a | Grid dimensions and cell tracking |
| GridPosition value object | v0.5.0a | X, Y coordinates |
| GridCell value object | v0.5.0a | Cell contents and properties |
| MovementSpeed stat | v0.5.0b | Creature movement stat |
| Movement point tracking | v0.5.0b | Per-turn movement |
| `move` command | v0.5.0b | Directional movement |
| Grid ASCII display | v0.5.0c | Visual representation |
| Combat grid integration | v0.5.0c | CombatService updates |

---

## Feature Analysis & Categorization

### Grid Core Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| CombatGrid entity | High | None | **v0.5.0a** |
| GridPosition value object | Low | None | **v0.5.0a** |
| GridCell value object | Medium | GridPosition | **v0.5.0a** |
| Grid initialization | Medium | CombatGrid | **v0.5.0a** |
| Entity placement | Medium | GridCell | **v0.5.0a** |
| ICombatGridService interface | Medium | CombatGrid | **v0.5.0a** |
| CombatGridService | High | CombatGrid, GridPosition | **v0.5.0a** |

### Movement Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| MovementSpeed stat | Medium | Player, Monster | **v0.5.0b** |
| MovementPointsRemaining | Medium | CombatState | **v0.5.0b** |
| Movement direction enum | Low | None | **v0.5.0b** |
| Basic grid movement | Medium | GridPosition, MovementSpeed | **v0.5.0b** |
| Turn movement tracking | Medium | TurnManager | **v0.5.0b** |
| Movement validation | Medium | CombatGrid | **v0.5.0b** |
| `move` command | Medium | CombatGridService | **v0.5.0b** |

### Display & Integration Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| ASCII grid display | High | CombatGrid, GridPosition | **v0.5.0c** |
| Grid legend | Low | Display | **v0.5.0c** |
| Combat service integration | High | CombatGrid, CombatService | **v0.5.0c** |
| Grid in combat display | Medium | GameRenderer | **v0.5.0c** |
| Position display in attacks | Medium | GridPosition | **v0.5.0c** |

---

## Phase Definitions

---

## v0.5.0a: Grid Core

[v0.5.0a Design Specification](v0.5.0a-design-specification.md)

### Overview

Establish the foundational grid data structures including the CombatGrid entity, GridPosition and GridCell value objects, and the service layer for grid management. This phase creates the core infrastructure that movement and display will build upon.

### Scope

**In Scope:**
- `GridPosition` value object (X, Y coordinates)
- `GridCell` value object (cell contents, occupant tracking)
- `CombatGrid` entity (dimensions, cell collection, initialization)
- `ICombatGridService` interface
- `CombatGridService` for grid management
- Grid initialization when combat begins
- Entity placement on grid
- Grid boundary validation
- Basic cell queries (get cell at position, is cell occupied)
- Grid configuration (default dimensions)

**Out of Scope:**
- Movement mechanics (v0.5.0b)
- Movement points (v0.5.0b)
- `move` command (v0.5.0b)
- ASCII grid display (v0.5.0c)
- Combat service integration (v0.5.0c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 1 | `CombatGrid` |
| Domain Value Objects | 2 | `GridPosition`, `GridCell` |
| Application Interfaces | 1 | `ICombatGridService` |
| Application Services | 1 | `CombatGridService` |
| Configuration | 1 | `grid.json` |
| Unit Tests | ~30 | Grid, position, cell tests |

### GridPosition Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a position on the combat grid.
/// </summary>
public readonly record struct GridPosition
{
    /// <summary>
    /// Gets the X coordinate (column).
    /// </summary>
    public int X { get; }

    /// <summary>
    /// Gets the Y coordinate (row).
    /// </summary>
    public int Y { get; }

    /// <summary>
    /// Creates a new grid position.
    /// </summary>
    public GridPosition(int x, int y)
    {
        X = x;
        Y = y;
    }

    /// <summary>
    /// Gets the position in a given direction.
    /// </summary>
    public GridPosition Move(MovementDirection direction) => direction switch
    {
        MovementDirection.North => new GridPosition(X, Y - 1),
        MovementDirection.South => new GridPosition(X, Y + 1),
        MovementDirection.East => new GridPosition(X + 1, Y),
        MovementDirection.West => new GridPosition(X - 1, Y),
        MovementDirection.NorthEast => new GridPosition(X + 1, Y - 1),
        MovementDirection.NorthWest => new GridPosition(X - 1, Y - 1),
        MovementDirection.SouthEast => new GridPosition(X + 1, Y + 1),
        MovementDirection.SouthWest => new GridPosition(X - 1, Y + 1),
        _ => this
    };

    /// <summary>
    /// Calculates the distance to another position (Chebyshev distance).
    /// </summary>
    public int DistanceTo(GridPosition other)
    {
        return Math.Max(Math.Abs(X - other.X), Math.Abs(Y - other.Y));
    }

    /// <summary>
    /// Calculates the Manhattan distance to another position.
    /// </summary>
    public int ManhattanDistanceTo(GridPosition other)
    {
        return Math.Abs(X - other.X) + Math.Abs(Y - other.Y);
    }

    /// <summary>
    /// Checks if this position is adjacent to another.
    /// </summary>
    public bool IsAdjacentTo(GridPosition other)
    {
        return DistanceTo(other) == 1;
    }

    /// <summary>
    /// Returns display string (e.g., "A1", "B3").
    /// </summary>
    public override string ToString()
    {
        var column = (char)('A' + X);
        var row = Y + 1;
        return $"{column}{row}";
    }

    /// <summary>
    /// Parses a position from string (e.g., "A1", "B3").
    /// </summary>
    public static bool TryParse(string input, out GridPosition position)
    {
        position = default;

        if (string.IsNullOrWhiteSpace(input) || input.Length < 2)
            return false;

        var column = char.ToUpperInvariant(input[0]);
        if (column < 'A' || column > 'Z')
            return false;

        if (!int.TryParse(input[1..], out var row) || row < 1)
            return false;

        position = new GridPosition(column - 'A', row - 1);
        return true;
    }

    /// <summary>
    /// Creates a position from column/row notation.
    /// </summary>
    public static GridPosition FromNotation(string notation)
    {
        if (!TryParse(notation, out var position))
            throw new ArgumentException($"Invalid grid notation: {notation}", nameof(notation));
        return position;
    }

    /// <summary>
    /// Origin position (0, 0).
    /// </summary>
    public static GridPosition Origin => new(0, 0);
}
```

### MovementDirection Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Directions for grid movement.
/// </summary>
public enum MovementDirection
{
    /// <summary>Up on the grid (Y decreases).</summary>
    North,

    /// <summary>Down on the grid (Y increases).</summary>
    South,

    /// <summary>Right on the grid (X increases).</summary>
    East,

    /// <summary>Left on the grid (X decreases).</summary>
    West,

    /// <summary>Up-right diagonal.</summary>
    NorthEast,

    /// <summary>Up-left diagonal.</summary>
    NorthWest,

    /// <summary>Down-right diagonal.</summary>
    SouthEast,

    /// <summary>Down-left diagonal.</summary>
    SouthWest
}
```

### GridCell Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a single cell on the combat grid.
/// </summary>
public class GridCell
{
    /// <summary>
    /// Gets the position of this cell.
    /// </summary>
    public GridPosition Position { get; }

    /// <summary>
    /// Gets whether this cell is occupied by an entity.
    /// </summary>
    public bool IsOccupied => OccupantId.HasValue;

    /// <summary>
    /// Gets the ID of the occupying entity (player or monster).
    /// </summary>
    public Guid? OccupantId { get; private set; }

    /// <summary>
    /// Gets whether the occupant is the player.
    /// </summary>
    public bool IsPlayerOccupied { get; private set; }

    /// <summary>
    /// Gets whether this cell is passable.
    /// </summary>
    public bool IsPassable { get; private set; } = true;

    private GridCell(GridPosition position)
    {
        Position = position;
    }

    /// <summary>
    /// Creates a new empty grid cell.
    /// </summary>
    public static GridCell Create(GridPosition position)
    {
        return new GridCell(position);
    }

    /// <summary>
    /// Creates a new empty grid cell at coordinates.
    /// </summary>
    public static GridCell Create(int x, int y)
    {
        return new GridCell(new GridPosition(x, y));
    }

    /// <summary>
    /// Places an entity in this cell.
    /// </summary>
    public bool PlaceEntity(Guid entityId, bool isPlayer)
    {
        if (IsOccupied || !IsPassable)
            return false;

        OccupantId = entityId;
        IsPlayerOccupied = isPlayer;
        return true;
    }

    /// <summary>
    /// Removes the entity from this cell.
    /// </summary>
    public bool RemoveEntity()
    {
        if (!IsOccupied)
            return false;

        OccupantId = null;
        IsPlayerOccupied = false;
        return true;
    }

    /// <summary>
    /// Sets whether this cell is passable.
    /// </summary>
    public void SetPassable(bool passable)
    {
        IsPassable = passable;
    }

    /// <summary>
    /// Gets the display character for this cell.
    /// </summary>
    public char GetDisplayChar()
    {
        if (!IsPassable)
            return '#';
        if (IsPlayerOccupied)
            return '@';
        if (IsOccupied)
            return 'M';
        return '.';
    }
}
```

### CombatGrid Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a 2D grid for tactical combat positioning.
/// </summary>
public class CombatGrid : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this grid.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the width of the grid (number of columns).
    /// </summary>
    public int Width { get; private set; }

    /// <summary>
    /// Gets the height of the grid (number of rows).
    /// </summary>
    public int Height { get; private set; }

    /// <summary>
    /// Gets the associated room ID.
    /// </summary>
    public Guid? RoomId { get; private set; }

    private readonly Dictionary<GridPosition, GridCell> _cells = new();
    private readonly Dictionary<Guid, GridPosition> _entityPositions = new();

    /// <summary>
    /// Gets all cells in the grid.
    /// </summary>
    public IReadOnlyDictionary<GridPosition, GridCell> Cells => _cells;

    /// <summary>
    /// Gets all entity positions.
    /// </summary>
    public IReadOnlyDictionary<Guid, GridPosition> EntityPositions => _entityPositions;

    private CombatGrid() { }

    /// <summary>
    /// Creates a new combat grid with the specified dimensions.
    /// </summary>
    public static CombatGrid Create(int width, int height, Guid? roomId = null)
    {
        if (width < 3 || width > 20)
            throw new ArgumentOutOfRangeException(nameof(width), "Grid width must be between 3 and 20.");
        if (height < 3 || height > 20)
            throw new ArgumentOutOfRangeException(nameof(height), "Grid height must be between 3 and 20.");

        var grid = new CombatGrid
        {
            Id = Guid.NewGuid(),
            Width = width,
            Height = height,
            RoomId = roomId
        };

        grid.InitializeCells();
        return grid;
    }

    /// <summary>
    /// Creates a default 8x8 combat grid.
    /// </summary>
    public static CombatGrid CreateDefault(Guid? roomId = null)
    {
        return Create(8, 8, roomId);
    }

    private void InitializeCells()
    {
        for (int y = 0; y < Height; y++)
        {
            for (int x = 0; x < Width; x++)
            {
                var position = new GridPosition(x, y);
                _cells[position] = GridCell.Create(position);
            }
        }
    }

    /// <summary>
    /// Gets the cell at the specified position.
    /// </summary>
    public GridCell? GetCell(GridPosition position)
    {
        return _cells.TryGetValue(position, out var cell) ? cell : null;
    }

    /// <summary>
    /// Gets the cell at the specified coordinates.
    /// </summary>
    public GridCell? GetCell(int x, int y)
    {
        return GetCell(new GridPosition(x, y));
    }

    /// <summary>
    /// Checks if a position is within grid bounds.
    /// </summary>
    public bool IsInBounds(GridPosition position)
    {
        return position.X >= 0 && position.X < Width &&
               position.Y >= 0 && position.Y < Height;
    }

    /// <summary>
    /// Checks if a position is valid for movement.
    /// </summary>
    public bool IsValidPosition(GridPosition position)
    {
        if (!IsInBounds(position))
            return false;

        var cell = GetCell(position);
        return cell != null && cell.IsPassable && !cell.IsOccupied;
    }

    /// <summary>
    /// Places an entity on the grid.
    /// </summary>
    public bool PlaceEntity(Guid entityId, GridPosition position, bool isPlayer)
    {
        if (!IsInBounds(position))
            return false;

        var cell = GetCell(position);
        if (cell == null || !cell.PlaceEntity(entityId, isPlayer))
            return false;

        _entityPositions[entityId] = position;
        return true;
    }

    /// <summary>
    /// Removes an entity from the grid.
    /// </summary>
    public bool RemoveEntity(Guid entityId)
    {
        if (!_entityPositions.TryGetValue(entityId, out var position))
            return false;

        var cell = GetCell(position);
        if (cell == null || !cell.RemoveEntity())
            return false;

        _entityPositions.Remove(entityId);
        return true;
    }

    /// <summary>
    /// Moves an entity to a new position.
    /// </summary>
    public bool MoveEntity(Guid entityId, GridPosition newPosition)
    {
        if (!_entityPositions.TryGetValue(entityId, out var currentPosition))
            return false;

        if (!IsValidPosition(newPosition))
            return false;

        var currentCell = GetCell(currentPosition);
        var newCell = GetCell(newPosition);

        if (currentCell == null || newCell == null)
            return false;

        var isPlayer = currentCell.IsPlayerOccupied;

        if (!currentCell.RemoveEntity())
            return false;

        if (!newCell.PlaceEntity(entityId, isPlayer))
        {
            // Rollback
            currentCell.PlaceEntity(entityId, isPlayer);
            return false;
        }

        _entityPositions[entityId] = newPosition;
        return true;
    }

    /// <summary>
    /// Gets an entity's current position.
    /// </summary>
    public GridPosition? GetEntityPosition(Guid entityId)
    {
        return _entityPositions.TryGetValue(entityId, out var position) ? position : null;
    }

    /// <summary>
    /// Gets the distance between two entities.
    /// </summary>
    public int? GetDistanceBetween(Guid entityId1, Guid entityId2)
    {
        var pos1 = GetEntityPosition(entityId1);
        var pos2 = GetEntityPosition(entityId2);

        if (!pos1.HasValue || !pos2.HasValue)
            return null;

        return pos1.Value.DistanceTo(pos2.Value);
    }

    /// <summary>
    /// Checks if two entities are adjacent.
    /// </summary>
    public bool AreAdjacent(Guid entityId1, Guid entityId2)
    {
        var distance = GetDistanceBetween(entityId1, entityId2);
        return distance.HasValue && distance.Value == 1;
    }

    /// <summary>
    /// Gets all entities within a given range of a position.
    /// </summary>
    public IEnumerable<Guid> GetEntitiesInRange(GridPosition center, int range)
    {
        foreach (var (entityId, position) in _entityPositions)
        {
            if (center.DistanceTo(position) <= range)
                yield return entityId;
        }
    }

    /// <summary>
    /// Gets adjacent cells to a position.
    /// </summary>
    public IEnumerable<GridCell> GetAdjacentCells(GridPosition position)
    {
        var directions = new[]
        {
            MovementDirection.North, MovementDirection.South,
            MovementDirection.East, MovementDirection.West,
            MovementDirection.NorthEast, MovementDirection.NorthWest,
            MovementDirection.SouthEast, MovementDirection.SouthWest
        };

        foreach (var direction in directions)
        {
            var adjacent = position.Move(direction);
            if (IsInBounds(adjacent))
            {
                var cell = GetCell(adjacent);
                if (cell != null)
                    yield return cell;
            }
        }
    }
}
```

### ICombatGridService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing combat grid operations.
/// </summary>
public interface ICombatGridService
{
    /// <summary>
    /// Creates a new combat grid for a room.
    /// </summary>
    CombatGrid CreateGrid(Room room, int? width = null, int? height = null);

    /// <summary>
    /// Initializes entity positions on a grid.
    /// </summary>
    GridInitializationResult InitializePositions(
        CombatGrid grid,
        Player player,
        IEnumerable<Monster> monsters);

    /// <summary>
    /// Gets the active combat grid.
    /// </summary>
    CombatGrid? GetActiveGrid();

    /// <summary>
    /// Sets the active combat grid.
    /// </summary>
    void SetActiveGrid(CombatGrid? grid);

    /// <summary>
    /// Clears the active grid (combat ended).
    /// </summary>
    void ClearGrid();

    /// <summary>
    /// Gets an entity's position on the grid.
    /// </summary>
    GridPosition? GetEntityPosition(Guid entityId);

    /// <summary>
    /// Gets the distance between two entities.
    /// </summary>
    int? GetDistance(Guid entityId1, Guid entityId2);

    /// <summary>
    /// Checks if two entities are adjacent.
    /// </summary>
    bool AreAdjacent(Guid entityId1, Guid entityId2);
}

public readonly record struct GridInitializationResult
{
    public bool Success { get; init; }
    public GridPosition PlayerPosition { get; init; }
    public IReadOnlyDictionary<Guid, GridPosition> MonsterPositions { get; init; }
    public string Message { get; init; }
}
```

### Configuration Example

```json
{
  "$schema": "../schemas/grid.schema.json",
  "gridSettings": {
    "defaultWidth": 8,
    "defaultHeight": 8,
    "minWidth": 3,
    "maxWidth": 20,
    "minHeight": 3,
    "maxHeight": 20,
    "playerStartPosition": "center-south",
    "monsterSpawnZone": "north"
  },
  "roomGridOverrides": [
    {
      "roomId": "boss-chamber",
      "width": 12,
      "height": 12
    },
    {
      "roomId": "narrow-corridor",
      "width": 3,
      "height": 10
    }
  ]
}
```

### Acceptance Criteria

- [ ] GridPosition stores X, Y coordinates correctly
- [ ] GridPosition calculates distance between positions
- [ ] GridPosition.Move returns correct adjacent position
- [ ] GridPosition string notation works (A1, B3, etc.)
- [ ] GridCell tracks occupancy state
- [ ] GridCell prevents multiple occupants
- [ ] CombatGrid initializes with correct dimensions
- [ ] CombatGrid validates boundary positions
- [ ] CombatGrid places entities correctly
- [ ] CombatGrid moves entities between cells
- [ ] CombatGrid tracks all entity positions
- [ ] CombatGridService creates grids for rooms
- [ ] CombatGridService initializes entity positions
- [ ] ~30 unit tests pass

---

## v0.5.0b: Movement System

[v0.5.0b Design Specification](v0.5.0b-design-specification.md)

### Overview

Implement the movement mechanics including movement speed stats, movement point tracking per turn, directional movement commands, and validation. Players can move on the grid during combat using their movement points.

### Scope

**In Scope:**
- `MovementSpeed` stat for Player and Monster
- Movement points remaining per turn
- Movement point cost (1 for cardinal, 1.5 for diagonal)
- Directional movement (`move north`, `move ne`, etc.)
- Movement validation (bounds, occupied cells)
- Turn movement tracking (reset on new turn)
- Movement point display
- `move` command with direction argument
- Movement result messages

**Out of Scope:**
- ASCII grid display (v0.5.0c)
- Combat service integration (v0.5.0c)
- Terrain movement costs (v0.5.2)
- Difficult terrain (v0.5.2)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Player Updates | 1 | Add MovementSpeed, GridPosition |
| Monster Updates | 1 | Add MovementSpeed, GridPosition |
| Combat State Updates | 1 | MovementPointsRemaining |
| Service Updates | 1 | CombatGridService movement methods |
| Commands | 1 | `move` command |
| Configuration | 1 | Update progression.json |
| Unit Tests | ~30 | Movement, cost, validation tests |

### Player/Monster Modifications

```
MODIFY: Player
├── ADD: MovementSpeed: int (default: 4)
├── ADD: BaseMovementSpeed: int (from config)
├── ADD: CombatGridPosition: GridPosition? (combat only)
├── ADD: MovementPointsRemaining: int
├── ADD: SetMovementSpeed(int): void
├── ADD: ResetMovementPoints(): void
└── ADD: UseMovementPoints(int): bool

MODIFY: Monster
├── ADD: MovementSpeed: int (from definition)
├── ADD: CombatGridPosition: GridPosition? (combat only)
├── ADD: MovementPointsRemaining: int
├── ADD: ResetMovementPoints(): void
└── ADD: UseMovementPoints(int): bool

MODIFY: MonsterDefinition
└── ADD: MovementSpeed: int (default: 3)
```

### Movement Cost Constants

```csharp
namespace RuneAndRust.Domain.Constants;

/// <summary>
/// Constants for movement costs on the combat grid.
/// </summary>
public static class MovementCosts
{
    /// <summary>
    /// Base movement cost for cardinal directions (N, S, E, W).
    /// </summary>
    public const int Cardinal = 1;

    /// <summary>
    /// Base movement cost for diagonal directions.
    /// Using integer math: 3 points = 2 diagonal moves.
    /// </summary>
    public const int Diagonal = 2; // Costs 1.5, tracked as double-points

    /// <summary>
    /// Movement point multiplier (for fractional costs).
    /// </summary>
    public const int PointMultiplier = 2;

    /// <summary>
    /// Gets the movement cost for a direction.
    /// </summary>
    public static int GetCost(MovementDirection direction) => direction switch
    {
        MovementDirection.North => Cardinal * PointMultiplier,
        MovementDirection.South => Cardinal * PointMultiplier,
        MovementDirection.East => Cardinal * PointMultiplier,
        MovementDirection.West => Cardinal * PointMultiplier,
        MovementDirection.NorthEast => Diagonal + 1, // 3 points (1.5x)
        MovementDirection.NorthWest => Diagonal + 1,
        MovementDirection.SouthEast => Diagonal + 1,
        MovementDirection.SouthWest => Diagonal + 1,
        _ => Cardinal * PointMultiplier
    };

    /// <summary>
    /// Converts movement speed to movement points.
    /// </summary>
    public static int SpeedToPoints(int speed) => speed * PointMultiplier;

    /// <summary>
    /// Converts movement points to display speed.
    /// </summary>
    public static int PointsToSpeed(int points) => points / PointMultiplier;
}
```

### IMovementService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for handling grid movement during combat.
/// </summary>
public interface IMovementService
{
    /// <summary>
    /// Attempts to move an entity in a direction.
    /// </summary>
    MovementResult Move(Guid entityId, MovementDirection direction);

    /// <summary>
    /// Gets remaining movement points for an entity.
    /// </summary>
    int GetRemainingMovement(Guid entityId);

    /// <summary>
    /// Resets movement points for a new turn.
    /// </summary>
    void ResetMovement(Guid entityId);

    /// <summary>
    /// Resets movement for all entities (new round).
    /// </summary>
    void ResetAllMovement();

    /// <summary>
    /// Checks if an entity can move in a direction.
    /// </summary>
    bool CanMove(Guid entityId, MovementDirection direction);

    /// <summary>
    /// Gets valid movement directions for an entity.
    /// </summary>
    IEnumerable<MovementDirection> GetValidDirections(Guid entityId);

    /// <summary>
    /// Gets the movement cost for a direction.
    /// </summary>
    int GetMovementCost(MovementDirection direction);
}

public readonly record struct MovementResult
{
    public bool Success { get; init; }
    public GridPosition? OldPosition { get; init; }
    public GridPosition? NewPosition { get; init; }
    public int MovementPointsUsed { get; init; }
    public int MovementPointsRemaining { get; init; }
    public string Message { get; init; }
    public MovementFailureReason? FailureReason { get; init; }
}

public enum MovementFailureReason
{
    NoActiveGrid,
    EntityNotOnGrid,
    OutOfBounds,
    CellOccupied,
    InsufficientMovementPoints,
    CellImpassable,
    NotInCombat
}
```

### User-Facing Changes

**Commands:**
```
> move <direction>        # Move in a direction (n, s, e, w, ne, nw, se, sw)
> move north              # Move north (up on grid)
> move ne                 # Move northeast (diagonal)
> position                # Show current position and movement
```

**Movement Example:**
```
> move north

You move north on the battlefield.

[Movement: A4 → A3]
[Movement Points: 4 → 3 remaining]
```

**Diagonal Movement:**
```
> move northeast

You move northeast on the battlefield.

[Movement: B3 → C2]
[Movement Points: 3 → 1.5 remaining]
```

**Insufficient Movement:**
```
> move east

You don't have enough movement points to move.

[Movement Points: 1 remaining]
[Cardinal move costs: 1]
[Diagonal move costs: 1.5]
```

**Blocked Movement:**
```
> move south

You can't move there - a Skeleton blocks your path!

[Cell C5 is occupied]
```

**Position Display:**
```
> position

Your Position: C4
Movement Points: 3 / 4

Nearby:
  North (C3): Empty
  South (C5): Skeleton
  East (D4): Empty
  West (B4): Wall
```

### Configuration Example

```json
{
  "movementSettings": {
    "defaultPlayerSpeed": 4,
    "defaultMonsterSpeed": 3,
    "diagonalCostMultiplier": 1.5,
    "allowDiagonalMovement": true
  },
  "classMovementModifiers": [
    {
      "classId": "warrior",
      "movementSpeedBonus": 0
    },
    {
      "classId": "rogue",
      "movementSpeedBonus": 1
    },
    {
      "classId": "mage",
      "movementSpeedBonus": -1
    }
  ]
}
```

### Acceptance Criteria

- [ ] Player.MovementSpeed returns correct value
- [ ] Monster.MovementSpeed returns correct value from definition
- [ ] MovementPointsRemaining tracks usage correctly
- [ ] Cardinal movement costs 1 movement point
- [ ] Diagonal movement costs 1.5 movement points
- [ ] Movement fails when insufficient points
- [ ] Movement fails for out-of-bounds positions
- [ ] Movement fails for occupied cells
- [ ] Movement resets at start of turn
- [ ] `move` command accepts all 8 directions
- [ ] Direction aliases work (n, ne, nw, s, se, sw, e, w)
- [ ] Movement updates grid position
- [ ] Movement result shows old and new position
- [ ] ~30 unit tests pass

---

## v0.5.0c: Grid Display & Integration

[v0.5.0c Design Specification](v0.5.0c-design-specification.md)

### Overview

Implement the ASCII grid display and integrate the combat grid with the existing combat system. Players can see the tactical map during combat, and combat commands are aware of grid positions.

### Scope

**In Scope:**
- ASCII grid rendering (8x8 default)
- Grid legend (player, monsters, empty, walls)
- Grid display in combat view
- Combat service integration (grid initialization)
- Attack command position awareness
- Combat end grid cleanup
- Grid display on `look` during combat
- `grid` command to show tactical map
- Position indicators in combat messages

**Out of Scope:**
- Range checking (v0.5.1)
- Line of sight (v0.5.1)
- Terrain display (v0.5.2)
- Cover display (v0.5.2)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Renderer Updates | 1 | GridRenderer for ASCII display |
| CombatService Updates | 1 | Grid integration |
| GameView Updates | 1 | Grid display in combat |
| Commands | 1 | `grid` command |
| Unit Tests | ~20 | Display, integration tests |

### ASCII Grid Display

```
Combat Grid                              [Turn 3]
===============================================

     A   B   C   D   E   F   G   H
   +---+---+---+---+---+---+---+---+
 1 | . | . | . | . | . | . | . | . |
   +---+---+---+---+---+---+---+---+
 2 | . | . | M | . | . | M | . | . |
   +---+---+---+---+---+---+---+---+
 3 | . | . | . | . | . | . | . | . |
   +---+---+---+---+---+---+---+---+
 4 | . | . | . | @ | . | . | . | . |
   +---+---+---+---+---+---+---+---+
 5 | . | . | . | . | . | . | . | . |
   +---+---+---+---+---+---+---+---+
 6 | . | . | . | . | . | . | . | . |
   +---+---+---+---+---+---+---+---+
 7 | . | . | . | . | . | . | . | . |
   +---+---+---+---+---+---+---+---+
 8 | . | . | . | . | . | . | . | . |
   +---+---+---+---+---+---+---+---+

Legend: @ = You (D4)  M = Monster  . = Empty  # = Wall

Combatants:
  @ You (D4) - HP: 25/30 - Move: 2/4
  M Skeleton (C2) - HP: 10/10
  M Skeleton (F2) - HP: 8/10
```

### Compact Grid Display

```
Combat: Skeleton x2                      [Your Turn]
═══════════════════════════════════════════════════

  A B C D E F G H
1 . . . . . . . .
2 . . M . . M . .     Legend:
3 . . . . . . . .       @ = You
4 . . . @ . . . .       M = Monster
5 . . . . . . . .       . = Empty
6 . . . . . . . .
7 . . . . . . . .
8 . . . . . . . .

You (D4) | HP: 25/30 | Move: 2/4
```

### IGridRenderer Interface

```csharp
namespace RuneAndRust.Presentation.Interfaces;

/// <summary>
/// Renders the combat grid as ASCII art.
/// </summary>
public interface IGridRenderer
{
    /// <summary>
    /// Renders the full combat grid.
    /// </summary>
    string RenderGrid(CombatGrid grid, GridRenderOptions? options = null);

    /// <summary>
    /// Renders a compact version of the grid.
    /// </summary>
    string RenderCompactGrid(CombatGrid grid, GridRenderOptions? options = null);

    /// <summary>
    /// Renders the grid legend.
    /// </summary>
    string RenderLegend(CombatGrid grid);

    /// <summary>
    /// Renders combatant list with positions.
    /// </summary>
    string RenderCombatantList(
        CombatGrid grid,
        Player player,
        IEnumerable<Monster> monsters);
}

public class GridRenderOptions
{
    /// <summary>
    /// Whether to use box-drawing characters.
    /// </summary>
    public bool UseBoxDrawing { get; init; } = true;

    /// <summary>
    /// Whether to show coordinates.
    /// </summary>
    public bool ShowCoordinates { get; init; } = true;

    /// <summary>
    /// Whether to show the legend.
    /// </summary>
    public bool ShowLegend { get; init; } = true;

    /// <summary>
    /// Whether to highlight the player's valid moves.
    /// </summary>
    public bool HighlightValidMoves { get; init; } = false;

    /// <summary>
    /// Use compact rendering (no grid lines).
    /// </summary>
    public bool Compact { get; init; } = false;
}
```

### CombatService Integration

```csharp
// In CombatService:

/// <summary>
/// Starts combat with grid initialization.
/// </summary>
public CombatStartResult StartCombat(Player player, IEnumerable<Monster> monsters, Room room)
{
    // Create grid
    var grid = _gridService.CreateGrid(room);

    // Initialize positions
    var initResult = _gridService.InitializePositions(grid, player, monsters);
    if (!initResult.Success)
    {
        // Fallback to non-grid combat
        return StartNonGridCombat(player, monsters);
    }

    // Set active grid
    _gridService.SetActiveGrid(grid);

    // Reset movement for all combatants
    _movementService.ResetAllMovement();

    // Continue with normal combat initialization
    return new CombatStartResult
    {
        Success = true,
        Grid = grid,
        PlayerPosition = initResult.PlayerPosition,
        MonsterPositions = initResult.MonsterPositions,
        Message = "Combat begins!"
    };
}

/// <summary>
/// Ends combat and cleans up grid.
/// </summary>
public void EndCombat()
{
    _gridService.ClearGrid();
    // ... rest of combat cleanup
}

/// <summary>
/// Processes start of a new turn.
/// </summary>
public void StartTurn(Guid entityId)
{
    _movementService.ResetMovement(entityId);
    // ... rest of turn start
}
```

### User-Facing Changes

**Commands:**
```
> grid                    # Show the tactical grid
> grid compact            # Show compact grid view
> look                    # Includes grid in combat
```

**Combat with Grid:**
```
=== COMBAT BEGINS ===

Two Skeletons block your path!

  A B C D E F G H
1 . . . . . . . .
2 . . M . . M . .       @ = You
3 . . . . . . . .       M = Monster
4 . . . @ . . . .       . = Empty
5 . . . . . . . .

You (D4) | HP: 25/30 | Move: 4/4

[Your Turn]
> _
```

**Attack with Position:**
```
> attack skeleton

Which Skeleton?
  1. Skeleton at C2 (2 cells away)
  2. Skeleton at F2 (3 cells away)

> 1

You swing your sword at the Skeleton at C2...

[You are at D4, target at C2 - distance: 2]
[Attack Roll: 2d6 + 3 = 14 vs AC 12]
Hit! 8 damage to Skeleton.

  A B C D E F G H
1 . . . . . . . .
2 . . M . . M . .       Skeleton (C2): 2/10 HP
3 . . . . . . . .
4 . . . @ . . . .       You (D4): 25/30 HP
5 . . . . . . . .
```

### Acceptance Criteria

- [ ] ASCII grid displays correctly with coordinates
- [ ] Player position shows as @
- [ ] Monster positions show as M
- [ ] Empty cells show as .
- [ ] Grid legend displays correctly
- [ ] Compact grid mode works
- [ ] Combat initializes grid when starting
- [ ] Combat clears grid when ending
- [ ] Attack commands show position context
- [ ] `grid` command shows tactical map
- [ ] `look` includes grid during combat
- [ ] Movement updates grid display
- [ ] Combatant list shows positions and stats
- [ ] Turn start resets movement points
- [ ] ~20 unit tests pass

---

## Dependencies & Prerequisites

```
v0.4.3 (Light & Environment) - REQUIRED
    │
    ├── LightLevel ────────────────────────┐
    ├── VisionType ────────────────────────┤
    ├── SkillService ──────────────────────┤
    └── Room.CurrentLightLevel ────────────┘
                                           │
v0.0.6 (Enhanced Combat) - REQUIRED        │
    │                                      │
    ├── CombatService ─────────────────────┤
    ├── TurnManager ───────────────────────┤
    └── Initiative system ─────────────────┘
                                           │
                                           ▼
v0.5.0 (Combat Grid Foundation)
    │
    ├── v0.5.0a: Grid Core ────────────────────────────────┐
    │       Dependencies: Player, Monster, Room            │
    │       Provides: CombatGrid, GridPosition, GridCell   │
    │                                                      │
    ├── v0.5.0b: Movement System ──────────────────────────┤
    │       Dependencies: v0.5.0a, TurnManager             │
    │       Provides: MovementSpeed, move command          │
    │                                                      │
    └── v0.5.0c: Grid Display & Integration ───────────────┘
            Dependencies: v0.5.0a, v0.5.0b, CombatService
            Provides: ASCII display, combat integration
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.5.0a | ~6 | ~3 | ~30 | High |
| v0.5.0b | ~3 | ~5 | ~30 | Medium |
| v0.5.0c | ~2 | ~4 | ~20 | Medium |
| **Total** | **~11** | **~12** | **~80** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Grid size balance | Medium | Medium | Configurable dimensions |
| Performance with large grids | Low | Low | Limit to 20x20 max |
| Movement point calculation | Medium | Low | Double-point system for fractions |
| ASCII rendering alignment | Low | Medium | Use monospace, test rendering |
| Combat integration complexity | Medium | Medium | Phased integration |
| Backward compatibility | Medium | Low | Non-grid combat fallback |

---

## Design Decisions (Confirmed)

### Grid System

| Decision | Value | Notes |
|----------|-------|-------|
| **Default Grid Size** | 8x8 | Suitable for most encounters |
| **Max Grid Size** | 20x20 | Performance limit |
| **Coordinate System** | Column-Row (A1) | Chess-like notation |
| **Distance Calculation** | Chebyshev | Diagonal = 1 cell |
| **Movement Cost** | Integer-doubled | 2 points = 1 cardinal, 3 = diagonal |

### Movement System

| Decision | Value | Notes |
|----------|-------|-------|
| **Default Player Speed** | 4 | 4 cells per turn |
| **Default Monster Speed** | 3 | Slightly slower |
| **Diagonal Movement** | Allowed | Costs 1.5x |
| **Movement Reset** | Turn start | Per-entity |

### Display System

| Decision | Value | Notes |
|----------|-------|-------|
| **Player Symbol** | @ | Standard roguelike |
| **Monster Symbol** | M | Generic monster |
| **Empty Symbol** | . | Standard |
| **Wall Symbol** | # | Standard |
| **Render Mode** | Compact default | Full grid available |

---

## Integration Points

### To v0.5.1 (Range & Melee)
- GridPosition for distance calculations
- CombatGrid for range validation
- Entity positions for adjacency checks

### To v0.5.2 (Terrain & Cover)
- GridCell for terrain type storage
- CombatGrid for terrain lookup
- Movement cost modification

### To v0.5.3 (Tactical Positioning)
- GridPosition for flanking calculations
- Entity positions for threat tracking
- Adjacent cell queries for opportunity attacks

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.5.0a Design Spec** - Grid core system
3. **Implement v0.5.0a** - Build grid infrastructure
4. **v0.5.0b Design Spec** - Movement system
5. **Implement v0.5.0b** - Build movement mechanics
6. **v0.5.0c Design Spec** - Display and integration
7. **Implement v0.5.0c** - Complete grid visualization

---

*This scope breakdown provides a structured approach to implementing v0.5.0 Combat Grid Foundation. Each sub-phase builds on the previous, establishing the tactical positioning infrastructure that range, terrain, and advanced combat mechanics will build upon.*
