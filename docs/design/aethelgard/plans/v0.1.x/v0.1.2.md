Here is the comprehensive implementation plan for v0.1.2: Inventory & Economy.
v0.1.2: The Burden of Survival
Goal: Implement the Inventory System, Equipment management, and Loot Generation. This transforms the exploration loop by giving players resources to manage ("Burden"), gear to equip ("Binding"), and rewards to find ("Salvage").

## Table of Contents
- [1. Implementation Workflow](#1-implementation-workflow)
- [2. Code Implementation](#2-code-implementation)
- [3. Architecture Decision Tree](#3-architecture-decision-tree-v012)
- [4. Logging Matrix](#4-logging-matrix-v012)
- [5. Deliverable Checklist](#5-v012-deliverable-checklist)

1. Implementation Workflow
	1	Domain Definition: Define Item, Equipment, QualityTier, and EquipmentSlot in Core.
	2	Persistence Update: Create Items and InventoryItems tables via EF Core migration.
	3	Inventory Logic: Implement InventoryService to handle limits, stacking, and the "Burden" mechanic.
	4	Stat Integration: Update StatCalculationService to include bonuses from equipped gear.
	5	Loot Logic: Implement LootService to generate procedural items based on Tier and Biome.
	6	UI Wiring: Implement inventory, equip, unequip, take, and drop commands.

2. Code Implementation
A. Core Layer (Entities & Enums)
We introduce the concept of "Burden" (Encumbrance) and Quality Tiers.
File: RuneAndRust.Core/Enums/QualityTier.cs
namespace RuneAndRust.Core.Enums;

public enum QualityTier
{
    JuryRigged = 0, // Gray: Unstable, improvised
    Scavenged = 1,  // White: Functional, worn
    ClanForged = 2, // Green: Reliable, new
    Optimized = 3,  // Purple: Enhanced, superior
    MythForged = 4  // Gold: Legendary, complex code
}
File: RuneAndRust.Core/Entities/Item.cs
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

// Base class for all items using Table-per-Hierarchy (TPH)
public class Item
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int Weight { get; set; } // "Heft" in grams
    public int Value { get; set; }  // "Scrip/Cogs"
    public QualityTier Quality { get; set; }
    public bool IsStackable { get; set; }
}

public class Equipment : Item
{
    public EquipmentSlot Slot { get; set; }
    // Bonuses applied when equipped (Bound)
    public Dictionary<Attribute, int> AttributeBonuses { get; set; } = new();
    public int SoakBonus { get; set; } // Armor
    public int DamageDie { get; set; } // Weapons (d10 based)
}
B. Engine Layer (Services)
The InventoryService manages the physical constraints of the character's pack.
File: RuneAndRust.Engine/Services/InventoryService.cs
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;

namespace RuneAndRust.Engine.Services;

public class InventoryService
{
    private readonly ILogger<InventoryService> _logger;
    private readonly IRepository<Character> _charRepo;

    // Burden Thresholds (Percentage of Max Capacity)
    private const double HeavyBurdenThreshold = 0.7;
    private const double OverburdenedThreshold = 0.9;

    public InventoryService(ILogger<InventoryService> logger, IRepository<Character> charRepo)
    {
        _logger = logger;
        _charRepo = charRepo;
    }

    public BurdenState CalculateBurden(Character character)
    {
        // Max Carry = MIGHT * 10kg (10000g)
        int maxCapacity = character.Attributes[Attribute.Might] * 10000;
        int currentWeight = character.Inventory.Sum(i => i.Item.Weight * i.Quantity);

        double ratio = (double)currentWeight / maxCapacity;

        if (ratio >= OverburdenedThreshold) return BurdenState.Overburdened; // Cannot run
        if (ratio >= HeavyBurdenThreshold) return BurdenState.Heavy;         // Stat penalty
        return BurdenState.Light;
    }

    public async Task EquipItemAsync(Character character, Guid itemId)
    {
        var inventoryItem = character.Inventory.FirstOrDefault(i => i.ItemId == itemId);
        if (inventoryItem == null || inventoryItem.Item is not Equipment equipment)
        {
            _logger.LogWarning("Cannot equip item {ItemId}: Not found or not equipment", itemId);
            return;
        }

        // Unequip current slot if occupied
        var current = character.Equipment.FirstOrDefault(e => e.Slot == equipment.Slot);
        if (current != null) UnequipItem(character, current.Id);

        character.Equipment.Add(equipment);
        _logger.LogInformation("{Character} bound {Item} to {Slot}", character.Name, equipment.Name, equipment.Slot);

        // Recalculate derived stats immediately
        // _statService.Recalculate(character);
    }
}
C. Persistence Layer (Data)
Update the database to handle the many-to-many relationship between Characters and Items (Inventory) and the ownership of Items.
File: RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs
public DbSet<Item> Items { get; set; }
// Join entity for Inventory (Character <-> Item)
public DbSet<InventoryItem> InventoryItems { get; set; }

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    // ... previous config

    // TPH Configuration for Item hierarchy
    modelBuilder.Entity<Item>()
        .HasDiscriminator<string>("ItemType")
        .HasValue<Item>("Base")
        .HasValue<Equipment>("Equipment");

    modelBuilder.Entity<InventoryItem>()
        .HasKey(ii => new { ii.CharacterId, ii.ItemId });
}
Migration Workflow:
dotnet ef migrations add AddInventorySystem --project RuneAndRust.Persistence --startup-project RuneAndRust.Terminal
dotnet ef database update --project RuneAndRust.Persistence --startup-project RuneAndRust.Terminal
D. Terminal Layer (UI)
Implement the inventory command using Spectre.Console tables to show "Heft" and status.
File: RuneAndRust.Terminal/Services/CommandParser.cs (Snippet)
// Inside ParseAndExecute
if (command == "inventory" || command == "i")
{
    var char = _gameState.CurrentCharacter;
    var table = new Table().Title($"[yellow]Pack (Burden: {_inventoryService.CalculateBurden(char)})[/]");
    table.AddColumns("Name", "Heft", "Quality", "Qty");

    foreach (var slot in char.Inventory)
    {
        var color = GetQualityColor(slot.Item.Quality);
        table.AddRow(
            $"[{color}]{slot.Item.Name}[/]",
            $"{slot.Item.Weight}g",
            slot.Item.Quality.ToString(),
            slot.Quantity.ToString());
    }

    AnsiConsole.Write(table);
}

3. Architecture Decision Tree (v0.1.2)
	•	Q: Should loot be generated at room creation or upon "Search"?
	◦	A: Upon Search. This adheres to the "Lazy Loading" principle. We don't want to fill the DB with millions of items for rooms the player never inspects. When search is called, the LootService rolls against the Room's Danger Level and Biome to create items instantly.
	•	Q: How do we handle Encumbrance penalties?
	◦	A: Soft limits. Instead of a hard "You cannot move," implement Burden States.
	▪	Light: No penalty.
	▪	Heavy: -2 to FINESSE checks (implemented in DiceService later).
	▪	Overburdened: Cannot leave current room (block NavigationService.MoveAsync).
	•	Q: Do we strictly use "Inventory" terminology?
	◦	A: No. Use "Pack", "Heft", and "Bind" in flavor text per the Narrative Voice Guidelines, but keep code readable (InventoryService, EquipAsync).

4. Logging Matrix (v0.1.2)
System
Event
Level
Message Template
Inventory
Item Added
Info
"{Character} added {Item} to pack (Heft: {Weight})"
Inventory
Equip
Info
"{Character} bound {Item} to {Slot}"
Inventory
Burden Change
Warning
"{Character} is now {BurdenState}"
LootGen
Generation
Debug
"Generated loot for Room {RoomId}: {ItemCount} items (Tier {Tier})"
LootGen
Mythic Drop
Warning
"LEGENDARY DROP: {Item} spawned!"

5. v0.1.2 Deliverable Checklist
	•	Core:
	◦	[ ] Item and Equipment entities defined.
	◦	[ ] QualityTier (0-4) and EquipmentSlot enums created.
	◦	[ ] BurdenState enum defined.
	•	Persistence:
	◦	[ ] Database migration applied; Items table exists.
	◦	[ ] InventoryItem join table exists.
	•	Engine:
	◦	[ ] InventoryService calculates weight/burden correctly.
	◦	[ ] LootService generates items with correct Tier scaling (e.g., Tier 0 for simple rooms).
	◦	[ ] StatCalculationService updated to sum bonuses from Character.Equipment.
	•	Terminal:
	◦	[ ] inventory command displays list with colors for Quality.
	◦	[ ] equip <item> moves item from Pack to Equipment list.
	◦	[ ] take command moves item from Room to Pack.
	•	Verification:
	◦	[ ] Spawn a "Heavy Rock" (weight 100000). Pick it up. Verify state changes to "Overburdened". Try to move. Verify movement is blocked.
This completes the Economy & Gear foundation. The next step, v0.1.3, will implement the Data Capture System (The Codex).
Ready to proceed to the Codex?
