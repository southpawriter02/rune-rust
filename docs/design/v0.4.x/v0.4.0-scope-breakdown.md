# v0.4.0 Interactive Objects Foundation - Scope Breakdown

**Version:** 0.4.0
**Theme:** Interactive Objects Foundation
**Prerequisites:** v0.3.2 Complete (Quest Chains & Advanced Features)
**Total Estimated Tests:** ~90 new tests

---

## Executive Summary

The Interactive Objects Foundation version introduces a comprehensive system for environmental interaction within the dungeon. Players can interact with objects like chests, doors, levers, and buttons, creating gameplay depth beyond combat and exploration. This foundational system establishes the core mechanics that traps (v0.4.1), puzzles (v0.4.2), and lighting (v0.4.3) will build upon.

Key focus areas:
- **InteractiveObject Entity**: Base class for all interactable objects with state management
- **Container System**: Chests, crates, and barrels with their own inventories
- **Lock & Key Mechanics**: Keys unlock matching locks, lockpicking as dice-based alternative
- **Activation Objects**: Levers and buttons that trigger effects on other objects
- **Destructible Objects**: Breakable barriers with attack interactions

The work is divided into **three sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.4.0a | Interactive Object Core | Base entity, states, interact command, Room integration | ~35 |
| v0.4.0b | Containers & Locks | Container inventory, keys, locks, lockpicking | ~30 |
| v0.4.0c | Activation & Destruction | Levers, buttons, destructible objects, linked effects | ~25 |

---

## Existing Infrastructure

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| ObjectState enum | `Domain/Enums/ObjectState.cs` | 20+ states: Open, Closed, Locked, Active, etc. |
| InteractiveObjectType enum | `Domain/Enums/InteractiveObjectType.cs` | Door, Chest, Lever, etc. (will expand) |
| InteractiveObjectDescriptor | `Domain/ValueObjects/InteractiveObjectDescriptor.cs` | Multi-depth descriptions |
| ObjectDescriptorService | `Application/Services/ObjectDescriptorService.cs` | Descriptor management |
| ObjectDescriptorContext | `Application/Services/ObjectDescriptorContext.cs` | Descriptor context |
| Room entity | `Domain/Entities/Room.cs` | Will add Interactables collection |
| Item entity | `Domain/Entities/Item.cs` | Key items for locks |
| ItemType enum | `Domain/Enums/ItemType.cs` | Add Key type |
| DiceService | `Application/Services/DiceService.cs` | Lockpicking checks |
| DicePool | `Domain/ValueObjects/DicePool.cs` | Skill check dice |
| SkillCheckService | `Application/Services/SkillCheckService.cs` | Lockpicking skill checks |
| Player.Inventory | `Domain/Entities/Player.cs` | Key storage |
| GameSessionService | `Application/Services/GameSessionService.cs` | Command processing |
| IGameRenderer | `Application/Interfaces/IGameRenderer.cs` | Display output |

### Needs Implementation (v0.4.0)

| Feature | Phase | Notes |
|---------|-------|-------|
| InteractiveObject entity | v0.4.0a | Base class using existing ObjectState & InteractiveObjectType |
| InteractiveObjectType expansion | v0.4.0a | Add: Crate, Barrel, Button, Web, Barrier |
| InteractionType enum | v0.4.0a | Open, Close, Unlock, etc. |
| InteractiveObjectDefinition | v0.4.0a | Configuration |
| Room.Interactables | v0.4.0a | Collection on Room |
| InteractionService | v0.4.0a | Handles interactions |
| ContainerInventory | v0.4.0b | Object-held items |
| LockDefinition | v0.4.0b | Key requirements, difficulty |
| ItemType.Key | v0.4.0b | Key item support |
| ObjectEffect | v0.4.0c | Linked object effects |
| DestructibleProperties | v0.4.0c | Breakable object data |

---

## Feature Analysis & Categorization

### Core System Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| InteractiveObject entity | High | ObjectState, InteractiveObjectType (existing) | **v0.4.0a** |
| InteractiveObjectType expansion | Low | Existing enum | **v0.4.0a** |
| InteractionType enum (NEW) | Low | None | **v0.4.0a** |
| InteractiveObjectDescriptor integration | Low | Existing service | **v0.4.0a** |
| Interact command | Medium | InteractiveObject | **v0.4.0a** |
| Room.Interactables | Medium | Room, InteractiveObject | **v0.4.0a** |
| InteractionService | High | All core types | **v0.4.0a** |
| Object definitions | Medium | Configuration | **v0.4.0a** |

### Container & Lock Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| Containers (chests, crates) | Medium | InteractiveObject | **v0.4.0b** |
| ContainerInventory | Medium | Item | **v0.4.0b** |
| Open/Close commands | Low | ObjectState | **v0.4.0b** |
| Keys | Medium | Item, ItemType | **v0.4.0b** |
| LockDefinition | Medium | None | **v0.4.0b** |
| Locked doors | Medium | InteractiveObject, Lock | **v0.4.0b** |
| Lockpicking | Medium | DiceService, SkillCheck | **v0.4.0b** |
| Unlock command | Low | LockDefinition | **v0.4.0b** |

### Activation & Destruction Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| Levers | Medium | InteractiveObject | **v0.4.0c** |
| Buttons | Medium | InteractiveObject | **v0.4.0c** |
| ObjectEffect (linked effects) | High | InteractiveObject | **v0.4.0c** |
| Destructible objects | Medium | Combat system | **v0.4.0c** |
| Break command/attack | Medium | CombatService | **v0.4.0c** |

---

## Phase Definitions

---

## v0.4.0a: Interactive Object Core

[v0.4.0a Design Specification](v0.4.0a-design-specification.md)

### Overview

Establish the foundational `InteractiveObject` entity with state management, the `interact` command infrastructure, and Room integration. This phase creates the base class that all interactive objects (containers, doors, levers, etc.) will extend.

### Scope

**In Scope:**
- `InteractiveObject` entity with state tracking (uses existing `ObjectState` enum)
- `InteractiveObjectType` enum expansion (add: Crate, Barrel, Button, Web, Barrier)
- `InteractionType` enum (NEW: Open, Close, Unlock, Activate, Deactivate, Break, Search, Examine)
- `InteractiveObjectDefinition` for JSON configuration
- Integration with existing `InteractiveObjectDescriptor` and `ObjectDescriptorService`
- `interact <object>` command
- Room.Interactables collection
- `InteractionService` for handling interactions
- Basic doors (non-locked, passage blockers)
- Object discovery in room descriptions
- Examine integration for interactive objects

**Out of Scope:**
- Container inventories (v0.4.0b)
- Keys and locks (v0.4.0b)
- Lockpicking (v0.4.0b)
- Levers and buttons (v0.4.0c)
- Destructible objects (v0.4.0c)
- Linked effects (v0.4.0c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 1 | `InteractiveObject` |
| Domain Enums | 1 | `InteractionType` (NEW) |
| Domain Enum Updates | 1 | `InteractiveObjectType` expansion |
| Domain Definitions | 1 | `InteractiveObjectDefinition` |
| Application Services | 1 | `InteractionService` |
| Application Interfaces | 1 | `IInteractionService` |
| Commands | 1 | `interact` |
| Configuration | 1 | `interactive-objects.json` |
| Unit Tests | ~35 | Entity, service, command tests |

**Note:** `ObjectState` enum already exists with required states (Open, Closed, Locked, Active, Inactive, Broken, etc.). `InteractiveObjectDescriptor` already exists for multi-depth descriptions.

### InteractiveObject Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents an object in the world that players can interact with.
/// Uses existing ObjectState and InteractiveObjectType enums.
/// </summary>
public class InteractiveObject : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this object.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the definition ID from configuration.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name of this object.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the type of interactive object (uses existing enum).
    /// </summary>
    public InteractiveObjectType ObjectType { get; private set; }

    /// <summary>
    /// Gets the current state of this object (uses existing enum).
    /// </summary>
    public ObjectState State { get; private set; } = ObjectState.Normal;

    /// <summary>
    /// Gets the default state this object starts in.
    /// </summary>
    public ObjectState DefaultState { get; private set; } = ObjectState.Normal;

    /// <summary>
    /// Gets the allowed interaction types for this object.
    /// </summary>
    public IReadOnlyList<InteractionType> AllowedInteractions { get; private set; } = Array.Empty<InteractionType>();

    /// <summary>
    /// Gets whether this object blocks passage (like a closed door).
    /// </summary>
    public bool BlocksPassage { get; private set; }

    /// <summary>
    /// Gets the direction this object blocks (for doors).
    /// </summary>
    public Direction? BlockedDirection { get; private set; }

    /// <summary>
    /// Gets whether this object is currently blocking passage.
    /// </summary>
    public bool IsCurrentlyBlocking => BlocksPassage && (State == ObjectState.Closed || State == ObjectState.Locked);

    /// <summary>
    /// Gets whether this object can be interacted with.
    /// </summary>
    public bool CanInteract => State != ObjectState.Broken && State != ObjectState.Destroyed;

    /// <summary>
    /// Gets whether this object is visible in room descriptions.
    /// </summary>
    public bool IsVisible { get; private set; } = true;

    /// <summary>
    /// Gets keywords that can be used to reference this object.
    /// </summary>
    public IReadOnlyList<string> Keywords { get; private set; } = Array.Empty<string>();

    private InteractiveObject() { }

    /// <summary>
    /// Creates a new interactive object.
    /// </summary>
    public static InteractiveObject Create(
        string definitionId,
        string name,
        InteractiveObjectType objectType,
        ObjectState defaultState,
        IEnumerable<InteractionType> allowedInteractions,
        bool blocksPassage = false,
        Direction? blockedDirection = null,
        IEnumerable<string>? keywords = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(definitionId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new InteractiveObject
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId,
            Name = name,
            ObjectType = objectType,
            State = defaultState,
            DefaultState = defaultState,
            AllowedInteractions = allowedInteractions.ToList(),
            BlocksPassage = blocksPassage,
            BlockedDirection = blockedDirection,
            Keywords = keywords?.ToList() ?? new List<string> { name.ToLowerInvariant() }
        };
    }

    /// <summary>
    /// Attempts to change the object's state.
    /// </summary>
    public bool TrySetState(ObjectState newState)
    {
        if (State == ObjectState.Broken || State == ObjectState.Destroyed)
            return false;

        State = newState;
        return true;
    }

    /// <summary>
    /// Checks if an interaction type is allowed.
    /// </summary>
    public bool CanPerformInteraction(InteractionType type)
    {
        if (!CanInteract) return false;
        return AllowedInteractions.Contains(type);
    }

    /// <summary>
    /// Gets the default interaction for this object based on its current state.
    /// </summary>
    public InteractionType? GetDefaultInteraction()
    {
        return State switch
        {
            ObjectState.Closed => AllowedInteractions.Contains(InteractionType.Open) ? InteractionType.Open : null,
            ObjectState.Open => AllowedInteractions.Contains(InteractionType.Close) ? InteractionType.Close : null,
            ObjectState.Locked => AllowedInteractions.Contains(InteractionType.Unlock) ? InteractionType.Unlock : null,
            ObjectState.Inactive => AllowedInteractions.Contains(InteractionType.Activate) ? InteractionType.Activate : null,
            ObjectState.Active => AllowedInteractions.Contains(InteractionType.Deactivate) ? InteractionType.Deactivate : null,
            ObjectState.Down => AllowedInteractions.Contains(InteractionType.Activate) ? InteractionType.Activate : null,
            ObjectState.Up => AllowedInteractions.Contains(InteractionType.Deactivate) ? InteractionType.Deactivate : null,
            _ => null
        };
    }

    /// <summary>
    /// Checks if a keyword matches this object.
    /// </summary>
    public bool MatchesKeyword(string keyword)
    {
        return Keywords.Any(k => k.Equals(keyword, StringComparison.OrdinalIgnoreCase)) ||
               Name.Contains(keyword, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets the description for this object at a given examination depth.
    /// Integrates with existing InteractiveObjectDescriptor system.
    /// </summary>
    public string GetDescription(ExaminationDepth depth, IObjectDescriptorService descriptorService)
    {
        var descriptor = descriptorService.GetDescriptor(ObjectType, State);
        return descriptor.GetDescription(depth);
    }
}
```

**Integration with Existing InteractiveObjectDescriptor:**

The entity uses the existing `InteractiveObjectDescriptor` value object via the `ObjectDescriptorService` for generating state-aware descriptions at different examination depths (Glance, Look, Examine).

### ObjectState Enum (EXISTING)

**Location:** `Domain/Enums/ObjectState.cs`

The `ObjectState` enum already exists with comprehensive states for interactive objects:

| State | Use Case |
|-------|----------|
| `Normal` | Default state |
| `Open` | Containers, doors |
| `Closed` | Containers, doors |
| `Locked` | Requires key/lockpicking |
| `Barred` | Blocked from other side |
| `Empty` | Container has no contents |
| `Trapped` | Contains a trap |
| `Active` | Mechanisms on |
| `Inactive` | Mechanisms off |
| `Up` / `Down` | Lever positions |
| `Stuck` | Cannot be changed |
| `Broken` / `Destroyed` / `Damaged` | Damage states |
| `Lit` / `Unlit` / `Flickering` | Light sources |

No modifications needed - use as-is.

### InteractiveObjectType Enum (EXPAND)

**Location:** `Domain/Enums/InteractiveObjectType.cs`

**Current values:** Door, Chest, Lever, Statue, Altar, LightSource, Inscription, WaterFeature

**Add these values for v0.4.0:**

```csharp
// Add to existing InteractiveObjectType enum:

/// <summary>A breakable wooden crate.</summary>
Crate,

/// <summary>A storage barrel.</summary>
Barrel,

/// <summary>A momentary push button.</summary>
Button,

/// <summary>A spider web or similar barrier.</summary>
Web,

/// <summary>A generic destructible barrier.</summary>
Barrier
```

### InteractionType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of interactions that can be performed on objects.
/// </summary>
public enum InteractionType
{
    /// <summary>Open a closed object (chest, door).</summary>
    Open,

    /// <summary>Close an open object.</summary>
    Close,

    /// <summary>Unlock a locked object with a key.</summary>
    Unlock,

    /// <summary>Lock an unlocked object with a key.</summary>
    Lock,

    /// <summary>Activate a mechanism (pull lever, press button).</summary>
    Activate,

    /// <summary>Deactivate an active mechanism.</summary>
    Deactivate,

    /// <summary>Break/destroy the object.</summary>
    Break,

    /// <summary>Search the object for hidden items or secrets.</summary>
    Search,

    /// <summary>Examine the object for detailed information.</summary>
    Examine,

    /// <summary>Take items from a container.</summary>
    Take,

    /// <summary>Put items into a container.</summary>
    Put
}
```

### Room Modifications

```
MODIFY: Room
├── ADD: _interactables: List<InteractiveObject>
├── ADD: Interactables: IReadOnlyList<InteractiveObject>
├── ADD: HasInteractables: bool
├── ADD: AddInteractable(InteractiveObject): void
├── ADD: RemoveInteractable(InteractiveObject): bool
├── ADD: GetInteractableByKeyword(string): InteractiveObject?
├── ADD: GetBlockingObject(Direction): InteractiveObject?
└── ADD: GetVisibleInteractables(): IEnumerable<InteractiveObject>
```

### User-Facing Changes

**Commands:**
```
> interact <object>         # Perform default interaction
> interact door             # Open/close a door
> open <object>             # Open a container or door
> close <object>            # Close a container or door
> examine <object>          # Get detailed description
```

**Room Description with Objects:**
```
You are in the Ancient Vault. Dust-covered stone walls
surround a chamber that hasn't been disturbed for centuries.

You notice:
  A heavy iron door (closed) - blocking the north exit
  A weathered wooden chest (closed)
  A rusty lever (inactive)

Exits: south
```

**Interaction Example:**
```
> interact door

You push against the heavy iron door. With a grinding
of ancient hinges, it swings open, revealing a passage
to the north.

The heavy iron door is now open.

---

> interact chest

You lift the lid of the weathered wooden chest.

The weathered wooden chest is now open.
```

### Configuration Example

```json
{
  "$schema": "../schemas/interactive-objects.schema.json",
  "interactiveObjects": [
    {
      "id": "iron-door-basic",
      "name": "Heavy Iron Door",
      "objectType": "Door",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine"],
      "blocksPassage": true,
      "keywords": ["door", "iron door", "heavy door"]
    },
    {
      "id": "wooden-chest-basic",
      "name": "Weathered Wooden Chest",
      "objectType": "Chest",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine", "Search"],
      "keywords": ["chest", "wooden chest", "box"]
    },
    {
      "id": "rusty-lever-basic",
      "name": "Rusty Lever",
      "objectType": "Lever",
      "defaultState": "Down",
      "allowedInteractions": ["Activate", "Examine"],
      "keywords": ["lever", "switch", "mechanism"]
    },
    {
      "id": "wooden-crate-basic",
      "name": "Wooden Crate",
      "objectType": "Crate",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Break", "Examine", "Search"],
      "keywords": ["crate", "box"]
    },
    {
      "id": "spider-web-basic",
      "name": "Giant Spider Web",
      "objectType": "Web",
      "defaultState": "Normal",
      "allowedInteractions": ["Break", "Examine"],
      "blocksPassage": true,
      "keywords": ["web", "spider web", "cobweb"]
    }
  ]
}
```

**Note:** The `objectType` field references the existing `InteractiveObjectType` enum. Descriptions are generated dynamically via `ObjectDescriptorService` based on the object type and current state, using the existing descriptor configuration system.

### Acceptance Criteria

- [ ] InteractiveObject entity stores state and allowed interactions
- [ ] ObjectState enum covers all necessary states
- [ ] InteractionType enum covers all interaction types
- [ ] `interact` command finds objects by keyword
- [ ] `interact` performs default action based on state
- [ ] `open` and `close` commands work on applicable objects
- [ ] Room.Interactables collection works correctly
- [ ] Blocking objects prevent movement until opened
- [ ] Room descriptions list visible interactive objects
- [ ] Configuration loads interactive object definitions
- [ ] ~35 unit tests pass

---

## v0.4.0b: Containers & Locks

[v0.4.0b Design Specification](v0.4.0b-design-specification.md)

### Overview

Implement container inventories so chests and crates can hold items, and add the complete lock and key system including lockpicking as a dice-based skill check.

### Scope

**In Scope:**
- `ContainerInventory` value object for object-held items
- Container capacity limits
- `take` command for removing items from containers
- `put` command for placing items in containers
- `ItemType.Key` addition
- `LockDefinition` value object
- Key matching system (key ID → lock ID)
- `unlock` command with key consumption option
- Lockpicking skill checks via DiceService
- Lock difficulty ratings
- Locked door integration

**Out of Scope:**
- Levers and buttons (v0.4.0c)
- Linked effects (v0.4.0c)
- Destructible objects (v0.4.0c)
- Trapped containers (v0.4.1)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Value Objects | 2 | `ContainerInventory`, `LockDefinition` |
| Entity Updates | 1 | `InteractiveObject` container properties |
| Enum Updates | 1 | Add `Key` to `ItemType` |
| Service Updates | 1 | `InteractionService` lock handling |
| Commands | 3 | `take`, `put`, `unlock` |
| Configuration | 1 | Update `interactive-objects.json` |
| Unit Tests | ~30 | Container, lock, lockpicking tests |

### ContainerInventory Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the inventory contents of a container object.
/// </summary>
public class ContainerInventory
{
    /// <summary>
    /// Gets the items stored in this container.
    /// </summary>
    public IReadOnlyList<Item> Items => _items;
    private readonly List<Item> _items = new();

    /// <summary>
    /// Gets the maximum number of items this container can hold.
    /// </summary>
    public int Capacity { get; private set; }

    /// <summary>
    /// Gets the current number of items in the container.
    /// </summary>
    public int Count => _items.Count;

    /// <summary>
    /// Gets whether the container is empty.
    /// </summary>
    public bool IsEmpty => _items.Count == 0;

    /// <summary>
    /// Gets whether the container is full.
    /// </summary>
    public bool IsFull => _items.Count >= Capacity;

    /// <summary>
    /// Gets the remaining capacity.
    /// </summary>
    public int RemainingCapacity => Math.Max(0, Capacity - _items.Count);

    private ContainerInventory() { }

    /// <summary>
    /// Creates a new container inventory with the specified capacity.
    /// </summary>
    public static ContainerInventory Create(int capacity)
    {
        if (capacity <= 0)
            throw new ArgumentException("Capacity must be positive.", nameof(capacity));

        return new ContainerInventory { Capacity = capacity };
    }

    /// <summary>
    /// Creates an empty container with default capacity.
    /// </summary>
    public static ContainerInventory Empty(int capacity = 10) => Create(capacity);

    /// <summary>
    /// Attempts to add an item to the container.
    /// </summary>
    public bool TryAddItem(Item item)
    {
        if (IsFull) return false;
        if (item == null) return false;

        _items.Add(item);
        return true;
    }

    /// <summary>
    /// Removes an item from the container.
    /// </summary>
    public bool RemoveItem(Item item)
    {
        return _items.Remove(item);
    }

    /// <summary>
    /// Finds an item by name.
    /// </summary>
    public Item? GetItemByName(string name)
    {
        return _items.FirstOrDefault(i =>
            i.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Takes all items from the container.
    /// </summary>
    public IEnumerable<Item> TakeAll()
    {
        var items = _items.ToList();
        _items.Clear();
        return items;
    }

    /// <summary>
    /// Populates the container with items (for initialization).
    /// </summary>
    public void Populate(IEnumerable<Item> items)
    {
        foreach (var item in items)
        {
            if (!TryAddItem(item)) break;
        }
    }
}
```

### LockDefinition Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines the lock properties of an interactive object.
/// </summary>
public readonly record struct LockDefinition
{
    /// <summary>
    /// Gets the lock ID that keys must match.
    /// </summary>
    public string LockId { get; init; }

    /// <summary>
    /// Gets the required key ID to unlock (null if lockpickable only).
    /// </summary>
    public string? RequiredKeyId { get; init; }

    /// <summary>
    /// Gets whether this lock can be picked.
    /// </summary>
    public bool IsLockpickable { get; init; }

    /// <summary>
    /// Gets the lockpicking difficulty (dice check DC).
    /// </summary>
    public int LockpickDC { get; init; }

    /// <summary>
    /// Gets whether the key is consumed when used.
    /// </summary>
    public bool KeyConsumedOnUse { get; init; }

    /// <summary>
    /// Gets whether the lock can be re-locked after opening.
    /// </summary>
    public bool CanRelock { get; init; }

    /// <summary>
    /// Gets an empty lock definition (no lock).
    /// </summary>
    public static LockDefinition None => new()
    {
        LockId = string.Empty,
        RequiredKeyId = null,
        IsLockpickable = false,
        LockpickDC = 0
    };

    /// <summary>
    /// Creates a key-only lock.
    /// </summary>
    public static LockDefinition KeyOnly(string lockId, string keyId, bool consumeKey = false) => new()
    {
        LockId = lockId,
        RequiredKeyId = keyId,
        IsLockpickable = false,
        LockpickDC = 0,
        KeyConsumedOnUse = consumeKey
    };

    /// <summary>
    /// Creates a lockpickable lock.
    /// </summary>
    public static LockDefinition Pickable(string lockId, int dc, string? keyId = null) => new()
    {
        LockId = lockId,
        RequiredKeyId = keyId,
        IsLockpickable = true,
        LockpickDC = dc
    };

    /// <summary>
    /// Checks if a key matches this lock.
    /// </summary>
    public bool KeyMatches(string keyId)
    {
        if (string.IsNullOrEmpty(RequiredKeyId)) return false;
        return RequiredKeyId.Equals(keyId, StringComparison.OrdinalIgnoreCase);
    }
}
```

### InteractiveObject Updates

```
MODIFY: InteractiveObject
├── ADD: ContainerInventory?: ContainerInventory (nullable for non-containers)
├── ADD: IsContainer: bool
├── ADD: Lock: LockDefinition
├── ADD: IsLocked: bool => State == ObjectState.Locked
├── ADD: HasLock: bool => !string.IsNullOrEmpty(Lock.LockId)
├── ADD: TryUnlock(string keyId): UnlockResult
└── ADD: TryLockpick(DiceRollResult roll): LockpickResult
```

### ItemType Update

```csharp
// Add to ItemType enum:

/// <summary>
/// Items used to unlock locked objects.
/// </summary>
Key
```

### Item Key Properties

```
MODIFY: Item
├── ADD: KeyId: string? (the lock ID this key opens)
├── ADD: IsKey: bool => Type == ItemType.Key
└── ADD: IsConsumedOnUse: bool (for single-use keys)
```

### User-Facing Changes

**Commands:**
```
> open chest               # Open a container (if unlocked)
> take sword from chest    # Take specific item from container
> take all from chest      # Take all items from container
> put torch in chest       # Put item in container
> unlock door              # Attempt to unlock with matching key
> unlock chest             # Auto-uses matching key if in inventory
> pick lock on door        # Attempt lockpicking (dice check)
```

**Container Interaction:**
```
> open chest

You open the weathered wooden chest.

Inside you find:
  - Iron Sword
  - Health Potion
  - 25 gold

> take sword from chest

You take the Iron Sword from the chest.

> take all from chest

You take the Health Potion from the chest.
You collect 25 gold from the chest.
The chest is now empty.
```

**Lock Interaction:**
```
> open door

The heavy iron door is locked.

> unlock door

You don't have the key for this lock.

> unlock door
[Player has "Vault Key" in inventory]

You use the Vault Key to unlock the heavy iron door.

---

> pick lock on chest

You attempt to pick the lock...
[Rolling Lockpicking check: DC 12]
Roll: 3d6 + 2 = [4, 3, 6] + 2 = 15

Success! The lock clicks open.

---

> pick lock on chest
[Failed roll]

You attempt to pick the lock...
[Rolling Lockpicking check: DC 12]
Roll: 3d6 + 2 = [2, 1, 3] + 2 = 8

The lock resists your attempt.
```

### Configuration Example

```json
{
  "interactiveObjects": [
    {
      "id": "locked-chest-vault",
      "name": "Iron-Bound Vault Chest",
      "description": "A sturdy chest reinforced with iron bands. A complex lock guards its contents.",
      "defaultState": "Locked",
      "allowedInteractions": ["Open", "Close", "Unlock", "Examine", "Take"],
      "isContainer": true,
      "containerCapacity": 15,
      "lock": {
        "lockId": "vault-chest-lock",
        "requiredKeyId": "vault-key",
        "isLockpickable": true,
        "lockpickDC": 14
      },
      "contents": [
        { "itemId": "gold", "quantity": 50 },
        { "itemId": "health-potion" },
        { "itemId": "enchanted-ring" }
      ]
    },
    {
      "id": "vault-door",
      "name": "Vault Door",
      "description": "A massive iron door protecting the inner vault. It won't budge without the proper key.",
      "defaultState": "Locked",
      "allowedInteractions": ["Open", "Close", "Unlock", "Examine"],
      "blocksPassage": true,
      "blockedDirection": "North",
      "lock": {
        "lockId": "vault-door-lock",
        "requiredKeyId": "master-vault-key",
        "isLockpickable": false
      }
    }
  ],
  "keys": [
    {
      "id": "vault-key",
      "name": "Vault Key",
      "description": "A small brass key with intricate teeth.",
      "opensLockId": "vault-chest-lock"
    },
    {
      "id": "master-vault-key",
      "name": "Master Vault Key",
      "description": "A large iron key bearing the seal of the vault keeper.",
      "opensLockId": "vault-door-lock"
    }
  ]
}
```

### Acceptance Criteria

- [ ] ContainerInventory holds items with capacity limits
- [ ] Containers can be opened to reveal contents
- [ ] `take` command removes items from containers
- [ ] `take all` empties container contents
- [ ] `put` command adds items to containers
- [ ] Keys are a new ItemType
- [ ] Keys have associated lock IDs
- [ ] `unlock` command uses matching key from inventory
- [ ] Lockpicking performs dice check against DC
- [ ] Successful lockpick unlocks object
- [ ] Failed lockpick keeps object locked
- [ ] Locked objects cannot be opened without unlock
- [ ] ~30 unit tests pass

---

## v0.4.0c: Activation & Destruction

[v0.4.0c Design Specification](v0.4.0c-design-specification.md)

### Overview

Implement levers and buttons that can trigger effects on other objects, and add destructible objects that can be broken through combat.

### Scope

**In Scope:**
- Levers (toggle state on activation)
- Buttons (momentary activation, auto-reset)
- `ObjectEffect` value object for linked effects
- Effect types: OpenTarget, CloseTarget, UnlockTarget, ToggleTarget
- Effect triggering when activation objects change state
- Destructible objects with HP
- Breaking objects through attack command
- Breakable barriers (webs, crates, wooden doors)
- Loot drops from broken objects

**Out of Scope:**
- Traps (v0.4.1)
- Complex puzzles (v0.4.2)
- Timed effects (v0.4.2)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Value Objects | 2 | `ObjectEffect`, `DestructibleProperties` |
| Enums | 1 | `EffectType` |
| Entity Updates | 1 | InteractiveObject activation/destruction |
| Service Updates | 2 | InteractionService, CombatService integration |
| Commands | 1 | `break` (or attack redirect) |
| Configuration | 1 | Update definitions |
| Unit Tests | ~25 | Activation, destruction, effect tests |

### ObjectEffect Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines an effect that occurs when an interactive object changes state.
/// </summary>
public readonly record struct ObjectEffect
{
    /// <summary>
    /// Gets the effect type.
    /// </summary>
    public EffectType Type { get; init; }

    /// <summary>
    /// Gets the target object ID affected by this effect.
    /// </summary>
    public string TargetObjectId { get; init; }

    /// <summary>
    /// Gets the triggering state (effect happens when source enters this state).
    /// </summary>
    public ObjectState TriggerOnState { get; init; }

    /// <summary>
    /// Gets the delay in turns before the effect triggers (0 = immediate).
    /// </summary>
    public int DelayTurns { get; init; }

    /// <summary>
    /// Gets the message displayed when this effect triggers.
    /// </summary>
    public string? EffectMessage { get; init; }

    /// <summary>
    /// Creates an immediate open effect.
    /// </summary>
    public static ObjectEffect OpenTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.OpenTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        EffectMessage = message
    };

    /// <summary>
    /// Creates an immediate close effect.
    /// </summary>
    public static ObjectEffect CloseTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.CloseTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        EffectMessage = message
    };

    /// <summary>
    /// Creates an unlock effect.
    /// </summary>
    public static ObjectEffect UnlockTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.UnlockTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        EffectMessage = message
    };

    /// <summary>
    /// Creates a toggle effect.
    /// </summary>
    public static ObjectEffect ToggleTarget(string targetId, ObjectState triggerOn, string? message = null) => new()
    {
        Type = EffectType.ToggleTarget,
        TargetObjectId = targetId,
        TriggerOnState = triggerOn,
        EffectMessage = message
    };
}
```

### EffectType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of effects that can be triggered by interactive objects.
/// </summary>
public enum EffectType
{
    /// <summary>Opens the target object.</summary>
    OpenTarget,

    /// <summary>Closes the target object.</summary>
    CloseTarget,

    /// <summary>Unlocks the target object.</summary>
    UnlockTarget,

    /// <summary>Locks the target object.</summary>
    LockTarget,

    /// <summary>Toggles the target between open/closed or active/inactive.</summary>
    ToggleTarget,

    /// <summary>Activates the target object.</summary>
    ActivateTarget,

    /// <summary>Deactivates the target object.</summary>
    DeactivateTarget,

    /// <summary>Destroys/breaks the target object.</summary>
    DestroyTarget,

    /// <summary>Reveals a hidden object.</summary>
    RevealTarget,

    /// <summary>Displays a message (no state change).</summary>
    Message
}
```

### DestructibleProperties Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Properties for objects that can be destroyed through damage.
/// </summary>
public class DestructibleProperties
{
    /// <summary>
    /// Gets the maximum hit points of this object.
    /// </summary>
    public int MaxHP { get; private set; }

    /// <summary>
    /// Gets the current hit points.
    /// </summary>
    public int CurrentHP { get; private set; }

    /// <summary>
    /// Gets whether this object is destroyed.
    /// </summary>
    public bool IsDestroyed => CurrentHP <= 0;

    /// <summary>
    /// Gets the defense/armor of this object.
    /// </summary>
    public int Defense { get; private set; }

    /// <summary>
    /// Gets damage type vulnerabilities (deal extra damage).
    /// </summary>
    public IReadOnlyList<string> Vulnerabilities { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets damage type resistances (deal reduced damage).
    /// </summary>
    public IReadOnlyList<string> Resistances { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets damage type immunities (deal no damage).
    /// </summary>
    public IReadOnlyList<string> Immunities { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the loot dropped when destroyed.
    /// </summary>
    public string? LootTableId { get; private set; }

    private DestructibleProperties() { }

    /// <summary>
    /// Creates destructible properties.
    /// </summary>
    public static DestructibleProperties Create(
        int maxHP,
        int defense = 0,
        IEnumerable<string>? vulnerabilities = null,
        IEnumerable<string>? resistances = null,
        IEnumerable<string>? immunities = null,
        string? lootTableId = null)
    {
        return new DestructibleProperties
        {
            MaxHP = maxHP,
            CurrentHP = maxHP,
            Defense = defense,
            Vulnerabilities = vulnerabilities?.ToList() ?? Array.Empty<string>(),
            Resistances = resistances?.ToList() ?? Array.Empty<string>(),
            Immunities = immunities?.ToList() ?? Array.Empty<string>(),
            LootTableId = lootTableId
        };
    }

    /// <summary>
    /// Applies damage to this object.
    /// </summary>
    public int TakeDamage(int amount, string? damageType = null)
    {
        if (IsDestroyed) return 0;

        var finalDamage = amount;

        if (!string.IsNullOrEmpty(damageType))
        {
            if (Immunities.Contains(damageType, StringComparer.OrdinalIgnoreCase))
                return 0;

            if (Resistances.Contains(damageType, StringComparer.OrdinalIgnoreCase))
                finalDamage = amount / 2;

            if (Vulnerabilities.Contains(damageType, StringComparer.OrdinalIgnoreCase))
                finalDamage = amount * 2;
        }

        finalDamage = Math.Max(0, finalDamage - Defense);
        CurrentHP = Math.Max(0, CurrentHP - finalDamage);

        return finalDamage;
    }
}
```

### InteractiveObject Updates

```
MODIFY: InteractiveObject
├── ADD: Effects: IReadOnlyList<ObjectEffect>
├── ADD: Destructible: DestructibleProperties?
├── ADD: IsDestructible: bool
├── ADD: IsButton: bool (auto-resets after activation)
├── ADD: ResetDelay: int (turns before button resets)
├── ADD: TakeDamage(int, string?): int
└── ADD: GetTriggeredEffects(ObjectState): IEnumerable<ObjectEffect>
```

### User-Facing Changes

**Lever Interaction:**
```
> interact lever

You pull the rusty lever. With a grinding of gears,
something shifts in the room.

You hear a click as the iron door to the north unlocks.

---

> interact lever

You push the lever back to its original position.

The iron door to the north locks again.
```

**Button Interaction:**
```
> interact button

You press the stone button. It clicks and holds for a moment.

The secret passage to the east slides open!

[After 3 turns]
The stone button resets with a soft click.
The secret passage slides closed.
```

**Destructible Objects:**
```
> look

You are in the Webbed Corridor. Thick spider webs
block your path forward.

You notice:
  Giant Spider Web (blocking north) [Destructible]

> attack web

You slash at the Giant Spider Web!
Damage: 8

The web tears and collapses!

The path to the north is now clear.
Exits: north, south

---

> attack crate

You strike the Wooden Crate!
Damage: 12

The crate splinters apart!

You find:
  - 3x Torch
  - Rope (50 ft)
```

### Configuration Example

```json
{
  "interactiveObjects": [
    {
      "id": "wall-lever",
      "name": "Rusty Wall Lever",
      "description": "An old lever mounted on the wall. It looks connected to something.",
      "defaultState": "Inactive",
      "allowedInteractions": ["Activate", "Deactivate", "Examine"],
      "effects": [
        {
          "type": "UnlockTarget",
          "targetObjectId": "vault-door",
          "triggerOnState": "Active",
          "message": "You hear a click as the vault door unlocks."
        },
        {
          "type": "LockTarget",
          "targetObjectId": "vault-door",
          "triggerOnState": "Inactive",
          "message": "The vault door locks again."
        }
      ]
    },
    {
      "id": "stone-button",
      "name": "Stone Button",
      "description": "A round stone button set into the wall.",
      "defaultState": "Inactive",
      "allowedInteractions": ["Activate", "Examine"],
      "isButton": true,
      "resetDelay": 3,
      "effects": [
        {
          "type": "OpenTarget",
          "targetObjectId": "secret-passage",
          "triggerOnState": "Active",
          "message": "A hidden passage slides open!"
        },
        {
          "type": "CloseTarget",
          "targetObjectId": "secret-passage",
          "triggerOnState": "Inactive",
          "message": "The passage slides closed."
        }
      ]
    },
    {
      "id": "spider-web-barrier",
      "name": "Giant Spider Web",
      "description": "A thick barrier of sticky spider silk blocking the passage.",
      "defaultState": "Active",
      "allowedInteractions": ["Break", "Examine"],
      "blocksPassage": true,
      "blockedDirection": "North",
      "destructible": {
        "maxHP": 15,
        "defense": 0,
        "vulnerabilities": ["fire", "slashing"],
        "resistances": ["bludgeoning"],
        "immunities": ["poison"]
      }
    },
    {
      "id": "wooden-crate",
      "name": "Wooden Crate",
      "description": "A simple wooden storage crate.",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Break", "Examine", "Search"],
      "isContainer": true,
      "containerCapacity": 5,
      "destructible": {
        "maxHP": 10,
        "defense": 0,
        "vulnerabilities": ["fire"],
        "lootTableId": "crate-loot-common"
      }
    }
  ]
}
```

### Acceptance Criteria

- [ ] Levers toggle between Active/Inactive states
- [ ] Buttons activate then auto-reset after delay
- [ ] ObjectEffects trigger when source changes state
- [ ] Effects correctly modify target object states
- [ ] Effect messages display to player
- [ ] Destructible objects have HP tracking
- [ ] Attack command works on destructible objects
- [ ] Damage applies vulnerabilities/resistances
- [ ] Destroyed objects change to Broken state
- [ ] Destroyed barriers no longer block passage
- [ ] Destroyed containers drop loot
- [ ] ~25 unit tests pass

---

## Dependencies & Prerequisites

```
v0.3.2 (Quest Chains) - REQUIRED
    │
    ├── Quest system ────────────────────┐
    ├── Player inventory ────────────────┤
    ├── DiceService ─────────────────────┤
    └── SkillCheckService ───────────────┘
                                         │
                                         ▼
v0.4.0 (Interactive Objects)
    │
    ├── v0.4.0a: Interactive Object Core ────────────┐
    │       Dependencies: Room, Direction, Player     │
    │       Provides: InteractiveObject, ObjectState  │
    │                 InteractionService              │
    │                                                 │
    ├── v0.4.0b: Containers & Locks ─────────────────┤
    │       Dependencies: v0.4.0a, Item, DiceService  │
    │       Provides: ContainerInventory, LockDef     │
    │                                                 │
    └── v0.4.0c: Activation & Destruction ───────────┘
            Dependencies: v0.4.0a, v0.4.0b, CombatService
            Provides: ObjectEffect, DestructibleProperties
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.4.0a | ~8 | ~5 | ~35 | High |
| v0.4.0b | ~4 | ~6 | ~30 | Medium |
| v0.4.0c | ~4 | ~4 | ~25 | Medium |
| **Total** | **~16** | **~15** | **~90** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Complex object state management | High | Medium | Clear state machine, thorough testing |
| Effect chain loops | High | Low | Detect cycles, limit effect depth |
| Performance with many objects | Medium | Low | Lazy loading, spatial indexing |
| Command parsing ambiguity | Medium | Medium | Clear keyword matching, disambiguation prompts |
| Container inventory overflow | Low | Medium | Capacity checks, rejection messages |

---

## Design Decisions (Confirmed)

### Existing Infrastructure Usage

| Decision | Value | Notes |
|----------|-------|-------|
| **ObjectState enum** | Use existing (no changes) | Already has 20+ states covering all needs |
| **InteractiveObjectType enum** | Expand existing | Add: Crate, Barrel, Button, Web, Barrier |
| **InteractiveObjectDescriptor** | Use existing | Provides multi-depth descriptions |
| **ObjectDescriptorService** | Use existing | Generates descriptions by type/state |

### Object Architecture

| Decision | Value | Notes |
|----------|-------|-------|
| **Object Storage** | Room.Interactables collection | Per-room object lists |
| **Object Lookup** | Keyword matching | Case-insensitive, supports aliases |
| **State Model** | Existing ObjectState enum | Already covers all object types |
| **Definition Pattern** | JSON configuration | InteractiveObjectDefinition |
| **Descriptions** | Via ObjectDescriptorService | Dynamic based on type and state |

### Lock System

| Decision | Value | Notes |
|----------|-------|-------|
| **Key Matching** | Key.KeyId → Lock.RequiredKeyId | String-based matching |
| **Lockpicking** | Dice check vs DC | Uses existing DiceService |
| **Key Consumption** | Configurable per key | Default: not consumed |
| **Auto-Use Keys** | Yes | Inventory searched automatically |

### Effect System

| Decision | Value | Notes |
|----------|-------|-------|
| **Effect Scope** | Same room only | Cross-room effects future |
| **Effect Timing** | Immediate (turn 0) | Delayed effects for v0.4.2 |
| **Chain Depth** | Max 5 effects | Prevent infinite loops |

---

## Integration Points

### From Prior Versions
- **ObjectState enum** - Use existing states (Open, Closed, Locked, Active, etc.)
- **InteractiveObjectType enum** - Expand with new types
- **InteractiveObjectDescriptor** - Use for state-aware descriptions
- **ObjectDescriptorService** - Generate descriptions by type and state
- **Room entity** - Add Interactables collection
- **Item entity** - Key items for locks
- **DiceService** - Lockpicking checks
- **SkillCheckService** - Skill-based lockpicking
- **CombatService** - Destruction damage

### To v0.4.1 (Traps & Hazards)
- InteractiveObject base for trap triggers
- ObjectEffect for trap activation
- DestructibleProperties for breakable traps

### To v0.4.2 (Puzzles)
- Levers and buttons for puzzle mechanics
- ObjectEffect chains for puzzle solutions
- State tracking for sequence puzzles

### To v0.4.3 (Light & Skills)
- Light sources as interactive objects
- Skill-based lockpicking integration

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.4.0a Design Spec** - Create detailed design specification
3. **Implement v0.4.0a** - Build interactive object core
4. **v0.4.0b Design Spec** - Container and lock details
5. **Implement v0.4.0b** - Build containers and locks
6. **Implement v0.4.0c** - Build activation and destruction

---

*This scope breakdown provides a structured approach to implementing v0.4.0 Interactive Objects Foundation. Each sub-phase builds on the previous, establishing the core environmental interaction system that traps, puzzles, and lighting will extend.*
