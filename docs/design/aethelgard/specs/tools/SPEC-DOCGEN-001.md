# SPEC-DOCGEN-001: Documentation Generator (Developer's Handbook)

**Version:** 1.0.0 (v0.3.11b)
**Status:** Implemented
**Last Updated:** 2025-12-25
**Author:** The Architect
**Implementation:** `RuneAndRust.Engine/Services/DocGenService.cs`
**Tests:** `RuneAndRust.Tests/Engine/DocGenServiceTests.cs` (9 tests)

---

## Table of Contents

1. [Overview](#overview)
2. [Core Concepts](#core-concepts)
3. [Behaviors](#behaviors)
4. [Restrictions](#restrictions)
5. [Limitations](#limitations)
6. [Use Cases](#use-cases)
7. [Decision Trees](#decision-trees)
8. [Cross-System Integration](#cross-system-integration)
9. [Data Models](#data-models)
10. [Configuration](#configuration)
11. [Testing](#testing)
12. [Design Rationale](#design-rationale)
13. [Changelog](#changelog)

---

## Overview

The **Documentation Generator** (`DocGenService`) is a CLI-based documentation export tool that generates Markdown files from the Dynamic Knowledge Engine. It transforms runtime `CodexEntry` objects from `LibraryService` into structured Markdown files suitable for external wikis, GitHub documentation, or developer handbooks.

### Purpose

- **CLI Documentation Export**: Generate Markdown files via `--docgen` command-line flag
- **Category-Based Organization**: Output one file per `EntryCategory` plus README index
- **Automatic Synchronization**: Documentation regenerated from current codebase annotations
- **External Publishing**: Produce files suitable for GitHub wikis, static sites, or documentation platforms

### Key Features

1. **CLI Integration**:
   - `--docgen` flag triggers documentation generation
   - Hardcoded output path: `docs/generated/`
   - Early exit after generation (no game loop started)

2. **Output Structure**:
   ```
   docs/generated/
   ├── README.md           (index with category links)
   ├── FieldGuide.md       (FieldGuide entries)
   ├── Bestiary.md         (Bestiary entries)
   └── {Category}.md       (one file per category with entries)
   ```

3. **Markdown Generation**:
   - Category files with H1 header, table of entries, footer
   - README index with overview, category links, usage instructions
   - Automatic escaping of pipes and newlines in table cells

4. **LibraryService Integration**:
   - Consumes `ILibraryService.GetSystemEntries()` for entry retrieval
   - Groups entries by `EntryCategory` for file organization
   - Alphabetical sorting within categories

### System Context

**DocGenService** is a **developer tool** that runs outside the normal game loop. It generates static documentation files that can be committed to version control or published to external platforms.

**Dependencies**:
- `ILibraryService` - Provides system entries from `[GameDocument]` attributes
- `ILogger<DocGenService>` - Structured logging
- `System.IO` - File system operations

**Dependents**:
- CLI (`--docgen` flag) - Triggers documentation generation
- External wikis/documentation platforms - Consume generated Markdown files

---

## Core Concepts

### CLI Integration

**Purpose**: Enable documentation generation from command line without starting the game.

**Usage**:
```bash
dotnet run --project RuneAndRust.Terminal -- --docgen
```

**Program.cs Integration**:
```csharp
// RuneAndRust.Terminal/Program.cs (lines 235-248)
if (args.Contains("--docgen"))
{
    var docGenService = serviceProvider.GetRequiredService<IDocGenService>();
    var outputPath = Path.Combine(Directory.GetCurrentDirectory(), "docs", "generated");

    await docGenService.GenerateDocsAsync(outputPath);

    Console.WriteLine($"Documentation generated at: {outputPath}");
    return 0; // Exit without starting game
}
```

**Behavior**:
1. Check `args` for `--docgen` flag
2. Resolve `IDocGenService` from DI container
3. Call `GenerateDocsAsync` with output path
4. Print success message
5. Exit with code 0 (skip game loop)

### Output File Structure

**Directory**: `docs/generated/`

**Files Generated**:
| File | Content | Purpose |
|------|---------|---------|
| `README.md` | Index with category links | Entry point for documentation |
| `{Category}.md` | Entries for single category | Category-specific reference |

**README.md Structure**:
```markdown
# Rune & Rust - Field Guide

> Auto-generated documentation from game source code.
> Last updated: 2025-12-23

## Categories

- [FieldGuide](./FieldGuide.md) (52 entries)
- [Bestiary](./Bestiary.md) (12 entries)
- [BlightOrigin](./BlightOrigin.md) (5 entries)

## Usage

This documentation is generated from `[GameDocument]` attributes in the codebase.
Run `dotnet run -- --docgen` to regenerate.
```

**Category File Structure**:
```markdown
# FieldGuide

> 52 entries in this category

| Title | Description |
|-------|-------------|
| Attack Types | The various attack styles available in combat. |
| Bludgeoning Damage | Impact force from blunt weapons. |
| ... | ... |

---
*Generated by DocGenService*
```

### Markdown Escaping

**Purpose**: Ensure table cell content doesn't break Markdown table syntax.

**Escaped Characters**:
| Character | Escape | Reason |
|-----------|--------|--------|
| `\|` (pipe) | `\|` | Would create extra column |
| `\n` (newline) | `<br>` | Would break row |
| `\r` (carriage return) | (removed) | Control character |

**Implementation**:
```csharp
private static string EscapeMarkdownTableCell(string content)
{
    if (string.IsNullOrEmpty(content)) return content;

    return content
        .Replace("|", "\\|")
        .Replace("\r", "")
        .Replace("\n", "<br>");
}
```

---

## Behaviors

### 1. Generate Documentation (`GenerateDocsAsync`)

**Signature**: `Task GenerateDocsAsync(string outputPath)`

**Purpose**: Generate all Markdown files from LibraryService entries.

**Behavior**:
```csharp
public async Task GenerateDocsAsync(string outputPath)
{
    _logger.LogInformation("[DocGen] Starting documentation generation to {Path}", outputPath);

    // 1. Ensure output directory exists
    Directory.CreateDirectory(outputPath);

    // 2. Get all system entries
    var entries = _libraryService.GetSystemEntries().ToList();
    _logger.LogDebug("[DocGen] Retrieved {Count} entries from LibraryService", entries.Count);

    // 3. Group by category
    var grouped = entries
        .GroupBy(e => e.Category)
        .OrderBy(g => g.Key.ToString())
        .ToList();

    // 4. Generate category files
    foreach (var group in grouped)
    {
        var categoryPath = Path.Combine(outputPath, $"{group.Key}.md");
        var content = GenerateCategoryMarkdown(group.Key, group.ToList());
        await File.WriteAllTextAsync(categoryPath, content);

        _logger.LogDebug("[DocGen] Generated {Path} with {Count} entries",
            categoryPath, group.Count());
    }

    // 5. Generate README index
    var readmePath = Path.Combine(outputPath, "README.md");
    var readmeContent = GenerateReadmeMarkdown(grouped);
    await File.WriteAllTextAsync(readmePath, readmeContent);

    _logger.LogInformation("[DocGen] Documentation generation complete. {FileCount} files created.",
        grouped.Count + 1);
}
```

**Parameters**:
| Parameter | Type | Description |
|-----------|------|-------------|
| `outputPath` | `string` | Directory path for generated files |

**Files Created**:
- One `{Category}.md` per entry category
- One `README.md` index file

**Logging**:
- **Information**: Start and completion with file count
- **Debug**: Entry retrieval count, individual file generation

---

### 2. Generate Category Markdown (`GenerateCategoryMarkdown`)

**Purpose**: Create Markdown content for a single category file.

**Behavior**:
```csharp
private string GenerateCategoryMarkdown(EntryCategory category, List<CodexEntry> entries)
{
    var sb = new StringBuilder();

    // Header
    sb.AppendLine($"# {category}");
    sb.AppendLine();
    sb.AppendLine($"> {entries.Count} entries in this category");
    sb.AppendLine();

    // Table header
    sb.AppendLine("| Title | Description |");
    sb.AppendLine("|-------|-------------|");

    // Table rows (sorted alphabetically)
    foreach (var entry in entries.OrderBy(e => e.Title))
    {
        var title = EscapeMarkdownTableCell(entry.Title);
        var description = EscapeMarkdownTableCell(entry.FullText);
        sb.AppendLine($"| {title} | {description} |");
    }

    // Footer
    sb.AppendLine();
    sb.AppendLine("---");
    sb.AppendLine("*Generated by DocGenService*");

    return sb.ToString();
}
```

**Output Format**:
```markdown
# FieldGuide

> 52 entries in this category

| Title | Description |
|-------|-------------|
| Attack Types | The various attack styles available in combat. |
| Bludgeoning Damage | Impact force from blunt weapons. |

---
*Generated by DocGenService*
```

---

### 3. Generate README Markdown (`GenerateReadmeMarkdown`)

**Purpose**: Create index file with category links and overview.

**Behavior**:
```csharp
private string GenerateReadmeMarkdown(List<IGrouping<EntryCategory, CodexEntry>> grouped)
{
    var sb = new StringBuilder();

    // Header
    sb.AppendLine("# Rune & Rust - Field Guide");
    sb.AppendLine();
    sb.AppendLine("> Auto-generated documentation from game source code.");
    sb.AppendLine($"> Last updated: {DateTime.Now:yyyy-MM-dd}");
    sb.AppendLine();

    // Category links
    sb.AppendLine("## Categories");
    sb.AppendLine();

    foreach (var group in grouped)
    {
        sb.AppendLine($"- [{group.Key}](./{group.Key}.md) ({group.Count()} entries)");
    }

    sb.AppendLine();

    // Usage instructions
    sb.AppendLine("## Usage");
    sb.AppendLine();
    sb.AppendLine("This documentation is generated from `[GameDocument]` attributes in the codebase.");
    sb.AppendLine("Run `dotnet run -- --docgen` to regenerate.");
    sb.AppendLine();

    // Footer
    sb.AppendLine("---");
    sb.AppendLine("*Generated by DocGenService*");

    return sb.ToString();
}
```

**Output Format**:
```markdown
# Rune & Rust - Field Guide

> Auto-generated documentation from game source code.
> Last updated: 2025-12-23

## Categories

- [FieldGuide](./FieldGuide.md) (52 entries)
- [Bestiary](./Bestiary.md) (12 entries)

## Usage

This documentation is generated from `[GameDocument]` attributes in the codebase.
Run `dotnet run -- --docgen` to regenerate.

---
*Generated by DocGenService*
```

---

### 4. Escape Markdown Table Cells (`EscapeMarkdownTableCell`)

**Purpose**: Sanitize content for safe inclusion in Markdown tables.

**Behavior**:
```csharp
private static string EscapeMarkdownTableCell(string content)
{
    if (string.IsNullOrEmpty(content)) return content;

    return content
        .Replace("|", "\\|")    // Escape pipe characters
        .Replace("\r", "")       // Remove carriage returns
        .Replace("\n", "<br>"); // Convert newlines to HTML breaks
}
```

**Examples**:
| Input | Output |
|-------|--------|
| `"Normal text"` | `"Normal text"` |
| `"Has \| pipe"` | `"Has \\| pipe"` |
| `"Line 1\nLine 2"` | `"Line 1<br>Line 2"` |
| `"Mixed\|and\nnew"` | `"Mixed\\|and<br>new"` |

---

## Restrictions

### Hard Constraints (MUST NOT Violate)

1. **MUST NOT start game loop**:
   - `--docgen` flag triggers early exit after generation
   - No player session, no database connections beyond documentation

2. **MUST NOT modify source code**:
   - DocGenService is read-only (generates files from existing entries)
   - No attribute modification or code generation

3. **MUST create output directory if missing**:
   - `Directory.CreateDirectory(outputPath)` called before file writes
   - Supports fresh clone scenarios

4. **MUST escape Markdown table special characters**:
   - Pipes (`|`) escaped to prevent column breaks
   - Newlines converted to `<br>` for row integrity

5. **MUST use LibraryService as sole data source**:
   - No direct database queries for documentation
   - All entries from `[GameDocument]` attributes via LibraryService

### Soft Constraints (SHOULD Follow)

1. **SHOULD log file generation at Debug level**:
   - Individual file paths and entry counts
   - Helps diagnose missing categories

2. **SHOULD sort entries alphabetically within categories**:
   - Improves documentation readability
   - Consistent ordering across regenerations

3. **SHOULD include generation timestamp in README**:
   - Helps identify stale documentation
   - `DateTime.Now:yyyy-MM-dd` format

---

## Limitations

### Design Limitations

1. **No Incremental Generation**:
   - Full regeneration on each run
   - No diffing or partial updates

2. **No Custom Templates**:
   - Hardcoded Markdown format
   - Cannot customize table layout or styling

3. **No Image/Media Export**:
   - Text-only documentation
   - No asset copying or embedding

4. **No Localization Support**:
   - Single language output (source language)
   - No multi-language documentation generation

5. **Hardcoded Output Path**:
   - CLI uses `docs/generated/` relative to working directory
   - No command-line path override

### Performance Limitations

1. **Synchronous File Writes**:
   - Uses `File.WriteAllTextAsync` but processes categories sequentially
   - Could be parallelized for large documentation sets

2. **Full Entry Scan**:
   - Loads all entries into memory before grouping
   - Large entry sets may increase memory usage

---

## Use Cases

### UC-DOCGEN-01: Generate Documentation from CLI

**Scenario**: Developer runs documentation generation before release.

**Pre-Conditions**:
- LibraryService has 75+ entries across 6 categories
- `docs/generated/` directory may or may not exist

**Execution**:
```bash
dotnet run --project RuneAndRust.Terminal -- --docgen
```

**Output**:
```
Documentation generated at: /path/to/project/docs/generated
```

**Post-Conditions**:
- 7 files created (6 category files + README.md)
- Application exits with code 0

---

### UC-DOCGEN-02: Regenerate After Code Changes

**Scenario**: Developer adds new `[GameDocument]` attributes and regenerates.

**Pre-Conditions**:
- Previous documentation exists in `docs/generated/`
- New entries added to `AttackType` enum

**Execution**:
```bash
dotnet run -- --docgen
```

**Post-Conditions**:
- Files overwritten with new content
- New entries appear in FieldGuide.md
- README timestamp updated

---

### UC-DOCGEN-03: Fresh Clone Documentation

**Scenario**: New developer clones repository without docs/generated directory.

**Pre-Conditions**:
- `docs/generated/` directory does not exist
- LibraryService functional

**Execution**:
```bash
dotnet run -- --docgen
```

**Post-Conditions**:
- Directory created automatically
- All documentation files generated
- Ready for use/publication

---

## Decision Trees

### Decision Tree 1: CLI Argument Processing

```
Input: Program arguments (args[])
│
├─ Contains "--docgen"?
│  │
│  ├─ YES → Resolve IDocGenService
│  │  └─ Call GenerateDocsAsync("docs/generated")
│  │  └─ Print success message
│  │  └─ Return 0 (exit without game)
│  │
│  └─ NO → Continue to normal game startup
```

---

### Decision Tree 2: File Generation Flow

```
Input: GenerateDocsAsync(outputPath)
│
├─ Create output directory (if missing)
│
├─ Get all entries from LibraryService
│
├─ Group entries by category
│  └─ OrderBy(category name)
│
├─ For each category group:
│  └─ Generate category Markdown
│  └─ Write to {Category}.md
│
├─ Generate README Markdown
│  └─ Include category links with counts
│  └─ Write to README.md
│
└─ Log completion with file count
```

---

## Cross-System Integration

### Integration 1: LibraryService (Data Source)

**Relationship**: `DocGenService` → `ILibraryService`

**Integration Points**:

1. **Entry Retrieval**:
   ```csharp
   var entries = _libraryService.GetSystemEntries();
   ```

2. **Category Grouping**:
   ```csharp
   var grouped = entries.GroupBy(e => e.Category);
   ```

**Data Flow**:
- LibraryService scans assembly for `[GameDocument]` attributes
- DocGenService consumes entries and generates Markdown
- No bidirectional dependency

---

### Integration 2: CLI (Trigger)

**Relationship**: `Program.cs` → `DocGenService`

**Integration Points**:

1. **Flag Detection**:
   ```csharp
   if (args.Contains("--docgen"))
   ```

2. **Service Resolution**:
   ```csharp
   var docGenService = serviceProvider.GetRequiredService<IDocGenService>();
   ```

3. **Generation Trigger**:
   ```csharp
   await docGenService.GenerateDocsAsync(outputPath);
   ```

**Data Flow**:
- CLI parses arguments
- Triggers DocGenService if flag present
- Exits without starting game

---

## Data Models

### Interface: IDocGenService

**Purpose**: Contract for documentation generation service.

**Definition**:
```csharp
public interface IDocGenService
{
    Task GenerateDocsAsync(string outputPath);
}
```

**Methods**:
| Method | Parameters | Return | Description |
|--------|------------|--------|-------------|
| `GenerateDocsAsync` | `string outputPath` | `Task` | Generate all Markdown files |

---

### Input: CodexEntry (from LibraryService)

**See [SPEC-LIBRARY-001: Data Models](./SPEC-LIBRARY-001.md#data-models)** for CodexEntry structure.

**Used Properties**:
| Property | Usage in DocGenService |
|----------|----------------------|
| `Title` | Table row first column |
| `FullText` | Table row second column (Description) |
| `Category` | File grouping, README links |

---

## Configuration

### Hardcoded Values

**Output Path** (CLI):
```csharp
var outputPath = Path.Combine(Directory.GetCurrentDirectory(), "docs", "generated");
```

**README Timestamp Format**:
```csharp
$"> Last updated: {DateTime.Now:yyyy-MM-dd}"
```

**Table Columns**:
- Column 1: `Title`
- Column 2: `Description` (from `FullText`)

### Output Files

| File Pattern | Example | Content |
|--------------|---------|---------|
| `README.md` | `docs/generated/README.md` | Index with category links |
| `{Category}.md` | `docs/generated/FieldGuide.md` | Category-specific entries |

---

## Testing

### Test File: DocGenServiceTests.cs

**Location**: `RuneAndRust.Tests/Engine/DocGenServiceTests.cs`
**Test Count**: 9 tests

### Test Categories

#### Category 1: File Creation (3 tests)

| Test | Description |
|------|-------------|
| `GenerateDocsAsync_CreatesOutputDirectory` | Directory created if missing |
| `GenerateDocsAsync_CreatesReadmeFile` | README.md generated |
| `GenerateDocsAsync_CreatesCategoryFiles` | One file per category |

#### Category 2: Content Formatting (3 tests)

| Test | Description |
|------|-------------|
| `GenerateCategoryMarkdown_IncludesTableHeader` | Table has title/description columns |
| `GenerateCategoryMarkdown_SortsEntriesAlphabetically` | Entries in A-Z order |
| `GenerateReadmeMarkdown_IncludesCategoryLinks` | README has links to each category |

#### Category 3: Escaping (3 tests)

| Test | Description |
|------|-------------|
| `EscapeMarkdownTableCell_EscapesPipes` | `\|` becomes `\\|` |
| `EscapeMarkdownTableCell_ConvertsNewlines` | `\n` becomes `<br>` |
| `EscapeMarkdownTableCell_HandlesNull` | Null input returns null |

---

## Design Rationale

### Why CLI-Based Trigger?

**Problem**: Documentation generation should not run during normal gameplay.

**Solution**: `--docgen` flag provides explicit opt-in. Early exit prevents game initialization overhead.

**Alternative Considered**: Automatic generation on startup would slow every launch and produce unnecessary file changes.

### Why Hardcoded Output Path?

**Problem**: Need consistent, predictable output location.

**Solution**: `docs/generated/` is standard location for generated documentation. Developers know where to find it.

**Alternative Considered**: Command-line path argument would add complexity for minimal benefit.

### Why One File Per Category?

**Problem**: Single large file becomes unwieldy for navigation.

**Solution**: Category-based files match Field Guide tabs. README provides index for discovery.

**Alternative Considered**: Single file with anchors would work but provides worse navigation for large documentation sets.

### Why HTML `<br>` for Newlines?

**Problem**: Newlines in table cells break Markdown table syntax.

**Solution**: `<br>` is valid HTML that renders as line break in Markdown viewers. Most Markdown parsers (GitHub, GitLab) support inline HTML.

**Alternative Considered**: Escaping `\n` as `\\n` would display literal text instead of line break.

### Why Synchronous Processing?

**Problem**: Could parallelize file writes for performance.

**Solution**: Sequential processing is simpler, and documentation generation is infrequent (developer tool, not runtime). File I/O is typically fast for small files.

**Alternative Considered**: `Task.WhenAll` for parallel writes would add complexity for marginal speed improvement.

---

## Changelog

### v1.0.0 (v0.3.11b) - 2025-12-23

**Implemented Features**:
- `IDocGenService` interface with single method
- `DocGenService` implementation with Markdown generation
- CLI integration via `--docgen` flag
- Category-based file organization
- README index with category links
- Markdown table cell escaping

**Test Coverage**:
- 9 tests across 3 categories
- 100% method coverage

**Related Releases**:
- v0.3.11b "The Developer's Handbook" - Initial implementation

---

**End of SPEC-DOCGEN-001**
