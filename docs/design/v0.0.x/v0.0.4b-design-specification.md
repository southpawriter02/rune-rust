# v0.0.4b Design Specification: Resource Pool System

## Overview

**Version:** 0.0.4b
**Status:** Implemented
**Focus:** Implement class-specific resource pools beyond Health
**Prerequisites:** v0.0.4a (Archetype & Class Foundations)
**Estimated Unit Tests:** ~30

---

## Table of Contents

1. [User Stories](#user-stories)
2. [Architecture](#architecture)
3. [Data Models](#data-models)
4. [Configuration Schemas](#configuration-schemas)
5. [Service Specifications](#service-specifications)
6. [Resource Mechanics](#resource-mechanics)
7. [Code Examples](#code-examples)
8. [Logging Requirements](#logging-requirements)
9. [Unit Test Specifications](#unit-test-specifications)
10. [Acceptance Criteria](#acceptance-criteria)
11. [Documentation Requirements](#documentation-requirements)
12. [Deliverable Checklist](#deliverable-checklist)

---

## User Stories

### US-4b-1: View Resource Pools
**As a** player during gameplay
**I want to** see my class-specific resource pool in my status
**So that** I know how much resource I have available for abilities

**Acceptance Criteria:**
- Status command displays primary resource (e.g., Mana, Rage)
- Resource shows current/max values
- Resource bar visualization (progress bar)
- Resource name uses configured display name

### US-4b-2: Resource Regeneration
**As a** player during gameplay
**I want to** have my resources regenerate appropriately
**So that** I can use abilities over time

**Acceptance Criteria:**
- Mana regenerates a fixed amount per turn
- Energy regenerates quickly each turn
- Focus regenerates steadily each turn
- Regeneration occurs at turn end

### US-4b-3: Resource Decay
**As a** Shieldmaiden player
**I want to** my Rage to decay when not in combat
**So that** the resource mechanic feels thematic

**Acceptance Criteria:**
- Rage decays by configured amount each turn out of combat
- Decay does not occur during combat
- Rage cannot go below zero

### US-4b-4: Build-on-Hit Resources
**As a** Shieldmaiden player
**I want to** gain Rage when I deal or receive damage
**So that** combat builds my resource for abilities

**Acceptance Criteria:**
- Rage increases when player deals damage
- Rage increases when player takes damage
- Build amount is configurable per resource type
- Resource cannot exceed maximum

### US-4b-5: Faith from Support Actions
**As a** Blood-Priest player
**I want to** gain Faith when I heal or support allies
**So that** my support playstyle is rewarded

**Acceptance Criteria:**
- Faith increases when healing is performed
- Faith build amount is configurable
- Faith does not decay (or decays slowly)

### US-4b-6: Class-Resource Binding
**As a** game designer
**I want to** define which resources each class uses
**So that** classes have unique resource mechanics

**Acceptance Criteria:**
- Each class has a primary resource defined
- Health is universal (all classes have it)
- Class definition references resource type ID
- Invalid resource references produce clear errors

---

## Architecture

### Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         PRESENTATION LAYER                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────┐  ┌─────────────────────┐                      │
│  │    StatusView       │  │   ResourceBarView   │                      │
│  │    (updated)        │  │                     │                      │
│  │                     │  │ - RenderBar()       │                      │
│  │ - ShowResources()   │  │ - GetColor()        │                      │
│  └─────────┬───────────┘  └─────────┬───────────┘                      │
│            │                        │                                   │
└────────────┼────────────────────────┼───────────────────────────────────┘
             │                        │
             ▼                        ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION LAYER                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      ResourceService                             │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + GetResourceType(id) : ResourceTypeDto?                        │   │
│  │ + GetAllResourceTypes() : IReadOnlyList<ResourceTypeDto>        │   │
│  │ + InitializePlayerResources(player, classId) : void             │   │
│  │ + GetPlayerResources(player) : IReadOnlyList<ResourcePoolDto>   │   │
│  │ + SpendResource(player, resourceId, amount) : bool              │   │
│  │ + GainResource(player, resourceId, amount) : void               │   │
│  │ + ProcessTurnEnd(player) : ResourceChangeResult                 │   │
│  │ + ProcessCombatHit(player, damageDealt, damageTaken) : void     │   │
│  │ + ProcessSupportAction(player, healAmount) : void               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      ClassService (updated)                      │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + ApplyClassToPlayer(classId, player) : void  // Now also       │   │
│  │   initializes resources via ResourceService                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           DOMAIN LAYER                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ENTITIES                                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │                   ResourceTypeDefinition                        │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + Id: string                   // "mana", "rage", "energy"      │    │
│  │ + DisplayName: string          // "Arcane Power", "Fury"        │    │
│  │ + Abbreviation: string         // "MP", "RG", "EN"              │    │
│  │ + Description: string                                           │    │
│  │ + Color: string                // Hex color for UI "#0066FF"    │    │
│  │ + DefaultMax: int              // Default maximum value         │    │
│  │ + RegenPerTurn: int            // Amount regenerated per turn   │    │
│  │ + DecayPerTurn: int            // Amount lost per turn (Rage)   │    │
│  │ + DecayOnlyOutOfCombat: bool   // Decay pauses during combat    │    │
│  │ + BuildOnDamageDealt: int      // Gain when dealing damage      │    │
│  │ + BuildOnDamageTaken: int      // Gain when taking damage       │    │
│  │ + BuildOnHeal: int             // Gain when healing (Faith)     │    │
│  │ + IsUniversal: bool            // All classes have this (HP)    │    │
│  │ + StartsAtZero: bool           // Begin at 0 instead of max     │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  VALUE OBJECTS                                                          │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │                       ResourcePool                              │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + ResourceTypeId: string                                        │    │
│  │ + Current: int                                                  │    │
│  │ + Maximum: int                                                  │    │
│  │ + Percentage: float { get; }   // Current / Maximum             │    │
│  │ + IsFull: bool { get; }                                         │    │
│  │ + IsEmpty: bool { get; }                                        │    │
│  │ + Spend(amount): bool          // Returns false if insufficient │    │
│  │ + Gain(amount): int            // Returns actual amount gained  │    │
│  │ + SetToMax(): void                                              │    │
│  │ + SetToZero(): void                                             │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  PLAYER UPDATES                                                         │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │                       Player (updated)                          │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + Resources: Dictionary<string, ResourcePool>  // NEW           │    │
│  │ + GetResource(resourceId): ResourcePool?       // NEW           │    │
│  │ + HasResource(resourceId): bool                // NEW           │    │
│  │ + InitializeResource(resourceTypeId, max, startAtZero): void    │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  RECORDS                                                                │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │ ResourceChangeResult                                            │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + Changes: IReadOnlyList<ResourceChange>                        │    │
│  │ + HasChanges: bool                                              │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │ ResourceChange                                                  │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + ResourceTypeId: string                                        │    │
│  │ + PreviousValue: int                                            │    │
│  │ + NewValue: int                                                 │    │
│  │ + ChangeType: ResourceChangeType (Regen, Decay, Spent, Gained)  │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        INFRASTRUCTURE LAYER                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                   ConfigurationLoader (updated)                  │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + LoadResourceTypes(path) : IReadOnlyList<ResourceTypeDefinition>│   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Configuration Files:                                                   │
│  └── config/resources.json                                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Resource Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    RESOURCE LIFECYCLE FLOW                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  CHARACTER CREATION                                                     │
│  ┌─────────────────┐                                                   │
│  │ Player selects  │                                                   │
│  │ class           │                                                   │
│  └────────┬────────┘                                                   │
│           │                                                             │
│           ▼                                                             │
│  ┌─────────────────┐     ┌─────────────────┐                           │
│  │ ClassService    │────►│ ResourceService │                           │
│  │ ApplyClass()    │     │ Initialize()    │                           │
│  └─────────────────┘     └────────┬────────┘                           │
│                                   │                                     │
│                                   ▼                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ Player.Resources initialized with:                              │   │
│  │  - Health (all classes)                                         │   │
│  │  - Primary resource from ClassDefinition.PrimaryResourceId      │   │
│  │    (e.g., Mana for Galdr-Caster, Rage for Shieldmaiden)         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  GAMEPLAY LOOP                                                          │
│                                                                         │
│  ┌─────────────────┐                                                   │
│  │ TURN START      │                                                   │
│  └────────┬────────┘                                                   │
│           │                                                             │
│           ▼                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ Player Actions:                                                 │   │
│  │  - Use ability ──► SpendResource(resourceId, cost)              │   │
│  │  - Attack ──────► ProcessCombatHit(damageDealt, damageTaken)    │   │
│  │  - Heal ally ───► ProcessSupportAction(healAmount)              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│           │                                                             │
│           ▼                                                             │
│  ┌─────────────────┐                                                   │
│  │ TURN END        │                                                   │
│  └────────┬────────┘                                                   │
│           │                                                             │
│           ▼                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ ResourceService.ProcessTurnEnd(player):                         │   │
│  │  - Apply RegenPerTurn to regenerating resources                 │   │
│  │  - Apply DecayPerTurn to decaying resources (if out of combat)  │   │
│  │  - Return ResourceChangeResult for UI display                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Data Models

### ResourceTypeDefinition Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Defines a type of resource that can be used by player classes.
/// </summary>
/// <remarks>
/// Resource types are loaded from configuration and define mechanics like
/// regeneration, decay, and build-on-hit. Examples include Mana, Rage, Energy.
/// </remarks>
public class ResourceTypeDefinition : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this resource type.
    /// </summary>
    /// <example>"mana", "rage", "energy", "faith", "focus"</example>
    public string Id { get; private set; }

    /// <summary>
    /// Gets the display name shown to players.
    /// </summary>
    /// <example>"Arcane Power", "Fury", "Stamina"</example>
    public string DisplayName { get; private set; }

    /// <summary>
    /// Gets the abbreviated form for compact display.
    /// </summary>
    /// <example>"MP", "RG", "EN", "FTH", "FOC"</example>
    public string Abbreviation { get; private set; }

    /// <summary>
    /// Gets the description of this resource type.
    /// </summary>
    public string Description { get; private set; }

    /// <summary>
    /// Gets the hex color code for UI rendering.
    /// </summary>
    /// <example>"#0066FF" for mana blue, "#FF6600" for rage orange</example>
    public string Color { get; private set; }

    /// <summary>
    /// Gets the default maximum value for this resource.
    /// </summary>
    public int DefaultMax { get; private set; }

    /// <summary>
    /// Gets the amount regenerated at the end of each turn.
    /// </summary>
    /// <remarks>
    /// Set to 0 for resources that don't regenerate naturally (like Rage).
    /// </remarks>
    public int RegenPerTurn { get; private set; }

    /// <summary>
    /// Gets the amount lost at the end of each turn.
    /// </summary>
    /// <remarks>
    /// Used for resources like Rage that decay over time.
    /// </remarks>
    public int DecayPerTurn { get; private set; }

    /// <summary>
    /// Gets whether decay only occurs outside of combat.
    /// </summary>
    public bool DecayOnlyOutOfCombat { get; private set; }

    /// <summary>
    /// Gets the amount gained when dealing damage.
    /// </summary>
    /// <remarks>
    /// Used for Rage-like resources that build during combat.
    /// </remarks>
    public int BuildOnDamageDealt { get; private set; }

    /// <summary>
    /// Gets the amount gained when taking damage.
    /// </summary>
    public int BuildOnDamageTaken { get; private set; }

    /// <summary>
    /// Gets the amount gained when performing healing.
    /// </summary>
    /// <remarks>
    /// Used for Faith-like resources that build from support actions.
    /// </remarks>
    public int BuildOnHeal { get; private set; }

    /// <summary>
    /// Gets whether all classes have this resource.
    /// </summary>
    /// <remarks>
    /// True for Health, false for class-specific resources.
    /// </remarks>
    public bool IsUniversal { get; private set; }

    /// <summary>
    /// Gets whether this resource starts at zero instead of maximum.
    /// </summary>
    /// <remarks>
    /// True for build-up resources like Rage that start empty.
    /// </remarks>
    public bool StartsAtZero { get; private set; }

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private ResourceTypeDefinition()
    {
        Id = null!;
        DisplayName = null!;
        Abbreviation = null!;
        Description = null!;
        Color = null!;
    }

    /// <summary>
    /// Creates a new resource type definition.
    /// </summary>
    public static ResourceTypeDefinition Create(
        string id,
        string displayName,
        string abbreviation,
        string description,
        string color,
        int defaultMax,
        int regenPerTurn = 0,
        int decayPerTurn = 0,
        bool decayOnlyOutOfCombat = true,
        int buildOnDamageDealt = 0,
        int buildOnDamageTaken = 0,
        int buildOnHeal = 0,
        bool isUniversal = false,
        bool startsAtZero = false)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(displayName);
        ArgumentException.ThrowIfNullOrWhiteSpace(abbreviation);
        ArgumentOutOfRangeException.ThrowIfNegative(defaultMax);

        return new ResourceTypeDefinition
        {
            Id = id.ToLowerInvariant(),
            DisplayName = displayName,
            Abbreviation = abbreviation.ToUpperInvariant(),
            Description = description,
            Color = color,
            DefaultMax = defaultMax,
            RegenPerTurn = regenPerTurn,
            DecayPerTurn = decayPerTurn,
            DecayOnlyOutOfCombat = decayOnlyOutOfCombat,
            BuildOnDamageDealt = buildOnDamageDealt,
            BuildOnDamageTaken = buildOnDamageTaken,
            BuildOnHeal = buildOnHeal,
            IsUniversal = isUniversal,
            StartsAtZero = startsAtZero
        };
    }

    /// <summary>
    /// Gets whether this resource regenerates over time.
    /// </summary>
    public bool Regenerates => RegenPerTurn > 0;

    /// <summary>
    /// Gets whether this resource decays over time.
    /// </summary>
    public bool Decays => DecayPerTurn > 0;

    /// <summary>
    /// Gets whether this resource builds from combat.
    /// </summary>
    public bool BuildsFromCombat => BuildOnDamageDealt > 0 || BuildOnDamageTaken > 0;

    /// <summary>
    /// Gets whether this resource builds from support actions.
    /// </summary>
    public bool BuildsFromSupport => BuildOnHeal > 0;
}
```

### ResourcePool Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a pool of a specific resource with current and maximum values.
/// </summary>
/// <remarks>
/// ResourcePool is a mutable value object that tracks the current state of
/// a resource. It provides methods for spending and gaining resource amounts.
/// </remarks>
public class ResourcePool
{
    /// <summary>
    /// Gets the ID of the resource type this pool represents.
    /// </summary>
    public string ResourceTypeId { get; }

    /// <summary>
    /// Gets the current amount of the resource.
    /// </summary>
    public int Current { get; private set; }

    /// <summary>
    /// Gets the maximum amount of the resource.
    /// </summary>
    public int Maximum { get; private set; }

    /// <summary>
    /// Gets the current fill percentage (0.0 to 1.0).
    /// </summary>
    public float Percentage => Maximum > 0 ? (float)Current / Maximum : 0f;

    /// <summary>
    /// Gets whether the pool is at maximum capacity.
    /// </summary>
    public bool IsFull => Current >= Maximum;

    /// <summary>
    /// Gets whether the pool is empty (zero).
    /// </summary>
    public bool IsEmpty => Current <= 0;

    /// <summary>
    /// Creates a new resource pool.
    /// </summary>
    /// <param name="resourceTypeId">The resource type ID.</param>
    /// <param name="maximum">The maximum capacity.</param>
    /// <param name="startAtZero">If true, starts at 0; otherwise starts at max.</param>
    public ResourcePool(string resourceTypeId, int maximum, bool startAtZero = false)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(resourceTypeId);
        ArgumentOutOfRangeException.ThrowIfNegative(maximum);

        ResourceTypeId = resourceTypeId.ToLowerInvariant();
        Maximum = maximum;
        Current = startAtZero ? 0 : maximum;
    }

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private ResourcePool()
    {
        ResourceTypeId = null!;
    }

    /// <summary>
    /// Attempts to spend the specified amount of resource.
    /// </summary>
    /// <param name="amount">The amount to spend.</param>
    /// <returns>True if the resource was spent; false if insufficient.</returns>
    public bool Spend(int amount)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(amount);

        if (Current < amount)
            return false;

        Current -= amount;
        return true;
    }

    /// <summary>
    /// Gains the specified amount of resource, up to the maximum.
    /// </summary>
    /// <param name="amount">The amount to gain.</param>
    /// <returns>The actual amount gained (may be less if capped at max).</returns>
    public int Gain(int amount)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(amount);

        var previousValue = Current;
        Current = Math.Min(Maximum, Current + amount);
        return Current - previousValue;
    }

    /// <summary>
    /// Loses the specified amount of resource, down to zero.
    /// </summary>
    /// <param name="amount">The amount to lose.</param>
    /// <returns>The actual amount lost.</returns>
    public int Lose(int amount)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(amount);

        var previousValue = Current;
        Current = Math.Max(0, Current - amount);
        return previousValue - Current;
    }

    /// <summary>
    /// Sets the current value to maximum.
    /// </summary>
    public void SetToMax() => Current = Maximum;

    /// <summary>
    /// Sets the current value to zero.
    /// </summary>
    public void SetToZero() => Current = 0;

    /// <summary>
    /// Sets the current value directly (clamped to valid range).
    /// </summary>
    /// <param name="value">The value to set.</param>
    public void SetCurrent(int value) => Current = Math.Clamp(value, 0, Maximum);

    /// <summary>
    /// Modifies the maximum value, optionally adjusting current proportionally.
    /// </summary>
    /// <param name="newMaximum">The new maximum value.</param>
    /// <param name="adjustCurrentProportionally">If true, scales current value.</param>
    public void SetMaximum(int newMaximum, bool adjustCurrentProportionally = false)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(newMaximum);

        if (adjustCurrentProportionally && Maximum > 0)
        {
            var ratio = (float)Current / Maximum;
            Current = (int)(newMaximum * ratio);
        }

        Maximum = newMaximum;
        Current = Math.Min(Current, Maximum);
    }

    public override string ToString() => $"{ResourceTypeId}: {Current}/{Maximum}";
}
```

### ResourceChange Records

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the type of resource change that occurred.
/// </summary>
public enum ResourceChangeType
{
    /// <summary>Resource gained from regeneration.</summary>
    Regeneration,

    /// <summary>Resource lost from decay.</summary>
    Decay,

    /// <summary>Resource spent on an ability.</summary>
    Spent,

    /// <summary>Resource gained from an action.</summary>
    Gained,

    /// <summary>Resource gained from dealing damage.</summary>
    BuildOnDamageDealt,

    /// <summary>Resource gained from taking damage.</summary>
    BuildOnDamageTaken,

    /// <summary>Resource gained from healing.</summary>
    BuildOnHeal
}

/// <summary>
/// Represents a change to a resource pool.
/// </summary>
/// <param name="ResourceTypeId">The resource that changed.</param>
/// <param name="PreviousValue">The value before the change.</param>
/// <param name="NewValue">The value after the change.</param>
/// <param name="ChangeType">The type of change that occurred.</param>
public record ResourceChange(
    string ResourceTypeId,
    int PreviousValue,
    int NewValue,
    ResourceChangeType ChangeType)
{
    /// <summary>
    /// Gets the amount of change (positive for gain, negative for loss).
    /// </summary>
    public int Delta => NewValue - PreviousValue;

    /// <summary>
    /// Gets whether this was a gain (positive change).
    /// </summary>
    public bool IsGain => Delta > 0;

    /// <summary>
    /// Gets whether this was a loss (negative change).
    /// </summary>
    public bool IsLoss => Delta < 0;
}

/// <summary>
/// Contains all resource changes from a game action or turn end.
/// </summary>
/// <param name="Changes">The list of individual resource changes.</param>
public record ResourceChangeResult(IReadOnlyList<ResourceChange> Changes)
{
    /// <summary>
    /// Gets whether any changes occurred.
    /// </summary>
    public bool HasChanges => Changes.Count > 0;

    /// <summary>
    /// Gets an empty result with no changes.
    /// </summary>
    public static ResourceChangeResult Empty => new(Array.Empty<ResourceChange>());
}
```

### Player Entity Updates

```csharp
// Additions to existing Player class

/// <summary>
/// Gets the player's resource pools keyed by resource type ID.
/// </summary>
public Dictionary<string, ResourcePool> Resources { get; private set; } = new();

/// <summary>
/// Gets a specific resource pool by type ID.
/// </summary>
/// <param name="resourceTypeId">The resource type ID (e.g., "mana").</param>
/// <returns>The resource pool, or null if the player doesn't have it.</returns>
public ResourcePool? GetResource(string resourceTypeId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(resourceTypeId);
    return Resources.TryGetValue(resourceTypeId.ToLowerInvariant(), out var pool)
        ? pool
        : null;
}

/// <summary>
/// Checks whether the player has a specific resource type.
/// </summary>
/// <param name="resourceTypeId">The resource type ID.</param>
/// <returns>True if the player has this resource.</returns>
public bool HasResource(string resourceTypeId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(resourceTypeId);
    return Resources.ContainsKey(resourceTypeId.ToLowerInvariant());
}

/// <summary>
/// Initializes a resource pool for the player.
/// </summary>
/// <param name="resourceTypeId">The resource type ID.</param>
/// <param name="maximum">The maximum value.</param>
/// <param name="startAtZero">Whether to start at zero instead of max.</param>
public void InitializeResource(string resourceTypeId, int maximum, bool startAtZero = false)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(resourceTypeId);
    var id = resourceTypeId.ToLowerInvariant();
    Resources[id] = new ResourcePool(id, maximum, startAtZero);
}
```

---

## Configuration Schemas

### resources.json

```json
{
  "$schema": "resources.schema.json",
  "resourceTypes": [
    {
      "id": "health",
      "displayName": "Vitality",
      "abbreviation": "HP",
      "description": "Your life force. When it reaches zero, you are defeated.",
      "color": "#FF0000",
      "defaultMax": 100,
      "regenPerTurn": 0,
      "decayPerTurn": 0,
      "isUniversal": true,
      "startsAtZero": false
    },
    {
      "id": "mana",
      "displayName": "Arcane Power",
      "abbreviation": "MP",
      "description": "Magical energy used to cast spells. Regenerates naturally over time.",
      "color": "#0066FF",
      "defaultMax": 100,
      "regenPerTurn": 10,
      "decayPerTurn": 0,
      "isUniversal": false,
      "startsAtZero": false
    },
    {
      "id": "rage",
      "displayName": "Fury",
      "abbreviation": "RG",
      "description": "Battle fury that builds from combat. Decays when not fighting.",
      "color": "#FF6600",
      "defaultMax": 100,
      "regenPerTurn": 0,
      "decayPerTurn": 10,
      "decayOnlyOutOfCombat": true,
      "buildOnDamageDealt": 10,
      "buildOnDamageTaken": 15,
      "isUniversal": false,
      "startsAtZero": true
    },
    {
      "id": "energy",
      "displayName": "Stamina",
      "abbreviation": "EN",
      "description": "Physical energy for quick actions. Regenerates rapidly.",
      "color": "#FFCC00",
      "defaultMax": 100,
      "regenPerTurn": 20,
      "decayPerTurn": 0,
      "isUniversal": false,
      "startsAtZero": false
    },
    {
      "id": "faith",
      "displayName": "Divine Favor",
      "abbreviation": "FTH",
      "description": "Spiritual power that builds through acts of devotion and healing.",
      "color": "#FFDD88",
      "defaultMax": 100,
      "regenPerTurn": 5,
      "decayPerTurn": 0,
      "buildOnHeal": 15,
      "isUniversal": false,
      "startsAtZero": false
    },
    {
      "id": "focus",
      "displayName": "Concentration",
      "abbreviation": "FOC",
      "description": "Mental focus used to power gadgets and devices. Steady regeneration.",
      "color": "#00CCAA",
      "defaultMax": 100,
      "regenPerTurn": 8,
      "decayPerTurn": 0,
      "isUniversal": false,
      "startsAtZero": false
    }
  ]
}
```

### JSON Schema: resources.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Resource Types Configuration",
  "type": "object",
  "required": ["resourceTypes"],
  "properties": {
    "resourceTypes": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id", "displayName", "abbreviation", "description", "color", "defaultMax"],
        "properties": {
          "id": {
            "type": "string",
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Unique identifier"
          },
          "displayName": {
            "type": "string",
            "minLength": 1,
            "description": "Display name shown to players"
          },
          "abbreviation": {
            "type": "string",
            "minLength": 1,
            "maxLength": 4,
            "description": "Short abbreviation (e.g., HP, MP)"
          },
          "description": {
            "type": "string",
            "description": "Description of the resource"
          },
          "color": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Hex color code for UI"
          },
          "defaultMax": {
            "type": "integer",
            "minimum": 1,
            "description": "Default maximum value"
          },
          "regenPerTurn": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Amount regenerated per turn"
          },
          "decayPerTurn": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Amount lost per turn"
          },
          "decayOnlyOutOfCombat": {
            "type": "boolean",
            "default": true,
            "description": "Whether decay pauses during combat"
          },
          "buildOnDamageDealt": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Amount gained when dealing damage"
          },
          "buildOnDamageTaken": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Amount gained when taking damage"
          },
          "buildOnHeal": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Amount gained when healing"
          },
          "isUniversal": {
            "type": "boolean",
            "default": false,
            "description": "Whether all classes have this resource"
          },
          "startsAtZero": {
            "type": "boolean",
            "default": false,
            "description": "Whether to start at 0 instead of max"
          }
        }
      }
    }
  }
}
```

---

## Service Specifications

### ResourceService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages resource types and player resource pools.
/// </summary>
public class ResourceService
{
    private readonly IReadOnlyList<ResourceTypeDefinition> _resourceTypes;
    private readonly ILogger<ResourceService> _logger;

    public ResourceService(
        IConfigurationLoader configLoader,
        ILogger<ResourceService> logger)
    {
        _logger = logger;
        _resourceTypes = configLoader.LoadResourceTypes("config/resources.json");

        _logger.LogInformation(
            "ResourceService initialized with {ResourceTypeCount} resource types",
            _resourceTypes.Count);
    }

    /// <summary>
    /// Gets a resource type by ID.
    /// </summary>
    public ResourceTypeDefinition? GetResourceType(string id)
    {
        _logger.LogDebug("GetResourceType called for: {ResourceTypeId}", id);
        return _resourceTypes.FirstOrDefault(
            r => r.Id.Equals(id, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Gets all resource types.
    /// </summary>
    public IReadOnlyList<ResourceTypeDto> GetAllResourceTypes()
    {
        _logger.LogDebug("GetAllResourceTypes called");
        return _resourceTypes.Select(r => r.ToDto()).ToList();
    }

    /// <summary>
    /// Initializes a player's resource pools based on their class.
    /// </summary>
    public void InitializePlayerResources(Player player, ClassDefinition classDef)
    {
        _logger.LogDebug(
            "InitializePlayerResources for Player: {PlayerName}, Class: {ClassId}",
            player.Name, classDef.Id);

        // Initialize universal resources (Health)
        foreach (var resourceType in _resourceTypes.Where(r => r.IsUniversal))
        {
            player.InitializeResource(
                resourceType.Id,
                resourceType.DefaultMax,
                resourceType.StartsAtZero);

            _logger.LogDebug(
                "Initialized universal resource {ResourceId} for {PlayerName}: {Max}",
                resourceType.Id, player.Name, resourceType.DefaultMax);
        }

        // Initialize class-specific primary resource
        var primaryResource = GetResourceType(classDef.PrimaryResourceId);
        if (primaryResource != null && !primaryResource.IsUniversal)
        {
            player.InitializeResource(
                primaryResource.Id,
                primaryResource.DefaultMax,
                primaryResource.StartsAtZero);

            _logger.LogInformation(
                "Initialized primary resource {ResourceName} ({ResourceId}) for {PlayerName}: " +
                "{Current}/{Max} (StartsAtZero: {StartsAtZero})",
                primaryResource.DisplayName,
                primaryResource.Id,
                player.Name,
                primaryResource.StartsAtZero ? 0 : primaryResource.DefaultMax,
                primaryResource.DefaultMax,
                primaryResource.StartsAtZero);
        }
        else if (primaryResource == null)
        {
            _logger.LogWarning(
                "Primary resource type not found for class {ClassId}: {ResourceId}",
                classDef.Id, classDef.PrimaryResourceId);
        }
    }

    /// <summary>
    /// Gets all resource pools for a player as DTOs.
    /// </summary>
    public IReadOnlyList<ResourcePoolDto> GetPlayerResources(Player player)
    {
        _logger.LogDebug("GetPlayerResources for: {PlayerName}", player.Name);

        return player.Resources.Values
            .Select(pool =>
            {
                var resourceType = GetResourceType(pool.ResourceTypeId);
                return new ResourcePoolDto(
                    pool.ResourceTypeId,
                    resourceType?.DisplayName ?? pool.ResourceTypeId,
                    resourceType?.Abbreviation ?? "??",
                    resourceType?.Color ?? "#FFFFFF",
                    pool.Current,
                    pool.Maximum,
                    pool.Percentage);
            })
            .ToList();
    }

    /// <summary>
    /// Attempts to spend a resource.
    /// </summary>
    public bool SpendResource(Player player, string resourceTypeId, int amount)
    {
        _logger.LogDebug(
            "SpendResource: {PlayerName}, {ResourceId}, Amount: {Amount}",
            player.Name, resourceTypeId, amount);

        var pool = player.GetResource(resourceTypeId);
        if (pool == null)
        {
            _logger.LogWarning(
                "Player {PlayerName} does not have resource: {ResourceId}",
                player.Name, resourceTypeId);
            return false;
        }

        var previousValue = pool.Current;
        if (!pool.Spend(amount))
        {
            _logger.LogDebug(
                "Insufficient {ResourceId}: Has {Current}, needs {Amount}",
                resourceTypeId, pool.Current, amount);
            return false;
        }

        _logger.LogInformation(
            "Resource spent: {PlayerName} {ResourceId} {Previous} -> {Current} (-{Amount})",
            player.Name, resourceTypeId, previousValue, pool.Current, amount);

        return true;
    }

    /// <summary>
    /// Gains a resource amount.
    /// </summary>
    public int GainResource(Player player, string resourceTypeId, int amount)
    {
        _logger.LogDebug(
            "GainResource: {PlayerName}, {ResourceId}, Amount: {Amount}",
            player.Name, resourceTypeId, amount);

        var pool = player.GetResource(resourceTypeId);
        if (pool == null)
        {
            _logger.LogWarning(
                "Player {PlayerName} does not have resource: {ResourceId}",
                player.Name, resourceTypeId);
            return 0;
        }

        var previousValue = pool.Current;
        var actualGain = pool.Gain(amount);

        if (actualGain > 0)
        {
            _logger.LogInformation(
                "Resource gained: {PlayerName} {ResourceId} {Previous} -> {Current} (+{Actual})",
                player.Name, resourceTypeId, previousValue, pool.Current, actualGain);
        }

        return actualGain;
    }

    /// <summary>
    /// Processes end-of-turn resource regeneration and decay.
    /// </summary>
    public ResourceChangeResult ProcessTurnEnd(Player player, bool inCombat = false)
    {
        _logger.LogDebug(
            "ProcessTurnEnd for {PlayerName}, InCombat: {InCombat}",
            player.Name, inCombat);

        var changes = new List<ResourceChange>();

        foreach (var pool in player.Resources.Values)
        {
            var resourceType = GetResourceType(pool.ResourceTypeId);
            if (resourceType == null) continue;

            // Apply regeneration
            if (resourceType.RegenPerTurn > 0 && !pool.IsFull)
            {
                var previousValue = pool.Current;
                var actualGain = pool.Gain(resourceType.RegenPerTurn);

                if (actualGain > 0)
                {
                    changes.Add(new ResourceChange(
                        pool.ResourceTypeId,
                        previousValue,
                        pool.Current,
                        ResourceChangeType.Regeneration));

                    _logger.LogDebug(
                        "Regeneration: {ResourceId} {Previous} -> {Current} (+{Regen})",
                        pool.ResourceTypeId, previousValue, pool.Current, actualGain);
                }
            }

            // Apply decay (only out of combat if configured)
            if (resourceType.DecayPerTurn > 0 && !pool.IsEmpty)
            {
                var shouldDecay = !resourceType.DecayOnlyOutOfCombat || !inCombat;

                if (shouldDecay)
                {
                    var previousValue = pool.Current;
                    var actualLoss = pool.Lose(resourceType.DecayPerTurn);

                    if (actualLoss > 0)
                    {
                        changes.Add(new ResourceChange(
                            pool.ResourceTypeId,
                            previousValue,
                            pool.Current,
                            ResourceChangeType.Decay));

                        _logger.LogDebug(
                            "Decay: {ResourceId} {Previous} -> {Current} (-{Decay})",
                            pool.ResourceTypeId, previousValue, pool.Current, actualLoss);
                    }
                }
            }
        }

        if (changes.Count > 0)
        {
            _logger.LogInformation(
                "Turn end processed for {PlayerName}: {ChangeCount} resource changes",
                player.Name, changes.Count);
        }

        return new ResourceChangeResult(changes);
    }

    /// <summary>
    /// Processes combat hit for build-on-hit resources.
    /// </summary>
    public ResourceChangeResult ProcessCombatHit(
        Player player,
        int damageDealt,
        int damageTaken)
    {
        _logger.LogDebug(
            "ProcessCombatHit: {PlayerName}, Dealt: {Dealt}, Taken: {Taken}",
            player.Name, damageDealt, damageTaken);

        var changes = new List<ResourceChange>();

        foreach (var pool in player.Resources.Values)
        {
            var resourceType = GetResourceType(pool.ResourceTypeId);
            if (resourceType == null) continue;

            // Build on damage dealt
            if (resourceType.BuildOnDamageDealt > 0 && damageDealt > 0)
            {
                var previousValue = pool.Current;
                var actualGain = pool.Gain(resourceType.BuildOnDamageDealt);

                if (actualGain > 0)
                {
                    changes.Add(new ResourceChange(
                        pool.ResourceTypeId,
                        previousValue,
                        pool.Current,
                        ResourceChangeType.BuildOnDamageDealt));

                    _logger.LogDebug(
                        "Build on damage dealt: {ResourceId} {Previous} -> {Current} (+{Gain})",
                        pool.ResourceTypeId, previousValue, pool.Current, actualGain);
                }
            }

            // Build on damage taken
            if (resourceType.BuildOnDamageTaken > 0 && damageTaken > 0)
            {
                var previousValue = pool.Current;
                var actualGain = pool.Gain(resourceType.BuildOnDamageTaken);

                if (actualGain > 0)
                {
                    changes.Add(new ResourceChange(
                        pool.ResourceTypeId,
                        previousValue,
                        pool.Current,
                        ResourceChangeType.BuildOnDamageTaken));

                    _logger.LogDebug(
                        "Build on damage taken: {ResourceId} {Previous} -> {Current} (+{Gain})",
                        pool.ResourceTypeId, previousValue, pool.Current, actualGain);
                }
            }
        }

        return new ResourceChangeResult(changes);
    }

    /// <summary>
    /// Processes support action for build-on-heal resources.
    /// </summary>
    public ResourceChangeResult ProcessSupportAction(Player player, int healAmount)
    {
        _logger.LogDebug(
            "ProcessSupportAction: {PlayerName}, HealAmount: {HealAmount}",
            player.Name, healAmount);

        var changes = new List<ResourceChange>();

        foreach (var pool in player.Resources.Values)
        {
            var resourceType = GetResourceType(pool.ResourceTypeId);
            if (resourceType == null) continue;

            if (resourceType.BuildOnHeal > 0 && healAmount > 0)
            {
                var previousValue = pool.Current;
                var actualGain = pool.Gain(resourceType.BuildOnHeal);

                if (actualGain > 0)
                {
                    changes.Add(new ResourceChange(
                        pool.ResourceTypeId,
                        previousValue,
                        pool.Current,
                        ResourceChangeType.BuildOnHeal));

                    _logger.LogDebug(
                        "Build on heal: {ResourceId} {Previous} -> {Current} (+{Gain})",
                        pool.ResourceTypeId, previousValue, pool.Current, actualGain);
                }
            }
        }

        return new ResourceChangeResult(changes);
    }
}
```

---

## Resource Mechanics

### Mechanic Summary by Resource Type

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    RESOURCE MECHANIC MATRIX                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  HEALTH (All Classes)                                                   │
│  ├─ No natural regeneration                                            │
│  ├─ Restored by healing items/abilities                                │
│  └─ Reaching 0 = defeat                                                │
│                                                                         │
│  MANA (Galdr-Caster)                                                   │
│  ├─ Starts at 100% (full)                                              │
│  ├─ Regenerates +10 per turn                                           │
│  ├─ Spent on offensive spells                                          │
│  └─ Encourages sustained magical combat                                │
│                                                                         │
│  RAGE (Shieldmaiden)                                                   │
│  ├─ Starts at 0% (empty)                                               │
│  ├─ Builds +10 when dealing damage                                     │
│  ├─ Builds +15 when taking damage                                      │
│  ├─ Decays -10 per turn OUT of combat                                  │
│  └─ Encourages aggressive, continuous combat                           │
│                                                                         │
│  ENERGY (Shadow-Walker)                                                │
│  ├─ Starts at 100% (full)                                              │
│  ├─ Regenerates +20 per turn (fast)                                    │
│  ├─ Spent on quick strikes and mobility                                │
│  └─ Encourages burst damage with recovery                              │
│                                                                         │
│  FAITH (Blood-Priest)                                                  │
│  ├─ Starts at 100% (full)                                              │
│  ├─ Regenerates +5 per turn (slow base)                                │
│  ├─ Builds +15 when healing                                            │
│  ├─ Spent on heals and smites                                          │
│  └─ Rewards supportive playstyle                                       │
│                                                                         │
│  FOCUS (Scrap-Tinker)                                                  │
│  ├─ Starts at 100% (full)                                              │
│  ├─ Regenerates +8 per turn (steady)                                   │
│  ├─ Spent on gadgets and deployables                                   │
│  └─ Encourages thoughtful resource management                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Turn Cycle Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      TURN CYCLE RESOURCE FLOW                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ╔═══════════════╗                                                      │
│  ║  TURN START   ║                                                      │
│  ╚═══════╤═══════╝                                                      │
│          │                                                              │
│          │ Player has current resources                                 │
│          │ (no automatic changes at turn start)                         │
│          │                                                              │
│          ▼                                                              │
│  ┌───────────────────────────────────────────────────────────────┐     │
│  │                    PLAYER ACTIONS                              │     │
│  ├───────────────────────────────────────────────────────────────┤     │
│  │                                                                │     │
│  │  Use Ability ──────────────────────────────────────────────►  │     │
│  │    │                                                           │     │
│  │    ├─► Check HasResource(abilityResourceId)                   │     │
│  │    ├─► Check pool.Current >= abilityCost                      │     │
│  │    └─► SpendResource(resourceId, cost)                        │     │
│  │                                                                │     │
│  │  Attack ────────────────────────────────────────────────────►  │     │
│  │    │                                                           │     │
│  │    └─► ProcessCombatHit(damageDealt, damageTaken)             │     │
│  │        ├─► BuildOnDamageDealt (Rage +10)                      │     │
│  │        └─► BuildOnDamageTaken (Rage +15)                      │     │
│  │                                                                │     │
│  │  Heal ──────────────────────────────────────────────────────►  │     │
│  │    │                                                           │     │
│  │    └─► ProcessSupportAction(healAmount)                       │     │
│  │        └─► BuildOnHeal (Faith +15)                            │     │
│  │                                                                │     │
│  └───────────────────────────────────────────────────────────────┘     │
│          │                                                              │
│          ▼                                                              │
│  ╔═══════════════╗                                                      │
│  ║   TURN END    ║                                                      │
│  ╚═══════╤═══════╝                                                      │
│          │                                                              │
│          ▼                                                              │
│  ┌───────────────────────────────────────────────────────────────┐     │
│  │              ProcessTurnEnd(player, inCombat)                  │     │
│  ├───────────────────────────────────────────────────────────────┤     │
│  │                                                                │     │
│  │  For each resource pool:                                       │     │
│  │                                                                │     │
│  │    IF RegenPerTurn > 0:                                        │     │
│  │      pool.Gain(regenAmount)                                   │     │
│  │      Mana: +10, Energy: +20, Faith: +5, Focus: +8             │     │
│  │                                                                │     │
│  │    IF DecayPerTurn > 0:                                        │     │
│  │      IF !DecayOnlyOutOfCombat OR !inCombat:                   │     │
│  │        pool.Lose(decayAmount)                                 │     │
│  │        Rage: -10 (only out of combat)                         │     │
│  │                                                                │     │
│  └───────────────────────────────────────────────────────────────┘     │
│          │                                                              │
│          ▼                                                              │
│  ┌───────────────────────────────────────────────────────────────┐     │
│  │  Return ResourceChangeResult with all changes                  │     │
│  │  UI displays regeneration/decay messages                       │     │
│  └───────────────────────────────────────────────────────────────┘     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## TUI Mockups

### Updated Status Display with Resources

```
╔════════════════════════════════════════════════════════════════════════╗
║                           CHARACTER STATUS                             ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  Name:       Astrid Ironheart                                          ║
║  Race:       Human                                                     ║
║  Background: Soldier                                                   ║
║  Archetype:  Warrior                                                   ║
║  Class:      Shieldmaiden                                              ║
║                                                                        ║
║  ─────────────────────────────────────────────────────────────────     ║
║                                                                        ║
║  VITALS                                                                ║
║  Vitality:   85/120   ██████████████░░░░░░  (71%)                     ║
║  Fury:       45/100   █████████░░░░░░░░░░░  (45%)                     ║
║                                                                        ║
║  COMBAT STATS                                                          ║
║  Attack:     8                                                         ║
║  Defense:    10                                                        ║
║                                                                        ║
║  ATTRIBUTES                                                            ║
║  Might:      12   Fortitude: 14   Will: 8                              ║
║  Wits:       7    Finesse:   6                                         ║
║                                                                        ║
╚════════════════════════════════════════════════════════════════════════╝
```

### Resource Change Feedback

```
╔════════════════════════════════════════════════════════════════════════╗
║ COMBAT                                                                 ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  You attack the Goblin for 12 damage!                                  ║
║  ► Fury +10 (dealing damage)                                          ║
║                                                                        ║
║  The Goblin strikes back for 8 damage!                                 ║
║  ► Fury +15 (taking damage)                                           ║
║                                                                        ║
║  Fury: 25 → 50/100  ██████████░░░░░░░░░░                              ║
║                                                                        ║
╚════════════════════════════════════════════════════════════════════════╝
```

### Turn End Resource Display

```
╔════════════════════════════════════════════════════════════════════════╗
║ TURN END                                                               ║
╠════════════════════════════════════════════════════════════════════════╣
║                                                                        ║
║  Resource Changes:                                                     ║
║  ► Arcane Power regenerates +10 (70 → 80/100)                         ║
║                                                                        ║
║  -- or for Rage out of combat --                                       ║
║                                                                        ║
║  Resource Changes:                                                     ║
║  ► Fury decays -10 (50 → 40/100)                                      ║
║                                                                        ║
╚════════════════════════════════════════════════════════════════════════╝
```

---

## Logging Requirements

### Log Events

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Service Init | Information | "ResourceService initialized with {ResourceTypeCount} resource types" | ResourceTypeCount |
| Resource Type Loaded | Debug | "Loaded resource type: {ResourceId} ({DisplayName})" | ResourceId, DisplayName |
| Player Resources Init | Information | "Initialized primary resource {ResourceName} ({ResourceId}) for {PlayerName}: {Current}/{Max}" | ResourceName, ResourceId, PlayerName, Current, Max |
| Resource Spent | Information | "Resource spent: {PlayerName} {ResourceId} {Previous} -> {Current} (-{Amount})" | PlayerName, ResourceId, Previous, Current, Amount |
| Resource Gained | Information | "Resource gained: {PlayerName} {ResourceId} {Previous} -> {Current} (+{Amount})" | PlayerName, ResourceId, Previous, Current, Amount |
| Insufficient Resource | Debug | "Insufficient {ResourceId}: Has {Current}, needs {Amount}" | ResourceId, Current, Amount |
| Regeneration | Debug | "Regeneration: {ResourceId} {Previous} -> {Current} (+{Regen})" | ResourceId, Previous, Current, Regen |
| Decay | Debug | "Decay: {ResourceId} {Previous} -> {Current} (-{Decay})" | ResourceId, Previous, Current, Decay |
| Build On Damage | Debug | "Build on damage dealt: {ResourceId} {Previous} -> {Current} (+{Gain})" | ResourceId, Previous, Current, Gain |
| Turn End Processed | Information | "Turn end processed for {PlayerName}: {ChangeCount} resource changes" | PlayerName, ChangeCount |
| Missing Resource | Warning | "Player {PlayerName} does not have resource: {ResourceId}" | PlayerName, ResourceId |

### Example Log Output

```
[2024-01-15 10:30:15 INF] ResourceService initialized with 6 resource types
[2024-01-15 10:30:15 DBG] Loaded resource type: health (Vitality)
[2024-01-15 10:30:15 DBG] Loaded resource type: mana (Arcane Power)
[2024-01-15 10:30:15 DBG] Loaded resource type: rage (Fury)
[2024-01-15 10:30:15 DBG] Loaded resource type: energy (Stamina)
[2024-01-15 10:30:15 DBG] Loaded resource type: faith (Divine Favor)
[2024-01-15 10:30:15 DBG] Loaded resource type: focus (Concentration)
[2024-01-15 10:32:52 INF] Initialized primary resource Fury (rage) for Astrid: 0/100 (StartsAtZero: True)
[2024-01-15 10:35:10 DBG] Build on damage dealt: rage 0 -> 10 (+10)
[2024-01-15 10:35:10 DBG] Build on damage taken: rage 10 -> 25 (+15)
[2024-01-15 10:35:15 INF] Resource spent: Astrid rage 25 -> 10 (-15)
[2024-01-15 10:36:00 DBG] Decay: rage 10 -> 0 (-10)
[2024-01-15 10:36:00 INF] Turn end processed for Astrid: 1 resource changes
```

---

## Unit Test Specifications

### ResourceTypeDefinition Tests (~6 tests)

```csharp
[TestFixture]
public class ResourceTypeDefinitionTests
{
    [Test]
    public void Create_WithValidParameters_ReturnsDefinition()
    {
        var resource = ResourceTypeDefinition.Create(
            "mana", "Arcane Power", "MP", "Magical energy", "#0066FF",
            defaultMax: 100, regenPerTurn: 10);

        resource.Id.Should().Be("mana");
        resource.DisplayName.Should().Be("Arcane Power");
        resource.Abbreviation.Should().Be("MP");
        resource.DefaultMax.Should().Be(100);
        resource.RegenPerTurn.Should().Be(10);
    }

    [Test]
    public void Create_WithNullId_ThrowsArgumentException()
    {
        var act = () => ResourceTypeDefinition.Create(
            null!, "Test", "T", "Desc", "#FFFFFF", 100);
        act.Should().Throw<ArgumentException>();
    }

    [Test]
    public void Create_NormalizesIdToLowercase()
    {
        var resource = ResourceTypeDefinition.Create(
            "MANA", "Arcane Power", "mp", "Desc", "#0066FF", 100);
        resource.Id.Should().Be("mana");
        resource.Abbreviation.Should().Be("MP");
    }

    [Test]
    public void Regenerates_ReturnsTrue_WhenRegenPerTurnPositive()
    {
        var resource = ResourceTypeDefinition.Create(
            "mana", "Mana", "MP", "Desc", "#0066FF", 100, regenPerTurn: 10);
        resource.Regenerates.Should().BeTrue();
    }

    [Test]
    public void Decays_ReturnsTrue_WhenDecayPerTurnPositive()
    {
        var resource = ResourceTypeDefinition.Create(
            "rage", "Rage", "RG", "Desc", "#FF6600", 100, decayPerTurn: 10);
        resource.Decays.Should().BeTrue();
    }

    [Test]
    public void BuildsFromCombat_ReturnsTrue_WhenBuildOnDamageSet()
    {
        var resource = ResourceTypeDefinition.Create(
            "rage", "Rage", "RG", "Desc", "#FF6600", 100,
            buildOnDamageDealt: 10, buildOnDamageTaken: 15);
        resource.BuildsFromCombat.Should().BeTrue();
    }
}
```

### ResourcePool Tests (~10 tests)

```csharp
[TestFixture]
public class ResourcePoolTests
{
    [Test]
    public void Constructor_WithStartAtZeroFalse_StartsAtMax()
    {
        var pool = new ResourcePool("mana", 100, startAtZero: false);
        pool.Current.Should().Be(100);
        pool.Maximum.Should().Be(100);
        pool.IsFull.Should().BeTrue();
    }

    [Test]
    public void Constructor_WithStartAtZeroTrue_StartsAtZero()
    {
        var pool = new ResourcePool("rage", 100, startAtZero: true);
        pool.Current.Should().Be(0);
        pool.IsEmpty.Should().BeTrue();
    }

    [Test]
    public void Spend_WithSufficientResource_ReturnsTrue()
    {
        var pool = new ResourcePool("mana", 100);
        var result = pool.Spend(30);
        result.Should().BeTrue();
        pool.Current.Should().Be(70);
    }

    [Test]
    public void Spend_WithInsufficientResource_ReturnsFalse()
    {
        var pool = new ResourcePool("mana", 100);
        pool.Spend(80);
        var result = pool.Spend(30);
        result.Should().BeFalse();
        pool.Current.Should().Be(20);
    }

    [Test]
    public void Gain_IncreasesCurrentUpToMax()
    {
        var pool = new ResourcePool("rage", 100, startAtZero: true);
        var gained = pool.Gain(30);
        gained.Should().Be(30);
        pool.Current.Should().Be(30);
    }

    [Test]
    public void Gain_CapsAtMaximum()
    {
        var pool = new ResourcePool("mana", 100);
        pool.Spend(20);
        var gained = pool.Gain(50);
        gained.Should().Be(20);
        pool.Current.Should().Be(100);
    }

    [Test]
    public void Lose_DecreasesCurrentDownToZero()
    {
        var pool = new ResourcePool("rage", 100);
        pool.SetCurrent(30);
        var lost = pool.Lose(50);
        lost.Should().Be(30);
        pool.Current.Should().Be(0);
    }

    [Test]
    public void Percentage_ReturnsCorrectRatio()
    {
        var pool = new ResourcePool("mana", 100);
        pool.SetCurrent(75);
        pool.Percentage.Should().Be(0.75f);
    }

    [Test]
    public void SetMaximum_WithProportionalAdjust_ScalesCurrent()
    {
        var pool = new ResourcePool("mana", 100);
        pool.SetCurrent(50);
        pool.SetMaximum(200, adjustCurrentProportionally: true);
        pool.Maximum.Should().Be(200);
        pool.Current.Should().Be(100);
    }

    [Test]
    public void SetMaximum_WithoutProportionalAdjust_ClampsCurrent()
    {
        var pool = new ResourcePool("mana", 100);
        pool.SetCurrent(80);
        pool.SetMaximum(50, adjustCurrentProportionally: false);
        pool.Maximum.Should().Be(50);
        pool.Current.Should().Be(50);
    }
}
```

### ResourceService Tests (~10 tests)

```csharp
[TestFixture]
public class ResourceServiceTests
{
    private Mock<IConfigurationLoader> _configLoaderMock;
    private Mock<ILogger<ResourceService>> _loggerMock;
    private ResourceService _service;
    private List<ResourceTypeDefinition> _resourceTypes;

    [SetUp]
    public void Setup()
    {
        _configLoaderMock = new Mock<IConfigurationLoader>();
        _loggerMock = new Mock<ILogger<ResourceService>>();

        _resourceTypes = new List<ResourceTypeDefinition>
        {
            ResourceTypeDefinition.Create("health", "Vitality", "HP", "Life", "#FF0000", 100, isUniversal: true),
            ResourceTypeDefinition.Create("mana", "Arcane Power", "MP", "Magic", "#0066FF", 100, regenPerTurn: 10),
            ResourceTypeDefinition.Create("rage", "Fury", "RG", "Anger", "#FF6600", 100,
                decayPerTurn: 10, decayOnlyOutOfCombat: true,
                buildOnDamageDealt: 10, buildOnDamageTaken: 15, startsAtZero: true)
        };

        _configLoaderMock.Setup(x => x.LoadResourceTypes(It.IsAny<string>())).Returns(_resourceTypes);
        _service = new ResourceService(_configLoaderMock.Object, _loggerMock.Object);
    }

    [Test]
    public void GetResourceType_WithValidId_ReturnsType()
    {
        var result = _service.GetResourceType("mana");
        result.Should().NotBeNull();
        result!.DisplayName.Should().Be("Arcane Power");
    }

    [Test]
    public void InitializePlayerResources_SetsUniversalResources()
    {
        var player = new Player("Test");
        var classDef = ClassDefinition.Create("galdr-caster", "Galdr-Caster", "Desc", "mystic",
            StatModifiers.None, StatModifiers.None, "mana");

        _service.InitializePlayerResources(player, classDef);

        player.HasResource("health").Should().BeTrue();
        player.GetResource("health")!.Current.Should().Be(100);
    }

    [Test]
    public void InitializePlayerResources_SetsPrimaryResource()
    {
        var player = new Player("Test");
        var classDef = ClassDefinition.Create("galdr-caster", "Galdr-Caster", "Desc", "mystic",
            StatModifiers.None, StatModifiers.None, "mana");

        _service.InitializePlayerResources(player, classDef);

        player.HasResource("mana").Should().BeTrue();
        player.GetResource("mana")!.Current.Should().Be(100);
    }

    [Test]
    public void InitializePlayerResources_StartsAtZero_WhenConfigured()
    {
        var player = new Player("Test");
        var classDef = ClassDefinition.Create("shieldmaiden", "Shieldmaiden", "Desc", "warrior",
            StatModifiers.None, StatModifiers.None, "rage");

        _service.InitializePlayerResources(player, classDef);

        player.HasResource("rage").Should().BeTrue();
        player.GetResource("rage")!.Current.Should().Be(0);
    }

    [Test]
    public void SpendResource_WithSufficientAmount_ReturnsTrue()
    {
        var player = new Player("Test");
        player.InitializeResource("mana", 100);

        var result = _service.SpendResource(player, "mana", 30);

        result.Should().BeTrue();
        player.GetResource("mana")!.Current.Should().Be(70);
    }

    [Test]
    public void ProcessTurnEnd_AppliesRegeneration()
    {
        var player = new Player("Test");
        player.InitializeResource("mana", 100);
        player.GetResource("mana")!.Spend(50);

        var result = _service.ProcessTurnEnd(player);

        result.HasChanges.Should().BeTrue();
        player.GetResource("mana")!.Current.Should().Be(60);
    }

    [Test]
    public void ProcessTurnEnd_AppliesDecay_WhenOutOfCombat()
    {
        var player = new Player("Test");
        player.InitializeResource("rage", 100, startAtZero: true);
        player.GetResource("rage")!.Gain(50);

        var result = _service.ProcessTurnEnd(player, inCombat: false);

        result.HasChanges.Should().BeTrue();
        player.GetResource("rage")!.Current.Should().Be(40);
    }

    [Test]
    public void ProcessTurnEnd_SkipsDecay_WhenInCombat()
    {
        var player = new Player("Test");
        player.InitializeResource("rage", 100, startAtZero: true);
        player.GetResource("rage")!.Gain(50);

        var result = _service.ProcessTurnEnd(player, inCombat: true);

        player.GetResource("rage")!.Current.Should().Be(50);
    }

    [Test]
    public void ProcessCombatHit_BuildsResourceOnDamage()
    {
        var player = new Player("Test");
        player.InitializeResource("rage", 100, startAtZero: true);

        var result = _service.ProcessCombatHit(player, damageDealt: 10, damageTaken: 5);

        result.HasChanges.Should().BeTrue();
        player.GetResource("rage")!.Current.Should().Be(25);
    }
}
```

### Player Resource Integration Tests (~4 tests)

```csharp
[TestFixture]
public class PlayerResourceIntegrationTests
{
    [Test]
    public void Player_InitializeResource_AddsToResourceDictionary()
    {
        var player = new Player("Test");
        player.InitializeResource("mana", 100);

        player.Resources.Should().ContainKey("mana");
        player.HasResource("mana").Should().BeTrue();
    }

    [Test]
    public void Player_GetResource_ReturnsPool()
    {
        var player = new Player("Test");
        player.InitializeResource("mana", 100);

        var pool = player.GetResource("mana");

        pool.Should().NotBeNull();
        pool!.Maximum.Should().Be(100);
    }

    [Test]
    public void Player_GetResource_WithMissingResource_ReturnsNull()
    {
        var player = new Player("Test");

        var pool = player.GetResource("nonexistent");

        pool.Should().BeNull();
    }

    [Test]
    public void Player_MultipleResources_AllAccessible()
    {
        var player = new Player("Test");
        player.InitializeResource("health", 100);
        player.InitializeResource("mana", 80);

        player.Resources.Should().HaveCount(2);
        player.GetResource("health")!.Maximum.Should().Be(100);
        player.GetResource("mana")!.Maximum.Should().Be(80);
    }
}
```

---

## Acceptance Criteria

### AC-4b-1: Resource Type Configuration Loading
- [ ] Resource types load successfully from `config/resources.json`
- [ ] All 6 default resource types are present
- [ ] Invalid JSON produces clear error message
- [ ] Missing required fields produce validation error

### AC-4b-2: Player Resource Initialization
- [ ] Health is initialized for all players
- [ ] Primary class resource is initialized based on ClassDefinition
- [ ] Resources start at correct value (max or zero based on config)
- [ ] Multiple resources can coexist on same player

### AC-4b-3: Resource Display
- [ ] Status command shows all player resources
- [ ] Resources display with correct name and color
- [ ] Progress bar shows current/max ratio
- [ ] Percentage is calculated correctly

### AC-4b-4: Resource Spending
- [ ] SpendResource returns true when sufficient
- [ ] SpendResource returns false when insufficient
- [ ] Resource current value decreases correctly
- [ ] Spending zero is valid

### AC-4b-5: Resource Regeneration
- [ ] Mana regenerates +10 per turn
- [ ] Energy regenerates +20 per turn
- [ ] Faith regenerates +5 per turn
- [ ] Focus regenerates +8 per turn
- [ ] Regeneration does not exceed maximum

### AC-4b-6: Resource Decay
- [ ] Rage decays -10 per turn out of combat
- [ ] Rage does NOT decay during combat
- [ ] Decay does not go below zero

### AC-4b-7: Build-on-Hit Mechanics
- [ ] Rage gains +10 when dealing damage
- [ ] Rage gains +15 when taking damage
- [ ] Faith gains +15 when healing
- [ ] Build amounts cap at maximum

### AC-4b-8: Logging
- [ ] Service initialization logs resource type count
- [ ] Resource spending/gaining logs before/after values
- [ ] Turn end processing logs change count
- [ ] Warnings logged for missing resources

### AC-4b-9: Unit Tests
- [ ] All unit tests pass
- [ ] ~30 tests covering all mechanics
- [ ] Mocks used appropriately

---

## Documentation Requirements

### Code Documentation
- [ ] All public types have XML documentation
- [ ] All public methods have XML documentation
- [ ] `<remarks>` sections explain mechanics
- [ ] `<example>` tags show usage

### Configuration Documentation
- [ ] JSON schema file created
- [ ] Example configuration documented
- [ ] Mechanic descriptions in config comments

---

## Deliverable Checklist

### Domain Layer
- [ ] `ResourceTypeDefinition.cs` entity
- [ ] `ResourcePool.cs` value object
- [ ] `ResourceChange.cs` record
- [ ] `ResourceChangeResult.cs` record
- [ ] `ResourceChangeType.cs` enum
- [ ] Player entity updates (`Resources`, `GetResource()`, etc.)

### Application Layer
- [ ] `ResourceService.cs`
- [ ] `ResourceTypeDto.cs`
- [ ] `ResourcePoolDto.cs`
- [ ] DTO mapping extensions

### Infrastructure Layer
- [ ] `ConfigurationLoader` updates for resources
- [ ] `config/resources.json`
- [ ] `resources.schema.json`

### Presentation Layer
- [ ] Status view updates to show resources
- [ ] Resource bar rendering
- [ ] Resource change feedback display

### Tests
- [ ] `ResourceTypeDefinitionTests.cs`
- [ ] `ResourcePoolTests.cs`
- [ ] `ResourceServiceTests.cs`
- [ ] `PlayerResourceIntegrationTests.cs`

### Documentation
- [ ] XML documentation on all public members
- [ ] JSON schema file
- [ ] Update ROADMAP.md to mark items complete

---

## Dependencies

### Required from v0.0.4a
- `ClassDefinition.PrimaryResourceId` property
- `ClassService.ApplyClassToPlayer()` integration point
- Player entity with class assignment

### Provided to v0.0.4c
- `ResourceService.SpendResource()` for ability costs
- `ResourceService.GainResource()` for ability effects
- Player resource pools for ability validation

### Provided to v0.0.4d
- `ResourceService.ProcessTurnEnd()` for turn processing
- `ResourceService.ProcessCombatHit()` for combat integration
- Resource change results for UI feedback
