# v0.3.22b: The Inspector (Analysis Engine)

**Status:** Planned
**Parent Plan:** [v0.3.22](./v0.3.22.md)
**Dependencies:** `v0.1.3` (DataCapture/Codex)

## Overview
Currently, players have to guess enemy capabilities or memorize them. **v0.3.22b** leverages the existing Codex/DataCapture system to reward exploration. The more players know about an enemy (via Codex fragments), the more stats they can see during combat using the `inspect` command. This gamifies information gathering.

## Goals
1.  **Analysis Service:** Create a service to query `CodexEntry` progress and return a sanitized "Intel" object.
2.  **Inspect Command:** Implement `inspect <target>` in combat.
3.  **Visual Feedback:** Display a popup or panel with the gathered intel.

---

## 1. Architecture & Data Flow

### The Inspection Loop
1.  **User Input:** Player types `inspect draugr`.
2.  **Command Handling:** `CombatController` calls `AnalysisService.Inspect(target)`.
3.  **Data Resolution:**
    -   `AnalysisService` looks up the `CodexEntry` for "Draugr".
    -   Calculates `KnowledgeTier` (Unknown, Obscured, Known, Mastered) based on unlock percentage.
    -   *Bonus:* `Adept` archetype gets +1 Tier bonus.
4.  **Masking:** The service returns an `EnemyIntel` DTO with fields hidden/fuzzed based on the Tier.
5.  **Rendering:** `CombatScreenRenderer` (or a new helper) draws a modal overlay with the info.

### Knowledge Tiers
1.  **Unknown (0-24%):**
    -   Name: "Unknown Entity" (or basic visual desc).
    -   HP: "???"
    -   Resistances: Hidden.
2.  **Obscured (25-74%):**
    -   Name: "Rusted Draugr"
    -   HP: Narrative ("Wounded", "Healthy") - *Already standard, but maybe gives % estimate*.
    -   Resistances: "Resistant to Fire?" (Vague hints).
3.  **Known (75-99%):**
    -   HP: Exact Numbers (e.g., "45/100").
    -   Resistances: Explicit (e.g., "Fire: 50%").
    -   Abilities: List known abilities.
4.  **Mastered (100%):**
    -   All stats visible.
    -   Behavior hints (e.g., "Attacks lowest HP target").

---

## 2. Implementation Steps

### Step 1: Core Definitions
*   **Create `KnowledgeTier` Enum.**
*   **Create `EnemyIntel` DTO:**
    ```csharp
    public record EnemyIntel(
        string Name,
        string Description,
        string HpDisplay,
        List<string> KnownAbilities,
        List<string> Weaknesses,
        KnowledgeTier Tier
    );
    ```

### Step 2: Engine Services
*   **Create `AnalysisService`:**
    -   Inject `ICodexEntryRepository` (or `IDataCaptureService`).
    -   Method `Inspect(Combatant target)` -> `EnemyIntel`.
    -   Implement the masking logic.

### Step 3: Terminal Integration
*   **Update `CommandParser`:** Add `inspect` keyword.
*   **Update `CombatController`:** Handle the command -> call service -> set "InspectMode" in ViewModel? Or just log it?
    -   *Decision:* A modal popup is best, but TUI modals are tricky. A dedicated "Intel Panel" in the log or a temporary overlay in the Grid area might work.
    -   *Approach:* `CombatViewModel` gets an `ActiveInspection` property. If set, `CombatScreenRenderer` draws an overlay box over the grid.

---

## 3. Detailed Changes

### A. `RuneAndRust.Engine/Services/AnalysisService.cs`
```csharp
public class AnalysisService : IAnalysisService {
    // ... logic to check DataCapture progress ...
    public EnemyIntel Inspect(Combatant target) {
        // ...
    }
}
```

### B. `RuneAndRust.Terminal/Rendering/InspectWindowRenderer.cs`
A static helper to draw the box.
```csharp
public static Panel Render(EnemyIntel intel) {
    // Spectre.Console panel with "Secret" style borders
}
```

### C. `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs`
-   In `Render(vm)`, check `if (vm.ActiveInspection != null)`.
-   If true, call `InspectWindowRenderer.Render` and overlay it (or print it).

---

## 4. Verification & Testing

*   **Unit Tests:**
    -   `AnalysisServiceTests`:
        -   `Inspect_Unknown_ReturnsFuzzedData`
        -   `Inspect_Mastered_ReturnsExactData`
        -   `Inspect_Adept_ReturnsBonusTier`
*   **Integration Tests:**
    -   Seed a Codex entry with 0% and 100%. Check inspection results for both.

## 5. Pre-Commit Checks
-   [ ] Verify Codex dependencies are available.
-   [ ] Ensure `inspect` command doesn't crash if target is invalid.
