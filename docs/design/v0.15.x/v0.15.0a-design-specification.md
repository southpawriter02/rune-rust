# v0.15.0a Design Specification: Core Dice Mechanics Refactor

**Version:** 0.15.0a
**Theme:** Core Dice Mechanics Refactor
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.14.x Complete (prior version series)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Success-Counting Mechanics](#4-success-counting-mechanics)
5. [DiceRollResult Refactor](#5-dicerollresult-refactor)
6. [DiceConstants Static Class](#6-diceconstants-static-class)
7. [DiceService Refactor](#7-diceservice-refactor)
8. [Data Model Changes](#8-data-model-changes)
9. [Configuration](#9-configuration)
10. [Commands](#10-commands)
11. [User-Facing Changes](#11-user-facing-changes)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Future Considerations](#17-future-considerations)
18. [Implementation Notes](#18-implementation-notes)
19. [Document Metadata](#19-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.0a, the Core Dice Mechanics Refactor. This part fundamentally changes the dice pool system from a **total-based mechanic** (sum all dice, compare to DC) to a **success-counting mechanic** (count dice showing 8-10 as successes, count 1s as botches, calculate net successes). This foundational change is required before implementing skill system expansions in v0.15.1+, which depend on fumble detection, critical success thresholds, and degrees of success.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Success Model** | Sum all dice, add modifier, compare total to DC | Count dice showing 8, 9, 10 as successes (30% per die) |
| **Botch Model** | `IsNaturalOne`: first die = 1 (only flags, no penalty) | All 1s count as botches (10% per die), subtract from successes |
| **Net Successes** | N/A (uses raw totals) | `Successes - Botches` (minimum 0) |
| **Critical Success** | `IsNaturalMax`: first die = max value | Net Successes ≥ 5 |
| **Fumble** | `IsNaturalOne`: first die = 1 | 0 Successes AND ≥1 Botch |
| **Result Type** | Sum-based integer comparison | Success-count-based comparison |

### 1.3 Scope

**In Scope:**
- Refactor `DiceRollResult` value object with success-counting properties
- Create `DiceConstants` static class with threshold values
- Refactor `DiceService.Roll()` to count successes and botches
- Add fumble detection logic (0 successes + ≥1 botch)
- Add critical success detection logic (net ≥ 5)
- Preserve `RawTotal` for damage calculations (backward compatibility)
- Update unit tests for new mechanics

**Out of Scope:**
- Seeded random provider (`IRandomProvider`) - v0.15.0b
- Skill check service refactor - v0.15.0c
- Contested and extended checks - v0.15.0d
- Dice roll logging infrastructure - v0.15.0e
- Combat integration (hit quality) - v0.15.0f
- `SkillOutcome` enum expansion - v0.15.0c
- Degrees of success classification - v0.15.0c

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Value Objects | 1 | `DiceRollResult` (refactored) |
| Static Classes | 1 | `DiceConstants` |
| Services | 1 | `DiceService` (refactored roll logic) |
| Unit Tests | ~8 | Success counting, botch, fumble, critical tests |

---

## 2. Dependencies

### 2.1 Required Existing Components

| Component | Location | Purpose in v0.15.0a |
|-----------|----------|---------------------|
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Refactor to add success-counting properties |
| `DicePool` | `Domain/ValueObjects/DicePool.cs` | Input to roll; unchanged |
| `DiceService` | `Application/Services/DiceService.cs` | Refactor roll logic to count successes |
| `IDiceService` | `Domain/Interfaces/IDiceService.cs` | Interface; may need minor updates |
| `AdvantageType` | `Domain/Enums/AdvantageType.cs` | Unchanged; advantage still rolls twice |
| `DiceType` | `Domain/Enums/DiceType.cs` | Unchanged |

### 2.2 Current DiceRollResult Properties (to be modified)

```csharp
// Current properties in DiceRollResult
public DicePool Pool { get; init; }
public IReadOnlyList<int> Rolls { get; init; }
public IReadOnlyList<int> ExplosionRolls { get; init; }
public int DiceTotal { get; init; }           // Sum of all dice
public int Total { get; init; }               // Sum + modifier
public AdvantageType AdvantageType { get; init; }
public IReadOnlyList<int> AllRollTotals { get; init; }
public int SelectedRollIndex { get; init; }
public bool IsNaturalMax { get; }             // First die = max
public bool IsNaturalOne { get; }             // First die = 1
public bool HadExplosions { get; }
public int ExplosionCount { get; }
```

### 2.3 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.0b | `SeededRandomProvider` | Consumes roll results for logging |
| v0.15.0c | `SkillCheckService` | Uses `NetSuccesses`, `IsFumble`, `IsCriticalSuccess` |
| v0.15.0d | `ContestedCheckResult` | Compares `NetSuccesses` between parties |
| v0.15.0f | `CombatService` | Uses `NetSuccesses` for hit quality classification |

---

## 3. Architecture Diagrams

### 3.1 Success-Counting Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SUCCESS-COUNTING DICE ROLL FLOW                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INPUT: DicePool (e.g., 5d10)                                               │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        ROLL DICE                                     │    │
│  │                                                                      │    │
│  │  Example: 5d10 → [1, 4, 8, 9, 1]                                    │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                     COUNT SUCCESSES                                  │    │
│  │                                                                      │    │
│  │  Success = die shows 8, 9, or 10  (30% probability per die)         │    │
│  │                                                                      │    │
│  │  [1, 4, 8, 9, 1]                                                    │    │
│  │       ×  ×  ✓  ✓  ×                                                 │    │
│  │                                                                      │    │
│  │  TotalSuccesses = 2  (8 and 9)                                      │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                       COUNT BOTCHES                                  │    │
│  │                                                                      │    │
│  │  Botch = die shows 1  (10% probability per die)                     │    │
│  │                                                                      │    │
│  │  [1, 4, 8, 9, 1]                                                    │    │
│  │   ✗  ×  ×  ×  ✗                                                     │    │
│  │                                                                      │    │
│  │  TotalBotches = 2  (two 1s)                                         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                   CALCULATE NET SUCCESSES                            │    │
│  │                                                                      │    │
│  │  NetSuccesses = max(0, Successes - Botches)                         │    │
│  │                                                                      │    │
│  │  NetSuccesses = max(0, 2 - 2) = 0                                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    DETECT SPECIAL OUTCOMES                           │    │
│  │                                                                      │    │
│  │  IsFumble = (Successes == 0) AND (Botches >= 1)                     │    │
│  │           = (2 == 0) AND (2 >= 1) = false AND true = FALSE          │    │
│  │                                                                      │    │
│  │  IsCriticalSuccess = (NetSuccesses >= 5)                            │    │
│  │                    = (0 >= 5) = FALSE                               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  OUTPUT: DiceRollResult                                                     │
│          {                                                                   │
│              Rolls: [1, 4, 8, 9, 1],                                        │
│              TotalSuccesses: 2,                                             │
│              TotalBotches: 2,                                               │
│              NetSuccesses: 0,                                               │
│              IsFumble: false,                                               │
│              IsCriticalSuccess: false,                                      │
│              RawTotal: 23  (preserved for damage)                           │
│          }                                                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Fumble Detection Example

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         FUMBLE DETECTION EXAMPLE                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Roll: 3d10 → [1, 4, 2]                                                     │
│                                                                              │
│  Successes:  0  (no 8, 9, or 10)                                            │
│  Botches:    1  (one 1)                                                     │
│  NetSuccesses: max(0, 0 - 1) = 0                                            │
│                                                                              │
│  FUMBLE CHECK:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  IsFumble = (Successes == 0) AND (Botches >= 1)                     │    │
│  │           = (0 == 0) AND (1 >= 1)                                   │    │
│  │           = true AND true                                           │    │
│  │           = TRUE  ← FUMBLE!                                         │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  When IsFumble is true:                                                     │
│  - NetSuccesses is forced to 0 (redundant in this case)                     │
│  - Skill checks result in CriticalFailure outcome (v0.15.0c)                │
│  - Fumble consequences apply (v0.15.1+)                                     │
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  NON-FUMBLE WITH BOTCHES:                                                   │
│                                                                              │
│  Roll: 4d10 → [1, 8, 3, 10]                                                 │
│                                                                              │
│  Successes:  2  (8 and 10)                                                  │
│  Botches:    1  (one 1)                                                     │
│  NetSuccesses: max(0, 2 - 1) = 1                                            │
│                                                                              │
│  FUMBLE CHECK:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  IsFumble = (Successes == 0) AND (Botches >= 1)                     │    │
│  │           = (2 == 0) AND (1 >= 1)                                   │    │
│  │           = false AND true                                          │    │
│  │           = FALSE  ← Not a fumble                                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  The botch reduced NetSuccesses from 2 to 1, but did not cause fumble.     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Critical Success Detection Example

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      CRITICAL SUCCESS DETECTION EXAMPLE                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Roll: 6d10 → [8, 9, 10, 8, 9, 1]                                           │
│                                                                              │
│  Successes:  5  (8, 9, 10, 8, 9)                                            │
│  Botches:    1  (one 1)                                                     │
│  NetSuccesses: max(0, 5 - 1) = 4                                            │
│                                                                              │
│  CRITICAL CHECK:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  IsCriticalSuccess = (NetSuccesses >= 5)                            │    │
│  │                    = (4 >= 5)                                       │    │
│  │                    = FALSE  ← Not critical                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Roll: 7d10 → [8, 9, 10, 8, 9, 10, 3]                                       │
│                                                                              │
│  Successes:  6  (8, 9, 10, 8, 9, 10)                                        │
│  Botches:    0  (no 1s)                                                     │
│  NetSuccesses: max(0, 6 - 0) = 6                                            │
│                                                                              │
│  CRITICAL CHECK:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  IsCriticalSuccess = (NetSuccesses >= 5)                            │    │
│  │                    = (6 >= 5)                                       │    │
│  │                    = TRUE  ← CRITICAL SUCCESS!                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  When IsCriticalSuccess is true:                                            │
│  - Skill checks may result in CriticalSuccess outcome (v0.15.0c)            │
│  - Combat hits become critical hits with bonus effects (v0.15.0f)           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  ValueObjects/                                                       │    │
│  │  ├── DiceRollResult.cs  ←── REFACTORED (add success-counting props)│    │
│  │  └── DicePool.cs        ←── UNCHANGED                              │    │
│  │                                                                      │    │
│  │  Interfaces/                                                         │    │
│  │  └── IDiceService.cs    ←── UNCHANGED (return type already correct) │    │
│  │                                                                      │    │
│  │  Enums/                                                              │    │
│  │  ├── AdvantageType.cs   ←── UNCHANGED                              │    │
│  │  └── DiceType.cs        ←── UNCHANGED                              │    │
│  │                                                                      │    │
│  │  Constants/                                                          │    │
│  │  └── DiceConstants.cs   ←── NEW                                    │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ implements                                │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Services/                                                           │    │
│  │  └── DiceService.cs     ←── REFACTORED (count successes logic)     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. Success-Counting Mechanics

### 4.1 Core Probability Model

The success-counting mechanic uses a d10 dice pool where:

| Die Result | Classification | Probability |
|------------|----------------|-------------|
| 1 | Botch | 10% |
| 2-7 | Neutral | 60% |
| 8, 9, 10 | Success | 30% |

### 4.2 Expected Values by Pool Size

| Pool Size | Expected Successes | Expected Botches | Expected Net |
|-----------|-------------------|------------------|--------------|
| 1d10 | 0.3 | 0.1 | 0.2 |
| 2d10 | 0.6 | 0.2 | 0.4 |
| 3d10 | 0.9 | 0.3 | 0.6 |
| 4d10 | 1.2 | 0.4 | 0.8 |
| 5d10 | 1.5 | 0.5 | 1.0 |
| 6d10 | 1.8 | 0.6 | 1.2 |
| 7d10 | 2.1 | 0.7 | 1.4 |
| 8d10 | 2.4 | 0.8 | 1.6 |
| 9d10 | 2.7 | 0.9 | 1.8 |
| 10d10 | 3.0 | 1.0 | 2.0 |

### 4.3 Fumble Probability by Pool Size

Fumble requires: 0 successes AND ≥1 botch

| Pool Size | P(0 Successes) | P(≥1 Botch) | P(Fumble) |
|-----------|----------------|-------------|-----------|
| 1d10 | 70% | 10% | ~7.0% |
| 2d10 | 49% | 19% | ~9.3% |
| 3d10 | 34.3% | 27.1% | ~9.3% |
| 4d10 | 24.0% | 34.4% | ~8.3% |
| 5d10 | 16.8% | 40.9% | ~6.9% |
| 6d10 | 11.8% | 46.9% | ~5.5% |

**Note:** Fumble probability peaks around 2-3 dice, then decreases as larger pools are more likely to get at least one success.

### 4.4 Critical Success Probability by Pool Size

Critical requires: Net Successes ≥ 5

| Pool Size | P(Critical Success) | Notes |
|-----------|---------------------|-------|
| 1-5d10 | <1% | Very rare |
| 6d10 | ~1.5% | Possible with no botches |
| 7d10 | ~4% | More achievable |
| 8d10 | ~8% | Reasonable chance |
| 9d10 | ~14% | Good chance |
| 10d10 | ~20% | Likely for experts |

---

## 5. DiceRollResult Refactor

### 5.1 Refactored DiceRollResult Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DiceRollResult.cs`

```csharp
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of rolling a dice pool using success-counting mechanics.
/// </summary>
/// <remarks>
/// <para>
/// Immutable value object containing all roll details including individual dice,
/// success counts, botch counts, and special outcome detection.
/// </para>
/// <para>
/// Success-Counting Mechanics:
/// <list type="bullet">
///   <item><description>Success: Die shows 8, 9, or 10 (30% probability)</description></item>
///   <item><description>Botch: Die shows 1 (10% probability)</description></item>
///   <item><description>Net Successes: Successes - Botches (minimum 0)</description></item>
///   <item><description>Fumble: 0 successes AND ≥1 botch</description></item>
///   <item><description>Critical Success: Net successes ≥ 5</description></item>
/// </list>
/// </para>
/// </remarks>
public readonly record struct DiceRollResult
{
    /// <summary>The dice pool that was rolled.</summary>
    public DicePool Pool { get; init; }

    /// <summary>Individual dice results before any modifier.</summary>
    public IReadOnlyList<int> Rolls { get; init; }

    /// <summary>Additional rolls from exploding dice.</summary>
    public IReadOnlyList<int> ExplosionRolls { get; init; }

    /// <summary>
    /// Count of dice showing success values (8, 9, or 10).
    /// </summary>
    /// <remarks>
    /// Each die has a 30% chance of being a success.
    /// Includes both base rolls and explosion rolls.
    /// </remarks>
    public int TotalSuccesses { get; init; }

    /// <summary>
    /// Count of dice showing botch value (1).
    /// </summary>
    /// <remarks>
    /// Each die has a 10% chance of being a botch.
    /// Botches reduce the net success count.
    /// Includes both base rolls and explosion rolls.
    /// </remarks>
    public int TotalBotches { get; init; }

    /// <summary>
    /// Net successes after subtracting botches (minimum 0).
    /// </summary>
    /// <remarks>
    /// Formula: max(0, TotalSuccesses - TotalBotches)
    /// This is the primary value used for skill check comparisons.
    /// </remarks>
    public int NetSuccesses { get; init; }

    /// <summary>
    /// Whether this roll is a critical success (net successes ≥ 5).
    /// </summary>
    /// <remarks>
    /// Critical successes provide exceptional outcomes in skill checks
    /// and combat, such as bonus damage or special effects.
    /// </remarks>
    public bool IsCriticalSuccess { get; init; }

    /// <summary>
    /// Whether this roll is a fumble (0 successes AND ≥1 botch).
    /// </summary>
    /// <remarks>
    /// Fumbles represent catastrophic failures that may incur
    /// additional consequences beyond simple failure.
    /// </remarks>
    public bool IsFumble { get; init; }

    /// <summary>
    /// Raw sum of all dice values (preserved for damage calculations).
    /// </summary>
    /// <remarks>
    /// Damage rolls still use sum-based mechanics, not success-counting.
    /// This property provides backward compatibility for those systems.
    /// </remarks>
    public int RawTotal { get; init; }

    /// <summary>
    /// Total including pool modifier (preserved for legacy compatibility).
    /// </summary>
    /// <remarks>
    /// Equivalent to RawTotal + Pool.Modifier.
    /// Maintained for backward compatibility with existing code.
    /// </remarks>
    public int Total { get; init; }

    /// <summary>Advantage type used for this roll.</summary>
    public AdvantageType AdvantageType { get; init; }

    /// <summary>All roll totals made (for advantage/disadvantage comparison).</summary>
    public IReadOnlyList<int> AllRollTotals { get; init; }

    /// <summary>Index of the selected roll (0 for normal, 0 or 1 for advantage/disadvantage).</summary>
    public int SelectedRollIndex { get; init; }

    /// <summary>
    /// True if the first die rolled its maximum value.
    /// </summary>
    /// <remarks>
    /// Preserved for backward compatibility. In the new system,
    /// use <see cref="IsCriticalSuccess"/> for critical detection.
    /// </remarks>
    [Obsolete("Use IsCriticalSuccess for success-counting mechanics. IsNaturalMax preserved for damage rolls only.")]
    public bool IsNaturalMax => Rolls.Count > 0 && Rolls[0] == Pool.Faces;

    /// <summary>
    /// True if the first die rolled a 1.
    /// </summary>
    /// <remarks>
    /// Preserved for backward compatibility. In the new system,
    /// use <see cref="IsFumble"/> for fumble detection.
    /// </remarks>
    [Obsolete("Use IsFumble for success-counting mechanics. IsNaturalOne preserved for damage rolls only.")]
    public bool IsNaturalOne => Rolls.Count > 0 && Rolls[0] == 1;

    /// <summary>True if any dice exploded.</summary>
    public bool HadExplosions => ExplosionRolls.Count > 0;

    /// <summary>Number of explosions that occurred.</summary>
    public int ExplosionCount => ExplosionRolls.Count;

    /// <summary>
    /// Total number of dice evaluated (base rolls + explosions).
    /// </summary>
    public int TotalDiceEvaluated => Rolls.Count + ExplosionRolls.Count;

    /// <summary>
    /// Creates a roll result with success-counting properties calculated.
    /// </summary>
    /// <param name="pool">The dice pool that was rolled.</param>
    /// <param name="rolls">Individual die results.</param>
    /// <param name="explosionRolls">Explosion roll results (optional).</param>
    /// <param name="advantageType">Advantage type used.</param>
    /// <param name="allRollTotals">All roll totals for advantage/disadvantage.</param>
    /// <param name="selectedRollIndex">Index of selected roll.</param>
    public DiceRollResult(
        DicePool pool,
        IReadOnlyList<int> rolls,
        AdvantageType advantageType = AdvantageType.Normal,
        IReadOnlyList<int>? explosionRolls = null,
        IReadOnlyList<int>? allRollTotals = null,
        int selectedRollIndex = 0)
    {
        Pool = pool;
        Rolls = rolls;
        ExplosionRolls = explosionRolls ?? Array.Empty<int>();
        AdvantageType = advantageType;
        SelectedRollIndex = selectedRollIndex;

        // Combine base rolls and explosions for counting
        var allDice = rolls.Concat(ExplosionRolls).ToList();

        // Count successes and botches
        TotalSuccesses = allDice.Count(d => d >= DiceConstants.SuccessThreshold);
        TotalBotches = allDice.Count(d => d == DiceConstants.BotchValue);

        // Calculate net successes (minimum 0)
        NetSuccesses = Math.Max(0, TotalSuccesses - TotalBotches);

        // Detect special outcomes
        IsFumble = TotalSuccesses == 0 && TotalBotches > 0;
        IsCriticalSuccess = NetSuccesses >= DiceConstants.CriticalSuccessNet;

        // Calculate raw totals (for damage and backward compatibility)
        RawTotal = allDice.Sum();
        Total = RawTotal + pool.Modifier;

        // For advantage/disadvantage, store all totals
        AllRollTotals = allRollTotals ?? new[] { Total };
    }

    /// <summary>
    /// Returns a formatted string showing the roll breakdown with success counts.
    /// </summary>
    /// <example>
    /// "5d10: [1, 4, 8, 9, 1] → 2 successes - 2 botches = 0 net"
    /// "3d10: [8, 9, 10] → 3 successes - 0 botches = 3 net [CRITICAL!]"
    /// </example>
    public override string ToString()
    {
        var rollsStr = $"[{string.Join(", ", Rolls)}]";

        if (HadExplosions)
            rollsStr += $" + explosions [{string.Join(", ", ExplosionRolls)}]";

        var result = $"{Pool}: {rollsStr} → {TotalSuccesses} successes - {TotalBotches} botches = {NetSuccesses} net";

        if (IsFumble)
            result += " [FUMBLE!]";
        else if (IsCriticalSuccess)
            result += " [CRITICAL!]";

        if (AdvantageType != AdvantageType.Normal)
        {
            var allRolls = string.Join(", ", AllRollTotals);
            var typeStr = AdvantageType == AdvantageType.Advantage ? "ADV" : "DIS";
            result += $" ({typeStr}: [{allRolls}])";
        }

        return result;
    }

    /// <summary>
    /// Returns a formatted string showing legacy sum-based breakdown.
    /// </summary>
    /// <remarks>
    /// Use for damage rolls or other sum-based mechanics.
    /// </remarks>
    public string ToSumString()
    {
        var rollsStr = $"[{string.Join(", ", Rolls)}]";

        if (HadExplosions)
            rollsStr += $" + explosions [{string.Join(", ", ExplosionRolls)}]";

        var result = $"{Pool}: {rollsStr}";

        if (Pool.Modifier != 0)
        {
            var modSign = Pool.Modifier > 0 ? "+" : "";
            result += $" {modSign}{Pool.Modifier}";
        }

        result += $" = {Total}";

        return result;
    }
}
```

### 5.2 Property Summary Table

| Property | Type | Description | New/Modified |
|----------|------|-------------|--------------|
| `Pool` | `DicePool` | The dice pool rolled | Unchanged |
| `Rolls` | `IReadOnlyList<int>` | Individual die results | Unchanged |
| `ExplosionRolls` | `IReadOnlyList<int>` | Explosion die results | Unchanged |
| `TotalSuccesses` | `int` | Count of 8, 9, 10 | **New** |
| `TotalBotches` | `int` | Count of 1s | **New** |
| `NetSuccesses` | `int` | Successes - Botches (min 0) | **New** |
| `IsCriticalSuccess` | `bool` | Net ≥ 5 | **New** |
| `IsFumble` | `bool` | 0 successes AND ≥1 botch | **New** |
| `RawTotal` | `int` | Sum of all dice | **New** |
| `Total` | `int` | RawTotal + modifier | Modified (was sum-based) |
| `AdvantageType` | `AdvantageType` | Advantage/disadvantage | Unchanged |
| `AllRollTotals` | `IReadOnlyList<int>` | For adv/dis comparison | Unchanged |
| `SelectedRollIndex` | `int` | Selected roll index | Unchanged |
| `IsNaturalMax` | `bool` | First die = max | **Obsolete** |
| `IsNaturalOne` | `bool` | First die = 1 | **Obsolete** |
| `HadExplosions` | `bool` | Any explosions occurred | Unchanged |
| `ExplosionCount` | `int` | Number of explosions | Unchanged |
| `TotalDiceEvaluated` | `int` | Rolls + explosions count | **New** |

---

## 6. DiceConstants Static Class

### 6.1 Constants Definition

**File:** `src/Core/RuneAndRust.Domain/Constants/DiceConstants.cs`

```csharp
namespace RuneAndRust.Domain.Constants;

/// <summary>
/// Constants for the success-counting dice system.
/// </summary>
/// <remarks>
/// <para>
/// These values define the core mechanics of the dice pool system:
/// <list type="bullet">
///   <item><description>Success threshold: dice showing 8-10 count as successes</description></item>
///   <item><description>Botch value: dice showing 1 count as botches</description></item>
///   <item><description>Critical threshold: 5+ net successes for critical success</description></item>
/// </list>
/// </para>
/// <para>
/// Probability per d10:
/// <list type="bullet">
///   <item><description>Success (8, 9, 10): 30%</description></item>
///   <item><description>Botch (1): 10%</description></item>
///   <item><description>Neutral (2-7): 60%</description></item>
/// </list>
/// </para>
/// </remarks>
public static class DiceConstants
{
    /// <summary>
    /// Minimum die value that counts as a success (8, 9, or 10).
    /// </summary>
    /// <remarks>
    /// A d10 showing 8, 9, or 10 counts as one success.
    /// This gives a 30% success rate per die.
    /// </remarks>
    public const int SuccessThreshold = 8;

    /// <summary>
    /// Die value that counts as a botch (1).
    /// </summary>
    /// <remarks>
    /// A d10 showing 1 counts as one botch.
    /// Botches subtract from the success count.
    /// This gives a 10% botch rate per die.
    /// </remarks>
    public const int BotchValue = 1;

    /// <summary>
    /// Minimum net successes required for a critical success.
    /// </summary>
    /// <remarks>
    /// When net successes (successes - botches) reaches 5 or more,
    /// the result is considered a critical success with bonus effects.
    /// </remarks>
    public const int CriticalSuccessNet = 5;

    /// <summary>
    /// Minimum dice pool size. Always roll at least 1 die.
    /// </summary>
    /// <remarks>
    /// Even with severe penalties, a character always rolls at least 1d10.
    /// This ensures some chance of success in any situation.
    /// </remarks>
    public const int MinimumPool = 1;

    /// <summary>
    /// Probability of success per die (30%).
    /// </summary>
    /// <remarks>
    /// Three values out of ten (8, 9, 10) count as successes.
    /// </remarks>
    public const float SuccessProbability = 0.30f;

    /// <summary>
    /// Probability of botch per die (10%).
    /// </summary>
    /// <remarks>
    /// One value out of ten (1) counts as a botch.
    /// </remarks>
    public const float BotchProbability = 0.10f;

    /// <summary>
    /// Probability of neutral result per die (60%).
    /// </summary>
    /// <remarks>
    /// Six values out of ten (2-7) are neutral, neither success nor botch.
    /// </remarks>
    public const float NeutralProbability = 0.60f;

    /// <summary>
    /// Maximum value on a d10.
    /// </summary>
    public const int D10MaxValue = 10;

    /// <summary>
    /// Minimum value on a d10.
    /// </summary>
    public const int D10MinValue = 1;
}
```

---

## 7. DiceService Refactor

### 7.1 Updated Roll Logic

**File:** `src/Core/RuneAndRust.Application/Services/DiceService.cs`

The `DiceService` requires updates to produce `DiceRollResult` objects with success-counting properties.

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Core dice rolling service using success-counting mechanics.
/// </summary>
/// <remarks>
/// <para>
/// Supports standard dice pools with success-counting, exploding dice,
/// and advantage/disadvantage rolls.
/// </para>
/// <para>
/// Success-counting mechanics:
/// <list type="bullet">
///   <item><description>Dice showing 8-10 count as successes</description></item>
///   <item><description>Dice showing 1 count as botches</description></item>
///   <item><description>Net successes = successes - botches (min 0)</description></item>
///   <item><description>Fumble = 0 successes AND ≥1 botch</description></item>
///   <item><description>Critical = net ≥ 5</description></item>
/// </list>
/// </para>
/// </remarks>
public class DiceService : IDiceService
{
    private readonly Random _random;
    private readonly ILogger<DiceService> _logger;
    private readonly IGameEventLogger? _eventLogger;

    /// <summary>
    /// Creates a new DiceService.
    /// </summary>
    /// <param name="logger">Logger for diagnostics.</param>
    /// <param name="random">Optional Random instance for deterministic testing.</param>
    /// <param name="eventLogger">Optional game event logger.</param>
    public DiceService(
        ILogger<DiceService> logger,
        Random? random = null,
        IGameEventLogger? eventLogger = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _random = random ?? new Random();
        _eventLogger = eventLogger;
        _logger.LogInformation("DiceService initialized with success-counting mechanics");
    }

    /// <summary>
    /// Rolls a dice pool and returns the result with success counts.
    /// </summary>
    /// <param name="pool">The dice pool to roll.</param>
    /// <param name="advantageType">Whether to roll with advantage or disadvantage.</param>
    /// <returns>The complete roll result with success-counting breakdown.</returns>
    public DiceRollResult Roll(DicePool pool, AdvantageType advantageType = AdvantageType.Normal)
    {
        _logger.LogDebug("Rolling {Pool} with {AdvantageType}", pool, advantageType);

        if (advantageType == AdvantageType.Normal)
        {
            return RollOnce(pool, advantageType);
        }

        // Roll twice for advantage/disadvantage
        var roll1 = RollOnce(pool, advantageType);
        var roll2 = RollOnce(pool, advantageType);

        // For success-counting, compare NetSuccesses (not Total)
        var allTotals = new[] { roll1.NetSuccesses, roll2.NetSuccesses };
        var selectedIndex = advantageType == AdvantageType.Advantage
            ? (roll1.NetSuccesses >= roll2.NetSuccesses ? 0 : 1)
            : (roll1.NetSuccesses <= roll2.NetSuccesses ? 0 : 1);

        var selectedRoll = selectedIndex == 0 ? roll1 : roll2;

        // Reconstruct with advantage info
        var result = new DiceRollResult(
            pool,
            selectedRoll.Rolls,
            advantageType,
            selectedRoll.ExplosionRolls,
            allTotals,
            selectedIndex);

        _logger.LogInformation(
            "Roll {Pool} ({AdvantageType}): [{Roll1}, {Roll2}] net successes -> {Selected} selected",
            pool, advantageType, roll1.NetSuccesses, roll2.NetSuccesses, result.NetSuccesses);

        LogRollEvent(result);

        return result;
    }

    /// <summary>
    /// Parses dice notation and rolls.
    /// </summary>
    /// <param name="notation">Dice notation (e.g., "3d10").</param>
    /// <param name="advantageType">Advantage/disadvantage.</param>
    /// <returns>Roll result with success counts.</returns>
    /// <exception cref="FormatException">If notation is invalid.</exception>
    public DiceRollResult Roll(string notation, AdvantageType advantageType = AdvantageType.Normal)
    {
        var pool = DicePool.Parse(notation);
        return Roll(pool, advantageType);
    }

    /// <summary>
    /// Convenience method for rolling a single die type.
    /// </summary>
    /// <param name="diceType">Type of die to roll.</param>
    /// <param name="count">Number of dice (default 1).</param>
    /// <param name="modifier">Modifier to add (default 0).</param>
    /// <returns>Roll result with success counts.</returns>
    public DiceRollResult Roll(DiceType diceType, int count = 1, int modifier = 0)
    {
        var pool = new DicePool(count, diceType, modifier);
        return Roll(pool);
    }

    /// <summary>
    /// Rolls a dice pool specifically for damage (sum-based, not success-counting).
    /// </summary>
    /// <param name="pool">The dice pool to roll.</param>
    /// <returns>Roll result; use RawTotal or Total for damage value.</returns>
    /// <remarks>
    /// Damage rolls use sum-based mechanics. Use the RawTotal property
    /// for the damage value before modifiers, or Total for final damage.
    /// </remarks>
    public DiceRollResult RollDamage(DicePool pool)
    {
        var result = Roll(pool);
        _logger.LogDebug("Damage roll {Pool}: {Total} total", pool, result.Total);
        return result;
    }

    /// <summary>
    /// Quick roll returning net successes (for skill checks).
    /// </summary>
    /// <param name="pool">The dice pool to roll.</param>
    /// <returns>The net success count.</returns>
    public int RollNetSuccesses(DicePool pool) => Roll(pool).NetSuccesses;

    /// <summary>
    /// Quick roll returning just the raw total (for damage).
    /// </summary>
    /// <param name="pool">The dice pool to roll.</param>
    /// <returns>The total result (sum-based).</returns>
    public int RollTotal(DicePool pool) => Roll(pool).Total;

    /// <summary>
    /// Quick roll from notation returning just the total.
    /// </summary>
    /// <param name="notation">Dice notation (e.g., "3d6+5").</param>
    /// <returns>The total result (sum-based).</returns>
    public int RollTotal(string notation) => Roll(notation).Total;

    /// <summary>
    /// Performs a single roll of the dice pool.
    /// </summary>
    private DiceRollResult RollOnce(DicePool pool, AdvantageType advantageType)
    {
        // Enforce minimum pool size
        var actualCount = Math.Max(DiceConstants.MinimumPool, pool.Count);
        var actualPool = actualCount != pool.Count
            ? new DicePool(actualCount, pool.DiceType, pool.Modifier, pool.Exploding, pool.MaxExplosions)
            : pool;

        var rolls = new List<int>();
        var explosions = new List<int>();

        // Roll each die
        for (var i = 0; i < actualPool.Count; i++)
        {
            var roll = RollSingleDie(actualPool.Faces);
            rolls.Add(roll);

            // Handle exploding dice
            if (actualPool.Exploding && roll == actualPool.Faces)
            {
                var explosionCount = 0;
                var explosionRoll = roll;

                while (explosionRoll == actualPool.Faces && explosionCount < actualPool.MaxExplosions)
                {
                    explosionRoll = RollSingleDie(actualPool.Faces);
                    explosions.Add(explosionRoll);
                    explosionCount++;

                    _logger.LogDebug(
                        "Die exploded! Roll {Explosion} on d{Faces} (explosion {Count})",
                        explosionRoll, actualPool.Faces, explosionCount);
                }
            }
        }

        // Create result (constructor handles success counting)
        var result = new DiceRollResult(
            actualPool,
            rolls.AsReadOnly(),
            advantageType,
            explosions.AsReadOnly());

        _logger.LogDebug(
            "Rolled {Pool}: dice=[{Rolls}] explosions=[{Explosions}] → {Successes}S - {Botches}B = {Net} net{Special}",
            actualPool,
            string.Join(",", rolls),
            string.Join(",", explosions),
            result.TotalSuccesses,
            result.TotalBotches,
            result.NetSuccesses,
            result.IsFumble ? " [FUMBLE]" : result.IsCriticalSuccess ? " [CRITICAL]" : "");

        return result;
    }

    /// <summary>
    /// Rolls a single die with the specified number of faces.
    /// </summary>
    private int RollSingleDie(int faces) => _random.Next(1, faces + 1);

    /// <summary>
    /// Logs a roll event to the game event logger if available.
    /// </summary>
    private void LogRollEvent(DiceRollResult result)
    {
        _eventLogger?.LogDice("DiceRolled", $"{result.Pool} → {result.NetSuccesses} net successes",
            data: new Dictionary<string, object>
            {
                ["pool"] = result.Pool.ToString(),
                ["rolls"] = result.Rolls.ToArray(),
                ["totalSuccesses"] = result.TotalSuccesses,
                ["totalBotches"] = result.TotalBotches,
                ["netSuccesses"] = result.NetSuccesses,
                ["isFumble"] = result.IsFumble,
                ["isCriticalSuccess"] = result.IsCriticalSuccess,
                ["rawTotal"] = result.RawTotal,
                ["advantageType"] = result.AdvantageType.ToString()
            });
    }
}
```

### 7.2 Key Changes Summary

| Method | Change |
|--------|--------|
| `Roll(DicePool, AdvantageType)` | Compares `NetSuccesses` for advantage/disadvantage instead of `Total` |
| `RollOnce(DicePool, AdvantageType)` | Enforces minimum pool; constructor handles counting |
| `RollNetSuccesses(DicePool)` | **New** - Returns net successes for skill checks |
| `RollDamage(DicePool)` | **New** - Explicit method for sum-based damage rolls |
| `LogRollEvent()` | Updated to log success-counting properties |

---

## 8. Data Model Changes

### 8.1 New Types Summary

| Type | Layer | File | Description |
|------|-------|------|-------------|
| `DiceConstants` | Domain | `Constants/DiceConstants.cs` | Static class with threshold values |

### 8.2 Modified Types Summary

| Type | Layer | File | Changes |
|------|-------|------|---------|
| `DiceRollResult` | Domain | `ValueObjects/DiceRollResult.cs` | Added success-counting properties, modified constructor |

### 8.3 Unchanged Types

| Type | Layer | Notes |
|------|-------|-------|
| `DicePool` | Domain | No changes required |
| `IDiceService` | Domain | Interface unchanged (return type already `DiceRollResult`) |
| `AdvantageType` | Domain | No changes required |
| `DiceType` | Domain | No changes required |

---

## 9. Configuration

### 9.1 No New Configuration Files

v0.15.0a does not introduce new configuration files. Constants are defined in `DiceConstants.cs` as compile-time values.

### 9.2 Future Configuration (v0.15.0e)

Configuration files for dice system parameters will be introduced in v0.15.0e along with the logging infrastructure:

**Planned: `config/dice-system.json`**
```json
{
  "$schema": "./schemas/dice-system.schema.json",
  "successThreshold": 8,
  "botchValue": 1,
  "criticalSuccessNet": 5,
  "minimumPool": 1
}
```

This is documented here for context but is **out of scope** for v0.15.0a.

---

## 10. Commands

### 10.1 No Command Changes

v0.15.0a does not modify any user-facing commands. The `roll` command will continue to work but will display success-counting output.

### 10.2 Command Output Changes

The `roll` command output will change to show success counts:

**Before (sum-based):**
```
> roll 5d10
Rolling 5d10...
5d10: [3, 7, 8, 2, 9] = 29
```

**After (success-counting):**
```
> roll 5d10
Rolling 5d10...
5d10: [3, 7, 8, 2, 9] → 2 successes - 0 botches = 2 net
```

---

## 11. User-Facing Changes

### 11.1 Roll Output Format

| Scenario | Old Format | New Format |
|----------|------------|------------|
| Normal roll | `5d10: [3,7,8,2,9] = 29` | `5d10: [3,7,8,2,9] → 2S - 0B = 2 net` |
| With fumble | `3d10: [1,4,2] = 7` | `3d10: [1,4,2] → 0S - 1B = 0 net [FUMBLE!]` |
| With critical | `6d10: [8,9,10,8,9,10] = 54` | `6d10: [8,9,10,8,9,10] → 6S - 0B = 6 net [CRITICAL!]` |
| With botches | `4d10: [1,8,3,1] = 13` | `4d10: [1,8,3,1] → 1S - 2B = 0 net` |

### 11.2 Skill Check Output Changes

Skill check rendering (handled by other services, not DiceService) will need updates in v0.15.0c. For v0.15.0a, the raw DiceRollResult provides the necessary data.

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `DiceService` | Information | Roll results with net successes |
| `DiceService` | Debug | Individual die rolls, explosions, counting details |
| `DiceService` | Debug | Fumble/critical detection |

### 12.2 Log Message Formats

```
[Information] Roll 5d10 (Normal): [3, 7, 8, 2, 9] → 2 successes - 0 botches = 2 net
[Information] Roll 3d10 (Normal): [1, 4, 2] → 0 successes - 1 botches = 0 net [FUMBLE]
[Information] Roll 6d10 (Advantage): [3, 5] net successes -> 5 selected
[Debug] Rolled 5d10: dice=[3,7,8,2,9] explosions=[] → 2S - 0B = 2 net
[Debug] Die exploded! Roll 7 on d10 (explosion 1)
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Success counting | 2 |
| Botch counting | 2 |
| Net successes calculation | 2 |
| Fumble detection | 1 |
| Critical success detection | 1 |
| **Total** | **~8** |

### 13.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/DiceRollResultSuccessCountingTests.cs`

```csharp
[TestFixture]
public class DiceRollResultSuccessCountingTests
{
    [Test]
    public void TotalSuccesses_CountsDiceShowingEightNineOrTen()
    {
        // Arrange: rolls with known successes
        var pool = new DicePool(5, DiceType.D10);
        var rolls = new[] { 3, 7, 8, 9, 10 };  // 3 successes (8, 9, 10)

        // Act
        var result = new DiceRollResult(pool, rolls);

        // Assert
        Assert.That(result.TotalSuccesses, Is.EqualTo(3));
    }

    [Test]
    public void TotalSuccesses_ReturnsZero_WhenNoSuccessValues()
    {
        var pool = new DicePool(4, DiceType.D10);
        var rolls = new[] { 1, 2, 5, 7 };  // No 8, 9, or 10

        var result = new DiceRollResult(pool, rolls);

        Assert.That(result.TotalSuccesses, Is.EqualTo(0));
    }

    [Test]
    public void TotalBotches_CountsDiceShowingOne()
    {
        var pool = new DicePool(5, DiceType.D10);
        var rolls = new[] { 1, 4, 1, 8, 1 };  // 3 botches (three 1s)

        var result = new DiceRollResult(pool, rolls);

        Assert.That(result.TotalBotches, Is.EqualTo(3));
    }

    [Test]
    public void TotalBotches_ReturnsZero_WhenNoOnes()
    {
        var pool = new DicePool(4, DiceType.D10);
        var rolls = new[] { 2, 5, 8, 10 };  // No 1s

        var result = new DiceRollResult(pool, rolls);

        Assert.That(result.TotalBotches, Is.EqualTo(0));
    }

    [Test]
    public void NetSuccesses_EqualsSuccessesMinusBotches()
    {
        var pool = new DicePool(5, DiceType.D10);
        var rolls = new[] { 1, 8, 9, 1, 10 };  // 3 successes, 2 botches

        var result = new DiceRollResult(pool, rolls);

        Assert.That(result.TotalSuccesses, Is.EqualTo(3));
        Assert.That(result.TotalBotches, Is.EqualTo(2));
        Assert.That(result.NetSuccesses, Is.EqualTo(1));  // 3 - 2 = 1
    }

    [Test]
    public void NetSuccesses_MinimumIsZero_WhenBotchesExceedSuccesses()
    {
        var pool = new DicePool(4, DiceType.D10);
        var rolls = new[] { 1, 1, 1, 8 };  // 1 success, 3 botches

        var result = new DiceRollResult(pool, rolls);

        Assert.That(result.TotalSuccesses, Is.EqualTo(1));
        Assert.That(result.TotalBotches, Is.EqualTo(3));
        Assert.That(result.NetSuccesses, Is.EqualTo(0));  // max(0, 1-3) = 0
    }

    [Test]
    public void IsFumble_TrueWhen_ZeroSuccessesAndAtLeastOneBotch()
    {
        var pool = new DicePool(3, DiceType.D10);
        var rolls = new[] { 1, 4, 2 };  // 0 successes, 1 botch

        var result = new DiceRollResult(pool, rolls);

        Assert.That(result.TotalSuccesses, Is.EqualTo(0));
        Assert.That(result.TotalBotches, Is.EqualTo(1));
        Assert.That(result.IsFumble, Is.True);
    }

    [Test]
    public void IsCriticalSuccess_TrueWhen_NetSuccessesAtLeastFive()
    {
        var pool = new DicePool(6, DiceType.D10);
        var rolls = new[] { 8, 9, 10, 8, 9, 10 };  // 6 successes, 0 botches

        var result = new DiceRollResult(pool, rolls);

        Assert.That(result.NetSuccesses, Is.EqualTo(6));
        Assert.That(result.IsCriticalSuccess, Is.True);
    }
}
```

**File:** `tests/RuneAndRust.Application.UnitTests/Services/DiceServiceSuccessCountingTests.cs`

```csharp
[TestFixture]
public class DiceServiceSuccessCountingTests
{
    private Mock<ILogger<DiceService>> _mockLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<DiceService>>();
    }

    [Test]
    public void Roll_ReturnsCorrectNumberOfDice()
    {
        var service = new DiceService(_mockLogger.Object);
        var pool = new DicePool(5, DiceType.D10);

        var result = service.Roll(pool);

        Assert.That(result.Rolls, Has.Count.EqualTo(5));
    }

    [Test]
    public void Roll_SuccessesCountedCorrectly_ForKnownSeed()
    {
        // Use seeded random for deterministic verification
        var seededRandom = new Random(42);
        var service = new DiceService(_mockLogger.Object, seededRandom);

        var result = service.Roll(new DicePool(10, DiceType.D10));

        // With seeded random, we can verify counting logic works
        var expectedSuccesses = result.Rolls.Count(r => r >= 8);
        var expectedBotches = result.Rolls.Count(r => r == 1);

        Assert.That(result.TotalSuccesses, Is.EqualTo(expectedSuccesses));
        Assert.That(result.TotalBotches, Is.EqualTo(expectedBotches));
    }

    [Test]
    public void Roll_MinimumPoolEnforced_WhenPoolSizeIsZeroOrNegative()
    {
        var service = new DiceService(_mockLogger.Object);

        // This would throw in current DicePool, but service should enforce minimum
        // If DicePool allows 0, service should still roll at least 1
        var pool = new DicePool(1, DiceType.D10);  // Use valid pool for now

        var result = service.Roll(pool);

        Assert.That(result.Rolls.Count, Is.GreaterThanOrEqualTo(DiceConstants.MinimumPool));
    }

    [Test]
    public void Roll_WithAdvantage_SelectsHigherNetSuccesses()
    {
        // Multiple trials to ensure advantage logic is correct
        var service = new DiceService(_mockLogger.Object);

        for (int i = 0; i < 50; i++)
        {
            var result = service.Roll(new DicePool(3, DiceType.D10), AdvantageType.Advantage);

            // AllRollTotals now contains net successes
            Assert.That(result.NetSuccesses, Is.EqualTo(result.AllRollTotals.Max()));
        }
    }

    [Test]
    public void Roll_WithDisadvantage_SelectsLowerNetSuccesses()
    {
        var service = new DiceService(_mockLogger.Object);

        for (int i = 0; i < 50; i++)
        {
            var result = service.Roll(new DicePool(3, DiceType.D10), AdvantageType.Disadvantage);

            Assert.That(result.NetSuccesses, Is.EqualTo(result.AllRollTotals.Min()));
        }
    }

    [Test]
    public void Roll_RawTotalPreserved_ForDamageCalculations()
    {
        var seededRandom = new Random(42);
        var service = new DiceService(_mockLogger.Object, seededRandom);

        var result = service.Roll(new DicePool(3, DiceType.D10));

        // RawTotal should be sum of all dice
        var expectedSum = result.Rolls.Sum();
        Assert.That(result.RawTotal, Is.EqualTo(expectedSum));
    }
}
```

---

## 14. Use Cases

### 14.1 UC-150a-001: Perform Skill Check Roll

**Actor:** Player
**Flow:** Player requests skill check → System rolls dice pool → System counts successes/botches → System returns result with net successes

**Details:**
1. Player initiates skill check (e.g., `check acrobatics`)
2. SkillCheckService calculates dice pool (attribute + skill rank + modifiers)
3. DiceService.Roll() is called with the pool
4. DiceRollResult contains TotalSuccesses, TotalBotches, NetSuccesses
5. SkillCheckService compares NetSuccesses to DC (v0.15.0c)
6. Result displayed to player

### 14.2 UC-150a-002: Detect Fumble

**Actor:** System
**Flow:** Player rolls → System detects 0 successes + ≥1 botch → Fumble flagged

**Details:**
1. DiceService rolls the pool
2. Constructor counts: TotalSuccesses = 0, TotalBotches ≥ 1
3. IsFumble property set to true
4. Downstream systems (v0.15.0c+) apply fumble consequences

### 14.3 UC-150a-003: Detect Critical Success

**Actor:** System
**Flow:** Player rolls → System calculates net ≥ 5 → Critical flagged

**Details:**
1. DiceService rolls the pool
2. Constructor calculates: NetSuccesses = Successes - Botches
3. If NetSuccesses ≥ 5, IsCriticalSuccess = true
4. Downstream systems apply critical bonuses

### 14.4 UC-150a-004: Roll Damage (Sum-Based)

**Actor:** System
**Flow:** Combat resolves hit → System rolls damage → Sum-based total used

**Details:**
1. CombatService determines hit (using NetSuccesses from attack roll)
2. DiceService.RollDamage() called for damage dice
3. DiceRollResult.RawTotal or .Total used for damage value
4. Success-counting properties ignored for damage

---

## 15. Deliverable Checklist

### 15.1 Domain Layer

- [ ] `DiceConstants.cs` created in `Domain/Constants/`
- [ ] `DiceRollResult.cs` refactored with success-counting properties
- [ ] `DiceRollResult` constructor calculates successes, botches, net
- [ ] `DiceRollResult.ToString()` updated for success-counting format
- [ ] `DiceRollResult.ToSumString()` added for legacy format

### 15.2 Application Layer

- [ ] `DiceService.Roll()` updated for success-counting
- [ ] `DiceService.RollOnce()` enforces minimum pool
- [ ] `DiceService.RollNetSuccesses()` convenience method added
- [ ] `DiceService.RollDamage()` method added for clarity
- [ ] Advantage/disadvantage compares NetSuccesses

### 15.3 Unit Tests

- [ ] `DiceRollResultSuccessCountingTests.cs` created (~8 tests)
- [ ] `DiceServiceSuccessCountingTests.cs` updated
- [ ] All existing dice tests updated/passing
- [ ] Success counting verified
- [ ] Botch counting verified
- [ ] Fumble detection verified
- [ ] Critical success detection verified

### 15.4 Documentation

- [ ] This design specification complete
- [ ] Code XML documentation complete

---

## 16. Acceptance Criteria

### 16.1 Functional

- [ ] Dice showing 8, 9, or 10 are counted as successes
- [ ] Dice showing 1 are counted as botches
- [ ] Net successes = max(0, successes - botches)
- [ ] Fumble detected when 0 successes AND ≥1 botch
- [ ] Critical success detected when net ≥ 5
- [ ] Minimum pool size of 1 enforced
- [ ] RawTotal preserved for damage calculations
- [ ] Advantage selects higher NetSuccesses
- [ ] Disadvantage selects lower NetSuccesses
- [ ] Exploding dice counted for successes/botches

### 16.2 Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~8 new unit tests pass
- [ ] All existing dice-related tests pass (updated)
- [ ] XML documentation complete on all public members

---

## 17. Future Considerations

### 17.1 Deferred to v0.15.0b (Seeded Random Provider)

- `IRandomProvider` interface
- `SeededRandomProvider` implementation
- `IRngContextService` for context-aware seeding
- Save/restore RNG state

### 17.2 Deferred to v0.15.0c (Skill Check Refactor)

- `SkillOutcome` enum expansion (6 tiers)
- `SkillCheckResult` refactor
- Degrees of success classification
- Margin calculation (NetSuccesses - DC)

### 17.3 Deferred to v0.15.0d (Contested & Extended Checks)

- `ContestedCheckResult` value object
- `ExtendedCheckState` entity
- Accumulated successes over rounds

### 17.4 Deferred to v0.15.0e (Dice Roll Logging)

- `IDiceRollLogger` interface
- `DiceRollLog` record
- Configuration file support
- Roll history retrieval

### 17.5 Deferred to v0.15.0f (Combat Integration)

- `HitQuality` enum based on NetSuccesses
- Combat attack resolution updates
- Damage roll clarification (sum-based)

---

## 18. Implementation Notes

### 18.1 Backward Compatibility

The `Total` and `RawTotal` properties preserve sum-based functionality for:
- Damage rolls (continue using sum)
- Any legacy code expecting totals
- Existing tests that check totals

The `IsNaturalMax` and `IsNaturalOne` properties are marked `[Obsolete]` but preserved for damage roll critical detection.

### 18.2 Migration Path

1. Add `DiceConstants` (no breaking changes)
2. Add new properties to `DiceRollResult` (additive)
3. Update constructor to calculate new properties
4. Update `DiceService` roll methods
5. Update tests to verify new behavior
6. Mark legacy properties as obsolete

### 18.3 Testing Strategy

Use seeded `Random` instances for deterministic testing. With a known seed, the exact dice values are predictable, allowing verification of counting logic.

Example:
```csharp
var seededRandom = new Random(42);
var service = new DiceService(logger, seededRandom);
// Rolls will be deterministic
```

---

## 19. Document Metadata

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*

---

*This design specification provides the detailed blueprint for implementing v0.15.0a Core Dice Mechanics Refactor. This is the foundational change required before implementing skill system expansions in v0.15.1+.*
