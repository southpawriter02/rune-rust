# v0.0.6c Implementation Plan: Status Effect Framework

**Version:** 0.0.6c
**Parent:** v0.0.6 (Enhanced Combat System)
**Prerequisites:** v0.0.6a Complete (Multi-Monster Combat Foundation)
**Status:** Ready for Implementation
**Target Tests:** ~236 -> ~261 (+25 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Infrastructure Layer](#infrastructure-layer)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Build the comprehensive status effect framework that supports buffs, debuffs, and environmental effects. This phase establishes all 28 effect definitions, the application/removal mechanics, duration tracking, stacking rules, DoT/HoT processing, and stat modification calculations. Combat integration is deferred to v0.0.6d.

### Scope

**In Scope:**
- `EffectCategory` enum (Debuff, Buff, Environmental)
- `DurationType` enum (Turns, Permanent, Triggered, ResourceBased)
- `StackingRule` enum (RefreshDuration, Stack, Block)
- `StatModifierType` enum (Flat, Percentage, Override)
- `StatModifier` value object for stat modifications
- `StatusEffectDefinition` entity with all configuration options
- `ActiveStatusEffect` class for tracking applied effects
- `EffectApplicationResult` and `EffectTickResult` value objects
- `IEffectTarget` interface for entities that can have effects
- `StatusEffectService` for apply/remove/tick operations
- `StatCalculator` for computing effective stats
- `IStatusEffectRepository` and JSON-based implementation
- Player and Monster modifications to implement `IEffectTarget`
- All 28 effect definitions in JSON configuration
- JSON schema for validation

**Out of Scope (v0.0.6d):**
- Combat integration (applying effects on hit)
- Effect interactions (Wet + Lightning → Stun)
- Cleanse mechanics
- UI display of active effects
- AI behavior modification by effects

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Effect storage | In-memory list per entity | Simple, sufficient for combat duration |
| Stacking rule source | JSON configuration | Data-driven, easily adjustable |
| Stat calculation order | Flat → Percentage → Override | Standard RPG pattern |
| DoT/HoT timing | Start of turn | Predictable, matches initiative flow |
| Effect definition loading | Singleton repository | Effects are immutable definitions |
| Buff stacking | Always Block | Prevents OP stacking exploits |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.6a (Multi-Monster Combat)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `CombatEncounter` | `Domain/Entities/CombatEncounter.cs` | Turn processing context |
| `Combatant` | `Domain/Entities/Combatant.cs` | Effect target wrapper |
| `CombatState` | `Domain/Enums/CombatState.cs` | Combat state checks |

### Dependencies from v0.0.6b (Monster AI & Flee)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `CombatLogEntry` | `Domain/Entities/CombatLogEntry.cs` | Log DoT/HoT ticks |
| `CombatLogType` | `Domain/Enums/CombatLogType.cs` | StatusApplied, StatusExpired types |
| `CombatLogService` | `Application/Services/CombatLogService.cs` | Effect event logging |

### Dependencies from v0.0.4 (Core Systems)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Player` | `Domain/Entities/Player.cs` | Implement IEffectTarget |
| `Monster` | `Domain/Entities/Monster.cs` | Implement IEffectTarget |
| `Stats` | `Domain/ValueObjects/Stats.cs` | Base stat values |
| `IGameConfigurationProvider` | `Application/Interfaces/` | Effect definition loading |

---

## Current System Analysis

### Existing Entity Structure

**Player Entity** (`src/Core/RuneAndRust.Domain/Entities/Player.cs`):
- Has `Health`, `Stats`, `TakeDamage()`, `Heal()` methods
- No effect tracking infrastructure
- No immunity system

**Monster Entity** (`src/Core/RuneAndRust.Domain/Entities/Monster.cs`):
- Has `Health`, `Stats`, `TakeDamage()` methods
- Has `Heal()` method (added in v0.0.6b)
- No effect tracking infrastructure
- No immunity system

### New Status Effect Flow

```
EFFECT APPLICATION
    │
    ├── StatusEffectService.ApplyEffect(effectId, target, source)
    │   ├── Get definition from repository
    │   ├── Check immunity
    │   │   └── If immune → Return Immune result
    │   ├── Check existing effect
    │   │   ├── RefreshDuration → Refresh and return
    │   │   ├── Stack → Add stacks and return
    │   │   └── Block → Return Blocked result
    │   └── Create and add ActiveStatusEffect
    │
    └── Return EffectApplicationResult

TURN PROCESSING
    │
    ├── StatusEffectService.TickEffects(target)
    │   ├── For each active effect:
    │   │   ├── Calculate DoT damage → Apply to target
    │   │   ├── Calculate HoT healing → Apply to target
    │   │   ├── Decrement duration
    │   │   └── Check expiration
    │   └── Remove expired effects
    │
    └── Return list of EffectTickResults

STAT CALCULATION
    │
    ├── StatCalculator.CalculateStat(target, statId, baseValue)
    │   ├── Gather all modifiers for stat
    │   ├── Check for Override → Return override value
    │   ├── Sum flat modifiers
    │   ├── Multiply percentage modifiers
    │   └── Return final value (min 0)
    │
    └── Return effective stat value
```

---

## Detailed Implementation

### Domain Layer

#### 1. EffectCategory.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/EffectCategory.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categorizes status effects by their general nature.
/// </summary>
/// <remarks>
/// <para>Categories determine default behavior for cleansing and UI display.</para>
/// <para>Buffs are beneficial, Debuffs are harmful, Environmental are neutral conditions.</para>
/// </remarks>
public enum EffectCategory
{
    /// <summary>
    /// Negative effects that harm or hinder the target.
    /// Can be cleansed by purify effects.
    /// </summary>
    Debuff,

    /// <summary>
    /// Positive effects that help or enhance the target.
    /// Can be dispelled by enemy abilities.
    /// </summary>
    Buff,

    /// <summary>
    /// Effects from environmental conditions.
    /// May interact with other effects (e.g., Wet + Lightning).
    /// </summary>
    Environmental
}
```

#### 2. DurationType.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/DurationType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines how a status effect's duration is tracked.
/// </summary>
public enum DurationType
{
    /// <summary>
    /// Effect lasts a fixed number of turns.
    /// Duration decrements at the start of the affected entity's turn.
    /// </summary>
    Turns,

    /// <summary>
    /// Effect lasts until explicitly removed.
    /// Used for persistent conditions like On Fire.
    /// </summary>
    Permanent,

    /// <summary>
    /// Effect lasts until a specific trigger occurs.
    /// Example: Knocked Down removed when taking Stand action.
    /// </summary>
    Triggered,

    /// <summary>
    /// Effect lasts until its resource pool is depleted.
    /// Example: Shielded absorbs damage until shield HP is gone.
    /// </summary>
    ResourceBased
}
```

#### 3. StackingRule.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/StackingRule.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines how a status effect behaves when applied to a target that already has it.
/// </summary>
/// <remarks>
/// <para>Stacking rules are configured per effect in the status-effects.json file.</para>
/// <para>Design decision: All buffs use Block to prevent overpowered stacking.</para>
/// </remarks>
public enum StackingRule
{
    /// <summary>
    /// Reapplication refreshes duration to maximum.
    /// Used by: Bleeding, Poisoned, Burning, Frozen, Weakened, Slowed, Exhausted, Wet, Chilled.
    /// </summary>
    RefreshDuration,

    /// <summary>
    /// Reapplication increases intensity/stacks up to a maximum.
    /// Each stack increases the effect's power (e.g., more DoT damage).
    /// </summary>
    Stack,

    /// <summary>
    /// Reapplication is blocked/resisted while effect is active.
    /// Used by: All buffs, Stunned, Blinded, Feared, Silenced, Cursed, Disarmed, On Fire, Electrified.
    /// </summary>
    Block
}
```

#### 4. StatModifierType.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/StatModifierType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines how a stat modifier is applied to a base value.
/// </summary>
/// <remarks>
/// <para>Application order: Flat modifiers first, then Percentage, then Override.</para>
/// <para>Override takes complete precedence and ignores other modifiers.</para>
/// </remarks>
public enum StatModifierType
{
    /// <summary>
    /// Adds a flat value to the stat.
    /// Example: +2 Attack, -3 Defense.
    /// Applied first in calculation order.
    /// </summary>
    Flat,

    /// <summary>
    /// Multiplies the stat by a percentage.
    /// Example: +30% Attack (value = 0.3), -50% Speed (value = -0.5).
    /// Applied after flat modifiers.
    /// </summary>
    Percentage,

    /// <summary>
    /// Sets the stat to a specific value, ignoring all other modifiers.
    /// Rarely used, for special effects that set stats absolutely.
    /// </summary>
    Override
}
```

#### 5. EffectApplicationOutcome.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/EffectApplicationOutcome.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Outcome of attempting to apply a status effect.
/// </summary>
public enum EffectApplicationOutcome
{
    /// <summary>Effect was newly applied to the target.</summary>
    Applied,

    /// <summary>Existing effect duration was refreshed.</summary>
    Refreshed,

    /// <summary>Existing effect stacks were increased.</summary>
    Stacked,

    /// <summary>Effect was blocked due to stacking rules (already active).</summary>
    Blocked,

    /// <summary>Target is immune to this effect.</summary>
    Immune,

    /// <summary>Effect definition was not found.</summary>
    NotFound
}
```

#### 6. StatModifier.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/StatModifier.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a modification to a combat stat.
/// </summary>
/// <remarks>
/// <para>StatModifier is an immutable value object that defines how a stat is changed.</para>
/// <para>Modifiers from multiple effects are aggregated by <see cref="Services.StatCalculator"/>.</para>
/// </remarks>
/// <param name="StatId">The stat being modified (e.g., "attack", "defense", "speed").</param>
/// <param name="ModifierType">How the modification is applied (Flat, Percentage, Override).</param>
/// <param name="Value">The modification value. For Percentage, use decimal (0.3 = +30%).</param>
public readonly record struct StatModifier(
    string StatId,
    StatModifierType ModifierType,
    float Value)
{
    /// <summary>
    /// Applies this modifier to a base value.
    /// </summary>
    /// <param name="baseValue">The base stat value before modification.</param>
    /// <returns>The modified value.</returns>
    public int Apply(int baseValue)
    {
        return ModifierType switch
        {
            StatModifierType.Flat => baseValue + (int)Value,
            StatModifierType.Percentage => (int)(baseValue * (1 + Value)),
            StatModifierType.Override => (int)Value,
            _ => baseValue
        };
    }

    /// <summary>
    /// Creates a flat modifier that adds/subtracts a fixed value.
    /// </summary>
    /// <param name="statId">The stat to modify.</param>
    /// <param name="value">The flat value to add (negative to subtract).</param>
    /// <returns>A flat stat modifier.</returns>
    public static StatModifier Flat(string statId, int value) =>
        new(statId, StatModifierType.Flat, value);

    /// <summary>
    /// Creates a percentage modifier that multiplies the stat.
    /// </summary>
    /// <param name="statId">The stat to modify.</param>
    /// <param name="percentage">The percentage as decimal (0.3 = +30%, -0.5 = -50%).</param>
    /// <returns>A percentage stat modifier.</returns>
    public static StatModifier Percentage(string statId, float percentage) =>
        new(statId, StatModifierType.Percentage, percentage);

    /// <summary>
    /// Creates an override modifier that sets the stat to a specific value.
    /// </summary>
    /// <param name="statId">The stat to modify.</param>
    /// <param name="value">The override value.</param>
    /// <returns>An override stat modifier.</returns>
    public static StatModifier Override(string statId, int value) =>
        new(statId, StatModifierType.Override, value);

    /// <summary>
    /// Returns a display string for this modifier.
    /// </summary>
    public override string ToString()
    {
        return ModifierType switch
        {
            StatModifierType.Flat when Value >= 0 => $"{StatId} +{Value:F0}",
            StatModifierType.Flat => $"{StatId} {Value:F0}",
            StatModifierType.Percentage when Value >= 0 => $"{StatId} +{Value * 100:F0}%",
            StatModifierType.Percentage => $"{StatId} {Value * 100:F0}%",
            StatModifierType.Override => $"{StatId} = {Value:F0}",
            _ => $"{StatId}: {Value}"
        };
    }
}
```

#### 7. EffectApplicationResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EffectApplicationResult.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of attempting to apply a status effect to a target.
/// </summary>
/// <remarks>
/// <para>Provides detailed information about what happened during effect application.</para>
/// <para>Used for combat log messages and UI feedback.</para>
/// </remarks>
/// <param name="Applied">Whether the effect was successfully applied or modified.</param>
/// <param name="EffectId">The effect definition ID.</param>
/// <param name="EffectName">The effect display name.</param>
/// <param name="Outcome">The specific outcome of the application attempt.</param>
/// <param name="NewStacks">Current stack count (if applicable).</param>
/// <param name="NewDuration">Current duration in turns (if applicable).</param>
/// <param name="Message">Human-readable result message.</param>
public readonly record struct EffectApplicationResult(
    bool Applied,
    string EffectId,
    string EffectName,
    EffectApplicationOutcome Outcome,
    int? NewStacks,
    int? NewDuration,
    string Message)
{
    /// <summary>
    /// Creates a result for a newly applied effect.
    /// </summary>
    public static EffectApplicationResult Success(
        string effectId,
        string effectName,
        int stacks,
        int? duration) =>
        new(true, effectId, effectName, EffectApplicationOutcome.Applied,
            stacks, duration, $"{effectName} applied");

    /// <summary>
    /// Creates a result for a duration refresh.
    /// </summary>
    public static EffectApplicationResult Refreshed(
        string effectId,
        string effectName,
        int newDuration) =>
        new(true, effectId, effectName, EffectApplicationOutcome.Refreshed,
            null, newDuration, $"{effectName} duration refreshed");

    /// <summary>
    /// Creates a result for increased stacks.
    /// </summary>
    public static EffectApplicationResult Stacked(
        string effectId,
        string effectName,
        int newStacks,
        int? duration) =>
        new(true, effectId, effectName, EffectApplicationOutcome.Stacked,
            newStacks, duration, $"{effectName} stacked to {newStacks}");

    /// <summary>
    /// Creates a result for a blocked application.
    /// </summary>
    public static EffectApplicationResult Blocked(string effectId, string effectName) =>
        new(false, effectId, effectName, EffectApplicationOutcome.Blocked,
            null, null, $"{effectName} resisted (already active)");

    /// <summary>
    /// Creates a result for an immune target.
    /// </summary>
    public static EffectApplicationResult Immune(string effectId, string effectName) =>
        new(false, effectId, effectName, EffectApplicationOutcome.Immune,
            null, null, $"Immune to {effectName}");

    /// <summary>
    /// Creates a result for an unknown effect.
    /// </summary>
    public static EffectApplicationResult NotFound(string effectId) =>
        new(false, effectId, effectId, EffectApplicationOutcome.NotFound,
            null, null, $"Unknown effect: {effectId}");
}
```

#### 8. EffectTickResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EffectTickResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of ticking a status effect at the start of a turn.
/// </summary>
/// <remarks>
/// <para>Captures DoT damage, HoT healing, and expiration for combat log and UI.</para>
/// </remarks>
/// <param name="EffectId">The effect definition ID.</param>
/// <param name="EffectName">The effect display name.</param>
/// <param name="DamageDealt">Damage dealt by DoT (0 if none).</param>
/// <param name="HealingDone">Healing from HoT (0 if none).</param>
/// <param name="Expired">Whether the effect expired this tick.</param>
/// <param name="RemainingDuration">Turns remaining (null if not turn-based).</param>
public readonly record struct EffectTickResult(
    string EffectId,
    string EffectName,
    int DamageDealt,
    int HealingDone,
    bool Expired,
    int? RemainingDuration)
{
    /// <summary>
    /// Creates a tick result for a DoT effect.
    /// </summary>
    public static EffectTickResult WithDamage(
        string effectId,
        string effectName,
        int damage,
        bool expired,
        int? remaining) =>
        new(effectId, effectName, damage, 0, expired, remaining);

    /// <summary>
    /// Creates a tick result for a HoT effect.
    /// </summary>
    public static EffectTickResult WithHealing(
        string effectId,
        string effectName,
        int healing,
        bool expired,
        int? remaining) =>
        new(effectId, effectName, 0, healing, expired, remaining);

    /// <summary>
    /// Creates a tick result for a non-DoT/HoT effect.
    /// </summary>
    public static EffectTickResult Ticked(
        string effectId,
        string effectName,
        bool expired,
        int? remaining) =>
        new(effectId, effectName, 0, 0, expired, remaining);

    /// <summary>
    /// Whether this tick caused any damage or healing.
    /// </summary>
    public bool HadEffect => DamageDealt > 0 || HealingDone > 0;

    /// <summary>
    /// Returns a display string for this tick result.
    /// </summary>
    public override string ToString()
    {
        if (DamageDealt > 0)
            return $"{EffectName}: {DamageDealt} damage{(Expired ? " (expired)" : "")}";
        if (HealingDone > 0)
            return $"{EffectName}: {HealingDone} healing{(Expired ? " (expired)" : "")}";
        if (Expired)
            return $"{EffectName} expired";
        return $"{EffectName}: {RemainingDuration} turns remaining";
    }
}
```

#### 9. StatusEffectDefinition.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Definitions/StatusEffectDefinition.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a status effect's properties and behavior.
/// </summary>
/// <remarks>
/// <para>StatusEffectDefinition is an immutable configuration entity loaded from JSON.</para>
/// <para>Instances are shared across all active effects of the same type.</para>
/// </remarks>
public class StatusEffectDefinition
{
    // ═══════════════════════════════════════════════════════════════
    // IDENTITY
    // ═══════════════════════════════════════════════════════════════

    /// <summary>Unique identifier for this effect (e.g., "bleeding", "hasted").</summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>Display name for this effect.</summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>Description of what this effect does.</summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>Category of this effect (Debuff, Buff, Environmental).</summary>
    public EffectCategory Category { get; private set; }

    /// <summary>Icon identifier for UI display.</summary>
    public string? IconId { get; private set; }

    // ═══════════════════════════════════════════════════════════════
    // DURATION
    // ═══════════════════════════════════════════════════════════════

    /// <summary>How duration is tracked for this effect.</summary>
    public DurationType DurationType { get; private set; }

    /// <summary>Base duration in turns (if DurationType is Turns).</summary>
    public int BaseDuration { get; private set; }

    /// <summary>Event that removes this effect (if DurationType is Triggered).</summary>
    public string? RemovalTrigger { get; private set; }

    /// <summary>Resource pool amount (if DurationType is ResourceBased).</summary>
    public int? ResourcePool { get; private set; }

    // ═══════════════════════════════════════════════════════════════
    // STACKING
    // ═══════════════════════════════════════════════════════════════

    /// <summary>How this effect behaves when reapplied.</summary>
    public StackingRule StackingRule { get; private set; }

    /// <summary>Maximum stack count (if StackingRule is Stack).</summary>
    public int MaxStacks { get; private set; } = 1;

    // ═══════════════════════════════════════════════════════════════
    // EFFECTS
    // ═══════════════════════════════════════════════════════════════

    /// <summary>Stat modifications applied by this effect.</summary>
    public IReadOnlyList<StatModifier> StatModifiers => _statModifiers.AsReadOnly();
    private readonly List<StatModifier> _statModifiers = new();

    /// <summary>Damage dealt per turn (DoT).</summary>
    public int? DamagePerTurn { get; private set; }

    /// <summary>Damage type for DoT (e.g., "physical", "fire", "poison").</summary>
    public string? DamageType { get; private set; }

    /// <summary>Healing applied per turn (HoT).</summary>
    public int? HealingPerTurn { get; private set; }

    // ═══════════════════════════════════════════════════════════════
    // BEHAVIORAL FLAGS
    // ═══════════════════════════════════════════════════════════════

    /// <summary>Whether this effect prevents all actions.</summary>
    public bool PreventsActions { get; private set; }

    /// <summary>Whether this effect prevents movement.</summary>
    public bool PreventsMovement { get; private set; }

    /// <summary>Whether this effect prevents ability use.</summary>
    public bool PreventsAbilities { get; private set; }

    /// <summary>Whether this effect prevents attacking.</summary>
    public bool PreventsAttacking { get; private set; }

    /// <summary>Whether this effect is hidden from the target.</summary>
    public bool IsHidden { get; private set; }

    /// <summary>Whether this effect is beneficial (buff).</summary>
    public bool IsBeneficial => Category == EffectCategory.Buff;

    /// <summary>Whether this effect is harmful (debuff).</summary>
    public bool IsHarmful => Category == EffectCategory.Debuff;

    // ═══════════════════════════════════════════════════════════════
    // INTERACTIONS (metadata for v0.0.6d)
    // ═══════════════════════════════════════════════════════════════

    /// <summary>Effect IDs that this effect grants immunity to.</summary>
    public IReadOnlyList<string> GrantsImmunityTo => _grantsImmunityTo.AsReadOnly();
    private readonly List<string> _grantsImmunityTo = new();

    /// <summary>Damage types that this effect grants resistance to.</summary>
    public IReadOnlyList<string> ResistsDamageTypes => _resistsDamageTypes.AsReadOnly();
    private readonly List<string> _resistsDamageTypes = new();

    /// <summary>Damage types that this effect grants vulnerability to.</summary>
    public IReadOnlyList<string> VulnerableToDamageTypes => _vulnerableToDamageTypes.AsReadOnly();
    private readonly List<string> _vulnerableToDamageTypes = new();

    // ═══════════════════════════════════════════════════════════════
    // CONSTRUCTORS & FACTORY METHODS
    // ═══════════════════════════════════════════════════════════════

    /// <summary>Private constructor for controlled creation.</summary>
    private StatusEffectDefinition() { }

    /// <summary>
    /// Creates a status effect definition with required properties.
    /// </summary>
    public static StatusEffectDefinition Create(
        string id,
        string name,
        string description,
        EffectCategory category,
        DurationType durationType,
        int baseDuration = 0,
        StackingRule stackingRule = StackingRule.RefreshDuration,
        int maxStacks = 1,
        string? iconId = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new StatusEffectDefinition
        {
            Id = id.ToLowerInvariant(),
            Name = name,
            Description = description ?? string.Empty,
            Category = category,
            DurationType = durationType,
            BaseDuration = baseDuration,
            StackingRule = stackingRule,
            MaxStacks = Math.Max(1, maxStacks),
            IconId = iconId
        };
    }

    /// <summary>Adds a stat modifier to this effect.</summary>
    public StatusEffectDefinition WithStatModifier(StatModifier modifier)
    {
        _statModifiers.Add(modifier);
        return this;
    }

    /// <summary>Adds multiple stat modifiers to this effect.</summary>
    public StatusEffectDefinition WithStatModifiers(IEnumerable<StatModifier> modifiers)
    {
        _statModifiers.AddRange(modifiers);
        return this;
    }

    /// <summary>Sets damage over time for this effect.</summary>
    public StatusEffectDefinition WithDamageOverTime(int damage, string damageType)
    {
        DamagePerTurn = damage;
        DamageType = damageType;
        return this;
    }

    /// <summary>Sets healing over time for this effect.</summary>
    public StatusEffectDefinition WithHealingOverTime(int healing)
    {
        HealingPerTurn = healing;
        return this;
    }

    /// <summary>Sets action prevention flags.</summary>
    public StatusEffectDefinition WithActionPrevention(
        bool preventsActions = false,
        bool preventsMovement = false,
        bool preventsAbilities = false,
        bool preventsAttacking = false)
    {
        PreventsActions = preventsActions;
        PreventsMovement = preventsMovement;
        PreventsAbilities = preventsAbilities;
        PreventsAttacking = preventsAttacking;
        return this;
    }

    /// <summary>Sets triggered removal condition.</summary>
    public StatusEffectDefinition WithRemovalTrigger(string trigger)
    {
        RemovalTrigger = trigger;
        return this;
    }

    /// <summary>Sets resource pool for resource-based effects.</summary>
    public StatusEffectDefinition WithResourcePool(int amount)
    {
        ResourcePool = amount;
        return this;
    }

    /// <summary>Adds immunity grants to this effect.</summary>
    public StatusEffectDefinition WithImmunityGrants(params string[] effectIds)
    {
        _grantsImmunityTo.AddRange(effectIds.Select(e => e.ToLowerInvariant()));
        return this;
    }

    /// <summary>Adds damage type resistances to this effect.</summary>
    public StatusEffectDefinition WithDamageResistance(params string[] damageTypes)
    {
        _resistsDamageTypes.AddRange(damageTypes.Select(d => d.ToLowerInvariant()));
        return this;
    }

    /// <summary>Adds damage type vulnerabilities to this effect.</summary>
    public StatusEffectDefinition WithDamageVulnerability(params string[] damageTypes)
    {
        _vulnerableToDamageTypes.AddRange(damageTypes.Select(d => d.ToLowerInvariant()));
        return this;
    }

    /// <summary>Returns the effect name and ID.</summary>
    public override string ToString() => $"{Name} ({Id})";
}
```

#### 10. ActiveStatusEffect.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Entities/ActiveStatusEffect.cs`

```csharp
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents an active status effect instance on an entity.
/// </summary>
/// <remarks>
/// <para>ActiveStatusEffect tracks the runtime state of an applied effect:</para>
/// <list type="bullet">
/// <item>Remaining duration (for turn-based effects)</item>
/// <item>Current stack count (for stackable effects)</item>
/// <item>Remaining resource pool (for resource-based effects like Shield)</item>
/// <item>Source information (who applied the effect)</item>
/// </list>
/// </remarks>
public class ActiveStatusEffect
{
    /// <summary>Unique identifier for this effect instance.</summary>
    public Guid Id { get; private set; }

    /// <summary>The effect definition (shared, immutable).</summary>
    public StatusEffectDefinition Definition { get; private set; } = null!;

    /// <summary>The entity that applied this effect.</summary>
    public Guid? SourceId { get; private set; }

    /// <summary>Name of the source (for display).</summary>
    public string? SourceName { get; private set; }

    /// <summary>When this effect was applied.</summary>
    public DateTime AppliedAt { get; private set; }

    /// <summary>Remaining duration in turns (null if permanent/triggered).</summary>
    public int? RemainingDuration { get; private set; }

    /// <summary>Current stack count.</summary>
    public int Stacks { get; private set; } = 1;

    /// <summary>Remaining resource pool (for resource-based effects).</summary>
    public int? RemainingResource { get; private set; }

    /// <summary>Whether this effect has expired.</summary>
    public bool IsExpired =>
        (Definition.DurationType == DurationType.Turns && RemainingDuration <= 0) ||
        (Definition.DurationType == DurationType.ResourceBased && RemainingResource <= 0);

    /// <summary>Whether this effect is still active.</summary>
    public bool IsActive => !IsExpired;

    /// <summary>Convenience accessor for effect ID.</summary>
    public string EffectId => Definition.Id;

    /// <summary>Convenience accessor for effect name.</summary>
    public string EffectName => Definition.Name;

    /// <summary>Private constructor for controlled creation.</summary>
    private ActiveStatusEffect() { }

    /// <summary>
    /// Creates an active status effect instance.
    /// </summary>
    /// <param name="definition">The effect definition.</param>
    /// <param name="sourceId">The source entity ID (optional).</param>
    /// <param name="sourceName">The source entity name (optional).</param>
    /// <returns>A new active effect instance.</returns>
    public static ActiveStatusEffect Create(
        StatusEffectDefinition definition,
        Guid? sourceId = null,
        string? sourceName = null)
    {
        ArgumentNullException.ThrowIfNull(definition);

        var effect = new ActiveStatusEffect
        {
            Id = Guid.NewGuid(),
            Definition = definition,
            SourceId = sourceId,
            SourceName = sourceName,
            AppliedAt = DateTime.UtcNow,
            Stacks = 1
        };

        // Set initial duration/resource based on type
        effect.RemainingDuration = definition.DurationType == DurationType.Turns
            ? definition.BaseDuration
            : null;

        effect.RemainingResource = definition.DurationType == DurationType.ResourceBased
            ? definition.ResourcePool
            : null;

        return effect;
    }

    /// <summary>
    /// Decrements the duration by one turn.
    /// </summary>
    /// <returns>True if the effect is still active after ticking.</returns>
    public bool TickDuration()
    {
        if (RemainingDuration.HasValue && RemainingDuration > 0)
        {
            RemainingDuration--;
        }
        return IsActive;
    }

    /// <summary>
    /// Refreshes the duration to maximum.
    /// </summary>
    public void RefreshDuration()
    {
        if (Definition.DurationType == DurationType.Turns)
        {
            RemainingDuration = Definition.BaseDuration;
        }
    }

    /// <summary>
    /// Adds stacks to this effect (up to max).
    /// </summary>
    /// <param name="count">Number of stacks to add.</param>
    /// <returns>True if stacks were added, false if at max.</returns>
    public bool AddStacks(int count = 1)
    {
        if (Stacks >= Definition.MaxStacks)
            return false;

        Stacks = Math.Min(Stacks + count, Definition.MaxStacks);
        return true;
    }

    /// <summary>
    /// Removes stacks from this effect.
    /// </summary>
    /// <param name="count">Number of stacks to remove.</param>
    /// <returns>The number of stacks actually removed.</returns>
    public int RemoveStacks(int count = 1)
    {
        var removed = Math.Min(count, Stacks - 1); // Keep at least 1 stack
        Stacks -= removed;
        return removed;
    }

    /// <summary>
    /// Consumes resource from this effect (for shields, etc.).
    /// </summary>
    /// <param name="amount">Amount to consume.</param>
    /// <returns>Amount actually consumed.</returns>
    public int ConsumeResource(int amount)
    {
        if (!RemainingResource.HasValue || RemainingResource <= 0)
            return 0;

        var consumed = Math.Min(amount, RemainingResource.Value);
        RemainingResource -= consumed;
        return consumed;
    }

    /// <summary>
    /// Calculates the effective damage per turn (scaled by stacks).
    /// </summary>
    public int CalculateDamagePerTurn()
    {
        if (!Definition.DamagePerTurn.HasValue)
            return 0;

        return Definition.DamagePerTurn.Value * Stacks;
    }

    /// <summary>
    /// Calculates the effective healing per turn (scaled by stacks).
    /// </summary>
    public int CalculateHealingPerTurn()
    {
        if (!Definition.HealingPerTurn.HasValue)
            return 0;

        return Definition.HealingPerTurn.Value * Stacks;
    }

    /// <summary>
    /// Gets all stat modifiers (scaled by stacks where applicable).
    /// </summary>
    public IEnumerable<StatModifier> GetEffectiveStatModifiers()
    {
        foreach (var mod in Definition.StatModifiers)
        {
            // Flat modifiers scale with stacks
            if (mod.ModifierType == StatModifierType.Flat)
            {
                yield return mod with { Value = mod.Value * Stacks };
            }
            // Percentage and Override modifiers don't stack
            else
            {
                yield return mod;
            }
        }
    }

    /// <summary>Returns a display string for this active effect.</summary>
    public override string ToString()
    {
        var info = Definition.Name;
        if (Stacks > 1)
            info += $" x{Stacks}";
        if (RemainingDuration.HasValue)
            info += $" ({RemainingDuration} turns)";
        if (RemainingResource.HasValue)
            info += $" ({RemainingResource} remaining)";
        return info;
    }
}
```

#### 11. IEffectTarget.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Interfaces/IEffectTarget.cs`

```csharp
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Domain.Interfaces;

/// <summary>
/// Interface for entities that can have status effects applied.
/// </summary>
/// <remarks>
/// <para>Implemented by Player and Monster to enable polymorphic effect handling.</para>
/// <para>Provides effect storage, immunity tracking, and damage/heal methods.</para>
/// </remarks>
public interface IEffectTarget
{
    /// <summary>Unique identifier.</summary>
    Guid Id { get; }

    /// <summary>Display name.</summary>
    string Name { get; }

    /// <summary>Current health.</summary>
    int Health { get; }

    /// <summary>Maximum health.</summary>
    int MaxHealth { get; }

    /// <summary>Active status effects on this entity.</summary>
    IReadOnlyList<ActiveStatusEffect> ActiveEffects { get; }

    /// <summary>Effect IDs this entity is immune to.</summary>
    IReadOnlyList<string> EffectImmunities { get; }

    /// <summary>Adds an active effect.</summary>
    void AddEffect(ActiveStatusEffect effect);

    /// <summary>Removes an active effect by instance ID.</summary>
    void RemoveEffect(Guid effectId);

    /// <summary>Applies damage to this entity.</summary>
    /// <param name="damage">Raw damage amount.</param>
    /// <param name="damageType">Type of damage (for resistance/vulnerability).</param>
    /// <returns>Actual damage dealt after defense.</returns>
    int TakeDamage(int damage, string? damageType = null);

    /// <summary>Heals this entity.</summary>
    /// <param name="amount">Amount to heal.</param>
    /// <returns>Actual healing done.</returns>
    int Heal(int amount);

    /// <summary>Checks if this entity has an effect by ID.</summary>
    bool HasEffect(string effectId);

    /// <summary>Gets an active effect by definition ID.</summary>
    ActiveStatusEffect? GetEffect(string effectId);

    /// <summary>Checks if this entity is immune to an effect.</summary>
    bool IsImmuneToEffect(string effectId);
}
```

#### 12. Update Player.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

```csharp
// Add to existing Player class - implement IEffectTarget

// ═══════════════════════════════════════════════════════════════
// STATUS EFFECT SUPPORT (v0.0.6c)
// ═══════════════════════════════════════════════════════════════

private readonly List<ActiveStatusEffect> _activeEffects = new();
private readonly List<string> _effectImmunities = new();

/// <summary>
/// Gets the active status effects on the player.
/// </summary>
public IReadOnlyList<ActiveStatusEffect> ActiveEffects => _activeEffects.AsReadOnly();

/// <summary>
/// Gets the effect IDs the player is immune to.
/// </summary>
public IReadOnlyList<string> EffectImmunities => _effectImmunities.AsReadOnly();

/// <summary>
/// Gets the player's maximum health (from Stats).
/// </summary>
public int MaxHealth => Stats.MaxHealth;

/// <summary>
/// Adds an active effect to the player.
/// </summary>
/// <param name="effect">The effect to add.</param>
public void AddEffect(ActiveStatusEffect effect)
{
    ArgumentNullException.ThrowIfNull(effect);
    _activeEffects.Add(effect);
}

/// <summary>
/// Removes an active effect by instance ID.
/// </summary>
/// <param name="effectId">The effect instance ID to remove.</param>
public void RemoveEffect(Guid effectId)
{
    _activeEffects.RemoveAll(e => e.Id == effectId);
}

/// <summary>
/// Checks if the player has a specific effect active.
/// </summary>
/// <param name="effectId">The effect definition ID.</param>
/// <returns>True if the effect is active.</returns>
public bool HasEffect(string effectId) =>
    _activeEffects.Any(e => e.Definition.Id == effectId && e.IsActive);

/// <summary>
/// Gets an active effect by definition ID.
/// </summary>
/// <param name="effectId">The effect definition ID.</param>
/// <returns>The active effect, or null if not found.</returns>
public ActiveStatusEffect? GetEffect(string effectId) =>
    _activeEffects.FirstOrDefault(e => e.Definition.Id == effectId && e.IsActive);

/// <summary>
/// Checks if the player is immune to an effect.
/// </summary>
/// <param name="effectId">The effect definition ID.</param>
/// <returns>True if immune.</returns>
public bool IsImmuneToEffect(string effectId) =>
    _effectImmunities.Contains(effectId.ToLowerInvariant());

/// <summary>
/// Adds an effect immunity to the player.
/// </summary>
/// <param name="effectId">The effect ID to become immune to.</param>
public void AddImmunity(string effectId)
{
    var id = effectId.ToLowerInvariant();
    if (!_effectImmunities.Contains(id))
        _effectImmunities.Add(id);
}

/// <summary>
/// Removes an effect immunity from the player.
/// </summary>
/// <param name="effectId">The effect ID to remove immunity for.</param>
public void RemoveImmunity(string effectId)
{
    _effectImmunities.Remove(effectId.ToLowerInvariant());
}

/// <summary>
/// Removes all expired effects from the player.
/// </summary>
/// <returns>The number of effects removed.</returns>
public int RemoveExpiredEffects()
{
    return _activeEffects.RemoveAll(e => e.IsExpired);
}

// Update existing TakeDamage to support damage type parameter:
/// <summary>
/// Applies damage to the player, reduced by their defense stat.
/// </summary>
/// <param name="damage">The raw damage amount before defense reduction.</param>
/// <param name="damageType">Optional damage type for resistance/vulnerability (used in v0.0.6d).</param>
/// <returns>The actual damage dealt after defense calculation.</returns>
public int TakeDamage(int damage, string? damageType = null)
{
    if (damage < 0)
        throw new ArgumentOutOfRangeException(nameof(damage), "Damage cannot be negative");

    // Note: Damage type resistance/vulnerability will be applied in v0.0.6d
    var actualDamage = Math.Max(0, damage - Stats.Defense);
    Health = Math.Max(0, Health - actualDamage);
    return actualDamage;
}
```

#### 13. Update Monster.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Monster.cs`

```csharp
// Add to existing Monster class - implement IEffectTarget
// (Same implementation pattern as Player)

// ═══════════════════════════════════════════════════════════════
// STATUS EFFECT SUPPORT (v0.0.6c)
// ═══════════════════════════════════════════════════════════════

private readonly List<ActiveStatusEffect> _activeEffects = new();
private readonly List<string> _effectImmunities = new();

/// <summary>
/// Gets the active status effects on this monster.
/// </summary>
public IReadOnlyList<ActiveStatusEffect> ActiveEffects => _activeEffects.AsReadOnly();

/// <summary>
/// Gets the effect IDs this monster is immune to.
/// </summary>
public IReadOnlyList<string> EffectImmunities => _effectImmunities.AsReadOnly();

/// <summary>
/// Adds an active effect to this monster.
/// </summary>
public void AddEffect(ActiveStatusEffect effect)
{
    ArgumentNullException.ThrowIfNull(effect);
    _activeEffects.Add(effect);
}

/// <summary>
/// Removes an active effect by instance ID.
/// </summary>
public void RemoveEffect(Guid effectId)
{
    _activeEffects.RemoveAll(e => e.Id == effectId);
}

/// <summary>
/// Checks if this monster has a specific effect active.
/// </summary>
public bool HasEffect(string effectId) =>
    _activeEffects.Any(e => e.Definition.Id == effectId && e.IsActive);

/// <summary>
/// Gets an active effect by definition ID.
/// </summary>
public ActiveStatusEffect? GetEffect(string effectId) =>
    _activeEffects.FirstOrDefault(e => e.Definition.Id == effectId && e.IsActive);

/// <summary>
/// Checks if this monster is immune to an effect.
/// </summary>
public bool IsImmuneToEffect(string effectId) =>
    _effectImmunities.Contains(effectId.ToLowerInvariant());

/// <summary>
/// Adds an effect immunity to this monster.
/// </summary>
public void AddImmunity(string effectId)
{
    var id = effectId.ToLowerInvariant();
    if (!_effectImmunities.Contains(id))
        _effectImmunities.Add(id);
}

/// <summary>
/// Removes an effect immunity.
/// </summary>
public void RemoveImmunity(string effectId)
{
    _effectImmunities.Remove(effectId.ToLowerInvariant());
}

/// <summary>
/// Removes all expired effects.
/// </summary>
public int RemoveExpiredEffects()
{
    return _activeEffects.RemoveAll(e => e.IsExpired);
}

// Update existing TakeDamage to support damage type parameter:
/// <summary>
/// Applies damage to the monster, reduced by their defense stat.
/// </summary>
/// <param name="damage">The raw damage amount before defense reduction.</param>
/// <param name="damageType">Optional damage type for resistance/vulnerability.</param>
/// <returns>The actual damage dealt after defense calculation.</returns>
public int TakeDamage(int damage, string? damageType = null)
{
    if (damage < 0)
        throw new ArgumentOutOfRangeException(nameof(damage), "Damage cannot be negative");

    var actualDamage = Math.Max(0, damage - Stats.Defense);
    Health = Math.Max(0, Health - actualDamage);
    return actualDamage;
}
```

### Application Layer

#### 14. IStatusEffectRepository.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IStatusEffectRepository.cs`

```csharp
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Repository for status effect definitions.
/// </summary>
/// <remarks>
/// <para>Provides read-only access to effect definitions loaded from configuration.</para>
/// </remarks>
public interface IStatusEffectRepository
{
    /// <summary>
    /// Gets an effect definition by ID.
    /// </summary>
    /// <param name="id">The effect ID (case-insensitive).</param>
    /// <returns>The effect definition, or null if not found.</returns>
    StatusEffectDefinition? GetEffectById(string id);

    /// <summary>
    /// Gets all effect definitions.
    /// </summary>
    /// <returns>All loaded effect definitions.</returns>
    IReadOnlyList<StatusEffectDefinition> GetAllEffects();

    /// <summary>
    /// Gets effects by category.
    /// </summary>
    /// <param name="category">The category to filter by.</param>
    /// <returns>Effects matching the category.</returns>
    IReadOnlyList<StatusEffectDefinition> GetEffectsByCategory(EffectCategory category);

    /// <summary>
    /// Checks if an effect definition exists.
    /// </summary>
    /// <param name="id">The effect ID.</param>
    /// <returns>True if the effect exists.</returns>
    bool EffectExists(string id);
}
```

#### 15. StatusEffectService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/StatusEffectService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing status effects on entities.
/// </summary>
/// <remarks>
/// <para>StatusEffectService handles all effect lifecycle operations:</para>
/// <list type="bullet">
/// <item>Applying effects (with immunity and stacking checks)</item>
/// <item>Removing effects (single or by predicate)</item>
/// <item>Ticking effects (DoT/HoT and duration)</item>
/// <item>Querying effect state (stat modifiers, action prevention)</item>
/// </list>
/// </remarks>
public class StatusEffectService
{
    private readonly IStatusEffectRepository _effectRepository;
    private readonly ILogger<StatusEffectService> _logger;

    /// <summary>
    /// Creates a new StatusEffectService.
    /// </summary>
    public StatusEffectService(
        IStatusEffectRepository effectRepository,
        ILogger<StatusEffectService> logger)
    {
        _effectRepository = effectRepository ?? throw new ArgumentNullException(nameof(effectRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Attempts to apply a status effect to a target.
    /// </summary>
    /// <param name="effectId">The effect definition ID.</param>
    /// <param name="target">The target entity.</param>
    /// <param name="sourceId">The source entity ID (optional).</param>
    /// <param name="sourceName">The source entity name (optional).</param>
    /// <returns>The result of the application attempt.</returns>
    public EffectApplicationResult ApplyEffect(
        string effectId,
        IEffectTarget target,
        Guid? sourceId = null,
        string? sourceName = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(effectId);
        ArgumentNullException.ThrowIfNull(target);

        var definition = _effectRepository.GetEffectById(effectId);
        if (definition == null)
        {
            _logger.LogWarning("Unknown effect ID: {EffectId}", effectId);
            return EffectApplicationResult.NotFound(effectId);
        }

        // Check immunity
        if (target.IsImmuneToEffect(effectId))
        {
            _logger.LogDebug("{Target} is immune to {Effect}",
                target.Name, definition.Name);
            return EffectApplicationResult.Immune(effectId, definition.Name);
        }

        // Check for granted immunities from active effects
        foreach (var activeEffect in target.ActiveEffects.Where(e => e.IsActive))
        {
            if (activeEffect.Definition.GrantsImmunityTo.Contains(effectId))
            {
                _logger.LogDebug("{Target} is immune to {Effect} via {Source}",
                    target.Name, definition.Name, activeEffect.EffectName);
                return EffectApplicationResult.Immune(effectId, definition.Name);
            }
        }

        // Check for existing effect
        var existing = target.GetEffect(effectId);
        if (existing != null)
        {
            return HandleExistingEffect(existing, definition, target);
        }

        // Apply new effect
        var activeEffect = ActiveStatusEffect.Create(definition, sourceId, sourceName);
        target.AddEffect(activeEffect);

        _logger.LogInformation(
            "Applied {Effect} to {Target} (Duration: {Duration}, Stacks: {Stacks})",
            definition.Name, target.Name, activeEffect.RemainingDuration, activeEffect.Stacks);

        return EffectApplicationResult.Success(
            effectId,
            definition.Name,
            activeEffect.Stacks,
            activeEffect.RemainingDuration);
    }

    private EffectApplicationResult HandleExistingEffect(
        ActiveStatusEffect existing,
        StatusEffectDefinition definition,
        IEffectTarget target)
    {
        switch (definition.StackingRule)
        {
            case StackingRule.RefreshDuration:
                existing.RefreshDuration();
                _logger.LogDebug("Refreshed {Effect} duration on {Target}",
                    definition.Name, target.Name);
                return EffectApplicationResult.Refreshed(
                    definition.Id,
                    definition.Name,
                    existing.RemainingDuration ?? 0);

            case StackingRule.Stack:
                if (existing.AddStacks(1))
                {
                    existing.RefreshDuration();
                    _logger.LogDebug("Stacked {Effect} on {Target} ({Stacks})",
                        definition.Name, target.Name, existing.Stacks);
                    return EffectApplicationResult.Stacked(
                        definition.Id,
                        definition.Name,
                        existing.Stacks,
                        existing.RemainingDuration);
                }
                // At max stacks, just refresh duration
                existing.RefreshDuration();
                return EffectApplicationResult.Refreshed(
                    definition.Id,
                    definition.Name,
                    existing.RemainingDuration ?? 0);

            case StackingRule.Block:
            default:
                _logger.LogDebug("{Effect} blocked on {Target} (already active)",
                    definition.Name, target.Name);
                return EffectApplicationResult.Blocked(definition.Id, definition.Name);
        }
    }

    /// <summary>
    /// Removes a specific effect from a target.
    /// </summary>
    /// <param name="target">The target entity.</param>
    /// <param name="effectId">The effect definition ID to remove.</param>
    /// <returns>True if the effect was removed.</returns>
    public bool RemoveEffect(IEffectTarget target, string effectId)
    {
        var effect = target.GetEffect(effectId);
        if (effect == null)
            return false;

        target.RemoveEffect(effect.Id);
        _logger.LogDebug("Removed {Effect} from {Target}",
            effect.EffectName, target.Name);
        return true;
    }

    /// <summary>
    /// Removes all effects matching a predicate.
    /// </summary>
    /// <param name="target">The target entity.</param>
    /// <param name="predicate">The filter predicate.</param>
    /// <returns>The number of effects removed.</returns>
    public int RemoveEffects(IEffectTarget target, Func<ActiveStatusEffect, bool> predicate)
    {
        var toRemove = target.ActiveEffects.Where(predicate).ToList();
        foreach (var effect in toRemove)
        {
            target.RemoveEffect(effect.Id);
            _logger.LogDebug("Removed {Effect} from {Target}",
                effect.EffectName, target.Name);
        }
        return toRemove.Count;
    }

    /// <summary>
    /// Ticks all effects on a target, processing DoT/HoT and durations.
    /// </summary>
    /// <param name="target">The target to tick effects on.</param>
    /// <returns>Results of ticking each effect.</returns>
    public IReadOnlyList<EffectTickResult> TickEffects(IEffectTarget target)
    {
        ArgumentNullException.ThrowIfNull(target);

        var results = new List<EffectTickResult>();
        var activeEffects = target.ActiveEffects.Where(e => e.IsActive).ToList();

        foreach (var effect in activeEffects)
        {
            var result = TickSingleEffect(target, effect);
            results.Add(result);

            if (result.Expired)
            {
                target.RemoveEffect(effect.Id);
                _logger.LogDebug("{Effect} expired on {Target}",
                    effect.EffectName, target.Name);
            }
        }

        return results;
    }

    private EffectTickResult TickSingleEffect(IEffectTarget target, ActiveStatusEffect effect)
    {
        var definition = effect.Definition;

        // Process DoT
        var damage = effect.CalculateDamagePerTurn();
        if (damage > 0)
        {
            target.TakeDamage(damage, definition.DamageType);
            _logger.LogDebug("{Effect} deals {Damage} {Type} damage to {Target}",
                definition.Name, damage, definition.DamageType ?? "physical", target.Name);

            var stillActive = effect.TickDuration();
            return EffectTickResult.WithDamage(
                definition.Id,
                definition.Name,
                damage,
                !stillActive,
                effect.RemainingDuration);
        }

        // Process HoT
        var healing = effect.CalculateHealingPerTurn();
        if (healing > 0)
        {
            var actualHealing = target.Heal(healing);
            _logger.LogDebug("{Effect} heals {Target} for {Healing}",
                definition.Name, target.Name, actualHealing);

            var stillActive = effect.TickDuration();
            return EffectTickResult.WithHealing(
                definition.Id,
                definition.Name,
                actualHealing,
                !stillActive,
                effect.RemainingDuration);
        }

        // Just tick duration
        var active = effect.TickDuration();
        return EffectTickResult.Ticked(
            definition.Id,
            definition.Name,
            !active,
            effect.RemainingDuration);
    }

    /// <summary>
    /// Gets all stat modifiers from active effects on a target.
    /// </summary>
    public IEnumerable<StatModifier> GetAllStatModifiers(IEffectTarget target)
    {
        return target.ActiveEffects
            .Where(e => e.IsActive)
            .SelectMany(e => e.GetEffectiveStatModifiers());
    }

    /// <summary>
    /// Checks if a target can take actions (not stunned, etc.).
    /// </summary>
    public bool CanTakeActions(IEffectTarget target)
    {
        return !target.ActiveEffects.Any(e =>
            e.IsActive && e.Definition.PreventsActions);
    }

    /// <summary>
    /// Checks if a target can move (not frozen, knocked down, etc.).
    /// </summary>
    public bool CanMove(IEffectTarget target)
    {
        return !target.ActiveEffects.Any(e =>
            e.IsActive && e.Definition.PreventsMovement);
    }

    /// <summary>
    /// Checks if a target can use abilities (not silenced, etc.).
    /// </summary>
    public bool CanUseAbilities(IEffectTarget target)
    {
        return !target.ActiveEffects.Any(e =>
            e.IsActive && e.Definition.PreventsAbilities);
    }

    /// <summary>
    /// Checks if a target can attack (not disarmed, feared, etc.).
    /// </summary>
    public bool CanAttack(IEffectTarget target)
    {
        return !target.ActiveEffects.Any(e =>
            e.IsActive && e.Definition.PreventsAttacking);
    }

    /// <summary>
    /// Gets an effect definition by ID.
    /// </summary>
    public StatusEffectDefinition? GetEffectDefinition(string effectId)
    {
        return _effectRepository.GetEffectById(effectId);
    }

    /// <summary>
    /// Gets all effect definitions.
    /// </summary>
    public IReadOnlyList<StatusEffectDefinition> GetAllEffectDefinitions()
    {
        return _effectRepository.GetAllEffects();
    }
}
```

#### 16. StatCalculator.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/StatCalculator.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Calculates effective stat values considering all active effect modifiers.
/// </summary>
/// <remarks>
/// <para>Application order: Base → Flat → Percentage → Override</para>
/// <para>Override modifiers completely replace the calculated value.</para>
/// </remarks>
public class StatCalculator
{
    /// <summary>
    /// Calculates the effective value of a stat considering all modifiers.
    /// </summary>
    /// <param name="modifiers">All stat modifiers from active effects.</param>
    /// <param name="statId">The stat to calculate.</param>
    /// <param name="baseValue">The base stat value.</param>
    /// <returns>The final effective value (minimum 0).</returns>
    public int Calculate(
        IEnumerable<StatModifier> modifiers,
        string statId,
        int baseValue)
    {
        var relevantMods = modifiers
            .Where(m => m.StatId.Equals(statId, StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (relevantMods.Count == 0)
            return baseValue;

        // Check for Override first (takes complete precedence)
        var overrideMod = relevantMods.LastOrDefault(m => m.ModifierType == StatModifierType.Override);
        if (overrideMod.ModifierType == StatModifierType.Override)
        {
            return Math.Max(0, (int)overrideMod.Value);
        }

        // Apply flat modifiers
        var flatSum = relevantMods
            .Where(m => m.ModifierType == StatModifierType.Flat)
            .Sum(m => (int)m.Value);

        var afterFlat = baseValue + flatSum;

        // Apply percentage modifiers (multiplicatively)
        var percentageMultiplier = 1.0f;
        foreach (var mod in relevantMods.Where(m => m.ModifierType == StatModifierType.Percentage))
        {
            percentageMultiplier *= (1 + mod.Value);
        }

        var final = (int)(afterFlat * percentageMultiplier);
        return Math.Max(0, final);
    }

    /// <summary>
    /// Calculates all combat stats for an effect target.
    /// </summary>
    /// <param name="target">The target with active effects.</param>
    /// <param name="baseStats">Base stat values keyed by stat ID.</param>
    /// <returns>Effective stat values keyed by stat ID.</returns>
    public Dictionary<string, int> CalculateAll(
        IEffectTarget target,
        Dictionary<string, int> baseStats)
    {
        var allModifiers = target.ActiveEffects
            .Where(e => e.IsActive)
            .SelectMany(e => e.GetEffectiveStatModifiers())
            .ToList();

        var result = new Dictionary<string, int>();
        foreach (var (statId, baseValue) in baseStats)
        {
            result[statId] = Calculate(allModifiers, statId, baseValue);
        }
        return result;
    }
}
```

### Infrastructure Layer

#### 17. JsonStatusEffectRepository.cs (NEW)

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Repositories/JsonStatusEffectRepository.cs`

```csharp
using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Infrastructure.Repositories;

/// <summary>
/// JSON file-based repository for status effect definitions.
/// </summary>
public class JsonStatusEffectRepository : IStatusEffectRepository
{
    private readonly Dictionary<string, StatusEffectDefinition> _effects = new();
    private readonly ILogger<JsonStatusEffectRepository> _logger;
    private bool _loaded;

    public JsonStatusEffectRepository(ILogger<JsonStatusEffectRepository> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Loads effect definitions from a JSON file.
    /// </summary>
    /// <param name="filePath">Path to the status-effects.json file.</param>
    public async Task LoadFromFileAsync(string filePath)
    {
        if (!File.Exists(filePath))
        {
            _logger.LogWarning("Status effects file not found: {Path}", filePath);
            return;
        }

        try
        {
            var json = await File.ReadAllTextAsync(filePath);
            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                ReadCommentHandling = JsonCommentHandling.Skip
            };

            var data = JsonSerializer.Deserialize<StatusEffectJsonData>(json, options);
            if (data?.Effects == null)
            {
                _logger.LogWarning("No effects found in {Path}", filePath);
                return;
            }

            foreach (var effectData in data.Effects)
            {
                var definition = ConvertToDefinition(effectData);
                _effects[definition.Id] = definition;
            }

            _loaded = true;
            _logger.LogInformation("Loaded {Count} status effect definitions", _effects.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load status effects from {Path}", filePath);
            throw;
        }
    }

    private StatusEffectDefinition ConvertToDefinition(StatusEffectJson data)
    {
        var category = Enum.Parse<EffectCategory>(data.Category, ignoreCase: true);
        var durationType = Enum.Parse<DurationType>(data.DurationType, ignoreCase: true);
        var stackingRule = Enum.Parse<StackingRule>(data.StackingRule, ignoreCase: true);

        var definition = StatusEffectDefinition.Create(
            data.Id,
            data.Name,
            data.Description,
            category,
            durationType,
            data.BaseDuration,
            stackingRule,
            data.MaxStacks,
            data.IconId);

        // Add stat modifiers
        if (data.StatModifiers != null)
        {
            foreach (var mod in data.StatModifiers)
            {
                var modType = Enum.Parse<StatModifierType>(mod.Type, ignoreCase: true);
                definition.WithStatModifier(new StatModifier(mod.StatId, modType, mod.Value));
            }
        }

        // Add DoT/HoT
        if (data.DamagePerTurn.HasValue)
            definition.WithDamageOverTime(data.DamagePerTurn.Value, data.DamageType ?? "physical");
        if (data.HealingPerTurn.HasValue)
            definition.WithHealingOverTime(data.HealingPerTurn.Value);

        // Add behavioral flags
        definition.WithActionPrevention(
            data.PreventsActions,
            data.PreventsMovement,
            data.PreventsAbilities,
            data.PreventsAttacking);

        // Add removal trigger
        if (!string.IsNullOrEmpty(data.RemovalTrigger))
            definition.WithRemovalTrigger(data.RemovalTrigger);

        // Add resource pool
        if (data.ResourcePool.HasValue)
            definition.WithResourcePool(data.ResourcePool.Value);

        // Add immunities and resistances
        if (data.GrantsImmunityTo != null)
            definition.WithImmunityGrants(data.GrantsImmunityTo);
        if (data.ResistsDamageTypes != null)
            definition.WithDamageResistance(data.ResistsDamageTypes);
        if (data.VulnerableToDamageTypes != null)
            definition.WithDamageVulnerability(data.VulnerableToDamageTypes);

        return definition;
    }

    public StatusEffectDefinition? GetEffectById(string id)
    {
        return _effects.TryGetValue(id.ToLowerInvariant(), out var effect) ? effect : null;
    }

    public IReadOnlyList<StatusEffectDefinition> GetAllEffects()
    {
        return _effects.Values.ToList().AsReadOnly();
    }

    public IReadOnlyList<StatusEffectDefinition> GetEffectsByCategory(EffectCategory category)
    {
        return _effects.Values
            .Where(e => e.Category == category)
            .ToList()
            .AsReadOnly();
    }

    public bool EffectExists(string id)
    {
        return _effects.ContainsKey(id.ToLowerInvariant());
    }

    // JSON deserialization models
    private class StatusEffectJsonData
    {
        public List<StatusEffectJson> Effects { get; set; } = new();
    }

    private class StatusEffectJson
    {
        public string Id { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string Category { get; set; } = "Debuff";
        public string DurationType { get; set; } = "Turns";
        public int BaseDuration { get; set; }
        public string StackingRule { get; set; } = "RefreshDuration";
        public int MaxStacks { get; set; } = 1;
        public string? IconId { get; set; }
        public List<StatModifierJson>? StatModifiers { get; set; }
        public int? DamagePerTurn { get; set; }
        public string? DamageType { get; set; }
        public int? HealingPerTurn { get; set; }
        public bool PreventsActions { get; set; }
        public bool PreventsMovement { get; set; }
        public bool PreventsAbilities { get; set; }
        public bool PreventsAttacking { get; set; }
        public string? RemovalTrigger { get; set; }
        public int? ResourcePool { get; set; }
        public string[]? GrantsImmunityTo { get; set; }
        public string[]? ResistsDamageTypes { get; set; }
        public string[]? VulnerableToDamageTypes { get; set; }
    }

    private class StatModifierJson
    {
        public string StatId { get; set; } = string.Empty;
        public string Type { get; set; } = "Flat";
        public float Value { get; set; }
    }
}
```

### Configuration

#### 18. status-effects.json (Sample - First 8 Effects)

**File:** `config/status-effects.json`

```json
{
  "$schema": "./status-effects.schema.json",
  "effects": [
    {
      "id": "bleeding",
      "name": "Bleeding",
      "description": "Losing blood from wounds. Takes damage each turn.",
      "category": "Debuff",
      "durationType": "Turns",
      "baseDuration": 3,
      "stackingRule": "RefreshDuration",
      "damagePerTurn": 3,
      "damageType": "physical"
    },
    {
      "id": "poisoned",
      "name": "Poisoned",
      "description": "Toxins coursing through the body. Takes poison damage each turn.",
      "category": "Debuff",
      "durationType": "Turns",
      "baseDuration": 4,
      "stackingRule": "RefreshDuration",
      "damagePerTurn": 2,
      "damageType": "poison"
    },
    {
      "id": "burning",
      "name": "Burning",
      "description": "Engulfed in flames. Takes fire damage each turn.",
      "category": "Debuff",
      "durationType": "Turns",
      "baseDuration": 2,
      "stackingRule": "RefreshDuration",
      "damagePerTurn": 5,
      "damageType": "fire"
    },
    {
      "id": "frozen",
      "name": "Frozen",
      "description": "Encased in ice. Cannot move or take actions.",
      "category": "Debuff",
      "durationType": "Turns",
      "baseDuration": 1,
      "stackingRule": "RefreshDuration",
      "preventsActions": true,
      "preventsMovement": true,
      "vulnerableToDamageTypes": ["fire"]
    },
    {
      "id": "stunned",
      "name": "Stunned",
      "description": "Dazed and unable to act.",
      "category": "Debuff",
      "durationType": "Turns",
      "baseDuration": 1,
      "stackingRule": "Block",
      "preventsActions": true
    },
    {
      "id": "weakened",
      "name": "Weakened",
      "description": "Physical strength reduced. Attack power decreased.",
      "category": "Debuff",
      "durationType": "Turns",
      "baseDuration": 3,
      "stackingRule": "RefreshDuration",
      "statModifiers": [
        { "statId": "attack", "type": "Percentage", "value": -0.3 }
      ]
    },
    {
      "id": "hasted",
      "name": "Hasted",
      "description": "Moving with supernatural speed. Initiative and evasion increased.",
      "category": "Buff",
      "durationType": "Turns",
      "baseDuration": 3,
      "stackingRule": "Block",
      "statModifiers": [
        { "statId": "initiative", "type": "Flat", "value": 5 },
        { "statId": "evasion", "type": "Percentage", "value": 0.2 }
      ]
    },
    {
      "id": "regenerating",
      "name": "Regenerating",
      "description": "Wounds healing rapidly. Recovers health each turn.",
      "category": "Buff",
      "durationType": "Turns",
      "baseDuration": 5,
      "stackingRule": "Block",
      "healingPerTurn": 5
    }
  ]
}
```

---

## Flow Diagrams

### Effect Application Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        EFFECT APPLICATION FLOW                               │
└─────────────────────────────────────────────────────────────────────────────┘

    ApplyEffect(effectId, target) called
                │
                ▼
┌───────────────────────────────┐
│  Get Definition from Repo     │
├───────────────────────────────┤
│  Not found → NotFound result  │
└───────────────────────────────┘
                │ Found
                ▼
┌───────────────────────────────┐
│  Check Target Immunities      │
├───────────────────────────────┤
│  • Direct immunity list       │
│  • Immunities from effects    │
│  Immune → Immune result       │
└───────────────────────────────┘
                │ Not immune
                ▼
┌───────────────────────────────┐
│  Check Existing Effect        │
├───────────────────────────────┤
│  None → Apply new effect      │
│  Exists → Handle stacking     │
└───────────────────────────────┘
          │           │
    (New Effect)  (Existing)
          │           │
          ▼           ▼
┌─────────────┐ ┌─────────────────────────────────────────────┐
│ Create      │ │              STACKING RULES                  │
│ Active      │ ├─────────────────────────────────────────────┤
│ Effect      │ │                                              │
│ Instance    │ │  RefreshDuration → Refresh to max duration   │
│             │ │  Stack → Add stacks (if < max), refresh      │
│             │ │  Block → Return Blocked result               │
└─────────────┘ └─────────────────────────────────────────────┘
          │                           │
          └─────────┬─────────────────┘
                    ▼
        Return EffectApplicationResult
```

### Effect Tick Flow (Turn Processing)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          EFFECT TICK FLOW                                    │
└─────────────────────────────────────────────────────────────────────────────┘

    TickEffects(target) called at start of turn
                │
                ▼
    ┌─────────────────────────────────────────────────────────────────────────┐
    │                    FOR EACH ACTIVE EFFECT                                │
    ├─────────────────────────────────────────────────────────────────────────┤
    │                                                                          │
    │   ┌───────────────────────────────────────────────────────────────────┐ │
    │   │ 1. Check for DoT (DamagePerTurn > 0)                              │ │
    │   │    • Calculate damage: base × stacks                              │ │
    │   │    • Apply damage to target (with damage type)                    │ │
    │   │    • Create EffectTickResult with damage                          │ │
    │   └───────────────────────────────────────────────────────────────────┘ │
    │                                                                          │
    │   ┌───────────────────────────────────────────────────────────────────┐ │
    │   │ 2. Check for HoT (HealingPerTurn > 0)                             │ │
    │   │    • Calculate healing: base × stacks                             │ │
    │   │    • Apply healing to target (capped at max HP)                   │ │
    │   │    • Create EffectTickResult with healing                         │ │
    │   └───────────────────────────────────────────────────────────────────┘ │
    │                                                                          │
    │   ┌───────────────────────────────────────────────────────────────────┐ │
    │   │ 3. Tick Duration                                                  │ │
    │   │    • If DurationType is Turns: decrement RemainingDuration        │ │
    │   │    • Check if expired (duration <= 0)                             │ │
    │   │    • If expired: mark for removal                                 │ │
    │   └───────────────────────────────────────────────────────────────────┘ │
    │                                                                          │
    └─────────────────────────────────────────────────────────────────────────┘
                │
                ▼
    Remove all expired effects from target
                │
                ▼
    Return List<EffectTickResult>
```

### Stat Calculation Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       STAT CALCULATION FLOW                                  │
└─────────────────────────────────────────────────────────────────────────────┘

    Calculate(modifiers, statId, baseValue)
                │
                ▼
    ┌───────────────────────────────────────────────────────────────────────┐
    │ 1. Filter modifiers by statId                                         │
    │    • Case-insensitive match                                           │
    │    • If no modifiers → return baseValue                               │
    └───────────────────────────────────────────────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────────────────────────────────────────────┐
    │ 2. Check for Override modifier                                        │
    │    • If any Override exists → return override value (min 0)           │
    │    • Last override wins if multiple                                   │
    └───────────────────────────────────────────────────────────────────────┘
                │ No Override
                ▼
    ┌───────────────────────────────────────────────────────────────────────┐
    │ 3. Apply Flat modifiers                                               │
    │    • Sum all flat values                                              │
    │    • afterFlat = baseValue + flatSum                                  │
    └───────────────────────────────────────────────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────────────────────────────────────────────┐
    │ 4. Apply Percentage modifiers (multiplicative)                        │
    │    • multiplier = 1.0                                                 │
    │    • For each percentage: multiplier *= (1 + value)                   │
    │    • final = afterFlat × multiplier                                   │
    └───────────────────────────────────────────────────────────────────────┘
                │
                ▼
    Return Math.Max(0, final)
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Definitions/
│   │   └── StatusEffectDefinitionTests.cs        (4 tests)
│   ├── Entities/
│   │   └── ActiveStatusEffectTests.cs            (6 tests)
│   └── ValueObjects/
│       ├── StatModifierTests.cs                  (4 tests)
│       └── EffectApplicationResultTests.cs       (3 tests)
├── RuneAndRust.Application.UnitTests/
│   └── Services/
│       ├── StatusEffectServiceTests.cs           (12 tests)
│       └── StatCalculatorTests.cs                (6 tests)
```

### Test Summary by File

| Test File | Tests | Focus Areas |
|-----------|-------|-------------|
| StatusEffectDefinitionTests.cs | 4 | Factory methods, fluent builders |
| ActiveStatusEffectTests.cs | 6 | Duration tick, stacks, resource consumption |
| StatModifierTests.cs | 4 | Apply methods, factory methods |
| EffectApplicationResultTests.cs | 3 | Factory methods, message formatting |
| StatusEffectServiceTests.cs | 12 | Apply, remove, tick, immunity, stacking |
| StatCalculatorTests.cs | 6 | Flat, percentage, override, combined |
| **Total** | **35** | |

### Key Test Cases

**StatusEffectService Tests:**
1. `ApplyEffect_NewEffect_AppliesSuccessfully`
2. `ApplyEffect_UnknownEffect_ReturnsNotFound`
3. `ApplyEffect_ImmuneTarget_ReturnsImmune`
4. `ApplyEffect_ExistingRefreshDuration_RefreshesDuration`
5. `ApplyEffect_ExistingStack_IncreasesStacks`
6. `ApplyEffect_ExistingBlock_ReturnsBlocked`
7. `RemoveEffect_ExistingEffect_RemovesSuccessfully`
8. `TickEffects_DoTEffect_DealsDamage`
9. `TickEffects_HoTEffect_Heals`
10. `TickEffects_ExpiredEffect_RemovesEffect`
11. `CanTakeActions_StunnedTarget_ReturnsFalse`
12. `GetAllStatModifiers_MultipleEffects_AggregatesCorrectly`

**StatCalculator Tests:**
1. `Calculate_NoModifiers_ReturnsBaseValue`
2. `Calculate_FlatModifiers_AddsCorrectly`
3. `Calculate_PercentageModifiers_MultipliesCorrectly`
4. `Calculate_OverrideModifier_ReturnsOverrideValue`
5. `Calculate_CombinedModifiers_AppliesInOrder`
6. `Calculate_NegativeResult_ReturnsZero`

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Effect applied | Information | "Applied {Effect} to {Target}" |
| Effect refreshed | Debug | "Refreshed {Effect} duration on {Target}" |
| Effect stacked | Debug | "Stacked {Effect} on {Target} ({Stacks})" |
| Effect blocked | Debug | "{Effect} blocked on {Target} (already active)" |
| Effect immune | Debug | "{Target} is immune to {Effect}" |
| Effect removed | Debug | "Removed {Effect} from {Target}" |
| Effect expired | Debug | "{Effect} expired on {Target}" |
| DoT damage | Debug | "{Effect} deals {Damage} {Type} damage to {Target}" |
| HoT healing | Debug | "{Effect} heals {Target} for {Healing}" |
| Unknown effect | Warning | "Unknown effect ID: {EffectId}" |
| Load success | Information | "Loaded {Count} status effect definitions" |
| Load failure | Error | "Failed to load status effects from {Path}" |

### Structured Logging Format

```csharp
_logger.LogInformation(
    "Applied {Effect} to {Target} (Duration: {Duration}, Stacks: {Stacks})",
    definition.Name, target.Name, activeEffect.RemainingDuration, activeEffect.Stacks);

_logger.LogDebug(
    "{Effect} deals {Damage} {DamageType} damage to {Target}",
    definition.Name, damage, definition.DamageType ?? "physical", target.Name);
```

---

## Implementation Checklist

### Domain Layer - Enums
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/EffectCategory.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/DurationType.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/StackingRule.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/StatModifierType.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/EffectApplicationOutcome.cs`

### Domain Layer - Value Objects
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/StatModifier.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/EffectApplicationResult.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/EffectTickResult.cs`

### Domain Layer - Definitions & Entities
- [ ] Create `src/Core/RuneAndRust.Domain/Definitions/StatusEffectDefinition.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Entities/ActiveStatusEffect.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Interfaces/IEffectTarget.cs`

### Domain Layer - Entity Modifications
- [ ] Update `src/Core/RuneAndRust.Domain/Entities/Player.cs`
  - [ ] Implement IEffectTarget
  - [ ] Add ActiveEffects list
  - [ ] Add EffectImmunities list
  - [ ] Add effect management methods
  - [ ] Update TakeDamage signature
- [ ] Update `src/Core/RuneAndRust.Domain/Entities/Monster.cs`
  - [ ] Implement IEffectTarget
  - [ ] Add ActiveEffects list
  - [ ] Add EffectImmunities list
  - [ ] Add effect management methods
  - [ ] Update TakeDamage signature

### Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/Interfaces/IStatusEffectRepository.cs`
- [ ] Create `src/Core/RuneAndRust.Application/Services/StatusEffectService.cs`
- [ ] Create `src/Core/RuneAndRust.Application/Services/StatCalculator.cs`
- [ ] Update DI registration for new services

### Infrastructure Layer
- [ ] Create `src/Infrastructure/RuneAndRust.Infrastructure/Repositories/JsonStatusEffectRepository.cs`

### Configuration
- [ ] Create `config/status-effects.json` (all 28 effects)
- [ ] Create `config/status-effects.schema.json` (JSON Schema)

### Tests
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Definitions/StatusEffectDefinitionTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Entities/ActiveStatusEffectTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/StatModifierTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/EffectApplicationResultTests.cs`
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/StatusEffectServiceTests.cs`
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/StatCalculatorTests.cs`

### Validation
- [ ] All 35 new tests pass
- [ ] All existing tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings
- [ ] JSON configuration loads successfully

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | 28 status effects defined in JSON configuration | Configuration review |
| AC-2 | Effects can be applied to Player and Monster | Unit test |
| AC-3 | Immune targets reject effect application | Unit test |
| AC-4 | RefreshDuration effects refresh on reapplication | Unit test |
| AC-5 | Stack effects increase stacks on reapplication | Unit test |
| AC-6 | Block effects prevent reapplication | Unit test |
| AC-7 | DoT effects deal damage each turn | Unit test |
| AC-8 | HoT effects heal each turn | Unit test |
| AC-9 | Turn-based effects decrement duration | Unit test |
| AC-10 | Expired effects are removed | Unit test |
| AC-11 | Stat modifiers are correctly aggregated | Unit test |
| AC-12 | Flat → Percentage → Override calculation order | Unit test |
| AC-13 | Action prevention flags checked correctly | Unit test |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | All public types have XML documentation | Code review |
| NF-2 | Services use dependency injection | Code review |
| NF-3 | Effect definitions are immutable | Code review |
| NF-4 | Repository loads effects on startup | Integration test |
| NF-5 | Logging follows established patterns | Code review |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| JSON schema changes | Medium | Low | Version schema, backward compatibility |
| Effect balance issues | Medium | Medium | Tunable via JSON, no code changes needed |
| Performance with many effects | Low | Low | Effects cleared per combat, limited stacking |
| Repository initialization race | Medium | Low | Load synchronously at startup |
| Stat calculation precision | Low | Low | Use int math, minimum 0 cap |
| Missing effect definitions | Medium | Low | Validate on load, log warnings |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Domain/Enums/EffectCategory.cs` | Effect category enum | ~25 |
| `Domain/Enums/DurationType.cs` | Duration type enum | ~25 |
| `Domain/Enums/StackingRule.cs` | Stacking rule enum | ~30 |
| `Domain/Enums/StatModifierType.cs` | Stat modifier type enum | ~30 |
| `Domain/Enums/EffectApplicationOutcome.cs` | Application outcome enum | ~25 |
| `Domain/ValueObjects/StatModifier.cs` | Stat modifier value object | ~70 |
| `Domain/ValueObjects/EffectApplicationResult.cs` | Application result | ~70 |
| `Domain/ValueObjects/EffectTickResult.cs` | Tick result | ~60 |
| `Domain/Definitions/StatusEffectDefinition.cs` | Effect definition | ~200 |
| `Domain/Entities/ActiveStatusEffect.cs` | Active effect instance | ~150 |
| `Domain/Interfaces/IEffectTarget.cs` | Effect target interface | ~35 |
| `Application/Interfaces/IStatusEffectRepository.cs` | Repository interface | ~30 |
| `Application/Services/StatusEffectService.cs` | Main effect service | ~250 |
| `Application/Services/StatCalculator.cs` | Stat calculation | ~60 |
| `Infrastructure/Repositories/JsonStatusEffectRepository.cs` | JSON repository | ~150 |
| `config/status-effects.json` | Effect definitions | ~400 |
| `config/status-effects.schema.json` | JSON schema | ~100 |
| Test files (6 files) | Unit tests | ~400 |

### Files to Modify

| File | Changes |
|------|---------|
| `Domain/Entities/Player.cs` | Add IEffectTarget implementation (~80 lines) |
| `Domain/Entities/Monster.cs` | Add IEffectTarget implementation (~80 lines) |
| DI Registration | Register new services |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| Status Effect Types | 0 | 28 |
| Enums | ~15 | ~20 |
| Value Objects | ~12 | ~15 |
| Application Services | ~11 | ~13 |
| Unit Tests | ~236 | ~261 |

---

## Next Steps

After completing this phase:

1. **v0.0.6d (Status Effect Integration)** - Combat integration, effect interactions, cleanse mechanics, UI display
2. **v0.0.7 (Equipment System)** - Equipment with effects and stat modifiers

---

*This implementation plan provides step-by-step guidance for implementing the comprehensive status effect framework. The plan establishes the foundation for v0.0.6d's combat integration and future equipment effects.*
