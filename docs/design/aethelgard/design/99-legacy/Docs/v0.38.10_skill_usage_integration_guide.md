# v0.38.10: Skill Usage Flavor Text - Integration Guide

## Overview

The Skill Usage Flavor Text system (v0.38.10) provides comprehensive, context-aware narrative descriptors for skill checks across all non-combat actions. This guide explains how to integrate skill check flavor text into game commands and systems.

## Philosophy

**Every skill check tells a story of expertise, struggle, and consequence.**

- Attempts describe the setup and environmental context
- Successes vary by degree (minimal, solid, critical)
- Failures show the struggle and near-misses
- Fumbles have mechanical consequences with dramatic narrative impact

## Quick Start

### 1. Initialize the Database

Run the schema and data migrations:

```bash
sqlite3 rune_and_rust.db < Data/v0.38.10_skill_usage_descriptors_schema.sql
sqlite3 rune_and_rust.db < Data/v0.38.10_skill_usage_descriptors_data.sql
```

This creates:
- `Skill_Check_Descriptors` table (150+ descriptors)
- `Skill_Fumble_Descriptors` table (30+ fumble consequences)
- Statistics view and indexes

### 2. Initialize the Service

```csharp
using RuneAndRust.Persistence;
using RuneAndRust.Engine;

// Create repository
var repository = new DescriptorRepository(connectionString);

// Create service
var skillFlavorService = new SkillUsageFlavorTextService(repository);
```

### 3. Generate Skill Check Narrative

```csharp
// Complete skill check with flavor text
var narrative = skillFlavorService.GenerateSkillCheckNarrative(
    skillType: "SystemBypass",
    actionType: "Lockpicking",
    roll: 15,
    dc: 12,
    isFumble: false,
    environmentalContext: "ComplexLock",
    biomeContext: null
);

Console.WriteLine(narrative.GetFullNarrative());
```

**Output:**
```
This is Jötun craftsmanship—precision engineering. You steady your hands.

Your picks find their marks efficiently. The lock opens with a satisfying click.
```

## Core Skills and Actions

### System Bypass (WITS)

```csharp
// Lockpicking
var lockpicking = skillFlavorService.GenerateSkillCheckNarrative(
    "SystemBypass", "Lockpicking", roll, dc,
    environmentalContext: "CorrodedLock");

// Terminal Hacking
var hacking = skillFlavorService.GenerateSkillCheckNarrative(
    "SystemBypass", "TerminalHacking", roll, dc,
    environmentalContext: "GlitchedTerrain");

// Trap Disarming
var trapDisarm = skillFlavorService.GenerateSkillCheckNarrative(
    "SystemBypass", "TrapDisarm", roll, dc,
    environmentalContext: "ComplexLock");
```

**Environmental Contexts:**
- Lockpicking: `SimpleLock`, `ComplexLock`, `CorrodedLock`, `DamagedLock`
- Terminal Hacking: `GlitchedTerrain` (Blight corruption)
- Trap Disarming: `SimpleLock`, `ComplexLock`

### Acrobatics (FINESSE)

```csharp
// Climbing
var climbing = skillFlavorService.GenerateSkillCheckNarrative(
    "Acrobatics", "Climbing", roll, dc,
    environmentalContext: "DangerousHeight");

// Leaping
var leaping = skillFlavorService.GenerateSkillCheckNarrative(
    "Acrobatics", "Leaping", roll, dc,
    environmentalContext: "GlitchedTerrain");

// Stealth
var stealth = skillFlavorService.GenerateSkillCheckNarrative(
    "Acrobatics", "Stealth", roll, dc,
    environmentalContext: "NoisyEnvironment");
```

**Environmental Contexts:**
- Climbing: `CorrodedStructure`, `DangerousHeight`, `GlitchedTerrain`
- Leaping: `GlitchedTerrain`
- Stealth: `ShadowyCover`, `NoisyEnvironment`, `OpenGround`

### Wasteland Survival (WITS)

```csharp
// Tracking
var tracking = skillFlavorService.GenerateSkillCheckNarrative(
    "WastelandSurvival", "Tracking", roll, dc,
    environmentalContext: "FreshTracks");

// Foraging
var foraging = skillFlavorService.GenerateSkillCheckNarrative(
    "WastelandSurvival", "Foraging", roll, dc,
    environmentalContext: "RichArea");

// Navigation
var navigation = skillFlavorService.GenerateSkillCheckNarrative(
    "WastelandSurvival", "Navigation", roll, dc,
    environmentalContext: "StormHazard");
```

**Environmental Contexts:**
- Tracking: `FreshTracks`, `OldTracks`, `UnusualTracks`
- Foraging: `RichArea`, `DangerousArea`, `ContaminatedArea`
- Navigation: `NormalTravel`, `StormHazard`, `GlitchedSpace`

### Rhetoric (WILL)

```csharp
// Persuasion
var persuasion = skillFlavorService.GenerateSkillCheckNarrative(
    "Rhetoric", "Persuasion", roll, dc,
    environmentalContext: "DifficultRequest");

// Deception
var deception = skillFlavorService.GenerateSkillCheckNarrative(
    "Rhetoric", "Deception", roll, dc,
    environmentalContext: "ComplexDeception");

// Intimidation
var intimidation = skillFlavorService.GenerateSkillCheckNarrative(
    "Rhetoric", "Intimidation", roll, dc);
```

**Environmental Contexts:**
- Persuasion: `ReasonableRequest`, `DifficultRequest`
- Deception: `SimpleDeception`, `ComplexDeception`
- Intimidation: None (context-independent)

## Success Degrees

The system automatically selects descriptors based on margin of success/failure:

- **Minimal** (1-2 margin): Barely succeeded/failed
- **Solid** (3-5 margin): Clear success/failure
- **Critical** (6+ margin): Exceptional success

```csharp
// Example: Minimal Success
Roll: 13, DC: 12, Margin: 1
"You barely manage to align the tumblers. The lock clicks open, but you're sweating."

// Example: Solid Success
Roll: 16, DC: 12, Margin: 4
"Your picks find their marks efficiently. The lock opens with a satisfying click."

// Example: Critical Success
Roll: 19, DC: 12, Margin: 7
"You open the lock so smoothly, it's as if you had the key. Masterful work."
```

## Fumble Handling

Fumbles occur on natural 1s or catastrophic failures:

```csharp
// Generate fumble with consequences
var fumbleResult = skillFlavorService.GenerateFumbleDescription(
    skillType: "SystemBypass",
    actionType: "Lockpicking",
    preferredConsequenceType: "ToolBreakage"
);

Console.WriteLine(fumbleResult.Description);
// Output: "Your pick snaps off inside the lock! The broken piece jams the mechanism."

// Apply mechanical consequences
if (fumbleResult.NextAttemptDCModifier.HasValue)
{
    dc += fumbleResult.NextAttemptDCModifier.Value; // DC +2 for next attempt
}

if (!string.IsNullOrEmpty(fumbleResult.DamageFormula))
{
    var damage = RollDice(fumbleResult.DamageFormula); // e.g., "2d6"
    player.HP -= damage;
}

if (!string.IsNullOrEmpty(fumbleResult.StatusEffectApplied))
{
    ApplyStatusEffect(player, fumbleResult.StatusEffectApplied); // e.g., "Poisoned"
}

if (fumbleResult.PreventsRetry)
{
    // Lock destroyed, cannot retry
}
```

### Fumble Consequence Types

- **ToolBreakage**: Pick/tool breaks, increases DC for next attempt
- **AlarmTriggered**: Detection, guards alerted
- **TrapActivated**: Damage and status effects
- **InjuryTaken**: Fall damage, structural collapse
- **DetectedByEnemy**: Stealth blown, combat initiated
- **TimeWasted**: Navigation/tracking setback
- **Poisoned**: Foraging misidentification
- **SocialConsequence**: Persuasion/deception backfire
- **BlightCorruption**: Terminal hacking into corrupted data

## Integration Examples

### Example 1: Lockpicking Command

```csharp
public class LockpickCommand : ICommand
{
    private readonly SkillUsageFlavorTextService _skillFlavorService;

    public CommandResult Execute(GameState state, string[] args)
    {
        var player = state.Player;
        var witsBonus = player.GetAttributeModifier("Wits");
        var roll = RollD20() + witsBonus;
        var dc = 14; // Complex Jötun lock

        // Determine environmental context from current location
        var environmentalContext = state.CurrentRoom.HasTag("JotunRuins")
            ? "ComplexLock"
            : "SimpleLock";

        // Check for fumble (natural 1)
        bool isFumble = (roll - witsBonus) == 1;

        // Generate narrative
        var narrative = _skillFlavorService.GenerateSkillCheckNarrative(
            "SystemBypass",
            "Lockpicking",
            roll,
            dc,
            isFumble,
            environmentalContext,
            state.CurrentRoom.BiomeName
        );

        var output = new StringBuilder();
        output.AppendLine(narrative.GetFullNarrative());
        output.AppendLine();
        output.AppendLine($"[Roll: {roll} vs DC: {dc}]");

        // Handle fumble consequences
        if (narrative.IsFumble && narrative.FumbleResult != null)
        {
            var fumble = narrative.FumbleResult;

            if (!string.IsNullOrEmpty(fumble.DamageFormula))
            {
                var damage = DiceRoller.Roll(fumble.DamageFormula);
                player.HP -= damage;
                output.AppendLine($"You take {damage} damage!");
            }

            if (!string.IsNullOrEmpty(fumble.StatusEffectApplied))
            {
                ApplyStatusEffect(player, fumble.StatusEffectApplied);
                output.AppendLine($"You are now {fumble.StatusEffectApplied}!");
            }

            if (fumble.PreventsRetry)
            {
                // Mark lock as destroyed
                state.CurrentRoom.RemoveLock();
                output.AppendLine("The lock is destroyed. You cannot try again.");
            }
        }
        else if (narrative.IsSuccess)
        {
            state.CurrentRoom.UnlockDoor();
            output.AppendLine("The door is now unlocked.");
        }

        return CommandResult.Success(output.ToString());
    }
}
```

### Example 2: Stealth System

```csharp
public class StealthSystem
{
    private readonly SkillUsageFlavorTextService _skillFlavorService;

    public StealthCheckResult AttemptStealth(PlayerCharacter player, Room room)
    {
        var finesseBonus = player.GetAttributeModifier("Finesse");
        var roll = RollD20() + finesseBonus;
        var dc = CalculateStealthDC(room);

        // Determine environmental context
        var environmentalContext = room.HasDebris
            ? "NoisyEnvironment"
            : (room.LightLevel == LightLevel.Dark ? "ShadowyCover" : "OpenGround");

        var narrative = _skillFlavorService.GenerateSkillCheckNarrative(
            "Acrobatics",
            "Stealth",
            roll,
            dc,
            isFumble: false,
            environmentalContext,
            room.BiomeName
        );

        return new StealthCheckResult
        {
            Success = narrative.IsSuccess,
            Description = narrative.GetFullNarrative(),
            Detected = !narrative.IsSuccess
        };
    }
}
```

### Example 3: Foraging with Rewards

```csharp
public class ForagingSystem
{
    private readonly SkillUsageFlavorTextService _skillFlavorService;

    public ForagingResult Forage(PlayerCharacter player, Room room)
    {
        var witsBonus = player.GetAttributeModifier("Wits");
        var roll = RollD20() + witsBonus;
        var dc = 12;

        var environmentalContext = room.HasEdiblePlants
            ? "RichArea"
            : (room.IsBlightTouched ? "DangerousArea" : null);

        bool isFumble = (roll - witsBonus) == 1;

        var narrative = _skillFlavorService.GenerateSkillCheckNarrative(
            "WastelandSurvival",
            "Foraging",
            roll,
            dc,
            isFumble,
            environmentalContext,
            room.BiomeName
        );

        var result = new ForagingResult
        {
            Description = narrative.GetFullNarrative()
        };

        if (narrative.IsFumble && narrative.FumbleResult != null)
        {
            // Poisoned by misidentified fungi
            if (narrative.FumbleResult.StatusEffectApplied == "Poisoned")
            {
                ApplyStatusEffect(player, "Poisoned");
                result.Poisoned = true;
            }
        }
        else if (narrative.IsSuccess)
        {
            // Parse rations from descriptor text (e.g., "[+2 Rations]")
            var rationsMatch = System.Text.RegularExpressions.Regex.Match(
                narrative.ResultDescription, @"\[\+(\d+) Rations?\]");

            if (rationsMatch.Success)
            {
                var rations = int.Parse(rationsMatch.Groups[1].Value);
                player.AddRations(rations);
                result.RationsFound = rations;
            }
        }

        return result;
    }
}
```

## Advanced Usage

### Custom Environmental Contexts

You can create custom environmental contexts by adding new descriptors to the database:

```sql
INSERT INTO Skill_Check_Descriptors (
    skill_type, action_type, check_phase, result_degree,
    environmental_context, descriptor_text, weight, tags
) VALUES (
    'SystemBypass', 'Lockpicking', 'Attempt', NULL,
    'RuneBoundLock', 'Runes glow around the lock—this is warded by Galdr. You''ll need more than picks.',
    1.0, '["Lore", "Magic"]'
);
```

### Biome-Specific Descriptors

Add biome context for environmental storytelling:

```csharp
var narrative = skillFlavorService.GenerateSkillCheckNarrative(
    "Acrobatics",
    "Climbing",
    roll, dc,
    environmentalContext: "CorrodedStructure",
    biomeContext: "Muspelheim" // Hot, scorched environment
);
```

### Variable Replacement

The service supports variable replacement in descriptor text:

- `{Roll}` - The d20 roll result
- `{DC}` - The difficulty class
- `{Margin}` - Margin of success/failure
- `{Player}`, `{Character}` - Player character name (future)
- `{Tool}`, `{ToolQuality}` - Equipment details (future)

## Statistics and Debugging

### Get Library Statistics

```csharp
var stats = repository.GetSkillUsageFlavorTextStats();

Console.WriteLine($"Skill Check Descriptors: {stats.TotalSkillCheckDescriptors}");
Console.WriteLine($"Fumble Descriptors: {stats.TotalFumbleDescriptors}");

foreach (var (skillType, count) in stats.DescriptorsBySkillType)
{
    Console.WriteLine($"  {skillType}: {count}");
}
```

### Query Specific Descriptors

```csharp
// Get all lockpicking attempt descriptors
var lockpickingAttempts = repository.GetSkillCheckDescriptors(
    skillType: "SystemBypass",
    actionType: "Lockpicking",
    checkPhase: "Attempt"
);

// Get all fumbles for climbing
var climbingFumbles = repository.GetSkillFumbleDescriptors(
    skillType: "Acrobatics",
    actionType: "Climbing"
);
```

## Testing

Example unit test:

```csharp
[Test]
public void SkillFlavorService_GeneratesLockpickingNarrative()
{
    // Arrange
    var repository = new DescriptorRepository(TestConnectionString);
    var service = new SkillUsageFlavorTextService(repository);

    // Act
    var narrative = service.GenerateSkillCheckNarrative(
        "SystemBypass", "Lockpicking",
        roll: 16, dc: 12,
        environmentalContext: "ComplexLock"
    );

    // Assert
    Assert.IsTrue(narrative.IsSuccess);
    Assert.IsNotEmpty(narrative.AttemptDescription);
    Assert.IsNotEmpty(narrative.ResultDescription);
    Assert.IsFalse(narrative.IsFumble);
}

[Test]
public void SkillFlavorService_GeneratesFumbleWithConsequences()
{
    // Arrange
    var repository = new DescriptorRepository(TestConnectionString);
    var service = new SkillUsageFlavorTextService(repository);

    // Act
    var fumble = service.GenerateFumbleDescription(
        "SystemBypass", "Lockpicking"
    );

    // Assert
    Assert.IsNotEmpty(fumble.Description);
    Assert.IsNotEmpty(fumble.ConsequenceType);
    Assert.IsNotEmpty(fumble.Severity);
}
```

## Content Coverage

### Total Descriptors

- **Skill Check Descriptors**: 150+
  - System Bypass: 60+ (Lockpicking, Hacking, Traps)
  - Acrobatics: 40+ (Climbing, Leaping, Stealth)
  - Wasteland Survival: 30+ (Tracking, Foraging, Navigation)
  - Rhetoric: 30+ (Persuasion, Deception, Intimidation)

- **Fumble Descriptors**: 30+
  - Each skill action has 2-5 fumble types
  - Multiple severity levels
  - Mechanical consequences included

## Best Practices

1. **Always provide environmental context** when available for richer descriptions
2. **Handle fumble consequences** mechanically (damage, status effects, DC modifiers)
3. **Use biome context** for location-specific flavor
4. **Fallback gracefully** - service provides fallback text if no descriptor found
5. **Log warnings** when descriptors are missing for debugging
6. **Batch load** descriptors at game start for performance

## Troubleshooting

### Issue: No descriptors returned

**Check:**
- Database schema and data migrations ran successfully
- Skill type and action type match exactly (case-sensitive)
- Environmental context is valid for that action type

```csharp
// Debug query
var allDescriptors = repository.GetSkillCheckDescriptors();
Console.WriteLine($"Total descriptors: {allDescriptors.Count}");
```

### Issue: Same descriptor repeating

**Ensure:**
- Multiple descriptors exist for that context
- Weights are properly set (not all 0)
- Random selection is working (service creates new Random each call)

## Next Steps

After implementing v0.38.10:
- **v0.38.11**: Crafting & Recipe Descriptors
- **v0.38.12**: Exploration Discovery Descriptors
- **v0.38.13**: Social Interaction Descriptors

---

**v0.38.10 Status**: ✅ Complete
**Integration Ready**: Yes
**Database Required**: Yes
