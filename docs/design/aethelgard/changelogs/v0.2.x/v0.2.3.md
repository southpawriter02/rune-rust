# Changelog: v0.2.3 - The Hero's Toolkit (Complete)

**Versions:** v0.2.3a through v0.2.3c
**Release Dates:** December 20, 2025

## Table of Contents

- [Overview](#overview)
- [Part A: The Fuel (Resource Management)](#part-a-the-fuel-resource-management)
  - [Summary](#summary)
  - [New Features](#new-features)
  - [New Files](#new-files)
  - [Modified Files](#modified-files)
  - [API Changes](#api-changes)
  - [Test Coverage](#test-coverage)
  - [Logging Matrix](#logging-matrix)
  - [Architecture](#architecture)
  - [Known Limitations](#known-limitations)
  - [Migration Notes](#migration-notes)
  - [Next Steps (v0.2.3b)](#next-steps-v023b)
  - [Contributors](#contributors)
- [Part B: The Engine (Ability Logic)](#part-b-the-engine-ability-logic)
  - [Summary](#summary-1)
  - [New Features](#new-features-1)
  - [New Files](#new-files-1)
  - [Modified Files](#modified-files-1)
  - [Code Implementation Details](#code-implementation-details)
  - [Logging Matrix](#logging-matrix-1)
  - [Test Coverage](#test-coverage-1)
  - [DI Registration](#di-registration)
  - [Architecture](#architecture-1)
  - [Known Limitations](#known-limitations-1)
  - [Migration Notes](#migration-notes-1)
  - [Verification Results](#verification-results)
  - [Directory Structure After Release](#directory-structure-after-release)
  - [Running Tests](#running-tests)
  - [Next Steps (v0.2.3c)](#next-steps-v023c)
  - [Contributors](#contributors-1)
- [Part C: The Arsenal (Archetype Kits)](#part-c-the-arsenal-archetype-kits)
  - [Summary](#summary-2)
  - [New Features](#new-features-2)
  - [New Files](#new-files-2)
  - [Modified Files](#modified-files-2)
  - [Code Implementation Details](#code-implementation-details-1)
  - [Ability Data](#ability-data)
  - [Database Schema](#database-schema)
  - [Logging Matrix](#logging-matrix-2)
  - [DI Registration Changes](#di-registration-changes)
  - [Architecture](#architecture-2)
  - [Known Limitations](#known-limitations-2)
  - [Migration Notes](#migration-notes-2)
  - [Verification Results](#verification-results-1)
  - [Directory Structure After Release](#directory-structure-after-release-1)
  - [Milestone v0.2.3 Complete](#milestone-v023-complete)
  - [Next Steps (v0.2.4)](#next-steps-v024)
  - [Contributors](#contributors-2)

---

## Overview

Version 0.2.3 represents a complete transformation of Rune & Rust's combat system, introducing a three-layer hero toolkit that enables tactical, ability-driven gameplay. This milestone delivers resource management, data-driven ability execution, and archetype-specific combat kits through three coordinated releases:

**v0.2.3a - The Fuel:** Implemented ResourceService to manage stamina regeneration, aether pools, and the Mystic Overcast mechanic (HP-to-AP conversion at 2:1 ratio). Added 34 comprehensive tests covering resource validation, deduction, and regeneration logic.

**v0.2.3b - The Engine:** Built AbilityService with an EffectScript parser supporting DAMAGE, HEAL, and STATUS commands. Implemented cooldown tracking, dice-based damage calculation with armor interactions, and vulnerability multipliers. Added 39 tests covering all execution paths and edge cases.

**v0.2.3c - The Arsenal:** Seeded database with 8 Tier 1 abilities (2 per archetype), wired combat UI with hotkey-based ability execution, and implemented auto-targeting logic. Completed the gameplay loop connecting resource costs to ability effects through a narrative combat interface.

The combined implementation adds 73 new tests (1470 → 1509 total), establishes a flexible ability scripting system for future content expansion, and provides the foundation for enemy AI abilities, multi-target effects, and ability progression systems.

---

## Part A: The Fuel (Resource Management)

# v0.2.3a Changelog: The Fuel (Resource Management)

**Release Date:** 2025-12-20
**Milestone:** v0.2.3 – The Hero's Toolkit (1 of 3)
**Test Count:** 1470 tests (34 new)

---

## Summary

This release implements the **ResourceService** to manage combat resources (Stamina and Aether). Players now regenerate stamina at the start of each turn, and Mystics can use the **Overcast** mechanic to spend HP when their Aether pool is depleted.

---

## New Features

### Resource Management System (ResourceService)

The core of v0.2.3a is a resource economy that governs ability costs:

| Resource | Regeneration | Special Rules |
|----------|--------------|---------------|
| Stamina  | 5 + (Finesse / 2) per turn | Blocked while Stunned |
| Aether   | None in combat | Mystic Overcast: spend HP at 2:1 ratio |
| Health   | N/A | Spent via Overcast or direct damage |

### Overcast Mechanic (Mystic Archetype)

Mystics can channel abilities beyond their Aether reserves at the cost of their life force:

- When Aether is insufficient, missing AP is converted from HP at **2:1 ratio**
- Overcast is only available if the Mystic would survive the HP cost
- Example: 25 AP ability with 10 current AP → spends 10 AP + 30 HP

### Stamina Regeneration

Combat now features dynamic stamina recovery each turn:

- **Base Regeneration:** 5 stamina per turn
- **Finesse Bonus:** Additional (Finesse / 2) stamina
- **Blocked States:** Stunned combatants do not regenerate
- **Clamping:** Cannot exceed MaxStamina

### Aether Pool (New Character Stat)

Characters now track Aether Points for magical abilities:

- **MaxAp:** 10 + (Will × 5) for Mystics, 0 for non-Mystics
- **CurrentAp:** Does not regenerate during combat
- **Combat Snapshot:** Copied to Combatant at combat start

---

## New Files

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/ResourceType.cs` | Enum for resource types (Health, Stamina, Aether) |
| `RuneAndRust.Core/Interfaces/IResourceService.cs` | Interface for resource management |
| `RuneAndRust.Engine/Services/ResourceService.cs` | Resource management implementation |
| `RuneAndRust.Tests/Engine/ResourceServiceTests.cs` | 34 unit tests for resource mechanics |

---

## Modified Files

| File | Changes |
|------|---------|
| `RuneAndRust.Core/Entities/Character.cs` | Added `CurrentAp`, `MaxAp` properties |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added `CurrentAp`, `MaxAp` properties; updated `FromCharacter()` |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `IResourceService` dependency; stamina regen in `NextTurn()` |
| `RuneAndRust.Terminal/Program.cs` | Registered `IResourceService` in DI container |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added `IResourceService` mock |

---

## API Changes

### IResourceService Interface

New service contract for resource management:

```csharp
public interface IResourceService
{
    bool CanAfford(Combatant combatant, ResourceType type, int cost);
    bool Deduct(Combatant combatant, ResourceType type, int cost);
    int RegenerateStamina(Combatant combatant);
    int GetCurrent(Combatant combatant, ResourceType type);
    int GetMax(Combatant combatant, ResourceType type);
    bool IsMystic(Combatant combatant);
}
```

### CombatService Constructor (Breaking Change)

The constructor now requires `IResourceService`:

```csharp
// Before (v0.2.2c)
public CombatService(..., ICreatureTraitService traitService, ILogger)

// After
public CombatService(..., ICreatureTraitService traitService, IResourceService resourceService, ILogger)
```

### Character Entity

New properties for Aether management:

```csharp
public int MaxAp { get; set; } = 0;
public int CurrentAp { get; set; } = 0;
```

### Combatant Model

New properties and updated factory method:

```csharp
public int CurrentAp { get; set; }
public int MaxAp { get; set; }

public static Combatant FromCharacter(CharacterEntity c)
{
    // ... now includes CurrentAp and MaxAp
}
```

---

## Test Coverage

### New Tests (34 total)

**CanAfford Tests:**
- `CanAfford_ZeroCost_ReturnsTrue`
- `CanAfford_NegativeCost_ReturnsTrue`
- `CanAfford_Stamina_SufficientStamina_ReturnsTrue`
- `CanAfford_Stamina_InsufficientStamina_ReturnsFalse`
- `CanAfford_Health_SufficientHp_ReturnsTrue`
- `CanAfford_Health_InsufficientHp_ReturnsFalse`
- `CanAfford_Aether_NonMystic_ReturnsFalse`
- `CanAfford_Aether_Mystic_SufficientAp_ReturnsTrue`
- `CanAfford_Aether_Mystic_InsufficientAp_CanOvercast_ReturnsTrue`
- `CanAfford_Aether_Mystic_InsufficientAp_CannotOvercast_ReturnsFalse`
- `CanAfford_Aether_Mystic_ZeroAp_CanOvercast_ReturnsTrue`

**Deduct Tests:**
- `Deduct_ZeroCost_ReturnsTrue`
- `Deduct_Stamina_DeductsCorrectAmount`
- `Deduct_Stamina_InsufficientStamina_ReturnsFalse`
- `Deduct_Health_DeductsCorrectAmount`
- `Deduct_Aether_NormalDeduction`
- `Deduct_Aether_Overcast_SpendsHpAt2To1Ratio`
- `Deduct_Aether_Overcast_FullHpCost`
- `Deduct_Aether_NonMystic_ReturnsFalse`
- `Deduct_SyncsToCharacterSource`

**RegenerateStamina Tests:**
- `RegenerateStamina_AppliesBaseRegen`
- `RegenerateStamina_ClampsToMaxStamina`
- `RegenerateStamina_AtMaxStamina_ReturnsZero`
- `RegenerateStamina_Stunned_ReturnsZero`
- `RegenerateStamina_HighFinesse_IncreaseRegen`
- `RegenerateStamina_SyncsToCharacterSource`

**GetCurrent / GetMax Tests:**
- `GetCurrent_ReturnsCorrectValues`
- `GetMax_ReturnsCorrectValues`

**IsMystic Tests:**
- `IsMystic_MysticArchetype_ReturnsTrue`
- `IsMystic_WarriorArchetype_ReturnsFalse`
- `IsMystic_EnemyCombatant_ReturnsFalse`

**Edge Case Tests:**
- `Deduct_Aether_CanAffordButJustBarely_Succeeds`
- `Deduct_Aether_WouldDieFromOvercast_Fails`
- `Deduct_Stamina_EnemyCombatant_DoesNotSyncToSource`

---

## Logging Matrix

| Event | Level | Template |
|-------|-------|----------|
| Service Init | Information | `"ResourceService initialized"` |
| Affordability Check | Trace | `"[Resource] {Name} checking affordability: {Type} cost {Cost}"` |
| Free Action | Trace | `"[Resource] {Name} checked cost {Cost} for {Type}: free action"` |
| Cannot Afford | Warning | `"[Resource] {Name} cannot afford {Cost} {Type}. Current: {Current}"` |
| Deduction Start | Debug | `"[Resource] {Name} deducting {Cost} {Type}. Before: {Before}"` |
| Deduction Success | Information | `"[Resource] {Name} spent {Cost} {Type}. After: {After}"` |
| Overcast Check | Debug | `"[Resource] {Name} Overcast check: Need {ApCost} AP, have {CurrentAp}..."` |
| Overcast Execution | Warning | `"[Resource] {Name} OVERCASTS! Spent {ApSpent} AP + {HpCost} HP..."` |
| Stamina Regen | Information | `"[Resource] {Name} regenerates {Amount} stamina..."` |
| Stunned Block | Debug | `"[Resource] {Name} is Stunned - no stamina regeneration"` |
| Source Sync | Trace | `"[Resource] Synced {Type} to CharacterSource: {Current}"` |
| Non-Mystic Aether | Debug | `"[Resource] {Name} is not a Mystic - cannot use Aether abilities"` |

---

## Architecture

```
┌─────────────────────┐     ┌──────────────────────┐     ┌─────────────────────┐
│  CombatService      │────▶│   ResourceService    │────▶│   Combatant         │
│  (NextTurn)         │     │   (RegenerateStamina)│     │   - CurrentStamina  │
└─────────────────────┘     └──────────────────────┘     │   - CurrentAp       │
         │                           │                   │   - CurrentHp       │
         │                           ▼                   └─────────────────────┘
         │                  ┌──────────────────────┐              │
         │                  │   Resource Checks:   │              │
         │                  │   - CanAfford()      │              │
         │                  │   - Deduct()         │              │
         │                  │   - IsMystic()       │              │
         │                  └──────────────────────┘              │
         │                                                        │
         ▼                                                        ▼
┌─────────────────────┐                               ┌─────────────────────┐
│  Ability System     │◀──────────────────────────────│   Character Source  │
│  (v0.2.3b - Future) │                               │   (Sync on change)  │
└─────────────────────┘                               └─────────────────────┘
```

### Resource Flow

```
Turn Start
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  RegenerateStamina(combatant)                                   │
│  ├─ Check: IsStunned? → No regen                                │
│  ├─ Calculate: 5 + (Finesse / 2)                                │
│  ├─ Clamp: min(regen, MaxStamina - CurrentStamina)              │
│  └─ Apply + Sync to CharacterSource                             │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
Player/Enemy Action
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  CanAfford(combatant, ResourceType, cost)                       │
│  ├─ Stamina: CurrentStamina >= cost                             │
│  ├─ Health:  CurrentHp >= cost                                  │
│  └─ Aether:  IsMystic? Can Overcast if HP > (cost-AP)*2        │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  Deduct(combatant, ResourceType, cost)                          │
│  ├─ Stamina: CurrentStamina -= cost                             │
│  ├─ Health:  CurrentHp -= cost                                  │
│  └─ Aether:  Spend AP first, then HP at 2:1 (Overcast)         │
└─────────────────────────────────────────────────────────────────┘
```

---

## Known Limitations

1. **Aether Initialization**: MaxAp/CurrentAp defaults to 0. Character creation must set these for Mystic archetype.
2. **No Exhausted Status**: Only Stunned blocks stamina regen. Exhausted effect not yet implemented.
3. **Enemy Aether**: Enemies currently have no Aether Pool. Caster enemies use stamina-based attacks.
4. **No UI Display**: Resource values are tracked but not yet displayed in combat UI.

---

## Migration Notes

### For Developers

If you have custom CombatService instantiations, you must now provide an `IResourceService`:

```csharp
// Update your DI registration
services.AddSingleton<IResourceService, ResourceService>();
```

### For Tests

Existing CombatService tests need to mock `IResourceService`:

```csharp
private readonly Mock<IResourceService> _mockResourceService = new Mock<IResourceService>();

// Add to constructor
_mockResourceService.Setup(r => r.RegenerateStamina(It.IsAny<Combatant>())).Returns(0);

_sut = new CombatService(
    _gameState,
    _mockInitiative.Object,
    _mockAttackResolution.Object,
    _mockLootService.Object,
    _mockStatusEffects.Object,
    _mockAIService.Object,
    _mockTraitService.Object,
    _mockResourceService.Object,  // NEW
    _mockLogger.Object);
```

### Character Migration

Existing characters will have MaxAp = 0 and CurrentAp = 0. For Mystic characters, these should be initialized:

```csharp
if (character.Archetype == ArchetypeType.Mystic)
{
    character.MaxAp = 10 + (character.Will * 5);
    character.CurrentAp = character.MaxAp;
}
```

---

## Next Steps (v0.2.3b)

- Implement `IAbilityService` for active ability execution
- Create `Ability` entity with cost definitions
- Integrate ability costs with ResourceService
- Add ability cooldown tracking

---

## Contributors

- Implementation: Claude Opus 4.5

---

## Part B: The Engine (Ability Logic)

# v0.2.3b Changelog: The Engine (Ability Logic)

**Release Date:** 2025-12-20
**Milestone:** v0.2.3 - The Hero's Toolkit (2 of 3)
**Test Count:** 1509 tests (39 new)

---

## Summary

This release implements the **AbilityService** to parse and execute data-driven abilities using an **EffectScript** system. Players can now define abilities with stamina/aether costs, cooldown tracking, and multi-effect execution through semicolon-delimited command strings. The EffectScript parser supports three core commands: DAMAGE (dice-based damage with type-specific armor interactions), HEAL (flat restoration clamped to MaxHP), and STATUS (status effect application with configurable duration and stacks). This implementation completes the second layer of v0.2.3's hero toolkit, building on v0.2.3a's resource management foundation and preparing for v0.2.3c's ability database integration.

---

## New Features

### EffectScript Parsing System

Abilities are defined using a semicolon-separated command syntax that allows chaining multiple effects:

| Command | Format | Example | Behavior |
|---------|--------|---------|----------|
| DAMAGE  | `DAMAGE:Type:Dice` | `DAMAGE:Physical:2d6` | Rolls dice, applies vulnerability multiplier, Physical damage is reduced by armor soak |
| HEAL    | `HEAL:Amount` | `HEAL:15` | Restores flat HP amount, clamped to MaxHP |
| STATUS  | `STATUS:Type:Duration:Stacks` | `STATUS:Bleeding:3:2` | Applies status effect with optional stack count (defaults to 1) |

**Example Multi-Effect Ability:**
```
EffectScript: "DAMAGE:Physical:3d6;STATUS:Bleeding:2:1"
```
This ability deals 3d6 physical damage (subject to armor soak) and applies 1 stack of Bleeding for 2 turns.

### Damage Type Interactions

Physical damage is reduced by armor soak, while non-physical damage types (Fire, Cold, Poison, etc.) bypass armor:

- **Physical Damage:** `FinalDamage = max(0, (RolledDamage * VulnerabilityMultiplier) - ArmorSoak)`
- **Non-Physical Damage:** `FinalDamage = RolledDamage * VulnerabilityMultiplier`

This creates tactical depth where heavily armored enemies are vulnerable to magical attacks.

### Cooldown Management

Abilities with `CooldownTurns > 0` are tracked per-combatant in a `Dictionary<Guid, int>`:

- **On Use:** Cooldown value is set to the ability's `CooldownTurns`
- **Turn Start:** All cooldowns are decremented by 1 via `ProcessCooldowns()`
- **Ready State:** Cooldowns reaching 0 are removed from the dictionary

### Resource Integration

The AbilityService validates and deducts costs through the ResourceService:

- **Stamina Cost:** Standard action cost for physical abilities
- **Aether Cost:** Magical abilities with Mystic Overcast support (HP-to-AP conversion at 2:1 ratio)
- **Validation Order:** Cooldown check → Stamina check → Aether check

---

## New Files

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/ActiveAbility.cs` | Ability definition entity with costs, cooldowns, range, and EffectScript |
| `RuneAndRust.Core/Models/Combat/AbilityResult.cs` | Execution result record containing success status, narrative message, and effect totals |
| `RuneAndRust.Core/Interfaces/IAbilityService.cs` | Service contract for ability validation, execution, and cooldown processing |
| `RuneAndRust.Engine/Services/AbilityService.cs` | EffectScript parser with DAMAGE, HEAL, and STATUS command implementations |
| `RuneAndRust.Tests/Engine/AbilityServiceTests.cs` | 39 unit tests covering all execution paths and edge cases |

---

## Modified Files

| File | Changes |
|------|---------|
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added `Cooldowns` property (`Dictionary<Guid, int>`) for per-ability cooldown tracking |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `IAbilityService` dependency; integrated `ProcessCooldowns()` call in `NextTurn()` |
| `RuneAndRust.Terminal/Program.cs` | Registered `IAbilityService` as Singleton in DI container |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added `IAbilityService` mock to CombatService constructor calls |

---

## Code Implementation Details

### ActiveAbility Entity

```csharp
public class ActiveAbility
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;        // "Power Strike", "Flame Bolt"
    public string Description { get; set; } = string.Empty; // AAM-VOICE compliant flavor text
    public int StaminaCost { get; set; }                    // 0 for free abilities
    public int AetherCost { get; set; }                     // 0 for non-magical abilities
    public int CooldownTurns { get; set; }                  // 0 for no cooldown
    public int Range { get; set; } = 1;                     // 0=Self, 1=Melee, >1=Ranged
    public string EffectScript { get; set; } = string.Empty; // Semicolon-separated commands
}
```

**Key Behaviors:**
- `Id` is auto-generated GUID for cooldown dictionary key
- `Range` property exists but is not yet validated (future feature)
- `EffectScript` is parsed at execution time, not at ability creation

### AbilityResult Record

```csharp
public record AbilityResult(
    bool Success,
    string Message,
    int TotalDamage = 0,
    int TotalHealing = 0,
    List<string>? StatusesApplied = null)
{
    public static AbilityResult Failure(string reason);
    public static AbilityResult Ok(string message, int damage = 0, int healing = 0, List<string>? statuses = null);
}
```

**Key Behaviors:**
- Immutable record type for clean return semantics
- `TotalDamage` and `TotalHealing` aggregate across all commands in a multi-effect script
- `StatusesApplied` contains status effect names (e.g., "Bleeding", "Poisoned") for UI display
- `Message` is a narrative string for combat log integration (e.g., "Hero uses Power Strike on Goblin! Deals 12 physical damage.")

### IAbilityService Interface

```csharp
public interface IAbilityService
{
    bool CanUse(Combatant user, ActiveAbility ability);
    AbilityResult Execute(Combatant user, Combatant target, ActiveAbility ability);
    void ProcessCooldowns(Combatant combatant);
    int GetCooldownRemaining(Combatant combatant, Guid abilityId);
}
```

**Key Behaviors:**
- `CanUse()` performs non-destructive validation (cooldown, resources)
- `Execute()` deducts resources, sets cooldown, then parses EffectScript
- `ProcessCooldowns()` decrements all cooldowns by 1 and removes expired entries
- `GetCooldownRemaining()` returns 0 if ability is ready, else remaining turns

### AbilityService Implementation

**Constructor Dependencies:**
```csharp
public AbilityService(
    IResourceService resourceService,
    IStatusEffectService statusEffectService,
    IDiceService diceService,
    ILogger<AbilityService> logger)
```

**DAMAGE Command Execution:**
- Parses dice notation using regex pattern `(\d+)d(\d+)` (e.g., "2d6" → count=2, sides=6)
- Rolls dice via `IDiceService.RollSingle()` in a loop
- Applies vulnerability multiplier from `IStatusEffectService.GetDamageMultiplier(target)`
- Physical damage is reduced by `target.ArmorSoak + IStatusEffectService.GetSoakModifier(target)`
- Non-physical damage bypasses soak entirely
- Damage is clamped to 0 minimum (cannot heal via negative damage)

**HEAL Command Execution:**
- Parses flat integer amount from command parameter
- Applies healing: `target.CurrentHp += amount`
- Clamped to MaxHP: `actualHealing = min(amount, MaxHp - CurrentHp)`
- Returns actual healing done (0 if target is already at full HP)

**STATUS Command Execution:**
- Parses `StatusEffectType` enum from string (case-insensitive)
- Defaults to 1 stack if stack parameter is omitted
- Applies effect via `IStatusEffectService.ApplyEffect()` in a loop for multiple stacks
- Unknown status types are logged and skipped (no failure)

**Cooldown Processing:**
- Iterates through `Combatant.Cooldowns` dictionary
- Decrements each value by 1
- Collects expired ability IDs (value ≤ 0) and removes them after iteration
- Empty cooldown dictionary is handled gracefully (no-op)

### Combatant Model Extension

```csharp
public Dictionary<Guid, int> Cooldowns { get; set; } = new();
```

**Key Behaviors:**
- Key is `ActiveAbility.Id` (GUID)
- Value is remaining turns until ability is ready
- Initialized as empty dictionary (not null)
- Combat-volatile: cleared when combat ends

---

## Logging Matrix

### AbilityService Logs

| Event | Level | Template |
|-------|-------|----------|
| Service Init | Information | `"AbilityService initialized"` |
| Can Use Check | Debug | `"[Ability] {User} checking if can use {Ability}"` |
| On Cooldown | Debug | `"[Ability] {User} cannot use {Ability}: on cooldown ({Remaining} turns)"` |
| Insufficient Stamina | Debug | `"[Ability] {User} cannot use {Ability}: insufficient stamina ({Cost} required, {Current} available)"` |
| Insufficient Aether | Debug | `"[Ability] {User} cannot use {Ability}: insufficient aether ({Cost} required, {Current} available)"` |
| Ability Ready | Debug | `"[Ability] {User} can use {Ability}"` |
| Execution Start | Information | `"[Ability] {User} uses {Ability} on {Target}"` |
| Execution Failure | Warning | `"[Ability] {User} failed to use {Ability}: {Reason}"` |
| Cooldown Set | Debug | `"[Ability] {User} ability {Ability} on cooldown: {Turns} turns"` |
| Empty EffectScript | Warning | `"[Ability] {Ability} has no EffectScript"` |
| Parsing EffectScript | Debug | `"[Ability] Parsing EffectScript: {Script}"` |
| Executing Command | Debug | `"[Ability] Executing command: {Command}"` |
| Unknown Command | Warning | `"[Ability] Unknown command type: {CommandType}"` |
| DAMAGE Applied | Information | `"[Ability] DAMAGE: {User} deals {Damage} {Type} damage to {Target} (rolled {Roll}, soak applied)"` |
| HEAL Applied | Information | `"[Ability] HEAL: {Target} healed for {Amount} HP (actual: {Actual})"` |
| STATUS Applied | Information | `"[Ability] STATUS: Applied {Type} to {Target} (Duration: {Duration}, Stacks: {Stacks})"` |
| Execution Complete | Information | `"[Ability] {User} used {Ability} on {Target}: {Message}"` |
| Cooldowns Processed | Trace | `"[Ability] Processing cooldowns for {Combatant}: {Count} active"` |
| Cooldown Expired | Debug | `"[Ability] {Combatant} ability {AbilityId} cooldown expired"` |
| Cooldown Decremented | Trace | `"[Ability] Decremented {AbilityId} cooldown to {Remaining}"` |
| Invalid Dice Notation | Warning | `"[Ability] Invalid dice notation: {Notation}"` |
| DAMAGE Missing Params | Warning | `"[Ability] DAMAGE command missing parameters: {Parts}"` |
| HEAL Missing Params | Warning | `"[Ability] HEAL command missing amount parameter"` |
| HEAL Invalid Amount | Warning | `"[Ability] HEAL command has invalid amount: {Amount}"` |
| STATUS Missing Params | Warning | `"[Ability] STATUS command missing parameters: {Parts}"` |
| Unknown Status Type | Warning | `"[Ability] Unknown status effect type: {Type}"` |
| STATUS Invalid Duration | Warning | `"[Ability] STATUS command has invalid duration: {Duration}"` |

---

## Test Coverage

### Summary

**Total Tests:** 1509 (up from 1470 in v0.2.3a)
**New Tests:** 39
**Test Class:** `AbilityServiceTests`
**Test Duration:** 554ms (entire test suite)
**Pass Rate:** 100% (0 failures)

### Complete Test Inventory

#### CanUse Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `CanUse_OnCooldown_ReturnsFalse` | Ability with remaining cooldown turns cannot be used |
| `CanUse_InsufficientStamina_ReturnsFalse` | Validates stamina cost via ResourceService |
| `CanUse_InsufficientAether_ReturnsFalse` | Validates aether cost via ResourceService |
| `CanUse_AllConditionsMet_ReturnsTrue` | Ability is usable when cooldown and resources are available |
| `CanUse_ZeroCooldownRemaining_ReturnsTrue` | Expired cooldown (value=0) does not block usage |
| `CanUse_NoCosts_ReturnsTrue` | Free abilities (0 stamina, 0 aether) always pass cost check |

#### Execute Tests - Resource Handling (4 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_DeductsStaminaCost` | Verifies ResourceService.Deduct() is called with stamina cost |
| `Execute_DeductsAetherCost` | Verifies ResourceService.Deduct() is called with aether cost |
| `Execute_SetsCooldown` | Cooldown value is set in Cooldowns dictionary after execution |
| `Execute_CannotUse_ReturnsFailure` | Execution aborts and returns failure result if CanUse() fails |

#### Execute Tests - DAMAGE Command (7 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_DamageScript_RollsDice` | DiceService.RollSingle() is called correct number of times for dice notation |
| `Execute_DamageScript_AppliesDamageToTarget` | Target.CurrentHp is reduced by rolled damage amount |
| `Execute_PhysicalDamage_AppliesArmorSoak` | Physical damage subtracts target's ArmorSoak before applying |
| `Execute_NonPhysicalDamage_IgnoresArmorSoak` | Non-physical damage types (Fire, Cold, etc.) bypass armor |
| `Execute_DamageScript_AppliesVulnerabilityMultiplier` | Damage is multiplied by StatusEffectService.GetDamageMultiplier() |
| `Execute_DamageScript_ReturnsDamageAmount` | AbilityResult.TotalDamage reflects final damage dealt |
| `Execute_DamageCannotGoNegative` | Damage is clamped to 0 when soak exceeds rolled damage |

#### Execute Tests - HEAL Command (4 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_HealScript_RestoresHp` | Target.CurrentHp is increased by healing amount |
| `Execute_HealScript_ClampsToMaxHp` | Healing cannot exceed target's MaxHp |
| `Execute_HealScript_ReturnsHealingAmount` | AbilityResult.TotalHealing reflects amount healed |
| `Execute_HealScript_ReturnsActualHealingWhenClamped` | TotalHealing is actual amount healed, not requested amount |

#### Execute Tests - STATUS Command (4 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_StatusScript_AppliesEffect` | StatusEffectService.ApplyEffect() is called with correct parameters |
| `Execute_StatusScript_AppliesMultipleStacks` | ApplyEffect() is called N times for N stacks |
| `Execute_StatusScript_ReturnsStatusApplied` | AbilityResult.StatusesApplied contains status effect name |
| `Execute_StatusScript_DefaultsToOneStack` | Omitting stack parameter defaults to 1 stack application |

#### Execute Tests - Combined Scripts (3 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_CombinedScript_AppliesAllEffects` | Multi-command EffectScript executes all commands in sequence |
| `Execute_CombinedScript_DamageAndHeal` | Damage and healing are both applied and summed correctly |
| `Execute_ReturnsSuccessWithMessage` | AbilityResult.Message contains user name, ability name, and target name |

#### ProcessCooldowns Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `ProcessCooldowns_DecrementsValues` | Cooldown values are decremented by 1 |
| `ProcessCooldowns_RemovesExpired` | Cooldowns reaching 0 are removed from dictionary |
| `ProcessCooldowns_HandlesMultipleCooldowns` | Multiple cooldowns are processed independently in one call |
| `ProcessCooldowns_EmptyCooldowns_DoesNothing` | Empty cooldown dictionary does not throw exception |

#### GetCooldownRemaining Tests (2 tests)

| Test Name | Description |
|-----------|-------------|
| `GetCooldownRemaining_ReturnsRemainingTurns` | Returns correct cooldown value from dictionary |
| `GetCooldownRemaining_NotOnCooldown_ReturnsZero` | Returns 0 if ability ID is not in Cooldowns dictionary |

#### Edge Cases (5 tests)

| Test Name | Description |
|-----------|-------------|
| `Execute_EmptyEffectScript_ReturnsSuccessWithMessage` | Empty EffectScript produces success result with "nothing happens" message |
| `Execute_InvalidDiceNotation_HandleGracefully` | Invalid dice notation (e.g., "invalid") is logged and skipped without exception |
| `Execute_UnknownCommand_IgnoresAndContinues` | Unknown command types are logged and skipped, execution continues |
| `Execute_UnknownStatusEffect_DoesNotApply` | Invalid StatusEffectType names are logged and skipped |
| `Execute_SelfTarget_Works` | Abilities targeting user (self-heal, self-buff) execute correctly |

---

## DI Registration

### Program.cs (RuneAndRust.Terminal)

```csharp
// Line 82 - Combat Services section
services.AddSingleton<IAbilityService, AbilityService>();
```

**Lifetime:** Singleton (no mutable state, thread-safe)
**Registration Order:** After `IResourceService`, before `ICombatService`

### CombatService Constructor (Breaking Change)

**Before (v0.2.3a):**
```csharp
public CombatService(
    GameState gameState,
    IInitiativeService initiative,
    IAttackResolutionService attackResolution,
    ILootService lootService,
    IStatusEffectService statusEffects,
    IEnemyAIService aiService,
    ICreatureTraitService traitService,
    IResourceService resourceService,
    ILogger<CombatService> logger)
```

**After (v0.2.3b):**
```csharp
public CombatService(
    GameState gameState,
    IInitiativeService initiative,
    IAttackResolutionService attackResolution,
    ILootService lootService,
    IStatusEffectService statusEffects,
    IEnemyAIService aiService,
    ICreatureTraitService traitService,
    IResourceService resourceService,
    IAbilityService abilityService,  // NEW
    ILogger<CombatService> logger)
```

### CombatService Integration

Cooldowns are processed at the start of each combatant's turn:

```csharp
// Line 187-188 in CombatService.NextTurn()
// Process ability cooldowns at turn start (v0.2.3b)
_abilityService.ProcessCooldowns(active);
```

**Execution Order:**
1. Status effect tick damage/expiration
2. Creature trait triggers
3. Ability cooldown processing (NEW in v0.2.3b)
4. Stamina regeneration
5. Defending stance reset
6. Turn begins

---

## Architecture

### Service Dependency Graph

```
┌─────────────────────────────────────────────────────────────────┐
│                        AbilityService                           │
│  - EffectScript Parser                                          │
│  - Cooldown Manager                                             │
│  - Narrative Generator                                          │
└─────────────────────────────────────────────────────────────────┘
       │                    │                    │
       ▼                    ▼                    ▼
┌─────────────┐   ┌──────────────────┐   ┌────────────────────┐
│ ResourceSvc │   │ StatusEffectSvc  │   │   DiceService      │
│ - CanAfford │   │ - ApplyEffect    │   │   - RollSingle     │
│ - Deduct    │   │ - GetMultiplier  │   │                    │
└─────────────┘   │ - GetSoakMod     │   └────────────────────┘
                  └──────────────────┘

       ▲
       │
┌─────────────────────────────────────────────────────────────────┐
│                        CombatService                             │
│  - NextTurn() calls ProcessCooldowns()                          │
│  - Future: PlayerAction() will call Execute()                   │
└─────────────────────────────────────────────────────────────────┘
```

### EffectScript Execution Flow

```
Execute(user, target, ability)
    │
    ├─ 1. Validate: CanUse(user, ability)
    │     ├─ Check: Cooldown remaining?
    │     ├─ Check: ResourceService.CanAfford(Stamina)?
    │     └─ Check: ResourceService.CanAfford(Aether)?
    │
    ├─ 2. Deduct Resources
    │     ├─ ResourceService.Deduct(Stamina, cost)
    │     └─ ResourceService.Deduct(Aether, cost)
    │
    ├─ 3. Set Cooldown
    │     └─ user.Cooldowns[abilityId] = cooldownTurns
    │
    ├─ 4. Parse EffectScript
    │     └─ Split by ';' → foreach command:
    │           ├─ DAMAGE:Type:Dice
    │           │     ├─ Parse dice notation with regex
    │           │     ├─ Roll dice (loop: RollSingle)
    │           │     ├─ Apply vulnerability multiplier
    │           │     ├─ If Physical: subtract soak
    │           │     └─ target.CurrentHp -= damage
    │           │
    │           ├─ HEAL:Amount
    │           │     ├─ Parse integer amount
    │           │     ├─ Calculate: min(amount, MaxHp - CurrentHp)
    │           │     └─ target.CurrentHp += actual
    │           │
    │           └─ STATUS:Type:Duration:Stacks
    │                 ├─ Parse StatusEffectType enum
    │                 ├─ Parse duration (int)
    │                 ├─ Parse stacks (int, default 1)
    │                 └─ Loop: ApplyEffect(type, duration) × stacks
    │
    └─ 5. Build Narrative
          ├─ Construct message: "{User} uses {Ability} on {Target}!"
          ├─ Append command narratives
          └─ Return AbilityResult(Success, Message, TotalDamage, TotalHealing, Statuses)
```

### Cooldown Processing Flow (Turn Start)

```
CombatService.NextTurn()
    │
    ├─ Determine active combatant
    │
    ├─ Process status effects
    │
    ├─ ProcessCooldowns(active)
    │     │
    │     ├─ foreach (abilityId, remainingTurns) in Cooldowns:
    │     │     ├─ newValue = remainingTurns - 1
    │     │     ├─ if newValue <= 0:
    │     │     │     └─ Mark for removal (expired)
    │     │     └─ else:
    │     │           └─ Cooldowns[abilityId] = newValue
    │     │
    │     └─ foreach (expired abilityId):
    │           └─ Cooldowns.Remove(abilityId)
    │
    ├─ Regenerate stamina
    │
    └─ Reset defending stance
```

---

## Known Limitations

1. **No UI Integration:** Abilities are not yet exposed in combat commands. Player cannot use abilities in v0.2.3b.
2. **No Ability Database:** Abilities must be manually instantiated. Character ability loadout is not persisted.
3. **Range Validation Not Implemented:** `ActiveAbility.Range` property exists but is not checked during execution.
4. **No Target Validation:** Abilities can target dead combatants or invalid targets.
5. **No Self-Only Flag:** Self-buff abilities can incorrectly target enemies.
6. **EffectScript Errors Are Silent:** Invalid commands are logged but execution continues. No feedback to player about partial failures.
7. **No Dice Roll Display:** Damage calculations show final result but not individual die rolls.

---

## Migration Notes

### For Developers

If you have custom `CombatService` instantiations, you must now provide an `IAbilityService`:

```csharp
// Update your DI registration
services.AddSingleton<IAbilityService, AbilityService>();
```

### For Tests

Existing `CombatService` tests need to mock `IAbilityService`:

```csharp
private readonly Mock<IAbilityService> _mockAbilityService = new Mock<IAbilityService>();

// Add to constructor
_mockAbilityService.Setup(a => a.ProcessCooldowns(It.IsAny<Combatant>()));

_sut = new CombatService(
    _gameState,
    _mockInitiative.Object,
    _mockAttackResolution.Object,
    _mockLootService.Object,
    _mockStatusEffects.Object,
    _mockAIService.Object,
    _mockTraitService.Object,
    _mockResourceService.Object,
    _mockAbilityService.Object,  // NEW
    _mockLogger.Object);
```

### Combatant Initialization

The `Cooldowns` dictionary is automatically initialized as empty in the Combatant constructor. No migration needed for existing combatants.

---

## Verification Results

### Build Output

```
Build succeeded.
    0 Warning(s)
    0 Error(s)
```

### Test Output

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
VSTest version 17.14.1 (arm64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:  1509, Skipped:     0, Total:  1509, Duration: 554 ms
```

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   ├── ActiveAbility.cs         [NEW]
│   ├── Character.cs
│   ├── Enemy.cs
│   └── ...
├── Enums/
│   ├── AttackOutcome.cs         [NEW - v0.2.3a pre-work]
│   ├── AttackType.cs            [NEW - v0.2.3a pre-work]
│   ├── ResourceType.cs
│   └── ...
├── Interfaces/
│   ├── IAbilityService.cs       [NEW]
│   ├── IAttackResolutionService.cs [NEW - v0.2.3a pre-work]
│   ├── IResourceService.cs
│   └── ...
├── Models/Combat/
│   ├── AbilityResult.cs         [NEW]
│   ├── AttackResult.cs          [NEW - v0.2.3a pre-work]
│   ├── Combatant.cs             [MODIFIED - added Cooldowns property]
│   └── ...

RuneAndRust.Engine/Services/
├── AbilityService.cs            [NEW]
├── AttackResolutionService.cs   [NEW - v0.2.3a pre-work]
├── CombatService.cs             [MODIFIED - added IAbilityService dependency]
├── ResourceService.cs
└── ...

RuneAndRust.Terminal/
├── Program.cs                   [MODIFIED - registered IAbilityService]
└── ...

RuneAndRust.Tests/Engine/
├── AbilityServiceTests.cs       [NEW - 39 tests]
├── AttackResolutionServiceTests.cs [NEW - v0.2.3a pre-work]
├── CombatServiceTests.cs        [MODIFIED - added IAbilityService mock]
├── ResourceServiceTests.cs
└── ...
```

---

## Running Tests

### Full Test Suite
```bash
dotnet test
```

### AbilityService Tests Only
```bash
dotnet test --filter "FullyQualifiedName~AbilityServiceTests"
```

### Specific Test Method
```bash
dotnet test --filter "FullyQualifiedName~AbilityServiceTests.Execute_DamageScript_AppliesDamageToTarget"
```

### List All Tests
```bash
dotnet test --list-tests | grep AbilityServiceTests
```

---

## Next Steps (v0.2.3c)

- Create `ActiveAbility` database table with migration script
- Seed starter abilities for Warrior, Scout, and Mystic archetypes
- Add `CharacterAbilities` junction table for many-to-many relationship
- Integrate ability selection into character creation flow
- Expose "use ability" command in combat UI (`use [ability name] on [target]`)
- Display available abilities with cooldown status in combat screen
- Add ability tooltips showing costs, cooldown, and effects
- Implement ability unlock/progression system

---

## Contributors

- Implementation: Claude Opus 4.5

---

## Part C: The Arsenal (Archetype Kits)

# v0.2.3c Changelog: The Arsenal (Archetype Kits)

**Release Date:** 2025-12-20
**Milestone:** v0.2.3 - The Hero's Toolkit (3 of 3)
**Test Count:** 1509 tests (0 new, existing tests updated)

---

## Summary

This release completes milestone v0.2.3 "The Hero's Toolkit" by seeding the database with **Tier 1 abilities for each archetype** and wiring the `use` command in Combat UI. Players can now execute archetype-specific abilities using numbered hotkeys (`1`, `2`, `3`) or by name (`use wild swing`), with auto-targeting for single-enemy encounters and explicit target syntax for multi-enemy scenarios (`use aether dart on goblin`). The combat screen now displays an ability panel with hotkey bindings, resource costs, and cooldown status. This implementation connects v0.2.3b's EffectScript parser to actual gameplay, enabling the tactical combat experience that defines Rune & Rust.

---

## New Features

### Archetype Ability Kits

Each archetype receives 2 Tier 1 abilities at character creation:

| Archetype | Ability 1 | Ability 2 |
|-----------|-----------|-----------|
| **Warrior** | Wild Swing (35 STA, 2d8 Physical) | Defensive Stance (Free, +Fortified, CD:2) |
| **Skirmisher** | Precise Shot (30 STA, 1d8 Physical, Range:2) | Evasive Roll (20 STA, +Evasion, CD:2) |
| **Mystic** | Aether Dart (15 AP, 1d10 Arcane, Range:3) | Mind Spike (25 AP, 1d6 Psychic + Dazed, CD:1) |
| **Adept** | Mend Wound (20 STA, HEAL:12, CD:2) | Blessed Strike (15 AP, 1d6 Radiant + HEAL:6, CD:1) |

### Combat UI Commands

New combat commands for ability usage:

| Command | Example | Description |
|---------|---------|-------------|
| `use <name>` | `use wild swing` | Use ability by name (partial match) |
| `use <#>` | `use 1` | Use ability by hotkey number |
| `<#>` | `1` | Shortcut for `use <#>` |
| `use <name> on <target>` | `use aether dart on goblin` | Use ability on specific target |
| `use <#> at <target>` | `use 2 at wolf` | Use hotkey ability on specific target |

### Auto-Targeting Logic

Abilities automatically resolve targets based on context:

| Condition | Behavior |
|-----------|----------|
| Self-targeting ability (Range=0) | Target is user |
| Single enemy alive | Auto-select that enemy |
| Multiple enemies alive | Require explicit target ("on <name>") |
| Invalid target specified | Return error with available target names |

### Combat Screen Ability Panel

New UI section displays player abilities during combat:

```
╭──────────────────────────────────────────╮
│         YOUR ABILITIES                   │
├───┬──────────────────┬───────────┬───────┤
│ # │ Ability          │ Cost      │Status │
├───┼──────────────────┼───────────┼───────┤
│[1]│ Wild Swing       │ 35 STA    │ READY │
│[2]│ Defensive Stance │ Free      │ CD: 2 │
╰───┴──────────────────┴───────────┴───────╯
```

Status indicators:
- **READY** (green): Ability can be used
- **CD: X** (red): Cooldown remaining (X turns)
- **N/A** (grey): Insufficient resources

---

## New Files

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IActiveAbilityRepository.cs` | Repository interface with `GetByArchetypeAsync()` and `ExistsByNameAsync()` |
| `RuneAndRust.Persistence/Repositories/ActiveAbilityRepository.cs` | EF Core repository implementation with archetype filtering |
| `RuneAndRust.Persistence/Data/AbilitySeeder.cs` | Idempotent seeder with 8 Tier 1 abilities (2 per archetype) |

---

## Modified Files

| File | Changes |
|------|---------|
| `RuneAndRust.Core/Entities/ActiveAbility.cs` | Added `Archetype` (ArchetypeType) and `Tier` (int, default 1) properties |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added `Abilities` list property; updated `FromCharacter()` to accept abilities parameter |
| `RuneAndRust.Core/Interfaces/ICombatService.cs` | Added `GetPlayerAbilities()`, `ExecutePlayerAbility(int)`, `ExecutePlayerAbility(string)` |
| `RuneAndRust.Core/ViewModels/CombatViewModel.cs` | Added `AbilityView` record and `PlayerAbilities` property |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Added `DbSet<ActiveAbility>` with entity configuration and composite index |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `IActiveAbilityRepository` dependency; ability loading in `StartCombat()`; ability execution methods |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added `use` command parsing for combat phase; hotkey shortcuts (1-9) |
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | Added `RenderAbilities()` method for ability panel display |
| `RuneAndRust.Terminal/Program.cs` | Registered `IActiveAbilityRepository`; changed `CombatService` to Scoped; added seeder call |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added `IActiveAbilityRepository` mock with default setup |

---

## Code Implementation Details

### ActiveAbility Entity Extensions

```csharp
// New properties added to ActiveAbility.cs
public ArchetypeType Archetype { get; set; }
public int Tier { get; set; } = 1;
```

**Key Behaviors:**
- `Archetype` determines which characters can learn the ability
- `Tier` controls unlock progression (Tier 1: Level 1+, Tier 2: Level 5+, Tier 3: Level 10+)

### IActiveAbilityRepository Interface

```csharp
public interface IActiveAbilityRepository : IRepository<ActiveAbility>
{
    Task<IEnumerable<ActiveAbility>> GetByArchetypeAsync(ArchetypeType archetype, int maxTier = 1);
    Task<ActiveAbility?> GetByNameAsync(string name);
    Task AddRangeAsync(IEnumerable<ActiveAbility> abilities);
    Task<bool> ExistsByNameAsync(string name);
}
```

**Key Behaviors:**
- `GetByArchetypeAsync()` filters by archetype and tier ceiling
- Results ordered by Tier, then Name for consistent UI display
- Case-insensitive name matching for player convenience

### AbilityView Record

```csharp
public record AbilityView(
    int Hotkey,            // 1-based index
    string Name,           // "Wild Swing"
    string CostDisplay,    // "35 STA" or "15 AP" or "Free"
    int CooldownRemaining, // 0 if ready
    bool IsUsable          // Can afford resources and not on cooldown
);
```

### Combat Ability Execution Flow

```
CommandParser.HandleCombat("use 1")
    │
    ├─ Parse: hotkey=1, targetName=null
    │
    └─ CombatService.ExecutePlayerAbility(1, null)
          │
          ├─ Get ability by index from player.Abilities
          │
          ├─ AbilityService.CanUse(player, ability)
          │     ├─ Check cooldown
          │     ├─ Check stamina
          │     └─ Check aether
          │
          ├─ ResolveAbilityTarget(ability, targetName)
          │     ├─ Range=0 → return player (self-target)
          │     ├─ Single enemy → auto-select
          │     ├─ Multiple + no target → return null (error)
          │     └─ Explicit target → find by name
          │
          ├─ AbilityService.Execute(player, target, ability)
          │     ├─ Deduct resources
          │     ├─ Set cooldown
          │     └─ Parse EffectScript → apply effects
          │
          ├─ Log combat event
          │
          ├─ Check target death → remove combatant
          │
          └─ Return narrative message
```

### Seeder Implementation

```csharp
public static async Task SeedAsync(RuneAndRustDbContext context, ILogger? logger = null)
{
    if (await context.ActiveAbilities.AnyAsync())
    {
        logger?.LogDebug("Active abilities already exist, skipping seed");
        return;
    }

    var abilities = GetTier1Abilities();
    await context.ActiveAbilities.AddRangeAsync(abilities);
    await context.SaveChangesAsync();
}
```

**Key Behaviors:**
- Idempotent: skips if any abilities exist
- Seeds all archetypes in single transaction
- Domain 4 compliant descriptions (no precision measurements)

---

## Ability Data

### Warrior Abilities

| Ability | Cost | Script | Cooldown | Range | Description |
|---------|------|--------|----------|-------|-------------|
| Wild Swing | 35 STA | `DAMAGE:Physical:2d8` | 0 | 1 | Powerful but reckless attack that sacrifices precision for raw power |
| Defensive Stance | Free | `STATUS:Fortified:1:1` | 2 | 0 | Brace yourself against incoming attacks, raising your guard |

### Skirmisher Abilities

| Ability | Cost | Script | Cooldown | Range | Description |
|---------|------|--------|----------|-------|-------------|
| Precise Shot | 30 STA | `DAMAGE:Physical:1d8` | 0 | 2 | Take careful aim at an exposed weakness |
| Evasive Roll | 20 STA | `STATUS:Evasion:1:1` | 2 | 0 | Quick tumble to avoid incoming attacks |

### Mystic Abilities

| Ability | Cost | Script | Cooldown | Range | Description |
|---------|------|--------|----------|-------|-------------|
| Aether Dart | 15 AP | `DAMAGE:Arcane:1d10` | 0 | 3 | Channel raw Aetheric energy into a concentrated bolt |
| Mind Spike | 25 AP | `DAMAGE:Psychic:1d6;STATUS:Dazed:1:1` | 1 | 2 | Psychic assault that pierces mental defenses |

### Adept Abilities

| Ability | Cost | Script | Cooldown | Range | Description |
|---------|------|--------|----------|-------|-------------|
| Mend Wound | 20 STA | `HEAL:12` | 2 | 0 | Channel restorative energy to close minor wounds |
| Blessed Strike | 15 AP | `DAMAGE:Radiant:1d6;HEAL:6` | 1 | 1 | Infuse weapon with purifying light that harms and heals |

---

## Database Schema

### ActiveAbilities Table

```sql
CREATE TABLE "ActiveAbilities" (
    "Id" uuid NOT NULL PRIMARY KEY,
    "Name" character varying(100) NOT NULL,
    "Description" character varying(500) NOT NULL,
    "StaminaCost" integer NOT NULL,
    "AetherCost" integer NOT NULL,
    "CooldownTurns" integer NOT NULL,
    "Range" integer NOT NULL,
    "EffectScript" character varying(500) NOT NULL,
    "Archetype" integer NOT NULL,
    "Tier" integer NOT NULL
);

CREATE UNIQUE INDEX "IX_ActiveAbilities_Name" ON "ActiveAbilities" ("Name");
CREATE INDEX "IX_ActiveAbilities_Archetype_Tier" ON "ActiveAbilities" ("Archetype", "Tier");
```

---

## Logging Matrix

### CombatService Ability Logs

| Event | Level | Template |
|-------|-------|----------|
| Abilities Loaded | Information | `"Loaded {Count} abilities for archetype {Archetype}"` |
| Auto-target | Debug | `"Auto-targeting single enemy: {Target}"` |
| Self-target | Debug | `"{Ability} is self-targeting"` |
| Explicit Target | Debug | `"Explicit target: {Target}"` |
| Multiple Enemies | Warning | `"Multiple enemies present, target required for {Ability}"` |
| Invalid Hotkey | Debug | `"Invalid ability hotkey: {Hotkey}. Player has {Count} abilities."` |
| Ability Not Found | Debug | `"Ability '{AbilityName}' not found in player's kit"` |
| Target Slain | Warning | `"{Target} was slain by ability!"` |
| Victory | Information | `"Combat Victory! All enemies defeated by ability."` |

### AbilitySeeder Logs

| Event | Level | Template |
|-------|-------|----------|
| Skip Seed | Debug | `"Active abilities already exist, skipping seed"` |
| Seed Start | Information | `"Seeding Tier 1 abilities..."` |
| Seed Complete | Information | `"Seeded {Count} Tier 1 abilities"` |

---

## DI Registration Changes

### Program.cs

```csharp
// Repository registration (line 48)
services.AddScoped<IActiveAbilityRepository, ActiveAbilityRepository>();

// CombatService changed from Singleton to Scoped (line 85)
services.AddScoped<ICombatService, CombatService>();

// Seeder call after host build (lines 99-104)
using (var scope = host.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<RuneAndRustDbContext>();
    AbilitySeeder.SeedAsync(context).GetAwaiter().GetResult();
}
```

### CombatService Constructor (Breaking Change)

**Before (v0.2.3b):**
```csharp
public CombatService(..., IAbilityService abilityService, ILogger<CombatService> logger)
```

**After (v0.2.3c):**
```csharp
public CombatService(..., IAbilityService abilityService, IActiveAbilityRepository abilityRepository, ILogger<CombatService> logger)
```

---

## Architecture

### Ability Loading Flow

```
Game Start
    │
    └─ AbilitySeeder.SeedAsync() → 8 abilities to database
         │
         └─ Combat Start
              │
              └─ CombatService.StartCombat()
                    │
                    ├─ Get character archetype
                    │
                    ├─ IActiveAbilityRepository.GetByArchetypeAsync(archetype, maxTier=1)
                    │
                    └─ Combatant.FromCharacter(character, abilities)
                          │
                          └─ player.Abilities = abilities
```

### Command Parsing Flow

```
User Input: "use aether dart on goblin"
    │
    └─ CommandParser.HandleCombat()
          │
          ├─ Match: "use " prefix
          │
          ├─ ExecuteAbilityCommand("aether dart on goblin")
          │     │
          │     ├─ Find " on " separator
          │     │     └─ abilityArg = "aether dart"
          │     │     └─ targetName = "goblin"
          │     │
          │     └─ CombatService.ExecutePlayerAbility("aether dart", "goblin")
          │
          └─ Display result + advance turn
```

---

## Known Limitations

1. **No Ability Progression:** Only Tier 1 abilities are seeded; Tier 2/3 require level-based unlocking (future feature)
2. **No Ability Customization:** Abilities are fixed per archetype; no talent trees or ability swapping
3. **Enemy Abilities Not Implemented:** Enemies use basic attacks only; enemy ability system deferred to v0.2.4
4. **No Healing Target Selection:** Self-targeting healing abilities cannot target allies
5. **Range Validation Not Enforced:** Ranged abilities can target any enemy regardless of distance
6. **No Ability Tooltips:** Full ability descriptions are not shown in combat UI

---

## Migration Notes

### For Developers

If you have custom `CombatService` instantiations, add the `IActiveAbilityRepository`:

```csharp
// Update your mocks in tests
var mockAbilityRepo = new Mock<IActiveAbilityRepository>();
mockAbilityRepo.Setup(r => r.GetByArchetypeAsync(It.IsAny<ArchetypeType>(), It.IsAny<int>()))
    .ReturnsAsync(new List<ActiveAbility>());

_sut = new CombatService(
    _gameState,
    _mockInitiative.Object,
    _mockAttackResolution.Object,
    _mockLootService.Object,
    _mockStatusEffects.Object,
    _mockAIService.Object,
    _mockTraitService.Object,
    _mockResourceService.Object,
    _mockAbilityService.Object,
    mockAbilityRepo.Object,  // NEW
    _mockLogger.Object);
```

### Database Migration

Run EF Core migration to create the ActiveAbilities table:

```bash
dotnet ef migrations add AddActiveAbilities --project RuneAndRust.Persistence
dotnet ef database update --project RuneAndRust.Persistence
```

---

## Verification Results

### Build Output

```
Build succeeded.
    63 Warning(s)
    0 Error(s)
```

### Test Output

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
VSTest version 17.14.1 (arm64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:  1509, Skipped:     0, Total:  1509, Duration: 572 ms
```

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   └── ActiveAbility.cs             [MODIFIED - added Archetype, Tier]
├── Interfaces/
│   ├── IActiveAbilityRepository.cs  [NEW]
│   └── ICombatService.cs            [MODIFIED - added ability methods]
├── Models/Combat/
│   └── Combatant.cs                 [MODIFIED - added Abilities list]
├── ViewModels/
│   └── CombatViewModel.cs           [MODIFIED - added AbilityView, PlayerAbilities]

RuneAndRust.Persistence/
├── Data/
│   ├── AbilitySeeder.cs             [NEW]
│   └── RuneAndRustDbContext.cs      [MODIFIED - added DbSet]
├── Repositories/
│   └── ActiveAbilityRepository.cs   [NEW]

RuneAndRust.Engine/Services/
├── CombatService.cs                 [MODIFIED - ability loading, execution, UI]
├── CommandParser.cs                 [MODIFIED - use command, hotkeys]

RuneAndRust.Terminal/
├── Program.cs                       [MODIFIED - DI, seeder call]
├── Services/
│   └── CombatScreenRenderer.cs      [MODIFIED - ability panel]

RuneAndRust.Tests/Engine/
├── CombatServiceTests.cs            [MODIFIED - added ability repo mock]
```

---

## Milestone v0.2.3 Complete

This release completes the v0.2.3 milestone "The Hero's Toolkit":

| Sub-version | Feature | Status |
|-------------|---------|--------|
| v0.2.3a | Resource Service (Stamina/Aether/Overcast) | Complete |
| v0.2.3b | Ability Service (EffectScript Parser) | Complete |
| v0.2.3c | Archetype Kits (Database + UI) | Complete |

---

## Next Steps (v0.2.4)

- Implement enemy ability system with AI ability selection
- Add Tier 2 abilities unlocked at Level 5
- Create ability unlock screen in character progression
- Add visual effects for ability execution (screen flash, damage numbers)
- Implement multi-target abilities (AOE damage, group heals)
- Add ability combos and synergies between archetypes

---

## Contributors

- Implementation: Claude Opus 4.5
