# v0.15.0d Design Specification: Contested & Extended Checks

**Version:** 0.15.0d
**Theme:** Contested & Extended Checks
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0a Complete (Core Dice Mechanics Refactor), v0.15.0b Complete (Seeded Random Provider), v0.15.0c Complete (Skill Check Refactor)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ContestedOutcome Enum](#4-contestedoutcome-enum)
5. [ContestedCheckResult Value Object](#5-contestedcheckresult-value-object)
6. [Contested Check Logic](#6-contested-check-logic)
7. [ExtendedCheckStatus Enum](#7-extendedcheckstatus-enum)
8. [ExtendedCheckState Entity](#8-extendedcheckstate-entity)
9. [Extended Check Logic](#9-extended-check-logic)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration](#11-configuration)
12. [Commands](#12-commands)
13. [User-Facing Changes](#13-user-facing-changes)
14. [Logging Specifications](#14-logging-specifications)
15. [Unit Testing Requirements](#15-unit-testing-requirements)
16. [Use Cases](#16-use-cases)
17. [Deliverable Checklist](#17-deliverable-checklist)
18. [Acceptance Criteria](#18-acceptance-criteria)
19. [Future Considerations](#19-future-considerations)
20. [Implementation Notes](#20-implementation-notes)
21. [Document Metadata](#21-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.0d, the Contested & Extended Checks phase. This part introduces two advanced check mechanics that build upon the success-counting foundation established in v0.15.0a-c:

1. **Contested Checks**: Two parties roll against each other, comparing net successes to determine a winner. Used for opposed skill checks like grappling, stealth vs. perception, or social duels.

2. **Extended Checks**: Multi-round skill challenges that accumulate successes over time toward a target threshold. Used for complex tasks like picking a difficult lock, hacking a terminal, or tracking prey across the wasteland.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Contested Checks** | `PerformContestedCheck()` compares `TotalResult` | `ResolveContestedCheck()` compares `NetSuccesses` |
| **Contested Result** | Returns tuple `(ActiveResult, PassiveResult, Winner)` | Returns `ContestedCheckResult` value object |
| **Fumble Handling** | Not handled specially in contested | Fumbler auto-loses; both fumble = mutual failure |
| **Tie Resolution** | Active player wins (simple comparison) | Initiator gets minor advantage |
| **Extended Checks** | Not implemented | `ExtendedCheckState` entity tracks multi-round progress |
| **Accumulated Successes** | N/A | `NetSuccesses` added per round toward target |
| **Fumble Penalty** | N/A | -2 accumulated successes per fumble |
| **Catastrophic Failure** | N/A | 3 consecutive fumbles ends check |

### 1.3 Scope

**In Scope:**
- Define `ContestedOutcome` enum (6 values)
- Create `ContestedCheckResult` value object
- Implement contested check resolution logic with fumble handling
- Define `ExtendedCheckStatus` enum (5 values)
- Create `ExtendedCheckState` entity for multi-round checks
- Implement extended check round processing logic
- Handle fumble penalties and catastrophic failure
- Unit tests for contested and extended checks (~8 tests)

**Out of Scope:**
- Dice roll logging infrastructure - v0.15.0e
- Combat hit quality integration - v0.15.0f
- Fumble consequence narratives - v0.15.1+
- Skill context modifiers - v0.15.1+
- Chase sequence state machine - v0.15.2
- Terminal hacking multi-layer - v0.15.4

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 2 | `ContestedOutcome` (6 values), `ExtendedCheckStatus` (5 values) |
| Value Objects | 1 | `ContestedCheckResult` |
| Entities | 1 | `ExtendedCheckState` |
| Services | 1 | `SkillCheckService` (extended with contested/extended methods) |
| Unit Tests | ~8 | Contested outcomes, extended accumulation, fumble handling |

---

## 2. Dependencies

### 2.1 Required from v0.15.0a (Core Dice Mechanics)

| Component | Location | Usage in v0.15.0d |
|-----------|----------|-------------------|
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Provides `NetSuccesses`, `IsFumble`, `IsCriticalSuccess` |
| `DiceConstants` | `Domain/Constants/DiceConstants.cs` | `CriticalSuccessNet` threshold (5) |
| `DiceService` | `Application/Services/DiceService.cs` | Returns success-counting results |

### 2.2 Required from v0.15.0b (Seeded Random Provider)

| Component | Location | Usage in v0.15.0d |
|-----------|----------|-------------------|
| `IRandomProvider` | `Domain/Interfaces/IRandomProvider.cs` | Injected into `DiceService` |
| `SeededRandomProvider` | `Application/Services/SeededRandomProvider.cs` | Deterministic testing |

### 2.3 Required from v0.15.0c (Skill Check Refactor)

| Component | Location | Usage in v0.15.0d |
|-----------|----------|-------------------|
| `SkillOutcome` | `Domain/Enums/SkillOutcome.cs` | 6-tier outcome classification |
| `SkillCheckResult` | `Domain/ValueObjects/SkillCheckResult.cs` | Individual check results |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Base service to extend |
| `ClassifyOutcome()` | `SkillOutcomeExtensions.cs` | Outcome classification helper |

### 2.4 Current SkillCheckService Contested Method (to be replaced)

```csharp
// Current contested check method - to be refactored
public (SkillCheckResult ActiveResult, SkillCheckResult PassiveResult, string Winner) PerformContestedCheck(
    Player activePlayer,
    Player passivePlayer,
    string activeSkillId,
    string passiveSkillId,
    AdvantageType activeAdvantage = AdvantageType.Normal,
    AdvantageType passiveAdvantage = AdvantageType.Normal)
{
    // ... current implementation compares TotalResult
    var winner = activeResult.TotalResult >= passiveResult.TotalResult
        ? activePlayer.Name
        : passivePlayer.Name;
    // ...
}
```

### 2.5 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.0f | `CombatService` | Contested combat maneuvers (grapple, shove) |
| v0.15.2 | `ChaseService` | Chase sequences use contested Acrobatics |
| v0.15.3 | `SocialService` | Social duels use contested Rhetoric |
| v0.15.4 | `TerminalService` | Multi-layer hacking uses extended checks |
| v0.15.5 | `TrackingService` | Multi-phase pursuit uses extended checks |

---

## 3. Architecture Diagrams

### 3.1 Contested Check Resolution Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CONTESTED CHECK RESOLUTION FLOW                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INPUT: InitiatorId, DefenderId, InitiatorSkill, DefenderSkill               │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  1. ROLL FOR BOTH PARTIES                                           │    │
│  │                                                                      │    │
│  │  initiatorRoll = DiceService.Roll(initiatorPool)                   │    │
│  │  defenderRoll = DiceService.Roll(defenderPool)                     │    │
│  │                                                                      │    │
│  │  Example:                                                           │    │
│  │    Initiator: 5d10 → [8, 9, 1, 4, 3] → 2 successes, 1 botch = 1 net│    │
│  │    Defender:  4d10 → [10, 8, 5, 2]   → 2 successes, 0 botch = 2 net│    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  2. CHECK FOR FUMBLES (Priority)                                    │    │
│  │                                                                      │    │
│  │  if (initiator.IsFumble && defender.IsFumble)                      │    │
│  │      return BothFumble (mutual failure)                            │    │
│  │                                                                      │    │
│  │  if (initiator.IsFumble)                                           │    │
│  │      return InitiatorFumble (defender auto-wins)                   │    │
│  │                                                                      │    │
│  │  if (defender.IsFumble)                                            │    │
│  │      return DefenderFumble (initiator auto-wins)                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │ no fumbles                                                       │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  3. COMPARE NET SUCCESSES                                           │    │
│  │                                                                      │    │
│  │  diff = initiator.NetSuccesses - defender.NetSuccesses              │    │
│  │                                                                      │    │
│  │  Example: 1 - 2 = -1                                                │    │
│  │                                                                      │    │
│  │  if (diff > 0) → InitiatorWins, margin = diff                      │    │
│  │  if (diff < 0) → DefenderWins, margin = -diff                      │    │
│  │  if (diff == 0) → Tie, margin = 0                                  │    │
│  │                                                                      │    │
│  │  Example: diff = -1 → DefenderWins, margin = 1                     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  OUTPUT: ContestedCheckResult                                               │
│  {                                                                           │
│      InitiatorId, DefenderId,                                               │
│      InitiatorRoll, DefenderRoll,                                           │
│      Outcome: DefenderWins,                                                  │
│      Margin: 1,                                                              │
│      WinnerId: DefenderId                                                    │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Contested Outcome Examples

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       CONTESTED OUTCOME EXAMPLES                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INITIATOR WINS:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Stealth vs Perception                                              │    │
│  │                                                                      │    │
│  │  Rogue (Stealth): 6d10 → [8, 9, 10, 4, 3, 5] → 3 net successes     │    │
│  │  Guard (Perception): 4d10 → [8, 6, 3, 2] → 1 net success           │    │
│  │                                                                      │    │
│  │  Difference: 3 - 1 = 2 → InitiatorWins, Margin: 2                  │    │
│  │                                                                      │    │
│  │  Narrative: "You slip past the guard completely unnoticed."        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  DEFENDER WINS:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Deception vs Insight                                               │    │
│  │                                                                      │    │
│  │  Liar (Deception): 5d10 → [8, 4, 3, 2, 1] → 0 net successes       │    │
│  │  Target (Insight): 4d10 → [9, 8, 5, 4] → 2 net successes          │    │
│  │                                                                      │    │
│  │  Difference: 0 - 2 = -2 → DefenderWins, Margin: 2                  │    │
│  │                                                                      │    │
│  │  Narrative: "The merchant sees through your lies immediately."     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  TIE (Initiator Advantage):                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Grapple Contest                                                    │    │
│  │                                                                      │    │
│  │  Attacker: 5d10 → [10, 8, 1, 4, 3] → 1 net success                │    │
│  │  Defender: 5d10 → [9, 5, 4, 3, 2] → 1 net success                 │    │
│  │                                                                      │    │
│  │  Difference: 1 - 1 = 0 → Tie, Margin: 0                           │    │
│  │                                                                      │    │
│  │  Rule: Initiator gets minor advantage in ties                      │    │
│  │                                                                      │    │
│  │  Narrative: "You struggle evenly, but press the slight advantage." │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  BOTH FUMBLE (Mutual Failure):                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Chase Contest                                                      │    │
│  │                                                                      │    │
│  │  Runner: 3d10 → [1, 4, 2] → 0 successes, 1 botch = FUMBLE         │    │
│  │  Chaser: 3d10 → [1, 3, 5] → 0 successes, 1 botch = FUMBLE         │    │
│  │                                                                      │    │
│  │  Both fumbled → BothFumble, Margin: 0                              │    │
│  │                                                                      │    │
│  │  Narrative: "Both of you trip and tumble into the rubble."        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  INITIATOR FUMBLE (Defender Auto-Wins):                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Intimidation Contest                                               │    │
│  │                                                                      │    │
│  │  Bully: 4d10 → [1, 4, 3, 2] → 0 successes, 1 botch = FUMBLE       │    │
│  │  Target: 3d10 → [5, 4, 3] → 0 successes, 0 botches = no fumble    │    │
│  │                                                                      │    │
│  │  Initiator fumbled → InitiatorFumble (defender auto-wins)          │    │
│  │  Margin: Target's net successes (0)                                │    │
│  │                                                                      │    │
│  │  Narrative: "Your voice cracks embarrassingly. They laugh at you." │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Extended Check State Machine

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       EXTENDED CHECK STATE MACHINE                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                        ┌─────────────┐                                       │
│                        │   START     │                                       │
│                        └──────┬──────┘                                       │
│                               │ Initialize                                   │
│                               │ - TargetSuccesses = N                        │
│                               │ - MaxRounds = M                              │
│                               │ - AccumulatedSuccesses = 0                   │
│                               │ - ConsecutiveFumbles = 0                     │
│                               ▼                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                        IN PROGRESS                                   │     │
│  │                                                                      │     │
│  │  On each round:                                                      │     │
│  │    1. Character rolls skill check                                   │     │
│  │    2. ProcessRound(DiceRollResult)                                  │     │
│  │                                                                      │     │
│  │    If FUMBLE:                                                       │     │
│  │      - ConsecutiveFumbles++                                         │     │
│  │      - AccumulatedSuccesses -= 2 (min 0)                           │     │
│  │      - If ConsecutiveFumbles >= 3 → CATASTROPHIC FAILURE           │     │
│  │                                                                      │     │
│  │    If NOT FUMBLE:                                                   │     │
│  │      - ConsecutiveFumbles = 0                                       │     │
│  │      - AccumulatedSuccesses += NetSuccesses                         │     │
│  │                                                                      │     │
│  │    RoundsRemaining--                                                │     │
│  │                                                                      │     │
│  │    Check completion:                                                │     │
│  │      - If AccumulatedSuccesses >= TargetSuccesses → SUCCEEDED       │     │
│  │      - If RoundsRemaining <= 0 → FAILED                            │     │
│  │                                                                      │     │
│  └───────┬─────────────────┬─────────────────┬─────────────────┬──────┘     │
│          │                 │                 │                 │             │
│          │ Target Met      │ Time Out        │ 3 Fumbles       │ Abandoned   │
│          ▼                 ▼                 ▼                 ▼             │
│  ┌───────────────┐ ┌───────────────┐ ┌───────────────────┐ ┌───────────┐   │
│  │   SUCCEEDED   │ │    FAILED     │ │CATASTROPHIC FAILURE│ │ ABANDONED │   │
│  │               │ │               │ │                    │ │           │   │
│  │ Target met    │ │ Ran out of    │ │ 3 consecutive      │ │ Player    │   │
│  │ within time   │ │ rounds        │ │ fumbles caused     │ │ gave up   │   │
│  │               │ │               │ │ disaster           │ │           │   │
│  └───────────────┘ └───────────────┘ └───────────────────┘ └───────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Extended Check Example: Lock Picking

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   EXTENDED CHECK EXAMPLE: LOCK PICKING                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Setup:                                                                      │
│    - TargetSuccesses: 6 (complex lock)                                      │
│    - MaxRounds: 5 (time pressure)                                           │
│    - Skill: System Bypass (WITS)                                           │
│    - Pool: 5d10                                                             │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Round 1:                                                            │    │
│  │    Roll: 5d10 → [8, 9, 4, 3, 2] → 2 successes, 0 botches = 2 net   │    │
│  │    Accumulated: 0 + 2 = 2                                           │    │
│  │    Remaining: 4 rounds                                              │    │
│  │    Status: InProgress                                               │    │
│  │    Narrative: "You find the first tumbler..."                       │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                              │                                               │
│                              ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Round 2:                                                            │    │
│  │    Roll: 5d10 → [10, 8, 8, 5, 1] → 3 successes, 1 botch = 2 net   │    │
│  │    Accumulated: 2 + 2 = 4                                           │    │
│  │    Remaining: 3 rounds                                              │    │
│  │    Status: InProgress                                               │    │
│  │    Narrative: "Progress, though a pin nearly slips..."              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                              │                                               │
│                              ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Round 3:                                                            │    │
│  │    Roll: 5d10 → [1, 4, 3, 2, 5] → 0 successes, 1 botch = FUMBLE   │    │
│  │    ConsecutiveFumbles: 1                                            │    │
│  │    Accumulated: 4 - 2 = 2 (fumble penalty)                         │    │
│  │    Remaining: 2 rounds                                              │    │
│  │    Status: InProgress                                               │    │
│  │    Narrative: "Your pick slips! Two tumblers reset."               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                              │                                               │
│                              ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Round 4:                                                            │    │
│  │    Roll: 5d10 → [9, 10, 8, 8, 4] → 4 successes, 0 botches = 4 net │    │
│  │    ConsecutiveFumbles: 0 (reset)                                    │    │
│  │    Accumulated: 2 + 4 = 6                                           │    │
│  │    6 >= 6 (target)                                                  │    │
│  │    Status: Succeeded                                                │    │
│  │    Narrative: "The lock clicks open!"                               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  RESULT: Succeeded in 4 rounds with 6 accumulated successes                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.5 Extended Check Example: Catastrophic Failure

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              EXTENDED CHECK EXAMPLE: CATASTROPHIC FAILURE                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Setup:                                                                      │
│    - TargetSuccesses: 8 (difficult terminal hack)                           │
│    - MaxRounds: 6                                                           │
│    - Skill: System Bypass (WITS)                                           │
│    - Pool: 4d10                                                             │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Round 1:                                                            │    │
│  │    Roll: 4d10 → [8, 5, 4, 3] → 1 success, 0 botches = 1 net        │    │
│  │    Accumulated: 1                                                   │    │
│  │    ConsecutiveFumbles: 0                                            │    │
│  │    Status: InProgress                                               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                              │                                               │
│                              ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Round 2:                                                            │    │
│  │    Roll: 4d10 → [1, 4, 3, 2] → 0 successes, 1 botch = FUMBLE      │    │
│  │    Accumulated: 1 - 2 = 0 (min 0)                                  │    │
│  │    ConsecutiveFumbles: 1                                            │    │
│  │    Status: InProgress                                               │    │
│  │    Narrative: "ICE detected your probe. Resetting..."              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                              │                                               │
│                              ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Round 3:                                                            │    │
│  │    Roll: 4d10 → [1, 5, 3, 2] → 0 successes, 1 botch = FUMBLE      │    │
│  │    Accumulated: 0 - 2 = 0 (already at minimum)                     │    │
│  │    ConsecutiveFumbles: 2                                            │    │
│  │    Status: InProgress (WARNING: one more fumble = disaster)        │    │
│  │    Narrative: "Another probe failed. ICE tracing intensifies..."   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                              │                                               │
│                              ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Round 4:                                                            │    │
│  │    Roll: 4d10 → [1, 1, 4, 3] → 0 successes, 2 botches = FUMBLE    │    │
│  │    ConsecutiveFumbles: 3 → CATASTROPHIC FAILURE TRIGGERED          │    │
│  │    Status: CatastrophicFailure                                      │    │
│  │    Narrative: "ICE countermeasures activate! Neural feedback!"     │    │
│  │               "Terminal locked permanently. Alarm triggered."       │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  RESULT: CatastrophicFailure after 3 consecutive fumbles                    │
│          - Terminal is permanently locked                                   │
│          - Alarm system activated                                           │
│          - Character may suffer additional consequences                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.6 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Enums/                                                              │    │
│  │  ├── ContestedOutcome.cs      ←── NEW (6 contested outcomes)       │    │
│  │  └── ExtendedCheckStatus.cs   ←── NEW (5 check statuses)           │    │
│  │                                                                      │    │
│  │  ValueObjects/                                                       │    │
│  │  └── ContestedCheckResult.cs  ←── NEW (contested result container) │    │
│  │                                                                      │    │
│  │  Entities/                                                           │    │
│  │  └── ExtendedCheckState.cs    ←── NEW (multi-round state tracker)  │    │
│  │                                                                      │    │
│  │  Constants/                                                          │    │
│  │  └── ExtendedCheckConstants.cs ←── NEW (fumble penalty, max fumbles)│   │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Services/                                                           │    │
│  │  └── SkillCheckService.cs     ←── EXTENDED (add contested/extended)│    │
│  │                                                                      │    │
│  │  Interfaces/                                                         │    │
│  │  └── IExtendedCheckService.cs ←── NEW (optional interface)         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. ContestedOutcome Enum

### 4.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/ContestedOutcome.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the outcome of a contested check between two parties.
/// </summary>
/// <remarks>
/// <para>
/// Contested checks compare the net successes of two opposing skill checks.
/// Fumbles take priority over net success comparison.
/// </para>
/// <para>
/// Resolution order:
/// <list type="bullet">
///   <item><description>Both fumble → BothFumble (mutual failure)</description></item>
///   <item><description>Initiator fumbles → InitiatorFumble (defender auto-wins)</description></item>
///   <item><description>Defender fumbles → DefenderFumble (initiator auto-wins)</description></item>
///   <item><description>Compare net successes → InitiatorWins, DefenderWins, or Tie</description></item>
/// </list>
/// </para>
/// </remarks>
public enum ContestedOutcome
{
    /// <summary>
    /// Initiator wins the contested check by having more net successes.
    /// </summary>
    /// <remarks>
    /// The initiator's net successes exceed the defender's net successes.
    /// The margin indicates the difference in net successes.
    /// </remarks>
    InitiatorWins = 0,

    /// <summary>
    /// Defender wins the contested check by having more net successes.
    /// </summary>
    /// <remarks>
    /// The defender's net successes exceed the initiator's net successes.
    /// The margin indicates the difference in net successes.
    /// </remarks>
    DefenderWins = 1,

    /// <summary>
    /// Both parties have equal net successes - initiator gets minor advantage.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When net successes are equal, the initiator (active party) receives
    /// a minor advantage. This represents the momentum of being the aggressor.
    /// </para>
    /// <para>
    /// The minor advantage is context-dependent:
    /// <list type="bullet">
    ///   <item><description>Grapple: Initiator gains grip but not control</description></item>
    ///   <item><description>Chase: Neither gains/loses distance</description></item>
    ///   <item><description>Social: Conversation continues, slight edge to initiator</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    Tie = 2,

    /// <summary>
    /// Both parties fumbled - mutual failure with consequences for both.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Both rolls resulted in fumbles (0 successes AND ≥1 botch).
    /// Both parties suffer fumble consequences.
    /// </para>
    /// <para>
    /// Examples:
    /// <list type="bullet">
    ///   <item><description>Grapple: Both fall prone</description></item>
    ///   <item><description>Chase: Both stumble into hazard</description></item>
    ///   <item><description>Social: Both embarrass themselves</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    BothFumble = 3,

    /// <summary>
    /// Initiator fumbled - defender automatically wins.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The initiator's roll was a fumble (0 successes AND ≥1 botch).
    /// The defender wins regardless of their roll (unless also fumbling).
    /// </para>
    /// <para>
    /// The initiator may suffer additional fumble consequences beyond losing.
    /// The margin is the defender's net successes.
    /// </para>
    /// </remarks>
    InitiatorFumble = 4,

    /// <summary>
    /// Defender fumbled - initiator automatically wins.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The defender's roll was a fumble (0 successes AND ≥1 botch).
    /// The initiator wins regardless of their roll (unless also fumbling).
    /// </para>
    /// <para>
    /// The defender may suffer additional fumble consequences beyond losing.
    /// The margin is the initiator's net successes.
    /// </para>
    /// </remarks>
    DefenderFumble = 5
}
```

### 4.2 Outcome Summary Table

| Outcome | Condition | Margin | Winner | Notes |
|---------|-----------|--------|--------|-------|
| `InitiatorWins` | initiator.Net > defender.Net | initiator.Net - defender.Net | Initiator | Clean victory |
| `DefenderWins` | defender.Net > initiator.Net | defender.Net - initiator.Net | Defender | Clean victory |
| `Tie` | initiator.Net == defender.Net | 0 | N/A (initiator advantage) | Neither wins outright |
| `BothFumble` | Both fumbled | 0 | N/A | Mutual consequences |
| `InitiatorFumble` | Initiator fumbled (only) | defender.Net | Defender | Initiator suffers |
| `DefenderFumble` | Defender fumbled (only) | initiator.Net | Initiator | Defender suffers |

---

## 5. ContestedCheckResult Value Object

### 5.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ContestedCheckResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the complete result of a contested skill check between two parties.
/// </summary>
/// <remarks>
/// <para>
/// Immutable value object containing both parties' rolls, the outcome,
/// and the margin of victory.
/// </para>
/// <para>
/// The contested check resolution follows this priority:
/// <list type="bullet">
///   <item><description>Fumble handling: fumbles auto-lose (or both fumble = mutual failure)</description></item>
///   <item><description>Net success comparison: higher net wins</description></item>
///   <item><description>Tie handling: initiator gets minor advantage</description></item>
/// </list>
/// </para>
/// </remarks>
public readonly record struct ContestedCheckResult
{
    /// <summary>
    /// Gets the unique identifier of the initiator (active party).
    /// </summary>
    /// <remarks>
    /// The initiator is the party who triggered the contested check.
    /// In ties, the initiator receives minor advantage.
    /// </remarks>
    public string InitiatorId { get; init; }

    /// <summary>
    /// Gets the unique identifier of the defender (passive party).
    /// </summary>
    public string DefenderId { get; init; }

    /// <summary>
    /// Gets the skill ID used by the initiator.
    /// </summary>
    public string InitiatorSkillId { get; init; }

    /// <summary>
    /// Gets the skill ID used by the defender.
    /// </summary>
    public string DefenderSkillId { get; init; }

    /// <summary>
    /// Gets the complete dice roll result for the initiator.
    /// </summary>
    /// <remarks>
    /// Contains the individual dice, net successes, and fumble/critical status.
    /// </remarks>
    public DiceRollResult InitiatorRoll { get; init; }

    /// <summary>
    /// Gets the complete dice roll result for the defender.
    /// </summary>
    public DiceRollResult DefenderRoll { get; init; }

    /// <summary>
    /// Gets the outcome of the contested check.
    /// </summary>
    /// <remarks>
    /// One of: InitiatorWins, DefenderWins, Tie, BothFumble, InitiatorFumble, DefenderFumble
    /// </remarks>
    public ContestedOutcome Outcome { get; init; }

    /// <summary>
    /// Gets the margin of victory (winner's net - loser's net).
    /// </summary>
    /// <remarks>
    /// <para>
    /// For fumble outcomes, the margin is the non-fumbling party's net successes.
    /// For BothFumble and Tie, the margin is 0.
    /// </para>
    /// <para>
    /// Higher margin indicates a more decisive victory.
    /// </para>
    /// </remarks>
    public int Margin { get; init; }

    /// <summary>
    /// Gets the ID of the winner, or null for ties and mutual fumbles.
    /// </summary>
    public string? WinnerId => Outcome switch
    {
        ContestedOutcome.InitiatorWins => InitiatorId,
        ContestedOutcome.DefenderWins => DefenderId,
        ContestedOutcome.InitiatorFumble => DefenderId,
        ContestedOutcome.DefenderFumble => InitiatorId,
        _ => null
    };

    /// <summary>
    /// Gets whether there is a clear winner.
    /// </summary>
    public bool HasWinner => WinnerId != null;

    /// <summary>
    /// Gets whether any party fumbled.
    /// </summary>
    public bool HadFumble => Outcome is ContestedOutcome.BothFumble
        or ContestedOutcome.InitiatorFumble
        or ContestedOutcome.DefenderFumble;

    /// <summary>
    /// Gets whether both parties fumbled.
    /// </summary>
    public bool IsMutualFumble => Outcome == ContestedOutcome.BothFumble;

    /// <summary>
    /// Gets the initiator's net successes for convenience.
    /// </summary>
    public int InitiatorNetSuccesses => InitiatorRoll.NetSuccesses;

    /// <summary>
    /// Gets the defender's net successes for convenience.
    /// </summary>
    public int DefenderNetSuccesses => DefenderRoll.NetSuccesses;

    /// <summary>
    /// Returns a formatted string describing the contested check result.
    /// </summary>
    /// <example>
    /// "Contested (Stealth vs Perception): Initiator 3 vs Defender 1 → InitiatorWins (margin: 2)"
    /// "Contested (Grapple vs Grapple): Initiator FUMBLE vs Defender 2 → DefenderWins (auto)"
    /// </example>
    public override string ToString()
    {
        var initiatorDisplay = InitiatorRoll.IsFumble
            ? "FUMBLE"
            : InitiatorRoll.NetSuccesses.ToString();
        var defenderDisplay = DefenderRoll.IsFumble
            ? "FUMBLE"
            : DefenderRoll.NetSuccesses.ToString();

        var marginDisplay = Outcome switch
        {
            ContestedOutcome.InitiatorFumble or ContestedOutcome.DefenderFumble => "auto",
            ContestedOutcome.BothFumble => "mutual",
            _ => $"margin: {Margin}"
        };

        return $"Contested ({InitiatorSkillId} vs {DefenderSkillId}): " +
               $"Initiator {initiatorDisplay} vs Defender {defenderDisplay} → " +
               $"{Outcome} ({marginDisplay})";
    }
}
```

### 5.2 Property Summary Table

| Property | Type | Description |
|----------|------|-------------|
| `InitiatorId` | `string` | ID of the active party |
| `DefenderId` | `string` | ID of the passive party |
| `InitiatorSkillId` | `string` | Skill used by initiator |
| `DefenderSkillId` | `string` | Skill used by defender |
| `InitiatorRoll` | `DiceRollResult` | Complete roll result for initiator |
| `DefenderRoll` | `DiceRollResult` | Complete roll result for defender |
| `Outcome` | `ContestedOutcome` | Result classification |
| `Margin` | `int` | Victory margin (net difference) |
| `WinnerId` | `string?` | ID of winner, or null |
| `HasWinner` | `bool` | True if clear winner exists |
| `HadFumble` | `bool` | True if any fumble occurred |
| `IsMutualFumble` | `bool` | True if both fumbled |
| `InitiatorNetSuccesses` | `int` | Initiator's net successes |
| `DefenderNetSuccesses` | `int` | Defender's net successes |

---

## 6. Contested Check Logic

### 6.1 Resolution Method

**File:** `src/Core/RuneAndRust.Application/Services/SkillCheckService.cs` (additions)

```csharp
/// <summary>
/// Resolves a contested skill check between two characters.
/// </summary>
/// <param name="initiatorId">ID of the initiating character.</param>
/// <param name="defenderId">ID of the defending character.</param>
/// <param name="initiatorSkillId">Skill ID for the initiator.</param>
/// <param name="defenderSkillId">Skill ID for the defender.</param>
/// <param name="initiatorAdvantage">Advantage type for initiator roll.</param>
/// <param name="defenderAdvantage">Advantage type for defender roll.</param>
/// <returns>Complete contested check result.</returns>
/// <remarks>
/// <para>
/// Resolution priority:
/// <list type="bullet">
///   <item><description>Both fumble → BothFumble outcome</description></item>
///   <item><description>Initiator fumbles → InitiatorFumble (defender auto-wins)</description></item>
///   <item><description>Defender fumbles → DefenderFumble (initiator auto-wins)</description></item>
///   <item><description>Compare net successes → higher wins, equal = Tie</description></item>
/// </list>
/// </para>
/// </remarks>
public ContestedCheckResult ResolveContestedCheck(
    string initiatorId,
    string defenderId,
    string initiatorSkillId,
    string defenderSkillId,
    AdvantageType initiatorAdvantage = AdvantageType.Normal,
    AdvantageType defenderAdvantage = AdvantageType.Normal)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(initiatorId, nameof(initiatorId));
    ArgumentException.ThrowIfNullOrWhiteSpace(defenderId, nameof(defenderId));
    ArgumentException.ThrowIfNullOrWhiteSpace(initiatorSkillId, nameof(initiatorSkillId));
    ArgumentException.ThrowIfNullOrWhiteSpace(defenderSkillId, nameof(defenderSkillId));

    _logger.LogDebug(
        "Resolving contested check: {Initiator} ({InitiatorSkill}) vs {Defender} ({DefenderSkill})",
        initiatorId, initiatorSkillId, defenderId, defenderSkillId);

    // Roll for both parties
    var initiatorRoll = RollForCharacter(initiatorId, initiatorSkillId, initiatorAdvantage);
    var defenderRoll = RollForCharacter(defenderId, defenderSkillId, defenderAdvantage);

    // Determine outcome
    var (outcome, margin) = DetermineContestedOutcome(initiatorRoll, defenderRoll);

    var result = new ContestedCheckResult
    {
        InitiatorId = initiatorId,
        DefenderId = defenderId,
        InitiatorSkillId = initiatorSkillId,
        DefenderSkillId = defenderSkillId,
        InitiatorRoll = initiatorRoll,
        DefenderRoll = defenderRoll,
        Outcome = outcome,
        Margin = margin
    };

    LogContestedResult(result);

    return result;
}

/// <summary>
/// Determines the contested outcome based on roll results.
/// </summary>
private static (ContestedOutcome outcome, int margin) DetermineContestedOutcome(
    DiceRollResult initiatorRoll,
    DiceRollResult defenderRoll)
{
    // Priority 1: Both fumble
    if (initiatorRoll.IsFumble && defenderRoll.IsFumble)
    {
        return (ContestedOutcome.BothFumble, 0);
    }

    // Priority 2: Initiator fumble (defender auto-wins)
    if (initiatorRoll.IsFumble)
    {
        return (ContestedOutcome.InitiatorFumble, defenderRoll.NetSuccesses);
    }

    // Priority 3: Defender fumble (initiator auto-wins)
    if (defenderRoll.IsFumble)
    {
        return (ContestedOutcome.DefenderFumble, initiatorRoll.NetSuccesses);
    }

    // Priority 4: Compare net successes
    int difference = initiatorRoll.NetSuccesses - defenderRoll.NetSuccesses;

    if (difference > 0)
    {
        return (ContestedOutcome.InitiatorWins, difference);
    }

    if (difference < 0)
    {
        return (ContestedOutcome.DefenderWins, -difference);
    }

    return (ContestedOutcome.Tie, 0);
}

/// <summary>
/// Rolls for a character using their skill pool.
/// </summary>
private DiceRollResult RollForCharacter(
    string characterId,
    string skillId,
    AdvantageType advantageType)
{
    var skill = _configProvider.GetSkillById(skillId)
        ?? throw new ArgumentException($"Unknown skill: {skillId}", nameof(skillId));

    // Get character (simplified - actual implementation would load from repository)
    var poolSize = CalculatePoolSize(characterId, skill);

    return _diceService.Roll(new DicePool(poolSize, DiceType.D10), advantageType);
}

/// <summary>
/// Logs the contested check result.
/// </summary>
private void LogContestedResult(ContestedCheckResult result)
{
    var logLevel = result.HadFumble ? LogLevel.Information : LogLevel.Debug;

    _logger.Log(logLevel,
        "Contested check: {Initiator} ({INet}) vs {Defender} ({DNet}) → {Outcome} (margin: {Margin})",
        result.InitiatorId, result.InitiatorNetSuccesses,
        result.DefenderId, result.DefenderNetSuccesses,
        result.Outcome, result.Margin);

    _eventLogger?.LogDice("ContestedCheck", result.ToString(),
        data: new Dictionary<string, object>
        {
            ["initiatorId"] = result.InitiatorId,
            ["defenderId"] = result.DefenderId,
            ["initiatorNet"] = result.InitiatorNetSuccesses,
            ["defenderNet"] = result.DefenderNetSuccesses,
            ["outcome"] = result.Outcome.ToString(),
            ["margin"] = result.Margin,
            ["winnerId"] = result.WinnerId ?? "none",
            ["hadFumble"] = result.HadFumble
        });
}
```

### 6.2 Outcome Determination Summary

| Initiator Roll | Defender Roll | Outcome | Margin |
|----------------|---------------|---------|--------|
| Fumble | Fumble | BothFumble | 0 |
| Fumble | Any | InitiatorFumble | defender.Net |
| Any | Fumble | DefenderFumble | initiator.Net |
| Net > Defender | Net < Initiator | InitiatorWins | difference |
| Net < Defender | Net > Initiator | DefenderWins | difference |
| Net == Defender | Net == Initiator | Tie | 0 |

---

## 7. ExtendedCheckStatus Enum

### 7.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/ExtendedCheckStatus.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the current status of an extended (multi-round) skill check.
/// </summary>
/// <remarks>
/// <para>
/// Extended checks accumulate successes over multiple rounds toward a target threshold.
/// The check ends when the target is reached, time runs out, or a catastrophic failure occurs.
/// </para>
/// <para>
/// Status transitions:
/// <list type="bullet">
///   <item><description>InProgress → Succeeded: accumulated ≥ target</description></item>
///   <item><description>InProgress → Failed: rounds exhausted</description></item>
///   <item><description>InProgress → CatastrophicFailure: 3 consecutive fumbles</description></item>
///   <item><description>InProgress → Abandoned: player chose to stop</description></item>
/// </list>
/// </para>
/// </remarks>
public enum ExtendedCheckStatus
{
    /// <summary>
    /// The extended check is still in progress.
    /// </summary>
    /// <remarks>
    /// The character has not yet accumulated enough successes,
    /// and there are rounds remaining.
    /// </remarks>
    InProgress = 0,

    /// <summary>
    /// The extended check succeeded.
    /// </summary>
    /// <remarks>
    /// The accumulated successes met or exceeded the target threshold
    /// within the allowed number of rounds.
    /// </remarks>
    Succeeded = 1,

    /// <summary>
    /// The extended check failed due to running out of time.
    /// </summary>
    /// <remarks>
    /// <para>
    /// All available rounds were used without reaching the target threshold.
    /// </para>
    /// <para>
    /// Regular failure may allow retry with fresh state, depending on context.
    /// </para>
    /// </remarks>
    Failed = 2,

    /// <summary>
    /// The extended check ended in catastrophic failure.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Three consecutive fumbles occurred, triggering a disaster.
    /// </para>
    /// <para>
    /// Catastrophic failure typically has severe consequences:
    /// <list type="bullet">
    ///   <item><description>Lock picking: lock jams permanently</description></item>
    ///   <item><description>Terminal hacking: lockout + alarm triggered</description></item>
    ///   <item><description>Tracking: quarry escapes permanently</description></item>
    ///   <item><description>Climbing: character falls from current height</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    CatastrophicFailure = 3,

    /// <summary>
    /// The extended check was abandoned by the player.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The player chose to stop the extended check before completion.
    /// </para>
    /// <para>
    /// Abandoning may have consequences depending on context:
    /// <list type="bullet">
    ///   <item><description>Stealth infiltration: may trigger alert on retreat</description></item>
    ///   <item><description>Terminal hacking: may leave trace of intrusion</description></item>
    ///   <item><description>Negotiation: may damage reputation</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    Abandoned = 4
}
```

### 7.2 Status Transition Diagram

```
                    ┌──────────────┐
                    │  InProgress  │◄─────────────────┐
                    └──────┬───────┘                  │
                           │                          │
        ┌──────────────────┼──────────────────┐      │
        │                  │                  │      │ (continue rolling)
        ▼                  ▼                  ▼      │
┌───────────────┐  ┌───────────────┐  ┌────────────────────┐
│   Succeeded   │  │    Failed     │  │CatastrophicFailure │
│               │  │               │  │                    │
│ Target met    │  │ Time out      │  │ 3 consecutive      │
└───────────────┘  └───────────────┘  │ fumbles            │
                                      └────────────────────┘
                                               │
                                      ┌────────┴────────┐
                                      ▼                 ▼
                               ┌───────────┐    ┌───────────┐
                               │ Abandoned │    │           │
                               │           │    │ (player   │
                               │ (by player│    │  choice)  │
                               │  choice)  │    │           │
                               └───────────┘    └───────────┘
```

---

## 8. ExtendedCheckState Entity

### 8.1 Constants Definition

**File:** `src/Core/RuneAndRust.Domain/Constants/ExtendedCheckConstants.cs`

```csharp
namespace RuneAndRust.Domain.Constants;

/// <summary>
/// Constants for the extended check system.
/// </summary>
public static class ExtendedCheckConstants
{
    /// <summary>
    /// Number of accumulated successes lost per fumble.
    /// </summary>
    /// <remarks>
    /// When a fumble occurs, the character loses this many accumulated successes
    /// (minimum 0 - cannot go negative).
    /// </remarks>
    public const int FumblePenalty = 2;

    /// <summary>
    /// Number of consecutive fumbles required to trigger catastrophic failure.
    /// </summary>
    /// <remarks>
    /// Three fumbles in a row ends the extended check with catastrophic failure,
    /// regardless of accumulated successes or remaining rounds.
    /// </remarks>
    public const int CatastrophicFumbleThreshold = 3;

    /// <summary>
    /// Default maximum rounds for an extended check if not specified.
    /// </summary>
    public const int DefaultMaxRounds = 10;

    /// <summary>
    /// Minimum target successes for an extended check.
    /// </summary>
    public const int MinimumTargetSuccesses = 1;
}
```

### 8.2 Entity Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/ExtendedCheckState.cs`

```csharp
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Tracks the state of an extended (multi-round) skill check.
/// </summary>
/// <remarks>
/// <para>
/// Extended checks represent complex tasks that require multiple successful attempts
/// to complete. Characters accumulate net successes over multiple rounds until
/// reaching a target threshold or running out of time.
/// </para>
/// <para>
/// Key mechanics:
/// <list type="bullet">
///   <item><description>Each round, character rolls and adds net successes to total</description></item>
///   <item><description>Fumbles subtract 2 accumulated successes (min 0)</description></item>
///   <item><description>3 consecutive fumbles = catastrophic failure</description></item>
///   <item><description>Success when accumulated ≥ target within max rounds</description></item>
/// </list>
/// </para>
/// </remarks>
public class ExtendedCheckState
{
    /// <summary>
    /// Unique identifier for this extended check instance.
    /// </summary>
    public string CheckId { get; init; }

    /// <summary>
    /// ID of the character performing the check.
    /// </summary>
    public string CharacterId { get; init; }

    /// <summary>
    /// ID of the skill being used.
    /// </summary>
    public string SkillId { get; init; }

    /// <summary>
    /// Number of accumulated successes required to complete the check.
    /// </summary>
    public int TargetSuccesses { get; init; }

    /// <summary>
    /// Current accumulated net successes.
    /// </summary>
    /// <remarks>
    /// Increases by net successes each round.
    /// Decreases by 2 on fumble (minimum 0).
    /// </remarks>
    public int AccumulatedSuccesses { get; private set; }

    /// <summary>
    /// Number of rounds remaining before failure.
    /// </summary>
    public int RoundsRemaining { get; private set; }

    /// <summary>
    /// Maximum rounds allowed for this check.
    /// </summary>
    public int MaxRounds { get; init; }

    /// <summary>
    /// Number of rounds completed.
    /// </summary>
    public int RoundsCompleted => MaxRounds - RoundsRemaining;

    /// <summary>
    /// History of dice roll results for each round.
    /// </summary>
    public List<DiceRollResult> RoundResults { get; } = new();

    /// <summary>
    /// Current status of the extended check.
    /// </summary>
    public ExtendedCheckStatus Status { get; private set; }

    /// <summary>
    /// Number of consecutive fumbles in a row.
    /// </summary>
    /// <remarks>
    /// Resets to 0 when a non-fumble roll occurs.
    /// Triggers catastrophic failure at 3.
    /// </remarks>
    public int ConsecutiveFumbles { get; private set; }

    /// <summary>
    /// Total number of fumbles throughout the check (not necessarily consecutive).
    /// </summary>
    public int TotalFumbles { get; private set; }

    /// <summary>
    /// Timestamp when the check was started.
    /// </summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// Timestamp when the check was completed (or null if in progress).
    /// </summary>
    public DateTime? CompletedAt { get; private set; }

    /// <summary>
    /// Gets the progress toward the target (0.0 to 1.0+).
    /// </summary>
    public double Progress => TargetSuccesses > 0
        ? (double)AccumulatedSuccesses / TargetSuccesses
        : 0;

    /// <summary>
    /// Gets whether the check is still active (in progress).
    /// </summary>
    public bool IsActive => Status == ExtendedCheckStatus.InProgress;

    /// <summary>
    /// Gets whether the check has ended (any terminal state).
    /// </summary>
    public bool IsComplete => Status != ExtendedCheckStatus.InProgress;

    /// <summary>
    /// Gets whether one more fumble will trigger catastrophic failure.
    /// </summary>
    public bool IsAtRisk => ConsecutiveFumbles == ExtendedCheckConstants.CatastrophicFumbleThreshold - 1;

    // Private constructor for factory pattern
    private ExtendedCheckState() { }

    /// <summary>
    /// Creates a new extended check state.
    /// </summary>
    /// <param name="checkId">Unique identifier for this check.</param>
    /// <param name="characterId">ID of the character performing the check.</param>
    /// <param name="skillId">ID of the skill being used.</param>
    /// <param name="targetSuccesses">Successes required to complete the check.</param>
    /// <param name="maxRounds">Maximum rounds allowed (default: 10).</param>
    /// <returns>A new ExtendedCheckState in InProgress status.</returns>
    /// <exception cref="ArgumentException">If targetSuccesses or maxRounds is invalid.</exception>
    public static ExtendedCheckState Create(
        string checkId,
        string characterId,
        string skillId,
        int targetSuccesses,
        int maxRounds = ExtendedCheckConstants.DefaultMaxRounds)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(checkId, nameof(checkId));
        ArgumentException.ThrowIfNullOrWhiteSpace(characterId, nameof(characterId));
        ArgumentException.ThrowIfNullOrWhiteSpace(skillId, nameof(skillId));

        if (targetSuccesses < ExtendedCheckConstants.MinimumTargetSuccesses)
            throw new ArgumentOutOfRangeException(
                nameof(targetSuccesses),
                $"Target successes must be at least {ExtendedCheckConstants.MinimumTargetSuccesses}");

        if (maxRounds < 1)
            throw new ArgumentOutOfRangeException(nameof(maxRounds), "Max rounds must be at least 1");

        return new ExtendedCheckState
        {
            CheckId = checkId,
            CharacterId = characterId,
            SkillId = skillId,
            TargetSuccesses = targetSuccesses,
            MaxRounds = maxRounds,
            RoundsRemaining = maxRounds,
            AccumulatedSuccesses = 0,
            ConsecutiveFumbles = 0,
            TotalFumbles = 0,
            Status = ExtendedCheckStatus.InProgress,
            StartedAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Processes a round of the extended check with the given roll result.
    /// </summary>
    /// <param name="rollResult">The dice roll result for this round.</param>
    /// <exception cref="InvalidOperationException">If the check is not in progress.</exception>
    /// <remarks>
    /// <para>
    /// Processing order:
    /// <list type="bullet">
    ///   <item><description>Record the roll result</description></item>
    ///   <item><description>Decrement rounds remaining</description></item>
    ///   <item><description>Handle fumble (penalty + consecutive tracking)</description></item>
    ///   <item><description>Or accumulate net successes</description></item>
    ///   <item><description>Check for completion (success, failure, catastrophic)</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    public void ProcessRound(DiceRollResult rollResult)
    {
        if (Status != ExtendedCheckStatus.InProgress)
            throw new InvalidOperationException(
                $"Cannot process round when check is {Status}");

        // Record the result
        RoundResults.Add(rollResult);
        RoundsRemaining--;

        if (rollResult.IsFumble)
        {
            ProcessFumble();
        }
        else
        {
            ProcessSuccess(rollResult.NetSuccesses);
        }

        // Check completion conditions (if not already set by ProcessFumble)
        if (Status == ExtendedCheckStatus.InProgress)
        {
            CheckCompletion();
        }
    }

    /// <summary>
    /// Handles fumble processing: penalty and consecutive tracking.
    /// </summary>
    private void ProcessFumble()
    {
        ConsecutiveFumbles++;
        TotalFumbles++;

        // Apply fumble penalty
        AccumulatedSuccesses = Math.Max(0,
            AccumulatedSuccesses - ExtendedCheckConstants.FumblePenalty);

        // Check for catastrophic failure
        if (ConsecutiveFumbles >= ExtendedCheckConstants.CatastrophicFumbleThreshold)
        {
            Status = ExtendedCheckStatus.CatastrophicFailure;
            CompletedAt = DateTime.UtcNow;
        }
    }

    /// <summary>
    /// Handles successful (non-fumble) roll processing.
    /// </summary>
    private void ProcessSuccess(int netSuccesses)
    {
        // Reset consecutive fumbles
        ConsecutiveFumbles = 0;

        // Add net successes to accumulated total
        AccumulatedSuccesses += netSuccesses;
    }

    /// <summary>
    /// Checks if the check has reached a completion state.
    /// </summary>
    private void CheckCompletion()
    {
        if (AccumulatedSuccesses >= TargetSuccesses)
        {
            Status = ExtendedCheckStatus.Succeeded;
            CompletedAt = DateTime.UtcNow;
        }
        else if (RoundsRemaining <= 0)
        {
            Status = ExtendedCheckStatus.Failed;
            CompletedAt = DateTime.UtcNow;
        }
    }

    /// <summary>
    /// Abandons the extended check.
    /// </summary>
    /// <exception cref="InvalidOperationException">If the check is not in progress.</exception>
    public void Abandon()
    {
        if (Status != ExtendedCheckStatus.InProgress)
            throw new InvalidOperationException(
                $"Cannot abandon check when status is {Status}");

        Status = ExtendedCheckStatus.Abandoned;
        CompletedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Returns a summary string of the current state.
    /// </summary>
    public override string ToString()
    {
        var riskWarning = IsAtRisk ? " [AT RISK!]" : "";
        return $"ExtendedCheck[{CheckId}]: {AccumulatedSuccesses}/{TargetSuccesses} successes, " +
               $"{RoundsRemaining}/{MaxRounds} rounds remaining, " +
               $"Status: {Status}{riskWarning}";
    }
}
```

### 8.3 Property Summary Table

| Property | Type | Description |
|----------|------|-------------|
| `CheckId` | `string` | Unique identifier for the check |
| `CharacterId` | `string` | Character performing the check |
| `SkillId` | `string` | Skill being used |
| `TargetSuccesses` | `int` | Successes needed to complete |
| `AccumulatedSuccesses` | `int` | Current accumulated successes |
| `RoundsRemaining` | `int` | Rounds left before timeout |
| `MaxRounds` | `int` | Maximum rounds allowed |
| `RoundsCompleted` | `int` | Rounds already taken |
| `RoundResults` | `List<DiceRollResult>` | History of all rolls |
| `Status` | `ExtendedCheckStatus` | Current status |
| `ConsecutiveFumbles` | `int` | Fumbles in a row (resets on success) |
| `TotalFumbles` | `int` | Total fumbles throughout |
| `StartedAt` | `DateTime` | When check started |
| `CompletedAt` | `DateTime?` | When check ended (null if active) |
| `Progress` | `double` | Progress toward target (0.0 to 1.0+) |
| `IsActive` | `bool` | True if InProgress |
| `IsComplete` | `bool` | True if any terminal state |
| `IsAtRisk` | `bool` | True if one more fumble = catastrophic |

---

## 9. Extended Check Logic

### 9.1 Service Methods

**File:** `src/Core/RuneAndRust.Application/Services/SkillCheckService.cs` (additions)

```csharp
/// <summary>
/// Starts a new extended skill check.
/// </summary>
/// <param name="characterId">ID of the character.</param>
/// <param name="skillId">ID of the skill to use.</param>
/// <param name="targetSuccesses">Successes required to complete.</param>
/// <param name="maxRounds">Maximum rounds allowed (default: 10).</param>
/// <returns>The initial ExtendedCheckState.</returns>
public ExtendedCheckState StartExtendedCheck(
    string characterId,
    string skillId,
    int targetSuccesses,
    int maxRounds = ExtendedCheckConstants.DefaultMaxRounds)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(characterId, nameof(characterId));
    ArgumentException.ThrowIfNullOrWhiteSpace(skillId, nameof(skillId));

    var checkId = Guid.NewGuid().ToString("N")[..8]; // Short unique ID

    var state = ExtendedCheckState.Create(
        checkId,
        characterId,
        skillId,
        targetSuccesses,
        maxRounds);

    _logger.LogInformation(
        "Started extended check {CheckId}: {Character} using {Skill}, " +
        "target {Target} successes in {MaxRounds} rounds",
        checkId, characterId, skillId, targetSuccesses, maxRounds);

    return state;
}

/// <summary>
/// Performs one round of an extended check.
/// </summary>
/// <param name="state">The current extended check state.</param>
/// <param name="advantageType">Advantage type for this round's roll.</param>
/// <returns>The updated state after processing this round.</returns>
/// <exception cref="InvalidOperationException">If the check is not in progress.</exception>
public ExtendedCheckState PerformExtendedCheckRound(
    ExtendedCheckState state,
    AdvantageType advantageType = AdvantageType.Normal)
{
    ArgumentNullException.ThrowIfNull(state);

    if (!state.IsActive)
        throw new InvalidOperationException(
            $"Cannot perform round: check is {state.Status}");

    // Roll for this round
    var rollResult = RollForCharacter(state.CharacterId, state.SkillId, advantageType);

    // Process the round
    state.ProcessRound(rollResult);

    // Log the result
    LogExtendedCheckRound(state, rollResult);

    return state;
}

/// <summary>
/// Abandons an in-progress extended check.
/// </summary>
/// <param name="state">The extended check state to abandon.</param>
/// <returns>The updated state with Abandoned status.</returns>
public ExtendedCheckState AbandonExtendedCheck(ExtendedCheckState state)
{
    ArgumentNullException.ThrowIfNull(state);

    state.Abandon();

    _logger.LogInformation(
        "Extended check {CheckId} abandoned by {Character} with {Accumulated}/{Target} successes",
        state.CheckId, state.CharacterId, state.AccumulatedSuccesses, state.TargetSuccesses);

    return state;
}

/// <summary>
/// Logs an extended check round result.
/// </summary>
private void LogExtendedCheckRound(ExtendedCheckState state, DiceRollResult rollResult)
{
    var logLevel = rollResult.IsFumble ? LogLevel.Warning : LogLevel.Debug;
    var riskNote = state.IsAtRisk ? " [AT RISK - one more fumble = catastrophic!]" : "";

    _logger.Log(logLevel,
        "Extended check {CheckId} round {Round}: {Net} net successes " +
        "(accumulated: {Accumulated}/{Target}, remaining: {Remaining}){Risk}",
        state.CheckId, state.RoundsCompleted, rollResult.NetSuccesses,
        state.AccumulatedSuccesses, state.TargetSuccesses, state.RoundsRemaining, riskNote);

    if (state.IsComplete)
    {
        _logger.LogInformation(
            "Extended check {CheckId} completed with status: {Status} " +
            "(accumulated: {Accumulated}, rounds: {Rounds}, fumbles: {Fumbles})",
            state.CheckId, state.Status,
            state.AccumulatedSuccesses, state.RoundsCompleted, state.TotalFumbles);
    }

    _eventLogger?.LogDice("ExtendedCheckRound", $"Round {state.RoundsCompleted}: {rollResult.NetSuccesses} net",
        data: new Dictionary<string, object>
        {
            ["checkId"] = state.CheckId,
            ["characterId"] = state.CharacterId,
            ["skillId"] = state.SkillId,
            ["round"] = state.RoundsCompleted,
            ["netSuccesses"] = rollResult.NetSuccesses,
            ["isFumble"] = rollResult.IsFumble,
            ["accumulated"] = state.AccumulatedSuccesses,
            ["target"] = state.TargetSuccesses,
            ["remaining"] = state.RoundsRemaining,
            ["consecutiveFumbles"] = state.ConsecutiveFumbles,
            ["status"] = state.Status.ToString()
        });
}
```

---

## 10. Data Model Changes

### 10.1 New Types Summary

| Type | Layer | File | Description |
|------|-------|------|-------------|
| `ContestedOutcome` | Domain | `Enums/ContestedOutcome.cs` | 6 contested check outcomes |
| `ExtendedCheckStatus` | Domain | `Enums/ExtendedCheckStatus.cs` | 5 extended check statuses |
| `ContestedCheckResult` | Domain | `ValueObjects/ContestedCheckResult.cs` | Contested check result container |
| `ExtendedCheckState` | Domain | `Entities/ExtendedCheckState.cs` | Multi-round check state tracker |
| `ExtendedCheckConstants` | Domain | `Constants/ExtendedCheckConstants.cs` | Fumble penalty, thresholds |

### 10.2 Modified Types Summary

| Type | Layer | File | Changes |
|------|-------|------|---------|
| `SkillCheckService` | Application | `Services/SkillCheckService.cs` | Add contested/extended methods |

### 10.3 Unchanged Types

| Type | Layer | Notes |
|------|-------|-------|
| `DiceRollResult` | Domain | Used unchanged (from v0.15.0a) |
| `SkillOutcome` | Domain | Used unchanged (from v0.15.0c) |
| `SkillCheckResult` | Domain | Used unchanged (from v0.15.0c) |

---

## 11. Configuration

### 11.1 No New Configuration Files

v0.15.0d does not introduce new configuration files. Constants are defined in `ExtendedCheckConstants.cs` as compile-time values.

### 11.2 Future Configuration (v0.15.1+)

Configuration for extended check parameters may be introduced in a future version:

**Planned: `config/extended-checks.json`**
```json
{
  "$schema": "./schemas/extended-checks.schema.json",
  "fumblePenalty": 2,
  "catastrophicFumbleThreshold": 3,
  "defaultMaxRounds": 10,
  "minimumTargetSuccesses": 1
}
```

This is documented here for context but is **out of scope** for v0.15.0d.

---

## 12. Commands

### 12.1 No Command Changes

v0.15.0d does not modify any user-facing commands directly. The contested and extended check mechanics are invoked programmatically by other services (combat, skills).

### 12.2 Future Command Integration (v0.15.1+)

Future versions may add commands for:

- `contest <skill> <target>` - Initiate contested check
- `extend <skill> <target-successes>` - Start extended check
- `abandon` - Abandon current extended check

---

## 13. User-Facing Changes

### 13.1 Contested Check Output

```
> grapple guard

Contested Grapple Check:
  You: 5d10 → [8, 9, 4, 3, 2] → 2 successes - 0 botches = 2 net
  Guard: 4d10 → [10, 5, 3, 1] → 1 success - 1 botch = 0 net

Result: You win! (margin: 2)
You successfully grapple the guard.
```

### 13.2 Contested Check with Fumble

```
> deceive merchant

Contested Deception vs Insight:
  You: 4d10 → [1, 4, 3, 2] → 0 successes - 1 botch = FUMBLE
  Merchant: 3d10 → [8, 5, 4] → 1 success - 0 botches = 1 net

Result: You fumbled! The merchant sees through your lies immediately.
[The merchant's disposition drops to Hostile]
```

### 13.3 Extended Check Progress

```
> pick lock (complex mechanism)

Extended Check: System Bypass (Target: 6 successes, 5 rounds max)

Round 1: 5d10 → [8, 9, 4, 3, 2] → 2 net successes
  Progress: ██░░░░░░░░ 2/6 (4 rounds remaining)

Round 2: 5d10 → [10, 8, 8, 5, 1] → 2 net successes
  Progress: ████░░░░░░ 4/6 (3 rounds remaining)

Round 3: 5d10 → [1, 4, 3, 2, 5] → FUMBLE! (-2 accumulated)
  Progress: ██░░░░░░░░ 2/6 (2 rounds remaining)
  [WARNING: 1 consecutive fumble - 2 more will cause catastrophic failure!]

Round 4: 5d10 → [9, 10, 8, 8, 4] → 4 net successes
  Progress: ██████████ 6/6 (1 round remaining)

SUCCESS! The lock clicks open.
```

### 13.4 Extended Check Catastrophic Failure

```
> hack terminal

Extended Check: System Bypass (Target: 8 successes, 6 rounds max)

Round 1: 4d10 → [8, 5, 4, 3] → 1 net success
  Progress: █░░░░░░░░░ 1/8 (5 rounds remaining)

Round 2: 4d10 → [1, 4, 3, 2] → FUMBLE! (-2 accumulated)
  Progress: ░░░░░░░░░░ 0/8 (4 rounds remaining)
  [1 consecutive fumble]

Round 3: 4d10 → [1, 5, 3, 2] → FUMBLE! (-2 accumulated)
  Progress: ░░░░░░░░░░ 0/8 (3 rounds remaining)
  [WARNING: 2 consecutive fumbles - one more will cause catastrophic failure!]

Round 4: 4d10 → [1, 1, 4, 3] → FUMBLE!

CATASTROPHIC FAILURE! Three consecutive fumbles!
ICE countermeasures activate. Neural feedback damages your cyberdeck.
Terminal locked permanently. Security alert triggered.
```

---

## 14. Logging Specifications

### 14.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `SkillCheckService` | Information | Contested check start, extended check start/end |
| `SkillCheckService` | Warning | Fumble during extended check |
| `SkillCheckService` | Debug | Contested/extended round results |
| `SkillCheckService` | Information | Catastrophic failure |

### 14.2 Log Message Formats

```
[Information] Resolving contested check: Player1 (Stealth) vs Guard (Perception)
[Debug] Contested check: Player1 (3) vs Guard (1) → InitiatorWins (margin: 2)
[Information] Started extended check abc123: Player1 using SystemBypass, target 6 successes in 5 rounds
[Debug] Extended check abc123 round 2: 2 net successes (accumulated: 4/6, remaining: 3)
[Warning] Extended check abc123 round 3: 0 net successes (accumulated: 2/6, remaining: 2) [AT RISK - one more fumble = catastrophic!]
[Information] Extended check abc123 completed with status: Succeeded (accumulated: 6, rounds: 4, fumbles: 1)
[Information] Extended check def456 completed with status: CatastrophicFailure (accumulated: 0, rounds: 4, fumbles: 3)
```

---

## 15. Unit Testing Requirements

### 15.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Contested outcome determination | 3 |
| ContestedCheckResult properties | 1 |
| Extended check accumulation | 2 |
| Extended check fumble handling | 2 |
| **Total** | **~8** |

### 15.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/ContestedCheckResultTests.cs`

```csharp
[TestFixture]
public class ContestedCheckResultTests
{
    [Test]
    public void DetermineOutcome_InitiatorHigherNet_ReturnsInitiatorWins()
    {
        // Arrange
        var initiatorRoll = CreateRollResult(netSuccesses: 3, isFumble: false);
        var defenderRoll = CreateRollResult(netSuccesses: 1, isFumble: false);

        // Act
        var (outcome, margin) = DetermineContestedOutcome(initiatorRoll, defenderRoll);

        // Assert
        Assert.That(outcome, Is.EqualTo(ContestedOutcome.InitiatorWins));
        Assert.That(margin, Is.EqualTo(2));
    }

    [Test]
    public void DetermineOutcome_InitiatorFumbles_ReturnsInitiatorFumble()
    {
        // Arrange
        var initiatorRoll = CreateRollResult(netSuccesses: 0, isFumble: true);
        var defenderRoll = CreateRollResult(netSuccesses: 2, isFumble: false);

        // Act
        var (outcome, margin) = DetermineContestedOutcome(initiatorRoll, defenderRoll);

        // Assert
        Assert.That(outcome, Is.EqualTo(ContestedOutcome.InitiatorFumble));
        Assert.That(margin, Is.EqualTo(2)); // Defender's net
    }

    [Test]
    public void DetermineOutcome_BothFumble_ReturnsBothFumble()
    {
        // Arrange
        var initiatorRoll = CreateRollResult(netSuccesses: 0, isFumble: true);
        var defenderRoll = CreateRollResult(netSuccesses: 0, isFumble: true);

        // Act
        var (outcome, margin) = DetermineContestedOutcome(initiatorRoll, defenderRoll);

        // Assert
        Assert.That(outcome, Is.EqualTo(ContestedOutcome.BothFumble));
        Assert.That(margin, Is.EqualTo(0));
    }

    [Test]
    public void WinnerId_ReturnsCorrectWinner_ForEachOutcome()
    {
        // Test InitiatorWins
        var resultInitWins = new ContestedCheckResult
        {
            InitiatorId = "player",
            DefenderId = "npc",
            Outcome = ContestedOutcome.InitiatorWins
        };
        Assert.That(resultInitWins.WinnerId, Is.EqualTo("player"));

        // Test DefenderWins
        var resultDefWins = new ContestedCheckResult
        {
            InitiatorId = "player",
            DefenderId = "npc",
            Outcome = ContestedOutcome.DefenderWins
        };
        Assert.That(resultDefWins.WinnerId, Is.EqualTo("npc"));

        // Test Tie
        var resultTie = new ContestedCheckResult
        {
            Outcome = ContestedOutcome.Tie
        };
        Assert.That(resultTie.WinnerId, Is.Null);
    }
}
```

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/ExtendedCheckStateTests.cs`

```csharp
[TestFixture]
public class ExtendedCheckStateTests
{
    [Test]
    public void ProcessRound_AccumulatesNetSuccesses()
    {
        // Arrange
        var state = ExtendedCheckState.Create("test", "player", "lockpick",
            targetSuccesses: 6, maxRounds: 5);
        var roll1 = CreateRollResult(netSuccesses: 2, isFumble: false);
        var roll2 = CreateRollResult(netSuccesses: 3, isFumble: false);

        // Act
        state.ProcessRound(roll1);
        state.ProcessRound(roll2);

        // Assert
        Assert.That(state.AccumulatedSuccesses, Is.EqualTo(5));
        Assert.That(state.RoundsRemaining, Is.EqualTo(3));
        Assert.That(state.Status, Is.EqualTo(ExtendedCheckStatus.InProgress));
    }

    [Test]
    public void ProcessRound_SucceedsWhenTargetReached()
    {
        // Arrange
        var state = ExtendedCheckState.Create("test", "player", "lockpick",
            targetSuccesses: 4, maxRounds: 5);
        var roll1 = CreateRollResult(netSuccesses: 2, isFumble: false);
        var roll2 = CreateRollResult(netSuccesses: 3, isFumble: false); // Total: 5 >= 4

        // Act
        state.ProcessRound(roll1);
        state.ProcessRound(roll2);

        // Assert
        Assert.That(state.Status, Is.EqualTo(ExtendedCheckStatus.Succeeded));
        Assert.That(state.AccumulatedSuccesses, Is.EqualTo(5));
    }

    [Test]
    public void ProcessRound_FumbleReducesAccumulated()
    {
        // Arrange
        var state = ExtendedCheckState.Create("test", "player", "lockpick",
            targetSuccesses: 6, maxRounds: 5);
        var roll1 = CreateRollResult(netSuccesses: 3, isFumble: false);
        var fumble = CreateRollResult(netSuccesses: 0, isFumble: true);

        // Act
        state.ProcessRound(roll1); // Accumulated: 3
        state.ProcessRound(fumble); // Accumulated: 3 - 2 = 1

        // Assert
        Assert.That(state.AccumulatedSuccesses, Is.EqualTo(1));
        Assert.That(state.ConsecutiveFumbles, Is.EqualTo(1));
        Assert.That(state.Status, Is.EqualTo(ExtendedCheckStatus.InProgress));
    }

    [Test]
    public void ProcessRound_ThreeConsecutiveFumbles_CausesCatastrophicFailure()
    {
        // Arrange
        var state = ExtendedCheckState.Create("test", "player", "lockpick",
            targetSuccesses: 6, maxRounds: 10);
        var fumble = CreateRollResult(netSuccesses: 0, isFumble: true);

        // Act
        state.ProcessRound(fumble);
        state.ProcessRound(fumble);
        state.ProcessRound(fumble);

        // Assert
        Assert.That(state.Status, Is.EqualTo(ExtendedCheckStatus.CatastrophicFailure));
        Assert.That(state.ConsecutiveFumbles, Is.EqualTo(3));
    }

    [Test]
    public void ProcessRound_NonFumbleResetsConsecutiveFumbles()
    {
        // Arrange
        var state = ExtendedCheckState.Create("test", "player", "lockpick",
            targetSuccesses: 10, maxRounds: 10);
        var fumble = CreateRollResult(netSuccesses: 0, isFumble: true);
        var success = CreateRollResult(netSuccesses: 2, isFumble: false);

        // Act
        state.ProcessRound(fumble);
        state.ProcessRound(fumble);
        Assert.That(state.ConsecutiveFumbles, Is.EqualTo(2));

        state.ProcessRound(success);

        // Assert
        Assert.That(state.ConsecutiveFumbles, Is.EqualTo(0));
        Assert.That(state.TotalFumbles, Is.EqualTo(2)); // Total doesn't reset
    }

    [Test]
    public void ProcessRound_FailsWhenRoundsExhausted()
    {
        // Arrange
        var state = ExtendedCheckState.Create("test", "player", "lockpick",
            targetSuccesses: 10, maxRounds: 2);
        var roll = CreateRollResult(netSuccesses: 1, isFumble: false);

        // Act
        state.ProcessRound(roll);
        state.ProcessRound(roll);

        // Assert
        Assert.That(state.Status, Is.EqualTo(ExtendedCheckStatus.Failed));
        Assert.That(state.AccumulatedSuccesses, Is.EqualTo(2)); // Didn't reach 10
    }
}
```

---

## 16. Use Cases

### 16.1 UC-150d-001: Resolve Contested Stealth Check

**Actor:** Player
**Flow:** Player attempts to sneak past guard → System resolves contested check → Winner determined

**Details:**
1. Player initiates stealth action near guard
2. SkillCheckService.ResolveContestedCheck() called with:
   - Initiator: Player (Stealth skill)
   - Defender: Guard (Perception skill)
3. Both parties roll using success-counting mechanics
4. Fumbles checked first, then net successes compared
5. ContestedCheckResult returned with outcome and margin
6. Game applies outcome (player hidden or detected)

### 16.2 UC-150d-002: Contested Check with Fumble

**Actor:** Player
**Flow:** Player attempts deception → Player fumbles → Defender auto-wins

**Details:**
1. Player attempts to lie to NPC
2. Player rolls: 0 successes + 1 botch = FUMBLE
3. System detects initiator fumble
4. Outcome: InitiatorFumble (defender auto-wins)
5. NPC sees through lie, disposition drops
6. Player may suffer additional fumble consequences

### 16.3 UC-150d-003: Extended Lock Picking Check

**Actor:** Player
**Flow:** Player picks complex lock → Multiple rounds → Success

**Details:**
1. Player initiates lock picking on complex lock
2. SkillCheckService.StartExtendedCheck() called:
   - Target: 6 successes
   - Max rounds: 5
3. Each round:
   - Player rolls System Bypass
   - Net successes added to accumulated total
   - Fumbles subtract 2 accumulated (min 0)
4. Check succeeds when accumulated >= 6
5. Or fails if 5 rounds pass without reaching target

### 16.4 UC-150d-004: Extended Check Catastrophic Failure

**Actor:** Player
**Flow:** Player hacks terminal → Three fumbles → Catastrophic failure

**Details:**
1. Player initiates terminal hacking
2. Round 1: Normal result, 1 consecutive fumble after fumble roll
3. Round 2: Fumble, 2 consecutive fumbles
4. Round 3: Fumble, 3 consecutive fumbles
5. System triggers CatastrophicFailure status
6. Terminal locks permanently, alarm triggered
7. Player may suffer additional consequences

---

## 17. Deliverable Checklist

### 17.1 Domain Layer

- [ ] `ContestedOutcome.cs` created in `Domain/Enums/`
- [ ] `ExtendedCheckStatus.cs` created in `Domain/Enums/`
- [ ] `ContestedCheckResult.cs` created in `Domain/ValueObjects/`
- [ ] `ExtendedCheckState.cs` created in `Domain/Entities/`
- [ ] `ExtendedCheckConstants.cs` created in `Domain/Constants/`

### 17.2 Application Layer

- [ ] `SkillCheckService.ResolveContestedCheck()` implemented
- [ ] `SkillCheckService.StartExtendedCheck()` implemented
- [ ] `SkillCheckService.PerformExtendedCheckRound()` implemented
- [ ] `SkillCheckService.AbandonExtendedCheck()` implemented
- [ ] `DetermineContestedOutcome()` static method implemented

### 17.3 Unit Tests

- [ ] `ContestedCheckResultTests.cs` created (~4 tests)
- [ ] `ExtendedCheckStateTests.cs` created (~6 tests)
- [ ] All contested outcome scenarios covered
- [ ] Extended check accumulation verified
- [ ] Fumble handling verified
- [ ] Catastrophic failure verified

### 17.4 Documentation

- [ ] This design specification complete
- [ ] Code XML documentation complete

---

## 18. Acceptance Criteria

### 18.1 Contested Checks

- [ ] Contested checks compare net successes (not totals)
- [ ] Initiator fumble results in InitiatorFumble outcome
- [ ] Defender fumble results in DefenderFumble outcome
- [ ] Both fumble results in BothFumble outcome
- [ ] Equal net successes results in Tie (initiator minor advantage)
- [ ] Margin calculated correctly (winner's net - loser's net)
- [ ] WinnerId property returns correct winner

### 18.2 Extended Checks

- [ ] Extended check accumulates net successes over rounds
- [ ] Success when accumulated >= target within max rounds
- [ ] Failure when rounds exhausted before target reached
- [ ] Fumble subtracts 2 accumulated successes (min 0)
- [ ] Consecutive fumbles tracked (resets on success)
- [ ] 3 consecutive fumbles triggers CatastrophicFailure
- [ ] Abandoned status when player quits
- [ ] Progress calculation correct
- [ ] IsAtRisk flag when 2 consecutive fumbles

### 18.3 Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~8 new unit tests pass
- [ ] All existing tests pass
- [ ] XML documentation complete on all public members

---

## 19. Future Considerations

### 19.1 Deferred to v0.15.0e (Dice Roll Logging)

- `IDiceRollLogger` interface
- `DiceRollLog` record
- Roll history retrieval
- Contested/extended check logging integration

### 19.2 Deferred to v0.15.0f (Combat Integration)

- `CombatService` contested maneuvers (grapple, shove)
- `HitQuality` integration with contested checks

### 19.3 Deferred to v0.15.1+ (Skill Expansions)

- Fumble consequence narratives
- Skill context modifiers
- Equipment bonuses for extended checks
- Master rank abilities affecting checks

### 19.4 Deferred to v0.15.2 (Acrobatics)

- Chase sequence state machine using contested checks
- Multi-stage climbing using extended checks

### 19.5 Deferred to v0.15.4 (System Bypass)

- Terminal hacking multi-layer using extended checks
- ICE countermeasures as fumble consequences

---

## 20. Implementation Notes

### 20.1 Entity Mutability

`ExtendedCheckState` is intentionally mutable (unlike value objects) because it represents state that changes over time. The `ProcessRound()` method modifies internal state.

### 20.2 Validation Strategy

- Factory method `Create()` validates initial parameters
- `ProcessRound()` throws if check is not in progress
- `Abandon()` throws if check is not in progress

### 20.3 Thread Safety

`ExtendedCheckState` is not thread-safe. If concurrent access is needed, synchronization must be handled externally.

### 20.4 Testing Strategy

Use deterministic `DiceRollResult` objects for testing:

```csharp
private static DiceRollResult CreateRollResult(int netSuccesses, bool isFumble)
{
    return new DiceRollResult
    {
        Pool = new DicePool(5, DiceType.D10),
        Rolls = new[] { 8, 5, 4, 3, 2 }, // Placeholder
        NetSuccesses = netSuccesses,
        IsFumble = isFumble,
        IsCriticalSuccess = netSuccesses >= 5
    };
}
```

---

## 21. Document Metadata

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*

---

*This design specification provides the detailed blueprint for implementing v0.15.0d Contested & Extended Checks. These mechanics enable opposed skill checks and multi-round challenges that are fundamental to the skill expansions in v0.15.1+.*
