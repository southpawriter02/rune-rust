# v0.0.6c Design Specification: Status Effect Framework

**Version:** 0.0.6c
**Parent:** v0.0.6 (Enhanced Combat System)
**Prerequisites:** v0.0.6a Complete (Multi-Monster Combat Foundation)
**Status:** Design Complete

---

## Table of Contents

1. [Overview](#overview)
2. [Scope](#scope)
3. [Data Model](#data-model)
4. [Status Effect Definitions](#status-effect-definitions)
5. [Status Effect Service](#status-effect-service)
6. [Effect Processing](#effect-processing)
7. [Stacking Rules](#stacking-rules)
8. [Configuration](#configuration)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Test Specifications](#test-specifications)

---

## Overview

### Purpose

v0.0.6c builds the comprehensive status effect framework that supports buffs, debuffs, and environmental effects. This phase focuses on the core infrastructure and all 28 effect definitions, without combat integration (which comes in v0.0.6d).

### Key Changes

| Area | Current State (v0.0.6b) | Target State (v0.0.6c) |
|------|-------------------------|------------------------|
| Combat modifiers | None | Status effects modify stats |
| Damage over time | None | DoT effects deal damage |
| Healing over time | None | HoT effects restore health |
| Combat conditions | None | Effects prevent/modify actions |
| Effect duration | N/A | Turn-based, permanent, triggered |
| Effect stacking | N/A | Refresh, stack, or block |

### Design Principles

1. **Data-Driven**: All effects defined in JSON configuration
2. **Extensible**: Framework supports future effect types
3. **Deterministic**: Effects process in predictable order
4. **Testable**: Effect logic isolated in services

---

## Scope

### In Scope

- `StatusEffectDefinition` entity with all configuration options
- `ActiveStatusEffect` value object for tracking applied effects
- `StatusEffectService` for applying, removing, and ticking effects
- Duration types: turns, permanent, triggered removal
- Stacking rules: refresh duration, stack intensity, block
- All 14 negative effects (debuffs)
- All 10 positive effects (buffs)
- All 4 environmental effects
- JSON configuration schema for effects
- Stat modifier calculations
- DoT/HoT processing

### Out of Scope (v0.0.6d)

- Combat integration (applying effects on hit)
- Effect interactions (Wet + Lightning)
- Cleanse mechanics
- UI display of effects
- AI behavior modification by effects

---

## Data Model

### New: EffectCategory (Enum)

```csharp
/// <summary>
/// Categorizes status effects by their general nature.
/// </summary>
public enum EffectCategory
{
    /// <summary>Negative effects that harm or hinder.</summary>
    Debuff,

    /// <summary>Positive effects that help or enhance.</summary>
    Buff,

    /// <summary>Effects from environmental conditions.</summary>
    Environmental
}
```

### New: DurationType (Enum)

```csharp
/// <summary>
/// Defines how an effect's duration is tracked.
/// </summary>
public enum DurationType
{
    /// <summary>Effect lasts a fixed number of turns.</summary>
    Turns,

    /// <summary>Effect lasts until explicitly removed.</summary>
    Permanent,

    /// <summary>Effect lasts until a specific trigger occurs.</summary>
    Triggered,

    /// <summary>Effect lasts until its resource pool is depleted.</summary>
    ResourceBased
}
```

### New: StackingRule (Enum)

```csharp
/// <summary>
/// Defines how an effect behaves when applied to a target that already has it.
/// </summary>
public enum StackingRule
{
    /// <summary>Reapplication refreshes duration to maximum.</summary>
    RefreshDuration,

    /// <summary>Reapplication increases intensity/stacks.</summary>
    Stack,

    /// <summary>Reapplication is blocked/resisted.</summary>
    Block
}
```

### New: StatModifierType (Enum)

```csharp
/// <summary>
/// Defines the type of stat modification.
/// </summary>
public enum StatModifierType
{
    /// <summary>Adds a flat value to the stat.</summary>
    Flat,

    /// <summary>Multiplies the stat by a percentage.</summary>
    Percentage,

    /// <summary>Sets the stat to a specific value (overrides other mods).</summary>
    Override
}
```

### New: StatModifier (Value Object)

```csharp
/// <summary>
/// Represents a modification to a stat.
/// </summary>
/// <param name="StatId">The stat being modified (e.g., "attack", "defense", "speed").</param>
/// <param name="ModifierType">How the modification is applied.</param>
/// <param name="Value">The modification value.</param>
public readonly record struct StatModifier(
    string StatId,
    StatModifierType ModifierType,
    float Value)
{
    /// <summary>
    /// Applies this modifier to a base value.
    /// </summary>
    public int Apply(int baseValue)
    {
        return ModifierType switch
        {
            StatModifierType.Flat => baseValue + (int)Value,
            StatModifierType.Percentage => (int)(baseValue * (1 + Value)),
            StatModifierType.Override => (int)Value,
            _ => baseValue
        };
    }

    /// <summary>
    /// Creates a flat modifier.
    /// </summary>
    public static StatModifier Flat(string statId, int value) =>
        new(statId, StatModifierType.Flat, value);

    /// <summary>
    /// Creates a percentage modifier.
    /// </summary>
    public static StatModifier Percentage(string statId, float percentage) =>
        new(statId, StatModifierType.Percentage, percentage);

    /// <summary>
    /// Creates an override modifier.
    /// </summary>
    public static StatModifier Override(string statId, int value) =>
        new(statId, StatModifierType.Override, value);
}
```

### New: StatusEffectDefinition (Entity)

```csharp
/// <summary>
/// Defines a status effect's properties and behavior.
/// </summary>
public class StatusEffectDefinition
{
    // ═══════════════════════════════════════════════════════════════
    // IDENTITY
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Unique identifier for this effect (e.g., "bleeding", "hasted").
    /// </summary>
    public string Id { get; private set; }

    /// <summary>
    /// Display name for this effect.
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// Description of what this effect does.
    /// </summary>
    public string Description { get; private set; }

    /// <summary>
    /// Category of this effect.
    /// </summary>
    public EffectCategory Category { get; private set; }

    /// <summary>
    /// Icon identifier for UI display.
    /// </summary>
    public string? IconId { get; private set; }

    // ═══════════════════════════════════════════════════════════════
    // DURATION
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// How duration is tracked for this effect.
    /// </summary>
    public DurationType DurationType { get; private set; }

    /// <summary>
    /// Base duration in turns (if DurationType is Turns).
    /// </summary>
    public int BaseDuration { get; private set; }

    /// <summary>
    /// Event that removes this effect (if DurationType is Triggered).
    /// </summary>
    public string? RemovalTrigger { get; private set; }

    /// <summary>
    /// Resource pool amount (if DurationType is ResourceBased).
    /// </summary>
    public int? ResourcePool { get; private set; }

    // ═══════════════════════════════════════════════════════════════
    // STACKING
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// How this effect behaves when reapplied.
    /// </summary>
    public StackingRule StackingRule { get; private set; }

    /// <summary>
    /// Maximum stack count (if StackingRule is Stack).
    /// </summary>
    public int MaxStacks { get; private set; } = 1;

    // ═══════════════════════════════════════════════════════════════
    // EFFECTS
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Stat modifications applied by this effect.
    /// </summary>
    public IReadOnlyList<StatModifier> StatModifiers => _statModifiers.AsReadOnly();
    private readonly List<StatModifier> _statModifiers = new();

    /// <summary>
    /// Damage dealt per turn (DoT).
    /// </summary>
    public int? DamagePerTurn { get; private set; }

    /// <summary>
    /// Damage type for DoT (e.g., "physical", "fire", "poison").
    /// </summary>
    public string? DamageType { get; private set; }

    /// <summary>
    /// Healing applied per turn (HoT).
    /// </summary>
    public int? HealingPerTurn { get; private set; }

    // ═══════════════════════════════════════════════════════════════
    // BEHAVIORAL FLAGS
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Whether this effect prevents all actions.
    /// </summary>
    public bool PreventsActions { get; private set; }

    /// <summary>
    /// Whether this effect prevents movement.
    /// </summary>
    public bool PreventsMovement { get; private set; }

    /// <summary>
    /// Whether this effect prevents ability use.
    /// </summary>
    public bool PreventsAbilities { get; private set; }

    /// <summary>
    /// Whether this effect prevents attacking.
    /// </summary>
    public bool PreventsAttacking { get; private set; }

    /// <summary>
    /// Whether this effect is hidden from the target.
    /// </summary>
    public bool IsHidden { get; private set; }

    /// <summary>
    /// Whether this effect is beneficial (for cleanse targeting).
    /// </summary>
    public bool IsBeneficial => Category == EffectCategory.Buff;

    /// <summary>
    /// Whether this effect is harmful (for cleanse targeting).
    /// </summary>
    public bool IsHarmful => Category == EffectCategory.Debuff;

    // ═══════════════════════════════════════════════════════════════
    // INTERACTIONS (metadata for v0.0.6d)
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Effect IDs that this effect grants immunity to.
    /// </summary>
    public IReadOnlyList<string> GrantsImmunityTo => _grantsImmunityTo.AsReadOnly();
    private readonly List<string> _grantsImmunityTo = new();

    /// <summary>
    /// Effect IDs that this effect makes the target vulnerable to.
    /// </summary>
    public IReadOnlyList<string> GrantsVulnerabilityTo => _grantsVulnerabilityTo.AsReadOnly();
    private readonly List<string> _grantsVulnerabilityTo = new();

    /// <summary>
    /// Damage types that this effect grants resistance to.
    /// </summary>
    public IReadOnlyList<string> ResistsDamageTypes => _resistsDamageTypes.AsReadOnly();
    private readonly List<string> _resistsDamageTypes = new();

    /// <summary>
    /// Damage types that this effect grants vulnerability to.
    /// </summary>
    public IReadOnlyList<string> VulnerableToDamageTypes => _vulnerableToDamageTypes.AsReadOnly();
    private readonly List<string> _vulnerableToDamageTypes = new();

    // ═══════════════════════════════════════════════════════════════
    // CONSTRUCTORS & FACTORY METHODS
    // ═══════════════════════════════════════════════════════════════

    // Private constructor for EF Core
    private StatusEffectDefinition() { }

    /// <summary>
    /// Creates a status effect definition from configuration.
    /// </summary>
    public static StatusEffectDefinition Create(
        string id,
        string name,
        string description,
        EffectCategory category,
        DurationType durationType,
        int baseDuration = 0,
        StackingRule stackingRule = StackingRule.RefreshDuration,
        int maxStacks = 1,
        string? iconId = null)
    {
        return new StatusEffectDefinition
        {
            Id = id,
            Name = name,
            Description = description,
            Category = category,
            DurationType = durationType,
            BaseDuration = baseDuration,
            StackingRule = stackingRule,
            MaxStacks = maxStacks,
            IconId = iconId
        };
    }

    /// <summary>
    /// Adds a stat modifier to this effect.
    /// </summary>
    public StatusEffectDefinition WithStatModifier(StatModifier modifier)
    {
        _statModifiers.Add(modifier);
        return this;
    }

    /// <summary>
    /// Sets damage over time for this effect.
    /// </summary>
    public StatusEffectDefinition WithDamageOverTime(int damage, string damageType)
    {
        DamagePerTurn = damage;
        DamageType = damageType;
        return this;
    }

    /// <summary>
    /// Sets healing over time for this effect.
    /// </summary>
    public StatusEffectDefinition WithHealingOverTime(int healing)
    {
        HealingPerTurn = healing;
        return this;
    }

    /// <summary>
    /// Sets action prevention flags.
    /// </summary>
    public StatusEffectDefinition WithActionPrevention(
        bool preventsActions = false,
        bool preventsMovement = false,
        bool preventsAbilities = false,
        bool preventsAttacking = false)
    {
        PreventsActions = preventsActions;
        PreventsMovement = preventsMovement;
        PreventsAbilities = preventsAbilities;
        PreventsAttacking = preventsAttacking;
        return this;
    }

    /// <summary>
    /// Sets triggered removal condition.
    /// </summary>
    public StatusEffectDefinition WithRemovalTrigger(string trigger)
    {
        RemovalTrigger = trigger;
        return this;
    }

    /// <summary>
    /// Sets resource pool for resource-based effects.
    /// </summary>
    public StatusEffectDefinition WithResourcePool(int amount)
    {
        ResourcePool = amount;
        return this;
    }
}
```

### New: ActiveStatusEffect (Value Object)

```csharp
/// <summary>
/// Represents an active status effect on an entity.
/// </summary>
public class ActiveStatusEffect
{
    /// <summary>
    /// Unique identifier for this instance.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// The effect definition.
    /// </summary>
    public StatusEffectDefinition Definition { get; private set; }

    /// <summary>
    /// The entity that applied this effect.
    /// </summary>
    public Guid? SourceId { get; private set; }

    /// <summary>
    /// Name of the source (for display).
    /// </summary>
    public string? SourceName { get; private set; }

    /// <summary>
    /// When this effect was applied.
    /// </summary>
    public DateTime AppliedAt { get; private set; }

    /// <summary>
    /// Remaining duration in turns (null if permanent/triggered).
    /// </summary>
    public int? RemainingDuration { get; private set; }

    /// <summary>
    /// Current stack count.
    /// </summary>
    public int Stacks { get; private set; } = 1;

    /// <summary>
    /// Remaining resource pool (for resource-based effects like Shield).
    /// </summary>
    public int? RemainingResource { get; private set; }

    /// <summary>
    /// Whether this effect has expired.
    /// </summary>
    public bool IsExpired =>
        (Definition.DurationType == DurationType.Turns && RemainingDuration <= 0) ||
        (Definition.DurationType == DurationType.ResourceBased && RemainingResource <= 0);

    /// <summary>
    /// Whether this effect is still active.
    /// </summary>
    public bool IsActive => !IsExpired;

    // Private constructor for EF Core
    private ActiveStatusEffect() { }

    /// <summary>
    /// Creates an active status effect instance.
    /// </summary>
    public static ActiveStatusEffect Create(
        StatusEffectDefinition definition,
        Guid? sourceId = null,
        string? sourceName = null)
    {
        var effect = new ActiveStatusEffect
        {
            Id = Guid.NewGuid(),
            Definition = definition,
            SourceId = sourceId,
            SourceName = sourceName,
            AppliedAt = DateTime.UtcNow,
            Stacks = 1
        };

        // Set initial duration based on type
        effect.RemainingDuration = definition.DurationType == DurationType.Turns
            ? definition.BaseDuration
            : null;

        effect.RemainingResource = definition.DurationType == DurationType.ResourceBased
            ? definition.ResourcePool
            : null;

        return effect;
    }

    /// <summary>
    /// Decrements the duration by one turn.
    /// </summary>
    /// <returns>True if the effect is still active.</returns>
    public bool TickDuration()
    {
        if (RemainingDuration.HasValue && RemainingDuration > 0)
        {
            RemainingDuration--;
        }
        return IsActive;
    }

    /// <summary>
    /// Refreshes the duration to maximum.
    /// </summary>
    public void RefreshDuration()
    {
        if (Definition.DurationType == DurationType.Turns)
        {
            RemainingDuration = Definition.BaseDuration;
        }
    }

    /// <summary>
    /// Adds stacks to this effect.
    /// </summary>
    /// <returns>True if stacks were added, false if at max.</returns>
    public bool AddStacks(int count = 1)
    {
        if (Stacks >= Definition.MaxStacks)
            return false;

        Stacks = Math.Min(Stacks + count, Definition.MaxStacks);
        return true;
    }

    /// <summary>
    /// Consumes resource from this effect.
    /// </summary>
    /// <param name="amount">Amount to consume.</param>
    /// <returns>Amount actually consumed.</returns>
    public int ConsumeResource(int amount)
    {
        if (!RemainingResource.HasValue || RemainingResource <= 0)
            return 0;

        var consumed = Math.Min(amount, RemainingResource.Value);
        RemainingResource -= consumed;
        return consumed;
    }

    /// <summary>
    /// Calculates the effective damage per turn (considering stacks).
    /// </summary>
    public int CalculateDamagePerTurn()
    {
        if (!Definition.DamagePerTurn.HasValue)
            return 0;

        return Definition.DamagePerTurn.Value * Stacks;
    }

    /// <summary>
    /// Calculates the effective healing per turn (considering stacks).
    /// </summary>
    public int CalculateHealingPerTurn()
    {
        if (!Definition.HealingPerTurn.HasValue)
            return 0;

        return Definition.HealingPerTurn.Value * Stacks;
    }

    /// <summary>
    /// Gets all stat modifiers (scaled by stacks if applicable).
    /// </summary>
    public IEnumerable<StatModifier> GetEffectiveStatModifiers()
    {
        foreach (var mod in Definition.StatModifiers)
        {
            // Flat modifiers scale with stacks
            if (mod.ModifierType == StatModifierType.Flat)
            {
                yield return mod with { Value = mod.Value * Stacks };
            }
            // Percentage modifiers don't stack (would be too powerful)
            else
            {
                yield return mod;
            }
        }
    }
}
```

### New: EffectApplicationResult (Value Object)

```csharp
/// <summary>
/// Result of attempting to apply a status effect.
/// </summary>
public readonly record struct EffectApplicationResult(
    bool Applied,
    string EffectId,
    EffectApplicationOutcome Outcome,
    int? NewStacks,
    int? NewDuration,
    string Message)
{
    /// <summary>
    /// Creates a successful application result.
    /// </summary>
    public static EffectApplicationResult Success(
        string effectId,
        int stacks,
        int? duration) =>
        new(true, effectId, EffectApplicationOutcome.Applied,
            stacks, duration, $"{effectId} applied");

    /// <summary>
    /// Creates a duration refresh result.
    /// </summary>
    public static EffectApplicationResult Refreshed(
        string effectId,
        int newDuration) =>
        new(true, effectId, EffectApplicationOutcome.Refreshed,
            null, newDuration, $"{effectId} duration refreshed");

    /// <summary>
    /// Creates a stack increase result.
    /// </summary>
    public static EffectApplicationResult Stacked(
        string effectId,
        int newStacks,
        int? duration) =>
        new(true, effectId, EffectApplicationOutcome.Stacked,
            newStacks, duration, $"{effectId} stacked to {newStacks}");

    /// <summary>
    /// Creates a blocked/resisted result.
    /// </summary>
    public static EffectApplicationResult Blocked(string effectId) =>
        new(false, effectId, EffectApplicationOutcome.Blocked,
            null, null, $"{effectId} resisted");

    /// <summary>
    /// Creates an immune result.
    /// </summary>
    public static EffectApplicationResult Immune(string effectId) =>
        new(false, effectId, EffectApplicationOutcome.Immune,
            null, null, $"Immune to {effectId}");
}

/// <summary>
/// Outcome of applying a status effect.
/// </summary>
public enum EffectApplicationOutcome
{
    /// <summary>Effect was newly applied.</summary>
    Applied,

    /// <summary>Existing effect duration was refreshed.</summary>
    Refreshed,

    /// <summary>Existing effect stacks were increased.</summary>
    Stacked,

    /// <summary>Effect was blocked due to stacking rules.</summary>
    Blocked,

    /// <summary>Target is immune to this effect.</summary>
    Immune
}
```

### New: EffectTickResult (Value Object)

```csharp
/// <summary>
/// Result of ticking a status effect.
/// </summary>
public readonly record struct EffectTickResult(
    string EffectId,
    int DamageDealt,
    int HealingDone,
    bool Expired,
    int? RemainingDuration)
{
    /// <summary>
    /// Creates a tick result with DoT damage.
    /// </summary>
    public static EffectTickResult WithDamage(
        string effectId,
        int damage,
        bool expired,
        int? remaining) =>
        new(effectId, damage, 0, expired, remaining);

    /// <summary>
    /// Creates a tick result with HoT healing.
    /// </summary>
    public static EffectTickResult WithHealing(
        string effectId,
        int healing,
        bool expired,
        int? remaining) =>
        new(effectId, 0, healing, expired, remaining);

    /// <summary>
    /// Creates a tick result for a non-DoT/HoT effect.
    /// </summary>
    public static EffectTickResult Ticked(
        string effectId,
        bool expired,
        int? remaining) =>
        new(effectId, 0, 0, expired, remaining);
}
```

### Modified: IEffectTarget (Interface)

```csharp
/// <summary>
/// Interface for entities that can have status effects applied.
/// </summary>
public interface IEffectTarget
{
    /// <summary>
    /// Unique identifier.
    /// </summary>
    Guid Id { get; }

    /// <summary>
    /// Display name.
    /// </summary>
    string Name { get; }

    /// <summary>
    /// Active status effects on this entity.
    /// </summary>
    IReadOnlyList<ActiveStatusEffect> ActiveEffects { get; }

    /// <summary>
    /// Effect IDs this entity is immune to.
    /// </summary>
    IReadOnlyList<string> EffectImmunities { get; }

    /// <summary>
    /// Adds an active effect.
    /// </summary>
    void AddEffect(ActiveStatusEffect effect);

    /// <summary>
    /// Removes an active effect.
    /// </summary>
    void RemoveEffect(Guid effectId);

    /// <summary>
    /// Takes damage.
    /// </summary>
    void TakeDamage(int damage, string? damageType = null);

    /// <summary>
    /// Heals for an amount.
    /// </summary>
    void Heal(int amount);

    /// <summary>
    /// Checks if this entity has an effect.
    /// </summary>
    bool HasEffect(string effectId);

    /// <summary>
    /// Gets an active effect by ID.
    /// </summary>
    ActiveStatusEffect? GetEffect(string effectId);
}
```

### Modified: Player (Implement IEffectTarget)

```csharp
// Add to existing Player entity:

/// <summary>
/// Active status effects on the player.
/// </summary>
public IReadOnlyList<ActiveStatusEffect> ActiveEffects => _activeEffects.AsReadOnly();
private readonly List<ActiveStatusEffect> _activeEffects = new();

/// <summary>
/// Effect IDs the player is immune to.
/// </summary>
public IReadOnlyList<string> EffectImmunities => _effectImmunities.AsReadOnly();
private readonly List<string> _effectImmunities = new();

/// <summary>
/// Adds an active effect.
/// </summary>
public void AddEffect(ActiveStatusEffect effect)
{
    _activeEffects.Add(effect);
}

/// <summary>
/// Removes an active effect by ID.
/// </summary>
public void RemoveEffect(Guid effectId)
{
    _activeEffects.RemoveAll(e => e.Id == effectId);
}

/// <summary>
/// Checks if the player has a specific effect.
/// </summary>
public bool HasEffect(string effectId) =>
    _activeEffects.Any(e => e.Definition.Id == effectId && e.IsActive);

/// <summary>
/// Gets an active effect by definition ID.
/// </summary>
public ActiveStatusEffect? GetEffect(string effectId) =>
    _activeEffects.FirstOrDefault(e => e.Definition.Id == effectId && e.IsActive);

/// <summary>
/// Adds an effect immunity.
/// </summary>
public void AddImmunity(string effectId)
{
    if (!_effectImmunities.Contains(effectId))
        _effectImmunities.Add(effectId);
}

/// <summary>
/// Removes an effect immunity.
/// </summary>
public void RemoveImmunity(string effectId)
{
    _effectImmunities.Remove(effectId);
}
```

### Modified: Monster (Implement IEffectTarget)

```csharp
// Add to existing Monster entity (same implementation as Player):

public IReadOnlyList<ActiveStatusEffect> ActiveEffects => _activeEffects.AsReadOnly();
private readonly List<ActiveStatusEffect> _activeEffects = new();

public IReadOnlyList<string> EffectImmunities => _effectImmunities.AsReadOnly();
private readonly List<string> _effectImmunities = new();

public void AddEffect(ActiveStatusEffect effect) => _activeEffects.Add(effect);

public void RemoveEffect(Guid effectId) =>
    _activeEffects.RemoveAll(e => e.Id == effectId);

public bool HasEffect(string effectId) =>
    _activeEffects.Any(e => e.Definition.Id == effectId && e.IsActive);

public ActiveStatusEffect? GetEffect(string effectId) =>
    _activeEffects.FirstOrDefault(e => e.Definition.Id == effectId && e.IsActive);

public void AddImmunity(string effectId)
{
    if (!_effectImmunities.Contains(effectId))
        _effectImmunities.Add(effectId);
}

public void RemoveImmunity(string effectId) =>
    _effectImmunities.Remove(effectId);
```

---

## Status Effect Definitions

### Debuffs (14 Total)

| Effect | Duration | DoT | Stat Mods | Special Flags |
|--------|----------|-----|-----------|---------------|
| Bleeding | 3 turns | 3/turn (physical) | - | - |
| Poisoned | 5 turns | 2/turn (poison) | ATK -1 | - |
| Burning | 3 turns | 4/turn (fire) | - | - |
| Frozen | 2 turns | - | Speed -50% | Prevents movement |
| Stunned | 1 turn | - | DEF -2 | Prevents actions |
| Knocked Down | Triggered | - | DEF -3 | Prevents movement, removed on action |
| Weakened | 3 turns | - | ATK -30% | - |
| Blinded | 3 turns | - | Accuracy -50% | Prevents targeting distant |
| Slowed | 3 turns | - | Speed -50%, Initiative -2 | - |
| Feared | 2 turns | - | - | Prevents attacking source |
| Silenced | 2 turns | - | - | Prevents abilities |
| Cursed | 5 turns | - | All -1 | Reduces healing received |
| Exhausted | 4 turns | - | Regen -50% | - |
| Disarmed | 2 turns | - | - | Prevents weapon attacks |

### Buffs (10 Total)

| Effect | Duration | HoT | Stat Mods | Special |
|--------|----------|-----|-----------|---------|
| Fortified | 3 turns | - | DEF +30% | - |
| Hasted | 2 turns | - | Speed +50% | Extra action |
| Regenerating | 5 turns | 5/turn | - | - |
| Strengthened | 3 turns | - | ATK +30% | - |
| Shielded | Resource | - | - | Absorbs damage |
| Invisible | 3 turns | - | Stealth +100% | Cannot be targeted |
| Blessed | 3 turns | - | All rolls +2 | Grants curse immunity |
| Inspired | 3 turns | - | Crit +10% | - |
| Protected | 3 turns | - | - | -50% from damage type |
| Enraged | 3 turns | - | ATK +50%, DEF -30% | - |

### Environmental (4 Total)

| Effect | Duration | Special |
|--------|----------|---------|
| Wet | 3 turns | Lightning/Ice vulnerability, Fire resistance |
| On Fire | Permanent | Spreading damage, removed by water |
| Chilled | 3 turns | Slowed, Freeze vulnerability |
| Electrified | 2 turns | Stun chance on contact |

---

## Status Effect Service

### StatusEffectService

```csharp
/// <summary>
/// Service for managing status effects on entities.
/// </summary>
public class StatusEffectService
{
    private readonly IStatusEffectRepository _effectRepository;
    private readonly ILogger<StatusEffectService> _logger;

    public StatusEffectService(
        IStatusEffectRepository effectRepository,
        ILogger<StatusEffectService> logger)
    {
        _effectRepository = effectRepository;
        _logger = logger;
    }

    /// <summary>
    /// Attempts to apply a status effect to a target.
    /// </summary>
    /// <param name="effectId">The effect definition ID.</param>
    /// <param name="target">The target entity.</param>
    /// <param name="sourceId">The source entity ID (optional).</param>
    /// <param name="sourceName">The source entity name (optional).</param>
    /// <returns>The result of the application attempt.</returns>
    public EffectApplicationResult ApplyEffect(
        string effectId,
        IEffectTarget target,
        Guid? sourceId = null,
        string? sourceName = null)
    {
        var definition = _effectRepository.GetEffectById(effectId);
        if (definition == null)
        {
            _logger.LogWarning("Unknown effect ID: {EffectId}", effectId);
            return EffectApplicationResult.Blocked(effectId);
        }

        // Check immunity
        if (target.EffectImmunities.Contains(effectId))
        {
            _logger.LogDebug("{Target} is immune to {Effect}",
                target.Name, definition.Name);
            return EffectApplicationResult.Immune(effectId);
        }

        // Check for existing effect
        var existing = target.GetEffect(effectId);
        if (existing != null)
        {
            return HandleExistingEffect(existing, definition, target);
        }

        // Apply new effect
        var activeEffect = ActiveStatusEffect.Create(definition, sourceId, sourceName);
        target.AddEffect(activeEffect);

        _logger.LogInformation(
            "Applied {Effect} to {Target} (Duration: {Duration})",
            definition.Name, target.Name, activeEffect.RemainingDuration);

        return EffectApplicationResult.Success(
            effectId,
            activeEffect.Stacks,
            activeEffect.RemainingDuration);
    }

    private EffectApplicationResult HandleExistingEffect(
        ActiveStatusEffect existing,
        StatusEffectDefinition definition,
        IEffectTarget target)
    {
        switch (definition.StackingRule)
        {
            case StackingRule.RefreshDuration:
                existing.RefreshDuration();
                _logger.LogDebug("Refreshed {Effect} duration on {Target}",
                    definition.Name, target.Name);
                return EffectApplicationResult.Refreshed(
                    definition.Id,
                    existing.RemainingDuration ?? 0);

            case StackingRule.Stack:
                if (existing.AddStacks(1))
                {
                    existing.RefreshDuration();
                    _logger.LogDebug("Stacked {Effect} on {Target} ({Stacks})",
                        definition.Name, target.Name, existing.Stacks);
                    return EffectApplicationResult.Stacked(
                        definition.Id,
                        existing.Stacks,
                        existing.RemainingDuration);
                }
                // At max stacks, just refresh
                existing.RefreshDuration();
                return EffectApplicationResult.Refreshed(
                    definition.Id,
                    existing.RemainingDuration ?? 0);

            case StackingRule.Block:
            default:
                _logger.LogDebug("{Effect} blocked on {Target} (already active)",
                    definition.Name, target.Name);
                return EffectApplicationResult.Blocked(definition.Id);
        }
    }

    /// <summary>
    /// Removes a specific effect from a target.
    /// </summary>
    public bool RemoveEffect(IEffectTarget target, string effectId)
    {
        var effect = target.GetEffect(effectId);
        if (effect == null)
            return false;

        target.RemoveEffect(effect.Id);
        _logger.LogDebug("Removed {Effect} from {Target}",
            effect.Definition.Name, target.Name);
        return true;
    }

    /// <summary>
    /// Removes all effects matching a predicate.
    /// </summary>
    public int RemoveEffects(
        IEffectTarget target,
        Func<ActiveStatusEffect, bool> predicate)
    {
        var toRemove = target.ActiveEffects.Where(predicate).ToList();
        foreach (var effect in toRemove)
        {
            target.RemoveEffect(effect.Id);
        }
        return toRemove.Count;
    }

    /// <summary>
    /// Ticks all effects on a target, processing DoT/HoT and durations.
    /// </summary>
    /// <param name="target">The target to tick effects on.</param>
    /// <returns>Results of ticking each effect.</returns>
    public IReadOnlyList<EffectTickResult> TickEffects(IEffectTarget target)
    {
        var results = new List<EffectTickResult>();

        foreach (var effect in target.ActiveEffects.Where(e => e.IsActive).ToList())
        {
            var result = TickEffect(target, effect);
            results.Add(result);

            if (result.Expired)
            {
                target.RemoveEffect(effect.Id);
                _logger.LogDebug("{Effect} expired on {Target}",
                    effect.Definition.Name, target.Name);
            }
        }

        return results;
    }

    private EffectTickResult TickEffect(IEffectTarget target, ActiveStatusEffect effect)
    {
        var definition = effect.Definition;

        // Process DoT
        if (effect.CalculateDamagePerTurn() > 0)
        {
            var damage = effect.CalculateDamagePerTurn();
            target.TakeDamage(damage, definition.DamageType);

            _logger.LogDebug("{Effect} deals {Damage} damage to {Target}",
                definition.Name, damage, target.Name);

            var stillActive = effect.TickDuration();
            return EffectTickResult.WithDamage(
                definition.Id,
                damage,
                !stillActive,
                effect.RemainingDuration);
        }

        // Process HoT
        if (effect.CalculateHealingPerTurn() > 0)
        {
            var healing = effect.CalculateHealingPerTurn();
            target.Heal(healing);

            _logger.LogDebug("{Effect} heals {Target} for {Healing}",
                definition.Name, target.Name, healing);

            var stillActive = effect.TickDuration();
            return EffectTickResult.WithHealing(
                definition.Id,
                healing,
                !stillActive,
                effect.RemainingDuration);
        }

        // Just tick duration
        var active = effect.TickDuration();
        return EffectTickResult.Ticked(
            definition.Id,
            !active,
            effect.RemainingDuration);
    }

    /// <summary>
    /// Gets all stat modifiers from active effects on a target.
    /// </summary>
    public IEnumerable<StatModifier> GetAllStatModifiers(IEffectTarget target)
    {
        return target.ActiveEffects
            .Where(e => e.IsActive)
            .SelectMany(e => e.GetEffectiveStatModifiers());
    }

    /// <summary>
    /// Checks if a target has any effect that prevents actions.
    /// </summary>
    public bool CanTakeActions(IEffectTarget target)
    {
        return !target.ActiveEffects.Any(e =>
            e.IsActive && e.Definition.PreventsActions);
    }

    /// <summary>
    /// Checks if a target has any effect that prevents movement.
    /// </summary>
    public bool CanMove(IEffectTarget target)
    {
        return !target.ActiveEffects.Any(e =>
            e.IsActive && e.Definition.PreventsMovement);
    }

    /// <summary>
    /// Checks if a target has any effect that prevents abilities.
    /// </summary>
    public bool CanUseAbilities(IEffectTarget target)
    {
        return !target.ActiveEffects.Any(e =>
            e.IsActive && e.Definition.PreventsAbilities);
    }

    /// <summary>
    /// Checks if a target has any effect that prevents attacking.
    /// </summary>
    public bool CanAttack(IEffectTarget target)
    {
        return !target.ActiveEffects.Any(e =>
            e.IsActive && e.Definition.PreventsAttacking);
    }
}
```

### IStatusEffectRepository

```csharp
/// <summary>
/// Repository for status effect definitions.
/// </summary>
public interface IStatusEffectRepository
{
    /// <summary>
    /// Gets an effect definition by ID.
    /// </summary>
    StatusEffectDefinition? GetEffectById(string id);

    /// <summary>
    /// Gets all effect definitions.
    /// </summary>
    IReadOnlyList<StatusEffectDefinition> GetAllEffects();

    /// <summary>
    /// Gets effects by category.
    /// </summary>
    IReadOnlyList<StatusEffectDefinition> GetEffectsByCategory(EffectCategory category);
}
```

---

## Effect Processing

### Processing Order

```
START OF TURN
│
├─► 1. Tick all active effects
│   │
│   ├─► For each DoT effect:
│   │   └─► Apply damage
│   │
│   ├─► For each HoT effect:
│   │   └─► Apply healing
│   │
│   └─► For each effect with duration:
│       └─► Decrement duration
│
├─► 2. Remove expired effects
│
├─► 3. Check action prevention
│   │
│   ├─► Stunned? Skip turn
│   ├─► Feared? Force flee attempt
│   └─► Other preventions? Apply
│
└─► 4. Calculate modified stats
    │
    ├─► Gather all stat modifiers
    ├─► Apply flat modifiers first
    ├─► Apply percentage modifiers
    └─► Apply any overrides
```

### Stat Calculation Flow

```csharp
/// <summary>
/// Calculates effective stats considering all active effects.
/// </summary>
public class StatCalculator
{
    private readonly StatusEffectService _effectService;

    public StatCalculator(StatusEffectService effectService)
    {
        _effectService = effectService;
    }

    /// <summary>
    /// Calculates the effective value of a stat.
    /// </summary>
    public int CalculateStat(IEffectTarget target, string statId, int baseValue)
    {
        var modifiers = _effectService.GetAllStatModifiers(target)
            .Where(m => m.StatId == statId)
            .ToList();

        if (modifiers.Count == 0)
            return baseValue;

        // Check for overrides first
        var overrideMod = modifiers.FirstOrDefault(m =>
            m.ModifierType == StatModifierType.Override);
        if (overrideMod != default)
            return (int)overrideMod.Value;

        // Apply flat modifiers
        var flatModifiers = modifiers
            .Where(m => m.ModifierType == StatModifierType.Flat)
            .Sum(m => m.Value);

        // Apply percentage modifiers
        var percentageMultiplier = modifiers
            .Where(m => m.ModifierType == StatModifierType.Percentage)
            .Aggregate(1f, (acc, m) => acc * (1 + m.Value));

        var result = (int)((baseValue + flatModifiers) * percentageMultiplier);

        // Ensure non-negative
        return Math.Max(0, result);
    }
}
```

---

## Stacking Rules

### Stacking Behavior by Effect

Based on confirmed design decisions:

**Debuffs with Duration Refresh:**

| Effect | Stacking Rule | Behavior on Reapply |
|--------|---------------|---------------------|
| Bleeding | RefreshDuration | Duration resets to 3 |
| Poisoned | RefreshDuration | Duration resets to 5 |
| Burning | RefreshDuration | Duration resets to 3 |
| Frozen | RefreshDuration | Duration resets to 2 |
| Weakened | RefreshDuration | Duration resets to 3 |
| Slowed | RefreshDuration | Duration resets to 3 |
| Exhausted | RefreshDuration | Duration resets to 4 |

**All Other Debuffs:** Block (effect is resisted if already active)

**All Buffs:** Block (cannot have multiple instances)

> **Design Rationale:** Buffs always use Block stacking to prevent characters from becoming overpowered by stacking multiple instances of powerful effects like Fortified, Invisible, or Hasted. A character cannot have two instances of the same buff active simultaneously.

**Environmental Effects:**

| Effect | Stacking Rule | Behavior on Reapply |
|--------|---------------|---------------------|
| Wet | RefreshDuration | Duration resets to 3 |
| Chilled | RefreshDuration | Duration resets to 3 |
| On Fire | Block | Already burning |
| Electrified | Block | Already electrified |

### Implementation

```csharp
// In StatusEffectRepository/Configuration:

/// <summary>
/// Debuffs that refresh duration when reapplied.
/// </summary>
private static readonly HashSet<string> RefreshDurationDebuffs = new()
{
    "bleeding", "poisoned", "burning", "frozen",
    "weakened", "slowed", "exhausted"
};

/// <summary>
/// Environmental effects that refresh duration when reapplied.
/// </summary>
private static readonly HashSet<string> RefreshDurationEnvironmental = new()
{
    "wet", "chilled"
};

/// <summary>
/// Gets the stacking rule for an effect.
/// </summary>
/// <remarks>
/// - All buffs use Block (no stacking allowed - prevents OP characters)
/// - Specific debuffs use RefreshDuration
/// - All other debuffs use Block
/// - Specific environmental effects use RefreshDuration
/// </remarks>
public StackingRule GetStackingRuleFor(string effectId, EffectCategory category)
{
    // Buffs NEVER stack - prevents OP characters
    if (category == EffectCategory.Buff)
        return StackingRule.Block;

    var id = effectId.ToLowerInvariant();

    // Check debuff refresh list
    if (RefreshDurationDebuffs.Contains(id))
        return StackingRule.RefreshDuration;

    // Check environmental refresh list
    if (RefreshDurationEnvironmental.Contains(id))
        return StackingRule.RefreshDuration;

    // Default to Block for everything else
    return StackingRule.Block;
}
```

---

## Configuration

### status-effects.json

```json
{
  "$schema": "./status-effects.schema.json",
  "version": "1.0",
  "debuffs": [
    {
      "id": "bleeding",
      "name": "Bleeding",
      "description": "Taking physical damage over time from an open wound.",
      "iconId": "icon_bleeding",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "refreshDuration",
      "damagePerTurn": 3,
      "damageType": "physical"
    },
    {
      "id": "poisoned",
      "name": "Poisoned",
      "description": "Toxins course through your body, weakening you.",
      "iconId": "icon_poison",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 5,
      "stackingRule": "refreshDuration",
      "damagePerTurn": 2,
      "damageType": "poison",
      "statModifiers": [
        { "statId": "attack", "type": "flat", "value": -1 }
      ]
    },
    {
      "id": "burning",
      "name": "Burning",
      "description": "Engulfed in flames, taking fire damage.",
      "iconId": "icon_fire",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "refreshDuration",
      "damagePerTurn": 4,
      "damageType": "fire"
    },
    {
      "id": "frozen",
      "name": "Frozen",
      "description": "Encased in ice, movement severely restricted.",
      "iconId": "icon_ice",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 2,
      "stackingRule": "refreshDuration",
      "statModifiers": [
        { "statId": "speed", "type": "percentage", "value": -0.5 }
      ],
      "preventsMovement": true,
      "vulnerableToDamageTypes": ["ice"]
    },
    {
      "id": "stunned",
      "name": "Stunned",
      "description": "Dazed and unable to act.",
      "iconId": "icon_stun",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 1,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "defense", "type": "flat", "value": -2 }
      ],
      "preventsActions": true
    },
    {
      "id": "knocked_down",
      "name": "Knocked Down",
      "description": "Prone on the ground, must use action to stand.",
      "iconId": "icon_prone",
      "category": "debuff",
      "durationType": "triggered",
      "removalTrigger": "stand_action",
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "defense", "type": "flat", "value": -3 }
      ],
      "preventsMovement": true
    },
    {
      "id": "weakened",
      "name": "Weakened",
      "description": "Strength sapped, attacks deal less damage.",
      "iconId": "icon_weaken",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "refreshDuration",
      "statModifiers": [
        { "statId": "attack", "type": "percentage", "value": -0.3 }
      ]
    },
    {
      "id": "blinded",
      "name": "Blinded",
      "description": "Unable to see, accuracy severely reduced.",
      "iconId": "icon_blind",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "accuracy", "type": "percentage", "value": -0.5 }
      ]
    },
    {
      "id": "slowed",
      "name": "Slowed",
      "description": "Movement and reactions hampered.",
      "iconId": "icon_slow",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "refreshDuration",
      "statModifiers": [
        { "statId": "speed", "type": "percentage", "value": -0.5 },
        { "statId": "initiative", "type": "flat", "value": -2 }
      ]
    },
    {
      "id": "feared",
      "name": "Feared",
      "description": "Overcome with terror, must flee from the source.",
      "iconId": "icon_fear",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 2,
      "stackingRule": "block",
      "preventsAttacking": true
    },
    {
      "id": "silenced",
      "name": "Silenced",
      "description": "Unable to speak or cast spells.",
      "iconId": "icon_silence",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 2,
      "stackingRule": "block",
      "preventsAbilities": true
    },
    {
      "id": "cursed",
      "name": "Cursed",
      "description": "Afflicted by dark magic, all capabilities diminished.",
      "iconId": "icon_curse",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 5,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "attack", "type": "flat", "value": -1 },
        { "statId": "defense", "type": "flat", "value": -1 },
        { "statId": "speed", "type": "flat", "value": -1 }
      ]
    },
    {
      "id": "exhausted",
      "name": "Exhausted",
      "description": "Fatigued, natural recovery slowed.",
      "iconId": "icon_exhaust",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 4,
      "stackingRule": "refreshDuration",
      "statModifiers": [
        { "statId": "regeneration", "type": "percentage", "value": -0.5 }
      ]
    },
    {
      "id": "disarmed",
      "name": "Disarmed",
      "description": "Weapon knocked away, cannot make weapon attacks.",
      "iconId": "icon_disarm",
      "category": "debuff",
      "durationType": "turns",
      "baseDuration": 2,
      "stackingRule": "block",
      "preventsAttacking": true
    }
  ],
  "buffs": [
    {
      "id": "fortified",
      "name": "Fortified",
      "description": "Defenses bolstered, harder to damage.",
      "iconId": "icon_fortify",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "defense", "type": "percentage", "value": 0.3 }
      ]
    },
    {
      "id": "hasted",
      "name": "Hasted",
      "description": "Moving with supernatural speed.",
      "iconId": "icon_haste",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 2,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "speed", "type": "percentage", "value": 0.5 }
      ]
    },
    {
      "id": "regenerating",
      "name": "Regenerating",
      "description": "Wounds closing naturally over time.",
      "iconId": "icon_regen",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 5,
      "stackingRule": "block",
      "healingPerTurn": 5
    },
    {
      "id": "strengthened",
      "name": "Strengthened",
      "description": "Imbued with enhanced strength.",
      "iconId": "icon_strength",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "attack", "type": "percentage", "value": 0.3 }
      ]
    },
    {
      "id": "shielded",
      "name": "Shielded",
      "description": "Protected by a magical barrier.",
      "iconId": "icon_shield",
      "category": "buff",
      "durationType": "resourceBased",
      "resourcePool": 20,
      "stackingRule": "block"
    },
    {
      "id": "invisible",
      "name": "Invisible",
      "description": "Unseen by enemies, cannot be targeted.",
      "iconId": "icon_invis",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "stealth", "type": "percentage", "value": 1.0 }
      ]
    },
    {
      "id": "blessed",
      "name": "Blessed",
      "description": "Touched by divine favor, protected from curses.",
      "iconId": "icon_bless",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "all_rolls", "type": "flat", "value": 2 }
      ],
      "grantsImmunityTo": ["cursed"]
    },
    {
      "id": "inspired",
      "name": "Inspired",
      "description": "Filled with confidence, more likely to land critical hits.",
      "iconId": "icon_inspire",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "critical_chance", "type": "flat", "value": 0.1 }
      ]
    },
    {
      "id": "protected",
      "name": "Protected",
      "description": "Warded against a specific damage type.",
      "iconId": "icon_protect",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "block",
      "resistsDamageTypes": ["configured_type"]
    },
    {
      "id": "enraged",
      "name": "Enraged",
      "description": "Blinded by fury, dealing more damage but easier to hit.",
      "iconId": "icon_rage",
      "category": "buff",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "block",
      "statModifiers": [
        { "statId": "attack", "type": "percentage", "value": 0.5 },
        { "statId": "defense", "type": "percentage", "value": -0.3 }
      ]
    }
  ],
  "environmental": [
    {
      "id": "wet",
      "name": "Wet",
      "description": "Soaked with water, affecting elemental interactions.",
      "iconId": "icon_wet",
      "category": "environmental",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "refreshDuration",
      "vulnerableToDamageTypes": ["lightning", "ice"],
      "resistsDamageTypes": ["fire"]
    },
    {
      "id": "on_fire",
      "name": "On Fire",
      "description": "Actively burning, fire spreading to nearby.",
      "iconId": "icon_onfire",
      "category": "environmental",
      "durationType": "permanent",
      "stackingRule": "block",
      "damagePerTurn": 5,
      "damageType": "fire"
    },
    {
      "id": "chilled",
      "name": "Chilled",
      "description": "Cold is seeping in, slowing movement.",
      "iconId": "icon_chill",
      "category": "environmental",
      "durationType": "turns",
      "baseDuration": 3,
      "stackingRule": "refreshDuration",
      "statModifiers": [
        { "statId": "speed", "type": "percentage", "value": -0.25 }
      ],
      "vulnerableToDamageTypes": ["ice"]
    },
    {
      "id": "electrified",
      "name": "Electrified",
      "description": "Crackling with electricity, may stun on contact.",
      "iconId": "icon_electric",
      "category": "environmental",
      "durationType": "turns",
      "baseDuration": 2,
      "stackingRule": "block"
    }
  ]
}
```

### status-effects.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Status Effects Configuration",
  "type": "object",
  "required": ["version", "debuffs", "buffs", "environmental"],
  "properties": {
    "version": {
      "type": "string"
    },
    "debuffs": {
      "type": "array",
      "items": { "$ref": "#/definitions/statusEffect" }
    },
    "buffs": {
      "type": "array",
      "items": { "$ref": "#/definitions/statusEffect" }
    },
    "environmental": {
      "type": "array",
      "items": { "$ref": "#/definitions/statusEffect" }
    }
  },
  "definitions": {
    "statusEffect": {
      "type": "object",
      "required": ["id", "name", "description", "category", "durationType"],
      "properties": {
        "id": { "type": "string" },
        "name": { "type": "string" },
        "description": { "type": "string" },
        "iconId": { "type": "string" },
        "category": {
          "enum": ["debuff", "buff", "environmental"]
        },
        "durationType": {
          "enum": ["turns", "permanent", "triggered", "resourceBased"]
        },
        "baseDuration": { "type": "integer", "minimum": 0 },
        "removalTrigger": { "type": "string" },
        "resourcePool": { "type": "integer", "minimum": 1 },
        "stackingRule": {
          "enum": ["refreshDuration", "stack", "block"]
        },
        "maxStacks": { "type": "integer", "minimum": 1 },
        "damagePerTurn": { "type": "integer", "minimum": 0 },
        "damageType": { "type": "string" },
        "healingPerTurn": { "type": "integer", "minimum": 0 },
        "statModifiers": {
          "type": "array",
          "items": { "$ref": "#/definitions/statModifier" }
        },
        "preventsActions": { "type": "boolean" },
        "preventsMovement": { "type": "boolean" },
        "preventsAbilities": { "type": "boolean" },
        "preventsAttacking": { "type": "boolean" },
        "isHidden": { "type": "boolean" },
        "grantsImmunityTo": {
          "type": "array",
          "items": { "type": "string" }
        },
        "vulnerableToDamageTypes": {
          "type": "array",
          "items": { "type": "string" }
        },
        "resistsDamageTypes": {
          "type": "array",
          "items": { "type": "string" }
        }
      }
    },
    "statModifier": {
      "type": "object",
      "required": ["statId", "type", "value"],
      "properties": {
        "statId": { "type": "string" },
        "type": {
          "enum": ["flat", "percentage", "override"]
        },
        "value": { "type": "number" }
      }
    }
  }
}
```

---

## Acceptance Criteria

### Data Model
- [ ] StatusEffectDefinition entity supports all required properties
- [ ] ActiveStatusEffect tracks duration, stacks, source correctly
- [ ] EffectCategory enum includes Debuff, Buff, Environmental
- [ ] DurationType enum includes Turns, Permanent, Triggered, ResourceBased
- [ ] StackingRule enum includes RefreshDuration, Stack, Block
- [ ] StatModifier supports Flat, Percentage, Override types

### Effect Application
- [ ] StatusEffectService can apply new effects
- [ ] Existing effects with RefreshDuration rule refresh correctly
- [ ] Existing effects with Block rule are resisted
- [ ] Immune targets resist effect application
- [ ] Effect application returns detailed result

### Effect Processing
- [ ] TickEffects processes all active effects
- [ ] DoT effects deal damage per turn
- [ ] HoT effects heal per turn
- [ ] Duration decrements each tick
- [ ] Expired effects are removed automatically

### Stat Modification
- [ ] Flat modifiers add/subtract correctly
- [ ] Percentage modifiers multiply correctly
- [ ] Multiple modifiers combine properly
- [ ] Override modifiers take precedence

### Action Prevention
- [ ] CanTakeActions checks for PreventsActions flag
- [ ] CanMove checks for PreventsMovement flag
- [ ] CanUseAbilities checks for PreventsAbilities flag
- [ ] CanAttack checks for PreventsAttacking flag

### Configuration
- [ ] All 14 debuffs defined in JSON
- [ ] All 10 buffs defined in JSON
- [ ] All 4 environmental effects defined
- [ ] JSON schema validates configuration
- [ ] Effects load correctly from configuration

---

## Test Specifications

### Unit Tests (~25 tests)

#### StatusEffectDefinitionTests.cs

```csharp
[TestFixture]
public class StatusEffectDefinitionTests
{
    [Test]
    public void Create_InitializesAllProperties();

    [Test]
    public void WithStatModifier_AddsModifier();

    [Test]
    public void WithDamageOverTime_SetsDoTProperties();

    [Test]
    public void WithHealingOverTime_SetsHoTProperties();

    [Test]
    public void WithActionPrevention_SetsFlags();

    [Test]
    public void IsBeneficial_ReturnsTrueForBuffs();

    [Test]
    public void IsHarmful_ReturnsTrueForDebuffs();
}
```

#### ActiveStatusEffectTests.cs

```csharp
[TestFixture]
public class ActiveStatusEffectTests
{
    [Test]
    public void Create_InitializesFromDefinition();

    [Test]
    public void TickDuration_DecrementsDuration();

    [Test]
    public void TickDuration_ReturnsfalseWhenExpired();

    [Test]
    public void RefreshDuration_ResetsToBaseDuration();

    [Test]
    public void AddStacks_IncreasesStackCount();

    [Test]
    public void AddStacks_RespectsMaxStacks();

    [Test]
    public void ConsumeResource_ReducesPool();

    [Test]
    public void CalculateDamagePerTurn_ScalesWithStacks();

    [Test]
    public void IsExpired_TrueWhenDurationZero();

    [Test]
    public void IsExpired_TrueWhenResourceDepleted();
}
```

#### StatusEffectServiceTests.cs

```csharp
[TestFixture]
public class StatusEffectServiceTests
{
    [Test]
    public void ApplyEffect_NewEffect_AddsToTarget();

    [Test]
    public void ApplyEffect_RefreshDuration_RefreshesExisting();

    [Test]
    public void ApplyEffect_Block_RejectsIfActive();

    [Test]
    public void ApplyEffect_Immune_ReturnsImmune();

    [Test]
    public void RemoveEffect_RemovesFromTarget();

    [Test]
    public void TickEffects_ProcessesDoT();

    [Test]
    public void TickEffects_ProcessesHoT();

    [Test]
    public void TickEffects_RemovesExpired();

    [Test]
    public void GetAllStatModifiers_AggregatesAllEffects();

    [Test]
    public void CanTakeActions_ReturnsFalseIfStunned();

    [Test]
    public void CanMove_ReturnsFalseIfFrozen();

    [Test]
    public void CanUseAbilities_ReturnsFalseIfSilenced();
}
```

#### StatModifierTests.cs

```csharp
[TestFixture]
public class StatModifierTests
{
    [Test]
    public void Apply_FlatModifier_AddsValue();

    [Test]
    public void Apply_PercentageModifier_MultipliesValue();

    [Test]
    public void Apply_OverrideModifier_ReplacesValue();
}
```

#### StatCalculatorTests.cs

```csharp
[TestFixture]
public class StatCalculatorTests
{
    [Test]
    public void CalculateStat_NoModifiers_ReturnsBase();

    [Test]
    public void CalculateStat_WithFlatModifier_AddsCorrectly();

    [Test]
    public void CalculateStat_WithPercentage_MultipliesCorrectly();

    [Test]
    public void CalculateStat_CombinesModifiers_AppliesInOrder();

    [Test]
    public void CalculateStat_NeverReturnsNegative();
}
```

---

## Dependencies

### Required from v0.0.6a
- `CombatEncounter` - For effect context
- `Combatant` - For effect application targets
- Combat turn processing - For effect tick timing

### Provides to v0.0.6d
- `StatusEffectDefinition` - Effect metadata
- `ActiveStatusEffect` - Effect instances
- `StatusEffectService` - Effect management
- Stat calculation infrastructure
- Action prevention checks

---

*This design specification provides the complete status effect framework. Combat integration, effect interactions, cleanse mechanics, and UI display are handled in v0.0.6d.*
