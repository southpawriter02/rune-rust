# Design Specification: v0.20.0a - Legacy Class Removal & Migration Infrastructure

**Version:** v0.20.0a
**Status:** Design Phase
**Last Updated:** 2026-01-28
**Target Tests:** ~10 unit tests
**Scope:** Legacy class system removal and migration infrastructure establishment

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [Domain Layer Specifications](#5-domain-layer-specifications)
6. [Application Layer Specifications](#6-application-layer-specifications)
7. [Infrastructure Layer](#7-infrastructure-layer)
8. [Decision Trees and Flow Diagrams](#8-decision-trees-and-flow-diagrams)
9. [Code Examples with XML Documentation](#9-code-examples-with-xml-documentation)
10. [Logging Specifications](#10-logging-specifications)
11. [Unit Testing Requirements](#11-unit-testing-requirements)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Dependencies](#14-dependencies)
15. [Deferrals and Future Considerations](#15-deferrals-and-future-considerations)
16. [Configuration Files](#16-configuration-files)
17. [Error Handling](#17-error-handling)
18. [Performance Considerations](#18-performance-considerations)
19. [Security Considerations](#19-security-considerations)
20. [Migration Guide](#20-migration-guide)

---

## 1. Executive Summary

Version 0.20.0a is a foundational cleanup release that removes all placeholder/generic class definitions from the codebase and establishes the migration infrastructure for existing characters. This release is critical for preparing the system for Aethelgard-specific specialization implementations (v0.20.1-v0.20.8).

### Key Objectives

- **Legacy Class Removal:** Eliminate all generic class definitions (Rogue, Fighter, Mage, Healer, Scholar, Crafter)
- **Character Migration:** Establish infrastructure to migrate existing characters from legacy classes to Aethelgard archetypes
- **Ability Compatibility:** Preserve compatible abilities and refund PP for incompatible ones
- **Specialization Foundation:** Prepare ability slot structure for v0.20.1+ specialization implementations
- **Audit Trail:** Maintain comprehensive migration logs for transparency and debugging

### Key Deliverables

| Category | Count | Details |
|----------|-------|---------|
| **Enumerations** | 2 | LegacyClassId (6 values), MigrationStatus (4 values) |
| **Value Objects** | 4 | LegacyClassMapping, MigrationResult, AbilitySlotPreparation, SpecializationPrerequisite |
| **Entities** | 2 | CharacterMigration, MigrationLog |
| **Service Interfaces** | 4 | ILegacyClassDetectionService, ICharacterMigrationService, ISpecializationPrerequisiteService, IAbilitySlotService |
| **Service Implementations** | 4 | Corresponding implementations for all interfaces |
| **Configuration Files** | 2 | legacy_class_mappings.json, legacy_class_mappings.schema.json |
| **Unit Tests** | ~10 | Comprehensive coverage of all services |

---

## 2. Feature Overview

### 2.1 Legacy Class System

**Current State (Pre-v0.20.0a):** Generic placeholder classes exist for all characters, regardless of game setting.

**Post-v0.20.0a State:** All legacy classes are removed, characters possess Aethelgard archetypes and specializations.

### 2.2 Migration Mapping

| Legacy Class | Target Archetype | Primary Specializations | Migration Cost |
|--------------|------------------|----------------------|-----------------|
| **Rogue** | Skirmisher | Myrk-gengr, Veiðimaðr | Free (0 PP) |
| **Fighter** | Warrior | Skjaldmær, Berserkr | Free (0 PP) |
| **Mage** | Mystic | Seiðkona | Free (0 PP) |
| **Healer** | Adept | Bone-Setter | Free (0 PP) |
| **Scholar** | Adept | Jötun-Reader | Free (0 PP) |
| **Crafter** | Adept | Rúnasmiðr, Scrap-Tinker | Free (0 PP) |

### 2.3 Ability Slot Structure

Once a specialization is selected, ability slots are initialized as follows:

```
Tier 1 (Unlocked Immediately):
  - 3 slots @ 0 PP each
  - Total: 3 slots

Tier 2 (Unlocked at 8 PP invested):
  - 3 slots @ 4 PP each
  - Total: 12 PP investment

Tier 3 (Unlocked at 16 PP invested):
  - 2 slots @ 5 PP each
  - Total: 10 PP investment

Capstone (Unlocked at 24 PP invested):
  - 1 slot @ 6 PP
  - Total: 6 PP investment

Grand Total: 9 ability slots, 35 PP max to complete
```

### 2.4 Migration Workflow

1. **Detection:** System identifies characters with legacy classes
2. **Initiation:** Migration record created, archetype assigned
3. **Ability Evaluation:** Existing abilities assessed for compatibility
4. **Specialization Selection:** Player chooses from recommended specializations (free first spec)
5. **Slot Preparation:** Ability slot structure initialized for chosen specialization
6. **Completion:** Legacy class removed, new archetype/specialization applied

---

## 3. Architecture Diagrams

### 3.1 Domain Layer Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│           v0.20.0a Migration Infrastructure (Domain)             │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Enumeration Layer                             │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │  ┌─────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ LegacyClassId   │  │    MigrationStatus           │   │  │
│  │  │ (6 values)      │  │    (4 values)                │   │  │
│  │  │ - Rogue         │  │    - Pending                 │   │  │
│  │  │ - Fighter       │  │    - InProgress              │   │  │
│  │  │ - Mage          │  │    - Completed               │   │  │
│  │  │ - Healer        │  │    - Failed                  │   │  │
│  │  │ - Scholar       │  │                              │   │  │
│  │  │ - Crafter       │  │                              │   │  │
│  │  └─────────────────┘  └──────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              │                                    │
│                              ▼                                    │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Value Objects Layer                           │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ LegacyClass      │  │    MigrationResult           │   │  │
│  │  │ Mapping          │  │    - CharacterId             │   │  │
│  │  │ - LegacyClass    │  │    - OriginalClass           │   │  │
│  │  │ - TargetArchetype│  │    - AssignedArchetype       │   │  │
│  │  │ - SuggestedSpecs │  │    - SelectedSpecialization  │   │  │
│  │  │ - Description    │  │    - PpRefunded              │   │  │
│  │  └──────────────────┘  └──────────────────────────────┘   │  │
│  │                                                              │  │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ AbilitySlot      │  │    SpecializationPrerequisite│   │  │
│  │  │ Preparation      │  │    - SpecializationId        │   │  │
│  │  │ - CharacterId    │  │    - RequiredArchetype       │   │  │
│  │  │ - Tier1/2/3 Slots│  │    - MinimumArchetypePP      │   │  │
│  │  │ - CapstoneSlots  │  │    - UnlockCost              │   │  │
│  │  │ - TotalSlots     │  │    - AvailableAsFreeSelection│   │  │
│  │  └──────────────────┘  └──────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              │                                    │
│                              ▼                                    │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Entities Layer                                │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ CharacterMigration   │    MigrationLog              │   │  │
│  │  │ - Id             │  │    - Id                      │   │  │
│  │  │ - CharacterId    │  │    - MigrationId             │   │  │
│  │  │ - OriginalClass  │  │    - ActionType              │   │  │
│  │  │ - TargetArchetype│  │    - Description             │   │  │
│  │  │ - Status         │  │    - PpDelta                 │   │  │
│  │  │ - SelectedSpec   │  │    - Timestamp               │   │  │
│  │  │ - Methods        │  │                              │   │  │
│  │  │ - BeginMigration │  │                              │   │  │
│  │  │ - SelectSpecial. │  │                              │   │  │
│  │  │ - RecordRefund   │  │                              │   │  │
│  │  │ - Complete       │  │                              │   │  │
│  │  │ - Fail           │  │                              │   │  │
│  │  └──────────────────┘  └──────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Application Layer Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│         v0.20.0a Migration Infrastructure (Application)          │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Service Interfaces                            │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ ILegacyClass     │  │ ICharacterMigration Service  │   │  │
│  │  │ DetectionService │  │                              │   │  │
│  │  │ - GetCharacters  │  │ - InitiateMigration          │   │  │
│  │  │   WithLegacy     │  │ - GetAvailableSpecializations│   │  │
│  │  │ - HasLegacyClass │  │ - SelectSpecialization       │   │  │
│  │  │ - GetLegacyClass │  │ - CompleteMigration          │   │  │
│  │  │ - GetPendingCount│  │ - GetMigrationStatus         │   │  │
│  │  └──────────────────┘  └──────────────────────────────┘   │  │
│  │                                                              │  │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ ISpecialization  │  │ IAbilitySlotService          │   │  │
│  │  │ PrerequisiteServ.│  │                              │   │  │
│  │  │ - GetPrerequisite│  │ - InitializeAbilitySlots     │   │  │
│  │  │ - CanSelectSpec. │  │ - GetAbilitySlots            │   │  │
│  │  │ - GetAvailable   │  │ - IsTierUnlocked             │   │  │
│  │  │ - ValidateArch.  │  │ - GetNextTierUnlockCost      │   │  │
│  │  │ - GetUnlockCost  │  │                              │   │  │
│  │  └──────────────────┘  └──────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              │                                    │
│                              ▼                                    │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Service Implementations                       │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ LegacyClassDetect│  │ CharacterMigrationService    │   │  │
│  │  │ ionService       │  │ Implementation               │   │  │
│  │  └──────────────────┘  └──────────────────────────────┘   │  │
│  │                                                              │  │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ SpecializationPr │  │ AbilitySlotService           │   │  │
│  │  │ erequisiteService│  │ Implementation               │   │  │
│  │  │ Implementation   │  │                              │   │  │
│  │  └──────────────────┘  └──────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              │                                    │
│                              ▼                                    │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Infrastructure Layer                          │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐   │  │
│  │  │ legacy_class_    │  │ legacy_class_                │   │  │
│  │  │ mappings.json    │  │ mappings.schema.json         │   │  │
│  │  │ - 6 mappings     │  │ - JSON Schema validation     │   │  │
│  │  │ - Archetype data │  │ - Version support            │   │  │
│  │  └──────────────────┘  └──────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. User Stories

### User Story 1: Character with Legacy Class Discovers Migration

**As a** player whose character has a legacy class (e.g., "Fighter")
**I want to** understand what migration means and how it will affect my character
**So that** I can make an informed decision about specialization selection

**Acceptance Criteria:**
- Migration notification clearly explains the legacy class is being replaced
- Player receives suggested specializations (e.g., Skjaldmær, Berserkr for Fighter)
- Migration description explains the narrative connection between legacy and new class
- Player is offered a choice between suggested specializations
- First specialization selection is marked as free (0 PP cost)

### User Story 2: Ability Compatibility During Migration

**As a** character with existing abilities
**I want to** know which abilities are compatible with my new archetype
**So that** I don't lose critical gameplay capabilities

**Acceptance Criteria:**
- Character can see list of compatible abilities being preserved
- Character can see list of incompatible abilities being removed
- Full PP refund is shown for removed abilities
- Preserved abilities maintain their functionality in the new system
- Migration logs show complete audit trail of all ability changes

### User Story 3: Specialization Selection and Ability Slots

**As a** player completing character migration
**I want to** select my specialization and see how ability slots will function
**So that** I can plan ability progression for v0.20.1 onwards

**Acceptance Criteria:**
- Specialization selection shows available options matching archetype
- First specialization is marked as free (granted during migration)
- Ability slot structure is displayed (Tier 1: 3 free slots, Tier 2: 3 @ 4PP each, etc.)
- Player understands PP investment required to unlock higher tiers
- Character sheet displays prepared ability slots post-migration

### User Story 4: Migration Status Tracking

**As a** game administrator
**I want to** track migration progress for all legacy class characters
**So that** I can ensure no characters are left with inconsistent states

**Acceptance Criteria:**
- System identifies all characters with legacy classes
- Migration status shows count of Pending, InProgress, Completed, and Failed migrations
- Detailed logs show all actions taken during each migration
- Failed migrations can be retried without data loss
- Audit trail is immutable and accessible for investigation

---

## 5. Domain Layer Specifications

### 5.1 LegacyClassId Enumeration

```csharp
/// <summary>
/// Identifies deprecated generic character classes that must be migrated
/// to Aethelgard-specific archetypes and specializations.
/// </summary>
/// <remarks>
/// These classes exist only for migration purposes. No new characters
/// should be created with these classes after v0.20.0. All existing
/// characters with these classes must be migrated during v0.20.0 init.
/// </remarks>
public enum LegacyClassId
{
    /// <summary>
    /// Generic stealth and thievery focused class.
    /// Migrates to Skirmisher archetype with Myrk-gengr or Veiðimaðr specializations.
    /// </summary>
    Rogue = 0,

    /// <summary>
    /// Generic melee combat and tanking focused class.
    /// Migrates to Warrior archetype with Skjaldmær or Berserkr specializations.
    /// </summary>
    Fighter = 1,

    /// <summary>
    /// Generic spellcasting and magic focused class.
    /// Migrates to Mystic archetype with Seiðkona specialization.
    /// </summary>
    Mage = 2,

    /// <summary>
    /// Generic healing and support focused class.
    /// Migrates to Adept archetype with Bone-Setter specialization.
    /// </summary>
    Healer = 3,

    /// <summary>
    /// Generic knowledge and lore focused class.
    /// Migrates to Adept archetype with Jötun-Reader specialization.
    /// </summary>
    Scholar = 4,

    /// <summary>
    /// Generic crafting and item creation focused class.
    /// Migrates to Adept archetype with Rúnasmiðr or Scrap-Tinker specializations.
    /// </summary>
    Crafter = 5
}
```

### 5.2 MigrationStatus Enumeration

```csharp
/// <summary>
/// Tracks the state of a character's migration from legacy class to archetype.
/// Represents the complete lifecycle of the migration process.
/// </summary>
public enum MigrationStatus
{
    /// <summary>
    /// Character has been identified as having a legacy class but migration
    /// has not yet been initiated. Migration record exists but no changes
    /// have been applied to the character.
    /// </summary>
    Pending = 0,

    /// <summary>
    /// Migration is in progress. The archetype has been assigned but the
    /// character is awaiting specialization selection. Player interaction
    /// is required to advance to Completed state.
    /// </summary>
    InProgress = 1,

    /// <summary>
    /// Migration has completed successfully. The legacy class has been removed,
    /// the archetype has been assigned, and specialization has been selected.
    /// All ability compatibility has been resolved and PP refunds applied.
    /// </summary>
    Completed = 2,

    /// <summary>
    /// Migration failed due to validation error, missing data, or system error.
    /// The character remains in the state prior to failure. ErrorMessage
    /// contains details about what went wrong.
    /// </summary>
    Failed = 3
}
```

### 5.3 LegacyClassMapping Value Object

```csharp
/// <summary>
/// Defines the migration path from a legacy class to an Aethelgard archetype,
/// including suggested specializations and player-facing descriptions.
/// This is an immutable value object loaded from configuration.
/// </summary>
public sealed record LegacyClassMapping
{
    /// <summary>
    /// The legacy class being migrated from.
    /// This should be one of the six legacy class IDs.
    /// </summary>
    public required LegacyClassId LegacyClass { get; init; }

    /// <summary>
    /// The target Aethelgard archetype for this migration path.
    /// All characters with the legacy class will be migrated to this archetype.
    /// </summary>
    public required Archetype TargetArchetype { get; init; }

    /// <summary>
    /// List of suggested specializations for this migration path.
    /// These are recommended based on the legacy class characteristics.
    /// The player may select any specialization compatible with the archetype.
    /// </summary>
    public required IReadOnlyList<SpecializationId> SuggestedSpecializations { get; init; }

    /// <summary>
    /// Player-facing description explaining the migration and recommendations.
    /// This text is displayed to the player during the specialization selection UI.
    /// Should be between 100-200 characters for optimal display.
    /// </summary>
    public required string MigrationDescription { get; init; }

    /// <summary>
    /// Whether this migration grants a free first specialization selection.
    /// Should always be true for v0.20.0 to compensate for forced migration.
    /// Future migrations may have different policies if new legacy states are introduced.
    /// </summary>
    public bool GrantsFreeSpecialization { get; init; } = true;
}
```

### 5.4 MigrationResult Value Object

```csharp
/// <summary>
/// Represents the outcome of a completed character migration.
/// Contains all information about what changed during the migration process.
/// </summary>
public sealed record MigrationResult
{
    /// <summary>
    /// The ID of the character that was migrated.
    /// </summary>
    public required Guid CharacterId { get; init; }

    /// <summary>
    /// The legacy class that was removed from the character.
    /// </summary>
    public required LegacyClassId OriginalClass { get; init; }

    /// <summary>
    /// The archetype that was assigned during migration.
    /// </summary>
    public required Archetype AssignedArchetype { get; init; }

    /// <summary>
    /// The specialization the player selected during migration.
    /// This will never be null in a successful migration result.
    /// </summary>
    public SpecializationId? SelectedSpecialization { get; init; }

    /// <summary>
    /// Total Protection Points (PP) refunded for incompatible abilities.
    /// This represents the sum of all PP costs for abilities that were removed.
    /// The player receives this refund to reinvest in new specialization abilities.
    /// </summary>
    public required int PpRefunded { get; init; }

    /// <summary>
    /// List of ability names that were preserved during migration.
    /// These abilities remain on the character and are compatible with the new archetype.
    /// </summary>
    public required IReadOnlyList<string> PreservedAbilities { get; init; }

    /// <summary>
    /// List of ability names that were removed during migration.
    /// These abilities were incompatible with the target archetype.
    /// </summary>
    public required IReadOnlyList<string> RemovedAbilities { get; init; }

    /// <summary>
    /// Final status of the migration. Should be Completed for this result type.
    /// If status is Failed, ErrorMessage will contain the failure reason.
    /// </summary>
    public required MigrationStatus Status { get; init; }

    /// <summary>
    /// Error message if migration failed.
    /// Null if Status is Completed.
    /// Contains diagnostic information for troubleshooting failed migrations.
    /// </summary>
    public string? ErrorMessage { get; init; }

    /// <summary>
    /// When the migration was completed (UTC timestamp).
    /// Used for audit trails and tracking migration batch processing.
    /// </summary>
    public required DateTime CompletedAt { get; init; }
}
```

### 5.5 AbilitySlotPreparation Value Object

```csharp
/// <summary>
/// Configuration for a specialization's ability slot structure.
/// Prepares the character for ability unlocking and progression in v0.20.1+.
/// Immutable value object created during specialization selection.
/// </summary>
public sealed record AbilitySlotPreparation
{
    /// <summary>
    /// Character ID that is receiving ability slots for a specialization.
    /// </summary>
    public required Guid CharacterId { get; init; }

    /// <summary>
    /// Specialization ID that is receiving the ability slots.
    /// </summary>
    public required SpecializationId SpecializationId { get; init; }

    /// <summary>
    /// Number of Tier 1 ability slots (unlocked immediately, cost 0 PP each).
    /// Standard value: 3 slots = 0 PP total.
    /// </summary>
    public required int Tier1Slots { get; init; }

    /// <summary>
    /// Number of Tier 2 ability slots (locked until 8 PP invested in tree, cost 4 PP each).
    /// Standard value: 3 slots = 12 PP total.
    /// Requires character to have invested 8 PP in the archetype ability tree.
    /// </summary>
    public required int Tier2Slots { get; init; }

    /// <summary>
    /// Number of Tier 3 ability slots (locked until 16 PP invested in tree, cost 5 PP each).
    /// Standard value: 2 slots = 10 PP total.
    /// Requires character to have invested 16 PP in the archetype ability tree.
    /// </summary>
    public required int Tier3Slots { get; init; }

    /// <summary>
    /// Number of Capstone ability slots (locked until 24 PP invested in tree, cost 6 PP).
    /// Standard value: 1 slot = 6 PP total.
    /// Requires character to have invested 24 PP in the archetype ability tree.
    /// </summary>
    public required int CapstoneSlots { get; init; }

    /// <summary>
    /// Calculated total number of ability slots for this specialization.
    /// Typically 9 slots (3+3+2+1) with maximum PP investment of 35.
    /// </summary>
    public int TotalSlots => Tier1Slots + Tier2Slots + Tier3Slots + CapstoneSlots;
}
```

### 5.6 SpecializationPrerequisite Value Object

```csharp
/// <summary>
/// Validation rules and requirements for selecting a specialization.
/// Defines the archetype relationship, PP costs, and unlock conditions.
/// </summary>
public sealed record SpecializationPrerequisite
{
    /// <summary>
    /// The specialization that these prerequisites apply to.
    /// </summary>
    public required SpecializationId SpecializationId { get; init; }

    /// <summary>
    /// The archetype that must be assigned to select this specialization.
    /// A character cannot select a specialization from a different archetype.
    /// </summary>
    public required Archetype RequiredArchetype { get; init; }

    /// <summary>
    /// Minimum Protection Points that must be invested in the archetype ability tree
    /// before this specialization can be selected. Zero for the first specialization.
    /// </summary>
    public required int MinimumArchetypePP { get; init; }

    /// <summary>
    /// PP cost to unlock this specialization. Zero for the first specialization selection,
    /// 3 PP for additional specializations within the same archetype.
    /// </summary>
    public required int UnlockCost { get; init; }

    /// <summary>
    /// Whether this specialization is available as a free first specialization selection.
    /// During v0.20.0 migration, the first specialization is always free (0 PP).
    /// </summary>
    public required bool AvailableAsFreeSelection { get; init; }

    /// <summary>
    /// Other specializations that must be unlocked before this one can be selected.
    /// Used for specialization trees with dependencies. Null if no prerequisites.
    /// </summary>
    public IReadOnlyList<SpecializationId>? RequiredSpecializations { get; init; }
}
```

### 5.7 CharacterMigration Entity

```csharp
/// <summary>
/// Tracks migration state for a specific character transitioning from
/// legacy class to Aethelgard archetype and specialization system.
/// Entity with state transitions following domain-driven design principles.
/// </summary>
public sealed class CharacterMigration
{
    /// <summary>
    /// Unique identifier for this migration record.
    /// Generated when migration is initiated, used for audit trail correlation.
    /// </summary>
    public required Guid Id { get; init; }

    /// <summary>
    /// The character being migrated.
    /// This reference is immutable after record creation.
    /// </summary>
    public required Guid CharacterId { get; init; }

    /// <summary>
    /// The original legacy class that is being replaced.
    /// Captured at migration initiation for audit purposes.
    /// </summary>
    public required LegacyClassId OriginalClass { get; init; }

    /// <summary>
    /// The target archetype for migration.
    /// Assigned during migration initiation, immutable thereafter.
    /// </summary>
    public required Archetype TargetArchetype { get; init; }

    /// <summary>
    /// Current status of the migration.
    /// Transitions: Pending → InProgress → Completed (or Failed).
    /// </summary>
    public MigrationStatus Status { get; private set; } = MigrationStatus.Pending;

    /// <summary>
    /// The specialization selected by the player.
    /// Null until player makes selection during InProgress state.
    /// </summary>
    public SpecializationId? SelectedSpecialization { get; private set; }

    /// <summary>
    /// Total Protection Points refunded for removed abilities.
    /// Accumulated from individual ability removals during evaluation.
    /// </summary>
    public int PpRefunded { get; private set; } = 0;

    /// <summary>
    /// When the migration record was created.
    /// </summary>
    public required DateTime CreatedAt { get; init; }

    /// <summary>
    /// When the migration was completed or failed.
    /// Null if migration is still in Pending or InProgress state.
    /// </summary>
    public DateTime? CompletedAt { get; private set; }

    /// <summary>
    /// Error message if migration failed.
    /// Null if Status is not Failed.
    /// Contains diagnostic information for troubleshooting.
    /// </summary>
    public string? ErrorMessage { get; private set; }

    /// <summary>
    /// Begins the migration process by transitioning from Pending to InProgress state.
    /// The archetype assignment should occur before this method is called.
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// Thrown if migration is not in Pending state.
    /// </exception>
    public void BeginMigration()
    {
        if (Status != MigrationStatus.Pending)
            throw new InvalidOperationException(
                $"Cannot begin migration in {Status} state. Migration must be in Pending state.");

        Status = MigrationStatus.InProgress;
    }

    /// <summary>
    /// Records the player's specialization selection.
    /// Must be called while migration is in InProgress state.
    /// </summary>
    /// <param name="specialization">
    /// The specialization ID selected by the player.
    /// </param>
    /// <exception cref="InvalidOperationException">
    /// Thrown if migration is not in InProgress state.
    /// </exception>
    public void SelectSpecialization(SpecializationId specialization)
    {
        if (Status != MigrationStatus.InProgress)
            throw new InvalidOperationException(
                $"Cannot select specialization in {Status} state. Migration must be in InProgress state.");

        SelectedSpecialization = specialization;
    }

    /// <summary>
    /// Records Protection Points refunded from incompatible abilities.
    /// Called for each ability that is removed during migration.
    /// </summary>
    /// <param name="ppAmount">
    /// The amount of PP to refund. Must be non-negative.
    /// </param>
    /// <exception cref="ArgumentException">
    /// Thrown if ppAmount is negative.
    /// </exception>
    public void RecordRefund(int ppAmount)
    {
        if (ppAmount < 0)
            throw new ArgumentException(
                "PP refund cannot be negative.",
                nameof(ppAmount));

        PpRefunded += ppAmount;
    }

    /// <summary>
    /// Completes the migration successfully.
    /// Transitions from InProgress to Completed state.
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// Thrown if migration is not in InProgress state or if specialization is not selected.
    /// </exception>
    public void Complete()
    {
        if (Status != MigrationStatus.InProgress)
            throw new InvalidOperationException(
                $"Cannot complete migration in {Status} state. Migration must be in InProgress state.");

        if (SelectedSpecialization is null)
            throw new InvalidOperationException(
                "Must select specialization before completing migration.");

        Status = MigrationStatus.Completed;
        CompletedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Marks the migration as failed with an error message.
    /// Transitions to Failed state and records completion time.
    /// </summary>
    /// <param name="errorMessage">
    /// Detailed error message describing what went wrong.
    /// </param>
    public void Fail(string errorMessage)
    {
        Status = MigrationStatus.Failed;
        ErrorMessage = errorMessage;
        CompletedAt = DateTime.UtcNow;
    }
}
```

### 5.8 MigrationLog Entity

```csharp
/// <summary>
/// Audit trail entry for a migration action.
/// Provides complete transparency into all changes made during character migration.
/// </summary>
public sealed class MigrationLog
{
    /// <summary>
    /// Unique identifier for this log entry.
    /// </summary>
    public required Guid Id { get; init; }

    /// <summary>
    /// The migration record this log entry is associated with.
    /// Links logs to specific character migrations.
    /// </summary>
    public required Guid MigrationId { get; init; }

    /// <summary>
    /// The character affected by this action.
    /// </summary>
    public required Guid CharacterId { get; init; }

    /// <summary>
    /// Type of action that was logged.
    /// Examples: "MigrationInitiated", "AbilityRemoved", "SpecializationSelected", "MigrationCompleted"
    /// </summary>
    public required string ActionType { get; init; }

    /// <summary>
    /// Detailed description of the action and its outcome.
    /// Human-readable text explaining what happened.
    /// </summary>
    public required string Description { get; init; }

    /// <summary>
    /// Protection Points affected by this action.
    /// Positive values represent refunds, negative values represent costs.
    /// Zero if the action does not affect PP.
    /// </summary>
    public int PpDelta { get; init; } = 0;

    /// <summary>
    /// List of ability names affected by this action (if applicable).
    /// Null if this action does not involve abilities.
    /// </summary>
    public IReadOnlyList<string>? AffectedAbilities { get; init; }

    /// <summary>
    /// When this action occurred (UTC timestamp).
    /// Used for audit trail chronological ordering.
    /// </summary>
    public required DateTime Timestamp { get; init; }
}
```

---

## 6. Application Layer Specifications

### 6.1 ILegacyClassDetectionService Interface

```csharp
/// <summary>
/// Service for identifying characters with legacy class assignments that require migration.
/// Used during initialization to scan the database and prepare migration records.
/// </summary>
public interface ILegacyClassDetectionService
{
    /// <summary>
    /// Gets all characters that have legacy class assignments.
    /// </summary>
    /// <returns>
    /// A read-only list of tuples containing CharacterId and their LegacyClassId.
    /// Returns empty list if no legacy class characters exist.
    /// </returns>
    IReadOnlyList<(Guid CharacterId, LegacyClassId LegacyClass)> GetCharactersWithLegacyClasses();

    /// <summary>
    /// Checks whether a specific character has a legacy class.
    /// </summary>
    /// <param name="characterId">The character ID to check.</param>
    /// <returns>True if character has a legacy class, false otherwise.</returns>
    bool HasLegacyClass(Guid characterId);

    /// <summary>
    /// Gets the legacy class ID for a character if they have one.
    /// </summary>
    /// <param name="characterId">The character ID to query.</param>
    /// <returns>
    /// The LegacyClassId if the character has one, null if they don't.
    /// </returns>
    LegacyClassId? GetLegacyClass(Guid characterId);

    /// <summary>
    /// Gets the count of characters that have legacy classes and need migration.
    /// Used for progress tracking during batch migration operations.
    /// </summary>
    /// <returns>Number of characters requiring migration.</returns>
    int GetPendingMigrationCount();
}
```

### 6.2 ICharacterMigrationService Interface

```csharp
/// <summary>
/// Orchestrates character migration from legacy classes to Aethelgard archetypes.
/// Manages the complete migration workflow including ability evaluation and PP refunds.
/// </summary>
public interface ICharacterMigrationService
{
    /// <summary>
    /// Gets the migration mapping configuration for a legacy class.
    /// Defines which archetype and specializations are available.
    /// </summary>
    /// <param name="legacyClass">The legacy class to get mapping for.</param>
    /// <returns>The LegacyClassMapping containing archetype and specialization info.</returns>
    LegacyClassMapping GetMappingForLegacyClass(LegacyClassId legacyClass);

    /// <summary>
    /// Initiates the migration process for a character.
    /// Creates a CharacterMigration record and transitions it to InProgress.
    /// </summary>
    /// <param name="characterId">The character to migrate.</param>
    /// <returns>The created CharacterMigration record in InProgress state.</returns>
    CharacterMigration InitiateMigration(Guid characterId);

    /// <summary>
    /// Gets the list of specializations available for a migration.
    /// These should be compatible with the assigned archetype.
    /// </summary>
    /// <param name="migrationId">The migration record ID.</param>
    /// <returns>List of available SpecializationIds for selection.</returns>
    IReadOnlyList<SpecializationId> GetAvailableSpecializations(Guid migrationId);

    /// <summary>
    /// Records the player's specialization selection for the migration.
    /// </summary>
    /// <param name="migrationId">The migration record ID.</param>
    /// <param name="specialization">The SpecializationId selected.</param>
    void SelectSpecialization(Guid migrationId, SpecializationId specialization);

    /// <summary>
    /// Completes the migration, applying all changes to the character.
    /// Removes legacy class, assigns archetype/specialization, initializes ability slots.
    /// </summary>
    /// <param name="migrationId">The migration record ID.</param>
    /// <returns>MigrationResult containing details of all changes made.</returns>
    MigrationResult CompleteMigration(Guid migrationId);

    /// <summary>
    /// Gets the current migration status for a character.
    /// Returns null if no migration record exists.
    /// </summary>
    /// <param name="characterId">The character ID to query.</param>
    /// <returns>CharacterMigration if one exists, null otherwise.</returns>
    CharacterMigration? GetMigrationStatus(Guid characterId);

    /// <summary>
    /// Gets all audit log entries for a character's migration.
    /// Provides complete transparency into all actions taken.
    /// </summary>
    /// <param name="characterId">The character ID to query.</param>
    /// <returns>List of MigrationLog entries for this character.</returns>
    IReadOnlyList<MigrationLog> GetMigrationLogs(Guid characterId);
}
```

### 6.3 ISpecializationPrerequisiteService Interface

```csharp
/// <summary>
/// Validates specialization selection prerequisites and unlock conditions.
/// Ensures characters meet archetype compatibility and PP investment requirements.
/// </summary>
public interface ISpecializationPrerequisiteService
{
    /// <summary>
    /// Gets the prerequisite rules for a specialization.
    /// </summary>
    /// <param name="specialization">The SpecializationId to query.</param>
    /// <returns>SpecializationPrerequisite containing all validation rules.</returns>
    SpecializationPrerequisite GetPrerequisites(SpecializationId specialization);

    /// <summary>
    /// Checks whether a character is able to select a specialization.
    /// Validates archetype compatibility, PP investment, and any other prerequisites.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="specialization">The SpecializationId to check.</param>
    /// <returns>True if character can select this specialization, false otherwise.</returns>
    bool CanSelectSpecialization(Guid characterId, SpecializationId specialization);

    /// <summary>
    /// Gets all specializations available to a character.
    /// Filtered by archetype and existing prerequisite requirements.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>List of SpecializationIds the character can select.</returns>
    IReadOnlyList<SpecializationId> GetAvailableSpecializations(Guid characterId);

    /// <summary>
    /// Validates that a specialization belongs to and is compatible with an archetype.
    /// </summary>
    /// <param name="archetype">The Archetype to validate against.</param>
    /// <param name="specialization">The SpecializationId to check.</param>
    /// <returns>True if specialization is part of this archetype, false otherwise.</returns>
    bool ValidateArchetypeCompatibility(Archetype archetype, SpecializationId specialization);

    /// <summary>
    /// Gets the PP cost for a character to unlock a specialization.
    /// Returns 0 for first specialization (free), 3 for additional specializations.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="specialization">The SpecializationId to check cost for.</param>
    /// <returns>PP cost to unlock this specialization (0 or 3).</returns>
    int GetUnlockCost(Guid characterId, SpecializationId specialization);
}
```

### 6.4 IAbilitySlotService Interface

```csharp
/// <summary>
/// Manages specialization ability slot preparation and tier unlock tracking.
/// Prepares the ability slot structure for specialization ability implementations in v0.20.1+.
/// </summary>
public interface IAbilitySlotService
{
    /// <summary>
    /// Initializes ability slots for a character's newly selected specialization.
    /// Creates the tier structure (3+3+2+1) with appropriate lock states.
    /// </summary>
    /// <param name="characterId">The character receiving ability slots.</param>
    /// <param name="specialization">The specialization to initialize slots for.</param>
    /// <returns>AbilitySlotPreparation with initialized tier structure.</returns>
    AbilitySlotPreparation InitializeAbilitySlots(Guid characterId, SpecializationId specialization);

    /// <summary>
    /// Gets the current ability slot configuration for a character's specialization.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="specialization">The specialization ID.</param>
    /// <returns>
    /// AbilitySlotPreparation if slots exist, null if specialization not selected.
    /// </returns>
    AbilitySlotPreparation? GetAbilitySlots(Guid characterId, SpecializationId specialization);

    /// <summary>
    /// Checks whether a tier's ability slots are unlocked for a character.
    /// Tier 1 always unlocked; higher tiers require PP investment.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="specialization">The specialization ID.</param>
    /// <param name="tier">The tier number (1-4, where 4 is capstone).</param>
    /// <returns>True if tier is unlocked, false otherwise.</returns>
    bool IsTierUnlocked(Guid characterId, SpecializationId specialization, int tier);

    /// <summary>
    /// Gets the PP investment required to unlock the next tier.
    /// Helps with character progression planning.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="specialization">The specialization ID.</param>
    /// <returns>
    /// PP required to unlock next tier. Returns 0 if all tiers unlocked.
    /// </returns>
    int GetNextTierUnlockCost(Guid characterId, SpecializationId specialization);
}
```

---

## 7. Infrastructure Layer

### 7.1 legacy_class_mappings.json

```json
{
  "version": "0.20.0",
  "mappings": [
    {
      "legacyClass": "Rogue",
      "targetArchetype": "Skirmisher",
      "suggestedSpecializations": ["MyrkGengr", "Veidimadur"],
      "migrationDescription": "Your shadowy skills translate well to the Skirmisher's path. Consider the Myrk-gengr for stealth mastery or Veiðimaðr for tactical raiding.",
      "grantsFreeSpecialization": true
    },
    {
      "legacyClass": "Fighter",
      "targetArchetype": "Warrior",
      "suggestedSpecializations": ["Skjaldmaer", "Berserkr"],
      "migrationDescription": "Your combat prowess aligns with the Warrior's discipline. The Skjaldmær offers defensive mastery, while the Berserkr unleashes raw fury.",
      "grantsFreeSpecialization": true
    },
    {
      "legacyClass": "Mage",
      "targetArchetype": "Mystic",
      "suggestedSpecializations": ["Seidkona"],
      "migrationDescription": "Your arcane knowledge resonates with the Mystic's path. The Seiðkona tradition offers mastery over Aether itself.",
      "grantsFreeSpecialization": true
    },
    {
      "legacyClass": "Healer",
      "targetArchetype": "Adept",
      "suggestedSpecializations": ["BoneSetter"],
      "migrationDescription": "Your healing arts find new expression through the Adept's wisdom. The Bone-Setter specialization continues your healing tradition.",
      "grantsFreeSpecialization": true
    },
    {
      "legacyClass": "Scholar",
      "targetArchetype": "Adept",
      "suggestedSpecializations": ["JotunReader"],
      "migrationDescription": "Your scholarly pursuits align with the Adept's knowledge. The Jötun-Reader unlocks secrets of the ancient giants.",
      "grantsFreeSpecialization": true
    },
    {
      "legacyClass": "Crafter",
      "targetArchetype": "Adept",
      "suggestedSpecializations": ["Runasmidur", "ScrapTinker"],
      "migrationDescription": "Your crafting expertise finds new purpose through the Adept's path. Consider Rúnasmiðr for runic inscription or Scrap-Tinker for mechanical innovation.",
      "grantsFreeSpecialization": true
    }
  ],
  "refundPolicy": {
    "incompatibleAbilities": "Full PP refund",
    "partiallyCompatibleAbilities": "50% PP refund, ability marked for review",
    "fullyCompatibleAbilities": "No refund, ability preserved"
  }
}
```

### 7.2 legacy_class_mappings.schema.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "legacy_class_mappings.schema.json",
  "title": "Legacy Class Mappings Schema",
  "description": "Defines the structure and validation rules for legacy class migration mappings",
  "type": "object",
  "properties": {
    "version": {
      "type": "string",
      "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$",
      "description": "Semantic version of the mapping configuration"
    },
    "mappings": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "legacyClass": {
            "type": "string",
            "enum": ["Rogue", "Fighter", "Mage", "Healer", "Scholar", "Crafter"],
            "description": "The legacy class being defined for migration"
          },
          "targetArchetype": {
            "type": "string",
            "enum": ["Warrior", "Skirmisher", "Mystic", "Adept"],
            "description": "The target Aethelgard archetype for this legacy class"
          },
          "suggestedSpecializations": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1
            },
            "minItems": 1,
            "description": "Recommended specializations for players migrating from this legacy class"
          },
          "migrationDescription": {
            "type": "string",
            "minLength": 10,
            "maxLength": 500,
            "description": "Player-facing narrative description of the migration"
          },
          "grantsFreeSpecialization": {
            "type": "boolean",
            "description": "Whether this migration grants a free specialization selection"
          }
        },
        "required": [
          "legacyClass",
          "targetArchetype",
          "suggestedSpecializations",
          "migrationDescription",
          "grantsFreeSpecialization"
        ],
        "additionalProperties": false
      },
      "minItems": 6,
      "maxItems": 6,
      "description": "Exactly 6 legacy class mappings (one for each legacy class)"
    },
    "refundPolicy": {
      "type": "object",
      "properties": {
        "incompatibleAbilities": {
          "type": "string",
          "description": "PP refund policy for abilities that are completely incompatible"
        },
        "partiallyCompatibleAbilities": {
          "type": "string",
          "description": "PP refund policy for abilities that have partial compatibility"
        },
        "fullyCompatibleAbilities": {
          "type": "string",
          "description": "PP refund policy for abilities that are fully compatible"
        }
      },
      "required": [
        "incompatibleAbilities",
        "partiallyCompatibleAbilities",
        "fullyCompatibleAbilities"
      ],
      "additionalProperties": false
    }
  },
  "required": ["version", "mappings", "refundPolicy"],
  "additionalProperties": false
}
```

---

## 8. Decision Trees and Flow Diagrams

### 8.1 Character Migration Decision Tree

```
┌──────────────────────────────────────────────────────────┐
│  CHARACTER MIGRATION DECISION TREE (v0.20.0)              │
└──────────────────────────────────────────────────────────┘

START: Character Load
    │
    ├─► Has Legacy Class?
    │   │
    │   ├─ NO  ► Continue normal character load
    │   │       (Skip migration entirely)
    │   │
    │   └─ YES ►┌─────────────────────────────────┐
    │           │ Check Existing Migration Record  │
    │           └─────────────────────────────────┘
    │                   │
    │                   ├─ Migration = NULL
    │                   │  ► Create new migration record
    │                   │    Status: Pending
    │                   │
    │                   ├─ Migration.Status = Pending
    │                   │  ► Load specialization selection UI
    │                   │
    │                   ├─ Migration.Status = InProgress
    │                   │  ► Show specialization selection
    │                   │    (if not yet selected)
    │                   │
    │                   ├─ Migration.Status = Completed
    │                   │  ► Character already migrated
    │                   │    Load normally with new archetype
    │                   │
    │                   └─ Migration.Status = Failed
    │                      ► Show error, offer retry
    │
    ▼
END: Character loaded
```

### 8.2 Specialization Selection Flow

```
┌──────────────────────────────────────────────────────────┐
│      SPECIALIZATION SELECTION FLOW                        │
└──────────────────────────────────────────────────────────┘

Player views specialization selection UI
    │
    ├─► Display suggested specializations
    │   (from LegacyClassMapping.SuggestedSpecializations)
    │
    ├─► Player selects specialization
    │   │
    │   └─► Validate specialization
    │       │
    │       ├─ Is compatible with archetype?
    │       │  YES ► Continue
    │       │  NO  ► Show error, allow re-selection
    │       │
    │       ├─ Can character select this spec?
    │       │  (CanSelectSpecialization check)
    │       │  YES ► Continue
    │       │  NO  ► Show error, display prerequisites
    │       │
    │       └─ First specialization selection?
    │          YES ► Mark as FREE (0 PP cost)
    │          NO  ► Apply 3 PP cost (future migrations)
    │
    ├─► Record selection in migration record
    │   CharacterMigration.SelectSpecialization(spec)
    │
    ├─► Initialize ability slots
    │   IAbilitySlotService.InitializeAbilitySlots()
    │   │
    │   └─ Create AbilitySlotPreparation
    │      Tier 1: 3 slots (FREE)
    │      Tier 2: 3 slots (4 PP each)
    │      Tier 3: 2 slots (5 PP each)
    │      Capstone: 1 slot (6 PP)
    │
    ├─► Complete migration
    │   ICharacterMigrationService.CompleteMigration()
    │   │
    │   └─ Return MigrationResult
    │      - Remove legacy class
    │      - Assign archetype
    │      - Assign specialization
    │      - Apply PP refunds
    │      - Create audit logs
    │
    ▼
Character migration complete
```

### 8.3 Ability Evaluation and Refund Flow

```
┌──────────────────────────────────────────────────────────┐
│      ABILITY EVALUATION & REFUND FLOW                     │
└──────────────────────────────────────────────────────────┘

For each ability on the character:
    │
    ├─► Is ability compatible with target archetype?
    │   │
    │   ├─ YES ► Mark as PRESERVED
    │   │       No refund
    │   │       Add to PreservedAbilities
    │   │
    │   └─ NO  ► Check partial compatibility
    │           │
    │           ├─ Partially compatible?
    │           │  YES ► 50% PP refund
    │           │        Mark for review
    │           │
    │           └─ NO  ► Full PP refund
    │                   Remove ability
    │                   Add to RemovedAbilities
    │                   CharacterMigration.RecordRefund(ppAmount)
    │
    ├─► Create MigrationLog entry
    │   - ActionType: "AbilityRemoved" or "AbilityPreserved"
    │   - PpDelta: positive if refund, 0 if preserved
    │   - AffectedAbilities: [ability name]
    │
    ▼
All abilities processed
```

---

## 9. Code Examples with XML Documentation

### 9.1 LegacyClassDetectionService Implementation

```csharp
/// <summary>
/// Implements legacy class detection service for identifying and tracking
/// characters that require migration from generic classes to Aethelgard archetypes.
/// </summary>
public sealed class LegacyClassDetectionService : ILegacyClassDetectionService
{
    private readonly ICharacterRepository _characterRepository;
    private readonly ILogger<LegacyClassDetectionService> _logger;

    /// <summary>
    /// Initializes a new instance of the LegacyClassDetectionService.
    /// </summary>
    /// <param name="characterRepository">
    /// Repository for accessing character data.
    /// </param>
    /// <param name="logger">
    /// Logger for diagnostic information.
    /// </param>
    public LegacyClassDetectionService(
        ICharacterRepository characterRepository,
        ILogger<LegacyClassDetectionService> logger)
    {
        _characterRepository = characterRepository ?? throw new ArgumentNullException(nameof(characterRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Retrieves all characters currently assigned legacy class types.
    /// Scans the character database for any character with a legacy class ID.
    /// </summary>
    /// <returns>
    /// A read-only list of tuples containing character ID and their legacy class.
    /// Empty list if no legacy class characters exist (all migrated).
    /// </returns>
    public IReadOnlyList<(Guid CharacterId, LegacyClassId LegacyClass)> GetCharactersWithLegacyClasses()
    {
        _logger.LogInformation("Scanning for characters with legacy classes.");

        var legacyCharacters = new List<(Guid, LegacyClassId)>();

        // Scan all characters for legacy class assignments
        var allCharacters = _characterRepository.GetAll();

        foreach (var character in allCharacters)
        {
            if (character.Class is LegacyClassId legacyClass)
            {
                legacyCharacters.Add((character.Id, legacyClass));
                _logger.LogDebug(
                    "Found legacy class character: {CharacterId} with class {LegacyClass}",
                    character.Id,
                    legacyClass);
            }
        }

        _logger.LogInformation(
            "Scan complete. Found {Count} characters with legacy classes.",
            legacyCharacters.Count);

        return legacyCharacters.AsReadOnly();
    }

    /// <summary>
    /// Determines if a specific character has a legacy class assignment.
    /// Used for targeted checks during character loading.
    /// </summary>
    /// <param name="characterId">The ID of the character to check.</param>
    /// <returns>
    /// True if the character has a legacy class, false if they have modern archetype or non-legacy class.
    /// </returns>
    public bool HasLegacyClass(Guid characterId)
    {
        var character = _characterRepository.GetById(characterId);

        if (character is null)
        {
            _logger.LogWarning("Character not found: {CharacterId}", characterId);
            return false;
        }

        bool hasLegacy = character.Class is LegacyClassId;

        if (hasLegacy)
        {
            _logger.LogDebug(
                "Character {CharacterId} has legacy class: {Class}",
                characterId,
                character.Class);
        }

        return hasLegacy;
    }

    /// <summary>
    /// Retrieves the legacy class ID for a character if they have one.
    /// Used during migration initiation to determine target archetype.
    /// </summary>
    /// <param name="characterId">The ID of the character to query.</param>
    /// <returns>
    /// The LegacyClassId if the character has one (Rogue, Fighter, Mage, etc.),
    /// null if the character has a modern archetype or missing character.
    /// </returns>
    public LegacyClassId? GetLegacyClass(Guid characterId)
    {
        var character = _characterRepository.GetById(characterId);

        if (character is null)
        {
            _logger.LogWarning("Character not found: {CharacterId}", characterId);
            return null;
        }

        if (character.Class is LegacyClassId legacyClass)
        {
            _logger.LogDebug(
                "Retrieved legacy class for character {CharacterId}: {LegacyClass}",
                characterId,
                legacyClass);
            return legacyClass;
        }

        _logger.LogDebug(
            "Character {CharacterId} does not have a legacy class",
            characterId);
        return null;
    }

    /// <summary>
    /// Gets the count of characters that need migration.
    /// Used for progress tracking and batch processing operations.
    /// </summary>
    /// <returns>
    /// Number of characters with legacy class assignments.
    /// Returns 0 if all characters have been migrated.
    /// </returns>
    public int GetPendingMigrationCount()
    {
        int count = GetCharactersWithLegacyClasses().Count;

        _logger.LogInformation(
            "Pending migration count: {Count}",
            count);

        return count;
    }
}
```

### 9.2 SpecializationPrerequisiteService Implementation

```csharp
/// <summary>
/// Implements specialization prerequisite validation and unlock cost calculation.
/// Ensures characters meet all requirements before selecting specializations.
/// </summary>
public sealed class SpecializationPrerequisiteService : ISpecializationPrerequisiteService
{
    private readonly ISpecializationRepository _specializationRepository;
    private readonly ICharacterRepository _characterRepository;
    private readonly ILogger<SpecializationPrerequisiteService> _logger;

    // Cache of prerequisite rules loaded from configuration
    private readonly Dictionary<SpecializationId, SpecializationPrerequisite> _prerequisiteCache;

    /// <summary>
    /// Initializes a new instance of the SpecializationPrerequisiteService.
    /// </summary>
    /// <param name="specializationRepository">
    /// Repository for specialization metadata and prerequisites.
    /// </param>
    /// <param name="characterRepository">
    /// Repository for character data to validate against.
    /// </param>
    /// <param name="logger">
    /// Logger for diagnostic information.
    /// </param>
    public SpecializationPrerequisiteService(
        ISpecializationRepository specializationRepository,
        ICharacterRepository characterRepository,
        ILogger<SpecializationPrerequisiteService> logger)
    {
        _specializationRepository = specializationRepository ?? throw new ArgumentNullException(nameof(specializationRepository));
        _characterRepository = characterRepository ?? throw new ArgumentNullException(nameof(characterRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _prerequisiteCache = new Dictionary<SpecializationId, SpecializationPrerequisite>();
    }

    /// <summary>
    /// Retrieves the prerequisite rules for a specialization.
    /// Uses caching to avoid repeated configuration lookups.
    /// </summary>
    /// <param name="specialization">The specialization ID to get prerequisites for.</param>
    /// <returns>
    /// SpecializationPrerequisite containing all validation rules for this specialization.
    /// </returns>
    public SpecializationPrerequisite GetPrerequisites(SpecializationId specialization)
    {
        if (_prerequisiteCache.TryGetValue(specialization, out var cached))
        {
            return cached;
        }

        var prerequisite = _specializationRepository.GetPrerequisites(specialization);

        _prerequisiteCache[specialization] = prerequisite;

        _logger.LogDebug(
            "Loaded prerequisites for specialization {SpecId}: Archetype={Archetype}, Cost={Cost}",
            specialization,
            prerequisite.RequiredArchetype,
            prerequisite.UnlockCost);

        return prerequisite;
    }

    /// <summary>
    /// Validates whether a character can select a specific specialization.
    /// Checks archetype compatibility, PP investment, and other prerequisites.
    /// </summary>
    /// <param name="characterId">The character ID to validate.</param>
    /// <param name="specialization">The specialization to check eligibility for.</param>
    /// <returns>
    /// True if the character meets all prerequisites for this specialization,
    /// false if any prerequisite is not met.
    /// </returns>
    public bool CanSelectSpecialization(Guid characterId, SpecializationId specialization)
    {
        var character = _characterRepository.GetById(characterId);

        if (character is null)
        {
            _logger.LogWarning("Cannot validate specialization for missing character: {CharacterId}", characterId);
            return false;
        }

        var prerequisites = GetPrerequisites(specialization);

        // Check archetype compatibility
        if (character.Archetype != prerequisites.RequiredArchetype)
        {
            _logger.LogDebug(
                "Character {CharacterId} archetype {CurrentArchetype} does not match required {RequiredArchetype}",
                characterId,
                character.Archetype,
                prerequisites.RequiredArchetype);
            return false;
        }

        // Check minimum archetype PP investment
        if (character.ArchetypePPInvested < prerequisites.MinimumArchetypePP)
        {
            _logger.LogDebug(
                "Character {CharacterId} has {Current} archetype PP, requires minimum {Minimum}",
                characterId,
                character.ArchetypePPInvested,
                prerequisites.MinimumArchetypePP);
            return false;
        }

        // Check if character already has max specializations (if applicable)
        // This is version-dependent and may be implemented in v0.20.1+

        _logger.LogDebug(
            "Character {CharacterId} meets all prerequisites for specialization {SpecId}",
            characterId,
            specialization);

        return true;
    }

    /// <summary>
    /// Gets all specializations available to a character.
    /// Filters by archetype and existing prerequisite requirements.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <returns>
    /// List of SpecializationIds that the character can currently select.
    /// </returns>
    public IReadOnlyList<SpecializationId> GetAvailableSpecializations(Guid characterId)
    {
        var character = _characterRepository.GetById(characterId);

        if (character is null)
        {
            _logger.LogWarning("Cannot get available specializations for missing character: {CharacterId}", characterId);
            return Array.Empty<SpecializationId>();
        }

        var allSpecializations = _specializationRepository.GetByArchetype(character.Archetype);
        var available = new List<SpecializationId>();

        foreach (var spec in allSpecializations)
        {
            if (CanSelectSpecialization(characterId, spec))
            {
                available.Add(spec);
            }
        }

        _logger.LogDebug(
            "Character {CharacterId} has {Count} available specializations",
            characterId,
            available.Count);

        return available.AsReadOnly();
    }

    /// <summary>
    /// Validates that a specialization belongs to and is compatible with an archetype.
    /// </summary>
    /// <param name="archetype">The Archetype to validate against.</param>
    /// <param name="specialization">The specialization to check.</param>
    /// <returns>
    /// True if the specialization is defined for this archetype,
    /// false if there's an archetype mismatch.
    /// </returns>
    public bool ValidateArchetypeCompatibility(Archetype archetype, SpecializationId specialization)
    {
        var prerequisites = GetPrerequisites(specialization);

        bool compatible = prerequisites.RequiredArchetype == archetype;

        if (!compatible)
        {
            _logger.LogWarning(
                "Archetype compatibility validation failed: {Archetype} vs {RequiredArchetype} for specialization {SpecId}",
                archetype,
                prerequisites.RequiredArchetype,
                specialization);
        }

        return compatible;
    }

    /// <summary>
    /// Calculates the PP cost for a character to unlock a specialization.
    /// Returns 0 for first specialization (always free), 3 for additional specializations.
    /// </summary>
    /// <param name="characterId">The character ID.</param>
    /// <param name="specialization">The specialization to get cost for.</param>
    /// <returns>
    /// PP cost to unlock this specialization (0 for first, 3 for additional).
    /// </returns>
    public int GetUnlockCost(Guid characterId, SpecializationId specialization)
    {
        var character = _characterRepository.GetById(characterId);

        if (character is null)
        {
            _logger.LogWarning("Cannot get unlock cost for missing character: {CharacterId}", characterId);
            return 0;
        }

        var prerequisites = GetPrerequisites(specialization);

        // If this is the character's first specialization, it's free
        if (!character.HasSpecialization)
        {
            _logger.LogDebug(
                "First specialization {SpecId} for character {CharacterId}: FREE (0 PP)",
                specialization,
                characterId);
            return 0;
        }

        // Otherwise, apply the standard unlock cost
        _logger.LogDebug(
            "Additional specialization {SpecId} for character {CharacterId}: {Cost} PP",
            specialization,
            characterId,
            prerequisites.UnlockCost);

        return prerequisites.UnlockCost;
    }
}
```

---

## 10. Logging Specifications

### 10.1 Migration Logging Standards

| Log Level | Event | Format |
|-----------|-------|--------|
| **INFO** | Migration scan started | "Scanning for characters with legacy classes." |
| **INFO** | Migration scan completed | "Scan complete. Found {Count} characters with legacy classes." |
| **DEBUG** | Character found with legacy class | "Found legacy class character: {CharacterId} with class {LegacyClass}" |
| **INFO** | Migration initiated | "Migration initiated for character {CharacterId}: {LegacyClass} → {TargetArchetype}" |
| **DEBUG** | Ability evaluation | "Evaluating ability {AbilityName}: {Compatibility}" |
| **INFO** | Ability removed | "Ability {AbilityName} removed, {PpRefunded} PP refunded" |
| **DEBUG** | Ability preserved | "Ability {AbilityName} preserved and maintained" |
| **INFO** | Specialization selected | "Character {CharacterId} selected specialization {SpecId}" |
| **INFO** | Migration completed | "Migration completed for character {CharacterId}. Refunded {PpRefunded} PP." |
| **ERROR** | Migration failed | "Migration failed for character {CharacterId}: {ErrorMessage}" |

### 10.2 MigrationLog Entities

Every migration action creates a MigrationLog entry:

```csharp
// Example: Ability removed during migration
new MigrationLog
{
    Id = Guid.NewGuid(),
    MigrationId = migrationId,
    CharacterId = characterId,
    ActionType = "AbilityRemoved",
    Description = "Ability 'Fireball' incompatible with Warrior archetype, full PP refund applied",
    PpDelta = 12, // Positive = refund
    AffectedAbilities = new[] { "Fireball" },
    Timestamp = DateTime.UtcNow
}

// Example: Specialization selected
new MigrationLog
{
    Id = Guid.NewGuid(),
    MigrationId = migrationId,
    CharacterId = characterId,
    ActionType = "SpecializationSelected",
    Description = "Player selected Skjaldmær specialization during migration",
    PpDelta = 0,
    AffectedAbilities = null,
    Timestamp = DateTime.UtcNow
}
```

---

## 11. Unit Testing Requirements

### 11.1 LegacyClassDetectionService Tests

**Test 1: GetCharactersWithLegacyClasses_ReturnsAllMatches**

```csharp
[Fact]
public void GetCharactersWithLegacyClasses_ReturnsAllMatches()
{
    // Arrange: Create test characters with legacy classes
    var character1 = CreateCharacter(LegacyClassId.Fighter);
    var character2 = CreateCharacter(LegacyClassId.Mage);
    var character3 = CreateCharacter(Archetype.Warrior); // Modern archetype

    var repository = new MockCharacterRepository(new[] { character1, character2, character3 });
    var service = new LegacyClassDetectionService(repository, _logger);

    // Act
    var legacyCharacters = service.GetCharactersWithLegacyClasses();

    // Assert
    Assert.Equal(2, legacyCharacters.Count);
    Assert.Contains((character1.Id, LegacyClassId.Fighter), legacyCharacters);
    Assert.Contains((character2.Id, LegacyClassId.Mage), legacyCharacters);
}
```

**Test 2: HasLegacyClass_NoLegacyClass_ReturnsFalse**

```csharp
[Fact]
public void HasLegacyClass_NoLegacyClass_ReturnsFalse()
{
    // Arrange
    var character = CreateCharacter(Archetype.Warrior);
    var repository = new MockCharacterRepository(new[] { character });
    var service = new LegacyClassDetectionService(repository, _logger);

    // Act
    bool result = service.HasLegacyClass(character.Id);

    // Assert
    Assert.False(result);
}
```

### 11.2 CharacterMigrationService Tests

**Test 3: InitiateMigration_ValidCharacter_CreatesMigration**

```csharp
[Fact]
public void InitiateMigration_ValidCharacter_CreatesMigration()
{
    // Arrange
    var character = CreateCharacter(LegacyClassId.Fighter);
    var repository = new MockCharacterRepository(new[] { character });
    var service = new CharacterMigrationService(repository, _logger);

    // Act
    var migration = service.InitiateMigration(character.Id);

    // Assert
    Assert.NotNull(migration);
    Assert.Equal(character.Id, migration.CharacterId);
    Assert.Equal(LegacyClassId.Fighter, migration.OriginalClass);
    Assert.Equal(Archetype.Warrior, migration.TargetArchetype);
    Assert.Equal(MigrationStatus.InProgress, migration.Status);
}
```

**Test 4: CompleteMigration_NoSpecialization_ThrowsException**

```csharp
[Fact]
public void CompleteMigration_NoSpecialization_ThrowsException()
{
    // Arrange
    var migration = CreateMigration(MigrationStatus.InProgress);
    migration.SelectedSpecialization = null;

    var repository = new MockCharacterRepository();
    var service = new CharacterMigrationService(repository, _logger);

    // Act & Assert
    var exception = Assert.Throws<InvalidOperationException>(
        () => service.CompleteMigration(migration.Id));

    Assert.Contains("specialization", exception.Message, StringComparison.OrdinalIgnoreCase);
}
```

**Test 5: GetAvailableSpecializations_Fighter_ReturnsWarriorSpecs**

```csharp
[Fact]
public void GetAvailableSpecializations_Fighter_ReturnsWarriorSpecs()
{
    // Arrange
    var migration = CreateMigration(LegacyClassId.Fighter);
    var repository = new MockCharacterRepository();
    var service = new CharacterMigrationService(repository, _logger);

    // Act
    var specializations = service.GetAvailableSpecializations(migration.Id);

    // Assert
    Assert.NotEmpty(specializations);
    Assert.Contains(SpecializationId.Skjaldmaer, specializations);
    Assert.Contains(SpecializationId.Berserkr, specializations);
}
```

### 11.3 SpecializationPrerequisiteService Tests

**Test 6: CanSelectSpecialization_WrongArchetype_ReturnsFalse**

```csharp
[Fact]
public void CanSelectSpecialization_WrongArchetype_ReturnsFalse()
{
    // Arrange: Character is Warrior, trying to select Mystic specialization
    var character = CreateCharacter(Archetype.Warrior);
    var repository = new MockCharacterRepository(new[] { character });
    var service = new SpecializationPrerequisiteService(repository, _logger);

    // Act
    bool result = service.CanSelectSpecialization(character.Id, SpecializationId.Seidkona);

    // Assert
    Assert.False(result);
}
```

**Test 7: GetUnlockCost_FirstSpecialization_ReturnsZero**

```csharp
[Fact]
public void GetUnlockCost_FirstSpecialization_ReturnsZero()
{
    // Arrange: Character with no specializations
    var character = CreateCharacter(Archetype.Warrior, specializationCount: 0);
    var repository = new MockCharacterRepository(new[] { character });
    var service = new SpecializationPrerequisiteService(repository, _logger);

    // Act
    int cost = service.GetUnlockCost(character.Id, SpecializationId.Skjaldmaer);

    // Assert
    Assert.Equal(0, cost);
}
```

### 11.4 AbilitySlotService Tests

**Test 8: InitializeAbilitySlots_CreatesCorrectStructure**

```csharp
[Fact]
public void InitializeAbilitySlots_CreatesCorrectStructure()
{
    // Arrange
    var characterId = Guid.NewGuid();
    var specialization = SpecializationId.Skjaldmaer;
    var repository = new MockAbilitySlotRepository();
    var service = new AbilitySlotService(repository, _logger);

    // Act
    var slots = service.InitializeAbilitySlots(characterId, specialization);

    // Assert
    Assert.Equal(3, slots.Tier1Slots);
    Assert.Equal(3, slots.Tier2Slots);
    Assert.Equal(2, slots.Tier3Slots);
    Assert.Equal(1, slots.CapstoneSlots);
    Assert.Equal(9, slots.TotalSlots);
}
```

**Test 9: IsTierUnlocked_Tier2_RequiresEightPP**

```csharp
[Fact]
public void IsTierUnlocked_Tier2_RequiresEightPP()
{
    // Arrange: Character with 7 PP in archetype tree
    var character = CreateCharacter(Archetype.Warrior, ppInvested: 7);
    var repository = new MockCharacterRepository(new[] { character });
    var service = new AbilitySlotService(repository, _logger);

    // Act
    bool isTier2Unlocked = service.IsTierUnlocked(character.Id, SpecializationId.Skjaldmaer, 2);

    // Assert
    Assert.False(isTier2Unlocked);

    // Now increase to 8 PP
    character.ArchetypePPInvested = 8;
    isTier2Unlocked = service.IsTierUnlocked(character.Id, SpecializationId.Skjaldmaer, 2);

    Assert.True(isTier2Unlocked);
}
```

**Test 10: GetNextTierUnlockCost_ReturnsCorrectCost**

```csharp
[Fact]
public void GetNextTierUnlockCost_ReturnsCorrectCost()
{
    // Arrange: Character with 0 PP in archetype tree
    var character = CreateCharacter(Archetype.Warrior, ppInvested: 0);
    var repository = new MockCharacterRepository(new[] { character });
    var service = new AbilitySlotService(repository, _logger);

    // Act
    int cost = service.GetNextTierUnlockCost(character.Id, SpecializationId.Skjaldmaer);

    // Assert
    Assert.Equal(8, cost); // Need 8 PP to unlock Tier 2
}
```

---

## 12. Deliverable Checklist

### Domain Layer Deliverables

- [ ] `LegacyClassId` enumeration (6 values: Rogue, Fighter, Mage, Healer, Scholar, Crafter)
- [ ] `MigrationStatus` enumeration (4 values: Pending, InProgress, Completed, Failed)
- [ ] `LegacyClassMapping` value object (sealed record with archetype and specialization mapping)
- [ ] `MigrationResult` value object (sealed record with migration outcome details)
- [ ] `AbilitySlotPreparation` value object (sealed record for tier structure)
- [ ] `SpecializationPrerequisite` value object (sealed record for validation rules)
- [ ] `CharacterMigration` entity (sealed class with state transitions)
- [ ] `MigrationLog` entity (sealed class for audit trail)

### Application Layer Deliverables

- [ ] `ILegacyClassDetectionService` interface definition
- [ ] `LegacyClassDetectionService` implementation class
- [ ] `ICharacterMigrationService` interface definition
- [ ] `CharacterMigrationService` implementation class
- [ ] `ISpecializationPrerequisiteService` interface definition
- [ ] `SpecializationPrerequisiteService` implementation class
- [ ] `IAbilitySlotService` interface definition
- [ ] `AbilitySlotService` implementation class

### Infrastructure Layer Deliverables

- [ ] `legacy_class_mappings.json` configuration file (6 mapping entries)
- [ ] `legacy_class_mappings.schema.json` JSON Schema validation file

### Testing Deliverables

- [ ] `LegacyClassDetectionService` unit tests (2 tests)
- [ ] `CharacterMigrationService` unit tests (4 tests)
- [ ] `SpecializationPrerequisiteService` unit tests (2 tests)
- [ ] `AbilitySlotService` unit tests (2 tests)
- [ ] All tests passing with 100% pass rate
- [ ] Code coverage: >= 85% for all service implementations

### Quality Deliverables

- [ ] All public members have complete XML documentation
- [ ] Configuration files validate against schema successfully
- [ ] No build errors
- [ ] No build warnings
- [ ] All tests pass
- [ ] Static analysis clean (no code quality issues)

---

## 13. Acceptance Criteria

### Functional Acceptance Criteria

- [ ] **Legacy Class Detection:** System correctly identifies all characters with legacy classes
- [ ] **Migration Mapping:** All 6 legacy classes map to correct archetypes
- [ ] **Archetype Assignment:** Characters receive correct archetype based on legacy class
- [ ] **Specialization Options:** Suggested specializations align with archetype
- [ ] **Ability Preservation:** Compatible abilities preserved during migration
- [ ] **PP Refunds:** Incompatible abilities generate correct PP refunds
- [ ] **First Specialization Free:** First specialization selection costs 0 PP
- [ ] **Ability Slot Initialization:** Tier structure (3+3+2+1) created correctly
- [ ] **Tier Unlock Requirements:** Tier 1 free, Tier 2 requires 8 PP, Tier 3 requires 16 PP, Capstone requires 24 PP
- [ ] **Migration Status Tracking:** All four migration states transitionable and traceable
- [ ] **Audit Trail:** Complete logs created for all migration actions
- [ ] **No Legacy Class References:** All legacy class references removed from character data post-migration

### Quality Acceptance Criteria

- [ ] **XML Documentation:** 100% of public members documented
- [ ] **Unit Tests:** All ~10 tests passing
- [ ] **Code Coverage:** >= 85% coverage of service implementations
- [ ] **Build Status:** 0 errors, 0 warnings
- [ ] **Schema Validation:** Configuration files valid against schema
- [ ] **Static Analysis:** Clean code quality report
- [ ] **Performance:** Migration completes for 1000 characters in < 5 seconds
- [ ] **Data Integrity:** No character data corrupted during migration

---

## 14. Dependencies

### Required From Previous Versions

| Dependency | Source Version | Usage | Notes |
|-----------|----------------|-------|-------|
| `Archetype` enum | v0.17.3 | Specifies target archetype | Required for migration mapping |
| `SpecializationId` enum | v0.17.4 | Specialization selection | Must include all 8 specializations |
| `SpecializationDefinition` | v0.17.4 | Specialization metadata | Provides specialization details |
| `SpecializationPathType` | v0.17.4 | Coherent/Heretical classification | Used for compatibility checks |
| `PP System` | v0.17.4 | Protection Points for costs and refunds | Must support refund operations |
| `Character` entity | v0.17.2 | Base character model | Must support class assignments |
| `Ability` entity | v0.18.0 | Character abilities | Required for compatibility evaluation |

### Provides To Subsequent Versions

| Provides | Consumer | Target Version | Notes |
|----------|----------|-----------------|-------|
| `IAbilitySlotService` | Ability implementations | v0.20.1-v0.20.8 | Used to query slot availability |
| `ISpecializationPrerequisiteService` | Specialization systems | v0.20.1+ | Validates all specialization selections |
| Migration infrastructure | Future class systems | TBD | Reusable pattern for future migrations |
| `CharacterMigration` entities | Migration tracking systems | v0.20.1+ | Historical reference for player support |
| `MigrationLog` audit trail | Admin/reporting systems | TBD | Provides complete audit trail |

---

## 15. Deferrals and Future Considerations

### Out of Scope for v0.20.0a

| Feature | Target Version | Reason |
|---------|-----------------|--------|
| Individual specialization abilities | v0.20.1-v0.20.8 | Each specialization needs dedicated development |
| Special resource mechanics | v0.20.1+ | Requires specialization-specific implementation |
| Tier-specific ability unlocking | v0.20.1+ | Ability system not yet implemented |
| Corruption mechanics | v0.20.2+ | Requires Heretical specialization framework |
| UI rendering for specializations | v0.20.1+ | Frontend team dependency |
| Character respeccing | TBD | Policy decision required |
| Paid specialization changes | TBD | Business model decision required |

### Future Enhancements

1. **Respecification System (v0.21.x):** Allow paid PP exchange to change specializations
2. **Multiclassing Support (v0.22.x):** Enable characters to specialize in multiple archetypes
3. **Legacy Data Archive (v0.20.1+):** Store pre-migration character snapshots for reference
4. **Migration Rollback (Emergency):** Ability to revert failed migrations with audit trail
5. **Batch Migration Analytics:** Reports on migration success rates and common issues
6. **Character Resurrection (v0.21+):** Recover archived characters if needed

---

## 16. Configuration Files

### 16.1 legacy_class_mappings.json

**Location:** `/data/config/legacy_class_mappings.json`
**Purpose:** Runtime configuration for legacy class to archetype mapping
**Validation:** Must validate against `legacy_class_mappings.schema.json`
**Deployment:** Packaged with release, not modifiable after deployment

**Entry Example - Fighter:**

```json
{
  "legacyClass": "Fighter",
  "targetArchetype": "Warrior",
  "suggestedSpecializations": ["Skjaldmaer", "Berserkr"],
  "migrationDescription": "Your combat prowess aligns with the Warrior's discipline. The Skjaldmær offers defensive mastery, while the Berserkr unleashes raw fury.",
  "grantsFreeSpecialization": true
}
```

### 16.2 Tier Unlock Configuration

```json
{
  "tierUnlocks": [
    {
      "tier": 1,
      "requiresArchetypePP": 0,
      "slots": 3,
      "costPerSlot": 0,
      "description": "Tier 1: Foundational abilities"
    },
    {
      "tier": 2,
      "requiresArchetypePP": 8,
      "slots": 3,
      "costPerSlot": 4,
      "description": "Tier 2: Advanced specialization abilities"
    },
    {
      "tier": 3,
      "requiresArchetypePP": 16,
      "slots": 2,
      "costPerSlot": 5,
      "description": "Tier 3: Expert specialization abilities"
    },
    {
      "tier": 4,
      "requiresArchetypePP": 24,
      "slots": 1,
      "costPerSlot": 6,
      "description": "Capstone: Ultimate specialization ability"
    }
  ]
}
```

---

## 17. Error Handling

### 17.1 Error Categories

| Category | Example | Handling |
|----------|---------|----------|
| **Migration Validation** | Character not found | Log error, mark migration as Failed, provide user message |
| **Specialization Invalid** | Specialization not for archetype | Log warning, reject selection, prompt valid choices |
| **Ability Compatibility** | Ability incompatible with archetype | Log debug, remove ability, calculate refund |
| **PP Refund Failure** | Cannot add PP to character | Log error, mark migration as Failed, trigger rollback |
| **Configuration Error** | Missing or invalid mapping | Log error, fail migration, alert administrator |
| **Database Error** | Cannot save migration record | Log error, retry with exponential backoff |

### 17.2 Exception Specifications

```csharp
/// <summary>
/// Thrown when a migration operation violates state transition rules.
/// </summary>
public class InvalidMigrationStateException : Exception
{
    public Guid MigrationId { get; set; }
    public MigrationStatus CurrentStatus { get; set; }
    public string? RequestedOperation { get; set; }

    public InvalidMigrationStateException(
        string message,
        Guid migrationId,
        MigrationStatus currentStatus,
        string? requestedOperation = null)
        : base(message)
    {
        MigrationId = migrationId;
        CurrentStatus = currentStatus;
        RequestedOperation = requestedOperation;
    }
}

/// <summary>
/// Thrown when a character lacks prerequisites for specialization selection.
/// </summary>
public class SpecializationPrerequisiteNotMetException : Exception
{
    public Guid CharacterId { get; set; }
    public SpecializationId SpecializationId { get; set; }
    public string? MissingPrerequisite { get; set; }

    public SpecializationPrerequisiteNotMetException(
        string message,
        Guid characterId,
        SpecializationId specializationId,
        string? missingPrerequisite = null)
        : base(message)
    {
        CharacterId = characterId;
        SpecializationId = specializationId;
        MissingPrerequisite = missingPrerequisite;
    }
}
```

---

## 18. Performance Considerations

### 18.1 Optimization Goals

| Metric | Target | Notes |
|--------|--------|-------|
| **Legacy class scan** | < 500ms for 10k characters | Uses database index on class field |
| **Single migration** | < 1 second | Cached configuration lookups |
| **Batch migration** | < 5 seconds for 1000 characters | Parallel processing where safe |
| **Ability evaluation** | < 100ms per character | In-memory ability compatibility matrix |
| **PP refund calculation** | < 50ms per character | Single pass through ability list |

### 18.2 Caching Strategy

```csharp
// Configuration cache (loaded once at startup)
private readonly Dictionary<LegacyClassId, LegacyClassMapping> _mappingCache
    = new Dictionary<LegacyClassId, LegacyClassMapping>();

// Specialization prerequisites cache
private readonly Dictionary<SpecializationId, SpecializationPrerequisite> _prerequisiteCache
    = new Dictionary<SpecializationId, SpecializationPrerequisite>();

// Character archetype cache (cleared on character updates)
private readonly Dictionary<Guid, Archetype> _characterArchetypeCache
    = new Dictionary<Guid, Archetype>();
```

### 18.3 Database Indexing Requirements

```sql
-- Recommended indexes for migration performance
CREATE INDEX idx_character_class ON character(class) WHERE class IN ('Rogue', 'Fighter', 'Mage', 'Healer', 'Scholar', 'Crafter');
CREATE INDEX idx_character_migration_status ON character_migration(status);
CREATE INDEX idx_migration_log_character ON migration_log(character_id, timestamp DESC);
```

---

## 19. Security Considerations

### 19.1 Authorization Controls

| Action | Required Role | Verification |
|--------|---------------|--------------|
| **View migration status** | Player (for own character) or Admin | Character ownership check |
| **Complete migration** | Player (for own character) | Session ownership validation |
| **View migration logs** | Admin only | Admin role check |
| **Modify mapping config** | Admin only | Role-based access control |

### 19.2 Data Protection

- **Migration logs immutable:** Audit trail cannot be modified after creation
- **PP refunds audited:** Every refund recorded with timestamp and details
- **Configuration validation:** All config files validated against schema before use
- **Input sanitization:** All string inputs sanitized to prevent injection attacks
- **Sensitive data:** No sensitive data stored in logs beyond character ID

### 19.3 Audit Requirements

```csharp
// All migration actions create immutable audit logs
public void LogMigrationAction(
    Guid migrationId,
    Guid characterId,
    string actionType,
    string description,
    int ppDelta = 0,
    IReadOnlyList<string>? affectedAbilities = null)
{
    var log = new MigrationLog
    {
        Id = Guid.NewGuid(),
        MigrationId = migrationId,
        CharacterId = characterId,
        ActionType = actionType,
        Description = description,
        PpDelta = ppDelta,
        AffectedAbilities = affectedAbilities,
        Timestamp = DateTime.UtcNow
    };

    _migrationLogRepository.Add(log);
    _migrationLogRepository.SaveChanges();
}
```

---

## 20. Migration Guide

### 20.1 For Players: Understanding Your Migration

**What is happening?**
Your character's generic class (Fighter, Mage, Rogue, etc.) is being replaced with a specialized Aethelgard archetype system. This is a one-time change that prepares you for more powerful abilities in v0.20.1 and beyond.

**What changes?**
1. Your generic class is removed
2. You receive an Aethelgard archetype (e.g., Warrior, Mystic, Skirmisher)
3. You select a specialization (first specialization is FREE)
4. Your ability slots are prepared for new specialization abilities
5. Any incompatible abilities are removed (you get full PP refund)

**What stays the same?**
- Compatible abilities remain on your character
- Your character level and experience
- Your archetype abilities
- Your inventory and equipment

### 20.2 For Game Masters: Running the Migration

**Step 1: Backup Character Data**

```bash
# Create backup of all character data before v0.20.0 deployment
mysqldump -u user -p database characters > characters_backup_v0.19.2.sql
```

**Step 2: Deploy v0.20.0a**

```bash
# Deploy new code and configuration
dotnet publish -c Release
# Copy legacy_class_mappings.json to config directory
cp legacy_class_mappings.json /data/config/
```

**Step 3: Run Migration Scan**

```csharp
var detectionService = serviceProvider.GetRequiredService<ILegacyClassDetectionService>();
int legacyCharacterCount = detectionService.GetPendingMigrationCount();
Console.WriteLine($"Found {legacyCharacterCount} characters requiring migration");
```

**Step 4: Initiate Character Migrations**

```csharp
var migrationService = serviceProvider.GetRequiredService<ICharacterMigrationService>();
var characters = detectionService.GetCharactersWithLegacyClasses();

foreach (var (characterId, _) in characters)
{
    var migration = migrationService.InitiateMigration(characterId);
    Console.WriteLine($"Initiated migration for character {characterId}");
}
```

**Step 5: Monitor Migration Progress**

```csharp
// Check migration status periodically
while (true)
{
    var legacyCount = detectionService.GetPendingMigrationCount();
    Console.WriteLine($"Remaining legacy class characters: {legacyCount}");

    if (legacyCount == 0)
        break;

    await Task.Delay(TimeSpan.FromSeconds(30));
}
```

### 20.3 For Developers: Integration Points

**Integration Point 1: Character Loading**

```csharp
public async Task<Character> LoadCharacterAsync(Guid characterId)
{
    var character = await _characterRepository.GetByIdAsync(characterId);

    // Check for legacy class and handle migration UI
    if (_legacyDetectionService.HasLegacyClass(characterId))
    {
        var migration = _migrationService.GetMigrationStatus(characterId);

        if (migration?.Status == MigrationStatus.Pending ||
            migration?.Status == MigrationStatus.InProgress)
        {
            // Display migration UI to player
            return character; // UI handles specialization selection
        }
    }

    return character;
}
```

**Integration Point 2: Specialization Selection**

```csharp
public void OnSpecializationSelected(Guid characterId, SpecializationId specialization)
{
    var migration = _migrationService.GetMigrationStatus(characterId);

    if (migration is null || migration.Status != MigrationStatus.InProgress)
        return;

    // Validate selection
    if (!_prerequisiteService.CanSelectSpecialization(characterId, specialization))
    {
        ShowError("Invalid specialization selection");
        return;
    }

    // Record selection
    _migrationService.SelectSpecialization(migration.Id, specialization);

    // Complete migration
    var result = _migrationService.CompleteMigration(migration.Id);

    // Show result to player
    ShowMigrationSummary(result);
}
```

**Integration Point 3: Character Save**

```csharp
public async Task SaveCharacterAsync(Character character)
{
    // After migration completion, no legacy class should exist
    if (character.Archetype == null && character.Class is LegacyClassId)
    {
        throw new InvalidOperationException(
            $"Character {character.Id} still has legacy class after migration. " +
            "Migration may have failed.");
    }

    await _characterRepository.SaveAsync(character);
}
```

### 20.4 Troubleshooting Migration Issues

**Issue: Character stuck in InProgress state**

```csharp
// Check what went wrong
var logs = _migrationService.GetMigrationLogs(characterId);
foreach (var log in logs)
{
    Console.WriteLine($"{log.Timestamp}: {log.ActionType} - {log.Description}");
}

// Retry migration
var migration = _migrationService.GetMigrationStatus(characterId);
if (migration?.Status == MigrationStatus.InProgress)
{
    // Provide UI for specialization selection again
    ShowSpecializationSelectionUI();
}
```

**Issue: Character has both legacy class and archetype**

```csharp
// Data integrity check - should not happen
var character = await _characterRepository.GetByIdAsync(characterId);

if (character.Class is LegacyClassId && character.Archetype != null)
{
    _logger.LogError(
        "Data integrity issue: Character {CharacterId} has both legacy class and archetype",
        characterId);

    // Restore from backup and retry migration
}
```

---

## Conclusion

v0.20.0a represents a critical infrastructure release that removes all legacy class placeholders and establishes the migration framework for existing characters. The migration infrastructure is designed to be transparent to players while providing administrators with complete audit trails and recovery mechanisms.

All characters will transition smoothly from generic classes to specialized Aethelgard archetypes, with the first specialization selection completely free to compensate for the forced migration. The ability slot structure prepared in this version serves as the foundation for v0.20.1-v0.20.8 specialization ability implementations.

**Status:** Ready for development
**Estimated Timeline:** 2-3 weeks for implementation and testing
**Team:** Backend Development (4-5 engineers)

---

*Design Specification: v0.20.0a - Legacy Class Removal & Migration Infrastructure*
*Last Updated: 2026-01-28*
*Version: 1.0 Final*
