# v0.18.4f Design Specification: Configuration & Persistence

**Version:** 0.18.4f
**Parent:** v0.18.4 (Specialization-Specific Resources)
**Prerequisites:** v0.18.4e (Service Implementation), v0.18.4a-c (Domain Models)
**Status:** Design Complete
**Estimated Unit Tests:** ~3

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Configuration Design](#3-configuration-design)
4. [Database Schema](#4-database-schema)
5. [Repository Patterns](#5-repository-patterns)
6. [Configuration Loading](#6-configuration-loading)
7. [Data Access Implementation](#7-data-access-implementation)
8. [Logging Specifications](#8-logging-specifications)
9. [Unit Testing Requirements](#9-unit-testing-requirements)
10. [Deliverable Checklist](#10-deliverable-checklist)
11. [Acceptance Criteria](#11-acceptance-criteria)
12. [Dependencies](#12-dependencies)
13. [Future Considerations](#13-future-considerations)

---

## 1. Executive Summary

This design specification defines the **Configuration and Persistence Layer** for all three specialization resources. This phase centralizes configuration values in JSON format and establishes the database schema for persistent storage of resource states.

v0.18.4f establishes:

- `specialization-resources.json` configuration file with all resource parameters
- `specialization-resources.schema.json` JSON Schema for validation
- Database tables for `character_rage`, `character_momentum`, `character_coherence`
- Repository methods for loading and persisting resource state

### Key Deliverables

| Category              | Items                                     |
| --------------------- | ----------------------------------------- |
| **Configuration**     | specialization-resources.json, schema.json|
| **Database Schema**   | 3 new tables with constraints and indexes|
| **Repository Methods**| Load, update, and delete operations      |
| **Tests**             | ~3 unit tests for loading and persisting |

---

## 2. Feature Overview

```
v0.18.4f Configuration & Persistence
│
├── Configuration Files
│   ├── config/specialization-resources.json
│   │   ├── version: "1.0"
│   │   ├── rage: { maxValue, decayPerTurn, thresholds[], sources{} }
│   │   ├── momentum: { maxValue, decayOnMiss, thresholds[], sources{} }
│   │   └── coherence: { maxValue, meditationGain, thresholds[], sources{} }
│   │
│   └── config/schemas/specialization-resources.schema.json
│       └── JSON Schema for validation
│
├── Database Schema
│   ├── character_rage table
│   │   ├── character_id (FK)
│   │   ├── current_rage (0-100)
│   │   ├── last_combat_time
│   │   └── updated_at
│   │
│   ├── character_momentum table
│   │   ├── character_id (FK)
│   │   ├── current_momentum (0-100)
│   │   ├── consecutive_hits
│   │   ├── last_action_time
│   │   └── updated_at
│   │
│   └── character_coherence table
│       ├── character_id (FK)
│       ├── current_coherence (0-100)
│       ├── in_apotheosis (bool)
│       ├── apotheosis_abilities_unlocked (bool)
│       ├── turns_in_apotheosis
│       ├── last_cast_time
│       ├── is_combat (bool)
│       └── updated_at
│
└── Repository Methods
    ├── LoadRageState(Guid characterId)
    ├── SaveRageState(Guid characterId, RageState state)
    ├── LoadMomentumState(Guid characterId)
    ├── SaveMomentumState(Guid characterId, MomentumState state)
    ├── LoadCoherenceState(Guid characterId)
    └── SaveCoherenceState(Guid characterId, CoherenceState state)
```

---

## 3. Configuration Design

### 3.1 specialization-resources.json

**File:** `config/specialization-resources.json`

```json
{
  "version": "1.0",
  "metadata": {
    "createdDate": "2026-01-28",
    "description": "Configuration for specialization-specific resources (Rage, Momentum, Coherence)"
  },
  "rage": {
    "maxValue": 100,
    "minValue": 0,
    "decayPerTurn": 10,
    "decayMinutesBeforeNonCombat": 1,
    "thresholds": [
      {
        "name": "Calm",
        "minValue": 0,
        "maxValue": 20,
        "damageBonus": 0,
        "soakBonus": 0,
        "fearImmune": false,
        "mustAttackNearest": false,
        "partyStressReduction": null
      },
      {
        "name": "Simmering",
        "minValue": 21,
        "maxValue": 40,
        "damageBonus": 3,
        "soakBonus": 1,
        "fearImmune": false,
        "mustAttackNearest": false,
        "partyStressReduction": null
      },
      {
        "name": "Burning",
        "minValue": 41,
        "maxValue": 60,
        "damageBonus": 5,
        "soakBonus": 2,
        "fearImmune": false,
        "mustAttackNearest": false,
        "partyStressReduction": null
      },
      {
        "name": "BerserkFury",
        "minValue": 61,
        "maxValue": 80,
        "damageBonus": 7,
        "soakBonus": 3,
        "fearImmune": false,
        "mustAttackNearest": true,
        "partyStressReduction": null
      },
      {
        "name": "FrenzyBeyondReason",
        "minValue": 81,
        "maxValue": 100,
        "damageBonus": 9,
        "soakBonus": 4,
        "fearImmune": true,
        "mustAttackNearest": true,
        "partyStressReduction": 10
      }
    ],
    "sources": {
      "takingDamage": {
        "type": "formula",
        "formula": "floor(damage / 5)",
        "description": "Rage gained from taking damage"
      },
      "dealingDamage": {
        "type": "formula",
        "formula": "floor(damage / 10)",
        "description": "Rage gained from dealing damage"
      },
      "allyDamaged": {
        "type": "flat",
        "value": 5,
        "description": "Rage gained when ally takes damage"
      },
      "enemyKill": {
        "type": "flat",
        "value": 15,
        "description": "Rage gained from killing an enemy"
      },
      "rageMaintenance": {
        "type": "flat",
        "value": 5,
        "description": "Passive rage gain at FrenzyBeyondReason"
      }
    }
  },
  "momentum": {
    "maxValue": 100,
    "minValue": 0,
    "decayOnMiss": 25,
    "decayOnStun": 100,
    "decayOnIdleTurn": 15,
    "thresholds": [
      {
        "name": "Stationary",
        "minValue": 0,
        "maxValue": 20,
        "bonusAttacks": 0,
        "attackBonus": 0,
        "defenseBonus": 0,
        "criticalChance": null,
        "movementBonusPerTwenty": 1
      },
      {
        "name": "Moving",
        "minValue": 21,
        "maxValue": 40,
        "bonusAttacks": 0,
        "attackBonus": 1,
        "defenseBonus": 1,
        "criticalChance": null,
        "movementBonusPerTwenty": 1
      },
      {
        "name": "Flowing",
        "minValue": 41,
        "maxValue": 60,
        "bonusAttacks": 1,
        "attackBonus": 2,
        "defenseBonus": 2,
        "criticalChance": null,
        "movementBonusPerTwenty": 1
      },
      {
        "name": "Surging",
        "minValue": 61,
        "maxValue": 80,
        "bonusAttacks": 1,
        "attackBonus": 3,
        "defenseBonus": 3,
        "criticalChance": null,
        "movementBonusPerTwenty": 1
      },
      {
        "name": "Unstoppable",
        "minValue": 81,
        "maxValue": 100,
        "bonusAttacks": 2,
        "attackBonus": 4,
        "defenseBonus": 4,
        "criticalChance": 10,
        "movementBonusPerTwenty": 1,
        "healOnKill": true
      }
    ],
    "sources": {
      "successfulAttack": {
        "type": "flat",
        "value": 10,
        "description": "Momentum from successful attack hit"
      },
      "killingBlow": {
        "type": "flat",
        "value": 20,
        "description": "Momentum from defeating an enemy"
      },
      "chainAttack": {
        "type": "formula",
        "formula": "floor(consecutiveHits * 5)",
        "description": "Momentum bonus from attack chain"
      },
      "movement": {
        "type": "formula",
        "formula": "floor(distanceMoved / 2)",
        "description": "Momentum from repositioning"
      }
    }
  },
  "coherence": {
    "maxValue": 100,
    "minValue": 0,
    "defaultValue": 50,
    "meditationGain": 20,
    "castGain": 5,
    "channelGainPerTurn": 3,
    "apotheosisStressCost": 10,
    "thresholds": [
      {
        "name": "Destabilized",
        "minValue": 0,
        "maxValue": 20,
        "spellPowerBonus": -2,
        "criticalCastChance": 0,
        "cascadeRisk": 25
      },
      {
        "name": "Unstable",
        "minValue": 21,
        "maxValue": 40,
        "spellPowerBonus": -1,
        "criticalCastChance": 0,
        "cascadeRisk": 10
      },
      {
        "name": "Balanced",
        "minValue": 41,
        "maxValue": 60,
        "spellPowerBonus": 0,
        "criticalCastChance": 5,
        "cascadeRisk": 0
      },
      {
        "name": "Focused",
        "minValue": 61,
        "maxValue": 80,
        "spellPowerBonus": 2,
        "criticalCastChance": 10,
        "cascadeRisk": 0
      },
      {
        "name": "Apotheosis",
        "minValue": 81,
        "maxValue": 100,
        "spellPowerBonus": 5,
        "criticalCastChance": 20,
        "cascadeRisk": 0,
        "ultimateAbilitiesEnabled": true
      }
    ],
    "sources": {
      "successfulCast": {
        "type": "flat",
        "value": 5,
        "description": "Coherence from completed spell"
      },
      "controlledChannel": {
        "type": "formula",
        "formula": "3 per turn",
        "description": "Coherence from maintained spell"
      },
      "meditation": {
        "type": "flat",
        "value": 20,
        "description": "Coherence from meditation action"
      },
      "stabilityField": {
        "type": "variable",
        "minValue": 1,
        "maxValue": 10,
        "description": "Coherence from environmental effects"
      }
    }
  }
}
```

### 3.2 JSON Schema Validation

**File:** `config/schemas/specialization-resources.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Specialization Resources Configuration",
  "description": "Configuration schema for Rage, Momentum, and Coherence systems",
  "type": "object",
  "required": ["version", "rage", "momentum", "coherence"],
  "properties": {
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+$",
      "description": "Configuration version (e.g., 1.0)"
    },
    "metadata": {
      "type": "object",
      "properties": {
        "createdDate": { "type": "string" },
        "description": { "type": "string" }
      }
    },
    "rage": {
      "type": "object",
      "required": ["maxValue", "minValue", "decayPerTurn", "thresholds", "sources"],
      "properties": {
        "maxValue": { "type": "integer", "minimum": 100, "maximum": 100 },
        "minValue": { "type": "integer", "minimum": 0, "maximum": 0 },
        "decayPerTurn": { "type": "integer", "minimum": 1 },
        "decayMinutesBeforeNonCombat": { "type": "integer", "minimum": 1 },
        "thresholds": {
          "type": "array",
          "minItems": 5,
          "maxItems": 5,
          "items": {
            "type": "object",
            "required": ["name", "minValue", "maxValue", "soakBonus"],
            "properties": {
              "name": { "type": "string" },
              "minValue": { "type": "integer" },
              "maxValue": { "type": "integer" },
              "damageBonus": { "type": "integer" },
              "soakBonus": { "type": "integer" },
              "fearImmune": { "type": "boolean" },
              "mustAttackNearest": { "type": "boolean" },
              "partyStressReduction": { "type": ["integer", "null"] }
            }
          }
        },
        "sources": { "type": "object" }
      }
    },
    "momentum": {
      "type": "object",
      "required": ["maxValue", "minValue", "decayOnMiss", "thresholds", "sources"],
      "properties": {
        "maxValue": { "type": "integer", "minimum": 100, "maximum": 100 },
        "minValue": { "type": "integer", "minimum": 0, "maximum": 0 },
        "decayOnMiss": { "type": "integer", "minimum": 1 },
        "decayOnStun": { "type": "integer", "minimum": 100, "maximum": 100 },
        "decayOnIdleTurn": { "type": "integer", "minimum": 1 },
        "thresholds": { "type": "array", "minItems": 5, "maxItems": 5 },
        "sources": { "type": "object" }
      }
    },
    "coherence": {
      "type": "object",
      "required": ["maxValue", "minValue", "defaultValue", "thresholds", "sources"],
      "properties": {
        "maxValue": { "type": "integer", "minimum": 100, "maximum": 100 },
        "minValue": { "type": "integer", "minimum": 0, "maximum": 0 },
        "defaultValue": { "type": "integer", "minimum": 0, "maximum": 100 },
        "meditationGain": { "type": "integer", "minimum": 1 },
        "apotheosisStressCost": { "type": "integer", "minimum": 1 },
        "thresholds": { "type": "array", "minItems": 5, "maxItems": 5 },
        "sources": { "type": "object" }
      }
    }
  }
}
```

---

## 4. Database Schema

### 4.1 character_rage Table

```sql
CREATE TABLE IF NOT EXISTS character_rage (
    character_id UUID PRIMARY KEY REFERENCES characters(id) ON DELETE CASCADE,
    current_rage INT NOT NULL DEFAULT 0
        CONSTRAINT chk_rage_range CHECK (current_rage >= 0 AND current_rage <= 100),
    last_combat_time TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_character_rage_character_id
    ON character_rage(character_id);

CREATE INDEX idx_character_rage_combat_time
    ON character_rage(character_id, last_combat_time)
    WHERE last_combat_time IS NOT NULL;

COMMENT ON TABLE character_rage IS 'Stores Rage resource state for Berserker specialization';
COMMENT ON COLUMN character_rage.current_rage IS 'Current rage value (0-100)';
COMMENT ON COLUMN character_rage.last_combat_time IS 'Timestamp of last combat engagement for decay calculation';
```

### 4.2 character_momentum Table

```sql
CREATE TABLE IF NOT EXISTS character_momentum (
    character_id UUID PRIMARY KEY REFERENCES characters(id) ON DELETE CASCADE,
    current_momentum INT NOT NULL DEFAULT 0
        CONSTRAINT chk_momentum_range CHECK (current_momentum >= 0 AND current_momentum <= 100),
    consecutive_hits INT NOT NULL DEFAULT 0
        CONSTRAINT chk_consecutive_hits CHECK (consecutive_hits >= 0),
    last_action_time TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_character_momentum_character_id
    ON character_momentum(character_id);

CREATE INDEX idx_character_momentum_action_time
    ON character_momentum(character_id, last_action_time)
    WHERE last_action_time IS NOT NULL;

COMMENT ON TABLE character_momentum IS 'Stores Momentum resource state for Storm Blade specialization';
COMMENT ON COLUMN character_momentum.current_momentum IS 'Current momentum value (0-100)';
COMMENT ON COLUMN character_momentum.consecutive_hits IS 'Count of consecutive successful attacks for chain bonuses';
COMMENT ON COLUMN character_momentum.last_action_time IS 'Timestamp of last attack or movement for idle decay';
```

### 4.3 character_coherence Table

```sql
CREATE TABLE IF NOT EXISTS character_coherence (
    character_id UUID PRIMARY KEY REFERENCES characters(id) ON DELETE CASCADE,
    current_coherence INT NOT NULL DEFAULT 50
        CONSTRAINT chk_coherence_range CHECK (current_coherence >= 0 AND current_coherence <= 100),
    in_apotheosis BOOLEAN NOT NULL DEFAULT false,
    apotheosis_abilities_unlocked BOOLEAN NOT NULL DEFAULT false,
    turns_in_apotheosis INT NOT NULL DEFAULT 0
        CONSTRAINT chk_turns_in_apotheosis CHECK (turns_in_apotheosis >= 0),
    last_cast_time TIMESTAMP,
    is_combat BOOLEAN NOT NULL DEFAULT false,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_character_coherence_character_id
    ON character_coherence(character_id);

CREATE INDEX idx_character_coherence_apotheosis
    ON character_coherence(character_id, in_apotheosis)
    WHERE in_apotheosis = true;

CREATE INDEX idx_character_coherence_cast_time
    ON character_coherence(character_id, last_cast_time)
    WHERE last_cast_time IS NOT NULL;

COMMENT ON TABLE character_coherence IS 'Stores Coherence resource state for Arcanist specialization';
COMMENT ON COLUMN character_coherence.current_coherence IS 'Current coherence value (0-100), defaults to 50 (Balanced)';
COMMENT ON COLUMN character_coherence.in_apotheosis IS 'True if character is currently in Apotheosis state';
COMMENT ON COLUMN character_coherence.apotheosis_abilities_unlocked IS 'Persists across Apotheosis exits once unlocked';
COMMENT ON COLUMN character_coherence.turns_in_apotheosis IS 'Duration counter for stress cost management';
COMMENT ON COLUMN character_coherence.last_cast_time IS 'Timestamp of last spell cast for cascade tracking';
COMMENT ON COLUMN character_coherence.is_combat IS 'True when character is in combat (affects meditation availability)';
```

---

## 5. Repository Patterns

### 5.1 Repository Interface Extensions

```csharp
namespace RuneAndRust.Persistence.Repositories.Interfaces;

public interface IResourceRepository
{
    /// <summary>
    /// Loads rage state for a character, or creates new if not exists.
    /// </summary>
    Task<RageState> LoadOrCreateRageStateAsync(Guid characterId);

    /// <summary>
    /// Persists rage state changes.
    /// </summary>
    Task UpdateRageStateAsync(Guid characterId, RageState state);

    /// <summary>
    /// Loads momentum state for a character, or creates new if not exists.
    /// </summary>
    Task<MomentumState> LoadOrCreateMomentumStateAsync(Guid characterId);

    /// <summary>
    /// Persists momentum state changes.
    /// </summary>
    Task UpdateMomentumStateAsync(Guid characterId, MomentumState state);

    /// <summary>
    /// Loads coherence state for a character, or creates new if not exists.
    /// </summary>
    Task<CoherenceState> LoadOrCreateCoherenceStateAsync(Guid characterId);

    /// <summary>
    /// Persists coherence state changes.
    /// </summary>
    Task UpdateCoherenceStateAsync(Guid characterId, CoherenceState state);
}
```

---

## 6. Configuration Loading

### 6.1 Configuration Provider Interface

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Provides access to specialization resource configuration.
/// </summary>
public interface ISpecializationResourceConfiguration
{
    /// <summary>
    /// Gets rage configuration settings.
    /// </summary>
    RageConfigurationSection Rage { get; }

    /// <summary>
    /// Gets momentum configuration settings.
    /// </summary>
    MomentumConfigurationSection Momentum { get; }

    /// <summary>
    /// Gets coherence configuration settings.
    /// </summary>
    CoherenceConfigurationSection Coherence { get; }
}

public class RageConfigurationSection
{
    public int MaxValue { get; set; }
    public int DecayPerTurn { get; set; }
    public int DecayMinutesBeforeNonCombat { get; set; }
    public List<RageThresholdConfig> Thresholds { get; set; } = new();
    public Dictionary<string, RageSourceConfig> Sources { get; set; } = new();
}

public class RageThresholdConfig
{
    public string Name { get; set; }
    public int MinValue { get; set; }
    public int MaxValue { get; set; }
    public int SoakBonus { get; set; }
    public bool FearImmune { get; set; }
    public bool MustAttackNearest { get; set; }
    public int? PartyStressReduction { get; set; }
}

// Similar structures for MomentumConfigurationSection and CoherenceConfigurationSection
```

### 6.2 Configuration Loading in Startup

```csharp
// In Startup.cs or Program.cs:

services.Configure<SpecializationResourceConfiguration>(
    configuration.GetSection("SpecializationResources"));

services.AddScoped<ISpecializationResourceConfiguration>(provider =>
    provider.GetRequiredService<IOptions<SpecializationResourceConfiguration>>().Value);
```

---

## 7. Data Access Implementation

### 7.1 Repository Implementation Example

```csharp
namespace RuneAndRust.Persistence.Repositories;

public class ResourceRepository : IResourceRepository
{
    private readonly GameDbContext _context;
    private readonly ILogger<ResourceRepository> _logger;

    public ResourceRepository(GameDbContext context, ILogger<ResourceRepository> logger)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<RageState> LoadOrCreateRageStateAsync(Guid characterId)
    {
        try
        {
            var rageRecord = await _context.CharacterRage.FirstOrDefaultAsync(r => r.CharacterId == characterId);

            if (rageRecord == null)
            {
                _logger.LogInformation("Creating new rage state for character {CharacterId}", characterId);
                rageRecord = new CharacterRageRecord { CharacterId = characterId, CurrentRage = 0 };
                _context.CharacterRage.Add(rageRecord);
                await _context.SaveChangesAsync();
            }

            return RageState.Create(characterId, rageRecord.CurrentRage);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading rage state for character {CharacterId}", characterId);
            throw;
        }
    }

    public async Task UpdateRageStateAsync(Guid characterId, RageState state)
    {
        try
        {
            var rageRecord = await _context.CharacterRage.FirstOrDefaultAsync(r => r.CharacterId == characterId);

            if (rageRecord == null)
            {
                rageRecord = new CharacterRageRecord { CharacterId = characterId };
                _context.CharacterRage.Add(rageRecord);
            }

            rageRecord.CurrentRage = state.CurrentRage;
            rageRecord.LastCombatTime = state.LastCombatTime;
            rageRecord.UpdatedAt = DateTime.UtcNow;

            await _context.SaveChangesAsync();
            _logger.LogDebug("Updated rage state for character {CharacterId}", characterId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating rage state for character {CharacterId}", characterId);
            throw;
        }
    }

    // Similar implementations for momentum and coherence...
}
```

---

## 8. Logging Specifications

### 8.1 Configuration Loading Logs

| Event                    | Level       | Template                                                   |
| ------------------------ | ----------- | ---------------------------------------------------------- |
| Config loaded            | Information | `"Specialization resources config loaded from {Path}"`     |
| Config validation passed | Debug       | `"Config validation passed for {ResourceType}"`            |
| Config validation failed | Error       | `"Config validation failed: {Errors}"`                     |

### 8.2 Database Operation Logs

| Event                      | Level       | Template                                            |
| -------------------------- | ----------- | --------------------------------------------------- |
| State created              | Information | `"Created new {Resource} state for {CharacterId}"`  |
| State loaded               | Debug       | `"Loaded {Resource} state for {CharacterId}"`       |
| State updated              | Debug       | `"Updated {Resource} state for {CharacterId}"`      |
| Persistence error          | Error       | `"Error persisting {Resource}: {Message}"`          |

---

## 9. Unit Testing Requirements

### 9.1 Test File Locations

- `tests/RuneAndRust.Persistence.UnitTests/Configuration/SpecializationResourcesConfigTests.cs` (~1 test)
- `tests/RuneAndRust.Persistence.UnitTests/Repositories/ResourceRepositoryTests.cs` (~2 tests)

### 9.2 Required Tests

| Test Name                                      | Description                                         |
| ---------------------------------------------- | --------------------------------------------------- |
| `LoadConfiguration_ValidJson_ParsesCorrectly`  | Verify JSON config loads without errors            |
| `LoadOrCreateRageState_NewCharacter_CreatesNew`| Verify repository creates new state if not exists   |
| `UpdateRageState_ExistingRecord_PersistsChanges`| Verify updates persist to database correctly        |

### 9.3 Example Test

```csharp
[TestFixture]
public class ResourceRepositoryTests
{
    private ResourceRepository _repository;
    private Mock<GameDbContext> _mockContext;
    private Mock<ILogger<ResourceRepository>> _mockLogger;

    [SetUp]
    public void SetUp()
    {
        _mockContext = new Mock<GameDbContext>();
        _mockLogger = new Mock<ILogger<ResourceRepository>>();
        _repository = new ResourceRepository(_mockContext.Object, _mockLogger.Object);
    }

    [Test]
    public async Task LoadOrCreateRageState_NewCharacter_CreatesNewState()
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var rageDbSet = new List<CharacterRageRecord>().AsQueryable().BuildMockDbSet();
        _mockContext.Setup(c => c.CharacterRage).Returns(rageDbSet.Object);

        // Act
        var result = await _repository.LoadOrCreateRageStateAsync(characterId);

        // Assert
        result.Should().NotBeNull();
        result.CharacterId.Should().Be(characterId);
        result.CurrentRage.Should().Be(0);
        _mockContext.Verify(c => c.SaveChangesAsync(It.IsAny<CancellationToken>()), Times.Once);
    }
}
```

---

## 10. Deliverable Checklist

### 10.1 Configuration Files

- [ ] `config/specialization-resources.json`
- [ ] `config/schemas/specialization-resources.schema.json`

### 10.2 Database Schema

- [ ] Create migration: `Add_SpecializationResourcesTables`
- [ ] Apply migration to database

### 10.3 Repository Implementation

- [ ] `src/Persistence/RuneAndRust.Persistence/Repositories/ResourceRepository.cs`
- [ ] Update `IResourceRepository` interface in persistence project

### 10.4 Configuration Classes

- [ ] `src/Core/RuneAndRust.Application/Configuration/SpecializationResourceConfiguration.cs`
- [ ] `src/Core/RuneAndRust.Application/Configuration/RageConfigurationSection.cs`
- [ ] `src/Core/RuneAndRust.Application/Configuration/MomentumConfigurationSection.cs`
- [ ] `src/Core/RuneAndRust.Application/Configuration/CoherenceConfigurationSection.cs`

### 10.5 Tests

- [ ] `tests/RuneAndRust.Persistence.UnitTests/Configuration/SpecializationResourcesConfigTests.cs`
- [ ] `tests/RuneAndRust.Persistence.UnitTests/Repositories/ResourceRepositoryTests.cs`

### 10.6 Documentation

- [ ] Create `docs/design/v0.18.x/v0.18.4f-design-specification.md`
- [ ] Update `docs/design/v0.18.x/v0.18.4-scope-breakdown.md` (mark v0.18.4f complete)
- [ ] Create `docs/configuration/specialization-resources-guide.md` (usage guide)

---

## 11. Acceptance Criteria

### 11.1 Configuration Verification

- [ ] `specialization-resources.json` loads without errors
- [ ] `specialization-resources.schema.json` validates configuration
- [ ] All three resource sections (rage, momentum, coherence) present and valid
- [ ] Configuration values match domain constants

### 11.2 Database Verification

- [ ] All three tables created successfully
- [ ] Primary keys and foreign keys correct
- [ ] Constraints enforced properly
- [ ] Indexes created for performance

### 11.3 Repository Verification

- [ ] LoadOrCreate methods create new states for new characters
- [ ] Update methods persist changes correctly
- [ ] Load methods retrieve correct state for existing characters
- [ ] Timestamps updated on modifications

### 11.4 Build & Test Verification

- [ ] Solution builds without errors
- [ ] All new unit tests pass
- [ ] All existing tests continue to pass
- [ ] Configuration schema validation passes

---

## 12. Dependencies

### 12.1 Required from Previous Phases

| Item                | Provided By | Used For                    |
| ------------------- | ----------- | --------------------------- |
| RageService         | v0.18.4e    | Dependency in services      |
| MomentumService     | v0.18.4e    | Dependency in services      |
| CoherenceService    | v0.18.4e    | Dependency in services      |
| Domain entities     | v0.18.4a-c  | Database record mapping     |

### 12.2 Infrastructure Requirements

| Dependency          | Version | Usage                              |
| ------------------- | ------- | ---------------------------------- |
| GameDbContext       | v0.6.x+ | Database access and migrations    |
| IConfiguration      | .NET 6+ | Configuration loading             |
| IOptions<T>         | .NET 6+ | Options pattern for config        |

### 12.3 Deferred to Later Phases

| Item                        | Deferred To | Reason                        |
| --------------------------- | ----------- | ----------------------------- |
| Advanced config reloading   | v0.19.x     | Dynamic configuration support |
| Configuration UI            | v0.20.x     | Admin tools                   |

---

## 13. Future Considerations

### 13.1 v0.18.5 (Cross-Resource Interactions)

- Configuration for interaction thresholds
- Multi-resource state persistence in single transaction

### 13.2 v0.19.x (Effects and Abilities)

- Cascade effect table configuration
- Apotheosis ability definitions in config
- Dynamic threshold scaling

### 13.3 v0.20.x (Admin & Configuration)

- Configuration reload without restart
- Admin UI for resource balance tuning
- A/B testing configuration variants

---

## Migration Example

### 13.1 EF Core Migration

```csharp
public partial class AddSpecializationResourcesTables : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "character_rage",
            columns: table => new
            {
                character_id = table.Column<Guid>(nullable: false),
                current_rage = table.Column<int>(nullable: false, defaultValue: 0),
                last_combat_time = table.Column<DateTime>(nullable: true),
                updated_at = table.Column<DateTime>(nullable: false, defaultValueSql: "CURRENT_TIMESTAMP")
            },
            constraints: table =>
            {
                table.PrimaryKey("pk_character_rage", x => x.character_id);
                table.ForeignKey(
                    name: "fk_character_rage_characters",
                    column: x => x.character_id,
                    principalTable: "characters",
                    principalColumn: "id",
                    onDelete: ReferentialAction.Cascade);
                table.CheckConstraint("chk_rage_range", "current_rage >= 0 AND current_rage <= 100");
            });

        migrationBuilder.CreateIndex(
            name: "idx_character_rage_character_id",
            table: "character_rage",
            column: "character_id");

        // Similar for momentum and coherence tables...
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable("character_rage");
        migrationBuilder.DropTable("character_momentum");
        migrationBuilder.DropTable("character_coherence");
    }
}
```

---

## Changelog

| Version | Date       | Changes                              |
| ------- | ---------- | ------------------------------------ |
| 1.0     | 2026-01-28 | Initial configuration & persistence  |
