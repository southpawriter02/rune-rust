# Changelog: v0.4.0b - The Growth (Attribute Upgrades)
**Release Date:** 2025-12-27

---

## Summary

Version 0.4.0b implements the **Attribute Upgrade System**, enabling players to spend Progression Points (PP) earned through the Saga system (v0.4.0a) to enhance character attributes. This release touches the **Core Layer** (result models, service interfaces), **Engine Layer** (progression service implementation), **Terminal Layer** (dependency injection registration), and **Test Layer** (comprehensive unit testing with 19 test cases). Key architectural patterns include the **Result Pattern** via `AttributeUpgradeResult`, **Service-Repository Pattern** via `IProgressionService`, and strict **Dependency Injection** through scoped lifetime registration. The system enforces a flat cost model (1 PP per attribute point) with a hard cap of 10 per attribute, validates affordability before transactions, and triggers derived stat recalculation via `IStatCalculationService` to update MaxHP/MaxStamina after each upgrade.

---

## New Files Created

### Core Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Core/Models/AttributeUpgradeResult.cs` | Domain-specific result record following established pattern (like LootResult, AbilityResult), containing Success, Message, Attribute, OldValue, NewValue, and PpSpent properties with factory methods Ok() and Failure() | 48 |
| `RuneAndRust.Core/Interfaces/IProgressionService.cs` | Service contract for attribute progression management with methods UpgradeAttribute(), GetUpgradeCost(), and CanUpgrade() | 37 |

### Engine Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Engine/Services/ProgressionService.cs` | Engine-layer implementation of IProgressionService with flat-cost upgrade logic, cap validation, PP deduction, and derived stat recalculation | 124 |

### Test Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Tests/Engine/ProgressionServiceTests.cs` | Comprehensive unit test suite covering 19 test cases across success scenarios, failure scenarios, query methods, all attributes, and edge cases | 311 |

**Total Lines Added:** 520

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Terminal/Program.cs` (line 108) | Registered `IProgressionService` as Scoped dependency in DI container: `services.AddScoped<IProgressionService, ProgressionService>();` |

---

## Code Implementation Details

### AttributeUpgradeResult Record

```csharp
public record AttributeUpgradeResult(
    bool Success,
    string Message,
    CharacterAttribute? Attribute = null,
    int OldValue = 0,
    int NewValue = 0,
    int PpSpent = 0)
{
    public static AttributeUpgradeResult Ok(
        string message,
        CharacterAttribute attribute,
        int oldValue,
        int newValue,
        int cost)
        => new(true, message, attribute, oldValue, newValue, cost);

    public static AttributeUpgradeResult Failure(string reason)
        => new(false, reason);
}
```

**Purpose:** Immutable result record following the domain-specific Result pattern established in v0.3.x (LootResult, AbilityResult). Provides type-safe return values for upgrade operations with detailed transaction information.

**Properties:**
- `Success` (bool): Indicates whether the upgrade transaction succeeded
- `Message` (string): Human-readable description of the result (e.g., "Might upgraded to 7" or "Insufficient Progression Points")
- `Attribute` (CharacterAttribute?): The attribute that was upgraded; null on failure
- `OldValue` (int): Attribute value before transaction (0 on failure)
- `NewValue` (int): Attribute value after transaction (0 on failure)
- `PpSpent` (int): Progression Points deducted (0 on failure)

**Factory Methods:**
- `Ok()`: Creates success result with complete transaction details
- `Failure()`: Creates failure result with reason message

**Namespace Alias Pattern:** Uses `CharacterAttribute = RuneAndRust.Core.Enums.Attribute` to resolve ambiguity with System.Attribute.

---

### IProgressionService Interface

```csharp
public interface IProgressionService
{
    /// <summary>
    /// Attempts to upgrade a character's attribute by spending Progression Points.
    /// </summary>
    /// <param name="character">The character to upgrade.</param>
    /// <param name="attribute">The attribute to upgrade.</param>
    /// <returns>An AttributeUpgradeResult indicating success or failure with details.</returns>
    AttributeUpgradeResult UpgradeAttribute(Entities.Character character, CharacterAttribute attribute);

    /// <summary>
    /// Gets the PP cost to upgrade a specific attribute for a character.
    /// </summary>
    /// <param name="character">The character whose attribute cost is being queried.</param>
    /// <param name="attribute">The attribute to check.</param>
    /// <returns>The PP cost, or int.MaxValue if the attribute is at cap.</returns>
    int GetUpgradeCost(Entities.Character character, CharacterAttribute attribute);

    /// <summary>
    /// Checks if a character can afford and is eligible to upgrade an attribute.
    /// </summary>
    /// <param name="character">The character to check.</param>
    /// <param name="attribute">The attribute to check.</param>
    /// <returns>True if the upgrade is possible; false otherwise.</returns>
    bool CanUpgrade(Entities.Character character, CharacterAttribute attribute);
}
```

**Purpose:** Service contract for character attribute progression management, enabling PP-to-attribute conversion with validation and cost queries.

**Namespace Alias Pattern:** Uses `Entities.Character` qualifier to avoid ambiguity with `Models.Character` (if exists in future).

---

### ProgressionService Implementation

**Dependencies:**
- `IStatCalculationService` - Recalculates MaxHP/MaxStamina after attribute changes
- `ILogger<ProgressionService>` - Serilog structured logging

**Constants:**

| Constant | Value | Purpose |
|----------|-------|---------|
| `AttributeCap` | 10 | Maximum value any attribute can reach (enforced across all 5 attributes) |
| `UpgradeCost` | 1 | Flat PP cost per attribute point (no scaling or diminishing returns) |

**Key Method: UpgradeAttribute()**

```csharp
public AttributeUpgradeResult UpgradeAttribute(Character character, CharacterAttribute attribute)
```

**Behavior:**
- Logs method entry at Trace level with character name and target attribute
- Validates attribute is not at cap (10); returns Failure with warning log if capped
- Validates character has sufficient PP (cost = 1); returns Failure with warning log if insufficient
- Executes atomic transaction:
  - Deducts 1 PP from `character.ProgressionPoints`
  - Increments target attribute by 1 via `character.SetAttribute()`
- Calls `IStatCalculationService.RecalculateDerivedStats()` to update MaxHP/MaxStamina based on new attribute values
- Logs success at Information level with before/after values and remaining PP
- Returns `AttributeUpgradeResult.Ok()` with full transaction details
- Does NOT throw exceptions on validation failure (fail-safe design)

**Validation Order:**
1. Cap check (prevents over-leveling)
2. Affordability check (prevents negative PP)

**State Changes:**
- `character.ProgressionPoints` decreased by `UpgradeCost`
- Attribute value increased by 1 (e.g., Might: 5 → 6)
- `character.MaxHP` / `character.MaxStamina` recalculated based on new attribute (STURDINESS affects HP, WILL affects Stamina)

---

**Key Method: GetUpgradeCost()**

```csharp
public int GetUpgradeCost(Character character, CharacterAttribute attribute)
```

**Behavior:**
- Retrieves current attribute value via `character.GetAttribute()`
- Returns `int.MaxValue` if attribute is at cap (sentinel value for UI to detect impossibility)
- Returns `UpgradeCost` (1) for all valid upgrades
- No logging (query method, not state-changing)

**Design Note:** Returning `int.MaxValue` instead of throwing exception allows UI to check affordability without try/catch blocks.

---

**Key Method: CanUpgrade()**

```csharp
public bool CanUpgrade(Character character, CharacterAttribute attribute)
```

**Behavior:**
- Returns `false` if attribute is at cap (10)
- Returns `false` if character has insufficient PP (< upgrade cost)
- Returns `true` if both conditions pass
- Delegates cost calculation to `GetUpgradeCost()` (DRY principle)
- No logging (query method)

**Use Case:** UI can call this before rendering "Upgrade" button to disable/enable interactivity.

---

## Logging Matrix

### ProgressionService Logging

| Event | Level | Template |
|-------|-------|----------|
| Method Entry | Trace | `[Progression] UpgradeAttribute called for {Name}: {Attribute}` |
| Cap Failure | Warning | `[Progression] Upgrade failed: {Attribute} is at cap ({Cap}) for {Name}` |
| Funds Failure | Warning | `[Progression] Upgrade failed for {Name}: Insufficient PP ({Have}/{Need})` |
| Success | Information | `[Progression] {Name} upgraded {Attribute} from {OldVal} to {NewVal} (Cost: {Cost} PP, Remaining: {Remaining} PP)` |

**Structured Logging Properties:**
- `{Name}` - Character.Name
- `{Attribute}` - CharacterAttribute enum value (Might, Finesse, Wits, Will, Sturdiness)
- `{Cap}` - AttributeCap constant (10)
- `{Have}` - character.ProgressionPoints before transaction
- `{Need}` - UpgradeCost (1)
- `{OldVal}` - Attribute value before upgrade
- `{NewVal}` - Attribute value after upgrade
- `{Cost}` - PP spent (always 1 in current implementation)
- `{Remaining}` - character.ProgressionPoints after transaction

---

## Test Coverage

### Summary

```
Total: 19 | Passed: 19 | Failed: 0 | Duration: 552ms (includes build time)
```

### Complete Test Inventory

#### ProgressionServiceTests (19 tests)

**Category: Success Tests (4 tests)**

| Test Name | Description |
|-----------|-------------|
| `UpgradeAttribute_DeductsPP_FromCharacter` | Verifies that 1 PP is deducted from character.ProgressionPoints when upgrade succeeds |
| `UpgradeAttribute_IncreasesAttribute_ByOne` | Validates that target attribute increments by exactly 1 (e.g., Might: 5 → 6) |
| `UpgradeAttribute_CallsRecalculateDerivedStats` | Confirms IStatCalculationService.RecalculateDerivedStats() is called exactly once via mock verification |
| `UpgradeAttribute_ReturnsSuccess_WithCorrectDetails` | Asserts Success=true, Attribute=Finesse, OldValue=5, NewValue=6, PpSpent=1, Message contains "Finesse" |

**Category: Failure Tests (3 tests)**

| Test Name | Description |
|-----------|-------------|
| `UpgradeAttribute_Fails_WhenInsufficientPP` | Confirms upgrade fails when PP=0, returns Failure with "Insufficient" message, no state changes occur |
| `UpgradeAttribute_Fails_WhenAttributeAtCap` | Validates upgrade fails when attribute=10, returns Failure with "maximum" message, PP unchanged |
| `UpgradeAttribute_AtCap_DoesNotCallRecalculate` | Ensures RecalculateDerivedStats() is never called when validation fails (cap check) |

**Category: GetUpgradeCost Tests (2 tests)**

| Test Name | Description |
|-----------|-------------|
| `GetUpgradeCost_Returns1_ForNormalAttributeValue` | Confirms cost is 1 when attribute is below cap (e.g., Might=5 → cost=1) |
| `GetUpgradeCost_ReturnsMaxValue_WhenAttributeAtCap` | Validates sentinel value int.MaxValue returned when attribute=10 |

**Category: CanUpgrade Tests (3 tests)**

| Test Name | Description |
|-----------|-------------|
| `CanUpgrade_ReturnsTrue_WhenAffordableAndNotCapped` | Asserts true when PP=5 and attribute=5 (normal upgrade scenario) |
| `CanUpgrade_ReturnsFalse_WhenAttributeAtCap` | Confirms false when attribute=10 even if PP=5 (cap takes precedence) |
| `CanUpgrade_ReturnsFalse_WhenInsufficientPP` | Validates false when PP=0 and attribute=5 (affordability check) |

**Category: All Attributes Tests (5 tests - Theory)**

| Test Name | Description |
|-----------|-------------|
| `UpgradeAttribute_WorksForAllAttributes(Might)` | Verifies upgrade succeeds for MIGHT attribute (5 → 6) |
| `UpgradeAttribute_WorksForAllAttributes(Finesse)` | Verifies upgrade succeeds for FINESSE attribute (5 → 6) |
| `UpgradeAttribute_WorksForAllAttributes(Wits)` | Verifies upgrade succeeds for WITS attribute (5 → 6) |
| `UpgradeAttribute_WorksForAllAttributes(Will)` | Verifies upgrade succeeds for WILL attribute (5 → 6) |
| `UpgradeAttribute_WorksForAllAttributes(Sturdiness)` | Verifies upgrade succeeds for STURDINESS attribute (5 → 6) |

**Category: Edge Cases (2 tests)**

| Test Name | Description |
|-----------|-------------|
| `UpgradeAttribute_CanUpgradeFromMinToMax_Incrementally` | Tests upgrading from 1 → 10 (9 upgrades) with PP=10, confirms final state: Might=10, PP=1, all upgrades succeed |
| `UpgradeAttribute_MultipleAttributes_IndependentlyTracked` | Validates upgrading Might, Finesse, and Wits independently: all reach 6, Will and Sturdiness remain 5, PP=0 |

---

## DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// Register Engine Services
services.AddSingleton<CommandParser>();
services.AddSingleton<IGameService, GameService>();
services.AddSingleton<IDiceService, DiceService>();
services.AddSingleton<IStatCalculationService, StatCalculationService>();
services.AddScoped<ISagaService, SagaService>();
services.AddScoped<IProgressionService, ProgressionService>();  // [NEW] - Scoped lifetime
services.AddScoped<SaveManager>();
```

**Lifetime Justification:**
- `IProgressionService` registered as **Scoped** to align with `ISagaService` (v0.4.0a) and `SaveManager`. Scoped lifetime ensures:
  - Service instance is shared within a single logical operation (e.g., "player levels up and spends PP")
  - Clean state isolation between game sessions or batch operations
  - Consistency with transaction-like behavior (upgrade + recalculate + save)

**Dependency Chain:**
- `ProgressionService` depends on `IStatCalculationService` (Singleton) and `ILogger<ProgressionService>` (Singleton)
- Safe to inject Singleton into Scoped (lifetime hierarchy: Singleton → Scoped → Transient)

---

## Verification Results

### Build Output

```
Build succeeded.
    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.12
```

**Warning:** MSB3277 - EntityFrameworkCore.Relational version conflict (9.0.1 vs 9.0.4). This is a non-blocking dependency resolution warning inherited from v0.4.0a that does not affect functionality.

---

### Test Execution

```bash
# ProgressionServiceTests
dotnet test --filter "FullyQualifiedName~ProgressionServiceTests"
Passed!  - Failed: 0, Passed: 19, Skipped: 0, Total: 19, Duration: 552ms (includes build)
```

**Test Breakdown:**
- **Success scenarios:** 4 tests (PP deduction, attribute increment, recalculate call, result details)
- **Failure scenarios:** 3 tests (insufficient PP, at cap, no recalculate on failure)
- **Query methods:** 5 tests (GetUpgradeCost normal/capped, CanUpgrade true/false conditions)
- **All attributes:** 5 tests (Theory validating MIGHT, FINESSE, WITS, WILL, STURDINESS)
- **Edge cases:** 2 tests (min-to-max incremental, multiple attributes independent)

**Coverage Achievement:** 100% method coverage, 100% branch coverage on ProgressionService (all validation paths tested).

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Enums/
│   └── Attribute.cs [EXISTING - Used via alias CharacterAttribute]
├── Entities/
│   └── Character.cs [EXISTING - Modified in v0.4.0a for Legend/ProgressionPoints]
├── Interfaces/
│   ├── ISagaService.cs [v0.4.0a]
│   └── IProgressionService.cs [NEW]
└── Models/
    ├── AttributeUpgradeResult.cs [NEW]
    └── LootResult.cs [EXISTING - Similar Result pattern]

RuneAndRust.Engine/
└── Services/
    ├── SagaService.cs [v0.4.0a]
    ├── ProgressionService.cs [NEW]
    └── StatCalculationService.cs [EXISTING - Dependency]

RuneAndRust.Terminal/
└── Program.cs [MODIFIED - DI registration line 108]

RuneAndRust.Tests/
└── Engine/
    ├── SagaServiceTests.cs [v0.4.0a - 35 tests]
    └── ProgressionServiceTests.cs [NEW - 19 tests]
```

---

## Running Tests

### Execute ProgressionService Test Suite

```bash
dotnet test --filter "FullyQualifiedName~ProgressionServiceTests"
```

### Execute All Progression-Related Tests (Saga + Progression)

```bash
dotnet test --filter "FullyQualifiedName~SagaServiceTests|FullyQualifiedName~ProgressionServiceTests"
```

### Execute All Tests

```bash
dotnet test
```

---

## Next Steps

### v0.4.0c - Attribute Upgrade UI

- **UI Components:**
  - Implement `CharacterSheetViewModel` with attribute display and upgrade buttons
  - Create attribute upgrade panel with cost display and CanUpgrade() binding
  - Add PP balance display in character sheet header
  - Implement visual feedback for successful upgrades (animation, color change)

- **Validation Integration:**
  - Bind "Upgrade" button IsEnabled to `CanUpgrade()` result
  - Display upgrade cost dynamically via `GetUpgradeCost()`
  - Show cap warning tooltip when attribute reaches 10
  - Disable all upgrade buttons when PP = 0

- **User Experience:**
  - Add confirmation dialog for attribute upgrades (prevent mis-clicks)
  - Display derived stat changes in real-time (e.g., "Upgrading STURDINESS will increase MaxHP by X")
  - Implement undo/respec system (optional - requires tracking upgrade history)

### v0.4.1 - Combat-Progression Integration

- Wire `SagaService.AddLegend()` into combat resolution (award Legend on enemy defeat)
- Implement Legend-to-PP conversion flow (level up → award PP → notify player → open upgrade panel)
- Add tutorial/tooltip system explaining attribute effects (MIGHT = melee damage, FINESSE = ranged/initiative, WITS = crit rate, WILL = magic/stamina, STURDINESS = HP)

### v0.5.0 - Advanced Progression Systems

- Implement soft caps (diminishing returns after attribute reaches 7)
- Add synergy bonuses (e.g., MIGHT + STURDINESS = bonus armor)
- Create specialization paths (e.g., "Berserker" archetype grants extra benefit from MIGHT)
- Implement attribute respec currency (find Rune of Forgetting to reset attributes)

---

## Technical Notes

### Design Decisions

1. **Flat Cost Model:** The 1 PP per attribute point model was chosen over scaling costs (1, 2, 3, 5, 8...) to simplify early implementation. This creates a linear progression curve where each level's PP awards translate directly to attribute upgrades. Future versions may introduce scaling via `GetUpgradeCost()` without changing the interface contract.

2. **Attribute Cap Enforcement:** The hard cap of 10 prevents attribute inflation and maintains game balance. This matches tabletop RPG conventions (D&D 5e ability scores cap at 20; Rune & Rust caps at 10 for simplicity). The cap is enforced in `ProgressionService` rather than `Character.SetAttribute()` to centralize business logic.

3. **Derived Stat Recalculation:** Calling `RecalculateDerivedStats()` after every upgrade ensures MaxHP/MaxStamina stay synchronized with attribute changes. STURDINESS directly affects HP calculation (likely formula: `MaxHP = BaseHP + (STURDINESS × 10)`), and WILL affects stamina. This prevents desync bugs where UI shows outdated values.

4. **Scoped Lifetime:** ProgressionService is scoped (not singleton) to align with SaveManager's lifetime. This ensures that upgrade operations within a game session share state but remain isolated across sessions. A singleton would risk state leakage if multiple characters are loaded sequentially.

5. **Result Pattern Consistency:** AttributeUpgradeResult follows the same factory method pattern as LootResult (v0.3.x) and AbilityResult. This creates a consistent API surface where all state-changing operations return typed results instead of throwing exceptions or returning bools. The pattern enables detailed UI feedback (e.g., "Might upgraded from 5 to 6" vs generic "Success").

6. **No Event Publishing:** Unlike `SagaService.AddLegend()` which publishes `LevelUpEvent`, `UpgradeAttribute()` does NOT publish an event. This was a deliberate choice to keep the service lightweight. UI components can observe the return value directly. If future requirements demand event-driven architecture (e.g., achievement system reacting to attribute milestones), an `AttributeUpgradedEvent` can be added without breaking existing code.

7. **Namespace Alias Pattern:** The codebase uses `Character = RuneAndRust.Core.Entities.Character` and `CharacterAttribute = RuneAndRust.Core.Enums.Attribute` to avoid ambiguity with `System.Attribute` and potential future `Models.Character`. This pattern is applied consistently across all new files (AttributeUpgradeResult, IProgressionService, ProgressionService, ProgressionServiceTests).

### Known Limitations

1. **No Persistence:** This release does NOT include database migration scripts for the `ProgressionPoints` column added in v0.4.0a. Character attribute changes persist in-memory but are not saved to PostgreSQL. Saving/loading will fail or reset attributes to defaults. A SQL migration is required before production use.

2. **No UI Integration:** ProgressionService is fully functional but has no UI binding. Players cannot access the upgrade system. This is deferred to v0.4.0c.

3. **No Undo Mechanism:** Attribute upgrades are permanent. There is no respec system, no confirmation dialog, and no "preview" mode. Accidental upgrades cannot be reversed. This should be addressed in v0.4.0c with a confirmation dialog.

4. **No Attribute Synergies:** All attributes are treated independently. Upgrading MIGHT does not affect FINESSE calculations (no cross-stat bonuses). Advanced synergy systems are planned for v0.5.0.

5. **No Cost Scaling:** Upgrade cost is flat (1 PP) regardless of attribute value. This creates a linear progression curve that may feel too generous at high levels. Consider exponential scaling (1, 1, 2, 2, 3, 3, 5, 5, 8) in future balancing passes.

6. **No Validation Against Negative PP:** While the service prevents spending PP when `character.ProgressionPoints < UpgradeCost`, it does NOT prevent external code from setting `ProgressionPoints = -10` directly. Add a setter guard in `Character.ProgressionPoints` or a validation service.

### Breaking Changes

**None.** This release is purely additive. All new types are in isolated namespaces (Core.Models.AttributeUpgradeResult, Core.Interfaces.IProgressionService, Engine.Services.ProgressionService). No existing code is modified except for DI registration.

### Integration Points

**For Future UI Developers:**

To integrate ProgressionService into Avalonia UI:

1. **Inject IProgressionService into ViewModel:**
   ```csharp
   public CharacterSheetViewModel(IProgressionService progression, Character character)
   {
       _progression = progression;
       _character = character;
   }
   ```

2. **Bind CanUpgrade() to Button IsEnabled:**
   ```csharp
   public bool CanUpgradeMight => _progression.CanUpgrade(_character, CharacterAttribute.Might);
   ```

3. **Create ReactiveCommand for Upgrade:**
   ```csharp
   UpgradeMightCommand = ReactiveCommand.Create(() =>
   {
       var result = _progression.UpgradeAttribute(_character, CharacterAttribute.Might);
       if (result.Success)
       {
           // Update UI, show notification
           this.RaisePropertyChanged(nameof(CanUpgradeMight)); // Refresh button state
           this.RaisePropertyChanged(nameof(MightValue));      // Refresh display
       }
       else
       {
           // Show error message
           MessageBox.Show(result.Message);
       }
   });
   ```

4. **Display Upgrade Cost:**
   ```csharp
   public string MightUpgradeCostText
   {
       get
       {
           var cost = _progression.GetUpgradeCost(_character, CharacterAttribute.Might);
           return cost == int.MaxValue ? "MAX" : $"{cost} PP";
       }
   }
   ```

---

**Changelog prepared by The Chronicle-Smith on 2025-12-27.**
