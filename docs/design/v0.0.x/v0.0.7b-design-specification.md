# v0.0.7b Design Specification: Weapon System

**Version:** 0.0.7b
**Parent:** v0.0.7 (Equipment System)
**Prerequisites:** v0.0.7a Complete (Core Equipment Infrastructure), v0.0.5c Complete (Combat Integration)
**Status:** Design Complete

---

## Table of Contents

1. [Overview](#overview)
2. [Scope](#scope)
3. [Data Model](#data-model)
4. [Services](#services)
5. [Command Changes](#command-changes)
6. [Rendering Changes](#rendering-changes)
7. [Configuration](#configuration)
8. [Acceptance Criteria](#acceptance-criteria)
9. [Test Specifications](#test-specifications)
10. [Dependencies](#dependencies)

---

## Overview

### Purpose

Implement weapon types with distinct damage dice pools and integrate with the combat system so equipped weapons determine attack damage. This phase transforms weapons from simple inventory items into combat-affecting equipment with unique characteristics per weapon type.

### Key Changes

| Area | Current State (v0.0.7a) | Target State (v0.0.7b) |
|------|-------------------------|------------------------|
| Item Entity | Has `EquipmentSlot` for equipping | Adds `DamageDice`, `WeaponType`, `WeaponBonuses` |
| Combat | Uses static damage formula (Attack - Defense) | Uses equipped weapon's damage dice via `DiceService` |
| Unarmed Combat | N/A (no weapon system) | Uses 1d4 base damage (incentivizes weapons) |
| Weapon Types | N/A | 4 types: Sword, Axe, Dagger, Staff |

### Design Principles

1. **Dice Integration**: Weapons use the v0.0.5 `DicePool` system for damage, leveraging existing parsing and rolling infrastructure
2. **Combat Enhancement**: Equipped weapons meaningfully affect combat outcomes through damage dice and bonuses
3. **Extensibility**: Weapon system supports future additions (two-handed, dual-wield) without breaking changes
4. **Data-Driven**: Weapon definitions loaded from configuration, not hardcoded

---

## Scope

### In Scope

- `WeaponType` enum (Sword, Axe, Dagger, Staff)
- `DamageDice` property on `Item` (dice notation string, e.g., "1d8")
- `WeaponType?` property on `Item`
- `WeaponBonuses` property on `Item` for weapon-specific stat bonuses
- Update `CombatService` to use equipped weapon's damage dice
- Unarmed combat with reduced base damage (1d4)
- `weapons.json` configuration file with weapon definitions
- Combat output showing weapon name in attack messages

### Out of Scope (Future Phases)

- Armor defense bonuses (v0.0.7c)
- General stat modifiers from equipment (v0.0.7c)
- Equipment requirements (v0.0.7c)
- Two-handed weapons (future)
- Dual-wielding (future)
- Weapon enchantments (future)
- Weapon durability (future)

---

## Data Model

### New: WeaponType (Enum)

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the type of weapon, affecting combat style and bonuses.
/// </summary>
/// <remarks>
/// Each weapon type has distinct characteristics:
/// - Swords: Balanced, reliable damage
/// - Axes: High damage, accuracy penalty
/// - Daggers: Low damage, Finesse bonus
/// - Staffs: Moderate damage, Will bonus
/// </remarks>
public enum WeaponType
{
    /// <summary>Balanced melee weapons. Standard damage, no special modifiers.</summary>
    Sword,

    /// <summary>Heavy chopping weapons. Higher damage dice, attack roll penalty.</summary>
    Axe,

    /// <summary>Quick, precise weapons. Lower damage dice, Finesse bonus.</summary>
    Dagger,

    /// <summary>Magic-focused weapons. Moderate damage, Will bonus.</summary>
    Staff
}
```

### New: WeaponBonuses (Value Object)

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents stat bonuses provided by a weapon when equipped.
/// </summary>
/// <param name="Might">Bonus to Might attribute.</param>
/// <param name="Fortitude">Bonus to Fortitude attribute.</param>
/// <param name="Will">Bonus to Will attribute.</param>
/// <param name="Wits">Bonus to Wits attribute.</param>
/// <param name="Finesse">Bonus to Finesse attribute.</param>
/// <param name="AttackModifier">Flat bonus/penalty to attack rolls.</param>
public readonly record struct WeaponBonuses(
    int Might = 0,
    int Fortitude = 0,
    int Will = 0,
    int Wits = 0,
    int Finesse = 0,
    int AttackModifier = 0)
{
    /// <summary>
    /// Returns true if this weapon provides any bonuses.
    /// </summary>
    public bool HasBonuses => Might != 0 || Fortitude != 0 || Will != 0 ||
                              Wits != 0 || Finesse != 0 || AttackModifier != 0;

    /// <summary>
    /// Creates an empty bonuses instance (no bonuses).
    /// </summary>
    public static WeaponBonuses None => new();

    /// <summary>
    /// Creates bonuses for a Finesse-based weapon.
    /// </summary>
    public static WeaponBonuses ForFinesse(int bonus) => new(Finesse: bonus);

    /// <summary>
    /// Creates bonuses for a Will-based weapon.
    /// </summary>
    public static WeaponBonuses ForWill(int bonus) => new(Will: bonus);

    /// <summary>
    /// Creates bonuses with an attack modifier.
    /// </summary>
    public static WeaponBonuses ForAttack(int modifier) => new(AttackModifier: modifier);

    /// <summary>
    /// Returns a display string of non-zero bonuses.
    /// </summary>
    public override string ToString()
    {
        var parts = new List<string>();
        if (Might != 0) parts.Add($"{(Might > 0 ? "+" : "")}{Might} Might");
        if (Fortitude != 0) parts.Add($"{(Fortitude > 0 ? "+" : "")}{Fortitude} Fortitude");
        if (Will != 0) parts.Add($"{(Will > 0 ? "+" : "")}{Will} Will");
        if (Wits != 0) parts.Add($"{(Wits > 0 ? "+" : "")}{Wits} Wits");
        if (Finesse != 0) parts.Add($"{(Finesse > 0 ? "+" : "")}{Finesse} Finesse");
        if (AttackModifier != 0) parts.Add($"{(AttackModifier > 0 ? "+" : "")}{AttackModifier} Attack");
        return parts.Count > 0 ? string.Join(", ", parts) : "None";
    }
}
```

### Modified: Item (Entity)

```csharp
// Add to existing Item entity:

/// <summary>
/// Gets the damage dice notation for this weapon (e.g., "1d8", "2d6").
/// </summary>
/// <remarks>
/// Only applicable to weapon items. Uses the DicePool.Parse() format from v0.0.5.
/// Returns null for non-weapon items.
/// </remarks>
public string? DamageDice { get; private set; }

/// <summary>
/// Gets the type of weapon this item is, or null if not a weapon.
/// </summary>
/// <remarks>
/// Weapon type affects combat characteristics and available bonuses.
/// Items with WeaponType must also have EquipmentSlot.Weapon.
/// </remarks>
public WeaponType? WeaponType { get; private set; }

/// <summary>
/// Gets the stat bonuses provided by this weapon when equipped.
/// </summary>
/// <remarks>
/// Bonuses are applied while the weapon is equipped and removed when unequipped.
/// </remarks>
public WeaponBonuses WeaponBonuses { get; private set; } = WeaponBonuses.None;

/// <summary>
/// Gets whether this item is a weapon.
/// </summary>
public bool IsWeapon => WeaponType.HasValue && EquipmentSlot == Enums.EquipmentSlot.Weapon;

/// <summary>
/// Gets the parsed damage dice pool for combat calculations.
/// </summary>
/// <returns>The DicePool for this weapon, or null if not a weapon.</returns>
/// <exception cref="FormatException">Thrown if DamageDice notation is invalid.</exception>
public DicePool? GetDamageDicePool()
{
    if (string.IsNullOrWhiteSpace(DamageDice))
        return null;

    return DicePool.Parse(DamageDice);
}

// Update constructor to accept weapon properties:
public Item(
    string name,
    string description,
    ItemType type,
    int value = 0,
    ItemEffect effect = ItemEffect.None,
    int effectValue = 0,
    int effectDuration = 0,
    EquipmentSlot? equipmentSlot = null,
    string? damageDice = null,           // NEW
    WeaponType? weaponType = null,       // NEW
    WeaponBonuses? weaponBonuses = null) // NEW
{
    Id = Guid.NewGuid();
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Description = description ?? throw new ArgumentNullException(nameof(description));
    Type = type;
    Value = value;
    Effect = effect;
    EffectValue = effectValue;
    EffectDuration = effectDuration;
    EquipmentSlot = equipmentSlot;
    DamageDice = damageDice;
    WeaponType = weaponType;
    WeaponBonuses = weaponBonuses ?? WeaponBonuses.None;
}

// Update factory method:
public static Item CreateSword() => new(
    "Rusty Sword",
    "An old sword covered in rust. Still sharp enough to cut.",
    ItemType.Weapon,
    value: 5,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d8",
    weaponType: Enums.WeaponType.Sword
);

// Add new factory methods for each weapon type:
public static Item CreateIronSword() => new(
    "Iron Sword",
    "A standard iron sword. Reliable and balanced.",
    ItemType.Weapon,
    value: 50,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d8",
    weaponType: Enums.WeaponType.Sword
);

public static Item CreateBattleAxe() => new(
    "Battle Axe",
    "A heavy two-handed axe. Hits hard but swings slow.",
    ItemType.Weapon,
    value: 75,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d10",
    weaponType: Enums.WeaponType.Axe,
    weaponBonuses: WeaponBonuses.ForAttack(-1)
);

public static Item CreateSteelDagger() => new(
    "Steel Dagger",
    "A quick, precise blade favored by rogues.",
    ItemType.Weapon,
    value: 40,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d4",
    weaponType: Enums.WeaponType.Dagger,
    weaponBonuses: WeaponBonuses.ForFinesse(2)
);

public static Item CreateOakStaff() => new(
    "Oak Staff",
    "A sturdy wooden staff imbued with minor magic.",
    ItemType.Weapon,
    value: 45,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d6",
    weaponType: Enums.WeaponType.Staff,
    weaponBonuses: WeaponBonuses.ForWill(2)
);
```

---

## Services

### Modified: CombatService

```csharp
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Handles combat resolution between players and monsters.
/// </summary>
/// <remarks>
/// Combat flow:
/// 1. Player attack roll (1d10 + Finesse + weapon attack modifier) vs Monster Defense
/// 2. On hit, damage roll (weapon dice + Might) - (Monster Defense / 2)
/// 3. Monster counterattack if alive
/// </remarks>
public class CombatService
{
    /// <summary>
    /// Default damage dice for unarmed combat.
    /// </summary>
    public static readonly DicePool UnarmedDamageDice = DicePool.D4();

    /// <summary>
    /// Default damage dice when no weapon system is active (fallback).
    /// </summary>
    public static readonly DicePool DefaultWeaponDice = DicePool.D6();

    private readonly Random _random = new();
    private readonly ILogger<CombatService> _logger;
    private readonly DiceService? _diceService;

    /// <summary>
    /// Creates a new combat service instance.
    /// </summary>
    /// <param name="logger">Optional logger for combat diagnostics.</param>
    /// <param name="diceService">Optional dice service for dice-based combat.</param>
    public CombatService(ILogger<CombatService>? logger = null, DiceService? diceService = null)
    {
        _logger = logger ?? NullLogger<CombatService>.Instance;
        _diceService = diceService;
        _logger.LogDebug("CombatService initialized with DiceService: {HasDiceService}", _diceService != null);
    }

    /// <summary>
    /// Gets the damage dice pool for a player based on their equipped weapon.
    /// </summary>
    /// <param name="player">The player to get damage dice for.</param>
    /// <returns>The appropriate DicePool for the player's attack.</returns>
    /// <remarks>
    /// Priority:
    /// 1. Equipped weapon's DamageDice
    /// 2. UnarmedDamageDice (1d4) if no weapon equipped
    /// </remarks>
    public DicePool GetPlayerDamageDice(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var equippedWeapon = player.GetEquippedItem(EquipmentSlot.Weapon);

        if (equippedWeapon == null)
        {
            _logger.LogDebug("Player {Player} has no weapon equipped, using unarmed dice: {Dice}",
                player.Name, UnarmedDamageDice);
            return UnarmedDamageDice;
        }

        var weaponDice = equippedWeapon.GetDamageDicePool();
        if (weaponDice == null)
        {
            _logger.LogWarning(
                "Equipped weapon {Weapon} has no damage dice, using default: {Dice}",
                equippedWeapon.Name, DefaultWeaponDice);
            return DefaultWeaponDice;
        }

        _logger.LogDebug("Player {Player} using weapon {Weapon} with dice: {Dice}",
            player.Name, equippedWeapon.Name, weaponDice);

        return weaponDice.Value;
    }

    /// <summary>
    /// Gets the equipped weapon's name for combat messages.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>The weapon name, or "fists" if unarmed.</returns>
    public string GetPlayerWeaponName(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var weapon = player.GetEquippedItem(EquipmentSlot.Weapon);
        return weapon?.Name ?? "fists";
    }

    /// <summary>
    /// Gets the attack roll modifier from the player's equipped weapon.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>The attack modifier from weapon bonuses.</returns>
    public int GetWeaponAttackModifier(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var weapon = player.GetEquippedItem(EquipmentSlot.Weapon);
        return weapon?.WeaponBonuses.AttackModifier ?? 0;
    }

    /// <summary>
    /// Gets total attribute bonuses from the player's equipped weapon.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>The weapon bonuses, or None if no weapon equipped.</returns>
    public WeaponBonuses GetWeaponBonuses(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var weapon = player.GetEquippedItem(EquipmentSlot.Weapon);
        return weapon?.WeaponBonuses ?? WeaponBonuses.None;
    }

    /// <summary>
    /// Resolves a single round of combat between a player and a monster.
    /// </summary>
    /// <param name="player">The player engaging in combat.</param>
    /// <param name="monster">The monster being fought.</param>
    /// <returns>A <see cref="CombatResult"/> containing the outcome of the combat round.</returns>
    /// <remarks>
    /// If DiceService is available, uses dice-based combat:
    /// - Attack: 1d10 + Finesse + Weapon Attack Modifier vs Defense
    /// - Damage: Weapon Dice + Might - (Defense / 2)
    ///
    /// Otherwise falls back to static calculation (legacy behavior).
    /// </remarks>
    public CombatResult ResolveCombatRound(Player player, Monster monster)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(monster);

        var weaponName = GetPlayerWeaponName(player);
        _logger.LogDebug(
            "Resolving combat round - Player: {PlayerName} with {Weapon} vs Monster: {MonsterName}",
            player.Name, weaponName, monster.Name);

        // Use dice-based combat if DiceService available
        if (_diceService != null)
        {
            return ResolveCombatRoundWithDice(player, monster);
        }

        // Legacy static combat (fallback)
        return ResolveCombatRoundStatic(player, monster);
    }

    /// <summary>
    /// Resolves combat using dice-based mechanics.
    /// </summary>
    private CombatResult ResolveCombatRoundWithDice(Player player, Monster monster)
    {
        // Get weapon info
        var damageDice = GetPlayerDamageDice(player);
        var weaponAttackMod = GetWeaponAttackModifier(player);
        var weaponBonuses = GetWeaponBonuses(player);

        // Calculate effective Finesse (base + weapon bonus)
        var effectiveFinesse = player.Attributes.Finesse + weaponBonuses.Finesse;

        // Attack roll: 1d10 + Finesse + Weapon Attack Modifier
        var attackRoll = _diceService!.Roll(DicePool.D10());
        var attackTotal = attackRoll.Total + effectiveFinesse + weaponAttackMod;

        var isHit = attackTotal >= monster.Stats.Defense || attackRoll.IsNaturalMax;
        var isCriticalHit = attackRoll.IsNaturalMax;
        var isCriticalMiss = attackRoll.IsNaturalOne;

        int playerDamage = 0;

        if (isHit && !isCriticalMiss)
        {
            // Double dice on critical hit
            var actualDamageDice = isCriticalHit
                ? damageDice with { Count = damageDice.Count * 2 }
                : damageDice;

            // Calculate effective Might (base + weapon bonus)
            var effectiveMight = player.Attributes.Might + weaponBonuses.Might;

            // Damage roll: Weapon Dice + Might - Armor
            var damageRoll = _diceService.Roll(actualDamageDice);
            var armorReduction = monster.Stats.Defense / 2;
            playerDamage = Math.Max(1, damageRoll.Total + effectiveMight - armorReduction);

            monster.TakeDamage(playerDamage);

            _logger.LogDebug(
                "Player attack: Roll={Roll}+{Finesse}+{WeaponMod}={Total} vs DEF {Defense} -> HIT. " +
                "Damage: {DamageDice}={DamageRoll}+{Might}-{Armor}={FinalDamage}",
                attackRoll.Total, effectiveFinesse, weaponAttackMod, attackTotal, monster.Stats.Defense,
                actualDamageDice, damageRoll.Total, effectiveMight, armorReduction, playerDamage);
        }
        else
        {
            _logger.LogDebug(
                "Player attack: Roll={Roll}+{Finesse}+{WeaponMod}={Total} vs DEF {Defense} -> MISS",
                attackRoll.Total, effectiveFinesse, weaponAttackMod, attackTotal, monster.Stats.Defense);
        }

        // Monster counterattack
        var monsterDamage = 0;
        if (monster.IsAlive)
        {
            monsterDamage = CalculateDamage(monster.Stats.Attack, player.Stats.Defense);
            player.TakeDamage(monsterDamage);
        }

        return new CombatResult(
            DamageDealt: playerDamage,
            DamageReceived: monsterDamage,
            MonsterDefeated: monster.IsDefeated,
            PlayerDefeated: player.IsDead
        );
    }

    /// <summary>
    /// Resolves combat using static calculations (legacy).
    /// </summary>
    private CombatResult ResolveCombatRoundStatic(Player player, Monster monster)
    {
        var playerDamage = CalculateDamage(player.Stats.Attack, monster.Stats.Defense);
        monster.TakeDamage(playerDamage);

        var monsterDamage = 0;
        if (monster.IsAlive)
        {
            monsterDamage = CalculateDamage(monster.Stats.Attack, player.Stats.Defense);
            player.TakeDamage(monsterDamage);
        }

        return new CombatResult(
            DamageDealt: playerDamage,
            DamageReceived: monsterDamage,
            MonsterDefeated: monster.IsDefeated,
            PlayerDefeated: player.IsDead
        );
    }

    /// <summary>
    /// Calculates damage using static formula (legacy).
    /// </summary>
    private int CalculateDamage(int attack, int defense)
    {
        var baseDamage = Math.Max(1, attack - defense);
        var variance = _random.Next(-2, 3);
        return Math.Max(1, baseDamage + variance);
    }

    // ... existing methods (MonsterAttack, GetCombatDescription, etc.)
}
```

### Service Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    COMBAT ROUND FLOW (with Weapons)                          │
└─────────────────────────────────────────────────────────────────────────────┘

    ResolveCombatRound(player, monster)
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 1: GET WEAPON INFO                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  weapon = player.GetEquippedItem(EquipmentSlot.Weapon)                      │
│  ├── Has weapon? Use weapon.DamageDice, weapon.WeaponBonuses                │
│  └── No weapon? Use UnarmedDamageDice (1d4), no bonuses                     │
└─────────────────────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 2: ATTACK ROLL                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│  Roll 1d10                                                                   │
│  + Finesse (base + weapon bonus)                                            │
│  + Weapon Attack Modifier                                                    │
│  ────────────────────────────                                                │
│  = Attack Total                                                              │
│                                                                              │
│  Compare to Monster Defense:                                                 │
│  ├── Total >= Defense OR Natural 10 → HIT                                   │
│  ├── Natural 10 → CRITICAL HIT                                              │
│  └── Natural 1 → CRITICAL MISS (always misses)                              │
└─────────────────────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 3: DAMAGE ROLL (if hit)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  Dice = Weapon Damage Dice (doubled on critical)                            │
│  Roll Weapon Dice                                                            │
│  + Might (base + weapon bonus)                                              │
│  - Monster Defense / 2 (armor reduction)                                    │
│  ────────────────────────────                                                │
│  = Final Damage (minimum 1)                                                 │
│                                                                              │
│  monster.TakeDamage(finalDamage)                                            │
└─────────────────────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 4: MONSTER COUNTERATTACK                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  If monster.IsAlive:                                                         │
│    Calculate monster damage (static formula for now)                        │
│    player.TakeDamage(monsterDamage)                                         │
└─────────────────────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 5: RETURN RESULT                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  CombatResult {                                                              │
│    DamageDealt, DamageReceived,                                             │
│    MonsterDefeated, PlayerDefeated                                          │
│  }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Command Changes

### Updated Attack Command Output

The existing `attack` command remains unchanged, but combat output now includes weapon information:

```csharp
// In GameSessionService or CombatService

/// <summary>
/// Gets a combat description that includes weapon information.
/// </summary>
public string GetCombatDescriptionWithWeapon(
    CombatResult result,
    string playerName,
    string monsterName,
    string weaponName)
{
    var lines = new List<string>();

    if (weaponName == "fists")
    {
        lines.Add($"{playerName} attacks the {monsterName} with bare fists!");
    }
    else
    {
        lines.Add($"{playerName} attacks the {monsterName} with the {weaponName}!");
    }

    if (result.DamageDealt > 0)
    {
        lines.Add($"Hit! {result.DamageDealt} damage dealt.");
    }
    else
    {
        lines.Add("The attack misses!");
    }

    if (result.MonsterDefeated)
    {
        lines.Add($"The {monsterName} has been defeated!");
    }
    else if (result.DamageReceived > 0)
    {
        lines.Add($"The {monsterName} strikes back for {result.DamageReceived} damage!");
    }

    if (result.PlayerDefeated)
    {
        lines.Add($"{playerName} has fallen in battle...");
    }

    return string.Join(Environment.NewLine, lines);
}
```

### User Commands

| Command | Description | Example |
|---------|-------------|---------|
| `attack <target>` | Attack with equipped weapon | `attack goblin` |
| `equipment` | Shows equipped weapon and stats | `equipment` |

---

## Rendering Changes

### IGameRenderer Updates

```csharp
// The existing RenderCombatRoundAsync should be updated to show weapon info

/// <summary>
/// Renders a combat round result with weapon information.
/// </summary>
/// <param name="result">The combat result to display.</param>
/// <param name="weaponName">The name of the weapon used.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatRoundAsync(CombatResultDto result, string weaponName, CancellationToken ct = default);
```

### DTOs

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying weapon information.
/// </summary>
/// <param name="Name">The weapon's display name.</param>
/// <param name="WeaponType">The type of weapon (Sword, Axe, etc.).</param>
/// <param name="DamageDice">The damage dice notation (e.g., "1d8").</param>
/// <param name="Description">The weapon's description.</param>
/// <param name="Bonuses">String representation of weapon bonuses.</param>
public record WeaponDto(
    string Name,
    string WeaponType,
    string DamageDice,
    string Description,
    string? Bonuses = null)
{
    /// <summary>
    /// Creates a WeaponDto from an Item.
    /// </summary>
    public static WeaponDto? FromItem(Item item)
    {
        if (!item.IsWeapon || item.WeaponType == null)
            return null;

        return new WeaponDto(
            item.Name,
            item.WeaponType.Value.ToString(),
            item.DamageDice ?? "1d4",
            item.Description,
            item.WeaponBonuses.HasBonuses ? item.WeaponBonuses.ToString() : null);
    }
}
```

### Display Examples

**Equipment Command with Weapon:**
```
> equipment

╭─────────────────────────────────────────╮
│             ⚔ Equipment ⚔               │
├─────────────────────────────────────────┤
│  Weapon:  Iron Sword                    │
│           Type: Sword                   │
│           Damage: 1d8                   │
│                                         │
│  Armor:   (empty)                       │
│  Shield:  (empty)                       │
│  Helmet:  (empty)                       │
│  Boots:   (empty)                       │
│  Ring:    (empty)                       │
│  Amulet:  (empty)                       │
╰─────────────────────────────────────────╯
```

**Equipment Command with Dagger (bonuses):**
```
> equipment

╭─────────────────────────────────────────╮
│             ⚔ Equipment ⚔               │
├─────────────────────────────────────────┤
│  Weapon:  Steel Dagger                  │
│           Type: Dagger                  │
│           Damage: 1d4                   │
│           Bonuses: +2 Finesse           │
│                                         │
│  Armor:   (empty)                       │
│  ...                                    │
╰─────────────────────────────────────────╯
```

**Combat with Weapon:**
```
> attack goblin

You attack the Goblin with the Iron Sword!
Attack Roll: [14] + 3 (Finesse) = 17 vs Defense 12
Hit! Rolling damage...
Damage Roll: 1d8 [6] + 2 (Might) - 2 (Armor) = 6 damage!
The Goblin takes 6 damage. (HP: 30 -> 24)
```

**Unarmed Combat:**
```
> attack goblin

You attack the Goblin with your fists!
Attack Roll: [15] + 3 (Finesse) = 18 vs Defense 12
Hit! Rolling damage...
Damage Roll: 1d4 [3] + 2 (Might) - 2 (Armor) = 3 damage!
The Goblin takes 3 damage. (HP: 30 -> 27)
```

**Critical Hit:**
```
> attack goblin

You attack the Goblin with the Battle Axe!
Attack Roll: [10] + 2 (Finesse) - 1 (Weapon) = 11 vs Defense 12
CRITICAL HIT! (Natural 10)
Damage Roll: 2d10 [8, 7] + 2 (Might) - 2 (Armor) = 15 damage!
The Goblin takes 15 damage. (HP: 30 -> 15)
```

---

## Configuration

### weapons.json

```json
{
  "$schema": "weapons.schema.json",
  "weapons": [
    {
      "id": "rusty_sword",
      "name": "Rusty Sword",
      "description": "An old sword covered in rust. Still sharp enough to cut.",
      "weaponType": "Sword",
      "damageDice": "1d8",
      "value": 5
    },
    {
      "id": "iron_sword",
      "name": "Iron Sword",
      "description": "A standard iron sword. Reliable and balanced.",
      "weaponType": "Sword",
      "damageDice": "1d8",
      "value": 50
    },
    {
      "id": "steel_sword",
      "name": "Steel Sword",
      "description": "A finely crafted steel sword with excellent balance.",
      "weaponType": "Sword",
      "damageDice": "1d8+1",
      "value": 150
    },
    {
      "id": "battle_axe",
      "name": "Battle Axe",
      "description": "A heavy two-handed axe. Hits hard but swings slow.",
      "weaponType": "Axe",
      "damageDice": "1d10",
      "attackModifier": -1,
      "value": 75
    },
    {
      "id": "great_axe",
      "name": "Great Axe",
      "description": "An enormous axe capable of devastating blows.",
      "weaponType": "Axe",
      "damageDice": "2d6",
      "attackModifier": -2,
      "value": 200
    },
    {
      "id": "steel_dagger",
      "name": "Steel Dagger",
      "description": "A quick, precise blade favored by rogues.",
      "weaponType": "Dagger",
      "damageDice": "1d4",
      "statBonuses": { "finesse": 2 },
      "value": 40
    },
    {
      "id": "assassins_blade",
      "name": "Assassin's Blade",
      "description": "A wickedly sharp dagger perfect for striking vital points.",
      "weaponType": "Dagger",
      "damageDice": "1d4+2",
      "statBonuses": { "finesse": 3 },
      "value": 250
    },
    {
      "id": "oak_staff",
      "name": "Oak Staff",
      "description": "A sturdy wooden staff imbued with minor magic.",
      "weaponType": "Staff",
      "damageDice": "1d6",
      "statBonuses": { "will": 2 },
      "value": 45
    },
    {
      "id": "arcane_staff",
      "name": "Arcane Staff",
      "description": "A staff crackling with magical energy.",
      "weaponType": "Staff",
      "damageDice": "1d6+1",
      "statBonuses": { "will": 4 },
      "value": 300
    }
  ]
}
```

### Configuration Schema

| Property | Type | Required | Default | Description |
|----------|------|----------|---------|-------------|
| `id` | string | Yes | - | Unique identifier for the weapon |
| `name` | string | Yes | - | Display name |
| `description` | string | Yes | - | Item description |
| `weaponType` | string | Yes | - | One of: Sword, Axe, Dagger, Staff |
| `damageDice` | string | Yes | - | Dice notation (e.g., "1d8", "2d6+1") |
| `value` | int | No | 0 | Gold value |
| `attackModifier` | int | No | 0 | Bonus/penalty to attack rolls |
| `statBonuses` | object | No | null | Stat bonuses when equipped |
| `statBonuses.might` | int | No | 0 | Might bonus |
| `statBonuses.fortitude` | int | No | 0 | Fortitude bonus |
| `statBonuses.will` | int | No | 0 | Will bonus |
| `statBonuses.wits` | int | No | 0 | Wits bonus |
| `statBonuses.finesse` | int | No | 0 | Finesse bonus |

---

## Acceptance Criteria

### WeaponType Enum
- [ ] `WeaponType` enum contains Sword, Axe, Dagger, Staff
- [ ] Enum can be parsed from strings (case-insensitive)

### Item Entity
- [ ] Items have `DamageDice` property (nullable string)
- [ ] Items have `WeaponType` property (nullable)
- [ ] Items have `WeaponBonuses` property
- [ ] `IsWeapon` returns true only for weapon items
- [ ] `GetDamageDicePool()` parses and returns valid DicePool
- [ ] `CreateSword()` creates weapon with "1d8" damage
- [ ] Factory methods exist for all weapon types

### WeaponBonuses Value Object
- [ ] Can create bonuses with various attribute combinations
- [ ] `HasBonuses` correctly identifies non-zero bonuses
- [ ] `ToString()` formats bonuses for display
- [ ] Static factory methods work (ForFinesse, ForWill, ForAttack)

### CombatService
- [ ] `GetPlayerDamageDice()` returns weapon dice when equipped
- [ ] `GetPlayerDamageDice()` returns 1d4 when unarmed
- [ ] `GetPlayerWeaponName()` returns weapon name or "fists"
- [ ] `GetWeaponAttackModifier()` returns weapon attack modifier
- [ ] `GetWeaponBonuses()` returns weapon stat bonuses
- [ ] Combat uses weapon dice for damage rolls
- [ ] Weapon bonuses apply to effective stats
- [ ] Critical hits double damage dice
- [ ] Combat works correctly without weapon (unarmed)

### Configuration
- [ ] `weapons.json` loads successfully
- [ ] All 9 weapons defined with correct properties
- [ ] Weapons can be created from configuration

### Combat Output
- [ ] Attack messages include weapon name
- [ ] Unarmed attacks show "fists"
- [ ] Damage rolls show dice breakdown
- [ ] Critical hits are highlighted

### General
- [ ] ~15 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Test Specifications

### Unit Tests (~15 tests)

#### WeaponTypeTests.cs
```csharp
[TestFixture]
public class WeaponTypeTests
{
    [Test]
    public void WeaponType_ContainsAllExpectedValues();

    [Test]
    public void TryParse_ValidWeaponType_ReturnsTrue();

    [Test]
    public void TryParse_InvalidWeaponType_ReturnsFalse();
}
```

#### WeaponBonusesTests.cs
```csharp
[TestFixture]
public class WeaponBonusesTests
{
    [Test]
    public void None_HasNoBonuses();

    [Test]
    public void ForFinesse_CreatesFinesseBonus();

    [Test]
    public void ForWill_CreatesWillBonus();

    [Test]
    public void ForAttack_CreatesAttackModifier();

    [Test]
    public void HasBonuses_WithNonZeroValue_ReturnsTrue();

    [Test]
    public void HasBonuses_WithAllZeros_ReturnsFalse();

    [Test]
    public void ToString_FormatsCorrectly();
}
```

#### ItemWeaponTests.cs
```csharp
[TestFixture]
public class ItemWeaponTests
{
    [Test]
    public void CreateSword_HasWeaponProperties();

    [Test]
    public void CreateBattleAxe_HasAttackPenalty();

    [Test]
    public void CreateSteelDagger_HasFinesseBonus();

    [Test]
    public void CreateOakStaff_HasWillBonus();

    [Test]
    public void IsWeapon_WithWeaponItem_ReturnsTrue();

    [Test]
    public void IsWeapon_WithNonWeaponItem_ReturnsFalse();

    [Test]
    public void GetDamageDicePool_ReturnsValidPool();

    [Test]
    public void GetDamageDicePool_WithoutDamageDice_ReturnsNull();
}
```

#### CombatServiceWeaponTests.cs
```csharp
[TestFixture]
public class CombatServiceWeaponTests
{
    [Test]
    public void GetPlayerDamageDice_WithWeapon_ReturnsWeaponDice();

    [Test]
    public void GetPlayerDamageDice_Unarmed_ReturnsD4();

    [Test]
    public void GetPlayerWeaponName_WithWeapon_ReturnsName();

    [Test]
    public void GetPlayerWeaponName_Unarmed_ReturnsFists();

    [Test]
    public void GetWeaponAttackModifier_WithModifier_ReturnsValue();

    [Test]
    public void GetWeaponAttackModifier_NoWeapon_ReturnsZero();

    [Test]
    public void ResolveCombatRound_UsesWeaponDice();

    [Test]
    public void ResolveCombatRound_CriticalHit_DoublesDice();
}
```

---

## Dependencies

### Required from Previous Versions

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `EquipmentSlot` | `Domain/Enums/EquipmentSlot.cs` | Check Weapon slot |
| `Player.GetEquippedItem()` | `Domain/Entities/Player.cs` | Get equipped weapon |
| `DicePool` | `Domain/ValueObjects/DicePool.cs` | Parse weapon damage dice |
| `DiceService` | `Application/Services/DiceService.cs` | Roll damage dice |
| `CombatService` | `Domain/Services/CombatService.cs` | Modified for weapon integration |

### Provides to v0.0.7c

| Type | Usage |
|------|-------|
| `WeaponBonuses` | Template for ArmorBonuses/StatModifiers |
| Weapon integration pattern | Same pattern for armor defense |
| `GetWeaponBonuses()` | Combined with armor for effective stats |

### Provides to Future Versions

| Type | Usage |
|------|-------|
| `WeaponType` | Two-handed weapons, dual-wielding |
| `WeaponBonuses` | Enchantments, special effects |
| Configuration pattern | Other equipment configurations |

---

## Files Summary

### Files to Create (New)

| File | Purpose |
|------|---------|
| `src/Core/RuneAndRust.Domain/Enums/WeaponType.cs` | Weapon type enum |
| `src/Core/RuneAndRust.Domain/ValueObjects/WeaponBonuses.cs` | Weapon bonuses value object |
| `src/Core/RuneAndRust.Application/DTOs/WeaponDto.cs` | Weapon display DTO |
| `config/weapons.json` | Weapon definitions |
| `tests/RuneAndRust.Domain.UnitTests/Enums/WeaponTypeTests.cs` | Enum tests |
| `tests/RuneAndRust.Domain.UnitTests/ValueObjects/WeaponBonusesTests.cs` | Value object tests |
| `tests/RuneAndRust.Domain.UnitTests/Services/CombatServiceWeaponTests.cs` | Combat integration tests |

### Files to Modify

| File | Changes |
|------|---------|
| `src/Core/RuneAndRust.Domain/Entities/Item.cs` | Add DamageDice, WeaponType, WeaponBonuses properties |
| `src/Core/RuneAndRust.Domain/Services/CombatService.cs` | Use weapon dice for damage |
| `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs` | Show weapon in equipment display |
| `tests/RuneAndRust.Domain.UnitTests/Entities/ItemTests.cs` | Add weapon property tests |

---

*This design specification provides the detailed blueprint for implementing v0.0.7b Weapon System. This phase builds on v0.0.7a (Core Equipment Infrastructure) and integrates with v0.0.5's dice system to provide meaningful combat differentiation based on equipped weapons.*
