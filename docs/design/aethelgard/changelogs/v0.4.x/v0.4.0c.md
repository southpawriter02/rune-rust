# Changelog: v0.4.0c - The Shrine

**Release Date:** 2025-12-27

---

## Summary

Version 0.4.0c implements "The Shrine of Echoes" - a modal Saga UI screen that allows players to visualize Legend (XP) progression and spend Progression Points (PP) to upgrade character Attributes. This release introduces key-based modal input handling (distinct from the text-based command parsing used in other phases), a comprehensive ViewModel architecture for immutable state snapshots, and a rich Spectre.Console-based rendering system with color-coded attribute status indicators.

**Architectural Focus:** Modal UI Phase Management, ViewModel Pattern, Key-Based Input Handling, Service Integration
**Layers Touched:** Core (ViewModels, Enums, Interfaces), Engine (GameService, CommandParser), Terminal (Controllers, Rendering), Tests
**Key Patterns:** MVVM, Command Pattern, Dependency Injection, Immutable Data Transfer Objects

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/ViewModels/SagaViewModel.cs` | Immutable snapshot record for Saga UI state containing character name, level, Legend progress, PP balance, selected attribute index, and list of attribute rows |
| `RuneAndRust.Core/Interfaces/ISagaScreenRenderer.cs` | Service contract defining `Render(SagaViewModel)` method for Saga UI rendering implementations |

### Terminal Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Terminal/Controllers/SagaController.cs` | Input controller managing attribute selection navigation (UpArrow/DownArrow/W/S), upgrade actions (Enter/Spacebar), and menu exit (Escape/Q) |
| `RuneAndRust.Terminal/Rendering/SagaScreenRenderer.cs` | Spectre.Console-based renderer implementing ISagaScreenRenderer with header, stats row, attribute table, and footer sections |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Terminal/SagaControllerTests.cs` | Comprehensive test suite with 25 unit tests covering navigation, upgrades, boundary conditions, exit behavior, and static utility methods |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/GamePhase.cs` (line 35) | Added `SagaMenu = 4` enum value with XML documentation describing the Saga progression menu phase |
| `RuneAndRust.Terminal/Program.cs` (lines 165-167) | Registered `ISagaScreenRenderer` as Singleton and `SagaController` as Scoped in DI container |
| `RuneAndRust.Engine/Services/CommandParser.cs` (lines 896-902) | Added four command aliases (`saga`, `shrine`, `legend`, `progression`) that transition state to `GamePhase.SagaMenu` |
| `RuneAndRust.Engine/Services/GameService.cs` (lines 10-11, 36-39, 58-77, 140-153, 219-226, 239, 373, 379-444, 452-510) | Extended with Saga UI support: added four optional constructor parameters, `_sagaSelectedIndex` field, SagaMenu input handling branch in game loop, `BuildSagaViewModel()` method, and `HandleSagaInput()` public method |

---

## Code Implementation Details

### SagaViewModel (Core/ViewModels/SagaViewModel.cs)

**Primary Record:**
```csharp
public record SagaViewModel(
    string CharacterName,
    int Level,
    int CurrentLegend,
    int LegendForNextLevel,
    int ProgressionPoints,
    int SelectedIndex,
    List<AttributeRowViewModel> Attributes
);
```

**Supporting Record:**
```csharp
public record AttributeRowViewModel(
    CharacterAttribute Type,
    int CurrentValue,
    int UpgradeCost,
    AttributeStatus Status
);
```

**Enum:**
```csharp
public enum AttributeStatus
{
    Upgrade,   // Can afford upgrade, not at cap (green)
    Locked,    // Cannot afford upgrade (red)
    Maxed      // At maximum value of 10 (grey)
}
```

**Behaviors:**
- `SagaViewModel` is an immutable snapshot created by `GameService.BuildSagaViewModel()` on each render cycle
- `SelectedIndex` ranges from 0-4, mapping to attribute order: MIGHT, FINESSE, STURDINESS, WITS, WILL
- `LegendForNextLevel` is -1 when at maximum level (10), triggering "MAX LEVEL" display
- `UpgradeCost` is `int.MaxValue` for maxed attributes, 1 for all other valid upgrades

---

### ISagaScreenRenderer (Core/Interfaces/ISagaScreenRenderer.cs)

**Contract:**
```csharp
public interface ISagaScreenRenderer
{
    void Render(SagaViewModel viewModel);
}
```

**Requirements:**
- Clears screen before rendering for clean display
- Displays Legend progress bar using `StatusWidget.RenderBar()`
- Renders attribute table with selection indicator and color-coded status
- Shows control hints in footer

---

### SagaController (Terminal/Controllers/SagaController.cs)

**Key Properties:**
```csharp
private static readonly CharacterAttribute[] AttributeOrder = { Might, Finesse, Sturdiness, Wits, Will };
public int SelectedIndex { get; private set; }
```

**Primary Method:**
```csharp
public GamePhase HandleInput(ConsoleKey key, Character character)
```

**Navigation Behaviors:**
- UpArrow/W: Decrements `SelectedIndex` if greater than 0
- DownArrow/S: Increments `SelectedIndex` if less than 4
- Boundary clamping: Stays at 0 when at top, stays at 4 when at bottom
- All navigation keys return `GamePhase.SagaMenu` (stay in menu)

**Action Behaviors:**
- Enter/Spacebar: Calls `IProgressionService.UpgradeAttribute()` with selected attribute
- Logs success with Info level, failures with Debug level
- Stays in `SagaMenu` phase regardless of upgrade result

**Exit Behaviors:**
- Escape/Q: Resets `SelectedIndex` to 0 and returns `GamePhase.Exploration`
- Logs exit with Info level message

**Static Utilities:**
```csharp
public static CharacterAttribute GetAttributeAtIndex(int index)  // Throws ArgumentOutOfRangeException if index < 0 or > 4
public static int AttributeCount => AttributeOrder.Length;       // Returns 5
public void ResetSelection()                                     // Sets SelectedIndex to 0
```

---

### SagaScreenRenderer (Terminal/Rendering/SagaScreenRenderer.cs)

**Dependencies:**
- `IThemeService`: For color configuration
- `ILogger<SagaScreenRenderer>`: For render traceability

**Render Pipeline (4 sections):**

1. **RenderHeader()** (lines 52-57)
   - Title: `"⚶ THE SHRINE OF ECHOES ⚶"` (gold1, bold)
   - Spectre.Console `Rule` with gold1 border

2. **RenderStatsRow()** (lines 62-86)
   - Level display: `"Level: [bold white]{Level}[/]"`
   - Legend progress bar: Reuses `StatusWidget.RenderBar(current, target, width: 20)`
   - Progress percentage calculation: `(int)((double)CurrentLegend / LegendForNextLevel * 100)`
   - Special case: When `LegendForNextLevel < 0`, renders full bar with "MAX LEVEL" text
   - PP balance: `"Progression Points: [yellow bold][{PP}][/]"`

3. **RenderAttributeTable()** (lines 91-137)
   - Spectre.Console `Table` with Rounded border (grey color)
   - 4 columns: ATTRIBUTE (width 20), VALUE (width 10, centered), COST (width 10, centered), STATUS (width 15)
   - Selection indicator: `">"` prefix for selected row, `" "` for others
   - Selected row name markup: `[bold white]> {NAME}[/]`
   - Unselected row markup: `"  {NAME}"` (plain text)
   - Cost display logic:
     - Maxed: `"[grey]-[/]"`
     - Upgradeable: `"{cost} PP"`
   - Status color coding:
     - `AttributeStatus.Upgrade`: `"[green][UPGRADE][/]"`
     - `AttributeStatus.Locked`: `"[red][LOCKED][/]"`
     - `AttributeStatus.Maxed`: `"[grey][MAXED][/]"`

4. **RenderFooter()** (lines 142-145)
   - Control hints: `"↑↓ Navigate  │  Enter: Purchase  │  Esc: Return"` (dim styling)
   - Uses Unicode arrows (U+2191, U+2193) and vertical bar (U+2502)

**Logging:**
- Trace level on render completion: `"[Saga UI] Rendered. Selected: {Index}"`

---

### GameService.BuildSagaViewModel() (Engine/Services/GameService.cs, lines 379-444)

**Validation Logic:**
```csharp
if (_state.CurrentCharacter == null)
    → LogWarning, return null
if (_sagaService == null || _progressionService == null)
    → LogWarning, return null
```

**Attribute Row Construction:**
```csharp
foreach (var attrType in [Might, Finesse, Sturdiness, Wits, Will])
{
    int currentValue = character.GetAttribute(attrType);
    int upgradeCost = _progressionService.GetUpgradeCost(character, attrType);
    bool canUpgrade = _progressionService.CanUpgrade(character, attrType);

    AttributeStatus status = upgradeCost == int.MaxValue ? Maxed
                           : !canUpgrade ? Locked
                           : Upgrade;

    attributes.Add(new AttributeRowViewModel(attrType, currentValue, upgradeCost, status));
}
```

**Legend Calculation:**
```csharp
int legendForNext = _sagaService.GetLegendForNextLevel(character.Level);
```

**Logging:**
- Debug level: `"[Saga UI] Building ViewModel for {Name}: Level {Level}, Legend {Current}/{Next}, PP {PP}, Selected {Index}"`

---

### GameService.HandleSagaInput() (Engine/Services/GameService.cs, lines 452-510)

**Method Signature:**
```csharp
public GamePhase HandleSagaInput(ConsoleKey key)
```

**Input Processing:**
- Uses same `AttributeOrder` array as `SagaController` (Might, Finesse, Sturdiness, Wits, Will)
- Directly mutates `_sagaSelectedIndex` field (range: 0-4)
- Calls `_progressionService.UpgradeAttribute(_state.CurrentCharacter, attribute)` on Enter/Spacebar
- Returns `GamePhase.Exploration` on Escape/Q, `GamePhase.SagaMenu` otherwise

**Integration with Game Loop (lines 140-153):**
```csharp
if (_state.Phase == GamePhase.SagaMenu && _inputService != null)
{
    var inputEvent = _inputService.ReadNextFiltered();
    var key = inputEvent switch
    {
        RawKeyEvent rawKey => rawKey.KeyInfo.Key,
        ActionEvent actionEvent when actionEvent.SourceKey.HasValue => actionEvent.SourceKey.Value,
        _ => ConsoleKey.NoName
    };

    _state.Phase = HandleSagaInput(key);
    _renderRequired = true;
}
```

**Critical Difference:** SagaMenu phase uses `IInputService.ReadNextFiltered()` for key-based input, while other phases use `IInputHandler.GetInput()` for text-based input.

---

### CommandParser Integration (Engine/Services/CommandParser.cs, lines 896-902)

**Command Aliases:**
```csharp
case "saga":
case "shrine":
case "legend":
case "progression":
    _logger.LogDebug("Saga screen (The Shrine) requested (v0.4.0c).");
    state.Phase = GamePhase.SagaMenu;
    return ParseResult.None;
```

**Behavior:**
- All four aliases transition to `GamePhase.SagaMenu`
- Returns `ParseResult.None` (no additional processing required)
- Logs at Debug level with version tag

---

## Logging Matrix

### SagaController

| Event | Level | Template |
|-------|-------|----------|
| Selection moved up | Trace | `"[Saga UI] Selection moved up to index {Index}"` |
| Selection moved down | Trace | `"[Saga UI] Selection moved down to index {Index}"` |
| Upgrade success | Information | `"[Saga UI] Successfully upgraded {Attribute}"` |
| Upgrade failure | Debug | `"[Saga UI] Upgrade failed: {Message}"` |
| Exit to Exploration | Information | `"[Saga UI] Exiting Shrine, returning to Exploration"` |

### SagaScreenRenderer

| Event | Level | Template |
|-------|-------|----------|
| Render complete | Trace | `"[Saga UI] Rendered. Selected: {Index}"` |

### GameService (Saga UI)

| Event | Level | Template |
|-------|-------|----------|
| ViewModel build | Debug | `"[Saga UI] Building ViewModel for {Name}: Level {Level}, Legend {Current}/{Next}, PP {PP}, Selected {Index}"` |
| No character | Warning | `"[Saga UI] Cannot build ViewModel: No current character"` |
| Missing services | Warning | `"[Saga UI] Cannot build ViewModel: Missing Saga/Progression service"` |
| Selection up (GameService) | Trace | `"[Saga UI] Selection moved up to index {Index}"` |
| Selection down (GameService) | Trace | `"[Saga UI] Selection moved down to index {Index}"` |
| Upgrade success (GameService) | Information | `"[Saga UI] Successfully upgraded {Attribute}"` |
| Upgrade failure (GameService) | Debug | `"[Saga UI] Upgrade failed: {Message}"` |
| Exit (GameService) | Information | `"[Saga UI] Exiting Shrine, returning to Exploration"` |

### CommandParser

| Event | Level | Template |
|-------|-------|----------|
| Saga screen requested | Debug | `"Saga screen (The Shrine) requested (v0.4.0c)."` |

---

## Test Coverage

**Total Tests:** 25 | **Passed:** 25 | **Failed:** 0 | **Duration:** 52ms

### Complete Test Inventory

#### SagaControllerTests (25 tests)

| Test Name | Description |
|-----------|-------------|
| `HandleInput_UpArrow_DecrementsIndex` | UpArrow key decrements selected index from 2 to 1 |
| `HandleInput_UpArrow_AtZero_StaysZero` | UpArrow at index 0 does not decrement (boundary check) |
| `HandleInput_W_DecrementsIndex` | W key (alternate) decrements selected index |
| `HandleInput_DownArrow_IncrementsIndex` | DownArrow key increments selected index from 2 to 3 |
| `HandleInput_DownArrow_AtMax_StaysMax` | DownArrow at index 4 does not increment (boundary check) |
| `HandleInput_S_IncrementsIndex` | S key (alternate) increments selected index |
| `HandleInput_Enter_CallsProgressionService` | Enter key invokes UpgradeAttribute() with selected attribute |
| `HandleInput_Spacebar_CallsProgressionService` | Spacebar (alternate) invokes UpgradeAttribute() |
| `HandleInput_Enter_UpgradesSelectedAttribute` | Enter at index 2 upgrades STURDINESS attribute |
| `HandleInput_Enter_FailedUpgrade_StaysInMenu` | Failed upgrade returns GamePhase.SagaMenu (no exit) |
| `HandleInput_Escape_ReturnsExploration` | Escape key returns GamePhase.Exploration |
| `HandleInput_Escape_ResetsSelection` | Escape resets SelectedIndex to 0 |
| `HandleInput_Q_ReturnsExploration` | Q key (alternate) returns GamePhase.Exploration |
| `HandleInput_Q_ResetsSelection` | Q resets SelectedIndex to 0 |
| `HandleInput_OtherKey_NoEffect` | Unhandled key (X) does not modify state or call services |
| `HandleInput_UnhandledKeys_ReturnSagaMenu` | 7 unhandled keys (A, B, C, Tab, F1, Home, Delete) all return SagaMenu |
| `GetAttributeAtIndex_ReturnsCorrectAttribute` (Theory, 5 cases) | Static method returns correct attribute for indices 0-4 |
| `GetAttributeAtIndex_NegativeIndex_ThrowsArgumentOutOfRangeException` | Index -1 throws exception |
| `GetAttributeAtIndex_IndexTooHigh_ThrowsArgumentOutOfRangeException` | Index 5 throws exception |
| `AttributeCount_Returns5` | Static property returns 5 |
| `ResetSelection_SetsIndexToZero` | ResetSelection() method sets SelectedIndex to 0 |

**Test Methodology:**
- All tests use NSubstitute for mocking `IProgressionService` and `ILogger<SagaController>`
- Helper method `CreateTestCharacter(int pp)` creates consistent test fixtures with all attributes at 5
- Helper method `SetupProgressionSuccess()` mocks successful upgrade results
- Helper method `SetupProgressionFailure()` mocks failed upgrade results (e.g., insufficient PP)
- Helper method `SetSelectedIndex(int target)` navigates to specific index using DownArrow presses
- FluentAssertions used for all assertions

---

## DI Registration

### Program.cs (RuneAndRust.Terminal, lines 165-167)

```csharp
// Register Saga UI (v0.4.0c - The Shrine)
services.AddSingleton<ISagaScreenRenderer, SagaScreenRenderer>();
services.AddScoped<SagaController>();
```

**Lifetime Rationale:**
- `ISagaScreenRenderer`: **Singleton** - Stateless rendering service, safe to share across all scopes
- `SagaController`: **Scoped** - Maintains `SelectedIndex` state, needs fresh instance per game session scope

**Dependencies Satisfied:**
- `SagaScreenRenderer` requires `IThemeService` (Singleton) and `ILogger<SagaScreenRenderer>` (Transient)
- `SagaController` requires `IProgressionService` (Scoped) and `ILogger<SagaController>` (Transient)
- `GameService` receives all four new optional parameters via constructor injection

---

## Verification Results

### Build Output

```
Build succeeded.

/usr/local/share/dotnet/sdk/9.0.306/Microsoft.Common.CurrentVersion.targets(2433,5): warning MSB3277: Found conflicts between different versions of "Microsoft.EntityFrameworkCore.Relational"
    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.13
```

**Status:** Success (1 pre-existing warning unrelated to v0.4.0c changes)

### Test Output

```
Test run for /Volumes/GitHub/github/southpawriter02/rune-rust/RuneAndRust.Tests/bin/Debug/net9.0/RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)

Passed!  - Failed:     0, Passed:    25, Skipped:     0, Total:    25, Duration: 52 ms
```

**Status:** All 25 SagaControllerTests passed

---

## Architecture Notes

### Modal Input Handling Strategy

**Text-Based Phases (MainMenu, Exploration, Combat):**
```csharp
string prompt = GetPhasePrompt();
string input = _inputHandler.GetInput(prompt);
await _parser.ParseAndExecuteAsync(input, _state);
```

**Key-Based Phases (SagaMenu):**
```csharp
var inputEvent = _inputService.ReadNextFiltered();
var key = inputEvent switch
{
    RawKeyEvent rawKey => rawKey.KeyInfo.Key,
    ActionEvent actionEvent when actionEvent.SourceKey.HasValue => actionEvent.SourceKey.Value,
    _ => ConsoleKey.NoName
};
_state.Phase = HandleSagaInput(key);
```

**Design Rationale:** Modal UIs like Saga Menu require immediate key response for navigation (no Enter key required), while text-based phases allow command composition and editing before submission.

---

### ViewModel Immutability Pattern

**Construction:**
- `SagaViewModel` and `AttributeRowViewModel` are C# 10 `record` types, providing value-based equality and immutability by default
- Built fresh on each render cycle via `BuildSagaViewModel()`
- No state is cached between renders (ensures UI always reflects latest character data)

**Benefits:**
- Thread-safe snapshots (no mutation during rendering)
- Testability (ViewModel construction can be tested independently of UI rendering)
- Temporal decoupling (UI rendering doesn't block game state updates)

---

### Attribute Order Canonicalization

**Single Source of Truth:**
```csharp
private static readonly CharacterAttribute[] AttributeOrder =
{
    CharacterAttribute.Might,
    CharacterAttribute.Finesse,
    CharacterAttribute.Sturdiness,
    CharacterAttribute.Wits,
    CharacterAttribute.Will
};
```

**Replication:** Same array exists in both `SagaController` (line 22-29) and `GameService.HandleSagaInput()` (lines 459-466) to avoid cross-layer coupling.

**Future Refactoring:** Consider moving to `SagaViewModel` as a static property for centralized management.

---

### State Persistence: _sagaSelectedIndex

**Storage Location:** `GameService` private field (line 373)
**Lifetime:** Persists across multiple Saga Menu render cycles until exit
**Reset Conditions:** Set to 0 when exiting via Escape/Q
**Alternative Considered:** Storing in `SagaController.SelectedIndex` would require passing controller instance to `BuildSagaViewModel()`, violating separation of concerns.

---

### Color Coding System

| Attribute Status | UI Color | Semantic Meaning |
|------------------|----------|------------------|
| `Upgrade` | Green (`[green]`) | Player has sufficient PP, attribute not at cap |
| `Locked` | Red (`[red]`) | Insufficient PP to afford upgrade |
| `Maxed` | Grey (`[grey]`) | Attribute at maximum value (10) |

**Accessibility Consideration:** Status is conveyed through both color AND text (`[UPGRADE]`, `[LOCKED]`, `[MAXED]`) for colorblind users.

---

## Critical Implementation Details

### AttributeUpgradeResult API Contract

**Used Properties:**
- `.Success` (bool) - Indicates upgrade operation success
- `.Message` (string) - Error description on failure

**NOT Used (despite spec documentation):**
- `.IsSuccess` - Property does not exist in actual implementation
- `.Error` - Property does not exist in actual implementation

**Code Evidence:**
```csharp
var result = _progression.UpgradeAttribute(character, attribute);
if (result.Success)  // ← Uses .Success, not .IsSuccess
{
    _logger.LogInformation("[Saga UI] Successfully upgraded {Attribute}", attribute);
}
else
{
    _logger.LogDebug("[Saga UI] Upgrade failed: {Message}", result.Message);  // ← Uses .Message, not .Error
}
```

---

### Attribute Index Mapping

| Index | Attribute | Display Order |
|-------|-----------|---------------|
| 0 | `CharacterAttribute.Might` | Row 1 |
| 1 | `CharacterAttribute.Finesse` | Row 2 |
| 2 | `CharacterAttribute.Sturdiness` | Row 3 |
| 3 | `CharacterAttribute.Wits` | Row 4 |
| 4 | `CharacterAttribute.Will` | Row 5 |

---

### Legend Progress Display Logic

**Normal Levels (1-9):**
```csharp
legendBar = StatusWidget.RenderBar(vm.CurrentLegend, vm.LegendForNextLevel, 20);
int pct = (int)((double)vm.CurrentLegend / vm.LegendForNextLevel * 100);
legendProgress = $"{vm.CurrentLegend}/{vm.LegendForNextLevel} ({pct}%)";
```

**Maximum Level (10):**
```csharp
if (vm.LegendForNextLevel < 0)
{
    legendBar = StatusWidget.RenderBar(1, 1, 20);  // Full bar
    legendProgress = "[grey]MAX LEVEL[/]";
}
```

**Visual Example:**
```
Level: 7    Legend: [████████████░░░░░░░░] 800/1000 (80%)
                    Progression Points: [5]

Level: 10   Legend: [████████████████████] MAX LEVEL
                     Progression Points: [12]
```

---

### Upgrade Cost Display Rules

| Condition | Display |
|-----------|---------|
| `UpgradeCost == int.MaxValue` | `"[grey]-[/]"` (attribute maxed) |
| `UpgradeCost == 1` (normal) | `"1 PP"` |
| Other costs (future-proof) | `"{cost} PP"` |

**Code (SagaScreenRenderer.cs, lines 119-121):**
```csharp
var costMarkup = attr.Status == AttributeStatus.Maxed
    ? "[grey]-[/]"
    : $"{attr.UpgradeCost} PP";
```

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Enums/
│   └── GamePhase.cs                           [MODIFIED - added SagaMenu = 4]
├── Interfaces/
│   └── ISagaScreenRenderer.cs                 [NEW]
└── ViewModels/
    └── SagaViewModel.cs                       [NEW - 3 types: SagaViewModel, AttributeRowViewModel, AttributeStatus]

RuneAndRust.Engine/
└── Services/
    ├── CommandParser.cs                       [MODIFIED - lines 896-902: saga command aliases]
    └── GameService.cs                         [MODIFIED - extensive Saga UI integration]

RuneAndRust.Terminal/
├── Controllers/
│   └── SagaController.cs                      [NEW]
├── Rendering/
│   └── SagaScreenRenderer.cs                  [NEW]
└── Program.cs                                 [MODIFIED - lines 165-167: DI registrations]

RuneAndRust.Tests/
└── Terminal/
    └── SagaControllerTests.cs                 [NEW - 25 tests, 434 lines]

docs/
└── changelogs/
    └── v0.4.0c.md                             [NEW - this file]
```

---

## Running Tests

### Full Test Suite
```bash
dotnet test
```

### Saga UI Tests Only
```bash
dotnet test --filter "FullyQualifiedName~SagaControllerTests"
```

**Expected Output:**
```
Passed!  - Failed:     0, Passed:    25, Skipped:     0, Total:    25, Duration: 52 ms
```

### Individual Test Categories
```bash
# Navigation tests only
dotnet test --filter "FullyQualifiedName~SagaControllerTests&TestCategory=Navigation"

# Upgrade action tests only
dotnet test --filter "FullyQualifiedName~SagaControllerTests&FullyQualifiedName~Upgrade"

# Exit behavior tests only
dotnet test --filter "FullyQualifiedName~SagaControllerTests&(FullyQualifiedName~Escape|FullyQualifiedName~Q)"
```

---

## Next Steps

### v0.4.0d (Planned)
- Implement Saga screen transition animations (fade-in/fade-out for modal entry/exit)
- Add sound effects for attribute upgrades (success chime, failure buzz)
- Implement attribute upgrade confirmation prompt for expensive upgrades
- Add keyboard shortcut help overlay (press `?` in Saga Menu)

### v0.4.1 (Planned)
- Extend Saga UI with "Rune Slot" section for passive ability management
- Add visual indicator for recently upgraded attributes (pulsing green for 3 seconds)
- Implement attribute comparison tooltip (hold Shift to see stat impact preview)

### Technical Debt
- Deduplicate `AttributeOrder` array between `SagaController` and `GameService.HandleSagaInput()`
- Consider extracting Saga input handling to separate `SagaInputHandler` service
- Evaluate performance impact of rebuilding full ViewModel on every keystroke (profile under high attribute count scenarios)

---

**End of Changelog v0.4.0c**
