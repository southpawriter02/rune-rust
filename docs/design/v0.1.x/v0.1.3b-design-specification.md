# v0.1.3b Design Specification: Room Shapes & Features

**Version:** 0.1.3b
**Phase Name:** Room Shapes & Features
**Parent Version:** v0.1.3 (Advanced Procedural Architecture)
**Prerequisites:** v0.1.3a Complete (Architectural Styles)
**Estimated Tests:** ~25 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [RoomShape Enum](#4-roomshape-enum)
5. [ShapeDefinition Value Object](#5-shapedefinition-value-object)
6. [StructuralFeature Entity](#6-structuralfeature-entity)
7. [FeatureCategory Enum](#7-featurecategory-enum)
8. [RoomFeature Value Object](#8-roomfeature-value-object)
9. [ShapeGeneratorService](#9-shapegeneratorservice)
10. [StructuralFeatureService](#10-structuralfeatureservice)
11. [Room Entity Integration](#11-room-entity-integration)
12. [Data Model Changes](#12-data-model-changes)
13. [Configuration File Schemas](#13-configuration-file-schemas)
14. [Logging Specifications](#14-logging-specifications)
15. [Unit Testing Requirements](#15-unit-testing-requirements)
16. [Use Cases](#16-use-cases)
17. [Deliverable Checklist](#17-deliverable-checklist)
18. [Acceptance Criteria](#18-acceptance-criteria)
19. [Dependencies](#19-dependencies)
20. [Future Considerations](#20-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement non-rectangular room shapes and structural features that add geometric variety and tactical depth to dungeon rooms. Each shape has distinct geometry affecting exit placement, line of sight, and combat dynamics. Structural features such as pillars, platforms, and natural formations provide cover, height advantage, and environmental interaction opportunities.

### 1.2 Current State

| Area | Current State (v0.1.3a) | Target State (v0.1.3b) |
|------|------------------------|------------------------|
| Room geometry | Implicit rectangular | Explicit shape with geometry rules |
| Exit placement | Generic cardinal | Shape-aware positioning |
| Structural features | None | Configurable feature system |
| Line of sight | Always clear | Shape and feature dependent |
| Cover mechanics | None | Feature-based cover bonuses |
| Height advantage | None | Climbable features with bonuses |
| Room descriptions | Style + Biome | Style + Biome + Shape + Features |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Enums** | `RoomShape`, `FeatureCategory` |
| **Value Objects** | `ShapeDefinition`, `RoomFeature` |
| **Entities** | `StructuralFeature` |
| **Services** | `ShapeGeneratorService`, `StructuralFeatureService` (with interfaces) |
| **Configuration** | `shape-definitions.json`, `structural-features.json`, schemas |
| **Entity Updates** | `Room.Shape`, `Room.StructuralFeatures` properties |
| **Tests** | ~25 new unit tests |

### 1.4 Architectural Significance

This version establishes the **geometric foundation** for advanced room generation:
- Shape-aware exit placement based on room geometry
- Feature placement rules respecting shape constraints
- Tactical combat elements (cover, height, line of sight)
- Integration with architectural styles for thematic consistency
- Foundation for landmark rooms (v0.1.3c) requiring specific shapes

---

## 2. Feature Overview

```
v0.1.3b Room Shapes & Features
├── RoomShape Enum
│   ├── Rectangular (standard four-wall chamber)
│   ├── Circular (ritual rooms, arenas)
│   ├── LShaped (ambush corners, LOS breaks)
│   ├── Irregular (natural caverns)
│   ├── TShaped (corridor junctions)
│   └── Cross (ceremonial crossroads)
├── ShapeDefinition Value Object
│   ├── Shape type reference
│   ├── Valid exit directions
│   ├── Maximum exits count
│   ├── Cardinal exit requirement
│   ├── Line of sight properties
│   ├── Natural cover percentage
│   ├── Area multiplier
│   └── Shape descriptor text
├── StructuralFeature Entity
│   ├── Unique identification (Id)
│   ├── Display name and description
│   ├── Feature category
│   ├── Cover properties (provides, bonus)
│   ├── Movement blocking
│   ├── Line of sight blocking
│   ├── Climbable with height advantage
│   ├── Interactive properties
│   ├── Compatible architectural styles
│   ├── Descriptors for room text
│   └── Map symbol for display
├── FeatureCategory Enum
│   ├── Support (pillars, columns)
│   ├── Platform (raised areas)
│   ├── Alcove (recessed areas)
│   ├── Water (pools, streams)
│   ├── Decoration (non-functional)
│   ├── Furniture (functional objects)
│   └── Natural (cave formations)
├── RoomFeature Value Object
│   ├── Feature ID reference
│   ├── Position within room
│   └── Quantity placed
├── ShapeGeneratorService
│   ├── GetShapeDefinition(shape)
│   ├── GetAllShapeDefinitions()
│   ├── SelectShapeForStyle(styleId, position)
│   ├── GetValidExitDirections(shape)
│   └── GetShapeDescriptor(shape, position)
├── StructuralFeatureService
│   ├── GetFeature(featureId)
│   ├── GetAllFeatures()
│   ├── GetFeaturesForStyle(styleId)
│   ├── GetFeaturesForShape(shape)
│   ├── SelectFeaturesForRoom(room, style)
│   ├── PlaceFeature(room, featureId, position)
│   └── GetRandomDescriptor(featureId, position)
├── Room Entity Updates
│   ├── Shape property
│   ├── StructuralFeatures collection
│   ├── SetShape(shape) method
│   ├── AddFeature(feature) method
│   ├── RemoveFeature(featureId) method
│   └── HasFeature(featureId) method
└── Configuration
    ├── shape-definitions.json (6 shape definitions)
    ├── structural-features.json (10+ feature definitions)
    ├── shape-definitions-schema.json (validation)
    └── structural-features-schema.json (validation)
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Room descriptions now include shape and feature descriptors                │
│  ├── GameView displays shape-appropriate environment text                   │
│  ├── Map rendering uses feature symbols                                     │
│  └── Combat system queries cover/height from features                       │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  ShapeGeneratorService               StructuralFeatureService                │
│  ├── GetShapeDefinition(shape)       ├── GetFeature(featureId)              │
│  ├── GetAllShapeDefinitions()        ├── GetAllFeatures()                   │
│  ├── SelectShapeForStyle()           ├── GetFeaturesForStyle(styleId)       │
│  ├── GetValidExitDirections()        ├── GetFeaturesForShape(shape)         │
│  └── GetShapeDescriptor()            ├── SelectFeaturesForRoom()            │
│                                      ├── PlaceFeature()                      │
│  Interfaces:                         └── GetRandomDescriptor()              │
│  ├── IShapeGeneratorService                                                  │
│  └── IStructuralFeatureService       RoomGeneratorService (Updated)         │
│                                      └── Assigns shape and features          │
│                                                                              │
│  Configuration:                      DescriptorService (Updated)             │
│  ├── ShapeDefinitionConfigDto        └── Includes shape/feature descriptors │
│  └── StructuralFeatureConfigDto                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Enums:                          Definitions:                                │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                │
│  │ RoomShape               │     │ StructuralFeature       │                │
│  │ ├── Rectangular         │     │ ├── Id: string          │                │
│  │ ├── Circular            │     │ ├── Name: string        │                │
│  │ ├── LShaped             │     │ ├── Description: string │                │
│  │ ├── Irregular           │     │ ├── Category            │                │
│  │ ├── TShaped             │     │ ├── ProvidesCover: bool │                │
│  │ └── Cross               │     │ ├── CoverBonus: float   │                │
│  └─────────────────────────┘     │ ├── BlocksMovement      │                │
│  ┌─────────────────────────┐     │ ├── BlocksLineOfSight   │                │
│  │ FeatureCategory         │     │ ├── IsClimbable: bool   │                │
│  │ ├── Support             │     │ ├── HeightAdvantage     │                │
│  │ ├── Platform            │     │ ├── IsInteractive       │                │
│  │ ├── Alcove              │     │ ├── InteractionType     │                │
│  │ ├── Water               │     │ ├── CompatibleStyles    │                │
│  │ ├── Decoration          │     │ ├── Descriptors         │                │
│  │ ├── Furniture           │     │ └── MapSymbol: char     │                │
│  │ └── Natural             │     └─────────────────────────┘                │
│  └─────────────────────────┘                                                 │
│                                                                              │
│  Value Objects:                  Entities (Updated):                         │
│  ┌─────────────────────────┐     ┌─────────────────────────┐                │
│  │ ShapeDefinition         │     │ Room                    │                │
│  │ ├── Shape: RoomShape    │     │ ├── Shape: RoomShape    │                │
│  │ ├── Name: string        │     │ ├── StructuralFeatures  │                │
│  │ ├── ValidExitDirections │     │ ├── SetShape(shape)     │                │
│  │ ├── MaxExits: int       │     │ ├── AddFeature(feature) │                │
│  │ ├── RequiresCardinalExits│    │ ├── RemoveFeature(id)   │                │
│  │ ├── ClearLineOfSight    │     │ └── HasFeature(id)      │                │
│  │ ├── NaturalCoverPercent │     └─────────────────────────┘                │
│  │ ├── AreaMultiplier      │                                                │
│  │ └── ShapeDescriptor     │     ┌─────────────────────────┐                │
│  └─────────────────────────┘     │ RoomFeature             │                │
│                                  │ ├── FeatureId: string   │                │
│                                  │ ├── Position: string    │                │
│                                  │ └── Quantity: int       │                │
│                                  └─────────────────────────┘                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetShapeDefinitions(): IReadOnlyList<ShapeDefinition>                  │
│  ├── GetStructuralFeatures(): IReadOnlyList<StructuralFeature>              │
│  └── Loads and deserializes configuration files                             │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/shape-definitions.json (6 shape definitions)                    │
│  ├── config/structural-features.json (10+ feature definitions)              │
│  └── config/schemas/shape-definitions-schema.json                           │
│  └── config/schemas/structural-features-schema.json                         │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Shape Selection Flow

```
┌───────────────────────────────────────┐
│ RoomGeneratorService generates room   │
│ with ArchitecturalStyleId assigned    │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ ArchitecturalStyleService.GetStyle(styleId)                   │
├───────────────────────────────────────────────────────────────┤
│ Returns style with PreferredShapes:                           │
│ ├── natural-caves: ["irregular", "circular"]                  │
│ ├── carved-halls: ["rectangular", "l-shaped"]                 │
│ ├── ruined-structures: ["irregular", "rectangular"]           │
│ └── ancient-temples: ["rectangular", "circular"]              │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ ShapeGeneratorService.SelectShapeForStyle(styleId, position)  │
├───────────────────────────────────────────────────────────────┤
│ Step 1: Get preferred shapes from style                       │
│ ├── Style "natural-caves" prefers: irregular, circular        │
│                                                                │
│ Step 2: Map shape names to RoomShape enum                     │
│ ├── "irregular" → RoomShape.Irregular                         │
│ ├── "circular" → RoomShape.Circular                           │
│                                                                │
│ Step 3: Consider style rules                                  │
│ ├── PrefersRegularShapes: false → favor Irregular             │
│ ├── PrefersSymmetry: false → any orientation                  │
│                                                                │
│ Step 4: Weighted random selection                             │
│ ├── SeededRandomService.SelectWeighted(position, shapes)      │
│ └── Selected: RoomShape.Irregular                             │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Get ShapeDefinition for selected shape                        │
├───────────────────────────────────────────────────────────────┤
│ ShapeDefinition.Irregular:                                    │
│ ├── ValidExitDirections: [N, S, E, W]                        │
│ ├── MaxExits: 6                                               │
│ ├── RequiresCardinalExits: false                              │
│ ├── ClearLineOfSight: false                                   │
│ ├── NaturalCoverPercent: 0.25f                               │
│ ├── AreaMultiplier: 0.9f                                      │
│ └── ShapeDescriptor: "irregular cavern"                       │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Room.SetShape(RoomShape.Irregular)                            │
├───────────────────────────────────────────────────────────────┤
│ Room now has:                                                 │
│ ├── BiomeId: "mines"                                          │
│ ├── ArchitecturalStyleId: "natural-caves"                     │
│ ├── Shape: RoomShape.Irregular                                │
│ └── Exit generation uses shape constraints                    │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Feature Placement Flow

```
┌───────────────────────────────────────────────────────────────┐
│ Room generated with:                                          │
│ ├── StyleId: "ancient-temples"                                │
│ ├── Shape: RoomShape.Circular                                 │
│ └── Size: Large (10+ tiles)                                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ StructuralFeatureService.SelectFeaturesForRoom(room, style)   │
├───────────────────────────────────────────────────────────────┤
│ Step 1: Get style's common features                           │
│ ├── ancient-temples.CommonFeatures:                           │
│ │   ["altar", "pillar", "statue", "offering-bowl"]            │
│                                                                │
│ Step 2: Filter by shape compatibility                         │
│ ├── Circular rooms support: center, perimeter, cardinal       │
│ ├── All listed features compatible with Circular              │
│                                                                │
│ Step 3: Determine feature count by room size                  │
│ ├── Large room: 2-4 features                                  │
│ ├── SeededRandom selects: 3 features                          │
│                                                                │
│ Step 4: Select specific features                              │
│ ├── Weighted selection from common features                   │
│ └── Selected: ["pillar", "pillar", "altar"]                   │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Place each selected feature                                   │
├───────────────────────────────────────────────────────────────┤
│ Feature 1: pillar                                             │
│ ├── Valid positions for Circular: perimeter, inner-ring       │
│ ├── Selected position: "perimeter"                            │
│ ├── Quantity for perimeter placement: 4 (cardinal points)     │
│ └── RoomFeature { "pillar", "perimeter", 4 }                  │
│                                                                │
│ Feature 2: altar                                               │
│ ├── Valid positions for Circular: center                      │
│ ├── Selected position: "center"                               │
│ ├── Quantity for center placement: 1                          │
│ └── RoomFeature { "altar", "center", 1 }                      │
└───────────────┬───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────────────────────┐
│ Room with features                                            │
├───────────────────────────────────────────────────────────────┤
│ Room.StructuralFeatures:                                      │
│ ├── RoomFeature { "pillar", "perimeter", 4 }                  │
│ └── RoomFeature { "altar", "center", 1 }                      │
│                                                                │
│ Tactical implications:                                        │
│ ├── 4 pillars provide cover at cardinal points                │
│ ├── Central altar may be climbable (height advantage)         │
│ └── Room description includes feature descriptors             │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 Shape-Feature Compatibility Matrix

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SHAPE-FEATURE POSITION COMPATIBILITY                      │
├─────────────────┬───────┬───────┬───────┬───────┬───────┬───────┬───────────┤
│ Position        │ Rect  │ Circ  │ L-Shp │ Irreg │ T-Shp │ Cross │ Notes     │
├─────────────────┼───────┼───────┼───────┼───────┼───────┼───────┼───────────┤
│ center          │  ✓    │  ✓    │  ✗    │  ✓    │  ✓    │  ✓    │ L has no  │
│                 │       │       │       │       │       │       │ true center│
├─────────────────┼───────┼───────┼───────┼───────┼───────┼───────┼───────────┤
│ perimeter       │  ✓    │  ✓    │  ✓    │  ✓    │  ✓    │  ✓    │ All shapes│
├─────────────────┼───────┼───────┼───────┼───────┼───────┼───────┼───────────┤
│ corners         │  ✓    │  ✗    │  ✓    │  ✗    │  ✓    │  ✗    │ Rect only │
├─────────────────┼───────┼───────┼───────┼───────┼───────┼───────┼───────────┤
│ north-wall      │  ✓    │  ✓    │  ?    │  ✗    │  ✓    │  ✓    │ L depends │
│ south-wall      │  ✓    │  ✓    │  ?    │  ✗    │  ✓    │  ✓    │ on orient │
│ east-wall       │  ✓    │  ✓    │  ?    │  ✗    │  ✓    │  ✓    │           │
│ west-wall       │  ✓    │  ✓    │  ?    │  ✗    │  ✓    │  ✓    │           │
├─────────────────┼───────┼───────┼───────┼───────┼───────┼───────┼───────────┤
│ inner-ring      │  ✗    │  ✓    │  ✗    │  ✗    │  ✗    │  ✓    │ Circular  │
├─────────────────┼───────┼───────┼───────┼───────┼───────┼───────┼───────────┤
│ scattered       │  ✓    │  ✓    │  ✓    │  ✓    │  ✓    │  ✓    │ Random    │
├─────────────────┼───────┼───────┼───────┼───────┼───────┼───────┼───────────┤
│ alcove-*        │  ✓    │  ✗    │  ✓    │  ✗    │  ✓    │  ✓    │ Wall-based│
├─────────────────┼───────┼───────┼───────┼───────┼───────┼───────┼───────────┤
│ branch-*        │  ✗    │  ✗    │  ✓    │  ✗    │  ✓    │  ✓    │ Multi-arm │
└─────────────────┴───────┴───────┴───────┴───────┴───────┴───────┴───────────┘

Legend: ✓ = Valid, ✗ = Invalid, ? = Conditional
```

---

## 4. RoomShape Enum

### 4.1 Purpose

The `RoomShape` enum defines the geometric shape of a room, affecting exit placement, line of sight, natural cover, and feature positioning. Each shape has distinct tactical properties.

### 4.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Enums/RoomShape.cs`

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the geometric shape of a room.
/// </summary>
/// <remarks>
/// Room shapes affect exit placement, line of sight calculations,
/// natural cover availability, and structural feature positioning.
/// Each shape creates distinct tactical dynamics for combat encounters.
/// </remarks>
public enum RoomShape
{
    /// <summary>
    /// Standard rectangular room with four walls.
    /// </summary>
    /// <remarks>
    /// The most common room shape. Exits can be placed on any wall.
    /// Clear line of sight across the entire room. No natural cover.
    /// Compatible with all architectural styles.
    /// </remarks>
    Rectangular = 0,

    /// <summary>
    /// Circular or oval room.
    /// </summary>
    /// <remarks>
    /// Often used for ritual spaces, arenas, and ceremonial chambers.
    /// Exits at cardinal points only. Clear line of sight to center.
    /// Favored by ancient-temples and natural-caves styles.
    /// </remarks>
    Circular = 1,

    /// <summary>
    /// L-shaped room with two connected rectangular sections.
    /// </summary>
    /// <remarks>
    /// Creates natural ambush opportunities with line-of-sight breaks.
    /// The corner provides cover and tactical positioning.
    /// Common in carved-halls and ruined-structures styles.
    /// </remarks>
    LShaped = 2,

    /// <summary>
    /// Irregular natural cavern with organic boundaries.
    /// </summary>
    /// <remarks>
    /// Natural cave formations with uneven walls and surfaces.
    /// Exits can be placed anywhere along the perimeter.
    /// Line of sight often broken by natural formations.
    /// 25% natural cover from rock formations.
    /// Exclusive to natural-caves and ruined-structures styles.
    /// </remarks>
    Irregular = 3,

    /// <summary>
    /// T-shaped intersection with three branches.
    /// </summary>
    /// <remarks>
    /// Common at corridor junctions and decision points.
    /// Three exits, one at each branch terminus.
    /// Center provides line of sight to all branches.
    /// Often used for defensive chokepoints.
    /// </remarks>
    TShaped = 4,

    /// <summary>
    /// Cross-shaped room with four branches from center.
    /// </summary>
    /// <remarks>
    /// Ceremonial or defensive crossroads layout.
    /// Four exits, one at each branch terminus.
    /// Central position commands all approaches.
    /// Favored by ancient-temples style for ritual spaces.
    /// </remarks>
    Cross = 5
}
```

### 4.4 Shape Characteristics Summary

| Shape | Max Exits | Cardinal Only | Clear LOS | Natural Cover | Style Affinity |
|-------|-----------|---------------|-----------|---------------|----------------|
| Rectangular | 4 | Yes | Yes | 0% | All |
| Circular | 4 | Yes | Yes | 0% | Temples, Caves |
| LShaped | 3 | Yes | No | 15% | Halls, Ruins |
| Irregular | 6 | No | No | 25% | Caves, Ruins |
| TShaped | 3 | Yes | Partial | 0% | Halls |
| Cross | 4 | Yes | Partial | 0% | Temples |

---

## 5. ShapeDefinition Value Object

### 5.1 Purpose

The `ShapeDefinition` value object defines geometry and behavior rules for each room shape. It specifies valid exit directions, line of sight properties, cover percentages, and descriptive text.

### 5.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ShapeDefinition.cs`

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines geometry and behavior rules for a room shape.
/// </summary>
/// <remarks>
/// ShapeDefinitions are loaded from configuration and provide
/// the rules for exit placement, line of sight, cover, and
/// descriptive text generation for each room shape.
/// </remarks>
public readonly record struct ShapeDefinition
{
    /// <summary>
    /// Gets the shape type this definition describes.
    /// </summary>
    public RoomShape Shape { get; init; }

    /// <summary>
    /// Gets the display name of this shape.
    /// </summary>
    public string Name { get; init; }

    /// <summary>
    /// Gets valid exit directions for this shape.
    /// </summary>
    /// <remarks>
    /// Determines which directions exits can be placed.
    /// Rectangular/Circular allow N, S, E, W.
    /// Irregular allows any direction.
    /// </remarks>
    public IReadOnlyList<Direction> ValidExitDirections { get; init; }

    /// <summary>
    /// Gets the maximum number of exits this shape supports.
    /// </summary>
    /// <remarks>
    /// Limits how many connections a room can have.
    /// L-shaped rooms max at 3, Cross at 4, Irregular at 6.
    /// </remarks>
    public int MaxExits { get; init; }

    /// <summary>
    /// Gets whether exits must be on cardinal directions only.
    /// </summary>
    /// <remarks>
    /// True for constructed shapes (Rectangular, Circular).
    /// False for natural shapes (Irregular) which can have
    /// exits at any angle along the perimeter.
    /// </remarks>
    public bool RequiresCardinalExits { get; init; }

    /// <summary>
    /// Gets whether line of sight is always clear across the room.
    /// </summary>
    /// <remarks>
    /// False for L-shaped (corner blocks LOS) and Irregular
    /// (natural formations block LOS). Affects ranged combat
    /// and stealth mechanics.
    /// </remarks>
    public bool ClearLineOfSight { get; init; }

    /// <summary>
    /// Gets the percentage of room area providing natural cover.
    /// </summary>
    /// <remarks>
    /// Irregular caverns have 25% natural cover from formations.
    /// L-shaped rooms have 15% from the corner area.
    /// Cover provides defensive bonuses in combat.
    /// </remarks>
    public float NaturalCoverPercent { get; init; }

    /// <summary>
    /// Gets the area multiplier compared to a rectangular room.
    /// </summary>
    /// <remarks>
    /// Used for calculating room capacity and feature density.
    /// Circular: 0.785 (π/4), L-shaped: 0.75, Irregular: 0.9.
    /// </remarks>
    public float AreaMultiplier { get; init; }

    /// <summary>
    /// Gets the descriptive text for this shape in room descriptions.
    /// </summary>
    public string ShapeDescriptor { get; init; }

    /// <summary>
    /// Gets valid feature positions for this shape.
    /// </summary>
    /// <remarks>
    /// Determines where structural features can be placed.
    /// Circular rooms support "center" and "inner-ring".
    /// L-shaped rooms do not support "center".
    /// </remarks>
    public IReadOnlyList<string> ValidFeaturePositions { get; init; }

    /// <summary>
    /// Creates a default shape definition (Rectangular).
    /// </summary>
    public static ShapeDefinition Default => Rectangular;

    /// <summary>
    /// Gets rectangular shape definition.
    /// </summary>
    public static ShapeDefinition Rectangular => new()
    {
        Shape = RoomShape.Rectangular,
        Name = "Rectangular",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 4,
        RequiresCardinalExits = true,
        ClearLineOfSight = true,
        NaturalCoverPercent = 0f,
        AreaMultiplier = 1.0f,
        ShapeDescriptor = "rectangular chamber",
        ValidFeaturePositions = new[] { "center", "perimeter", "corners", "north-wall", "south-wall", "east-wall", "west-wall", "scattered" }
    };

    /// <summary>
    /// Gets circular shape definition.
    /// </summary>
    public static ShapeDefinition Circular => new()
    {
        Shape = RoomShape.Circular,
        Name = "Circular",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 4,
        RequiresCardinalExits = true,
        ClearLineOfSight = true,
        NaturalCoverPercent = 0f,
        AreaMultiplier = 0.785f,
        ShapeDescriptor = "circular chamber",
        ValidFeaturePositions = new[] { "center", "perimeter", "inner-ring", "north-wall", "south-wall", "east-wall", "west-wall", "scattered" }
    };

    /// <summary>
    /// Gets L-shaped definition.
    /// </summary>
    public static ShapeDefinition LShaped => new()
    {
        Shape = RoomShape.LShaped,
        Name = "L-Shaped",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 3,
        RequiresCardinalExits = true,
        ClearLineOfSight = false,
        NaturalCoverPercent = 0.15f,
        AreaMultiplier = 0.75f,
        ShapeDescriptor = "L-shaped chamber",
        ValidFeaturePositions = new[] { "perimeter", "corners", "branch-a", "branch-b", "junction", "scattered" }
    };

    /// <summary>
    /// Gets irregular shape definition.
    /// </summary>
    public static ShapeDefinition Irregular => new()
    {
        Shape = RoomShape.Irregular,
        Name = "Irregular",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West, Direction.Up, Direction.Down },
        MaxExits = 6,
        RequiresCardinalExits = false,
        ClearLineOfSight = false,
        NaturalCoverPercent = 0.25f,
        AreaMultiplier = 0.9f,
        ShapeDescriptor = "irregular cavern",
        ValidFeaturePositions = new[] { "center", "perimeter", "scattered", "natural-alcove" }
    };

    /// <summary>
    /// Gets T-shaped definition.
    /// </summary>
    public static ShapeDefinition TShaped => new()
    {
        Shape = RoomShape.TShaped,
        Name = "T-Shaped",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 3,
        RequiresCardinalExits = true,
        ClearLineOfSight = false,
        NaturalCoverPercent = 0f,
        AreaMultiplier = 0.75f,
        ShapeDescriptor = "T-shaped junction",
        ValidFeaturePositions = new[] { "center", "branch-north", "branch-south", "branch-east", "branch-west", "scattered" }
    };

    /// <summary>
    /// Gets cross-shaped definition.
    /// </summary>
    public static ShapeDefinition Cross => new()
    {
        Shape = RoomShape.Cross,
        Name = "Cross",
        ValidExitDirections = new[] { Direction.North, Direction.South, Direction.East, Direction.West },
        MaxExits = 4,
        RequiresCardinalExits = true,
        ClearLineOfSight = false,
        NaturalCoverPercent = 0f,
        AreaMultiplier = 0.6f,
        ShapeDescriptor = "cross-shaped chamber",
        ValidFeaturePositions = new[] { "center", "branch-north", "branch-south", "branch-east", "branch-west", "inner-ring", "scattered" }
    };

    /// <summary>
    /// Gets the shape definition for a given shape.
    /// </summary>
    /// <param name="shape">The room shape.</param>
    /// <returns>The corresponding shape definition.</returns>
    public static ShapeDefinition ForShape(RoomShape shape) => shape switch
    {
        RoomShape.Rectangular => Rectangular,
        RoomShape.Circular => Circular,
        RoomShape.LShaped => LShaped,
        RoomShape.Irregular => Irregular,
        RoomShape.TShaped => TShaped,
        RoomShape.Cross => Cross,
        _ => Rectangular
    };

    /// <summary>
    /// Checks if a position is valid for this shape.
    /// </summary>
    /// <param name="position">The position identifier.</param>
    /// <returns>True if the position is valid for this shape.</returns>
    public bool IsValidPosition(string position)
    {
        if (string.IsNullOrWhiteSpace(position))
            return false;

        return ValidFeaturePositions.Contains(position, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Checks if an exit direction is valid for this shape.
    /// </summary>
    /// <param name="direction">The exit direction.</param>
    /// <returns>True if the direction is valid for this shape.</returns>
    public bool IsValidExitDirection(Direction direction)
    {
        return ValidExitDirections.Contains(direction);
    }
}
```

---

## 6. StructuralFeature Entity

### 6.1 Purpose

The `StructuralFeature` entity defines a structural element that can appear in rooms, such as pillars, platforms, pools, or natural formations. Features provide tactical benefits like cover, height advantage, and interaction opportunities.

### 6.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Definitions/StructuralFeature.cs`

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Defines a structural element that can appear in rooms.
/// </summary>
/// <remarks>
/// Structural features add tactical depth to rooms by providing
/// cover, height advantage, movement obstacles, and interactive
/// elements. Features are loaded from JSON configuration and
/// filtered by architectural style compatibility.
/// </remarks>
public class StructuralFeature
{
    /// <summary>
    /// Gets the unique identifier (e.g., "pillar", "raised-platform").
    /// </summary>
    /// <remarks>
    /// Uses kebab-case naming convention. Must be unique across all features.
    /// </remarks>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name (e.g., "Stone Pillar").
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the detailed description for codex/examination.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the feature category.
    /// </summary>
    /// <remarks>
    /// Categories group features by function: Support, Platform,
    /// Alcove, Water, Decoration, Furniture, Natural.
    /// </remarks>
    public FeatureCategory Category { get; init; }

    /// <summary>
    /// Gets whether this feature provides cover in combat.
    /// </summary>
    /// <remarks>
    /// Cover reduces incoming damage or attack accuracy.
    /// Pillars, stalagmites, and large furniture provide cover.
    /// </remarks>
    public bool ProvidesCover { get; init; }

    /// <summary>
    /// Gets the cover bonus as a percentage (0.0-1.0).
    /// </summary>
    /// <remarks>
    /// 0.5 = 50% cover (half cover), 0.75 = 75% (three-quarters).
    /// Only applies if ProvidesCover is true.
    /// </remarks>
    public float CoverBonus { get; init; }

    /// <summary>
    /// Gets whether this feature blocks movement.
    /// </summary>
    /// <remarks>
    /// Pillars and solid objects block movement.
    /// Pools and platforms may not block movement.
    /// </remarks>
    public bool BlocksMovement { get; init; }

    /// <summary>
    /// Gets whether this feature blocks line of sight.
    /// </summary>
    /// <remarks>
    /// Full pillars block LOS. Partial cover (low walls) may not.
    /// Affects ranged attacks and visibility.
    /// </remarks>
    public bool BlocksLineOfSight { get; init; }

    /// <summary>
    /// Gets whether this feature can be climbed.
    /// </summary>
    /// <remarks>
    /// Platforms, balconies, and large sturdy objects can be climbed
    /// to gain height advantage in combat.
    /// </remarks>
    public bool IsClimbable { get; init; }

    /// <summary>
    /// Gets the height advantage tier if climbable.
    /// </summary>
    /// <remarks>
    /// 0 = no advantage, 1 = minor (+1 to hit), 2 = significant (+2).
    /// Only applies if IsClimbable is true.
    /// </remarks>
    public int HeightAdvantage { get; init; }

    /// <summary>
    /// Gets whether this feature is interactive.
    /// </summary>
    /// <remarks>
    /// Interactive features can be examined, used, or manipulated
    /// by the player (pools, altars, levers).
    /// </remarks>
    public bool IsInteractive { get; init; }

    /// <summary>
    /// Gets the interaction type if interactive.
    /// </summary>
    /// <remarks>
    /// Types: "examine", "use", "activate", "drink", "pray".
    /// Null if not interactive.
    /// </remarks>
    public string? InteractionType { get; init; }

    /// <summary>
    /// Gets architectural styles compatible with this feature.
    /// </summary>
    /// <remarks>
    /// Empty list means compatible with all styles.
    /// Pillars work in carved-halls and temples.
    /// Stalagmites only in natural-caves.
    /// </remarks>
    public IReadOnlyList<string> CompatibleStyles { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets room shapes this feature can appear in.
    /// </summary>
    /// <remarks>
    /// Empty list means compatible with all shapes.
    /// Some features only make sense in certain geometries.
    /// </remarks>
    public IReadOnlyList<string> CompatibleShapes { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets valid positions within a room for this feature.
    /// </summary>
    /// <remarks>
    /// Positions: "center", "perimeter", "corners", "walls", "scattered".
    /// Altars typically go in "center", pillars on "perimeter".
    /// </remarks>
    public IReadOnlyList<string> ValidPositions { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets descriptors for room text generation.
    /// </summary>
    /// <remarks>
    /// Multiple descriptors provide variety in room descriptions.
    /// Selected randomly during room generation.
    /// </remarks>
    public IReadOnlyList<string> Descriptors { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Gets the map symbol for display on the dungeon map.
    /// </summary>
    /// <remarks>
    /// Single character representing this feature on ASCII maps.
    /// Examples: 'O' for pillar, '~' for pool, '=' for platform.
    /// </remarks>
    public char MapSymbol { get; init; } = '?';

    /// <summary>
    /// Gets the selection weight for random placement.
    /// </summary>
    /// <remarks>
    /// Higher weights increase placement probability.
    /// Default is 100.
    /// </remarks>
    public int Weight { get; init; } = 100;

    /// <summary>
    /// Gets the minimum room size required for this feature.
    /// </summary>
    /// <remarks>
    /// Large features like balconies require larger rooms.
    /// 0 = no minimum size requirement.
    /// </remarks>
    public int MinRoomSize { get; init; }

    /// <summary>
    /// Gets tags for filtering and categorization.
    /// </summary>
    /// <remarks>
    /// Tags enable filtering features by characteristics
    /// (e.g., "natural", "constructed", "sacred", "hazardous").
    /// </remarks>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Private constructor for EF Core and factory method.
    /// </summary>
    private StructuralFeature() { }

    /// <summary>
    /// Creates a structural feature from configuration.
    /// </summary>
    public static StructuralFeature Create(
        string id,
        string name,
        string description,
        FeatureCategory category,
        bool providesCover = false,
        float coverBonus = 0f,
        bool blocksMovement = false,
        bool blocksLineOfSight = false,
        bool isClimbable = false,
        int heightAdvantage = 0,
        bool isInteractive = false,
        string? interactionType = null,
        IEnumerable<string>? compatibleStyles = null,
        IEnumerable<string>? compatibleShapes = null,
        IEnumerable<string>? validPositions = null,
        IEnumerable<string>? descriptors = null,
        char mapSymbol = '?',
        int weight = 100,
        int minRoomSize = 0,
        IEnumerable<string>? tags = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id, nameof(id));
        ArgumentException.ThrowIfNullOrWhiteSpace(name, nameof(name));

        if (coverBonus < 0f || coverBonus > 1f)
            throw new ArgumentOutOfRangeException(nameof(coverBonus), "Cover bonus must be between 0.0 and 1.0.");

        if (heightAdvantage < 0)
            throw new ArgumentOutOfRangeException(nameof(heightAdvantage), "Height advantage cannot be negative.");

        if (weight <= 0)
            throw new ArgumentOutOfRangeException(nameof(weight), "Weight must be positive.");

        return new StructuralFeature
        {
            Id = id,
            Name = name,
            Description = description ?? string.Empty,
            Category = category,
            ProvidesCover = providesCover,
            CoverBonus = coverBonus,
            BlocksMovement = blocksMovement,
            BlocksLineOfSight = blocksLineOfSight,
            IsClimbable = isClimbable,
            HeightAdvantage = heightAdvantage,
            IsInteractive = isInteractive,
            InteractionType = interactionType,
            CompatibleStyles = compatibleStyles?.ToList() ?? new List<string>(),
            CompatibleShapes = compatibleShapes?.ToList() ?? new List<string>(),
            ValidPositions = validPositions?.ToList() ?? new List<string>(),
            Descriptors = descriptors?.ToList() ?? new List<string>(),
            MapSymbol = mapSymbol,
            Weight = weight,
            MinRoomSize = minRoomSize,
            Tags = tags?.ToList() ?? new List<string>()
        };
    }

    /// <summary>
    /// Checks if this feature is compatible with an architectural style.
    /// </summary>
    /// <param name="styleId">The style identifier to check.</param>
    /// <returns>True if the feature is compatible.</returns>
    public bool IsCompatibleWithStyle(string styleId)
    {
        if (!CompatibleStyles.Any())
            return true;

        return CompatibleStyles.Contains(styleId, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Checks if this feature is compatible with a room shape.
    /// </summary>
    /// <param name="shape">The room shape to check.</param>
    /// <returns>True if the feature is compatible.</returns>
    public bool IsCompatibleWithShape(RoomShape shape)
    {
        if (!CompatibleShapes.Any())
            return true;

        var shapeName = shape.ToString().ToLowerInvariant();
        return CompatibleShapes.Contains(shapeName, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Checks if this feature can be placed at a position.
    /// </summary>
    /// <param name="position">The position identifier.</param>
    /// <returns>True if the position is valid for this feature.</returns>
    public bool IsValidPosition(string position)
    {
        if (!ValidPositions.Any())
            return true;

        return ValidPositions.Contains(position, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Checks if this feature has a specific tag.
    /// </summary>
    /// <param name="tag">The tag to check.</param>
    /// <returns>True if the feature has the tag.</returns>
    public bool HasTag(string tag)
    {
        return Tags.Contains(tag, StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets a random descriptor for room text generation.
    /// </summary>
    /// <param name="random">Random instance for selection.</param>
    /// <returns>A random descriptor, or the name if no descriptors defined.</returns>
    public string GetRandomDescriptor(Random random)
    {
        if (!Descriptors.Any())
            return Name.ToLowerInvariant();

        return Descriptors[random.Next(Descriptors.Count)];
    }

    /// <summary>
    /// Gets a string representation of the feature.
    /// </summary>
    public override string ToString() => $"Feature[{Id}] {Name} ({Category})";
}
```

---

## 7. FeatureCategory Enum

### 7.1 Purpose

The `FeatureCategory` enum categorizes structural features by their primary function, enabling filtering and thematic grouping.

### 7.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Enums/FeatureCategory.cs`

### 7.3 Implementation

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categories of structural features based on their function.
/// </summary>
/// <remarks>
/// Feature categories enable filtering by purpose and help
/// ensure appropriate feature selection for different room types
/// and architectural styles.
/// </remarks>
public enum FeatureCategory
{
    /// <summary>
    /// Vertical support structures (pillars, columns, beams).
    /// </summary>
    /// <remarks>
    /// Typically provide cover and block movement/LOS.
    /// Common in carved-halls and ancient-temples styles.
    /// </remarks>
    Support = 0,

    /// <summary>
    /// Raised platforms or elevation changes.
    /// </summary>
    /// <remarks>
    /// Climbable features providing height advantage.
    /// Includes daises, stages, balconies, and ledges.
    /// </remarks>
    Platform = 1,

    /// <summary>
    /// Recessed areas or niches in walls.
    /// </summary>
    /// <remarks>
    /// May contain items, statues, or provide partial cover.
    /// Common in temples and carved halls.
    /// </remarks>
    Alcove = 2,

    /// <summary>
    /// Water or liquid features.
    /// </summary>
    /// <remarks>
    /// Pools, streams, fountains. May be interactive.
    /// Can slow movement or provide environmental effects.
    /// </remarks>
    Water = 3,

    /// <summary>
    /// Decorative elements with no tactical function.
    /// </summary>
    /// <remarks>
    /// Statues, carvings, murals. Enhance room descriptions
    /// but don't affect combat or movement.
    /// </remarks>
    Decoration = 4,

    /// <summary>
    /// Functional furniture and objects.
    /// </summary>
    /// <remarks>
    /// Tables, benches, altars, chests. May be interactive
    /// and can provide partial cover.
    /// </remarks>
    Furniture = 5,

    /// <summary>
    /// Natural cave formations.
    /// </summary>
    /// <remarks>
    /// Stalagmites, stalactites, rock formations.
    /// Exclusive to natural-caves style.
    /// Provide cover and block movement.
    /// </remarks>
    Natural = 6
}
```

---

## 8. RoomFeature Value Object

### 8.1 Purpose

The `RoomFeature` value object represents a placed structural feature within a room, storing the feature reference, its position, and quantity.

### 8.2 File Location

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/RoomFeature.cs`

### 8.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a placed structural feature within a room.
/// </summary>
/// <remarks>
/// RoomFeature stores the placement information for a feature
/// in a specific room, including position and quantity.
/// Multiple RoomFeatures can reference the same feature type
/// at different positions.
/// </remarks>
public readonly record struct RoomFeature
{
    /// <summary>
    /// Gets the feature definition ID.
    /// </summary>
    /// <remarks>
    /// References a StructuralFeature by its Id.
    /// Example: "pillar", "raised-platform", "stalagmite".
    /// </remarks>
    public string FeatureId { get; init; }

    /// <summary>
    /// Gets the position within the room.
    /// </summary>
    /// <remarks>
    /// Position identifiers: "center", "perimeter", "corners",
    /// "north-wall", "south-wall", "east-wall", "west-wall",
    /// "inner-ring", "scattered", "branch-north", etc.
    /// </remarks>
    public string Position { get; init; }

    /// <summary>
    /// Gets the quantity of features at this position.
    /// </summary>
    /// <remarks>
    /// For "perimeter" position, quantity might be 4 or 8.
    /// For "center", quantity is typically 1.
    /// For "corners", quantity is typically 4.
    /// </remarks>
    public int Quantity { get; init; }

    /// <summary>
    /// Creates a room feature placement.
    /// </summary>
    /// <param name="featureId">The feature definition ID.</param>
    /// <param name="position">The position within the room.</param>
    /// <param name="quantity">The quantity at this position.</param>
    /// <returns>A new RoomFeature instance.</returns>
    /// <exception cref="ArgumentException">Thrown when featureId or position is null/empty.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when quantity is less than 1.</exception>
    public static RoomFeature Create(string featureId, string position, int quantity = 1)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(featureId, nameof(featureId));
        ArgumentException.ThrowIfNullOrWhiteSpace(position, nameof(position));

        if (quantity < 1)
            throw new ArgumentOutOfRangeException(nameof(quantity), "Quantity must be at least 1.");

        return new RoomFeature
        {
            FeatureId = featureId,
            Position = position,
            Quantity = quantity
        };
    }

    /// <summary>
    /// Creates a center-positioned feature.
    /// </summary>
    public static RoomFeature AtCenter(string featureId, int quantity = 1) =>
        Create(featureId, "center", quantity);

    /// <summary>
    /// Creates a perimeter-positioned feature.
    /// </summary>
    public static RoomFeature AtPerimeter(string featureId, int quantity) =>
        Create(featureId, "perimeter", quantity);

    /// <summary>
    /// Creates a corner-positioned feature.
    /// </summary>
    public static RoomFeature AtCorners(string featureId) =>
        Create(featureId, "corners", 4);

    /// <summary>
    /// Creates a scattered feature placement.
    /// </summary>
    public static RoomFeature Scattered(string featureId, int quantity) =>
        Create(featureId, "scattered", quantity);

    /// <summary>
    /// Gets a string representation of the room feature.
    /// </summary>
    public override string ToString() => $"{Quantity}x {FeatureId} at {Position}";
}
```

---

## 9. ShapeGeneratorService

### 9.1 Purpose

The `ShapeGeneratorService` provides shape selection based on architectural style preferences and position-based seeded randomization. It manages shape definitions and validates shape constraints.

### 9.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/IShapeGeneratorService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/ShapeGeneratorService.cs`

### 9.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for room shape selection and management.
/// </summary>
public interface IShapeGeneratorService
{
    /// <summary>
    /// Gets the shape definition for a room shape.
    /// </summary>
    /// <param name="shape">The room shape.</param>
    /// <returns>The shape definition.</returns>
    ShapeDefinition GetShapeDefinition(RoomShape shape);

    /// <summary>
    /// Gets all available shape definitions.
    /// </summary>
    /// <returns>A read-only list of all shape definitions.</returns>
    IReadOnlyList<ShapeDefinition> GetAllShapeDefinitions();

    /// <summary>
    /// Selects a room shape based on architectural style preferences.
    /// </summary>
    /// <param name="styleId">The architectural style ID.</param>
    /// <param name="position">Position for seeded randomization.</param>
    /// <returns>The selected room shape.</returns>
    RoomShape SelectShapeForStyle(string styleId, Position3D position);

    /// <summary>
    /// Gets valid exit directions for a room shape.
    /// </summary>
    /// <param name="shape">The room shape.</param>
    /// <returns>Valid exit directions.</returns>
    IReadOnlyList<Direction> GetValidExitDirections(RoomShape shape);

    /// <summary>
    /// Gets a shape descriptor for room text generation.
    /// </summary>
    /// <param name="shape">The room shape.</param>
    /// <param name="position">Position for seeded randomization.</param>
    /// <returns>A descriptive string for the shape.</returns>
    string GetShapeDescriptor(RoomShape shape, Position3D position);

    /// <summary>
    /// Parses a shape name string to RoomShape enum.
    /// </summary>
    /// <param name="shapeName">The shape name (e.g., "rectangular", "l-shaped").</param>
    /// <returns>The RoomShape enum value, or null if not found.</returns>
    RoomShape? ParseShapeName(string shapeName);

    /// <summary>
    /// Checks if a shape is compatible with a style.
    /// </summary>
    /// <param name="shape">The room shape.</param>
    /// <param name="styleId">The architectural style ID.</param>
    /// <returns>True if the shape is compatible.</returns>
    bool IsShapeCompatibleWithStyle(RoomShape shape, string styleId);
}
```

### 9.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for room shape selection and management.
/// </summary>
public class ShapeGeneratorService : IShapeGeneratorService
{
    private readonly IArchitecturalStyleService _styleService;
    private readonly SeededRandomService _random;
    private readonly ILogger<ShapeGeneratorService> _logger;

    private static readonly Dictionary<string, RoomShape> ShapeNameMap = new(StringComparer.OrdinalIgnoreCase)
    {
        ["rectangular"] = RoomShape.Rectangular,
        ["circular"] = RoomShape.Circular,
        ["l-shaped"] = RoomShape.LShaped,
        ["lshaped"] = RoomShape.LShaped,
        ["irregular"] = RoomShape.Irregular,
        ["t-shaped"] = RoomShape.TShaped,
        ["tshaped"] = RoomShape.TShaped,
        ["cross"] = RoomShape.Cross
    };

    /// <summary>
    /// Initializes a new instance of the ShapeGeneratorService.
    /// </summary>
    public ShapeGeneratorService(
        IArchitecturalStyleService styleService,
        SeededRandomService random,
        ILogger<ShapeGeneratorService> logger)
    {
        _styleService = styleService ?? throw new ArgumentNullException(nameof(styleService));
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public ShapeDefinition GetShapeDefinition(RoomShape shape)
    {
        return ShapeDefinition.ForShape(shape);
    }

    /// <inheritdoc />
    public IReadOnlyList<ShapeDefinition> GetAllShapeDefinitions()
    {
        return new[]
        {
            ShapeDefinition.Rectangular,
            ShapeDefinition.Circular,
            ShapeDefinition.LShaped,
            ShapeDefinition.Irregular,
            ShapeDefinition.TShaped,
            ShapeDefinition.Cross
        };
    }

    /// <inheritdoc />
    public RoomShape SelectShapeForStyle(string styleId, Position3D position)
    {
        var style = _styleService.GetStyle(styleId);

        if (style == null)
        {
            _logger.LogWarning("Style {StyleId} not found, using default shape", styleId);
            return RoomShape.Rectangular;
        }

        // Get preferred shapes from style
        var preferredShapes = style.PreferredShapes
            .Select(ParseShapeName)
            .Where(s => s.HasValue)
            .Select(s => s!.Value)
            .ToList();

        if (!preferredShapes.Any())
        {
            _logger.LogDebug("Style {StyleId} has no preferred shapes, using default", styleId);
            return RoomShape.Rectangular;
        }

        // Apply style rules to weight selection
        var weightedShapes = preferredShapes.Select(shape =>
        {
            var weight = 100;

            // Prefer regular shapes if style wants them
            if (style.Rules.PrefersRegularShapes)
            {
                if (shape == RoomShape.Rectangular || shape == RoomShape.Circular)
                    weight += 50;
                else if (shape == RoomShape.Irregular)
                    weight -= 30;
            }

            // Prefer symmetric shapes if style wants them
            if (style.Rules.PrefersSymmetry)
            {
                if (shape == RoomShape.Circular || shape == RoomShape.Cross)
                    weight += 40;
                else if (shape == RoomShape.LShaped || shape == RoomShape.Irregular)
                    weight -= 20;
            }

            return (shape, Math.Max(10, weight));
        });

        var selected = _random.SelectWeighted(position, weightedShapes, "shape_select");

        _logger.LogDebug(
            "Selected shape {Shape} for style {StyleId} at position ({X}, {Y}, {Z})",
            selected,
            styleId,
            position.X,
            position.Y,
            position.Z);

        return selected;
    }

    /// <inheritdoc />
    public IReadOnlyList<Direction> GetValidExitDirections(RoomShape shape)
    {
        var definition = GetShapeDefinition(shape);
        return definition.ValidExitDirections;
    }

    /// <inheritdoc />
    public string GetShapeDescriptor(RoomShape shape, Position3D position)
    {
        var definition = GetShapeDefinition(shape);
        return definition.ShapeDescriptor;
    }

    /// <inheritdoc />
    public RoomShape? ParseShapeName(string shapeName)
    {
        if (string.IsNullOrWhiteSpace(shapeName))
            return null;

        if (ShapeNameMap.TryGetValue(shapeName, out var shape))
            return shape;

        return null;
    }

    /// <inheritdoc />
    public bool IsShapeCompatibleWithStyle(RoomShape shape, string styleId)
    {
        var style = _styleService.GetStyle(styleId);
        if (style == null)
            return true;

        if (!style.PreferredShapes.Any())
            return true;

        var shapeName = shape.ToString().ToLowerInvariant();
        var kebabName = shape switch
        {
            RoomShape.LShaped => "l-shaped",
            RoomShape.TShaped => "t-shaped",
            _ => shapeName
        };

        return style.PreferredShapes.Contains(shapeName, StringComparer.OrdinalIgnoreCase) ||
               style.PreferredShapes.Contains(kebabName, StringComparer.OrdinalIgnoreCase);
    }
}
```

---

## 10. StructuralFeatureService

### 10.1 Purpose

The `StructuralFeatureService` manages structural features, providing lookup, selection, and placement functionality. It filters features by style and shape compatibility.

### 10.2 File Locations

**Interface:** `src/Core/RuneAndRust.Application/Interfaces/IStructuralFeatureService.cs`
**Implementation:** `src/Core/RuneAndRust.Application/Services/StructuralFeatureService.cs`

### 10.3 Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for structural feature management and placement.
/// </summary>
public interface IStructuralFeatureService
{
    /// <summary>
    /// Gets a structural feature by ID.
    /// </summary>
    /// <param name="featureId">The feature identifier.</param>
    /// <returns>The feature definition, or null if not found.</returns>
    StructuralFeature? GetFeature(string featureId);

    /// <summary>
    /// Gets all available structural features.
    /// </summary>
    /// <returns>A read-only list of all features.</returns>
    IReadOnlyList<StructuralFeature> GetAllFeatures();

    /// <summary>
    /// Gets features compatible with an architectural style.
    /// </summary>
    /// <param name="styleId">The style identifier.</param>
    /// <returns>Compatible features.</returns>
    IReadOnlyList<StructuralFeature> GetFeaturesForStyle(string styleId);

    /// <summary>
    /// Gets features compatible with a room shape.
    /// </summary>
    /// <param name="shape">The room shape.</param>
    /// <returns>Compatible features.</returns>
    IReadOnlyList<StructuralFeature> GetFeaturesForShape(RoomShape shape);

    /// <summary>
    /// Gets features by category.
    /// </summary>
    /// <param name="category">The feature category.</param>
    /// <returns>Features in the category.</returns>
    IReadOnlyList<StructuralFeature> GetFeaturesByCategory(FeatureCategory category);

    /// <summary>
    /// Selects features to place in a room based on style and shape.
    /// </summary>
    /// <param name="room">The room to populate.</param>
    /// <param name="style">The architectural style.</param>
    /// <returns>Selected room features for placement.</returns>
    IReadOnlyList<RoomFeature> SelectFeaturesForRoom(Room room, ArchitecturalStyle style);

    /// <summary>
    /// Places a feature in a room.
    /// </summary>
    /// <param name="room">The room to modify.</param>
    /// <param name="featureId">The feature to place.</param>
    /// <param name="position">The position within the room.</param>
    /// <param name="quantity">The quantity to place.</param>
    /// <returns>True if placement succeeded.</returns>
    bool PlaceFeature(Room room, string featureId, string position, int quantity = 1);

    /// <summary>
    /// Gets a random descriptor for a feature.
    /// </summary>
    /// <param name="featureId">The feature identifier.</param>
    /// <param name="position">Position for seeded randomization.</param>
    /// <returns>A random descriptor string.</returns>
    string GetRandomDescriptor(string featureId, Position3D position);

    /// <summary>
    /// Calculates total cover bonus from features in a room.
    /// </summary>
    /// <param name="room">The room to analyze.</param>
    /// <returns>The effective cover bonus percentage.</returns>
    float CalculateRoomCoverBonus(Room room);

    /// <summary>
    /// Gets features providing height advantage in a room.
    /// </summary>
    /// <param name="room">The room to analyze.</param>
    /// <returns>Features that can be climbed for height advantage.</returns>
    IReadOnlyList<StructuralFeature> GetClimbableFeatures(Room room);
}
```

### 10.4 Implementation

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for structural feature management and placement.
/// </summary>
public class StructuralFeatureService : IStructuralFeatureService
{
    private readonly IConfigurationProvider _config;
    private readonly IShapeGeneratorService _shapeService;
    private readonly SeededRandomService _random;
    private readonly ILogger<StructuralFeatureService> _logger;

    /// <summary>
    /// Initializes a new instance of the StructuralFeatureService.
    /// </summary>
    public StructuralFeatureService(
        IConfigurationProvider config,
        IShapeGeneratorService shapeService,
        SeededRandomService random,
        ILogger<StructuralFeatureService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _shapeService = shapeService ?? throw new ArgumentNullException(nameof(shapeService));
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public StructuralFeature? GetFeature(string featureId)
    {
        if (string.IsNullOrWhiteSpace(featureId))
            return null;

        return _config.GetStructuralFeatures()
            .FirstOrDefault(f => f.Id.Equals(featureId, StringComparison.OrdinalIgnoreCase));
    }

    /// <inheritdoc />
    public IReadOnlyList<StructuralFeature> GetAllFeatures()
    {
        return _config.GetStructuralFeatures();
    }

    /// <inheritdoc />
    public IReadOnlyList<StructuralFeature> GetFeaturesForStyle(string styleId)
    {
        return _config.GetStructuralFeatures()
            .Where(f => f.IsCompatibleWithStyle(styleId))
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<StructuralFeature> GetFeaturesForShape(RoomShape shape)
    {
        return _config.GetStructuralFeatures()
            .Where(f => f.IsCompatibleWithShape(shape))
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<StructuralFeature> GetFeaturesByCategory(FeatureCategory category)
    {
        return _config.GetStructuralFeatures()
            .Where(f => f.Category == category)
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<RoomFeature> SelectFeaturesForRoom(Room room, ArchitecturalStyle style)
    {
        var selectedFeatures = new List<RoomFeature>();

        // Get style's common features
        var styleFeatureIds = style.CommonFeatures.ToList();
        if (!styleFeatureIds.Any())
        {
            _logger.LogDebug("Style {StyleId} has no common features", style.Id);
            return selectedFeatures;
        }

        // Get compatible features
        var compatibleFeatures = styleFeatureIds
            .Select(GetFeature)
            .Where(f => f != null)
            .Where(f => f!.IsCompatibleWithShape(room.Shape))
            .ToList();

        if (!compatibleFeatures.Any())
        {
            _logger.LogDebug(
                "No compatible features for style {StyleId} and shape {Shape}",
                style.Id,
                room.Shape);
            return selectedFeatures;
        }

        // Determine feature count based on room characteristics
        var featureCount = DetermineFeatureCount(room, style);
        var shapeDefinition = _shapeService.GetShapeDefinition(room.Shape);

        // Select features
        for (int i = 0; i < featureCount; i++)
        {
            var weightedFeatures = compatibleFeatures
                .Select(f => (f!, f!.Weight));

            var selected = _random.SelectWeighted(
                room.Position,
                weightedFeatures,
                $"feature_select_{i}");

            // Select position for this feature
            var validPositions = shapeDefinition.ValidFeaturePositions
                .Where(p => selected.IsValidPosition(p))
                .ToList();

            if (!validPositions.Any())
                continue;

            var positionIndex = _random.NextForPosition(
                room.Position,
                0,
                validPositions.Count,
                $"feature_position_{i}");

            var position = validPositions[positionIndex];
            var quantity = GetQuantityForPosition(position, room.Shape);

            selectedFeatures.Add(RoomFeature.Create(selected.Id, position, quantity));

            _logger.LogDebug(
                "Selected feature {FeatureId} at {Position} (qty: {Quantity}) for room at {RoomPosition}",
                selected.Id,
                position,
                quantity,
                room.Position);
        }

        return selectedFeatures;
    }

    /// <inheritdoc />
    public bool PlaceFeature(Room room, string featureId, string position, int quantity = 1)
    {
        var feature = GetFeature(featureId);
        if (feature == null)
        {
            _logger.LogWarning("Feature {FeatureId} not found", featureId);
            return false;
        }

        if (!feature.IsCompatibleWithShape(room.Shape))
        {
            _logger.LogWarning(
                "Feature {FeatureId} is not compatible with shape {Shape}",
                featureId,
                room.Shape);
            return false;
        }

        var shapeDefinition = _shapeService.GetShapeDefinition(room.Shape);
        if (!shapeDefinition.IsValidPosition(position))
        {
            _logger.LogWarning(
                "Position {Position} is not valid for shape {Shape}",
                position,
                room.Shape);
            return false;
        }

        room.AddFeature(RoomFeature.Create(featureId, position, quantity));
        return true;
    }

    /// <inheritdoc />
    public string GetRandomDescriptor(string featureId, Position3D position)
    {
        var feature = GetFeature(featureId);
        if (feature == null)
            return string.Empty;

        if (!feature.Descriptors.Any())
            return feature.Name.ToLowerInvariant();

        var index = _random.NextForPosition(
            position,
            0,
            feature.Descriptors.Count,
            $"feature_descriptor_{featureId}");

        return feature.Descriptors[index];
    }

    /// <inheritdoc />
    public float CalculateRoomCoverBonus(Room room)
    {
        float totalCover = 0f;

        foreach (var roomFeature in room.StructuralFeatures)
        {
            var feature = GetFeature(roomFeature.FeatureId);
            if (feature?.ProvidesCover == true)
            {
                totalCover += feature.CoverBonus * roomFeature.Quantity * 0.1f;
            }
        }

        // Also add shape's natural cover
        var shapeDefinition = _shapeService.GetShapeDefinition(room.Shape);
        totalCover += shapeDefinition.NaturalCoverPercent;

        return Math.Min(1f, totalCover);
    }

    /// <inheritdoc />
    public IReadOnlyList<StructuralFeature> GetClimbableFeatures(Room room)
    {
        return room.StructuralFeatures
            .Select(rf => GetFeature(rf.FeatureId))
            .Where(f => f?.IsClimbable == true)
            .ToList()!;
    }

    private int DetermineFeatureCount(Room room, ArchitecturalStyle style)
    {
        // Base count on room size range from style
        var sizeRange = style.Rules.RoomSizeRange;
        var avgSize = (sizeRange.Min + sizeRange.Max) / 2;

        // Small rooms: 0-1 features, Medium: 1-2, Large: 2-4
        var baseCount = avgSize switch
        {
            < 4 => _random.NextForPosition(room.Position, 0, 2, "feature_count"),
            < 8 => _random.NextForPosition(room.Position, 1, 3, "feature_count"),
            < 12 => _random.NextForPosition(room.Position, 2, 4, "feature_count"),
            _ => _random.NextForPosition(room.Position, 2, 5, "feature_count")
        };

        return baseCount;
    }

    private int GetQuantityForPosition(string position, RoomShape shape)
    {
        return position.ToLowerInvariant() switch
        {
            "center" => 1,
            "corners" => 4,
            "perimeter" when shape == RoomShape.Circular => 8,
            "perimeter" => 4,
            "inner-ring" => 4,
            "scattered" => _random.Next(2, 5),
            _ when position.StartsWith("branch-") => 1,
            _ when position.EndsWith("-wall") => 1,
            _ => 1
        };
    }
}
```

---

## 11. Room Entity Integration

### 11.1 Purpose

Extend the `Room` entity to store shape and structural feature information, enabling shape-aware generation and feature-based tactical mechanics.

### 11.2 File Location

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modification)

### 11.3 Changes

```csharp
// Add to Room.cs - new using statements
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

// Add to Room.cs - new properties
/// <summary>
/// Gets the geometric shape of this room.
/// </summary>
/// <remarks>
/// Shapes affect exit placement, line of sight, natural cover,
/// and feature positioning. Set during room generation based
/// on architectural style preferences.
/// </remarks>
public RoomShape Shape { get; private set; } = RoomShape.Rectangular;

/// <summary>
/// Gets the structural features present in this room.
/// </summary>
/// <remarks>
/// Features provide tactical elements like cover, height advantage,
/// and interactive opportunities. Placed during room generation
/// based on style compatibility.
/// </remarks>
public IReadOnlyList<RoomFeature> StructuralFeatures { get; private set; } = Array.Empty<RoomFeature>();

// Add to Room.cs - new methods
/// <summary>
/// Sets the geometric shape of this room.
/// </summary>
/// <param name="shape">The room shape to set.</param>
public void SetShape(RoomShape shape)
{
    Shape = shape;
}

/// <summary>
/// Adds a structural feature to this room.
/// </summary>
/// <param name="feature">The room feature to add.</param>
/// <exception cref="ArgumentException">Thrown when feature is default.</exception>
public void AddFeature(RoomFeature feature)
{
    if (string.IsNullOrWhiteSpace(feature.FeatureId))
        throw new ArgumentException("Feature must have a valid FeatureId.", nameof(feature));

    var features = StructuralFeatures.ToList();
    features.Add(feature);
    StructuralFeatures = features;
}

/// <summary>
/// Removes a structural feature from this room by ID.
/// </summary>
/// <param name="featureId">The feature ID to remove.</param>
/// <returns>True if a feature was removed.</returns>
public bool RemoveFeature(string featureId)
{
    var features = StructuralFeatures.ToList();
    var removed = features.RemoveAll(f =>
        f.FeatureId.Equals(featureId, StringComparison.OrdinalIgnoreCase));

    if (removed > 0)
    {
        StructuralFeatures = features;
        return true;
    }

    return false;
}

/// <summary>
/// Checks if this room has a specific feature.
/// </summary>
/// <param name="featureId">The feature ID to check.</param>
/// <returns>True if the room has this feature.</returns>
public bool HasFeature(string featureId)
{
    return StructuralFeatures.Any(f =>
        f.FeatureId.Equals(featureId, StringComparison.OrdinalIgnoreCase));
}

/// <summary>
/// Gets the total quantity of a specific feature in this room.
/// </summary>
/// <param name="featureId">The feature ID to count.</param>
/// <returns>Total quantity across all placements.</returns>
public int GetFeatureCount(string featureId)
{
    return StructuralFeatures
        .Where(f => f.FeatureId.Equals(featureId, StringComparison.OrdinalIgnoreCase))
        .Sum(f => f.Quantity);
}

/// <summary>
/// Clears all structural features from this room.
/// </summary>
public void ClearFeatures()
{
    StructuralFeatures = Array.Empty<RoomFeature>();
}
```

---

## 12. Data Model Changes

### 12.1 Summary

```
NEW: RoomShape (Enum)
├── Rectangular
├── Circular
├── LShaped
├── Irregular
├── TShaped
└── Cross

NEW: FeatureCategory (Enum)
├── Support
├── Platform
├── Alcove
├── Water
├── Decoration
├── Furniture
└── Natural

NEW: ShapeDefinition (Value Object)
├── Shape: RoomShape
├── Name: string
├── ValidExitDirections: IReadOnlyList<Direction>
├── MaxExits: int
├── RequiresCardinalExits: bool
├── ClearLineOfSight: bool
├── NaturalCoverPercent: float
├── AreaMultiplier: float
├── ShapeDescriptor: string
├── ValidFeaturePositions: IReadOnlyList<string>
├── ForShape(shape): ShapeDefinition
├── IsValidPosition(position): bool
└── IsValidExitDirection(direction): bool

NEW: StructuralFeature (Definition)
├── Id: string
├── Name: string
├── Description: string
├── Category: FeatureCategory
├── ProvidesCover: bool
├── CoverBonus: float
├── BlocksMovement: bool
├── BlocksLineOfSight: bool
├── IsClimbable: bool
├── HeightAdvantage: int
├── IsInteractive: bool
├── InteractionType: string?
├── CompatibleStyles: IReadOnlyList<string>
├── CompatibleShapes: IReadOnlyList<string>
├── ValidPositions: IReadOnlyList<string>
├── Descriptors: IReadOnlyList<string>
├── MapSymbol: char
├── Weight: int
├── MinRoomSize: int
├── Tags: IReadOnlyList<string>
├── IsCompatibleWithStyle(styleId): bool
├── IsCompatibleWithShape(shape): bool
├── IsValidPosition(position): bool
├── HasTag(tag): bool
└── GetRandomDescriptor(random): string

NEW: RoomFeature (Value Object)
├── FeatureId: string
├── Position: string
├── Quantity: int
├── Create(featureId, position, quantity): RoomFeature
├── AtCenter(featureId, quantity): RoomFeature
├── AtPerimeter(featureId, quantity): RoomFeature
├── AtCorners(featureId): RoomFeature
└── Scattered(featureId, quantity): RoomFeature

MODIFY: Room
├── ADD: Shape: RoomShape (default: Rectangular)
├── ADD: StructuralFeatures: IReadOnlyList<RoomFeature>
├── ADD: SetShape(shape): void
├── ADD: AddFeature(feature): void
├── ADD: RemoveFeature(featureId): bool
├── ADD: HasFeature(featureId): bool
├── ADD: GetFeatureCount(featureId): int
└── ADD: ClearFeatures(): void

MODIFY: IConfigurationProvider
├── ADD: GetShapeDefinitions(): IReadOnlyList<ShapeDefinition>
└── ADD: GetStructuralFeatures(): IReadOnlyList<StructuralFeature>
```

---

## 13. Configuration File Schemas

### 13.1 Shape Definitions Configuration

**File:** `config/shape-definitions.json`

```json
{
  "$schema": "schemas/shape-definitions-schema.json",
  "shapes": [
    {
      "shape": "rectangular",
      "name": "Rectangular",
      "validExitDirections": ["north", "south", "east", "west"],
      "maxExits": 4,
      "requiresCardinalExits": true,
      "clearLineOfSight": true,
      "naturalCoverPercent": 0.0,
      "areaMultiplier": 1.0,
      "shapeDescriptor": "rectangular chamber",
      "validFeaturePositions": ["center", "perimeter", "corners", "north-wall", "south-wall", "east-wall", "west-wall", "scattered"]
    },
    {
      "shape": "circular",
      "name": "Circular",
      "validExitDirections": ["north", "south", "east", "west"],
      "maxExits": 4,
      "requiresCardinalExits": true,
      "clearLineOfSight": true,
      "naturalCoverPercent": 0.0,
      "areaMultiplier": 0.785,
      "shapeDescriptor": "circular chamber",
      "validFeaturePositions": ["center", "perimeter", "inner-ring", "north-wall", "south-wall", "east-wall", "west-wall", "scattered"]
    },
    {
      "shape": "l-shaped",
      "name": "L-Shaped",
      "validExitDirections": ["north", "south", "east", "west"],
      "maxExits": 3,
      "requiresCardinalExits": true,
      "clearLineOfSight": false,
      "naturalCoverPercent": 0.15,
      "areaMultiplier": 0.75,
      "shapeDescriptor": "L-shaped chamber",
      "validFeaturePositions": ["perimeter", "corners", "branch-a", "branch-b", "junction", "scattered"]
    },
    {
      "shape": "irregular",
      "name": "Irregular",
      "validExitDirections": ["north", "south", "east", "west", "up", "down"],
      "maxExits": 6,
      "requiresCardinalExits": false,
      "clearLineOfSight": false,
      "naturalCoverPercent": 0.25,
      "areaMultiplier": 0.9,
      "shapeDescriptor": "irregular cavern",
      "validFeaturePositions": ["center", "perimeter", "scattered", "natural-alcove"]
    },
    {
      "shape": "t-shaped",
      "name": "T-Shaped",
      "validExitDirections": ["north", "south", "east", "west"],
      "maxExits": 3,
      "requiresCardinalExits": true,
      "clearLineOfSight": false,
      "naturalCoverPercent": 0.0,
      "areaMultiplier": 0.75,
      "shapeDescriptor": "T-shaped junction",
      "validFeaturePositions": ["center", "branch-north", "branch-south", "branch-east", "branch-west", "scattered"]
    },
    {
      "shape": "cross",
      "name": "Cross",
      "validExitDirections": ["north", "south", "east", "west"],
      "maxExits": 4,
      "requiresCardinalExits": true,
      "clearLineOfSight": false,
      "naturalCoverPercent": 0.0,
      "areaMultiplier": 0.6,
      "shapeDescriptor": "cross-shaped chamber",
      "validFeaturePositions": ["center", "branch-north", "branch-south", "branch-east", "branch-west", "inner-ring", "scattered"]
    }
  ]
}
```

### 13.2 Structural Features Configuration

**File:** `config/structural-features.json`

```json
{
  "$schema": "schemas/structural-features-schema.json",
  "features": [
    {
      "id": "pillar",
      "name": "Stone Pillar",
      "description": "A thick stone column supporting the ceiling.",
      "category": "Support",
      "providesCover": true,
      "coverBonus": 0.5,
      "blocksMovement": true,
      "blocksLineOfSight": true,
      "isClimbable": false,
      "heightAdvantage": 0,
      "isInteractive": false,
      "compatibleStyles": ["carved-halls", "ancient-temples"],
      "compatibleShapes": [],
      "validPositions": ["perimeter", "corners", "inner-ring", "scattered"],
      "descriptors": ["thick stone pillar", "carved column", "supporting column", "ornate pillar"],
      "mapSymbol": "O",
      "weight": 100,
      "minRoomSize": 0,
      "tags": ["constructed", "support", "cover"]
    },
    {
      "id": "raised-platform",
      "name": "Raised Platform",
      "description": "An elevated stone platform accessible by steps.",
      "category": "Platform",
      "providesCover": false,
      "coverBonus": 0.0,
      "blocksMovement": false,
      "blocksLineOfSight": false,
      "isClimbable": true,
      "heightAdvantage": 1,
      "isInteractive": false,
      "compatibleStyles": ["ancient-temples", "carved-halls"],
      "compatibleShapes": ["rectangular", "circular"],
      "validPositions": ["center", "north-wall", "south-wall"],
      "descriptors": ["raised dais", "elevated platform", "stepped altar base", "stone platform"],
      "mapSymbol": "=",
      "weight": 80,
      "minRoomSize": 6,
      "tags": ["constructed", "platform", "climbable"]
    },
    {
      "id": "stalagmite",
      "name": "Stalagmite",
      "description": "A natural mineral formation rising from the floor.",
      "category": "Natural",
      "providesCover": true,
      "coverBonus": 0.3,
      "blocksMovement": true,
      "blocksLineOfSight": false,
      "isClimbable": false,
      "heightAdvantage": 0,
      "isInteractive": false,
      "compatibleStyles": ["natural-caves"],
      "compatibleShapes": ["irregular", "circular"],
      "validPositions": ["scattered", "perimeter"],
      "descriptors": ["jagged stalagmite", "mineral spire", "crystalline formation", "natural column"],
      "mapSymbol": "^",
      "weight": 100,
      "minRoomSize": 0,
      "tags": ["natural", "cave", "cover"]
    },
    {
      "id": "pool",
      "name": "Pool",
      "description": "A shallow pool of water.",
      "category": "Water",
      "providesCover": false,
      "coverBonus": 0.0,
      "blocksMovement": false,
      "blocksLineOfSight": false,
      "isClimbable": false,
      "heightAdvantage": 0,
      "isInteractive": true,
      "interactionType": "examine",
      "compatibleStyles": ["natural-caves", "ancient-temples"],
      "compatibleShapes": [],
      "validPositions": ["center", "perimeter", "scattered"],
      "descriptors": ["still pool", "shallow water", "reflecting pool", "dark pool"],
      "mapSymbol": "~",
      "weight": 70,
      "minRoomSize": 4,
      "tags": ["water", "natural", "interactive"]
    },
    {
      "id": "balcony",
      "name": "Balcony",
      "description": "An elevated walkway along the walls.",
      "category": "Platform",
      "providesCover": true,
      "coverBonus": 0.25,
      "blocksMovement": false,
      "blocksLineOfSight": false,
      "isClimbable": true,
      "heightAdvantage": 2,
      "isInteractive": false,
      "compatibleStyles": ["carved-halls", "ancient-temples"],
      "compatibleShapes": ["rectangular"],
      "validPositions": ["perimeter", "north-wall", "south-wall"],
      "descriptors": ["stone balcony", "elevated walkway", "overlooking gallery", "upper platform"],
      "mapSymbol": "_",
      "weight": 50,
      "minRoomSize": 10,
      "tags": ["constructed", "platform", "climbable", "tactical"]
    },
    {
      "id": "altar",
      "name": "Altar",
      "description": "A sacred altar for rituals and offerings.",
      "category": "Furniture",
      "providesCover": true,
      "coverBonus": 0.25,
      "blocksMovement": true,
      "blocksLineOfSight": false,
      "isClimbable": false,
      "heightAdvantage": 0,
      "isInteractive": true,
      "interactionType": "pray",
      "compatibleStyles": ["ancient-temples"],
      "compatibleShapes": ["rectangular", "circular"],
      "validPositions": ["center", "north-wall"],
      "descriptors": ["sacred altar", "stone altar", "offering table", "ceremonial altar"],
      "mapSymbol": "+",
      "weight": 60,
      "minRoomSize": 6,
      "tags": ["sacred", "furniture", "interactive"]
    },
    {
      "id": "rubble-pile",
      "name": "Rubble Pile",
      "description": "A heap of collapsed stone and debris.",
      "category": "Natural",
      "providesCover": true,
      "coverBonus": 0.4,
      "blocksMovement": true,
      "blocksLineOfSight": false,
      "isClimbable": true,
      "heightAdvantage": 1,
      "isInteractive": false,
      "compatibleStyles": ["ruined-structures"],
      "compatibleShapes": [],
      "validPositions": ["corners", "scattered", "perimeter"],
      "descriptors": ["rubble pile", "collapsed stones", "debris heap", "fallen masonry"],
      "mapSymbol": "%",
      "weight": 100,
      "minRoomSize": 0,
      "tags": ["ruined", "cover", "climbable"]
    },
    {
      "id": "statue",
      "name": "Statue",
      "description": "A stone statue of a figure or deity.",
      "category": "Decoration",
      "providesCover": true,
      "coverBonus": 0.35,
      "blocksMovement": true,
      "blocksLineOfSight": false,
      "isClimbable": false,
      "heightAdvantage": 0,
      "isInteractive": true,
      "interactionType": "examine",
      "compatibleStyles": ["ancient-temples", "carved-halls"],
      "compatibleShapes": [],
      "validPositions": ["corners", "perimeter", "center"],
      "descriptors": ["stone statue", "carved figure", "divine effigy", "ancient statue"],
      "mapSymbol": "&",
      "weight": 80,
      "minRoomSize": 0,
      "tags": ["constructed", "decoration", "cover"]
    },
    {
      "id": "ledge",
      "name": "Natural Ledge",
      "description": "A natural rock ledge jutting from the wall.",
      "category": "Platform",
      "providesCover": false,
      "coverBonus": 0.0,
      "blocksMovement": false,
      "blocksLineOfSight": false,
      "isClimbable": true,
      "heightAdvantage": 1,
      "isInteractive": false,
      "compatibleStyles": ["natural-caves"],
      "compatibleShapes": ["irregular"],
      "validPositions": ["perimeter", "natural-alcove"],
      "descriptors": ["rock ledge", "natural shelf", "stone outcrop", "jutting ledge"],
      "mapSymbol": "-",
      "weight": 70,
      "minRoomSize": 4,
      "tags": ["natural", "platform", "climbable"]
    },
    {
      "id": "fountain",
      "name": "Fountain",
      "description": "An ornate fountain, perhaps still trickling water.",
      "category": "Water",
      "providesCover": false,
      "coverBonus": 0.0,
      "blocksMovement": true,
      "blocksLineOfSight": false,
      "isClimbable": false,
      "heightAdvantage": 0,
      "isInteractive": true,
      "interactionType": "drink",
      "compatibleStyles": ["ancient-temples", "carved-halls"],
      "compatibleShapes": ["rectangular", "circular"],
      "validPositions": ["center"],
      "descriptors": ["ornate fountain", "trickling fountain", "stone basin", "ancient fountain"],
      "mapSymbol": "o",
      "weight": 40,
      "minRoomSize": 8,
      "tags": ["water", "constructed", "interactive"]
    }
  ]
}
```

### 13.3 Shape Definitions Schema

**File:** `config/schemas/shape-definitions-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "shape-definitions-schema.json",
  "title": "Shape Definitions",
  "description": "Schema for room shape definitions",
  "type": "object",
  "required": ["shapes"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "shapes": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/shapeDefinition"
      }
    }
  },
  "$defs": {
    "shapeDefinition": {
      "type": "object",
      "required": ["shape", "name", "validExitDirections", "maxExits", "shapeDescriptor"],
      "properties": {
        "shape": {
          "type": "string",
          "enum": ["rectangular", "circular", "l-shaped", "irregular", "t-shaped", "cross"],
          "description": "Shape identifier"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Display name"
        },
        "validExitDirections": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["north", "south", "east", "west", "up", "down"]
          },
          "description": "Valid exit directions for this shape"
        },
        "maxExits": {
          "type": "integer",
          "minimum": 1,
          "maximum": 6,
          "description": "Maximum number of exits"
        },
        "requiresCardinalExits": {
          "type": "boolean",
          "default": true,
          "description": "Whether exits must be on cardinal directions"
        },
        "clearLineOfSight": {
          "type": "boolean",
          "default": true,
          "description": "Whether LOS is clear across the room"
        },
        "naturalCoverPercent": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0,
          "default": 0.0,
          "description": "Natural cover percentage"
        },
        "areaMultiplier": {
          "type": "number",
          "minimum": 0.1,
          "maximum": 2.0,
          "default": 1.0,
          "description": "Area multiplier vs rectangular"
        },
        "shapeDescriptor": {
          "type": "string",
          "description": "Descriptive text for the shape"
        },
        "validFeaturePositions": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Valid positions for features in this shape"
        }
      }
    }
  }
}
```

### 13.4 Structural Features Schema

**File:** `config/schemas/structural-features-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "structural-features-schema.json",
  "title": "Structural Features",
  "description": "Schema for structural feature definitions",
  "type": "object",
  "required": ["features"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "features": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/structuralFeature"
      }
    }
  },
  "$defs": {
    "structuralFeature": {
      "type": "object",
      "required": ["id", "name", "category"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier in kebab-case"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Display name"
        },
        "description": {
          "type": "string",
          "description": "Detailed description"
        },
        "category": {
          "type": "string",
          "enum": ["Support", "Platform", "Alcove", "Water", "Decoration", "Furniture", "Natural"],
          "description": "Feature category"
        },
        "providesCover": {
          "type": "boolean",
          "default": false
        },
        "coverBonus": {
          "type": "number",
          "minimum": 0.0,
          "maximum": 1.0,
          "default": 0.0
        },
        "blocksMovement": {
          "type": "boolean",
          "default": false
        },
        "blocksLineOfSight": {
          "type": "boolean",
          "default": false
        },
        "isClimbable": {
          "type": "boolean",
          "default": false
        },
        "heightAdvantage": {
          "type": "integer",
          "minimum": 0,
          "maximum": 3,
          "default": 0
        },
        "isInteractive": {
          "type": "boolean",
          "default": false
        },
        "interactionType": {
          "type": ["string", "null"],
          "enum": ["examine", "use", "activate", "drink", "pray", null]
        },
        "compatibleStyles": {
          "type": "array",
          "items": { "type": "string" }
        },
        "compatibleShapes": {
          "type": "array",
          "items": { "type": "string" }
        },
        "validPositions": {
          "type": "array",
          "items": { "type": "string" }
        },
        "descriptors": {
          "type": "array",
          "items": { "type": "string" },
          "minItems": 1
        },
        "mapSymbol": {
          "type": "string",
          "minLength": 1,
          "maxLength": 1
        },
        "weight": {
          "type": "integer",
          "minimum": 1,
          "default": 100
        },
        "minRoomSize": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" }
        }
      }
    }
  }
}
```

---

## 14. Logging Specifications

### 14.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `ShapeGeneratorService` | Information | Shape selected for room |
| `ShapeGeneratorService` | Debug | Shape lookup, compatibility check |
| `ShapeGeneratorService` | Warning | Style not found, using default shape |
| `StructuralFeatureService` | Information | Features placed in room |
| `StructuralFeatureService` | Debug | Feature selection, position validation |
| `StructuralFeatureService` | Warning | Feature not found, incompatible placement |
| `Room` | Debug | Shape set, feature added/removed |

### 14.2 Log Message Examples

```csharp
// Information
_logger.LogInformation(
    "Selected shape {Shape} for style {StyleId} at position ({X}, {Y}, {Z})",
    selected, styleId, position.X, position.Y, position.Z);

_logger.LogInformation(
    "Placed {Count} features in room at {Position}: {Features}",
    features.Count, room.Position, string.Join(", ", features.Select(f => f.FeatureId)));

// Debug
_logger.LogDebug("Getting shape definition for {Shape}", shape);
_logger.LogDebug(
    "Selected feature {FeatureId} at {Position} (qty: {Quantity})",
    featureId, position, quantity);
_logger.LogDebug("Validating position {Position} for shape {Shape}", position, shape);

// Warning
_logger.LogWarning("Style {StyleId} not found, using default shape", styleId);
_logger.LogWarning(
    "Feature {FeatureId} is not compatible with shape {Shape}",
    featureId, shape);
_logger.LogWarning(
    "Position {Position} is not valid for shape {Shape}",
    position, shape);
```

---

## 15. Unit Testing Requirements

### 15.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| RoomShape enum | ~2 |
| ShapeDefinition value object | ~5 |
| StructuralFeature entity | ~5 |
| RoomFeature value object | ~3 |
| ShapeGeneratorService | ~4 |
| StructuralFeatureService | ~4 |
| Room shape/feature integration | ~2 |
| **Total** | **~25** |

### 15.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `RoomShapeTests.cs` | ~2 | All enum values exist, string conversion |
| `ShapeDefinitionTests.cs` | ~5 | Static factories, ForShape, IsValidPosition, IsValidExitDirection |
| `StructuralFeatureTests.cs` | ~5 | Create, validation, IsCompatibleWithStyle, IsCompatibleWithShape, GetRandomDescriptor |
| `RoomFeatureTests.cs` | ~3 | Create, factory methods, validation |
| `ShapeGeneratorServiceTests.cs` | ~4 | GetShapeDefinition, SelectShapeForStyle, ParseShapeName, IsShapeCompatibleWithStyle |
| `StructuralFeatureServiceTests.cs` | ~4 | GetFeature, GetFeaturesForStyle, SelectFeaturesForRoom, PlaceFeature |
| `RoomShapeIntegrationTests.cs` | ~2 | SetShape, AddFeature, HasFeature |

### 15.3 Test Categories

**ShapeDefinition Tests:**
```csharp
[Test]
public void ForShape_WithValidShape_ReturnsCorrectDefinition()

[Test]
public void Rectangular_HasCorrectProperties()

[Test]
public void Irregular_HasMaxSixExits()

[Test]
public void IsValidPosition_WithValidPosition_ReturnsTrue()

[Test]
public void IsValidPosition_WithInvalidPosition_ReturnsFalse()
```

**StructuralFeature Tests:**
```csharp
[Test]
public void Create_WithValidParameters_CreatesFeature()

[Test]
public void Create_WithNullId_ThrowsArgumentException()

[Test]
public void Create_WithInvalidCoverBonus_ThrowsArgumentOutOfRangeException()

[Test]
public void IsCompatibleWithStyle_WithEmptyList_ReturnsTrue()

[Test]
public void IsCompatibleWithStyle_WithMatchingStyle_ReturnsTrue()

[Test]
public void GetRandomDescriptor_ReturnsDescriptorFromPool()
```

**ShapeGeneratorService Tests:**
```csharp
[Test]
public void GetShapeDefinition_ReturnsCorrectDefinition()

[Test]
public void SelectShapeForStyle_ReturnsPreferredShape()

[Test]
public void SelectShapeForStyle_WithUnknownStyle_ReturnsRectangular()

[Test]
public void ParseShapeName_WithValidName_ReturnsShape()
```

**StructuralFeatureService Tests:**
```csharp
[Test]
public void GetFeature_WithExistingId_ReturnsFeature()

[Test]
public void GetFeaturesForStyle_ReturnsCompatibleFeatures()

[Test]
public void SelectFeaturesForRoom_ReturnsAppropriateFeatures()

[Test]
public void PlaceFeature_WithValidPosition_ReturnsTrue()
```

---

## 16. Use Cases

### UC-001: Generate Room with Shape

**Actor:** System (Room Generator)
**Flow:** RoomGeneratorService generates room → ArchitecturalStyleService provides styleId → ShapeGeneratorService.SelectShapeForStyle(styleId, position) → Room.SetShape(shape) → Room has shape-aware geometry

### UC-002: Place Features in Room

**Actor:** System (Room Generator)
**Flow:** Room generated with shape → StructuralFeatureService.SelectFeaturesForRoom(room, style) → Returns RoomFeature list → Room.AddFeature() for each → Room has features

### UC-003: Query Room Cover

**Actor:** Combat System
**Flow:** Combat initiated → StructuralFeatureService.CalculateRoomCoverBonus(room) → Returns total cover % → Combat applies cover modifier

### UC-004: Find Climbable Features

**Actor:** Player
**Flow:** Player looks for height advantage → StructuralFeatureService.GetClimbableFeatures(room) → Returns climbable features → Player can climb for bonus

### UC-005: Validate Exit Placement

**Actor:** System (Room Generator)
**Flow:** Room has shape → ShapeGeneratorService.GetValidExitDirections(shape) → Returns valid directions → Exit placement constrained

### UC-006: Generate Shape-Aware Description

**Actor:** Player
**Flow:** Player enters room → DescriptorService combines biome + style + shape + features → Generates complete room description → Player sees themed description

---

## 17. Deliverable Checklist

### Domain Layer
- [ ] `RoomShape.cs` enum created
- [ ] `FeatureCategory.cs` enum created
- [ ] `ShapeDefinition.cs` value object created
- [ ] `RoomFeature.cs` value object created
- [ ] `StructuralFeature.cs` entity created
- [ ] `Room.cs` updated with Shape and StructuralFeatures

### Application Layer
- [ ] `IShapeGeneratorService.cs` interface created
- [ ] `ShapeGeneratorService.cs` implementation created
- [ ] `IStructuralFeatureService.cs` interface created
- [ ] `StructuralFeatureService.cs` implementation created

### Infrastructure Layer
- [ ] `IConfigurationProvider.cs` updated with shape/feature methods
- [ ] `JsonConfigurationProvider.cs` updated to load shapes/features
- [ ] `ShapeDefinitionConfigDto.cs` created
- [ ] `StructuralFeatureConfigDto.cs` created

### Configuration Files
- [ ] `config/shape-definitions.json` created with 6 shapes
- [ ] `config/structural-features.json` created with 10+ features
- [ ] `config/schemas/shape-definitions-schema.json` created
- [ ] `config/schemas/structural-features-schema.json` created

### Testing
- [ ] `RoomShapeTests.cs` created (~2 tests)
- [ ] `ShapeDefinitionTests.cs` created (~5 tests)
- [ ] `StructuralFeatureTests.cs` created (~5 tests)
- [ ] `RoomFeatureTests.cs` created (~3 tests)
- [ ] `ShapeGeneratorServiceTests.cs` created (~4 tests)
- [ ] `StructuralFeatureServiceTests.cs` created (~4 tests)
- [ ] `RoomShapeIntegrationTests.cs` created (~2 tests)
- [ ] All ~25 tests passing

### Documentation
- [ ] XML documentation on all public members
- [ ] Code follows .editorconfig conventions

---

## 18. Acceptance Criteria

### Functional

- [ ] RoomShape enum includes all 6 specified shapes
- [ ] ShapeDefinition provides geometry rules for each shape
- [ ] StructuralFeature entity supports all feature properties
- [ ] Features load from JSON configuration
- [ ] ShapeGeneratorService selects shapes based on style preferences
- [ ] ShapeGeneratorService respects style rules (symmetry, regular shapes)
- [ ] StructuralFeatureService filters features by style compatibility
- [ ] StructuralFeatureService filters features by shape compatibility
- [ ] StructuralFeatureService places features at valid positions
- [ ] Room.Shape property stores selected shape
- [ ] Room.StructuralFeatures collection stores placed features
- [ ] Room.AddFeature/RemoveFeature/HasFeature methods work correctly
- [ ] Exit placement respects shape constraints
- [ ] Cover bonus calculation includes features and shape
- [ ] Climbable features provide height advantage

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~25 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on public members
- [ ] Code follows .editorconfig conventions
- [ ] No hardcoded feature/shape data outside configuration

---

## 19. Dependencies

### 19.1 Prerequisites (v0.1.3a)

| Component | Purpose for v0.1.3b |
|-----------|---------------------|
| `ArchitecturalStyle` | PreferredShapes for shape selection |
| `ArchitecturalStyle.CommonFeatures` | Feature selection for rooms |
| `ArchitecturalStyleService` | Style lookup for shape/feature compatibility |
| `StyleRules.PrefersSymmetry` | Shape selection weighting |
| `StyleRules.PrefersRegularShapes` | Shape selection weighting |
| `Room.ArchitecturalStyleId` | Style context for shape/feature selection |
| `SeededRandomService` | Reproducible shape/feature selection |
| `Position3D` | Position-based seeded randomization |
| `Direction` | Exit direction constraints |

### 19.2 Provides to Future Phases

| Component | Used By |
|-----------|---------|
| `RoomShape` | v0.1.3c (LandmarkRoom.Shape requirement) |
| `ShapeDefinition` | v0.1.3c (landmark layout constraints) |
| `StructuralFeature` | v0.1.3c (LandmarkRoom.Features) |
| `RoomFeature` | v0.1.3c (landmark feature placement) |
| `Room.Shape` | v0.1.3d (coherence validation) |
| `Room.StructuralFeatures` | v0.1.3d (age-based feature modification) |
| `ShapeGeneratorService` | v0.1.3c, v0.1.3d |
| `StructuralFeatureService` | v0.1.3c, v0.1.3d |

### 19.3 Dependency Diagram

```
v0.1.3a (Architectural Styles)
    │
    ├── ArchitecturalStyle ─────────────────────────────────────────┐
    │   ├── PreferredShapes                                         │
    │   └── CommonFeatures                                          │
    ├── ArchitecturalStyleService ──────────────────────────────────┤
    ├── StyleRules ─────────────────────────────────────────────────┤
    │   ├── PrefersSymmetry                                         │
    │   └── PrefersRegularShapes                                    │
    └── Room.ArchitecturalStyleId ──────────────────────────────────┘
                                                                    │
                                                                    ▼
v0.1.3b (Room Shapes & Features)
    │
    ├── RoomShape enum ─────────────────────────────────────────────┐
    ├── ShapeDefinition value object ───────────────────────────────┤
    ├── StructuralFeature entity ───────────────────────────────────┤
    ├── RoomFeature value object ───────────────────────────────────┤
    ├── ShapeGeneratorService ──────────────────────────────────────┤
    ├── StructuralFeatureService ───────────────────────────────────┤
    ├── Room.Shape ─────────────────────────────────────────────────┤
    └── Room.StructuralFeatures ────────────────────────────────────┘
                                                                    │
                                                                    ▼
                                      ┌─────────────────────────────┴─────────────────────────┐
                                      │                                                       │
                                      ▼                                                       ▼
                              v0.1.3c (Landmark Rooms)                           v0.1.3d (Age & Coherence)
                              └── Uses RoomShape, features                       └── Validates shape coherence
                                  for landmark layouts                               modifies features by age
```

---

## 20. Future Considerations

### 20.1 Deferred to v0.1.3c

- **LandmarkRoom shape requirements** - Landmarks specify required shapes
- **Landmark feature placement** - Fixed features in curated layouts
- **Boss arena shape constraints** - Combat-optimized geometries

### 20.2 Deferred to v0.1.3d

- **Age-modified features** - Collapsed pillars, overgrown pools
- **Coherence validation** - Shape consistency across regions
- **Feature decay** - Age affects feature condition

### 20.3 Out of Scope (Future Versions)

- **Custom shape creation** - Player/modder shape definitions
- **Dynamic feature destruction** - Features destroyed in combat
- **Multi-level rooms** - Shapes spanning Z-levels
- **Feature interactions** - Chained effects (lever opens door)
- **Procedural shape generation** - Algorithm-generated irregular shapes

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude*
