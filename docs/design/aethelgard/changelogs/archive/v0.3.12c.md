> **Archived** - This changelog has been consolidated. See the complete version at [v0.3.12](../v0.3.x/v0.3.12.md).

# Changelog: v0.3.12c - The Survivor's Cycle

**Release Date:** 2025-12-24
**Total Tests:** 2628 (12 new tests added)

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [Verification Results](#verification-results)
- [Directory Structure After v0.3.12c](#directory-structure-after-v0312c)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

Version 0.3.12c completes the E2E Integration Testing Infrastructure by adding **Persistence Journey Testing**. This release enables automated verification that game state survives simulated application restarts by creating two TestGameHost instances that share the same in-memory database. The "Survivor's Cycle" pattern tests the full save/load pipeline including JSON serialization, database persistence, and state restoration.

**Layers Touched:**
- **Test Layer:** Extended `TestGameHost` with persistence methods, created `PersistenceJourneyTests` with 12 E2E save/load tests

**Patterns Introduced:**
- **Survivor's Cycle Pattern:** Session A saves state, disposes; Session B loads from same database, verifies
- **Named Database Sharing:** Explicit `databaseName` parameter enables multiple hosts to share in-memory DB
- **State Restoration:** `LoadGameAsync()` deserializes and applies state to host's GameState singleton
- **Scoped SaveManager Access:** Proper DI scope handling for repository lifecycle

**Key Metrics:**
- 1 new file created (PersistenceJourneyTests.cs)
- 1 file modified (TestGameHost.cs)
- 12 E2E persistence integration tests
- 100% test pass rate for new tests
- 0 regressions in existing JourneyTests (9 Exploration + 12 Combat)

---

## New Files Created

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Integration/PersistenceJourneyTests.cs` | 12 E2E integration tests verifying save/load state preservation across simulated application restarts |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Tests/Infrastructure/TestGameHost.cs` | Added `DatabaseName` property for database name reuse. Added `GetSaveManager()` helper returning scoped SaveManager. Added `SaveGameAsync(int slot)` convenience method. Added `LoadGameAsync(int slot)` method that deserializes and applies state to GameState singleton. Updated constructor to accept and store database name. |

---

## Code Implementation Details

### DatabaseName Property

**Location:** `RuneAndRust.Tests/Infrastructure/TestGameHost.cs:50-54`

**Purpose:** Exposes the in-memory database name used by this host, enabling other TestGameHost instances to connect to the same database for persistence testing.

**Signature:**
```csharp
/// <summary>
/// The database name used by this test host.
/// Can be passed to another TestGameHost.Create() to share the same database (for persistence tests).
/// </summary>
public string DatabaseName { get; }
```

**Usage Pattern:**
```csharp
// Session A saves state
using (var hostA = TestGameHost.Create(seed: 42, new[] { "quit" }, "SharedDb_123"))
{
    await hostA.SetupExplorationAsync("TestCharacter");
    await hostA.SaveGameAsync(1);
}

// Session B loads from same database
using (var hostB = TestGameHost.Create(seed: 42, new[] { "quit" }, "SharedDb_123"))
{
    await hostB.LoadGameAsync(1);
    // hostB.GameState now contains Session A's state
}
```

---

### GetSaveManager Method

**Location:** `RuneAndRust.Tests/Infrastructure/TestGameHost.cs:335-345`

**Purpose:** Provides direct access to SaveManager with proper DI scope handling for advanced test scenarios requiring multiple save/load operations within a single host.

**Signature:**
```csharp
public (IServiceScope Scope, SaveManager Manager) GetSaveManager()
```

**Return Value:**

| Component | Type | Description |
|-----------|------|-------------|
| `Scope` | `IServiceScope` | The DI scope (caller must dispose) |
| `Manager` | `SaveManager` | The SaveManager instance for this scope |

**Implementation:**
```csharp
public (IServiceScope Scope, SaveManager Manager) GetSaveManager()
{
    var scope = _serviceProvider.CreateScope();
    var manager = scope.ServiceProvider.GetRequiredService<SaveManager>();
    return (scope, manager);
}
```

**Usage Pattern:**
```csharp
var (scope, saveManager) = host.GetSaveManager();
try
{
    var saves = await saveManager.GetSaveSlotSummariesAsync();
    // Process saves...
}
finally
{
    scope.Dispose();
}
```

---

### SaveGameAsync Method

**Location:** `RuneAndRust.Tests/Infrastructure/TestGameHost.cs:347-357`

**Purpose:** Convenience method that saves the host's current GameState to a specified slot using SaveManager.

**Signature:**
```csharp
public async Task<bool> SaveGameAsync(int slot)
```

**Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `slot` | `int` | The save slot number (1-3) |

**Returns:** `true` if save succeeded; `false` otherwise.

**Implementation:**
```csharp
public async Task<bool> SaveGameAsync(int slot)
{
    using var scope = _serviceProvider.CreateScope();
    var saveManager = scope.ServiceProvider.GetRequiredService<SaveManager>();
    return await saveManager.SaveGameAsync(slot, GameState);
}
```

**Behaviors:**
- Creates a scoped SaveManager instance (properly disposed after operation)
- Serializes entire GameState to JSON via SaveManager
- Stores serialized state in SaveGame entity with slot number
- Returns false if serialization or database operation fails

---

### LoadGameAsync Method

**Location:** `RuneAndRust.Tests/Infrastructure/TestGameHost.cs:359-383`

**Purpose:** Loads game state from a slot and applies it to this host's GameState singleton, enabling state restoration after simulated app restart.

**Signature:**
```csharp
public async Task<bool> LoadGameAsync(int slot)
```

**Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `slot` | `int` | The save slot number to load |

**Returns:** `true` if load and state application succeeded; `false` if slot doesn't exist or deserialization fails.

**Implementation:**
```csharp
public async Task<bool> LoadGameAsync(int slot)
{
    using var scope = _serviceProvider.CreateScope();
    var saveManager = scope.ServiceProvider.GetRequiredService<SaveManager>();
    var loadedState = await saveManager.LoadGameAsync(slot);

    if (loadedState == null)
        return false;

    // Apply loaded state to this host's GameState singleton
    var gameState = GameState;
    gameState.CurrentCharacter = loadedState.CurrentCharacter;
    gameState.CurrentRoomId = loadedState.CurrentRoomId;
    gameState.Phase = loadedState.Phase;
    gameState.TurnCount = loadedState.TurnCount;
    gameState.VisitedRoomIds = loadedState.VisitedRoomIds;
    gameState.IsSessionActive = loadedState.IsSessionActive;

    return true;
}
```

**State Properties Applied:**

| Property | Type | Description |
|----------|------|-------------|
| `CurrentCharacter` | `Character?` | Full character with inventory, stats, attributes |
| `CurrentRoomId` | `Guid?` | Player's current location |
| `Phase` | `GamePhase` | Current game phase (Exploration, Combat, etc.) |
| `TurnCount` | `int` | Number of turns elapsed |
| `VisitedRoomIds` | `HashSet<Guid>` | Fog of war tracking |
| `IsSessionActive` | `bool` | Session activity flag |

**Properties NOT Applied (JsonIgnore in GameState):**
- `PendingAction` - Runtime async bridge
- `CombatState` - Runtime combat state
- `PendingEncounter` - Runtime encounter trigger

---

### Constructor Update

**Location:** `RuneAndRust.Tests/Infrastructure/TestGameHost.cs:56-62`

**Change:** Extended constructor to accept and store database name.

**Before:**
```csharp
private TestGameHost(ServiceProvider provider, ScriptedInputHandler inputHandler, int? seed)
```

**After:**
```csharp
private TestGameHost(ServiceProvider provider, ScriptedInputHandler inputHandler, int? seed, string databaseName)
{
    _serviceProvider = provider;
    InputHandler = inputHandler;
    Seed = seed;
    DatabaseName = databaseName;
}
```

---

### PersistenceJourneyTests

**Location:** `RuneAndRust.Tests/Integration/PersistenceJourneyTests.cs`

**Purpose:** E2E integration tests for persistence (save/load) journeys that verify game state survives simulated application restarts.

**Test Categories:**

| Category | Tests | Description |
|----------|-------|-------------|
| State Preservation | 6 | Location, Character, VisitedRooms, Phase, TurnCount, Inventory |
| Slot Management | 3 | Slot isolation, overwrite behavior, non-existent slot handling |
| Infrastructure | 3 | DatabaseName exposure, shared database, complete survivor's cycle |

---

## Logging Matrix

### SaveManager (Exercised by Tests)

| Event | Level | Template | Properties |
|-------|-------|----------|------------|
| Save Started | Info | `"Starting save to slot {Slot} ('{SaveName}')"` | Slot, SaveName |
| Updating Existing | Debug | `"Updating existing save in slot {Slot}"` | Slot |
| Creating New | Debug | `"Creating new save in slot {Slot}"` | Slot |
| Save Completed | Info | `"Save completed in {Duration}ms (ID: {SaveId})"` | Duration, SaveId |
| Load Started | Info | `"Starting load from slot {Slot}"` | Slot |
| No Save Found | Warning | `"No save found in slot {Slot}"` | Slot |
| Load Completed | Info | `"Load completed in {Duration}ms from slot {Slot} ('{CharacterName}')"` | Duration, Slot, CharacterName |
| Deserialization Failed | Error | `"Failed to deserialize save data from slot {Slot}"` | Slot |

### SaveGameRepository (Exercised by Tests)

| Event | Level | Template | Properties |
|-------|-------|----------|------------|
| Entity Added | Debug | `"Added entity of type {EntityType}"` | EntityType |
| Entity Updated | Debug | `"Updated entity of type {EntityType}"` | EntityType |
| Save Changes | Debug | `"Saved {Count} entities to in-memory store"` | Count |

---

## Test Coverage

**Summary:**
```
Test Run Successful.
Total tests: 12
     Passed: 12
 Total time: 619 ms
```

### PersistenceJourneyTests (12 tests)

| Test Name | Description | Sessions |
|-----------|-------------|----------|
| `Journey_SaveLoad_PreservesLocation` | CurrentRoomId survives save/load cycle | 2 hosts |
| `Journey_SaveLoad_PreservesCharacter` | Character name, MaxHP, MaxStamina, Lineage, Archetype preserved | 2 hosts |
| `Journey_SaveLoad_PreservesVisitedRooms` | Fog of war HashSet preserved | 2 hosts |
| `Journey_SaveLoad_PreservesPhase` | GamePhase.Exploration preserved | 2 hosts |
| `Journey_SaveLoad_PreservesTurnCount` | TurnCount = 42 preserved | 2 hosts |
| `Journey_SaveLoad_DifferentSlotsAreIsolated` | Slot 1 and Slot 2 contain different characters | 4 hosts |
| `Journey_SaveLoad_OverwritesExistingSlot` | Second save to same slot replaces first | 3 hosts |
| `Journey_Load_NonExistentSlot_ReturnsFalse` | Loading empty slot returns false | 1 host |
| `Journey_DatabaseName_IsExposedForReuse` | DatabaseName property matches input | 1 host |
| `Journey_SharedDatabase_PersistsAcrossHosts` | Different hosts with same DB name share saves | 2 hosts |
| `Journey_SaveLoad_PreservesInventoryCount` | Inventory items with ItemId/Quantity preserved | 2 hosts |
| `Journey_SurvivorsCycle_CompleteStatePreservation` | Complete journey: damage, inventory, turns, fog of war | 2 hosts |

### Test Patterns Used

**Survivor's Cycle Pattern:**
```csharp
// Arrange
var sharedDbName = $"PersistenceTest_{Guid.NewGuid()}";
Guid expectedRoomId;
const int saveSlot = 1;

// --- SESSION A: The Life ---
using (var hostA = TestGameHost.Create(seed: 42, new[] { "quit" }, sharedDbName))
{
    await hostA.SetupExplorationAsync("TestCharacter");
    expectedRoomId = hostA.GameState.CurrentRoomId!.Value;
    await hostA.SaveGameAsync(saveSlot);
}
// hostA disposed - simulating app shutdown

// --- SESSION B: The Afterlife ---
using (var hostB = TestGameHost.Create(seed: 42, new[] { "quit" }, sharedDbName))
{
    await hostB.LoadGameAsync(saveSlot);
    hostB.GameState.CurrentRoomId.Should().Be(expectedRoomId);
}
```

**Multi-Host Slot Isolation Pattern:**
```csharp
// Create saves in different slots
using (var hostA = TestGameHost.Create(..., sharedDbName))
{
    await hostA.SetupExplorationAsync("Warrior One");
    await hostA.SaveGameAsync(1);
}

using (var hostB = TestGameHost.Create(..., sharedDbName))
{
    await hostB.SetupExplorationAsync("Warrior Two");
    await hostB.SaveGameAsync(2);
}

// Verify slot 1
using (var hostC = TestGameHost.Create(..., sharedDbName))
{
    await hostC.LoadGameAsync(1);
    hostC.GameState.CurrentCharacter!.Name.Should().Be("Warrior One");
}

// Verify slot 2
using (var hostD = TestGameHost.Create(..., sharedDbName))
{
    await hostD.LoadGameAsync(2);
    hostD.GameState.CurrentCharacter!.Name.Should().Be("Warrior Two");
}
```

**Complete Survivor's Cycle Pattern:**
```csharp
// SESSION A: Simulate gameplay
using (var hostA = TestGameHost.Create(..., sharedDbName))
{
    await hostA.SetupExplorationAsync("The Survivor");

    var character = hostA.GameState.CurrentCharacter!;
    character.CurrentHP -= 20;                    // Take damage
    hostA.GameState.TurnCount = 15;               // Advance turns
    character.Inventory.Add(new InventoryItem { ItemId = testItemId, Quantity = 3 });
    hostA.GameState.VisitedRoomIds.Add(Guid.NewGuid());  // Fog of war

    await hostA.SaveGameAsync(saveSlot);
}

// SESSION B: Verify complete state
using (var hostB = TestGameHost.Create(..., sharedDbName))
{
    await hostB.LoadGameAsync(saveSlot);

    var character = hostB.GameState.CurrentCharacter!;
    character.Name.Should().Be("The Survivor");
    character.CurrentHP.Should().Be(expectedCurrentHP);
    character.Inventory.Should().ContainSingle(i => i.ItemId == testItemId);
    hostB.GameState.TurnCount.Should().Be(15);
    hostB.GameState.VisitedRoomIds.Should().HaveCountGreaterThan(1);
}
```

---

## Verification Results

### Build Output

```
Build succeeded.
    0 Warning(s)
    0 Error(s)
```

### PersistenceJourneyTests Output

```
dotnet test --filter "FullyQualifiedName~PersistenceJourneyTests" --no-build

Passed!  - Failed: 0, Passed: 12, Skipped: 0, Total: 12, Duration: 619 ms
```

### All JourneyTests Regression Check

```
dotnet test --filter "FullyQualifiedName~JourneyTests" --no-build

Passed!  - Failed: 0, Passed: 33, Skipped: 0, Total: 33, Duration: 573 ms
```

### Combined E2E Test Suite

```
Total Integration Tests: 33 (9 Exploration + 12 Combat + 12 Persistence)
Pass Rate: 100%
```

---

## Directory Structure After v0.3.12c

```
RuneAndRust.Tests/
├── Infrastructure/
│   ├── ScriptedInputHandler.cs                         [v0.3.12a]
│   └── TestGameHost.cs                                 [MODIFIED - v0.3.12c]
└── Integration/
    ├── ExplorationJourneyTests.cs                      [v0.3.12a]
    ├── CombatJourneyTests.cs                           [v0.3.12b]
    └── PersistenceJourneyTests.cs                      [NEW - v0.3.12c]
```

---

## Running Tests

**Run all v0.3.12c persistence tests:**
```bash
dotnet test --filter "FullyQualifiedName~PersistenceJourneyTests"
```

**Run with verbose output:**
```bash
dotnet test --filter "PersistenceJourneyTests" --logger "console;verbosity=detailed"
```

**Run all E2E journey tests (v0.3.12a + v0.3.12b + v0.3.12c):**
```bash
dotnet test --filter "FullyQualifiedName~JourneyTests"
```

**Run specific persistence test:**
```bash
dotnet test --filter "Journey_SurvivorsCycle_CompleteStatePreservation"
```

**Run survivor's cycle tests only:**
```bash
dotnet test --filter "FullyQualifiedName~Journey_SaveLoad"
```

---

## Design Decisions

### Why In-Memory Database with Named Sharing?

**Problem:** The v0.3.12 plan suggested using `PostgreSqlTestFixture` with Docker, but this adds complexity and external dependencies.

**Solution:** EF Core's in-memory database provider supports named databases. By passing the same `databaseName` to multiple `TestGameHost.Create()` calls, they share the same in-memory storage. This approach:
- Works without Docker dependency (tests run anywhere)
- Matches existing v0.3.12a/b infrastructure patterns
- Still tests JSON serialization/deserialization (the primary concern)
- Fast execution (619ms for 12 tests)

### Why Explicit DatabaseName Property?

**Problem:** Tests need to create a second host that connects to the same database after the first host is disposed.

**Solution:** The `DatabaseName` property exposes the name used by the host, which can be captured before disposal and passed to subsequent hosts. This explicit approach is clearer than hidden state or static fields.

### Why Scoped SaveManager Access?

**Problem:** SaveManager uses scoped repositories (via SaveGameRepository) that require proper lifecycle management.

**Solution:** Both `SaveGameAsync()` and `LoadGameAsync()` create a new scope, resolve SaveManager, perform the operation, and dispose the scope. This ensures:
- Repository instances are fresh per operation
- DbContext is properly scoped
- No state leakage between operations

### Why Apply State to Singleton GameState?

**Problem:** `SaveManager.LoadGameAsync()` returns a new `GameState` instance, but the test host uses a singleton `GameState` for all services.

**Solution:** `LoadGameAsync()` copies individual properties from the loaded state to the singleton. This preserves:
- DI container integrity (services still reference the singleton)
- Test assertion capability (same `GameState` object accessible via `host.GameState`)
- Proper service behavior (services see the loaded state)

### Why Test with Minimal Scripts?

**Problem:** Persistence tests don't need to run the game loop; they only need to verify state serialization.

**Solution:** All tests use `new[] { "quit" }` as the script. This minimal script:
- Satisfies the `Create()` method's required parameter
- Allows game loop execution if needed (for debugging)
- Keeps tests focused on persistence logic

### Why Separate Tests for Each State Component?

**Problem:** A single large test might pass partially even if some state isn't preserved.

**Solution:** Individual tests for Location, Character, VisitedRooms, Phase, TurnCount, and Inventory ensure:
- Clear failure identification (which component failed)
- Independent verification
- Easier debugging
- Better documentation of what's preserved

---

## Next Steps

- **v0.3.13:** CI/CD integration with journey test scripts as regression gates
- **Future:** PostgreSQL fixture tests for real database constraints (JSONB, foreign keys)
- **Future:** Parameterized tests for multiple save slot scenarios
- **Future:** Performance benchmarks for save/load operations
- **Future:** Stress tests with large inventory and complex state

---

## Credits

**Primary Developer:** The Architect (Claude)
**Test Coverage:** 100% for new PersistenceJourneyTests (12/12 tests passing)
**Regression:** Zero regressions in existing JourneyTests (33/33 tests passing)
**Documentation:** Follows CHANGELOG_GENERATION_RULES.md Extended Template
