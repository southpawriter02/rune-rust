# v0.15.2a Design Specification: Climbing System

**Version:** 0.15.2a
**Theme:** Climbing System
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.1 Complete (Skill Context, Outcome Classification, Master Abilities, Cooperative Checks, Integration Points)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [SurfaceType Enum Extension](#4-surfacetype-enum-extension)
5. [ClimbStatus Enum](#5-climbstatus-enum)
6. [ClimbingStage Value Object](#6-climbingstage-value-object)
7. [ClimbContext Value Object](#7-climbcontext-value-object)
8. [ClimbStageResult Value Object](#8-climbstageresult-value-object)
9. [ClimbState Entity](#9-climbstate-entity)
10. [IClimbingService Interface](#10-iclimbingservice-interface)
11. [ClimbingService Implementation](#11-climbingservice-implementation)
12. [FallResult Value Object](#12-fallresult-value-object)
13. [Configuration](#13-configuration)
14. [Commands](#14-commands)
15. [User-Facing Changes](#15-user-facing-changes)
16. [Logging Specifications](#16-logging-specifications)
17. [Unit Testing Requirements](#17-unit-testing-requirements)
18. [Use Cases](#18-use-cases)
19. [Deliverable Checklist](#19-deliverable-checklist)
20. [Acceptance Criteria](#20-acceptance-criteria)
21. [Future Considerations](#21-future-considerations)
22. [Implementation Notes](#22-implementation-notes)
23. [Document Metadata](#23-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.2a, the Climbing System phase. This part introduces multi-stage climbing mechanics that allow characters to ascend heights through sequential skill checks. The key components are:

1. **ClimbingStage Value Object**: Represents one stage of a multi-stage climb, tracking height reached, surface conditions, and stage outcomes.

2. **ClimbContext Value Object**: Encapsulates all factors affecting a climb including total height, surface type, equipment modifiers, and armor penalties.

3. **ClimbState Entity**: Tracks the ongoing state of a climb, including current progress, stage history, and completion status.

4. **ClimbingService**: Orchestrates the climbing system, managing stage attempts, success/failure progression, and fall triggering.

This infrastructure enables realistic vertical traversal with meaningful mechanical depth, supporting the Acrobatics skill expansion.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Climbing Checks** | Single roll with pass/fail | Multi-stage progression based on height |
| **Height Tracking** | Not tracked | Stages calculated from total height |
| **Surface Effects** | Basic `SurfaceType` enum | Extended with `Glitched` variant |
| **Equipment Bonuses** | Ad-hoc modifiers | Structured `EquipmentModifier` with climbing gear |
| **Armor Penalties** | Not systematic | Explicit dice penalties for medium/heavy armor |
| **Fall Consequences** | Narrative only | Height-based fall damage trigger via `TheSlip` |
| **Critical Success** | Extra narrative | Advance 2 stages or reach top instantly |

### 1.3 Scope

**In Scope:**
- Extend `SurfaceType` enum with `Glitched` variant
- Define `ClimbStatus` enum for climb state tracking
- Define `ClimbingStage` value object for stage representation
- Define `ClimbContext` value object for climb configuration
- Define `ClimbStageResult` value object for stage outcomes
- Define `ClimbState` entity for ongoing climb tracking
- Create `IClimbingService` interface for climbing operations
- Implement `ClimbingService` with multi-stage logic
- Define `FallResult` value object for fall damage integration
- Configuration file `climbing-surfaces.json`
- Unit tests for climbing mechanics (~6 tests)

**Out of Scope:**
- Leaping mechanics - v0.15.2b
- Fall damage calculation - v0.15.2c
- Stealth movement - v0.15.2d
- Chase sequences - v0.15.2e
- Balance checks - v0.15.2f
- Specialization integration (Gantry-Runner) - v0.15.2g

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 2 | `SurfaceType` extension, `ClimbStatus` |
| Value Objects | 4 | `ClimbingStage`, `ClimbContext`, `ClimbStageResult`, `FallResult` |
| Entities | 1 | `ClimbState` |
| Interfaces | 1 | `IClimbingService` |
| Services | 1 | `ClimbingService` |
| Configuration | 1 | `climbing-surfaces.json` |
| Unit Tests | ~6 | Stage calculation, surface modifiers, success/failure progression, fumble fall |

---

## 2. Dependencies

### 2.1 Required from v0.15.0 (Dice Pool Refactor)

| Component | Location | Usage in v0.15.2a |
|-----------|----------|-------------------|
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Provides `NetSuccesses`, `IsFumble`, `IsCriticalSuccess` |
| `DiceConstants` | `Domain/Constants/DiceConstants.cs` | Success threshold (8), botch value (1) |
| `IDiceRollerService` | `Application/Interfaces/IDiceRollerService.cs` | Performs stage attempt dice rolls |

### 2.2 Required from v0.15.1a (Skill Context & Modifiers)

| Component | Location | Usage in v0.15.2a |
|-----------|----------|-------------------|
| `SkillContext` | `Domain/ValueObjects/SkillContext.cs` | Passed to stage attempts with modifiers |
| `SkillContextBuilder` | `Application/Services/SkillContextBuilder.cs` | Builds context for each stage |
| `EquipmentModifier` | `Domain/ValueObjects/EquipmentModifier.cs` | Climbing gear, grappling hook bonuses |
| `SurfaceType` | `Domain/Enums/SurfaceType.cs` | Extended with `Glitched` variant |
| `EnvironmentModifier` | `Domain/ValueObjects/EnvironmentModifier.cs` | Surface-based dice modifiers |

### 2.3 Required from v0.15.1b (Outcome Classification)

| Component | Location | Usage in v0.15.2a |
|-----------|----------|-------------------|
| `SkillOutcome` | `Domain/Enums/SkillOutcome.cs` | Stage result classification |
| `FumbleType` | `Domain/Enums/FumbleType.cs` | `TheSlip` for climbing fumbles |
| `FumbleConsequenceService` | `Application/Services/FumbleConsequenceService.cs` | Triggers `TheSlip` on fumble |

### 2.4 Required from v0.15.1e (Integration Points)

| Component | Location | Usage in v0.15.2a |
|-----------|----------|-------------------|
| `SkillStressResult` | `Domain/ValueObjects/SkillStressResult.cs` | Stress from climbing in corrupted areas |
| `ISkillStressService` | `Application/Interfaces/ISkillStressService.cs` | Calculates stress for climb attempts |
| `SpecializationSkillBonus` | `Domain/ValueObjects/SpecializationSkillBonus.cs` | Gantry-Runner bonuses (applied in v0.15.2g) |

### 2.5 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.2c | Fall Damage System | Uses `FallResult.FallHeight` for damage calculation |
| v0.15.2e | Chase Sequences | Uses climbing checks for `Climb` obstacles |
| v0.15.2g | Gantry-Runner | Modifies stage requirements via `[Roof-Runner]` |

---

## 3. Architecture Diagrams

### 3.1 Multi-Stage Climbing Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      MULTI-STAGE CLIMBING FLOW                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CLIMB REQUEST                                                              │
│  Player: "climb wall 40ft"                                                  │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    CALCULATE STAGES REQUIRED                         │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Height: 40ft                                                       │    │
│  │                                                                      │    │
│  │  Stage Calculation:                                                 │    │
│  │  ├── 10-20ft = 1 stage                                              │    │
│  │  ├── 30-40ft = 2 stages                                             │    │
│  │  └── 50+ft   = 3 stages                                             │    │
│  │                                                                      │    │
│  │  Result: 2 stages required                                          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    CREATE CLIMB CONTEXT                              │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  ClimbContext                                                       │    │
│  │  ├── TotalHeight: 40ft                                              │    │
│  │  ├── StagesRequired: 2                                              │    │
│  │  ├── SurfaceType: Wet                                               │    │
│  │  ├── BaseDc: 2                                                      │    │
│  │  ├── EquipmentModifiers: [Climbing Gear +1d10]                      │    │
│  │  └── ArmorPenalty: -1d10 (Medium Armor)                             │    │
│  │                                                                      │    │
│  │  Net Modifier: +1d10 - 1d10 - 1d10 = -1d10                          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    STAGE 1 ATTEMPT                                   │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Roll: 4d10 (base) - 1d10 (net modifier) = 3d10                     │    │
│  │  Result: [8, 10, 4] → 2 successes                                   │    │
│  │  DC: 2                                                               │    │
│  │  Outcome: MarginalSuccess (margin 0)                                │    │
│  │                                                                      │    │
│  │  Stage 1 Complete → Advance to Stage 2                              │    │
│  │  Height Reached: 20ft                                                │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    STAGE 2 ATTEMPT                                   │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Roll: 3d10                                                         │    │
│  │  Result: [9, 8, 6] → 2 successes                                    │    │
│  │  DC: 2                                                               │    │
│  │  Outcome: MarginalSuccess (margin 0)                                │    │
│  │                                                                      │    │
│  │  Stage 2 Complete → CLIMB COMPLETED                                 │    │
│  │  Height Reached: 40ft (top)                                          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  OUTPUT: ClimbState.Status = Completed                                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Stage Outcome Matrix

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         STAGE OUTCOME MATRIX                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  OUTCOME              │ EFFECT                                      │    │
│  ├───────────────────────┼─────────────────────────────────────────────┤    │
│  │                       │                                             │    │
│  │  CRITICAL SUCCESS     │ Advance 2 stages OR reach top               │    │
│  │  (Margin ≥ 5)         │ Message: "Magnificent climb!"               │    │
│  │                       │                                             │    │
│  ├───────────────────────┼─────────────────────────────────────────────┤    │
│  │                       │                                             │    │
│  │  SUCCESS              │ Advance 1 stage                             │    │
│  │  (Margin 0-4)         │ Message: "You make progress upward."        │    │
│  │                       │                                             │    │
│  ├───────────────────────┼─────────────────────────────────────────────┤    │
│  │                       │                                             │    │
│  │  FAILURE              │ Slip back 1 stage (min stage 0)             │    │
│  │  (Margin < 0)         │ Message: "Your grip falters..."             │    │
│  │                       │                                             │    │
│  ├───────────────────────┼─────────────────────────────────────────────┤    │
│  │                       │                                             │    │
│  │  FUMBLE               │ [The Slip] - Fall from current height       │    │
│  │  (0 successes +       │ Triggers: FallResult with current height    │    │
│  │   ≥1 botch)           │ Status: ClimbStatus.Fallen                  │    │
│  │                       │ Message: "You lose your grip entirely!"     │    │
│  │                       │                                             │    │
│  └───────────────────────┴─────────────────────────────────────────────┘    │
│                                                                              │
│  STAGE PROGRESSION DIAGRAM:                                                 │
│                                                                              │
│     Ground    Stage 1    Stage 2    Stage 3      Top                       │
│        ●─────────●─────────●─────────●───────────●                         │
│        │         │         │         │           │                         │
│      0 ft     20 ft     40 ft     50 ft      Variable                      │
│                                                                              │
│  Movement Examples:                                                         │
│  ├── Success at Stage 1 → Move to Stage 2                                  │
│  ├── Critical at Stage 1 → Move to Stage 3 (or top if only 2 stages)       │
│  ├── Failure at Stage 2 → Slip back to Stage 1                             │
│  ├── Failure at Stage 1 → Slip back to Stage 0 (ground, restart)           │
│  └── Fumble at Stage 2 → Fall 40ft, climb ends                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Surface Type Modifiers

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        SURFACE TYPE MODIFIERS                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SURFACE TYPE          DICE MODIFIER     DC MODIFIER     DESCRIPTION        │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  STABLE              +1d10            +0              Well-maintained   │    │
│  │  ○●●●●               ▲ Easier         ─               Surface           │    │
│  │                      climbing                                        │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  NORMAL              +0d10            +0              Standard surface  │    │
│  │  ●●●●●               ─ Baseline       ─                                 │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  WET                 -1d10            +0              Slippery from     │    │
│  │  ●●●●○               ▼ Harder         ─               moisture         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  COMPROMISED         -2d10            +0              Damaged,          │    │
│  │  ●●●○○               ▼▼ Much          ─               crumbling        │    │
│  │                      harder                                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  COLLAPSING          -3d10            +0              Actively falling  │    │
│  │  ●●○○○               ▼▼▼ Very         ─               apart            │    │
│  │                      hard                                            │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  GLITCHED            +0d10            +2              Corruption-       │    │
│  │  ●●●●●               ─ Same dice      ▲ Higher DC     affected         │    │
│  │  (NEW)                                                               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Equipment Modifier Table

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       EQUIPMENT MODIFIERS                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CLIMBING EQUIPMENT                                                         │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  EQUIPMENT           │ MODIFIER    │ NOTES                          │    │
│  ├──────────────────────┼─────────────┼────────────────────────────────┤    │
│  │  Climbing Gear       │ +1d10       │ Rope, pitons, harness          │    │
│  │  Grappling Hook      │ +2d10       │ Vertical surfaces only         │    │
│  └──────────────────────┴─────────────┴────────────────────────────────┘    │
│                                                                              │
│  ARMOR PENALTIES                                                            │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  ARMOR TYPE          │ PENALTY     │ REASON                         │    │
│  ├──────────────────────┼─────────────┼────────────────────────────────┤    │
│  │  Light / No Armor    │ +0d10       │ Full mobility                  │    │
│  │  Medium Armor        │ -1d10       │ Reduced flexibility            │    │
│  │  Heavy Armor         │ -4d10       │ Severe mobility restriction    │    │
│  └──────────────────────┴─────────────┴────────────────────────────────┘    │
│                                                                              │
│  EXAMPLE CALCULATION:                                                       │
│                                                                              │
│  Character with:                                                            │
│  ├── Climbing Gear (+1d10)                                                  │
│  ├── Medium Armor (-1d10)                                                   │
│  └── Wet Surface (-1d10)                                                    │
│                                                                              │
│  Net Modifier: +1 - 1 - 1 = -1d10                                           │
│                                                                              │
│  Base Pool: 4d10 (Acrobatics 2 + Agility 2)                                 │
│  Final Pool: 4d10 - 1d10 = 3d10                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.5 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Entities/                                                          │    │
│  │  └── ClimbState.cs                ←── NEW                           │    │
│  │                                                                      │    │
│  │  ValueObjects/                                                      │    │
│  │  ├── ClimbingStage.cs             ←── NEW                           │    │
│  │  ├── ClimbContext.cs              ←── NEW                           │    │
│  │  ├── ClimbStageResult.cs          ←── NEW                           │    │
│  │  └── FallResult.cs                ←── NEW                           │    │
│  │                                                                      │    │
│  │  Enums/                                                             │    │
│  │  ├── SurfaceType.cs               ←── MODIFIED (add Glitched)       │    │
│  │  └── ClimbStatus.cs               ←── NEW                           │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Interfaces/                                                        │    │
│  │  └── IClimbingService.cs          ←── NEW                           │    │
│  │                                                                      │    │
│  │  Services/                                                          │    │
│  │  └── ClimbingService.cs           ←── NEW                           │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  INFRASTRUCTURE LAYER                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Configuration/                                                     │    │
│  │  └── climbing-surfaces.json       ←── NEW                           │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. SurfaceType Enum Extension

### 4.1 Extended Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/SurfaceType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of surfaces affecting climbing and movement checks.
/// </summary>
/// <remarks>
/// <para>
/// Surface types modify dice pools for climbing checks. Most surface types
/// apply dice modifiers, while corruption-affected surfaces modify DC instead.
/// </para>
/// <para>
/// Surface type is determined by the environment and can change based on
/// weather conditions, structural damage, or corruption presence.
/// </para>
/// </remarks>
public enum SurfaceType
{
    /// <summary>
    /// Stable, well-maintained surface with good handholds.
    /// Modifier: +1d10 to climbing checks.
    /// </summary>
    /// <example>
    /// Ladder rungs, carved stone stairs, maintained scaffolding.
    /// </example>
    Stable = 0,

    /// <summary>
    /// Normal surface with no special conditions.
    /// Modifier: +0 (no bonus or penalty).
    /// </summary>
    /// <example>
    /// Standard brick wall, tree with branches, rocky cliff face.
    /// </example>
    Normal = 1,

    /// <summary>
    /// Wet or slippery surface requiring extra caution.
    /// Modifier: -1d10 to climbing checks.
    /// </summary>
    /// <example>
    /// Rain-soaked wall, moss-covered stone, condensation on metal.
    /// </example>
    Wet = 2,

    /// <summary>
    /// Damaged or unstable surface with crumbling handholds.
    /// Modifier: -2d10 to climbing checks.
    /// </summary>
    /// <example>
    /// Crumbling masonry, rotted wood, earthquake-damaged structure.
    /// </example>
    Compromised = 3,

    /// <summary>
    /// Actively falling apart, extremely dangerous to climb.
    /// Modifier: -3d10 to climbing checks.
    /// </summary>
    /// <example>
    /// Collapsing building, avalanche zone, actively burning structure.
    /// </example>
    Collapsing = 4,

    /// <summary>
    /// Corruption-affected surface that distorts perception and physics.
    /// Modifier: +2 to DC (rather than dice penalty).
    /// </summary>
    /// <remarks>
    /// Glitched surfaces appear normal but reality is unstable. Handholds
    /// may phase in and out, distances fluctuate, and gravity behaves oddly.
    /// Unlike other surface types, this affects difficulty rather than dice pool.
    /// </remarks>
    /// <example>
    /// Walls in [Glitched] zones, structures near Resonance sources.
    /// </example>
    Glitched = 5
}
```

### 4.2 Surface Type Extensions

**File:** `src/Core/RuneAndRust.Domain/Extensions/SurfaceTypeExtensions.cs`

```csharp
namespace RuneAndRust.Domain.Extensions;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Extension methods for <see cref="SurfaceType"/> enum.
/// </summary>
public static class SurfaceTypeExtensions
{
    /// <summary>
    /// Gets the dice modifier for this surface type.
    /// </summary>
    /// <param name="surfaceType">The surface type.</param>
    /// <returns>
    /// Dice pool modifier: positive for bonus, negative for penalty.
    /// Returns 0 for <see cref="SurfaceType.Glitched"/> (uses DC modifier instead).
    /// </returns>
    public static int GetDiceModifier(this SurfaceType surfaceType)
    {
        return surfaceType switch
        {
            SurfaceType.Stable => 1,
            SurfaceType.Normal => 0,
            SurfaceType.Wet => -1,
            SurfaceType.Compromised => -2,
            SurfaceType.Collapsing => -3,
            SurfaceType.Glitched => 0, // Uses DC modifier instead
            _ => 0
        };
    }

    /// <summary>
    /// Gets the DC modifier for this surface type.
    /// </summary>
    /// <param name="surfaceType">The surface type.</param>
    /// <returns>
    /// DC modifier: positive increases difficulty.
    /// Only <see cref="SurfaceType.Glitched"/> returns a non-zero value.
    /// </returns>
    public static int GetDcModifier(this SurfaceType surfaceType)
    {
        return surfaceType switch
        {
            SurfaceType.Glitched => 2,
            _ => 0
        };
    }

    /// <summary>
    /// Gets a human-readable description of the surface condition.
    /// </summary>
    /// <param name="surfaceType">The surface type.</param>
    /// <returns>A descriptive string for UI display.</returns>
    public static string GetDescription(this SurfaceType surfaceType)
    {
        return surfaceType switch
        {
            SurfaceType.Stable => "Stable surface (+1d10)",
            SurfaceType.Normal => "Normal surface",
            SurfaceType.Wet => "Wet surface (-1d10)",
            SurfaceType.Compromised => "Compromised surface (-2d10)",
            SurfaceType.Collapsing => "Collapsing surface (-3d10)",
            SurfaceType.Glitched => "Glitched surface (DC +2)",
            _ => "Unknown surface"
        };
    }

    /// <summary>
    /// Gets whether this surface type uses DC modification instead of dice modification.
    /// </summary>
    /// <param name="surfaceType">The surface type.</param>
    /// <returns>True if DC modifier should be applied instead of dice modifier.</returns>
    public static bool UsesDcModifier(this SurfaceType surfaceType)
    {
        return surfaceType == SurfaceType.Glitched;
    }
}
```

---

## 5. ClimbStatus Enum

### 5.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/ClimbStatus.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the current status of a climbing attempt.
/// </summary>
/// <remarks>
/// <para>
/// Climbing status tracks the lifecycle of a multi-stage climb from
/// initiation through completion, failure, or abandonment.
/// </para>
/// </remarks>
public enum ClimbStatus
{
    /// <summary>
    /// Climb is currently in progress. Character is on the wall.
    /// </summary>
    InProgress = 0,

    /// <summary>
    /// Climb completed successfully. Character reached the top.
    /// </summary>
    Completed = 1,

    /// <summary>
    /// Character fell during the climb due to a fumble.
    /// </summary>
    /// <remarks>
    /// Triggers <see cref="FumbleType.TheSlip"/> and fall damage calculation.
    /// </remarks>
    Fallen = 2,

    /// <summary>
    /// Character voluntarily abandoned the climb.
    /// </summary>
    /// <remarks>
    /// Character returns to their starting position safely.
    /// May be used when conditions become too dangerous to continue.
    /// </remarks>
    Abandoned = 3,

    /// <summary>
    /// Character slipped back to the ground (stage 0) due to failure.
    /// </summary>
    /// <remarks>
    /// Unlike <see cref="Fallen"/>, this occurs from a normal failure at stage 1,
    /// causing the character to slip back safely without fall damage.
    /// </remarks>
    SlippedToGround = 4
}
```

---

## 6. ClimbingStage Value Object

### 6.1 Class Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ClimbingStage.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents one stage of a multi-stage climbing attempt.
/// </summary>
/// <remarks>
/// <para>
/// Each stage represents a segment of the total climb height. Stage outcomes
/// determine progression, regression, or fall based on skill check results.
/// </para>
/// <para>
/// Height calculation per stage:
/// <list type="bullet">
///   <item><description>Stage 1: 0ft to 20ft</description></item>
///   <item><description>Stage 2: 20ft to 40ft</description></item>
///   <item><description>Stage 3: 40ft to destination</description></item>
/// </list>
/// </para>
/// </remarks>
/// <param name="StageNumber">The 1-based stage number (1, 2, or 3).</param>
/// <param name="HeightReached">Height in feet at completion of this stage.</param>
/// <param name="SurfaceType">The surface type for this stage.</param>
/// <param name="StageDc">The difficulty class for this stage.</param>
/// <param name="StageResult">The outcome of the stage attempt, null if not yet attempted.</param>
/// <param name="AttemptedAt">Timestamp when the stage was attempted.</param>
public readonly record struct ClimbingStage(
    int StageNumber,
    int HeightReached,
    SurfaceType SurfaceType,
    int StageDc,
    SkillOutcome? StageResult = null,
    DateTime? AttemptedAt = null)
{
    /// <summary>
    /// Gets the height at which the character started this stage.
    /// </summary>
    public int StartingHeight => StageNumber switch
    {
        1 => 0,
        2 => 20,
        3 => 40,
        _ => 0
    };

    /// <summary>
    /// Gets the height from which the character would fall if they fumble during this stage.
    /// </summary>
    /// <remarks>
    /// Fall height is calculated from the height reached at the end of the previous stage,
    /// which is the starting height of this stage.
    /// </remarks>
    public int FallHeight => StartingHeight;

    /// <summary>
    /// Gets a value indicating whether this stage was successfully completed.
    /// </summary>
    public bool IsCompleted => StageResult.HasValue &&
        StageResult.Value >= SkillOutcome.MarginalSuccess;

    /// <summary>
    /// Gets a value indicating whether this stage attempt was a fumble.
    /// </summary>
    public bool IsFumble => StageResult == SkillOutcome.CriticalFailure;

    /// <summary>
    /// Gets a value indicating whether this stage attempt was a critical success.
    /// </summary>
    public bool IsCriticalSuccess => StageResult == SkillOutcome.CriticalSuccess;

    /// <summary>
    /// Creates a new stage with the result recorded.
    /// </summary>
    /// <param name="result">The outcome of the stage attempt.</param>
    /// <returns>A new ClimbingStage with the result and timestamp set.</returns>
    public ClimbingStage WithResult(SkillOutcome result)
    {
        return this with
        {
            StageResult = result,
            AttemptedAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Gets a human-readable description of the stage.
    /// </summary>
    /// <returns>A formatted string describing the stage.</returns>
    public string ToDescription()
    {
        var resultStr = StageResult.HasValue
            ? $" - {StageResult.Value}"
            : " (not attempted)";
        return $"Stage {StageNumber}: {StartingHeight}ft → {HeightReached}ft (DC {StageDc}){resultStr}";
    }

    /// <inheritdoc/>
    public override string ToString() => ToDescription();
}
```

---

## 7. ClimbContext Value Object

### 7.1 Class Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ClimbContext.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Encapsulates all factors affecting a climbing attempt.
/// </summary>
/// <remarks>
/// <para>
/// The climb context is created when a climb is initiated and remains constant
/// throughout the climb attempt. It calculates the number of stages required
/// and aggregates all modifiers affecting the climb.
/// </para>
/// <para>
/// Stage calculation:
/// <list type="bullet">
///   <item><description>10-20ft = 1 stage</description></item>
///   <item><description>30-40ft = 2 stages</description></item>
///   <item><description>50+ft = 3 stages</description></item>
/// </list>
/// </para>
/// </remarks>
/// <param name="TotalHeight">Total height to climb in feet.</param>
/// <param name="SurfaceType">The surface type classification.</param>
/// <param name="BaseDc">Base difficulty class before modifiers.</param>
/// <param name="EquipmentDiceModifier">Total dice modifier from climbing equipment.</param>
/// <param name="ArmorPenalty">Dice penalty from worn armor.</param>
/// <param name="EquipmentDescription">Description of equipped climbing gear.</param>
/// <param name="ArmorDescription">Description of worn armor affecting the climb.</param>
public readonly record struct ClimbContext(
    int TotalHeight,
    SurfaceType SurfaceType,
    int BaseDc,
    int EquipmentDiceModifier = 0,
    int ArmorPenalty = 0,
    string? EquipmentDescription = null,
    string? ArmorDescription = null)
{
    /// <summary>
    /// Gets the number of stages required to complete the climb.
    /// </summary>
    /// <remarks>
    /// Stage calculation is based on total height:
    /// 10-20ft = 1 stage, 30-40ft = 2 stages, 50+ft = 3 stages.
    /// </remarks>
    public int StagesRequired => TotalHeight switch
    {
        <= 0 => 0,
        <= 20 => 1,
        <= 40 => 2,
        _ => 3
    };

    /// <summary>
    /// Gets the dice modifier from surface type.
    /// </summary>
    public int SurfaceDiceModifier => SurfaceType.GetDiceModifier();

    /// <summary>
    /// Gets the DC modifier from surface type (only for Glitched surfaces).
    /// </summary>
    public int SurfaceDcModifier => SurfaceType.GetDcModifier();

    /// <summary>
    /// Gets the total dice modifier combining surface, equipment, and armor.
    /// </summary>
    public int TotalDiceModifier => SurfaceDiceModifier + EquipmentDiceModifier + ArmorPenalty;

    /// <summary>
    /// Gets the effective DC after surface modifiers.
    /// </summary>
    public int EffectiveDc => BaseDc + SurfaceDcModifier;

    /// <summary>
    /// Gets the height reached after completing a specific stage.
    /// </summary>
    /// <param name="stageNumber">The stage number (1, 2, or 3).</param>
    /// <returns>Height in feet at the end of the stage.</returns>
    public int GetHeightAtStage(int stageNumber)
    {
        return stageNumber switch
        {
            1 => Math.Min(20, TotalHeight),
            2 => Math.Min(40, TotalHeight),
            3 => TotalHeight,
            _ => 0
        };
    }

    /// <summary>
    /// Creates a ClimbingStage for the specified stage number.
    /// </summary>
    /// <param name="stageNumber">The stage number to create.</param>
    /// <returns>A new ClimbingStage configured for this context.</returns>
    /// <exception cref="ArgumentOutOfRangeException">
    /// Thrown when stageNumber is less than 1 or greater than StagesRequired.
    /// </exception>
    public ClimbingStage CreateStage(int stageNumber)
    {
        if (stageNumber < 1 || stageNumber > StagesRequired)
        {
            throw new ArgumentOutOfRangeException(
                nameof(stageNumber),
                $"Stage number must be between 1 and {StagesRequired}.");
        }

        return new ClimbingStage(
            StageNumber: stageNumber,
            HeightReached: GetHeightAtStage(stageNumber),
            SurfaceType: SurfaceType,
            StageDc: EffectiveDc);
    }

    /// <summary>
    /// Gets a detailed description of the climb context for display.
    /// </summary>
    /// <returns>A multi-line string describing all climb factors.</returns>
    public string ToDescription()
    {
        var lines = new List<string>
        {
            $"Climbing {TotalHeight}ft ({StagesRequired} stage{(StagesRequired != 1 ? "s" : "")})",
            $"Surface: {SurfaceType.GetDescription()}",
            $"Base DC: {BaseDc}, Effective DC: {EffectiveDc}"
        };

        if (EquipmentDiceModifier != 0)
        {
            var sign = EquipmentDiceModifier > 0 ? "+" : "";
            lines.Add($"Equipment: {EquipmentDescription ?? "Climbing gear"} ({sign}{EquipmentDiceModifier}d10)");
        }

        if (ArmorPenalty != 0)
        {
            lines.Add($"Armor: {ArmorDescription ?? "Armor"} ({ArmorPenalty}d10)");
        }

        lines.Add($"Net Dice Modifier: {(TotalDiceModifier >= 0 ? "+" : "")}{TotalDiceModifier}d10");

        return string.Join(Environment.NewLine, lines);
    }

    /// <inheritdoc/>
    public override string ToString() =>
        $"Climb {TotalHeight}ft ({StagesRequired} stages, DC {EffectiveDc}, {TotalDiceModifier:+#;-#;+0}d10)";
}
```

### 7.2 Static Factory Methods

```csharp
// Additional static factory methods in ClimbContext

/// <summary>
/// Creates a climb context with standard climbing conditions.
/// </summary>
/// <param name="height">Total height to climb in feet.</param>
/// <param name="surfaceType">The surface type.</param>
/// <param name="baseDc">Base difficulty class (default: 2).</param>
/// <returns>A new ClimbContext with the specified parameters.</returns>
public static ClimbContext Create(int height, SurfaceType surfaceType, int baseDc = 2)
{
    return new ClimbContext(
        TotalHeight: height,
        SurfaceType: surfaceType,
        BaseDc: baseDc);
}

/// <summary>
/// Creates a climb context with equipment and armor modifiers.
/// </summary>
/// <param name="height">Total height to climb in feet.</param>
/// <param name="surfaceType">The surface type.</param>
/// <param name="baseDc">Base difficulty class.</param>
/// <param name="hasClimbingGear">Whether the character has climbing gear (+1d10).</param>
/// <param name="hasGrapplingHook">Whether the character has a grappling hook (+2d10).</param>
/// <param name="armorType">The type of armor worn affecting mobility.</param>
/// <returns>A new ClimbContext with all modifiers calculated.</returns>
public static ClimbContext CreateWithEquipment(
    int height,
    SurfaceType surfaceType,
    int baseDc,
    bool hasClimbingGear = false,
    bool hasGrapplingHook = false,
    ArmorWeight armorType = ArmorWeight.None)
{
    var equipmentMod = 0;
    var equipmentDesc = new List<string>();

    if (hasClimbingGear)
    {
        equipmentMod += 1;
        equipmentDesc.Add("Climbing Gear");
    }

    if (hasGrapplingHook)
    {
        equipmentMod += 2;
        equipmentDesc.Add("Grappling Hook");
    }

    var armorPenalty = armorType switch
    {
        ArmorWeight.None or ArmorWeight.Light => 0,
        ArmorWeight.Medium => -1,
        ArmorWeight.Heavy => -4,
        _ => 0
    };

    var armorDesc = armorType switch
    {
        ArmorWeight.Medium => "Medium Armor",
        ArmorWeight.Heavy => "Heavy Armor",
        _ => null
    };

    return new ClimbContext(
        TotalHeight: height,
        SurfaceType: surfaceType,
        BaseDc: baseDc,
        EquipmentDiceModifier: equipmentMod,
        ArmorPenalty: armorPenalty,
        EquipmentDescription: equipmentDesc.Count > 0 ? string.Join(", ", equipmentDesc) : null,
        ArmorDescription: armorDesc);
}
```

---

## 8. ClimbStageResult Value Object

### 8.1 Class Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ClimbStageResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the result of a single climbing stage attempt.
/// </summary>
/// <remarks>
/// <para>
/// Stage results determine progression through the climb:
/// <list type="bullet">
///   <item><description>Critical Success: Advance 2 stages or reach top</description></item>
///   <item><description>Success: Advance 1 stage</description></item>
///   <item><description>Failure: Slip back 1 stage (minimum stage 0)</description></item>
///   <item><description>Fumble: Fall from current height</description></item>
/// </list>
/// </para>
/// </remarks>
/// <param name="StageAttempted">The stage that was attempted.</param>
/// <param name="Outcome">The skill check outcome.</param>
/// <param name="NetSuccesses">Number of net successes from the dice roll.</param>
/// <param name="Margin">Margin of success or failure (NetSuccesses - DC).</param>
/// <param name="NewStage">The stage number after the attempt.</param>
/// <param name="ClimbStatus">The status of the climb after this attempt.</param>
/// <param name="FallTriggered">Whether a fall was triggered by fumble.</param>
/// <param name="FallHeight">Height fallen if fall was triggered.</param>
/// <param name="StagesAdvanced">Number of stages advanced (0, 1, or 2).</param>
/// <param name="Description">Narrative description of the outcome.</param>
public readonly record struct ClimbStageResult(
    ClimbingStage StageAttempted,
    SkillOutcome Outcome,
    int NetSuccesses,
    int Margin,
    int NewStage,
    ClimbStatus ClimbStatus,
    bool FallTriggered = false,
    int FallHeight = 0,
    int StagesAdvanced = 0,
    string? Description = null)
{
    /// <summary>
    /// Gets a value indicating whether the stage was successfully completed.
    /// </summary>
    public bool IsSuccess => Outcome >= SkillOutcome.MarginalSuccess;

    /// <summary>
    /// Gets a value indicating whether this was a critical success.
    /// </summary>
    public bool IsCriticalSuccess => Outcome == SkillOutcome.CriticalSuccess;

    /// <summary>
    /// Gets a value indicating whether this was a fumble.
    /// </summary>
    public bool IsFumble => Outcome == SkillOutcome.CriticalFailure;

    /// <summary>
    /// Gets a value indicating whether the climb is now complete.
    /// </summary>
    public bool ClimbCompleted => ClimbStatus == Enums.ClimbStatus.Completed;

    /// <summary>
    /// Creates a success result that advances the character.
    /// </summary>
    public static ClimbStageResult Success(
        ClimbingStage stage,
        SkillOutcome outcome,
        int netSuccesses,
        int margin,
        int newStage,
        int totalStages,
        int stagesAdvanced = 1)
    {
        var status = newStage >= totalStages
            ? Enums.ClimbStatus.Completed
            : Enums.ClimbStatus.InProgress;

        var desc = outcome == SkillOutcome.CriticalSuccess
            ? "Magnificent climb! You surge upward with incredible speed."
            : "You make steady progress up the surface.";

        return new ClimbStageResult(
            StageAttempted: stage.WithResult(outcome),
            Outcome: outcome,
            NetSuccesses: netSuccesses,
            Margin: margin,
            NewStage: newStage,
            ClimbStatus: status,
            StagesAdvanced: stagesAdvanced,
            Description: desc);
    }

    /// <summary>
    /// Creates a failure result that causes the character to slip back.
    /// </summary>
    public static ClimbStageResult Failure(
        ClimbingStage stage,
        SkillOutcome outcome,
        int netSuccesses,
        int margin,
        int newStage)
    {
        var status = newStage <= 0
            ? Enums.ClimbStatus.SlippedToGround
            : Enums.ClimbStatus.InProgress;

        return new ClimbStageResult(
            StageAttempted: stage.WithResult(outcome),
            Outcome: outcome,
            NetSuccesses: netSuccesses,
            Margin: margin,
            NewStage: Math.Max(0, newStage),
            ClimbStatus: status,
            Description: "Your grip falters and you slip back down.");
    }

    /// <summary>
    /// Creates a fumble result that triggers a fall.
    /// </summary>
    public static ClimbStageResult Fumble(
        ClimbingStage stage,
        int netSuccesses,
        int margin,
        int fallHeight)
    {
        return new ClimbStageResult(
            StageAttempted: stage.WithResult(SkillOutcome.CriticalFailure),
            Outcome: SkillOutcome.CriticalFailure,
            NetSuccesses: netSuccesses,
            Margin: margin,
            NewStage: 0,
            ClimbStatus: Enums.ClimbStatus.Fallen,
            FallTriggered: true,
            FallHeight: fallHeight,
            Description: "You lose your grip entirely and plummet to the ground!");
    }

    /// <summary>
    /// Gets a formatted summary of the stage result.
    /// </summary>
    public string ToSummary()
    {
        var outcomeStr = Outcome switch
        {
            SkillOutcome.CriticalSuccess => "CRITICAL SUCCESS",
            SkillOutcome.ExceptionalSuccess => "Exceptional Success",
            SkillOutcome.FullSuccess => "Success",
            SkillOutcome.MarginalSuccess => "Marginal Success",
            SkillOutcome.Failure => "Failure",
            SkillOutcome.CriticalFailure => "FUMBLE",
            _ => Outcome.ToString()
        };

        var statusStr = ClimbStatus switch
        {
            Enums.ClimbStatus.Completed => " - CLIMB COMPLETE!",
            Enums.ClimbStatus.Fallen => " - FALLEN!",
            Enums.ClimbStatus.SlippedToGround => " - Slipped to ground",
            _ => ""
        };

        return $"Stage {StageAttempted.StageNumber}: {outcomeStr} ({NetSuccesses} successes, margin {Margin}){statusStr}";
    }

    /// <inheritdoc/>
    public override string ToString() => ToSummary();
}
```

---

## 9. ClimbState Entity

### 9.1 Entity Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/ClimbState.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks the ongoing state of a multi-stage climbing attempt.
/// </summary>
/// <remarks>
/// <para>
/// The ClimbState entity maintains all information about an active climb,
/// including progress through stages, history of attempts, and final status.
/// </para>
/// <para>
/// A climb begins when <see cref="StartClimb"/> is called and ends when
/// the character reaches the top, falls, or abandons the attempt.
/// </para>
/// </remarks>
public sealed class ClimbState
{
    /// <summary>
    /// Gets the unique identifier for this climb attempt.
    /// </summary>
    public string ClimbId { get; private set; }

    /// <summary>
    /// Gets the identifier of the character making this climb attempt.
    /// </summary>
    public string CharacterId { get; private set; }

    /// <summary>
    /// Gets the climb context containing all climb parameters.
    /// </summary>
    public ClimbContext Context { get; private set; }

    /// <summary>
    /// Gets the current stage number (0 = ground, 1-3 = climbing stages).
    /// </summary>
    public int CurrentStage { get; private set; }

    /// <summary>
    /// Gets the history of completed stage attempts.
    /// </summary>
    public IReadOnlyList<ClimbingStage> StageHistory => _stageHistory.AsReadOnly();
    private readonly List<ClimbingStage> _stageHistory = new();

    /// <summary>
    /// Gets the current status of the climb.
    /// </summary>
    public ClimbStatus Status { get; private set; }

    /// <summary>
    /// Gets the timestamp when the climb was started.
    /// </summary>
    public DateTime StartedAt { get; private set; }

    /// <summary>
    /// Gets the timestamp when the climb ended, if applicable.
    /// </summary>
    public DateTime? EndedAt { get; private set; }

    /// <summary>
    /// Gets the current height of the character in feet.
    /// </summary>
    public int CurrentHeight => CurrentStage switch
    {
        0 => 0,
        1 => 20,
        2 => 40,
        _ => Context.TotalHeight
    };

    /// <summary>
    /// Gets a value indicating whether the climb is still in progress.
    /// </summary>
    public bool IsInProgress => Status == ClimbStatus.InProgress;

    /// <summary>
    /// Gets a value indicating whether the climb has ended (completed, fallen, or abandoned).
    /// </summary>
    public bool HasEnded => Status != ClimbStatus.InProgress;

    // Private constructor for factory pattern
    private ClimbState()
    {
        ClimbId = string.Empty;
        CharacterId = string.Empty;
    }

    /// <summary>
    /// Creates a new climb state for a character starting a climb.
    /// </summary>
    /// <param name="characterId">The ID of the climbing character.</param>
    /// <param name="context">The climb context with all parameters.</param>
    /// <returns>A new ClimbState ready for stage attempts.</returns>
    /// <exception cref="ArgumentException">
    /// Thrown when characterId is null or empty, or when context has invalid parameters.
    /// </exception>
    public static ClimbState StartClimb(string characterId, ClimbContext context)
    {
        if (string.IsNullOrWhiteSpace(characterId))
        {
            throw new ArgumentException("Character ID cannot be null or empty.", nameof(characterId));
        }

        if (context.TotalHeight <= 0)
        {
            throw new ArgumentException("Total height must be greater than 0.", nameof(context));
        }

        if (context.StagesRequired <= 0)
        {
            throw new ArgumentException("Stages required must be greater than 0.", nameof(context));
        }

        return new ClimbState
        {
            ClimbId = Guid.NewGuid().ToString(),
            CharacterId = characterId,
            Context = context,
            CurrentStage = 0,
            Status = ClimbStatus.InProgress,
            StartedAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Records a stage attempt and updates the climb state.
    /// </summary>
    /// <param name="result">The result of the stage attempt.</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the climb has already ended.
    /// </exception>
    public void RecordStageAttempt(ClimbStageResult result)
    {
        if (HasEnded)
        {
            throw new InvalidOperationException(
                $"Cannot record stage attempt for ended climb (status: {Status}).");
        }

        _stageHistory.Add(result.StageAttempted);
        CurrentStage = result.NewStage;
        Status = result.ClimbStatus;

        if (HasEnded)
        {
            EndedAt = DateTime.UtcNow;
        }
    }

    /// <summary>
    /// Abandons the climb, returning the character safely to the ground.
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the climb has already ended.
    /// </exception>
    public void Abandon()
    {
        if (HasEnded)
        {
            throw new InvalidOperationException(
                $"Cannot abandon ended climb (status: {Status}).");
        }

        Status = ClimbStatus.Abandoned;
        CurrentStage = 0;
        EndedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Gets the next stage to attempt, or null if the climb has ended.
    /// </summary>
    /// <returns>The next ClimbingStage to attempt, or null.</returns>
    public ClimbingStage? GetNextStage()
    {
        if (HasEnded)
        {
            return null;
        }

        var nextStageNumber = CurrentStage + 1;
        if (nextStageNumber > Context.StagesRequired)
        {
            return null;
        }

        return Context.CreateStage(nextStageNumber);
    }

    /// <summary>
    /// Gets a summary of the current climb state.
    /// </summary>
    /// <returns>A formatted string describing the climb state.</returns>
    public string ToSummary()
    {
        var statusStr = Status switch
        {
            ClimbStatus.InProgress => $"In Progress - Stage {CurrentStage}/{Context.StagesRequired}",
            ClimbStatus.Completed => "COMPLETED",
            ClimbStatus.Fallen => $"FALLEN from {CurrentHeight}ft",
            ClimbStatus.Abandoned => "Abandoned",
            ClimbStatus.SlippedToGround => "Slipped to ground",
            _ => Status.ToString()
        };

        return $"Climb {ClimbId}: {Context.TotalHeight}ft climb - {statusStr}";
    }

    /// <inheritdoc/>
    public override string ToString() => ToSummary();
}
```

---

## 10. IClimbingService Interface

### 10.1 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IClimbingService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines the contract for climbing system operations.
/// </summary>
/// <remarks>
/// <para>
/// The climbing service manages multi-stage climbing attempts, including:
/// <list type="bullet">
///   <item><description>Starting a new climb with context configuration</description></item>
///   <item><description>Attempting individual stages with skill checks</description></item>
///   <item><description>Processing falls from fumbles</description></item>
///   <item><description>Abandoning climbs safely</description></item>
/// </list>
/// </para>
/// </remarks>
public interface IClimbingService
{
    /// <summary>
    /// Starts a new climbing attempt for a character.
    /// </summary>
    /// <param name="characterId">The ID of the character starting the climb.</param>
    /// <param name="context">The climb context with all parameters.</param>
    /// <returns>A new ClimbState ready for stage attempts.</returns>
    /// <exception cref="ArgumentException">
    /// Thrown when characterId is invalid or context has invalid parameters.
    /// </exception>
    ClimbState StartClimb(string characterId, ClimbContext context);

    /// <summary>
    /// Attempts the next stage of an active climb.
    /// </summary>
    /// <param name="climbState">The current climb state.</param>
    /// <param name="baseDicePool">The character's base dice pool for Acrobatics.</param>
    /// <param name="additionalContext">Optional additional skill context modifiers.</param>
    /// <returns>The result of the stage attempt.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the climb has already ended.
    /// </exception>
    ClimbStageResult AttemptStage(
        ClimbState climbState,
        int baseDicePool,
        SkillContext? additionalContext = null);

    /// <summary>
    /// Processes a fall from a fumbled climb attempt.
    /// </summary>
    /// <param name="climbState">The climb state after a fumble.</param>
    /// <returns>A FallResult containing fall damage information.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the climb status is not Fallen.
    /// </exception>
    FallResult ProcessFall(ClimbState climbState);

    /// <summary>
    /// Abandons an active climb, returning the character safely to the ground.
    /// </summary>
    /// <param name="climbState">The climb state to abandon.</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the climb has already ended.
    /// </exception>
    void AbandonClimb(ClimbState climbState);

    /// <summary>
    /// Calculates the number of stages required for a given height.
    /// </summary>
    /// <param name="heightFeet">The total height in feet.</param>
    /// <returns>The number of stages (1, 2, or 3).</returns>
    int CalculateStagesRequired(int heightFeet);

    /// <summary>
    /// Gets the dice modifier for a given surface type.
    /// </summary>
    /// <param name="surfaceType">The surface type.</param>
    /// <returns>The dice pool modifier.</returns>
    int GetSurfaceDiceModifier(SurfaceType surfaceType);

    /// <summary>
    /// Gets the DC modifier for a given surface type.
    /// </summary>
    /// <param name="surfaceType">The surface type.</param>
    /// <returns>The DC modifier (non-zero only for Glitched surfaces).</returns>
    int GetSurfaceDcModifier(SurfaceType surfaceType);
}
```

---

## 11. ClimbingService Implementation

### 11.1 Service Implementation

**File:** `src/Core/RuneAndRust.Application/Services/ClimbingService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Extensions;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Implements multi-stage climbing mechanics for the Acrobatics skill.
/// </summary>
/// <remarks>
/// <para>
/// The climbing service orchestrates the climbing system:
/// <list type="bullet">
///   <item><description>Stage calculation based on height</description></item>
///   <item><description>Dice pool modification from surface, equipment, armor</description></item>
///   <item><description>Success/failure progression through stages</description></item>
///   <item><description>Fall triggering on fumble via [The Slip]</description></item>
/// </list>
/// </para>
/// </remarks>
public sealed class ClimbingService : IClimbingService
{
    private readonly IDiceRollerService _diceRoller;
    private readonly ISkillCheckService _skillCheckService;
    private readonly IFumbleConsequenceService _fumbleService;
    private readonly ILogger<ClimbingService> _logger;

    /// <summary>
    /// The critical success margin threshold for advancing 2 stages.
    /// </summary>
    private const int CriticalSuccessMargin = 5;

    /// <summary>
    /// Initializes a new instance of the <see cref="ClimbingService"/> class.
    /// </summary>
    /// <param name="diceRoller">The dice rolling service.</param>
    /// <param name="skillCheckService">The skill check service.</param>
    /// <param name="fumbleService">The fumble consequence service.</param>
    /// <param name="logger">The logger instance.</param>
    public ClimbingService(
        IDiceRollerService diceRoller,
        ISkillCheckService skillCheckService,
        IFumbleConsequenceService fumbleService,
        ILogger<ClimbingService> logger)
    {
        _diceRoller = diceRoller ?? throw new ArgumentNullException(nameof(diceRoller));
        _skillCheckService = skillCheckService ?? throw new ArgumentNullException(nameof(skillCheckService));
        _fumbleService = fumbleService ?? throw new ArgumentNullException(nameof(fumbleService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public ClimbState StartClimb(string characterId, ClimbContext context)
    {
        _logger.LogInformation(
            "Character {CharacterId} starting climb: {Height}ft, {Stages} stages, {Surface} surface",
            characterId,
            context.TotalHeight,
            context.StagesRequired,
            context.SurfaceType);

        return ClimbState.StartClimb(characterId, context);
    }

    /// <inheritdoc/>
    public ClimbStageResult AttemptStage(
        ClimbState climbState,
        int baseDicePool,
        SkillContext? additionalContext = null)
    {
        if (climbState.HasEnded)
        {
            throw new InvalidOperationException(
                $"Cannot attempt stage for ended climb (status: {climbState.Status}).");
        }

        var stage = climbState.GetNextStage();
        if (stage is null)
        {
            throw new InvalidOperationException("No more stages to attempt.");
        }

        var stageValue = stage.Value;

        // Calculate total dice pool
        var contextModifier = climbState.Context.TotalDiceModifier;
        var additionalModifier = additionalContext?.TotalDiceModifier ?? 0;
        var totalDicePool = Math.Max(1, baseDicePool + contextModifier + additionalModifier);

        _logger.LogDebug(
            "Attempting stage {Stage}: base {Base}d10, context {Context}d10, additional {Additional}d10 = {Total}d10",
            stageValue.StageNumber,
            baseDicePool,
            contextModifier,
            additionalModifier,
            totalDicePool);

        // Perform the dice roll
        var rollResult = _diceRoller.RollDicePool(totalDicePool);

        // Determine outcome
        var dc = stageValue.StageDc;
        var margin = rollResult.NetSuccesses - dc;
        var outcome = DetermineOutcome(rollResult, margin);

        _logger.LogInformation(
            "Stage {Stage} result: {Successes} successes vs DC {Dc}, margin {Margin}, outcome {Outcome}",
            stageValue.StageNumber,
            rollResult.NetSuccesses,
            dc,
            margin,
            outcome);

        // Process the outcome
        var result = ProcessStageOutcome(climbState, stageValue, outcome, rollResult.NetSuccesses, margin);

        // Record the attempt
        climbState.RecordStageAttempt(result);

        // Handle fumble consequence
        if (result.IsFumble)
        {
            _fumbleService.CreateConsequence(
                climbState.CharacterId,
                "acrobatics-climbing",
                FumbleType.TheSlip,
                targetId: null,
                context: $"Fell {result.FallHeight}ft while climbing");
        }

        return result;
    }

    /// <inheritdoc/>
    public FallResult ProcessFall(ClimbState climbState)
    {
        if (climbState.Status != ClimbStatus.Fallen)
        {
            throw new InvalidOperationException(
                $"Cannot process fall for climb with status {climbState.Status}.");
        }

        var lastStage = climbState.StageHistory.LastOrDefault();
        var fallHeight = lastStage.FallHeight;

        _logger.LogInformation(
            "Processing fall for {CharacterId}: {Height}ft",
            climbState.CharacterId,
            fallHeight);

        return FallResult.FromHeight(fallHeight, FallSource.Climbing);
    }

    /// <inheritdoc/>
    public void AbandonClimb(ClimbState climbState)
    {
        _logger.LogInformation(
            "Character {CharacterId} abandoning climb at stage {Stage}",
            climbState.CharacterId,
            climbState.CurrentStage);

        climbState.Abandon();
    }

    /// <inheritdoc/>
    public int CalculateStagesRequired(int heightFeet)
    {
        return heightFeet switch
        {
            <= 0 => 0,
            <= 20 => 1,
            <= 40 => 2,
            _ => 3
        };
    }

    /// <inheritdoc/>
    public int GetSurfaceDiceModifier(SurfaceType surfaceType)
    {
        return surfaceType.GetDiceModifier();
    }

    /// <inheritdoc/>
    public int GetSurfaceDcModifier(SurfaceType surfaceType)
    {
        return surfaceType.GetDcModifier();
    }

    /// <summary>
    /// Determines the skill outcome based on roll result and margin.
    /// </summary>
    private static SkillOutcome DetermineOutcome(DiceRollResult roll, int margin)
    {
        // Check for fumble first (0 successes + ≥1 botch)
        if (roll.IsFumble)
        {
            return SkillOutcome.CriticalFailure;
        }

        // Check for critical success (margin ≥ 5 OR dice roll critical)
        if (margin >= CriticalSuccessMargin || roll.IsCriticalSuccess)
        {
            return SkillOutcome.CriticalSuccess;
        }

        // Standard success/failure based on margin
        return margin switch
        {
            >= 3 => SkillOutcome.ExceptionalSuccess,
            >= 1 => SkillOutcome.FullSuccess,
            0 => SkillOutcome.MarginalSuccess,
            _ => SkillOutcome.Failure
        };
    }

    /// <summary>
    /// Processes the outcome of a stage attempt and returns the result.
    /// </summary>
    private ClimbStageResult ProcessStageOutcome(
        ClimbState climbState,
        ClimbingStage stage,
        SkillOutcome outcome,
        int netSuccesses,
        int margin)
    {
        var currentStage = climbState.CurrentStage;
        var totalStages = climbState.Context.StagesRequired;

        switch (outcome)
        {
            case SkillOutcome.CriticalFailure:
                // Fumble - fall from current height
                return ClimbStageResult.Fumble(
                    stage,
                    netSuccesses,
                    margin,
                    stage.FallHeight);

            case SkillOutcome.Failure:
                // Slip back one stage (minimum 0)
                var newStageAfterFailure = Math.Max(0, currentStage);
                return ClimbStageResult.Failure(
                    stage,
                    outcome,
                    netSuccesses,
                    margin,
                    newStageAfterFailure);

            case SkillOutcome.CriticalSuccess:
                // Advance 2 stages or reach top
                var stagesAdvanced = Math.Min(2, totalStages - currentStage);
                var newStageAfterCritical = currentStage + stagesAdvanced;
                return ClimbStageResult.Success(
                    stage,
                    outcome,
                    netSuccesses,
                    margin,
                    newStageAfterCritical,
                    totalStages,
                    stagesAdvanced);

            default:
                // Normal success - advance 1 stage
                var newStageAfterSuccess = currentStage + 1;
                return ClimbStageResult.Success(
                    stage,
                    outcome,
                    netSuccesses,
                    margin,
                    newStageAfterSuccess,
                    totalStages,
                    stagesAdvanced: 1);
        }
    }
}
```

---

## 12. FallResult Value Object

### 12.1 Class Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/FallResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the result of a fall, including height and damage calculation parameters.
/// </summary>
/// <remarks>
/// <para>
/// Fall results are created when a character falls from climbing, leaping, or other sources.
/// The actual damage calculation is handled by the Fall Damage System (v0.15.2c).
/// </para>
/// <para>
/// Damage formula (calculated in v0.15.2c):
/// <list type="bullet">
///   <item><description>Damage = (Height / 10) × 1d10</description></item>
///   <item><description>Maximum = 10d10 (100+ feet)</description></item>
///   <item><description>Crash Landing DC = 12 + (Height / 10)</description></item>
/// </list>
/// </para>
/// </remarks>
/// <param name="FallHeight">The height fallen in feet.</param>
/// <param name="Source">The source of the fall.</param>
/// <param name="DamageDice">The number of d10 damage dice (calculated from height).</param>
/// <param name="CrashLandingDc">The DC for a Crash Landing attempt.</param>
/// <param name="CanAttemptCrashLanding">Whether a Crash Landing attempt is possible.</param>
/// <param name="TriggeredByFumble">Whether the fall was triggered by a fumble.</param>
/// <param name="BonusDamage">Any bonus damage from fumble effects.</param>
public readonly record struct FallResult(
    int FallHeight,
    FallSource Source,
    int DamageDice,
    int CrashLandingDc,
    bool CanAttemptCrashLanding = true,
    bool TriggeredByFumble = false,
    int BonusDamage = 0)
{
    /// <summary>
    /// Gets a value indicating whether the fall would cause damage.
    /// </summary>
    /// <remarks>
    /// Falls from less than 10 feet typically don't cause damage.
    /// </remarks>
    public bool CausesDamage => DamageDice > 0;

    /// <summary>
    /// Gets the damage type for the fall (always Bludgeoning).
    /// </summary>
    public string DamageType => "Bludgeoning";

    /// <summary>
    /// Gets the maximum damage dice (capped at 10d10).
    /// </summary>
    public const int MaxDamageDice = 10;

    /// <summary>
    /// Creates a FallResult from a height in feet.
    /// </summary>
    /// <param name="heightFeet">The height fallen in feet.</param>
    /// <param name="source">The source of the fall.</param>
    /// <param name="triggeredByFumble">Whether the fall was triggered by a fumble.</param>
    /// <returns>A new FallResult with calculated damage parameters.</returns>
    public static FallResult FromHeight(
        int heightFeet,
        FallSource source,
        bool triggeredByFumble = true)
    {
        var damageDice = Math.Min(MaxDamageDice, heightFeet / 10);
        var crashLandingDc = 12 + (heightFeet / 10);

        return new FallResult(
            FallHeight: heightFeet,
            Source: source,
            DamageDice: damageDice,
            CrashLandingDc: crashLandingDc,
            CanAttemptCrashLanding: heightFeet >= 10,
            TriggeredByFumble: triggeredByFumble);
    }

    /// <summary>
    /// Creates a FallResult for [The Long Fall] fumble with bonus damage.
    /// </summary>
    /// <param name="heightFeet">The height fallen in feet.</param>
    /// <param name="bonusDamageDice">Additional damage dice from the fumble.</param>
    /// <returns>A new FallResult with bonus damage applied.</returns>
    public static FallResult TheLongFall(int heightFeet, int bonusDamageDice = 1)
    {
        var result = FromHeight(heightFeet, FallSource.Leaping, triggeredByFumble: true);
        return result with { BonusDamage = bonusDamageDice };
    }

    /// <summary>
    /// Gets a formatted description of the fall result.
    /// </summary>
    /// <returns>A human-readable description of the fall.</returns>
    public string ToDescription()
    {
        if (!CausesDamage)
        {
            return $"Fell {FallHeight}ft (no damage)";
        }

        var damageStr = BonusDamage > 0
            ? $"{DamageDice}d10 + {BonusDamage}d10 bonus"
            : $"{DamageDice}d10";

        return $"Fell {FallHeight}ft - {damageStr} {DamageType} damage (Crash Landing DC {CrashLandingDc})";
    }

    /// <inheritdoc/>
    public override string ToString() => ToDescription();
}

/// <summary>
/// Identifies the source of a fall for tracking and narrative purposes.
/// </summary>
public enum FallSource
{
    /// <summary>
    /// Fall from a climbing attempt.
    /// </summary>
    Climbing = 0,

    /// <summary>
    /// Fall from a failed leap attempt.
    /// </summary>
    Leaping = 1,

    /// <summary>
    /// Fall from a balance check failure.
    /// </summary>
    Balance = 2,

    /// <summary>
    /// Fall caused by external force (push, knockback).
    /// </summary>
    Pushed = 3,

    /// <summary>
    /// Fall from terrain collapse or trap.
    /// </summary>
    Environmental = 4
}
```

---

## 13. Configuration

### 13.1 climbing-surfaces.json

**File:** `src/Presentation/RuneAndRust.Console/Configuration/climbing-surfaces.json`

```json
{
  "$schema": "./climbing-surfaces.schema.json",
  "version": "0.15.2a",
  "surfaceTypes": {
    "stable": {
      "name": "Stable",
      "description": "Well-maintained surface with good handholds",
      "diceModifier": 1,
      "dcModifier": 0,
      "examples": [
        "Ladder rungs",
        "Carved stone stairs",
        "Maintained scaffolding"
      ]
    },
    "normal": {
      "name": "Normal",
      "description": "Standard surface with no special conditions",
      "diceModifier": 0,
      "dcModifier": 0,
      "examples": [
        "Standard brick wall",
        "Tree with branches",
        "Rocky cliff face"
      ]
    },
    "wet": {
      "name": "Wet",
      "description": "Slippery surface requiring extra caution",
      "diceModifier": -1,
      "dcModifier": 0,
      "examples": [
        "Rain-soaked wall",
        "Moss-covered stone",
        "Condensation on metal"
      ]
    },
    "compromised": {
      "name": "Compromised",
      "description": "Damaged or unstable surface with crumbling handholds",
      "diceModifier": -2,
      "dcModifier": 0,
      "examples": [
        "Crumbling masonry",
        "Rotted wood",
        "Earthquake-damaged structure"
      ]
    },
    "collapsing": {
      "name": "Collapsing",
      "description": "Actively falling apart, extremely dangerous",
      "diceModifier": -3,
      "dcModifier": 0,
      "examples": [
        "Collapsing building",
        "Avalanche zone",
        "Actively burning structure"
      ]
    },
    "glitched": {
      "name": "Glitched",
      "description": "Corruption-affected surface with unstable reality",
      "diceModifier": 0,
      "dcModifier": 2,
      "examples": [
        "Walls in [Glitched] zones",
        "Structures near Resonance sources"
      ]
    }
  },
  "equipmentModifiers": {
    "climbingGear": {
      "name": "Climbing Gear",
      "description": "Rope, pitons, and harness",
      "diceModifier": 1,
      "requirements": []
    },
    "grapplingHook": {
      "name": "Grappling Hook",
      "description": "Hook and rope for vertical surfaces",
      "diceModifier": 2,
      "requirements": ["verticalSurface"]
    }
  },
  "armorPenalties": {
    "none": {
      "name": "No Armor",
      "diceModifier": 0
    },
    "light": {
      "name": "Light Armor",
      "diceModifier": 0
    },
    "medium": {
      "name": "Medium Armor",
      "diceModifier": -1
    },
    "heavy": {
      "name": "Heavy Armor",
      "diceModifier": -4
    }
  },
  "stageCalculation": {
    "heights": [
      { "minHeight": 1, "maxHeight": 20, "stages": 1 },
      { "minHeight": 21, "maxHeight": 40, "stages": 2 },
      { "minHeight": 41, "maxHeight": null, "stages": 3 }
    ],
    "heightPerStage": {
      "stage1": 20,
      "stage2": 20,
      "stage3": "remaining"
    }
  },
  "outcomes": {
    "criticalSuccess": {
      "stagesAdvanced": 2,
      "description": "Magnificent climb! You surge upward with incredible speed."
    },
    "success": {
      "stagesAdvanced": 1,
      "description": "You make steady progress up the surface."
    },
    "failure": {
      "stagesLost": 1,
      "description": "Your grip falters and you slip back down."
    },
    "fumble": {
      "effect": "fall",
      "fumbleType": "TheSlip",
      "description": "You lose your grip entirely and plummet to the ground!"
    }
  },
  "defaults": {
    "baseDc": 2,
    "minimumDicePool": 1
  }
}
```

### 13.2 Configuration Schema

**File:** `src/Presentation/RuneAndRust.Console/Configuration/climbing-surfaces.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "climbing-surfaces.schema.json",
  "title": "Climbing Surfaces Configuration",
  "description": "Configuration for climbing system surface types and modifiers",
  "type": "object",
  "required": ["version", "surfaceTypes", "equipmentModifiers", "armorPenalties", "stageCalculation", "outcomes", "defaults"],
  "properties": {
    "version": {
      "type": "string",
      "description": "Configuration version"
    },
    "surfaceTypes": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "required": ["name", "description", "diceModifier", "dcModifier"],
        "properties": {
          "name": { "type": "string" },
          "description": { "type": "string" },
          "diceModifier": { "type": "integer", "minimum": -10, "maximum": 10 },
          "dcModifier": { "type": "integer", "minimum": 0, "maximum": 10 },
          "examples": { "type": "array", "items": { "type": "string" } }
        }
      }
    },
    "equipmentModifiers": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "required": ["name", "description", "diceModifier"],
        "properties": {
          "name": { "type": "string" },
          "description": { "type": "string" },
          "diceModifier": { "type": "integer", "minimum": 0, "maximum": 10 },
          "requirements": { "type": "array", "items": { "type": "string" } }
        }
      }
    },
    "armorPenalties": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "required": ["name", "diceModifier"],
        "properties": {
          "name": { "type": "string" },
          "diceModifier": { "type": "integer", "maximum": 0 }
        }
      }
    },
    "stageCalculation": {
      "type": "object",
      "required": ["heights", "heightPerStage"],
      "properties": {
        "heights": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["minHeight", "stages"],
            "properties": {
              "minHeight": { "type": "integer", "minimum": 1 },
              "maxHeight": { "type": ["integer", "null"] },
              "stages": { "type": "integer", "minimum": 1, "maximum": 3 }
            }
          }
        },
        "heightPerStage": {
          "type": "object"
        }
      }
    },
    "outcomes": {
      "type": "object",
      "required": ["criticalSuccess", "success", "failure", "fumble"],
      "properties": {
        "criticalSuccess": {
          "type": "object",
          "required": ["stagesAdvanced", "description"],
          "properties": {
            "stagesAdvanced": { "type": "integer" },
            "description": { "type": "string" }
          }
        },
        "success": {
          "type": "object",
          "required": ["stagesAdvanced", "description"],
          "properties": {
            "stagesAdvanced": { "type": "integer" },
            "description": { "type": "string" }
          }
        },
        "failure": {
          "type": "object",
          "required": ["stagesLost", "description"],
          "properties": {
            "stagesLost": { "type": "integer" },
            "description": { "type": "string" }
          }
        },
        "fumble": {
          "type": "object",
          "required": ["effect", "fumbleType", "description"],
          "properties": {
            "effect": { "type": "string" },
            "fumbleType": { "type": "string" },
            "description": { "type": "string" }
          }
        }
      }
    },
    "defaults": {
      "type": "object",
      "required": ["baseDc", "minimumDicePool"],
      "properties": {
        "baseDc": { "type": "integer", "minimum": 1 },
        "minimumDicePool": { "type": "integer", "minimum": 1 }
      }
    }
  }
}
```

---

## 14. Commands

### 14.1 Climb Command

```csharp
/// <summary>
/// Command to initiate or continue a climbing attempt.
/// </summary>
/// <param name="TargetHeight">The total height to climb in feet.</param>
/// <param name="SurfaceType">Optional surface type override.</param>
public record ClimbCommand(
    int? TargetHeight = null,
    SurfaceType? SurfaceType = null) : GameCommand;
```

### 14.2 Command Parsing

```csharp
// In ConsoleInputHandler.ParseCommand():

"climb" => ParseClimbCommand(argument),

private GameCommand ParseClimbCommand(string? argument)
{
    if (string.IsNullOrWhiteSpace(argument))
    {
        // Continue existing climb
        return new ClimbCommand();
    }

    // Parse height: "climb 40" or "climb 40ft"
    var heightMatch = Regex.Match(argument, @"(\d+)\s*(ft|feet)?", RegexOptions.IgnoreCase);
    if (heightMatch.Success)
    {
        var height = int.Parse(heightMatch.Groups[1].Value);
        return new ClimbCommand(TargetHeight: height);
    }

    return new ClimbCommand();
}
```

### 14.3 User Commands

| Command | Description | Example |
|---------|-------------|---------|
| `climb <height>` | Start climbing to specified height | `climb 40ft` |
| `climb` | Continue current climb (attempt next stage) | `climb` |
| `abandon climb` | Safely abandon current climb | `abandon climb` |

---

## 15. User-Facing Changes

### 15.1 Display Example - Starting a Climb

```
> climb 40ft

╔══════════════════════════════════════════════════════════════════╗
║                    CLIMBING ATTEMPT                              ║
╠══════════════════════════════════════════════════════════════════╣
║  Target: 40ft (2 stages required)                                ║
║  Surface: Wet (-1d10)                                            ║
║  Equipment: Climbing Gear (+1d10)                                ║
║  Armor: Medium Armor (-1d10)                                     ║
║  Base DC: 2                                                      ║
║  Net Modifier: -1d10                                             ║
╚══════════════════════════════════════════════════════════════════╝

Stage 1 of 2 (0ft → 20ft)
Rolling 3d10 vs DC 2...
```

### 15.2 Display Example - Stage Success

```
╔══════════════════════════════════════════════════════════════════╗
║  Stage 1: SUCCESS                                                ║
╠══════════════════════════════════════════════════════════════════╣
║  Roll: [8, 10, 4] → 2 successes                                  ║
║  vs DC 2 (margin: 0)                                             ║
║                                                                  ║
║  You make steady progress up the surface.                        ║
║                                                                  ║
║  Progress: ●━━━━━━━━━━━━━━━○━━━━━━━━━━━━━━━○                     ║
║            0ft           20ft           40ft                     ║
║                           ▲                                      ║
║                      (current)                                   ║
╚══════════════════════════════════════════════════════════════════╝

> climb
```

### 15.3 Display Example - Fumble (The Slip)

```
╔══════════════════════════════════════════════════════════════════╗
║  Stage 2: FUMBLE - THE SLIP!                                     ║
╠══════════════════════════════════════════════════════════════════╣
║  Roll: [1, 3, 5] → 0 successes, 1 botch                          ║
║  vs DC 2                                                         ║
║                                                                  ║
║  ⚠️  You lose your grip entirely and plummet to the ground!      ║
║                                                                  ║
║  Fall Height: 20ft                                               ║
║  Fall Damage: 2d10 Bludgeoning                                   ║
║  Crash Landing DC: 14                                            ║
╚══════════════════════════════════════════════════════════════════╝

Attempting Crash Landing...
```

---

## 16. Logging Specifications

### 16.1 Logging Events

```csharp
// In ClimbingService

// Climb start
_logger.LogInformation(
    "Character {CharacterId} starting climb: {Height}ft, {Stages} stages, {Surface} surface",
    characterId, context.TotalHeight, context.StagesRequired, context.SurfaceType);

// Stage attempt
_logger.LogDebug(
    "Attempting stage {Stage}: base {Base}d10, context {Context}d10, additional {Additional}d10 = {Total}d10",
    stageNumber, baseDicePool, contextModifier, additionalModifier, totalDicePool);

// Stage result
_logger.LogInformation(
    "Stage {Stage} result: {Successes} successes vs DC {Dc}, margin {Margin}, outcome {Outcome}",
    stageNumber, netSuccesses, dc, margin, outcome);

// Fall triggered
_logger.LogWarning(
    "Character {CharacterId} fell from {Height}ft during climb (fumble)",
    characterId, fallHeight);

// Climb completed
_logger.LogInformation(
    "Character {CharacterId} completed climb to {Height}ft in {Stages} stages",
    characterId, totalHeight, stagesCompleted);
```

---

## 17. Unit Testing Requirements

### 17.1 Test Specifications (~6 tests)

**File:** `tests/RuneAndRust.Application.Tests/Services/ClimbingServiceTests.cs`

```csharp
[TestFixture]
public class ClimbingServiceTests
{
    private ClimbingService _service;
    private Mock<IDiceRollerService> _mockDiceRoller;
    private Mock<ISkillCheckService> _mockSkillCheck;
    private Mock<IFumbleConsequenceService> _mockFumbleService;

    [SetUp]
    public void Setup()
    {
        _mockDiceRoller = new Mock<IDiceRollerService>();
        _mockSkillCheck = new Mock<ISkillCheckService>();
        _mockFumbleService = new Mock<IFumbleConsequenceService>();

        _service = new ClimbingService(
            _mockDiceRoller.Object,
            _mockSkillCheck.Object,
            _mockFumbleService.Object,
            Mock.Of<ILogger<ClimbingService>>());
    }

    /// <summary>
    /// Test 1: Height correctly calculates stages required.
    /// </summary>
    [TestCase(10, 1)]
    [TestCase(20, 1)]
    [TestCase(30, 2)]
    [TestCase(40, 2)]
    [TestCase(50, 3)]
    [TestCase(100, 3)]
    public void CalculateStagesRequired_GivenHeight_ReturnsCorrectStages(
        int height, int expectedStages)
    {
        // Act
        var result = _service.CalculateStagesRequired(height);

        // Assert
        Assert.That(result, Is.EqualTo(expectedStages));
    }

    /// <summary>
    /// Test 2: Surface type applies correct dice modifier.
    /// </summary>
    [TestCase(SurfaceType.Stable, 1)]
    [TestCase(SurfaceType.Normal, 0)]
    [TestCase(SurfaceType.Wet, -1)]
    [TestCase(SurfaceType.Compromised, -2)]
    [TestCase(SurfaceType.Collapsing, -3)]
    [TestCase(SurfaceType.Glitched, 0)]
    public void GetSurfaceDiceModifier_GivenSurfaceType_ReturnsCorrectModifier(
        SurfaceType surface, int expectedModifier)
    {
        // Act
        var result = _service.GetSurfaceDiceModifier(surface);

        // Assert
        Assert.That(result, Is.EqualTo(expectedModifier));
    }

    /// <summary>
    /// Test 3: Success advances to next stage.
    /// </summary>
    [Test]
    public void AttemptStage_OnSuccess_AdvancesToNextStage()
    {
        // Arrange
        var context = ClimbContext.Create(40, SurfaceType.Normal);
        var climbState = _service.StartClimb("char-1", context);

        _mockDiceRoller
            .Setup(x => x.RollDicePool(It.IsAny<int>()))
            .Returns(new DiceRollResult(new[] { 8, 9 }, successCount: 2, botchCount: 0));

        // Act
        var result = _service.AttemptStage(climbState, baseDicePool: 4);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result.IsSuccess, Is.True);
            Assert.That(result.NewStage, Is.EqualTo(1));
            Assert.That(climbState.CurrentStage, Is.EqualTo(1));
        });
    }

    /// <summary>
    /// Test 4: Failure slips back one stage.
    /// </summary>
    [Test]
    public void AttemptStage_OnFailure_SlipsBackOneStage()
    {
        // Arrange
        var context = ClimbContext.Create(40, SurfaceType.Normal);
        var climbState = _service.StartClimb("char-1", context);

        // First succeed to get to stage 1
        _mockDiceRoller
            .SetupSequence(x => x.RollDicePool(It.IsAny<int>()))
            .Returns(new DiceRollResult(new[] { 8, 9 }, successCount: 2, botchCount: 0))
            .Returns(new DiceRollResult(new[] { 3, 4 }, successCount: 0, botchCount: 0));

        _service.AttemptStage(climbState, baseDicePool: 4); // Stage 1 success

        // Act
        var result = _service.AttemptStage(climbState, baseDicePool: 4); // Stage 2 failure

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result.IsSuccess, Is.False);
            Assert.That(result.IsFumble, Is.False);
            Assert.That(climbState.CurrentStage, Is.EqualTo(1)); // Stayed at stage 1
        });
    }

    /// <summary>
    /// Test 5: Fumble triggers fall from current height.
    /// </summary>
    [Test]
    public void AttemptStage_OnFumble_TriggersFallFromCurrentHeight()
    {
        // Arrange
        var context = ClimbContext.Create(40, SurfaceType.Normal);
        var climbState = _service.StartClimb("char-1", context);

        // First succeed to get to stage 1
        _mockDiceRoller
            .SetupSequence(x => x.RollDicePool(It.IsAny<int>()))
            .Returns(new DiceRollResult(new[] { 8, 9 }, successCount: 2, botchCount: 0))
            .Returns(new DiceRollResult(new[] { 1, 3 }, successCount: 0, botchCount: 1)); // Fumble

        _service.AttemptStage(climbState, baseDicePool: 4); // Stage 1 success

        // Act
        var result = _service.AttemptStage(climbState, baseDicePool: 4); // Stage 2 fumble

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result.IsFumble, Is.True);
            Assert.That(result.FallTriggered, Is.True);
            Assert.That(result.FallHeight, Is.EqualTo(20)); // Fell from stage 1 height
            Assert.That(climbState.Status, Is.EqualTo(ClimbStatus.Fallen));
        });

        _mockFumbleService.Verify(
            x => x.CreateConsequence(
                "char-1",
                "acrobatics-climbing",
                FumbleType.TheSlip,
                It.IsAny<string?>(),
                It.IsAny<string?>()),
            Times.Once);
    }

    /// <summary>
    /// Test 6: Critical success advances two stages.
    /// </summary>
    [Test]
    public void AttemptStage_OnCriticalSuccess_AdvancesTwoStages()
    {
        // Arrange
        var context = ClimbContext.Create(60, SurfaceType.Normal, baseDc: 2);
        var climbState = _service.StartClimb("char-1", context);

        _mockDiceRoller
            .Setup(x => x.RollDicePool(It.IsAny<int>()))
            .Returns(new DiceRollResult(
                new[] { 8, 9, 10, 8, 10, 9, 8 },
                successCount: 7,
                botchCount: 0)); // Margin of 5+

        // Act
        var result = _service.AttemptStage(climbState, baseDicePool: 7);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result.IsCriticalSuccess, Is.True);
            Assert.That(result.StagesAdvanced, Is.EqualTo(2));
            Assert.That(climbState.CurrentStage, Is.EqualTo(2));
        });
    }
}
```

---

## 18. Use Cases

### 18.1 Use Case: Start a New Climb

**Actor:** Player
**Precondition:** Character is at ground level near a climbable surface
**Trigger:** Player issues `climb 40ft` command

**Main Flow:**
1. System calculates stages required (40ft = 2 stages)
2. System determines surface type from environment
3. System applies equipment modifiers (if any)
4. System applies armor penalties (if any)
5. System creates ClimbState entity
6. System displays climb context to player
7. Player is prompted to attempt first stage

**Postcondition:** ClimbState exists with status InProgress, CurrentStage = 0

### 18.2 Use Case: Attempt Climbing Stage

**Actor:** Player
**Precondition:** Active ClimbState exists with status InProgress
**Trigger:** Player issues `climb` command

**Main Flow:**
1. System retrieves next stage from ClimbState
2. System calculates final dice pool (base + modifiers)
3. System performs skill check via SkillCheckService
4. System determines outcome (success, failure, fumble, critical)
5. System updates ClimbState based on outcome
6. System displays stage result to player

**Alternative Flow - Fumble:**
5a. Outcome is fumble (0 successes + ≥1 botch)
6a. System triggers [The Slip] fumble consequence
7a. System creates FallResult with current height
8a. System sets ClimbState status to Fallen
9a. Fall damage system takes over (v0.15.2c)

**Postcondition:** ClimbState updated with new stage, history, and status

### 18.3 Use Case: Complete Climb

**Actor:** Player
**Precondition:** Player succeeded on final stage
**Trigger:** Stage attempt brings CurrentStage >= StagesRequired

**Main Flow:**
1. System detects climb completion
2. System sets ClimbState status to Completed
3. System records EndedAt timestamp
4. System displays success message
5. Player arrives at top of climb

**Postcondition:** ClimbState has status Completed, player at target height

### 18.4 Use Case: Abandon Climb

**Actor:** Player
**Precondition:** Active ClimbState exists with status InProgress
**Trigger:** Player issues `abandon climb` command

**Main Flow:**
1. System validates climb is in progress
2. System sets ClimbState status to Abandoned
3. System sets CurrentStage to 0
4. System records EndedAt timestamp
5. Player safely returns to ground

**Postcondition:** ClimbState has status Abandoned, player at ground level

### 18.5 Use Case: Critical Success Climb

**Actor:** Player
**Precondition:** Active ClimbState exists, attempting stage
**Trigger:** Player rolls margin ≥ 5 or dice roll is critical success

**Main Flow:**
1. System detects critical success condition
2. System advances player by 2 stages (or to top)
3. If at top, system completes climb
4. System displays critical success message
5. Player advances significantly or completes climb

**Postcondition:** Player advanced 2 stages or at top

---

## 19. Deliverable Checklist

### 19.1 Domain Layer

- [ ] `SurfaceType.cs` - Extended with `Glitched` variant
- [ ] `SurfaceTypeExtensions.cs` - Extension methods for modifiers
- [ ] `ClimbStatus.cs` - Climb state enum
- [ ] `ClimbingStage.cs` - Stage value object
- [ ] `ClimbContext.cs` - Context value object
- [ ] `ClimbStageResult.cs` - Result value object
- [ ] `ClimbState.cs` - State entity
- [ ] `FallResult.cs` - Fall result value object
- [ ] `FallSource.cs` - Fall source enum

### 19.2 Application Layer

- [ ] `IClimbingService.cs` - Service interface
- [ ] `ClimbingService.cs` - Service implementation

### 19.3 Infrastructure Layer

- [ ] `climbing-surfaces.json` - Configuration file
- [ ] `climbing-surfaces.schema.json` - JSON schema

### 19.4 Tests

- [ ] `ClimbingServiceTests.cs` - ~6 unit tests

---

## 20. Acceptance Criteria

### 20.1 Stage Calculation
- [ ] 10-20ft climbs require 1 stage
- [ ] 30-40ft climbs require 2 stages
- [ ] 50+ft climbs require 3 stages
- [ ] Height 0 or negative returns 0 stages

### 20.2 Surface Modifiers
- [ ] Stable surface grants +1d10
- [ ] Normal surface grants +0
- [ ] Wet surface applies -1d10
- [ ] Compromised surface applies -2d10
- [ ] Collapsing surface applies -3d10
- [ ] Glitched surface applies +2 DC (not dice)

### 20.3 Equipment and Armor
- [ ] Climbing Gear grants +1d10
- [ ] Grappling Hook grants +2d10
- [ ] Light/No Armor has no penalty
- [ ] Medium Armor applies -1d10
- [ ] Heavy Armor applies -4d10

### 20.4 Stage Progression
- [ ] Success advances 1 stage
- [ ] Critical success (margin ≥ 5) advances 2 stages
- [ ] Failure slips back 1 stage (minimum 0)
- [ ] Fumble triggers fall from current height

### 20.5 Fall Triggering
- [ ] Fumble (0 successes + ≥1 botch) triggers [The Slip]
- [ ] Fall height equals starting height of current stage
- [ ] FumbleConsequenceService called with TheSlip type

### 20.6 Climb Completion
- [ ] Reaching StagesRequired completes climb
- [ ] Status changes to Completed
- [ ] EndedAt timestamp recorded

### 20.7 Quality
- [ ] ~6 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## 21. Future Considerations

### 21.1 Deferred to v0.15.2c (Fall Damage System)

- Actual damage calculation from FallResult
- Crash Landing attempt mechanics
- Damage reduction from successful Crash Landing

### 21.2 Deferred to v0.15.2g (Specialization Integration)

- Gantry-Runner `[Roof-Runner]` ability reduces stages by 1
- Gantry-Runner `[Featherfall]` auto-succeeds Crash Landing DC ≤ 14
- Myrk-gengr stealth bonuses during climbing

### 21.3 Future Enhancements

- Multiple characters climbing same surface
- Dynamic surface degradation during climb
- Weather effects on surface conditions
- Climbing speed considerations
- Rope-assisted climbing (reduced fumble consequences)

---

## 22. Implementation Notes

### 22.1 Dice Pool Minimum

The climbing service enforces a minimum dice pool of 1d10, even when all modifiers result in a negative total. This ensures the player always has a chance to succeed (or fumble).

### 22.2 Fumble Detection

Fumble detection uses the DiceRollResult.IsFumble property from v0.15.0a, which checks for 0 successes AND at least 1 botch (roll of 1).

### 22.3 Surface Type Storage

Surface type for a climb is determined at climb initiation from the environment. The same surface type applies to all stages of a single climb attempt.

### 22.4 Fall Height Calculation

Fall height is calculated from the starting height of the current stage, not the height the character would have reached if successful. This matches the "fell from where they were" narrative.

---

## 23. Document Metadata

| Property | Value |
|----------|-------|
| Document Version | 1.0.0 |
| Last Updated | 2026-01-17 |
| Author | Claude |
| Reviewers | Pending |
| Status | Draft |
| Target Version | 0.15.2a |
| Parent Version | v0.15.2 (Acrobatics Skill Expansion) |
| Prerequisites | v0.15.1 (Skill Infrastructure) |

---

*This design specification provides the detailed blueprint for implementing v0.15.2a Climbing System. Implementation should proceed after user approval.*
