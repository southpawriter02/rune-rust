# Changelog: v0.4.1d - The Grid

**Release Date:** 2025-12-30

---

## Summary

Version 0.4.1d implements **The Grid**, a comprehensive refactoring of the Specialization UI layer that replaces v0.4.1c's two-panel modal layout with a grid-based architecture. This release introduces tier-based horizontal navigation, improved visual organization, and a cleaner separation of concerns through dedicated ViewModel building and controller interfaces. The Grid architecture organizes specialization nodes in a 4-column tier layout (Tier 1-3 plus Capstone), enabling intuitive left-right navigation between tiers and up-down navigation within each tier column.

**Architectural Focus:** Core (ViewModels, Interfaces, Enums), Engine (ViewModel Builder), Terminal (Rendering, Controller)

**Key Patterns Introduced:**
- **Builder Pattern**: `ISpecializationGridViewModelBuilder` extracts ViewModel composition logic from GameService
- **Interface Segregation**: `ISpecializationController` enables testable controller behavior
- **Grid-Based Layout**: 4-column tier organization for visual clarity
- **Enum Reordering**: NodeStatus values reordered to Locked=0, Available=1, Unlocked=2, Affordable=3

**Total Tests:** 169 (43 new specialization-related tests added: 17 controller, 16 builder, 10 renderer)

---

## Table of Contents

- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Files Deleted](#files-deleted)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.1d](#directory-structure-after-v041d)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Next Steps](#next-steps)

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/ViewModels/NodeViewModel.cs` | Immutable record for individual node display state with computed properties |
| `RuneAndRust.Core/ViewModels/SpecializationGridViewModel.cs` | Mutable ViewModel containing tier-grouped nodes and selection state |
| `RuneAndRust.Core/Interfaces/ISpecializationGridViewModelBuilder.cs` | Interface for building and refreshing grid ViewModels |
| `RuneAndRust.Core/Interfaces/ISpecializationGridRenderer.cs` | Interface for rendering the grid UI to terminal |
| `RuneAndRust.Core/Interfaces/ISpecializationController.cs` | Interface for grid navigation and unlock operations |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/ViewModels/SpecializationGridViewModelBuilder.cs` | Extracts ViewModel composition logic from GameService, computes node statuses |

### Terminal Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Terminal/Rendering/SpecializationGridRenderer.cs` | Spectre.Console renderer for 4-column tier grid layout |
| `RuneAndRust.Terminal/Controllers/SpecializationController.cs` | Complete rewrite: Handles tier-based navigation and node inscriptions |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Terminal/SpecializationControllerTests.cs` | 17 tests for controller navigation and unlock logic |
| `RuneAndRust.Tests/Engine/SpecializationGridViewModelBuilderTests.cs` | 16 tests for ViewModel building and status computation |
| `RuneAndRust.Tests/Terminal/SpecializationGridRendererTests.cs` | 10 tests for rendering different grid states |
| `RuneAndRust.Tests/Core/NodeStatusTests.cs` | Updated tests for reordered enum values |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/NodeStatus.cs` | Reordered enum values: Locked=0, Available=1, Unlocked=2, Affordable=3 (renamed from InsufficientPP) |
| `RuneAndRust.Engine/Services/GameService.cs` | Updated constructor and field declarations to use `ISpecializationGridRenderer` and `ISpecializationController` (v0.4.1d) |
| `RuneAndRust.Terminal/Program.cs` | Registered `ISpecializationGridRenderer`, `ISpecializationGridViewModelBuilder`, and `ISpecializationController` |

---

## Files Deleted

Version 0.4.1d removes all v0.4.1c artifacts that implemented the two-panel modal layout:

### Core Layer Deletions

| File | Reason |
|------|--------|
| `RuneAndRust.Core/ViewModels/SpecializationViewModel.cs` | Replaced by `SpecializationGridViewModel` |
| `RuneAndRust.Core/Enums/SpecializationViewMode.cs` | Grid navigation no longer requires two-panel view modes |
| `RuneAndRust.Core/Interfaces/ISpecializationScreenRenderer.cs` | Replaced by `ISpecializationGridRenderer` |

### Terminal Layer Deletions

| File | Reason |
|------|--------|
| `RuneAndRust.Terminal/Rendering/SpecializationScreenRenderer.cs` | Replaced by `SpecializationGridRenderer` |
| Previous `RuneAndRust.Terminal/Controllers/SpecializationController.cs` | Complete rewrite for grid-based navigation |

### Test Layer Deletions

| File | Reason |
|------|--------|
| `RuneAndRust.Tests/Core/SpecializationViewModelTests.cs` | ViewModel structure changed to SpecializationGridViewModel |
| Previous test files for deleted classes | Test coverage migrated to new architecture |

---

## Code Implementation Details

### NodeStatus Enum (Modified)

**File:** `RuneAndRust.Core/Enums/NodeStatus.cs`

**Values:**
```csharp
public enum NodeStatus
{
    Locked = 0,      // Prerequisites not met
    Available = 1,   // Can be purchased (prereqs met, PP available)
    Unlocked = 2,    // Already purchased
    Affordable = 3   // Prerequisites met but insufficient PP
}
```

**Key Change:** Reordered from v0.4.1c sequence (Locked, InsufficientPP, Available, Unlocked) to new sequence with renamed `Affordable` status. Default value is now `Locked = 0`.

---

### NodeViewModel (New Record)

**File:** `RuneAndRust.Core/ViewModels/NodeViewModel.cs`

**Properties:**
- `NodeId` (Guid): Unique node identifier
- `AbilityId` (Guid): Ability granted by node
- `Name` (string): Display name
- `Description` (string): Ability description
- `Tier` (int): Tier level (1-4, where 4 is capstone)
- `CostPP` (int): Progression Points cost
- `Status` (NodeStatus): Current unlock status
- `PositionX` (int): Horizontal position for layout
- `PositionY` (int): Vertical position for layout
- `IsCapstone` (bool): Whether this is a Tier 4 capstone node
- `ParentNodeIds` (IReadOnlyList<Guid>): Prerequisite node IDs

**Computed Properties:**
- `CostDisplay` (string): Returns "-" for unlocked nodes, otherwise "{CostPP} PP"
- `StatusMarkup` (string): Returns Spectre.Console markup for status display
  - Unlocked: `[green](INSCRIBED)[/]`
  - Available: `[cyan](AVAILABLE)[/]`
  - Affordable: `[yellow](SAVE UP)[/]`
  - Locked: `[red](LOCKED)[/]`

**Behavior:**
- Immutable record type for deterministic rendering
- Status markup provides consistent color coding across UI

---

### SpecializationGridViewModel (New Class)

**File:** `RuneAndRust.Core/ViewModels/SpecializationGridViewModel.cs`

**Properties:**
- `SpecializationId` (Guid): ID of displayed specialization
- `SpecializationName` (string): Name for header
- `SpecializationDescription` (string): Flavor text
- `ProgressionPoints` (int): Character's current PP balance
- `CharacterName` (string): Character name for display
- `NodesByTier` (IReadOnlyDictionary<int, IReadOnlyList<NodeViewModel>>): Nodes grouped by tier (1-4)
- `AllNodes` (IReadOnlyList<NodeViewModel>): Flat list in display order
- `SelectedNodeIndex` (int, mutable): Currently selected node index
- `SelectedNode` (NodeViewModel?, computed): Currently selected node or null
- `TotalNodes` (int, computed): Total node count
- `UnlockedCount` (int, computed): Count of nodes with Status=Unlocked
- `FeedbackMessage` (string?, mutable): Purchase result or error message
- `FeedbackIsSuccess` (bool, mutable): Whether feedback is success (green) or error (red)
- `CurrentSpecIndex` (int, mutable): Index of current spec (for multi-spec tab switching)
- `TotalSpecCount` (int): Total unlocked specialization count

**Behavior:**
- Mutable class (not record) to allow selection state updates
- `SelectedNode` computed property prevents index-out-of-bounds errors
- `NodesByTier` enables 4-column grid layout rendering

---

### ISpecializationGridViewModelBuilder Interface (New)

**File:** `RuneAndRust.Core/Interfaces/ISpecializationGridViewModelBuilder.cs`

**Methods:**

1. `Task<SpecializationGridViewModel> BuildAsync(Character character, Guid specializationId)`
   - Builds initial ViewModel for a character's specialization tree
   - Computes node statuses based on character state
   - Groups nodes by tier for grid layout
   - Returns: Populated ViewModel with selection at index 0

2. `Task<SpecializationGridViewModel> RefreshAsync(SpecializationGridViewModel existing, Character character)`
   - Refreshes ViewModel after node unlock
   - Preserves selection index (clamped to bounds)
   - Preserves feedback message from previous action
   - Returns: Updated ViewModel with refreshed node statuses

---

### SpecializationGridViewModelBuilder Implementation

**File:** `RuneAndRust.Engine/ViewModels/SpecializationGridViewModelBuilder.cs`

**Dependencies:**
- `ISpecializationRepository`: Fetches specialization and node data
- `ISpecializationService`: Validates prerequisites
- `ILogger<SpecializationGridViewModelBuilder>`: Logging

**Key Methods:**

1. `BuildAsync(Character character, Guid specializationId)`
   - Fetches specialization and nodes from repository
   - Computes status for each node via `ComputeNodeStatusAsync`
   - Orders nodes by Tier > PositionY > PositionX
   - Groups nodes into `NodesByTier` dictionary
   - Calculates `CurrentSpecIndex` and `TotalSpecCount`
   - Returns ViewModel with `SelectedNodeIndex = 0`

2. `RefreshAsync(SpecializationGridViewModel existing, Character character)`
   - Rebuilds ViewModel via `BuildAsync`
   - Clamps `SelectedNodeIndex` to `[0, AllNodes.Count - 1]`
   - Preserves `FeedbackMessage` and `FeedbackIsSuccess`
   - Returns refreshed ViewModel

3. `ComputeNodeStatusAsync(Character character, SpecializationNode node)` (private)
   - Returns `NodeStatus.Unlocked` if character has node
   - Returns `NodeStatus.Locked` if prerequisites not met
   - Returns `NodeStatus.Affordable` if prereqs met but PP insufficient
   - Returns `NodeStatus.Available` if can unlock now

**Logging:**
- Trace: BuildAsync entry, node status computation, RefreshAsync entry
- Debug: Completed build with node count, refreshed unlock count

---

### ISpecializationController Interface (New)

**File:** `RuneAndRust.Core/Interfaces/ISpecializationController.cs`

**Properties:**
- `SpecializationGridViewModel? CurrentViewModel { get; }`: Current ViewModel for rendering
- `bool IsInitialized { get; }`: Whether controller has been initialized

**Methods:**
1. `Task InitializeAsync(Character character, Guid specializationId)`: Initialize with character and spec
2. `Task<GamePhase> HandleInputAsync(ConsoleKey key)`: Process key input, return resulting phase
3. `void Reset()`: Reset controller state to initial values

---

### SpecializationController Implementation (Complete Rewrite)

**File:** `RuneAndRust.Terminal/Controllers/SpecializationController.cs`

**Dependencies:**
- `ISpecializationService`: Node unlock operations
- `ISpecializationGridViewModelBuilder`: ViewModel construction
- `ILogger<SpecializationController>`: Logging

**Key Methods:**

1. `InitializeAsync(Character character, Guid specializationId)`
   - Stores character reference
   - Builds initial ViewModel via `_vmBuilder.BuildAsync`
   - Logs initialization with node count and spec name

2. `HandleInputAsync(ConsoleKey key)`
   - **Escape/Q**: Resets controller, returns `GamePhase.Exploration`
   - **Up/W**: Calls `NavigateVertical(-1)`, stays in `SpecializationMenu`
   - **Down/S**: Calls `NavigateVertical(1)`, stays in `SpecializationMenu`
   - **Left/A**: Calls `NavigateHorizontal(-1)`, stays in `SpecializationMenu`
   - **Right/D**: Calls `NavigateHorizontal(1)`, stays in `SpecializationMenu`
   - **Tab**: Calls `SwitchSpecializationAsync`, stays in `SpecializationMenu`
   - **Enter/Spacebar**: Calls `HandleUnlockAsync`, stays in `SpecializationMenu`
   - Clears feedback message before processing input

3. `NavigateVertical(int delta)`
   - Finds nodes in same tier as current selection
   - Moves selection up (delta=-1) or down (delta=1) within tier
   - Updates `SelectedNodeIndex` to global index
   - Does nothing if at tier boundary

4. `NavigateHorizontal(int delta)`
   - Calculates target tier (current tier + delta)
   - Clamps target tier to [1, 4]
   - Finds nodes in target tier
   - If target tier empty, searches adjacent tiers
   - Preserves row position when switching tiers (or clamps to available)
   - Updates `SelectedNodeIndex` to global index

5. `SwitchSpecializationAsync()`
   - Cycles to next unlocked specialization (Tab key)
   - Does nothing if only one spec unlocked
   - Rebuilds ViewModel for new specialization

6. `HandleUnlockAsync()`
   - Validates selected node exists
   - Returns error if already unlocked, locked, or affordable (insufficient PP)
   - Calls `_specService.UnlockNodeAsync` for available nodes
   - Sets `FeedbackMessage` and `FeedbackIsSuccess` based on result
   - Refreshes ViewModel via `_vmBuilder.RefreshAsync` on success

**Navigation Behavior:**
- Tier-based horizontal movement (Left/Right or A/D keys)
- Row-based vertical movement within tier (Up/Down or W/S keys)
- Row position preserved when switching tiers
- Bounds checking prevents index-out-of-range errors

**Logging:**
- Trace: HandleInput entry, switch spec when only one spec
- Debug: Exit, vertical/horizontal navigation, switch spec, node status checks, unlock attempts, state reset
- Info: Initialization complete, node inscribed
- Warning: HandleInput before initialization, unlock failures

---

### ISpecializationGridRenderer Interface (New)

**File:** `RuneAndRust.Core/Interfaces/ISpecializationGridRenderer.cs`

**Methods:**
- `void Render(SpecializationGridViewModel vm)`: Renders the grid to the terminal

---

### SpecializationGridRenderer Implementation

**File:** `RuneAndRust.Terminal/Rendering/SpecializationGridRenderer.cs`

**Dependencies:**
- `IThemeService`: Theme colors (currently unused, prepared for future theming)
- `ILogger<SpecializationGridRenderer>`: Logging

**Render Method:**

Calls sub-methods in sequence:
1. `RenderHeader(vm)`: Spec name, character name, PP balance, progress
2. `RenderGrid(vm)`: 4-column tier table with node cells
3. `RenderDetailPanel(vm)`: Selected node description and status
4. `RenderFeedback(vm)`: Purchase result or error message
5. `RenderFooter(vm)`: Control hints

**RenderHeader:**
- Rule with specialization name in uppercase, gold color
- Tab indicator for multi-spec: "(1/3)" format
- Character name, PP balance (yellow), and unlock progress (cyan)

**RenderGrid:**
- Spectre.Console Table with 4 columns: TIER 1, TIER 2, TIER 3, CAPSTONE
- Rounded border, grey color
- Each column width: 18 characters
- Finds max nodes per tier to determine row count
- Iterates rows, populating cells with `FormatNodeCell`

**FormatNodeCell:**
- Indicator: "> " for selected, "  " otherwise
- Icon: "*" (Unlocked), "o" (Available), "~" (Affordable), "x" (Locked)
- Color: green (Unlocked), cyan (Available), yellow (Affordable), red (Locked)
- Truncates names longer than 12 characters to "{Name}..."
- Bold white for selected nodes

**RenderDetailPanel:**
- Panel with selected node name and tier in header
- "CAPSTONE" indicator for Tier 4 nodes (gold1 color)
- Description text (escaped for Spectre markup)
- Cost display and status markup on footer line
- Grey border when no selection

**RenderFeedback:**
- Displays `FeedbackMessage` if present
- Green for success, red for errors
- Prefixed with ">>" for emphasis

**RenderFooter:**
- Control hints: "Up/Down: Navigate | Left/Right: Tier | Enter: Inscribe | Esc: Return"
- Includes "Tab: Switch Spec" if multiple specs unlocked
- Dim grey color

**Logging:**
- Trace: Render complete with selected index and node name

---

### GameService Integration (Modified)

**File:** `RuneAndRust.Engine/Services/GameService.cs`

**Changes:**

1. **Fields Added:**
```csharp
private readonly ISpecializationGridRenderer? _specGridRenderer;
private readonly ISpecializationController? _specController;
```

2. **Constructor Parameters Added:**
```csharp
ISpecializationGridRenderer? specGridRenderer = null,
ISpecializationController? specController = null
```

3. **Field Initialization:**
```csharp
_specGridRenderer = specGridRenderer;
_specController = specController;
```

4. **Render Phase Logic (Line 261):**
```csharp
else if (_state.Phase == GamePhase.SpecializationMenu &&
         _specGridRenderer != null &&
         _specController != null)
{
    if (_specController.CurrentViewModel != null)
    {
        _specGridRenderer.Render(_specController.CurrentViewModel);
    }
}
```

5. **Input Handling Logic (Line 164):**
```csharp
else if (_state.Phase == GamePhase.SpecializationMenu &&
         _inputService != null &&
         _specController != null)
{
    var inputEvent = _inputService.ReadNextFiltered();
    if (inputEvent.HasValue)
    {
        _state.Phase = await _specController.HandleInputAsync(inputEvent.Value.Key);
        _renderRequired = true;
    }
}
```

6. **Phase Label (Line 283):**
```csharp
GamePhase.SpecializationMenu => "[RUNES]",
```

**Integration Behavior:**
- GameService no longer builds ViewModel directly
- Controller owns ViewModel state and navigation logic
- GameService delegates rendering to `_specGridRenderer`
- GameService delegates input to `_specController`

---

## Logging Matrix

### SpecializationController Logging

| Event | Level | Template |
|-------|-------|----------|
| Initialization entry | Debug | `[SpecController] InitializeAsync: CharName={CharName}, SpecId={SpecId}` |
| Initialization complete | Info | `[SpecController] Initialized with {NodeCount} nodes for {SpecName}` |
| HandleInput called before init | Warning | `[SpecController] HandleInputAsync called before initialization` |
| HandleInput entry | Trace | `[SpecController] HandleInputAsync: Key={Key}` |
| Exit requested | Debug | `[SpecController] Exit requested` |
| Vertical navigation | Debug | `[SpecController] Navigate vertical: Tier={Tier}, TierIdx={TierIdx}` |
| Horizontal navigation | Debug | `[SpecController] Navigate horizontal: FromTier={From}, ToTier={To}` |
| Switch spec (single spec) | Trace | `[SpecController] SwitchSpec: Only one spec unlocked, no switch` |
| Switch spec | Debug | `[SpecController] Switching spec: {From} -> {To}` |
| Node already unlocked | Debug | `[SpecController] Node already unlocked: {Name}` |
| Node locked | Debug | `[SpecController] Node locked: {Name}` |
| Insufficient PP | Debug | `[SpecController] Insufficient PP for: {Name}` |
| Unlock attempt | Debug | `[SpecController] Attempting to unlock node: {NodeId}` |
| Node inscribed | Info | `[SpecController] Node inscribed: {Name} (Tier {Tier})` |
| Unlock failed | Warning | `[SpecController] Node unlock failed: {Reason}` |
| State reset | Debug | `[SpecController] State reset` |

### SpecializationGridViewModelBuilder Logging

| Event | Level | Template |
|-------|-------|----------|
| BuildAsync entry | Trace | `[SpecVM] BuildAsync for {CharName}, SpecId={SpecId}` |
| Node status computed | Trace | `[SpecVM] Node {NodeName}: Status={Status}` |
| Build complete | Debug | `[SpecVM] Built VM with {NodeCount} nodes` |
| RefreshAsync entry | Trace | `[SpecVM] RefreshAsync for {SpecName}` |
| Refresh complete | Debug | `[SpecVM] Refreshed, {UnlockedCount} now unlocked` |

### SpecializationGridRenderer Logging

| Event | Level | Template |
|-------|-------|----------|
| Render complete | Trace | `[Spec UI] Rendered. Selected: {Index}, Node: {NodeName}` |

---

## Test Coverage

**Total Tests:** 169 (43 new tests added for v0.4.1d)
**Result:** Passed: 169 | Failed: 0 | Skipped: 0
**Duration:** ~1000ms

### Complete Test Inventory

#### SpecializationControllerTests (17 tests)

| Test Name | Description |
|-----------|-------------|
| `IsInitialized_WhenNotInitialized_ReturnsFalse` | Verifies `IsInitialized` is false before `InitializeAsync` |
| `InitializeAsync_SetsIsInitializedToTrue` | Verifies `IsInitialized` becomes true after initialization |
| `InitializeAsync_SetsCurrentViewModel` | Verifies `CurrentViewModel` is set by initialization |
| `HandleInputAsync_Escape_ReturnsExploration` | Escape key returns `GamePhase.Exploration` |
| `HandleInputAsync_Q_ReturnsExploration` | Q key returns `GamePhase.Exploration` |
| `HandleInputAsync_Escape_ResetsController` | Escape key resets `CurrentViewModel` to null |
| `HandleInputAsync_DownArrow_StaysInSpecializationMenu` | Down arrow returns `GamePhase.SpecializationMenu` |
| `HandleInputAsync_UpArrow_StaysInSpecializationMenu` | Up arrow returns `GamePhase.SpecializationMenu` |
| `HandleInputAsync_LeftArrow_StaysInSpecializationMenu` | Left arrow returns `GamePhase.SpecializationMenu` |
| `HandleInputAsync_RightArrow_StaysInSpecializationMenu` | Right arrow returns `GamePhase.SpecializationMenu` |
| `HandleInputAsync_Enter_OnAvailableNode_CallsUnlockNodeAsync` | Enter on available node triggers unlock service |
| `HandleInputAsync_Spacebar_OnAvailableNode_CallsUnlockNodeAsync` | Spacebar on available node triggers unlock service |
| `HandleInputAsync_Enter_OnLockedNode_DoesNotCallUnlockNodeAsync` | Enter on locked node does not call service |
| `HandleInputAsync_Enter_OnUnlockedNode_DoesNotCallUnlockNodeAsync` | Enter on unlocked node does not call service |
| `HandleInputAsync_Enter_OnAffordableNode_ShowsInsufficientPP` | Enter on affordable node shows PP error |
| `Reset_ClearsCurrentViewModel` | Reset method clears `CurrentViewModel` |
| `HandleInputAsync_WhenNotInitialized_ReturnsExploration` | HandleInput before init returns Exploration phase |

#### SpecializationGridViewModelBuilderTests (16 tests)

| Test Name | Description |
|-----------|-------------|
| `BuildAsync_ReturnsViewModelWithCorrectSpecName` | ViewModel contains correct specialization name |
| `BuildAsync_ReturnsViewModelWithCorrectCharacterName` | ViewModel contains correct character name |
| `BuildAsync_ReturnsViewModelWithCorrectProgressionPoints` | ViewModel contains correct PP balance |
| `BuildAsync_GroupsNodesByTier` | `NodesByTier` dictionary groups nodes correctly |
| `BuildAsync_SetsCorrectTotalNodeCount` | `AllNodes.Count` matches expected total |
| `BuildAsync_SetsCorrectSpecIndexForMultiSpec` | `CurrentSpecIndex` calculated from unlocked specs |
| `BuildAsync_ThrowsWhenSpecializationNotFound` | Throws `ArgumentException` for invalid spec ID |
| `BuildAsync_MarksTier4NodesAsCapstone` | Tier 4 nodes have `IsCapstone = true` |
| `BuildAsync_UnlockedNode_HasUnlockedStatus` | Character-owned node has `Status = Unlocked` |
| `BuildAsync_LockedNode_HasLockedStatus` | Node with unmet prereqs has `Status = Locked` |
| `BuildAsync_AvailableNode_HasAvailableStatus` | Node with met prereqs and PP has `Status = Available` |
| `BuildAsync_AffordableNode_HasAffordableStatus` | Node with prereqs but insufficient PP has `Status = Affordable` |
| `RefreshAsync_PreservesSelectedNodeIndex` | Refresh keeps selection index within bounds |
| `RefreshAsync_ClampsSelectedNodeIndex_WhenOutOfBounds` | Refresh clamps index if node count changed |
| `RefreshAsync_PreservesFeedbackMessage` | Refresh preserves `FeedbackMessage` from previous action |
| `BuildAsync_WithNoNodes_ReturnsEmptyNodesByTier` | Empty specialization returns empty `NodesByTier` |

#### SpecializationGridRendererTests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `Constructor_WithValidDependencies_CreatesInstance` | Constructor succeeds with valid dependencies |
| `Render_WithValidViewModel_DoesNotThrow` | Render succeeds with populated ViewModel |
| `Render_WithEmptyNodes_DoesNotThrow` | Render succeeds with empty `AllNodes` |
| `Render_WithNullSelectedNode_DoesNotThrow` | Render succeeds when `SelectedNode` is null |
| `Render_WithFeedbackMessage_DoesNotThrow` | Render succeeds with success feedback |
| `Render_WithErrorFeedbackMessage_DoesNotThrow` | Render succeeds with error feedback |
| `Render_WithMultiSpec_DoesNotThrow` | Render succeeds with multi-spec tab indicator |
| `Render_WithLongNodeName_DoesNotThrow` | Render succeeds with truncated long names |
| `Render_WithAllNodeStatuses_DoesNotThrow` | Render succeeds with all four NodeStatus values |
| `Render_WithCapstoneNode_DoesNotThrow` | Render succeeds with capstone node selected |

#### NodeStatusTests (Updated for v0.4.1d)

| Test Name | Description |
|-----------|-------------|
| `NodeStatus_ShouldHaveExactlyFourValues` | Enum has exactly 4 values |
| `NodeStatus_ShouldContain_Locked` | Enum contains `Locked` value |
| `NodeStatus_ShouldContain_Available` | Enum contains `Available` value |
| `NodeStatus_ShouldContain_Unlocked` | Enum contains `Unlocked` value |
| `NodeStatus_ShouldContain_Affordable` | Enum contains `Affordable` value (renamed from InsufficientPP) |
| `NodeStatus_EnumValues_ShouldBeSequential` | Values are sequential: 0, 1, 2, 3 |
| `NodeStatus_ToString_ReturnsExpectedName(Locked)` | ToString returns "Locked" |
| `NodeStatus_ToString_ReturnsExpectedName(Available)` | ToString returns "Available" |
| `NodeStatus_ToString_ReturnsExpectedName(Unlocked)` | ToString returns "Unlocked" |
| `NodeStatus_ToString_ReturnsExpectedName(Affordable)` | ToString returns "Affordable" |
| `NodeStatus_FromInt_ReturnsCorrectStatus(0, Locked)` | Cast from 0 returns `Locked` |
| `NodeStatus_FromInt_ReturnsCorrectStatus(1, Available)` | Cast from 1 returns `Available` |
| `NodeStatus_FromInt_ReturnsCorrectStatus(2, Unlocked)` | Cast from 2 returns `Unlocked` |
| `NodeStatus_FromInt_ReturnsCorrectStatus(3, Affordable)` | Cast from 3 returns `Affordable` |
| `NodeStatus_DefaultValue_ShouldBeLocked` | Default value is `Locked = 0` |

---

## DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

**Registrations Added (Lines 175-177):**

```csharp
// Specialization Grid UI (v0.4.1d - The Grid)
services.AddSingleton<ISpecializationGridRenderer, SpecializationGridRenderer>();
services.AddScoped<ISpecializationGridViewModelBuilder, SpecializationGridViewModelBuilder>();
services.AddScoped<ISpecializationController, SpecializationController>();
```

**Lifetime Justifications:**
- `ISpecializationGridRenderer`: **Singleton** - Stateless renderer, safe for reuse
- `ISpecializationGridViewModelBuilder`: **Scoped** - Accesses scoped repositories
- `ISpecializationController`: **Scoped** - Maintains session state per game loop

---

## Verification Results

### Build Output

```
Build succeeded.
    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.86
```

**Warning:** Version conflict for `Microsoft.EntityFrameworkCore.Relational` (9.0.1 vs 9.0.4) - non-blocking, resolved by primary assembly.

### Test Output

```
Passed!  - Failed: 0, Passed: 169, Skipped: 0, Total: 169, Duration: ~1 s
```

**Test Execution:** All specialization-related tests pass, including:
- 17 SpecializationControllerTests
- 16 SpecializationGridViewModelBuilderTests
- 10 SpecializationGridRendererTests
- 15 NodeStatusTests (updated for reordered enum)

---

## Directory Structure After v0.4.1d

```
RuneAndRust.Core/
├── Enums/
│   ├── NodeStatus.cs                  [MODIFIED - Reordered values]
│   └── GamePhase.cs                   [Existing - SpecializationMenu phase]
├── Interfaces/
│   ├── ISpecializationGridViewModelBuilder.cs  [NEW]
│   ├── ISpecializationGridRenderer.cs          [NEW]
│   └── ISpecializationController.cs            [NEW]
└── ViewModels/
    ├── NodeViewModel.cs                        [NEW]
    └── SpecializationGridViewModel.cs          [NEW]

RuneAndRust.Engine/
├── Services/
│   └── GameService.cs                 [MODIFIED - Updated DI and rendering]
└── ViewModels/
    └── SpecializationGridViewModelBuilder.cs   [NEW]

RuneAndRust.Terminal/
├── Controllers/
│   └── SpecializationController.cs    [REWRITTEN - Grid navigation]
├── Rendering/
│   └── SpecializationGridRenderer.cs  [NEW]
└── Program.cs                         [MODIFIED - DI registration]

RuneAndRust.Tests/
├── Core/
│   └── NodeStatusTests.cs             [MODIFIED - Updated for reordered enum]
├── Engine/
│   └── SpecializationGridViewModelBuilderTests.cs  [NEW - 16 tests]
└── Terminal/
    ├── SpecializationControllerTests.cs           [NEW - 17 tests]
    └── SpecializationGridRendererTests.cs         [NEW - 10 tests]
```

---

## Running Tests

### Run All Specialization Tests

```bash
dotnet test --filter "FullyQualifiedName~Specialization"
```

### Run Specific Test Classes

```bash
# Controller tests only
dotnet test --filter "FullyQualifiedName~SpecializationControllerTests"

# Builder tests only
dotnet test --filter "FullyQualifiedName~SpecializationGridViewModelBuilderTests"

# Renderer tests only
dotnet test --filter "FullyQualifiedName~SpecializationGridRendererTests"

# NodeStatus enum tests
dotnet test --filter "FullyQualifiedName~NodeStatusTests"
```

### Run All Tests

```bash
dotnet test
```

---

## Design Decisions

### Why Grid-Based Layout Over Two-Panel Modal?

**Problem:** v0.4.1c's two-panel layout (SpecList left, TreeDetail right) required explicit Left/Right arrow context switching, creating cognitive overhead.

**Decision:** Implement a unified 4-column tier grid (Tier 1, Tier 2, Tier 3, Capstone) with horizontal tier navigation and vertical row navigation.

**Rationale:**
- **Spatial Clarity**: Tiers are visually distinct columns, making progression path obvious
- **Natural Navigation**: Left/Right moves between tiers, Up/Down moves within tier
- **Reduced Context Switching**: Single grid eliminates "which panel am I in?" confusion
- **Scalability**: Supports specializations with variable node counts per tier
- **Consistency**: Matches RPG skill tree conventions (vertical tiers, horizontal choices)

### Why Extract ViewModel Building Into ISpecializationGridViewModelBuilder?

**Problem:** v0.4.1c had GameService directly building ViewModels, violating Single Responsibility Principle.

**Decision:** Create `ISpecializationGridViewModelBuilder` service to encapsulate ViewModel composition logic.

**Rationale:**
- **Testability**: Builder can be unit tested independently of GameService
- **Separation of Concerns**: GameService handles game loop, Builder handles data transformation
- **Reusability**: Builder can be used by future UI layers (Avalonia, web)
- **Maintainability**: Changes to ViewModel structure isolated to Builder
- **Dependency Inversion**: Builder abstracts repository and service access

### Why Reorder NodeStatus Enum Values?

**Problem:** v0.4.1c had `InsufficientPP` as value 1, causing default(NodeStatus) to be `Locked` inconsistently.

**Decision:** Reorder to Locked=0, Available=1, Unlocked=2, Affordable=3, and rename `InsufficientPP` to `Affordable`.

**Rationale:**
- **Semantic Default**: `Locked=0` is the safest default state for uninitialized nodes
- **Logical Progression**: 0=Locked → 1=Available → 2=Unlocked follows unlock flow
- **Clarity**: "Affordable" better conveys "you can afford it later" than "InsufficientPP"
- **Enum Convention**: Default value (0) should represent the most restrictive state

### Why Make SpecializationGridViewModel a Class Instead of Record?

**Problem:** Selection state (`SelectedNodeIndex`, `FeedbackMessage`) must be mutable during navigation.

**Decision:** Use class with init-only properties for immutable data and mutable properties for UI state.

**Rationale:**
- **Performance**: Avoids creating new ViewModel instances on every navigation action
- **State Preservation**: Controller can modify selection without rebuilding entire ViewModel
- **Hybrid Approach**: Immutable data (nodes, spec info) + mutable UI state (selection, feedback)
- **Practical MVVM**: Allows ViewModel to hold transient UI state without service calls

### Why Introduce ISpecializationController Interface?

**Problem:** v0.4.1c's controller was a concrete class tightly coupled to GameService, untestable in isolation.

**Decision:** Define `ISpecializationController` interface for navigation and unlock operations.

**Rationale:**
- **Testability**: Enables mocking controller in GameService tests
- **Dependency Inversion**: GameService depends on abstraction, not concrete implementation
- **Future-Proofing**: Allows alternative controller implementations (e.g., gamepad input)
- **Interface Segregation**: Clear contract for what GameService expects from controller

---

## Next Steps

Planned for **v0.4.1e** and beyond:

- **Node Connection Visualization**: ASCII art lines showing parent-child relationships between nodes
- **Multi-Spec Tab Switching**: Enhanced UI for characters with multiple unlocked specializations
- **Node Preview on Hover**: Show ability details without selecting node
- **Batch Unlock**: "Unlock Path" feature to inscribe all nodes to a selected capstone
- **Undo Last Unlock**: Allow players to refund last inscribed node (with cooldown)
- **Achievement Integration**: Track "First Capstone", "Full Tree Completion" achievements
- **Specialization Respec**: Allow full tree reset for cost (v0.4.2 candidate)

---

## Credits

**Implementation:** The Architect (Claude Sonnet 4.5)
**Changelog Generation:** The Chronicle-Smith (Claude Sonnet 4.5)
**Project Framework:** Rune & Rust Development Team
**Version:** v0.4.1d "The Grid"
**Release Date:** 2025-12-30

---

Generated with Claude Code
Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
