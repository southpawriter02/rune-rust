# Changelog: v0.3.23b - The Loop (Event-Driven Architecture)

**Version:** v0.3.23b
**Release Date:** 2025-12-27
**Total Tests:** 38 new/modified tests
**Test Results:** All passing

---

## Table of Contents

- [Overview](#overview)
- [Key Metrics](#key-metrics)
- [Architecture Summary](#architecture-summary)
  - [Event-Driven Loop Diagram](#event-driven-loop-diagram)
  - [Dirty Flag Rendering Pattern](#dirty-flag-rendering-pattern)
  - [VFX Expiry Tracking](#vfx-expiry-tracking)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
  - [IGameService Update](#igameservice-update)
  - [IVisualEffectService Update](#ivisualeffectservice-update)
  - [VisualEffectService Implementation](#visualeffectservice-implementation)
  - [ActionToCommandMapper Helper](#actiontocommandmapper-helper)
  - [GameService Refactoring](#gameservice-refactoring)
  - [Program.cs Cancellation Setup](#programcs-cancellation-setup)
- [Loop Lifecycle Analysis](#loop-lifecycle-analysis)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [Verification Results](#verification-results)
- [Directory Structure After Release](#directory-structure-after-release)
- [Architecture Decisions](#architecture-decisions)
- [Running Tests](#running-tests)
- [Breaking Changes](#breaking-changes)
- [Migration Notes](#migration-notes)
- [Next Steps](#next-steps)

---

## Overview

v0.3.23b "The Loop" introduces the second phase of the Input Refactoring milestone, transforming the main game loop from a simple blocking model to an event-driven architecture with dirty flag rendering. This release enables background processing (VFX expiration, visual invalidation events) while maintaining turn-based mechanics, creating a more responsive "alive" feel without sacrificing gameplay consistency.

**Key Achievements:**
- Added `CancellationToken` support to `IGameService.StartAsync()` for graceful shutdown
- Implemented `OnInvalidateVisuals` event and `CheckExpiredOverrides()` on `IVisualEffectService`
- Created expiry-based VFX tracking instead of blocking `Task.Delay`-based auto-clear
- Built `ActionToCommandMapper` for reverse GameAction-to-command-string mapping
- Refactored `GameService` with dirty flag rendering (`_renderRequired`)
- Added SIGINT/SIGTERM handlers in `Program.cs` for graceful shutdown on Ctrl+C

**Foundation For:**
- Full non-blocking input loop (v0.3.25 - CommandParser modernization)
- Background ambience ticks between keystrokes
- Animation interpolation and smooth transitions
- Real-time command buffer rendering

**Predecessor:** v0.3.23a "The Gatekeeper" (Input Abstraction) - COMPLETED

---

## Key Metrics

| Metric | Value |
|--------|-------|
| New Files | 2 |
| Modified Files | 7 |
| New Unit Tests | 24 |
| Modified Unit Tests | 14 |
| Test Pass Rate | 100% (v0.3.23b tests) |
| New Lines (Services) | ~150 |
| New Lines (Tests) | ~250 |
| Breaking Changes | 1 (IVisualEffectService interface) |

---

## Architecture Summary

### Event-Driven Loop Diagram

```
+---------------------------------------------------------------------+
|                  v0.3.23b NON-BLOCKING GAME LOOP                    |
+---------------------------------------------------------------------+
|                                                                      |
|  StartAsync(CancellationToken ct)                                   |
|       |                                                              |
|       v                                                              |
|  +-------------------------------------------------------------+    |
|  |                    MAIN LOOP                                 |    |
|  |  while (Phase != Quit && !ct.IsCancellationRequested)       |    |
|  |       |                                                      |    |
|  |       +--- 1. Check VFX expiration -> set renderRequired    |    |
|  |       |       via _vfxService.CheckExpiredOverrides()       |    |
|  |       |                                                      |    |
|  |       +--- 2. Check phase transition                        |    |
|  |       |       if changed -> HandlePhaseTransitionAsync()    |    |
|  |       |       set renderRequired = true                      |    |
|  |       |                                                      |    |
|  |       +--- 3. Render if renderRequired                      |    |
|  |       |       RenderCurrentPhaseAsync()                      |    |
|  |       |       set renderRequired = false                     |    |
|  |       |                                                      |    |
|  |       +--- 4. Get input (STILL BLOCKS for command text)     |    |
|  |       |       IInputHandler.GetInput(prompt)                 |    |
|  |       |                                                      |    |
|  |       +--- 5. Process command                               |    |
|  |       |       CommandParser.ParseAndExecuteAsync()           |    |
|  |       |                                                      |    |
|  |       +--- 6. Set renderRequired = true                     |    |
|  |       |                                                      |    |
|  |       +--- 7. Tick ambience (if Exploration)                |    |
|  +-------------------------------------------------------------+    |
|                                                                      |
|  VFX SUBSCRIPTION (Constructor):                                    |
|  _vfxService.OnInvalidateVisuals += () => renderRequired = true;   |
|                                                                      |
|  EXCEPTION HANDLING:                                                |
|  catch (OperationCanceledException) -> break                        |
|  catch (Exception) -> log, continue (resilience)                    |
|                                                                      |
+---------------------------------------------------------------------+
```

### Dirty Flag Rendering Pattern

```
                     RENDER TRIGGERS
                     ===============

+------------------+     +------------------+     +------------------+
| VFX Expiration   |     | Phase Transition |     | Input Processed  |
| CheckExpired()   |     | Phase != Previous|     | ParseAndExecute()|
| returns true     |     |                  |     | completes        |
+--------+---------+     +--------+---------+     +--------+---------+
         |                        |                        |
         v                        v                        v
     +---------------------------------------------------+
     |           _renderRequired = true                   |
     +----------------------------+-----------------------+
                                  |
                                  v
                    +---------------------------+
                    | if (_renderRequired)      |
                    |   RenderCurrentPhaseAsync |
                    |   _renderRequired = false |
                    +---------------------------+

+------------------+
| VFX Invalidation |
| OnInvalidateVis. |
| event fired      |
+--------+---------+
         |
         v
     +---------------------------------------------------+
     |           _renderRequired = true                   |
     |           (via event subscription)                 |
     +---------------------------------------------------+
```

### VFX Expiry Tracking

```
     BEFORE v0.3.23b                      AFTER v0.3.23b
     ==================                   ==================

  TriggerEffectAsync()                  TriggerEffectAsync()
         |                                      |
         v                                      v
  SetBorderOverride(color)              SetBorderOverride(color)
         |                              _borderOverrideExpiry =
         v                                  DateTime.UtcNow + duration
  await Task.Delay(duration)            OnInvalidateVisuals?.Invoke()
         |                                      |
         v                                      v
  ClearBorderOverride()                 await Task.Delay(duration)
         |                              [legacy await for callers]
         v                                      |
  (override gone)                               v
                                        (override persists until
                                         CheckExpiredOverrides()
                                         called by game loop)

                                        +----------------------+
                                        | Game Loop Each Tick: |
                                        | CheckExpiredOverrides|
                                        |   if expired:        |
                                        |     clear override   |
                                        |     fire event       |
                                        |     return true      |
                                        +----------------------+
```

---

## New Files Created

### Engine Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Engine/Helpers/ActionToCommandMapper.cs` | Static utility mapping 22 `GameAction` enum values to command strings for CommandParser. Provides `ToCommand()` method for reverse mapping and `GetAllMappings()` for enumeration. Bridge between `IInputService` (v0.3.23a) and `CommandParser` until full modernization in v0.3.25. | 65 |

### Test Layer

| File | Purpose | Lines |
|------|---------|-------|
| `RuneAndRust.Tests/Engine/ActionToCommandMapperTests.cs` | Unit tests for `ActionToCommandMapper` covering all 22 action mappings across 5 categories (movement, core, navigation, gameplay, combat), unmapped action handling, bidirectional mapping verification with `CommandToActionMapper`, and `GetAllMappings()` validation. 12 tests. | ~100 |

---

## Files Modified

| File | Change Summary |
|------|----------------|
| `RuneAndRust.Core/Interfaces/IGameService.cs` | Added optional `CancellationToken cancellationToken = default` parameter to `StartAsync()` for graceful shutdown support. Updated XML documentation with v0.3.23b remarks. |
| `RuneAndRust.Core/Interfaces/IVisualEffectService.cs` | Added `event Action? OnInvalidateVisuals` for render invalidation signaling. Added `bool CheckExpiredOverrides()` method for game loop tick-based expiry management. Updated XML documentation. **BREAKING CHANGE** |
| `RuneAndRust.Terminal/Services/VisualEffectService.cs` | Added `_borderOverrideExpiry` field for time-based tracking. Implemented `OnInvalidateVisuals` event (fired on set/clear/trigger). Implemented `CheckExpiredOverrides()` returning true when override cleared. Modified `TriggerEffectAsync()` to set expiry time instead of clearing after delay. Modified `SetBorderOverride()` and `ClearBorderOverride()` to fire invalidation event. |
| `RuneAndRust.Engine/Services/GameService.cs` | Added `_vfxService` dependency injection. Added `_renderRequired` dirty flag field. Added VFX event subscription in constructor. Refactored `StartAsync()` with `CancellationToken` parameter, dirty flag rendering, VFX expiry checking, exception resilience. Extracted `RenderCurrentPhaseAsync()` method. Updated logging for v0.3.23b. |
| `RuneAndRust.Terminal/Program.cs` | Added `CancellationTokenSource` with using statement. Added `Console.CancelKeyPress` handler for SIGINT (Ctrl+C). Added `AppDomain.CurrentDomain.ProcessExit` handler for SIGTERM. Passed `cts.Token` to `gameService.StartAsync()`. |
| `RuneAndRust.Tests/Engine/GameLoopTests.cs` | Added 5 new v0.3.23b tests: `StartAsync_WithCancellationRequested_ShouldExitLoop`, `StartAsync_WithImmediateCancellation_ShouldNotProcessInput`, `StartAsync_WithVfxService_ShouldSubscribeToInvalidateEvent`, `StartAsync_WhenVfxExpires_ShouldTriggerRender`, `StartAsync_WhenExceptionThrown_ShouldContinueLoop`. |
| `RuneAndRust.Tests/Terminal/VisualEffectServiceTests.cs` | Renamed and fixed `TriggerEffectAsync_ClearsBorderOverride_AfterDelay` to `TriggerEffectAsync_SetsOverrideWithExpiry_ThenCheckExpiredClears`. Added 7 new tests: `SetBorderOverride_RaisesOnInvalidateVisuals`, `ClearBorderOverride_RaisesOnInvalidateVisuals`, `TriggerEffectAsync_RaisesOnInvalidateVisuals`, `CheckExpiredOverrides_ReturnsFalse_WhenNoOverride`, `CheckExpiredOverrides_ReturnsFalse_WhenOverrideNotExpired`, `CheckExpiredOverrides_ReturnsTrue_AndClears_WhenExpired`, `CheckExpiredOverrides_RaisesOnInvalidateVisuals_WhenClearing`. |

---

## Code Implementation Details

### IGameService Update

**File:** `RuneAndRust.Core/Interfaces/IGameService.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Main game orchestration service.
/// </summary>
/// <remarks>
/// See: SPEC-GAME-001 for Game Orchestration System design.
/// v0.3.23b: Added CancellationToken support for graceful shutdown.
/// </remarks>
public interface IGameService
{
    /// <summary>
    /// Starts the main game loop.
    /// </summary>
    /// <param name="cancellationToken">Token for graceful shutdown on SIGINT or quit command.</param>
    /// <returns>A task that completes when the game exits.</returns>
    Task StartAsync(CancellationToken cancellationToken = default);
}
```

**Design Notes:**
- `default` parameter allows backward compatibility with existing callers
- `CancellationToken` enables SIGINT/SIGTERM handling without abrupt termination
- Task completes normally on both user quit and cancellation

---

### IVisualEffectService Update

**File:** `RuneAndRust.Core/Interfaces/IVisualEffectService.cs`

Added members:

```csharp
/// <summary>
/// Event raised when visual state changes and a redraw is required.
/// v0.3.23b: Used by non-blocking loop to trigger renders.
/// </summary>
event Action? OnInvalidateVisuals;

/// <summary>
/// Checks if any border override has expired and clears it.
/// Called by the game loop each tick to manage time-based effects.
/// </summary>
/// <returns>True if an override was cleared (redraw needed).</returns>
bool CheckExpiredOverrides();
```

**Method Purposes:**

| Member | Use Case |
|--------|----------|
| `OnInvalidateVisuals` | Signals game loop to set `_renderRequired = true` when VFX state changes |
| `CheckExpiredOverrides()` | Polled each loop iteration to clear expired time-based effects |

**BREAKING CHANGE:** Implementations of `IVisualEffectService` must now provide these two new members.

---

### VisualEffectService Implementation

**File:** `RuneAndRust.Terminal/Services/VisualEffectService.cs`

**New Fields:**

```csharp
private DateTime? _borderOverrideExpiry; // v0.3.23b: Track expiration time
```

**New Event:**

```csharp
/// <inheritdoc />
public event Action? OnInvalidateVisuals;
```

**Modified TriggerEffectAsync (Expiry-Based):**

```csharp
/// <inheritdoc/>
/// <remarks>v0.3.23b: Now sets expiry time instead of clearing after Task.Delay.</remarks>
public async Task TriggerEffectAsync(VisualEffectType effectType, int intensity = 1)
{
    _logger.LogTrace("[VFX] TriggerEffectAsync: Type={EffectType}, Intensity={Intensity}",
        effectType, intensity);

    if (GameSettings.ReduceMotion)
    {
        _logger.LogTrace("[VFX] ReduceMotion enabled, skipping effect");
        return;
    }

    if (effectType == VisualEffectType.None)
    {
        _logger.LogTrace("[VFX] EffectType is None, skipping");
        return;
    }

    var color = GetColorForEffect(effectType);
    if (color == null)
    {
        _logger.LogWarning("[VFX] No color mapping for EffectType={EffectType}", effectType);
        return;
    }

    intensity = Math.Clamp(intensity, 1, 3);
    var durationMs = 150 * intensity;

    _logger.LogTrace("[VFX] Setting border override: Color={Color}, Duration={Duration}ms",
        color, durationMs);

    // v0.3.23b: Set expiry time, let loop clear it
    _borderOverride = color;
    _borderOverrideExpiry = DateTime.UtcNow.AddMilliseconds(durationMs);
    OnInvalidateVisuals?.Invoke();

    // Legacy await for backward compatibility with callers expecting completion
    await Task.Delay(durationMs);
}
```

**Modified SetBorderOverride:**

```csharp
/// <inheritdoc/>
public void SetBorderOverride(string? colorOverride)
{
    _borderOverride = colorOverride;
    _borderOverrideExpiry = null; // Manual override has no expiry
    _logger.LogTrace("[VFX] Border override set: {Color}", colorOverride ?? "(null)");
    OnInvalidateVisuals?.Invoke();
}
```

**Modified ClearBorderOverride:**

```csharp
/// <inheritdoc/>
public void ClearBorderOverride()
{
    _borderOverride = null;
    _borderOverrideExpiry = null;
    _logger.LogTrace("[VFX] Border override cleared");
    OnInvalidateVisuals?.Invoke();
}
```

**New CheckExpiredOverrides:**

```csharp
/// <inheritdoc/>
/// <remarks>v0.3.23b: Called by game loop to manage time-based effects.</remarks>
public bool CheckExpiredOverrides()
{
    if (_borderOverride != null && _borderOverrideExpiry.HasValue
        && DateTime.UtcNow > _borderOverrideExpiry.Value)
    {
        _logger.LogTrace("[VFX] Border override expired, clearing");
        _borderOverride = null;
        _borderOverrideExpiry = null;
        OnInvalidateVisuals?.Invoke();
        return true;
    }
    return false;
}
```

---

### ActionToCommandMapper Helper

**File:** `RuneAndRust.Engine/Helpers/ActionToCommandMapper.cs`

```csharp
namespace RuneAndRust.Engine.Helpers;

using RuneAndRust.Core.Enums;

/// <summary>
/// Maps GameAction enum values to command strings for CommandParser.
/// Provides the reverse translation for v0.3.23b until full CommandParser modernization.
/// </summary>
/// <remarks>
/// See: SPEC-INPUT-001 for Input System design.
/// v0.3.23b: Bridge between IInputService and CommandParser.
/// </remarks>
public static class ActionToCommandMapper
{
    private static readonly Dictionary<GameAction, string> ActionMap = new()
    {
        // Movement (6)
        { GameAction.MoveNorth, "north" },
        { GameAction.MoveSouth, "south" },
        { GameAction.MoveEast, "east" },
        { GameAction.MoveWest, "west" },
        { GameAction.MoveUp, "up" },
        { GameAction.MoveDown, "down" },

        // Core Actions (4)
        { GameAction.Confirm, "confirm" },
        { GameAction.Cancel, "cancel" },
        { GameAction.Menu, "menu" },
        { GameAction.Help, "help" },

        // Screen Navigation (4)
        { GameAction.Inventory, "pack" },
        { GameAction.Character, "status" },
        { GameAction.Journal, "archive" },
        { GameAction.Crafting, "bench" },

        // Gameplay (4)
        { GameAction.Interact, "interact" },
        { GameAction.Look, "look" },
        { GameAction.Search, "search" },
        { GameAction.Wait, "wait" },

        // Combat (4)
        { GameAction.Attack, "attack" },
        { GameAction.LightAttack, "light" },
        { GameAction.HeavyAttack, "heavy" },
        { GameAction.UseAbility, "use" },
        { GameAction.Flee, "flee" }
    };

    /// <summary>
    /// Converts a GameAction to a command string for CommandParser.
    /// </summary>
    /// <param name="action">The game action.</param>
    /// <returns>The command string, or null if not mapped.</returns>
    public static string? ToCommand(GameAction action)
    {
        return ActionMap.TryGetValue(action, out var command) ? command : null;
    }

    /// <summary>
    /// Gets all registered action-to-command mappings.
    /// </summary>
    public static IReadOnlyDictionary<GameAction, string> GetAllMappings() => ActionMap;
}
```

**Mapping Table (22 entries):**

| Category | GameAction | Command String |
|----------|------------|----------------|
| Movement | MoveNorth | "north" |
| Movement | MoveSouth | "south" |
| Movement | MoveEast | "east" |
| Movement | MoveWest | "west" |
| Movement | MoveUp | "up" |
| Movement | MoveDown | "down" |
| Core | Confirm | "confirm" |
| Core | Cancel | "cancel" |
| Core | Menu | "menu" |
| Core | Help | "help" |
| Navigation | Inventory | "pack" |
| Navigation | Character | "status" |
| Navigation | Journal | "archive" |
| Navigation | Crafting | "bench" |
| Gameplay | Interact | "interact" |
| Gameplay | Look | "look" |
| Gameplay | Search | "search" |
| Gameplay | Wait | "wait" |
| Combat | Attack | "attack" |
| Combat | LightAttack | "light" |
| Combat | HeavyAttack | "heavy" |
| Combat | UseAbility | "use" |
| Combat | Flee | "flee" |

---

### GameService Refactoring

**File:** `RuneAndRust.Engine/Services/GameService.cs`

**New Dependencies and Fields:**

```csharp
private readonly IVisualEffectService? _vfxService; // v0.3.23b
private bool _renderRequired = true; // v0.3.23b: Dirty flag
```

**Updated Constructor:**

```csharp
public GameService(
    ILogger<GameService> logger,
    IInputHandler inputHandler,
    CommandParser parser,
    GameState state,
    ICombatService combatService,
    IServiceScopeFactory scopeFactory,
    ICombatScreenRenderer? combatRenderer = null,
    IExplorationScreenRenderer? explorationRenderer = null,
    IScreenTransitionService? transitionService = null,
    IAmbienceService? ambienceService = null,
    IVisualEffectService? vfxService = null) // v0.3.23b
{
    _logger = logger;
    _inputHandler = inputHandler;
    _parser = parser;
    _state = state;
    _combatService = combatService;
    _scopeFactory = scopeFactory;
    _combatRenderer = combatRenderer;
    _explorationRenderer = explorationRenderer;
    _transitionService = transitionService;
    _ambienceService = ambienceService;
    _vfxService = vfxService;

    // v0.3.23b: Subscribe to VFX invalidation events
    if (_vfxService != null)
    {
        _vfxService.OnInvalidateVisuals += () => _renderRequired = true;
    }
}
```

**Refactored StartAsync:**

```csharp
/// <inheritdoc/>
/// <remarks>v0.3.23b: Added CancellationToken support and dirty flag rendering.</remarks>
public async Task StartAsync(CancellationToken cancellationToken = default)
{
    _logger.LogInformation("[GameLoop] Starting game loop (v0.3.23b)");
    _inputHandler.DisplayMessage("Welcome to Rune & Rust!");
    _inputHandler.DisplayMessage("Type 'help' for available commands.");
    _inputHandler.DisplayMessage("");

    _previousPhase = _state.Phase;
    _renderRequired = true;

    while (_state.Phase != GamePhase.Quit && !cancellationToken.IsCancellationRequested)
    {
        try
        {
            // v0.3.23b: 1. Check VFX expiration
            if (_vfxService?.CheckExpiredOverrides() == true)
            {
                _renderRequired = true;
            }

            // 2. Check for phase transition and play animation (v0.3.14b)
            if (_state.Phase != _previousPhase)
            {
                await HandlePhaseTransitionAsync(_previousPhase, _state.Phase);
                _previousPhase = _state.Phase;
                _renderRequired = true;
            }

            // 3. Render phase-specific UI (v0.3.23b: Only if required)
            if (_renderRequired)
            {
                await RenderCurrentPhaseAsync();
                _renderRequired = false;
            }

            // 4. Determine prompt based on current phase
            string prompt = GetPhasePrompt();

            // 5. Get input from the user (abstracted for testability)
            string input = _inputHandler.GetInput(prompt);

            // 6. Process the input through the command parser
            await _parser.ParseAndExecuteAsync(input, _state);
            _renderRequired = true;

            // 7. Tick ambient soundscape after exploration commands (v0.3.19c)
            if (_state.Phase == GamePhase.Exploration && _state.CurrentRoomId.HasValue && _ambienceService != null)
            {
                await _ambienceService.UpdateAsync(_state.CurrentRoomId.Value);
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("[GameLoop] Cancellation requested");
            break;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "[GameLoop] Error in game loop iteration");
            // Continue running - don't crash on single iteration errors
        }
    }

    // Final transition before quit (v0.3.14b)
    if (_previousPhase == GamePhase.Combat)
    {
        await HandlePhaseTransitionAsync(_previousPhase, GamePhase.Quit);
    }

    _logger.LogInformation("[GameLoop] Game loop ended. Phase: {Phase}", _state.Phase);
    _inputHandler.DisplayMessage("Thank you for playing Rune & Rust. Farewell!");
}
```

**New RenderCurrentPhaseAsync Method:**

```csharp
/// <summary>
/// Renders the appropriate screen based on current game phase.
/// </summary>
/// <remarks>v0.3.23b: Extracted from main loop for dirty flag pattern.</remarks>
private async Task RenderCurrentPhaseAsync()
{
    _logger.LogTrace("[GameLoop] Rendering phase: {Phase}", _state.Phase);

    if (_state.Phase == GamePhase.Combat && _combatRenderer != null)
    {
        var viewModel = _combatService.GetViewModel();
        if (viewModel != null)
        {
            _combatRenderer.Render(viewModel);
        }
    }
    else if (_state.Phase == GamePhase.Exploration && _explorationRenderer != null)
    {
        var viewModel = await BuildExplorationViewModelAsync();
        if (viewModel != null)
        {
            _explorationRenderer.Render(viewModel);
        }
    }
}
```

---

### Program.cs Cancellation Setup

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// v0.3.23b: Cancellation token for graceful shutdown
using var cts = new CancellationTokenSource();

// Handle Ctrl+C gracefully (SIGINT)
Console.CancelKeyPress += (sender, e) =>
{
    e.Cancel = true; // Prevent immediate termination
    cts.Cancel();
    Console.WriteLine("\n[System] Shutting down gracefully...");
};

// Handle SIGTERM (for containerized environments)
AppDomain.CurrentDomain.ProcessExit += (sender, e) =>
{
    cts.Cancel();
};

// Start game with cancellation token
game.StartAsync(cts.Token).GetAwaiter().GetResult();
```

**Behavior:**

| Signal | Source | Effect |
|--------|--------|--------|
| SIGINT | Ctrl+C | Sets `e.Cancel = true` to prevent abrupt exit, cancels token, displays message |
| SIGTERM | Docker/systemd | Cancels token silently (no console output) |
| Quit Command | User input | Game loop exits via `Phase == Quit` check |

---

## Loop Lifecycle Analysis

### State Transitions

```
INITIAL STATE:
  Phase = MainMenu
  _previousPhase = MainMenu
  _renderRequired = true

LOOP ITERATION 1 (MainMenu):
  1. CheckExpiredOverrides() -> false (no VFX active)
  2. Phase == _previousPhase -> no transition
  3. _renderRequired = true -> Render MainMenu
  4. _renderRequired = false
  5. GetInput("[MENU]") -> user types "start"
  6. ParseAndExecuteAsync("start") -> Phase = Exploration
  7. _renderRequired = true
  8. Ambience check skipped (not Exploration or no room)

LOOP ITERATION 2 (Exploration):
  1. CheckExpiredOverrides() -> false
  2. Phase != _previousPhase -> HandlePhaseTransitionAsync(MainMenu, Exploration)
     _previousPhase = Exploration
     _renderRequired = true
  3. _renderRequired = true -> Render Exploration HUD
  4. _renderRequired = false
  5. GetInput("[EXPLORE]") -> user types "look"
  6. ParseAndExecuteAsync("look") -> TurnCount++
  7. _renderRequired = true
  8. AmbienceService.UpdateAsync(roomId)

LOOP ITERATION 3 (Exploration with VFX):
  [Combat triggers DamageFlash, sets _borderOverrideExpiry]
  1. CheckExpiredOverrides() -> true (expiry passed)
     clears override, fires OnInvalidateVisuals
     _renderRequired = true (from event)
  2. Phase == _previousPhase -> no transition
  3. _renderRequired = true -> Re-render with cleared border
  ...

CANCELLATION SCENARIO:
  [User presses Ctrl+C]
  1. Console.CancelKeyPress handler fires
     e.Cancel = true
     cts.Cancel()
  2. Next loop iteration: cancellationToken.IsCancellationRequested = true
  3. Loop exits without setting Phase = Quit
  4. Final message displayed

QUIT SCENARIO:
  1. User types "quit"
  2. ParseAndExecuteAsync("quit") -> Phase = Quit
  3. Next iteration: Phase == Quit -> loop exits
  4. Final message displayed
```

---

## Logging Matrix

### GameService

| Event | Level | Template |
|-------|-------|----------|
| Loop start | Info | `[GameLoop] Starting game loop (v0.3.23b)` |
| Render tick | Trace | `[GameLoop] Rendering phase: {Phase}` |
| Loop end | Info | `[GameLoop] Game loop ended. Phase: {Phase}` |
| Cancellation | Info | `[GameLoop] Cancellation requested` |
| Iteration error | Error | `[GameLoop] Error in game loop iteration` |

### VisualEffectService

| Event | Level | Template |
|-------|-------|----------|
| Effect trigger | Trace | `[VFX] TriggerEffectAsync: Type={EffectType}, Intensity={Intensity}` |
| Override set | Trace | `[VFX] Setting border override: Color={Color}, Duration={Duration}ms` |
| Manual set | Trace | `[VFX] Border override set: {Color}` |
| Clear | Trace | `[VFX] Border override cleared` |
| Expiry clear | Trace | `[VFX] Border override expired, clearing` |
| ReduceMotion skip | Trace | `[VFX] ReduceMotion enabled, skipping effect` |

---

## Test Coverage

**Summary:**
```
v0.3.23b Tests: 38 | Passed: 38 | Failed: 0
```

### ActionToCommandMapperTests (12 tests)

| Test Category | Count | Description |
|---------------|-------|-------------|
| Movement mapping | 6 | MoveNorth/South/East/West/Up/Down -> correct commands (Theory) |
| Core action mapping | 4 | Confirm/Cancel/Menu/Help -> correct commands (Theory) |
| Navigation mapping | 4 | Inventory/Character/Journal/Crafting -> correct commands (Theory) |
| Gameplay mapping | 4 | Interact/Look/Search/Wait -> correct commands (Theory) |
| Combat mapping | 5 | Attack/LightAttack/HeavyAttack/UseAbility/Flee -> correct commands (Theory) |
| Unmapped handling | 1 | Invalid cast returns null |
| GetAllMappings | 2 | Non-empty, contains expected keys |
| Bidirectional | 3 | Round-trip with CommandToActionMapper |

### GameLoopTests - v0.3.23b Section (5 tests)

| Test Name | Description |
|-----------|-------------|
| `StartAsync_WithCancellationRequested_ShouldExitLoop` | Token cancelled during loop -> exits without Quit phase |
| `StartAsync_WithImmediateCancellation_ShouldNotProcessInput` | Pre-cancelled token -> input never called |
| `StartAsync_WithVfxService_ShouldSubscribeToInvalidateEvent` | VFX service injected -> CheckExpiredOverrides called |
| `StartAsync_WhenVfxExpires_ShouldTriggerRender` | VFX expiry -> CheckExpiredOverrides polled |
| `StartAsync_WhenExceptionThrown_ShouldContinueLoop` | Exception in iteration -> loop continues |

### VisualEffectServiceTests - v0.3.23b Section (8 tests)

| Test Name | Description |
|-----------|-------------|
| `TriggerEffectAsync_SetsOverrideWithExpiry_ThenCheckExpiredClears` | Await delay, then CheckExpiredOverrides clears and returns true |
| `SetBorderOverride_RaisesOnInvalidateVisuals` | Event fired on set |
| `ClearBorderOverride_RaisesOnInvalidateVisuals` | Event fired on clear |
| `TriggerEffectAsync_RaisesOnInvalidateVisuals` | Event fired on trigger |
| `CheckExpiredOverrides_ReturnsFalse_WhenNoOverride` | No override -> false |
| `CheckExpiredOverrides_ReturnsFalse_WhenOverrideNotExpired` | Manual override (no expiry) -> false |
| `CheckExpiredOverrides_ReturnsTrue_AndClears_WhenExpired` | Expired override -> true + cleared |
| `CheckExpiredOverrides_RaisesOnInvalidateVisuals_WhenClearing` | Event fired when expiry clears override |

---

## Verification Results

### Build Output

```
Build succeeded.

    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:02.14
```

### Test Output (v0.3.23b Tests)

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
VSTest version 17.14.1 (arm64)

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:    38, Skipped:     0, Total:    38, Duration: 312 ms
```

**Note:** 57 pre-existing database/integration tests fail due to missing PostgreSQL connection. These failures are unrelated to v0.3.23b changes.

---

## Directory Structure After Release

```
RuneAndRust.Core/
└── Interfaces/
    ├── IGameService.cs                     [MODIFIED]
    └── IVisualEffectService.cs             [MODIFIED]

RuneAndRust.Engine/
├── Helpers/
│   ├── ActionToCommandMapper.cs            [NEW]
│   └── CommandToActionMapper.cs            (v0.3.23a)
└── Services/
    └── GameService.cs                      [MODIFIED]

RuneAndRust.Terminal/
├── Program.cs                              [MODIFIED]
└── Services/
    └── VisualEffectService.cs              [MODIFIED]

RuneAndRust.Tests/
├── Engine/
│   ├── ActionToCommandMapperTests.cs       [NEW]
│   └── GameLoopTests.cs                    [MODIFIED]
└── Terminal/
    └── VisualEffectServiceTests.cs         [MODIFIED]
```

---

## Architecture Decisions

### 1. Dirty Flag Pattern for Rendering

**Decision:** Introduced `_renderRequired` boolean flag to control when rendering occurs, rather than rendering every loop iteration.

**Rationale:**
- Reduces unnecessary render calls when visual state hasn't changed
- Enables future optimization (e.g., partial updates)
- Clear trigger points: VFX events, phase transitions, input processing
- Event subscription (`OnInvalidateVisuals`) allows external triggers

---

### 2. Expiry-Based VFX Instead of Task.Delay Clearing

**Decision:** Changed `TriggerEffectAsync` to set `_borderOverrideExpiry` timestamp and rely on `CheckExpiredOverrides()` polling instead of clearing in the same method after `Task.Delay`.

**Rationale:**
- Decouples VFX timing from blocking delays
- Game loop controls when to check expiration (each tick)
- Preserves `Task.Delay` await for backward compatibility with callers
- Enables future sub-tick VFX interpolation
- Cleaner separation: `TriggerEffectAsync` sets state, loop manages cleanup

---

### 3. Optional VFX Service Injection

**Decision:** Made `IVisualEffectService` an optional nullable parameter with `?` in `GameService` constructor.

**Rationale:**
- Maintains backward compatibility with tests that don't inject VFX service
- `_vfxService?.Method()` null-conditional calls are safe
- Headless/unit test scenarios don't require VFX functionality
- Gradual adoption without breaking existing code

---

### 4. Exception Resilience in Loop

**Decision:** Wrapped loop body in try-catch that logs errors and continues rather than crashing.

**Rationale:**
- Single iteration failure shouldn't terminate the game
- Transient errors (e.g., network hiccups for save) are recoverable
- `OperationCanceledException` is handled separately for clean shutdown
- Error logging enables post-mortem debugging
- User experience prioritized over fail-fast semantics

---

### 5. Dual Cancellation Handlers (SIGINT + SIGTERM)

**Decision:** Added both `Console.CancelKeyPress` for SIGINT and `AppDomain.ProcessExit` for SIGTERM.

**Rationale:**
- SIGINT (Ctrl+C) is most common user cancellation
- SIGTERM is sent by Docker/Kubernetes for graceful shutdown
- `e.Cancel = true` prevents CLR from immediately terminating
- Cancellation token unifies both signals into single loop exit condition
- Message only displayed for interactive (SIGINT) cancellation

---

### 6. ActionToCommandMapper as Static Helper

**Decision:** Implemented reverse mapper as static class mirroring `CommandToActionMapper` pattern.

**Rationale:**
- Symmetry with v0.3.23a's `CommandToActionMapper`
- Mapping table is compile-time constant
- No dependencies requiring injection
- Single allocation at static initialization
- `ToCommand` returns nullable for unmapped actions (defensive)

---

## Running Tests

### Run All v0.3.23b Tests

```bash
dotnet test --filter "FullyQualifiedName~ActionToCommandMapperTests|FullyQualifiedName~v0.3.23b"
```

### Run GameLoop Tests

```bash
dotnet test --filter "FullyQualifiedName~GameLoopTests"
```

### Run VisualEffectService Tests

```bash
dotnet test --filter "FullyQualifiedName~VisualEffectServiceTests"
```

### Run All Tests with Verbose Output

```bash
dotnet test --filter "FullyQualifiedName~ActionToCommandMapper" -v detailed
```

---

## Breaking Changes

### IVisualEffectService Interface

**Change:** Added two new members to `IVisualEffectService`:
- `event Action? OnInvalidateVisuals`
- `bool CheckExpiredOverrides()`

**Impact:** Any custom implementations of `IVisualEffectService` must implement these new members.

**Migration:**

```csharp
// Minimal implementation for custom IVisualEffectService:
public event Action? OnInvalidateVisuals;

public bool CheckExpiredOverrides()
{
    // Return false if not tracking expiry
    return false;
}
```

---

## Migration Notes

### For Test Authors

Tests that mock `IVisualEffectService` must now setup the new members:

```csharp
var mockVfxService = new Mock<IVisualEffectService>();

// Setup CheckExpiredOverrides to return false by default
mockVfxService.Setup(x => x.CheckExpiredOverrides()).Returns(false);

// Event can be left unset (null) for basic tests
```

### For GameService Consumers

No changes required. `StartAsync()` now accepts optional `CancellationToken`:

```csharp
// Old (still works):
await gameService.StartAsync();

// New (with cancellation):
await gameService.StartAsync(cancellationToken);
```

---

## Next Steps

### v0.3.25 - The Modernizer (CommandParser Refactoring)

- Replace `IInputHandler.GetInput()` with `IInputService` polling
- Implement character-by-character command buffer
- Add real-time command preview rendering
- Full non-blocking input loop with tick-based processing

### v0.3.23c - The Dancer (Mouse Support)

- Implement mouse escape sequence parsing in `ReadNextFiltered()`
- Populate `MouseEvent` with X/Y coordinates and click state
- Add `OnMouseClick` and `OnMouseMove` event support
- Integrate with UI components for click handling

### Future VFX Enhancements

- Sub-tick VFX interpolation (smooth color transitions)
- Multiple concurrent VFX layers
- VFX priority system for overlapping effects
- VFX presets for common scenarios (damage, heal, crit)

---

**End of Changelog v0.3.23b**
