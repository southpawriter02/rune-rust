# v0.3.18: The Auditor (Performance Tuning)

This milestone shifts focus from feature addition to engine optimization. As systems like the Dynamic Room Engine and Entity AI scale up, memory allocation (Garbage Collection pressure) and algorithmic complexity (Pathfinding) become potential bottlenecks. To manage the complexity of profiling and refactoring core systems, this version is split into three sub-versions:
	•	v0.3.18a: The Garbage Collector (Memory Management) – Reducing heap allocations via pooling and struct usage.
	•	v0.3.18b: The Hot Path (Pathfinding & AI) – Optimizing spatial queries and navigation algorithms.
	•	v0.3.18c: The Snapshot (Serialization Efficiency) – Optimizing JSON persistence and startup times.

## v0.3.18a: The Garbage Collector (Memory Management)
Goal: Implement object pooling and Span<T> optimizations to reduce GC pressure during the render loop and command parsing.
1. Architecture & Data Flow
	•	String Pooling: Replace frequent string concatenations in RoomRenderer and LogFormatter with a StringBuilderPoolservice.
	•	Object Pooling: Implement Microsoft.Extensions.ObjectPool for high-churn objects like AttackResult or temporary UI ViewModels.
	•	Struct Refactor: Audit Vector3/Coordinate usage. Ensure they are passed by ref or in where appropriate to avoid copying overhead.
2. Logic Decision Trees
A. Allocation Audit Logic Input: Profiler Snapshot
	1	Identify Hotspots: Is the object allocated > 100 times per frame?
	◦	Yes (e.g., Log Entries): Candidate for Pooling.
	2	Identify Lifetime: Is the object strictly scoped to a method?
	◦	Yes: Convert to ref struct or use Span<T> if array-based.
	3	Identify Immutability: Is the object read-only data (e.g., static descriptions)?
	◦	Yes: Use Flyweight Pattern (reference single instance).
3. Code Implementation
File: RuneAndRust.Engine/Performance/StringBuilderPool.cs
public static class StringBuilderPool
{
    private static readonly ObjectPool<StringBuilder> _pool =
        new DefaultObjectPoolProvider().CreateStringBuilderPool();

    public static StringBuilder Get() => _pool.Get();
    public static string GetStringAndReturn(StringBuilder sb)
    {
        var result = sb.ToString();
        _pool.Return(sb);
        return result;
    }
}
4. Deliverable Checklist (v0.3.18a)
	•	[ ] Engine: Implement StringBuilderPool wrapper.
	•	[ ] Terminal: Refactor CombatScreenRenderer to use pooled builders for log messages.
	•	[ ] Engine: Convert Coordinate class to readonly record struct (if not already) for stack allocation.
	•	[ ] Tests: Verify no memory leaks in pooled objects.

## v0.3.18b: The Hot Path (Pathfinding & AI)
Goal: Optimize NavigationService and EnemyAIService to handle larger grids (50x50+) without frame drops.
1. Architecture & Data Flow
	•	Spatial Hashing: Replace List<Enemy>.Where(e => e.Pos == target) with a Dictionary<Coordinate, Guid> lookup table for O(1) adjacency checks.
	•	A Optimization:* Implement a PriorityQueue based A* algorithm for enemy pathfinding, replacing naive distance checks.
	•	Cache: Cache paths for stationary targets until the grid changes.
2. Logic Decision Trees
A. Pathfinding Selection Logic Input: Start, End, EntityType
	1	Line of Sight: Is there a straight line with no obstacles?
	◦	Yes: Move direct. Skip A*.
	2	Complexity Check: Is distance < 2 tiles?
	◦	Yes: Simple neighbor check.
	3	Full Path:
	◦	Retrieve SpatialHashGrid.
	◦	Execute A* (Manhattan Heuristic).
	◦	Result: Cache path in Enemy.CurrentPath.
3. Code Implementation
File: RuneAndRust.Engine/Services/SpatialHashGrid.cs File: RuneAndRust.Engine/Algorithms/AStarPathfinder.cs
4. Deliverable Checklist (v0.3.18b)
	•	[ ] Engine: Implement SpatialHashGrid class for O(1) entity lookups.
	•	[ ] Engine: Implement AStarPathfinder using .NET 6+ PriorityQueue.
	•	[ ] AI: Update EnemyAIService to use the spatial hash for target acquisition.
	•	[ ] Tests: Benchmark pathfinding on a 100x100 grid.

## v0.3.18c: The Snapshot (Serialization Efficiency)
Goal: Optimize the Save/Load pipeline to handle large GameStates with thousands of visited rooms/items without freezing the UI.
1. Architecture & Data Flow
	•	Source Generation: Switch System.Text.Json to use Source Generators ([JsonSerializable]) for reflection-free serialization.
	•	Streaming: Implement Stream-based saving rather than loading huge strings into memory.
	•	Partial Loading: Refactor SaveManager to support "Header Only" loading for the Load Game menu (Metadata vs Full State).
2. Deliverable Checklist (v0.3.18c)
	•	[ ] Core: Define JsonSerializerContext for GameState.
	•	[ ] Engine: Update SaveManager to use FileStream and async pipes.
	•	[ ] Tests: Verify serialization speed improvement vs reflection-based approach.

Testing Strategy
	•	Benchmarks (BenchmarkDotNet):
	◦	Pathfinding_100Entities: Measure ticks per second.
	◦	Serialization_LargeState: Measure time to save/load 1MB state.
	•	Unit Tests:
	◦	ObjectPool_ResetsState: Ensure reused objects don't carry old data.
	◦	AStar_FindsOptimalPath: Verify path length against known maze solution.
Draft Changelog (v0.3.18)
# Changelog: v0.3.18 - The Auditor

**Release Date:** 2026-01-XX

## Summary
Performance optimization release focusing on memory allocation and pathfinding efficiency.

## Changes
- **Memory:** Implemented StringBuilder pooling for log rendering.
- **Engine:** Converted Coordinate to readonly record struct for stack allocation.
- **AI:** Implemented A* Pathfinding with Spatial Hashing for O(1) lookups.
- **System:** Added Source Generated JSON serialization for faster saves.