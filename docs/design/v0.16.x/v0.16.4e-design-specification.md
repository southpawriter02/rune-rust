# v0.16.4e Design Specification: Container State Persistence

## Document Information

| Field            | Value                                                                |
| ---------------- | -------------------------------------------------------------------- |
| Version          | v0.16.4e                                                             |
| Parent Version   | v0.16.4 - Container Loot Generation                                  |
| Epic             | v0.16.x - Advanced Loot & Proficiency Systems                        |
| Status           | Draft                                                                |
| Created          | 2025-01-27                                                           |
| Scope Breakdown  | [v0.16.4-scope-breakdown.md](v0.16.4-scope-breakdown.md)             |
| Previous Version | [v0.16.4d-design-specification.md](v0.16.4d-design-specification.md) |

---

## 1. Executive Summary

### 1.1 Overview

Version 0.16.4e introduces **Container State Persistence**, which ensures container looted states and generated contents persist within a game run. This sub-phase creates the `IContainerStateRepository` interface for saving, loading, and resetting container states.

### 1.2 Key Deliverables

| Category               | Count | Artifact                    |
| ---------------------- | ----- | --------------------------- |
| Application Interfaces | 1     | `IContainerStateRepository` |
| Unit Tests             | ~2    | Repository behavior tests   |

### 1.3 Success Metrics

- Container state persists after looting
- Generated contents cached and retrievable
- Reset clears all container states for new run
- Unit tests pass for persistence operations

---

## 2. Feature Overview

### 2.1 Feature Tree

```
v0.16.4e: Container State Persistence
├── IContainerStateRepository Interface
│   ├── GetContainerAsync(containerId)
│   ├── GetContainersByRoomAsync(roomId)
│   ├── SaveContainerAsync(container)
│   ├── SaveContainersAsync(containers)
│   ├── DeleteContainerAsync(containerId)
│   └── ResetAllContainersAsync()
└── Persistence Strategy
    ├── In-memory cache during run
    ├── State persists until explicit reset
    └── Reset on new game/run
```

### 2.2 Scope Boundaries

**In Scope:**

- `IContainerStateRepository` interface definition
- Get, save, delete, and reset operations
- Batch operations for efficiency
- Room-based container queries

**Out of Scope:**

- Concrete repository implementation (Infrastructure layer)
- Room integration (v0.16.4f)
- Cross-session persistence (future consideration)
- Database schema design

---

## 3. Architecture Diagrams

### 3.1 Component Integration Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        APPLICATION LAYER                                 │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐│
│  │                  IContainerStateRepository                           ││
│  │                                                                      ││
│  │  + GetContainerAsync(Guid containerId)                               ││
│  │    → Task<ContainerLootTable?>                                       ││
│  │                                                                      ││
│  │  + GetContainersByRoomAsync(Guid roomId)                             ││
│  │    → Task<IReadOnlyList<ContainerLootTable>>                         ││
│  │                                                                      ││
│  │  + SaveContainerAsync(ContainerLootTable container)                  ││
│  │    → Task                                                            ││
│  │                                                                      ││
│  │  + SaveContainersAsync(IEnumerable<ContainerLootTable> containers)   ││
│  │    → Task                                                            ││
│  │                                                                      ││
│  │  + DeleteContainerAsync(Guid containerId)                            ││
│  │    → Task<bool>                                                      ││
│  │                                                                      ││
│  │  + ResetAllContainersAsync()                                         ││
│  │    → Task<int>                                                       ││
│  │                                                                      ││
│  │  + ExistsAsync(Guid containerId)                                     ││
│  │    → Task<bool>                                                      ││
│  └─────────────────────────────────────────────────────────────────────┘│
│                                  ▲                                       │
│                                  │ uses                                  │
│                                  │                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐│
│  │                   IContainerLootService                              ││
│  │                   (from v0.16.4d)                                    ││
│  │                                                                      ││
│  │   GenerateContents() can retrieve/update via repository             ││
│  └─────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────┘
                                   │
                                   │ implemented by
                                   ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      INFRASTRUCTURE LAYER                                │
│                      (Implementation deferred)                           │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐│
│  │              InMemoryContainerStateRepository                        ││
│  │              (Example implementation)                                ││
│  │                                                                      ││
│  │  - Dictionary<Guid, ContainerLootTable> _containers                  ││
│  │  - Dictionary<Guid, List<Guid>> _roomContainerIndex                  ││
│  └─────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 State Lifecycle Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       CONTAINER STATE LIFECYCLE                          │
└─────────────────────────────────────────────────────────────────────────┘

 New Game/Run
      │
      ▼
┌─────────────────┐
│ Empty Repository│ ◄───────────────────────────────────────────────────┐
│ (No containers) │                                                     │
└────────┬────────┘                                                     │
         │                                                              │
         │ Player enters room with container                            │
         ▼                                                              │
┌─────────────────┐                                                     │
│ Container       │                                                     │
│ Created         │                                                     │
│ (State: Discovered)                                                   │
└────────┬────────┘                                                     │
         │                                                              │
         │ SaveContainerAsync()                                         │
         ▼                                                              │
┌─────────────────┐                                                     │
│ Container       │                                                     │
│ Persisted       │                                                     │
│ (In repository) │                                                     │
└────────┬────────┘                                                     │
         │                                                              │
         │ Player loots container                                       │
         ▼                                                              │
┌─────────────────┐                                                     │
│ Container       │                                                     │
│ Updated         │                                                     │
│ (State: Looted) │                                                     │
└────────┬────────┘                                                     │
         │                                                              │
         │ SaveContainerAsync()                                         │
         ▼                                                              │
┌─────────────────┐                                                     │
│ Looted State    │                                                     │
│ Persisted       │                                                     │
│ (Contents saved)│                                                     │
└────────┬────────┘                                                     │
         │                                                              │
         │ New Run                                                      │
         │ ResetAllContainersAsync()                                    │
         └──────────────────────────────────────────────────────────────┘
```

### 3.3 Decision Tree: Container Retrieval

```
                    ┌─────────────────┐
                    │ GetContainerAsync│
                    │ (containerId)   │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │ Container exists│
                    │ in repository?  │
                    └────────┬────────┘
                      Yes    │    No
                    ┌────────┴────────┐
                    ▼                 ▼
         ┌───────────────────┐ ┌───────────────────┐
         │ Return container  │ │ Return null       │
         │ with current state│ │                   │
         └───────────────────┘ └───────────────────┘
```

---

## 4. Feature Section: IContainerStateRepository Interface

### 4.1 Purpose

The `IContainerStateRepository` interface defines the contract for persisting container states within a game run, supporting CRUD operations and batch processing.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Interfaces/IContainerStateRepository.cs`

```csharp
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Repository interface for persisting container loot table states.
/// </summary>
/// <remarks>
/// This repository manages container state within a game run. Container states
/// (discovered, looted, contents) persist until explicitly reset. Typically,
/// reset occurs when starting a new game or run.
///
/// Implementations should maintain an index by room ID for efficient
/// room-based queries.
/// </remarks>
public interface IContainerStateRepository
{
    /// <summary>
    /// Gets a container by its unique identifier.
    /// </summary>
    /// <param name="containerId">The container's unique identifier.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>
    /// The container if found, or null if no container exists with that ID.
    /// </returns>
    Task<ContainerLootTable?> GetContainerAsync(
        Guid containerId,
        CancellationToken ct = default);

    /// <summary>
    /// Gets all containers in a specific room.
    /// </summary>
    /// <param name="roomId">The room's unique identifier.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>
    /// A read-only list of containers in the room, or empty if none exist.
    /// </returns>
    Task<IReadOnlyList<ContainerLootTable>> GetContainersByRoomAsync(
        Guid roomId,
        CancellationToken ct = default);

    /// <summary>
    /// Saves or updates a container's state.
    /// </summary>
    /// <param name="container">The container to save.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// If a container with the same ID exists, it will be updated.
    /// Otherwise, a new container record is created.
    /// </remarks>
    Task SaveContainerAsync(
        ContainerLootTable container,
        CancellationToken ct = default);

    /// <summary>
    /// Saves or updates multiple containers in a batch operation.
    /// </summary>
    /// <param name="containers">The containers to save.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// More efficient than multiple individual SaveContainerAsync calls.
    /// Useful when initializing room containers.
    /// </remarks>
    Task SaveContainersAsync(
        IEnumerable<ContainerLootTable> containers,
        CancellationToken ct = default);

    /// <summary>
    /// Deletes a container by its unique identifier.
    /// </summary>
    /// <param name="containerId">The container's unique identifier.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>True if the container was deleted, false if not found.</returns>
    Task<bool> DeleteContainerAsync(
        Guid containerId,
        CancellationToken ct = default);

    /// <summary>
    /// Resets all container states, clearing the repository.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>The number of containers that were cleared.</returns>
    /// <remarks>
    /// Called when starting a new game or run. All container states
    /// (discovered, looted, contents) are cleared.
    /// </remarks>
    Task<int> ResetAllContainersAsync(CancellationToken ct = default);

    /// <summary>
    /// Checks if a container exists in the repository.
    /// </summary>
    /// <param name="containerId">The container's unique identifier.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>True if the container exists, false otherwise.</returns>
    Task<bool> ExistsAsync(
        Guid containerId,
        CancellationToken ct = default);

    /// <summary>
    /// Gets the count of containers currently in the repository.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>The total number of persisted containers.</returns>
    Task<int> GetCountAsync(CancellationToken ct = default);

    /// <summary>
    /// Gets all containers that have been looted.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>A read-only list of looted containers.</returns>
    Task<IReadOnlyList<ContainerLootTable>> GetLootedContainersAsync(
        CancellationToken ct = default);
}
```

### 4.3 Design Decisions

| Decision                    | Rationale                                              |
| --------------------------- | ------------------------------------------------------ |
| Async methods               | Supports async I/O for future database implementations |
| CancellationToken parameter | Allows operation cancellation                          |
| Room-based queries          | Efficient container lookup by room                     |
| Batch save operation        | Reduces overhead when initializing rooms               |
| Reset returns count         | Provides feedback on cleanup scope                     |
| Nullable return for Get     | Clearly indicates missing containers                   |

---

## 5. Feature Section: Persistence Strategy

### 5.1 Strategy Overview

Container state persistence follows these principles:

1. **Run-Scoped Persistence**: States persist for the duration of a game run
2. **Lazy Creation**: Containers added to repository when first encountered
3. **Eager Save**: State changes saved immediately after modification
4. **Clean Reset**: All states cleared when starting new run

### 5.2 State Persistence Table

| Container State | Persisted Data                          |
| --------------- | --------------------------------------- |
| Undiscovered    | Type, RoomId, State only                |
| Discovered      | Type, RoomId, State                     |
| Locked          | Type, RoomId, State                     |
| Open            | Type, RoomId, State, Contents           |
| Looted          | Type, RoomId, State, Contents, LootedAt |

### 5.3 Reset Scenarios

| Trigger             | Action                       |
| ------------------- | ---------------------------- |
| New Game            | `ResetAllContainersAsync()`  |
| New Run (Roguelike) | `ResetAllContainersAsync()`  |
| Load Saved Game     | Load from save file (future) |

---

## 6. Data Model Changes

### 6.1 New Interfaces

| Interface                   | File Path                                                                  | Purpose                     |
| --------------------------- | -------------------------------------------------------------------------- | --------------------------- |
| `IContainerStateRepository` | `src/Core/RuneAndRust.Application/Interfaces/IContainerStateRepository.cs` | Container state persistence |

---

## 7. Logging Specifications

| Component                   | Level       | Event                                              |
| --------------------------- | ----------- | -------------------------------------------------- |
| Repository (Implementation) | Information | "Saved container {ContainerId} with state {State}" |
| Repository (Implementation) | Information | "Reset {Count} containers for new run"             |
| Repository (Implementation) | Debug       | "Retrieved container {ContainerId}"                |
| Repository (Implementation) | Debug       | "Retrieved {Count} containers for room {RoomId}"   |
| Repository (Implementation) | Debug       | "Saved batch of {Count} containers"                |
| Repository (Implementation) | Warning     | "Container {ContainerId} not found for deletion"   |

---

## 8. Unit Testing Requirements

### 8.1 Test Summary

| Test Class                      | Test Count | Focus Area                |
| ------------------------------- | ---------- | ------------------------- |
| `ContainerStateRepositoryTests` | ~2         | Repository contract tests |

### 8.2 Test Specifications

**File:** `tests/RuneAndRust.Application.UnitTests/Interfaces/ContainerStateRepositoryTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Interfaces;

/// <summary>
/// Contract tests for IContainerStateRepository implementations.
/// </summary>
/// <remarks>
/// These tests should be run against any implementation of the repository
/// to ensure consistent behavior across different storage backends.
/// </remarks>
[TestFixture]
public abstract class ContainerStateRepositoryTests
{
    protected abstract IContainerStateRepository CreateRepository();

    private IContainerStateRepository _repository = null!;

    [SetUp]
    public void SetUp()
    {
        _repository = CreateRepository();
    }

    [Test]
    public async Task SaveAndRetrieve_Container_PersistsState()
    {
        // Arrange
        var roomId = Guid.NewGuid();
        var container = ContainerLootTable.Create(
            ContainerType.SmallChest,
            ContainerState.Discovered,
            roomId);
        container.Open();
        var contents = ContainerContents.Create(
            new List<string> { "sword-iron" },
            25,
            1);
        container.SetContents(contents);

        // Act
        await _repository.SaveContainerAsync(container);
        var retrieved = await _repository.GetContainerAsync(container.Id);

        // Assert
        retrieved.Should().NotBeNull();
        retrieved!.Id.Should().Be(container.Id);
        retrieved.Type.Should().Be(ContainerType.SmallChest);
        retrieved.State.Should().Be(ContainerState.Open);
        retrieved.Contents.Should().Be(contents);
    }

    [Test]
    public async Task ResetAllContainers_ClearsAllState()
    {
        // Arrange
        var container1 = ContainerLootTable.Create(ContainerType.SmallChest);
        var container2 = ContainerLootTable.Create(ContainerType.MediumChest);
        await _repository.SaveContainerAsync(container1);
        await _repository.SaveContainerAsync(container2);

        // Act
        var clearedCount = await _repository.ResetAllContainersAsync();

        // Assert
        clearedCount.Should().Be(2);
        var count = await _repository.GetCountAsync();
        count.Should().Be(0);
    }

    [Test]
    public async Task GetContainersByRoom_ReturnsOnlyRoomContainers()
    {
        // Arrange
        var roomA = Guid.NewGuid();
        var roomB = Guid.NewGuid();

        var containerA1 = ContainerLootTable.Create(
            ContainerType.SmallChest, roomId: roomA);
        var containerA2 = ContainerLootTable.Create(
            ContainerType.MediumChest, roomId: roomA);
        var containerB1 = ContainerLootTable.Create(
            ContainerType.LargeChest, roomId: roomB);

        await _repository.SaveContainersAsync(new[] { containerA1, containerA2, containerB1 });

        // Act
        var roomAContainers = await _repository.GetContainersByRoomAsync(roomA);

        // Assert
        roomAContainers.Should().HaveCount(2);
        roomAContainers.Should().Contain(c => c.Id == containerA1.Id);
        roomAContainers.Should().Contain(c => c.Id == containerA2.Id);
        roomAContainers.Should().NotContain(c => c.Id == containerB1.Id);
    }
}
```

### 8.3 In-Memory Implementation for Testing

**File:** `tests/RuneAndRust.Application.UnitTests/Fakes/InMemoryContainerStateRepository.cs`

```csharp
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.UnitTests.Fakes;

/// <summary>
/// In-memory implementation of IContainerStateRepository for testing.
/// </summary>
public class InMemoryContainerStateRepository : IContainerStateRepository
{
    private readonly Dictionary<Guid, ContainerLootTable> _containers = new();
    private readonly Dictionary<Guid, HashSet<Guid>> _roomIndex = new();

    public Task<ContainerLootTable?> GetContainerAsync(
        Guid containerId,
        CancellationToken ct = default)
    {
        _containers.TryGetValue(containerId, out var container);
        return Task.FromResult(container);
    }

    public Task<IReadOnlyList<ContainerLootTable>> GetContainersByRoomAsync(
        Guid roomId,
        CancellationToken ct = default)
    {
        if (!_roomIndex.TryGetValue(roomId, out var containerIds))
        {
            return Task.FromResult<IReadOnlyList<ContainerLootTable>>(
                Array.Empty<ContainerLootTable>());
        }

        var containers = containerIds
            .Where(id => _containers.ContainsKey(id))
            .Select(id => _containers[id])
            .ToList();

        return Task.FromResult<IReadOnlyList<ContainerLootTable>>(containers);
    }

    public Task SaveContainerAsync(
        ContainerLootTable container,
        CancellationToken ct = default)
    {
        ArgumentNullException.ThrowIfNull(container);

        _containers[container.Id] = container;

        if (container.RoomId.HasValue)
        {
            if (!_roomIndex.TryGetValue(container.RoomId.Value, out var containerIds))
            {
                containerIds = new HashSet<Guid>();
                _roomIndex[container.RoomId.Value] = containerIds;
            }

            containerIds.Add(container.Id);
        }

        return Task.CompletedTask;
    }

    public Task SaveContainersAsync(
        IEnumerable<ContainerLootTable> containers,
        CancellationToken ct = default)
    {
        foreach (var container in containers)
        {
            SaveContainerAsync(container, ct).Wait(ct);
        }

        return Task.CompletedTask;
    }

    public Task<bool> DeleteContainerAsync(
        Guid containerId,
        CancellationToken ct = default)
    {
        if (!_containers.TryGetValue(containerId, out var container))
        {
            return Task.FromResult(false);
        }

        _containers.Remove(containerId);

        if (container.RoomId.HasValue &&
            _roomIndex.TryGetValue(container.RoomId.Value, out var containerIds))
        {
            containerIds.Remove(containerId);
        }

        return Task.FromResult(true);
    }

    public Task<int> ResetAllContainersAsync(CancellationToken ct = default)
    {
        var count = _containers.Count;
        _containers.Clear();
        _roomIndex.Clear();
        return Task.FromResult(count);
    }

    public Task<bool> ExistsAsync(
        Guid containerId,
        CancellationToken ct = default)
    {
        return Task.FromResult(_containers.ContainsKey(containerId));
    }

    public Task<int> GetCountAsync(CancellationToken ct = default)
    {
        return Task.FromResult(_containers.Count);
    }

    public Task<IReadOnlyList<ContainerLootTable>> GetLootedContainersAsync(
        CancellationToken ct = default)
    {
        var looted = _containers.Values
            .Where(c => c.State == ContainerState.Looted)
            .ToList();

        return Task.FromResult<IReadOnlyList<ContainerLootTable>>(looted);
    }
}
```

---

## 9. Use Cases

### UC-001: Persist Container After Looting

| Field   | Value                                                                                                                           |
| ------- | ------------------------------------------------------------------------------------------------------------------------------- |
| Actor   | Game System                                                                                                                     |
| Trigger | Player loots a container                                                                                                        |
| Flow    | 1. Container state changes to Looted<br>2. LootedAt timestamp set<br>3. Call SaveContainerAsync<br>4. Container state persisted |
| Outcome | Looted state survives player leaving and returning to room                                                                      |

### UC-002: Retrieve Containers for Room

| Field   | Value                                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| Actor   | Room System                                                                                                                                       |
| Trigger | Player enters a room                                                                                                                              |
| Flow    | 1. Call GetContainersByRoomAsync with room ID<br>2. Repository returns all containers for room<br>3. Room displays containers with current states |
| Outcome | Previously looted containers shown as empty                                                                                                       |

### UC-003: Reset for New Run

| Field   | Value                                                                                                                    |
| ------- | ------------------------------------------------------------------------------------------------------------------------ |
| Actor   | Game System                                                                                                              |
| Trigger | Player starts new game or run                                                                                            |
| Flow    | 1. Call ResetAllContainersAsync<br>2. All container states cleared<br>3. Containers regenerated fresh when rooms entered |
| Outcome | All containers available for looting again                                                                               |

---

## 10. Deliverable Checklist

### 10.1 Application Layer

- [ ] `IContainerStateRepository` interface (`src/Core/RuneAndRust.Application/Interfaces/IContainerStateRepository.cs`)

### 10.2 Tests

- [ ] `ContainerStateRepositoryTests` abstract test class (`tests/RuneAndRust.Application.UnitTests/Interfaces/ContainerStateRepositoryTests.cs`)
- [ ] `InMemoryContainerStateRepository` test fake (`tests/RuneAndRust.Application.UnitTests/Fakes/InMemoryContainerStateRepository.cs`)

---

## 11. Acceptance Criteria

### 11.1 Functional Criteria

| ID    | Criterion                                | Verification |
| ----- | ---------------------------------------- | ------------ |
| AC-01 | Container state persists after looting   | Unit test    |
| AC-02 | Reset clears all container states        | Unit test    |
| AC-03 | Containers retrievable by room ID        | Unit test    |
| AC-04 | Batch save works for multiple containers | Unit test    |
| AC-05 | Delete removes container from repository | Unit test    |

### 11.2 Quality Criteria

| ID    | Criterion                        | Verification    |
| ----- | -------------------------------- | --------------- |
| QC-01 | All code has XML documentation   | Code inspection |
| QC-02 | ~2 unit tests pass               | Test execution  |
| QC-03 | Interface follows async patterns | Code review     |

---

## 12. Dependencies

### 12.1 Prerequisites

| Dependency | Description                    | Status   |
| ---------- | ------------------------------ | -------- |
| v0.16.4b   | ContainerLootTable entity      | Complete |
| v0.16.4b   | ContainerContents value object | Complete |
| v0.16.4b   | ContainerState enum            | Complete |

### 12.2 Provides To

| Consumer | Description                      |
| -------- | -------------------------------- |
| v0.16.4f | Room integration uses repository |
| Future   | Save/load system integration     |

---

## 13. Future Considerations

### 13.1 Deferred to v0.16.4f

- Room integration with container discovery
- Container initialization when entering rooms

### 13.2 Deferred to Infrastructure Layer

- Concrete repository implementations:
    - `InMemoryContainerStateRepository` (for runtime)
    - `JsonContainerStateRepository` (for save files)
    - `SqliteContainerStateRepository` (for larger games)

### 13.3 Potential Future Enhancements

- Cross-session persistence (save/load)
- Container respawn timers
- Per-container reset (selective clearing)
- Change tracking for undo operations
- Container state history for analytics
