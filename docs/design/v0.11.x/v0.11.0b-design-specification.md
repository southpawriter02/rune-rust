# v0.11.0b Design Specification: Harvestable Features

**Version:** 0.11.0b
**Parent:** v0.11.0 (Resources & Gathering)
**Prerequisites:** v0.11.0a Complete (Resource Definitions)
**Status:** Design Complete
**Estimated Unit Tests:** ~8

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture](#3-architecture)
4. [HarvestableFeatureDefinition Entity](#4-harvestablefeaturedefiniton-entity)
5. [HarvestableFeature Entity](#5-harvestablefeature-entity)
6. [IHarvestableFeatureProvider Interface](#6-iharvestablefeatureprovider-interface)
7. [HarvestableFeatureProvider Implementation](#7-harvestablefeatureprovider-implementation)
8. [Room Integration](#8-room-integration)
9. [Configuration Schema](#9-configuration-schema)
10. [Configuration File](#10-configuration-file)
11. [Logging Specifications](#11-logging-specifications)
12. [Unit Testing Requirements](#12-unit-testing-requirements)
13. [Use Cases](#13-use-cases)
14. [Deliverable Checklist](#14-deliverable-checklist)
15. [Acceptance Criteria](#15-acceptance-criteria)
16. [Dependencies](#16-dependencies)
17. [Future Considerations](#17-future-considerations)

---

## 1. Executive Summary

### Purpose

Implement harvestable room features that yield resources when gathered. Features are placed in rooms and define what resources they provide, difficulty class for gathering, quantity ranges, optional tool requirements, and replenishment behavior. This creates the environmental interaction points that connect the resource system (v0.11.0a) to the gathering mechanics (v0.11.0c).

### Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Entities** | `HarvestableFeatureDefinition`, `HarvestableFeature` |
| **Interfaces** | `IHarvestableFeatureProvider` |
| **Infrastructure** | `HarvestableFeatureProvider` |
| **Room Updates** | Feature integration, spawning support |
| **Configuration** | `harvestable-features.json`, `harvestable-features.schema.json` |
| **Tests** | ~8 unit tests |

### Architectural Significance

This version establishes the **Definition-Instance Pattern** for room features:
- `HarvestableFeatureDefinition` is the template (loaded from JSON)
- `HarvestableFeature` is the runtime instance (tracks state per room)
- Features link to resources via `ResourceId` reference
- Replenishment system enables renewable resource nodes

---

## 2. Feature Overview

```
v0.11.0b Features
├── HarvestableFeatureDefinition Entity
│   ├── FeatureId (string key)
│   ├── Name, Description
│   ├── ResourceId (link to resource)
│   ├── MinQuantity, MaxQuantity
│   ├── DifficultyClass (DC)
│   ├── RequiredToolId (optional)
│   ├── ReplenishTurns (0 = never)
│   ├── IconPath (optional)
│   ├── RequiresTool property
│   └── Replenishes property
│
├── HarvestableFeature Entity (extends RoomFeature)
│   ├── DefinitionId (reference)
│   ├── RemainingQuantity
│   ├── ReplenishAtTurn (nullable)
│   ├── IsDepleted property
│   ├── Harvest(amount) method
│   ├── SetReplenishTimer() method
│   ├── Replenish(quantity) method
│   └── ShouldReplenish(turn) method
│
├── IHarvestableFeatureProvider Interface
│   ├── GetFeature(featureId)
│   ├── GetAllFeatures()
│   ├── GetFeaturesByResource(resourceId)
│   ├── Exists(featureId)
│   └── Count property
│
├── HarvestableFeatureProvider Implementation
│   ├── JSON loading
│   ├── Resource ID validation
│   └── Caching
│
├── Room Integration
│   ├── HarvestableFeature in Features list
│   ├── Feature spawning support
│   └── Feature state persistence
│
└── Configuration
    ├── harvestable-features.json (8 features)
    └── harvestable-features.schema.json
```

---

## 3. Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                 HARVESTABLE FEATURE ARCHITECTURE                         │
└─────────────────────────────────────────────────────────────────────────┘

     Configuration                        Domain
     ─────────────                        ──────

   harvestable-features.json     ┌─────────────────────────────┐
   ┌─────────────────┐           │HarvestableFeatureDefinition │
   │ {                │           ├─────────────────────────────┤
   │   "id": "ore-",  │  ─────▶   │ + Id: Guid                  │
   │   "resourceId":..,          │ + FeatureId: string         │
   │   "minQty": 1,  │           │ + Name: string              │
   │   "maxQty": 5   │           │ + Description: string       │
   │ }                │           │ + ResourceId: string        │
   └─────────────────┘           │ + MinQuantity: int          │
                                  │ + MaxQuantity: int          │
                                  │ + DifficultyClass: int      │
                                  │ + RequiredToolId: string?   │
                                  │ + ReplenishTurns: int       │
                                  │ + IconPath: string?         │
                                  └──────────────┬──────────────┘
                                                 │ creates instance
                                                 ▼
                                  ┌─────────────────────────────┐
                                  │     HarvestableFeature      │
                                  │     (Room instance)         │
                                  ├─────────────────────────────┤
                                  │ + Id: Guid                  │
                                  │ + DefinitionId: string      │
                                  │ + RemainingQuantity: int    │
                                  │ + ReplenishAtTurn: int?     │
                                  │ + IsDepleted: bool          │
                                  └─────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────┐
│                           LAYER DIAGRAM                                  │
└─────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────┐
    │                      PRESENTATION LAYER                          │
    │                        (v0.13.x UI)                              │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                      APPLICATION LAYER                           │
    ├─────────────────────────────────────────────────────────────────┤
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │        IHarvestableFeatureProvider (Interface)          │    │
    │  ├─────────────────────────────────────────────────────────┤    │
    │  │ + GetFeature(featureId): HarvestableFeatureDefinition?  │    │
    │  │ + GetAllFeatures(): IReadOnlyList<...>                  │    │
    │  │ + GetFeaturesByResource(resourceId): IReadOnlyList<...> │    │
    │  │ + Exists(featureId): bool                               │    │
    │  │ + Count: int                                            │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                        DOMAIN LAYER                              │
    ├─────────────────────────────────────────────────────────────────┤
    │  ┌──────────────────────────┐  ┌──────────────────────────┐     │
    │  │HarvestableFeatureDefinition│  │   HarvestableFeature    │     │
    │  │       (Definition)       │  │   (Room Instance)        │     │
    │  └──────────────────────────┘  └──────────────────────────┘     │
    │                │                           │                     │
    │                │ references                │ extends             │
    │                ▼                           ▼                     │
    │  ┌──────────────────────────┐  ┌──────────────────────────┐     │
    │  │   ResourceDefinition     │  │      RoomFeature         │     │
    │  │     (from v0.11.0a)      │  │   (existing entity)      │     │
    │  └──────────────────────────┘  └──────────────────────────┘     │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                    INFRASTRUCTURE LAYER                          │
    ├─────────────────────────────────────────────────────────────────┤
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │      HarvestableFeatureProvider (Implementation)        │    │
    │  ├─────────────────────────────────────────────────────────┤    │
    │  │ - _features: Dictionary<string, HarvestableFeatureDef>  │    │
    │  │ - _resourceProvider: IResourceProvider                  │    │
    │  │ - _logger: ILogger<HarvestableFeatureProvider>          │    │
    │  │                                                         │    │
    │  │ + LoadFeatures(configProvider)                          │    │
    │  │ + ValidateResourceReferences()                          │    │
    │  └─────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                     CONFIGURATION LAYER                          │
    ├─────────────────────────────────────────────────────────────────┤
    │  ┌────────────────────────────┐  ┌────────────────────────────┐ │
    │  │ harvestable-features.json  │  │harvestable-features.schema │ │
    │  │      (8 features)          │  │       .json                │ │
    │  └────────────────────────────┘  └────────────────────────────┘ │
    └─────────────────────────────────────────────────────────────────┘
```

### Definition-Instance Relationship

```
    DEFINITION → INSTANCE PATTERN
    ─────────────────────────────

    ┌─────────────────────────────────────────────────────────────────┐
    │             HarvestableFeatureDefinition (Template)              │
    ├─────────────────────────────────────────────────────────────────┤
    │  FeatureId: "iron-ore-vein"                                     │
    │  ResourceId: "iron-ore"                                         │
    │  MinQuantity: 1                                                 │
    │  MaxQuantity: 5                                                 │
    │  DifficultyClass: 12                                            │
    │  ReplenishTurns: 0                                              │
    └─────────────────────────────────────────────────────────────────┘
                    │
                    │ Create instance for room
                    │
        ┌───────────┴───────────┬───────────────────────┐
        ▼                       ▼                       ▼
    ┌─────────────┐       ┌─────────────┐       ┌─────────────┐
    │ Room A      │       │ Room B      │       │ Room C      │
    │ Instance    │       │ Instance    │       │ Instance    │
    ├─────────────┤       ├─────────────┤       ├─────────────┤
    │ Remaining: 5│       │ Remaining: 3│       │ Remaining: 0│
    │ Depleted: N │       │ Depleted: N │       │ Depleted: Y │
    └─────────────┘       └─────────────┘       └─────────────┘
```

### Room with Harvestable Features

```
    ROOM WITH HARVESTABLE FEATURES
    ──────────────────────────────

    ┌─────────────────────────────────────────────────────────────────┐
    │  DARK CAVE                                                       │
    ├─────────────────────────────────────────────────────────────────┤
    │                                                                  │
    │  You enter a damp cave. Water drips from stalactites above.     │
    │                                                                  │
    │  FEATURES:                                                       │
    │  ├─ [Ore Vein] A vein of iron ore in the wall                   │
    │  │             DC: 12 | Est. yield: 1-5 Iron Ore                │
    │  │                                                               │
    │  ├─ [Herb Patch] Healing herbs grow near a dim light source     │
    │  │               DC: 10 | Est. yield: 2-6 Healing Herb          │
    │  │               Replenishes in 100 turns                        │
    │  │                                                               │
    │  └─ [Gem Cluster] Sparkling gems embedded in rock               │
    │                   DC: 16 | Est. yield: 1-2 Ruby | Requires: pick │
    │                                                                  │
    └─────────────────────────────────────────────────────────────────┘
```

---

## 4. HarvestableFeatureDefinition Entity

**File:** `src/Core/RuneAndRust.Domain/Definitions/HarvestableFeatureDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a harvestable feature type that appears in rooms and yields resources.
/// </summary>
/// <remarks>
/// <para>
/// Harvestable feature definitions are templates loaded from JSON configuration.
/// They define the properties of environmental objects that players can gather
/// resources from, including the resource yielded, difficulty class, quantity
/// ranges, and optional tool requirements.
/// </para>
/// <para>
/// Features are identified by a unique string ID (e.g., "iron-ore-vein") and
/// link to resource definitions via the <see cref="ResourceId"/> property.
/// </para>
/// </remarks>
/// <example>
/// var oreVein = HarvestableFeatureDefinition.Create(
///     "iron-ore-vein",
///     "Iron Ore Vein",
///     "A vein of iron ore in the rock wall",
///     "iron-ore",
///     minQuantity: 1,
///     maxQuantity: 5,
///     difficultyClass: 12);
/// </example>
public class HarvestableFeatureDefinition : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this feature definition.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the string identifier used for lookups and configuration references.
    /// </summary>
    /// <example>"iron-ore-vein", "herb-patch", "gem-cluster"</example>
    public string FeatureId { get; private set; } = null!;

    /// <summary>
    /// Gets the display name of the feature shown in room descriptions.
    /// </summary>
    public string Name { get; private set; } = null!;

    /// <summary>
    /// Gets the description shown when examining the feature.
    /// </summary>
    public string Description { get; private set; } = null!;

    /// <summary>
    /// Gets the ID of the resource this feature yields when gathered.
    /// </summary>
    /// <remarks>
    /// Must match a valid resource ID from the resource definitions.
    /// </remarks>
    public string ResourceId { get; private set; } = null!;

    /// <summary>
    /// Gets the minimum quantity of resources yielded on a successful gather.
    /// </summary>
    public int MinQuantity { get; private set; }

    /// <summary>
    /// Gets the maximum quantity of resources yielded on a successful gather.
    /// </summary>
    public int MaxQuantity { get; private set; }

    /// <summary>
    /// Gets the difficulty class for gathering from this feature.
    /// </summary>
    /// <remarks>
    /// Players must roll d20 + skill modifier >= DC to succeed.
    /// Typical range: 10 (easy) to 18 (very hard).
    /// </remarks>
    public int DifficultyClass { get; private set; }

    /// <summary>
    /// Gets the optional tool ID required to gather from this feature.
    /// </summary>
    /// <remarks>
    /// If set, the player must have this tool in their inventory to attempt gathering.
    /// Examples: "pickaxe", "skinning-knife", "axe"
    /// </remarks>
    public string? RequiredToolId { get; private set; }

    /// <summary>
    /// Gets the number of turns until this feature replenishes after depletion.
    /// </summary>
    /// <remarks>
    /// A value of 0 means the feature never replenishes (one-time harvest).
    /// </remarks>
    public int ReplenishTurns { get; private set; }

    /// <summary>
    /// Gets the optional path to the feature's icon.
    /// </summary>
    public string? IconPath { get; private set; }

    // Private constructor for EF Core and JSON deserialization
    private HarvestableFeatureDefinition() { }

    /// <summary>
    /// Creates a new harvestable feature definition with the specified properties.
    /// </summary>
    /// <param name="featureId">Unique string identifier (will be lowercased).</param>
    /// <param name="name">Display name.</param>
    /// <param name="description">Description text.</param>
    /// <param name="resourceId">ID of the resource yielded (will be lowercased).</param>
    /// <param name="minQuantity">Minimum yield quantity (must be >= 0).</param>
    /// <param name="maxQuantity">Maximum yield quantity (must be >= minQuantity).</param>
    /// <param name="difficultyClass">DC for gathering check (must be > 0).</param>
    /// <param name="requiredToolId">Optional tool required for gathering.</param>
    /// <param name="replenishTurns">Turns to replenish (0 = never).</param>
    /// <returns>A new <see cref="HarvestableFeatureDefinition"/> instance.</returns>
    /// <exception cref="ArgumentException">Thrown when featureId or resourceId is null/whitespace.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when quantities or DC are invalid.</exception>
    public static HarvestableFeatureDefinition Create(
        string featureId,
        string name,
        string description,
        string resourceId,
        int minQuantity,
        int maxQuantity,
        int difficultyClass,
        string? requiredToolId = null,
        int replenishTurns = 0)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(featureId, nameof(featureId));
        ArgumentException.ThrowIfNullOrWhiteSpace(name, nameof(name));
        ArgumentException.ThrowIfNullOrWhiteSpace(resourceId, nameof(resourceId));
        ArgumentOutOfRangeException.ThrowIfNegative(minQuantity, nameof(minQuantity));
        ArgumentOutOfRangeException.ThrowIfLessThan(maxQuantity, minQuantity, nameof(maxQuantity));
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(difficultyClass, nameof(difficultyClass));
        ArgumentOutOfRangeException.ThrowIfNegative(replenishTurns, nameof(replenishTurns));

        return new HarvestableFeatureDefinition
        {
            Id = Guid.NewGuid(),
            FeatureId = featureId.ToLowerInvariant(),
            Name = name,
            Description = description ?? string.Empty,
            ResourceId = resourceId.ToLowerInvariant(),
            MinQuantity = minQuantity,
            MaxQuantity = maxQuantity,
            DifficultyClass = difficultyClass,
            RequiredToolId = requiredToolId?.ToLowerInvariant(),
            ReplenishTurns = replenishTurns
        };
    }

    /// <summary>
    /// Sets the icon path for this feature.
    /// </summary>
    /// <param name="iconPath">Path to the icon file.</param>
    /// <returns>This instance for fluent chaining.</returns>
    public HarvestableFeatureDefinition WithIcon(string iconPath)
    {
        IconPath = iconPath;
        return this;
    }

    /// <summary>
    /// Gets whether this feature requires a tool to harvest.
    /// </summary>
    public bool RequiresTool => RequiredToolId is not null;

    /// <summary>
    /// Gets whether this feature replenishes over time.
    /// </summary>
    public bool Replenishes => ReplenishTurns > 0;

    /// <summary>
    /// Gets the expected yield range as a display string.
    /// </summary>
    /// <returns>Formatted string like "1-5" or "3" if min equals max.</returns>
    public string GetYieldRangeDisplay()
    {
        return MinQuantity == MaxQuantity
            ? MinQuantity.ToString()
            : $"{MinQuantity}-{MaxQuantity}";
    }

    /// <summary>
    /// Gets a summary of gathering requirements for display.
    /// </summary>
    /// <returns>Formatted string with DC, yield, and optional tool requirement.</returns>
    public string GetRequirementsSummary()
    {
        var summary = $"DC: {DifficultyClass} | Yield: {GetYieldRangeDisplay()}";
        if (RequiresTool)
        {
            summary += $" | Requires: {RequiredToolId}";
        }
        if (Replenishes)
        {
            summary += $" | Replenishes: {ReplenishTurns} turns";
        }
        return summary;
    }

    /// <summary>
    /// Returns a display string for this feature definition.
    /// </summary>
    public override string ToString()
    {
        return $"{Name} ({FeatureId}) - {ResourceId}";
    }
}
```

---

## 5. HarvestableFeature Entity

**File:** `src/Core/RuneAndRust.Domain/Entities/HarvestableFeature.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// An instance of a harvestable feature placed in a room.
/// </summary>
/// <remarks>
/// <para>
/// Harvestable features are runtime instances created from
/// <see cref="HarvestableFeatureDefinition"/> templates. Each instance tracks
/// its own remaining quantity and replenishment state.
/// </para>
/// <para>
/// This entity extends <see cref="RoomFeature"/> to integrate with the
/// existing room feature system, allowing it to appear in room descriptions
/// and be interacted with using the "gather" verb.
/// </para>
/// </remarks>
public class HarvestableFeature : RoomFeature
{
    /// <summary>
    /// Gets the ID of the definition this feature was created from.
    /// </summary>
    public string DefinitionId { get; private set; } = null!;

    /// <summary>
    /// Gets the remaining quantity of resources available to harvest.
    /// </summary>
    public int RemainingQuantity { get; private set; }

    /// <summary>
    /// Gets the turn number at which this feature will replenish, if depleted.
    /// </summary>
    /// <remarks>
    /// Null if the feature is not depleted or does not replenish.
    /// </remarks>
    public int? ReplenishAtTurn { get; private set; }

    /// <summary>
    /// Gets the initial quantity this feature was created with.
    /// </summary>
    /// <remarks>
    /// Used for replenishment to restore to original state.
    /// </remarks>
    public int InitialQuantity { get; private set; }

    // Private constructor for EF Core
    private HarvestableFeature() : base() { }

    /// <summary>
    /// Creates a new harvestable feature instance from a definition.
    /// </summary>
    /// <param name="definition">The definition to create from.</param>
    /// <param name="initialQuantity">The starting quantity of resources.</param>
    /// <returns>A new <see cref="HarvestableFeature"/> instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown when definition is null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when initialQuantity is negative.</exception>
    public static HarvestableFeature Create(
        HarvestableFeatureDefinition definition,
        int initialQuantity)
    {
        ArgumentNullException.ThrowIfNull(definition, nameof(definition));
        ArgumentOutOfRangeException.ThrowIfNegative(initialQuantity, nameof(initialQuantity));

        return new HarvestableFeature
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.FeatureId,
            Name = definition.Name,
            Description = definition.Description,
            RemainingQuantity = initialQuantity,
            InitialQuantity = initialQuantity,
            IsInteractable = true,
            InteractionVerb = "gather"
        };
    }

    /// <summary>
    /// Creates a new harvestable feature with a random quantity within the definition's range.
    /// </summary>
    /// <param name="definition">The definition to create from.</param>
    /// <param name="random">Random number generator.</param>
    /// <returns>A new <see cref="HarvestableFeature"/> instance.</returns>
    public static HarvestableFeature CreateWithRandomQuantity(
        HarvestableFeatureDefinition definition,
        Random? random = null)
    {
        ArgumentNullException.ThrowIfNull(definition, nameof(definition));

        random ??= Random.Shared;
        var quantity = random.Next(definition.MinQuantity, definition.MaxQuantity + 1);

        return Create(definition, quantity);
    }

    /// <summary>
    /// Gets whether this feature has been depleted (no resources remaining).
    /// </summary>
    public bool IsDepleted => RemainingQuantity <= 0;

    /// <summary>
    /// Gets whether this feature is currently waiting to replenish.
    /// </summary>
    public bool IsAwaitingReplenishment => ReplenishAtTurn.HasValue;

    /// <summary>
    /// Reduces the remaining quantity by the amount harvested.
    /// </summary>
    /// <param name="amount">The amount to harvest.</param>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when amount is negative.</exception>
    /// <exception cref="InvalidOperationException">Thrown when feature is depleted.</exception>
    public void Harvest(int amount)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(amount, nameof(amount));

        if (IsDepleted)
        {
            throw new InvalidOperationException("Cannot harvest from a depleted feature.");
        }

        RemainingQuantity = Math.Max(0, RemainingQuantity - amount);
    }

    /// <summary>
    /// Sets the replenishment timer for this feature.
    /// </summary>
    /// <param name="currentTurn">The current game turn.</param>
    /// <param name="replenishTurns">The number of turns until replenishment.</param>
    /// <remarks>
    /// Only sets the timer if replenishTurns is greater than 0.
    /// </remarks>
    public void SetReplenishTimer(int currentTurn, int replenishTurns)
    {
        if (replenishTurns > 0)
        {
            ReplenishAtTurn = currentTurn + replenishTurns;
        }
    }

    /// <summary>
    /// Replenishes the feature to its initial quantity.
    /// </summary>
    /// <remarks>
    /// Clears the replenishment timer after replenishing.
    /// </remarks>
    public void Replenish()
    {
        RemainingQuantity = InitialQuantity;
        ReplenishAtTurn = null;
    }

    /// <summary>
    /// Replenishes the feature to a specific quantity.
    /// </summary>
    /// <param name="quantity">The quantity to replenish to.</param>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when quantity is negative.</exception>
    public void Replenish(int quantity)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(quantity, nameof(quantity));

        RemainingQuantity = quantity;
        ReplenishAtTurn = null;
    }

    /// <summary>
    /// Checks if the feature should replenish on the given turn.
    /// </summary>
    /// <param name="currentTurn">The current game turn.</param>
    /// <returns>True if the feature should replenish, false otherwise.</returns>
    public bool ShouldReplenish(int currentTurn)
    {
        return ReplenishAtTurn.HasValue && currentTurn >= ReplenishAtTurn.Value;
    }

    /// <summary>
    /// Gets a status display string for this feature.
    /// </summary>
    /// <returns>Formatted string showing depletion or remaining quantity.</returns>
    public string GetStatusDisplay()
    {
        if (IsDepleted && IsAwaitingReplenishment)
        {
            return $"[Depleted - Replenishes at turn {ReplenishAtTurn}]";
        }
        if (IsDepleted)
        {
            return "[Depleted]";
        }
        return $"[{RemainingQuantity} remaining]";
    }

    /// <summary>
    /// Returns a display string for this feature instance.
    /// </summary>
    public override string ToString()
    {
        return $"{Name} {GetStatusDisplay()}";
    }
}
```

---

## 6. IHarvestableFeatureProvider Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IHarvestableFeatureProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides access to harvestable feature definitions loaded from configuration.
/// </summary>
/// <remarks>
/// This interface abstracts the loading and retrieval of harvestable feature
/// definitions, allowing for different implementations while maintaining a
/// consistent API for the application layer.
/// </remarks>
public interface IHarvestableFeatureProvider
{
    /// <summary>
    /// Gets a harvestable feature definition by its unique string identifier.
    /// </summary>
    /// <param name="featureId">The feature identifier (case-insensitive).</param>
    /// <returns>The feature definition, or null if not found.</returns>
    /// <example>
    /// var oreVein = featureProvider.GetFeature("iron-ore-vein");
    /// if (oreVein is not null)
    /// {
    ///     Console.WriteLine($"Found: {oreVein.Name}, DC: {oreVein.DifficultyClass}");
    /// }
    /// </example>
    HarvestableFeatureDefinition? GetFeature(string featureId);

    /// <summary>
    /// Gets all registered harvestable feature definitions.
    /// </summary>
    /// <returns>A read-only list of all feature definitions.</returns>
    IReadOnlyList<HarvestableFeatureDefinition> GetAllFeatures();

    /// <summary>
    /// Gets all features that yield a specific resource.
    /// </summary>
    /// <param name="resourceId">The resource identifier to filter by.</param>
    /// <returns>A read-only list of matching feature definitions.</returns>
    /// <example>
    /// var ironFeatures = featureProvider.GetFeaturesByResource("iron-ore");
    /// // Returns all features that yield iron ore
    /// </example>
    IReadOnlyList<HarvestableFeatureDefinition> GetFeaturesByResource(string resourceId);

    /// <summary>
    /// Gets all features that require a specific tool.
    /// </summary>
    /// <param name="toolId">The tool identifier to filter by.</param>
    /// <returns>A read-only list of matching feature definitions.</returns>
    IReadOnlyList<HarvestableFeatureDefinition> GetFeaturesByTool(string toolId);

    /// <summary>
    /// Gets all features within a difficulty class range.
    /// </summary>
    /// <param name="minDC">Minimum difficulty class (inclusive).</param>
    /// <param name="maxDC">Maximum difficulty class (inclusive).</param>
    /// <returns>A read-only list of matching feature definitions.</returns>
    IReadOnlyList<HarvestableFeatureDefinition> GetFeaturesByDifficulty(int minDC, int maxDC);

    /// <summary>
    /// Checks if a feature with the specified ID exists.
    /// </summary>
    /// <param name="featureId">The feature identifier to check.</param>
    /// <returns>True if the feature exists, false otherwise.</returns>
    bool Exists(string featureId);

    /// <summary>
    /// Gets all registered feature IDs.
    /// </summary>
    /// <returns>A read-only list of all feature identifiers.</returns>
    IReadOnlyList<string> GetFeatureIds();

    /// <summary>
    /// Gets the total count of registered features.
    /// </summary>
    int Count { get; }

    /// <summary>
    /// Creates a new harvestable feature instance from a definition.
    /// </summary>
    /// <param name="featureId">The feature definition ID.</param>
    /// <param name="random">Optional random generator for quantity.</param>
    /// <returns>A new feature instance, or null if definition not found.</returns>
    HarvestableFeature? CreateFeatureInstance(string featureId, Random? random = null);
}
```

---

## 7. HarvestableFeatureProvider Implementation

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Services/HarvestableFeatureProvider.cs`

```csharp
namespace RuneAndRust.Infrastructure.Services;

/// <summary>
/// Provides harvestable feature definitions loaded from JSON configuration.
/// </summary>
/// <remarks>
/// Features are loaded once at construction and cached for the lifetime
/// of the provider. Resource ID references are validated against the
/// resource provider during loading.
/// </remarks>
public class HarvestableFeatureProvider : IHarvestableFeatureProvider
{
    private readonly Dictionary<string, HarvestableFeatureDefinition> _features =
        new(StringComparer.OrdinalIgnoreCase);
    private readonly IResourceProvider _resourceProvider;
    private readonly ILogger<HarvestableFeatureProvider> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="HarvestableFeatureProvider"/> class.
    /// </summary>
    /// <param name="configProvider">The configuration provider for loading JSON.</param>
    /// <param name="resourceProvider">The resource provider for validating resource references.</param>
    /// <param name="logger">The logger instance.</param>
    public HarvestableFeatureProvider(
        IConfigurationProvider configProvider,
        IResourceProvider resourceProvider,
        ILogger<HarvestableFeatureProvider> logger)
    {
        _resourceProvider = resourceProvider;
        _logger = logger;
        LoadFeatures(configProvider);
    }

    private void LoadFeatures(IConfigurationProvider configProvider)
    {
        try
        {
            _logger.LogInformation("Loading harvestable feature definitions from configuration");

            var json = configProvider.LoadConfig<HarvestableFeaturesJson>("harvestable-features.json");

            if (json?.HarvestableFeatures is null || json.HarvestableFeatures.Count == 0)
            {
                _logger.LogWarning("No harvestable features found in configuration");
                return;
            }

            foreach (var featureJson in json.HarvestableFeatures)
            {
                if (!TryParseFeature(featureJson, out var definition))
                {
                    continue;
                }

                if (_features.ContainsKey(definition!.FeatureId))
                {
                    _logger.LogWarning(
                        "Duplicate feature ID '{FeatureId}' - skipping",
                        definition.FeatureId);
                    continue;
                }

                _features[definition.FeatureId] = definition;
                _logger.LogDebug(
                    "Loaded feature: {FeatureId} -> {ResourceId} (DC: {DC})",
                    definition.FeatureId,
                    definition.ResourceId,
                    definition.DifficultyClass);
            }

            _logger.LogInformation(
                "Loaded {Count} harvestable feature definitions from configuration",
                _features.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load harvestable feature definitions");
            throw;
        }
    }

    private bool TryParseFeature(HarvestableFeatureJsonEntry entry, out HarvestableFeatureDefinition? definition)
    {
        definition = null;

        try
        {
            // Validate required fields
            if (string.IsNullOrWhiteSpace(entry.Id))
            {
                _logger.LogWarning("Feature entry missing ID - skipping");
                return false;
            }

            if (string.IsNullOrWhiteSpace(entry.ResourceId))
            {
                _logger.LogWarning(
                    "Feature '{Id}' missing resource ID - skipping",
                    entry.Id);
                return false;
            }

            // Validate resource reference exists
            if (!_resourceProvider.Exists(entry.ResourceId))
            {
                _logger.LogWarning(
                    "Feature '{Id}' references unknown resource '{ResourceId}' - skipping",
                    entry.Id,
                    entry.ResourceId);
                return false;
            }

            // Validate quantity range
            if (entry.MinQuantity < 0)
            {
                _logger.LogWarning(
                    "Feature '{Id}' has negative minQuantity - skipping",
                    entry.Id);
                return false;
            }

            if (entry.MaxQuantity < entry.MinQuantity)
            {
                _logger.LogWarning(
                    "Feature '{Id}' maxQuantity ({Max}) < minQuantity ({Min}) - skipping",
                    entry.Id,
                    entry.MaxQuantity,
                    entry.MinQuantity);
                return false;
            }

            // Validate difficulty class
            if (entry.DifficultyClass <= 0)
            {
                _logger.LogWarning(
                    "Feature '{Id}' has invalid difficulty class {DC} - skipping",
                    entry.Id,
                    entry.DifficultyClass);
                return false;
            }

            definition = HarvestableFeatureDefinition.Create(
                entry.Id,
                entry.Name ?? entry.Id,
                entry.Description ?? string.Empty,
                entry.ResourceId,
                entry.MinQuantity > 0 ? entry.MinQuantity : 1,
                entry.MaxQuantity > 0 ? entry.MaxQuantity : entry.MinQuantity,
                entry.DifficultyClass,
                entry.RequiredTool,
                entry.ReplenishTurns >= 0 ? entry.ReplenishTurns : 0);

            if (!string.IsNullOrEmpty(entry.Icon))
            {
                definition.WithIcon(entry.Icon);
            }

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to parse feature '{Id}'", entry.Id);
            return false;
        }
    }

    /// <inheritdoc />
    public HarvestableFeatureDefinition? GetFeature(string featureId)
    {
        if (string.IsNullOrWhiteSpace(featureId))
        {
            return null;
        }

        return _features.GetValueOrDefault(featureId.ToLowerInvariant());
    }

    /// <inheritdoc />
    public IReadOnlyList<HarvestableFeatureDefinition> GetAllFeatures()
    {
        return _features.Values.ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<HarvestableFeatureDefinition> GetFeaturesByResource(string resourceId)
    {
        if (string.IsNullOrWhiteSpace(resourceId))
        {
            return [];
        }

        var normalizedId = resourceId.ToLowerInvariant();
        return _features.Values
            .Where(f => f.ResourceId == normalizedId)
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<HarvestableFeatureDefinition> GetFeaturesByTool(string toolId)
    {
        if (string.IsNullOrWhiteSpace(toolId))
        {
            return [];
        }

        var normalizedId = toolId.ToLowerInvariant();
        return _features.Values
            .Where(f => f.RequiredToolId == normalizedId)
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<HarvestableFeatureDefinition> GetFeaturesByDifficulty(int minDC, int maxDC)
    {
        return _features.Values
            .Where(f => f.DifficultyClass >= minDC && f.DifficultyClass <= maxDC)
            .ToList();
    }

    /// <inheritdoc />
    public bool Exists(string featureId)
    {
        if (string.IsNullOrWhiteSpace(featureId))
        {
            return false;
        }

        return _features.ContainsKey(featureId.ToLowerInvariant());
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetFeatureIds()
    {
        return _features.Keys.ToList();
    }

    /// <inheritdoc />
    public int Count => _features.Count;

    /// <inheritdoc />
    public HarvestableFeature? CreateFeatureInstance(string featureId, Random? random = null)
    {
        var definition = GetFeature(featureId);
        if (definition is null)
        {
            _logger.LogDebug("Cannot create instance: feature '{FeatureId}' not found", featureId);
            return null;
        }

        return HarvestableFeature.CreateWithRandomQuantity(definition, random);
    }
}

/// <summary>
/// JSON model for harvestable features configuration file.
/// </summary>
internal class HarvestableFeaturesJson
{
    public List<HarvestableFeatureJsonEntry> HarvestableFeatures { get; set; } = new();
}

/// <summary>
/// JSON model for a single harvestable feature entry.
/// </summary>
internal class HarvestableFeatureJsonEntry
{
    public string Id { get; set; } = null!;
    public string? Name { get; set; }
    public string? Description { get; set; }
    public string ResourceId { get; set; } = null!;
    public int MinQuantity { get; set; }
    public int MaxQuantity { get; set; }
    public int DifficultyClass { get; set; }
    public string? RequiredTool { get; set; }
    public int ReplenishTurns { get; set; }
    public string? Icon { get; set; }
}
```

---

## 8. Room Integration

### Room Feature Registration

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modifications)

```csharp
// Add to existing Room entity:

/// <summary>
/// Gets all harvestable features in this room.
/// </summary>
/// <returns>A read-only list of harvestable features.</returns>
public IReadOnlyList<HarvestableFeature> GetHarvestableFeatures()
{
    return Features
        .OfType<HarvestableFeature>()
        .ToList();
}

/// <summary>
/// Gets all non-depleted harvestable features in this room.
/// </summary>
/// <returns>A read-only list of available harvestable features.</returns>
public IReadOnlyList<HarvestableFeature> GetAvailableHarvestableFeatures()
{
    return Features
        .OfType<HarvestableFeature>()
        .Where(f => !f.IsDepleted)
        .ToList();
}

/// <summary>
/// Adds a harvestable feature to this room.
/// </summary>
/// <param name="feature">The feature to add.</param>
/// <exception cref="ArgumentNullException">Thrown when feature is null.</exception>
public void AddHarvestableFeature(HarvestableFeature feature)
{
    ArgumentNullException.ThrowIfNull(feature, nameof(feature));
    AddFeature(feature);
}

/// <summary>
/// Processes replenishment for all harvestable features in this room.
/// </summary>
/// <param name="currentTurn">The current game turn.</param>
/// <returns>A list of features that were replenished.</returns>
public IReadOnlyList<HarvestableFeature> ProcessFeatureReplenishment(int currentTurn)
{
    var replenished = new List<HarvestableFeature>();

    foreach (var feature in GetHarvestableFeatures())
    {
        if (feature.ShouldReplenish(currentTurn))
        {
            feature.Replenish();
            replenished.Add(feature);
        }
    }

    return replenished;
}
```

### Feature Spawning Helper

**File:** `src/Core/RuneAndRust.Application/Services/RoomFeatureSpawner.cs`

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Helper service for spawning harvestable features in rooms.
/// </summary>
public class RoomFeatureSpawner
{
    private readonly IHarvestableFeatureProvider _featureProvider;
    private readonly ILogger<RoomFeatureSpawner> _logger;
    private readonly Random _random;

    public RoomFeatureSpawner(
        IHarvestableFeatureProvider featureProvider,
        ILogger<RoomFeatureSpawner> logger)
    {
        _featureProvider = featureProvider;
        _logger = logger;
        _random = new Random();
    }

    /// <summary>
    /// Spawns a specific feature in a room.
    /// </summary>
    /// <param name="room">The room to spawn in.</param>
    /// <param name="featureId">The feature definition ID.</param>
    /// <returns>The spawned feature, or null if the definition wasn't found.</returns>
    public HarvestableFeature? SpawnFeature(Room room, string featureId)
    {
        var feature = _featureProvider.CreateFeatureInstance(featureId, _random);
        if (feature is null)
        {
            _logger.LogWarning(
                "Failed to spawn feature '{FeatureId}' in room '{RoomId}': definition not found",
                featureId,
                room.Id);
            return null;
        }

        room.AddHarvestableFeature(feature);
        _logger.LogDebug(
            "Spawned feature '{FeatureId}' in room '{RoomId}' with quantity {Quantity}",
            featureId,
            room.Id,
            feature.RemainingQuantity);

        return feature;
    }

    /// <summary>
    /// Spawns multiple features in a room based on a spawn table.
    /// </summary>
    /// <param name="room">The room to spawn in.</param>
    /// <param name="spawnTable">Dictionary of feature IDs to spawn chances (0.0 to 1.0).</param>
    /// <returns>List of spawned features.</returns>
    public IReadOnlyList<HarvestableFeature> SpawnFromTable(
        Room room,
        IDictionary<string, double> spawnTable)
    {
        var spawned = new List<HarvestableFeature>();

        foreach (var (featureId, chance) in spawnTable)
        {
            if (_random.NextDouble() <= chance)
            {
                var feature = SpawnFeature(room, featureId);
                if (feature is not null)
                {
                    spawned.Add(feature);
                }
            }
        }

        return spawned;
    }

    /// <summary>
    /// Spawns a random feature from a difficulty range.
    /// </summary>
    /// <param name="room">The room to spawn in.</param>
    /// <param name="minDC">Minimum difficulty class.</param>
    /// <param name="maxDC">Maximum difficulty class.</param>
    /// <returns>The spawned feature, or null if no matching features exist.</returns>
    public HarvestableFeature? SpawnRandomByDifficulty(Room room, int minDC, int maxDC)
    {
        var candidates = _featureProvider.GetFeaturesByDifficulty(minDC, maxDC);
        if (candidates.Count == 0)
        {
            return null;
        }

        var selected = candidates[_random.Next(candidates.Count)];
        return SpawnFeature(room, selected.FeatureId);
    }
}
```

---

## 9. Configuration Schema

**File:** `config/schemas/harvestable-features.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://runeandrust.game/schemas/harvestable-features.schema.json",
  "title": "Harvestable Features Configuration",
  "description": "Schema for defining harvestable room features in Rune & Rust",
  "type": "object",
  "required": ["harvestableFeatures"],
  "properties": {
    "$schema": {
      "type": "string",
      "description": "Reference to this schema file"
    },
    "harvestableFeatures": {
      "type": "array",
      "description": "List of harvestable feature definitions",
      "items": {
        "$ref": "#/$defs/harvestableFeature"
      },
      "minItems": 1
    }
  },
  "$defs": {
    "harvestableFeature": {
      "type": "object",
      "description": "A single harvestable feature definition",
      "required": ["id", "name", "resourceId", "minQuantity", "maxQuantity", "difficultyClass"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the feature (lowercase, hyphenated)",
          "pattern": "^[a-z][a-z0-9-]*$",
          "examples": ["iron-ore-vein", "herb-patch", "gem-cluster"]
        },
        "name": {
          "type": "string",
          "description": "Display name of the feature",
          "minLength": 1,
          "maxLength": 50
        },
        "description": {
          "type": "string",
          "description": "Detailed description shown when examining",
          "maxLength": 500
        },
        "resourceId": {
          "type": "string",
          "description": "ID of the resource this feature yields",
          "pattern": "^[a-z][a-z0-9-]*$"
        },
        "minQuantity": {
          "type": "integer",
          "description": "Minimum quantity yielded on successful gather",
          "minimum": 0,
          "maximum": 100
        },
        "maxQuantity": {
          "type": "integer",
          "description": "Maximum quantity yielded on successful gather",
          "minimum": 1,
          "maximum": 100
        },
        "difficultyClass": {
          "type": "integer",
          "description": "DC for gathering check (d20 + modifier >= DC)",
          "minimum": 1,
          "maximum": 30
        },
        "requiredTool": {
          "type": ["string", "null"],
          "description": "Optional tool ID required to gather",
          "pattern": "^[a-z][a-z0-9-]*$"
        },
        "replenishTurns": {
          "type": "integer",
          "description": "Turns until replenishment (0 = never replenishes)",
          "minimum": 0,
          "maximum": 10000,
          "default": 0
        },
        "icon": {
          "type": "string",
          "description": "Path to the feature icon",
          "pattern": "^icons/.*\\.(png|jpg|svg)$"
        }
      },
      "additionalProperties": false
    }
  }
}
```

---

## 10. Configuration File

**File:** `config/harvestable-features.json`

```json
{
  "$schema": "./schemas/harvestable-features.schema.json",
  "harvestableFeatures": [
    {
      "id": "iron-ore-vein",
      "name": "Iron Ore Vein",
      "description": "A vein of iron ore embedded in the rock wall",
      "resourceId": "iron-ore",
      "minQuantity": 1,
      "maxQuantity": 5,
      "difficultyClass": 12,
      "requiredTool": null,
      "replenishTurns": 0,
      "icon": "icons/features/ore_vein.png"
    },
    {
      "id": "copper-ore-vein",
      "name": "Copper Ore Vein",
      "description": "A soft copper vein, easy to mine",
      "resourceId": "copper-ore",
      "minQuantity": 2,
      "maxQuantity": 6,
      "difficultyClass": 10,
      "requiredTool": null,
      "replenishTurns": 0
    },
    {
      "id": "gold-ore-vein",
      "name": "Gold Ore Vein",
      "description": "A precious gold vein gleaming in the dark",
      "resourceId": "gold-ore",
      "minQuantity": 1,
      "maxQuantity": 3,
      "difficultyClass": 15,
      "requiredTool": "pickaxe",
      "replenishTurns": 0
    },
    {
      "id": "herb-patch",
      "name": "Herb Patch",
      "description": "A patch of healing herbs growing in the shade",
      "resourceId": "healing-herb",
      "minQuantity": 2,
      "maxQuantity": 6,
      "difficultyClass": 10,
      "requiredTool": null,
      "replenishTurns": 100,
      "icon": "icons/features/herb_patch.png"
    },
    {
      "id": "mana-leaf-cluster",
      "name": "Mana Leaf Cluster",
      "description": "Glowing leaves infused with arcane power",
      "resourceId": "mana-leaf",
      "minQuantity": 1,
      "maxQuantity": 4,
      "difficultyClass": 13,
      "requiredTool": null,
      "replenishTurns": 150
    },
    {
      "id": "leather-source",
      "name": "Fallen Creature",
      "description": "A creature's remains that can be harvested for leather",
      "resourceId": "leather",
      "minQuantity": 1,
      "maxQuantity": 3,
      "difficultyClass": 11,
      "requiredTool": "skinning-knife",
      "replenishTurns": 0
    },
    {
      "id": "gem-cluster",
      "name": "Gem Cluster",
      "description": "Sparkling gems embedded in the rock",
      "resourceId": "ruby",
      "minQuantity": 1,
      "maxQuantity": 2,
      "difficultyClass": 16,
      "requiredTool": "pickaxe",
      "replenishTurns": 0
    },
    {
      "id": "fallen-tree",
      "name": "Fallen Tree",
      "description": "A fallen oak tree that can be harvested for wood",
      "resourceId": "oak-wood",
      "minQuantity": 3,
      "maxQuantity": 8,
      "difficultyClass": 10,
      "requiredTool": "axe",
      "replenishTurns": 0
    }
  ]
}
```

---

## 11. Logging Specifications

### Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `HarvestableFeatureProvider` | Information | Feature loading summary, count |
| `HarvestableFeatureProvider` | Debug | Individual feature loading |
| `HarvestableFeatureProvider` | Warning | Duplicate IDs, invalid entries, missing resources |
| `HarvestableFeatureProvider` | Error | Configuration loading failures |
| `RoomFeatureSpawner` | Debug | Feature spawn events |
| `RoomFeatureSpawner` | Warning | Failed spawn attempts |
| `HarvestableFeature` | Debug | Harvest, replenish events (if logged by caller) |

### Logging Decision Tree

```
HarvestableFeatureProvider.LoadFeatures()
│
├── [INFO] "Loading harvestable feature definitions from configuration"
│
├── For each feature entry:
│   │
│   ├── ID missing or empty?
│   │   └── [WARN] "Feature entry missing ID - skipping"
│   │
│   ├── Resource ID missing?
│   │   └── [WARN] "Feature '{Id}' missing resource ID - skipping"
│   │
│   ├── Resource doesn't exist?
│   │   └── [WARN] "Feature '{Id}' references unknown resource '{ResourceId}' - skipping"
│   │
│   ├── Invalid quantity range?
│   │   └── [WARN] "Feature '{Id}' maxQuantity < minQuantity - skipping"
│   │
│   ├── Invalid DC?
│   │   └── [WARN] "Feature '{Id}' has invalid difficulty class - skipping"
│   │
│   ├── Duplicate ID?
│   │   └── [WARN] "Duplicate feature ID '{FeatureId}' - skipping"
│   │
│   └── Success?
│       └── [DEBUG] "Loaded feature: {FeatureId} -> {ResourceId} (DC: {DC})"
│
├── [INFO] "Loaded {Count} harvestable feature definitions from configuration"
│
└── Exception?
    └── [ERROR] "Failed to load harvestable feature definitions"


RoomFeatureSpawner.SpawnFeature()
│
├── Definition not found?
│   └── [WARN] "Failed to spawn feature '{FeatureId}' in room '{RoomId}': definition not found"
│
└── Success?
    └── [DEBUG] "Spawned feature '{FeatureId}' in room '{RoomId}' with quantity {Quantity}"
```

### Sample Log Output

```
[INF] Loading harvestable feature definitions from configuration
[DBG] Loaded feature: iron-ore-vein -> iron-ore (DC: 12)
[DBG] Loaded feature: copper-ore-vein -> copper-ore (DC: 10)
[DBG] Loaded feature: gold-ore-vein -> gold-ore (DC: 15)
[DBG] Loaded feature: herb-patch -> healing-herb (DC: 10)
[DBG] Loaded feature: mana-leaf-cluster -> mana-leaf (DC: 13)
[DBG] Loaded feature: leather-source -> leather (DC: 11)
[DBG] Loaded feature: gem-cluster -> ruby (DC: 16)
[DBG] Loaded feature: fallen-tree -> oak-wood (DC: 10)
[INF] Loaded 8 harvestable feature definitions from configuration
[DBG] Spawned feature 'iron-ore-vein' in room 'abc123' with quantity 3
[DBG] Spawned feature 'herb-patch' in room 'abc123' with quantity 5
```

---

## 12. Unit Testing Requirements

### Test Count by Feature

| Feature | Test Count | Description |
|---------|------------|-------------|
| HarvestableFeatureDefinition creation | 2 | Valid creation, validation errors |
| HarvestableFeatureDefinition properties | 2 | RequiresTool, Replenishes |
| HarvestableFeature creation | 1 | Create from definition |
| HarvestableFeature.Harvest | 1 | Reduces quantity, depleted state |
| HarvestableFeature replenishment | 2 | SetReplenishTimer, ShouldReplenish, Replenish |
| HarvestableFeatureProvider loading | 1 | Loads from JSON |
| HarvestableFeatureProvider.GetFeature | 1 | Returns definition or null |
| HarvestableFeatureProvider.GetFeaturesByResource | 1 | Filters by resource |
| **Total** | **~8** | |

### Test Specifications

**File:** `tests/RuneAndRust.Domain.Tests/Definitions/HarvestableFeatureDefinitionTests.cs`

```csharp
[TestFixture]
public class HarvestableFeatureDefinitionTests
{
    [Test]
    public void Create_WithValidParameters_ReturnsDefinition()
    {
        // Arrange
        var featureId = "iron-ore-vein";
        var name = "Iron Ore Vein";
        var description = "A vein of iron ore";
        var resourceId = "iron-ore";
        var minQty = 1;
        var maxQty = 5;
        var dc = 12;

        // Act
        var definition = HarvestableFeatureDefinition.Create(
            featureId, name, description, resourceId, minQty, maxQty, dc);

        // Assert
        Assert.That(definition.FeatureId, Is.EqualTo("iron-ore-vein"));
        Assert.That(definition.ResourceId, Is.EqualTo("iron-ore"));
        Assert.That(definition.MinQuantity, Is.EqualTo(1));
        Assert.That(definition.MaxQuantity, Is.EqualTo(5));
        Assert.That(definition.DifficultyClass, Is.EqualTo(12));
        Assert.That(definition.RequiresTool, Is.False);
        Assert.That(definition.Replenishes, Is.False);
    }

    [Test]
    public void Create_WithInvalidQuantityRange_ThrowsArgumentOutOfRangeException()
    {
        // Act & Assert
        Assert.Throws<ArgumentOutOfRangeException>(() =>
            HarvestableFeatureDefinition.Create(
                "test", "Test", "Desc", "resource", 5, 3, 10)); // max < min
    }

    [Test]
    public void RequiresTool_WithToolSet_ReturnsTrue()
    {
        // Arrange
        var definition = HarvestableFeatureDefinition.Create(
            "test", "Test", "Desc", "resource", 1, 5, 10,
            requiredToolId: "pickaxe");

        // Assert
        Assert.That(definition.RequiresTool, Is.True);
        Assert.That(definition.RequiredToolId, Is.EqualTo("pickaxe"));
    }

    [Test]
    public void Replenishes_WithReplenishTurnsSet_ReturnsTrue()
    {
        // Arrange
        var definition = HarvestableFeatureDefinition.Create(
            "test", "Test", "Desc", "resource", 1, 5, 10,
            replenishTurns: 100);

        // Assert
        Assert.That(definition.Replenishes, Is.True);
        Assert.That(definition.ReplenishTurns, Is.EqualTo(100));
    }
}
```

**File:** `tests/RuneAndRust.Domain.Tests/Entities/HarvestableFeatureTests.cs`

```csharp
[TestFixture]
public class HarvestableFeatureTests
{
    private HarvestableFeatureDefinition _definition = null!;

    [SetUp]
    public void SetUp()
    {
        _definition = HarvestableFeatureDefinition.Create(
            "iron-ore-vein", "Iron Ore Vein", "A vein",
            "iron-ore", 1, 5, 12, null, 100);
    }

    [Test]
    public void Create_FromDefinition_SetsPropertiesCorrectly()
    {
        // Act
        var feature = HarvestableFeature.Create(_definition, 5);

        // Assert
        Assert.That(feature.DefinitionId, Is.EqualTo("iron-ore-vein"));
        Assert.That(feature.Name, Is.EqualTo("Iron Ore Vein"));
        Assert.That(feature.RemainingQuantity, Is.EqualTo(5));
        Assert.That(feature.IsDepleted, Is.False);
        Assert.That(feature.InteractionVerb, Is.EqualTo("gather"));
    }

    [Test]
    public void Harvest_ReducesQuantity()
    {
        // Arrange
        var feature = HarvestableFeature.Create(_definition, 5);

        // Act
        feature.Harvest(3);

        // Assert
        Assert.That(feature.RemainingQuantity, Is.EqualTo(2));
        Assert.That(feature.IsDepleted, Is.False);
    }

    [Test]
    public void Harvest_ToZero_SetsDepleted()
    {
        // Arrange
        var feature = HarvestableFeature.Create(_definition, 3);

        // Act
        feature.Harvest(3);

        // Assert
        Assert.That(feature.RemainingQuantity, Is.EqualTo(0));
        Assert.That(feature.IsDepleted, Is.True);
    }

    [Test]
    public void SetReplenishTimer_SetsCorrectTurn()
    {
        // Arrange
        var feature = HarvestableFeature.Create(_definition, 3);
        feature.Harvest(3); // Deplete

        // Act
        feature.SetReplenishTimer(currentTurn: 50, replenishTurns: 100);

        // Assert
        Assert.That(feature.ReplenishAtTurn, Is.EqualTo(150));
        Assert.That(feature.IsAwaitingReplenishment, Is.True);
    }

    [Test]
    public void ShouldReplenish_WhenTurnReached_ReturnsTrue()
    {
        // Arrange
        var feature = HarvestableFeature.Create(_definition, 3);
        feature.Harvest(3);
        feature.SetReplenishTimer(50, 100);

        // Act & Assert
        Assert.That(feature.ShouldReplenish(149), Is.False);
        Assert.That(feature.ShouldReplenish(150), Is.True);
        Assert.That(feature.ShouldReplenish(200), Is.True);
    }

    [Test]
    public void Replenish_RestoresQuantityAndClearsTimer()
    {
        // Arrange
        var feature = HarvestableFeature.Create(_definition, 5);
        feature.Harvest(5);
        feature.SetReplenishTimer(50, 100);

        // Act
        feature.Replenish();

        // Assert
        Assert.That(feature.RemainingQuantity, Is.EqualTo(5));
        Assert.That(feature.IsDepleted, Is.False);
        Assert.That(feature.ReplenishAtTurn, Is.Null);
    }
}
```

**File:** `tests/RuneAndRust.Infrastructure.Tests/Services/HarvestableFeatureProviderTests.cs`

```csharp
[TestFixture]
public class HarvestableFeatureProviderTests
{
    private HarvestableFeatureProvider _provider = null!;
    private Mock<IResourceProvider> _resourceProviderMock = null!;

    [SetUp]
    public void SetUp()
    {
        _resourceProviderMock = new Mock<IResourceProvider>();
        _resourceProviderMock.Setup(r => r.Exists(It.IsAny<string>())).Returns(true);

        var configProvider = new MockConfigurationProvider();
        var logger = new NullLogger<HarvestableFeatureProvider>();

        _provider = new HarvestableFeatureProvider(
            configProvider, _resourceProviderMock.Object, logger);
    }

    [Test]
    public void Constructor_LoadsFeaturesFromConfiguration()
    {
        // Assert
        Assert.That(_provider.Count, Is.GreaterThan(0));
    }

    [Test]
    public void GetFeature_WithExistingId_ReturnsDefinition()
    {
        // Act
        var feature = _provider.GetFeature("iron-ore-vein");

        // Assert
        Assert.That(feature, Is.Not.Null);
        Assert.That(feature!.Name, Is.EqualTo("Iron Ore Vein"));
        Assert.That(feature.ResourceId, Is.EqualTo("iron-ore"));
    }

    [Test]
    public void GetFeature_WithNonExistingId_ReturnsNull()
    {
        // Act
        var feature = _provider.GetFeature("nonexistent");

        // Assert
        Assert.That(feature, Is.Null);
    }

    [Test]
    public void GetFeaturesByResource_ReturnsMatchingFeatures()
    {
        // Act
        var features = _provider.GetFeaturesByResource("iron-ore");

        // Assert
        Assert.That(features, Is.Not.Empty);
        Assert.That(features.All(f => f.ResourceId == "iron-ore"), Is.True);
    }

    [Test]
    public void CreateFeatureInstance_ReturnsNewInstance()
    {
        // Act
        var instance = _provider.CreateFeatureInstance("iron-ore-vein");

        // Assert
        Assert.That(instance, Is.Not.Null);
        Assert.That(instance!.DefinitionId, Is.EqualTo("iron-ore-vein"));
        Assert.That(instance.RemainingQuantity, Is.InRange(1, 5));
    }
}
```

---

## 13. Use Cases

### UC-001: Load Harvestable Feature Definitions

**Actor:** System (on startup)
**Flow:** Application starts → ConfigurationProvider loads harvestable-features.json → HarvestableFeatureProvider parses and validates entries → Resource references validated → Features cached → Application ready

```
┌─────────────────────────────────────────────────────────────────────────┐
│             UC-001: LOAD HARVESTABLE FEATURE DEFINITIONS                │
└─────────────────────────────────────────────────────────────────────────┘

    Application Startup
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 1. DI Container resolves             │
    │    IHarvestableFeatureProvider       │
    └──────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 2. Provider constructor calls        │
    │    LoadFeatures()                    │
    └──────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 3. Load harvestable-features.json    │
    └──────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 4. For each entry:                   │
    │    - Validate required fields        │
    │    - Validate resource ID exists     │
    │    - Create definition               │
    └──────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 5. Cache in dictionary               │
    └──────────────────────────────────────┘
           │
           ▼
    Features Available for Room Spawning
```

### UC-002: Spawn Feature in Room

**Actor:** Room Generator / Level Builder
**Flow:** Generate room → Select features to spawn → Create feature instances → Add to room features list

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    UC-002: SPAWN FEATURE IN ROOM                        │
└─────────────────────────────────────────────────────────────────────────┘

    Room Generation
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 1. RoomFeatureSpawner.SpawnFeature() │
    │    featureId: "iron-ore-vein"        │
    └──────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 2. Get definition from provider      │
    └──────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 3. Roll random quantity (1-5)        │
    │    Result: 3                         │
    └──────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 4. Create HarvestableFeature         │
    │    RemainingQuantity: 3              │
    └──────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────┐
    │ 5. Add to room.Features              │
    └──────────────────────────────────────┘
           │
           ▼
    Feature Ready for Player Interaction
```

### UC-003: Process Feature Replenishment

**Actor:** Turn Manager (System)
**Flow:** Turn ends → For each room → Check features for replenishment → Replenish if timer reached

### UC-004: Get Available Features in Room

**Actor:** GatheringService (v0.11.0c)
**Flow:** Player enters gather command → Get room features → Filter to non-depleted HarvestableFeature instances → Return list

### UC-005: Harvest from Feature (Preview for v0.11.0c)

**Actor:** Player (via GatheringService)
**Flow:** Player gathers → Reduce RemainingQuantity → If depleted and replenishes → Set replenish timer

---

## 14. Deliverable Checklist

### Domain Layer

- [ ] `HarvestableFeatureDefinition` entity with all properties
- [ ] `HarvestableFeatureDefinition.Create()` with validation
- [ ] `HarvestableFeatureDefinition.RequiresTool` property
- [ ] `HarvestableFeatureDefinition.Replenishes` property
- [ ] `HarvestableFeature` entity extending RoomFeature
- [ ] `HarvestableFeature.Create()` and `CreateWithRandomQuantity()`
- [ ] `HarvestableFeature.Harvest()` method
- [ ] `HarvestableFeature.SetReplenishTimer()` method
- [ ] `HarvestableFeature.Replenish()` method
- [ ] `HarvestableFeature.ShouldReplenish()` method
- [ ] `HarvestableFeature.IsDepleted` property

### Application Layer

- [ ] `IHarvestableFeatureProvider` interface with all methods
- [ ] `RoomFeatureSpawner` helper class

### Infrastructure Layer

- [ ] `HarvestableFeatureProvider` implementation
- [ ] `HarvestableFeaturesJson` internal model
- [ ] `HarvestableFeatureJsonEntry` internal model
- [ ] Resource ID validation during load

### Room Integration

- [ ] `Room.GetHarvestableFeatures()` method
- [ ] `Room.GetAvailableHarvestableFeatures()` method
- [ ] `Room.AddHarvestableFeature()` method
- [ ] `Room.ProcessFeatureReplenishment()` method

### Configuration

- [ ] `config/harvestable-features.json` with 8 features
- [ ] `config/schemas/harvestable-features.schema.json`

### Testing

- [ ] `HarvestableFeatureDefinitionTests.cs` (~4 tests)
- [ ] `HarvestableFeatureTests.cs` (~6 tests)
- [ ] `HarvestableFeatureProviderTests.cs` (~5 tests)
- [ ] All tests passing

### Documentation

- [ ] XML documentation on all public members
- [ ] Code examples in XML docs

---

## 15. Acceptance Criteria

### Functional

- [ ] HarvestableFeatureDefinition.Create validates all parameters
- [ ] HarvestableFeatureDefinition.Create lowercases featureId and resourceId
- [ ] HarvestableFeatureDefinition.RequiresTool returns true when tool set
- [ ] HarvestableFeatureDefinition.Replenishes returns true when replenishTurns > 0
- [ ] HarvestableFeature.Create sets all properties from definition
- [ ] HarvestableFeature.CreateWithRandomQuantity generates valid quantity
- [ ] HarvestableFeature.Harvest reduces RemainingQuantity
- [ ] HarvestableFeature.Harvest cannot reduce below 0
- [ ] HarvestableFeature.IsDepleted returns true when quantity is 0
- [ ] HarvestableFeature.SetReplenishTimer calculates correct turn
- [ ] HarvestableFeature.ShouldReplenish returns true at or after target turn
- [ ] HarvestableFeature.Replenish restores quantity and clears timer
- [ ] HarvestableFeatureProvider loads all 8 features from JSON
- [ ] HarvestableFeatureProvider validates resource references exist
- [ ] HarvestableFeatureProvider.GetFeature returns definition by ID
- [ ] HarvestableFeatureProvider.GetFeaturesByResource filters correctly
- [ ] Room.GetHarvestableFeatures returns correct feature type
- [ ] Room.ProcessFeatureReplenishment replenishes ready features

### Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~8 unit tests pass
- [ ] Configuration validates against schema
- [ ] XML documentation complete on all public members
- [ ] All resource references in config are valid
- [ ] No duplicate feature IDs in configuration

---

## 16. Dependencies

### Required From v0.11.0a

| Type | Location | Usage |
|------|----------|-------|
| `ResourceDefinition` | `Domain/Definitions/ResourceDefinition.cs` | Reference validation |
| `IResourceProvider` | `Application/Interfaces/IResourceProvider.cs` | Resource ID validation |
| `ResourceCategory` | `Domain/Enums/ResourceCategory.cs` | Resource categorization |
| `ResourceQuality` | `Domain/Enums/ResourceQuality.cs` | Quality determination |

### Required From Prior Versions

| Type | Location | Usage |
|------|----------|-------|
| `IEntity` | `Domain/Interfaces/IEntity.cs` | Base interface |
| `RoomFeature` | `Domain/Entities/RoomFeature.cs` | Base class for HarvestableFeature |
| `Room` | `Domain/Entities/Room.cs` | Feature container |
| `IConfigurationProvider` | `Application/Interfaces/IConfigurationProvider.cs` | JSON loading |
| `ILogger<T>` | Microsoft.Extensions.Logging | Logging |

### Provides To v0.11.0c

| Type | Usage |
|------|-------|
| `HarvestableFeatureDefinition` | GatheringService reads DC, resource, quantity |
| `HarvestableFeature` | GatheringService harvests from, depletes |
| `IHarvestableFeatureProvider` | GatheringService retrieves definitions |
| `Room.GetHarvestableFeatures()` | GatheringService lists available features |

---

## 17. Future Considerations

### Deferred to v0.11.0c (Gathering Service)

- **Dice Check Mechanics**: Rolling against DC
- **Tool Requirement Enforcement**: Checking player inventory
- **Quantity Roll**: Determining actual yield
- **Inventory Addition**: Adding gathered resources

### Deferred to v0.11.1+ (Crafting)

- **Feature-Recipe Integration**: Features tied to crafting recipes
- **Refined Materials**: Processing raw resources

### Deferred to v0.13.x (UI Consolidation)

- **Feature Icons**: Visual display in room view
- **Depletion Indicators**: UI showing feature state
- **Replenishment Timers**: Countdown display

### Out of Scope

- **Feature Rarity**: Different spawn weights (could be added to config later)
- **Dynamic Feature Generation**: Procedurally generated features
- **Feature Damage/Destruction**: Permanent removal of features

---

## Harvestable Feature Summary Table

| Feature ID | Resource | DC | Quantity | Tool | Replenish |
|------------|----------|---:|----------|------|----------:|
| `iron-ore-vein` | iron-ore | 12 | 1-5 | - | Never |
| `copper-ore-vein` | copper-ore | 10 | 2-6 | - | Never |
| `gold-ore-vein` | gold-ore | 15 | 1-3 | pickaxe | Never |
| `herb-patch` | healing-herb | 10 | 2-6 | - | 100 turns |
| `mana-leaf-cluster` | mana-leaf | 13 | 1-4 | - | 150 turns |
| `leather-source` | leather | 11 | 1-3 | skinning-knife | Never |
| `gem-cluster` | ruby | 16 | 1-2 | pickaxe | Never |
| `fallen-tree` | oak-wood | 10 | 3-8 | axe | Never |

---

*Document Version: 1.0*
*Last Updated: 2026-01-16*
*Author: Claude (AI Assistant)*
