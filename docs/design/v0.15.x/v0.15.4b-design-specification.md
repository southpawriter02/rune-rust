# v0.15.4b Design Specification: Terminal Hacking System

**Version:** 0.15.4b
**Theme:** Terminal Hacking System (Multi-Layer Infiltration)
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0 Complete (Dice Pool Refactor), v0.15.1 Complete (Skill Infrastructure), v0.15.4a Complete (Lockpicking System)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [TerminalType Enum](#4-terminaltype-enum)
5. [InfiltrationLayer Enum](#5-infiltrationlayer-enum)
6. [AccessLevel Enum](#6-accesslevel-enum)
7. [TerminalInfiltrationState Entity](#7-terminalinfiltrationstate-entity)
8. [LayerResult Value Object](#8-layerresult-value-object)
9. [TerminalContext Value Object](#9-terminalcontext-value-object)
10. [TerminalHackingService](#10-terminalhackingservice-implementation)
11. [Data Model Changes](#11-data-model-changes)
12. [Configuration Files](#12-configuration-files)
13. [Logging Specifications](#13-logging-specifications)
14. [Unit Testing Requirements](#14-unit-testing-requirements)
15. [Use Cases](#15-use-cases)
16. [Deliverable Checklist](#16-deliverable-checklist)
17. [Acceptance Criteria](#17-acceptance-criteria)
18. [Dependencies](#18-dependencies)
19. [Future Considerations](#19-future-considerations)
20. [Document Metadata](#20-document-metadata)

---

## 1. Executive Summary

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.4b, the Terminal Hacking System. This phase implements the multi-layer terminal infiltration mechanics for the System Bypass skill, enabling characters to hack into various terminal types through a three-layer process.

Terminal hacking in Aethelgard follows the "cargo cult" approach to Old World technology—characters manipulate incomprehensible systems through learned patterns and observed behaviors rather than true understanding. The system supports:

1. **Terminal Classification**: Six terminal types from Civilian Data Port (DC 8) to Glitched Manifold (DC varies)
2. **Multi-Layer Infiltration**: Three sequential layers (Access → Authentication → Navigation)
3. **ICE Countermeasures**: Passive, Active, and Lethal ICE (detailed implementation in v0.15.4c)
4. **Access Level Progression**: None → UserLevel → AdminLevel, with Lockout as failure state
5. **Fumble Consequence**: [System Lockout] permanently disables terminal and broadcasts alert

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Enums** | `TerminalType`, `InfiltrationLayer`, `AccessLevel`, `InfiltrationStatus` |
| **Value Objects** | `TerminalContext`, `LayerResult` |
| **Entities** | `TerminalInfiltrationState` |
| **Services** | `ITerminalHackingService`, `TerminalHackingService` |
| **Configuration** | `terminal-types.json` |
| **Tests** | ~4 new unit tests |

### 1.3 Architectural Significance

This version establishes the **multi-layer state machine pattern** for complex bypass procedures:

- **State tracking**: `TerminalInfiltrationState` maintains infiltration progress across layers
- **Layer-specific outcomes**: Each layer has distinct success/failure consequences
- **ICE integration points**: Hooks for v0.15.4c ICE countermeasures
- **Access escalation**: Progressive access level improvements through the layers

---

## 2. Feature Overview

```
v0.15.4b Terminal Hacking System
├── Terminal Classification
│   ├── TerminalType enum (6 types with base DCs)
│   ├── ICE ratings by terminal type
│   └── Security level modifiers
├── Multi-Layer Infiltration
│   ├── Layer 1: Access (Initial connection)
│   ├── Layer 2: Authentication (Identity verification)
│   └── Layer 3: Navigation (Data location)
├── State Management
│   ├── TerminalInfiltrationState entity
│   ├── Layer progression tracking
│   └── Alert level accumulation
├── Access Levels
│   ├── None (Access denied)
│   ├── UserLevel (Basic functions)
│   ├── AdminLevel (Full access)
│   └── Lockout (Terminal disabled)
├── Layer Outcomes
│   ├── Success (Proceed to next layer)
│   ├── Critical Success (Gain AdminLevel)
│   ├── Failure (Lockout/Alert/Partial)
│   └── Fumble ([System Lockout])
└── Track Covering
    ├── Optional stealth check (DC 14)
    └── Log manipulation
```

---

## 3. Architecture Diagrams

### 3.1 Multi-Layer Infiltration Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    TERMINAL HACKING INFILTRATION FLOW                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Player: "hack terminal" on terminal object                                 │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    1. CREATE INFILTRATION STATE                      │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  TerminalInfiltrationState                                          │    │
│  │  ├── InfiltrationId: "inf-001"                                      │    │
│  │  ├── CharacterId: "player-1"                                        │    │
│  │  ├── TerminalType: CorporateMainframe                               │    │
│  │  ├── CurrentLayer: 1 (Access)                                       │    │
│  │  ├── LayerResults: []                                               │    │
│  │  ├── AccessLevel: None                                              │    │
│  │  ├── AlertLevel: 0                                                  │    │
│  │  ├── IsLockedOut: false                                             │    │
│  │  └── Status: InProgress                                             │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    2. LAYER 1: ACCESS                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Purpose: Bypass initial security and establish connection          │    │
│  │  DC: Based on terminal type (12-18)                                 │    │
│  │  Time: 1-5 rounds based on encryption                               │    │
│  │                                                                      │    │
│  │  Outcomes:                                                           │    │
│  │  ├── Success: Proceed to Layer 2                                    │    │
│  │  ├── Critical: Proceed to Layer 2 + AdminLevel granted              │    │
│  │  ├── Failure: 1 minute lockout, retry at DC +2                      │    │
│  │  └── Fumble: [System Lockout] - terminal disabled                   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │ (on success)                                                     │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    3. LAYER 2: AUTHENTICATION                        │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Purpose: Bypass identity verification systems                      │    │
│  │  DC: Layer 1 DC + Security Modifier (0 to +6)                       │    │
│  │                                                                      │    │
│  │  Security Modifiers:                                                 │    │
│  │  ├── Password only: +0                                              │    │
│  │  ├── Biometric: +2                                                  │    │
│  │  ├── Multi-factor: +4                                               │    │
│  │  └── Jötun-Locked: +6                                               │    │
│  │                                                                      │    │
│  │  Outcomes:                                                           │    │
│  │  ├── Success: UserLevel access, proceed to Layer 3                  │    │
│  │  ├── Critical: AdminLevel access, proceed to Layer 3                │    │
│  │  ├── Failure: Alert triggers, ICE may activate (v0.15.4c)           │    │
│  │  └── Fumble: [System Lockout] + alert broadcast                     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │ (on success)                                                     │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    4. LAYER 3: NAVIGATION                            │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Purpose: Locate and access specific data                           │    │
│  │  DC: Based on data type (10-22)                                     │    │
│  │                                                                      │    │
│  │  Data Type DCs:                                                      │    │
│  │  ├── Public records: DC 10                                          │    │
│  │  ├── Internal docs: DC 14                                           │    │
│  │  ├── Classified: DC 18                                              │    │
│  │  └── Archived/Hidden: DC 22                                         │    │
│  │                                                                      │    │
│  │  Outcomes:                                                           │    │
│  │  ├── Success: Full data access                                      │    │
│  │  ├── Critical: Full access + hidden data revealed                   │    │
│  │  ├── Failure: Partial access only                                   │    │
│  │  └── Fumble: [System Lockout] + data corrupted                      │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │ (on success)                                                     │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    5. COVER TRACKS (OPTIONAL)                        │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Purpose: Wipe evidence of intrusion                                │    │
│  │  DC: 14 (Stealth check)                                             │    │
│  │                                                                      │    │
│  │  Outcomes:                                                           │    │
│  │  ├── Success: Access logs wiped                                     │    │
│  │  └── Failure: Access logged permanently                             │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 System Lockout Fumble Consequence Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    [SYSTEM LOCKOUT] FUMBLE CONSEQUENCE                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  FUMBLE DETECTED: 0 successes, 1+ botch on any layer check                 │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    CREATE FUMBLE CONSEQUENCE                         │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  FumbleConsequence                                                  │    │
│  │  ├── ConsequenceId: "fc-terminal-001"                               │    │
│  │  ├── CharacterId: "player-1"                                        │    │
│  │  ├── SkillId: "system-bypass"                                       │    │
│  │  ├── ConsequenceType: SystemLockout                                 │    │
│  │  ├── TargetId: "terminal-mainframe-3"                               │    │
│  │  ├── IsActive: true                                                 │    │
│  │  ├── Duration: Permanent (for this terminal)                        │    │
│  │  └── Effects:                                                        │    │
│  │      ├── Terminal permanently disabled                              │    │
│  │      └── Security alert broadcast to nearby systems                 │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    UPDATE TERMINAL STATE                             │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  infiltrationState.MarkAsLockedOut()                                │    │
│  │                                                                      │    │
│  │  Terminal Entity:                                                   │    │
│  │  ├── Status: Disabled                                               │    │
│  │  ├── AccessLevel: Lockout                                           │    │
│  │  └── CannotBeReused: true                                           │    │
│  │                                                                      │    │
│  │  Security Alert:                                                    │    │
│  │  ├── AlertRadius: 50 feet                                           │    │
│  │  ├── AlertType: IntrusionDetected                                   │    │
│  │  └── IncludesLocation: true (if ICE was Passive/Trace)              │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    DISPLAY NARRATIVE                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  "The terminal emits a harsh klaxon as error codes cascade across   │    │
│  │   the display. Ancient security protocols engage—the screen flashes │    │
│  │   red, then goes dark. A final message burns into the display:      │    │
│  │   'INTRUSION DETECTED - SYSTEM DISABLED'. The alert echoes through  │    │
│  │   nearby corridors."                                                 │    │
│  │                                                                      │    │
│  │   [System Lockout - Terminal permanently disabled, alert broadcast] │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  RECOVERY OPTIONS:                                                          │
│  ├── None - terminal is permanently disabled                               │
│  ├── Find alternate terminal                                               │
│  └── Escape before security responds to alert                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Enums/                                                              │    │
│  │  ├── TerminalType.cs          ←── NEW (terminal classification)     │    │
│  │  ├── InfiltrationLayer.cs     ←── NEW (layer progression)           │    │
│  │  ├── AccessLevel.cs           ←── NEW (access state)                │    │
│  │  └── InfiltrationStatus.cs    ←── NEW (overall status)              │    │
│  │                                                                      │    │
│  │  Entities/                                                           │    │
│  │  └── TerminalInfiltrationState.cs ←── NEW (state machine)           │    │
│  │                                                                      │    │
│  │  ValueObjects/                                                       │    │
│  │  ├── TerminalContext.cs       ←── NEW (terminal-specific context)   │    │
│  │  └── LayerResult.cs           ←── NEW (layer attempt result)        │    │
│  │                                                                      │    │
│  │  Interfaces/                                                         │    │
│  │  └── ITerminalHackingService.cs ←── NEW (service interface)         │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ implements                                │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Services/                                                           │    │
│  │  └── TerminalHackingService.cs ←── NEW (infiltration mechanics)     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  EXISTING DEPENDENCIES                               │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  From v0.15.0:                                                       │    │
│  │  ├── DiceRollResult          (success counting)                     │    │
│  │  ├── DiceService             (dice rolling)                         │    │
│  │  └── DiceConstants           (thresholds)                           │    │
│  │                                                                      │    │
│  │  From v0.15.1:                                                       │    │
│  │  ├── SkillContext            (modifier aggregation)                 │    │
│  │  ├── SkillContextBuilder     (context construction)                 │    │
│  │  ├── SkillCheckService       (check execution)                      │    │
│  │  ├── FumbleConsequence       (fumble tracking)                      │    │
│  │  └── FumbleConsequenceService (consequence management)              │    │
│  │                                                                      │    │
│  │  From v0.15.4a:                                                      │    │
│  │  └── ToolQuality             (tool modifier pattern)                │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. TerminalType Enum

### 4.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/TerminalType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Classification of terminal types with associated base difficulty classes and ICE ratings.
/// </summary>
/// <remarks>
/// <para>
/// Terminal difficulty follows a progression from civilian data ports found in
/// everyday use to legendary Jötun Archives of incomprehensible complexity.
/// </para>
/// <para>
/// Base DCs represent the Layer 1 (Access) difficulty. Subsequent layers may
/// have modified DCs based on security level and data type.
/// </para>
/// <para>
/// ICE (Intrusion Countermeasures Electronics) ratings indicate the type and
/// danger level of defensive systems present. ICE mechanics are detailed in v0.15.4c.
/// </para>
/// </remarks>
public enum TerminalType
{
    /// <summary>
    /// Civilian data port for everyday use.
    /// </summary>
    /// <remarks>
    /// Found in residential areas, public spaces, and merchant stalls.
    /// Minimal security, no ICE countermeasures.
    /// Base DC: 8 (Layer 1 Access).
    /// ICE Rating: None.
    /// </remarks>
    CivilianDataPort = 8,

    /// <summary>
    /// Corporate mainframe with standard business security.
    /// </summary>
    /// <remarks>
    /// Found in corporate offices, trade companies, and guild halls.
    /// Standard security with passive trace countermeasures.
    /// Base DC: 12 (Layer 1 Access).
    /// ICE Rating: Passive (Trace).
    /// </remarks>
    CorporateMainframe = 12,

    /// <summary>
    /// Security hub with active defense systems.
    /// </summary>
    /// <remarks>
    /// Found in security stations, watch posts, and enforcement facilities.
    /// Enhanced security with active countermeasures.
    /// Base DC: 16 (Layer 1 Access).
    /// ICE Rating: Active (Attack).
    /// </remarks>
    SecurityHub = 16,

    /// <summary>
    /// Military server with hardened defenses.
    /// </summary>
    /// <remarks>
    /// Found in military installations, armories, and command centers.
    /// Heavy security with aggressive countermeasures.
    /// Base DC: 20 (Layer 1 Access).
    /// ICE Rating: Active (Attack) + Lethal backup.
    /// </remarks>
    MilitaryServer = 20,

    /// <summary>
    /// Ancient Jötun Archive of Old World origin.
    /// </summary>
    /// <remarks>
    /// Found in ruins, ancient facilities, and excavation sites.
    /// Incomprehensible security from the World Before.
    /// Often [Glitched] or [Blighted], adding corruption modifiers.
    /// Base DC: 24 (Layer 1 Access).
    /// ICE Rating: Lethal (Neural).
    /// </remarks>
    JotunArchive = 24,

    /// <summary>
    /// Glitched Manifold with unpredictable behavior.
    /// </summary>
    /// <remarks>
    /// Corrupted terminals where reality itself is unstable.
    /// DC varies based on glitch cycle phase (determined at encounter).
    /// May provide unexpected benefits or catastrophic failures.
    /// Base DC: 0 (determined dynamically, typically 12-20).
    /// ICE Rating: Unpredictable.
    /// </remarks>
    GlitchedManifold = 0
}
```

### 4.2 Terminal Type Summary Table

| Terminal Type | Base DC | Layer 1 Time | ICE Rating | Typical Location |
|---------------|---------|--------------|------------|------------------|
| Civilian Data Port | 8 | 1 round | None | Public areas, residences |
| Corporate Mainframe | 12 | 1 round | Passive (Trace) | Offices, guild halls |
| Security Hub | 16 | 2 rounds | Active (Attack) | Security stations |
| Military Server | 20 | 3 rounds | Active + Lethal | Military installations |
| Jötun Archive | 24 | 5 rounds | Lethal (Neural) | Ancient ruins |
| Glitched Manifold | varies | varies | Unpredictable | Corrupted zones |

---

## 5. InfiltrationLayer Enum

### 5.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/InfiltrationLayer.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Layers of terminal infiltration representing progressive security barriers.
/// </summary>
/// <remarks>
/// <para>
/// Terminal hacking proceeds through three sequential layers, each with
/// distinct challenges and consequences:
/// <list type="bullet">
///   <item><description>Layer 1 (Access): Bypass initial security and establish connection</description></item>
///   <item><description>Layer 2 (Authentication): Verify identity or spoof credentials</description></item>
///   <item><description>Layer 3 (Navigation): Locate and access desired data</description></item>
/// </list>
/// </para>
/// <para>
/// Failure at any layer has escalating consequences, from temporary lockouts
/// to permanent terminal disabling. Success at each layer grants progressively
/// greater access.
/// </para>
/// </remarks>
public enum InfiltrationLayer
{
    /// <summary>
    /// Initial connection and security bypass.
    /// </summary>
    /// <remarks>
    /// The first barrier—establishing a connection to the terminal's
    /// internal systems. Requires bypassing firewall equivalents and
    /// connection protocols.
    /// DC: Based on terminal type.
    /// Time: 1-5 rounds based on encryption level.
    /// Failure: 1 minute lockout, retry at DC +2.
    /// </remarks>
    Layer1_Access = 1,

    /// <summary>
    /// Identity verification bypass.
    /// </summary>
    /// <remarks>
    /// The second barrier—convincing the system you are authorized.
    /// May involve password cracking, biometric spoofing, or
    /// credential forgery.
    /// DC: Layer 1 DC + security modifier (0 to +6).
    /// Failure: Alert triggers, ICE may activate.
    /// </remarks>
    Layer2_Authentication = 2,

    /// <summary>
    /// Data location and access.
    /// </summary>
    /// <remarks>
    /// The final barrier—finding the specific data you need within
    /// the system's architecture. More sensitive data requires
    /// deeper navigation.
    /// DC: Based on data type (10-22).
    /// Failure: Partial access only.
    /// </remarks>
    Layer3_Navigation = 3
}
```

### 5.2 Layer DC Summary Table

| Layer | DC Determination | Time | Failure Consequence |
|-------|------------------|------|---------------------|
| Layer 1: Access | Terminal type base DC | 1-5 rounds | 1 min lockout, DC +2 retry |
| Layer 2: Authentication | Layer 1 DC + security modifier | 1 round | Alert, ICE activation |
| Layer 3: Navigation | Data type DC (10-22) | 1 round | Partial access only |

---

## 6. AccessLevel Enum

### 6.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/AccessLevel.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Levels of access achieved during terminal infiltration.
/// </summary>
/// <remarks>
/// <para>
/// Access levels represent the depth of control a hacker has achieved
/// over the target terminal. Higher levels grant access to more sensitive
/// functions and data.
/// </para>
/// <para>
/// Access progression:
/// <list type="bullet">
///   <item><description>None → UserLevel: Achieved by passing Layer 2</description></item>
///   <item><description>UserLevel → AdminLevel: Achieved by critical success on Layer 2, or Jötun-Reader ability</description></item>
///   <item><description>Any → Lockout: Caused by fumble at any layer</description></item>
/// </list>
/// </para>
/// </remarks>
public enum AccessLevel
{
    /// <summary>
    /// No access to the terminal.
    /// </summary>
    /// <remarks>
    /// Initial state before infiltration begins, or after being
    /// disconnected by ICE or other security measures.
    /// </remarks>
    None = 0,

    /// <summary>
    /// Basic user-level access.
    /// </summary>
    /// <remarks>
    /// Standard access level achieved by completing Layer 2 normally.
    /// Grants access to:
    /// <list type="bullet">
    ///   <item><description>Public records and basic functions</description></item>
    ///   <item><description>Internal documents (with Layer 3 check)</description></item>
    ///   <item><description>Standard user operations</description></item>
    /// </list>
    /// Does NOT grant access to:
    /// <list type="bullet">
    ///   <item><description>Hidden files or archived data</description></item>
    ///   <item><description>Administrative functions</description></item>
    ///   <item><description>Security logs or system controls</description></item>
    /// </list>
    /// </remarks>
    UserLevel = 1,

    /// <summary>
    /// Full administrative access.
    /// </summary>
    /// <remarks>
    /// Elevated access achieved by critical success on Layer 2, or by
    /// certain specialization abilities (Jötun-Reader [Deep Access]).
    /// Grants access to:
    /// <list type="bullet">
    ///   <item><description>All user-level data and functions</description></item>
    ///   <item><description>Hidden files and archived data</description></item>
    ///   <item><description>Security logs and audit trails</description></item>
    ///   <item><description>System configuration and controls</description></item>
    /// </list>
    /// </remarks>
    AdminLevel = 2,

    /// <summary>
    /// Terminal permanently locked out.
    /// </summary>
    /// <remarks>
    /// Terminal state caused by fumble at any layer. The terminal
    /// is disabled and cannot be used again by anyone.
    /// Additionally triggers a security alert broadcast.
    /// </remarks>
    Lockout = -1
}
```

---

## 7. TerminalInfiltrationState Entity

### 7.1 Entity Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/TerminalInfiltrationState.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Tracks the state of a multi-layer terminal infiltration attempt.
/// </summary>
/// <remarks>
/// <para>
/// Maintains the progression of a hacking attempt across all three layers,
/// tracking results, access level achieved, alert status, and overall outcome.
/// </para>
/// <para>
/// Infiltration follows a state machine pattern:
/// <code>
/// Created → Layer1 → Layer2 → Layer3 → Completed
///                ↓        ↓        ↓
///              Failed   Failed   Failed
///                ↓        ↓        ↓
///              Locked  Locked   Locked (fumble only)
/// </code>
/// </para>
/// </remarks>
public class TerminalInfiltrationState
{
    /// <summary>
    /// Unique identifier for this infiltration attempt.
    /// </summary>
    public string InfiltrationId { get; private set; } = string.Empty;

    /// <summary>
    /// The character attempting the infiltration.
    /// </summary>
    public string CharacterId { get; private set; } = string.Empty;

    /// <summary>
    /// The type of terminal being hacked.
    /// </summary>
    public TerminalType TerminalType { get; private set; }

    /// <summary>
    /// Unique identifier of the terminal entity.
    /// </summary>
    public string TerminalId { get; private set; } = string.Empty;

    /// <summary>
    /// The current layer being attempted (1-3).
    /// </summary>
    public int CurrentLayer { get; private set; }

    /// <summary>
    /// Results of each layer attempt.
    /// </summary>
    public IReadOnlyList<LayerResult> LayerResults => _layerResults.AsReadOnly();
    private readonly List<LayerResult> _layerResults = new();

    /// <summary>
    /// Current access level achieved.
    /// </summary>
    public AccessLevel AccessLevel { get; private set; }

    /// <summary>
    /// Accumulated alert level (affects security response).
    /// </summary>
    /// <remarks>
    /// Alert level increases on failed checks and certain outcomes.
    /// Higher alert levels may trigger faster security response or
    /// more aggressive ICE behavior.
    /// </remarks>
    public int AlertLevel { get; private set; }

    /// <summary>
    /// Whether the terminal has been locked out (fumble).
    /// </summary>
    public bool IsLockedOut { get; private set; }

    /// <summary>
    /// Overall status of the infiltration attempt.
    /// </summary>
    public InfiltrationStatus Status { get; private set; }

    /// <summary>
    /// Whether tracks have been covered (logs wiped).
    /// </summary>
    public bool TracksCovered { get; private set; }

    /// <summary>
    /// The current layer enum value.
    /// </summary>
    public InfiltrationLayer CurrentLayerEnum => CurrentLayer switch
    {
        1 => InfiltrationLayer.Layer1_Access,
        2 => InfiltrationLayer.Layer2_Authentication,
        3 => InfiltrationLayer.Layer3_Navigation,
        _ => InfiltrationLayer.Layer1_Access
    };

    /// <summary>
    /// Whether the infiltration is complete (success or failure).
    /// </summary>
    public bool IsComplete => Status is InfiltrationStatus.Completed
        or InfiltrationStatus.LockedOut
        or InfiltrationStatus.Disconnected;

    /// <summary>
    /// Whether the infiltration was successful.
    /// </summary>
    public bool IsSuccessful => Status == InfiltrationStatus.Completed
        && AccessLevel >= AccessLevel.UserLevel;

    /// <summary>
    /// Whether admin access was achieved.
    /// </summary>
    public bool HasAdminAccess => AccessLevel == AccessLevel.AdminLevel;

    // Private constructor for EF Core
    private TerminalInfiltrationState() { }

    /// <summary>
    /// Creates a new infiltration state for a terminal hacking attempt.
    /// </summary>
    /// <param name="infiltrationId">Unique identifier for this attempt.</param>
    /// <param name="characterId">The character attempting the hack.</param>
    /// <param name="terminalType">The type of terminal being hacked.</param>
    /// <param name="terminalId">The terminal entity identifier.</param>
    /// <returns>A new TerminalInfiltrationState in initial state.</returns>
    public static TerminalInfiltrationState Create(
        string infiltrationId,
        string characterId,
        TerminalType terminalType,
        string terminalId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(infiltrationId);
        ArgumentException.ThrowIfNullOrWhiteSpace(characterId);
        ArgumentException.ThrowIfNullOrWhiteSpace(terminalId);

        return new TerminalInfiltrationState
        {
            InfiltrationId = infiltrationId,
            CharacterId = characterId,
            TerminalType = terminalType,
            TerminalId = terminalId,
            CurrentLayer = 1,
            AccessLevel = AccessLevel.None,
            AlertLevel = 0,
            IsLockedOut = false,
            Status = InfiltrationStatus.InProgress,
            TracksCovered = false
        };
    }

    /// <summary>
    /// Records a layer result and advances the state machine.
    /// </summary>
    /// <param name="result">The result of the layer attempt.</param>
    /// <exception cref="InvalidOperationException">If infiltration is already complete.</exception>
    public void RecordLayerResult(LayerResult result)
    {
        if (IsComplete)
        {
            throw new InvalidOperationException("Cannot record result for completed infiltration.");
        }

        if (result.Layer != CurrentLayerEnum)
        {
            throw new InvalidOperationException(
                $"Expected result for {CurrentLayerEnum}, got {result.Layer}.");
        }

        _layerResults.Add(result);

        // Process result based on outcome
        if (result.IsFumble)
        {
            ProcessFumble();
        }
        else if (result.IsSuccess)
        {
            ProcessSuccess(result);
        }
        else
        {
            ProcessFailure(result);
        }
    }

    /// <summary>
    /// Marks tracks as covered after a successful stealth check.
    /// </summary>
    public void MarkTracksCovered()
    {
        if (!IsSuccessful)
        {
            throw new InvalidOperationException("Can only cover tracks after successful infiltration.");
        }

        TracksCovered = true;
    }

    /// <summary>
    /// Marks the infiltration as disconnected (voluntary or ICE).
    /// </summary>
    public void MarkDisconnected()
    {
        if (Status == InfiltrationStatus.LockedOut)
        {
            return; // Already in terminal state
        }

        Status = InfiltrationStatus.Disconnected;
    }

    /// <summary>
    /// Increases the alert level by the specified amount.
    /// </summary>
    /// <param name="amount">The amount to increase (default 1).</param>
    public void IncreaseAlertLevel(int amount = 1)
    {
        AlertLevel += Math.Max(0, amount);
    }

    private void ProcessFumble()
    {
        IsLockedOut = true;
        AccessLevel = AccessLevel.Lockout;
        Status = InfiltrationStatus.LockedOut;
        AlertLevel += 5; // Major alert on fumble
    }

    private void ProcessSuccess(LayerResult result)
    {
        switch (CurrentLayer)
        {
            case 1:
                // Layer 1 success: Proceed to Layer 2
                CurrentLayer = 2;
                if (result.IsCriticalSuccess)
                {
                    // Critical on Layer 1 grants Admin immediately
                    AccessLevel = AccessLevel.AdminLevel;
                }
                break;

            case 2:
                // Layer 2 success: Grant access, proceed to Layer 3
                CurrentLayer = 3;
                if (result.IsCriticalSuccess || AccessLevel == AccessLevel.AdminLevel)
                {
                    AccessLevel = AccessLevel.AdminLevel;
                }
                else
                {
                    AccessLevel = AccessLevel.UserLevel;
                }
                break;

            case 3:
                // Layer 3 success: Infiltration complete
                Status = InfiltrationStatus.Completed;
                break;
        }
    }

    private void ProcessFailure(LayerResult result)
    {
        AlertLevel += 1; // Increase alert on failure

        switch (CurrentLayer)
        {
            case 1:
                // Layer 1 failure: Temporary lockout, can retry
                // State remains at Layer 1, DC increase tracked elsewhere
                Status = InfiltrationStatus.TemporaryLockout;
                break;

            case 2:
                // Layer 2 failure: Alert triggered, ICE may activate
                // Note: ICE activation handled by v0.15.4c
                AlertLevel += 2; // Additional alert for Layer 2 failure
                Status = InfiltrationStatus.AlertTriggered;
                break;

            case 3:
                // Layer 3 failure: Partial access only
                Status = InfiltrationStatus.Completed; // Still "completed" but with reduced results
                break;
        }
    }

    /// <inheritdoc/>
    public override string ToString()
    {
        return $"Infiltration {InfiltrationId}: {TerminalType} " +
               $"Layer {CurrentLayer}, Access: {AccessLevel}, " +
               $"Status: {Status}, Alert: {AlertLevel}";
    }
}
```

### 7.2 InfiltrationStatus Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/InfiltrationStatus.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Overall status of a terminal infiltration attempt.
/// </summary>
public enum InfiltrationStatus
{
    /// <summary>
    /// Infiltration is actively in progress.
    /// </summary>
    InProgress,

    /// <summary>
    /// Temporarily locked out from Layer 1 failure.
    /// </summary>
    /// <remarks>
    /// Can retry after 1 minute at DC +2.
    /// </remarks>
    TemporaryLockout,

    /// <summary>
    /// Alert was triggered by Layer 2 failure.
    /// </summary>
    /// <remarks>
    /// ICE may activate, security may respond.
    /// </remarks>
    AlertTriggered,

    /// <summary>
    /// Infiltration completed (success or partial).
    /// </summary>
    Completed,

    /// <summary>
    /// Terminal permanently locked out due to fumble.
    /// </summary>
    LockedOut,

    /// <summary>
    /// Disconnected from terminal (voluntary or forced).
    /// </summary>
    Disconnected
}
```

---

## 8. LayerResult Value Object

### 8.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LayerResult.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of a single layer attempt during terminal infiltration.
/// </summary>
/// <remarks>
/// <para>
/// Encapsulates the outcome of one layer check, including the skill check
/// result, any access level changes, and narrative description.
/// </para>
/// </remarks>
/// <param name="Layer">The infiltration layer this result applies to.</param>
/// <param name="SkillCheckResult">The underlying skill check result.</param>
/// <param name="Outcome">The skill outcome tier.</param>
/// <param name="DcUsed">The DC that was used for this layer.</param>
/// <param name="TimeRounds">Number of rounds this layer took.</param>
/// <param name="AccessLevelGranted">Access level achieved (if any).</param>
/// <param name="NarrativeDescription">Flavor text describing the outcome.</param>
public readonly record struct LayerResult(
    InfiltrationLayer Layer,
    SkillCheckResult SkillCheckResult,
    SkillOutcome Outcome,
    int DcUsed,
    int TimeRounds,
    AccessLevel? AccessLevelGranted,
    string NarrativeDescription)
{
    /// <summary>
    /// Whether this layer was passed successfully.
    /// </summary>
    public bool IsSuccess => Outcome is SkillOutcome.MarginalSuccess
        or SkillOutcome.FullSuccess
        or SkillOutcome.ExceptionalSuccess
        or SkillOutcome.CriticalSuccess;

    /// <summary>
    /// Whether this was a critical success.
    /// </summary>
    public bool IsCriticalSuccess => Outcome == SkillOutcome.CriticalSuccess;

    /// <summary>
    /// Whether this was a fumble (critical failure).
    /// </summary>
    public bool IsFumble => Outcome == SkillOutcome.CriticalFailure;

    /// <summary>
    /// Creates a success result for a layer.
    /// </summary>
    public static LayerResult Success(
        InfiltrationLayer layer,
        SkillCheckResult checkResult,
        SkillOutcome outcome,
        int dc,
        int timeRounds,
        AccessLevel? accessGranted,
        string narrative)
    {
        return new LayerResult(
            layer,
            checkResult,
            outcome,
            dc,
            timeRounds,
            accessGranted,
            narrative);
    }

    /// <summary>
    /// Creates a failure result for a layer.
    /// </summary>
    public static LayerResult Failure(
        InfiltrationLayer layer,
        SkillCheckResult checkResult,
        SkillOutcome outcome,
        int dc,
        int timeRounds,
        string narrative)
    {
        return new LayerResult(
            layer,
            checkResult,
            outcome,
            dc,
            timeRounds,
            null,
            narrative);
    }

    /// <summary>
    /// Creates a fumble result for a layer.
    /// </summary>
    public static LayerResult Fumble(
        InfiltrationLayer layer,
        SkillCheckResult checkResult,
        int dc,
        string narrative)
    {
        return new LayerResult(
            layer,
            checkResult,
            SkillOutcome.CriticalFailure,
            dc,
            0, // Fumble ends immediately
            AccessLevel.Lockout,
            narrative);
    }

    /// <inheritdoc/>
    public override string ToString()
    {
        var result = IsSuccess ? "SUCCESS" : "FAILURE";
        if (IsCriticalSuccess) result = "CRITICAL SUCCESS";
        if (IsFumble) result = "FUMBLE";

        return $"{Layer} {result}: {NarrativeDescription}";
    }
}
```

---

## 9. TerminalContext Value Object

### 9.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TerminalContext.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Contextual information for a terminal hacking attempt.
/// </summary>
/// <remarks>
/// <para>
/// Aggregates all factors affecting terminal infiltration checks including
/// terminal type, security level, corruption, and tool quality.
/// </para>
/// <para>
/// Layer DCs are calculated as:
/// <code>
/// Layer 1 DC = TerminalType base DC + corruption modifier
/// Layer 2 DC = Layer 1 DC + security level modifier
/// Layer 3 DC = Data type DC
/// </code>
/// </para>
/// </remarks>
public sealed class TerminalContext
{
    /// <summary>
    /// The type/classification of the terminal.
    /// </summary>
    public TerminalType TerminalType { get; }

    /// <summary>
    /// The corruption level affecting the terminal.
    /// </summary>
    /// <remarks>
    /// Normal: No modifier.
    /// Glitched: +2 DC.
    /// Blighted: +4 DC.
    /// </remarks>
    public CorruptionTier CorruptionLevel { get; }

    /// <summary>
    /// The security level for Layer 2 authentication.
    /// </summary>
    public SecurityLevel SecurityLevel { get; }

    /// <summary>
    /// The type of data being sought (for Layer 3).
    /// </summary>
    public DataType? TargetDataType { get; }

    /// <summary>
    /// The quality of hacking tools being used.
    /// </summary>
    public ToolQuality ToolQuality { get; }

    /// <summary>
    /// Number of previous failed Layer 1 attempts.
    /// </summary>
    public int PreviousLayer1Failures { get; }

    /// <summary>
    /// Unique identifier of the terminal entity.
    /// </summary>
    public string TerminalId { get; }

    /// <summary>
    /// Display name of the terminal for UI messages.
    /// </summary>
    public string? TerminalName { get; }

    /// <summary>
    /// Base difficulty class from the terminal type.
    /// </summary>
    public int BaseDc => TerminalType == TerminalType.GlitchedManifold
        ? GetGlitchedManifoldDc()
        : (int)TerminalType;

    /// <summary>
    /// DC modifier from corruption level.
    /// </summary>
    public int CorruptionDcModifier => CorruptionLevel switch
    {
        CorruptionTier.Normal => 0,
        CorruptionTier.Glitched => 2,
        CorruptionTier.Blighted => 4,
        _ => 0
    };

    /// <summary>
    /// DC modifier from Layer 1 failures.
    /// </summary>
    public int FailureDcModifier => PreviousLayer1Failures * 2;

    /// <summary>
    /// Layer 1 (Access) effective DC.
    /// </summary>
    public int Layer1Dc => BaseDc + CorruptionDcModifier + FailureDcModifier;

    /// <summary>
    /// DC modifier from security level.
    /// </summary>
    public int SecurityDcModifier => SecurityLevel switch
    {
        SecurityLevel.PasswordOnly => 0,
        SecurityLevel.Biometric => 2,
        SecurityLevel.MultiFactor => 4,
        SecurityLevel.JotunLocked => 6,
        _ => 0
    };

    /// <summary>
    /// Layer 2 (Authentication) effective DC.
    /// </summary>
    public int Layer2Dc => Layer1Dc + SecurityDcModifier;

    /// <summary>
    /// Layer 3 (Navigation) DC based on data type.
    /// </summary>
    public int Layer3Dc => TargetDataType switch
    {
        DataType.PublicRecords => 10,
        DataType.InternalDocuments => 14,
        DataType.Classified => 18,
        DataType.ArchivedHidden => 22,
        _ => 14 // Default to internal documents
    };

    /// <summary>
    /// Dice pool modifier from tool quality.
    /// </summary>
    public int ToolDiceModifier => ToolQuality switch
    {
        ToolQuality.BareHands => -2,
        ToolQuality.Improvised => 0,
        ToolQuality.Proper => 1,
        ToolQuality.Masterwork => 2,
        _ => 0
    };

    /// <summary>
    /// Time in rounds for Layer 1 based on terminal type.
    /// </summary>
    public int Layer1TimeRounds => TerminalType switch
    {
        TerminalType.CivilianDataPort => 1,
        TerminalType.CorporateMainframe => 1,
        TerminalType.SecurityHub => 2,
        TerminalType.MilitaryServer => 3,
        TerminalType.JotunArchive => 5,
        TerminalType.GlitchedManifold => Random.Shared.Next(1, 4), // 1-3 rounds
        _ => 1
    };

    /// <summary>
    /// ICE rating for this terminal type.
    /// </summary>
    /// <remarks>
    /// ICE mechanics detailed in v0.15.4c.
    /// </remarks>
    public int IceRating => TerminalType switch
    {
        TerminalType.CivilianDataPort => 0,  // No ICE
        TerminalType.CorporateMainframe => 12, // Passive
        TerminalType.SecurityHub => 16,       // Active
        TerminalType.MilitaryServer => 20,    // Active + Lethal
        TerminalType.JotunArchive => 24,      // Lethal
        TerminalType.GlitchedManifold => Random.Shared.Next(12, 25), // Variable
        _ => 0
    };

    /// <summary>
    /// Creates a new terminal context.
    /// </summary>
    public TerminalContext(
        string terminalId,
        TerminalType terminalType,
        CorruptionTier corruptionLevel = CorruptionTier.Normal,
        SecurityLevel securityLevel = SecurityLevel.PasswordOnly,
        DataType? targetDataType = null,
        ToolQuality toolQuality = ToolQuality.Improvised,
        int previousLayer1Failures = 0,
        string? terminalName = null)
    {
        TerminalId = terminalId ?? throw new ArgumentNullException(nameof(terminalId));
        TerminalType = terminalType;
        CorruptionLevel = corruptionLevel;
        SecurityLevel = securityLevel;
        TargetDataType = targetDataType;
        ToolQuality = toolQuality;
        PreviousLayer1Failures = Math.Max(0, previousLayer1Failures);
        TerminalName = terminalName;
    }

    /// <summary>
    /// Creates a copy with incremented Layer 1 failures.
    /// </summary>
    public TerminalContext WithLayer1Failure()
    {
        return new TerminalContext(
            TerminalId,
            TerminalType,
            CorruptionLevel,
            SecurityLevel,
            TargetDataType,
            ToolQuality,
            PreviousLayer1Failures + 1,
            TerminalName);
    }

    /// <summary>
    /// Creates a copy with specified target data type.
    /// </summary>
    public TerminalContext WithTargetData(DataType dataType)
    {
        return new TerminalContext(
            TerminalId,
            TerminalType,
            CorruptionLevel,
            SecurityLevel,
            dataType,
            ToolQuality,
            PreviousLayer1Failures,
            TerminalName);
    }

    /// <summary>
    /// Converts this context to a SkillContext for skill check integration.
    /// </summary>
    public SkillContext ToSkillContext(InfiltrationLayer layer)
    {
        var builder = new SkillContextBuilder();

        // Add tool modifier as equipment
        if (ToolDiceModifier != 0)
        {
            var toolName = ToolQuality switch
            {
                ToolQuality.BareHands => "Bare Hands",
                ToolQuality.Improvised => "Improvised Probe",
                ToolQuality.Proper => "Wire Probe",
                ToolQuality.Masterwork => "Masterwork Interface",
                _ => "Unknown Tools"
            };

            builder.WithEquipment(
                equipmentId: $"tool-{ToolQuality.ToString().ToLowerInvariant()}",
                equipmentName: toolName,
                diceModifier: ToolDiceModifier);
        }

        // Add corruption modifier as environment
        if (CorruptionDcModifier != 0)
        {
            builder.WithEnvironment(
                source: $"Corruption ({CorruptionLevel})",
                dcModifier: CorruptionDcModifier);
        }

        // Add failure modifier as situational (Layer 1 only)
        if (layer == InfiltrationLayer.Layer1_Access && FailureDcModifier != 0)
        {
            builder.WithSituation(
                source: "Previous Access Failures",
                dcModifier: FailureDcModifier,
                description: $"{PreviousLayer1Failures} failed attempt(s)");
        }

        // Add security modifier (Layer 2 only)
        if (layer == InfiltrationLayer.Layer2_Authentication && SecurityDcModifier != 0)
        {
            builder.WithSituation(
                source: $"Security Level ({SecurityLevel})",
                dcModifier: SecurityDcModifier,
                description: GetSecurityDescription());
        }

        return builder.Build();
    }

    private int GetGlitchedManifoldDc()
    {
        // Glitched Manifold has variable DC based on glitch phase
        // Determined dynamically when encountered
        return Random.Shared.Next(12, 21); // 12-20
    }

    private string GetSecurityDescription()
    {
        return SecurityLevel switch
        {
            SecurityLevel.PasswordOnly => "Simple password authentication",
            SecurityLevel.Biometric => "Biometric verification required",
            SecurityLevel.MultiFactor => "Multi-factor authentication",
            SecurityLevel.JotunLocked => "Ancient Jötun authentication protocols",
            _ => "Unknown security"
        };
    }

    /// <inheritdoc/>
    public override string ToString()
    {
        var parts = new List<string>
        {
            $"{TerminalType} (Layer DCs: {Layer1Dc}/{Layer2Dc}/{Layer3Dc})"
        };

        if (CorruptionLevel != CorruptionTier.Normal)
            parts.Add($"[{CorruptionLevel}]");

        parts.Add($"Security: {SecurityLevel}");
        parts.Add($"Tools: {ToolQuality} ({(ToolDiceModifier >= 0 ? "+" : "")}{ToolDiceModifier}d10)");

        if (IceRating > 0)
            parts.Add($"ICE: {IceRating}");

        return string.Join(", ", parts);
    }
}
```

### 9.2 Supporting Enums

**File:** `src/Core/RuneAndRust.Domain/Enums/SecurityLevel.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Security levels for terminal authentication (Layer 2).
/// </summary>
public enum SecurityLevel
{
    /// <summary>
    /// Simple password authentication.
    /// </summary>
    /// <remarks>DC modifier: +0</remarks>
    PasswordOnly = 0,

    /// <summary>
    /// Biometric verification (fingerprint, retinal).
    /// </summary>
    /// <remarks>DC modifier: +2</remarks>
    Biometric = 2,

    /// <summary>
    /// Multi-factor authentication.
    /// </summary>
    /// <remarks>DC modifier: +4</remarks>
    MultiFactor = 4,

    /// <summary>
    /// Ancient Jötun authentication protocols.
    /// </summary>
    /// <remarks>DC modifier: +6</remarks>
    JotunLocked = 6
}
```

**File:** `src/Core/RuneAndRust.Domain/Enums/DataType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of data that can be accessed on terminals (Layer 3).
/// </summary>
public enum DataType
{
    /// <summary>
    /// Public records and openly available information.
    /// </summary>
    /// <remarks>DC: 10</remarks>
    PublicRecords = 10,

    /// <summary>
    /// Internal documents not meant for public access.
    /// </summary>
    /// <remarks>DC: 14</remarks>
    InternalDocuments = 14,

    /// <summary>
    /// Classified information with restricted access.
    /// </summary>
    /// <remarks>DC: 18</remarks>
    Classified = 18,

    /// <summary>
    /// Archived or hidden files requiring deep access.
    /// </summary>
    /// <remarks>DC: 22. Requires AdminLevel access to locate.</remarks>
    ArchivedHidden = 22
}
```

---

## 10. TerminalHackingService Implementation

### 10.1 Interface Definition

**File:** `src/Core/RuneAndRust.Domain/Interfaces/ITerminalHackingService.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Interfaces;

/// <summary>
/// Service for executing terminal hacking attempts.
/// </summary>
public interface ITerminalHackingService
{
    /// <summary>
    /// Begins a new terminal infiltration attempt.
    /// </summary>
    /// <param name="player">The player attempting to hack.</param>
    /// <param name="context">Context containing terminal information.</param>
    /// <returns>A new infiltration state ready for layer attempts.</returns>
    TerminalInfiltrationState BeginInfiltration(Player player, TerminalContext context);

    /// <summary>
    /// Attempts the current layer of an infiltration.
    /// </summary>
    /// <param name="player">The player attempting the hack.</param>
    /// <param name="state">The current infiltration state.</param>
    /// <param name="context">The terminal context.</param>
    /// <returns>The result of the layer attempt.</returns>
    LayerResult AttemptCurrentLayer(
        Player player,
        TerminalInfiltrationState state,
        TerminalContext context);

    /// <summary>
    /// Attempts to cover tracks after successful infiltration.
    /// </summary>
    /// <param name="player">The player covering tracks.</param>
    /// <param name="state">The infiltration state.</param>
    /// <returns>Whether tracks were successfully covered.</returns>
    bool AttemptCoverTracks(Player player, TerminalInfiltrationState state);

    /// <summary>
    /// Gets the DC for a specific layer given the context.
    /// </summary>
    /// <param name="layer">The infiltration layer.</param>
    /// <param name="context">The terminal context.</param>
    /// <returns>The effective DC for the layer.</returns>
    int GetLayerDc(InfiltrationLayer layer, TerminalContext context);

    /// <summary>
    /// Determines if a player can attempt to hack a specific terminal.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <param name="context">The terminal context.</param>
    /// <returns>True if the attempt can be made.</returns>
    bool CanAttempt(Player player, TerminalContext context);

    /// <summary>
    /// Gets the reason why an attempt cannot be made.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <param name="context">The terminal context.</param>
    /// <returns>Reason string if cannot attempt; null if can attempt.</returns>
    string? GetAttemptBlockedReason(Player player, TerminalContext context);
}
```

### 10.2 Service Implementation

**File:** `src/Core/RuneAndRust.Application/Services/TerminalHackingService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for executing multi-layer terminal hacking attempts.
/// </summary>
/// <remarks>
/// <para>
/// Implements the terminal hacking subsystem of the System Bypass skill.
/// Terminal hacking follows cargo cult mechanics—characters manipulate
/// incomprehensible systems through observed patterns.
/// </para>
/// <para>
/// Infiltration proceeds through three layers:
/// <list type="bullet">
///   <item><description>Layer 1 (Access): Establish connection, bypass firewall</description></item>
///   <item><description>Layer 2 (Authentication): Verify identity, gain access level</description></item>
///   <item><description>Layer 3 (Navigation): Locate and access specific data</description></item>
/// </list>
/// </para>
/// </remarks>
public class TerminalHackingService : ITerminalHackingService
{
    private readonly ISkillCheckService _skillCheckService;
    private readonly IFumbleConsequenceService _fumbleService;
    private readonly IGameConfigurationProvider _configProvider;
    private readonly ILogger<TerminalHackingService> _logger;

    private const string SystemBypassSkillId = "system-bypass";
    private const int CoverTracksDc = 14;

    /// <summary>
    /// Creates a new TerminalHackingService.
    /// </summary>
    public TerminalHackingService(
        ISkillCheckService skillCheckService,
        IFumbleConsequenceService fumbleService,
        IGameConfigurationProvider configProvider,
        ILogger<TerminalHackingService> logger)
    {
        _skillCheckService = skillCheckService ?? throw new ArgumentNullException(nameof(skillCheckService));
        _fumbleService = fumbleService ?? throw new ArgumentNullException(nameof(fumbleService));
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public TerminalInfiltrationState BeginInfiltration(Player player, TerminalContext context)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(context);

        var infiltrationId = $"inf-{Guid.NewGuid():N}";

        _logger.LogInformation(
            "Player {PlayerId} beginning infiltration of {TerminalType} terminal {TerminalId}",
            player.Id, context.TerminalType, context.TerminalId);

        return TerminalInfiltrationState.Create(
            infiltrationId,
            player.Id.ToString(),
            context.TerminalType,
            context.TerminalId);
    }

    /// <inheritdoc/>
    public LayerResult AttemptCurrentLayer(
        Player player,
        TerminalInfiltrationState state,
        TerminalContext context)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(state);
        ArgumentNullException.ThrowIfNull(context);

        if (state.IsComplete)
        {
            throw new InvalidOperationException("Cannot attempt layer on completed infiltration.");
        }

        var layer = state.CurrentLayerEnum;
        var dc = GetLayerDc(layer, context);
        var skillContext = context.ToSkillContext(layer);

        _logger.LogInformation(
            "Player {PlayerId} attempting {Layer} on {TerminalType} (DC {DC})",
            player.Id, layer, context.TerminalType, dc);

        // Perform the skill check
        var checkResult = _skillCheckService.PerformCheckWithDC(
            player,
            SystemBypassSkillId,
            dc,
            difficultyName: $"{context.TerminalType} {layer}",
            context: skillContext);

        _logger.LogDebug(
            "Terminal hack check: {NetSuccesses} net vs DC {DC}, Outcome: {Outcome}",
            checkResult.DiceResult.NetSuccesses,
            dc,
            checkResult.Outcome);

        // Process the result
        var layerResult = ProcessLayerResult(player, state, context, layer, dc, checkResult);

        // Record in state
        state.RecordLayerResult(layerResult);

        // Create fumble consequence if needed
        if (layerResult.IsFumble)
        {
            CreateSystemLockoutConsequence(player, state, context);
        }

        return layerResult;
    }

    /// <inheritdoc/>
    public bool AttemptCoverTracks(Player player, TerminalInfiltrationState state)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(state);

        if (!state.IsSuccessful)
        {
            throw new InvalidOperationException("Can only cover tracks after successful infiltration.");
        }

        _logger.LogDebug(
            "Player {PlayerId} attempting to cover tracks on {TerminalId}",
            player.Id, state.TerminalId);

        // Use stealth skill for covering tracks
        var checkResult = _skillCheckService.PerformCheckWithDC(
            player,
            "stealth",
            CoverTracksDc,
            difficultyName: "Cover Tracks");

        var success = checkResult.Outcome >= SkillOutcome.MarginalSuccess;

        if (success)
        {
            state.MarkTracksCovered();
            _logger.LogInformation(
                "Player {PlayerId} successfully covered tracks on {TerminalId}",
                player.Id, state.TerminalId);
        }
        else
        {
            _logger.LogDebug(
                "Player {PlayerId} failed to cover tracks on {TerminalId}",
                player.Id, state.TerminalId);
        }

        return success;
    }

    /// <inheritdoc/>
    public int GetLayerDc(InfiltrationLayer layer, TerminalContext context)
    {
        return layer switch
        {
            InfiltrationLayer.Layer1_Access => context.Layer1Dc,
            InfiltrationLayer.Layer2_Authentication => context.Layer2Dc,
            InfiltrationLayer.Layer3_Navigation => context.Layer3Dc,
            _ => context.Layer1Dc
        };
    }

    /// <inheritdoc/>
    public bool CanAttempt(Player player, TerminalContext context)
    {
        return GetAttemptBlockedReason(player, context) == null;
    }

    /// <inheritdoc/>
    public string? GetAttemptBlockedReason(Player player, TerminalContext context)
    {
        // Check for existing lockout on this terminal
        var hasLockout = _fumbleService.HasActiveConsequence(
            player.Id.ToString(),
            SystemBypassSkillId,
            context.TerminalId);

        if (hasLockout)
        {
            return "This terminal has been locked out and cannot be accessed.";
        }

        // Check for system-bypass skill training
        // Terminal hacking requires training (unlike basic lockpicking)
        // TODO: Add skill proficiency check when skill training system is implemented

        return null;
    }

    private LayerResult ProcessLayerResult(
        Player player,
        TerminalInfiltrationState state,
        TerminalContext context,
        InfiltrationLayer layer,
        int dc,
        SkillCheckResult checkResult)
    {
        var timeRounds = layer == InfiltrationLayer.Layer1_Access
            ? context.Layer1TimeRounds
            : 1;

        return checkResult.Outcome switch
        {
            SkillOutcome.CriticalFailure => CreateFumbleResult(layer, dc, checkResult),
            SkillOutcome.Failure => CreateFailureResult(layer, dc, timeRounds, checkResult),
            SkillOutcome.CriticalSuccess => CreateCriticalSuccessResult(layer, dc, timeRounds, checkResult),
            _ => CreateSuccessResult(layer, dc, timeRounds, checkResult)
        };
    }

    private LayerResult CreateSuccessResult(
        InfiltrationLayer layer,
        int dc,
        int timeRounds,
        SkillCheckResult checkResult)
    {
        var (accessGranted, narrative) = layer switch
        {
            InfiltrationLayer.Layer1_Access => (
                (AccessLevel?)null,
                "Connection established. Firewall bypassed. Proceeding to authentication."
            ),
            InfiltrationLayer.Layer2_Authentication => (
                AccessLevel.UserLevel,
                "Identity verified. User-level access granted. Proceeding to data navigation."
            ),
            InfiltrationLayer.Layer3_Navigation => (
                (AccessLevel?)null,
                "Data located and accessed successfully."
            ),
            _ => (null, "Layer completed.")
        };

        _logger.LogInformation(
            "Terminal hack {Layer} success, access: {Access}",
            layer, accessGranted);

        return LayerResult.Success(
            layer,
            checkResult,
            checkResult.Outcome,
            dc,
            timeRounds,
            accessGranted,
            narrative);
    }

    private LayerResult CreateCriticalSuccessResult(
        InfiltrationLayer layer,
        int dc,
        int timeRounds,
        SkillCheckResult checkResult)
    {
        var (accessGranted, narrative) = layer switch
        {
            InfiltrationLayer.Layer1_Access => (
                AccessLevel.AdminLevel,
                "Masterful bypass! Full system access achieved. Admin privileges granted immediately."
            ),
            InfiltrationLayer.Layer2_Authentication => (
                AccessLevel.AdminLevel,
                "Authentication spoofed flawlessly. Administrative access granted."
            ),
            InfiltrationLayer.Layer3_Navigation => (
                (AccessLevel?)null,
                "Expert navigation reveals hidden data caches and archived files."
            ),
            _ => (null, "Exceptional success.")
        };

        _logger.LogInformation(
            "Terminal hack {Layer} CRITICAL success, access: {Access}",
            layer, accessGranted);

        return LayerResult.Success(
            layer,
            checkResult,
            SkillOutcome.CriticalSuccess,
            dc,
            timeRounds,
            accessGranted,
            narrative);
    }

    private LayerResult CreateFailureResult(
        InfiltrationLayer layer,
        int dc,
        int timeRounds,
        SkillCheckResult checkResult)
    {
        var narrative = layer switch
        {
            InfiltrationLayer.Layer1_Access =>
                "Connection rejected. The terminal locks you out for 1 minute. " +
                "Security protocols have been alerted—next attempt will be harder (+2 DC).",
            InfiltrationLayer.Layer2_Authentication =>
                "Authentication failed. Security alert triggered! " +
                "ICE countermeasures may be activating.",
            InfiltrationLayer.Layer3_Navigation =>
                "Navigation unsuccessful. You can only access partial data—" +
                "classified and hidden files remain out of reach.",
            _ => "Layer failed."
        };

        _logger.LogDebug(
            "Terminal hack {Layer} failed",
            layer);

        return LayerResult.Failure(
            layer,
            checkResult,
            checkResult.Outcome,
            dc,
            timeRounds,
            narrative);
    }

    private LayerResult CreateFumbleResult(
        InfiltrationLayer layer,
        int dc,
        SkillCheckResult checkResult)
    {
        var narrative = layer switch
        {
            InfiltrationLayer.Layer1_Access =>
                "Catastrophic failure! Your intrusion triggers ancient security protocols. " +
                "The terminal emits a harsh klaxon and goes dark. [System Lockout]",
            InfiltrationLayer.Layer2_Authentication =>
                "Critical authentication failure! The system detects your intrusion and " +
                "initiates full lockdown. An alert broadcasts your location. [System Lockout]",
            InfiltrationLayer.Layer3_Navigation =>
                "Fatal navigation error! A cascading failure corrupts the system. " +
                "The terminal shuts down permanently, data irretrievably scrambled. [System Lockout]",
            _ => "Terminal locked out permanently."
        };

        _logger.LogWarning(
            "Terminal hack {Layer} FUMBLE - system lockout triggered",
            layer);

        return LayerResult.Fumble(layer, checkResult, dc, narrative);
    }

    private void CreateSystemLockoutConsequence(
        Player player,
        TerminalInfiltrationState state,
        TerminalContext context)
    {
        _fumbleService.CreateConsequence(
            player.Id.ToString(),
            SystemBypassSkillId,
            FumbleType.SystemLockout,
            context.TerminalId,
            description: $"Terminal {context.TerminalName ?? context.TerminalType.ToString()} " +
                        $"permanently disabled. Security alert broadcast.");

        _logger.LogWarning(
            "Terminal {TerminalId} LOCKED OUT by fumble from player {PlayerId}",
            context.TerminalId, player.Id);
    }
}
```

---

## 11. Data Model Changes

### 11.1 New Types Summary

| Type | Layer | File | Description |
|------|-------|------|-------------|
| `TerminalType` | Domain | `Enums/TerminalType.cs` | Terminal classification enum |
| `InfiltrationLayer` | Domain | `Enums/InfiltrationLayer.cs` | Layer progression enum |
| `AccessLevel` | Domain | `Enums/AccessLevel.cs` | Access state enum |
| `InfiltrationStatus` | Domain | `Enums/InfiltrationStatus.cs` | Overall status enum |
| `SecurityLevel` | Domain | `Enums/SecurityLevel.cs` | Layer 2 security levels |
| `DataType` | Domain | `Enums/DataType.cs` | Layer 3 data types |
| `TerminalInfiltrationState` | Domain | `Entities/TerminalInfiltrationState.cs` | Infiltration state entity |
| `TerminalContext` | Domain | `ValueObjects/TerminalContext.cs` | Terminal-specific context |
| `LayerResult` | Domain | `ValueObjects/LayerResult.cs` | Layer attempt result |
| `ITerminalHackingService` | Domain | `Interfaces/ITerminalHackingService.cs` | Service interface |
| `TerminalHackingService` | Application | `Services/TerminalHackingService.cs` | Service implementation |

### 11.2 Dependencies on Existing Types

| Type | Layer | Usage |
|------|-------|-------|
| `CorruptionTier` | Domain | Terminal corruption level |
| `FumbleType` | Domain | SystemLockout consequence (must add value) |
| `SkillOutcome` | Domain | Outcome classification |
| `SkillCheckResult` | Domain | Underlying check result |
| `SkillContext` | Domain | Skill modifier aggregation |
| `ToolQuality` | Domain | Tool modifier pattern (from v0.15.4a) |
| `FumbleConsequence` | Domain | Consequence tracking |
| `ISkillCheckService` | Application | Skill check execution |
| `IFumbleConsequenceService` | Application | Consequence management |

### 11.3 FumbleType Extension

Add to `src/Core/RuneAndRust.Domain/Enums/FumbleType.cs`:

```csharp
/// <summary>
/// Terminal permanently disabled due to hacking fumble.
/// </summary>
/// <remarks>
/// Triggers alert broadcast. Terminal cannot be reused by anyone.
/// </remarks>
SystemLockout = 2
```

---

## 12. Configuration Files

### 12.1 terminal-types.json

**File:** `config/terminal-types.json`

```json
{
    "$schema": "./schemas/terminal-types.schema.json",
    "terminalTypes": [
        {
            "id": "civilian-data-port",
            "type": "CivilianDataPort",
            "baseDc": 8,
            "displayName": "Civilian Data Port",
            "description": "A simple terminal for everyday civilian use.",
            "layer1TimeRounds": 1,
            "iceType": "None",
            "iceRating": 0,
            "defaultSecurityLevel": "PasswordOnly"
        },
        {
            "id": "corporate-mainframe",
            "type": "CorporateMainframe",
            "baseDc": 12,
            "displayName": "Corporate Mainframe",
            "description": "A business terminal with standard corporate security.",
            "layer1TimeRounds": 1,
            "iceType": "Passive",
            "iceRating": 12,
            "defaultSecurityLevel": "PasswordOnly"
        },
        {
            "id": "security-hub",
            "type": "SecurityHub",
            "baseDc": 16,
            "displayName": "Security Hub",
            "description": "A security station terminal with active defenses.",
            "layer1TimeRounds": 2,
            "iceType": "Active",
            "iceRating": 16,
            "defaultSecurityLevel": "Biometric"
        },
        {
            "id": "military-server",
            "type": "MilitaryServer",
            "baseDc": 20,
            "displayName": "Military Server",
            "description": "A hardened military terminal with aggressive countermeasures.",
            "layer1TimeRounds": 3,
            "iceType": "Active",
            "iceRating": 20,
            "secondaryIceType": "Lethal",
            "defaultSecurityLevel": "MultiFactor"
        },
        {
            "id": "jotun-archive",
            "type": "JotunArchive",
            "baseDc": 24,
            "displayName": "Jötun Archive",
            "description": "An ancient terminal of incomprehensible Old World design.",
            "layer1TimeRounds": 5,
            "iceType": "Lethal",
            "iceRating": 24,
            "defaultSecurityLevel": "JotunLocked"
        },
        {
            "id": "glitched-manifold",
            "type": "GlitchedManifold",
            "baseDc": 0,
            "displayName": "Glitched Manifold",
            "description": "A corrupted terminal where reality itself is unstable.",
            "layer1TimeRounds": -1,
            "iceType": "Unpredictable",
            "iceRating": -1,
            "dynamicDc": true,
            "dcRange": { "min": 12, "max": 20 },
            "defaultSecurityLevel": "PasswordOnly"
        }
    ],
    "securityLevels": {
        "PasswordOnly": { "dcModifier": 0, "displayName": "Password Only" },
        "Biometric": { "dcModifier": 2, "displayName": "Biometric Verification" },
        "MultiFactor": { "dcModifier": 4, "displayName": "Multi-Factor Authentication" },
        "JotunLocked": { "dcModifier": 6, "displayName": "Jötun Authentication" }
    },
    "dataTypes": {
        "PublicRecords": { "dc": 10, "displayName": "Public Records" },
        "InternalDocuments": { "dc": 14, "displayName": "Internal Documents" },
        "Classified": { "dc": 18, "displayName": "Classified Data" },
        "ArchivedHidden": { "dc": 22, "displayName": "Archived/Hidden Files", "requiresAdmin": true }
    },
    "corruptionModifiers": {
        "Normal": 0,
        "Glitched": 2,
        "Blighted": 4
    },
    "layer1FailureModifier": 2,
    "coverTracksDc": 14
}
```

---

## 13. Logging Specifications

### 13.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `TerminalHackingService` | Information | Infiltration started, layer success, completion |
| `TerminalHackingService` | Warning | Fumble occurred, system lockout |
| `TerminalHackingService` | Debug | Layer attempt details, DC calculation, cover tracks |

### 13.2 Log Message Formats

```
[Information] Player {PlayerId} beginning infiltration of {TerminalType} terminal {TerminalId}
[Information] Player {PlayerId} attempting {Layer} on {TerminalType} (DC {DC})
[Information] Terminal hack {Layer} success, access: {Access}
[Information] Terminal hack {Layer} CRITICAL success, access: {Access}
[Information] Player {PlayerId} successfully covered tracks on {TerminalId}
[Warning] Terminal hack {Layer} FUMBLE - system lockout triggered
[Warning] Terminal {TerminalId} LOCKED OUT by fumble from player {PlayerId}
[Debug] Terminal hack check: {NetSuccesses} net vs DC {DC}, Outcome: {Outcome}
[Debug] Terminal hack {Layer} failed
[Debug] Player {PlayerId} attempting to cover tracks on {TerminalId}
[Debug] Player {PlayerId} failed to cover tracks on {TerminalId}
```

---

## 14. Unit Testing Requirements

### 14.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Terminal type sets correct layer DCs | 1 |
| Layer failure applies lockout | 1 |
| Layer 2 failure triggers alert (ICE hook) | 1 |
| Fumble causes permanent lockout | 1 |
| **Total** | **~4** |

### 14.2 Test Specifications

**File:** `tests/RuneAndRust.Application.UnitTests/Services/TerminalHackingServiceTests.cs`

```csharp
[TestFixture]
public class TerminalHackingServiceTests
{
    private Mock<ISkillCheckService> _mockSkillCheckService = null!;
    private Mock<IFumbleConsequenceService> _mockFumbleService = null!;
    private Mock<IGameConfigurationProvider> _mockConfigProvider = null!;
    private Mock<ILogger<TerminalHackingService>> _mockLogger = null!;
    private TerminalHackingService _service = null!;

    [SetUp]
    public void SetUp()
    {
        _mockSkillCheckService = new Mock<ISkillCheckService>();
        _mockFumbleService = new Mock<IFumbleConsequenceService>();
        _mockConfigProvider = new Mock<IGameConfigurationProvider>();
        _mockLogger = new Mock<ILogger<TerminalHackingService>>();

        _service = new TerminalHackingService(
            _mockSkillCheckService.Object,
            _mockFumbleService.Object,
            _mockConfigProvider.Object,
            _mockLogger.Object);
    }

    [Test]
    [TestCase(TerminalType.CivilianDataPort, 8)]
    [TestCase(TerminalType.CorporateMainframe, 12)]
    [TestCase(TerminalType.SecurityHub, 16)]
    [TestCase(TerminalType.MilitaryServer, 20)]
    [TestCase(TerminalType.JotunArchive, 24)]
    public void TerminalType_SetsCorrectLayer1Dc(TerminalType terminalType, int expectedDc)
    {
        // Arrange
        var context = new TerminalContext("test-terminal", terminalType);

        // Act
        var dc = _service.GetLayerDc(InfiltrationLayer.Layer1_Access, context);

        // Assert
        Assert.That(dc, Is.EqualTo(expectedDc));
    }

    [Test]
    public void Layer1Failure_AppliesTemporaryLockout()
    {
        // Arrange
        var player = CreateTestPlayer();
        var context = new TerminalContext("test-terminal", TerminalType.CorporateMainframe);
        var state = _service.BeginInfiltration(player, context);

        SetupFailureCheck();

        // Act
        var result = _service.AttemptCurrentLayer(player, state, context);

        // Assert
        Assert.That(result.IsSuccess, Is.False);
        Assert.That(result.IsFumble, Is.False);
        Assert.That(state.Status, Is.EqualTo(InfiltrationStatus.TemporaryLockout));
        Assert.That(state.CurrentLayer, Is.EqualTo(1)); // Still on Layer 1
    }

    [Test]
    public void Layer2Failure_TriggersAlertStatus()
    {
        // Arrange
        var player = CreateTestPlayer();
        var context = new TerminalContext("test-terminal", TerminalType.CorporateMainframe);
        var state = _service.BeginInfiltration(player, context);

        // Pass Layer 1
        SetupSuccessCheck();
        _service.AttemptCurrentLayer(player, state, context);

        // Fail Layer 2
        SetupFailureCheck();

        // Act
        var result = _service.AttemptCurrentLayer(player, state, context);

        // Assert
        Assert.That(result.IsSuccess, Is.False);
        Assert.That(state.Status, Is.EqualTo(InfiltrationStatus.AlertTriggered));
        Assert.That(state.AlertLevel, Is.GreaterThan(0));
    }

    [Test]
    public void Fumble_CreatesPermanentLockout()
    {
        // Arrange
        var player = CreateTestPlayer();
        var context = new TerminalContext("test-terminal", TerminalType.SecurityHub);
        var state = _service.BeginInfiltration(player, context);

        SetupFumbleCheck();

        // Act
        var result = _service.AttemptCurrentLayer(player, state, context);

        // Assert
        Assert.That(result.IsFumble, Is.True);
        Assert.That(state.IsLockedOut, Is.True);
        Assert.That(state.AccessLevel, Is.EqualTo(AccessLevel.Lockout));
        Assert.That(state.Status, Is.EqualTo(InfiltrationStatus.LockedOut));

        _mockFumbleService.Verify(
            s => s.CreateConsequence(
                It.IsAny<string>(),
                "system-bypass",
                FumbleType.SystemLockout,
                "test-terminal",
                It.IsAny<string>()),
            Times.Once);
    }

    private Player CreateTestPlayer()
    {
        return Player.Create("Test Player", /* attributes */);
    }

    private void SetupSuccessCheck()
    {
        _mockSkillCheckService
            .Setup(s => s.PerformCheckWithDC(
                It.IsAny<Player>(),
                "system-bypass",
                It.IsAny<int>(),
                It.IsAny<string>(),
                It.IsAny<SkillContext>()))
            .Returns(CreateCheckResult(SkillOutcome.FullSuccess));
    }

    private void SetupFailureCheck()
    {
        _mockSkillCheckService
            .Setup(s => s.PerformCheckWithDC(
                It.IsAny<Player>(),
                It.IsAny<string>(),
                It.IsAny<int>(),
                It.IsAny<string>(),
                It.IsAny<SkillContext>()))
            .Returns(CreateCheckResult(SkillOutcome.Failure));
    }

    private void SetupFumbleCheck()
    {
        _mockSkillCheckService
            .Setup(s => s.PerformCheckWithDC(
                It.IsAny<Player>(),
                It.IsAny<string>(),
                It.IsAny<int>(),
                It.IsAny<string>(),
                It.IsAny<SkillContext>()))
            .Returns(CreateCheckResult(SkillOutcome.CriticalFailure));

        _mockFumbleService
            .Setup(s => s.CreateConsequence(
                It.IsAny<string>(),
                It.IsAny<string>(),
                It.IsAny<FumbleType>(),
                It.IsAny<string>(),
                It.IsAny<string>()))
            .Returns(CreateFumbleConsequence());
    }

    private SkillCheckResult CreateCheckResult(SkillOutcome outcome)
    {
        return new SkillCheckResult(/* ... */);
    }

    private FumbleConsequence CreateFumbleConsequence()
    {
        return FumbleConsequence.Create(/* ... */);
    }
}
```

---

## 15. Use Cases

### 15.1 UC-1504b-001: Complete Terminal Infiltration

**Actor:** Player
**Flow:** Player hacks terminal → Passes all three layers → Gains data access

**Details:**
1. Player issues `hack terminal` command on CorporateMainframe
2. System creates `TerminalInfiltrationState`
3. **Layer 1 (Access):** Player passes DC 12 check → Proceeds to Layer 2
4. **Layer 2 (Authentication):** Player passes DC 12 check → Gains UserLevel, proceeds to Layer 3
5. **Layer 3 (Navigation):** Player selects "Internal Documents" → Passes DC 14 check
6. Player can now access the internal documents
7. Player optionally covers tracks (DC 14 Stealth)

### 15.2 UC-1504b-002: Critical Success Grants Admin Access

**Actor:** Player
**Flow:** Player achieves critical success → Immediately gains AdminLevel

**Details:**
1. Player attempts Layer 1 on SecurityHub (DC 16)
2. Skill check results in 5+ net successes (Critical)
3. System grants AdminLevel access immediately
4. Player can skip or ease remaining layers
5. Hidden/archived data becomes accessible without additional checks

### 15.3 UC-1504b-003: Layer 1 Failure Temporary Lockout

**Actor:** Player
**Flow:** Player fails Layer 1 → Temporary lockout → Can retry at higher DC

**Details:**
1. Player attempts Layer 1 on MilitaryServer (DC 20)
2. Skill check fails
3. Terminal displays: "Access denied. 1-minute lockout."
4. `InfiltrationStatus` set to `TemporaryLockout`
5. After 1 minute, player can retry at DC 22 (+2)

### 15.4 UC-1504b-004: Fumble Causes System Lockout

**Actor:** Player
**Flow:** Player fumbles → Terminal permanently disabled → Alert broadcast

**Details:**
1. Player attempts Layer 2 on JotunArchive
2. Dice result: 0 successes, 1+ botches (Fumble)
3. `FumbleConsequenceService.CreateConsequence()` called with `SystemLockout`
4. Terminal marked as disabled permanently
5. Security alert broadcast to nearby systems
6. Player receives fumble narrative
7. No one can use this terminal again

---

## 16. Deliverable Checklist

### 16.1 Domain Layer

- [ ] `TerminalType.cs` enum created in `Enums/`
- [ ] `InfiltrationLayer.cs` enum created in `Enums/`
- [ ] `AccessLevel.cs` enum created in `Enums/`
- [ ] `InfiltrationStatus.cs` enum created in `Enums/`
- [ ] `SecurityLevel.cs` enum created in `Enums/`
- [ ] `DataType.cs` enum created in `Enums/`
- [ ] `TerminalInfiltrationState.cs` entity created in `Entities/`
- [ ] `TerminalContext.cs` value object created in `ValueObjects/`
- [ ] `LayerResult.cs` value object created in `ValueObjects/`
- [ ] `ITerminalHackingService.cs` interface created in `Interfaces/`
- [ ] `FumbleType.cs` updated with `SystemLockout` value

### 16.2 Application Layer

- [ ] `TerminalHackingService.cs` created in `Services/`
- [ ] Service registered in dependency injection

### 16.3 Configuration

- [ ] `config/terminal-types.json` created
- [ ] JSON schema created for configuration file

### 16.4 Testing

- [ ] `TerminalHackingServiceTests.cs` created (~4 tests)
- [ ] All tests passing

### 16.5 Documentation

- [ ] XML documentation complete on all public members
- [ ] This design specification complete

---

## 17. Acceptance Criteria

### 17.1 Functional

- [ ] Terminal type enum values correspond to correct base DCs
- [ ] Layer 1 DC calculated correctly (base + corruption + failures)
- [ ] Layer 2 DC calculated correctly (Layer 1 + security modifier)
- [ ] Layer 3 DC based on data type (10/14/18/22)
- [ ] Layer 1 failure causes temporary lockout and +2 DC on retry
- [ ] Layer 2 failure triggers alert status (ICE hook for v0.15.4c)
- [ ] Layer 3 failure results in partial access only
- [ ] Critical success on Layer 1 or 2 grants AdminLevel
- [ ] Fumble at any layer creates SystemLockout consequence
- [ ] Cover tracks check uses Stealth skill at DC 14
- [ ] TerminalInfiltrationState correctly tracks layer progression

### 17.2 Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~4 new unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on all public members

---

## 18. Dependencies

### 18.1 Required from Previous Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.0 | `DiceRollResult` | Success/botch counting |
| v0.15.0 | `DiceService` | Dice rolling |
| v0.15.0c | `SkillCheckService` | Check execution |
| v0.15.0c | `SkillOutcome` | Outcome classification |
| v0.15.1a | `SkillContext` | Modifier aggregation |
| v0.15.1a | `EquipmentModifier` | Tool bonuses |
| v0.15.1b | `FumbleConsequence` | Consequence tracking |
| v0.15.4a | `ToolQuality` | Tool modifier enum |
| v0.10.x | `CorruptionTier` | Terminal corruption level |

### 18.2 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.4c | ICE Countermeasures | ICE activation hooks on Layer 2 failure |
| v0.15.4i | Specialization | Jötun-Reader [Deep Access] for auto-AdminLevel |

---

## 19. Future Considerations

### 19.1 Deferred to v0.15.4c (ICE Countermeasures)

- ICE type definitions (Passive, Active, Lethal)
- ICE encounter resolution
- ICE activation on Layer 2 failure
- Neural damage and stress from Lethal ICE

### 19.2 Deferred to v0.15.4i (Specialization Integration)

- Jötun-Reader [Deep Access] ability for automatic AdminLevel
- Jötun-Reader [Pattern Recognition] for reduced Glitched DC penalty
- Gantry-Runner [Bypass Under Fire] for no penalty when in danger

### 19.3 Out of Scope

- Terminal entity definition (world system responsibility)
- Data content and quest integration (content system)
- UI for hacking minigame (future version)
- Network propagation of alerts (security system)

---

## 20. Document Metadata

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*

---

*This design specification provides the detailed blueprint for implementing v0.15.4b Terminal Hacking System. This establishes the multi-layer infiltration pattern that will be extended by v0.15.4c ICE Countermeasures.*
