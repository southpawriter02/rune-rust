# v0.18.1d Design Specification: CorruptionService Implementation

**Version:** 0.18.1d
**Parent:** v0.18.1 (Runic Blight Corruption)
**Prerequisites:** v0.18.1a-c Complete (Enums, Entity, Interface)
**Status:** Design Complete
**Estimated Unit Tests:** ~5

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [Value Object Definitions](#5-value-object-definitions)
6. [CorruptionService Implementation](#6-corruptionservice-implementation)
7. [Method Implementations](#7-method-implementations)
8. [Logging Specifications](#8-logging-specifications)
9. [Unit Testing Requirements](#9-unit-testing-requirements)
10. [Use Cases](#10-use-cases)
11. [Deliverable Checklist](#11-deliverable-checklist)
12. [Acceptance Criteria](#12-acceptance-criteria)
13. [Dependencies](#13-dependencies)
14. [Future Considerations](#14-future-considerations)

---

## 1. Executive Summary

This design specification defines the `CorruptionService` class — the core implementation of the `ICorruptionService` interface that manages all corruption operations including accumulation, Blight Transfer, Terminal Error checks, and skill modifiers.

v0.18.1d brings the corruption system to life by implementing:

- Corruption accumulation from various sources
- Blót-Priest corruption transfer mechanics
- WILL-based Terminal Error survival checks using `IDiceService`
- Stage-based skill modifier calculations
- Structured logging for all corruption events

### Key Deliverables

| Category                 | Items                                                  |
| ------------------------ | ------------------------------------------------------ |
| **Application Services** | `CorruptionService`                                    |
| **Domain Value Objects** | `CorruptionTransferResult`, `CorruptionSkillModifiers` |
| **Tests**                | ~5 unit tests                                          |

### Core Mechanics Implemented

| Mechanic            | Formula/Logic                           |
| ------------------- | --------------------------------------- |
| HP Penalty          | `floor(Corruption / 10) × 5%`           |
| AP Penalty          | `floor(Corruption / 10) × 5%`           |
| Resolve Penalty     | `floor(Corruption / 20)`                |
| Tech Bonus          | Stage-based: 0/+1/+2 (caps at Infected) |
| Social Penalty      | Stage-based: 0/-1/-2 (caps at Infected) |
| Faction Lock        | Corruption ≥ 50                         |
| Terminal Error DC   | 3 (WILL check)                          |
| Survival Corruption | Set to 99                               |
| Transfer            | Atomic swap between two characters      |

---

## 2. Feature Overview

```
v0.18.1d Features
└── CorruptionService (implements ICorruptionService)
    │
    ├── DEPENDENCIES
    │   ├── ICorruptionRepository — CorruptionTracker persistence
    │   ├── IDiceService — WILL-based Terminal Error rolls
    │   └── ILogger<CorruptionService> — Structured logging
    │
    ├── NEW VALUE OBJECTS
    │   ├── CorruptionTransferResult — Blót-Priest transfer outcome
    │   └── CorruptionSkillModifiers — Stage-based skill modifiers
    │
    ├── QUERY IMPLEMENTATIONS
    │   ├── GetCorruptionState() — Snapshot from tracker
    │   ├── GetMaxHpPenaltyPercent() — floor(c/10) × 5
    │   ├── GetMaxApPenaltyPercent() — floor(c/10) × 5
    │   ├── GetResolveDicePenalty() — floor(c/20)
    │   └── GetSkillModifiers() — Tech/Social/FactionLock
    │
    ├── COMMAND IMPLEMENTATIONS
    │   ├── AddCorruption() — Delegate to tracker
    │   ├── TransferCorruption() — Blót-Priest swap
    │   └── RemoveCorruption() — Rare purification
    │
    └── TERMINAL IMPLEMENTATION
        └── PerformTerminalErrorCheck() — WILL vs DC 3
```

### Comparison: StressService vs CorruptionService

| Aspect               | StressService (v0.18.0d)          | CorruptionService (v0.18.1d)         |
| -------------------- | --------------------------------- | ------------------------------------ |
| Tracker Type         | Character.PsychicStress (int)     | CorruptionTracker (Entity)           |
| Resistance Check     | WILL-based reduction              | N/A (corruption cannot be resisted)  |
| Recovery             | Formula-based (WILL × multiplier) | Near-impossible (narrative only)     |
| Transfer             | N/A                               | `TransferCorruption` (Blót-Priest)   |
| Terminal Check       | External (TraumaService)          | Built-in `PerformTerminalErrorCheck` |
| Modifier Aggregation | Single `DefensePenalty`           | Composite `SkillModifiers` record    |

---

## 3. Architecture Diagrams

### 3.1 Class Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                     CorruptionService                            │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │  Dependencies:                                                   │   │
│  │  - _corruptionRepository: ICorruptionRepository                 │   │
│  │  - _diceService: IDiceService                                   │   │
│  │  - _logger: ILogger<CorruptionService>                          │   │
│  │                                                                  │   │
│  │  Constants:                                                      │   │
│  │  - TerminalErrorDc = 3                                          │   │
│  │  - SurvivalCorruptionValue = 99                                 │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                                                                  │   │
│  │  ICorruptionService Implementation                               │   │
│  │  ─────────────────────────────────────────────────────────────   │   │
│  │  + GetCorruptionState(Guid): CorruptionState                    │   │
│  │  + GetMaxHpPenaltyPercent(Guid): int                            │   │
│  │  + GetMaxApPenaltyPercent(Guid): int                            │   │
│  │  + GetResolveDicePenalty(Guid): int                             │   │
│  │  + GetSkillModifiers(Guid): CorruptionSkillModifiers            │   │
│  │  + AddCorruption(Guid, int, Source): CorruptionAddResult        │   │
│  │  + TransferCorruption(Guid, Guid, int): TransferResult          │   │
│  │  + RemoveCorruption(Guid, int, string): bool                    │   │
│  │  + PerformTerminalErrorCheck(Guid): TerminalErrorResult         │   │
│  │                                                                  │   │
│  │  Private Methods                                                 │   │
│  │  ─────────────────────────────────────────────────────────────   │   │
│  │  - GetOrCreateTracker(Guid): CorruptionTracker                  │   │
│  │  - SaveTracker(CorruptionTracker): void                         │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                               │                                         │
│                               │ Implements                              │
│                               ▼                                         │
│                    ┌─────────────────────────┐                         │
│                    │   ICorruptionService    │                         │
│                    └─────────────────────────┘                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Dependency Flow

```
                    ┌────────────────────────────────┐
                    │       CorruptionService        │
                    └───────────────┬────────────────┘
                                    │
              ┌─────────────────────┼─────────────────────┐
              │                     │                     │
              ▼                     ▼                     ▼
   ┌────────────────────┐  ┌───────────────┐  ┌──────────────────────┐
   │ICorruptionRepository│  │  IDiceService │  │ILogger<CorruptionSvc>│
   ├────────────────────┤  ├───────────────┤  ├──────────────────────┤
   │ GetByCharacterId() │  │ RollWillCheck │  │ LogDebug             │
   │ Add()              │  │   (will, dc)  │  │ LogInformation       │
   │ Update()           │  │   → successes │  │ LogWarning           │
   └────────────────────┘  └───────────────┘  │ LogError             │
                                              └──────────────────────┘
```

### 3.3 AddCorruption Flow

```
    ┌────────────────────────────────────────────────────────────────┐
    │                     AddCorruption Flow                          │
    └────────────────────────────────────────────────────────────────┘

              AddCorruption(characterId, amount, source)
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  1. Validate Parameters       │
                    │     - amount >= 0             │
                    │     - characterId valid       │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  2. Get/Create Tracker        │
                    │     tracker = GetOrCreate     │
                    │       (characterId)           │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  3. Call Domain Method        │
                    │     result = tracker          │
                    │       .AddCorruption          │
                    │       (amount, source)        │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  4. Log Changes               │
                    │     - Always: value change    │
                    │     - If threshold: Warning   │
                    │     - If stage: Info          │
                    │     - If terminal: Error      │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  5. Persist Tracker           │
                    │     repository.Update(tracker)│
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  6. Return Result             │
                    │     CorruptionAddResult       │
                    └───────────────────────────────┘
```

### 3.4 TransferCorruption Flow

```
    ┌────────────────────────────────────────────────────────────────┐
    │                   TransferCorruption Flow                       │
    │                    (Blót-Priest Mechanic)                       │
    └────────────────────────────────────────────────────────────────┘

        TransferCorruption(fromCharacterId, toCharacterId, amount)
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  1. Validate Parameters       │
                    │     - amount > 0              │
                    │     - fromId != toId          │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  2. Load Both Trackers        │
                    │     source = GetTracker(from) │
                    │     target = GetTracker(to)   │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  3. Validate Transfer         │
                    │     source.Corruption >= amt? │
                    └───────────────┬───────────────┘
                           │                │
                          YES              NO
                           │                │
                           │                ▼
                           │     ┌─────────────────────┐
                           │     │ Return Failure      │
                           │     │ Success = false     │
                           │     └─────────────────────┘
                           │
                           ▼
                    ┌───────────────────────────────┐
                    │  4. Perform Transfer          │
                    │     source -= amount          │
                    │     targetResult = target     │
                    │       .AddCorruption(amount,  │
                    │        BlightTransfer)        │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  5. Log Transfer              │
                    │     - Amount transferred      │
                    │     - Both new values         │
                    │     - Terminal Error if 100   │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  6. Persist Both Trackers     │
                    │     (Atomic operation)        │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  7. Return TransferResult     │
                    └───────────────────────────────┘
```

### 3.5 PerformTerminalErrorCheck Flow

```
    ┌────────────────────────────────────────────────────────────────┐
    │                PerformTerminalErrorCheck Flow                   │
    └────────────────────────────────────────────────────────────────┘

               PerformTerminalErrorCheck(characterId)
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  1. Load Tracker              │
                    │     tracker = GetTracker(id)  │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  2. Validate State            │
                    │     tracker.IsTerminalError?  │
                    └───────────────┬───────────────┘
                           │                │
                         TRUE             FALSE
                           │                │
                           │                ▼
                           │     ┌─────────────────────┐
                           │     │ Throw Exception     │
                           │     │ InvalidOperation    │
                           │     └─────────────────────┘
                           │
                           ▼
                    ┌───────────────────────────────┐
                    │  3. Calculate WILL Pool       │
                    │     baseWill = char.WILL      │
                    │     penalty = tracker         │
                    │       .ResolveDicePenalty     │
                    │     effectiveWill =           │
                    │       max(1, base - penalty)  │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  4. Roll Terminal Error Check │
                    │     successes = _diceService  │
                    │       .RollAttributeCheck     │
                    │       (effectiveWill, DC=3)   │
                    └───────────────┬───────────────┘
                                    │
                           ┌────────┴────────┐
                           │                 │
                           ▼                 ▼
                  ┌──────────────┐   ┌──────────────┐
                  │successes >= 3│   │successes < 3 │
                  │   SURVIVED   │   │    FORLORN   │
                  └──────┬───────┘   └──────┬───────┘
                         │                  │
                         ▼                  ▼
              ┌────────────────────┐ ┌────────────────────┐
              │Set corruption = 99 │ │Mark char as Forlorn│
              │Log Survival        │ │Log Character Lost  │
              └────────────────────┘ └────────────────────┘
                         │                  │
                         └────────┬─────────┘
                                  │
                                  ▼
                    ┌───────────────────────────────┐
                    │  5. Persist & Return          │
                    │     TerminalErrorResult       │
                    └───────────────────────────────┘
```

### 3.6 Skill Modifiers by Stage

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    SKILL MODIFIERS BY CORRUPTION STAGE                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  GetSkillModifiers(characterId) → CorruptionSkillModifiers               │
│                                                                          │
│  ┌────────────┬────────────┬─────────────┬──────────────────────────┐   │
│  │   Stage    │ TechBonus  │ SocialPen   │ FactionLocked            │   │
│  ├────────────┼────────────┼─────────────┼──────────────────────────┤   │
│  │Uncorrupted │     +0     │     -0      │ false                    │   │
│  │  (0-19)    │            │             │                          │   │
│  ├────────────┼────────────┼─────────────┼──────────────────────────┤   │
│  │  Tainted   │     +1     │     -1      │ false                    │   │
│  │  (20-39)   │            │             │                          │   │
│  ├────────────┼────────────┼─────────────┼──────────────────────────┤   │
│  │  Infected  │     +2     │     -2      │ TRUE (Corruption >= 50)  │   │
│  │  (40-59)   │            │             │                          │   │
│  ├────────────┼────────────┼─────────────┼──────────────────────────┤   │
│  │  Blighted  │     +2     │     -2      │ TRUE                     │   │
│  │  (60-79)   │            │             │                          │   │
│  ├────────────┼────────────┼─────────────┼──────────────────────────┤   │
│  │  Corrupted │     +2     │     -2      │ TRUE                     │   │
│  │  (80-99)   │            │             │                          │   │
│  ├────────────┼────────────┼─────────────┼──────────────────────────┤   │
│  │  Consumed  │    N/A     │    N/A      │ TRUE (Forlorn)           │   │
│  │   (100)    │            │             │                          │   │
│  └────────────┴────────────┴─────────────┴──────────────────────────┘   │
│                                                                          │
│  Note: FactionLocked becomes true at Corruption >= 50, independent       │
│        of stage boundaries. Tech bonus and Social penalty cap at ±2.     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. User Stories

### US-18.1d-1: Add Corruption with Logging

**As a** combat system developer
**I want to** apply corruption with full event logging
**So that** all corruption changes are traceable

**Acceptance Criteria:**

- AddCorruption logs previous/new values
- Threshold crossings logged at Warning level
- Stage changes logged at Information level
- Terminal Error logged at Error level

### US-18.1d-2: Transfer Corruption (Blót-Priest)

**As a** Blót-Priest specialization developer
**I want to** transfer corruption between characters atomically
**So that** cleansing mechanics work correctly

**Acceptance Criteria:**

- Both trackers updated in single operation
- Amount cannot exceed source's corruption
- Transfer logged with both character IDs
- Terminal Error detected on target

### US-18.1d-3: Terminal Error Survival Check

**As a** game master system
**I want to** perform survival checks when corruption hits 100
**So that** characters have a chance to survive

**Acceptance Criteria:**

- WILL dice pool reduced by Resolve penalty
- Roll vs DC 3
- Success sets corruption to 99
- Failure marks character as Forlorn

### US-18.1d-4: Query Skill Modifiers

**As a** skill check service
**I want to** get all corruption-based skill modifiers in one call
**So that** I can apply them to appropriate checks

**Acceptance Criteria:**

- Returns composite `CorruptionSkillModifiers`
- TechBonus correct per stage
- SocialPenalty correct per stage
- FactionLocked true when corruption ≥ 50

---

## 5. Value Object Definitions

### 5.1 CorruptionTransferResult

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CorruptionTransferResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of transferring corruption between characters.
/// </summary>
/// <remarks>
/// <para>
/// This record captures the outcome of a Blót-Priest corruption transfer,
/// including both characters' new corruption values and any Terminal Error.
/// </para>
/// <para>
/// Transfer Rules:
/// <list type="bullet">
/// <item>Amount removed from source character</item>
/// <item>Amount added to target character (the Blót-Priest)</item>
/// <item>If target reaches 100, Terminal Error is triggered</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = corruptionService.TransferCorruption(allyId, priestId, 10);
/// if (result.TargetTerminalError)
///     InitiateTerminalErrorCheck(priestId);
/// </code>
/// </example>
public readonly record struct CorruptionTransferResult
{
    /// <summary>
    /// Gets whether the transfer was successful.
    /// </summary>
    /// <remarks>
    /// False if the source did not have enough corruption to transfer.
    /// </remarks>
    public bool Success { get; }

    /// <summary>
    /// Gets the amount of corruption transferred.
    /// </summary>
    public int AmountTransferred { get; }

    /// <summary>
    /// Gets the source character's corruption after transfer.
    /// </summary>
    public int SourceNewCorruption { get; }

    /// <summary>
    /// Gets the target character's corruption after transfer.
    /// </summary>
    public int TargetNewCorruption { get; }

    /// <summary>
    /// Gets whether the transfer caused the target to reach Terminal Error (100).
    /// </summary>
    public bool TargetTerminalError { get; }

    /// <summary>
    /// Gets the source character's ID.
    /// </summary>
    public Guid SourceCharacterId { get; }

    /// <summary>
    /// Gets the target character's ID.
    /// </summary>
    public Guid TargetCharacterId { get; }

    /// <summary>
    /// Private constructor to enforce factory pattern.
    /// </summary>
    private CorruptionTransferResult(
        bool success,
        int amountTransferred,
        int sourceNewCorruption,
        int targetNewCorruption,
        bool targetTerminalError,
        Guid sourceCharacterId,
        Guid targetCharacterId)
    {
        Success = success;
        AmountTransferred = amountTransferred;
        SourceNewCorruption = sourceNewCorruption;
        TargetNewCorruption = targetNewCorruption;
        TargetTerminalError = targetTerminalError;
        SourceCharacterId = sourceCharacterId;
        TargetCharacterId = targetCharacterId;
    }

    /// <summary>
    /// Creates a successful transfer result.
    /// </summary>
    public static CorruptionTransferResult Transferred(
        int amount,
        int sourceNew,
        int targetNew,
        Guid sourceId,
        Guid targetId) =>
        new(
            success: true,
            amountTransferred: amount,
            sourceNewCorruption: sourceNew,
            targetNewCorruption: targetNew,
            targetTerminalError: targetNew >= 100,
            sourceCharacterId: sourceId,
            targetCharacterId: targetId);

    /// <summary>
    /// Creates a failed transfer result (insufficient source corruption).
    /// </summary>
    public static CorruptionTransferResult Failed(
        int sourceCorruption,
        int targetCorruption,
        Guid sourceId,
        Guid targetId) =>
        new(
            success: false,
            amountTransferred: 0,
            sourceNewCorruption: sourceCorruption,
            targetNewCorruption: targetCorruption,
            targetTerminalError: false,
            sourceCharacterId: sourceId,
            targetCharacterId: targetId);

    /// <inheritdoc/>
    public override string ToString() =>
        Success
            ? $"Transfer: {AmountTransferred} corruption from {SourceCharacterId} to {TargetCharacterId}" +
              $" (Source: {SourceNewCorruption}, Target: {TargetNewCorruption})" +
              (TargetTerminalError ? " [TARGET TERMINAL ERROR!]" : "")
            : $"Transfer FAILED: Insufficient corruption on source {SourceCharacterId}";
}
```

### 5.2 CorruptionSkillModifiers

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CorruptionSkillModifiers.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the skill check modifiers derived from corruption stage.
/// </summary>
/// <remarks>
/// <para>
/// Corruption provides both benefits (tech affinity) and penalties (social stigma):
/// <list type="bullet">
/// <item>TechBonus: Corrupted characters have enhanced affinity with malfunctioning tech</item>
/// <item>SocialPenalty: Pure entities and uncorrupted NPCs react negatively</item>
/// <item>FactionLocked: At 50+ corruption, certain faction relationships are locked</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var modifiers = corruptionService.GetSkillModifiers(characterId);
/// if (isTechCheck)
///     dicePool += modifiers.TechBonus;
/// if (isSocialCheck)
///     dicePool += modifiers.SocialPenalty; // Negative value
/// if (modifiers.FactionLocked)
///     disableFactionReputationGain();
/// </code>
/// </example>
public readonly record struct CorruptionSkillModifiers
{
    /// <summary>
    /// Gets the bonus to technology interaction checks.
    /// </summary>
    /// <remarks>
    /// Corrupted characters resonate with the Blight-infected tech.
    /// Range: 0 to +2 based on corruption stage.
    /// </remarks>
    public int TechBonus { get; }

    /// <summary>
    /// Gets the penalty to social interaction checks.
    /// </summary>
    /// <remarks>
    /// Pure entities and uncorrupted NPCs react negatively to visible corruption.
    /// Range: 0 to -2 based on corruption stage.
    /// </remarks>
    public int SocialPenalty { get; }

    /// <summary>
    /// Gets whether faction reputation changes are locked.
    /// </summary>
    /// <remarks>
    /// At 50+ corruption, the character's reputation with certain "pure" factions
    /// can no longer be improved through normal means.
    /// </remarks>
    public bool FactionLocked { get; }

    /// <summary>
    /// Gets the corruption stage these modifiers are based on.
    /// </summary>
    public CorruptionStage Stage { get; }

    /// <summary>
    /// Gets the current corruption value.
    /// </summary>
    public int CurrentCorruption { get; }

    /// <summary>
    /// Private constructor to enforce factory pattern.
    /// </summary>
    private CorruptionSkillModifiers(
        int techBonus,
        int socialPenalty,
        bool factionLocked,
        CorruptionStage stage,
        int currentCorruption)
    {
        TechBonus = techBonus;
        SocialPenalty = socialPenalty;
        FactionLocked = factionLocked;
        Stage = stage;
        CurrentCorruption = currentCorruption;
    }

    /// <summary>
    /// Creates skill modifiers from a corruption tracker.
    /// </summary>
    /// <param name="tracker">The character's corruption tracker.</param>
    /// <returns>Skill modifiers based on the tracker's current state.</returns>
    public static CorruptionSkillModifiers FromTracker(Entities.CorruptionTracker tracker) =>
        new(
            techBonus: tracker.TechBonus,
            socialPenalty: tracker.SocialPenalty,
            factionLocked: tracker.IsFactionLocked,
            stage: tracker.Stage,
            currentCorruption: tracker.CurrentCorruption);

    /// <summary>
    /// Creates skill modifiers for an uncorrupted character.
    /// </summary>
    public static CorruptionSkillModifiers None => new(0, 0, false, CorruptionStage.Uncorrupted, 0);

    /// <inheritdoc/>
    public override string ToString() =>
        $"SkillModifiers[{Stage}]: Tech+{TechBonus}, Social{SocialPenalty}" +
        (FactionLocked ? " [FACTION LOCKED]" : "");
}
```

---

## 6. CorruptionService Implementation

### 6.1 Definition

**File:** `src/Core/RuneAndRust.Application/Services/CorruptionService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service implementation for managing character Runic Blight Corruption.
/// </summary>
/// <remarks>
/// <para>
/// Implements the core corruption mechanics including:
/// <list type="bullet">
/// <item>Corruption accumulation from various heretical sources</item>
/// <item>Blót-Priest corruption transfer (cleansing allies)</item>
/// <item>WILL-based Terminal Error survival checks</item>
/// <item>Stage-based skill modifier calculations</item>
/// </list>
/// </para>
/// <para>
/// Unlike stress, corruption does NOT recover naturally. Only specific
/// narrative events (purification rituals, divine intervention) can
/// reduce corruption, and even then at great cost.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// // Add corruption from heretical ability
/// var result = corruptionService.AddCorruption(
///     characterId, 15, CorruptionSource.HereticalAbility);
///
/// // Blót-Priest cleanses ally
/// var transfer = corruptionService.TransferCorruption(
///     allyId, priestId, 10);
///
/// // Handle Terminal Error
/// if (tracker.IsTerminalError)
/// {
///     var survival = corruptionService.PerformTerminalErrorCheck(characterId);
///     if (!survival.Survived)
///         MarkCharacterAsForlorn(characterId);
/// }
/// </code>
/// </example>
public class CorruptionService : ICorruptionService
{
    #region Constants

    /// <summary>Default DC for Terminal Error survival check.</summary>
    private const int TerminalErrorDc = 3;

    /// <summary>Corruption value after surviving Terminal Error.</summary>
    private const int SurvivalCorruptionValue = 99;

    #endregion

    #region Dependencies

    private readonly ICorruptionRepository _corruptionRepository;
    private readonly ICharacterRepository _characterRepository;
    private readonly IDiceService _diceService;
    private readonly ILogger<CorruptionService> _logger;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the <see cref="CorruptionService"/> class.
    /// </summary>
    /// <param name="corruptionRepository">Repository for corruption tracker persistence.</param>
    /// <param name="characterRepository">Repository for character data (WILL attribute).</param>
    /// <param name="diceService">Service for dice rolling mechanics.</param>
    /// <param name="logger">Logger for structured logging.</param>
    public CorruptionService(
        ICorruptionRepository corruptionRepository,
        ICharacterRepository characterRepository,
        IDiceService diceService,
        ILogger<CorruptionService> logger)
    {
        _corruptionRepository = corruptionRepository ??
            throw new ArgumentNullException(nameof(corruptionRepository));
        _characterRepository = characterRepository ??
            throw new ArgumentNullException(nameof(characterRepository));
        _diceService = diceService ??
            throw new ArgumentNullException(nameof(diceService));
        _logger = logger ??
            throw new ArgumentNullException(nameof(logger));
    }

    #endregion

    // Implementation methods follow in Section 7...
}
```

---

## 7. Method Implementations

### 7.1 Query Methods

```csharp
    #region Query Methods

    /// <inheritdoc/>
    public CorruptionState GetCorruptionState(Guid characterId)
    {
        var tracker = GetOrCreateTracker(characterId);
        var state = CorruptionState.Create(tracker.CurrentCorruption);

        _logger.LogDebug(
            "Corruption state queried for {CharacterId}: {Corruption}/{Max} [{Stage}]",
            characterId, state.CurrentCorruption, CorruptionState.MaxCorruption, state.Stage);

        return state;
    }

    /// <inheritdoc/>
    public int GetMaxHpPenaltyPercent(Guid characterId)
    {
        var tracker = GetOrCreateTracker(characterId);
        return tracker.MaxHpPenaltyPercent;
    }

    /// <inheritdoc/>
    public int GetMaxApPenaltyPercent(Guid characterId)
    {
        var tracker = GetOrCreateTracker(characterId);
        return tracker.MaxApPenaltyPercent;
    }

    /// <inheritdoc/>
    public int GetResolveDicePenalty(Guid characterId)
    {
        var tracker = GetOrCreateTracker(characterId);
        return tracker.ResolveDicePenalty;
    }

    /// <inheritdoc/>
    public CorruptionSkillModifiers GetSkillModifiers(Guid characterId)
    {
        var tracker = GetOrCreateTracker(characterId);
        var modifiers = CorruptionSkillModifiers.FromTracker(tracker);

        _logger.LogDebug(
            "Skill modifiers for {CharacterId}: Tech+{Tech}, Social{Social}, FactionLocked={Locked}",
            characterId, modifiers.TechBonus, modifiers.SocialPenalty, modifiers.FactionLocked);

        return modifiers;
    }

    #endregion
```

### 7.2 Command Methods

```csharp
    #region Command Methods

    /// <inheritdoc/>
    public CorruptionAddResult AddCorruption(
        Guid characterId,
        int amount,
        CorruptionSource source)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(amount);

        var tracker = GetOrCreateTracker(characterId);
        var result = tracker.AddCorruption(amount, source);

        // Log corruption change
        _logger.LogInformation(
            "Corruption added: {CharacterId} +{Amount} [{Source}] ({Previous} → {New})",
            characterId, result.AmountGained, source,
            result.PreviousCorruption, result.NewCorruption);

        // Log threshold crossing
        if (result.ThresholdCrossed.HasValue)
        {
            _logger.LogWarning(
                "Corruption threshold {Threshold}% crossed for {CharacterId}",
                result.ThresholdCrossed.Value, characterId);
        }

        // Log stage change
        if (result.StageCrossed)
        {
            _logger.LogInformation(
                "Corruption stage changed: {CharacterId} {OldStage} → {NewStage}",
                characterId, result.PreviousStage, result.NewStage);
        }

        // Log faction lock
        if (result.NowFactionLocked)
        {
            _logger.LogWarning(
                "Faction reputation LOCKED for {CharacterId}: Corruption at {Value}",
                characterId, result.NewCorruption);
        }

        // Log Terminal Error
        if (result.IsTerminalError)
        {
            _logger.LogError(
                "TERMINAL ERROR: {CharacterId} corruption reached 100",
                characterId);
        }

        SaveTracker(tracker);
        return result;
    }

    /// <inheritdoc/>
    public CorruptionTransferResult TransferCorruption(
        Guid fromCharacterId,
        Guid toCharacterId,
        int amount)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(amount);

        if (fromCharacterId == toCharacterId)
        {
            throw new ArgumentException(
                "Cannot transfer corruption to the same character.",
                nameof(toCharacterId));
        }

        var source = GetOrCreateTracker(fromCharacterId);
        var target = GetOrCreateTracker(toCharacterId);

        // Validate source has enough corruption
        if (source.CurrentCorruption < amount)
        {
            _logger.LogWarning(
                "Transfer failed: {FromId} has {Current} corruption, requested {Amount}",
                fromCharacterId, source.CurrentCorruption, amount);

            return CorruptionTransferResult.Failed(
                source.CurrentCorruption,
                target.CurrentCorruption,
                fromCharacterId,
                toCharacterId);
        }

        // Perform transfer
        var sourceOld = source.CurrentCorruption;
        source.SetCorruption(source.CurrentCorruption - amount);

        var targetResult = target.AddCorruption(amount, CorruptionSource.BlightTransfer);

        _logger.LogInformation(
            "Corruption transferred: {FromId} → {ToId} amount={Amount} " +
            "(Source: {SourceOld} → {SourceNew}, Target: {TargetOld} → {TargetNew})",
            fromCharacterId, toCharacterId, amount,
            sourceOld, source.CurrentCorruption,
            targetResult.PreviousCorruption, targetResult.NewCorruption);

        if (targetResult.IsTerminalError)
        {
            _logger.LogError(
                "Transfer caused TERMINAL ERROR for target {CharacterId}",
                toCharacterId);
        }

        // Persist both trackers
        SaveTracker(source);
        SaveTracker(target);

        return CorruptionTransferResult.Transferred(
            amount,
            source.CurrentCorruption,
            target.CurrentCorruption,
            fromCharacterId,
            toCharacterId);
    }

    /// <inheritdoc/>
    public bool RemoveCorruption(Guid characterId, int amount, string reason)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(amount);
        ArgumentException.ThrowIfNullOrWhiteSpace(reason);

        var tracker = GetOrCreateTracker(characterId);

        if (tracker.CurrentCorruption < amount)
        {
            _logger.LogWarning(
                "Corruption removal failed: {CharacterId} has {Current}, requested {Amount}",
                characterId, tracker.CurrentCorruption, amount);
            return false;
        }

        var previousCorruption = tracker.CurrentCorruption;
        tracker.SetCorruption(tracker.CurrentCorruption - amount);

        _logger.LogWarning(
            "Corruption REMOVED: {CharacterId} -{Amount} ({Previous} → {New}). " +
            "Reason: {Reason}",
            characterId, amount, previousCorruption, tracker.CurrentCorruption, reason);

        SaveTracker(tracker);
        return true;
    }

    #endregion
```

### 7.3 Terminal Error Methods

```csharp
    #region Terminal Error Methods

    /// <inheritdoc/>
    public TerminalErrorResult PerformTerminalErrorCheck(Guid characterId)
    {
        var tracker = GetOrCreateTracker(characterId);

        if (!tracker.IsTerminalError)
        {
            throw new InvalidOperationException(
                $"Character {characterId} is not at Terminal Error " +
                $"(corruption: {tracker.CurrentCorruption}).");
        }

        // Get character's WILL for the check
        var character = _characterRepository.GetById(characterId);
        var baseWill = character.Attributes.Will;

        // Apply Resolve penalty (corruption reduces WILL for this check)
        var resolvePenalty = tracker.ResolveDicePenalty;
        var effectiveWill = Math.Max(1, baseWill - resolvePenalty);

        _logger.LogWarning(
            "Terminal Error check for {CharacterId}: WILL {BaseWill} - {Penalty} penalty = {Effective} dice vs DC {Dc}",
            characterId, baseWill, resolvePenalty, effectiveWill, TerminalErrorDc);

        // Roll the survival check
        var rollResult = _diceService.RollAttributeCheck(effectiveWill, TerminalErrorDc);
        var successes = rollResult.Successes;
        var survived = successes >= TerminalErrorDc;

        TerminalErrorResult result;

        if (survived)
        {
            // Survived - set corruption to 99
            tracker.SetCorruption(SurvivalCorruptionValue);
            SaveTracker(tracker);

            result = TerminalErrorResult.Success(successes, TerminalErrorDc);

            _logger.LogWarning(
                "Terminal Error SURVIVED: {CharacterId} rolled {Successes}/{Dc}, " +
                "corruption set to {Value}",
                characterId, successes, TerminalErrorDc, SurvivalCorruptionValue);
        }
        else
        {
            // Failed - character becomes Forlorn
            result = TerminalErrorResult.Failure(successes, TerminalErrorDc);

            _logger.LogError(
                "Terminal Error FAILED: {CharacterId} rolled {Successes}/{Dc} - " +
                "CHARACTER BECAME FORLORN",
                characterId, successes, TerminalErrorDc);

            // Note: Actual Forlorn state is managed by Character entity (future version)
        }

        return result;
    }

    #endregion
```

### 7.4 Private Helper Methods

```csharp
    #region Private Methods

    /// <summary>
    /// Gets an existing corruption tracker or creates a new one.
    /// </summary>
    private CorruptionTracker GetOrCreateTracker(Guid characterId)
    {
        var tracker = _corruptionRepository.GetByCharacterId(characterId);

        if (tracker == null)
        {
            tracker = CorruptionTracker.Create(characterId);
            _corruptionRepository.Add(tracker);

            _logger.LogDebug(
                "Created new corruption tracker for {CharacterId}",
                characterId);
        }

        return tracker;
    }

    /// <summary>
    /// Persists a corruption tracker to the repository.
    /// </summary>
    private void SaveTracker(CorruptionTracker tracker)
    {
        _corruptionRepository.Update(tracker);
    }

    #endregion
```

---

## 8. Logging Specifications

### 8.1 Log Events

| Event                    | Level       | Template                                                                      |
| ------------------------ | ----------- | ----------------------------------------------------------------------------- |
| State Queried            | Debug       | `"Corruption state queried for {CharacterId}: {Corruption}/{Max} [{Stage}]"`  |
| Modifiers Queried        | Debug       | `"Skill modifiers for {CharacterId}: Tech+{Tech}, Social{Social}..."`         |
| Tracker Created          | Debug       | `"Created new corruption tracker for {CharacterId}"`                          |
| Corruption Added         | Information | `"Corruption added: {CharacterId} +{Amount} [{Source}] ({Previous} → {New})"` |
| Stage Changed            | Information | `"Corruption stage changed: {CharacterId} {OldStage} → {NewStage}"`           |
| Threshold Crossed        | Warning     | `"Corruption threshold {Threshold}% crossed for {CharacterId}"`               |
| Faction Locked           | Warning     | `"Faction reputation LOCKED for {CharacterId}: Corruption at {Value}"`        |
| Corruption Removed       | Warning     | `"Corruption REMOVED: {CharacterId} -{Amount}... Reason: {Reason}"`           |
| Terminal Error Check     | Warning     | `"Terminal Error check for {CharacterId}: WILL {Base} - {Penalty}..."`        |
| Terminal Error Survived  | Warning     | `"Terminal Error SURVIVED: {CharacterId} rolled {Successes}/{Dc}..."`         |
| Transfer Completed       | Information | `"Corruption transferred: {FromId} → {ToId} amount={Amount}..."`              |
| Transfer Failed          | Warning     | `"Transfer failed: {FromId} has {Current} corruption, requested {Amount}"`    |
| Terminal Error Triggered | Error       | `"TERMINAL ERROR: {CharacterId} corruption reached 100"`                      |
| Terminal Error Failed    | Error       | `"Terminal Error FAILED: {CharacterId}... CHARACTER BECAME FORLORN"`          |

---

## 9. Unit Testing Requirements

### 9.1 Test Count by Feature

| Feature                   | Test Count |
| ------------------------- | ---------- |
| AddCorruption             | ~2         |
| TransferCorruption        | ~1         |
| PerformTerminalErrorCheck | ~1         |
| GetSkillModifiers         | ~1         |
| **Total**                 | **~5**     |

### 9.2 CorruptionServiceTests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/CorruptionServiceTests.cs`

```csharp
namespace RuneAndRust.Application.UnitTests.Services;

using FluentAssertions;
using Microsoft.Extensions.Logging;
using NSubstitute;
using NUnit.Framework;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

[TestFixture]
public class CorruptionServiceTests
{
    private ICorruptionRepository _corruptionRepository = null!;
    private ICharacterRepository _characterRepository = null!;
    private IDiceService _diceService = null!;
    private ILogger<CorruptionService> _logger = null!;
    private CorruptionService _service = null!;

    [SetUp]
    public void SetUp()
    {
        _corruptionRepository = Substitute.For<ICorruptionRepository>();
        _characterRepository = Substitute.For<ICharacterRepository>();
        _diceService = Substitute.For<IDiceService>();
        _logger = Substitute.For<ILogger<CorruptionService>>();

        _service = new CorruptionService(
            _corruptionRepository,
            _characterRepository,
            _diceService,
            _logger);
    }

    #region AddCorruption Tests

    [Test]
    public void AddCorruption_ValidAmount_ReturnsCorrectResult()
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var tracker = CorruptionTracker.Create(characterId);
        _corruptionRepository.GetByCharacterId(characterId).Returns(tracker);

        // Act
        var result = _service.AddCorruption(characterId, 25, CorruptionSource.HereticalAbility);

        // Assert
        result.NewCorruption.Should().Be(25);
        result.AmountGained.Should().Be(25);
        result.Source.Should().Be(CorruptionSource.HereticalAbility);
        result.ThresholdCrossed.Should().Be(25);
        _corruptionRepository.Received(1).Update(tracker);
    }

    [Test]
    public void AddCorruption_Reaching100_SetsTerminalErrorFlag()
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var tracker = CorruptionTracker.Create(characterId);
        tracker.SetCorruption(90);
        _corruptionRepository.GetByCharacterId(characterId).Returns(tracker);

        // Act
        var result = _service.AddCorruption(characterId, 15, CorruptionSource.BlightExposure);

        // Assert
        result.NewCorruption.Should().Be(100);
        result.IsTerminalError.Should().BeTrue();
    }

    #endregion

    #region TransferCorruption Tests

    [Test]
    public void TransferCorruption_ValidTransfer_MovesCorruptionCorrectly()
    {
        // Arrange
        var sourceId = Guid.NewGuid();
        var targetId = Guid.NewGuid();

        var sourceTracker = CorruptionTracker.Create(sourceId);
        sourceTracker.SetCorruption(30);
        var targetTracker = CorruptionTracker.Create(targetId);
        targetTracker.SetCorruption(10);

        _corruptionRepository.GetByCharacterId(sourceId).Returns(sourceTracker);
        _corruptionRepository.GetByCharacterId(targetId).Returns(targetTracker);

        // Act
        var result = _service.TransferCorruption(sourceId, targetId, 20);

        // Assert
        result.Success.Should().BeTrue();
        result.AmountTransferred.Should().Be(20);
        result.SourceNewCorruption.Should().Be(10);
        result.TargetNewCorruption.Should().Be(30);
        result.TargetTerminalError.Should().BeFalse();
    }

    #endregion

    #region TerminalErrorCheck Tests

    [Test]
    public void PerformTerminalErrorCheck_PassCheck_SetsCorruptionTo99()
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var tracker = CorruptionTracker.Create(characterId);
        tracker.SetCorruption(100);

        var mockCharacter = Substitute.For<ICharacter>();
        mockCharacter.Attributes.Will.Returns(4);

        _corruptionRepository.GetByCharacterId(characterId).Returns(tracker);
        _characterRepository.GetById(characterId).Returns(mockCharacter);
        _diceService.RollAttributeCheck(Arg.Any<int>(), 3)
            .Returns(new RollResult { Successes = 4 });

        // Act
        var result = _service.PerformTerminalErrorCheck(characterId);

        // Assert
        result.Survived.Should().BeTrue();
        result.BecameForlorn.Should().BeFalse();
        result.FinalCorruption.Should().Be(99);
        tracker.CurrentCorruption.Should().Be(99);
    }

    #endregion

    #region GetSkillModifiers Tests

    [Test]
    [TestCase(0, 0, 0, false)]
    [TestCase(25, 1, -1, false)]
    [TestCase(50, 2, -2, true)]
    [TestCase(75, 2, -2, true)]
    public void GetSkillModifiers_ReturnsCorrectModifiersPerStage(
        int corruption,
        int expectedTech,
        int expectedSocial,
        bool expectedLocked)
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var tracker = CorruptionTracker.Create(characterId);
        tracker.SetCorruption(corruption);
        _corruptionRepository.GetByCharacterId(characterId).Returns(tracker);

        // Act
        var modifiers = _service.GetSkillModifiers(characterId);

        // Assert
        modifiers.TechBonus.Should().Be(expectedTech);
        modifiers.SocialPenalty.Should().Be(expectedSocial);
        modifiers.FactionLocked.Should().Be(expectedLocked);
    }

    #endregion
}
```

---

## 10. Use Cases

### UC-001: Berserker Uses Rage Ability

**Actor:** AbilityService
**Precondition:** Berserker has Rage Points and valid target
**Flow:**

1. Ability resolves with enhanced damage
2. Call `corruptionService.AddCorruption(berserkerId, 5, CorruptionSource.HereticalAbility)`
3. Check result for threshold crossing
4. Update UI with new corruption level
5. If `IsTerminalError`, pause and initiate Terminal Error check

**Postcondition:** Berserker takes corruption cost for using Rage

### UC-002: Blót-Priest Cleanses Ally

**Actor:** SpecializationAbilityService
**Precondition:** Blót-Priest has Cleanse ability, ally is corrupted
**Flow:**

1. Calculate transfer amount (based on ability tier)
2. Call `corruptionService.TransferCorruption(allyId, priestId, amount)`
3. If `result.Success`, update both character UIs
4. If `result.TargetTerminalError`, immediately initiate Terminal Error check for priest
5. Display narrative description of corruption transfer

**Postcondition:** Ally cleansed, priest absorbs corruption

### UC-003: Combat HP/AP Calculation

**Actor:** CombatService
**Precondition:** Combat begins or health changes
**Flow:**

1. Get base max HP from character
2. Call `corruptionService.GetMaxHpPenaltyPercent(characterId)`
3. Calculate effective HP: `baseMaxHP × (1 - penalty/100)`
4. Repeat for AP
5. Update combat stats

**Postcondition:** Combat uses corruption-penalized HP/AP values

### UC-004: Terminal Error Survival

**Actor:** GameMasterService
**Precondition:** Character corruption reaches 100
**Flow:**

1. Display dramatic "Terminal Error" UI
2. Call `corruptionService.PerformTerminalErrorCheck(characterId)`
3. If `result.Survived`:
    - Display survival message with roll details
    - Continue game with corruption at 99
4. If `!result.Survived`:
    - Mark character as Forlorn
    - Transition to character retirement flow

**Postcondition:** Character either survives at 99 or becomes unplayable NPC

---

## 11. Deliverable Checklist

### Domain Layer — Value Objects

- [ ] `src/Core/RuneAndRust.Domain/ValueObjects/CorruptionTransferResult.cs`
- [ ] `src/Core/RuneAndRust.Domain/ValueObjects/CorruptionSkillModifiers.cs`

### Application Layer — Service

- [ ] `src/Core/RuneAndRust.Application/Services/CorruptionService.cs`

### Application Layer — Repository Interface (if not exists)

- [ ] `src/Core/RuneAndRust.Application/Interfaces/ICorruptionRepository.cs`

### Unit Tests

- [ ] `tests/RuneAndRust.Application.UnitTests/Services/CorruptionServiceTests.cs`

### Documentation

- [ ] XML documentation on all public members
- [ ] Code examples in remarks sections
- [ ] Update scope breakdown to mark v0.18.1d complete

---

## 12. Acceptance Criteria

### Functional Criteria

- [ ] `AddCorruption` correctly delegates to tracker and persists
- [ ] `AddCorruption` logs at appropriate levels (Info/Warning/Error)
- [ ] `TransferCorruption` atomically updates both trackers
- [ ] `TransferCorruption` fails gracefully if source has insufficient corruption
- [ ] `TransferCorruption` detects Terminal Error on target
- [ ] `RemoveCorruption` requires valid reason (logged at Warning)
- [ ] `PerformTerminalErrorCheck` uses WILL minus Resolve penalty
- [ ] `PerformTerminalErrorCheck` sets corruption to 99 on survival
- [ ] `GetSkillModifiers` returns correct Stage-based values
- [ ] `GetSkillModifiers.FactionLocked` is true when corruption ≥ 50

### Quality Criteria

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~5 unit tests pass
- [ ] XML documentation complete on all public types and members
- [ ] All log messages use structured logging with `{Property}` placeholders
- [ ] Code follows project conventions

---

## 13. Dependencies

### Required from v0.18.1a

| Type               | Usage                         |
| ------------------ | ----------------------------- |
| `CorruptionStage`  | Stage enum for modifiers      |
| `CorruptionSource` | Parameter for `AddCorruption` |
| `CorruptionState`  | Return type for state query   |

### Required from v0.18.1b

| Type                  | Usage                                       |
| --------------------- | ------------------------------------------- |
| `CorruptionTracker`   | Domain entity for state management          |
| `CorruptionAddResult` | Return type for `AddCorruption`             |
| `TerminalErrorResult` | Return type for `PerformTerminalErrorCheck` |

### Required from v0.18.1c

| Type                 | Usage                 |
| -------------------- | --------------------- |
| `ICorruptionService` | Interface implemented |

### Required from Other Systems

| Type                   | Version | Usage                        |
| ---------------------- | ------- | ---------------------------- |
| `IDiceService`         | v0.6.x  | WILL-based roll for Terminal |
| `ICharacterRepository` | v0.4.x  | Character WILL attribute     |

### Provides to v0.18.1e

| Type                       | Usage                        |
| -------------------------- | ---------------------------- |
| `CorruptionService`        | Service to be configured     |
| `CorruptionTransferResult` | Logged in corruption_history |
| `CorruptionSkillModifiers` | Skill check integration      |

---

## 14. Future Considerations

### Deferred to v0.18.1e

- JSON configuration for corruption source amounts
- Database persistence for `corruption_history` table
- `ICorruptionRepository` implementation

### Deferred to v0.18.5

- Stress-Corruption interaction (stress increases corruption gain)
- Combined penalty calculation service

### Deferred to Future Versions

- Wild Magic system when corruption ≥ 60 (v0.20.x)
- Forlorn NPC behavior AI (v0.21.x)
- Advanced purification ritual system (v0.22.x)
- Corruption-themed UI elements (presentation layer)

### Out of Scope

- Mutation table (handled by separate Mutation system)
- NPC corruption tracking (future expansion)
- Multiplayer corruption synchronization

---

_Document Version: 1.0_
_Last Updated: 2026-01-27_
