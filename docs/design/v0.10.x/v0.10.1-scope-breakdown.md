# v0.10.1 Multi-Target Abilities - Scope Breakdown

**Version:** 0.10.1
**Theme:** Combat Actions
**Prerequisites:** v0.10.0c Complete (Status Effects System - Effect Triggers & Cleanse)
**Total Estimated Tests:** ~40 new tests

---

## Executive Summary

The Combat Actions sub-version implements defensive combat actions (block, dodge, parry), combat stances that modify stats and behavior, and environmental combat interactions like pushing enemies into hazards. These additions provide more tactical options during combat, allowing players to react to incoming attacks and manipulate the battlefield.

Key focus areas:
- **Defense Actions**: Block, dodge, and parry reactions
- **Combat Stances**: Aggressive, defensive, and balanced modes
- **Environmental Combat**: Push, knockback, and hazard interactions

The work is divided into **three sub-parts**:

| Part | Name | Focus | Est. Tests |
|------|------|-------|------------|
| v0.10.1a | Defense Actions | Block, dodge, parry reactions | ~15 |
| v0.10.1b | Combat Stances | Stance definitions, switching, stat modifiers | ~12 |
| v0.10.1c | Environmental Combat | Push, knockback, hazard damage | ~13 |

---

## Existing Infrastructure

### Already Implemented (from v0.5.x)

| Feature | Location | Notes |
|---------|----------|-------|
| CombatGrid | `Domain/Entities/CombatGrid.cs` | Grid-based combat |
| TerrainType | `Domain/Enums/TerrainType.cs` | Terrain types |
| CombatService | `Application/Services/CombatService.cs` | Combat flow |
| DamageService | `Application/Services/DamageService.cs` | Damage application |
| AttackService | `Application/Services/AttackService.cs` | Attack resolution |

### Already Implemented (from v0.10.1)

| Feature | Location | Notes |
|---------|----------|-------|
| IBuffDebuffService | `Application/Interfaces/IBuffDebuffService.cs` | Status effects |
| StatModifier | `Domain/ValueObjects/StatModifier.cs` | Stat modification |
| StatusEffectDefinition | `Domain/Definitions/StatusEffectDefinition.cs` | Effect templates |

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| Combatant | `Domain/Entities/Combatant.cs` | Combat participants |
| Stats | `Domain/ValueObjects/Stats.cs` | Stat system |
| GridPosition | `Domain/ValueObjects/GridPosition.cs` | Position tracking |
| EventBus | `Application/Services/EventBus.cs` | Event system |

### Needs Implementation (v0.10.1)

| Feature | Part | Notes |
|---------|------|-------|
| IDefenseActionService | v0.10.1a | Defense interface |
| DefenseActionService | v0.10.1a | Block/dodge/parry |
| DefenseActionType enum | v0.10.1a | Action types |
| StanceDefinition | v0.10.1b | Stance templates |
| IStanceService | v0.10.1b | Stance interface |
| StanceService | v0.10.1b | Stance switching |
| IEnvironmentalCombatService | v0.10.0c | Push/hazard interface |
| EnvironmentalCombatService | v0.10.0c | Push/hazard logic |
| HazardType enum | v0.10.0c | Hazard types |

---

## Feature Analysis & Categorization

### Defense Action Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| Block action | Medium | Combat, stats | **v0.10.1a** |
| Dodge action | Medium | Combat, stats | **v0.10.1a** |
| Parry action | High | Combat, stats | **v0.10.1a** |
| Reaction system | Medium | Turn system | **v0.10.1a** |
| Shield requirement | Low | Equipment | **v0.10.1a** |
| DEX-based rolls | Low | Stats | **v0.10.1a** |

### Stance Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| Stance definition | Medium | Domain | **v0.10.1b** |
| Stance switching | Medium | Combat flow | **v0.10.1b** |
| Aggressive stance | Medium | Stat modifiers | **v0.10.1b** |
| Defensive stance | Medium | Stat modifiers | **v0.10.1b** |
| Balanced stance | Low | Default | **v0.10.1b** |
| Stance UI | Low | UI | **v0.10.1b** |

### Environmental Combat Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| Push ability | Medium | Grid, movement | **v0.10.0c** |
| Knockback | Medium | Combat, grid | **v0.10.0c** |
| Hazard detection | Medium | Terrain | **v0.10.0c** |
| Hazard damage | Medium | Damage service | **v0.10.0c** |
| Pit falls | Medium | Grid, status | **v0.10.0c** |
| Critical knockback | Low | Combat | **v0.10.0c** |

---

## Part Definitions

---

## v0.10.1a: Defense Actions

[v0.10.1a Design Specification](v0.10.1a-design-specification.md)

### Overview

Implement defensive combat actions that allow combatants to react to incoming attacks. Block reduces damage when using a shield, dodge provides a chance to avoid attacks entirely, and parry allows deflecting an attack and counter-attacking. These consume the combatant's reaction for the round.

### Scope

**In Scope:**
- `IDefenseActionService` interface
- `DefenseActionService` implementation
- `DefenseActionType` enum (Block, Dodge, Parry)
- Block action mechanics
  - Requires shield equipped
  - Reduces incoming damage by 50% + shield bonus
  - Can be used as action or reaction
- Dodge action mechanics
  - DEX-based roll vs attack roll
  - Avoids attack entirely on success
  - Uses reaction
  - Cooldown: once per round
- Parry action mechanics
  - Requires melee weapon
  - DEX vs attack roll
  - Deflects attack and makes counter-attack
  - Uses reaction
  - Higher DC than dodge
- Reaction tracking on combatant
- Defense action events
- Configuration in `defense-actions.json`

**Out of Scope:**
- Combat stances (v0.10.1b)
- Environmental combat (v0.10.0c)
- Advanced parry combos (future)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Interfaces | 1 | `IDefenseActionService` |
| Services | 1 | `DefenseActionService` |
| Enums | 1 | `DefenseActionType` |
| Entity Updates | 1 | Reaction tracking on Combatant |
| Configuration | 1 | `defense-actions.json` |
| Unit Tests | ~15 | Block, dodge, parry tests |

### Defense Action Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DEFENSE ACTION ARCHITECTURE                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      Combat System         â”‚
                      â”‚   (AttackService, AI)      â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚ OnAttackIncoming
                                      â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   IDefenseActionService    â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ + CanBlock(target): bool  â”‚
                      â”‚ + CanDodge(target): bool  â”‚
                      â”‚ + CanParry(target): bool  â”‚
                      â”‚ + UseBlock(target): resultâ”‚
                      â”‚ + UseDodge(target): resultâ”‚
                      â”‚ + UseParry(target): resultâ”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚    DefenseActionService    â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ - CheckReactionAvailable  â”‚
                      â”‚ - ConsumeReaction         â”‚
                      â”‚ - RollDefense             â”‚
                      â”‚ - CalculateDamageReductionâ”‚
                      â”‚ - TriggerCounterAttack    â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


     BLOCK                    DODGE                    PARRY
     â”€â”€â”€â”€â”€                    â”€â”€â”€â”€â”€                    â”€â”€â”€â”€â”€
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   ğŸ›¡    â”‚              â”‚   ğŸ’¨    â”‚              â”‚   âš”ğŸ›¡   â”‚
     â”‚  BLOCK  â”‚              â”‚  DODGE  â”‚              â”‚  PARRY  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     
     Effect:                  Effect:                  Effect:
     Reduce damage by         Chance to avoid          Deflect attack
     50% (+ shield)           attack entirely          and counter
     
     Requires:                Requires:                Requires:
     Shield equipped          DEX check                Melee weapon
     Action or Reaction       Reaction                 Reaction + DEX
     
     Cooldown: None           Cooldown: 1/round        Cooldown: 1/round
```

### IDefenseActionService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for defensive combat actions.
/// </summary>
public interface IDefenseActionService
{
    /// <summary>Checks if target can use block.</summary>
    bool CanBlock(ICombatant target);
    
    /// <summary>Checks if target can use dodge.</summary>
    bool CanDodge(ICombatant target);
    
    /// <summary>Checks if target can use parry.</summary>
    bool CanParry(ICombatant target);
    
    /// <summary>Uses block against an incoming attack.</summary>
    /// <param name="target">The target using block.</param>
    /// <param name="incomingDamage">The damage to reduce.</param>
    /// <returns>Result with reduced damage.</returns>
    BlockResult UseBlock(ICombatant target, int incomingDamage);
    
    /// <summary>Attempts to dodge an incoming attack.</summary>
    /// <param name="target">The target attempting dodge.</param>
    /// <param name="attackRoll">The attacker's roll.</param>
    /// <returns>Result indicating success/failure.</returns>
    DodgeResult UseDodge(ICombatant target, int attackRoll);
    
    /// <summary>Attempts to parry an incoming attack.</summary>
    /// <param name="target">The target attempting parry.</param>
    /// <param name="attacker">The attacking combatant.</param>
    /// <param name="attackRoll">The attacker's roll.</param>
    /// <returns>Result with counter-attack info.</returns>
    ParryResult UseParry(ICombatant target, ICombatant attacker, int attackRoll);
    
    /// <summary>Resets reaction availability at turn start.</summary>
    void ResetReaction(ICombatant combatant);
    
    /// <summary>Checks if combatant has reaction available.</summary>
    bool HasReaction(ICombatant combatant);
}
```

### DefenseActionService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class DefenseActionService : IDefenseActionService
{
    private readonly IDiceService _diceService;
    private readonly IEquipmentService _equipmentService;
    private readonly IAttackService _attackService;
    private readonly ILogger<DefenseActionService> _logger;
    
    public DefenseActionService(
        IDiceService diceService,
        IEquipmentService equipmentService,
        IAttackService attackService,
        ILogger<DefenseActionService> logger)
    {
        _diceService = diceService;
        _equipmentService = equipmentService;
        _attackService = attackService;
        _logger = logger;
    }
    
    public bool CanBlock(ICombatant target)
    {
        // Requires shield equipped
        return _equipmentService.HasShieldEquipped(target);
    }
    
    public bool CanDodge(ICombatant target)
    {
        // Requires reaction available and no heavy armor
        return target.HasReaction && !_equipmentService.HasHeavyArmor(target);
    }
    
    public bool CanParry(ICombatant target)
    {
        // Requires reaction available and melee weapon
        return target.HasReaction && _equipmentService.HasMeleeWeapon(target);
    }
    
    public BlockResult UseBlock(ICombatant target, int incomingDamage)
    {
        if (!CanBlock(target))
        {
            return BlockResult.Failed("Cannot block without a shield");
        }
        
        var shield = _equipmentService.GetEquippedShield(target);
        var baseReduction = 0.5f;
        var shieldBonus = shield?.DefenseBonus ?? 0;
        
        // Calculate reduced damage: 50% base + shield bonus flat reduction
        var reducedDamage = (int)(incomingDamage * baseReduction) - shieldBonus;
        reducedDamage = Math.Max(0, reducedDamage);
        
        var prevented = incomingDamage - reducedDamage;
        
        _logger.LogInformation("{Target} blocked for {Prevented} damage reduction", 
            target.Name, prevented);
        
        return BlockResult.Success(reducedDamage, prevented);
    }
    
    public DodgeResult UseDodge(ICombatant target, int attackRoll)
    {
        if (!CanDodge(target))
        {
            return DodgeResult.Failed("Cannot dodge");
        }
        
        // Consume reaction
        target.UseReaction();
        
        // Roll DEX + proficiency vs attack roll
        var dodgeRoll = _diceService.Roll("1d20") + target.GetModifier("dexterity");
        var success = dodgeRoll >= attackRoll;
        
        _logger.LogInformation("{Target} dodge: rolled {Roll} vs {Attack} - {Result}",
            target.Name, dodgeRoll, attackRoll, success ? "SUCCESS" : "FAILED");
        
        return success 
            ? DodgeResult.Success(dodgeRoll, attackRoll)
            : DodgeResult.Failure(dodgeRoll, attackRoll);
    }
    
    public ParryResult UseParry(ICombatant target, ICombatant attacker, int attackRoll)
    {
        if (!CanParry(target))
        {
            return ParryResult.Failed("Cannot parry");
        }
        
        // Consume reaction
        target.UseReaction();
        
        // Roll DEX + proficiency vs attack roll (harder than dodge, DC +2)
        var parryRoll = _diceService.Roll("1d20") + target.GetModifier("dexterity");
        var parryDC = attackRoll + 2;
        var success = parryRoll >= parryDC;
        
        if (success)
        {
            // Counter-attack
            var counterAttack = _attackService.MakeAttack(target, attacker);
            
            _logger.LogInformation("{Target} parried and counter-attacked {Attacker}",
                target.Name, attacker.Name);
            
            return ParryResult.SuccessWithCounter(parryRoll, parryDC, counterAttack);
        }
        
        _logger.LogInformation("{Target} failed to parry: rolled {Roll} vs DC {DC}",
            target.Name, parryRoll, parryDC);
        
        return ParryResult.Failure(parryRoll, parryDC);
    }
    
    public void ResetReaction(ICombatant combatant)
    {
        combatant.ResetReaction();
    }
    
    public bool HasReaction(ICombatant combatant)
    {
        return combatant.HasReaction;
    }
}
```

### Defense Action Results

```csharp
namespace RuneAndRust.Application.Results;

public record BlockResult(bool IsSuccess, int FinalDamage, int DamagePrevented, string? FailureReason)
{
    public static BlockResult Success(int finalDamage, int prevented)
        => new(true, finalDamage, prevented, null);
    
    public static BlockResult Failed(string reason)
        => new(false, 0, 0, reason);
}

public record DodgeResult(bool IsSuccess, int DodgeRoll, int AttackRoll, string? FailureReason)
{
    public static DodgeResult Success(int dodgeRoll, int attackRoll)
        => new(true, dodgeRoll, attackRoll, null);
    
    public static DodgeResult Failure(int dodgeRoll, int attackRoll)
        => new(false, dodgeRoll, attackRoll, "Dodge failed");
    
    public static DodgeResult Failed(string reason)
        => new(false, 0, 0, reason);
}

public record ParryResult(bool IsSuccess, int ParryRoll, int DC, AttackResult? CounterAttack, string? FailureReason)
{
    public static ParryResult SuccessWithCounter(int parryRoll, int dc, AttackResult counter)
        => new(true, parryRoll, dc, counter, null);
    
    public static ParryResult Failure(int parryRoll, int dc)
        => new(false, parryRoll, dc, null, "Parry failed");
    
    public static ParryResult Failed(string reason)
        => new(false, 0, 0, null, reason);
}
```

### Acceptance Criteria

- [ ] Block reduces damage by 50% + shield
- [ ] Block requires shield equipped
- [ ] Dodge rolls DEX vs attack
- [ ] Successful dodge avoids attack
- [ ] Dodge consumes reaction
- [ ] Parry rolls DEX vs attack+2
- [ ] Successful parry triggers counter
- [ ] Parry requires melee weapon
- [ ] Parry consumes reaction
- [ ] Reaction resets on turn start
- [ ] Cannot use dodge/parry without reaction
- [ ] ~15 unit tests pass

---

## v0.10.1b: Combat Stances

[v0.10.1b Design Specification](v0.10.1b-design-specification.md)

### Overview

Implement combat stances that modify a combatant's stats and behavior. Players can switch between aggressive (offense focus), defensive (survival focus), and balanced (default) stances during combat. Stances apply stat modifiers while active.

### Scope

**In Scope:**
- `StanceDefinition` entity
- `IStanceService` interface
- `StanceService` implementation
- `CombatStance` enum
- Aggressive stance
  - +2 Attack bonus
  - +1d4 Damage bonus
  - -2 Defense
  - -1 to saves
- Defensive stance
  - -2 Attack bonus
  - -1d4 Damage
  - +2 Defense
  - +2 to saves
- Balanced stance (default, no modifiers)
- Stance switching (free action once per round)
- Stance persists between turns
- Stance modifiers on Combatant
- Stance events (OnStanceChanged)
- Configuration in `stances.json`

**Out of Scope:**
- Defense actions (v0.10.1a)
- Environmental combat (v0.10.0c)
- Class-specific stances (future)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 1 | `StanceDefinition` |
| Domain Enums | 1 | `CombatStance` |
| Interfaces | 1 | `IStanceService` |
| Services | 1 | `StanceService` |
| Entity Updates | 1 | CurrentStance on Combatant |
| Configuration | 1 | `stances.json` |
| Unit Tests | ~12 | Stance switching, modifier tests |

### Combat Stance Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMBAT STANCE ARCHITECTURE                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      Player / AI           â”‚
                      â”‚   (Combat decisions)       â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚ SetStance
                                      â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      IStanceService        â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ + GetCurrentStance()      â”‚
                      â”‚ + SetStance(stance)       â”‚
                      â”‚ + CanChangeStance()       â”‚
                      â”‚ + GetStanceModifiers()    â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚       StanceService        â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ - ApplyStanceModifiers    â”‚
                      â”‚ - RemoveStanceModifiers   â”‚
                      â”‚ - TrackStanceChange       â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    AGGRESSIVE               BALANCED                 DEFENSIVE
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€                 â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚    âš”âš”     â”‚           â”‚    âš”ğŸ›¡    â”‚           â”‚    ğŸ›¡ğŸ›¡    â”‚
    â”‚ AGGRESSIVEâ”‚           â”‚  BALANCED â”‚           â”‚ DEFENSIVE â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Modifiers:               Modifiers:               Modifiers:
    +2 Attack                No modifiers             -2 Attack
    +1d4 Damage              (Default stance)         +2 Defense
    -2 Defense                                        +2 All saves
    -1 to saves                                       -1d4 Damage
    
    Best for:                Best for:                Best for:
    Finishing enemies        General combat           Survival
    Glass cannons            Balanced play            Tank builds
```

### StanceDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a combat stance with its modifiers.
/// </summary>
public class StanceDefinition : IEntity
{
    public Guid Id { get; private set; }
    public string StanceId { get; private set; } = null!;
    public string Name { get; private set; } = null!;
    public string Description { get; private set; } = null!;
    public bool IsDefault { get; private set; }
    public int AttackBonus { get; private set; }
    public string? DamageBonus { get; private set; }
    public int DefenseBonus { get; private set; }
    public int SaveBonus { get; private set; }
    public IReadOnlyList<StatModifier> StatModifiers { get; private set; } = [];
    public string? IconPath { get; private set; }
    
    private StanceDefinition() { }
    
    public static StanceDefinition Create(
        string stanceId,
        string name,
        string description,
        int attackBonus = 0,
        string? damageBonus = null,
        int defenseBonus = 0,
        int saveBonus = 0,
        bool isDefault = false)
    {
        return new StanceDefinition
        {
            Id = Guid.NewGuid(),
            StanceId = stanceId.ToLowerInvariant(),
            Name = name,
            Description = description,
            AttackBonus = attackBonus,
            DamageBonus = damageBonus,
            DefenseBonus = defenseBonus,
            SaveBonus = saveBonus,
            IsDefault = isDefault
        };
    }
}
```

### IStanceService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing combat stances.
/// </summary>
public interface IStanceService
{
    /// <summary>Gets the current stance of a combatant.</summary>
    CombatStance GetCurrentStance(ICombatant combatant);
    
    /// <summary>Gets the stance definition for a combatant.</summary>
    StanceDefinition? GetStanceDefinition(ICombatant combatant);
    
    /// <summary>Sets a new combat stance.</summary>
    /// <param name="combatant">The combatant changing stance.</param>
    /// <param name="stance">The new stance.</param>
    /// <returns>Result of the stance change.</returns>
    StanceChangeResult SetStance(ICombatant combatant, CombatStance stance);
    
    /// <summary>Checks if combatant can change stance this round.</summary>
    bool CanChangeStance(ICombatant combatant);
    
    /// <summary>Gets attack bonus from current stance.</summary>
    int GetAttackBonus(ICombatant combatant);
    
    /// <summary>Gets damage bonus from current stance.</summary>
    string? GetDamageBonus(ICombatant combatant);
    
    /// <summary>Gets defense bonus from current stance.</summary>
    int GetDefenseBonus(ICombatant combatant);
    
    /// <summary>Gets save bonus from current stance.</summary>
    int GetSaveBonus(ICombatant combatant);
    
    /// <summary>Resets stance change availability at round start.</summary>
    void ResetStanceChange(ICombatant combatant);
    
    /// <summary>Gets all available stances.</summary>
    IReadOnlyList<StanceDefinition> GetAvailableStances();
}
```

### StanceService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class StanceService : IStanceService
{
    private readonly IStanceProvider _stanceProvider;
    private readonly IStatModifierService _statService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<StanceService> _logger;
    
    // Track which combatants have changed stance this round
    private readonly HashSet<Guid> _stanceChangedThisRound = new();
    
    public StanceService(
        IStanceProvider stanceProvider,
        IStatModifierService statService,
        IEventBus eventBus,
        ILogger<StanceService> logger)
    {
        _stanceProvider = stanceProvider;
        _statService = statService;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public CombatStance GetCurrentStance(ICombatant combatant)
    {
        return combatant.CurrentStance;
    }
    
    public StanceDefinition? GetStanceDefinition(ICombatant combatant)
    {
        return _stanceProvider.GetStance(combatant.CurrentStance);
    }
    
    public StanceChangeResult SetStance(ICombatant combatant, CombatStance stance)
    {
        if (!CanChangeStance(combatant))
        {
            return StanceChangeResult.Failed("Already changed stance this round");
        }
        
        if (combatant.CurrentStance == stance)
        {
            return StanceChangeResult.AlreadyInStance(stance);
        }
        
        var oldStance = combatant.CurrentStance;
        var oldDef = _stanceProvider.GetStance(oldStance);
        var newDef = _stanceProvider.GetStance(stance);
        
        if (newDef is null)
        {
            return StanceChangeResult.Failed($"Unknown stance: {stance}");
        }
        
        // Remove old stance modifiers
        if (oldDef is not null)
        {
            RemoveStanceModifiers(combatant, oldDef);
        }
        
        // Set new stance
        combatant.SetStance(stance);
        _stanceChangedThisRound.Add(combatant.Id);
        
        // Apply new stance modifiers
        ApplyStanceModifiers(combatant, newDef);
        
        _logger.LogInformation("{Combatant} changed stance from {Old} to {New}",
            combatant.Name, oldStance, stance);
        
        _eventBus.Publish(new StanceChangedEvent(combatant.Id, oldStance, stance));
        
        return StanceChangeResult.Success(oldStance, stance);
    }
    
    public bool CanChangeStance(ICombatant combatant)
    {
        return !_stanceChangedThisRound.Contains(combatant.Id);
    }
    
    public int GetAttackBonus(ICombatant combatant)
    {
        var stance = _stanceProvider.GetStance(combatant.CurrentStance);
        return stance?.AttackBonus ?? 0;
    }
    
    public string? GetDamageBonus(ICombatant combatant)
    {
        var stance = _stanceProvider.GetStance(combatant.CurrentStance);
        return stance?.DamageBonus;
    }
    
    public int GetDefenseBonus(ICombatant combatant)
    {
        var stance = _stanceProvider.GetStance(combatant.CurrentStance);
        return stance?.DefenseBonus ?? 0;
    }
    
    public int GetSaveBonus(ICombatant combatant)
    {
        var stance = _stanceProvider.GetStance(combatant.CurrentStance);
        return stance?.SaveBonus ?? 0;
    }
    
    public void ResetStanceChange(ICombatant combatant)
    {
        _stanceChangedThisRound.Remove(combatant.Id);
    }
    
    private void ApplyStanceModifiers(ICombatant combatant, StanceDefinition stance)
    {
        if (stance.AttackBonus != 0)
            _statService.ApplyModifier(combatant, "attack", ModifierOperation.Add, stance.AttackBonus, $"stance:{stance.StanceId}");
        
        if (stance.DefenseBonus != 0)
            _statService.ApplyModifier(combatant, "defense", ModifierOperation.Add, stance.DefenseBonus, $"stance:{stance.StanceId}");
        
        if (stance.SaveBonus != 0)
        {
            _statService.ApplyModifier(combatant, "fortitudeSave", ModifierOperation.Add, stance.SaveBonus, $"stance:{stance.StanceId}");
            _statService.ApplyModifier(combatant, "reflexSave", ModifierOperation.Add, stance.SaveBonus, $"stance:{stance.StanceId}");
            _statService.ApplyModifier(combatant, "willSave", ModifierOperation.Add, stance.SaveBonus, $"stance:{stance.StanceId}");
        }
    }
    
    private void RemoveStanceModifiers(ICombatant combatant, StanceDefinition stance)
    {
        _statService.RemoveModifiersBySource(combatant, $"stance:{stance.StanceId}");
    }
}
```

### Stance Configuration

```json
{
  "$schema": "./schemas/stances.schema.json",
  "stances": [
    {
      "id": "aggressive",
      "name": "Aggressive Stance",
      "description": "Focus on offense at the cost of defense",
      "attackBonus": 2,
      "damageBonus": "1d4",
      "defenseBonus": -2,
      "saveBonus": -1,
      "icon": "icons/stances/aggressive.png"
    },
    {
      "id": "balanced",
      "name": "Balanced Stance",
      "description": "Default combat stance with no modifiers",
      "attackBonus": 0,
      "damageBonus": null,
      "defenseBonus": 0,
      "saveBonus": 0,
      "isDefault": true,
      "icon": "icons/stances/balanced.png"
    },
    {
      "id": "defensive",
      "name": "Defensive Stance",
      "description": "Focus on survival at the cost of offense",
      "attackBonus": -2,
      "damageBonus": "-1d4",
      "defenseBonus": 2,
      "saveBonus": 2,
      "icon": "icons/stances/defensive.png"
    }
  ]
}
```

### Acceptance Criteria

- [ ] Aggressive stance provides +2 attack, +1d4 damage
- [ ] Aggressive stance applies -2 defense, -1 saves
- [ ] Defensive stance provides +2 defense, +2 saves
- [ ] Defensive stance applies -2 attack, -1d4 damage
- [ ] Balanced stance has no modifiers
- [ ] Stance can be changed once per round
- [ ] Stance persists between turns
- [ ] Stance modifiers apply correctly
- [ ] Stance modifiers remove on change
- [ ] StanceChanged event fires
- [ ] Configuration loads from JSON
- [ ] ~12 unit tests pass

---

## v0.10.0c: Environmental Combat

[v0.10.0c Design Specification](v0.10.0c-design-specification.md)

### Overview

Implement environmental combat interactions including push abilities that move targets, knockback on critical hits, and hazard interactions when pushed into dangerous terrain. This adds tactical depth through battlefield manipulation.

### Scope

**In Scope:**
- `IEnvironmentalCombatService` interface
- `EnvironmentalCombatService` implementation
- `HazardType` enum
- Push ability mechanics
  - Push target 1-2 cells in direction
  - Opposed STR check
  - Movement blocked by walls/entities
- Knockback on critical hits
  - Automatic 1 cell knockback
  - Direction away from attacker
- Hazard detection
  - Check destination for hazards
  - Trigger hazard effects on enter
- Hazard types
  - Lava: 3d6 fire damage per turn
  - Spikes: 2d6 piercing on entry
  - Pit: Fall damage, prone, turn to climb
  - Acid: 2d4 acid, damages armor
- Hazard damage events
- Configuration in `hazards.json`

**Out of Scope:**
- Defense actions (v0.10.1a)
- Combat stances (v0.10.1b)
- Environmental hazard creation abilities (future)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Interfaces | 1 | `IEnvironmentalCombatService` |
| Services | 1 | `EnvironmentalCombatService` |
| Enums | 1 | `HazardType` |
| Value Objects | 1 | `PushResult` |
| Configuration | 1 | `hazards.json` |
| Unit Tests | ~13 | Push, knockback, hazard tests |

### Environmental Combat Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ENVIRONMENTAL COMBAT ARCHITECTURE                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      Combat System         â”‚
                      â”‚   (Abilities, Critical)    â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                       â–¼                       â–¼
     [Push Ability]          [Critical Hit]          [Forced Movement]
              â”‚                       â”‚                       â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ IEnvironmentalCombatServiceâ”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ + Push(target, direction) â”‚
                      â”‚ + Knockback(target, from) â”‚
                      â”‚ + CheckHazard(position)   â”‚
                      â”‚ + ApplyHazardDamage()     â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ EnvironmentalCombatService â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ - CalculatePushPath       â”‚
                      â”‚ - CheckCollisions         â”‚
                      â”‚ - TriggerHazardEffect     â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    PUSH ABILITY
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Before:                          After:
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”               â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚ M â”‚   â”‚ ğŸ”¥â”‚               â”‚   â”‚   â”‚ M â”‚ ğŸ”¥â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤     PUSH      â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ @ â”‚   â”‚   â”‚   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚ @ â”‚   â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   (2 cells)   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚   â”‚               â”‚   â”‚   â”‚   â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜               â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    
    @ = Player   M = Monster   ğŸ”¥ = Lava (hazard)


    HAZARD TYPES
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ğŸ”¥ LAVA â”‚ 3d6 fire damage per turn            â”‚
    â”‚         â”‚ Burning status effect               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ âš¡ SPIKEâ”‚ 2d6 piercing damage on entry        â”‚
    â”‚         â”‚ Bleed status effect                 â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ â¬› PIT  â”‚ 2d6 fall damage, prone status       â”‚
    â”‚         â”‚ Takes action to climb out           â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ ğŸ’§ ACID â”‚ 2d4 acid damage per turn            â”‚
    â”‚         â”‚ Armor degradation                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### IEnvironmentalCombatService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for environmental combat interactions.
/// </summary>
public interface IEnvironmentalCombatService
{
    /// <summary>Pushes a target in a direction.</summary>
    /// <param name="pusher">The entity doing the pushing.</param>
    /// <param name="target">The entity being pushed.</param>
    /// <param name="direction">Direction to push.</param>
    /// <param name="distance">Number of cells to push.</param>
    /// <returns>Result of the push attempt.</returns>
    PushResult Push(ICombatant pusher, ICombatant target, Direction direction, int distance = 1);
    
    /// <summary>Knocks back a target away from a source position.</summary>
    /// <param name="target">The entity being knocked back.</param>
    /// <param name="sourcePosition">Position to knock back from.</param>
    /// <param name="distance">Number of cells.</param>
    /// <returns>Result of the knockback.</returns>
    PushResult Knockback(ICombatant target, GridPosition sourcePosition, int distance = 1);
    
    /// <summary>Checks if a position contains a hazard.</summary>
    bool IsHazard(GridPosition position);
    
    /// <summary>Gets the hazard type at a position.</summary>
    HazardType? GetHazardType(GridPosition position);
    
    /// <summary>Applies hazard damage to an entity at a position.</summary>
    HazardDamageResult ApplyHazardDamage(ICombatant target, GridPosition position);
    
    /// <summary>Processes hazards for all entities (turn tick).</summary>
    void TickHazards(IEnumerable<ICombatant> combatants);
    
    /// <summary>Applies knockback on critical hit.</summary>
    void ProcessCriticalKnockback(AttackResult attackResult);
}
```

### EnvironmentalCombatService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class EnvironmentalCombatService : IEnvironmentalCombatService
{
    private readonly ICombatGrid _grid;
    private readonly IDamageService _damageService;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IDiceService _diceService;
    private readonly IEventBus _eventBus;
    private readonly IHazardProvider _hazardProvider;
    private readonly ILogger<EnvironmentalCombatService> _logger;
    
    public EnvironmentalCombatService(
        ICombatGrid grid,
        IDamageService damageService,
        IBuffDebuffService buffDebuffService,
        IDiceService diceService,
        IEventBus eventBus,
        IHazardProvider hazardProvider,
        ILogger<EnvironmentalCombatService> logger)
    {
        _grid = grid;
        _damageService = damageService;
        _buffDebuffService = buffDebuffService;
        _diceService = diceService;
        _eventBus = eventBus;
        _hazardProvider = hazardProvider;
        _logger = logger;
    }
    
    public PushResult Push(ICombatant pusher, ICombatant target, Direction direction, int distance = 1)
    {
        // Opposed STR check
        var pusherRoll = _diceService.Roll("1d20") + pusher.GetModifier("strength");
        var targetRoll = _diceService.Roll("1d20") + target.GetModifier("strength");
        
        if (targetRoll >= pusherRoll)
        {
            _logger.LogDebug("{Target} resisted push from {Pusher}", target.Name, pusher.Name);
            return PushResult.Resisted(pusherRoll, targetRoll);
        }
        
        var startPosition = target.Position;
        var finalPosition = startPosition;
        var cellsMoved = 0;
        var hazardEncountered = false;
        HazardType? hazardType = null;
        
        for (int i = 0; i < distance; i++)
        {
            var nextPosition = finalPosition.Move(direction);
            
            // Check for walls or blocking entities
            if (!_grid.IsPassable(nextPosition))
            {
                _logger.LogDebug("Push blocked at {Position}", nextPosition);
                break;
            }
            
            finalPosition = nextPosition;
            cellsMoved++;
            
            // Check for hazard
            if (IsHazard(finalPosition))
            {
                hazardEncountered = true;
                hazardType = GetHazardType(finalPosition);
                break; // Stop on hazard
            }
        }
        
        if (cellsMoved > 0)
        {
            // Move the target
            target.SetPosition(finalPosition);
            
            _logger.LogInformation("{Pusher} pushed {Target} {Cells} cells to {Position}",
                pusher.Name, target.Name, cellsMoved, finalPosition);
            
            _eventBus.Publish(new EntityPushedEvent(target.Id, startPosition, finalPosition, pusher.Id));
            
            // Apply hazard damage if pushed into hazard
            if (hazardEncountered)
            {
                var hazardResult = ApplyHazardDamage(target, finalPosition);
                return PushResult.PushedIntoHazard(startPosition, finalPosition, cellsMoved, hazardResult);
            }
            
            return PushResult.Success(startPosition, finalPosition, cellsMoved);
        }
        
        return PushResult.Blocked(startPosition);
    }
    
    public PushResult Knockback(ICombatant target, GridPosition sourcePosition, int distance = 1)
    {
        // Calculate direction away from source
        var direction = CalculateDirectionAway(target.Position, sourcePosition);
        
        // No opposed check for knockback
        var startPosition = target.Position;
        var finalPosition = startPosition;
        var cellsMoved = 0;
        
        for (int i = 0; i < distance; i++)
        {
            var nextPosition = finalPosition.Move(direction);
            
            if (!_grid.IsPassable(nextPosition))
            {
                break;
            }
            
            finalPosition = nextPosition;
            cellsMoved++;
            
            if (IsHazard(finalPosition))
            {
                break;
            }
        }
        
        if (cellsMoved > 0)
        {
            target.SetPosition(finalPosition);
            _eventBus.Publish(new EntityKnockedBackEvent(target.Id, startPosition, finalPosition));
            
            if (IsHazard(finalPosition))
            {
                var hazardResult = ApplyHazardDamage(target, finalPosition);
                return PushResult.PushedIntoHazard(startPosition, finalPosition, cellsMoved, hazardResult);
            }
        }
        
        return PushResult.Success(startPosition, finalPosition, cellsMoved);
    }
    
    public bool IsHazard(GridPosition position)
    {
        var terrain = _grid.GetTerrain(position);
        return terrain.IsHazard;
    }
    
    public HazardType? GetHazardType(GridPosition position)
    {
        var terrain = _grid.GetTerrain(position);
        return terrain.HazardType;
    }
    
    public HazardDamageResult ApplyHazardDamage(ICombatant target, GridPosition position)
    {
        var hazardType = GetHazardType(position);
        if (hazardType is null) return HazardDamageResult.NoHazard();
        
        var hazardDef = _hazardProvider.GetHazard(hazardType.Value);
        var damage = _diceService.Roll(hazardDef.DamageDice);
        
        _damageService.ApplyDamage(target, new DamageInstance(damage, hazardDef.DamageType));
        
        // Apply status effect if any
        if (hazardDef.StatusEffectId is not null)
        {
            _buffDebuffService.ApplyEffect(target, hazardDef.StatusEffectId);
        }
        
        _logger.LogInformation("{Target} took {Damage} {Type} damage from {Hazard}",
            target.Name, damage, hazardDef.DamageType, hazardType);
        
        _eventBus.Publish(new HazardDamageEvent(target.Id, hazardType.Value, damage));
        
        return HazardDamageResult.DamageApplied(hazardType.Value, damage, hazardDef.StatusEffectId);
    }
    
    public void ProcessCriticalKnockback(AttackResult attackResult)
    {
        if (!attackResult.IsCritical || attackResult.Target is null) return;
        
        Knockback(attackResult.Target, attackResult.Attacker.Position, distance: 1);
    }
}
```

### Hazard Configuration

```json
{
  "$schema": "./schemas/hazards.schema.json",
  "hazards": [
    {
      "type": "Lava",
      "name": "Lava",
      "description": "Molten rock dealing fire damage",
      "damageDice": "3d6",
      "damageType": "fire",
      "statusEffectId": "burning",
      "damageOnEnter": true,
      "damagePerTurn": true,
      "icon": "icons/hazards/lava.png"
    },
    {
      "type": "Spikes",
      "name": "Spike Trap",
      "description": "Sharp spikes dealing piercing damage",
      "damageDice": "2d6",
      "damageType": "piercing",
      "statusEffectId": "bleeding",
      "damageOnEnter": true,
      "damagePerTurn": false,
      "icon": "icons/hazards/spikes.png"
    },
    {
      "type": "Pit",
      "name": "Pit",
      "description": "A deep pit causing fall damage",
      "damageDice": "2d6",
      "damageType": "bludgeoning",
      "statusEffectId": "prone",
      "damageOnEnter": true,
      "damagePerTurn": false,
      "requiresClimbOut": true,
      "icon": "icons/hazards/pit.png"
    },
    {
      "type": "Acid",
      "name": "Acid Pool",
      "description": "Corrosive acid damaging health and armor",
      "damageDice": "2d4",
      "damageType": "acid",
      "statusEffectId": null,
      "damageOnEnter": true,
      "damagePerTurn": true,
      "degradesArmor": true,
      "icon": "icons/hazards/acid.png"
    }
  ]
}
```

### Acceptance Criteria

- [ ] Push moves target in direction
- [ ] Push checks opposed STR
- [ ] Push blocked by walls/entities
- [ ] Knockback moves away from source
- [ ] Knockback triggers on critical hits
- [ ] Hazard positions detected correctly
- [ ] Lava deals fire damage, applies burning
- [ ] Spikes deal piercing damage on entry
- [ ] Pit causes prone and requires climb
- [ ] Acid deals acid damage
- [ ] Pushed into hazard triggers damage
- [ ] Hazard events fire
- [ ] ~13 unit tests pass

---

## Dependencies & Prerequisites

```
v0.10.0c (Effect Triggers & Cleanse) - REQUIRED
    â”‚
    â””â”€â”€ Status Effects System complete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                                          â”‚
v0.10.1 (Combat Actions)                                                  â”‚
    â”‚                                                                     â”‚
    â”œâ”€â”€ v0.10.1a: Defense Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚       Dependencies: Combat service, Equipment service               â”‚
    â”‚       Provides: IDefenseActionService, block/dodge/parry            â”‚
    â”‚                                                                     â”‚
    â”œâ”€â”€ v0.10.1b: Combat Stances â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚       Dependencies: Stat modifier service                           â”‚
    â”‚       Provides: IStanceService, stance modifiers                    â”‚
    â”‚                                                                     â”‚
    â””â”€â”€ v0.10.0c: Environmental Combat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            Dependencies: Combat grid, Damage service, Status effects
            Provides: IEnvironmentalCombatService, push/knockback/hazards
```

---

## Estimated Effort Summary

| Part | New Files | Modified Files | Est. Tests | Complexity |
|------|-----------|----------------|------------|------------|
| v0.10.1a | ~4 | ~2 | ~15 | Medium |
| v0.10.1b | ~4 | ~2 | ~12 | Medium |
| v0.10.0c | ~4 | ~3 | ~13 | High |
| **Total** | **~12** | **~7** | **~40** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Defense action timing | Medium | Medium | Clear combat flow integration |
| Stance modifier stacking | Medium | Low | Use modifier source tracking |
| Push path calculation | Low | Low | Thorough grid tests |
| Hazard effect balance | Medium | Medium | Configurable damage values |

---

## Design Decisions (Confirmed)

### Defense Actions

| Decision | Value | Notes |
|----------|-------|-------|
| **Block Reduction** | 50% + shield | Significant reduction |
| **Dodge** | DEX vs attack | Must beat roll |
| **Parry** | DEX vs attack+2 | Harder but counters |
| **Reaction Cost** | 1 per round | Shared resource |

### Stances

| Decision | Value | Notes |
|----------|-------|-------|
| **Change Limit** | Once per round | Free action |
| **Default** | Balanced | No modifiers |
| **Modifiers** | +/-2 attack/def | Significant trade-off |

### Environmental

| Decision | Value | Notes |
|----------|-------|-------|
| **Push Distance** | 1-2 cells | Ability dependent |
| **Critical Knockback** | 1 cell | Automatic |
| **Hazard Damage** | Per type config | Configurable |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.10.1a Design Spec** - Create detailed design for Defense Actions
3. **v0.10.1a Implementation** - Build block/dodge/parry
4. **v0.10.1b Design Spec** - Create specification for Combat Stances
5. **v0.10.1b Implementation** - Build stance system
6. **v0.10.0c Design Spec** - Create specification for Environmental Combat
7. **v0.10.0c Implementation** - Build push/knockback/hazards

---

*This scope breakdown provides a structured approach to implementing v0.10.1 Combat Actions. Defense actions, combat stances, and environmental interactions create deeper tactical combat with meaningful player choices and battlefield manipulation.*
