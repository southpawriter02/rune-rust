# v0.6.0a Design Specification: Screen Layout System

**Version:** 0.6.0a
**Parent:** v0.6.0 (Core UI Framework)
**Prerequisites:** v0.5.3c Complete (Area Effects)
**Status:** Design Complete

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Terminal Service](#4-terminal-service)
5. [Panel System](#5-panel-system)
6. [Screen Layout Manager](#6-screen-layout-manager)
7. [Data Model](#7-data-model)
8. [Configuration](#8-configuration)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Use Cases](#11-use-cases)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Dependencies](#14-dependencies)
15. [Future Considerations](#15-future-considerations)

---

## 1. Executive Summary

### Purpose

The Screen Layout System establishes the foundational infrastructure for all TUI enhancements by providing terminal abstraction, panel-based layout management, and responsive sizing. This version creates the container framework that all subsequent v0.6.x UI components will render within.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Terminal Abstraction** | ITerminalService, TerminalService |
| **Panel System** | Panel value object, PanelPosition enum |
| **Layout Management** | ScreenLayout class, responsive sizing |
| **Tests** | ~12 new unit tests |

### Architectural Significance

This version establishes the **Panel-Based Layout Pattern** that will be used throughout the game:
- All UI components render to defined panel regions
- Terminal abstraction enables cross-platform compatibility
- Responsive sizing ensures usability on various terminal sizes

---

## 2. Feature Overview

```
v0.6.0a Features
├── Terminal Service
│   ├── Terminal size detection
│   ├── Cursor position control
│   ├── Write/Clear operations
│   ├── Resize event handling
│   └── Capability detection (color, unicode)
├── Panel System
│   ├── Panel value object
│   ├── PanelPosition enum
│   ├── Content area calculation
│   └── Border support
└── Screen Layout Manager
    ├── Panel registration
    ├── Layout calculation algorithm
    ├── Responsive resizing
    ├── Border drawing utilities
    └── Minimum size validation
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                         PRESENTATION LAYER                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────────┐         ┌─────────────────────────────┐    │
│  │    ScreenLayout     │────────▶│         Panel               │    │
│  ├─────────────────────┤         ├─────────────────────────────┤    │
│  │ + GetPanel()        │         │ + Position: PanelPosition   │    │
│  │ + RenderToPanel()   │         │ + X, Y, Width, Height       │    │
│  │ + ClearPanel()      │         │ + ContentArea               │    │
│  │ + RecalculateLayout()         │ + HasBorder, Title          │    │
│  │ + DrawBorders()     │         └─────────────────────────────┘    │
│  └──────────┬──────────┘                                            │
│             │ uses                                                   │
└─────────────┼───────────────────────────────────────────────────────┘
              │
┌─────────────┼───────────────────────────────────────────────────────┐
│             ▼                   APPLICATION LAYER                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                     ITerminalService                         │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │ + GetSize(): (int Width, int Height)                        │    │
│  │ + SetCursorPosition(x, y): void                             │    │
│  │ + Write(text): void                                         │    │
│  │ + WriteLine(text): void                                     │    │
│  │ + Clear(): void                                             │    │
│  │ + ClearRegion(x, y, width, height): void                    │    │
│  │ + OnResize: event Action<(int, int)>                        │    │
│  │ + SupportsColor: bool                                       │    │
│  │ + SupportsUnicode: bool                                     │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
              │
┌─────────────┼───────────────────────────────────────────────────────┐
│             ▼                  INFRASTRUCTURE LAYER                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                     TerminalService                          │    │
│  ├─────────────────────────────────────────────────────────────┤    │
│  │ (Wraps System.Console)                                       │    │
│  │ (Handles resize polling for terminals without events)        │    │
│  │ (Detects color/unicode capability)                           │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 Screen Layout Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SCREEN LAYOUT INITIALIZATION                      │
└─────────────────────────────────────────────────────────────────────┘

    Application Start
           │
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 1. CREATE TERMINAL SERVICE                                          │
├─────────────────────────────────────────────────────────────────────┤
│  • Wrap System.Console                                              │
│  • Detect terminal capabilities                                     │
│  • Start resize polling (if needed)                                 │
└─────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. CREATE SCREEN LAYOUT                                              │
├─────────────────────────────────────────────────────────────────────┤
│  • Inject ITerminalService                                          │
│  • Subscribe to OnResize event                                      │
│  • Call RecalculateLayout()                                         │
└─────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. CALCULATE LAYOUT                                                  │
├─────────────────────────────────────────────────────────────────────┤
│  • Get terminal size                                                │
│  • Validate minimum size (80x24)                                    │
│  • Calculate panel dimensions                                       │
│  • Create Panel value objects                                       │
│  • Store in position dictionary                                     │
└─────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 4. DRAW BORDERS                                                      │
├─────────────────────────────────────────────────────────────────────┤
│  • For each panel with HasBorder=true                               │
│  • Draw box characters at panel edges                               │
│  • Draw titles (if present)                                         │
└─────────────────────────────────────────────────────────────────────┘
           │
           ▼
    Ready for Content Rendering
```

### 3.3 Resize Handling Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                       RESIZE HANDLING FLOW                           │
└─────────────────────────────────────────────────────────────────────┘

    Terminal Resize Detected
           │
           ▼
┌─────────────────────────────────┐
│ TerminalService.OnResize fires  │
│ with new (Width, Height)        │
└───────────────┬─────────────────┘
                │
                ▼
┌─────────────────────────────────┐         ┌─────────────────────────┐
│ ScreenLayout.HandleResize()     │─────────▶│ Validate minimum size   │
└───────────────┬─────────────────┘         │ (80x24)                 │
                │                            └──────────┬──────────────┘
                │                                       │
                │                         ┌─────────────┴─────────────┐
                │                         │ Size OK?                  │
                │                         └─────────────┬─────────────┘
                │                              YES │           │ NO
                │                                  │           │
                ▼                                  ▼           ▼
┌─────────────────────────────────┐  ┌──────────────┐  ┌──────────────┐
│ RecalculateLayout()             │  │ Recalculate  │  │ Show warning │
│ + Clear()                       │◀─│ panels       │  │ message      │
│ + DrawBorders()                 │  └──────────────┘  └──────────────┘
│ + Re-render active content      │
└─────────────────────────────────┘
```

---

## 4. Terminal Service

### 4.1 ITerminalService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITerminalService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Abstracts terminal operations for cross-platform compatibility.
/// </summary>
/// <remarks>
/// Provides a layer of abstraction over System.Console to enable:
/// - Testability (mock terminal in unit tests)
/// - Cross-platform compatibility
/// - Capability detection
/// </remarks>
public interface ITerminalService
{
    /// <summary>
    /// Gets the current terminal size.
    /// </summary>
    /// <returns>Tuple of (Width, Height) in character cells.</returns>
    (int Width, int Height) GetSize();
    
    /// <summary>
    /// Sets the cursor position.
    /// </summary>
    /// <param name="x">Column (0-indexed from left).</param>
    /// <param name="y">Row (0-indexed from top).</param>
    void SetCursorPosition(int x, int y);
    
    /// <summary>
    /// Writes text at the current cursor position.
    /// </summary>
    /// <param name="text">Text to write.</param>
    void Write(string text);
    
    /// <summary>
    /// Writes a line at the current cursor position.
    /// </summary>
    /// <param name="text">Text to write.</param>
    void WriteLine(string text);
    
    /// <summary>
    /// Clears the entire terminal.
    /// </summary>
    void Clear();
    
    /// <summary>
    /// Clears a specific rectangular region.
    /// </summary>
    /// <param name="x">Starting column.</param>
    /// <param name="y">Starting row.</param>
    /// <param name="width">Width in characters.</param>
    /// <param name="height">Height in rows.</param>
    void ClearRegion(int x, int y, int width, int height);
    
    /// <summary>
    /// Event raised when the terminal is resized.
    /// </summary>
    /// <remarks>
    /// On platforms without native resize events, this may
    /// be triggered by polling.
    /// </remarks>
    event Action<(int Width, int Height)>? OnResize;
    
    /// <summary>
    /// Gets whether color output is supported.
    /// </summary>
    bool SupportsColor { get; }
    
    /// <summary>
    /// Gets whether Unicode output is supported.
    /// </summary>
    bool SupportsUnicode { get; }
}
```

### 4.2 TerminalService Implementation

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Services/TerminalService.cs`

```csharp
namespace RuneAndRust.Infrastructure.Services;

/// <summary>
/// Console-based terminal service implementation.
/// </summary>
public class TerminalService : ITerminalService, IDisposable
{
    private readonly ILogger<TerminalService> _logger;
    private readonly Timer? _resizePoller;
    private (int Width, int Height) _lastSize;
    
    private const int ResizePollIntervalMs = 250;
    
    public event Action<(int Width, int Height)>? OnResize;
    
    public bool SupportsColor { get; }
    public bool SupportsUnicode { get; }
    
    public TerminalService(ILogger<TerminalService> logger)
    {
        _logger = logger;
        _lastSize = GetSize();
        
        // Detect capabilities
        SupportsColor = DetectColorSupport();
        SupportsUnicode = DetectUnicodeSupport();
        
        // Start resize polling (Console doesn't have native resize events)
        _resizePoller = new Timer(CheckForResize, null, 
            ResizePollIntervalMs, ResizePollIntervalMs);
        
        _logger.LogDebug("TerminalService initialized: {Width}x{Height}, " +
            "Color={Color}, Unicode={Unicode}",
            _lastSize.Width, _lastSize.Height, SupportsColor, SupportsUnicode);
    }
    
    public (int Width, int Height) GetSize()
    {
        try
        {
            return (Console.WindowWidth, Console.WindowHeight);
        }
        catch (IOException)
        {
            // Fallback for redirected/piped console
            return (80, 24);
        }
    }
    
    public void SetCursorPosition(int x, int y)
    {
        try
        {
            Console.SetCursorPosition(x, y);
        }
        catch (ArgumentOutOfRangeException)
        {
            _logger.LogWarning("Invalid cursor position: ({X}, {Y})", x, y);
        }
    }
    
    public void Write(string text)
    {
        Console.Write(text);
    }
    
    public void WriteLine(string text)
    {
        Console.WriteLine(text);
    }
    
    public void Clear()
    {
        Console.Clear();
    }
    
    public void ClearRegion(int x, int y, int width, int height)
    {
        var blank = new string(' ', width);
        for (var row = 0; row < height; row++)
        {
            SetCursorPosition(x, y + row);
            Write(blank);
        }
    }
    
    private void CheckForResize(object? state)
    {
        var currentSize = GetSize();
        if (currentSize != _lastSize)
        {
            _logger.LogDebug("Terminal resized: {OldWidth}x{OldHeight} -> {NewWidth}x{NewHeight}",
                _lastSize.Width, _lastSize.Height, currentSize.Width, currentSize.Height);
            
            _lastSize = currentSize;
            OnResize?.Invoke(currentSize);
        }
    }
    
    private static bool DetectColorSupport()
    {
        // Check environment variables for color support
        var term = Environment.GetEnvironmentVariable("TERM") ?? "";
        var colorTerm = Environment.GetEnvironmentVariable("COLORTERM") ?? "";
        
        return !Console.IsOutputRedirected && 
               (term.Contains("color") || 
                term.Contains("xterm") || 
                term.Contains("256") ||
                !string.IsNullOrEmpty(colorTerm));
    }
    
    private static bool DetectUnicodeSupport()
    {
        // Check if stdout supports Unicode
        try
        {
            return Console.OutputEncoding.EncodingName.Contains("Unicode") ||
                   Console.OutputEncoding.EncodingName.Contains("UTF");
        }
        catch
        {
            return false;
        }
    }
    
    public void Dispose()
    {
        _resizePoller?.Dispose();
    }
}
```

---

## 5. Panel System

### 5.1 Panel Value Object

**File:** `src/Presentation/RuneAndRust.TUI/UI/Panel.cs`

```csharp
namespace RuneAndRust.Presentation.UI;

/// <summary>
/// Represents a rectangular panel in the screen layout.
/// </summary>
/// <param name="Position">The logical position of this panel.</param>
/// <param name="X">The left column (0-indexed).</param>
/// <param name="Y">The top row (0-indexed).</param>
/// <param name="Width">The width in characters.</param>
/// <param name="Height">The height in rows.</param>
/// <param name="Title">Optional title to display in the border.</param>
/// <param name="HasBorder">Whether to draw a border around the panel.</param>
public readonly record struct Panel(
    PanelPosition Position,
    int X,
    int Y,
    int Width,
    int Height,
    string? Title = null,
    bool HasBorder = true)
{
    /// <summary>
    /// Gets the inner content area, accounting for borders.
    /// </summary>
    /// <returns>Tuple of (X, Y, Width, Height) for content area.</returns>
    public (int X, int Y, int Width, int Height) ContentArea =>
        HasBorder 
            ? (X + 1, Y + 1, Math.Max(0, Width - 2), Math.Max(0, Height - 2))
            : (X, Y, Width, Height);
    
    /// <summary>
    /// Gets the number of content lines that fit in this panel.
    /// </summary>
    public int ContentLines => ContentArea.Height;
    
    /// <summary>
    /// Gets the width available for content text.
    /// </summary>
    public int ContentWidth => ContentArea.Width;
    
    /// <summary>
    /// Checks if a point is within the content area.
    /// </summary>
    /// <param name="x">The x coordinate to check.</param>
    /// <param name="y">The y coordinate to check.</param>
    public bool ContainsPoint(int x, int y)
    {
        var content = ContentArea;
        return x >= content.X && x < content.X + content.Width &&
               y >= content.Y && y < content.Y + content.Height;
    }
}
```

### 5.2 PanelPosition Enum

**File:** `src/Presentation/RuneAndRust.TUI/UI/PanelPosition.cs`

```csharp
namespace RuneAndRust.Presentation.UI;

/// <summary>
/// Defines standard panel positions in the screen layout.
/// </summary>
public enum PanelPosition
{
    /// <summary>
    /// Primary content area (left/center).
    /// Used for room descriptions, combat log, and main game messages.
    /// </summary>
    MainContent,
    
    /// <summary>
    /// Right sidebar for status information.
    /// Used for player stats, location info.
    /// </summary>
    Sidebar,
    
    /// <summary>
    /// Bottom status bar.
    /// Used for HP, MP, XP, gold display.
    /// </summary>
    Footer,
    
    /// <summary>
    /// Command input area.
    /// Used for player command entry.
    /// </summary>
    Input,
    
    /// <summary>
    /// Modal/overlay panels.
    /// Used for dialogs, menus, popups.
    /// </summary>
    Popup
}
```

---

## 6. Screen Layout Manager

### 6.1 ScreenLayout Class

**File:** `src/Presentation/RuneAndRust.TUI/UI/ScreenLayout.cs`

```csharp
namespace RuneAndRust.Presentation.UI;

/// <summary>
/// Manages screen layout with multiple panels.
/// </summary>
public class ScreenLayout : IDisposable
{
    private readonly ITerminalService _terminal;
    private readonly ILogger<ScreenLayout> _logger;
    private readonly Dictionary<PanelPosition, Panel> _panels = new();
    
    private bool _isBelowMinimumSize;
    
    /// <summary>
    /// Minimum required terminal size for proper layout.
    /// </summary>
    public static (int Width, int Height) MinimumSize => (80, 24);
    
    /// <summary>
    /// Gets whether the current terminal size is below minimum.
    /// </summary>
    public bool IsBelowMinimumSize => _isBelowMinimumSize;
    
    /// <summary>
    /// Event raised when the layout is recalculated.
    /// </summary>
    public event Action? OnLayoutChanged;
    
    public ScreenLayout(ITerminalService terminal, ILogger<ScreenLayout> logger)
    {
        _terminal = terminal;
        _logger = logger;
        
        _terminal.OnResize += HandleResize;
        RecalculateLayout();
    }
    
    /// <summary>
    /// Gets a panel by position.
    /// </summary>
    /// <param name="position">The panel position.</param>
    /// <returns>The panel, or null if not defined.</returns>
    public Panel? GetPanel(PanelPosition position)
    {
        return _panels.TryGetValue(position, out var panel) ? panel : null;
    }
    
    /// <summary>
    /// Renders content lines to a specific panel.
    /// </summary>
    /// <param name="position">The target panel position.</param>
    /// <param name="lines">The lines to render.</param>
    public void RenderToPanel(PanelPosition position, IReadOnlyList<string> lines)
    {
        if (!_panels.TryGetValue(position, out var panel))
        {
            _logger.LogWarning("No panel defined for position {Position}", position);
            return;
        }
        
        var content = panel.ContentArea;
        
        for (var i = 0; i < Math.Min(lines.Count, content.Height); i++)
        {
            _terminal.SetCursorPosition(content.X, content.Y + i);
            
            var line = lines[i];
            if (line.Length > content.Width)
            {
                line = line[..content.Width];
            }
            else if (line.Length < content.Width)
            {
                line = line.PadRight(content.Width);
            }
            
            _terminal.Write(line);
        }
        
        // Clear remaining lines
        for (var i = lines.Count; i < content.Height; i++)
        {
            _terminal.SetCursorPosition(content.X, content.Y + i);
            _terminal.Write(new string(' ', content.Width));
        }
    }
    
    /// <summary>
    /// Clears a panel's content area.
    /// </summary>
    /// <param name="position">The panel to clear.</param>
    public void ClearPanel(PanelPosition position)
    {
        if (!_panels.TryGetValue(position, out var panel))
            return;
        
        var content = panel.ContentArea;
        _terminal.ClearRegion(content.X, content.Y, content.Width, content.Height);
    }
    
    /// <summary>
    /// Recalculates all panel positions based on current terminal size.
    /// </summary>
    public void RecalculateLayout()
    {
        var (width, height) = _terminal.GetSize();
        
        // Check minimum size
        _isBelowMinimumSize = width < MinimumSize.Width || height < MinimumSize.Height;
        
        if (_isBelowMinimumSize)
        {
            _logger.LogWarning("Terminal size {Width}x{Height} is below minimum " +
                "{MinWidth}x{MinHeight}", width, height, MinimumSize.Width, MinimumSize.Height);
        }
        
        _panels.Clear();
        
        // Calculate responsive dimensions
        var sidebarWidth = Math.Min(30, (int)(width * 0.25));
        var mainWidth = width - sidebarWidth - 3; // 3 for borders
        
        const int footerHeight = 1;
        const int inputHeight = 1;
        var contentHeight = height - footerHeight - inputHeight - 3; // 3 for borders
        
        // Define panels
        _panels[PanelPosition.MainContent] = new Panel(
            PanelPosition.MainContent,
            X: 0,
            Y: 0,
            Width: mainWidth,
            Height: contentHeight,
            Title: null,
            HasBorder: true);
        
        _panels[PanelPosition.Sidebar] = new Panel(
            PanelPosition.Sidebar,
            X: mainWidth + 1,
            Y: 0,
            Width: sidebarWidth,
            Height: contentHeight,
            Title: "Status",
            HasBorder: true);
        
        _panels[PanelPosition.Footer] = new Panel(
            PanelPosition.Footer,
            X: 0,
            Y: contentHeight,
            Width: width,
            Height: footerHeight + 2, // Include border
            Title: null,
            HasBorder: true);
        
        _panels[PanelPosition.Input] = new Panel(
            PanelPosition.Input,
            X: 0,
            Y: height - inputHeight,
            Width: width,
            Height: inputHeight,
            Title: null,
            HasBorder: false);
        
        _logger.LogDebug("Layout recalculated: Main={MainW}x{MainH}, " +
            "Sidebar={SidebarW}, Footer={FooterH}",
            mainWidth, contentHeight, sidebarWidth, footerHeight);
        
        OnLayoutChanged?.Invoke();
    }
    
    /// <summary>
    /// Draws borders for all panels.
    /// </summary>
    public void DrawBorders()
    {
        foreach (var (position, panel) in _panels)
        {
            if (panel.HasBorder)
            {
                DrawPanelBorder(panel);
            }
        }
    }
    
    private void DrawPanelBorder(Panel panel)
    {
        var useUnicode = _terminal.SupportsUnicode;
        
        // Box-drawing characters
        var horizontal = useUnicode ? '─' : '-';
        var vertical = useUnicode ? '│' : '|';
        var topLeft = useUnicode ? '┌' : '+';
        var topRight = useUnicode ? '┐' : '+';
        var bottomLeft = useUnicode ? '└' : '+';
        var bottomRight = useUnicode ? '┘' : '+';
        
        // Top border
        _terminal.SetCursorPosition(panel.X, panel.Y);
        _terminal.Write(topLeft.ToString());
        
        if (panel.Title != null)
        {
            var titleSpace = panel.Width - 4;
            var truncatedTitle = panel.Title.Length > titleSpace 
                ? panel.Title[..(titleSpace - 3)] + "..." 
                : panel.Title;
            var padding = (panel.Width - 2 - truncatedTitle.Length) / 2;
            
            _terminal.Write(new string(horizontal, padding));
            _terminal.Write($" {truncatedTitle} ");
            _terminal.Write(new string(horizontal, panel.Width - 2 - padding - truncatedTitle.Length - 2));
        }
        else
        {
            _terminal.Write(new string(horizontal, panel.Width - 2));
        }
        _terminal.Write(topRight.ToString());
        
        // Side borders
        for (var row = 1; row < panel.Height - 1; row++)
        {
            _terminal.SetCursorPosition(panel.X, panel.Y + row);
            _terminal.Write(vertical.ToString());
            _terminal.SetCursorPosition(panel.X + panel.Width - 1, panel.Y + row);
            _terminal.Write(vertical.ToString());
        }
        
        // Bottom border
        _terminal.SetCursorPosition(panel.X, panel.Y + panel.Height - 1);
        _terminal.Write(bottomLeft.ToString());
        _terminal.Write(new string(horizontal, panel.Width - 2));
        _terminal.Write(bottomRight.ToString());
    }
    
    private void HandleResize((int Width, int Height) newSize)
    {
        _terminal.Clear();
        RecalculateLayout();
        DrawBorders();
    }
    
    public void Dispose()
    {
        _terminal.OnResize -= HandleResize;
    }
}
```

### 6.2 Layout Calculation Algorithm

```
RESPONSIVE LAYOUT ALGORITHM:
────────────────────────────

INPUT: Terminal size (width, height)

1. VALIDATE MINIMUM SIZE
   IF width < 80 OR height < 24:
     Set IsBelowMinimumSize = true
     Log warning
   ELSE:
     Set IsBelowMinimumSize = false

2. CALCULATE SIDEBAR WIDTH
   sidebarWidth = MIN(30, width * 0.25)
   // Sidebar is 25% of width, max 30 chars

3. CALCULATE MAIN CONTENT WIDTH  
   mainWidth = width - sidebarWidth - 3
   // Subtract sidebar and border chars

4. CALCULATE HEIGHTS
   footerHeight = 1
   inputHeight = 1
   contentHeight = height - footerHeight - inputHeight - 3
   // Subtract footer, input, and borders

5. CREATE PANELS
   MainContent: (0, 0, mainWidth, contentHeight)
   Sidebar: (mainWidth+1, 0, sidebarWidth, contentHeight)
   Footer: (0, contentHeight, width, footerHeight+2)
   Input: (0, height-1, width, inputHeight)

6. FIRE OnLayoutChanged EVENT
```

---

## 7. Data Model

### 7.1 New Entities

| Entity | Layer | Description |
|--------|-------|-------------|
| `Panel` | Presentation | Value object for panel dimensions |
| `PanelPosition` | Presentation | Enum for panel positions |

### 7.2 New Interfaces

| Interface | Layer | Description |
|-----------|-------|-------------|
| `ITerminalService` | Application | Terminal abstraction |

### 7.3 New Services

| Service | Layer | Description |
|---------|-------|-------------|
| `TerminalService` | Infrastructure | Console wrapper |
| `ScreenLayout` | Presentation | Layout manager |

---

## 8. Configuration

### 8.1 Layout Configuration (Optional)

**File:** `config/ui-layout.json`

```json
{
  "$schema": "./schemas/ui-layout.schema.json",
  "layout": {
    "minimumSize": {
      "width": 80,
      "height": 24
    },
    "sidebar": {
      "maxWidth": 30,
      "widthPercent": 25
    },
    "footer": {
      "height": 1
    },
    "input": {
      "height": 1
    },
    "borders": {
      "unicode": {
        "horizontal": "─",
        "vertical": "│",
        "topLeft": "┌",
        "topRight": "┐",
        "bottomLeft": "└",
        "bottomRight": "┘"
      },
      "ascii": {
        "horizontal": "-",
        "vertical": "|",
        "topLeft": "+",
        "topRight": "+",
        "bottomLeft": "+",
        "bottomRight": "+"
      }
    }
  }
}
```

### 8.2 Configuration Schema

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `minimumSize.width` | int | 80 | Minimum terminal width |
| `minimumSize.height` | int | 24 | Minimum terminal height |
| `sidebar.maxWidth` | int | 30 | Maximum sidebar width |
| `sidebar.widthPercent` | int | 25 | Sidebar width as % of terminal |
| `footer.height` | int | 1 | Footer content height |
| `input.height` | int | 1 | Input line height |

---

## 9. Logging Specifications

### 9.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `TerminalService` | Debug | Initialization, resize detection |
| `TerminalService` | Warning | Invalid cursor position |
| `ScreenLayout` | Debug | Layout recalculation |
| `ScreenLayout` | Warning | Below minimum size, missing panel |

### 9.2 Log Message Templates

```csharp
// TerminalService
_logger.LogDebug("TerminalService initialized: {Width}x{Height}, Color={Color}, Unicode={Unicode}",
    width, height, supportsColor, supportsUnicode);

_logger.LogDebug("Terminal resized: {OldWidth}x{OldHeight} -> {NewWidth}x{NewHeight}",
    oldWidth, oldHeight, newWidth, newHeight);

// ScreenLayout
_logger.LogDebug("Layout recalculated: Main={MainW}x{MainH}, Sidebar={SidebarW}",
    mainWidth, contentHeight, sidebarWidth);

_logger.LogWarning("Terminal size {Width}x{Height} is below minimum {MinWidth}x{MinHeight}",
    width, height, minWidth, minHeight);
```

---

## 10. Unit Testing Requirements

### 10.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| ITerminalService (mock) | 3 |
| Panel value object | 3 |
| ScreenLayout | 6 |
| **Total** | **~12** |

### 10.2 Test Specifications

#### TerminalServiceTests.cs

```csharp
[TestFixture]
public class TerminalServiceTests
{
    [Test]
    public void GetSize_ReturnsPositiveDimensions();
    
    [Test]
    public void SupportsColor_ReturnsBoolean();
    
    [Test]
    public void OnResize_FiresWhenSizeChanges();
}
```

#### PanelTests.cs

```csharp
[TestFixture]
public class PanelTests
{
    [Test]
    public void ContentArea_WithBorder_ReducesDimensionsByTwo();
    
    [Test]
    public void ContentArea_WithoutBorder_ReturnsSameDimensions();
    
    [Test]
    public void ContainsPoint_WithPointInside_ReturnsTrue();
}
```

#### ScreenLayoutTests.cs

```csharp
[TestFixture]
public class ScreenLayoutTests
{
    [Test]
    public void RecalculateLayout_CreatesAllPanels();
    
    [Test]
    public void RecalculateLayout_WithMinimumSize_SetsIsBelowMinimumSizeFalse();
    
    [Test]
    public void RecalculateLayout_BelowMinimumSize_SetsIsBelowMinimumSizeTrue();
    
    [Test]
    public void GetPanel_WithValidPosition_ReturnsPanel();
    
    [Test]
    public void GetPanel_WithUnknownPosition_ReturnsNull();
    
    [Test]
    public void DrawBorders_RendersToTerminal();
}
```

---

## 11. Use Cases

### UC-001: Initialize Screen Layout
**Actor:** System
**Flow:** Application start → Create TerminalService → Create ScreenLayout → RecalculateLayout → DrawBorders → Ready

### UC-002: Handle Terminal Resize
**Actor:** System
**Flow:** User resizes terminal → OnResize fires → HandleResize → Clear → RecalculateLayout → DrawBorders → Re-render content

### UC-003: Render Content to Panel
**Actor:** Game Engine
**Flow:** Content ready → RenderToPanel(position, lines) → Calculate content area → Write lines → Pad/truncate as needed

### UC-004: Detect Below Minimum Size
**Actor:** System
**Flow:** RecalculateLayout → Check size < 80x24 → Set IsBelowMinimumSize → Log warning → Continue with constrained layout

---

## 12. Deliverable Checklist

### Terminal Abstraction
- [ ] `ITerminalService` interface created
- [ ] `TerminalService` implementation created
- [ ] Resize polling implemented
- [ ] Color capability detection implemented
- [ ] Unicode capability detection implemented

### Panel System
- [ ] `Panel` value object created
- [ ] `PanelPosition` enum created
- [ ] ContentArea calculation implemented
- [ ] ContainsPoint method implemented

### Screen Layout
- [ ] `ScreenLayout` class created
- [ ] Panel dictionary management implemented
- [ ] RecalculateLayout implemented
- [ ] RenderToPanel implemented
- [ ] ClearPanel implemented
- [ ] DrawBorders implemented
- [ ] HandleResize implemented
- [ ] OnLayoutChanged event implemented
- [ ] Minimum size validation implemented

### Configuration
- [ ] `config/ui-layout.json` created (optional)

### Testing
- [ ] ~12 unit tests implemented
- [ ] All tests passing

---

## 13. Acceptance Criteria

### Functional
- [ ] TerminalService wraps Console operations correctly
- [ ] Terminal size detection returns valid dimensions
- [ ] Resize events fire when terminal size changes
- [ ] Panel positions calculate correctly for various sizes
- [ ] ScreenLayout creates all four standard panels
- [ ] Content renders to correct panel positions
- [ ] Borders draw with correct box characters
- [ ] Unicode borders used when supported
- [ ] ASCII fallback works when Unicode not supported
- [ ] Minimum size (80x24) validation works
- [ ] Layout responds to terminal resize

### Quality
- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~12 unit tests pass
- [ ] XML documentation complete on all public members

---

## 14. Dependencies

### Required from v0.5.3c

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `System.Console` | .NET BCL | Terminal operations |
| `ILogger<T>` | Microsoft.Extensions.Logging | Logging |

### Provides to v0.6.0b

| Type | Usage |
|------|-------|
| `ITerminalService` | Status bar terminal access |
| `ScreenLayout` | Status bar renders to Footer panel |
| `Panel` | Status bar checks panel dimensions |
| `PanelPosition.Footer` | Status bar target position |

### Provides to v0.6.0c

| Type | Usage |
|------|-------|
| `ITerminalService` | Color output operations |
| `TerminalService.SupportsColor` | Color theme fallback logic |

---

## 15. Future Considerations

### Deferred to v0.6.0b
- **Status Bar Content**: HP/MP/XP/Gold display (next phase)

### Deferred to v0.6.0c
- **Color Output**: Colored text rendering (color themes phase)

### Out of Scope
- **Custom Layouts**: User-configurable panel positions (future major version)
- **Floating Windows**: Draggable/resizable popup panels (future)
- **Pixel-Based Rendering**: Sub-character positioning (GUI only)

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: Assistant*
