# v0.10.0 Status Effects System - Scope Breakdown

**Version:** 0.10.0
**Theme:** Status Effects System
**Prerequisites:** v0.9.2c Complete (Audio & Atmosphere - UI & Interaction Sounds)
**Total Estimated Tests:** ~40 new tests

---

## Executive Summary

The Status Effects System sub-version implements an enhanced data-driven buff/debuff system with configurable definitions, stacking rules, effect triggers, and cleanse mechanics. Status effects can modify stats, deal damage over time, heal over time, prevent actions, and interact with other effects. This system provides the foundation for tactical combat depth.

Key focus areas:
- **Effect Definitions**: Data-driven status effect configuration
- **Effect Management**: Application, stacking, duration, and removal
- **Effect Triggers**: Turn-based ticking and event-based triggers

The work is divided into **three sub-parts**:

| Part | Name | Focus | Est. Tests |
|------|------|-------|------------|
| v0.10.0a | Status Effect Definitions | StatusEffectDefinition, enums, configuration | ~15 |
| v0.10.0b | Buff/Debuff Service | Application, stacking, duration, removal | ~15 |
| v0.10.0c | Effect Triggers & Cleanse | Tick effects, triggers, immunity, cleanse | ~10 |

---

## Existing Infrastructure

### Already Implemented (from v0.5.x)

| Feature | Location | Notes |
|---------|----------|-------|
| CombatService | `Application/Services/CombatService.cs` | Combat flow |
| TurnService | `Application/Services/TurnService.cs` | Turn management |
| Combatant | `Domain/Entities/Combatant.cs` | Combat participants |
| Player | `Domain/Entities/Player.cs` | Player entity |
| Monster | `Domain/Entities/Monster.cs` | Monster entity |

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| Stats | `Domain/ValueObjects/Stats.cs` | Stat system |
| DamageService | `Application/Services/DamageService.cs` | Damage application |
| EventBus | `Application/Services/EventBus.cs` | Event system |
| IConfigurationProvider | `Application/Interfaces/IConfigurationProvider.cs` | Config loading |

### Needs Implementation (v0.10.0)

| Feature | Part | Notes |
|---------|------|-------|
| StatusEffectDefinition | v0.10.0a | Effect template |
| ActiveStatusEffect | v0.10.0a | Effect instance |
| EffectType enum | v0.10.0a | Effect categories |
| StackingRule enum | v0.10.0a | Stacking behavior |
| IBuffDebuffService | v0.10.0b | Service interface |
| BuffDebuffService | v0.10.0b | Service implementation |
| EffectTriggerAction | v0.10.0c | Trigger definitions |
| StatusEffectTriggerHandler | v0.10.0c | Event handling |

---

## Feature Analysis & Categorization

### Definition Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| StatusEffectDefinition entity | Medium | Domain | **v0.10.0a** |
| ActiveStatusEffect entity | Medium | Definition | **v0.10.0a** |
| EffectType enum | Low | None | **v0.10.0a** |
| StackingRule enum | Low | None | **v0.10.0a** |
| StatModifier value object | Medium | Stats | **v0.10.0a** |
| status-effects.json config | Medium | Config | **v0.10.0a** |

### Management Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| Effect application | High | Definitions | **v0.10.0b** |
| Stacking logic | High | Rules | **v0.10.0b** |
| Duration tracking | Medium | Turn system | **v0.10.0b** |
| Effect removal | Medium | Tracking | **v0.10.0b** |
| Stat modifier application | High | Stats | **v0.10.0b** |
| Active effects tracking | Medium | Entity | **v0.10.0b** |

### Trigger Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| Turn-based ticking | Medium | Turns | **v0.10.0c** |
| OnApply triggers | Medium | Events | **v0.10.0c** |
| OnTick triggers | Medium | Events | **v0.10.0c** |
| OnExpire triggers | Medium | Events | **v0.10.0c** |
| Immunity system | Medium | Definitions | **v0.10.0c** |
| Cleanse mechanics | Medium | Service | **v0.10.0c** |

---

## Part Definitions

---

## v0.10.0a: Status Effect Definitions

[v0.10.0a Design Specification](v0.10.0a-design-specification.md)

### Overview

Define the core status effect entities and configuration. This includes the StatusEffectDefinition entity that serves as a template for effects, the ActiveStatusEffect entity that tracks applied instances, supporting enums for effect types and stacking rules, and the JSON configuration for defining effects.

### Scope

**In Scope:**
- `StatusEffectDefinition` entity
- `ActiveStatusEffect` entity
- `EffectType` enum (StatModifier, DoT, HoT, ActionPrevention, Movement, Special)
- `StackingRule` enum (None, Stack, Replace, Refresh)
- `StatModifier` value object
- `EffectTriggerAction` value object
- `status-effects.json` configuration schema
- Effect definitions: poison, burning, blessed, stunned, haste, etc.
- IStatusEffectProvider interface for loading
- StatusEffectProvider implementation

**Out of Scope:**
- Effect application logic (v0.10.0b)
- Tick/trigger execution (v0.10.0c)
- UI display (separate)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 2 | `StatusEffectDefinition`, `ActiveStatusEffect` |
| Domain Enums | 2 | `EffectType`, `StackingRule` |
| Value Objects | 2 | `StatModifier`, `EffectTriggerAction` |
| Interfaces | 1 | `IStatusEffectProvider` |
| Infrastructure | 1 | `StatusEffectProvider` |
| Configuration | 1 | `status-effects.json` |
| Unit Tests | ~15 | Definition loading, validation |

### Status Effect Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                 STATUS EFFECT DEFINITION ARCHITECTURE                │
└─────────────────────────────────────────────────────────────────────┘

     Configuration                    Domain                    
     ─────────────                    ──────                    

   status-effects.json          ┌─────────────────────────┐
   ┌─────────────────┐          │  StatusEffectDefinition │
   │ {                │          ├─────────────────────────┤
   │   "id": "poison",│  ─────▶  │ + EffectId: string      │
   │   "name": "...", │          │ + Name: string          │
   │   "type": "DoT", │          │ + Type: EffectType      │
   │   "duration": 5, │          │ + IsBuff: bool          │
   │   "stacking": ..│          │ + BaseDuration: int     │
   │ }                │          │ + Stacking: StackingRule│
   └─────────────────┘          │ + MaxStacks: int        │
                                 │ + StatModifiers: list   │
                                 │ + Triggers: list        │
                                 │ + ImmunityIds: list     │
                                 └─────────────────────────┘
                                              │
                                              │ instantiates
                                              ▼
                                 ┌─────────────────────────┐
                                 │   ActiveStatusEffect    │
                                 ├─────────────────────────┤
                                 │ + DefinitionId: string  │
                                 │ + TargetId: Guid        │
                                 │ + SourceId: Guid        │
                                 │ + RemainingDuration: int│
                                 │ + CurrentStacks: int    │
                                 │ + AppliedAt: DateTime   │
                                 │ + TickCount: int        │
                                 └─────────────────────────┘
```

### StatusEffectDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Data-driven status effect template loaded from configuration.
/// </summary>
public class StatusEffectDefinition : IEntity
{
    public Guid Id { get; private set; }
    public string EffectId { get; private set; } = null!;
    public string Name { get; private set; } = null!;
    public string Description { get; private set; } = null!;
    public EffectType Type { get; private set; }
    public bool IsBuff { get; private set; }
    public int BaseDuration { get; private set; }
    public StackingRule Stacking { get; private set; }
    public int MaxStacks { get; private set; } = 1;
    public IReadOnlyList<StatModifier> StatModifiers { get; private set; } = [];
    public IReadOnlyList<EffectTriggerAction> Triggers { get; private set; } = [];
    public IReadOnlyList<string> ImmunityIds { get; private set; } = [];
    public IReadOnlyList<string> PreventsActions { get; private set; } = [];
    public string? IconPath { get; private set; }
    
    // Private constructor for EF Core
    private StatusEffectDefinition() { }
    
    public static StatusEffectDefinition Create(
        string effectId,
        string name,
        string description,
        EffectType type,
        bool isBuff,
        int baseDuration,
        StackingRule stacking = StackingRule.None,
        int maxStacks = 1)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(effectId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentOutOfRangeException.ThrowIfNegative(baseDuration);
        
        return new StatusEffectDefinition
        {
            Id = Guid.NewGuid(),
            EffectId = effectId.ToLowerInvariant(),
            Name = name,
            Description = description,
            Type = type,
            IsBuff = isBuff,
            BaseDuration = baseDuration,
            Stacking = stacking,
            MaxStacks = maxStacks
        };
    }
}
```

### ActiveStatusEffect Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// An active status effect instance applied to a combatant.
/// </summary>
public class ActiveStatusEffect : IEntity
{
    public Guid Id { get; private set; }
    public string DefinitionId { get; private set; } = null!;
    public Guid TargetId { get; private set; }
    public Guid SourceId { get; private set; }
    public int RemainingDuration { get; private set; }
    public int CurrentStacks { get; private set; }
    public DateTime AppliedAt { get; private set; }
    public int TickCount { get; private set; }
    
    // Private constructor for EF Core
    private ActiveStatusEffect() { }
    
    public static ActiveStatusEffect Create(
        StatusEffectDefinition definition,
        Guid targetId,
        Guid sourceId)
    {
        ArgumentNullException.ThrowIfNull(definition);
        
        return new ActiveStatusEffect
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.EffectId,
            TargetId = targetId,
            SourceId = sourceId,
            RemainingDuration = definition.BaseDuration,
            CurrentStacks = 1,
            AppliedAt = DateTime.UtcNow,
            TickCount = 0
        };
    }
    
    /// <summary>Decrements duration by one turn.</summary>
    public bool Tick()
    {
        TickCount++;
        RemainingDuration--;
        return RemainingDuration <= 0;
    }
    
    /// <summary>Adds stacks up to max.</summary>
    public void AddStacks(int count, int maxStacks)
    {
        CurrentStacks = Math.Min(CurrentStacks + count, maxStacks);
    }
    
    /// <summary>Refreshes duration to the base value.</summary>
    public void RefreshDuration(int baseDuration)
    {
        RemainingDuration = baseDuration;
    }
    
    /// <summary>Returns whether this effect has expired.</summary>
    public bool IsExpired => RemainingDuration <= 0;
}
```

### Effect Type Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categories of status effects determining their behavior.
/// </summary>
public enum EffectType
{
    /// <summary>Modifies one or more stats.</summary>
    StatModifier,
    
    /// <summary>Deals damage each turn.</summary>
    DamageOverTime,
    
    /// <summary>Heals each turn.</summary>
    HealOverTime,
    
    /// <summary>Prevents certain actions (stun, freeze, silence).</summary>
    ActionPrevention,
    
    /// <summary>Affects movement (slow, haste, root).</summary>
    Movement,
    
    /// <summary>Custom/special effects.</summary>
    Special
}
```

### Stacking Rule Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Rules for how status effects stack when reapplied.
/// </summary>
public enum StackingRule
{
    /// <summary>Cannot stack, new application refreshes duration only.</summary>
    None,
    
    /// <summary>Stacks up to MaxStacks, each stack has full effect.</summary>
    Stack,
    
    /// <summary>New effect replaces existing one entirely.</summary>
    Replace,
    
    /// <summary>Refreshes duration without adding stacks.</summary>
    Refresh
}
```

### StatModifier Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a stat modification applied by a status effect.
/// </summary>
public readonly record struct StatModifier
{
    /// <summary>The stat being modified.</summary>
    public string StatId { get; init; }
    
    /// <summary>The operation to apply.</summary>
    public ModifierOperation Operation { get; init; }
    
    /// <summary>The value for the operation.</summary>
    public int Value { get; init; }
    
    /// <summary>Whether the value scales per stack.</summary>
    public bool PerStack { get; init; }
    
    public static StatModifier Add(string statId, int value, bool perStack = false)
        => new() { StatId = statId, Operation = ModifierOperation.Add, Value = value, PerStack = perStack };
    
    public static StatModifier Multiply(string statId, int percentBonus, bool perStack = false)
        => new() { StatId = statId, Operation = ModifierOperation.Multiply, Value = percentBonus, PerStack = perStack };
}

public enum ModifierOperation
{
    Add,       // Stat + Value
    Multiply,  // Stat * (1 + Value/100)
    Set        // Stat = Value
}
```

### Status Effects Configuration

```json
{
  "$schema": "./schemas/status-effects.schema.json",
  "statusEffects": [
    {
      "id": "poison",
      "name": "Poison",
      "description": "Taking damage each turn from poison.",
      "type": "DamageOverTime",
      "isBuff": false,
      "baseDuration": 5,
      "stacking": "Stack",
      "maxStacks": 3,
      "triggers": [
        {
          "timing": "OnTurnStart",
          "action": "Damage",
          "value": "1d4",
          "damageType": "poison",
          "perStack": true
        }
      ],
      "icon": "icons/effects/poison.png"
    },
    {
      "id": "burning",
      "name": "Burning",
      "description": "On fire, taking fire damage.",
      "type": "DamageOverTime",
      "isBuff": false,
      "baseDuration": 3,
      "stacking": "Refresh",
      "triggers": [
        {
          "timing": "OnTurnEnd",
          "action": "Damage",
          "value": "2d6",
          "damageType": "fire"
        }
      ],
      "icon": "icons/effects/burning.png"
    },
    {
      "id": "regeneration",
      "name": "Regeneration",
      "description": "Healing each turn.",
      "type": "HealOverTime",
      "isBuff": true,
      "baseDuration": 5,
      "stacking": "None",
      "triggers": [
        {
          "timing": "OnTurnStart",
          "action": "Heal",
          "value": "1d8+2"
        }
      ],
      "icon": "icons/effects/regeneration.png"
    },
    {
      "id": "blessed",
      "name": "Blessed",
      "description": "+2 to all saving throws.",
      "type": "StatModifier",
      "isBuff": true,
      "baseDuration": 10,
      "stacking": "None",
      "statModifiers": [
        { "stat": "fortitudeSave", "operation": "Add", "value": 2 },
        { "stat": "reflexSave", "operation": "Add", "value": 2 },
        { "stat": "willSave", "operation": "Add", "value": 2 }
      ],
      "icon": "icons/effects/blessed.png"
    },
    {
      "id": "stunned",
      "name": "Stunned",
      "description": "Cannot take actions.",
      "type": "ActionPrevention",
      "isBuff": false,
      "baseDuration": 1,
      "stacking": "None",
      "preventsActions": ["attack", "move", "ability", "item"],
      "immunityIds": ["stunned"],
      "icon": "icons/effects/stunned.png"
    },
    {
      "id": "slowed",
      "name": "Slowed",
      "description": "Movement reduced by 50%.",
      "type": "Movement",
      "isBuff": false,
      "baseDuration": 3,
      "stacking": "Refresh",
      "statModifiers": [
        { "stat": "movementSpeed", "operation": "Multiply", "value": -50 }
      ],
      "icon": "icons/effects/slowed.png"
    },
    {
      "id": "haste",
      "name": "Haste",
      "description": "Extra action per turn.",
      "type": "Special",
      "isBuff": true,
      "baseDuration": 3,
      "stacking": "Refresh",
      "effects": [
        { "type": "ExtraAction", "value": 1 }
      ],
      "icon": "icons/effects/haste.png"
    },
    {
      "id": "strength-up",
      "name": "Strength Up",
      "description": "+2 Strength per stack.",
      "type": "StatModifier",
      "isBuff": true,
      "baseDuration": 5,
      "stacking": "Stack",
      "maxStacks": 3,
      "statModifiers": [
        { "stat": "strength", "operation": "Add", "value": 2, "perStack": true }
      ],
      "icon": "icons/effects/strength-up.png"
    }
  ]
}
```

### Acceptance Criteria

- [ ] StatusEffectDefinition loads from JSON
- [ ] All effect types are supported
- [ ] All stacking rules are defined
- [ ] StatModifier supports add/multiply/set
- [ ] ActiveStatusEffect tracks state
- [ ] Duration tracking works
- [ ] Stack counting works
- [ ] Tick count increments
- [ ] Effect expiration detected
- [ ] IStatusEffectProvider loads definitions
- [ ] ~15 unit tests pass

---

## v0.10.0b: Buff/Debuff Service

[v0.10.0b Design Specification](v0.10.0b-design-specification.md)

### Overview

Implement the core service for applying, managing, and removing status effects. This includes the IBuffDebuffService interface, BuffDebuffService implementation, stacking logic, stat modifier application/removal, and active effect tracking on entities.

### Scope

**In Scope:**
- `IBuffDebuffService` interface
- `BuffDebuffService` implementation
- `ApplyEffect(target, effectId, source)` method
- `RemoveEffect(target, effectId)` method
- `GetActiveEffects(target)` method
- `HasEffect(target, effectId)` method
- Stacking logic (stack, refresh, replace)
- Stat modifier application
- Stat modifier removal on expire
- Active effects collection on Combatant
- Effect events (OnEffectApplied, OnEffectRemoved)
- ApplyResult record for application feedback

**Out of Scope:**
- Effect definitions (v0.10.0a)
- Tick/trigger execution (v0.10.0c)
- Immunity system (v0.10.0c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Interfaces | 1 | `IBuffDebuffService` |
| Services | 1 | `BuffDebuffService` |
| Result Types | 1 | `ApplyResult` |
| Entity Updates | 1 | Combatant with effects collection |
| Events | 2 | `EffectAppliedEvent`, `EffectRemovedEvent` |
| Unit Tests | ~15 | Application, stacking, removal tests |

### BuffDebuffService Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                    BUFF/DEBUFF SERVICE ARCHITECTURE                  │
└─────────────────────────────────────────────────────────────────────┘

                      ┌───────────────────────────────┐
                      │       Combat System            │
                      │   (Abilities, Items, etc.)     │
                      └───────────────┬───────────────┘
                                      │
                                      ▼
                      ┌───────────────────────────────┐
                      │      IBuffDebuffService        │
                      ├───────────────────────────────┤
                      │ + ApplyEffect(target, id)     │
                      │ + RemoveEffect(target, id)    │
                      │ + GetActiveEffects(target)    │
                      │ + HasEffect(target, id)       │
                      │ + ClearEffects(target, type?) │
                      └───────────────┬───────────────┘
                                      │
                      ┌───────────────┴───────────────┐
                      │       BuffDebuffService        │
                      ├───────────────────────────────┤
                      │ - _effectProvider             │
                      │ - _statService                │
                      │ - _eventBus                   │
                      │                               │
                      │ + ProcessStacking()           │
                      │ + ApplyStatModifiers()        │
                      │ + RemoveStatModifiers()       │
                      └───────────────────────────────┘
                               │           │
                               ▼           ▼
              ┌─────────────────────┐  ┌─────────────────────┐
              │ IStatusEffectProvider│  │    IStatService     │
              │   (get definitions)  │  │ (apply/remove mods) │
              └─────────────────────┘  └─────────────────────┘
```

### IBuffDebuffService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing status effects on combat entities.
/// </summary>
public interface IBuffDebuffService
{
    /// <summary>Applies a status effect to a target.</summary>
    /// <param name="target">The entity to apply the effect to.</param>
    /// <param name="effectId">The effect definition ID.</param>
    /// <param name="source">The source entity applying the effect.</param>
    /// <returns>Result of the application attempt.</returns>
    ApplyResult ApplyEffect(ICombatant target, string effectId, ICombatant? source = null);
    
    /// <summary>Removes a specific effect from a target.</summary>
    /// <param name="target">The entity to remove the effect from.</param>
    /// <param name="effectId">The effect definition ID to remove.</param>
    /// <returns>True if the effect was removed.</returns>
    bool RemoveEffect(ICombatant target, string effectId);
    
    /// <summary>Removes all stacks of an effect from a target.</summary>
    bool RemoveAllStacks(ICombatant target, string effectId);
    
    /// <summary>Clears all effects of a given type from a target.</summary>
    /// <param name="target">The entity to clear effects from.</param>
    /// <param name="type">Optional type filter (null = all).</param>
    /// <returns>Number of effects removed.</returns>
    int ClearEffects(ICombatant target, EffectType? type = null);
    
    /// <summary>Clears all debuffs from a target.</summary>
    int ClearDebuffs(ICombatant target);
    
    /// <summary>Gets all active effects on a target.</summary>
    IReadOnlyList<ActiveStatusEffect> GetActiveEffects(ICombatant target);
    
    /// <summary>Gets active effects of a specific type.</summary>
    IReadOnlyList<ActiveStatusEffect> GetActiveEffects(ICombatant target, EffectType type);
    
    /// <summary>Checks if a target has a specific effect.</summary>
    bool HasEffect(ICombatant target, string effectId);
    
    /// <summary>Gets the current stack count of an effect.</summary>
    int GetStackCount(ICombatant target, string effectId);
    
    /// <summary>Gets the remaining duration of an effect.</summary>
    int GetRemainingDuration(ICombatant target, string effectId);
}
```

### BuffDebuffService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class BuffDebuffService : IBuffDebuffService
{
    private readonly IStatusEffectProvider _effectProvider;
    private readonly IStatModifierService _statService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<BuffDebuffService> _logger;
    
    public BuffDebuffService(
        IStatusEffectProvider effectProvider,
        IStatModifierService statService,
        IEventBus eventBus,
        ILogger<BuffDebuffService> logger)
    {
        _effectProvider = effectProvider;
        _statService = statService;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public ApplyResult ApplyEffect(ICombatant target, string effectId, ICombatant? source = null)
    {
        var definition = _effectProvider.GetEffect(effectId);
        if (definition is null)
        {
            _logger.LogWarning("Effect not found: {EffectId}", effectId);
            return ApplyResult.Failed($"Effect '{effectId}' not found");
        }
        
        var existingEffect = target.ActiveEffects.FirstOrDefault(e => e.DefinitionId == effectId);
        
        if (existingEffect is not null)
        {
            return ProcessStacking(target, existingEffect, definition, source);
        }
        
        // Apply new effect
        var newEffect = ActiveStatusEffect.Create(definition, target.Id, source?.Id ?? Guid.Empty);
        target.AddStatusEffect(newEffect);
        
        // Apply stat modifiers
        ApplyStatModifiers(target, definition, newEffect.CurrentStacks);
        
        _logger.LogInformation("Applied {Effect} to {Target}", effectId, target.Name);
        _eventBus.Publish(new EffectAppliedEvent(target.Id, effectId, source?.Id));
        
        return ApplyResult.Success(newEffect);
    }
    
    private ApplyResult ProcessStacking(
        ICombatant target, 
        ActiveStatusEffect existing, 
        StatusEffectDefinition definition,
        ICombatant? source)
    {
        switch (definition.Stacking)
        {
            case StackingRule.None:
                // Refresh duration only
                existing.RefreshDuration(definition.BaseDuration);
                _logger.LogDebug("Refreshed {Effect} on {Target}", definition.EffectId, target.Name);
                return ApplyResult.Refreshed(existing);
            
            case StackingRule.Stack:
                if (existing.CurrentStacks < definition.MaxStacks)
                {
                    // Remove old modifiers, add stack, reapply
                    RemoveStatModifiers(target, definition, existing.CurrentStacks);
                    existing.AddStacks(1, definition.MaxStacks);
                    existing.RefreshDuration(definition.BaseDuration);
                    ApplyStatModifiers(target, definition, existing.CurrentStacks);
                    
                    _logger.LogDebug("Stacked {Effect} on {Target} ({Stacks}/{Max})", 
                        definition.EffectId, target.Name, existing.CurrentStacks, definition.MaxStacks);
                    return ApplyResult.Stacked(existing);
                }
                else
                {
                    // At max stacks, just refresh
                    existing.RefreshDuration(definition.BaseDuration);
                    return ApplyResult.AtMaxStacks(existing);
                }
            
            case StackingRule.Replace:
                // Remove old, apply new
                RemoveStatModifiers(target, definition, existing.CurrentStacks);
                target.RemoveStatusEffect(existing);
                
                var newEffect = ActiveStatusEffect.Create(definition, target.Id, source?.Id ?? Guid.Empty);
                target.AddStatusEffect(newEffect);
                ApplyStatModifiers(target, definition, 1);
                
                _logger.LogDebug("Replaced {Effect} on {Target}", definition.EffectId, target.Name);
                return ApplyResult.Replaced(newEffect);
            
            case StackingRule.Refresh:
                existing.RefreshDuration(definition.BaseDuration);
                return ApplyResult.Refreshed(existing);
            
            default:
                return ApplyResult.Failed("Unknown stacking rule");
        }
    }
    
    public bool RemoveEffect(ICombatant target, string effectId)
    {
        var effect = target.ActiveEffects.FirstOrDefault(e => e.DefinitionId == effectId);
        if (effect is null) return false;
        
        var definition = _effectProvider.GetEffect(effectId);
        if (definition is not null)
        {
            RemoveStatModifiers(target, definition, effect.CurrentStacks);
        }
        
        target.RemoveStatusEffect(effect);
        _logger.LogInformation("Removed {Effect} from {Target}", effectId, target.Name);
        _eventBus.Publish(new EffectRemovedEvent(target.Id, effectId));
        
        return true;
    }
    
    private void ApplyStatModifiers(ICombatant target, StatusEffectDefinition definition, int stacks)
    {
        foreach (var modifier in definition.StatModifiers)
        {
            var value = modifier.PerStack ? modifier.Value * stacks : modifier.Value;
            _statService.ApplyModifier(target, modifier.StatId, modifier.Operation, value, definition.EffectId);
        }
    }
    
    private void RemoveStatModifiers(ICombatant target, StatusEffectDefinition definition, int stacks)
    {
        foreach (var modifier in definition.StatModifiers)
        {
            _statService.RemoveModifier(target, modifier.StatId, definition.EffectId);
        }
    }
    
    public IReadOnlyList<ActiveStatusEffect> GetActiveEffects(ICombatant target)
    {
        return target.ActiveEffects.ToList();
    }
    
    public bool HasEffect(ICombatant target, string effectId)
    {
        return target.ActiveEffects.Any(e => e.DefinitionId == effectId);
    }
}
```

### ApplyResult Record

```csharp
namespace RuneAndRust.Application.Results;

/// <summary>
/// Result of attempting to apply a status effect.
/// </summary>
public record ApplyResult(
    bool IsSuccess,
    ApplyResultType ResultType,
    ActiveStatusEffect? Effect,
    string? Message)
{
    public static ApplyResult Success(ActiveStatusEffect effect)
        => new(true, ApplyResultType.Applied, effect, null);
    
    public static ApplyResult Stacked(ActiveStatusEffect effect)
        => new(true, ApplyResultType.Stacked, effect, null);
    
    public static ApplyResult Refreshed(ActiveStatusEffect effect)
        => new(true, ApplyResultType.Refreshed, effect, null);
    
    public static ApplyResult Replaced(ActiveStatusEffect effect)
        => new(true, ApplyResultType.Replaced, effect, null);
    
    public static ApplyResult AtMaxStacks(ActiveStatusEffect effect)
        => new(true, ApplyResultType.AtMaxStacks, effect, "Already at maximum stacks");
    
    public static ApplyResult Failed(string message)
        => new(false, ApplyResultType.Failed, null, message);
    
    public static ApplyResult Immune(string effectId)
        => new(false, ApplyResultType.Immune, null, $"Target is immune to {effectId}");
}

public enum ApplyResultType
{
    Applied,
    Stacked,
    Refreshed,
    Replaced,
    AtMaxStacks,
    Failed,
    Immune
}
```

### Acceptance Criteria

- [ ] ApplyEffect applies new effects
- [ ] ApplyEffect handles stacking rules correctly
- [ ] Stack stacks up to maximum
- [ ] Refresh refreshes duration only
- [ ] Replace removes old and applies new
- [ ] RemoveEffect removes effects
- [ ] ClearEffects clears all/typed
- [ ] ClearDebuffs clears only debuffs
- [ ] Stat modifiers apply correctly
- [ ] Stat modifiers remove on effect removal
- [ ] PerStack modifiers scale properly
- [ ] GetActiveEffects returns list
- [ ] HasEffect returns correctly
- [ ] Events fire on apply/remove
- [ ] ~15 unit tests pass

---

## v0.10.0c: Effect Triggers & Cleanse

[v0.10.0c Design Specification](v0.10.0c-design-specification.md)

### Overview

Implement effect triggers that execute on turn events (start/end) and special events, the effect ticking system for DoT/HoT, immunity checking, and cleanse mechanics for removing negative effects.

### Scope

**In Scope:**
- `EffectTriggerAction` execution
- Turn start/end tick processing
- DoT damage application
- HoT healing application
- `TickEffects(target)` method
- Effect expiration on duration end
- `IsImmune(target, effectId)` method
- Immunity checking before application
- `Cleanse(target, count?)` method
- Remove random/all negative effects
- Dispel for removing buffs from enemies
- `StatusEffectTriggerHandler` for events
- OnApply, OnTick, OnExpire triggers

**Out of Scope:**
- Effect definitions (v0.10.0a)
- Core application logic (v0.10.0b)
- Effect UI display (separate)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Service Updates | 1 | BuffDebuffService tick, immunity, cleanse |
| Event Handlers | 1 | `StatusEffectTriggerHandler` |
| Trigger Types | 3 | OnApply, OnTick, OnExpire |
| Unit Tests | ~10 | Tick, immunity, cleanse tests |

### Effect Trigger Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                      EFFECT TRIGGER FLOW                             │
└─────────────────────────────────────────────────────────────────────┘

     Turn Event                     Effect Tick                Result
     ──────────                     ───────────                ──────

     [Turn Start] ────────────────▶ TickEffects() 
                                         │
                    ┌────────────────────┼────────────────────┐
                    ▼                    ▼                    ▼
              ┌──────────┐        ┌──────────┐         ┌──────────┐
              │ POISON   │        │ BURNING  │         │ REGEN    │
              │ (DoT)    │        │ (DoT)    │         │ (HoT)    │
              └────┬─────┘        └────┬─────┘         └────┬─────┘
                   │                   │                    │
                   ▼                   ▼                    ▼
              Deal damage         Deal damage          Apply healing
              per stack           (fire type)          
                   │                   │                    │
                   ▼                   ▼                    ▼
              Decrement           Decrement             Decrement
              duration            duration              duration
                   │                   │                    │
                   └───────────────────┴────────────────────┘
                                       │
                                       ▼
                              Remove expired effects


IMMUNITY CHECK:
     ┌─────────┐                ┌──────────────┐
     │ STUN    │ ───────────▶   │ Target has   │ ───▶ Block application
     │ Applied │                │ "stunned" in │
     │         │                │ immunityIds  │
     └─────────┘                └──────────────┘


CLEANSE:
     Before:                          After:
     ┌─────────────────────┐         ┌─────────────────────┐
     │ Target Effects:     │         │ Target Effects:     │
     │ ☠ Poison (3 stacks) │ ─────▶  │ ✨ Blessed          │
     │ ☠ Burning           │ Cleanse │                     │
     │ ✨ Blessed           │         │                     │
     └─────────────────────┘         └─────────────────────┘
```

### EffectTriggerAction Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines an action triggered by a status effect.
/// </summary>
public record EffectTriggerAction
{
    /// <summary>When the trigger activates.</summary>
    public TriggerTiming Timing { get; init; }
    
    /// <summary>What action to perform.</summary>
    public TriggerActionType Action { get; init; }
    
    /// <summary>Value for the action (damage dice, heal amount, etc.).</summary>
    public string Value { get; init; } = "";
    
    /// <summary>Damage type for damage triggers.</summary>
    public string? DamageType { get; init; }
    
    /// <summary>Whether the value scales per stack.</summary>
    public bool PerStack { get; init; }
}

public enum TriggerTiming
{
    OnApply,     // When effect is first applied
    OnTurnStart, // At the start of target's turn
    OnTurnEnd,   // At the end of target's turn
    OnTick,      // Each turn (alias for OnTurnStart)
    OnExpire,    // When effect expires naturally
    OnRemove,    // When effect is removed (any way)
    OnDamaged,   // When target takes damage
    OnAttack     // When target makes an attack
}

public enum TriggerActionType
{
    Damage,      // Deal damage
    Heal,        // Heal target
    ApplyEffect, // Apply another effect
    RemoveEffect,// Remove an effect
    ModifyStat,  // Temporary stat change
    Custom       // Custom action handler
}
```

### Tick and Immunity Methods

```csharp
// Additional methods for BuffDebuffService

public TickResult TickEffects(ICombatant target, TriggerTiming timing)
{
    var result = new TickResult();
    var effectsToRemove = new List<ActiveStatusEffect>();
    
    foreach (var effect in target.ActiveEffects.ToList())
    {
        var definition = _effectProvider.GetEffect(effect.DefinitionId);
        if (definition is null) continue;
        
        // Execute triggers for this timing
        foreach (var trigger in definition.Triggers.Where(t => t.Timing == timing))
        {
            ExecuteTrigger(target, effect, definition, trigger, result);
        }
        
        // Tick duration on turn start
        if (timing == TriggerTiming.OnTurnStart)
        {
            if (effect.Tick())
            {
                // Effect expired
                effectsToRemove.Add(effect);
                result.ExpiredEffects.Add(effect.DefinitionId);
            }
        }
    }
    
    // Remove expired effects
    foreach (var effect in effectsToRemove)
    {
        RemoveEffect(target, effect.DefinitionId);
    }
    
    return result;
}

private void ExecuteTrigger(
    ICombatant target,
    ActiveStatusEffect effect,
    StatusEffectDefinition definition,
    EffectTriggerAction trigger,
    TickResult result)
{
    var stacks = effect.CurrentStacks;
    
    switch (trigger.Action)
    {
        case TriggerActionType.Damage:
            var damageValue = _diceService.Roll(trigger.Value);
            if (trigger.PerStack) damageValue *= stacks;
            
            var damage = new DamageInstance(damageValue, trigger.DamageType ?? "poison");
            _damageService.ApplyDamage(target, damage);
            result.DamageDealt += damageValue;
            
            _logger.LogDebug("{Effect} dealt {Damage} {Type} damage to {Target}",
                definition.EffectId, damageValue, trigger.DamageType, target.Name);
            break;
        
        case TriggerActionType.Heal:
            var healValue = _diceService.Roll(trigger.Value);
            if (trigger.PerStack) healValue *= stacks;
            
            target.Heal(healValue);
            result.HealingDone += healValue;
            
            _logger.LogDebug("{Effect} healed {Target} for {Amount}",
                definition.EffectId, target.Name, healValue);
            break;
        
        case TriggerActionType.ApplyEffect:
            ApplyEffect(target, trigger.Value, null);
            break;
    }
}

public bool IsImmune(ICombatant target, string effectId)
{
    // Check if target has any effect that grants immunity to this effect
    foreach (var activeEffect in target.ActiveEffects)
    {
        var definition = _effectProvider.GetEffect(activeEffect.DefinitionId);
        if (definition?.ImmunityIds?.Contains(effectId) == true)
        {
            return true;
        }
    }
    
    // Check innate immunities on target
    return target.ImmuneTo?.Contains(effectId) == true;
}

public int Cleanse(ICombatant target, int? count = null)
{
    var debuffs = target.ActiveEffects
        .Where(e => !_effectProvider.GetEffect(e.DefinitionId)?.IsBuff == true)
        .ToList();
    
    if (count.HasValue)
    {
        debuffs = debuffs.Take(count.Value).ToList();
    }
    
    foreach (var debuff in debuffs)
    {
        RemoveEffect(target, debuff.DefinitionId);
    }
    
    _logger.LogInformation("Cleansed {Count} debuffs from {Target}", debuffs.Count, target.Name);
    return debuffs.Count;
}

public int Dispel(ICombatant target, int? count = null)
{
    var buffs = target.ActiveEffects
        .Where(e => _effectProvider.GetEffect(e.DefinitionId)?.IsBuff == true)
        .ToList();
    
    if (count.HasValue)
    {
        buffs = buffs.Take(count.Value).ToList();
    }
    
    foreach (var buff in buffs)
    {
        RemoveEffect(target, buff.DefinitionId);
    }
    
    _logger.LogInformation("Dispelled {Count} buffs from {Target}", buffs.Count, target.Name);
    return buffs.Count;
}
```

### TickResult Record

```csharp
namespace RuneAndRust.Application.Results;

/// <summary>
/// Result of ticking status effects for a turn.
/// </summary>
public record TickResult
{
    public int DamageDealt { get; set; }
    public int HealingDone { get; set; }
    public List<string> ExpiredEffects { get; } = new();
    public List<string> TriggeredEffects { get; } = new();
}
```

### StatusEffectTriggerHandler

```csharp
namespace RuneAndRust.Application.EventHandlers;

/// <summary>
/// Subscribes to turn events and processes status effect triggers.
/// </summary>
public class StatusEffectTriggerHandler : IDisposable
{
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<StatusEffectTriggerHandler> _logger;
    private readonly List<IDisposable> _subscriptions = new();
    
    public StatusEffectTriggerHandler(
        IBuffDebuffService buffDebuffService,
        IEventBus eventBus,
        ILogger<StatusEffectTriggerHandler> logger)
    {
        _buffDebuffService = buffDebuffService;
        _eventBus = eventBus;
        _logger = logger;
        
        RegisterSubscriptions();
    }
    
    private void RegisterSubscriptions()
    {
        _subscriptions.Add(_eventBus.Subscribe<TurnStartedEvent>(e =>
        {
            var result = _buffDebuffService.TickEffects(e.Combatant, TriggerTiming.OnTurnStart);
            
            if (result.DamageDealt > 0)
            {
                _eventBus.Publish(new DoTDamageDealtEvent(e.Combatant.Id, result.DamageDealt));
            }
            
            if (result.HealingDone > 0)
            {
                _eventBus.Publish(new HoTHealingDoneEvent(e.Combatant.Id, result.HealingDone));
            }
        }));
        
        _subscriptions.Add(_eventBus.Subscribe<TurnEndedEvent>(e =>
        {
            _buffDebuffService.TickEffects(e.Combatant, TriggerTiming.OnTurnEnd);
        }));
    }
    
    public void Dispose()
    {
        foreach (var sub in _subscriptions)
        {
            sub.Dispose();
        }
    }
}
```

### Acceptance Criteria

- [ ] TickEffects processes all active effects
- [ ] DoT effects deal damage per turn
- [ ] HoT effects heal per turn
- [ ] PerStack triggers scale with stacks
- [ ] Effects expire when duration reaches 0
- [ ] OnApply triggers fire on application
- [ ] OnExpire triggers fire on expiration
- [ ] IsImmune checks immunity correctly
- [ ] Immune targets block effect application
- [ ] Cleanse removes debuffs
- [ ] Dispel removes buffs
- [ ] Events publish for DoT/HoT
- [ ] ~10 unit tests pass

---

## Dependencies & Prerequisites

```
v0.9.2c (UI & Interaction Sounds) - REQUIRED
    │
    └── Audio & Atmosphere complete ──────────────────────────────────────┐
                                                                          │
v0.10.0 (Status Effects System)                                           │
    │                                                                     │
    ├── v0.10.0a: Status Effect Definitions ──────────────────────────────┤
    │       Dependencies: Domain entities, Configuration                  │
    │       Provides: StatusEffectDefinition, ActiveStatusEffect          │
    │                                                                     │
    ├── v0.10.0b: Buff/Debuff Service ────────────────────────────────────┤
    │       Dependencies: v0.10.0a (definitions), Stats system            │
    │       Provides: IBuffDebuffService, stacking, stat modifiers        │
    │                                                                     │
    └── v0.10.0c: Effect Triggers & Cleanse ──────────────────────────────┘
            Dependencies: v0.10.0a, v0.10.0b, Turn system
            Provides: Tick processing, immunity, cleanse
```

---

## Estimated Effort Summary

| Part | New Files | Modified Files | Est. Tests | Complexity |
|------|-----------|----------------|------------|------------|
| v0.10.0a | ~6 | ~1 | ~15 | Medium |
| v0.10.0b | ~3 | ~2 | ~15 | High |
| v0.10.0c | ~2 | ~2 | ~10 | Medium |
| **Total** | **~11** | **~5** | **~40** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Stat modifier conflicts | High | Medium | Clear modifier ordering |
| Stacking complexity | Medium | Medium | Thorough testing |
| DoT/HoT timing issues | Medium | Low | Clear turn event hooks |
| Immunity loops | Low | Low | Prevent self-immunity |

---

## Design Decisions (Confirmed)

### Effect Definitions

| Decision | Value | Notes |
|----------|-------|-------|
| **ID Format** | Lowercase kebab | "poison", "burning" |
| **Duration Unit** | Turns | Integer turn count |
| **Max Stacks Default** | 1 | Explicit for stacking |

### Stacking Rules

| Decision | Value | Notes |
|----------|-------|-------|
| **None** | Refresh only | Duration reset |
| **Stack** | Up to max | Each stack full effect |
| **Replace** | New replaces | Remove + apply |

### Triggers

| Decision | Value | Notes |
|----------|-------|-------|
| **Tick Timing** | Turn start | Before actions |
| **Expiration** | After tick | Remove after 0 duration |
| **PerStack** | Boolean | Scale value by stacks |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.10.0a Design Spec** - Create detailed design for Definitions
3. **v0.10.0a Implementation** - Build effect entities and config
4. **v0.10.0b Design Spec** - Create specification for Service
5. **v0.10.0b Implementation** - Build application and stacking
6. **v0.10.0c Design Spec** - Create specification for Triggers
7. **v0.10.0c Implementation** - Build tick, immunity, cleanse

---

*This scope breakdown provides a structured approach to implementing v0.10.0 Status Effects System. The enhanced buff/debuff system provides tactical depth through stat modifiers, damage over time, healing over time, and action prevention, with configurable stacking rules and cleanse mechanics.*
