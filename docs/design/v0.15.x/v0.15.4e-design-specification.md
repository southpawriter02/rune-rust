# v0.15.4e Design Specification: Jury-Rigging System

**Version:** 0.15.4e
**Theme:** Jury-Rigging System (Trial-and-Error Procedure)
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0 Complete (Dice Pool Refactor), v0.15.1 Complete (Skill Infrastructure), v0.15.4a Complete (Lockpicking System), v0.15.4b Complete (Terminal Hacking System), v0.15.4c Complete (ICE Countermeasures), v0.15.4d Complete (Trap Disarmament System)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [BypassMethod Enum](#4-bypassmethod-enum)
5. [JuryRigContext Value Object](#5-juryrigcontext-value-object)
6. [JuryRigState Entity](#6-juryrigstate-entity)
7. [JuryRigResult Value Object](#7-juryrigresult-value-object)
8. [JuryRiggingService](#8-juryriggingservice-implementation)
9. [Trial-and-Error Procedure](#9-trial-and-error-procedure)
10. [Complication Table](#10-complication-table)
11. [Electrocution Risk System](#11-electrocution-risk-system)
12. [Data Model Changes](#12-data-model-changes)
13. [Configuration Files](#13-configuration-files)
14. [Logging Specifications](#14-logging-specifications)
15. [Unit Testing Requirements](#15-unit-testing-requirements)
16. [Use Cases](#16-use-cases)
17. [Deliverable Checklist](#17-deliverable-checklist)
18. [Acceptance Criteria](#18-acceptance-criteria)
19. [Dependencies](#19-dependencies)
20. [Future Considerations](#20-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

The Jury-Rigging System enables characters to bypass Old World technology through creative improvisation—hitting, rewiring, exploiting glitches, or brute-force disassembly. Unlike the precision-based lockpicking or layered terminal hacking, jury-rigging represents the "cargo cult" approach of manipulating incomprehensible technology through trial and error, pattern recognition, and sheer determination.

This phase introduces six distinct bypass methods, each with unique risk-reward tradeoffs, a five-step trial-and-error procedure, a complication table for failed attempts, and the electrocution risk subsystem for wire manipulation.

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Enums** | `BypassMethod` (6 values) |
| **Value Objects** | `JuryRigContext`, `JuryRigResult`, `ComplicationRoll` |
| **Entities** | `JuryRigState` |
| **Services** | `JuryRiggingService` |
| **Configuration** | `bypass-methods.json` |
| **Tests** | ~3 new unit tests |

### 1.3 Architectural Significance

This version establishes the **Improvised Technology Manipulation Pattern** that will influence future game mechanics:

- **Risk-Reward Method Selection**: Players choose approaches with explicit tradeoffs (lower DC vs. higher consequences)
- **Complication Tables**: d10-based random consequence systems for failures
- **Familiarity Bonuses**: Characters gain advantages with mechanisms they've seen before
- **Environmental Hazard Integration**: Electrocution risk demonstrates how bypass attempts can trigger damage

---

## 2. Feature Overview

```
v0.15.4e Jury-Rigging System
├── BypassMethod Enum
│   ├── PercussiveMaintenance (+0 DC, may break)
│   ├── WireManipulation (-2 DC, electrocution risk)
│   ├── GlitchExploitation (-4 DC, unpredictable)
│   ├── MemorizedSequence (-2 DC, familiar only)
│   ├── BruteDisassembly (+2 DC, destroys mechanism)
│   └── PowerCycling (+0 DC, resets progress)
├── JuryRigContext Value Object
│   ├── MethodUsed
│   ├── FamiliarMechanism
│   ├── ToolsAvailable
│   ├── ElectrocutionRisk
│   └── ComplicationRoll
├── Trial-and-Error Procedure
│   ├── Step 1: Observe (WITS DC 10)
│   ├── Step 2: Probe (Automatic)
│   ├── Step 3: Pattern (WITS DC 12)
│   ├── Step 4: Experiment (Bypass DC)
│   └── Step 5: Iterate (Automatic)
├── Complication Table (d10)
│   ├── 1: Machine locks permanently
│   ├── 2-3: Alarm triggers
│   ├── 4-5: Sparks fly (1d6 damage)
│   ├── 6-7: Nothing, try again
│   ├── 8-9: Partial success
│   └── 10: Machine glitches in favor
└── Electrocution Risk System
    ├── Trigger: Wire Manipulation
    ├── Save: FINESSE DC 12
    └── Failure: 2d10 lightning damage
```

---

## 3. Architecture Diagrams

### 3.1 Jury-Rigging Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         JURY-RIGGING FLOW                                    │
└─────────────────────────────────────────────────────────────────────────────┘

    Player initiates jury-rig attempt
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 1: OBSERVE (Optional)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  WITS check DC 10 to identify machine type and inputs                       │
│  Success: Learn mechanism type, reveal potential methods                     │
│  Skip: Proceed blind (no pattern recognition bonus)                          │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 2: PROBE (Automatic)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│  Try obvious buttons, levers, switches                                       │
│  Machine reacts (may beep, light up, or do nothing)                          │
│  Outcome: Establish baseline behavior                                        │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 3: PATTERN (Optional)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  WITS check DC 12 to recognize mechanism type                                │
│  Success + Familiar: +2d10 bonus dice on experiment                          │
│  Success + Unfamiliar: Mark as "seen" for future                             │
│  Failure: No bonus, proceed normally                                         │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                  SELECT BYPASS METHOD                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐                │
│  │ Percussive      │ │ Wire            │ │ Glitch          │                │
│  │ Maintenance     │ │ Manipulation    │ │ Exploitation    │                │
│  │ +0 DC           │ │ -2 DC           │ │ -4 DC           │                │
│  │ May break       │ │ Electrocution   │ │ Unpredictable   │                │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘                │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐                │
│  │ Memorized       │ │ Brute           │ │ Power           │                │
│  │ Sequence        │ │ Disassembly     │ │ Cycling         │                │
│  │ -2 DC           │ │ +2 DC           │ │ +0 DC           │                │
│  │ Familiar only   │ │ Destroys        │ │ Resets progress │                │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘                │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 4: EXPERIMENT (Core Check)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  System Bypass check vs. Modified DC                                         │
│  Apply: Tool modifier, Method modifier, Familiarity bonus                    │
│                                                                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ CRITICAL    │  │ SUCCESS     │  │ FAILURE     │  │ FUMBLE      │        │
│  │ Net ≥5      │  │ Net >0      │  │ Net ≤0      │  │ 0 succ      │        │
│  │             │  │             │  │ No botch    │  │ ≥1 botch    │        │
│  │ Bypass +    │  │ Mechanism   │  │ Roll on     │  │ Mechanism   │        │
│  │ Salvage     │  │ Bypassed    │  │ Complication│  │ Destroyed   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼ (on failure, not fumble)
┌─────────────────────────────────────────────────────────────────────────────┐
│                      COMPLICATION TABLE (d10)                                │
├─────────────────────────────────────────────────────────────────────────────┤
│  1     │ Machine locks permanently - no further attempts                     │
│  2-3   │ Alarm triggers - enemies alerted                                    │
│  4-5   │ Sparks fly - take 1d6 electrical damage                            │
│  6-7   │ Nothing happens - may try again                                     │
│  8-9   │ Partial success - one function works                                │
│  10    │ Machine glitches in your favor - auto-success                       │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼ (if not locked/destroyed)
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 5: ITERATE (Automatic)                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  Learn from failure: DC -1 for next attempt on same mechanism                │
│  Return to Step 4 or choose different method                                 │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Service Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  ConsoleInputHandler          IGameRenderer                                  │
│  - ParseJuryRigCommand()      - RenderJuryRigStateAsync()                   │
│  - ParseMethodSelection()     - RenderComplicationAsync()                    │
│                               - RenderElectrocutionAsync()                   │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  GameEngine                                                                  │
│  - HandleJuryRigAttemptAsync()                                              │
│  - ApplyComplicationEffect()                                                 │
│  - ProcessElectrocutionRisk()                                               │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN SERVICES                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ JuryRiggingService                                                   │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ + InitiateJuryRig(character, mechanism) → JuryRigState             │   │
│  │ + PerformObservation(state) → ObservationResult                     │   │
│  │ + PerformProbe(state) → ProbeResult                                 │   │
│  │ + AttemptPatternRecognition(state) → PatternResult                  │   │
│  │ + SelectMethod(state, method) → void                                │   │
│  │ + PerformExperiment(state, context) → JuryRigResult                 │   │
│  │ + ProcessComplication(state, roll) → ComplicationEffect             │   │
│  │ + ApplyIteration(state) → void                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ ElectrocutionRiskService                                             │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ + EvaluateRisk(context) → bool                                      │   │
│  │ + AttemptSave(character, dc) → SaveResult                           │   │
│  │ + ApplyElectrocutionDamage(character) → DamageResult                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN ENTITIES                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  JuryRigState          JuryRigContext          JuryRigResult                │
│  - JuryRigId           - MethodUsed            - Outcome                    │
│  - CharacterId         - FamiliarMechanism     - ComplicationRoll           │
│  - MechanismType       - ToolsAvailable        - DamageDealt                │
│  - CurrentStep         - ElectrocutionRisk     - SalvagedComponents         │
│  - SelectedMethod      - ComplicationRoll      - NarrativeText              │
│  - IterationCount                                                            │
│  - BaseDC                                                                    │
│  - ModifiedDC                                                                │
│  - Status                                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Method Selection Decision Tree

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    BYPASS METHOD SELECTION GUIDE                             │
└─────────────────────────────────────────────────────────────────────────────┘

                    ┌─────────────────┐
                    │  MECHANISM      │
                    │  NEEDS BYPASS   │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              ▼              │              ▼
    ┌─────────────────┐     │     ┌─────────────────┐
    │ Have proper     │     │     │ Need to preserve│
    │ tools?          │     │     │ mechanism?      │
    └────────┬────────┘     │     └────────┬────────┘
             │              │              │
     YES ────┼──── NO       │      YES ────┼──── NO
             │              │              │
             ▼              │              ▼
    ┌─────────────────┐     │     ┌─────────────────┐
    │ WIRE            │     │     │ BRUTE           │
    │ MANIPULATION    │     │     │ DISASSEMBLY     │
    │ -2 DC           │     │     │ +2 DC           │
    │ Risk: Shock     │     │     │ Destroys mech   │
    └─────────────────┘     │     └─────────────────┘
                            │
              ┌─────────────┼─────────────┐
              ▼             │             ▼
    ┌─────────────────┐     │    ┌─────────────────┐
    │ Seen this type  │     │    │ Mechanism is    │
    │ before?         │     │    │ [Glitched]?     │
    └────────┬────────┘     │    └────────┬────────┘
             │              │             │
     YES ────┼──── NO       │     YES ────┼──── NO
             │              │             │
             ▼              │             ▼
    ┌─────────────────┐     │    ┌─────────────────┐
    │ MEMORIZED       │     │    │ GLITCH          │
    │ SEQUENCE        │     │    │ EXPLOITATION    │
    │ -2 DC           │     │    │ -4 DC           │
    │ Familiar only   │     │    │ Unpredictable   │
    └─────────────────┘     │    └─────────────────┘
                            │
              ┌─────────────┴─────────────┐
              ▼                           ▼
    ┌─────────────────┐         ┌─────────────────┐
    │ Just want to    │         │ Willing to try  │
    │ reset?          │         │ hitting it?     │
    └────────┬────────┘         └────────┬────────┘
             │                           │
             ▼                           ▼
    ┌─────────────────┐         ┌─────────────────┐
    │ POWER           │         │ PERCUSSIVE      │
    │ CYCLING         │         │ MAINTENANCE     │
    │ +0 DC           │         │ +0 DC           │
    │ Resets progress │         │ May break       │
    └─────────────────┘         └─────────────────┘
```

---

## 4. BypassMethod Enum

### 4.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/BypassMethod.cs`

```csharp
using System.ComponentModel;

namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the available methods for jury-rigging Old World technology.
/// Each method represents a different cargo-cult approach to making
/// incomprehensible machines do what the user wants.
/// </summary>
/// <remarks>
/// Methods have varying DC modifiers and associated risks:
/// - Negative modifiers make bypass easier but introduce specific hazards
/// - Positive modifiers make bypass harder but offer reliability
/// - Zero modifiers are neutral approaches with situational effects
/// </remarks>
public enum BypassMethod
{
    /// <summary>
    /// Hit the machine until it works. The classic approach.
    /// DC Modifier: +0
    /// Risk: May permanently break the mechanism on fumble
    /// </summary>
    [Description("Strike the mechanism forcefully to jar components into alignment")]
    PercussiveMaintenance = 0,

    /// <summary>
    /// Rewire internal connections to bypass security or reroute power.
    /// DC Modifier: -2 (easier)
    /// Risk: Electrocution (FINESSE save DC 12 or 2d10 lightning damage)
    /// </summary>
    [Description("Manipulate internal wiring to bypass security circuits")]
    WireManipulation = 1,

    /// <summary>
    /// Exploit the machine's corrupted or malfunctioning state.
    /// DC Modifier: -4 (much easier)
    /// Risk: Unpredictable - chaos roll determines actual modifier
    /// Only effective on [Glitched] mechanisms
    /// </summary>
    [Description("Exploit the mechanism's corrupted behavior patterns")]
    GlitchExploitation = 2,

    /// <summary>
    /// Apply a sequence learned from previous encounters with similar machines.
    /// DC Modifier: -2 (easier)
    /// Requirement: Character must have successfully bypassed this mechanism type before
    /// </summary>
    [Description("Apply a previously memorized activation sequence")]
    MemorizedSequence = 3,

    /// <summary>
    /// Forcefully disassemble the mechanism to access internal components.
    /// DC Modifier: +2 (harder)
    /// Consequence: Mechanism is destroyed on success (cannot be reused)
    /// Benefit: Guaranteed component salvage
    /// </summary>
    [Description("Tear apart the mechanism to force access")]
    BruteDisassembly = 4,

    /// <summary>
    /// Cut power and restore it, hoping to reset the machine to a default state.
    /// DC Modifier: +0
    /// Effect: Resets all progress (clears lockouts, resets alert levels)
    /// Risk: May lose partial progress
    /// </summary>
    [Description("Cycle power to reset the mechanism to factory state")]
    PowerCycling = 5
}
```

### 4.2 Method Modifiers Reference

| Method | DC Modifier | Risk/Requirement | Best Used When |
|--------|-------------|------------------|----------------|
| `PercussiveMaintenance` | +0 | May break on fumble | No tools, mechanical device |
| `WireManipulation` | -2 | Electrocution risk | Have tools, accept risk |
| `GlitchExploitation` | -4 | Unpredictable chaos | Mechanism is [Glitched] |
| `MemorizedSequence` | -2 | Must be familiar | Seen this type before |
| `BruteDisassembly` | +2 | Destroys mechanism | Don't need it intact |
| `PowerCycling` | +0 | Resets progress | Need to clear lockout |

### 4.3 Method Extension Methods

**File:** `src/Core/RuneAndRust.Domain/Enums/BypassMethodExtensions.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Extension methods for BypassMethod enum providing DC modifiers and requirements.
/// </summary>
public static class BypassMethodExtensions
{
    /// <summary>
    /// Gets the DC modifier for the bypass method.
    /// Negative values make bypass easier; positive values make it harder.
    /// </summary>
    /// <param name="method">The bypass method.</param>
    /// <returns>The DC modifier value.</returns>
    public static int GetDcModifier(this BypassMethod method) => method switch
    {
        BypassMethod.PercussiveMaintenance => 0,
        BypassMethod.WireManipulation => -2,
        BypassMethod.GlitchExploitation => -4,
        BypassMethod.MemorizedSequence => -2,
        BypassMethod.BruteDisassembly => +2,
        BypassMethod.PowerCycling => 0,
        _ => 0
    };

    /// <summary>
    /// Determines if the method has electrocution risk.
    /// </summary>
    /// <param name="method">The bypass method.</param>
    /// <returns>True if electrocution save is required.</returns>
    public static bool HasElectrocutionRisk(this BypassMethod method) =>
        method == BypassMethod.WireManipulation;

    /// <summary>
    /// Determines if the method requires prior familiarity.
    /// </summary>
    /// <param name="method">The bypass method.</param>
    /// <returns>True if character must have seen mechanism type before.</returns>
    public static bool RequiresFamiliarity(this BypassMethod method) =>
        method == BypassMethod.MemorizedSequence;

    /// <summary>
    /// Determines if the method requires a [Glitched] mechanism.
    /// </summary>
    /// <param name="method">The bypass method.</param>
    /// <returns>True if mechanism must be glitched.</returns>
    public static bool RequiresGlitchedMechanism(this BypassMethod method) =>
        method == BypassMethod.GlitchExploitation;

    /// <summary>
    /// Determines if the method destroys the mechanism on success.
    /// </summary>
    /// <param name="method">The bypass method.</param>
    /// <returns>True if mechanism cannot be reused.</returns>
    public static bool DestroysMechanism(this BypassMethod method) =>
        method == BypassMethod.BruteDisassembly;

    /// <summary>
    /// Determines if the method resets mechanism state.
    /// </summary>
    /// <param name="method">The bypass method.</param>
    /// <returns>True if mechanism state is cleared.</returns>
    public static bool ResetsMechanismState(this BypassMethod method) =>
        method == BypassMethod.PowerCycling;

    /// <summary>
    /// Gets the display name for the bypass method.
    /// </summary>
    /// <param name="method">The bypass method.</param>
    /// <returns>Human-readable method name.</returns>
    public static string GetDisplayName(this BypassMethod method) => method switch
    {
        BypassMethod.PercussiveMaintenance => "Percussive Maintenance",
        BypassMethod.WireManipulation => "Wire Manipulation",
        BypassMethod.GlitchExploitation => "Glitch Exploitation",
        BypassMethod.MemorizedSequence => "Memorized Sequence",
        BypassMethod.BruteDisassembly => "Brute Disassembly",
        BypassMethod.PowerCycling => "Power Cycling",
        _ => method.ToString()
    };
}
```

---

## 5. JuryRigContext Value Object

### 5.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/JuryRigContext.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Captures the complete context for a jury-rigging attempt, including
/// method selection, tool availability, familiarity, and risk factors.
/// </summary>
/// <remarks>
/// This value object is immutable and contains all information needed
/// to resolve a jury-rigging attempt, including:
/// - The bypass method selected by the player
/// - Whether the character has seen this mechanism type before
/// - The quality of tools available
/// - Whether electrocution risk applies
/// - The complication roll result (for failed attempts)
/// </remarks>
/// <param name="MethodUsed">The bypass approach selected by the player.</param>
/// <param name="FamiliarMechanism">True if character has successfully bypassed this mechanism type before.</param>
/// <param name="ToolsAvailable">Quality of tools available for the attempt.</param>
/// <param name="ElectrocutionRisk">True if wire manipulation is being attempted.</param>
/// <param name="ComplicationRoll">The d10 roll result for failure complications (1-10, null if not rolled).</param>
public readonly record struct JuryRigContext(
    BypassMethod MethodUsed,
    bool FamiliarMechanism,
    ToolQuality ToolsAvailable,
    bool ElectrocutionRisk,
    int? ComplicationRoll)
{
    /// <summary>
    /// Gets the DC modifier from the selected method.
    /// </summary>
    public int MethodDcModifier => MethodUsed.GetDcModifier();

    /// <summary>
    /// Gets the dice pool modifier from tool quality.
    /// </summary>
    public int ToolDiceModifier => ToolsAvailable.GetDiceModifier();

    /// <summary>
    /// Gets the familiarity bonus dice (2d10 if familiar, 0 otherwise).
    /// </summary>
    public int FamiliarityBonusDice => FamiliarMechanism ? 2 : 0;

    /// <summary>
    /// Gets the total dice pool modifier (tools + familiarity).
    /// </summary>
    public int TotalDiceModifier => ToolDiceModifier + FamiliarityBonusDice;

    /// <summary>
    /// Determines if the method is valid given the current context.
    /// </summary>
    /// <param name="isGlitched">Whether the mechanism is in a glitched state.</param>
    /// <returns>True if the method can be used.</returns>
    public bool IsMethodValid(bool isGlitched)
    {
        // MemorizedSequence requires familiarity
        if (MethodUsed.RequiresFamiliarity() && !FamiliarMechanism)
            return false;

        // GlitchExploitation requires glitched mechanism
        if (MethodUsed.RequiresGlitchedMechanism() && !isGlitched)
            return false;

        return true;
    }

    /// <summary>
    /// Creates a context for the specified method with automatic risk assessment.
    /// </summary>
    /// <param name="method">The bypass method to use.</param>
    /// <param name="familiar">Whether character is familiar with mechanism type.</param>
    /// <param name="tools">Available tool quality.</param>
    /// <returns>A new JuryRigContext with appropriate risk flags.</returns>
    public static JuryRigContext Create(
        BypassMethod method,
        bool familiar,
        ToolQuality tools)
    {
        return new JuryRigContext(
            MethodUsed: method,
            FamiliarMechanism: familiar,
            ToolsAvailable: tools,
            ElectrocutionRisk: method.HasElectrocutionRisk(),
            ComplicationRoll: null);
    }

    /// <summary>
    /// Creates a copy with the complication roll set.
    /// </summary>
    /// <param name="roll">The d10 roll result (1-10).</param>
    /// <returns>A new context with the complication roll.</returns>
    public JuryRigContext WithComplicationRoll(int roll)
    {
        if (roll < 1 || roll > 10)
            throw new ArgumentOutOfRangeException(nameof(roll), "Complication roll must be 1-10");

        return this with { ComplicationRoll = roll };
    }

    /// <summary>
    /// Creates a display string summarizing the context.
    /// </summary>
    public string ToDisplayString()
    {
        var parts = new List<string>
        {
            $"Method: {MethodUsed.GetDisplayName()} ({MethodDcModifier:+0;-0;+0} DC)"
        };

        if (FamiliarMechanism)
            parts.Add("Familiar mechanism (+2d10)");

        parts.Add($"Tools: {ToolsAvailable} ({ToolDiceModifier:+0;-0;+0}d10)");

        if (ElectrocutionRisk)
            parts.Add("⚡ Electrocution risk!");

        if (ComplicationRoll.HasValue)
            parts.Add($"Complication: {ComplicationRoll.Value}");

        return string.Join(" | ", parts);
    }
}
```

### 5.2 ToolQuality Extension (Reference)

The `ToolQuality` enum is defined in v0.15.4a. For reference:

| Tool Quality | Dice Modifier |
|--------------|---------------|
| `BareHands` | -2d10 |
| `Improvised` | +0 |
| `Proper` | +1d10 |
| `Masterwork` | +2d10 |

---

## 6. JuryRigState Entity

### 6.1 Entity Definition

**File:** `src/Core/RuneAndRust.Domain/Entities/JuryRigState.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Tracks the state of an ongoing jury-rigging attempt through the
/// five-step trial-and-error procedure.
/// </summary>
/// <remarks>
/// The jury-rigging process consists of:
/// 1. Observe - Identify mechanism type and inputs (WITS DC 10)
/// 2. Probe - Try obvious controls (automatic)
/// 3. Pattern - Recognize mechanism type (WITS DC 12)
/// 4. Experiment - Attempt bypass with selected method
/// 5. Iterate - Learn from failure (DC -1 next attempt)
///
/// State persists across multiple attempts until success, permanent lockout,
/// or mechanism destruction.
/// </remarks>
public class JuryRigState
{
    /// <summary>
    /// Unique identifier for this jury-rigging session.
    /// </summary>
    public string JuryRigId { get; private set; } = string.Empty;

    /// <summary>
    /// Character attempting the jury-rig.
    /// </summary>
    public string CharacterId { get; private set; } = string.Empty;

    /// <summary>
    /// Type/category of the mechanism being bypassed.
    /// </summary>
    public string MechanismType { get; private set; } = string.Empty;

    /// <summary>
    /// Display name of the specific mechanism.
    /// </summary>
    public string MechanismName { get; private set; } = string.Empty;

    /// <summary>
    /// Current step in the trial-and-error procedure.
    /// </summary>
    public JuryRigStep CurrentStep { get; private set; }

    /// <summary>
    /// Whether observation step was completed successfully.
    /// </summary>
    public bool ObservationComplete { get; private set; }

    /// <summary>
    /// Whether probing step was completed.
    /// </summary>
    public bool ProbingComplete { get; private set; }

    /// <summary>
    /// Whether pattern recognition was attempted and succeeded.
    /// </summary>
    public bool PatternRecognized { get; private set; }

    /// <summary>
    /// The bypass method selected by the player.
    /// </summary>
    public BypassMethod? SelectedMethod { get; private set; }

    /// <summary>
    /// Number of failed attempts on this mechanism.
    /// Each iteration reduces DC by 1.
    /// </summary>
    public int IterationCount { get; private set; }

    /// <summary>
    /// Base difficulty class before any modifiers.
    /// </summary>
    public int BaseDC { get; private set; }

    /// <summary>
    /// Whether the mechanism is in a [Glitched] state.
    /// </summary>
    public bool IsGlitched { get; private set; }

    /// <summary>
    /// Whether the character is familiar with this mechanism type.
    /// </summary>
    public bool IsFamiliarMechanism { get; private set; }

    /// <summary>
    /// Current status of the jury-rigging attempt.
    /// </summary>
    public JuryRigStatus Status { get; private set; }

    /// <summary>
    /// Hints revealed through observation and probing.
    /// </summary>
    public IReadOnlyList<string> RevealedHints => _revealedHints.AsReadOnly();
    private readonly List<string> _revealedHints = new();

    /// <summary>
    /// Results of previous experiment attempts.
    /// </summary>
    public IReadOnlyList<JuryRigResult> PreviousAttempts => _previousAttempts.AsReadOnly();
    private readonly List<JuryRigResult> _previousAttempts = new();

    // Private constructor for EF Core
    private JuryRigState() { }

    /// <summary>
    /// Creates a new jury-rigging state for the specified mechanism.
    /// </summary>
    /// <param name="juryRigId">Unique session identifier.</param>
    /// <param name="characterId">Character attempting the bypass.</param>
    /// <param name="mechanismType">Category of mechanism.</param>
    /// <param name="mechanismName">Display name of mechanism.</param>
    /// <param name="baseDc">Base difficulty class.</param>
    /// <param name="isGlitched">Whether mechanism is glitched.</param>
    /// <param name="isFamiliar">Whether character has bypassed this type before.</param>
    /// <returns>A new JuryRigState ready for the Observe step.</returns>
    public static JuryRigState Create(
        string juryRigId,
        string characterId,
        string mechanismType,
        string mechanismName,
        int baseDc,
        bool isGlitched,
        bool isFamiliar)
    {
        return new JuryRigState
        {
            JuryRigId = juryRigId,
            CharacterId = characterId,
            MechanismType = mechanismType,
            MechanismName = mechanismName,
            CurrentStep = JuryRigStep.Observe,
            BaseDC = baseDc,
            IsGlitched = isGlitched,
            IsFamiliarMechanism = isFamiliar,
            Status = JuryRigStatus.InProgress,
            IterationCount = 0,
            ObservationComplete = false,
            ProbingComplete = false,
            PatternRecognized = false,
            SelectedMethod = null
        };
    }

    /// <summary>
    /// Gets the current modified DC accounting for method, iterations, and glitch state.
    /// </summary>
    /// <returns>The effective DC for the bypass attempt.</returns>
    public int GetModifiedDC()
    {
        var dc = BaseDC;

        // Apply method modifier if selected
        if (SelectedMethod.HasValue)
            dc += SelectedMethod.Value.GetDcModifier();

        // Apply iteration learning (-1 per failed attempt)
        dc -= IterationCount;

        // Minimum DC of 4
        return Math.Max(dc, 4);
    }

    /// <summary>
    /// Completes the observation step with the specified result.
    /// </summary>
    /// <param name="success">Whether observation succeeded.</param>
    /// <param name="hints">Hints revealed on success.</param>
    public void CompleteObservation(bool success, IEnumerable<string>? hints = null)
    {
        ObservationComplete = true;

        if (success && hints != null)
            _revealedHints.AddRange(hints);

        CurrentStep = JuryRigStep.Probe;
    }

    /// <summary>
    /// Skips observation and moves to probing.
    /// </summary>
    public void SkipObservation()
    {
        CurrentStep = JuryRigStep.Probe;
    }

    /// <summary>
    /// Completes the probe step.
    /// </summary>
    /// <param name="hints">Machine reactions observed.</param>
    public void CompleteProbe(IEnumerable<string>? hints = null)
    {
        ProbingComplete = true;

        if (hints != null)
            _revealedHints.AddRange(hints);

        CurrentStep = JuryRigStep.Pattern;
    }

    /// <summary>
    /// Completes the pattern recognition step.
    /// </summary>
    /// <param name="success">Whether pattern was recognized.</param>
    public void CompletePatternRecognition(bool success)
    {
        PatternRecognized = success;
        CurrentStep = JuryRigStep.MethodSelection;
    }

    /// <summary>
    /// Skips pattern recognition and moves to method selection.
    /// </summary>
    public void SkipPatternRecognition()
    {
        CurrentStep = JuryRigStep.MethodSelection;
    }

    /// <summary>
    /// Selects the bypass method and moves to experiment.
    /// </summary>
    /// <param name="method">The bypass method to use.</param>
    /// <exception cref="InvalidOperationException">If method is invalid for context.</exception>
    public void SelectMethod(BypassMethod method)
    {
        // Validate method
        if (method.RequiresFamiliarity() && !IsFamiliarMechanism)
            throw new InvalidOperationException(
                $"Cannot use {method.GetDisplayName()}: mechanism type not familiar");

        if (method.RequiresGlitchedMechanism() && !IsGlitched)
            throw new InvalidOperationException(
                $"Cannot use {method.GetDisplayName()}: mechanism is not glitched");

        SelectedMethod = method;
        CurrentStep = JuryRigStep.Experiment;
    }

    /// <summary>
    /// Records an experiment attempt result.
    /// </summary>
    /// <param name="result">The result of the attempt.</param>
    public void RecordAttempt(JuryRigResult result)
    {
        _previousAttempts.Add(result);

        switch (result.Outcome)
        {
            case JuryRigOutcome.Success:
            case JuryRigOutcome.CriticalSuccess:
                Status = JuryRigStatus.Bypassed;
                break;

            case JuryRigOutcome.Fumble:
                Status = JuryRigStatus.MechanismDestroyed;
                break;

            case JuryRigOutcome.PermanentLock:
                Status = JuryRigStatus.PermanentlyLocked;
                break;

            case JuryRigOutcome.Failure:
            case JuryRigOutcome.PartialSuccess:
                // Move to iterate step
                CurrentStep = JuryRigStep.Iterate;
                break;
        }
    }

    /// <summary>
    /// Applies iteration learning after a failed attempt.
    /// </summary>
    public void ApplyIteration()
    {
        IterationCount++;
        CurrentStep = JuryRigStep.MethodSelection;
        SelectedMethod = null; // Allow method change
    }

    /// <summary>
    /// Marks the jury-rigging as abandoned.
    /// </summary>
    public void Abandon()
    {
        Status = JuryRigStatus.Abandoned;
    }
}

/// <summary>
/// The steps in the jury-rigging trial-and-error procedure.
/// </summary>
public enum JuryRigStep
{
    /// <summary>Study the mechanism visually (WITS DC 10).</summary>
    Observe,

    /// <summary>Try obvious buttons and levers (automatic).</summary>
    Probe,

    /// <summary>Recognize mechanism type (WITS DC 12).</summary>
    Pattern,

    /// <summary>Select a bypass method.</summary>
    MethodSelection,

    /// <summary>Attempt the bypass (System Bypass check).</summary>
    Experiment,

    /// <summary>Learn from failure (automatic DC reduction).</summary>
    Iterate
}

/// <summary>
/// The status of a jury-rigging attempt.
/// </summary>
public enum JuryRigStatus
{
    /// <summary>Attempt is ongoing.</summary>
    InProgress,

    /// <summary>Mechanism was successfully bypassed.</summary>
    Bypassed,

    /// <summary>Mechanism was destroyed by brute disassembly.</summary>
    Destroyed,

    /// <summary>Mechanism was destroyed by fumble.</summary>
    MechanismDestroyed,

    /// <summary>Mechanism is permanently locked (complication 1).</summary>
    PermanentlyLocked,

    /// <summary>Attempt was abandoned by player.</summary>
    Abandoned
}
```

---

## 7. JuryRigResult Value Object

### 7.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/JuryRigResult.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Captures the complete result of a jury-rigging experiment attempt,
/// including outcome, complications, damage, and salvage.
/// </summary>
/// <param name="Outcome">The outcome category of the attempt.</param>
/// <param name="NetSuccesses">Net successes (successes minus botches).</param>
/// <param name="ComplicationRoll">The d10 roll for failure complications (null if success).</param>
/// <param name="ComplicationEffect">The effect triggered by the complication roll.</param>
/// <param name="DamageDealt">Damage dealt to character (sparks, electrocution).</param>
/// <param name="DamageType">Type of damage dealt.</param>
/// <param name="SalvagedComponents">Components salvaged on critical/brute.</param>
/// <param name="NarrativeText">Descriptive text for the result.</param>
/// <param name="MethodUsed">The bypass method that was attempted.</param>
public readonly record struct JuryRigResult(
    JuryRigOutcome Outcome,
    int NetSuccesses,
    int? ComplicationRoll,
    ComplicationEffect? ComplicationEffect,
    int DamageDealt,
    DamageType? DamageType,
    IReadOnlyList<string> SalvagedComponents,
    string NarrativeText,
    BypassMethod MethodUsed)
{
    /// <summary>
    /// Whether the attempt resulted in successful bypass.
    /// </summary>
    public bool IsSuccess => Outcome is JuryRigOutcome.Success or JuryRigOutcome.CriticalSuccess;

    /// <summary>
    /// Whether components were salvaged.
    /// </summary>
    public bool HasSalvage => SalvagedComponents.Count > 0;

    /// <summary>
    /// Whether damage was dealt during the attempt.
    /// </summary>
    public bool TookDamage => DamageDealt > 0;

    /// <summary>
    /// Whether the mechanism can still be attempted.
    /// </summary>
    public bool CanRetry => Outcome is JuryRigOutcome.Failure or JuryRigOutcome.PartialSuccess;

    /// <summary>
    /// Creates a success result.
    /// </summary>
    public static JuryRigResult Success(
        int netSuccesses,
        BypassMethod method,
        string narrative)
    {
        return new JuryRigResult(
            Outcome: JuryRigOutcome.Success,
            NetSuccesses: netSuccesses,
            ComplicationRoll: null,
            ComplicationEffect: null,
            DamageDealt: 0,
            DamageType: null,
            SalvagedComponents: Array.Empty<string>(),
            NarrativeText: narrative,
            MethodUsed: method);
    }

    /// <summary>
    /// Creates a critical success result with salvage.
    /// </summary>
    public static JuryRigResult CriticalSuccess(
        int netSuccesses,
        BypassMethod method,
        IEnumerable<string> salvage,
        string narrative)
    {
        return new JuryRigResult(
            Outcome: JuryRigOutcome.CriticalSuccess,
            NetSuccesses: netSuccesses,
            ComplicationRoll: null,
            ComplicationEffect: null,
            DamageDealt: 0,
            DamageType: null,
            SalvagedComponents: salvage.ToList().AsReadOnly(),
            NarrativeText: narrative,
            MethodUsed: method);
    }

    /// <summary>
    /// Creates a failure result with complication.
    /// </summary>
    public static JuryRigResult Failure(
        int netSuccesses,
        BypassMethod method,
        int complicationRoll,
        ComplicationEffect effect,
        int damage,
        DamageType? damageType,
        string narrative)
    {
        return new JuryRigResult(
            Outcome: effect == ComplicationEffect.PermanentLock
                ? JuryRigOutcome.PermanentLock
                : JuryRigOutcome.Failure,
            NetSuccesses: netSuccesses,
            ComplicationRoll: complicationRoll,
            ComplicationEffect: effect,
            DamageDealt: damage,
            DamageType: damageType,
            SalvagedComponents: Array.Empty<string>(),
            NarrativeText: narrative,
            MethodUsed: method);
    }

    /// <summary>
    /// Creates a partial success result.
    /// </summary>
    public static JuryRigResult PartialSuccess(
        int netSuccesses,
        BypassMethod method,
        int complicationRoll,
        string functionActivated,
        string narrative)
    {
        return new JuryRigResult(
            Outcome: JuryRigOutcome.PartialSuccess,
            NetSuccesses: netSuccesses,
            ComplicationRoll: complicationRoll,
            ComplicationEffect: ComplicationEffect.PartialSuccess,
            DamageDealt: 0,
            DamageType: null,
            SalvagedComponents: new[] { $"Function: {functionActivated}" },
            NarrativeText: narrative,
            MethodUsed: method);
    }

    /// <summary>
    /// Creates a fumble result (mechanism destroyed).
    /// </summary>
    public static JuryRigResult Fumble(
        BypassMethod method,
        string narrative)
    {
        return new JuryRigResult(
            Outcome: JuryRigOutcome.Fumble,
            NetSuccesses: 0,
            ComplicationRoll: null,
            ComplicationEffect: null,
            DamageDealt: 0,
            DamageType: null,
            SalvagedComponents: Array.Empty<string>(),
            NarrativeText: narrative,
            MethodUsed: method);
    }

    /// <summary>
    /// Creates a display string for the result.
    /// </summary>
    public string ToDisplayString()
    {
        var lines = new List<string>
        {
            $"═══ {Outcome.GetDisplayName()} ═══",
            NarrativeText
        };

        if (TookDamage)
            lines.Add($"Damage: {DamageDealt} {DamageType}");

        if (HasSalvage)
            lines.Add($"Salvaged: {string.Join(", ", SalvagedComponents)}");

        if (CanRetry)
            lines.Add("You may attempt again (DC reduced by 1).");

        return string.Join(Environment.NewLine, lines);
    }
}

/// <summary>
/// The outcome categories for a jury-rigging attempt.
/// </summary>
public enum JuryRigOutcome
{
    /// <summary>Net successes > 0: Mechanism bypassed.</summary>
    Success,

    /// <summary>Net successes ≥ 5: Bypassed with salvage.</summary>
    CriticalSuccess,

    /// <summary>Net successes ≤ 0, no botches: Roll on complication table.</summary>
    Failure,

    /// <summary>Complication roll 8-9: One function works.</summary>
    PartialSuccess,

    /// <summary>0 successes and ≥1 botch: Mechanism destroyed.</summary>
    Fumble,

    /// <summary>Complication roll 1: Permanently locked.</summary>
    PermanentLock
}

/// <summary>
/// Extension methods for JuryRigOutcome.
/// </summary>
public static class JuryRigOutcomeExtensions
{
    /// <summary>
    /// Gets the display name for the outcome.
    /// </summary>
    public static string GetDisplayName(this JuryRigOutcome outcome) => outcome switch
    {
        JuryRigOutcome.Success => "BYPASS SUCCESSFUL",
        JuryRigOutcome.CriticalSuccess => "CRITICAL SUCCESS",
        JuryRigOutcome.Failure => "BYPASS FAILED",
        JuryRigOutcome.PartialSuccess => "PARTIAL SUCCESS",
        JuryRigOutcome.Fumble => "CATASTROPHIC FAILURE",
        JuryRigOutcome.PermanentLock => "PERMANENTLY LOCKED",
        _ => outcome.ToString()
    };
}
```

---

## 8. JuryRiggingService Implementation

### 8.1 Service Interface

**File:** `src/Core/RuneAndRust.Domain/Interfaces/IJuryRiggingService.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Interfaces;

/// <summary>
/// Service interface for the jury-rigging system.
/// Handles the five-step trial-and-error procedure for bypassing
/// Old World technology through improvised methods.
/// </summary>
public interface IJuryRiggingService
{
    /// <summary>
    /// Initiates a new jury-rigging attempt on a mechanism.
    /// </summary>
    /// <param name="characterId">The character attempting the bypass.</param>
    /// <param name="mechanismType">Category of the mechanism.</param>
    /// <param name="mechanismName">Display name of the mechanism.</param>
    /// <param name="baseDc">Base difficulty class.</param>
    /// <param name="isGlitched">Whether mechanism is in glitched state.</param>
    /// <returns>A new JuryRigState for tracking the attempt.</returns>
    JuryRigState InitiateJuryRig(
        string characterId,
        string mechanismType,
        string mechanismName,
        int baseDc,
        bool isGlitched);

    /// <summary>
    /// Performs the observation step (WITS DC 10).
    /// </summary>
    /// <param name="state">Current jury-rig state.</param>
    /// <param name="witsScore">Character's WITS attribute.</param>
    /// <param name="diceRoller">Dice rolling service.</param>
    /// <returns>Observation result with any revealed hints.</returns>
    ObservationResult PerformObservation(
        JuryRigState state,
        int witsScore,
        IDiceRoller diceRoller);

    /// <summary>
    /// Performs the probe step (automatic).
    /// </summary>
    /// <param name="state">Current jury-rig state.</param>
    /// <returns>Probe result with machine reactions.</returns>
    ProbeResult PerformProbe(JuryRigState state);

    /// <summary>
    /// Attempts pattern recognition (WITS DC 12).
    /// </summary>
    /// <param name="state">Current jury-rig state.</param>
    /// <param name="witsScore">Character's WITS attribute.</param>
    /// <param name="diceRoller">Dice rolling service.</param>
    /// <returns>Pattern recognition result.</returns>
    PatternResult AttemptPatternRecognition(
        JuryRigState state,
        int witsScore,
        IDiceRoller diceRoller);

    /// <summary>
    /// Gets available bypass methods for the current context.
    /// </summary>
    /// <param name="state">Current jury-rig state.</param>
    /// <returns>List of valid methods with descriptions.</returns>
    IReadOnlyList<MethodOption> GetAvailableMethods(JuryRigState state);

    /// <summary>
    /// Selects a bypass method for the experiment.
    /// </summary>
    /// <param name="state">Current jury-rig state.</param>
    /// <param name="method">The method to use.</param>
    void SelectMethod(JuryRigState state, BypassMethod method);

    /// <summary>
    /// Performs the experiment step with the selected method.
    /// </summary>
    /// <param name="state">Current jury-rig state.</param>
    /// <param name="context">Full context for the attempt.</param>
    /// <param name="systemBypassScore">Character's System Bypass skill.</param>
    /// <param name="diceRoller">Dice rolling service.</param>
    /// <returns>The result of the jury-rigging attempt.</returns>
    JuryRigResult PerformExperiment(
        JuryRigState state,
        JuryRigContext context,
        int systemBypassScore,
        IDiceRoller diceRoller);

    /// <summary>
    /// Processes the complication table for a failed attempt.
    /// </summary>
    /// <param name="roll">The d10 roll result (1-10).</param>
    /// <returns>The complication effect to apply.</returns>
    ComplicationEffect ProcessComplication(int roll);

    /// <summary>
    /// Applies iteration learning after a failed attempt.
    /// </summary>
    /// <param name="state">Current jury-rig state.</param>
    void ApplyIteration(JuryRigState state);
}

/// <summary>
/// Result of the observation step.
/// </summary>
/// <param name="Success">Whether observation succeeded.</param>
/// <param name="NetSuccesses">Number of net successes on the check.</param>
/// <param name="Hints">Hints revealed about the mechanism.</param>
/// <param name="NarrativeText">Descriptive text.</param>
public readonly record struct ObservationResult(
    bool Success,
    int NetSuccesses,
    IReadOnlyList<string> Hints,
    string NarrativeText);

/// <summary>
/// Result of the probe step.
/// </summary>
/// <param name="Reactions">Machine reactions observed.</param>
/// <param name="NarrativeText">Descriptive text.</param>
public readonly record struct ProbeResult(
    IReadOnlyList<string> Reactions,
    string NarrativeText);

/// <summary>
/// Result of pattern recognition.
/// </summary>
/// <param name="Success">Whether pattern was recognized.</param>
/// <param name="IsFamiliar">Whether this mechanism type is familiar.</param>
/// <param name="BonusDice">Bonus dice granted (2 if familiar).</param>
/// <param name="NarrativeText">Descriptive text.</param>
public readonly record struct PatternResult(
    bool Success,
    bool IsFamiliar,
    int BonusDice,
    string NarrativeText);

/// <summary>
/// A bypass method option with validity info.
/// </summary>
/// <param name="Method">The bypass method.</param>
/// <param name="IsAvailable">Whether method can be used.</param>
/// <param name="UnavailableReason">Why method is unavailable (if applicable).</param>
/// <param name="Description">Method description.</param>
/// <param name="DcModifier">DC modifier for this method.</param>
/// <param name="RiskDescription">Description of method risks.</param>
public readonly record struct MethodOption(
    BypassMethod Method,
    bool IsAvailable,
    string? UnavailableReason,
    string Description,
    int DcModifier,
    string RiskDescription);
```

### 8.2 Service Implementation

**File:** `src/Core/RuneAndRust.Domain/Services/JuryRiggingService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Implements the jury-rigging system for bypassing Old World technology
/// through trial-and-error improvisation.
/// </summary>
public class JuryRiggingService : IJuryRiggingService
{
    private readonly ICharacterRepository _characterRepository;
    private readonly ILogger<JuryRiggingService> _logger;

    private const int ObservationDC = 10;
    private const int PatternRecognitionDC = 12;
    private const int CriticalSuccessThreshold = 5;
    private const int FamiliarityBonusDice = 2;

    public JuryRiggingService(
        ICharacterRepository characterRepository,
        ILogger<JuryRiggingService> logger)
    {
        _characterRepository = characterRepository;
        _logger = logger;
    }

    /// <inheritdoc/>
    public JuryRigState InitiateJuryRig(
        string characterId,
        string mechanismType,
        string mechanismName,
        int baseDc,
        bool isGlitched)
    {
        // Check if character is familiar with this mechanism type
        var isFamiliar = _characterRepository.HasBypassedMechanismType(
            characterId, mechanismType);

        var state = JuryRigState.Create(
            juryRigId: Guid.NewGuid().ToString(),
            characterId: characterId,
            mechanismType: mechanismType,
            mechanismName: mechanismName,
            baseDc: baseDc,
            isGlitched: isGlitched,
            isFamiliar: isFamiliar);

        _logger.LogInformation(
            "Jury-rig initiated: {JuryRigId} on {MechanismName} (DC {BaseDC}, Glitched: {IsGlitched}, Familiar: {IsFamiliar})",
            state.JuryRigId, mechanismName, baseDc, isGlitched, isFamiliar);

        return state;
    }

    /// <inheritdoc/>
    public ObservationResult PerformObservation(
        JuryRigState state,
        int witsScore,
        IDiceRoller diceRoller)
    {
        var rollResult = diceRoller.RollSkillCheck(witsScore, ObservationDC);

        var hints = new List<string>();
        string narrative;

        if (rollResult.NetSuccesses > 0)
        {
            hints.Add($"This is a {state.MechanismType} mechanism");
            hints.Add($"Base difficulty appears to be DC {state.BaseDC}");

            if (state.IsGlitched)
                hints.Add("The mechanism exhibits erratic [Glitched] behavior");

            if (rollResult.NetSuccesses >= 3)
                hints.Add("You notice potential access points for wire manipulation");

            narrative = "You study the machine's exterior, identifying control surfaces and potential weak points.";
        }
        else
        {
            narrative = "The machine's purpose remains inscrutable. Its alien design defies your understanding.";
        }

        state.CompleteObservation(rollResult.NetSuccesses > 0, hints);

        _logger.LogDebug(
            "Observation complete: {Success} ({NetSuccesses} net)",
            rollResult.NetSuccesses > 0, rollResult.NetSuccesses);

        return new ObservationResult(
            Success: rollResult.NetSuccesses > 0,
            NetSuccesses: rollResult.NetSuccesses,
            Hints: hints.AsReadOnly(),
            NarrativeText: narrative);
    }

    /// <inheritdoc/>
    public ProbeResult PerformProbe(JuryRigState state)
    {
        var reactions = new List<string>
        {
            "A panel lights up briefly when pressed",
            "Something clicks inside the mechanism",
            "A low hum emanates from within"
        };

        if (state.IsGlitched)
        {
            reactions.Add("The lights flicker erratically");
            reactions.Add("Strange symbols flash across a display");
        }

        state.CompleteProbe(reactions);

        var narrative = "You press obvious buttons and pull accessible levers. " +
                       "The machine reacts, though the meaning of its responses remains unclear.";

        _logger.LogDebug("Probe complete for {JuryRigId}", state.JuryRigId);

        return new ProbeResult(
            Reactions: reactions.AsReadOnly(),
            NarrativeText: narrative);
    }

    /// <inheritdoc/>
    public PatternResult AttemptPatternRecognition(
        JuryRigState state,
        int witsScore,
        IDiceRoller diceRoller)
    {
        var rollResult = diceRoller.RollSkillCheck(witsScore, PatternRecognitionDC);

        bool recognized = rollResult.NetSuccesses > 0;
        bool familiar = state.IsFamiliarMechanism;
        int bonusDice = (recognized && familiar) ? FamiliarityBonusDice : 0;
        string narrative;

        if (recognized)
        {
            if (familiar)
            {
                narrative = $"You recognize this mechanism type! You've successfully bypassed " +
                           $"{state.MechanismType} systems before. Your experience grants +{FamiliarityBonusDice}d10.";
            }
            else
            {
                narrative = $"You identify this as a {state.MechanismType} mechanism. " +
                           "While unfamiliar, you now have a framework for experimentation.";

                // Mark as seen for future encounters
                _characterRepository.RecordMechanismTypeSeen(
                    state.CharacterId, state.MechanismType);
            }
        }
        else
        {
            narrative = "The mechanism's patterns elude you. You'll have to proceed blind.";
        }

        state.CompletePatternRecognition(recognized);

        _logger.LogDebug(
            "Pattern recognition: {Recognized}, Familiar: {Familiar}, Bonus: {BonusDice}d10",
            recognized, familiar, bonusDice);

        return new PatternResult(
            Success: recognized,
            IsFamiliar: familiar,
            BonusDice: bonusDice,
            NarrativeText: narrative);
    }

    /// <inheritdoc/>
    public IReadOnlyList<MethodOption> GetAvailableMethods(JuryRigState state)
    {
        var methods = new List<MethodOption>();

        foreach (BypassMethod method in Enum.GetValues<BypassMethod>())
        {
            var isAvailable = true;
            string? unavailableReason = null;

            // Check familiarity requirement
            if (method.RequiresFamiliarity() && !state.IsFamiliarMechanism)
            {
                isAvailable = false;
                unavailableReason = "Requires familiarity with this mechanism type";
            }

            // Check glitch requirement
            if (method.RequiresGlitchedMechanism() && !state.IsGlitched)
            {
                isAvailable = false;
                unavailableReason = "Mechanism must be [Glitched]";
            }

            methods.Add(new MethodOption(
                Method: method,
                IsAvailable: isAvailable,
                UnavailableReason: unavailableReason,
                Description: GetMethodDescription(method),
                DcModifier: method.GetDcModifier(),
                RiskDescription: GetMethodRiskDescription(method)));
        }

        return methods.AsReadOnly();
    }

    /// <inheritdoc/>
    public void SelectMethod(JuryRigState state, BypassMethod method)
    {
        state.SelectMethod(method);

        _logger.LogDebug(
            "Method selected for {JuryRigId}: {Method}",
            state.JuryRigId, method.GetDisplayName());
    }

    /// <inheritdoc/>
    public JuryRigResult PerformExperiment(
        JuryRigState state,
        JuryRigContext context,
        int systemBypassScore,
        IDiceRoller diceRoller)
    {
        var modifiedDC = state.GetModifiedDC();
        var dicePool = systemBypassScore + context.TotalDiceModifier;

        _logger.LogDebug(
            "Experiment: {Method}, DC {ModifiedDC}, Pool {DicePool}d10",
            context.MethodUsed.GetDisplayName(), modifiedDC, dicePool);

        var rollResult = diceRoller.RollSkillCheck(dicePool, modifiedDC);

        JuryRigResult result;

        // Check for fumble (0 successes, ≥1 botch)
        if (rollResult.IsFumble)
        {
            result = JuryRigResult.Fumble(
                context.MethodUsed,
                "Your attempt goes catastrophically wrong! The mechanism sparks, smokes, " +
                "and falls silent—permanently destroyed beyond any hope of repair.");
        }
        // Check for critical success (net ≥5)
        else if (rollResult.NetSuccesses >= CriticalSuccessThreshold)
        {
            var salvage = GetSalvageForMechanismType(state.MechanismType);
            result = JuryRigResult.CriticalSuccess(
                rollResult.NetSuccesses,
                context.MethodUsed,
                salvage,
                "The mechanism yields to your touch as if recognizing a long-lost operator! " +
                "As it opens, you notice salvageable components you can claim.");

            // Record successful bypass for familiarity
            _characterRepository.RecordMechanismBypassed(
                state.CharacterId, state.MechanismType);
        }
        // Check for success (net >0)
        else if (rollResult.NetSuccesses > 0)
        {
            result = JuryRigResult.Success(
                rollResult.NetSuccesses,
                context.MethodUsed,
                "With a satisfying click, the mechanism responds to your improvised approach. " +
                "The bypass is complete.");

            // Record successful bypass for familiarity
            _characterRepository.RecordMechanismBypassed(
                state.CharacterId, state.MechanismType);
        }
        // Failure - roll on complication table
        else
        {
            var complicationRoll = diceRoller.RollD10();
            var effect = ProcessComplication(complicationRoll);
            result = ResolveComplication(
                rollResult.NetSuccesses,
                context.MethodUsed,
                complicationRoll,
                effect,
                state.MechanismType);
        }

        state.RecordAttempt(result);

        _logger.LogInformation(
            "Jury-rig experiment result: {Outcome} for {JuryRigId}",
            result.Outcome, state.JuryRigId);

        return result;
    }

    /// <inheritdoc/>
    public ComplicationEffect ProcessComplication(int roll)
    {
        return roll switch
        {
            1 => ComplicationEffect.PermanentLock,
            2 or 3 => ComplicationEffect.AlarmTriggered,
            4 or 5 => ComplicationEffect.SparksFly,
            6 or 7 => ComplicationEffect.Nothing,
            8 or 9 => ComplicationEffect.PartialSuccess,
            10 => ComplicationEffect.GlitchInFavor,
            _ => ComplicationEffect.Nothing
        };
    }

    /// <inheritdoc/>
    public void ApplyIteration(JuryRigState state)
    {
        state.ApplyIteration();

        _logger.LogDebug(
            "Iteration applied for {JuryRigId}: now at iteration {Count}",
            state.JuryRigId, state.IterationCount);
    }

    private JuryRigResult ResolveComplication(
        int netSuccesses,
        BypassMethod method,
        int complicationRoll,
        ComplicationEffect effect,
        string mechanismType)
    {
        return effect switch
        {
            ComplicationEffect.PermanentLock => JuryRigResult.Failure(
                netSuccesses, method, complicationRoll, effect, 0, null,
                "Something inside the mechanism clicks ominously. A final, decisive lock engages—" +
                "no further attempts will be possible."),

            ComplicationEffect.AlarmTriggered => JuryRigResult.Failure(
                netSuccesses, method, complicationRoll, effect, 0, null,
                "An alarm klaxon begins wailing! Your tampering has been detected. " +
                "Nearby hostiles are alerted to your presence."),

            ComplicationEffect.SparksFly => JuryRigResult.Failure(
                netSuccesses, method, complicationRoll, effect,
                6, // 1d6 average
                DamageType.Electrical,
                "Sparks erupt from the mechanism, burning your hands! " +
                "You take electrical damage from the discharge."),

            ComplicationEffect.Nothing => JuryRigResult.Failure(
                netSuccesses, method, complicationRoll, effect, 0, null,
                "The mechanism buzzes indifferently. Your attempt achieves nothing, " +
                "but at least nothing goes wrong. You may try again."),

            ComplicationEffect.PartialSuccess => JuryRigResult.PartialSuccess(
                netSuccesses, method, complicationRoll,
                "Primary function", // Would be mechanism-specific
                "The mechanism partially responds! While not fully bypassed, " +
                "one of its functions activates. You may be able to use this."),

            ComplicationEffect.GlitchInFavor => JuryRigResult.Success(
                1, method,
                "The machine's own instability works in your favor! " +
                "A fortuitous glitch causes the mechanism to bypass itself."),

            _ => JuryRigResult.Failure(
                netSuccesses, method, complicationRoll, effect, 0, null,
                "The attempt fails without notable consequence.")
        };
    }

    private static string GetMethodDescription(BypassMethod method) => method switch
    {
        BypassMethod.PercussiveMaintenance =>
            "Strike the mechanism with calculated force to jar components into alignment.",
        BypassMethod.WireManipulation =>
            "Access internal wiring to bypass security circuits directly.",
        BypassMethod.GlitchExploitation =>
            "Exploit the mechanism's corrupted behavior to slip past its defenses.",
        BypassMethod.MemorizedSequence =>
            "Apply a button sequence learned from previous successful bypasses.",
        BypassMethod.BruteDisassembly =>
            "Tear the mechanism apart to force access, destroying it in the process.",
        BypassMethod.PowerCycling =>
            "Cut and restore power to reset the mechanism to its default state.",
        _ => "Unknown method."
    };

    private static string GetMethodRiskDescription(BypassMethod method) => method switch
    {
        BypassMethod.PercussiveMaintenance => "May permanently break the mechanism on fumble",
        BypassMethod.WireManipulation => "Electrocution risk: FINESSE DC 12 or 2d10 lightning",
        BypassMethod.GlitchExploitation => "Unpredictable: chaos roll determines actual effect",
        BypassMethod.MemorizedSequence => "Only works on mechanism types you've bypassed before",
        BypassMethod.BruteDisassembly => "Destroys the mechanism, but guarantees component salvage",
        BypassMethod.PowerCycling => "Resets all progress, including partial successes",
        _ => "Unknown risk."
    };

    private static IReadOnlyList<string> GetSalvageForMechanismType(string mechanismType)
    {
        // Simplified salvage - would be configuration-driven
        return new[]
        {
            "[Circuit Fragment]",
            "[Power Cell]"
        };
    }
}

/// <summary>
/// The effects from the complication table.
/// </summary>
public enum ComplicationEffect
{
    /// <summary>d10 = 1: Machine locks permanently.</summary>
    PermanentLock,

    /// <summary>d10 = 2-3: Alarm triggers.</summary>
    AlarmTriggered,

    /// <summary>d10 = 4-5: Sparks fly (1d6 damage).</summary>
    SparksFly,

    /// <summary>d10 = 6-7: Nothing happens.</summary>
    Nothing,

    /// <summary>d10 = 8-9: One function works.</summary>
    PartialSuccess,

    /// <summary>d10 = 10: Machine glitches in your favor.</summary>
    GlitchInFavor
}
```

---

## 9. Trial-and-Error Procedure

### 9.1 Procedure Overview

The trial-and-error procedure represents how characters in Aethelgard interact with Old World technology they cannot truly understand. Rather than systematic troubleshooting, they observe, poke, recognize patterns from past experience, and experiment until something works—or breaks.

### 9.2 Step Details

| Step | Name | Type | Check | DC | Outcome on Success | Outcome on Failure |
|------|------|------|-------|----|--------------------|-------------------|
| 1 | Observe | Optional | WITS | 10 | Identify mechanism type, reveal inputs | No hints, proceed blind |
| 2 | Probe | Automatic | — | — | Machine reacts, establish baseline | — |
| 3 | Pattern | Optional | WITS | 12 | +2d10 if familiar mechanism | No familiarity bonus |
| 4 | Experiment | Required | System Bypass | Modified | Bypass successful | Roll on complication table |
| 5 | Iterate | Automatic | — | — | DC -1 for next attempt | — |

### 9.3 Step Flowchart

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    TRIAL-AND-ERROR PROCEDURE                                 │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────┐
│   START     │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────────────┐
│  STEP 1: OBSERVE (Optional)             │
│  ─────────────────────────              │
│  Can skip → go to Step 2                │
│                                         │
│  WITS check DC 10                       │
│  ┌─────────────┐  ┌─────────────┐       │
│  │ Success     │  │ Failure     │       │
│  │ Learn type  │  │ No hints    │       │
│  │ See inputs  │  │ Proceed     │       │
│  └──────┬──────┘  └──────┬──────┘       │
└─────────┼────────────────┼──────────────┘
          └───────┬────────┘
                  ▼
┌─────────────────────────────────────────┐
│  STEP 2: PROBE (Automatic)              │
│  ─────────────────────────              │
│  No roll required                       │
│                                         │
│  Press buttons, pull levers             │
│  Observe machine reactions              │
│  Establish baseline behavior            │
└──────────────────┬──────────────────────┘
                   ▼
┌─────────────────────────────────────────┐
│  STEP 3: PATTERN (Optional)             │
│  ─────────────────────────              │
│  Can skip → go to Step 4                │
│                                         │
│  WITS check DC 12                       │
│  ┌─────────────┐  ┌─────────────┐       │
│  │ Success     │  │ Failure     │       │
│  │ If familiar │  │ No bonus    │       │
│  │ +2d10 bonus │  │             │       │
│  └──────┬──────┘  └──────┬──────┘       │
└─────────┼────────────────┼──────────────┘
          └───────┬────────┘
                  ▼
┌─────────────────────────────────────────┐
│  SELECT BYPASS METHOD                   │
│  ─────────────────────────              │
│  Choose from available methods          │
│  Each has DC modifier and risk          │
└──────────────────┬──────────────────────┘
                   ▼
┌─────────────────────────────────────────┐
│  STEP 4: EXPERIMENT (Required)          │
│  ─────────────────────────              │
│  System Bypass vs Modified DC           │
│                                         │
│  Dice Pool = Skill + Tools + Familiar   │
│  DC = Base + Method + Corruption - Iter │
│                                         │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │Critical │ │ Success │ │ Failure │   │
│  │ Net ≥5  │ │ Net >0  │ │ Net ≤0  │   │
│  │ +Salvage│ │ Bypass! │ │ Complica│   │
│  └────┬────┘ └────┬────┘ └────┬────┘   │
│       │           │           │        │
│  ┌────┴───────────┴───┐   ┌───┴─────┐  │
│  │      DONE!         │   │ Roll d10│  │
│  └────────────────────┘   └────┬────┘  │
│                               │        │
│                          COMPLICATION  │
│                          TABLE ────────┼─┐
└────────────────────────────────────────┘ │
                                           │
       ┌───────────────────────────────────┘
       ▼
┌─────────────────────────────────────────┐
│  COMPLICATION RESULTS                   │
│  ─────────────────────────              │
│  1: Permanent lock → END                │
│  2-3: Alarm → Continue allowed          │
│  4-5: Sparks (1d6) → Continue allowed   │
│  6-7: Nothing → Continue allowed        │
│  8-9: Partial success → Function works  │
│  10: Glitch favor → Auto-success!       │
└──────────────────┬──────────────────────┘
                   │
        (if not 1 or 10)
                   ▼
┌─────────────────────────────────────────┐
│  STEP 5: ITERATE (Automatic)            │
│  ─────────────────────────              │
│  Learn from failure                     │
│  DC -1 for next attempt                 │
│  May choose different method            │
│                                         │
│  Return to Step 4 (Method Selection)    │
└──────────────────┬──────────────────────┘
                   │
                   ▼
              (Loop back)
```

### 9.4 Familiarity System

Characters build familiarity with mechanism types over time:

| Event | Effect |
|-------|--------|
| First time seeing mechanism type | Marked as "seen" (no bonus yet) |
| Successfully bypassing mechanism type | Marked as "familiar" |
| Future encounters with familiar type | +2d10 bonus dice on experiment |

**Mechanism Type Categories:**
- Security Terminal
- Cargo Lock
- Vault Door
- Power Junction
- Automated Defense
- Jötun Archive
- Environmental Control
- Communication Array

---

## 10. Complication Table

### 10.1 Table Definition

| d10 Roll | Effect Name | Description | Consequences |
|----------|-------------|-------------|--------------|
| 1 | Permanent Lock | Machine locks permanently | No further attempts possible |
| 2-3 | Alarm Triggers | Security alert broadcast | Enemies alerted, +2 encounter chance |
| 4-5 | Sparks Fly | Electrical discharge | Take 1d6 electrical damage |
| 6-7 | Nothing | No effect | May attempt again |
| 8-9 | Partial Success | One function works | Limited access granted |
| 10 | Glitch in Favor | Lucky malfunction | Automatic success |

### 10.2 Complication Details

#### Permanent Lock (d10 = 1)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ⚠️  PERMANENT LOCK                                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  The mechanism detects your tampering and engages a final lockout protocol. │
│  A deep clunk echoes from within as internal bolts slide into place.        │
│                                                                              │
│  Effect: No further jury-rigging attempts are possible.                      │
│  Alternative: Must find key, destroy mechanism, or find alternate route.    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Alarm Triggers (d10 = 2-3)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  🔔 ALARM TRIGGERED                                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  Your fumbling activates a security protocol! A klaxon begins wailing,      │
│  and warning lights flash throughout the area.                               │
│                                                                              │
│  Effect: Enemies within earshot are alerted.                                │
│  Mechanical: +2 to encounter check, guards investigate in 1d4 rounds.       │
│  Retry: You may continue attempting (alarm already sounding anyway).        │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Sparks Fly (d10 = 4-5)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ⚡ SPARKS FLY                                                               │
├─────────────────────────────────────────────────────────────────────────────┤
│  A shower of sparks erupts from the mechanism, burning your hands and face! │
│  The acrid smell of ozone fills the air.                                    │
│                                                                              │
│  Effect: Take 1d6 electrical damage.                                        │
│  Retry: You may continue attempting (mechanism still functional).           │
│  Note: Damage is NOT reduced by armor.                                      │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Nothing (d10 = 6-7)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ✓ NOTHING HAPPENS                                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│  The mechanism buzzes indifferently. Your attempt achieves nothing,          │
│  but nothing goes wrong either. The machine waits, impassive as ever.       │
│                                                                              │
│  Effect: No change to mechanism state.                                       │
│  Retry: You may attempt again (DC reduced by 1 from iteration).             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Partial Success (d10 = 8-9)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ◐ PARTIAL SUCCESS                                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│  The mechanism partially responds! While not fully bypassed, one of its     │
│  secondary functions activates. This may be enough for your purposes.       │
│                                                                              │
│  Effect: One function of mechanism works (e.g., display activates,          │
│          secondary door opens, limited access granted).                      │
│  Retry: You may continue attempting for full access.                         │
│  Note: Specific function depends on mechanism type.                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Glitch in Favor (d10 = 10)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  ★ GLITCH IN YOUR FAVOR                                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  The machine's own instability works in your favor! A fortuitous glitch     │
│  causes the mechanism to bypass itself, flickering and then granting access.│
│                                                                              │
│  Effect: Automatic success! Mechanism is bypassed.                           │
│  Flavor: The Old World technology, corrupted by centuries, helps you        │
│          despite your lack of true understanding.                            │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 11. Electrocution Risk System

### 11.1 Overview

Wire Manipulation offers a significant DC reduction (-2) but carries the risk of electrocution. Before proceeding with the bypass, characters must make a FINESSE save to safely handle live wires.

### 11.2 Mechanics

| Aspect | Value |
|--------|-------|
| Trigger | Wire Manipulation method selected |
| Save | FINESSE |
| DC | 12 |
| Damage on Failure | 2d10 lightning |
| Success | Proceed with bypass at -2 DC |

### 11.3 Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    ELECTROCUTION RISK FLOW                                   │
└─────────────────────────────────────────────────────────────────────────────┘

    Player selects Wire Manipulation
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ⚡ ELECTROCUTION RISK CHECK                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  "As you reach toward the exposed wiring, you feel the hairs on your arm    │
│   stand up from the latent charge. One wrong move could be shocking."       │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
        FINESSE Save DC 12
                │
       ┌────────┴────────┐
       ▼                 ▼
┌─────────────┐   ┌─────────────┐
│  SUCCESS    │   │  FAILURE    │
├─────────────┤   ├─────────────┤
│ "Your deft  │   │ "A jolt of  │
│ fingers     │   │ current     │
│ navigate    │   │ courses     │
│ the wires   │   │ through     │
│ safely."    │   │ your body!" │
│             │   │             │
│ Proceed to  │   │ Take 2d10   │
│ bypass at   │   │ lightning   │
│ -2 DC       │   │ damage      │
└──────┬──────┘   └──────┬──────┘
       │                 │
       │          ┌──────┴──────┐
       │          ▼             ▼
       │   ┌─────────────┐ ┌─────────────┐
       │   │ Still alive │ │ Incapacit-  │
       │   │ Continue?   │ │ ated        │
       │   │ [Yes/No]    │ │ Abort       │
       │   └──────┬──────┘ └─────────────┘
       │          │
       └──────────┴──────┐
                         ▼
              Continue to Experiment step
              (with -2 DC from wire manipulation)
```

### 11.4 Implementation

**File:** `src/Core/RuneAndRust.Domain/Services/ElectrocutionRiskService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Handles electrocution risk checks for wire manipulation bypass attempts.
/// </summary>
public class ElectrocutionRiskService : IElectrocutionRiskService
{
    private readonly ILogger<ElectrocutionRiskService> _logger;

    private const int ElectrocutionSaveDC = 12;
    private const int ElectrocutionDamageDiceCount = 2;
    private const int ElectrocutionDamageDiceSize = 10;

    public ElectrocutionRiskService(ILogger<ElectrocutionRiskService> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Evaluates whether a jury-rigging context has electrocution risk.
    /// </summary>
    /// <param name="context">The jury-rigging context.</param>
    /// <returns>True if electrocution save is required.</returns>
    public bool EvaluateRisk(JuryRigContext context)
    {
        return context.ElectrocutionRisk;
    }

    /// <summary>
    /// Attempts the FINESSE save to avoid electrocution.
    /// </summary>
    /// <param name="finesseScore">Character's FINESSE attribute.</param>
    /// <param name="diceRoller">Dice rolling service.</param>
    /// <returns>The save result.</returns>
    public ElectrocutionSaveResult AttemptSave(
        int finesseScore,
        IDiceRoller diceRoller)
    {
        var rollResult = diceRoller.RollSave(finesseScore, ElectrocutionSaveDC);

        _logger.LogDebug(
            "Electrocution save: {NetSuccesses} net successes vs DC {DC}",
            rollResult.NetSuccesses, ElectrocutionSaveDC);

        if (rollResult.NetSuccesses > 0)
        {
            return new ElectrocutionSaveResult(
                SaveSucceeded: true,
                DamageRolled: 0,
                NarrativeText: "Your deft fingers navigate the live wiring with practiced care. " +
                              "The current hums around you but never finds a path through your body.");
        }

        // Failed save - roll damage
        var damage = diceRoller.RollDamage(
            ElectrocutionDamageDiceCount,
            ElectrocutionDamageDiceSize);

        return new ElectrocutionSaveResult(
            SaveSucceeded: false,
            DamageRolled: damage,
            NarrativeText: $"A violent jolt of current courses through your body! " +
                          $"You take {damage} lightning damage as electricity arcs through you.");
    }

    /// <summary>
    /// Gets the DC for the electrocution save.
    /// </summary>
    public int GetSaveDC() => ElectrocutionSaveDC;

    /// <summary>
    /// Gets the damage dice expression.
    /// </summary>
    public string GetDamageExpression() =>
        $"{ElectrocutionDamageDiceCount}d{ElectrocutionDamageDiceSize}";
}

/// <summary>
/// Result of an electrocution save attempt.
/// </summary>
/// <param name="SaveSucceeded">Whether the FINESSE save succeeded.</param>
/// <param name="DamageRolled">Damage taken on failure (0 on success).</param>
/// <param name="NarrativeText">Descriptive text for the result.</param>
public readonly record struct ElectrocutionSaveResult(
    bool SaveSucceeded,
    int DamageRolled,
    string NarrativeText);
```

---

## 12. Data Model Changes

### 12.1 New Entities

| Entity | Layer | Description |
|--------|-------|-------------|
| `JuryRigState` | Domain | Tracks ongoing jury-rigging attempts through the five-step procedure |

### 12.2 New Value Objects

| Value Object | Layer | Description |
|--------------|-------|-------------|
| `JuryRigContext` | Domain | Captures method, tools, familiarity, and risk factors |
| `JuryRigResult` | Domain | Captures outcome, complications, damage, and salvage |
| `ComplicationRoll` | Domain | The d10 roll for complication table |
| `ElectrocutionSaveResult` | Domain | Result of electrocution risk save |

### 12.3 New Enums

| Enum | Layer | Description |
|------|-------|-------------|
| `BypassMethod` | Domain | Six methods for jury-rigging (Percussive, Wire, Glitch, etc.) |
| `JuryRigStep` | Domain | Five steps in trial-and-error (Observe, Probe, Pattern, Experiment, Iterate) |
| `JuryRigStatus` | Domain | Status of attempt (InProgress, Bypassed, Destroyed, etc.) |
| `JuryRigOutcome` | Domain | Outcome categories (Success, Critical, Failure, Fumble, etc.) |
| `ComplicationEffect` | Domain | Complication table effects (PermanentLock, Alarm, Sparks, etc.) |

### 12.4 Entity Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      JURY-RIGGING DATA MODEL                                 │
└─────────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────┐
│         JuryRigState          │
│         (Entity)              │
├───────────────────────────────┤
│ + JuryRigId: string          │
│ + CharacterId: string        │
│ + MechanismType: string      │
│ + MechanismName: string      │
│ + CurrentStep: JuryRigStep   │
│ + SelectedMethod: BypassMethod?│
│ + IterationCount: int        │
│ + BaseDC: int                │
│ + IsGlitched: bool           │
│ + IsFamiliarMechanism: bool  │
│ + Status: JuryRigStatus      │
│ + RevealedHints: List<string>│
│ + PreviousAttempts: List<>   │───────┐
└───────────────────────────────┘       │
        │                               │
        │ uses                          │ contains
        ▼                               ▼
┌───────────────────────────────┐ ┌───────────────────────────────┐
│       JuryRigContext          │ │        JuryRigResult          │
│       (Value Object)          │ │       (Value Object)          │
├───────────────────────────────┤ ├───────────────────────────────┤
│ + MethodUsed: BypassMethod   │ │ + Outcome: JuryRigOutcome     │
│ + FamiliarMechanism: bool    │ │ + NetSuccesses: int           │
│ + ToolsAvailable: ToolQuality│ │ + ComplicationRoll: int?      │
│ + ElectrocutionRisk: bool    │ │ + ComplicationEffect: Effect? │
│ + ComplicationRoll: int?     │ │ + DamageDealt: int            │
└───────────────────────────────┘ │ + DamageType: DamageType?     │
                                  │ + SalvagedComponents: List<>  │
                                  │ + NarrativeText: string       │
                                  │ + MethodUsed: BypassMethod    │
                                  └───────────────────────────────┘

┌───────────────────────────────┐ ┌───────────────────────────────┐
│       BypassMethod            │ │     ComplicationEffect        │
│         (Enum)                │ │         (Enum)                │
├───────────────────────────────┤ ├───────────────────────────────┤
│ PercussiveMaintenance = 0    │ │ PermanentLock                 │
│ WireManipulation = 1         │ │ AlarmTriggered                │
│ GlitchExploitation = 2       │ │ SparksFly                     │
│ MemorizedSequence = 3        │ │ Nothing                       │
│ BruteDisassembly = 4         │ │ PartialSuccess                │
│ PowerCycling = 5             │ │ GlitchInFavor                 │
└───────────────────────────────┘ └───────────────────────────────┘
```

---

## 13. Configuration Files

### 13.1 bypass-methods.json

**File:** `config/bypass-methods.json`

```json
{
  "$schema": "./schemas/bypass-methods.schema.json",
  "methods": [
    {
      "id": "percussive_maintenance",
      "displayName": "Percussive Maintenance",
      "description": "Strike the mechanism with calculated force to jar components into alignment.",
      "dcModifier": 0,
      "requiresFamiliarity": false,
      "requiresGlitched": false,
      "destroysMechanism": false,
      "electrocutionRisk": false,
      "risks": [
        "May permanently break the mechanism on fumble"
      ],
      "narrativeOnUse": "You raise your hand and deliver a firm, precise strike to the mechanism's casing.",
      "narrativeOnSuccess": "With a satisfying clunk, something inside shifts into place.",
      "narrativeOnFailure": "The blow reverberates through the machine, but nothing changes."
    },
    {
      "id": "wire_manipulation",
      "displayName": "Wire Manipulation",
      "description": "Access internal wiring to bypass security circuits directly.",
      "dcModifier": -2,
      "requiresFamiliarity": false,
      "requiresGlitched": false,
      "destroysMechanism": false,
      "electrocutionRisk": true,
      "electrocutionSaveDc": 12,
      "electrocutionDamage": "2d10",
      "risks": [
        "Electrocution risk: FINESSE DC 12 or 2d10 lightning damage"
      ],
      "narrativeOnUse": "You pry open an access panel and reach into the tangle of wires within.",
      "narrativeOnSuccess": "Sparks fly as you short the correct circuits, and the mechanism yields.",
      "narrativeOnFailure": "The wires refuse to cooperate, resisting your amateur surgery."
    },
    {
      "id": "glitch_exploitation",
      "displayName": "Glitch Exploitation",
      "description": "Exploit the mechanism's corrupted behavior to slip past its defenses.",
      "dcModifier": -4,
      "requiresFamiliarity": false,
      "requiresGlitched": true,
      "destroysMechanism": false,
      "electrocutionRisk": false,
      "risks": [
        "Unpredictable: chaos roll determines actual effect",
        "Only works on [Glitched] mechanisms"
      ],
      "narrativeOnUse": "You observe the mechanism's erratic behavior, waiting for a pattern to emerge.",
      "narrativeOnSuccess": "The glitch cycles around to a permissive state, and you slip through!",
      "narrativeOnFailure": "The corruption proves too chaotic to exploit reliably."
    },
    {
      "id": "memorized_sequence",
      "displayName": "Memorized Sequence",
      "description": "Apply a button sequence learned from previous successful bypasses.",
      "dcModifier": -2,
      "requiresFamiliarity": true,
      "requiresGlitched": false,
      "destroysMechanism": false,
      "electrocutionRisk": false,
      "risks": [
        "Only works on mechanism types you've bypassed before"
      ],
      "narrativeOnUse": "Your fingers move from memory, pressing buttons in a sequence you've used before.",
      "narrativeOnSuccess": "The familiar pattern works! The mechanism recognizes the sequence.",
      "narrativeOnFailure": "This machine's variation defeats your memorized approach."
    },
    {
      "id": "brute_disassembly",
      "displayName": "Brute Disassembly",
      "description": "Tear the mechanism apart to force access, destroying it in the process.",
      "dcModifier": 2,
      "requiresFamiliarity": false,
      "requiresGlitched": false,
      "destroysMechanism": true,
      "electrocutionRisk": false,
      "guaranteesSalvage": true,
      "risks": [
        "Destroys the mechanism permanently",
        "Cannot be reused after success"
      ],
      "narrativeOnUse": "You begin systematically dismantling the mechanism, prying off panels and disconnecting components.",
      "narrativeOnSuccess": "The mechanism lies in pieces around you, but you've achieved your goal.",
      "narrativeOnFailure": "Your disassembly goes awry, jamming components together more tightly."
    },
    {
      "id": "power_cycling",
      "displayName": "Power Cycling",
      "description": "Cut and restore power to reset the mechanism to its default state.",
      "dcModifier": 0,
      "requiresFamiliarity": false,
      "requiresGlitched": false,
      "destroysMechanism": false,
      "electrocutionRisk": false,
      "resetsMechanismState": true,
      "risks": [
        "Resets all progress, including partial successes",
        "May lose favorable glitch states"
      ],
      "narrativeOnUse": "You locate the power conduit and interrupt the flow of energy.",
      "narrativeOnSuccess": "The mechanism reboots to a default, more permissive state!",
      "narrativeOnFailure": "The power cycle completes, but the mechanism returns to its locked state."
    }
  ]
}
```

### 13.2 complication-table.json

**File:** `config/complication-table.json`

```json
{
  "$schema": "./schemas/complication-table.schema.json",
  "tableName": "Jury-Rigging Complication Table",
  "diceType": "d10",
  "entries": [
    {
      "rollRange": [1, 1],
      "effect": "permanent_lock",
      "displayName": "Permanent Lock",
      "description": "The mechanism detects tampering and engages a final lockout protocol.",
      "consequences": {
        "mechanismLocked": true,
        "retriesAllowed": false
      },
      "narrativeText": "Something inside the mechanism clicks ominously. A final, decisive lock engages—no further attempts will be possible."
    },
    {
      "rollRange": [2, 3],
      "effect": "alarm_triggered",
      "displayName": "Alarm Triggered",
      "description": "Your fumbling activates a security protocol.",
      "consequences": {
        "alertNearbyEnemies": true,
        "encounterModifier": 2,
        "guardResponseRounds": "1d4"
      },
      "narrativeText": "An alarm klaxon begins wailing! Your tampering has been detected. Nearby hostiles are alerted to your presence."
    },
    {
      "rollRange": [4, 5],
      "effect": "sparks_fly",
      "displayName": "Sparks Fly",
      "description": "A shower of sparks erupts from the mechanism.",
      "consequences": {
        "damage": "1d6",
        "damageType": "electrical",
        "ignoresArmor": true
      },
      "narrativeText": "A shower of sparks erupts from the mechanism, burning your hands and face! The acrid smell of ozone fills the air."
    },
    {
      "rollRange": [6, 7],
      "effect": "nothing",
      "displayName": "Nothing Happens",
      "description": "The mechanism buzzes indifferently.",
      "consequences": {
        "retriesAllowed": true
      },
      "narrativeText": "The mechanism buzzes indifferently. Your attempt achieves nothing, but at least nothing goes wrong. You may try again."
    },
    {
      "rollRange": [8, 9],
      "effect": "partial_success",
      "displayName": "Partial Success",
      "description": "The mechanism partially responds.",
      "consequences": {
        "partialAccessGranted": true,
        "functionActivated": "secondary"
      },
      "narrativeText": "The mechanism partially responds! While not fully bypassed, one of its functions activates. This may be enough for your purposes."
    },
    {
      "rollRange": [10, 10],
      "effect": "glitch_in_favor",
      "displayName": "Glitch in Your Favor",
      "description": "The machine's own instability works in your favor.",
      "consequences": {
        "automaticSuccess": true
      },
      "narrativeText": "The machine's own instability works in your favor! A fortuitous glitch causes the mechanism to bypass itself."
    }
  ]
}
```

### 13.3 Configuration Schema

**File:** `config/schemas/bypass-methods.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "bypass-methods.schema.json",
  "title": "Bypass Methods Configuration",
  "description": "Schema for jury-rigging bypass method definitions",
  "type": "object",
  "required": ["methods"],
  "properties": {
    "methods": {
      "type": "array",
      "items": {
        "type": "object",
        "required": [
          "id",
          "displayName",
          "description",
          "dcModifier",
          "requiresFamiliarity",
          "requiresGlitched",
          "destroysMechanism",
          "electrocutionRisk",
          "risks"
        ],
        "properties": {
          "id": {
            "type": "string",
            "pattern": "^[a-z_]+$"
          },
          "displayName": {
            "type": "string",
            "maxLength": 50
          },
          "description": {
            "type": "string",
            "maxLength": 200
          },
          "dcModifier": {
            "type": "integer",
            "minimum": -10,
            "maximum": 10
          },
          "requiresFamiliarity": {
            "type": "boolean"
          },
          "requiresGlitched": {
            "type": "boolean"
          },
          "destroysMechanism": {
            "type": "boolean"
          },
          "electrocutionRisk": {
            "type": "boolean"
          },
          "electrocutionSaveDc": {
            "type": "integer",
            "minimum": 1
          },
          "electrocutionDamage": {
            "type": "string",
            "pattern": "^\\d+d\\d+$"
          },
          "guaranteesSalvage": {
            "type": "boolean"
          },
          "resetsMechanismState": {
            "type": "boolean"
          },
          "risks": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "narrativeOnUse": {
            "type": "string"
          },
          "narrativeOnSuccess": {
            "type": "string"
          },
          "narrativeOnFailure": {
            "type": "string"
          }
        }
      }
    }
  }
}
```

---

## 14. Logging Specifications

### 14.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `JuryRiggingService` | Information | Jury-rig initiated, experiment outcome |
| `JuryRiggingService` | Debug | Step completions, method selection, iteration count |
| `JuryRiggingService` | Warning | Invalid method selection attempts |
| `JuryRiggingService` | Error | State corruption, invalid transitions |
| `ElectrocutionRiskService` | Information | Save attempts, damage applied |
| `ElectrocutionRiskService` | Debug | Save roll details |

### 14.2 Log Message Templates

```csharp
// JuryRiggingService - Information
"Jury-rig initiated: {JuryRigId} on {MechanismName} (DC {BaseDC}, Glitched: {IsGlitched}, Familiar: {IsFamiliar})"
"Jury-rig experiment result: {Outcome} for {JuryRigId}"

// JuryRiggingService - Debug
"Observation complete: {Success} ({NetSuccesses} net)"
"Probe complete for {JuryRigId}"
"Pattern recognition: {Recognized}, Familiar: {Familiar}, Bonus: {BonusDice}d10"
"Method selected for {JuryRigId}: {Method}"
"Experiment: {Method}, DC {ModifiedDC}, Pool {DicePool}d10"
"Iteration applied for {JuryRigId}: now at iteration {Count}"

// JuryRiggingService - Warning
"Invalid method selection for {JuryRigId}: {Method} requires {Requirement}"

// ElectrocutionRiskService - Information
"Electrocution save {Result}: {Damage} damage for {CharacterId}"

// ElectrocutionRiskService - Debug
"Electrocution save: {NetSuccesses} net successes vs DC {DC}"
```

---

## 15. Unit Testing Requirements

### 15.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| BypassMethod modifiers | ~1 |
| Familiarity bonus | ~1 |
| Complication table resolution | ~1 |
| **Total** | **~3** |

### 15.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.Tests/Services/JuryRiggingServiceTests.cs`

```csharp
using NUnit.Framework;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Services;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Tests.Services;

[TestFixture]
public class JuryRiggingServiceTests
{
    private JuryRiggingService _service;
    private Mock<ICharacterRepository> _characterRepositoryMock;
    private Mock<IDiceRoller> _diceRollerMock;
    private Mock<ILogger<JuryRiggingService>> _loggerMock;

    [SetUp]
    public void Setup()
    {
        _characterRepositoryMock = new Mock<ICharacterRepository>();
        _loggerMock = new Mock<ILogger<JuryRiggingService>>();
        _diceRollerMock = new Mock<IDiceRoller>();

        _service = new JuryRiggingService(
            _characterRepositoryMock.Object,
            _loggerMock.Object);
    }

    [Test]
    public void BypassMethod_AppliesCorrectDcModifier()
    {
        // Arrange
        var state = CreateTestState(baseDc: 14);

        // Act - Wire Manipulation (-2 DC)
        state.SelectMethod(BypassMethod.WireManipulation);
        var modifiedDcWire = state.GetModifiedDC();

        // Reset and try Brute Disassembly (+2 DC)
        var state2 = CreateTestState(baseDc: 14);
        state2.SelectMethod(BypassMethod.BruteDisassembly);
        var modifiedDcBrute = state2.GetModifiedDC();

        // Assert
        Assert.That(modifiedDcWire, Is.EqualTo(12), "Wire Manipulation should reduce DC by 2");
        Assert.That(modifiedDcBrute, Is.EqualTo(16), "Brute Disassembly should increase DC by 2");
    }

    [Test]
    public void FamiliarMechanism_GrantsBonusDice()
    {
        // Arrange
        var context = JuryRigContext.Create(
            method: BypassMethod.MemorizedSequence,
            familiar: true,
            tools: ToolQuality.Proper);

        // Act
        var bonusDice = context.FamiliarityBonusDice;
        var totalDiceModifier = context.TotalDiceModifier;

        // Assert
        Assert.That(bonusDice, Is.EqualTo(2), "Familiar mechanism should grant +2d10");
        Assert.That(totalDiceModifier, Is.EqualTo(3), "Total modifier should be +3 (2 familiar + 1 proper tools)");
    }

    [Test]
    public void ComplicationTable_ResolvesCorrectly()
    {
        // Arrange & Act
        var permanentLock = _service.ProcessComplication(1);
        var alarm = _service.ProcessComplication(2);
        var sparks = _service.ProcessComplication(5);
        var nothing = _service.ProcessComplication(6);
        var partial = _service.ProcessComplication(9);
        var glitch = _service.ProcessComplication(10);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(permanentLock, Is.EqualTo(ComplicationEffect.PermanentLock));
            Assert.That(alarm, Is.EqualTo(ComplicationEffect.AlarmTriggered));
            Assert.That(sparks, Is.EqualTo(ComplicationEffect.SparksFly));
            Assert.That(nothing, Is.EqualTo(ComplicationEffect.Nothing));
            Assert.That(partial, Is.EqualTo(ComplicationEffect.PartialSuccess));
            Assert.That(glitch, Is.EqualTo(ComplicationEffect.GlitchInFavor));
        });
    }

    private JuryRigState CreateTestState(int baseDc = 14, bool isGlitched = false, bool isFamiliar = false)
    {
        return JuryRigState.Create(
            juryRigId: "test-jury-rig-1",
            characterId: "test-char-1",
            mechanismType: "SecurityTerminal",
            mechanismName: "Test Terminal",
            baseDc: baseDc,
            isGlitched: isGlitched,
            isFamiliar: isFamiliar);
    }
}
```

---

## 16. Use Cases

### UC-001: Complete Jury-Rigging Attempt

**Actor:** Player
**Flow:**
1. Player initiates jury-rig on mechanism
2. Player optionally observes (WITS DC 10)
3. Player probes mechanism (automatic)
4. Player optionally attempts pattern recognition (WITS DC 12)
5. Player selects bypass method
6. If Wire Manipulation, resolve electrocution risk
7. Player performs experiment (System Bypass vs Modified DC)
8. Resolve outcome (success/failure/fumble)
9. If failure, roll on complication table
10. If not permanent lock, apply iteration and allow retry

### UC-002: Use Memorized Sequence on Familiar Mechanism

**Actor:** Player
**Flow:**
1. Player encounters previously-bypassed mechanism type
2. System confirms familiarity
3. Player selects Memorized Sequence method (-2 DC)
4. Pattern recognition grants +2d10 bonus
5. Player performs experiment with enhanced dice pool
6. Higher success chance due to prior experience

### UC-003: Exploit Glitched Mechanism

**Actor:** Player
**Flow:**
1. Player encounters [Glitched] mechanism
2. Glitch Exploitation method becomes available
3. Player selects Glitch Exploitation (-4 DC)
4. Player performs experiment against reduced DC
5. Resolve outcome (unpredictable due to glitch nature)

### UC-004: Survive Wire Manipulation Electrocution

**Actor:** Player
**Flow:**
1. Player selects Wire Manipulation method
2. System prompts for electrocution risk
3. Player makes FINESSE save DC 12
4. On failure: take 2d10 lightning damage
5. If still alive, proceed with bypass at -2 DC
6. On success: proceed with bypass at -2 DC (no damage)

### UC-005: Learn from Failed Attempt

**Actor:** Player
**Flow:**
1. Player fails bypass attempt
2. System rolls on complication table
3. Result is "Nothing" (6-7)
4. System applies iteration (DC -1)
5. Player may retry with reduced difficulty
6. Player may also change method on retry

---

## 17. Deliverable Checklist

### Enums
- [ ] `BypassMethod` enum created with 6 values
- [ ] `BypassMethodExtensions` implemented with DC modifiers
- [ ] `JuryRigStep` enum created
- [ ] `JuryRigStatus` enum created
- [ ] `JuryRigOutcome` enum created
- [ ] `ComplicationEffect` enum created

### Value Objects
- [ ] `JuryRigContext` value object created
- [ ] `JuryRigResult` value object created
- [ ] `ElectrocutionSaveResult` value object created
- [ ] `ObservationResult` value object created
- [ ] `ProbeResult` value object created
- [ ] `PatternResult` value object created
- [ ] `MethodOption` value object created

### Entities
- [ ] `JuryRigState` entity created with step tracking

### Services
- [ ] `IJuryRiggingService` interface defined
- [ ] `JuryRiggingService` implemented
- [ ] `IElectrocutionRiskService` interface defined
- [ ] `ElectrocutionRiskService` implemented

### Configuration Files
- [ ] `config/bypass-methods.json` created
- [ ] `config/complication-table.json` created
- [ ] `config/schemas/bypass-methods.schema.json` created

### Testing
- [ ] ~3 unit tests implemented
- [ ] All tests passing
- [ ] Bypass method modifier tests complete
- [ ] Familiarity bonus tests complete
- [ ] Complication table tests complete

### Quality
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings
- [ ] XML documentation complete
- [ ] Configuration files validate against schemas

---

## 18. Acceptance Criteria

### Functional
- [ ] BypassMethod enum contains all 6 methods with correct DC modifiers
- [ ] JuryRigContext correctly calculates total dice modifiers
- [ ] Familiarity system grants +2d10 bonus on familiar mechanisms
- [ ] Trial-and-error procedure follows 5-step flow
- [ ] Complication table resolves d10 rolls to correct effects
- [ ] Electrocution risk triggers on Wire Manipulation
- [ ] Electrocution save uses FINESSE DC 12
- [ ] Failed electrocution save deals 2d10 lightning damage
- [ ] Iteration reduces DC by 1 after failed attempt
- [ ] Method validation prevents invalid selections

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~3 tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete for all public types

---

## 19. Dependencies

### 19.1 Required from Previous Versions

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `ToolQuality` | v0.15.4a | Dice pool modifiers |
| `DamageType` | Domain | Electrocution damage typing |
| `IDiceRoller` | Interfaces | Skill checks, saves, damage rolls |
| `ICharacterRepository` | Interfaces | Familiarity tracking |
| Success-counting dice | v0.15.0 | Core resolution mechanic |
| Fumble/Critical detection | v0.15.0 | Outcome determination |

### 19.2 Provides to Future Versions

| Type | Usage |
|------|-------|
| `BypassMethod` | v0.15.4f Glitch Exploitation (enhanced) |
| `JuryRigState` | Integration with terminal/lock systems |
| `ComplicationEffect` | Reusable consequence system |
| Familiarity tracking | All bypass systems |

---

## 20. Future Considerations

### Deferred to v0.15.4f (Glitch Exploitation)

- **Chaos Roll System**: Full unpredictable glitch effects with variable modifiers
- **Glitch Cycle Timing**: Observing and exploiting glitch patterns

### Deferred to v0.15.4i (Specialization Integration)

- **Scrap-Tinker Abilities**: Enhanced jury-rigging capabilities
- **Specialization-Specific Methods**: Unique bypass approaches per class

### Out of Scope

- **Crafting Integration**: Creating tools from salvage (v0.15.4g)
- **NPC Reactions**: How NPCs respond to alarms (encounter system)
- **Environmental Hazards**: Extended electrocution scenarios (damage system)

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*
