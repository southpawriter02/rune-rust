# v0.0.7a Implementation Plan: Core Equipment Infrastructure

**Version:** 0.0.7a
**Parent:** v0.0.7 (Equipment System)
**Prerequisites:** v0.0.6 Complete (Enhanced Combat System)
**Status:** Ready for Implementation
**Target Tests:** ~281 -> ~299 (+18 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Presentation Layer](#presentation-layer)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Establish the foundational equipment system that allows players to equip and unequip items into designated slots. This phase creates the core infrastructure that v0.0.7b (Weapons) and v0.0.7c (Armor) will build upon, including the equipment slot system, player equipment tracking, and basic equip/unequip commands.

### Scope

**In Scope:**
- `EquipmentSlot` enum (Weapon, Armor, Shield, Helmet, Boots, Ring, Amulet)
- `EquipResult` value object for operation results
- `EquipmentSlot?` property on `Item` entity
- `Equipment` dictionary on `Player` entity with management methods
- `EquipmentService` for equip/unequip logic and validation
- `EquipCommand`, `UnequipCommand`, `EquipmentCommand` commands
- `EquipmentSlotsDto`, `EquippedItemDto`, `EquipResultDto` DTOs
- Equipment display rendering
- Update existing `Item.CreateSword()` factory to include equipment slot

**Out of Scope:**
- Weapon damage dice (v0.0.7b)
- Combat integration (v0.0.7b)
- Armor defense bonuses (v0.0.7c)
- Stat modifiers from equipment (v0.0.7c)
- Equipment requirements (v0.0.7c)
- Two-handed weapons (future)
- Dual-wielding (future)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Equipment storage | Separate from Inventory | Clear separation, equipped items don't consume inventory slots |
| Slot type | Dictionary<EquipmentSlot, Item> | Direct slot lookup, enforces one item per slot |
| Swap behavior | Auto-return to inventory | Smooth UX, no need for manual unequip before equip |
| Unequip requires inventory space | Yes | Prevents item loss, maintains inventory constraints |
| EquipmentSlot on Item | Nullable | Non-equipment items (potions, quest items) have null |
| EquipmentService location | Domain Services | Core business logic, no external dependencies |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.6 (Enhanced Combat System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Player` | `Domain/Entities/Player.cs` | Extended with Equipment dictionary |
| `Item` | `Domain/Entities/Item.cs` | Extended with EquipmentSlot property |
| `Inventory` | `Domain/Entities/Inventory.cs` | Item storage, GetByName, IsFull |
| `ItemType` | `Domain/Enums/ItemType.cs` | Existing categorization (Weapon, Armor, etc.) |
| `GameCommand` | `Application/Commands/GameCommand.cs` | Base class for equipment commands |
| `InvalidCommand` | `Application/Commands/InvalidCommand.cs` | Error handling for invalid input |
| `IGameRenderer` | `Application/Interfaces/IGameRenderer.cs` | Extended with equipment rendering |
| `GameSessionService` | `Application/Services/GameSessionService.cs` | Command handling integration |

### Dependencies from v0.0.4 (Core Systems)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `IEntity` | `Domain/Interfaces/IEntity.cs` | Item entity interface |
| `Stats` | `Domain/ValueObjects/Stats.cs` | Player stats (future armor integration) |

---

## Current System Analysis

### Existing Item System

**Location:** `src/Core/RuneAndRust.Domain/Entities/Item.cs`

**Current Properties:**
```
Item
├── Id: Guid
├── Name: string
├── Description: string
├── Type: ItemType (Weapon, Armor, Consumable, Quest, Misc)
├── Value: int
├── Effect: ItemEffect
├── EffectValue: int
└── EffectDuration: int
```

**Current Factory Methods:**
- `CreateSword()` - Creates "Rusty Sword" weapon
- `CreateScroll()` - Creates "Ancient Scroll" quest item
- `CreateHealthPotion()` - Creates "Health Potion" consumable

**Current Limitation:**
- No `EquipmentSlot` property
- Items with `ItemType.Weapon` or `ItemType.Armor` cannot be equipped

### Existing Inventory System

**Location:** `src/Core/RuneAndRust.Domain/Entities/Inventory.cs`

**Current Capabilities:**
```
Inventory
├── Capacity: int (default 20)
├── Items: IReadOnlyList<Item>
├── Count: int
├── IsFull: bool
├── IsEmpty: bool
├── TryAdd(item): bool
├── Remove(item): bool
├── GetByName(name): Item?
└── GetById(id): Item?
```

**Usage:** Inventory holds all player items. Equipped items will be moved from Inventory to Equipment dictionary.

### Existing Player Entity

**Location:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

**Relevant Current State:**
```
Player
├── Inventory: Inventory
├── Stats: Stats
├── TryPickUpItem(item): bool
└── ... (other properties)
```

**Required Changes:**
- Add `Equipment` dictionary
- Add equipment management methods

---

## Detailed Implementation

### Domain Layer

#### 1. EquipmentSlot.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/EquipmentSlot.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the equipment slots available for equipping items.
/// </summary>
/// <remarks>
/// <para>Each slot can hold exactly one item at a time. Items must have a matching
/// EquipmentSlot property to be equipped to that slot.</para>
/// <para>The slot determines where on the character the item is worn/wielded:</para>
/// <list type="bullet">
/// <item>Weapon - Primary hand for offensive equipment</item>
/// <item>Armor - Body protection</item>
/// <item>Shield - Off-hand defensive equipment</item>
/// <item>Helmet - Head protection</item>
/// <item>Boots - Foot protection</item>
/// <item>Ring - Finger accessory</item>
/// <item>Amulet - Neck accessory</item>
/// </list>
/// </remarks>
public enum EquipmentSlot
{
    /// <summary>Primary weapon slot for swords, axes, daggers, staffs, etc.</summary>
    Weapon,

    /// <summary>Body armor slot for chest protection.</summary>
    Armor,

    /// <summary>Off-hand slot for shields or secondary items.</summary>
    Shield,

    /// <summary>Head protection slot for helmets, hoods, etc.</summary>
    Helmet,

    /// <summary>Footwear slot for boots, shoes, etc.</summary>
    Boots,

    /// <summary>Finger accessory slot for rings.</summary>
    Ring,

    /// <summary>Neck accessory slot for amulets, necklaces, etc.</summary>
    Amulet
}
```

#### 2. EquipResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EquipResult.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of an equip or unequip operation.
/// </summary>
/// <remarks>
/// <para>Provides factory methods for common result scenarios:</para>
/// <list type="bullet">
/// <item>Equipped - Successfully equipped an item (optionally replacing another)</item>
/// <item>Unequipped - Successfully removed an item from a slot</item>
/// <item>Failure - Operation failed with a specific reason</item>
/// </list>
/// </remarks>
/// <param name="Success">Whether the operation succeeded.</param>
/// <param name="Message">A message describing the result.</param>
/// <param name="UnequippedItem">The item that was unequipped (if any).</param>
/// <param name="EquippedItem">The item that was equipped (if any).</param>
public readonly record struct EquipResult(
    bool Success,
    string Message,
    Item? UnequippedItem = null,
    Item? EquippedItem = null)
{
    /// <summary>
    /// Whether an item was swapped during this operation.
    /// </summary>
    public bool WasSwapped => UnequippedItem != null && EquippedItem != null;

    /// <summary>
    /// Creates a successful equip result.
    /// </summary>
    /// <param name="item">The item that was equipped.</param>
    /// <param name="replaced">The item that was replaced, if any.</param>
    /// <returns>A success result.</returns>
    public static EquipResult Equipped(Item item, Item? replaced = null) =>
        new(true, $"You equip the {item.Name}.", replaced, item);

    /// <summary>
    /// Creates a successful unequip result.
    /// </summary>
    /// <param name="item">The item that was unequipped.</param>
    /// <returns>A success result.</returns>
    public static EquipResult Unequipped(Item item) =>
        new(true, $"You unequip the {item.Name}.", item, null);

    /// <summary>
    /// Creates a failure result with the specified message.
    /// </summary>
    /// <param name="message">The failure reason.</param>
    /// <returns>A failure result.</returns>
    public static EquipResult Failure(string message) =>
        new(false, message, null, null);

    /// <summary>
    /// Creates a failure for item not found.
    /// </summary>
    /// <param name="itemName">The name that was searched for.</param>
    /// <returns>A failure result.</returns>
    public static EquipResult ItemNotFound(string itemName) =>
        Failure($"You don't have '{itemName}' in your inventory.");

    /// <summary>
    /// Creates a failure for item not equippable.
    /// </summary>
    /// <param name="item">The non-equippable item.</param>
    /// <returns>A failure result.</returns>
    public static EquipResult NotEquippable(Item item) =>
        Failure($"The {item.Name} cannot be equipped.");

    /// <summary>
    /// Creates a failure for slot empty.
    /// </summary>
    /// <param name="slot">The empty slot.</param>
    /// <returns>A failure result.</returns>
    public static EquipResult SlotEmpty(EquipmentSlot slot) =>
        Failure($"Nothing is equipped in the {slot} slot.");

    /// <summary>
    /// Creates a failure for inventory full (can't unequip).
    /// </summary>
    /// <returns>A failure result.</returns>
    public static EquipResult InventoryFull() =>
        Failure("Your inventory is full. Cannot unequip.");
}
```

#### 3. Item.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Item.cs`

**Changes:**
1. Add `EquipmentSlot?` property
2. Add `IsEquippable` computed property
3. Update constructor to accept equipment slot
4. Update `CreateSword()` factory to include slot
5. Add new factory methods for testing

```csharp
// Add after existing properties:

/// <summary>
/// Gets the equipment slot this item can be equipped to, or null if not equippable.
/// </summary>
/// <remarks>
/// Items without an equipment slot (consumables, quest items, misc) cannot be equipped.
/// The slot determines which equipment position the item occupies when equipped.
/// </remarks>
public EquipmentSlot? EquipmentSlot { get; private set; }

/// <summary>
/// Gets whether this item can be equipped.
/// </summary>
public bool IsEquippable => EquipmentSlot.HasValue;

// Update constructor signature:
public Item(
    string name,
    string description,
    ItemType type,
    int value = 0,
    ItemEffect effect = ItemEffect.None,
    int effectValue = 0,
    int effectDuration = 0,
    EquipmentSlot? equipmentSlot = null)  // NEW parameter
{
    Id = Guid.NewGuid();
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Description = description ?? throw new ArgumentNullException(nameof(description));
    Type = type;
    Value = value;
    Effect = effect;
    EffectValue = effectValue;
    EffectDuration = effectDuration;
    EquipmentSlot = equipmentSlot;  // NEW
}

// Update CreateSword factory:
public static Item CreateSword() => new(
    "Rusty Sword",
    "An old sword covered in rust. Still sharp enough to cut.",
    ItemType.Weapon,
    value: 5,
    equipmentSlot: Enums.EquipmentSlot.Weapon  // NEW
);

// Add new factory methods:
/// <summary>
/// Factory method to create basic leather armor.
/// </summary>
/// <returns>A new armor item.</returns>
public static Item CreateLeatherArmor() => new(
    "Leather Armor",
    "Simple armor made of tanned leather. Provides basic protection.",
    ItemType.Armor,
    value: 15,
    equipmentSlot: Enums.EquipmentSlot.Armor
);

/// <summary>
/// Factory method to create a basic wooden shield.
/// </summary>
/// <returns>A new shield item.</returns>
public static Item CreateWoodenShield() => new(
    "Wooden Shield",
    "A basic wooden shield. Better than nothing.",
    ItemType.Armor,
    value: 10,
    equipmentSlot: Enums.EquipmentSlot.Shield
);

/// <summary>
/// Factory method to create a basic iron helmet.
/// </summary>
/// <returns>A new helmet item.</returns>
public static Item CreateIronHelmet() => new(
    "Iron Helmet",
    "A sturdy iron helmet that protects your head.",
    ItemType.Armor,
    value: 20,
    equipmentSlot: Enums.EquipmentSlot.Helmet
);
```

#### 4. Player.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

**Changes:**
1. Add `Equipment` dictionary property
2. Add equipment management methods
3. Initialize `Equipment` in constructors

```csharp
// Add after Inventory property:

/// <summary>
/// Gets the player's currently equipped items, keyed by equipment slot.
/// </summary>
/// <remarks>
/// Equipped items are separate from inventory. When an item is equipped,
/// it is removed from inventory. When unequipped, it returns to inventory.
/// </remarks>
public Dictionary<EquipmentSlot, Item> Equipment { get; private set; } = new();

/// <summary>
/// Gets the item equipped in the specified slot, or null if empty.
/// </summary>
/// <param name="slot">The equipment slot to check.</param>
/// <returns>The equipped item, or null if the slot is empty.</returns>
public Item? GetEquippedItem(EquipmentSlot slot)
{
    return Equipment.TryGetValue(slot, out var item) ? item : null;
}

/// <summary>
/// Checks whether the specified equipment slot is occupied.
/// </summary>
/// <param name="slot">The equipment slot to check.</param>
/// <returns>True if an item is equipped in the slot.</returns>
public bool IsSlotOccupied(EquipmentSlot slot)
{
    return Equipment.ContainsKey(slot);
}

/// <summary>
/// Equips an item to its designated slot.
/// </summary>
/// <param name="item">The item to equip.</param>
/// <returns>True if the item was equipped successfully.</returns>
/// <exception cref="ArgumentNullException">Thrown when item is null.</exception>
/// <exception cref="InvalidOperationException">Thrown when item has no equipment slot.</exception>
/// <remarks>
/// The item must have an EquipmentSlot defined. If the slot is already occupied,
/// this method returns false. Use EquipmentService for swap logic.
/// </remarks>
public bool TryEquip(Item item)
{
    ArgumentNullException.ThrowIfNull(item);

    if (!item.EquipmentSlot.HasValue)
        throw new InvalidOperationException($"Item '{item.Name}' cannot be equipped (no equipment slot).");

    var slot = item.EquipmentSlot.Value;

    // If slot is occupied, return false (use EquipmentService for swap logic)
    if (IsSlotOccupied(slot))
        return false;

    Equipment[slot] = item;
    return true;
}

/// <summary>
/// Unequips the item from the specified slot.
/// </summary>
/// <param name="slot">The slot to unequip from.</param>
/// <returns>The unequipped item, or null if the slot was empty.</returns>
public Item? Unequip(EquipmentSlot slot)
{
    if (Equipment.TryGetValue(slot, out var item))
    {
        Equipment.Remove(slot);
        return item;
    }
    return null;
}

/// <summary>
/// Gets all currently equipped items.
/// </summary>
/// <returns>A read-only collection of equipped items.</returns>
public IReadOnlyCollection<Item> GetAllEquippedItems()
{
    return Equipment.Values.ToList().AsReadOnly();
}

/// <summary>
/// Gets the number of equipped items.
/// </summary>
public int EquippedItemCount => Equipment.Count;

// Update both constructors to initialize Equipment:
// In Player(string name, Stats? stats = null):
Equipment = new Dictionary<EquipmentSlot, Item>();

// In Player(string name, string raceId, string backgroundId, ...):
Equipment = new Dictionary<EquipmentSlot, Item>();
```

#### 5. EquipmentService.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Services/EquipmentService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Service for managing player equipment operations.
/// </summary>
/// <remarks>
/// <para>Handles the logic for equipping and unequipping items, including validation,
/// inventory management, and slot swapping. This service coordinates between
/// the player's equipment slots and inventory.</para>
/// <para>Key responsibilities:</para>
/// <list type="bullet">
/// <item>Validate items are equippable</item>
/// <item>Handle automatic slot swapping</item>
/// <item>Manage inventory space during operations</item>
/// <item>Parse slot names from user input</item>
/// </list>
/// </remarks>
public class EquipmentService
{
    private readonly ILogger<EquipmentService> _logger;

    /// <summary>
    /// Creates a new EquipmentService instance.
    /// </summary>
    /// <param name="logger">The logger for equipment operations.</param>
    public EquipmentService(ILogger<EquipmentService> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Attempts to equip an item from the player's inventory by name.
    /// </summary>
    /// <param name="player">The player equipping the item.</param>
    /// <param name="itemName">The name of the item to equip (case-insensitive).</param>
    /// <returns>The result of the equip operation.</returns>
    /// <remarks>
    /// If the target slot is occupied, the existing item is automatically
    /// swapped back to inventory (if space available).
    /// </remarks>
    public EquipResult TryEquipByName(Player player, string itemName)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentException.ThrowIfNullOrWhiteSpace(itemName);

        _logger.LogDebug("Attempting to equip '{ItemName}' for player {Player}",
            itemName, player.Name);

        // Find item in inventory
        var item = player.Inventory.GetByName(itemName);
        if (item == null)
        {
            _logger.LogDebug("Item '{ItemName}' not found in inventory", itemName);
            return EquipResult.ItemNotFound(itemName);
        }

        return TryEquip(player, item);
    }

    /// <summary>
    /// Attempts to equip a specific item from the player's inventory.
    /// </summary>
    /// <param name="player">The player equipping the item.</param>
    /// <param name="item">The item to equip.</param>
    /// <returns>The result of the equip operation.</returns>
    public EquipResult TryEquip(Player player, Item item)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(item);

        _logger.LogDebug("Equipping '{ItemName}' for player {Player}",
            item.Name, player.Name);

        // Check if item is equippable
        if (!item.IsEquippable)
        {
            _logger.LogDebug("Item '{ItemName}' is not equippable", item.Name);
            return EquipResult.NotEquippable(item);
        }

        var slot = item.EquipmentSlot!.Value;
        Item? replacedItem = null;

        // Check if slot is occupied
        if (player.IsSlotOccupied(slot))
        {
            // Need to unequip current item first
            var currentItem = player.GetEquippedItem(slot)!;

            // Check if inventory has space for the current item
            if (player.Inventory.IsFull)
            {
                _logger.LogDebug("Cannot swap equipment - inventory is full");
                return EquipResult.InventoryFull();
            }

            // Unequip current item and add to inventory
            player.Unequip(slot);
            player.Inventory.TryAdd(currentItem);
            replacedItem = currentItem;

            _logger.LogDebug("Unequipped '{OldItem}' to make room for '{NewItem}'",
                currentItem.Name, item.Name);
        }

        // Remove item from inventory and equip it
        player.Inventory.Remove(item);
        player.TryEquip(item);

        _logger.LogInformation("Player {Player} equipped '{Item}' to {Slot} slot",
            player.Name, item.Name, slot);

        return EquipResult.Equipped(item, replacedItem);
    }

    /// <summary>
    /// Attempts to unequip an item from the specified slot.
    /// </summary>
    /// <param name="player">The player unequipping the item.</param>
    /// <param name="slot">The slot to unequip from.</param>
    /// <returns>The result of the unequip operation.</returns>
    public EquipResult TryUnequip(Player player, EquipmentSlot slot)
    {
        ArgumentNullException.ThrowIfNull(player);

        _logger.LogDebug("Attempting to unequip from {Slot} slot for player {Player}",
            slot, player.Name);

        // Check if slot has an item
        if (!player.IsSlotOccupied(slot))
        {
            _logger.LogDebug("Slot {Slot} is empty", slot);
            return EquipResult.SlotEmpty(slot);
        }

        // Check inventory space
        if (player.Inventory.IsFull)
        {
            _logger.LogDebug("Cannot unequip - inventory is full");
            return EquipResult.InventoryFull();
        }

        // Unequip and add to inventory
        var item = player.Unequip(slot)!;
        player.Inventory.TryAdd(item);

        _logger.LogInformation("Player {Player} unequipped '{Item}' from {Slot} slot",
            player.Name, item.Name, slot);

        return EquipResult.Unequipped(item);
    }

    /// <summary>
    /// Parses a slot name string to an EquipmentSlot enum value.
    /// </summary>
    /// <param name="slotName">The slot name to parse (case-insensitive).</param>
    /// <param name="slot">The parsed slot value.</param>
    /// <returns>True if parsing succeeded.</returns>
    public static bool TryParseSlot(string? slotName, out EquipmentSlot slot)
    {
        slot = default;

        if (string.IsNullOrWhiteSpace(slotName))
            return false;

        return Enum.TryParse(slotName.Trim(), ignoreCase: true, out slot);
    }

    /// <summary>
    /// Gets a formatted list of all valid slot names.
    /// </summary>
    /// <returns>Comma-separated list of slot names in lowercase.</returns>
    public static string GetValidSlotNames()
    {
        return string.Join(", ", Enum.GetNames<EquipmentSlot>().Select(n => n.ToLowerInvariant()));
    }
}
```

---

### Application Layer

#### 1. EquipCommand.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Commands/EquipCommand.cs`

```csharp
namespace RuneAndRust.Application.Commands;

/// <summary>
/// Command to equip an item from the player's inventory.
/// </summary>
/// <remarks>
/// Triggered by the "equip &lt;item name&gt;" command. The item name is
/// matched case-insensitively against inventory items.
/// </remarks>
/// <param name="ItemName">The name of the item to equip.</param>
public record EquipCommand(string ItemName) : GameCommand;
```

#### 2. UnequipCommand.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Commands/UnequipCommand.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.Commands;

/// <summary>
/// Command to unequip an item from a specific equipment slot.
/// </summary>
/// <remarks>
/// Triggered by the "unequip &lt;slot&gt;" command. The slot name is
/// parsed case-insensitively (e.g., "weapon", "ARMOR", "Shield").
/// </remarks>
/// <param name="Slot">The equipment slot to unequip from.</param>
public record UnequipCommand(EquipmentSlot Slot) : GameCommand;
```

#### 3. EquipmentCommand.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Commands/EquipmentCommand.cs`

```csharp
namespace RuneAndRust.Application.Commands;

/// <summary>
/// Command to display the player's current equipment.
/// </summary>
/// <remarks>
/// Triggered by "equipment", "eq", or "gear" commands.
/// Shows all equipment slots with their equipped items or "(empty)".
/// </remarks>
public record EquipmentCommand : GameCommand;
```

#### 4. EquipmentDtos.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/DTOs/EquipmentDtos.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying an equipped item in a specific slot.
/// </summary>
/// <param name="Slot">The equipment slot.</param>
/// <param name="ItemName">The name of the equipped item, or null if empty.</param>
/// <param name="ItemDescription">The description of the equipped item, or null if empty.</param>
public record EquippedItemDto(
    EquipmentSlot Slot,
    string? ItemName,
    string? ItemDescription)
{
    /// <summary>
    /// Whether this slot has an item equipped.
    /// </summary>
    public bool IsOccupied => ItemName != null;

    /// <summary>
    /// Gets the display name for the slot.
    /// </summary>
    public string SlotDisplayName => Slot.ToString();
}

/// <summary>
/// DTO for displaying all equipment slots.
/// </summary>
/// <param name="Slots">The list of all equipment slots with their items.</param>
public record EquipmentSlotsDto(IReadOnlyList<EquippedItemDto> Slots)
{
    /// <summary>
    /// Creates an EquipmentSlotsDto from a player's equipment.
    /// </summary>
    /// <param name="player">The player whose equipment to display.</param>
    /// <returns>A DTO with all slots.</returns>
    public static EquipmentSlotsDto FromPlayer(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var slots = Enum.GetValues<EquipmentSlot>()
            .Select(slot =>
            {
                var item = player.GetEquippedItem(slot);
                return new EquippedItemDto(
                    slot,
                    item?.Name,
                    item?.Description);
            })
            .ToList();

        return new EquipmentSlotsDto(slots);
    }

    /// <summary>
    /// Gets the number of occupied slots.
    /// </summary>
    public int OccupiedSlotCount => Slots.Count(s => s.IsOccupied);

    /// <summary>
    /// Gets the total number of slots.
    /// </summary>
    public int TotalSlotCount => Slots.Count;
}

/// <summary>
/// DTO for displaying an equip/unequip result.
/// </summary>
/// <param name="Success">Whether the operation succeeded.</param>
/// <param name="Message">The result message.</param>
/// <param name="ReplacedItemName">Name of replaced item if swapped.</param>
public record EquipResultDto(
    bool Success,
    string Message,
    string? ReplacedItemName = null)
{
    /// <summary>
    /// Whether an item was swapped during this operation.
    /// </summary>
    public bool WasSwapped => ReplacedItemName != null;

    /// <summary>
    /// Creates a DTO from an EquipResult.
    /// </summary>
    /// <param name="result">The domain result.</param>
    /// <returns>A DTO for rendering.</returns>
    public static EquipResultDto FromResult(EquipResult result) =>
        new(result.Success, result.Message, result.UnequippedItem?.Name);
}
```

#### 5. ConsoleInputHandler.cs (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/ConsoleInputHandler.cs`

**Changes:** Add parsing for equipment commands.

```csharp
// Add to ParseCommand switch statement:
"equip" => ParseEquipCommand(argument),
"unequip" => ParseUnequipCommand(argument),
"equipment" or "eq" or "gear" => new EquipmentCommand(),

// Add new parsing methods:

/// <summary>
/// Parses the equip command.
/// </summary>
private GameCommand ParseEquipCommand(string? argument)
{
    if (string.IsNullOrWhiteSpace(argument))
    {
        return new InvalidCommand("Usage: equip <item name>");
    }
    return new EquipCommand(argument.Trim());
}

/// <summary>
/// Parses the unequip command.
/// </summary>
private GameCommand ParseUnequipCommand(string? argument)
{
    if (string.IsNullOrWhiteSpace(argument))
    {
        return new InvalidCommand(
            $"Usage: unequip <slot>\nSlots: {EquipmentService.GetValidSlotNames()}");
    }

    if (EquipmentService.TryParseSlot(argument.Trim(), out var slot))
    {
        return new UnequipCommand(slot);
    }

    return new InvalidCommand(
        $"Unknown slot '{argument}'. Valid slots: {EquipmentService.GetValidSlotNames()}");
}
```

#### 6. GameSessionService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

**Changes:** Add handlers for equipment commands.

```csharp
// Add EquipmentService dependency:
private readonly EquipmentService _equipmentService;

// Update constructor to inject EquipmentService:
public GameSessionService(
    // ... existing dependencies ...
    EquipmentService equipmentService)
{
    // ... existing initialization ...
    _equipmentService = equipmentService;
}

// Add command handlers in ProcessCommandAsync:
case EquipCommand equipCmd:
    await HandleEquipCommand(equipCmd, ct);
    break;

case UnequipCommand unequipCmd:
    await HandleUnequipCommand(unequipCmd, ct);
    break;

case EquipmentCommand:
    await HandleEquipmentCommand(ct);
    break;

// Add handler methods:

/// <summary>
/// Handles the equip command.
/// </summary>
private async Task HandleEquipCommand(EquipCommand command, CancellationToken ct)
{
    var result = _equipmentService.TryEquipByName(_session!.Player, command.ItemName);
    var dto = EquipResultDto.FromResult(result);
    await _renderer.RenderEquipResultAsync(dto, ct);
}

/// <summary>
/// Handles the unequip command.
/// </summary>
private async Task HandleUnequipCommand(UnequipCommand command, CancellationToken ct)
{
    var result = _equipmentService.TryUnequip(_session!.Player, command.Slot);
    var dto = EquipResultDto.FromResult(result);
    await _renderer.RenderEquipResultAsync(dto, ct);
}

/// <summary>
/// Handles the equipment display command.
/// </summary>
private async Task HandleEquipmentCommand(CancellationToken ct)
{
    var dto = EquipmentSlotsDto.FromPlayer(_session!.Player);
    await _renderer.RenderEquipmentAsync(dto, ct);
}
```

---

### Presentation Layer

#### 1. IGameRenderer.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs`

**Changes:** Add equipment rendering methods.

```csharp
/// <summary>
/// Renders the player's current equipment.
/// </summary>
/// <param name="equipment">The equipment data to display.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderEquipmentAsync(EquipmentSlotsDto equipment, CancellationToken ct = default);

/// <summary>
/// Renders the result of an equip or unequip operation.
/// </summary>
/// <param name="result">The equip result to display.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderEquipResultAsync(EquipResultDto result, CancellationToken ct = default);
```

#### 2. SpectreGameRenderer.cs (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

**Changes:** Implement equipment rendering methods.

```csharp
/// <inheritdoc />
public Task RenderEquipmentAsync(EquipmentSlotsDto equipment, CancellationToken ct = default)
{
    var table = new Table()
        .Border(TableBorder.Rounded)
        .BorderColor(Color.Grey)
        .Title("[yellow]⚔ Equipment ⚔[/]")
        .AddColumn(new TableColumn("[bold]Slot[/]").Width(12))
        .AddColumn(new TableColumn("[bold]Item[/]"));

    foreach (var slot in equipment.Slots)
    {
        var slotName = slot.SlotDisplayName;
        var itemDisplay = slot.IsOccupied
            ? $"[green]{slot.ItemName}[/]"
            : "[dim](empty)[/]";

        table.AddRow(slotName, itemDisplay);
    }

    AnsiConsole.Write(table);
    AnsiConsole.WriteLine();

    return Task.CompletedTask;
}

/// <inheritdoc />
public Task RenderEquipResultAsync(EquipResultDto result, CancellationToken ct = default)
{
    if (result.Success)
    {
        AnsiConsole.MarkupLine($"[green]{Markup.Escape(result.Message)}[/]");

        if (result.WasSwapped)
        {
            AnsiConsole.MarkupLine($"[dim]({Markup.Escape(result.ReplacedItemName!)} returned to inventory)[/]");
        }
    }
    else
    {
        AnsiConsole.MarkupLine($"[red]{Markup.Escape(result.Message)}[/]");
    }

    AnsiConsole.WriteLine();
    return Task.CompletedTask;
}
```

#### 3. HelpText Updates

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/ConsoleInputHandler.cs` or help command handler

Add equipment commands to help text:

```csharp
// Add to help text:
"  equip <item>    - Equip an item from inventory"
"  unequip <slot>  - Remove equipment from a slot"
"  equipment (eq)  - Show equipped items"
```

---

## Flow Diagrams

### Equip Item Flow

```
equip <item name>
    │
    ├─► 1. PARSE COMMAND
    │   ├── Valid item name? Continue
    │   └── Empty? Return InvalidCommand
    │
    ├─► 2. FIND ITEM IN INVENTORY
    │   ├── player.Inventory.GetByName(itemName)
    │   ├── Found? Continue to Step 3
    │   └── Not found? Return ItemNotFound
    │
    ├─► 3. CHECK IF EQUIPPABLE
    │   ├── item.IsEquippable?
    │   ├── Yes? Continue to Step 4
    │   └── No? Return NotEquippable
    │
    ├─► 4. CHECK SLOT OCCUPANCY
    │   ├── player.IsSlotOccupied(slot)?
    │   ├── No? Go to Step 6 (equip)
    │   └── Yes? Go to Step 5 (swap)
    │
    ├─► 5. SWAP (if slot occupied)
    │   ├── Check inventory space
    │   │   ├── player.Inventory.IsFull?
    │   │   └── Yes? Return InventoryFull
    │   │
    │   ├── player.Unequip(slot)
    │   └── player.Inventory.TryAdd(oldItem)
    │
    ├─► 6. EQUIP ITEM
    │   ├── player.Inventory.Remove(item)
    │   ├── player.TryEquip(item)
    │   └── Return Equipped(item, replacedItem)
    │
    └─► 7. RENDER RESULT
        ├── Success: "You equip the <item>."
        └── If swapped: "(<old item> returned to inventory)"
```

### Unequip Item Flow

```
unequip <slot>
    │
    ├─► 1. PARSE COMMAND
    │   ├── Valid slot name? Continue
    │   └── Invalid? Return InvalidCommand with slot list
    │
    ├─► 2. CHECK SLOT OCCUPANCY
    │   ├── player.IsSlotOccupied(slot)?
    │   ├── Yes? Continue to Step 3
    │   └── No? Return SlotEmpty
    │
    ├─► 3. CHECK INVENTORY SPACE
    │   ├── player.Inventory.IsFull?
    │   ├── No? Continue to Step 4
    │   └── Yes? Return InventoryFull
    │
    ├─► 4. UNEQUIP ITEM
    │   ├── player.Unequip(slot)
    │   ├── player.Inventory.TryAdd(item)
    │   └── Return Unequipped(item)
    │
    └─► 5. RENDER RESULT
        └── "You unequip the <item>."
```

### Equipment Display Flow

```
equipment (or eq, gear)
    │
    ├─► 1. CREATE DTO
    │   └── EquipmentSlotsDto.FromPlayer(player)
    │       │
    │       └── For each EquipmentSlot:
    │           ├── Get equipped item (if any)
    │           └── Create EquippedItemDto
    │
    └─► 2. RENDER TABLE
        │
        ├── Header: "⚔ Equipment ⚔"
        │
        └── Rows:
            ├── Weapon:  <item name> or (empty)
            ├── Armor:   <item name> or (empty)
            ├── Shield:  <item name> or (empty)
            ├── Helmet:  <item name> or (empty)
            ├── Boots:   <item name> or (empty)
            ├── Ring:    <item name> or (empty)
            └── Amulet:  <item name> or (empty)
```

---

## Testing Strategy

### Test Categories

#### 1. EquipmentSlotTests.cs (~4 tests)

| Test | Description |
|------|-------------|
| `EquipmentSlot_ContainsAllExpectedValues` | Enum has all 7 slots |
| `TryParseSlot_ValidSlotName_ReturnsTrue` | "weapon" parses to Weapon |
| `TryParseSlot_InvalidSlotName_ReturnsFalse` | "invalid" returns false |
| `TryParseSlot_CaseInsensitive_ReturnsTrue` | "ARMOR" parses to Armor |

#### 2. ItemEquipmentTests.cs (~4 tests)

| Test | Description |
|------|-------------|
| `CreateSword_HasWeaponEquipmentSlot` | Factory creates equippable weapon |
| `CreateHealthPotion_HasNoEquipmentSlot` | Consumables not equippable |
| `IsEquippable_WithSlot_ReturnsTrue` | EquipmentSlot.HasValue = true |
| `IsEquippable_WithoutSlot_ReturnsFalse` | Null slot = not equippable |

#### 3. PlayerEquipmentTests.cs (~6 tests)

| Test | Description |
|------|-------------|
| `NewPlayer_HasEmptyEquipment` | Equipment dictionary initialized |
| `TryEquip_ValidItem_AddsToEquipment` | Item appears in slot |
| `TryEquip_ItemWithoutSlot_ThrowsException` | Throws InvalidOperationException |
| `TryEquip_SlotOccupied_ReturnsFalse` | Can't double-equip |
| `Unequip_OccupiedSlot_ReturnsItem` | Returns the equipped item |
| `Unequip_EmptySlot_ReturnsNull` | Empty slot returns null |

#### 4. EquipmentServiceTests.cs (~8 tests)

| Test | Description |
|------|-------------|
| `TryEquipByName_ItemInInventory_EquipsItem` | Normal equip flow |
| `TryEquipByName_ItemNotInInventory_ReturnsFailure` | Item not found |
| `TryEquip_NotEquippable_ReturnsFailure` | Non-equipment item |
| `TryEquip_RemovesItemFromInventory` | Item leaves inventory |
| `TryEquip_SlotOccupied_SwapsItems` | Old item to inventory |
| `TryEquip_InventoryFullDuringSwap_ReturnsFailure` | Can't swap when full |
| `TryUnequip_AddsItemToInventory` | Item returns to inventory |
| `TryUnequip_EmptySlot_ReturnsFailure` | Nothing to unequip |

### Test Data Setup

```csharp
// Test fixture for equipment tests
public class EquipmentTestFixture
{
    public Player Player { get; }
    public EquipmentService Service { get; }
    public Item Sword { get; }
    public Item Armor { get; }
    public Item Potion { get; }

    public EquipmentTestFixture()
    {
        var loggerFactory = new NullLoggerFactory();
        Service = new EquipmentService(loggerFactory.CreateLogger<EquipmentService>());

        Player = new Player("TestPlayer");

        // Create test items
        Sword = Item.CreateSword();
        Armor = Item.CreateLeatherArmor();
        Potion = Item.CreateHealthPotion();

        // Add items to inventory
        Player.Inventory.TryAdd(Sword);
        Player.Inventory.TryAdd(Armor);
        Player.Inventory.TryAdd(Potion);
    }
}
```

### Sample Test Implementation

```csharp
[TestFixture]
public class EquipmentServiceTests
{
    private EquipmentService _service = null!;
    private Player _player = null!;

    [SetUp]
    public void SetUp()
    {
        var loggerFactory = new NullLoggerFactory();
        _service = new EquipmentService(loggerFactory.CreateLogger<EquipmentService>());
        _player = new Player("TestPlayer");
    }

    [Test]
    public void TryEquipByName_ItemInInventory_EquipsItem()
    {
        // Arrange
        var sword = Item.CreateSword();
        _player.Inventory.TryAdd(sword);

        // Act
        var result = _service.TryEquipByName(_player, "Rusty Sword");

        // Assert
        Assert.That(result.Success, Is.True);
        Assert.That(result.EquippedItem, Is.EqualTo(sword));
        Assert.That(_player.GetEquippedItem(EquipmentSlot.Weapon), Is.EqualTo(sword));
        Assert.That(_player.Inventory.Contains(sword), Is.False);
    }

    [Test]
    public void TryEquip_SlotOccupied_SwapsItems()
    {
        // Arrange
        var sword1 = Item.CreateSword();
        var sword2 = new Item("Iron Sword", "A better sword.", ItemType.Weapon, 10,
            equipmentSlot: EquipmentSlot.Weapon);
        _player.Inventory.TryAdd(sword1);
        _player.Inventory.TryAdd(sword2);

        // Equip first sword
        _service.TryEquipByName(_player, "Rusty Sword");

        // Act - equip second sword
        var result = _service.TryEquipByName(_player, "Iron Sword");

        // Assert
        Assert.That(result.Success, Is.True);
        Assert.That(result.UnequippedItem, Is.EqualTo(sword1));
        Assert.That(result.EquippedItem, Is.EqualTo(sword2));
        Assert.That(_player.GetEquippedItem(EquipmentSlot.Weapon), Is.EqualTo(sword2));
        Assert.That(_player.Inventory.Contains(sword1), Is.True);
    }

    [Test]
    public void TryUnequip_EmptySlot_ReturnsFailure()
    {
        // Act
        var result = _service.TryUnequip(_player, EquipmentSlot.Weapon);

        // Assert
        Assert.That(result.Success, Is.False);
        Assert.That(result.Message, Does.Contain("Nothing is equipped"));
    }
}
```

---

## Logging Strategy

### Log Levels

| Level | Usage |
|-------|-------|
| Debug | Item lookup, slot checks, swap operations |
| Information | Successful equip/unequip operations |
| Warning | (None in this phase) |
| Error | (None in this phase - all failures are expected user errors) |

### Log Messages

```csharp
// EquipmentService
_logger.LogDebug("Attempting to equip '{ItemName}' for player {Player}", itemName, player.Name);
_logger.LogDebug("Item '{ItemName}' not found in inventory", itemName);
_logger.LogDebug("Item '{ItemName}' is not equippable", item.Name);
_logger.LogDebug("Cannot swap equipment - inventory is full");
_logger.LogDebug("Unequipped '{OldItem}' to make room for '{NewItem}'", oldItem.Name, newItem.Name);
_logger.LogInformation("Player {Player} equipped '{Item}' to {Slot} slot", player.Name, item.Name, slot);
_logger.LogDebug("Attempting to unequip from {Slot} slot for player {Player}", slot, player.Name);
_logger.LogDebug("Slot {Slot} is empty", slot);
_logger.LogDebug("Cannot unequip - inventory is full");
_logger.LogInformation("Player {Player} unequipped '{Item}' from {Slot} slot", player.Name, item.Name, slot);
```

---

## Implementation Checklist

### Phase 1: Domain Layer
- [ ] Create `EquipmentSlot.cs` enum
- [ ] Create `EquipResult.cs` value object
- [ ] Modify `Item.cs` - add EquipmentSlot property
- [ ] Modify `Item.cs` - add IsEquippable property
- [ ] Modify `Item.cs` - update constructor
- [ ] Modify `Item.cs` - update CreateSword factory
- [ ] Modify `Item.cs` - add CreateLeatherArmor factory
- [ ] Modify `Item.cs` - add CreateWoodenShield factory
- [ ] Modify `Item.cs` - add CreateIronHelmet factory
- [ ] Modify `Player.cs` - add Equipment dictionary
- [ ] Modify `Player.cs` - add GetEquippedItem method
- [ ] Modify `Player.cs` - add IsSlotOccupied method
- [ ] Modify `Player.cs` - add TryEquip method
- [ ] Modify `Player.cs` - add Unequip method
- [ ] Modify `Player.cs` - add GetAllEquippedItems method
- [ ] Modify `Player.cs` - initialize Equipment in constructors
- [ ] Create `EquipmentService.cs`

### Phase 2: Application Layer
- [ ] Create `EquipCommand.cs`
- [ ] Create `UnequipCommand.cs`
- [ ] Create `EquipmentCommand.cs`
- [ ] Create `EquipmentDtos.cs` (EquippedItemDto, EquipmentSlotsDto, EquipResultDto)
- [ ] Modify `ConsoleInputHandler.cs` - add equip parsing
- [ ] Modify `ConsoleInputHandler.cs` - add unequip parsing
- [ ] Modify `ConsoleInputHandler.cs` - add equipment parsing
- [ ] Modify `GameSessionService.cs` - add EquipmentService dependency
- [ ] Modify `GameSessionService.cs` - add HandleEquipCommand
- [ ] Modify `GameSessionService.cs` - add HandleUnequipCommand
- [ ] Modify `GameSessionService.cs` - add HandleEquipmentCommand

### Phase 3: Presentation Layer
- [ ] Modify `IGameRenderer.cs` - add RenderEquipmentAsync
- [ ] Modify `IGameRenderer.cs` - add RenderEquipResultAsync
- [ ] Modify `SpectreGameRenderer.cs` - implement RenderEquipmentAsync
- [ ] Modify `SpectreGameRenderer.cs` - implement RenderEquipResultAsync
- [ ] Update help text with equipment commands

### Phase 4: DI Registration
- [ ] Register EquipmentService in DI container

### Phase 5: Testing
- [ ] Create `EquipmentSlotTests.cs` (~4 tests)
- [ ] Create `ItemEquipmentTests.cs` (~4 tests)
- [ ] Create `PlayerEquipmentTests.cs` (~6 tests)
- [ ] Create `EquipmentServiceTests.cs` (~8 tests)

---

## Acceptance Criteria

### EquipmentSlot Enum
- [ ] Contains all 7 slots: Weapon, Armor, Shield, Helmet, Boots, Ring, Amulet
- [ ] Can be parsed from strings (case-insensitive)

### Item Entity
- [ ] Has nullable `EquipmentSlot` property
- [ ] `IsEquippable` returns true only when EquipmentSlot has value
- [ ] `CreateSword()` creates item with EquipmentSlot.Weapon
- [ ] Consumables have null EquipmentSlot

### Player Entity
- [ ] Has `Equipment` dictionary initialized to empty
- [ ] `GetEquippedItem()` returns item or null
- [ ] `IsSlotOccupied()` correctly reports slot status
- [ ] `TryEquip()` adds item to equipment
- [ ] `TryEquip()` throws if item has no equipment slot
- [ ] `Unequip()` removes and returns item from slot

### EquipmentService
- [ ] `TryEquipByName()` finds item in inventory and equips it
- [ ] `TryEquipByName()` returns failure if item not in inventory
- [ ] `TryEquip()` returns failure if item not equippable
- [ ] `TryEquip()` removes item from inventory when equipped
- [ ] `TryEquip()` swaps items if slot occupied
- [ ] `TryEquip()` fails if inventory full during swap
- [ ] `TryUnequip()` removes item and adds to inventory
- [ ] `TryUnequip()` fails if slot is empty
- [ ] `TryUnequip()` fails if inventory is full

### Commands
- [ ] `equip <item>` equips item from inventory
- [ ] `unequip <slot>` unequips item to inventory
- [ ] `equipment` shows all slots with items or "(empty)"
- [ ] Invalid commands show helpful error messages

### General
- [ ] ~18 unit tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Inventory manipulation during equip fails | Low | Medium | Thorough testing of inventory integration |
| EF Core doesn't serialize Equipment dictionary | Medium | High | May need navigation property or JSON column |
| Item reference issues after equip/unequip | Low | Medium | Use Item Id for persistence, load from context |
| Command parsing ambiguity | Low | Low | Clear error messages with valid options |
| Player constructor changes break existing code | Medium | Medium | Add new parameter with default null |

---

## File Summary

### New Files (8)

| Layer | File | Purpose |
|-------|------|---------|
| Domain | `Enums/EquipmentSlot.cs` | Equipment slot enumeration |
| Domain | `ValueObjects/EquipResult.cs` | Equip/unequip operation result |
| Domain | `Services/EquipmentService.cs` | Equipment management service |
| Application | `Commands/EquipCommand.cs` | Equip command record |
| Application | `Commands/UnequipCommand.cs` | Unequip command record |
| Application | `Commands/EquipmentCommand.cs` | Equipment display command |
| Application | `DTOs/EquipmentDtos.cs` | Equipment display DTOs |
| Tests | `Services/EquipmentServiceTests.cs` | Service tests |

### Modified Files (8)

| Layer | File | Changes |
|-------|------|---------|
| Domain | `Entities/Item.cs` | Add EquipmentSlot, IsEquippable, update factories |
| Domain | `Entities/Player.cs` | Add Equipment dictionary and methods |
| Application | `Interfaces/IGameRenderer.cs` | Add equipment render methods |
| Application | `Services/GameSessionService.cs` | Add equipment command handlers |
| Presentation | `Adapters/ConsoleInputHandler.cs` | Add command parsing |
| Presentation | `Adapters/SpectreGameRenderer.cs` | Implement rendering |
| Tests | `Entities/ItemTests.cs` | Add equipment slot tests |
| Tests | `Entities/PlayerTests.cs` | Add equipment tests |

### Test Files Summary

| File | Test Count |
|------|------------|
| `EquipmentSlotTests.cs` | ~4 |
| `ItemEquipmentTests.cs` | ~4 |
| `PlayerEquipmentTests.cs` | ~6 |
| `EquipmentServiceTests.cs` | ~8 |
| **Total** | **~18** |

---

## Provides to Future Phases

### To v0.0.7b (Weapon System)

| Type | Usage |
|------|-------|
| `EquipmentSlot.Weapon` | Weapon slot for equipped weapon |
| `Player.GetEquippedItem(Weapon)` | Get equipped weapon for damage calculation |
| `EquipmentService` | Extended with weapon-specific validation |

### To v0.0.7c (Armor & Requirements)

| Type | Usage |
|------|-------|
| `EquipmentSlot` (all armor slots) | Armor, Shield, Helmet, Boots |
| `Player.Equipment` | Calculate total armor from equipped items |
| `EquipmentService` | Extended with requirement validation |
