# v0.4.0b Design Specification: Containers & Locks

**Version:** 0.4.0b
**Phase Name:** Containers & Locks
**Parent Version:** v0.4.0 (Interactive Objects Foundation)
**Prerequisites:** v0.4.0a Complete (Interactive Object Core)
**Estimated Tests:** ~30 unit tests

---

## 1. Overview

### 1.1 Purpose

Implement container inventories so chests, crates, and barrels can hold items, and add the complete lock and key system including lockpicking as a dice-based skill check using the existing `SkillCheckService` and `DiceService`.

### 1.2 Current State

The following infrastructure exists from prior versions:

| Component | Location | Status |
|-----------|----------|--------|
| `InteractiveObject` entity | `Domain/Entities/InteractiveObject.cs` | From v0.4.0a |
| `InteractionService` | `Application/Services/InteractionService.cs` | From v0.4.0a |
| `InteractionType` enum | `Domain/Enums/InteractionType.cs` | From v0.4.0a |
| `ObjectState` enum | `Domain/Enums/ObjectState.cs` | Complete (includes Locked) |
| `Item` entity | `Domain/Entities/Item.cs` | Complete |
| `ItemType` enum | `Domain/Enums/ItemType.cs` | Needs Key type |
| `DiceService` | `Application/Services/DiceService.cs` | Complete |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Complete |
| `Player.Inventory` | `Domain/Entities/Player.cs` | Complete |
| Lockpicking skill | `Configuration/skills.json` | Complete (uses Finesse) |

### 1.3 Scope

**In Scope:**
- `ContainerInventory` value object for object-held items
- Container capacity limits
- `take <item> from <container>` command
- `take all from <container>` command
- `put <item> in <container>` command
- `ItemType.Key` enum value addition
- Item key properties (KeyId, IsConsumedOnUse)
- `LockDefinition` value object
- Key matching system (key ID to lock ID)
- `unlock <object>` command with automatic key detection
- `lock <object>` command for relocking
- `pick lock on <object>` command
- Lockpicking skill checks via existing DiceService/SkillCheckService
- Lock difficulty ratings (DC values)
- Locked door and container integration
- Container contents display when opened

**Out of Scope:**
- Levers and buttons (v0.4.0c)
- Linked effects (v0.4.0c)
- Destructible objects (v0.4.0c)
- Trapped containers (v0.4.1)
- Breaking locks (v0.4.0c)

### 1.4 Design Goals

1. **Seamless Integration**: Build upon v0.4.0a's InteractiveObject foundation
2. **Flexible Containers**: Support various container types with configurable capacities
3. **Realistic Lock System**: Keys match locks, lockpicking uses existing skill system
4. **Player Convenience**: Automatic key detection when unlocking
5. **Consistency**: Use existing Item entity patterns for keys
6. **Testability**: Clean separation for comprehensive unit testing

---

## 2. Data Model

### 2.1 ContainerInventory Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ContainerInventory.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Entities;

/// <summary>
/// Represents the inventory contents of a container object.
/// </summary>
public class ContainerInventory
{
    private readonly List<Item> _items = new();

    /// <summary>
    /// Gets the items stored in this container.
    /// </summary>
    public IReadOnlyList<Item> Items => _items;

    /// <summary>
    /// Gets the maximum number of items this container can hold.
    /// </summary>
    public int Capacity { get; private set; }

    /// <summary>
    /// Gets the current number of items in the container.
    /// </summary>
    public int Count => _items.Count;

    /// <summary>
    /// Gets whether the container is empty.
    /// </summary>
    public bool IsEmpty => _items.Count == 0;

    /// <summary>
    /// Gets whether the container is full.
    /// </summary>
    public bool IsFull => _items.Count >= Capacity;

    /// <summary>
    /// Gets the remaining capacity.
    /// </summary>
    public int RemainingCapacity => Math.Max(0, Capacity - _items.Count);

    private ContainerInventory() { }

    /// <summary>
    /// Creates a new container inventory with the specified capacity.
    /// </summary>
    /// <param name="capacity">The maximum number of items.</param>
    /// <returns>A new ContainerInventory.</returns>
    /// <exception cref="ArgumentException">Thrown when capacity is not positive.</exception>
    public static ContainerInventory Create(int capacity)
    {
        if (capacity <= 0)
            throw new ArgumentException("Capacity must be positive.", nameof(capacity));

        return new ContainerInventory { Capacity = capacity };
    }

    /// <summary>
    /// Creates an empty container with default capacity.
    /// </summary>
    /// <param name="capacity">The capacity (default 10).</param>
    /// <returns>A new empty ContainerInventory.</returns>
    public static ContainerInventory Empty(int capacity = 10) => Create(capacity);

    /// <summary>
    /// Attempts to add an item to the container.
    /// </summary>
    /// <param name="item">The item to add.</param>
    /// <returns>True if the item was added, false if container is full.</returns>
    public bool TryAddItem(Item item)
    {
        if (IsFull) return false;
        if (item == null) return false;

        _items.Add(item);
        return true;
    }

    /// <summary>
    /// Removes an item from the container.
    /// </summary>
    /// <param name="item">The item to remove.</param>
    /// <returns>True if the item was removed.</returns>
    public bool RemoveItem(Item item)
    {
        return _items.Remove(item);
    }

    /// <summary>
    /// Finds an item by name (case-insensitive).
    /// </summary>
    /// <param name="name">The item name to search for.</param>
    /// <returns>The matching item, or null if not found.</returns>
    public Item? GetItemByName(string name)
    {
        return _items.FirstOrDefault(i =>
            i.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Finds an item by partial name match (case-insensitive).
    /// </summary>
    /// <param name="partialName">The partial name to search for.</param>
    /// <returns>The first matching item, or null if not found.</returns>
    public Item? GetItemByPartialName(string partialName)
    {
        return _items.FirstOrDefault(i =>
            i.Name.Contains(partialName, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Takes all items from the container, clearing it.
    /// </summary>
    /// <returns>All items that were in the container.</returns>
    public IEnumerable<Item> TakeAll()
    {
        var items = _items.ToList();
        _items.Clear();
        return items;
    }

    /// <summary>
    /// Populates the container with items (for initialization).
    /// </summary>
    /// <param name="items">The items to add.</param>
    /// <remarks>Stops adding if capacity is reached.</remarks>
    public void Populate(IEnumerable<Item> items)
    {
        foreach (var item in items)
        {
            if (!TryAddItem(item)) break;
        }
    }

    /// <summary>
    /// Gets a formatted list of contents for display.
    /// </summary>
    /// <returns>Formatted string of container contents.</returns>
    public string GetContentsDescription()
    {
        if (IsEmpty)
            return "The container is empty.";

        var lines = _items.Select(i => $"  - {i.Name}");
        return "Inside you find:\n" + string.Join("\n", lines);
    }
}
```

### 2.2 LockDefinition Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LockDefinition.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines the lock properties of an interactive object.
/// </summary>
public readonly record struct LockDefinition
{
    /// <summary>
    /// Gets the lock ID that keys must match.
    /// </summary>
    public string LockId { get; init; }

    /// <summary>
    /// Gets the required key ID to unlock (null if lockpickable only).
    /// </summary>
    public string? RequiredKeyId { get; init; }

    /// <summary>
    /// Gets whether this lock can be picked.
    /// </summary>
    public bool IsLockpickable { get; init; }

    /// <summary>
    /// Gets the lockpicking difficulty (dice check DC).
    /// </summary>
    public int LockpickDC { get; init; }

    /// <summary>
    /// Gets whether the key is consumed when used.
    /// </summary>
    public bool KeyConsumedOnUse { get; init; }

    /// <summary>
    /// Gets whether the lock can be re-locked after opening.
    /// </summary>
    public bool CanRelock { get; init; }

    /// <summary>
    /// Gets whether this lock has been permanently unlocked (e.g., by a quest).
    /// </summary>
    public bool IsPermanentlyUnlocked { get; init; }

    /// <summary>
    /// Gets whether this is an empty/no lock definition.
    /// </summary>
    public bool HasLock => !string.IsNullOrEmpty(LockId);

    /// <summary>
    /// Gets an empty lock definition (no lock).
    /// </summary>
    public static LockDefinition None => new()
    {
        LockId = string.Empty,
        RequiredKeyId = null,
        IsLockpickable = false,
        LockpickDC = 0,
        KeyConsumedOnUse = false,
        CanRelock = false
    };

    /// <summary>
    /// Creates a key-only lock (cannot be picked).
    /// </summary>
    /// <param name="lockId">The lock identifier.</param>
    /// <param name="keyId">The required key identifier.</param>
    /// <param name="consumeKey">Whether to consume the key on use.</param>
    /// <param name="canRelock">Whether the lock can be relocked.</param>
    /// <returns>A new LockDefinition.</returns>
    public static LockDefinition KeyOnly(
        string lockId,
        string keyId,
        bool consumeKey = false,
        bool canRelock = true) => new()
    {
        LockId = lockId,
        RequiredKeyId = keyId,
        IsLockpickable = false,
        LockpickDC = 0,
        KeyConsumedOnUse = consumeKey,
        CanRelock = canRelock
    };

    /// <summary>
    /// Creates a lockpickable lock.
    /// </summary>
    /// <param name="lockId">The lock identifier.</param>
    /// <param name="dc">The lockpicking difficulty class.</param>
    /// <param name="keyId">Optional key that also opens this lock.</param>
    /// <param name="canRelock">Whether the lock can be relocked.</param>
    /// <returns>A new LockDefinition.</returns>
    public static LockDefinition Pickable(
        string lockId,
        int dc,
        string? keyId = null,
        bool canRelock = true) => new()
    {
        LockId = lockId,
        RequiredKeyId = keyId,
        IsLockpickable = true,
        LockpickDC = dc,
        KeyConsumedOnUse = false,
        CanRelock = canRelock
    };

    /// <summary>
    /// Creates a lock that can be opened by key or lockpicking.
    /// </summary>
    /// <param name="lockId">The lock identifier.</param>
    /// <param name="keyId">The required key identifier.</param>
    /// <param name="dc">The lockpicking difficulty class.</param>
    /// <param name="canRelock">Whether the lock can be relocked.</param>
    /// <returns>A new LockDefinition.</returns>
    public static LockDefinition KeyOrPick(
        string lockId,
        string keyId,
        int dc,
        bool canRelock = true) => new()
    {
        LockId = lockId,
        RequiredKeyId = keyId,
        IsLockpickable = true,
        LockpickDC = dc,
        KeyConsumedOnUse = false,
        CanRelock = canRelock
    };

    /// <summary>
    /// Checks if a key matches this lock.
    /// </summary>
    /// <param name="keyId">The key ID to check.</param>
    /// <returns>True if the key matches this lock.</returns>
    public bool KeyMatches(string keyId)
    {
        if (string.IsNullOrEmpty(RequiredKeyId)) return false;
        return RequiredKeyId.Equals(keyId, StringComparison.OrdinalIgnoreCase);
    }
}
```

### 2.3 UnlockResult Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/UnlockResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of an unlock attempt.
/// </summary>
public readonly record struct UnlockResult
{
    /// <summary>
    /// Gets whether the unlock was successful.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the message to display to the player.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the method used to unlock (Key, Lockpick, or None).
    /// </summary>
    public UnlockMethod Method { get; init; }

    /// <summary>
    /// Gets whether a key was consumed in the process.
    /// </summary>
    public bool KeyConsumed { get; init; }

    /// <summary>
    /// Gets the name of the key used (if applicable).
    /// </summary>
    public string? KeyUsed { get; init; }

    /// <summary>
    /// Gets the skill check result (if lockpicking was attempted).
    /// </summary>
    public SkillCheckResult? SkillCheckResult { get; init; }

    /// <summary>
    /// Creates a successful unlock result using a key.
    /// </summary>
    public static UnlockResult SuccessWithKey(string message, string keyName, bool consumed) => new()
    {
        Success = true,
        Message = message,
        Method = UnlockMethod.Key,
        KeyConsumed = consumed,
        KeyUsed = keyName
    };

    /// <summary>
    /// Creates a successful unlock result using lockpicking.
    /// </summary>
    public static UnlockResult SuccessWithLockpick(string message, SkillCheckResult skillCheck) => new()
    {
        Success = true,
        Message = message,
        Method = UnlockMethod.Lockpick,
        SkillCheckResult = skillCheck
    };

    /// <summary>
    /// Creates a failed unlock result.
    /// </summary>
    public static UnlockResult Failed(string message, UnlockMethod attemptedMethod = UnlockMethod.None,
        SkillCheckResult? skillCheck = null) => new()
    {
        Success = false,
        Message = message,
        Method = attemptedMethod,
        SkillCheckResult = skillCheck
    };

    /// <summary>
    /// Creates result for when object is not locked.
    /// </summary>
    public static UnlockResult NotLocked(string objectName) =>
        Failed($"The {objectName} is not locked.");

    /// <summary>
    /// Creates result for when no matching key is found.
    /// </summary>
    public static UnlockResult NoKey(string objectName) =>
        Failed($"You don't have a key that fits this lock.", UnlockMethod.Key);

    /// <summary>
    /// Creates result for when lock cannot be picked.
    /// </summary>
    public static UnlockResult CannotPick(string objectName) =>
        Failed($"This lock cannot be picked.", UnlockMethod.Lockpick);
}

/// <summary>
/// Methods of unlocking a locked object.
/// </summary>
public enum UnlockMethod
{
    /// <summary>No method (failed or not applicable).</summary>
    None,

    /// <summary>Unlocked using a key.</summary>
    Key,

    /// <summary>Unlocked using lockpicking skill.</summary>
    Lockpick
}
```

### 2.4 ItemType Enum Update

**File:** `src/Core/RuneAndRust.Domain/Enums/ItemType.cs`

Add the following value to the existing enum:

```csharp
// Add to existing ItemType enum:

/// <summary>
/// Items used to unlock locked objects.
/// </summary>
Key
```

### 2.5 Item Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Item.cs`

Add the following properties and methods:

```csharp
// Add properties:

/// <summary>
/// Gets the lock ID this key opens (for key items only).
/// </summary>
/// <remarks>
/// Only applicable when Type is ItemType.Key.
/// The KeyId must match a LockDefinition.RequiredKeyId to unlock.
/// </remarks>
public string? KeyId { get; private set; }

/// <summary>
/// Gets whether this item is a key.
/// </summary>
public bool IsKey => Type == ItemType.Key;

/// <summary>
/// Gets whether this key is consumed when used.
/// </summary>
/// <remarks>
/// Single-use keys are removed from inventory after unlocking.
/// Only applicable when Type is ItemType.Key.
/// </remarks>
public bool IsKeyConsumedOnUse { get; private set; }

// Update constructor to include key parameters:

/// <param name="keyId">The lock ID this key opens (for key items).</param>
/// <param name="isKeyConsumedOnUse">Whether the key is consumed when used.</param>
public Item(string name, string description, ItemType type, int value = 0,
            ItemEffect effect = ItemEffect.None, int effectValue = 0, int effectDuration = 0,
            EquipmentSlot? equipmentSlot = null,
            string? damageDice = null,
            WeaponType? weaponType = null,
            WeaponBonuses? weaponBonuses = null,
            ArmorType? armorType = null,
            int defenseBonus = 0,
            StatModifiers? statModifiers = null,
            int initiativePenalty = 0,
            EquipmentRequirements? requirements = null,
            string? keyId = null,
            bool isKeyConsumedOnUse = false)
{
    // ... existing initialization ...
    KeyId = keyId;
    IsKeyConsumedOnUse = isKeyConsumedOnUse;
}

// Add factory methods:

/// <summary>
/// Factory method to create a key item.
/// </summary>
/// <param name="name">The display name of the key.</param>
/// <param name="description">The description of the key.</param>
/// <param name="keyId">The lock ID this key opens.</param>
/// <param name="consumeOnUse">Whether the key is consumed when used.</param>
/// <returns>A new key item.</returns>
public static Item CreateKey(
    string name,
    string description,
    string keyId,
    bool consumeOnUse = false) => new(
    name,
    description,
    ItemType.Key,
    value: 0,
    keyId: keyId,
    isKeyConsumedOnUse: consumeOnUse
);

/// <summary>
/// Factory method to create a basic iron key.
/// </summary>
/// <param name="keyId">The lock ID this key opens.</param>
/// <returns>A new iron key item.</returns>
public static Item CreateIronKey(string keyId) => CreateKey(
    "Iron Key",
    "A simple iron key. It must open something.",
    keyId
);

/// <summary>
/// Factory method to create an ornate key.
/// </summary>
/// <param name="keyId">The lock ID this key opens.</param>
/// <returns>A new ornate key item.</returns>
public static Item CreateOrnateKey(string keyId) => CreateKey(
    "Ornate Key",
    "An elaborate key decorated with intricate patterns.",
    keyId
);
```

### 2.6 InteractiveObject Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/InteractiveObject.cs`

Add the following properties and methods:

```csharp
// Add properties:

/// <summary>
/// Gets the container inventory (null for non-containers).
/// </summary>
public ContainerInventory? ContainerInventory { get; private set; }

/// <summary>
/// Gets whether this object is a container.
/// </summary>
public bool IsContainer => ContainerInventory != null;

/// <summary>
/// Gets the lock definition for this object.
/// </summary>
public LockDefinition Lock { get; private set; } = LockDefinition.None;

/// <summary>
/// Gets whether this object has a lock.
/// </summary>
public bool HasLock => Lock.HasLock;

/// <summary>
/// Gets whether this object is currently locked.
/// </summary>
public bool IsLocked => State == ObjectState.Locked;

// Add methods:

/// <summary>
/// Sets up this object as a container with the specified capacity.
/// </summary>
/// <param name="capacity">The container capacity.</param>
public void SetupAsContainer(int capacity)
{
    ContainerInventory = ContainerInventory.Create(capacity);
}

/// <summary>
/// Sets the lock definition for this object.
/// </summary>
/// <param name="lockDefinition">The lock definition.</param>
public void SetLock(LockDefinition lockDefinition)
{
    Lock = lockDefinition;
    if (lockDefinition.HasLock && State == ObjectState.Closed)
    {
        State = ObjectState.Locked;
    }
}

/// <summary>
/// Attempts to unlock this object with a key.
/// </summary>
/// <param name="keyId">The key ID to try.</param>
/// <returns>True if unlocked, false if key doesn't match.</returns>
public bool TryUnlockWithKey(string keyId)
{
    if (!IsLocked) return false;
    if (!HasLock) return false;
    if (!Lock.KeyMatches(keyId)) return false;

    State = ObjectState.Closed;
    return true;
}

/// <summary>
/// Unlocks this object (e.g., after successful lockpick).
/// </summary>
/// <returns>True if state changed to unlocked.</returns>
public bool Unlock()
{
    if (!IsLocked) return false;

    State = ObjectState.Closed;
    return true;
}

/// <summary>
/// Locks this object if it can be relocked.
/// </summary>
/// <returns>True if locked, false if cannot relock.</returns>
public bool TryLock()
{
    if (IsLocked) return false;
    if (!HasLock) return false;
    if (!Lock.CanRelock) return false;
    if (State != ObjectState.Closed) return false;

    State = ObjectState.Locked;
    return true;
}

// Update FromDefinition to handle container and lock:

/// <summary>
/// Creates an interactive object from a definition.
/// </summary>
public static InteractiveObject FromDefinition(InteractiveObjectDefinition definition)
{
    ArgumentNullException.ThrowIfNull(definition);

    var obj = new InteractiveObject
    {
        Id = Guid.NewGuid(),
        DefinitionId = definition.Id,
        Name = definition.Name,
        ObjectType = definition.ObjectType,
        State = definition.DefaultState,
        DefaultState = definition.DefaultState,
        AllowedInteractions = definition.AllowedInteractions.ToList(),
        BlocksPassage = definition.BlocksPassage,
        BlockedDirection = definition.BlockedDirection,
        Keywords = definition.Keywords.ToList(),
        IsVisible = definition.IsVisible
    };

    // Set up container if applicable
    if (definition.IsContainer && definition.ContainerCapacity > 0)
    {
        obj.SetupAsContainer(definition.ContainerCapacity);
    }

    // Set up lock if applicable
    if (definition.Lock != null && definition.Lock.HasLock)
    {
        obj.SetLock(definition.Lock);
    }

    return obj;
}
```

### 2.7 InteractiveObjectDefinition Updates

**File:** `src/Core/RuneAndRust.Domain/Definitions/InteractiveObjectDefinition.cs`

Add properties for container and lock configuration:

```csharp
// Add properties:

/// <summary>
/// Gets or sets whether this object is a container.
/// </summary>
public bool IsContainer { get; set; }

/// <summary>
/// Gets or sets the container capacity (for containers).
/// </summary>
public int ContainerCapacity { get; set; }

/// <summary>
/// Gets or sets the lock definition for this object.
/// </summary>
public LockDefinition? Lock { get; set; }

/// <summary>
/// Gets or sets the initial contents of this container.
/// </summary>
/// <remarks>
/// List of item definition IDs to populate the container with.
/// </remarks>
public List<ContainerContentEntry> Contents { get; set; } = new();

/// <summary>
/// Represents an entry in container contents configuration.
/// </summary>
public class ContainerContentEntry
{
    /// <summary>
    /// Gets or sets the item definition ID.
    /// </summary>
    public string ItemId { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the quantity (default 1).
    /// </summary>
    public int Quantity { get; set; } = 1;
}
```

---

## 3. Services

### 3.1 IInteractionService Updates

**File:** `src/Core/RuneAndRust.Application/Interfaces/IInteractionService.cs`

Add new methods:

```csharp
// Add to interface:

/// <summary>
/// Attempts to unlock an interactive object using a key from player inventory.
/// </summary>
/// <param name="obj">The object to unlock.</param>
/// <param name="player">The player attempting to unlock.</param>
/// <returns>The unlock result.</returns>
UnlockResult UnlockWithKey(InteractiveObject obj, Player player);

/// <summary>
/// Attempts to pick the lock on an interactive object.
/// </summary>
/// <param name="obj">The object to unlock.</param>
/// <param name="player">The player attempting to pick the lock.</param>
/// <returns>The unlock result.</returns>
UnlockResult PickLock(InteractiveObject obj, Player player);

/// <summary>
/// Attempts to lock an interactive object.
/// </summary>
/// <param name="obj">The object to lock.</param>
/// <returns>The interaction result.</returns>
InteractionResult Lock(InteractiveObject obj);

/// <summary>
/// Takes an item from a container.
/// </summary>
/// <param name="container">The container to take from.</param>
/// <param name="itemName">The name of the item to take.</param>
/// <param name="player">The player taking the item.</param>
/// <returns>The interaction result.</returns>
InteractionResult TakeFromContainer(InteractiveObject container, string itemName, Player player);

/// <summary>
/// Takes all items from a container.
/// </summary>
/// <param name="container">The container to empty.</param>
/// <param name="player">The player taking the items.</param>
/// <returns>The interaction result with list of items taken.</returns>
InteractionResult TakeAllFromContainer(InteractiveObject container, Player player);

/// <summary>
/// Puts an item into a container.
/// </summary>
/// <param name="container">The container to put the item in.</param>
/// <param name="itemName">The name of the item to put.</param>
/// <param name="player">The player putting the item.</param>
/// <returns>The interaction result.</returns>
InteractionResult PutInContainer(InteractiveObject container, string itemName, Player player);

/// <summary>
/// Gets the contents description of a container.
/// </summary>
/// <param name="container">The container to describe.</param>
/// <returns>The contents description.</returns>
string GetContainerContents(InteractiveObject container);
```

### 3.2 InteractionService Updates

**File:** `src/Core/RuneAndRust.Application/Services/InteractionService.cs`

Add implementations and update existing methods:

```csharp
// Add dependencies:
private readonly SkillCheckService _skillCheckService;

// Update constructor:
public InteractionService(
    IObjectDescriptorService descriptorService,
    SkillCheckService skillCheckService,
    ILogger<InteractionService> logger)
{
    _descriptorService = descriptorService ?? throw new ArgumentNullException(nameof(descriptorService));
    _skillCheckService = skillCheckService ?? throw new ArgumentNullException(nameof(skillCheckService));
    _logger = logger ?? throw new ArgumentNullException(nameof(logger));
}

// Update Open method to show container contents:
public InteractionResult Open(InteractiveObject obj)
{
    ArgumentNullException.ThrowIfNull(obj);

    if (obj.State == ObjectState.Open)
    {
        return InteractionResult.Failed(
            InteractionType.Open,
            $"The {obj.Name} is already open.");
    }

    if (obj.State == ObjectState.Locked)
    {
        return InteractionResult.Failed(
            InteractionType.Open,
            $"The {obj.Name} is locked.",
            "Object is locked");
    }

    if (!obj.TrySetState(ObjectState.Open))
    {
        return InteractionResult.Failed(
            InteractionType.Open,
            $"The {obj.Name} cannot be opened.",
            "State change not allowed");
    }

    _logger.LogInformation("Opened {ObjectName}", obj.Name);

    var message = GetOpenMessage(obj);

    // If it's a container, show contents
    if (obj.IsContainer && obj.ContainerInventory != null)
    {
        message += "\n\n" + obj.ContainerInventory.GetContentsDescription();
    }

    return InteractionResult.Succeeded(
        InteractionType.Open,
        message,
        ObjectState.Open,
        stateChanged: true);
}

// Add new methods:

/// <inheritdoc />
public UnlockResult UnlockWithKey(InteractiveObject obj, Player player)
{
    ArgumentNullException.ThrowIfNull(obj);
    ArgumentNullException.ThrowIfNull(player);

    _logger.LogDebug("Attempting to unlock {ObjectName} with key", obj.Name);

    if (!obj.IsLocked)
    {
        return UnlockResult.NotLocked(obj.Name);
    }

    if (!obj.HasLock)
    {
        return UnlockResult.NotLocked(obj.Name);
    }

    // Find a matching key in player's inventory
    var matchingKey = player.Inventory.Items
        .FirstOrDefault(i => i.IsKey && obj.Lock.KeyMatches(i.KeyId!));

    if (matchingKey == null)
    {
        _logger.LogDebug("No matching key found for {ObjectName}", obj.Name);
        return UnlockResult.NoKey(obj.Name);
    }

    // Unlock with the key
    if (!obj.TryUnlockWithKey(matchingKey.KeyId!))
    {
        return UnlockResult.Failed($"The key doesn't fit this lock.");
    }

    var consumed = false;
    if (matchingKey.IsKeyConsumedOnUse)
    {
        player.Inventory.RemoveItem(matchingKey);
        consumed = true;
        _logger.LogInformation("Key {KeyName} consumed after unlocking {ObjectName}",
            matchingKey.Name, obj.Name);
    }

    _logger.LogInformation("Unlocked {ObjectName} with {KeyName}", obj.Name, matchingKey.Name);

    return UnlockResult.SuccessWithKey(
        $"You use the {matchingKey.Name} to unlock the {obj.Name}.",
        matchingKey.Name,
        consumed);
}

/// <inheritdoc />
public UnlockResult PickLock(InteractiveObject obj, Player player)
{
    ArgumentNullException.ThrowIfNull(obj);
    ArgumentNullException.ThrowIfNull(player);

    _logger.LogDebug("Attempting to pick lock on {ObjectName}", obj.Name);

    if (!obj.IsLocked)
    {
        return UnlockResult.NotLocked(obj.Name);
    }

    if (!obj.HasLock)
    {
        return UnlockResult.NotLocked(obj.Name);
    }

    if (!obj.Lock.IsLockpickable)
    {
        _logger.LogDebug("Lock on {ObjectName} cannot be picked", obj.Name);
        return UnlockResult.CannotPick(obj.Name);
    }

    // Perform lockpicking skill check
    var skillCheck = _skillCheckService.PerformCheckWithDC(
        player,
        "lockpicking",
        obj.Lock.LockpickDC,
        GetLockDifficultyName(obj.Lock.LockpickDC));

    if (skillCheck.IsSuccess)
    {
        obj.Unlock();
        _logger.LogInformation(
            "Successfully picked lock on {ObjectName} (DC {DC}, rolled {Roll})",
            obj.Name, obj.Lock.LockpickDC, skillCheck.TotalResult);

        var message = skillCheck.IsCriticalSuccess
            ? $"With expert precision, you pick the lock on the {obj.Name}. It clicks open effortlessly."
            : $"You carefully work the lock on the {obj.Name}. After a moment, it clicks open.";

        return UnlockResult.SuccessWithLockpick(message, skillCheck);
    }
    else
    {
        _logger.LogDebug(
            "Failed to pick lock on {ObjectName} (DC {DC}, rolled {Roll})",
            obj.Name, obj.Lock.LockpickDC, skillCheck.TotalResult);

        var message = skillCheck.IsCriticalFailure
            ? $"Your lockpick slips badly. The lock on the {obj.Name} remains firmly shut."
            : $"You attempt to pick the lock, but it resists your efforts.";

        return UnlockResult.Failed(message, UnlockMethod.Lockpick, skillCheck);
    }
}

/// <inheritdoc />
public InteractionResult Lock(InteractiveObject obj)
{
    ArgumentNullException.ThrowIfNull(obj);

    if (obj.IsLocked)
    {
        return InteractionResult.Failed(
            InteractionType.Lock,
            $"The {obj.Name} is already locked.");
    }

    if (!obj.HasLock)
    {
        return InteractionResult.Failed(
            InteractionType.Lock,
            $"The {obj.Name} doesn't have a lock.");
    }

    if (!obj.Lock.CanRelock)
    {
        return InteractionResult.Failed(
            InteractionType.Lock,
            $"This lock cannot be relocked.");
    }

    if (obj.State != ObjectState.Closed)
    {
        return InteractionResult.Failed(
            InteractionType.Lock,
            $"You need to close the {obj.Name} before locking it.");
    }

    if (!obj.TryLock())
    {
        return InteractionResult.Failed(
            InteractionType.Lock,
            $"The {obj.Name} cannot be locked.");
    }

    _logger.LogInformation("Locked {ObjectName}", obj.Name);

    return InteractionResult.Succeeded(
        InteractionType.Lock,
        $"You lock the {obj.Name}.",
        ObjectState.Locked,
        stateChanged: true);
}

/// <inheritdoc />
public InteractionResult TakeFromContainer(InteractiveObject container, string itemName, Player player)
{
    ArgumentNullException.ThrowIfNull(container);
    ArgumentException.ThrowIfNullOrWhiteSpace(itemName);
    ArgumentNullException.ThrowIfNull(player);

    if (!container.IsContainer)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            $"The {container.Name} is not a container.");
    }

    if (container.State != ObjectState.Open)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            $"The {container.Name} is not open.");
    }

    var item = container.ContainerInventory!.GetItemByPartialName(itemName);
    if (item == null)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            $"There is no '{itemName}' in the {container.Name}.");
    }

    if (player.Inventory.IsFull)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            "Your inventory is full.");
    }

    container.ContainerInventory.RemoveItem(item);
    player.Inventory.AddItem(item);

    _logger.LogInformation("Took {ItemName} from {ContainerName}", item.Name, container.Name);

    return InteractionResult.Succeeded(
        InteractionType.Take,
        $"You take the {item.Name} from the {container.Name}.");
}

/// <inheritdoc />
public InteractionResult TakeAllFromContainer(InteractiveObject container, Player player)
{
    ArgumentNullException.ThrowIfNull(container);
    ArgumentNullException.ThrowIfNull(player);

    if (!container.IsContainer)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            $"The {container.Name} is not a container.");
    }

    if (container.State != ObjectState.Open)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            $"The {container.Name} is not open.");
    }

    if (container.ContainerInventory!.IsEmpty)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            $"The {container.Name} is empty.");
    }

    var takenItems = new List<string>();
    var leftBehind = new List<string>();

    foreach (var item in container.ContainerInventory.Items.ToList())
    {
        if (player.Inventory.IsFull)
        {
            leftBehind.Add(item.Name);
        }
        else
        {
            container.ContainerInventory.RemoveItem(item);
            player.Inventory.AddItem(item);
            takenItems.Add(item.Name);
        }
    }

    if (takenItems.Count == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            "Your inventory is full.");
    }

    _logger.LogInformation("Took {Count} items from {ContainerName}", takenItems.Count, container.Name);

    var message = $"You take:\n" + string.Join("\n", takenItems.Select(n => $"  - {n}"));

    if (leftBehind.Count > 0)
    {
        message += $"\n\nYour inventory is full. Left behind:\n" +
                   string.Join("\n", leftBehind.Select(n => $"  - {n}"));
    }
    else if (container.ContainerInventory.IsEmpty)
    {
        message += $"\n\nThe {container.Name} is now empty.";
    }

    return InteractionResult.Succeeded(InteractionType.Take, message);
}

/// <inheritdoc />
public InteractionResult PutInContainer(InteractiveObject container, string itemName, Player player)
{
    ArgumentNullException.ThrowIfNull(container);
    ArgumentException.ThrowIfNullOrWhiteSpace(itemName);
    ArgumentNullException.ThrowIfNull(player);

    if (!container.IsContainer)
    {
        return InteractionResult.Failed(
            InteractionType.Put,
            $"You can't put things in the {container.Name}.");
    }

    if (container.State != ObjectState.Open)
    {
        return InteractionResult.Failed(
            InteractionType.Put,
            $"The {container.Name} is not open.");
    }

    var item = player.Inventory.GetItemByPartialName(itemName);
    if (item == null)
    {
        return InteractionResult.Failed(
            InteractionType.Put,
            $"You don't have '{itemName}' in your inventory.");
    }

    if (container.ContainerInventory!.IsFull)
    {
        return InteractionResult.Failed(
            InteractionType.Put,
            $"The {container.Name} is full.");
    }

    player.Inventory.RemoveItem(item);
    container.ContainerInventory.TryAddItem(item);

    _logger.LogInformation("Put {ItemName} in {ContainerName}", item.Name, container.Name);

    return InteractionResult.Succeeded(
        InteractionType.Put,
        $"You put the {item.Name} in the {container.Name}.");
}

/// <inheritdoc />
public string GetContainerContents(InteractiveObject container)
{
    if (!container.IsContainer || container.ContainerInventory == null)
    {
        return $"The {container.Name} is not a container.";
    }

    if (container.State != ObjectState.Open)
    {
        return $"The {container.Name} is closed.";
    }

    return container.ContainerInventory.GetContentsDescription();
}

// Helper methods:

private static string GetLockDifficultyName(int dc)
{
    return dc switch
    {
        <= 8 => "Simple",
        <= 10 => "Easy",
        <= 12 => "Average",
        <= 14 => "Tricky",
        <= 16 => "Hard",
        <= 18 => "Very Hard",
        <= 20 => "Expert",
        _ => "Master"
    };
}
```

---

## 4. Command Integration

### 4.1 Unlock Command

```
> unlock <object>
```

**Command Processing:**

```csharp
private InteractionResult ProcessUnlockCommand(string[] args, Room currentRoom, Player player)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Unlock,
            "Unlock what? Try 'unlock <object>'.");
    }

    var keyword = string.Join(" ", args);
    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Unlock,
            $"You don't see any '{keyword}' here.");
    }

    var result = _interactionService.UnlockWithKey(obj, player);

    // Convert UnlockResult to InteractionResult for display
    return result.Success
        ? InteractionResult.Succeeded(InteractionType.Unlock, result.Message, ObjectState.Closed, true)
        : InteractionResult.Failed(InteractionType.Unlock, result.Message);
}
```

### 4.2 Pick Lock Command

```
> pick lock on <object>
> pick <object>
```

**Command Processing:**

```csharp
private InteractionResult ProcessPickLockCommand(string[] args, Room currentRoom, Player player)
{
    // Parse "pick lock on <object>" or "pick <object>"
    var keyword = ParsePickLockTarget(args);

    if (string.IsNullOrEmpty(keyword))
    {
        return InteractionResult.Failed(
            InteractionType.Unlock,
            "Pick what? Try 'pick lock on <object>' or 'pick <object>'.");
    }

    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Unlock,
            $"You don't see any '{keyword}' here.");
    }

    var result = _interactionService.PickLock(obj, player);

    // Build message including skill check details
    var message = result.Message;
    if (result.SkillCheckResult.HasValue)
    {
        var check = result.SkillCheckResult.Value;
        message = $"[Lockpicking check: DC {check.DifficultyClass}]\n" +
                  $"Roll: {check.DiceResult.Total} + {check.TotalBonus} = {check.TotalResult}\n\n" +
                  message;
    }

    return result.Success
        ? InteractionResult.Succeeded(InteractionType.Unlock, message, ObjectState.Closed, true)
        : InteractionResult.Failed(InteractionType.Unlock, message);
}

private static string ParsePickLockTarget(string[] args)
{
    // "pick lock on door" -> "door"
    // "pick door" -> "door"
    if (args.Length == 0) return string.Empty;

    var argString = string.Join(" ", args);

    if (argString.StartsWith("lock on ", StringComparison.OrdinalIgnoreCase))
    {
        return argString[8..].Trim();
    }

    return argString;
}
```

### 4.3 Take Command (Container Support)

```
> take <item> from <container>
> take all from <container>
```

**Command Processing:**

```csharp
private InteractionResult ProcessTakeCommand(string[] args, Room currentRoom, Player player)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Take,
            "Take what? Try 'take <item>' or 'take <item> from <container>'.");
    }

    var argString = string.Join(" ", args);

    // Check for "from <container>" pattern
    var fromIndex = argString.IndexOf(" from ", StringComparison.OrdinalIgnoreCase);
    if (fromIndex > 0)
    {
        var itemName = argString[..fromIndex].Trim();
        var containerKeyword = argString[(fromIndex + 6)..].Trim();

        var container = _interactionService.FindObject(currentRoom, containerKeyword);
        if (container == null)
        {
            return InteractionResult.Failed(
                InteractionType.Take,
                $"You don't see any '{containerKeyword}' here.");
        }

        if (itemName.Equals("all", StringComparison.OrdinalIgnoreCase))
        {
            return _interactionService.TakeAllFromContainer(container, player);
        }

        return _interactionService.TakeFromContainer(container, itemName, player);
    }

    // Regular take from room (existing behavior)
    return ProcessTakeFromRoom(argString, currentRoom, player);
}
```

### 4.4 Put Command

```
> put <item> in <container>
```

**Command Processing:**

```csharp
private InteractionResult ProcessPutCommand(string[] args, Room currentRoom, Player player)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Put,
            "Put what where? Try 'put <item> in <container>'.");
    }

    var argString = string.Join(" ", args);

    // Check for "in <container>" pattern
    var inIndex = argString.IndexOf(" in ", StringComparison.OrdinalIgnoreCase);
    if (inIndex <= 0)
    {
        return InteractionResult.Failed(
            InteractionType.Put,
            "Put where? Try 'put <item> in <container>'.");
    }

    var itemName = argString[..inIndex].Trim();
    var containerKeyword = argString[(inIndex + 4)..].Trim();

    var container = _interactionService.FindObject(currentRoom, containerKeyword);
    if (container == null)
    {
        return InteractionResult.Failed(
            InteractionType.Put,
            $"You don't see any '{containerKeyword}' here.");
    }

    return _interactionService.PutInContainer(container, itemName, player);
}
```

### 4.5 Lock Command

```
> lock <object>
```

**Command Processing:**

```csharp
private InteractionResult ProcessLockCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return InteractionResult.Failed(
            InteractionType.Lock,
            "Lock what? Try 'lock <object>'.");
    }

    var keyword = string.Join(" ", args);
    var obj = _interactionService.FindObject(currentRoom, keyword);

    if (obj == null)
    {
        return InteractionResult.Failed(
            InteractionType.Lock,
            $"You don't see any '{keyword}' here.");
    }

    return _interactionService.Lock(obj);
}
```

---

## 5. Configuration

### 5.1 Updated Interactive Objects Configuration

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/interactive-objects.json`

Add locked and container objects:

```json
{
  "$schema": "./schemas/interactive-objects.schema.json",
  "interactiveObjects": [
    {
      "id": "locked-chest-simple",
      "name": "Locked Wooden Chest",
      "objectType": "Chest",
      "defaultState": "Locked",
      "allowedInteractions": ["Open", "Close", "Unlock", "Examine", "Take", "Put"],
      "isContainer": true,
      "containerCapacity": 10,
      "lock": {
        "lockId": "simple-chest-lock",
        "requiredKeyId": "simple-chest-key",
        "isLockpickable": true,
        "lockpickDC": 10,
        "canRelock": true
      },
      "keywords": ["chest", "locked chest", "wooden chest"]
    },
    {
      "id": "locked-chest-vault",
      "name": "Iron-Bound Vault Chest",
      "objectType": "Chest",
      "defaultState": "Locked",
      "allowedInteractions": ["Open", "Close", "Unlock", "Examine", "Take", "Put"],
      "isContainer": true,
      "containerCapacity": 15,
      "lock": {
        "lockId": "vault-chest-lock",
        "requiredKeyId": "vault-key",
        "isLockpickable": true,
        "lockpickDC": 14,
        "canRelock": true
      },
      "keywords": ["chest", "vault chest", "iron chest"]
    },
    {
      "id": "locked-door-vault",
      "name": "Vault Door",
      "objectType": "Door",
      "defaultState": "Locked",
      "allowedInteractions": ["Open", "Close", "Unlock", "Examine"],
      "blocksPassage": true,
      "lock": {
        "lockId": "vault-door-lock",
        "requiredKeyId": "master-vault-key",
        "isLockpickable": false,
        "canRelock": true
      },
      "keywords": ["door", "vault door", "iron door"]
    },
    {
      "id": "locked-door-cell",
      "name": "Cell Door",
      "objectType": "Door",
      "defaultState": "Locked",
      "allowedInteractions": ["Open", "Close", "Unlock", "Examine"],
      "blocksPassage": true,
      "lock": {
        "lockId": "cell-door-lock",
        "requiredKeyId": "cell-key",
        "isLockpickable": true,
        "lockpickDC": 12,
        "canRelock": true
      },
      "keywords": ["door", "cell door", "barred door"]
    },
    {
      "id": "storage-crate",
      "name": "Storage Crate",
      "objectType": "Crate",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine", "Take", "Put", "Break"],
      "isContainer": true,
      "containerCapacity": 8,
      "keywords": ["crate", "storage crate", "box"]
    },
    {
      "id": "supply-barrel",
      "name": "Supply Barrel",
      "objectType": "Barrel",
      "defaultState": "Closed",
      "allowedInteractions": ["Open", "Close", "Examine", "Take", "Put"],
      "isContainer": true,
      "containerCapacity": 6,
      "keywords": ["barrel", "supply barrel"]
    }
  ]
}
```

### 5.2 Keys Configuration

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/keys.json`

```json
{
  "$schema": "./schemas/keys.schema.json",
  "keys": [
    {
      "id": "simple-chest-key",
      "name": "Rusty Iron Key",
      "description": "A simple iron key, worn from use.",
      "opensLockId": "simple-chest-lock",
      "consumeOnUse": false
    },
    {
      "id": "vault-key",
      "name": "Vault Key",
      "description": "A small brass key with intricate teeth.",
      "opensLockId": "vault-chest-lock",
      "consumeOnUse": false
    },
    {
      "id": "master-vault-key",
      "name": "Master Vault Key",
      "description": "A large iron key bearing the seal of the vault keeper.",
      "opensLockId": "vault-door-lock",
      "consumeOnUse": false
    },
    {
      "id": "cell-key",
      "name": "Cell Key",
      "description": "A bent iron key that looks like it's seen better days.",
      "opensLockId": "cell-door-lock",
      "consumeOnUse": false
    },
    {
      "id": "skeleton-key",
      "name": "Skeleton Key",
      "description": "A mysterious key said to open any simple lock. Breaks after use.",
      "opensLockId": "simple-chest-lock",
      "consumeOnUse": true
    }
  ]
}
```

### 5.3 Keys Schema

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/schemas/keys.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Keys Configuration",
  "description": "Configuration for key items in the game",
  "type": "object",
  "properties": {
    "keys": {
      "type": "array",
      "description": "List of key definitions",
      "items": {
        "$ref": "#/definitions/keyDefinition"
      }
    }
  },
  "definitions": {
    "keyDefinition": {
      "type": "object",
      "required": ["id", "name", "opensLockId"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for this key"
        },
        "name": {
          "type": "string",
          "description": "Display name of the key"
        },
        "description": {
          "type": "string",
          "description": "Description shown when examining the key"
        },
        "opensLockId": {
          "type": "string",
          "description": "The lock ID this key opens"
        },
        "consumeOnUse": {
          "type": "boolean",
          "description": "Whether the key is destroyed after use",
          "default": false
        }
      }
    }
  }
}
```

### 5.4 Updated Interactive Objects Schema

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/schemas/interactive-objects.schema.json`

Add container and lock properties to the schema:

```json
{
  "definitions": {
    "interactiveObjectDefinition": {
      "properties": {
        "isContainer": {
          "type": "boolean",
          "description": "Whether this object is a container",
          "default": false
        },
        "containerCapacity": {
          "type": "integer",
          "description": "Maximum items the container can hold",
          "minimum": 1,
          "default": 10
        },
        "lock": {
          "$ref": "#/definitions/lockDefinition"
        },
        "contents": {
          "type": "array",
          "description": "Initial contents of the container",
          "items": {
            "$ref": "#/definitions/containerContent"
          }
        }
      }
    },
    "lockDefinition": {
      "type": "object",
      "properties": {
        "lockId": {
          "type": "string",
          "description": "Unique identifier for this lock"
        },
        "requiredKeyId": {
          "type": "string",
          "description": "The key ID required to open this lock"
        },
        "isLockpickable": {
          "type": "boolean",
          "description": "Whether this lock can be picked",
          "default": true
        },
        "lockpickDC": {
          "type": "integer",
          "description": "Difficulty class for lockpicking",
          "minimum": 1,
          "default": 10
        },
        "keyConsumedOnUse": {
          "type": "boolean",
          "description": "Whether the key is consumed when used",
          "default": false
        },
        "canRelock": {
          "type": "boolean",
          "description": "Whether the lock can be relocked",
          "default": true
        }
      }
    },
    "containerContent": {
      "type": "object",
      "required": ["itemId"],
      "properties": {
        "itemId": {
          "type": "string",
          "description": "Item definition ID"
        },
        "quantity": {
          "type": "integer",
          "description": "Number of this item",
          "minimum": 1,
          "default": 1
        }
      }
    }
  }
}
```

---

## 6. User Experience

### 6.1 Container Interaction Examples

**Opening a Container:**
```
> open chest

You lift the lid of the Locked Wooden Chest.

Inside you find:
  - Health Potion
  - Iron Key
  - 15 gold
```

**Taking Items:**
```
> take potion from chest

You take the Health Potion from the Locked Wooden Chest.

> take all from chest

You take:
  - Iron Key
  - 15 gold

The Locked Wooden Chest is now empty.
```

**Putting Items:**
```
> put torch in chest

You put the Torch in the Locked Wooden Chest.
```

### 6.2 Lock Interaction Examples

**Unlocking with Key:**
```
> open door

The Vault Door is locked.

> unlock door

You use the Master Vault Key to unlock the Vault Door.

> open door

You push open the Vault Door. It swings open with a creak.
```

**Lockpicking:**
```
> pick lock on chest

[Lockpicking check: DC 12]
Roll: 11 + 3 = 14

You carefully work the lock on the Cell Door. After a moment, it clicks open.

---

> pick lock on chest
[Failed roll]

[Lockpicking check: DC 12]
Roll: 6 + 3 = 9

You attempt to pick the lock, but it resists your efforts.
```

**Unpickable Lock:**
```
> pick lock on vault door

This lock cannot be picked.
```

**Relocking:**
```
> lock chest

You lock the Locked Wooden Chest.
```

---

## 7. Acceptance Criteria

### 7.1 Functional Requirements

- [ ] ContainerInventory holds items with capacity limits
- [ ] ContainerInventory tracks count, empty, and full states
- [ ] Containers can be opened to reveal contents
- [ ] Container contents display when opened
- [ ] `take <item> from <container>` removes item and adds to player inventory
- [ ] `take all from <container>` empties container
- [ ] `take all` stops when player inventory is full
- [ ] `put <item> in <container>` moves item from player to container
- [ ] `put` fails when container is full
- [ ] ItemType.Key enum value exists
- [ ] Item has KeyId property for key items
- [ ] Item has IsKeyConsumedOnUse property
- [ ] LockDefinition stores lock ID, key ID, DC, and options
- [ ] `unlock` command finds matching key in player inventory
- [ ] `unlock` uses key automatically when found
- [ ] Consumed keys are removed from inventory
- [ ] `pick lock` performs skill check against lock DC
- [ ] Successful lockpick changes state to Closed (unlocked)
- [ ] Failed lockpick keeps object locked
- [ ] `lock` command relocks relockable objects
- [ ] Locked objects cannot be opened without unlock
- [ ] Integration with existing SkillCheckService works
- [ ] ~30 unit tests pass

### 7.2 Non-Functional Requirements

- [ ] Value objects are immutable where appropriate
- [ ] Services follow DI patterns
- [ ] Logging follows established patterns
- [ ] Configuration is JSON-driven

---

## 8. Test Specifications

### 8.1 ContainerInventory Tests (~8 tests)

| Test Name | Description |
|-----------|-------------|
| `Create_WithValidCapacity_ReturnsContainer` | Valid creation |
| `Create_WithZeroCapacity_ThrowsException` | Zero capacity rejected |
| `TryAddItem_WhenNotFull_ReturnsTrue` | Adding items |
| `TryAddItem_WhenFull_ReturnsFalse` | Full container handling |
| `RemoveItem_ExistingItem_ReturnsTrue` | Removing items |
| `GetItemByName_CaseInsensitive_ReturnsItem` | Name lookup |
| `TakeAll_ReturnsAllAndClears` | Take all functionality |
| `IsEmpty_WhenEmpty_ReturnsTrue` | Empty state tracking |

### 8.2 LockDefinition Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `None_HasNoLock` | Empty definition |
| `KeyOnly_HasCorrectProperties` | Key-only lock |
| `Pickable_HasCorrectDC` | Pickable lock |
| `KeyMatches_WithMatchingKey_ReturnsTrue` | Key matching |
| `KeyMatches_WithWrongKey_ReturnsFalse` | Wrong key handling |
| `KeyMatches_WithNoRequiredKey_ReturnsFalse` | No key required |

### 8.3 InteractiveObject Lock Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `TryUnlockWithKey_MatchingKey_Unlocks` | Key unlock |
| `TryUnlockWithKey_WrongKey_ReturnsFalse` | Wrong key |
| `TryUnlockWithKey_NotLocked_ReturnsFalse` | Already unlocked |
| `TryLock_WhenClosed_Locks` | Locking |
| `TryLock_WhenNotClosed_ReturnsFalse` | Must be closed |
| `TryLock_CannotRelock_ReturnsFalse` | Non-relockable |

### 8.4 InteractionService Container Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `TakeFromContainer_ExistingItem_RemovesAndAdds` | Taking items |
| `TakeFromContainer_NotOpen_ReturnsFailed` | Must be open |
| `TakeAllFromContainer_MovesAllItems` | Take all |
| `PutInContainer_AddsItem` | Putting items |
| `PutInContainer_Full_ReturnsFailed` | Full handling |

### 8.5 InteractionService Lock Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `UnlockWithKey_FindsAndUsesKey` | Auto key detection |
| `UnlockWithKey_NoMatchingKey_ReturnsFailed` | No key handling |
| `PickLock_SuccessfulCheck_Unlocks` | Successful pick |
| `PickLock_FailedCheck_StaysLocked` | Failed pick |
| `PickLock_NotPickable_ReturnsFailed` | Unpickable handling |

---

## 9. Dependencies

### 9.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| InteractiveObject entity | v0.4.0a | Complete | Base entity |
| InteractionService | v0.4.0a | Complete | Needs updates |
| InteractionType enum | v0.4.0a | Complete | Has Unlock, Take, Put |
| ObjectState enum | v0.0.x | Complete | Has Locked state |
| Item entity | v0.0.x | Complete | Needs key properties |
| ItemType enum | v0.0.x | Complete | Needs Key value |
| DiceService | v0.0.5 | Complete | For lockpicking |
| SkillCheckService | v0.0.5 | Complete | For lockpicking |
| Player.Inventory | v0.0.x | Complete | For key lookup |
| Lockpicking skill | v0.0.5 | Complete | Uses Finesse attribute |

### 9.2 External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Microsoft.Extensions.Logging | 9.0.x | Logging |
| System.Text.Json | 9.0.x | Configuration parsing |

---

## 10. Files Summary

### 10.1 New Files

| File | Purpose |
|------|---------|
| `Domain/ValueObjects/ContainerInventory.cs` | Container storage |
| `Domain/ValueObjects/LockDefinition.cs` | Lock properties |
| `Domain/ValueObjects/UnlockResult.cs` | Unlock attempt result |
| `Configuration/keys.json` | Key item definitions |
| `Configuration/schemas/keys.schema.json` | Key schema |
| `Tests/ContainerInventoryTests.cs` | Container tests |
| `Tests/LockDefinitionTests.cs` | Lock tests |
| `Tests/InteractionServiceLockTests.cs` | Lock service tests |
| `Tests/InteractionServiceContainerTests.cs` | Container service tests |

### 10.2 Modified Files

| File | Changes |
|------|---------|
| `Domain/Enums/ItemType.cs` | Add Key value |
| `Domain/Entities/Item.cs` | Add KeyId, IsKeyConsumedOnUse, factory methods |
| `Domain/Entities/InteractiveObject.cs` | Add container and lock properties/methods |
| `Domain/Definitions/InteractiveObjectDefinition.cs` | Add container and lock config |
| `Application/Interfaces/IInteractionService.cs` | Add lock/container methods |
| `Application/Services/InteractionService.cs` | Implement lock/container methods |
| `Application/Services/GameSessionService.cs` | Add unlock/pick/take/put commands |
| `Configuration/interactive-objects.json` | Add locked/container objects |
| `Configuration/schemas/interactive-objects.schema.json` | Add lock/container schema |
| `Infrastructure/DependencyInjection.cs` | Update service registration |

---

## 11. Future Considerations

### 11.1 v0.4.0c Preparation

The following will extend this foundation:
- Breaking locks on destructible objects
- Levers that unlock doors remotely
- Buttons that open containers

### 11.2 v0.4.1 Preparation

The following will build on containers:
- Trapped containers (trigger on open)
- Mimics (hostile containers)

---

*This design specification extends the interactive object system with container inventory management and a complete lock and key system, integrating with the existing skill check infrastructure for lockpicking mechanics.*
