Here is the comprehensive implementation plan for v0.1.1: The Interaction Layer.
v0.1.1: The Interaction Layer
Goal: Implement the "Three-Tier Composition" engine for procedural descriptions and the core verb system (Search, Open, Unlock, Examine). This transforms the static rooms of v0.0.5 into interactive environments rich with sensory detail and hidden secrets.

## Table of Contents
- [1. Implementation Workflow](#1-implementation-workflow)
- [2. Code Implementation](#2-code-implementation)
- [3. Architecture Decision Tree](#3-architecture-decision-tree-v011)
- [4. Logging Requirements](#4-logging-requirements)
- [5. Deliverable Checklist](#5-v011-deliverable-checklist)

1. Implementation Workflow
	1	Data Structure: Define InteractableObject and Descriptor entities in Core.
	2	Descriptor Engine: Implement DescriptorService using the Three-Tier Composition model (Base + Modifier + Detail).
	3	Interaction Logic: Build InteractionService to handle state changes (Closed → Open, Locked → Unlocked).
	4	Examination System: Implement ExaminationService to handle WITS-based perception checks and layered info reveal.
	5	Command Wiring: Integrate Search, Open, Close, and Examine commands into the Parser.
	6	Persistence: Update Room entities to store the state of interactables (e.g., a chest remains open).

2. Code Implementation
A. Core Layer (Entities & Models)
We need robust models to support procedural text generation and object states.
File: RuneAndRust.Core/Models/Descriptors/DescriptorTemplate.cs
namespace RuneAndRust.Core.Models.Descriptors;

public class DescriptorTemplate
{
    public string Id { get; set; }
    // Tier 1: The skeleton (e.g., "A [Size] chamber with [Feature].")
    public string BaseText { get; set; }
    public List<string> CompatibleModifiers { get; set; } // e.g., "Rusted", "Overgrown"
}
File: RuneAndRust.Core/Entities/InteractableObject.cs
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

public class InteractableObject
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; }
    public string Description { get; set; } // Default/Cursory description

    // State
    public bool IsContainer { get; set; }
    public bool IsOpen { get; set; }
    public bool IsLocked { get; set; }
    public int LockDifficulty { get; set; } // DC for unlock

    // Examination Layers (SPEC-ROOMENGINE-EXAMINATION)
    public string DetailedDescription { get; set; } // DC 12
    public string ExpertDescription { get; set; }   // DC 18
    public bool HasHiddenSecrets { get; set; }
}
B. Engine Layer (Services)
The DescriptorService assembles text dynamically based on Biome and Danger Level.
File: RuneAndRust.Engine/Services/DescriptorService.cs
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Interfaces;

namespace RuneAndRust.Engine.Services;

public class DescriptorService : IDescriptorService
{
    private readonly ILogger<DescriptorService> _logger;
    // In real impl, inject repositories for Templates/Fragments

    public string GenerateRoomDescription(Room room, string biome, int dangerLevel)
    {
        // 1. Select Base Template (Tier 1)
        var template = "A {Spatial_Descriptor} {Function} lies before you.";

        // 2. Select Thematic Modifier (Tier 2) based on Biome
        // e.g., Biome "The Roots" -> Modifier "Rusted"
        var modifierAdj = "corroded";

        // 3. Select Details (Tier 3) based on Danger/RNG
        var detail = dangerLevel > 5 ? "The air tastes of ozone." : "Dust motes drift in the stillness.";

        // Composition
        var result = template
            .Replace("{Spatial_Descriptor}", "cramped")
            .Replace("{Function}", "maintenance tunnel");

        return $"{result} The walls are {modifierAdj}. {detail}";
    }
}
File: RuneAndRust.Engine/Services/ExaminationService.cs
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;

namespace RuneAndRust.Engine.Services;

public class ExaminationService
{
    private readonly IDiceService _dice;

    public string Examine(Character character, InteractableObject target)
    {
        // Layer 1: Always visible
        var result = $"[Look] {target.Description}";

        // WITS Check for Layer 2 & 3
        var wits = character.Attributes[Attribute.Wits];
        var roll = _dice.Roll(wits, "Examination Check");
        int netSuccesses = roll.Successes - roll.Botches;

        if (netSuccesses >= 1) // Approx DC 12 equivalent in dice pool logic
        {
            result += $"\n[Detailed] {target.DetailedDescription}";
        }

        if (netSuccesses >= 3) // Approx DC 18
        {
             result += $"\n[Expert] {target.ExpertDescription}";
             // Reveal hidden secrets here
        }

        return result;
    }
}
C. Terminal Layer (Command Wiring)
Update CommandParser to handle the new verbs.
File: RuneAndRust.Terminal/Services/CommandParser.cs (Snippet)
// Inside ParseAndExecute
case "examine":
case "x":
case "look":
    // Logic to find target object in current room
    var targetName = string.Join(" ", parts.Skip(1));
    var targetObj = _gameState.CurrentRoom.Objects.FirstOrDefault(o => o.Name.Equals(targetName, StringComparison.OrdinalIgnoreCase));

    if (targetObj != null)
    {
        var desc = _examinationService.Examine(_gameState.CurrentCharacter, targetObj);
        _inputHandler.DisplayMessage(desc);
    }
    else
    {
        // Fallback to room description
        _inputHandler.DisplayMessage(_gameState.CurrentRoom.Description);
    }
    break;

3. Architecture Decision Tree (v0.1.1)
	•	Q: Should descriptions be generated at runtime or database creation?
	◦	A: Runtime Assembly. Store fragments (templates, modifiers) in the DB, but assemble the final string when the player enters the room. This allows descriptions to change based on world state (e.g., lights out, aftermath of combat).
	•	Q: How do we persist opened chests?
	◦	A: RoomState. The Room entity is static template data. Create a RoomState or RoomInstance table in Persistence that tracks mutable data (IsOpen, IsLooted) linked by RoomId and SaveId.
	•	Q: Where does the WITS check logic live?
	◦	A: Engine. The UI (Terminal) just requests an examination; the Engine calculates the result based on stats and returns the appropriate string.

4. Logging Requirements
Event
Level
Message Template
Description Gen
Verbose
"Generated description for {RoomID} using Template {TemplateID}"
Examination
Info
"{Character} examined {Object}. Net Successes: {Count}. Layers Revealed: {Layers}"
Interaction
Info
"{Character} {Verb}ed {Object}. Success: {Result}"
Secret Found
Debug
"Hidden element '{SecretId}' revealed in {RoomId}"

5. v0.1.1 Deliverable Checklist
	•	Core:
	◦	[ ] InteractableObject entity defined with 3-layer description properties.
	◦	[ ] DescriptorTemplate and DescriptorFragment models created.
	•	Engine:
	◦	[ ] DescriptorService implemented (String interpolation of Base + Modifiers).
	◦	[ ] ExaminationService implemented (WITS check → Layer unlocking).
	◦	[ ] InteractionService implemented (Open/Close logic).
	•	Persistence:
	◦	[ ] RoomState entity created to track object states per save file.
	◦	[ ] Migration applied.
	•	Terminal:
	◦	[ ] look <target> command works.
	◦	[ ] open <target> command works (checks Locked status).
	◦	[ ] search command works (reveals hidden objects based on WITS).
	•	Testing:
	◦	[ ] ExaminationTests: Verify high WITS reveals Expert description.
	◦	[ ] DescriptorTests: Verify template replacement works.
	◦	[ ] InteractionTests: Verify locked objects cannot be opened without key/pick.
This completes v0.1.1. The next step, v0.1.2, will implement the Inventory & Economy to actually hold the items found in these containers.
Ready to implement the Descriptor Service?
