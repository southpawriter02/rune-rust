# v0.4.3b: The Grimoire (Spell Entity & Repository)

> **Status:** Planned
> **Parent:** v0.4.3 - The Weaver (Magic Core System)
> **Theme:** Defining the arcane lexicon—spell definitions, schools of magic, and the data layer for Aetheric knowledge.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Component Specifications](#component-specifications)
5. [Code Implementation](#code-implementation)
6. [Database Configuration](#database-configuration)
7. [Logging Matrix](#logging-matrix)
8. [Unit Testing Specification](#unit-testing-specification)
9. [Integration Points](#integration-points)
10. [Deliverable Checklist](#deliverable-checklist)
11. [Workflow](#workflow)
12. [Changelog](#changelog)

---

## Overview

v0.4.3b introduces the **Spell** entity and its supporting data infrastructure—the foundation for all magical abilities in The Weaver system. This version establishes the data model, enumeration types, repository layer, and database schema required before spell execution can be implemented.

### Design Philosophy

The Spell entity follows the established `ActiveAbility` pattern but extends it for magic-specific concerns:

1. **Flux Integration**: Each spell has a `FluxCost` that feeds into the Aether system (v0.4.3a)
2. **School Classification**: Spells belong to magical schools for thematic grouping and potential synergies
3. **Targeting System**: Explicit target type and range constraints
4. **Effect Scripts**: Reuses the existing `EffectScriptExecutor` format for consistent effect resolution

### Spell vs Ability Comparison

| Aspect | ActiveAbility | Spell |
|--------|---------------|-------|
| **Resource** | Stamina + optional Aether | Aether Points (AP) |
| **Environmental** | None | Flux Cost (accumulates in environment) |
| **Classification** | Archetype-based | School-based |
| **Targeting** | Simple range | TargetType + Range |
| **Risk** | None | Backlash potential (via Flux) |

### Spell Schools

| School | Focus | Typical Effects |
|--------|-------|-----------------|
| **Destruction** | Damage dealing | DAMAGE commands, offensive status effects |
| **Restoration** | Healing and cleansing | HEAL commands, buff removal |
| **Alteration** | Buffs and debuffs | STATUS commands (Fortified, Vulnerable, etc.) |
| **Divination** | Information and perception | STATUS commands (TrueSeeing, Revealed, etc.) |

---

## Architecture

### Entity Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                           Spell                                 │
├─────────────────────────────────────────────────────────────────┤
│ + Id: Guid (PK)                                                │
│ + Name: string (unique index)                                  │
│ + Description: string (Domain 4 compliant)                     │
│ + School: SpellSchool (enum)                                   │
│ + TargetType: SpellTargetType (enum)                           │
│ + Range: SpellRange (enum)                                     │
│ + ApCost: int (Aether Points required)                         │
│ + FluxCost: int (environmental accumulation)                   │
│ + BasePower: int (for scaling calculations)                    │
│ + EffectScript: string (DAMAGE:Type:Dice format)               │
│ + ChargeTurns: int (0 = instant)                               │
│ + TelegraphMessage: string? (for charged spells)               │
│ + RequiresConcentration: bool                                  │
│ + Tier: int (progression gating)                               │
│ + Archetype: ArchetypeType? (null = universal)                 │
│ + CreatedAt: DateTime                                          │
│ + LastModified: DateTime                                       │
└─────────────────────────────────────────────────────────────────┘
         │
         │ stored in
         ▼
┌─────────────────────────────────────────────────────────────────┐
│                    ISpellRepository                             │
├─────────────────────────────────────────────────────────────────┤
│ + GetByIdAsync(Guid): Task<Spell?>                             │
│ + GetAllAsync(): Task<IEnumerable<Spell>>                      │
│ + GetByNameAsync(string): Task<Spell?>                         │
│ + GetBySchoolAsync(SpellSchool): Task<IEnumerable<Spell>>      │
│ + GetByArchetypeAsync(ArchetypeType?, int): Task<IEnumerable>  │
│ + GetByTierAsync(int): Task<IEnumerable<Spell>>                │
│ + AddAsync(Spell): Task                                        │
│ + AddRangeAsync(IEnumerable<Spell>): Task                      │
│ + UpdateAsync(Spell): Task                                     │
│ + DeleteAsync(Guid): Task                                      │
│ + ExistsByNameAsync(string): Task<bool>                        │
│ + SaveChangesAsync(): Task                                     │
└─────────────────────────────────────────────────────────────────┘
         │
         │ extends
         ▼
┌─────────────────────────────────────────────────────────────────┐
│                  GenericRepository<Spell>                       │
│                         (base)                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow: Spell Lookup

```
MagicService.CastSpell("spark", target)     (v0.4.3c - future)
         │
         │ spell name: "spark"
         │
         ▼
ISpellRepository.GetByNameAsync("spark")
         │
         ├─── 1. Normalize name: "spark" → "spark"
         ├─── 2. Query: WHERE Name.ToLower() == "spark"
         ├─── 3. Log: "[SpellRepo] Fetching spell 'spark'"
         │
         └─── 4. Return Spell entity or null
                    │
                    ▼
              ┌─────────────────────┐
              │      Spell          │
              │ Name: "Spark"       │
              │ School: Destruction │
              │ ApCost: 2           │
              │ FluxCost: 8         │
              │ EffectScript:       │
              │   "DAMAGE:Fire:1d6" │
              └─────────────────────┘
```

### Component Dependencies

```
┌─────────────────────────────────────────────────────────────────┐
│                         Core Layer                              │
├─────────────────────────────────────────────────────────────────┤
│  Entities/           Enums/              Interfaces/            │
│  └── Spell.cs        ├── SpellSchool.cs  └── ISpellRepository   │
│                      ├── SpellTargetType │                      │
│                      └── SpellRange.cs   │                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ references
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Persistence Layer                          │
├─────────────────────────────────────────────────────────────────┤
│  Repositories/                    Data/                         │
│  └── SpellRepository.cs           ├── RuneAndRustDbContext.cs  │
│                                   │   (entity configuration)    │
│                                   └── Migrations/               │
│                                       └── Add_Spell_v0_4_3b.cs │
└─────────────────────────────────────────────────────────────────┘
```

---

## Decision Trees

### 1. GetByNameAsync Decision Tree

```
GetByNameAsync(name: string): Task<Spell?>
│
├─── [GUARD] string.IsNullOrWhiteSpace(name)?
│    └─── YES → Log Warning "Empty spell name" → RETURN null
│
├─── 1. NORMALIZE input
│    └─── normalizedName = name.Trim().ToLowerInvariant()
│
├─── 2. LOG query initiation
│    └─── Log Debug "[SpellRepo] Fetching spell '{Name}'"
│
├─── 3. EXECUTE query
│    └─── query = _dbSet.FirstOrDefaultAsync(s => s.Name.ToLower() == normalizedName)
│
├─── 4. CHECK result
│    ├─── spell == null?
│    │    └─── Log Debug "[SpellRepo] Spell '{Name}' not found" → RETURN null
│    └─── spell != null?
│         └─── Log Debug "[SpellRepo] Retrieved spell: {Name} ({Id})"
│
└─── 5. RETURN spell
```

### 2. GetBySchoolAsync Decision Tree

```
GetBySchoolAsync(school: SpellSchool): Task<IEnumerable<Spell>>
│
├─── 1. LOG query initiation
│    └─── Log Debug "[SpellRepo] Fetching spells for school {School}"
│
├─── 2. EXECUTE query
│    └─── spells = await _dbSet
│              .Where(s => s.School == school)
│              .OrderBy(s => s.Tier)
│              .ThenBy(s => s.Name)
│              .ToListAsync()
│
├─── 3. LOG results
│    └─── Log Debug "[SpellRepo] Retrieved {Count} spells for school {School}"
│
└─── 4. RETURN spells
```

### 3. GetByArchetypeAsync Decision Tree

```
GetByArchetypeAsync(archetype: ArchetypeType?, maxTier: int = 1): Task<IEnumerable<Spell>>
│
├─── 1. LOG query initiation
│    └─── Log Debug "[SpellRepo] Fetching spells for archetype {Archetype}, maxTier {MaxTier}"
│
├─── 2. BUILD query
│    ├─── archetype == null?
│    │    └─── Filter: s.Archetype == null (universal spells only)
│    └─── archetype != null?
│         └─── Filter: s.Archetype == null OR s.Archetype == archetype
│              (universal + archetype-specific)
│
├─── 3. APPLY tier filter
│    └─── Filter: s.Tier <= maxTier
│
├─── 4. EXECUTE query
│    └─── spells = await query
│              .OrderBy(s => s.Tier)
│              .ThenBy(s => s.School)
│              .ThenBy(s => s.Name)
│              .ToListAsync()
│
├─── 5. LOG results
│    └─── Log Debug "[SpellRepo] Retrieved {Count} spells for archetype {Archetype}"
│
└─── 6. RETURN spells
```

### 4. AddRangeAsync Decision Tree

```
AddRangeAsync(spells: IEnumerable<Spell>): Task
│
├─── 1. MATERIALIZE enumerable
│    └─── spellList = spells.ToList()
│
├─── 2. LOG operation
│    └─── Log Debug "[SpellRepo] Adding {Count} spells"
│
├─── 3. VALIDATE entries
│    └─── foreach spell in spellList:
│         ├─── Name empty? → Log Warning, skip
│         └─── EffectScript empty? → Log Warning (allow, but warn)
│
├─── 4. ADD to context
│    └─── await _dbSet.AddRangeAsync(spellList)
│
├─── 5. LOG completion
│    └─── Log Debug "[SpellRepo] Added {Count} spells to context"
│
└─── 6. RETURN (caller must call SaveChangesAsync)
```

### 5. ExistsByNameAsync Decision Tree

```
ExistsByNameAsync(name: string): Task<bool>
│
├─── [GUARD] string.IsNullOrWhiteSpace(name)?
│    └─── YES → RETURN false
│
├─── 1. NORMALIZE input
│    └─── normalizedName = name.Trim().ToLowerInvariant()
│
├─── 2. LOG check
│    └─── Log Debug "[SpellRepo] Checking existence of spell '{Name}'"
│
├─── 3. EXECUTE query
│    └─── exists = await _dbSet.AnyAsync(s => s.Name.ToLower() == normalizedName)
│
├─── 4. LOG result
│    └─── Log Debug "[SpellRepo] Spell '{Name}' exists: {Exists}"
│
└─── 5. RETURN exists
```

### 6. Spell Validation Decision Tree

```
ValidateSpell(spell: Spell): ValidationResult
│
├─── 1. CHECK required fields
│    ├─── Name empty? → Add error "Name is required"
│    ├─── Description empty? → Add error "Description is required"
│    └─── EffectScript empty? → Add warning "No effect script defined"
│
├─── 2. CHECK value ranges
│    ├─── ApCost < 0? → Add error "AP cost cannot be negative"
│    ├─── FluxCost < 0? → Add error "Flux cost cannot be negative"
│    ├─── BasePower < 0? → Add error "Base power cannot be negative"
│    ├─── ChargeTurns < 0? → Add error "Charge turns cannot be negative"
│    └─── Tier < 0? → Add error "Tier cannot be negative"
│
├─── 3. CHECK logical constraints
│    ├─── ChargeTurns > 0 AND TelegraphMessage empty?
│    │    └─── Add warning "Charged spell without telegraph message"
│    └─── RequiresConcentration AND ChargeTurns == 0?
│         └─── Add warning "Concentration on instant spell has no effect"
│
├─── 4. VALIDATE effect script syntax (basic)
│    └─── Contains invalid command? → Add error "Invalid effect script"
│
└─── 5. RETURN ValidationResult
```

---

## Component Specifications

### 1. Spell Entity

**File:** `RuneAndRust.Core/Entities/Spell.cs`

| Property | Type | Required | Default | Description |
|----------|------|----------|---------|-------------|
| `Id` | `Guid` | Yes | `Guid.NewGuid()` | Unique identifier |
| `Name` | `string` | Yes | `""` | Display name (unique index) |
| `Description` | `string` | Yes | `""` | Domain 4 compliant flavor text |
| `School` | `SpellSchool` | Yes | `Destruction` | Magic classification |
| `TargetType` | `SpellTargetType` | Yes | `SingleEnemy` | Valid target categories |
| `Range` | `SpellRange` | Yes | `Close` | Distance constraint |
| `ApCost` | `int` | Yes | `0` | Aether Points consumed |
| `FluxCost` | `int` | Yes | `0` | Environmental Flux added |
| `BasePower` | `int` | Yes | `0` | Scaling multiplier |
| `EffectScript` | `string` | Yes | `""` | Effect commands |
| `ChargeTurns` | `int` | Yes | `0` | Turns to cast (0 = instant) |
| `TelegraphMessage` | `string?` | No | `null` | Message shown during charge |
| `RequiresConcentration` | `bool` | Yes | `false` | Can be interrupted |
| `Tier` | `int` | Yes | `1` | Progression requirement |
| `Archetype` | `ArchetypeType?` | No | `null` | Null = universal spell |
| `CreatedAt` | `DateTime` | Yes | `DateTime.UtcNow` | Creation timestamp |
| `LastModified` | `DateTime` | Yes | `DateTime.UtcNow` | Last update timestamp |

### 2. SpellSchool Enum

**File:** `RuneAndRust.Core/Enums/SpellSchool.cs`

| Value | Int | Description | Typical Effects |
|-------|-----|-------------|-----------------|
| `Destruction` | 0 | Offensive magic | DAMAGE commands |
| `Restoration` | 1 | Healing magic | HEAL commands |
| `Alteration` | 2 | Transformation magic | STATUS (buffs/debuffs) |
| `Divination` | 3 | Information magic | STATUS (perception) |

### 3. SpellTargetType Enum

**File:** `RuneAndRust.Core/Enums/SpellTargetType.cs`

| Value | Int | Description |
|-------|-----|-------------|
| `Self` | 0 | Caster only |
| `SingleEnemy` | 1 | One hostile target |
| `SingleAlly` | 2 | One friendly target |
| `AllEnemies` | 3 | All hostile targets |
| `AllAllies` | 4 | All friendly targets (including self) |
| `SingleAny` | 5 | Any single combatant |
| `Area` | 6 | All combatants in area |

### 4. SpellRange Enum

**File:** `RuneAndRust.Core/Enums/SpellRange.cs`

| Value | Int | Description | Mechanical Range |
|-------|-----|-------------|------------------|
| `Self` | 0 | Caster only | 0 |
| `Touch` | 1 | Adjacent targets | 1 |
| `Close` | 2 | Nearby targets | 2-3 |
| `Medium` | 3 | Moderate distance | 4-6 |
| `Far` | 4 | Distant targets | 7+ |

### 5. ISpellRepository Interface

**File:** `RuneAndRust.Core/Interfaces/ISpellRepository.cs`

| Method | Returns | Description |
|--------|---------|-------------|
| `GetByIdAsync(Guid)` | `Task<Spell?>` | Fetch by primary key |
| `GetAllAsync()` | `Task<IEnumerable<Spell>>` | Fetch all spells |
| `GetByNameAsync(string)` | `Task<Spell?>` | Case-insensitive name lookup |
| `GetBySchoolAsync(SpellSchool)` | `Task<IEnumerable<Spell>>` | Filter by school |
| `GetByArchetypeAsync(ArchetypeType?, int)` | `Task<IEnumerable<Spell>>` | Filter by archetype + tier |
| `GetByTierAsync(int)` | `Task<IEnumerable<Spell>>` | Filter by exact tier |
| `GetAvailableForCasterAsync(ArchetypeType, int)` | `Task<IEnumerable<Spell>>` | Universal + archetype spells up to tier |
| `AddAsync(Spell)` | `Task` | Add single spell |
| `AddRangeAsync(IEnumerable<Spell>)` | `Task` | Batch add spells |
| `UpdateAsync(Spell)` | `Task` | Update existing spell |
| `DeleteAsync(Guid)` | `Task` | Remove spell |
| `ExistsByNameAsync(string)` | `Task<bool>` | Check for duplicates |
| `SaveChangesAsync()` | `Task` | Persist changes |

---

## Code Implementation

### 1. Spell.cs

```csharp
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

/// <summary>
/// Represents a magical spell that can be cast by characters with Aether Points.
/// Spells consume AP, add Flux to the environment, and execute effects via scripts.
/// </summary>
/// <remarks>
/// See: v0.4.3b (The Grimoire) for Spell entity implementation.
/// Domain 4 Compliant: Descriptions must use archaeologist perspective.
/// </remarks>
public class Spell
{
    #region Identity

    /// <summary>
    /// Unique identifier for this spell.
    /// </summary>
    public Guid Id { get; set; } = Guid.NewGuid();

    /// <summary>
    /// Display name of the spell. Must be unique.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Flavor text describing the spell. Must be Domain 4 compliant.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    #endregion

    #region Classification

    /// <summary>
    /// The school of magic this spell belongs to.
    /// </summary>
    public SpellSchool School { get; set; } = SpellSchool.Destruction;

    /// <summary>
    /// What types of targets this spell can affect.
    /// </summary>
    public SpellTargetType TargetType { get; set; } = SpellTargetType.SingleEnemy;

    /// <summary>
    /// The range category for this spell.
    /// </summary>
    public SpellRange Range { get; set; } = SpellRange.Close;

    /// <summary>
    /// The archetype that can learn this spell. Null means universal (all archetypes).
    /// </summary>
    public ArchetypeType? Archetype { get; set; }

    /// <summary>
    /// Progression tier required to learn this spell.
    /// </summary>
    public int Tier { get; set; } = 1;

    #endregion

    #region Costs

    /// <summary>
    /// Aether Points consumed when casting this spell.
    /// </summary>
    public int ApCost { get; set; }

    /// <summary>
    /// Flux added to the environment when casting this spell.
    /// Higher values increase Backlash risk in high-Flux situations.
    /// </summary>
    public int FluxCost { get; set; }

    #endregion

    #region Effects

    /// <summary>
    /// Base power value for scaling calculations.
    /// </summary>
    public int BasePower { get; set; }

    /// <summary>
    /// Effect script in standard format: "COMMAND:Param1:Param2;COMMAND:..."
    /// Examples: "DAMAGE:Fire:2d6", "HEAL:2d6;STATUS:Inspired:2"
    /// </summary>
    public string EffectScript { get; set; } = string.Empty;

    #endregion

    #region Casting Mechanics

    /// <summary>
    /// Number of turns required to cast. 0 = instant cast.
    /// </summary>
    public int ChargeTurns { get; set; }

    /// <summary>
    /// Message displayed when the spell begins charging.
    /// Required for charged spells (ChargeTurns > 0).
    /// </summary>
    public string? TelegraphMessage { get; set; }

    /// <summary>
    /// If true, taking damage may interrupt this spell.
    /// </summary>
    public bool RequiresConcentration { get; set; }

    #endregion

    #region Metadata

    /// <summary>
    /// When this spell definition was created.
    /// </summary>
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// When this spell definition was last modified.
    /// </summary>
    public DateTime LastModified { get; set; } = DateTime.UtcNow;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Returns true if this spell requires charging before release.
    /// </summary>
    public bool IsChargedSpell => ChargeTurns > 0;

    /// <summary>
    /// Returns true if this spell is available to all archetypes.
    /// </summary>
    public bool IsUniversal => Archetype == null;

    /// <summary>
    /// Returns true if this spell targets the caster.
    /// </summary>
    public bool IsSelfTargeted => TargetType == SpellTargetType.Self || Range == SpellRange.Self;

    #endregion
}
```

### 2. SpellSchool.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Categorizes spells by their magical discipline.
/// Each school has thematic focus and typical effect patterns.
/// </summary>
/// <remarks>
/// See: v0.4.3b (The Grimoire) for Spell system implementation.
/// </remarks>
public enum SpellSchool
{
    /// <summary>
    /// Offensive magic focused on dealing damage.
    /// "The Old Ones called fire from nothing. We remember the words."
    /// </summary>
    Destruction = 0,

    /// <summary>
    /// Healing magic focused on mending wounds and curing ailments.
    /// "Life was their gift to give. Some of us still speak their prayers."
    /// </summary>
    Restoration = 1,

    /// <summary>
    /// Transformative magic that enhances or weakens.
    /// "Reality bends for those who know the old shapes."
    /// </summary>
    Alteration = 2,

    /// <summary>
    /// Perceptive magic that reveals hidden truths.
    /// "The veil is thin for those who learn to see."
    /// </summary>
    Divination = 3
}
```

### 3. SpellTargetType.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Defines what types of targets a spell can affect.
/// Used for validation and UI targeting assistance.
/// </summary>
/// <remarks>
/// See: v0.4.3b (The Grimoire) for Spell system implementation.
/// </remarks>
public enum SpellTargetType
{
    /// <summary>
    /// The spell can only target the caster.
    /// </summary>
    Self = 0,

    /// <summary>
    /// The spell targets a single hostile combatant.
    /// </summary>
    SingleEnemy = 1,

    /// <summary>
    /// The spell targets a single friendly combatant (not self).
    /// </summary>
    SingleAlly = 2,

    /// <summary>
    /// The spell affects all hostile combatants.
    /// </summary>
    AllEnemies = 3,

    /// <summary>
    /// The spell affects all friendly combatants including the caster.
    /// </summary>
    AllAllies = 4,

    /// <summary>
    /// The spell can target any single combatant regardless of allegiance.
    /// </summary>
    SingleAny = 5,

    /// <summary>
    /// The spell affects all combatants in an area.
    /// </summary>
    Area = 6
}
```

### 4. SpellRange.cs

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Defines the range categories for spell targeting.
/// Determines how far a spell can reach in combat.
/// </summary>
/// <remarks>
/// See: v0.4.3b (The Grimoire) for Spell system implementation.
/// Domain 4 Compliant: Uses qualitative descriptors, not precise measurements.
/// </remarks>
public enum SpellRange
{
    /// <summary>
    /// The spell can only affect the caster.
    /// "The power flows inward, not outward."
    /// </summary>
    Self = 0,

    /// <summary>
    /// The spell requires physical contact with the target.
    /// "Close enough to feel their breath."
    /// </summary>
    Touch = 1,

    /// <summary>
    /// The spell can reach nearby targets within a few paces.
    /// "Within arm's reach, more or less."
    /// </summary>
    Close = 2,

    /// <summary>
    /// The spell can reach targets at moderate distance.
    /// "Across the hall, but not beyond."
    /// </summary>
    Medium = 3,

    /// <summary>
    /// The spell can reach distant targets.
    /// "As far as a thrown stone, perhaps further."
    /// </summary>
    Far = 4
}
```

### 5. ISpellRepository.cs

```csharp
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Repository interface for Spell entity persistence and retrieval.
/// Extends the base IRepository pattern with spell-specific query methods.
/// </summary>
/// <remarks>
/// See: v0.4.3b (The Grimoire) for Spell system implementation.
/// </remarks>
public interface ISpellRepository : IRepository<Spell>
{
    /// <summary>
    /// Gets a spell by name using case-insensitive matching.
    /// </summary>
    /// <param name="name">The spell name to search for.</param>
    /// <returns>The spell if found, null otherwise.</returns>
    Task<Spell?> GetByNameAsync(string name);

    /// <summary>
    /// Gets all spells belonging to a specific school.
    /// </summary>
    /// <param name="school">The school to filter by.</param>
    /// <returns>Spells in the specified school, ordered by tier then name.</returns>
    Task<IEnumerable<Spell>> GetBySchoolAsync(SpellSchool school);

    /// <summary>
    /// Gets all spells available to an archetype up to a maximum tier.
    /// Includes universal spells (Archetype == null) and archetype-specific spells.
    /// </summary>
    /// <param name="archetype">The archetype to filter for, or null for universal only.</param>
    /// <param name="maxTier">Maximum tier to include (default 1).</param>
    /// <returns>Available spells ordered by tier, school, then name.</returns>
    Task<IEnumerable<Spell>> GetByArchetypeAsync(ArchetypeType? archetype, int maxTier = 1);

    /// <summary>
    /// Gets all spells at a specific tier.
    /// </summary>
    /// <param name="tier">The exact tier to filter by.</param>
    /// <returns>Spells at the specified tier.</returns>
    Task<IEnumerable<Spell>> GetByTierAsync(int tier);

    /// <summary>
    /// Gets all spells a caster can use based on their archetype and level.
    /// Combines universal spells with archetype-specific spells up to the tier limit.
    /// </summary>
    /// <param name="archetype">The caster's archetype.</param>
    /// <param name="maxTier">Maximum tier based on caster's level.</param>
    /// <returns>All available spells for the caster.</returns>
    Task<IEnumerable<Spell>> GetAvailableForCasterAsync(ArchetypeType archetype, int maxTier);

    /// <summary>
    /// Adds multiple spells in a single operation.
    /// Used for batch seeding of spell data.
    /// </summary>
    /// <param name="spells">The spells to add.</param>
    Task AddRangeAsync(IEnumerable<Spell> spells);

    /// <summary>
    /// Checks if a spell with the given name already exists.
    /// Used for idempotent seeding operations.
    /// </summary>
    /// <param name="name">The spell name to check.</param>
    /// <returns>True if a spell with this name exists.</returns>
    Task<bool> ExistsByNameAsync(string name);
}
```

### 6. SpellRepository.cs

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Persistence.Data;

namespace RuneAndRust.Persistence.Repositories;

/// <summary>
/// Repository implementation for Spell entity persistence.
/// Provides spell-specific query methods beyond basic CRUD.
/// </summary>
/// <remarks>
/// See: v0.4.3b (The Grimoire) for Spell system implementation.
/// </remarks>
public class SpellRepository : GenericRepository<Spell>, ISpellRepository
{
    private readonly ILogger<SpellRepository> _spellLogger;

    /// <summary>
    /// Initializes a new instance of the <see cref="SpellRepository"/> class.
    /// </summary>
    public SpellRepository(
        RuneAndRustDbContext context,
        ILogger<GenericRepository<Spell>> genericLogger,
        ILogger<SpellRepository> spellLogger)
        : base(context, genericLogger)
    {
        _spellLogger = spellLogger;
    }

    /// <inheritdoc/>
    public async Task<Spell?> GetByNameAsync(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            _spellLogger.LogWarning("[SpellRepo] GetByNameAsync called with empty name");
            return null;
        }

        var normalizedName = name.Trim().ToLowerInvariant();
        _spellLogger.LogDebug("[SpellRepo] Fetching spell '{Name}'", name);

        var spell = await _dbSet
            .FirstOrDefaultAsync(s => s.Name.ToLower() == normalizedName);

        if (spell == null)
        {
            _spellLogger.LogDebug("[SpellRepo] Spell '{Name}' not found", name);
        }
        else
        {
            _spellLogger.LogDebug("[SpellRepo] Retrieved spell: {Name} ({Id})", spell.Name, spell.Id);
        }

        return spell;
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<Spell>> GetBySchoolAsync(SpellSchool school)
    {
        _spellLogger.LogDebug("[SpellRepo] Fetching spells for school {School}", school);

        var spells = await _dbSet
            .Where(s => s.School == school)
            .OrderBy(s => s.Tier)
            .ThenBy(s => s.Name)
            .ToListAsync();

        _spellLogger.LogDebug("[SpellRepo] Retrieved {Count} spells for school {School}",
            spells.Count, school);

        return spells;
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<Spell>> GetByArchetypeAsync(ArchetypeType? archetype, int maxTier = 1)
    {
        _spellLogger.LogDebug(
            "[SpellRepo] Fetching spells for archetype {Archetype}, maxTier {MaxTier}",
            archetype?.ToString() ?? "Universal", maxTier);

        IQueryable<Spell> query;

        if (archetype == null)
        {
            // Universal spells only
            query = _dbSet.Where(s => s.Archetype == null && s.Tier <= maxTier);
        }
        else
        {
            // Universal + archetype-specific
            query = _dbSet.Where(s =>
                (s.Archetype == null || s.Archetype == archetype) &&
                s.Tier <= maxTier);
        }

        var spells = await query
            .OrderBy(s => s.Tier)
            .ThenBy(s => s.School)
            .ThenBy(s => s.Name)
            .ToListAsync();

        _spellLogger.LogDebug(
            "[SpellRepo] Retrieved {Count} spells for archetype {Archetype}",
            spells.Count, archetype?.ToString() ?? "Universal");

        return spells;
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<Spell>> GetByTierAsync(int tier)
    {
        _spellLogger.LogDebug("[SpellRepo] Fetching spells at tier {Tier}", tier);

        var spells = await _dbSet
            .Where(s => s.Tier == tier)
            .OrderBy(s => s.School)
            .ThenBy(s => s.Name)
            .ToListAsync();

        _spellLogger.LogDebug("[SpellRepo] Retrieved {Count} spells at tier {Tier}",
            spells.Count, tier);

        return spells;
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<Spell>> GetAvailableForCasterAsync(ArchetypeType archetype, int maxTier)
    {
        _spellLogger.LogDebug(
            "[SpellRepo] Fetching available spells for {Archetype} caster, maxTier {MaxTier}",
            archetype, maxTier);

        var spells = await _dbSet
            .Where(s =>
                (s.Archetype == null || s.Archetype == archetype) &&
                s.Tier <= maxTier)
            .OrderBy(s => s.School)
            .ThenBy(s => s.Tier)
            .ThenBy(s => s.Name)
            .ToListAsync();

        _spellLogger.LogDebug(
            "[SpellRepo] Retrieved {Count} available spells for {Archetype} caster",
            spells.Count, archetype);

        return spells;
    }

    /// <inheritdoc/>
    public async Task AddRangeAsync(IEnumerable<Spell> spells)
    {
        var spellList = spells.ToList();
        _spellLogger.LogDebug("[SpellRepo] Adding {Count} spells", spellList.Count);

        // Basic validation logging
        foreach (var spell in spellList)
        {
            if (string.IsNullOrWhiteSpace(spell.Name))
            {
                _spellLogger.LogWarning("[SpellRepo] Spell with empty name in batch");
            }
            if (string.IsNullOrWhiteSpace(spell.EffectScript))
            {
                _spellLogger.LogWarning("[SpellRepo] Spell '{Name}' has no effect script", spell.Name);
            }
        }

        await _dbSet.AddRangeAsync(spellList);

        _spellLogger.LogDebug("[SpellRepo] Added {Count} spells to context", spellList.Count);
    }

    /// <inheritdoc/>
    public async Task<bool> ExistsByNameAsync(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return false;
        }

        var normalizedName = name.Trim().ToLowerInvariant();
        _spellLogger.LogDebug("[SpellRepo] Checking existence of spell '{Name}'", name);

        var exists = await _dbSet
            .AnyAsync(s => s.Name.ToLower() == normalizedName);

        _spellLogger.LogDebug("[SpellRepo] Spell '{Name}' exists: {Exists}", name, exists);

        return exists;
    }
}
```

### 7. DI Registration (Program.cs Addition)

```csharp
// In ConfigureServices method, add after other repository registrations:

// v0.4.3b: Spell Repository
services.AddScoped<ISpellRepository, SpellRepository>();
```

---

## Database Configuration

### 1. Entity Configuration (RuneAndRustDbContext.cs)

Add to `OnModelCreating` method:

```csharp
// v0.4.3b: Spell Entity Configuration
modelBuilder.Entity<Spell>(entity =>
{
    entity.ToTable("Spells");

    entity.HasKey(s => s.Id);

    // Unique index on Name for fast lookups
    entity.HasIndex(s => s.Name)
        .IsUnique();

    // Composite index for archetype + tier queries
    entity.HasIndex(s => new { s.Archetype, s.Tier });

    // Index for school-based queries
    entity.HasIndex(s => s.School);

    // Required string properties
    entity.Property(s => s.Name)
        .HasMaxLength(100)
        .IsRequired();

    entity.Property(s => s.Description)
        .HasMaxLength(1000)
        .IsRequired();

    entity.Property(s => s.EffectScript)
        .HasMaxLength(500)
        .IsRequired();

    entity.Property(s => s.TelegraphMessage)
        .HasMaxLength(200)
        .IsRequired(false);

    // Required numeric properties
    entity.Property(s => s.ApCost).IsRequired();
    entity.Property(s => s.FluxCost).IsRequired();
    entity.Property(s => s.BasePower).IsRequired();
    entity.Property(s => s.ChargeTurns).IsRequired();
    entity.Property(s => s.Tier).IsRequired();
    entity.Property(s => s.RequiresConcentration).IsRequired();

    // Enum conversions (stored as integers)
    entity.Property(s => s.School)
        .HasConversion<int>()
        .IsRequired();

    entity.Property(s => s.TargetType)
        .HasConversion<int>()
        .IsRequired();

    entity.Property(s => s.Range)
        .HasConversion<int>()
        .IsRequired();

    // Nullable archetype
    entity.Property(s => s.Archetype)
        .HasConversion<int?>()
        .IsRequired(false);

    // Timestamps
    entity.Property(s => s.CreatedAt).IsRequired();
    entity.Property(s => s.LastModified).IsRequired();
});
```

Add DbSet property:

```csharp
public DbSet<Spell> Spells { get; set; } = null!;
```

### 2. Migration File

**File:** `RuneAndRust.Persistence/Migrations/[Timestamp]_Add_Spell_Entity_v0_4_3b.cs`

```csharp
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace RuneAndRust.Persistence.Migrations
{
    /// <inheritdoc />
    public partial class Add_Spell_Entity_v0_4_3b : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Spells",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Name = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    Description = table.Column<string>(type: "character varying(1000)", maxLength: 1000, nullable: false),
                    School = table.Column<int>(type: "integer", nullable: false),
                    TargetType = table.Column<int>(type: "integer", nullable: false),
                    Range = table.Column<int>(type: "integer", nullable: false),
                    Archetype = table.Column<int>(type: "integer", nullable: true),
                    Tier = table.Column<int>(type: "integer", nullable: false),
                    ApCost = table.Column<int>(type: "integer", nullable: false),
                    FluxCost = table.Column<int>(type: "integer", nullable: false),
                    BasePower = table.Column<int>(type: "integer", nullable: false),
                    EffectScript = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: false),
                    ChargeTurns = table.Column<int>(type: "integer", nullable: false),
                    TelegraphMessage = table.Column<string>(type: "character varying(200)", maxLength: 200, nullable: true),
                    RequiresConcentration = table.Column<bool>(type: "boolean", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    LastModified = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Spells", x => x.Id);
                });

            migrationBuilder.CreateIndex(
                name: "IX_Spells_Name",
                table: "Spells",
                column: "Name",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Spells_Archetype_Tier",
                table: "Spells",
                columns: new[] { "Archetype", "Tier" });

            migrationBuilder.CreateIndex(
                name: "IX_Spells_School",
                table: "Spells",
                column: "School");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(name: "Spells");
        }
    }
}
```

---

## Logging Matrix

### SpellRepository Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| GetByNameAsync | EmptyName | Warning | `"[SpellRepo] GetByNameAsync called with empty name"` | - |
| GetByNameAsync | Query | Debug | `"[SpellRepo] Fetching spell '{Name}'"` | Name |
| GetByNameAsync | NotFound | Debug | `"[SpellRepo] Spell '{Name}' not found"` | Name |
| GetByNameAsync | Found | Debug | `"[SpellRepo] Retrieved spell: {Name} ({Id})"` | Name, Id |
| GetBySchoolAsync | Query | Debug | `"[SpellRepo] Fetching spells for school {School}"` | School |
| GetBySchoolAsync | Results | Debug | `"[SpellRepo] Retrieved {Count} spells for school {School}"` | Count, School |
| GetByArchetypeAsync | Query | Debug | `"[SpellRepo] Fetching spells for archetype {Archetype}, maxTier {MaxTier}"` | Archetype, MaxTier |
| GetByArchetypeAsync | Results | Debug | `"[SpellRepo] Retrieved {Count} spells for archetype {Archetype}"` | Count, Archetype |
| GetByTierAsync | Query | Debug | `"[SpellRepo] Fetching spells at tier {Tier}"` | Tier |
| GetByTierAsync | Results | Debug | `"[SpellRepo] Retrieved {Count} spells at tier {Tier}"` | Count, Tier |
| GetAvailableForCasterAsync | Query | Debug | `"[SpellRepo] Fetching available spells for {Archetype} caster, maxTier {MaxTier}"` | Archetype, MaxTier |
| GetAvailableForCasterAsync | Results | Debug | `"[SpellRepo] Retrieved {Count} available spells for {Archetype} caster"` | Count, Archetype |
| AddRangeAsync | Start | Debug | `"[SpellRepo] Adding {Count} spells"` | Count |
| AddRangeAsync | EmptyName | Warning | `"[SpellRepo] Spell with empty name in batch"` | - |
| AddRangeAsync | NoEffect | Warning | `"[SpellRepo] Spell '{Name}' has no effect script"` | Name |
| AddRangeAsync | Complete | Debug | `"[SpellRepo] Added {Count} spells to context"` | Count |
| ExistsByNameAsync | Query | Debug | `"[SpellRepo] Checking existence of spell '{Name}'"` | Name |
| ExistsByNameAsync | Result | Debug | `"[SpellRepo] Spell '{Name}' exists: {Exists}"` | Name, Exists |

---

## Unit Testing Specification

### Test Class: SpellRepositoryTests.cs

**File:** `RuneAndRust.Tests/Persistence/Repositories/SpellRepositoryTests.cs`

#### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| GetByNameAsync | 5 | Name lookup variations |
| GetBySchoolAsync | 4 | School filtering |
| GetByArchetypeAsync | 6 | Archetype + tier filtering |
| GetByTierAsync | 3 | Tier filtering |
| GetAvailableForCasterAsync | 4 | Combined archetype queries |
| AddRangeAsync | 4 | Batch operations |
| ExistsByNameAsync | 3 | Existence checks |
| CRUD Operations | 6 | Basic CRUD from GenericRepository |

**Total: 35 tests**

#### Test Specifications

```csharp
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using NSubstitute;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Persistence.Data;
using RuneAndRust.Persistence.Repositories;
using Xunit;

namespace RuneAndRust.Tests.Persistence.Repositories;

/// <summary>
/// Unit tests for SpellRepository (v0.4.3b - The Grimoire).
/// Uses in-memory SQLite database for testing.
/// </summary>
public class SpellRepositoryTests : IDisposable
{
    private readonly RuneAndRustDbContext _context;
    private readonly SpellRepository _sut;
    private readonly ILogger<GenericRepository<Spell>> _mockGenericLogger;
    private readonly ILogger<SpellRepository> _mockSpellLogger;

    public SpellRepositoryTests()
    {
        var options = new DbContextOptionsBuilder<RuneAndRustDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        _context = new RuneAndRustDbContext(options);
        _mockGenericLogger = Substitute.For<ILogger<GenericRepository<Spell>>>();
        _mockSpellLogger = Substitute.For<ILogger<SpellRepository>>();

        _sut = new SpellRepository(_context, _mockGenericLogger, _mockSpellLogger);
    }

    public void Dispose()
    {
        _context.Dispose();
    }

    #region GetByNameAsync Tests

    [Fact]
    public async Task GetByNameAsync_ReturnsSpell_WhenExactNameMatch()
    {
        // Arrange
        var spell = CreateTestSpell("Spark", SpellSchool.Destruction);
        await _context.Spells.AddAsync(spell);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByNameAsync("Spark");

        // Assert
        result.Should().NotBeNull();
        result!.Name.Should().Be("Spark");
    }

    [Fact]
    public async Task GetByNameAsync_ReturnsSpell_WhenCaseInsensitiveMatch()
    {
        // Arrange
        var spell = CreateTestSpell("Spark", SpellSchool.Destruction);
        await _context.Spells.AddAsync(spell);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByNameAsync("SPARK");

        // Assert
        result.Should().NotBeNull();
        result!.Name.Should().Be("Spark");
    }

    [Fact]
    public async Task GetByNameAsync_ReturnsNull_WhenNotFound()
    {
        // Act
        var result = await _sut.GetByNameAsync("NonExistent");

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task GetByNameAsync_ReturnsNull_WhenNameIsEmpty()
    {
        // Act
        var result = await _sut.GetByNameAsync("");

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task GetByNameAsync_TrimsWhitespace()
    {
        // Arrange
        var spell = CreateTestSpell("Spark", SpellSchool.Destruction);
        await _context.Spells.AddAsync(spell);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByNameAsync("  Spark  ");

        // Assert
        result.Should().NotBeNull();
    }

    #endregion

    #region GetBySchoolAsync Tests

    [Fact]
    public async Task GetBySchoolAsync_ReturnsSpellsInSchool()
    {
        // Arrange
        await SeedTestSpells();

        // Act
        var result = await _sut.GetBySchoolAsync(SpellSchool.Destruction);

        // Assert
        result.Should().HaveCount(2);
        result.Should().OnlyContain(s => s.School == SpellSchool.Destruction);
    }

    [Fact]
    public async Task GetBySchoolAsync_ReturnsEmpty_WhenNoSpellsInSchool()
    {
        // Arrange
        var spell = CreateTestSpell("Spark", SpellSchool.Destruction);
        await _context.Spells.AddAsync(spell);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetBySchoolAsync(SpellSchool.Divination);

        // Assert
        result.Should().BeEmpty();
    }

    [Fact]
    public async Task GetBySchoolAsync_OrdersByTierThenName()
    {
        // Arrange
        var spells = new[]
        {
            CreateTestSpell("Zephyr", SpellSchool.Destruction, tier: 2),
            CreateTestSpell("Alpha", SpellSchool.Destruction, tier: 1),
            CreateTestSpell("Beta", SpellSchool.Destruction, tier: 1)
        };
        await _context.Spells.AddRangeAsync(spells);
        await _context.SaveChangesAsync();

        // Act
        var result = (await _sut.GetBySchoolAsync(SpellSchool.Destruction)).ToList();

        // Assert
        result[0].Name.Should().Be("Alpha");
        result[1].Name.Should().Be("Beta");
        result[2].Name.Should().Be("Zephyr");
    }

    [Fact]
    public async Task GetBySchoolAsync_ReturnsAllSchoolMembers()
    {
        // Arrange
        await SeedTestSpells();

        // Act
        var restoration = await _sut.GetBySchoolAsync(SpellSchool.Restoration);

        // Assert
        restoration.Should().HaveCount(1);
    }

    #endregion

    #region GetByArchetypeAsync Tests

    [Fact]
    public async Task GetByArchetypeAsync_ReturnsUniversalAndArchetypeSpells()
    {
        // Arrange
        var universal = CreateTestSpell("Universal", SpellSchool.Destruction, archetype: null);
        var mystic = CreateTestSpell("Mystic Only", SpellSchool.Destruction, archetype: ArchetypeType.Mystic);
        var warrior = CreateTestSpell("Warrior Only", SpellSchool.Destruction, archetype: ArchetypeType.Warrior);

        await _context.Spells.AddRangeAsync(universal, mystic, warrior);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByArchetypeAsync(ArchetypeType.Mystic);

        // Assert
        result.Should().HaveCount(2);
        result.Should().Contain(s => s.Name == "Universal");
        result.Should().Contain(s => s.Name == "Mystic Only");
        result.Should().NotContain(s => s.Name == "Warrior Only");
    }

    [Fact]
    public async Task GetByArchetypeAsync_RespectsMaxTier()
    {
        // Arrange
        var tier1 = CreateTestSpell("Tier 1", SpellSchool.Destruction, tier: 1);
        var tier2 = CreateTestSpell("Tier 2", SpellSchool.Destruction, tier: 2);
        var tier3 = CreateTestSpell("Tier 3", SpellSchool.Destruction, tier: 3);

        await _context.Spells.AddRangeAsync(tier1, tier2, tier3);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByArchetypeAsync(null, maxTier: 2);

        // Assert
        result.Should().HaveCount(2);
        result.Should().NotContain(s => s.Tier > 2);
    }

    [Fact]
    public async Task GetByArchetypeAsync_NullArchetype_ReturnsOnlyUniversal()
    {
        // Arrange
        var universal = CreateTestSpell("Universal", SpellSchool.Destruction, archetype: null);
        var specific = CreateTestSpell("Specific", SpellSchool.Destruction, archetype: ArchetypeType.Mystic);

        await _context.Spells.AddRangeAsync(universal, specific);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByArchetypeAsync(null);

        // Assert
        result.Should().HaveCount(1);
        result.First().Name.Should().Be("Universal");
    }

    [Fact]
    public async Task GetByArchetypeAsync_OrdersByTierSchoolName()
    {
        // Arrange
        var spells = new[]
        {
            CreateTestSpell("Zeta", SpellSchool.Restoration, tier: 1),
            CreateTestSpell("Alpha", SpellSchool.Destruction, tier: 1),
            CreateTestSpell("Beta", SpellSchool.Destruction, tier: 2)
        };
        await _context.Spells.AddRangeAsync(spells);
        await _context.SaveChangesAsync();

        // Act
        var result = (await _sut.GetByArchetypeAsync(null, maxTier: 2)).ToList();

        // Assert
        result[0].Tier.Should().Be(1);
        result[0].School.Should().Be(SpellSchool.Destruction);
    }

    [Fact]
    public async Task GetByArchetypeAsync_DefaultMaxTierIsOne()
    {
        // Arrange
        var tier1 = CreateTestSpell("Tier 1", SpellSchool.Destruction, tier: 1);
        var tier2 = CreateTestSpell("Tier 2", SpellSchool.Destruction, tier: 2);

        await _context.Spells.AddRangeAsync(tier1, tier2);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByArchetypeAsync(null);

        // Assert
        result.Should().HaveCount(1);
        result.First().Tier.Should().Be(1);
    }

    [Fact]
    public async Task GetByArchetypeAsync_ReturnsEmpty_WhenNoMatches()
    {
        // Arrange
        var warrior = CreateTestSpell("Warrior", SpellSchool.Destruction, archetype: ArchetypeType.Warrior);
        await _context.Spells.AddAsync(warrior);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByArchetypeAsync(ArchetypeType.Mystic);

        // Assert
        result.Should().BeEmpty();
    }

    #endregion

    #region GetByTierAsync Tests

    [Fact]
    public async Task GetByTierAsync_ReturnsExactTierMatch()
    {
        // Arrange
        await SeedTestSpells();

        // Act
        var result = await _sut.GetByTierAsync(1);

        // Assert
        result.Should().OnlyContain(s => s.Tier == 1);
    }

    [Fact]
    public async Task GetByTierAsync_ReturnsEmpty_WhenNoMatches()
    {
        // Arrange
        var tier1 = CreateTestSpell("Tier 1", SpellSchool.Destruction, tier: 1);
        await _context.Spells.AddAsync(tier1);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetByTierAsync(5);

        // Assert
        result.Should().BeEmpty();
    }

    [Fact]
    public async Task GetByTierAsync_OrdersBySchoolThenName()
    {
        // Arrange
        var spells = new[]
        {
            CreateTestSpell("Zeta", SpellSchool.Restoration, tier: 1),
            CreateTestSpell("Alpha", SpellSchool.Destruction, tier: 1)
        };
        await _context.Spells.AddRangeAsync(spells);
        await _context.SaveChangesAsync();

        // Act
        var result = (await _sut.GetByTierAsync(1)).ToList();

        // Assert
        result[0].School.Should().Be(SpellSchool.Destruction);
    }

    #endregion

    #region GetAvailableForCasterAsync Tests

    [Fact]
    public async Task GetAvailableForCasterAsync_CombinesUniversalAndArchetype()
    {
        // Arrange
        var universal = CreateTestSpell("Universal", SpellSchool.Destruction);
        var mystic = CreateTestSpell("Mystic", SpellSchool.Destruction, archetype: ArchetypeType.Mystic);
        var warrior = CreateTestSpell("Warrior", SpellSchool.Destruction, archetype: ArchetypeType.Warrior);

        await _context.Spells.AddRangeAsync(universal, mystic, warrior);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetAvailableForCasterAsync(ArchetypeType.Mystic, maxTier: 1);

        // Assert
        result.Should().HaveCount(2);
    }

    [Fact]
    public async Task GetAvailableForCasterAsync_RespectsMaxTier()
    {
        // Arrange
        var tier1 = CreateTestSpell("T1", SpellSchool.Destruction, tier: 1, archetype: ArchetypeType.Mystic);
        var tier3 = CreateTestSpell("T3", SpellSchool.Destruction, tier: 3, archetype: ArchetypeType.Mystic);

        await _context.Spells.AddRangeAsync(tier1, tier3);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.GetAvailableForCasterAsync(ArchetypeType.Mystic, maxTier: 2);

        // Assert
        result.Should().HaveCount(1);
    }

    [Fact]
    public async Task GetAvailableForCasterAsync_OrdersBySchoolTierName()
    {
        // Arrange
        var spells = new[]
        {
            CreateTestSpell("Zeta", SpellSchool.Restoration, tier: 1),
            CreateTestSpell("Alpha", SpellSchool.Destruction, tier: 2),
            CreateTestSpell("Beta", SpellSchool.Destruction, tier: 1)
        };
        await _context.Spells.AddRangeAsync(spells);
        await _context.SaveChangesAsync();

        // Act
        var result = (await _sut.GetAvailableForCasterAsync(ArchetypeType.Mystic, maxTier: 2)).ToList();

        // Assert
        result[0].School.Should().Be(SpellSchool.Destruction);
        result[0].Tier.Should().Be(1);
    }

    [Fact]
    public async Task GetAvailableForCasterAsync_ReturnsEmpty_WhenNoMatches()
    {
        // Arrange - no spells seeded

        // Act
        var result = await _sut.GetAvailableForCasterAsync(ArchetypeType.Mystic, maxTier: 1);

        // Assert
        result.Should().BeEmpty();
    }

    #endregion

    #region AddRangeAsync Tests

    [Fact]
    public async Task AddRangeAsync_AddsAllSpells()
    {
        // Arrange
        var spells = new[]
        {
            CreateTestSpell("Spell1", SpellSchool.Destruction),
            CreateTestSpell("Spell2", SpellSchool.Restoration)
        };

        // Act
        await _sut.AddRangeAsync(spells);
        await _context.SaveChangesAsync();

        // Assert
        var count = await _context.Spells.CountAsync();
        count.Should().Be(2);
    }

    [Fact]
    public async Task AddRangeAsync_HandlesEmptyCollection()
    {
        // Act
        await _sut.AddRangeAsync(Array.Empty<Spell>());
        await _context.SaveChangesAsync();

        // Assert
        var count = await _context.Spells.CountAsync();
        count.Should().Be(0);
    }

    [Fact]
    public async Task AddRangeAsync_LogsWarning_WhenEmptyName()
    {
        // Arrange
        var spells = new[] { new Spell { Name = "", Description = "Test" } };

        // Act
        await _sut.AddRangeAsync(spells);

        // Assert
        _mockSpellLogger.Received().LogWarning(
            Arg.Is<string>(s => s.Contains("empty name")));
    }

    [Fact]
    public async Task AddRangeAsync_LogsWarning_WhenNoEffectScript()
    {
        // Arrange
        var spells = new[] { CreateTestSpell("NoScript", SpellSchool.Destruction, effectScript: "") };

        // Act
        await _sut.AddRangeAsync(spells);

        // Assert
        _mockSpellLogger.Received().LogWarning(
            Arg.Is<string>(s => s.Contains("no effect script")),
            Arg.Any<string>());
    }

    #endregion

    #region ExistsByNameAsync Tests

    [Fact]
    public async Task ExistsByNameAsync_ReturnsTrue_WhenExists()
    {
        // Arrange
        var spell = CreateTestSpell("Spark", SpellSchool.Destruction);
        await _context.Spells.AddAsync(spell);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.ExistsByNameAsync("Spark");

        // Assert
        result.Should().BeTrue();
    }

    [Fact]
    public async Task ExistsByNameAsync_ReturnsFalse_WhenNotExists()
    {
        // Act
        var result = await _sut.ExistsByNameAsync("NonExistent");

        // Assert
        result.Should().BeFalse();
    }

    [Fact]
    public async Task ExistsByNameAsync_IsCaseInsensitive()
    {
        // Arrange
        var spell = CreateTestSpell("Spark", SpellSchool.Destruction);
        await _context.Spells.AddAsync(spell);
        await _context.SaveChangesAsync();

        // Act
        var result = await _sut.ExistsByNameAsync("SPARK");

        // Assert
        result.Should().BeTrue();
    }

    #endregion

    #region Helper Methods

    private static Spell CreateTestSpell(
        string name,
        SpellSchool school,
        int tier = 1,
        ArchetypeType? archetype = null,
        string effectScript = "DAMAGE:Fire:1d6")
    {
        return new Spell
        {
            Name = name,
            Description = $"Test spell: {name}",
            School = school,
            Tier = tier,
            Archetype = archetype,
            ApCost = 2,
            FluxCost = 5,
            BasePower = 10,
            EffectScript = effectScript,
            TargetType = SpellTargetType.SingleEnemy,
            Range = SpellRange.Close
        };
    }

    private async Task SeedTestSpells()
    {
        var spells = new[]
        {
            CreateTestSpell("Spark", SpellSchool.Destruction),
            CreateTestSpell("Fireball", SpellSchool.Destruction, tier: 2),
            CreateTestSpell("Heal", SpellSchool.Restoration),
            CreateTestSpell("Shield", SpellSchool.Alteration)
        };

        await _context.Spells.AddRangeAsync(spells);
        await _context.SaveChangesAsync();
    }

    #endregion
}
```

---

## Integration Points

### 1. MagicService Integration (v0.4.3c - Future)

```csharp
// In MagicService constructor:
private readonly ISpellRepository _spellRepository;

// In CastSpell method:
var spell = await _spellRepository.GetByNameAsync(spellName);
if (spell == null)
{
    return MagicResult.Failure(CastFailureReason.UnknownSpell, $"Unknown spell: {spellName}");
}
```

### 2. SpellSeeder (v0.4.3e - Future)

```csharp
// SpellSeeder will use ISpellRepository.AddRangeAsync
public static async Task SeedAsync(ISpellRepository repository, ILogger? logger = null)
{
    if (await repository.ExistsByNameAsync("Spark"))
    {
        logger?.LogDebug("Spells already seeded, skipping");
        return;
    }

    var spells = GetStarterSpells();
    await repository.AddRangeAsync(spells);
    await repository.SaveChangesAsync();

    logger?.LogInformation("Seeded {Count} spells", spells.Count);
}
```

### 3. Character Spell Learning (Future)

```csharp
// When character levels up or learns spells:
var availableSpells = await _spellRepository.GetAvailableForCasterAsync(
    character.Archetype,
    maxTier: character.Level / 3 + 1);
```

---

## Deliverable Checklist

### Core Components

- [ ] **Spell.cs** - Entity with all properties
  - [ ] Identity properties (Id, Name, Description)
  - [ ] Classification properties (School, TargetType, Range, Archetype, Tier)
  - [ ] Cost properties (ApCost, FluxCost)
  - [ ] Effect properties (BasePower, EffectScript)
  - [ ] Casting properties (ChargeTurns, TelegraphMessage, RequiresConcentration)
  - [ ] Metadata properties (CreatedAt, LastModified)
  - [ ] Computed properties (IsChargedSpell, IsUniversal, IsSelfTargeted)

- [ ] **SpellSchool.cs** - Enum with 4 schools
  - [ ] Destruction, Restoration, Alteration, Divination
  - [ ] XML documentation with Domain 4 compliant flavor

- [ ] **SpellTargetType.cs** - Enum with 7 target types
  - [ ] Self, SingleEnemy, SingleAlly, AllEnemies, AllAllies, SingleAny, Area

- [ ] **SpellRange.cs** - Enum with 5 range categories
  - [ ] Self, Touch, Close, Medium, Far
  - [ ] Domain 4 compliant descriptions

- [ ] **ISpellRepository.cs** - Repository interface
  - [ ] Extends IRepository<Spell>
  - [ ] GetByNameAsync, GetBySchoolAsync
  - [ ] GetByArchetypeAsync, GetByTierAsync
  - [ ] GetAvailableForCasterAsync
  - [ ] AddRangeAsync, ExistsByNameAsync

- [ ] **SpellRepository.cs** - Repository implementation
  - [ ] All interface methods implemented
  - [ ] Comprehensive logging

### Persistence

- [ ] **RuneAndRustDbContext.cs** - Entity configuration
  - [ ] DbSet<Spell> property
  - [ ] Entity configuration in OnModelCreating
  - [ ] Indexes on Name, Archetype+Tier, School

- [ ] **Migration** - Database schema
  - [ ] Spells table with all columns
  - [ ] Unique index on Name
  - [ ] Composite index on Archetype+Tier

### Integration

- [ ] **Program.cs** - DI registration
  - [ ] `services.AddScoped<ISpellRepository, SpellRepository>()`

### Testing

- [ ] **SpellRepositoryTests.cs** - 35 unit tests
  - [ ] GetByNameAsync tests (5)
  - [ ] GetBySchoolAsync tests (4)
  - [ ] GetByArchetypeAsync tests (6)
  - [ ] GetByTierAsync tests (3)
  - [ ] GetAvailableForCasterAsync tests (4)
  - [ ] AddRangeAsync tests (4)
  - [ ] ExistsByNameAsync tests (3)
  - [ ] CRUD tests (6)

---

## Workflow

### Implementation Order

```
1. CREATE Core Enums
   ├── SpellSchool.cs
   ├── SpellTargetType.cs
   └── SpellRange.cs

2. CREATE Core Entity
   └── Spell.cs

3. CREATE Core Interface
   └── ISpellRepository.cs

4. UPDATE Persistence Layer
   ├── RuneAndRustDbContext.cs (DbSet + config)
   └── Generate migration

5. CREATE Repository Implementation
   └── SpellRepository.cs

6. REGISTER in DI
   └── Program.cs modification

7. CREATE Tests
   └── SpellRepositoryTests.cs

8. APPLY Migration
   └── dotnet ef database update

9. VERIFY
   ├── Run all tests
   └── Manual database inspection
```

### File Creation Order

| Order | File | Layer | Dependencies |
|-------|------|-------|--------------|
| 1 | SpellSchool.cs | Core/Enums | None |
| 2 | SpellTargetType.cs | Core/Enums | None |
| 3 | SpellRange.cs | Core/Enums | None |
| 4 | Spell.cs | Core/Entities | All enums above |
| 5 | ISpellRepository.cs | Core/Interfaces | Spell entity |
| 6 | RuneAndRustDbContext.cs (modify) | Persistence/Data | Spell entity |
| 7 | Migration file | Persistence/Migrations | DbContext |
| 8 | SpellRepository.cs | Persistence/Repositories | All above |
| 9 | SpellRepositoryTests.cs | Tests | All above |
| 10 | Program.cs (modify) | Terminal | SpellRepository |

---

## Changelog

```markdown
## v0.4.3b - The Grimoire (Spell Entity & Repository)

**Release Date:** TBD

### Summary
Introduced the Spell entity and repository layer—the data foundation for The Weaver
magic system. Spells are now fully defined with school classification, targeting
constraints, AP costs, Flux costs, and effect scripts.

### Features
- **Spell Entity**: New entity with 20 properties covering identity, classification,
  costs, effects, and casting mechanics.
- **Spell Schools**: Four schools of magic (Destruction, Restoration, Alteration,
  Divination) with Domain 4 compliant descriptions.
- **Targeting System**: Comprehensive target type and range enums for spell validation.
- **Repository Layer**: Full CRUD plus spell-specific query methods for filtering by
  school, archetype, and tier.

### Technical
- Implemented `Spell` entity with computed properties (IsChargedSpell, IsUniversal).
- Created `SpellSchool`, `SpellTargetType`, and `SpellRange` enums.
- Implemented `ISpellRepository` interface extending base repository.
- Created `SpellRepository` with specialized query methods.
- Added database indexes on Name (unique), Archetype+Tier, and School.
- Registered `ISpellRepository` as Scoped in DI container.

### Database
- Added `Spells` table with 17 columns.
- Unique constraint on spell Name.
- Composite index for archetype-based queries.

### New Files
- `RuneAndRust.Core/Entities/Spell.cs`
- `RuneAndRust.Core/Enums/SpellSchool.cs`
- `RuneAndRust.Core/Enums/SpellTargetType.cs`
- `RuneAndRust.Core/Enums/SpellRange.cs`
- `RuneAndRust.Core/Interfaces/ISpellRepository.cs`
- `RuneAndRust.Persistence/Repositories/SpellRepository.cs`
- `RuneAndRust.Persistence/Migrations/[Timestamp]_Add_Spell_Entity_v0_4_3b.cs`
- `RuneAndRust.Tests/Persistence/Repositories/SpellRepositoryTests.cs`

### Modified Files
- `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` - Added DbSet and configuration
- `RuneAndRust.Terminal/Program.cs` - Added DI registration

### Testing
- 35 new unit tests in `SpellRepositoryTests.cs`
- In-memory SQLite database for isolated testing
- Coverage: All repository methods plus edge cases

### Domain 4 Compliance
- Spell school descriptions use archaeologist perspective
- Range categories use qualitative descriptors ("Close enough to feel their breath")
- No precision measurements in any descriptions

### Dependencies
- Requires v0.4.3a (The Aether) - FluxCost property feeds into AetherService
- Required by v0.4.3c (The Incantation) - MagicService consumes spells
- Required by v0.4.3e (The Resonance) - SpellSeeder populates spells
```

---

## Next Steps

After v0.4.3b implementation:

1. **v0.4.3c (The Incantation)**: Implement MagicService consuming spells from repository
2. **v0.4.3d (The Backlash)**: Add risk mechanics using spell's FluxCost
3. **v0.4.3e (The Resonance)**: Create SpellSeeder with starter spells and TUI integration
