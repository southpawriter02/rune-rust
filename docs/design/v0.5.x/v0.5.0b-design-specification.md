# v0.5.0b Design Specification: Movement System

**Version:** 0.5.0b
**Phase Name:** Movement System
**Parent Version:** v0.5.0 (Combat Grid Foundation)
**Prerequisites:** v0.5.0a Complete (Grid Core)
**Estimated Tests:** ~30 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [MovementCosts Constants](#4-movementcosts-constants)
5. [Player Modifications](#5-player-modifications)
6. [Monster Modifications](#6-monster-modifications)
7. [MovementService](#7-movementservice)
8. [User-Facing Commands](#8-user-facing-commands)
9. [Data Model Changes](#9-data-model-changes)
10. [Configuration File Schemas](#10-configuration-file-schemas)
11. [Logging Specifications](#11-logging-specifications)
12. [Unit Testing Requirements](#12-unit-testing-requirements)
13. [Use Cases](#13-use-cases)
14. [Deliverable Checklist](#14-deliverable-checklist)
15. [Acceptance Criteria](#15-acceptance-criteria)
16. [Dependencies](#16-dependencies)
17. [Future Considerations](#17-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification implements movement mechanics for the combat grid system. Building on the grid infrastructure from v0.5.0a, this phase enables players and monsters to move on the grid using movement points, with different costs for cardinal and diagonal movement.

Key mechanics:
- **Movement Speed**: Base stat determining movement points per turn
- **Movement Points**: Consumable per-turn resource for movement
- **Directional Movement**: 8-direction movement with different costs
- **Movement Validation**: Bounds, occupancy, and point checking

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Constants** | `MovementCosts` |
| **Domain Enums** | `MovementFailureReason` |
| **Player Updates** | `MovementSpeed`, `MovementPointsRemaining`, `CombatGridPosition` |
| **Monster Updates** | `MovementSpeed`, `MovementPointsRemaining`, `CombatGridPosition` |
| **MonsterDefinition Updates** | `MovementSpeed` property |
| **Application Interfaces** | `IMovementService` |
| **Application Services** | `MovementService` |
| **Result Types** | `MovementResult` |
| **Commands** | `move`, `position` |
| **Configuration** | Movement settings in grid.json |
| **Tests** | ~30 unit tests |

### 1.3 Architectural Significance

This version establishes the **Movement Point System**:

- **Speed-Based Points**: Movement points = Speed × 2 (for fractional support)
- **Differential Costs**: Cardinal (2 pts) vs Diagonal (3 pts) - simulates 1 vs 1.5
- **Per-Turn Tracking**: Points reset at start of each turn
- **Validation Chain**: Bounds → Occupancy → Passability → Points

---

## 2. Feature Overview

```
v0.5.0b Movement System
├── MovementCosts Constants
│   ├── Cardinal = 1 (×2 = 2 points)
│   ├── Diagonal = 1.5 (×2 = 3 points)
│   ├── PointMultiplier = 2
│   ├── GetCost(direction)
│   ├── SpeedToPoints(speed)
│   └── PointsToSpeed(points)
├── Player Modifications
│   ├── MovementSpeed: int (default: 4)
│   ├── BaseMovementSpeed: int
│   ├── CombatGridPosition: GridPosition?
│   ├── MovementPointsRemaining: int
│   ├── SetMovementSpeed()
│   ├── ResetMovementPoints()
│   └── UseMovementPoints()
├── Monster Modifications
│   ├── MovementSpeed: int (from definition)
│   ├── CombatGridPosition: GridPosition?
│   ├── MovementPointsRemaining: int
│   ├── ResetMovementPoints()
│   └── UseMovementPoints()
├── MonsterDefinition Updates
│   └── MovementSpeed: int (default: 3)
├── MovementService
│   ├── Move(entityId, direction)
│   ├── GetRemainingMovement(entityId)
│   ├── ResetMovement(entityId)
│   ├── ResetAllMovement()
│   ├── CanMove(entityId, direction)
│   ├── GetValidDirections(entityId)
│   └── GetMovementCost(direction)
└── Commands
    ├── move <direction>
    └── position
```

### 2.1 Scope Alignment

**In Scope:**
- `MovementSpeed` stat for Player and Monster
- Movement points remaining per turn
- Movement point cost (1 for cardinal, 1.5 for diagonal)
- Directional movement (`move north`, `move ne`, etc.)
- Movement validation (bounds, occupied cells)
- Turn movement tracking (reset on new turn)
- Movement point display
- `move` command with direction argument
- `position` command for current location
- Movement result messages

**Out of Scope:**
- ASCII grid display (v0.5.0c)
- Combat service integration (v0.5.0c)
- Terrain movement costs (v0.5.2)
- Difficult terrain (v0.5.2)

---

## 3. Architecture Diagrams

### 3.1 Movement Cost System

```
┌─────────────────────────────────────────────────────────────────────┐
│                      MOVEMENT COST SYSTEM                            │
└─────────────────────────────────────────────────────────────────────┘

    Movement Speed → Movement Points (×2 multiplier for fractional costs)

    Speed 4 → 8 Movement Points per turn

    Cardinal Movement (N, S, E, W): 2 points each
    ┌─────┬─────┬─────┐
    │     │  2  │     │
    ├─────┼─────┼─────┤
    │  2  │  ●  │  2  │
    ├─────┼─────┼─────┤
    │     │  2  │     │
    └─────┴─────┴─────┘

    Diagonal Movement (NE, NW, SE, SW): 3 points each
    ┌─────┬─────┬─────┐
    │  3  │     │  3  │
    ├─────┼─────┼─────┤
    │     │  ●  │     │
    ├─────┼─────┼─────┤
    │  3  │     │  3  │
    └─────┴─────┴─────┘

    Example Movement Sequence (Speed 4 = 8 points):
    ┌────────────────────────────────────────────────────────────┐
    │ Action          │ Points Used │ Points Remaining           │
    ├────────────────────────────────────────────────────────────┤
    │ Start of turn   │      -      │ 8 points                   │
    │ Move North      │      2      │ 6 points                   │
    │ Move NE         │      3      │ 3 points                   │
    │ Move East       │      2      │ 1 point                    │
    │ Move South      │      ✗      │ Insufficient (needs 2)     │
    └────────────────────────────────────────────────────────────┘
```

### 3.2 Movement Validation Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MOVEMENT VALIDATION FLOW                          │
└─────────────────────────────────────────────────────────────────────┘

    Move Request
        │
        ▼
    ┌───────────────┐
    │ Active Grid?  │──No──▶ Fail: NoActiveGrid
    └───────┬───────┘
            │Yes
            ▼
    ┌───────────────┐
    │ Entity on     │──No──▶ Fail: EntityNotOnGrid
    │ Grid?         │
    └───────┬───────┘
            │Yes
            ▼
    ┌───────────────┐
    │ Target in     │──No──▶ Fail: OutOfBounds
    │ Bounds?       │
    └───────┬───────┘
            │Yes
            ▼
    ┌───────────────┐
    │ Target        │──No──▶ Fail: CellImpassable
    │ Passable?     │
    └───────┬───────┘
            │Yes
            ▼
    ┌───────────────┐
    │ Target        │──Yes─▶ Fail: CellOccupied
    │ Occupied?     │
    └───────┬───────┘
            │No
            ▼
    ┌───────────────┐
    │ Enough        │──No──▶ Fail: InsufficientMovementPoints
    │ Points?       │
    └───────┬───────┘
            │Yes
            ▼
    ┌───────────────┐
    │ Execute Move  │
    │ Deduct Points │
    └───────┬───────┘
            │
            ▼
        Success
```

### 3.3 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  MoveCommand                     PositionCommand                     │
│  "move <direction>"              "position"                          │
└───────┬──────────────────────────────────┬──────────────────────────┘
        │                                  │
        ▼                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  IMovementService / MovementService                                  │
│  ├── Move(entityId, direction): MovementResult                      │
│  ├── GetRemainingMovement(entityId): int                            │
│  ├── ResetMovement(entityId): void                                  │
│  ├── ResetAllMovement(): void                                       │
│  ├── CanMove(entityId, direction): bool                             │
│  ├── GetValidDirections(entityId): IEnumerable<MovementDirection>   │
│  └── GetMovementCost(direction): int                                │
├─────────────────────────────────────────────────────────────────────┤
│  Result Types                                                        │
│  ├── MovementResult { Success, OldPos, NewPos, PointsUsed, Msg }    │
│  └── MovementFailureReason (enum)                                   │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         DOMAIN LAYER                                 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌────────────────────────────────────────────────────────────────┐│
│  │                      MovementCosts                              ││
│  │                      (Constants)                                ││
│  ├────────────────────────────────────────────────────────────────┤│
│  │ + Cardinal: int = 1                                            ││
│  │ + Diagonal: int = 2 (effective 1.5 with multiplier)            ││
│  │ + PointMultiplier: int = 2                                     ││
│  │ + GetCost(direction): int                                      ││
│  │ + SpeedToPoints(speed): int                                    ││
│  │ + PointsToSpeed(points): int                                   ││
│  └────────────────────────────────────────────────────────────────┘│
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐│
│  │ Player (Modified)                                              ││
│  ├────────────────────────────────────────────────────────────────┤│
│  │ + MovementSpeed: int (default: 4)                              ││
│  │ + BaseMovementSpeed: int                                       ││
│  │ + CombatGridPosition: GridPosition?                            ││
│  │ + MovementPointsRemaining: int                                 ││
│  │ + SetMovementSpeed(speed): void                                ││
│  │ + ResetMovementPoints(): void                                  ││
│  │ + UseMovementPoints(cost): bool                                ││
│  └────────────────────────────────────────────────────────────────┘│
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐│
│  │ Monster (Modified)                                             ││
│  ├────────────────────────────────────────────────────────────────┤│
│  │ + MovementSpeed: int (from definition, default: 3)             ││
│  │ + CombatGridPosition: GridPosition?                            ││
│  │ + MovementPointsRemaining: int                                 ││
│  │ + ResetMovementPoints(): void                                  ││
│  │ + UseMovementPoints(cost): bool                                ││
│  └────────────────────────────────────────────────────────────────┘│
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐│
│  │ MonsterDefinition (Modified)                                   ││
│  ├────────────────────────────────────────────────────────────────┤│
│  │ + MovementSpeed: int (default: 3)                              ││
│  └────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. MovementCosts Constants

### 4.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/Constants/MovementCosts.cs`

```csharp
namespace RuneAndRust.Domain.Constants;

/// <summary>
/// Constants for movement costs on the combat grid.
/// </summary>
/// <remarks>
/// Uses a point multiplier system to handle fractional costs.
/// Actual costs: Cardinal = 1, Diagonal = 1.5
/// Point system: Cardinal = 2 pts, Diagonal = 3 pts (Speed × 2 = total points)
/// </remarks>
public static class MovementCosts
{
    /// <summary>Base movement cost for cardinal directions (N, S, E, W).</summary>
    public const int Cardinal = 1;

    /// <summary>Base movement cost for diagonal directions.</summary>
    public const int Diagonal = 2;

    /// <summary>Movement point multiplier for fractional costs.</summary>
    public const int PointMultiplier = 2;

    /// <summary>Gets the movement point cost for a direction.</summary>
    public static int GetCost(MovementDirection direction) => direction switch
    {
        MovementDirection.North => Cardinal * PointMultiplier,     // 2
        MovementDirection.South => Cardinal * PointMultiplier,     // 2
        MovementDirection.East => Cardinal * PointMultiplier,      // 2
        MovementDirection.West => Cardinal * PointMultiplier,      // 2
        MovementDirection.NorthEast => Diagonal + 1,               // 3
        MovementDirection.NorthWest => Diagonal + 1,               // 3
        MovementDirection.SouthEast => Diagonal + 1,               // 3
        MovementDirection.SouthWest => Diagonal + 1,               // 3
        _ => Cardinal * PointMultiplier
    };

    /// <summary>Converts movement speed to movement points.</summary>
    public static int SpeedToPoints(int speed) => speed * PointMultiplier;

    /// <summary>Converts movement points to display speed.</summary>
    public static int PointsToSpeed(int points) => points / PointMultiplier;

    /// <summary>Gets display cost (human-readable).</summary>
    public static string GetDisplayCost(MovementDirection direction) => direction switch
    {
        MovementDirection.NorthEast or MovementDirection.NorthWest or
        MovementDirection.SouthEast or MovementDirection.SouthWest => "1.5",
        _ => "1"
    };
}
```

### 4.2 Cost Table

| Direction | Raw Cost | Points (×2) | Display |
|-----------|----------|-------------|---------|
| North | 1 | 2 | 1 |
| South | 1 | 2 | 1 |
| East | 1 | 2 | 1 |
| West | 1 | 2 | 1 |
| NorthEast | 1.5 | 3 | 1.5 |
| NorthWest | 1.5 | 3 | 1.5 |
| SouthEast | 1.5 | 3 | 1.5 |
| SouthWest | 1.5 | 3 | 1.5 |

| Speed | Points | Cardinal Moves | Diagonal Moves | Mixed Example |
|-------|--------|----------------|----------------|---------------|
| 3 | 6 | 3 | 2 | 1 cardinal + 1 diagonal + 1 remaining |
| 4 | 8 | 4 | 2 + 2 left | 2 cardinal + 1 diagonal + 1 left |
| 5 | 10 | 5 | 3 + 1 left | 2 cardinal + 2 diagonal |

---

## 5. Player Modifications

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

```csharp
// Add to Player entity:

#region Movement Properties

/// <summary>Gets or sets the base movement speed (from configuration/class).</summary>
public int BaseMovementSpeed { get; private set; } = 4;

/// <summary>Gets the current movement speed (with modifiers).</summary>
public int MovementSpeed => BaseMovementSpeed; // Future: add modifiers

/// <summary>Gets the current combat grid position (null if not in combat).</summary>
public GridPosition? CombatGridPosition { get; private set; }

/// <summary>Gets remaining movement points this turn.</summary>
public int MovementPointsRemaining { get; private set; }

/// <summary>Sets the base movement speed.</summary>
public void SetMovementSpeed(int speed)
{
    ArgumentOutOfRangeException.ThrowIfLessThan(speed, 1);
    BaseMovementSpeed = speed;
}

/// <summary>Sets the combat grid position.</summary>
public void SetCombatGridPosition(GridPosition? position)
{
    CombatGridPosition = position;
}

/// <summary>Resets movement points to full (start of turn).</summary>
public void ResetMovementPoints()
{
    MovementPointsRemaining = MovementCosts.SpeedToPoints(MovementSpeed);
}

/// <summary>Uses movement points. Returns false if insufficient.</summary>
public bool UseMovementPoints(int cost)
{
    if (cost > MovementPointsRemaining)
        return false;
    MovementPointsRemaining -= cost;
    return true;
}

/// <summary>Gets movement points as display value.</summary>
public float GetDisplayMovementRemaining() =>
    MovementPointsRemaining / (float)MovementCosts.PointMultiplier;

#endregion
```

---

## 6. Monster Modifications

**File:** `src/Core/RuneAndRust.Domain/Entities/Monster.cs`

```csharp
// Add to Monster entity:

#region Movement Properties

/// <summary>Gets the movement speed (from definition).</summary>
public int MovementSpeed { get; private set; } = 3;

/// <summary>Gets the current combat grid position.</summary>
public GridPosition? CombatGridPosition { get; private set; }

/// <summary>Gets remaining movement points this turn.</summary>
public int MovementPointsRemaining { get; private set; }

/// <summary>Sets the movement speed from definition.</summary>
public void SetMovementSpeed(int speed)
{
    ArgumentOutOfRangeException.ThrowIfLessThan(speed, 1);
    MovementSpeed = speed;
}

/// <summary>Sets the combat grid position.</summary>
public void SetCombatGridPosition(GridPosition? position)
{
    CombatGridPosition = position;
}

/// <summary>Resets movement points to full.</summary>
public void ResetMovementPoints()
{
    MovementPointsRemaining = MovementCosts.SpeedToPoints(MovementSpeed);
}

/// <summary>Uses movement points.</summary>
public bool UseMovementPoints(int cost)
{
    if (cost > MovementPointsRemaining)
        return false;
    MovementPointsRemaining -= cost;
    return true;
}

#endregion
```

**MonsterDefinition Updates:**

```csharp
// Add to MonsterDefinition:
public int MovementSpeed { get; private set; } = 3;
```

---

## 7. MovementService

### 7.1 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IMovementService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

public interface IMovementService
{
    MovementResult Move(Guid entityId, MovementDirection direction);
    int GetRemainingMovement(Guid entityId);
    void ResetMovement(Guid entityId);
    void ResetAllMovement();
    bool CanMove(Guid entityId, MovementDirection direction);
    IEnumerable<MovementDirection> GetValidDirections(Guid entityId);
    int GetMovementCost(MovementDirection direction);
}

public readonly record struct MovementResult(
    bool Success, GridPosition? OldPosition, GridPosition? NewPosition,
    int MovementPointsUsed, int MovementPointsRemaining,
    string Message, MovementFailureReason? FailureReason);

public enum MovementFailureReason
{
    NoActiveGrid,
    EntityNotOnGrid,
    OutOfBounds,
    CellOccupied,
    InsufficientMovementPoints,
    CellImpassable,
    NotInCombat
}
```

### 7.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/MovementService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class MovementService : IMovementService
{
    private readonly ICombatGridService _gridService;
    private readonly IGameSessionService _sessionService;
    private readonly ILogger<MovementService> _logger;

    public MovementService(
        ICombatGridService gridService,
        IGameSessionService sessionService,
        ILogger<MovementService> logger)
    {
        _gridService = gridService;
        _sessionService = sessionService;
        _logger = logger;
    }

    public MovementResult Move(Guid entityId, MovementDirection direction)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            return Fail(MovementFailureReason.NoActiveGrid, "No active combat grid.");

        var currentPos = grid.GetEntityPosition(entityId);
        if (!currentPos.HasValue)
            return Fail(MovementFailureReason.EntityNotOnGrid, "Entity not on grid.");

        var newPos = currentPos.Value.Move(direction);

        if (!grid.IsInBounds(newPos))
            return Fail(MovementFailureReason.OutOfBounds, "Cannot move outside the battlefield.");

        var targetCell = grid.GetCell(newPos);
        if (targetCell == null || !targetCell.IsPassable)
            return Fail(MovementFailureReason.CellImpassable, "That path is blocked.");

        if (targetCell.IsOccupied)
        {
            var occupantName = GetEntityName(targetCell.OccupantId!.Value);
            return Fail(MovementFailureReason.CellOccupied,
                $"A {occupantName} blocks your path!");
        }

        var cost = GetMovementCost(direction);
        var remaining = GetRemainingMovement(entityId);

        if (cost > remaining)
            return Fail(MovementFailureReason.InsufficientMovementPoints,
                $"Not enough movement points. Need {MovementCosts.GetDisplayCost(direction)}, have {remaining / (float)MovementCosts.PointMultiplier}.");

        // Execute movement
        if (!UseEntityMovementPoints(entityId, cost))
            return Fail(MovementFailureReason.InsufficientMovementPoints, "Failed to use movement points.");

        if (!grid.MoveEntity(entityId, newPos))
        {
            RefundEntityMovementPoints(entityId, cost);
            return Fail(MovementFailureReason.CellOccupied, "Failed to move on grid.");
        }

        UpdateEntityGridPosition(entityId, newPos);
        var newRemaining = GetRemainingMovement(entityId);

        _logger.LogInformation(
            "Entity {Id} moved {Dir} from {Old} to {New} (cost: {Cost}, remaining: {Rem})",
            entityId, direction, currentPos, newPos, cost, newRemaining);

        return new MovementResult(
            true, currentPos, newPos, cost, newRemaining,
            $"Moved {direction.ToString().ToLower()} to {newPos}.", null);
    }

    public int GetRemainingMovement(Guid entityId)
    {
        var player = _sessionService.GetCurrentPlayer();
        if (player?.Id == entityId)
            return player.MovementPointsRemaining;

        var monster = _sessionService.GetMonster(entityId);
        return monster?.MovementPointsRemaining ?? 0;
    }

    public void ResetMovement(Guid entityId)
    {
        var player = _sessionService.GetCurrentPlayer();
        if (player?.Id == entityId)
        {
            player.ResetMovementPoints();
            return;
        }

        var monster = _sessionService.GetMonster(entityId);
        monster?.ResetMovementPoints();
    }

    public void ResetAllMovement()
    {
        var player = _sessionService.GetCurrentPlayer();
        player?.ResetMovementPoints();

        foreach (var monster in _sessionService.GetActiveMonsters())
            monster.ResetMovementPoints();
    }

    public bool CanMove(Guid entityId, MovementDirection direction)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) return false;

        var currentPos = grid.GetEntityPosition(entityId);
        if (!currentPos.HasValue) return false;

        var newPos = currentPos.Value.Move(direction);
        if (!grid.IsValidPosition(newPos)) return false;

        var cost = GetMovementCost(direction);
        return GetRemainingMovement(entityId) >= cost;
    }

    public IEnumerable<MovementDirection> GetValidDirections(Guid entityId)
    {
        foreach (var direction in Enum.GetValues<MovementDirection>())
            if (CanMove(entityId, direction))
                yield return direction;
    }

    public int GetMovementCost(MovementDirection direction) =>
        MovementCosts.GetCost(direction);

    private static MovementResult Fail(MovementFailureReason reason, string message) =>
        new(false, null, null, 0, 0, message, reason);

    private bool UseEntityMovementPoints(Guid entityId, int cost)
    {
        var player = _sessionService.GetCurrentPlayer();
        if (player?.Id == entityId)
            return player.UseMovementPoints(cost);

        var monster = _sessionService.GetMonster(entityId);
        return monster?.UseMovementPoints(cost) ?? false;
    }

    private void RefundEntityMovementPoints(Guid entityId, int cost)
    {
        // Add points back (negative use)
        var player = _sessionService.GetCurrentPlayer();
        if (player?.Id == entityId)
        {
            player.UseMovementPoints(-cost);
            return;
        }
        // Monster refund handled similarly
    }

    private void UpdateEntityGridPosition(Guid entityId, GridPosition newPos)
    {
        var player = _sessionService.GetCurrentPlayer();
        if (player?.Id == entityId)
        {
            player.SetCombatGridPosition(newPos);
            return;
        }

        var monster = _sessionService.GetMonster(entityId);
        monster?.SetCombatGridPosition(newPos);
    }

    private string GetEntityName(Guid entityId)
    {
        var player = _sessionService.GetCurrentPlayer();
        if (player?.Id == entityId) return player.Name;

        var monster = _sessionService.GetMonster(entityId);
        return monster?.Name ?? "something";
    }
}
```

---

## 8. User-Facing Commands

### 8.1 Move Command

```
> move north

You move north on the battlefield.

[Movement: D4 → D3]
[Movement Points: 4 → 3 remaining]
```

```
> move ne

You move northeast on the battlefield.

[Movement: D3 → E2]
[Movement Points: 3 → 1.5 remaining]
```

### 8.2 Insufficient Points

```
> move east

You don't have enough movement points to move.

[Movement Points: 1 remaining]
[Cardinal move costs: 1]
[Diagonal move costs: 1.5]
```

### 8.3 Blocked Movement

```
> move south

You can't move there - a Skeleton blocks your path!

[Cell D5 is occupied]
```

### 8.4 Position Command

```
> position

Your Position: D4
Movement Points: 3 / 4

Nearby:
  North (D3): Empty
  South (D5): Skeleton
  East (E4): Empty
  West (C4): Wall
```

### 8.5 Direction Aliases

| Full Name | Aliases |
|-----------|---------|
| north | n |
| south | s |
| east | e |
| west | w |
| northeast | ne |
| northwest | nw |
| southeast | se |
| southwest | sw |

---

## 9. Data Model Changes

| Type | Layer | Description |
|------|-------|-------------|
| `MovementCosts` | Domain/Constants | Movement point costs |
| `MovementFailureReason` | Application/Enums | Failure reasons |
| `Player` | Domain/Entities | Add movement properties |
| `Monster` | Domain/Entities | Add movement properties |
| `MonsterDefinition` | Domain/Definitions | Add MovementSpeed |
| `IMovementService` | Application/Interfaces | Movement service interface |
| `MovementService` | Application/Services | Movement implementation |

---

## 10. Configuration File Schemas

**Add to `config/grid.json`:**

```json
{
  "gridSettings": { ... },
  "movementSettings": {
    "defaultPlayerSpeed": 4,
    "defaultMonsterSpeed": 3,
    "diagonalCostMultiplier": 1.5,
    "allowDiagonalMovement": true
  },
  "classMovementModifiers": [
    { "classId": "warrior", "movementSpeedBonus": 0 },
    { "classId": "rogue", "movementSpeedBonus": 1 },
    { "classId": "mage", "movementSpeedBonus": -1 }
  ]
}
```

---

## 11. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `MovementService` | Information | Successful moves with positions |
| `MovementService` | Debug | Movement point calculations, validation |
| `MovementService` | Warning | Failed movement attempts |

---

## 12. Unit Testing Requirements

| Feature | Test Count |
|---------|------------|
| MovementCosts | ~6 |
| Player Movement Properties | ~6 |
| Monster Movement Properties | ~4 |
| MovementService.Move | ~8 |
| MovementService Validation | ~6 |
| **Total** | **~30** |

---

## 13. Use Cases

### UC-001: Cardinal Movement
**Flow:** Player uses `move north` → Validate → Cost 2 pts → Execute → Update position

### UC-002: Diagonal Movement
**Flow:** Player uses `move ne` → Validate → Cost 3 pts → Execute → Update position

### UC-003: Insufficient Points
**Flow:** Player moves → Not enough points → Fail with message

### UC-004: Blocked by Monster
**Flow:** Player moves toward monster → Cell occupied → Fail with occupant name

### UC-005: Turn Reset
**Flow:** New turn starts → ResetAllMovement → All entities full points

---

## 14. Deliverable Checklist

### Domain Layer
- [ ] `MovementCosts` constants
- [ ] Player movement properties
- [ ] Monster movement properties
- [ ] MonsterDefinition MovementSpeed

### Application Layer
- [ ] `IMovementService` interface
- [ ] `MovementService` implementation
- [ ] `MovementResult` record
- [ ] `MovementFailureReason` enum

### Presentation Layer
- [ ] `move` command with direction parsing
- [ ] `position` command
- [ ] Direction alias support

### Configuration
- [ ] Movement settings in grid.json

### Testing
- [ ] ~30 unit tests
- [ ] All tests passing

---

## 15. Acceptance Criteria

### Functional
- [ ] Player.MovementSpeed returns correct value (default: 4)
- [ ] Monster.MovementSpeed returns correct value from definition
- [ ] MovementPointsRemaining tracks usage correctly
- [ ] Cardinal movement costs 2 points (displays as 1)
- [ ] Diagonal movement costs 3 points (displays as 1.5)
- [ ] Movement fails when insufficient points
- [ ] Movement fails for out-of-bounds positions
- [ ] Movement fails for occupied cells
- [ ] Movement resets at start of turn
- [ ] `move` command accepts all 8 directions
- [ ] Direction aliases work (n, ne, nw, s, se, sw, e, w)
- [ ] Movement updates grid position and entity position
- [ ] Movement result shows old and new position

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~30 unit tests pass
- [ ] XML documentation complete

---

## 16. Dependencies

### Required from v0.5.0a

| Type | Usage |
|------|-------|
| `CombatGrid` | Position tracking and movement |
| `GridPosition` | Coordinate calculations |
| `ICombatGridService` | Grid operations |
| `MovementDirection` | Direction enumeration |

### Provides to v0.5.0c
- Movement point tracking for display
- Entity position updates for grid rendering
- Movement service for AI movement

---

## 17. Future Considerations

### Deferred to v0.5.0c
- ASCII grid display
- Combat service integration
- Position indicators in combat messages

### Deferred to v0.5.2
- Terrain movement costs
- Difficult terrain
- Movement affecting attacks of opportunity

### Out of Scope for v0.5.0
- Dash/run actions
- Movement reactions
- Push/pull effects

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: AI Assistant*
