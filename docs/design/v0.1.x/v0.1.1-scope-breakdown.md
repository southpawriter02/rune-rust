# v0.1.1 Dynamic Room Generation - Scope Breakdown

**Version:** 0.1.1
**Theme:** Dynamic Room Generation
**Prerequisites:** v0.1.0 Complete (Expanded Dungeon & Z-Axis)
**Total Estimated Tests:** ~90 new tests

---

## Executive Summary

The Dynamic Room Generation version transforms the basic procedural system from v0.1.0 into a fully-featured randomization engine with infinite playability. This version adds room templates with variable content, reproducible dungeon seeds, comprehensive difficulty scaling, procedural descriptions, dynamic monster/item placement, branch generation, and an infinite dungeon mode.

Key focus areas:
- **Room Templates**: Reusable patterns with variable slots for content
- **Dungeon Seeds**: Reproducible randomization from seed values
- **Difficulty Scaling**: Progressive challenge based on depth and distance
- **Procedural Descriptions**: Randomized flavor text combining descriptor pools
- **Dynamic Placement**: Context-aware monster and item spawning
- **Branch Generation**: Random side paths, dead ends, and loops
- **Infinite Mode**: Endless procedural generation for unlimited play

The work is divided into **four sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.1.1a | Room Template System | Template entities, variable slots, template configuration | ~20 |
| v0.1.1b | Seeded Generation | Dungeon seeds, reproducibility, deterministic RNG | ~22 |
| v0.1.1c | Difficulty & Content Scaling | Difficulty rating, dynamic placement, scaling rules | ~25 |
| v0.1.1d | Branch Generation & Infinite Mode | Branching paths, dead ends, infinite generation | ~23 |

---

## Existing Infrastructure

### Already Implemented (from v0.1.0)

| Feature | Location | Notes |
|---------|----------|-------|
| Position3D | `Domain/ValueObjects/Position3D.cs` | X, Y, Z coordinates |
| Direction (6-way) | `Domain/Enums/Direction.cs` | N, S, E, W, Up, Down |
| RoomType enum | `Domain/Enums/RoomType.cs` | Standard, Treasure, Trap, Boss, Safe, Shrine |
| Exit value object | `Domain/ValueObjects/Exit.cs` | Target, hidden state, discovery |
| RoomGeneratorService | `Application/Services/RoomGeneratorService.cs` | Basic room generation |
| Room templates (basic) | `config/room-templates.json` | Exit probabilities, biome tags |
| Generation rules | `config/generation-rules.json` | Max rooms, depth multipliers |
| MapRendererService | `Application/Services/MapRendererService.cs` | ASCII map generation |
| ExplorationState | `Domain/Enums/ExplorationState.cs` | Unexplored, Visited, Cleared |
| EnvironmentContext | `Domain/ValueObjects/EnvironmentContext.cs` | Biome, climate, lighting |
| DescriptorService | `Application/Services/DescriptorService.cs` | Weighted text generation |
| TierDefinition | `Domain/Definitions/TierDefinition.cs` | Monster tier multipliers |
| DifficultyClassDefinition | `Domain/Definitions/DifficultyClassDefinition.cs` | DC thresholds |

### Needs Implementation (v0.1.1)

| Feature | Phase | Notes |
|---------|-------|-------|
| RoomTemplate entity | v0.1.1a | Full template with content slots |
| TemplateSlot value object | v0.1.1a | Variable content positions |
| SlotType enum | v0.1.1a | Monster, Item, Feature, Exit |
| SeededRandom wrapper | v0.1.1b | Reproducible random generation |
| Dungeon.Seed property | v0.1.1b | Seed value for reproduction |
| DifficultyRating value object | v0.1.1c | Room/dungeon challenge level |
| ContentPlacementService | v0.1.1c | Dynamic monster/item spawning |
| ScalingRulesConfiguration | v0.1.1c | Depth/distance scaling formulas |
| BranchGeneratorService | v0.1.1d | Side paths and dead ends |
| InfiniteDungeonService | v0.1.1d | Endless generation management |

---

## Feature Analysis & Categorization

### Template Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| RoomTemplate entity | High | Room, BiomeConfiguration | **v0.1.1a** |
| TemplateSlot value object | Medium | None | **v0.1.1a** |
| SlotType enum | Low | None | **v0.1.1a** |
| Template validation | Medium | RoomTemplate | **v0.1.1a** |
| Template selection by context | Medium | EnvironmentContext | **v0.1.1a** |
| Variable description parts | Medium | DescriptorService | **v0.1.1a** |

### Seeding Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| SeededRandom wrapper | Medium | None | **v0.1.1b** |
| Dungeon seed property | Low | Dungeon | **v0.1.1b** |
| Position-based sub-seeds | Medium | Position3D | **v0.1.1b** |
| Reproducibility validation | Medium | SeededRandom | **v0.1.1b** |
| Seed display/input commands | Low | GameSessionService | **v0.1.1b** |

### Scaling Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| DifficultyRating value object | Medium | None | **v0.1.1c** |
| Room difficulty calculation | Medium | Position3D, DifficultyRating | **v0.1.1c** |
| ContentPlacementService | High | TierDefinition, ItemDefinition | **v0.1.1c** |
| Scaling rules configuration | Medium | Configuration loader | **v0.1.1c** |
| Monster level scaling | Medium | MonsterDefinition | **v0.1.1c** |
| Loot quality scaling | Medium | LootService | **v0.1.1c** |

### Generation Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| BranchGeneratorService | High | RoomGeneratorService | **v0.1.1d** |
| Branch probability rules | Medium | Configuration | **v0.1.1d** |
| Dead end generation | Medium | BranchGeneratorService | **v0.1.1d** |
| Loop detection/prevention | Medium | Dungeon graph | **v0.1.1d** |
| InfiniteDungeonService | High | All generation services | **v0.1.1d** |
| Chunk-based generation | High | InfiniteDungeonService | **v0.1.1d** |

---

## Phase Definitions

---

## v0.1.1a: Room Template System

### Overview

Create a comprehensive room template system with variable content slots. Templates define room structure patterns that can be filled with different content based on context, enabling varied room generation while maintaining coherent design patterns.

### Scope

**In Scope:**
- `RoomTemplate` entity with full structure definition
- `TemplateSlot` value object for variable content positions
- `SlotType` enum (Monster, Item, Feature, Exit, Description)
- Template configuration with multiple templates per biome
- Slot filling rules (required vs optional, quantity ranges)
- Variable description parts with descriptor pool references
- Template selection service based on context
- Template validation service

**Out of Scope:**
- Seeded randomization (v0.1.1b)
- Difficulty scaling (v0.1.1c)
- Branch generation (v0.1.1d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Entities | 1 | `RoomTemplate` |
| Value Objects | 2 | `TemplateSlot`, `SlotFillResult` |
| Enums | 1 | `SlotType` |
| Services | 2 | `TemplateSelectionService`, `TemplateValidationService` |
| Configuration | 1 | Enhanced `room-templates.json` |
| Unit Tests | ~20 | Template, slot, selection tests |

### RoomTemplate Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Defines a reusable room pattern with variable content slots.
/// </summary>
public class RoomTemplate : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this template.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the template's configuration ID (e.g., "dungeon-corridor-01").
    /// </summary>
    public string TemplateId { get; private set; }

    /// <summary>
    /// Gets the display name pattern (may contain {variables}).
    /// </summary>
    public string NamePattern { get; private set; }

    /// <summary>
    /// Gets the description pattern with descriptor pool references.
    /// </summary>
    public string DescriptionPattern { get; private set; }

    /// <summary>
    /// Gets the biomes this template can be used in.
    /// </summary>
    public IReadOnlyList<string> ValidBiomes { get; private set; }

    /// <summary>
    /// Gets the room type this template produces.
    /// </summary>
    public RoomType RoomType { get; private set; }

    /// <summary>
    /// Gets the content slots defined in this template.
    /// </summary>
    public IReadOnlyList<TemplateSlot> Slots { get; private set; }

    /// <summary>
    /// Gets the selection weight for random template selection.
    /// </summary>
    public int Weight { get; private set; }

    /// <summary>
    /// Gets the minimum depth (Z-level) where this template can appear.
    /// </summary>
    public int MinDepth { get; private set; }

    /// <summary>
    /// Gets the maximum depth (Z-level) where this template can appear.
    /// </summary>
    public int? MaxDepth { get; private set; }

    /// <summary>
    /// Gets tags for additional filtering.
    /// </summary>
    public IReadOnlyList<string> Tags { get; private set; }

    private RoomTemplate() { /* EF Core */ }
}
```

### TemplateSlot Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a variable content position within a room template.
/// </summary>
public readonly record struct TemplateSlot
{
    /// <summary>
    /// Gets the slot identifier within the template.
    /// </summary>
    public string SlotId { get; init; }

    /// <summary>
    /// Gets the type of content this slot accepts.
    /// </summary>
    public SlotType Type { get; init; }

    /// <summary>
    /// Gets whether this slot must be filled.
    /// </summary>
    public bool IsRequired { get; init; }

    /// <summary>
    /// Gets the minimum quantity to place (default 1 if required).
    /// </summary>
    public int MinQuantity { get; init; }

    /// <summary>
    /// Gets the maximum quantity to place.
    /// </summary>
    public int MaxQuantity { get; init; }

    /// <summary>
    /// Gets the probability this slot is filled (0.0-1.0).
    /// </summary>
    public float FillProbability { get; init; }

    /// <summary>
    /// Gets constraints for content selection.
    /// </summary>
    public IReadOnlyDictionary<string, string> Constraints { get; init; }

    /// <summary>
    /// Gets the descriptor pool for description slots.
    /// </summary>
    public string? DescriptorPool { get; init; }

    public static TemplateSlot Monster(
        string slotId,
        bool required = false,
        int min = 1,
        int max = 1,
        float probability = 0.5f) => new()
    {
        SlotId = slotId,
        Type = SlotType.Monster,
        IsRequired = required,
        MinQuantity = min,
        MaxQuantity = max,
        FillProbability = probability,
        Constraints = new Dictionary<string, string>()
    };

    public static TemplateSlot Item(
        string slotId,
        bool required = false,
        float probability = 0.3f) => new()
    {
        SlotId = slotId,
        Type = SlotType.Item,
        IsRequired = required,
        MinQuantity = 1,
        MaxQuantity = 1,
        FillProbability = probability,
        Constraints = new Dictionary<string, string>()
    };
}
```

### SlotType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of content that can fill template slots.
/// </summary>
public enum SlotType
{
    /// <summary>Monster spawn point.</summary>
    Monster,

    /// <summary>Item placement point.</summary>
    Item,

    /// <summary>Interactive feature (lever, altar, etc.).</summary>
    Feature,

    /// <summary>Potential exit direction.</summary>
    Exit,

    /// <summary>Variable description segment.</summary>
    Description,

    /// <summary>Environmental hazard or trap.</summary>
    Hazard,

    /// <summary>Loot container (chest, barrel, etc.).</summary>
    Container
}
```

### Template Configuration Example

```json
{
  "templates": [
    {
      "templateId": "dungeon-corridor-narrow",
      "namePattern": "{adjective} Corridor",
      "descriptionPattern": "A {width} {material} corridor stretches {direction}. {atmosphere} {detail}",
      "validBiomes": ["dungeon", "ruins", "cave"],
      "roomType": "Standard",
      "weight": 40,
      "minDepth": 0,
      "maxDepth": null,
      "tags": ["corridor", "passage"],
      "slots": [
        {
          "slotId": "adjective",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.adjectives.corridor"
        },
        {
          "slotId": "width",
          "type": "Description",
          "isRequired": true,
          "descriptorPool": "room.dimensions.width"
        },
        {
          "slotId": "monster_01",
          "type": "Monster",
          "isRequired": false,
          "fillProbability": 0.35,
          "minQuantity": 1,
          "maxQuantity": 2,
          "constraints": {
            "maxTier": "named",
            "categories": "humanoid,beast"
          }
        },
        {
          "slotId": "item_01",
          "type": "Item",
          "isRequired": false,
          "fillProbability": 0.15,
          "constraints": {
            "types": "consumable,treasure"
          }
        }
      ]
    },
    {
      "templateId": "dungeon-treasure-vault",
      "namePattern": "{guardian}'s {container_type}",
      "descriptionPattern": "A {size} chamber filled with {treasure_description}. {guardian_hint}",
      "validBiomes": ["dungeon", "ruins"],
      "roomType": "Treasure",
      "weight": 8,
      "minDepth": 2,
      "tags": ["treasure", "vault", "guarded"],
      "slots": [
        {
          "slotId": "guardian",
          "type": "Monster",
          "isRequired": true,
          "fillProbability": 1.0,
          "minQuantity": 1,
          "maxQuantity": 1,
          "constraints": {
            "minTier": "elite"
          }
        },
        {
          "slotId": "main_container",
          "type": "Container",
          "isRequired": true,
          "fillProbability": 1.0,
          "constraints": {
            "containerType": "chest",
            "lootQuality": "high"
          }
        },
        {
          "slotId": "bonus_loot",
          "type": "Item",
          "isRequired": false,
          "fillProbability": 0.5,
          "minQuantity": 1,
          "maxQuantity": 3
        }
      ]
    }
  ]
}
```

### Acceptance Criteria

- [ ] RoomTemplate entity created with all properties
- [ ] TemplateSlot value object supports all slot types
- [ ] SlotType enum covers all content types
- [ ] Templates load from JSON configuration
- [ ] Template selection filters by biome and depth
- [ ] Required slots are always filled
- [ ] Optional slots respect fill probability
- [ ] Description patterns resolve descriptor pool references
- [ ] ~20 unit tests pass

---

## v0.1.1b: Seeded Generation

### Overview

Implement reproducible random generation using seed values. Players can share dungeon seeds to experience identical layouts, and the system ensures deterministic generation from any given seed.

### Scope

**In Scope:**
- `SeededRandom` wrapper class for reproducible randomization
- `Dungeon.Seed` property for storing generation seed
- Position-based sub-seed derivation (same position = same result)
- Seed display command (`seed`)
- Seed input for new game (`new game --seed XXXXX`)
- Reproducibility validation tests
- Seed serialization for save/load

**Out of Scope:**
- Difficulty scaling (v0.1.1c)
- Branch generation algorithms (v0.1.1d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Services | 1 | `SeededRandomService` |
| Entity Updates | 1 | `Dungeon` seed property |
| Commands | 2 | `seed`, `new game --seed` |
| Unit Tests | ~22 | Reproducibility, sub-seed tests |

### SeededRandom Service

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Provides reproducible random number generation from seeds.
/// </summary>
public class SeededRandomService
{
    private readonly int _masterSeed;
    private readonly Dictionary<string, Random> _subGenerators = new();

    /// <summary>
    /// Gets the master seed for this generator.
    /// </summary>
    public int MasterSeed => _masterSeed;

    /// <summary>
    /// Creates a new seeded random service with the specified seed.
    /// </summary>
    public SeededRandomService(int seed)
    {
        _masterSeed = seed;
    }

    /// <summary>
    /// Creates a new seeded random service with a random seed.
    /// </summary>
    public SeededRandomService()
    {
        _masterSeed = Environment.TickCount;
    }

    /// <summary>
    /// Gets a deterministic random value for a position.
    /// </summary>
    public int NextForPosition(Position3D position, string context = "default")
    {
        var subSeed = DeriveSubSeed(position, context);
        return GetOrCreateGenerator(subSeed).Next();
    }

    /// <summary>
    /// Gets a deterministic random value in range for a position.
    /// </summary>
    public int NextForPosition(Position3D position, int minInclusive, int maxExclusive, string context = "default")
    {
        var subSeed = DeriveSubSeed(position, context);
        return GetOrCreateGenerator(subSeed).Next(minInclusive, maxExclusive);
    }

    /// <summary>
    /// Gets a deterministic float (0.0-1.0) for a position.
    /// </summary>
    public float NextFloatForPosition(Position3D position, string context = "default")
    {
        var subSeed = DeriveSubSeed(position, context);
        return (float)GetOrCreateGenerator(subSeed).NextDouble();
    }

    /// <summary>
    /// Selects a weighted random item for a position.
    /// </summary>
    public T SelectWeighted<T>(Position3D position, IEnumerable<(T item, int weight)> items, string context = "default")
    {
        var list = items.ToList();
        var totalWeight = list.Sum(i => i.weight);
        var roll = NextForPosition(position, 0, totalWeight, context);

        var cumulative = 0;
        foreach (var (item, weight) in list)
        {
            cumulative += weight;
            if (roll < cumulative)
                return item;
        }

        return list[^1].item;
    }

    /// <summary>
    /// Derives a deterministic sub-seed from position and context.
    /// </summary>
    private int DeriveSubSeed(Position3D position, string context)
    {
        unchecked
        {
            var hash = _masterSeed;
            hash = hash * 31 + position.X;
            hash = hash * 31 + position.Y;
            hash = hash * 31 + position.Z;
            hash = hash * 31 + context.GetHashCode();
            return hash;
        }
    }

    private Random GetOrCreateGenerator(int subSeed)
    {
        var key = subSeed.ToString();
        if (!_subGenerators.TryGetValue(key, out var generator))
        {
            generator = new Random(subSeed);
            _subGenerators[key] = generator;
        }
        return generator;
    }

    /// <summary>
    /// Generates a human-readable seed string.
    /// </summary>
    public static string ToSeedString(int seed)
    {
        // Convert to alphanumeric format for easier sharing
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
        var result = new char[8];
        var value = (uint)seed;

        for (int i = 0; i < 8; i++)
        {
            result[i] = chars[(int)(value % chars.Length)];
            value /= (uint)chars.Length;
        }

        return new string(result);
    }

    /// <summary>
    /// Parses a seed string back to integer.
    /// </summary>
    public static int FromSeedString(string seedString)
    {
        const string chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
        uint value = 0;
        uint multiplier = 1;

        foreach (char c in seedString.ToUpperInvariant())
        {
            var index = chars.IndexOf(c);
            if (index < 0) throw new ArgumentException($"Invalid seed character: {c}");
            value += (uint)index * multiplier;
            multiplier *= (uint)chars.Length;
        }

        return (int)value;
    }
}
```

### Dungeon Seed Property

```csharp
// In Dungeon.cs
/// <summary>
/// Gets the seed used to generate this dungeon.
/// </summary>
/// <remarks>
/// The same seed produces identical dungeon layouts, enabling
/// reproducible exploration and seed sharing between players.
/// </remarks>
public int Seed { get; private set; }

/// <summary>
/// Gets the human-readable seed string.
/// </summary>
public string SeedString => SeededRandomService.ToSeedString(Seed);

/// <summary>
/// Creates a new dungeon with a specific seed.
/// </summary>
public Dungeon(string name, int seed) : this(name)
{
    Seed = seed;
}
```

### Seed Commands

```
> seed
Current dungeon seed: HXKP4MN2
Share this seed to let others explore the same dungeon!

> new game --seed HXKP4MN2
Starting new game with seed HXKP4MN2...
You find yourself in a familiar dungeon...
```

### Acceptance Criteria

- [ ] SeededRandomService generates reproducible values from seed
- [ ] Same position + seed always produces same result
- [ ] Different positions produce different results
- [ ] Dungeon entity stores seed value
- [ ] Seed command displays current seed
- [ ] New game accepts seed parameter
- [ ] Seed string format is human-readable
- [ ] Sub-seeds derived deterministically from position
- [ ] ~22 unit tests pass

---

## v0.1.1c: Difficulty & Content Scaling

### Overview

Implement comprehensive difficulty scaling based on depth and distance from start. Create a content placement service that selects appropriate monsters and items based on room difficulty rating and context.

### Scope

**In Scope:**
- `DifficultyRating` value object with level calculation
- Room difficulty based on depth (Z) and distance from start
- `ContentPlacementService` for monster/item selection
- `ScalingRulesConfiguration` for configurable formulas
- Monster tier selection based on difficulty
- Monster level scaling based on depth
- Loot quality scaling based on difficulty
- Special room type bonuses (Treasure = higher quality)

**Out of Scope:**
- Branch generation (v0.1.1d)
- Infinite mode (v0.1.1d)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Value Objects | 1 | `DifficultyRating` |
| Services | 1 | `ContentPlacementService` |
| Configuration | 1 | `scaling-rules.json` |
| Entity Updates | 1 | `Room.DifficultyRating` property |
| Unit Tests | ~25 | Scaling, placement tests |

### DifficultyRating Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the difficulty rating of a room or area.
/// </summary>
public readonly record struct DifficultyRating
{
    /// <summary>
    /// Gets the base difficulty level (1-100).
    /// </summary>
    public int Level { get; init; }

    /// <summary>
    /// Gets the depth contribution (Z-level).
    /// </summary>
    public int DepthFactor { get; init; }

    /// <summary>
    /// Gets the distance contribution (from start).
    /// </summary>
    public int DistanceFactor { get; init; }

    /// <summary>
    /// Gets the room type modifier.
    /// </summary>
    public float RoomTypeModifier { get; init; }

    /// <summary>
    /// Gets the effective difficulty after all modifiers.
    /// </summary>
    public int EffectiveLevel => (int)(Level * RoomTypeModifier);

    /// <summary>
    /// Gets the suggested monster tier based on difficulty.
    /// </summary>
    public string SuggestedMonsterTier => EffectiveLevel switch
    {
        < 15 => "common",
        < 35 => "named",
        < 60 => "elite",
        _ => "boss"
    };

    /// <summary>
    /// Gets the loot quality multiplier.
    /// </summary>
    public float LootQualityMultiplier => 1.0f + (EffectiveLevel * 0.02f);

    /// <summary>
    /// Gets the monster level bonus.
    /// </summary>
    public int MonsterLevelBonus => EffectiveLevel / 10;

    /// <summary>
    /// Calculates difficulty from position and room type.
    /// </summary>
    public static DifficultyRating Calculate(
        Position3D position,
        Position3D startPosition,
        RoomType roomType,
        ScalingRules rules)
    {
        var depth = position.Z;
        var distance = ManhattanDistance(position, startPosition);

        var depthContribution = depth * rules.DepthMultiplier;
        var distanceContribution = distance * rules.DistanceMultiplier;
        var baseLevel = rules.BaseDifficulty + (int)depthContribution + (int)distanceContribution;

        var typeModifier = roomType switch
        {
            RoomType.Treasure => rules.TreasureRoomModifier,
            RoomType.Boss => rules.BossRoomModifier,
            RoomType.Trap => rules.TrapRoomModifier,
            RoomType.Safe => 0.0f, // No combat in safe rooms
            _ => 1.0f
        };

        return new DifficultyRating
        {
            Level = Math.Clamp(baseLevel, 1, 100),
            DepthFactor = depth,
            DistanceFactor = distance,
            RoomTypeModifier = typeModifier
        };
    }

    private static int ManhattanDistance(Position3D a, Position3D b) =>
        Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y) + Math.Abs(a.Z - b.Z);
}
```

### ContentPlacementService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for placing monsters and items based on difficulty.
/// </summary>
public class ContentPlacementService
{
    private readonly IMonsterService _monsterService;
    private readonly ITierService _tierService;
    private readonly ILootService _lootService;
    private readonly SeededRandomService _random;
    private readonly ScalingRules _rules;
    private readonly ILogger<ContentPlacementService> _logger;

    /// <summary>
    /// Fills a template slot with appropriate monster content.
    /// </summary>
    public IEnumerable<Monster> FillMonsterSlot(
        TemplateSlot slot,
        DifficultyRating difficulty,
        Position3D position,
        EnvironmentContext environment)
    {
        // Check if slot should be filled
        var fillRoll = _random.NextFloatForPosition(position, "monster_fill");
        if (!slot.IsRequired && fillRoll > slot.FillProbability)
        {
            yield break;
        }

        // Determine quantity
        var quantity = _random.NextForPosition(
            position,
            slot.MinQuantity,
            slot.MaxQuantity + 1,
            "monster_quantity");

        // Select tier based on difficulty
        var tier = SelectTierForDifficulty(difficulty, slot.Constraints, position);

        // Generate monsters
        for (int i = 0; i < quantity; i++)
        {
            var monster = _monsterService.CreateMonsterForBiome(
                environment.Biome ?? "dungeon",
                tier.Id,
                difficulty.MonsterLevelBonus);

            if (monster != null)
                yield return monster;
        }
    }

    /// <summary>
    /// Fills a template slot with appropriate item content.
    /// </summary>
    public IEnumerable<Item> FillItemSlot(
        TemplateSlot slot,
        DifficultyRating difficulty,
        Position3D position,
        EnvironmentContext environment)
    {
        var fillRoll = _random.NextFloatForPosition(position, "item_fill");
        if (!slot.IsRequired && fillRoll > slot.FillProbability)
        {
            yield break;
        }

        var quantity = _random.NextForPosition(
            position,
            slot.MinQuantity,
            slot.MaxQuantity + 1,
            "item_quantity");

        for (int i = 0; i < quantity; i++)
        {
            var item = GenerateItemForDifficulty(difficulty, slot.Constraints, position);
            if (item != null)
                yield return item;
        }
    }

    private TierDefinition SelectTierForDifficulty(
        DifficultyRating difficulty,
        IReadOnlyDictionary<string, string> constraints,
        Position3D position)
    {
        var availableTiers = _tierService.GetAllTiers()
            .Where(t => t.SpawnWeight > 0);

        // Apply constraints
        if (constraints.TryGetValue("maxTier", out var maxTier))
        {
            var maxOrder = _tierService.GetTier(maxTier)?.SortOrder ?? int.MaxValue;
            availableTiers = availableTiers.Where(t => t.SortOrder <= maxOrder);
        }

        if (constraints.TryGetValue("minTier", out var minTier))
        {
            var minOrder = _tierService.GetTier(minTier)?.SortOrder ?? 0;
            availableTiers = availableTiers.Where(t => t.SortOrder >= minOrder);
        }

        // Adjust weights based on difficulty
        var weightedTiers = availableTiers.Select(t =>
        {
            var adjustedWeight = t.SpawnWeight;
            // Higher difficulty = more likely to get higher tiers
            if (t.SortOrder > 0)
                adjustedWeight = (int)(adjustedWeight * (1 + difficulty.EffectiveLevel * 0.01));
            return (t, adjustedWeight);
        });

        return _random.SelectWeighted(position, weightedTiers, "tier_select");
    }
}
```

### Scaling Rules Configuration

```json
{
  "scalingRules": {
    "baseDifficulty": 5,
    "depthMultiplier": 8.0,
    "distanceMultiplier": 2.0,
    "treasureRoomModifier": 1.5,
    "bossRoomModifier": 2.0,
    "trapRoomModifier": 1.2,
    "monsterLevelScaling": {
      "perDepthLevel": 1,
      "perDistanceUnit": 0.5
    },
    "lootScaling": {
      "baseQualityChance": 0.1,
      "qualityPerDifficulty": 0.005,
      "rarityWeights": {
        "common": 70,
        "uncommon": 20,
        "rare": 8,
        "epic": 2
      }
    },
    "specialRoomChances": {
      "treasure": 0.08,
      "boss": 0.03,
      "trap": 0.12,
      "safe": 0.05,
      "shrine": 0.04
    }
  }
}
```

### Acceptance Criteria

- [ ] DifficultyRating calculates from position and room type
- [ ] Deeper rooms have higher difficulty
- [ ] Farther rooms have higher difficulty
- [ ] Room types modify difficulty appropriately
- [ ] ContentPlacementService fills template slots
- [ ] Monster tier selection respects difficulty
- [ ] Monster levels scale with depth
- [ ] Loot quality scales with difficulty
- [ ] Scaling rules load from configuration
- [ ] ~25 unit tests pass

---

## v0.1.1d: Branch Generation & Infinite Mode

### Overview

Implement branch generation for varied dungeon layouts with side paths, dead ends, and optional loops. Add infinite dungeon mode for endless procedural generation.

### Scope

**In Scope:**
- `BranchGeneratorService` for creating branching paths
- Branch probability rules (main path vs side path)
- Dead end generation and capping
- Loop detection and optional loop creation
- `InfiniteDungeonService` for endless generation
- Chunk-based generation (generate around player)
- Cleanup of distant generated rooms (memory management)
- Infinite mode toggle and configuration

**Out of Scope:**
- Save/load for infinite mode (future version)
- Multiplayer infinite dungeons (future version)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Services | 2 | `BranchGeneratorService`, `InfiniteDungeonService` |
| Configuration | 1 | `branch-rules.json` |
| Value Objects | 1 | `BranchDecision` |
| Commands | 1 | `infinite mode` toggle |
| Unit Tests | ~23 | Branching, infinite tests |

### BranchGeneratorService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for generating branching dungeon paths.
/// </summary>
public class BranchGeneratorService
{
    private readonly SeededRandomService _random;
    private readonly BranchRules _rules;
    private readonly ILogger<BranchGeneratorService> _logger;

    /// <summary>
    /// Determines branching decisions for a room's exits.
    /// </summary>
    public BranchDecision DecideBranching(
        Position3D position,
        IEnumerable<Direction> potentialExits,
        DungeonGraph existingGraph)
    {
        var decisions = new Dictionary<Direction, BranchType>();
        var exits = potentialExits.ToList();

        // Always ensure at least one continuation (not a dead end)
        var hasMainPath = false;

        foreach (var direction in exits)
        {
            var targetPos = position.Move(direction);
            var roll = _random.NextFloatForPosition(position, $"branch_{direction}");

            // Check if this would create a loop
            var wouldLoop = existingGraph.HasRoom(targetPos);

            if (wouldLoop)
            {
                // Decide whether to allow the loop
                if (roll < _rules.LoopProbability)
                {
                    decisions[direction] = BranchType.Loop;
                }
                else
                {
                    decisions[direction] = BranchType.None;
                }
                continue;
            }

            // Main path vs side path decision
            if (!hasMainPath && roll < _rules.MainPathProbability)
            {
                decisions[direction] = BranchType.MainPath;
                hasMainPath = true;
            }
            else if (roll < _rules.SidePathProbability)
            {
                decisions[direction] = BranchType.SidePath;
            }
            else if (roll < _rules.DeadEndProbability)
            {
                decisions[direction] = BranchType.DeadEnd;
            }
            else
            {
                decisions[direction] = BranchType.None;
            }
        }

        // Ensure at least one exit if not at a forced dead end
        if (!decisions.Values.Any(b => b != BranchType.None))
        {
            var fallback = exits.First();
            decisions[fallback] = BranchType.MainPath;
        }

        return new BranchDecision
        {
            Position = position,
            ExitDecisions = decisions,
            IsDeadEnd = decisions.Values.All(b => b == BranchType.None || b == BranchType.DeadEnd)
        };
    }

    /// <summary>
    /// Generates dead end content for terminal rooms.
    /// </summary>
    public DeadEndContent GenerateDeadEndContent(
        Position3D position,
        DifficultyRating difficulty)
    {
        var roll = _random.NextFloatForPosition(position, "deadend_type");

        return roll switch
        {
            < 0.3f => DeadEndContent.TreasureCache,  // Good loot
            < 0.5f => DeadEndContent.MonsterLair,    // Tough fight
            < 0.7f => DeadEndContent.SecretShrine,   // Special interaction
            < 0.85f => DeadEndContent.TrapRoom,      // Dangerous
            _ => DeadEndContent.Empty                 // Nothing special
        };
    }
}

/// <summary>
/// Types of branch connections.
/// </summary>
public enum BranchType
{
    None,       // No exit in this direction
    MainPath,   // Primary progression route
    SidePath,   // Optional exploration
    DeadEnd,    // Terminates after 1-3 rooms
    Loop        // Connects back to existing room
}

/// <summary>
/// Result of branching decisions for a room.
/// </summary>
public readonly record struct BranchDecision
{
    public Position3D Position { get; init; }
    public IReadOnlyDictionary<Direction, BranchType> ExitDecisions { get; init; }
    public bool IsDeadEnd { get; init; }
}
```

### InfiniteDungeonService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing infinite procedural dungeon generation.
/// </summary>
public class InfiniteDungeonService
{
    private readonly IRoomGeneratorService _roomGenerator;
    private readonly BranchGeneratorService _branchGenerator;
    private readonly ContentPlacementService _contentPlacer;
    private readonly SeededRandomService _random;
    private readonly InfiniteRules _rules;

    /// <summary>
    /// Gets whether infinite mode is active.
    /// </summary>
    public bool IsInfiniteMode { get; private set; }

    /// <summary>
    /// Gets the current generation radius around the player.
    /// </summary>
    public int GenerationRadius => _rules.GenerationRadius;

    /// <summary>
    /// Enables infinite dungeon mode.
    /// </summary>
    public void EnableInfiniteMode(Dungeon dungeon)
    {
        IsInfiniteMode = true;
        _logger.LogInformation("Infinite dungeon mode enabled");
    }

    /// <summary>
    /// Disables infinite dungeon mode.
    /// </summary>
    public void DisableInfiniteMode()
    {
        IsInfiniteMode = false;
    }

    /// <summary>
    /// Ensures rooms exist around the player position.
    /// </summary>
    public void EnsureGeneratedAround(
        Dungeon dungeon,
        Position3D playerPosition)
    {
        if (!IsInfiniteMode) return;

        var toGenerate = GetPositionsInRadius(playerPosition, GenerationRadius)
            .Where(p => !dungeon.HasRoomAt(p))
            .Where(p => ShouldGenerate(p, dungeon, playerPosition));

        foreach (var position in toGenerate)
        {
            GenerateRoomAt(dungeon, position);
        }

        // Cleanup distant rooms if memory management enabled
        if (_rules.EnableCleanup)
        {
            CleanupDistantRooms(dungeon, playerPosition);
        }
    }

    /// <summary>
    /// Generates a single room at the specified position.
    /// </summary>
    private void GenerateRoomAt(Dungeon dungeon, Position3D position)
    {
        var environment = DetermineEnvironment(position);
        var difficulty = DifficultyRating.Calculate(
            position,
            dungeon.StartingRoomPosition,
            RoomType.Standard, // Will be updated by template
            _rules.Scaling);

        var template = _roomGenerator.SelectTemplate(position, environment);
        var room = _roomGenerator.GenerateFromTemplate(template, position, environment);

        // Apply difficulty-based content
        FillRoomContent(room, template, difficulty, position, environment);

        // Determine branching
        var branches = _branchGenerator.DecideBranching(
            position,
            template.PotentialExits,
            dungeon.GetGraph());

        // Add room and connections
        dungeon.AddRoom(room);
        ConnectToBranches(dungeon, room, branches);
    }

    /// <summary>
    /// Removes rooms far from the player to manage memory.
    /// </summary>
    private void CleanupDistantRooms(Dungeon dungeon, Position3D playerPosition)
    {
        var cleanupRadius = _rules.CleanupRadius;
        var roomsToRemove = dungeon.Rooms.Values
            .Where(r => ManhattanDistance(r.Position3D, playerPosition) > cleanupRadius)
            .Where(r => !r.HasUncollectedLoot) // Don't remove rooms with loot
            .ToList();

        foreach (var room in roomsToRemove)
        {
            dungeon.RemoveRoom(room.Id);
            _logger.LogDebug("Cleaned up distant room at {Position}", room.Position3D);
        }
    }

    private IEnumerable<Position3D> GetPositionsInRadius(Position3D center, int radius)
    {
        for (int x = -radius; x <= radius; x++)
        for (int y = -radius; y <= radius; y++)
        for (int z = 0; z <= radius; z++) // Only generate deeper, not upward
        {
            if (Math.Abs(x) + Math.Abs(y) + z <= radius)
            {
                yield return new Position3D(center.X + x, center.Y + y, center.Z + z);
            }
        }
    }
}
```

### Branch Rules Configuration

```json
{
  "branchRules": {
    "mainPathProbability": 0.7,
    "sidePathProbability": 0.4,
    "deadEndProbability": 0.15,
    "loopProbability": 0.08,
    "maxDeadEndLength": 3,
    "minMainPathContinuation": 1,
    "deadEndContentChances": {
      "treasureCache": 0.3,
      "monsterLair": 0.2,
      "secretShrine": 0.2,
      "trapRoom": 0.15,
      "empty": 0.15
    }
  },
  "infiniteRules": {
    "generationRadius": 3,
    "cleanupRadius": 10,
    "enableCleanup": true,
    "maxGeneratedRooms": 500,
    "depthLimit": null
  }
}
```

### Acceptance Criteria

- [ ] BranchGeneratorService creates varied path structures
- [ ] Main path always continues (no accidental dead ends)
- [ ] Side paths branch off appropriately
- [ ] Dead ends contain interesting content
- [ ] Loops can optionally form
- [ ] InfiniteDungeonService generates rooms around player
- [ ] Infinite mode can be toggled
- [ ] Distant rooms are cleaned up (memory management)
- [ ] Generation respects radius limits
- [ ] ~23 unit tests pass

---

## Dependencies & Prerequisites

```
v0.1.0 (Expanded Dungeon & Z-Axis) - REQUIRED
    │
    └── Position3D, RoomType, RoomGeneratorService, MapRenderer ─────┐
                                                                      │
                                                                      ▼
v0.1.1 (Dynamic Room Generation)
    │
    ├── v0.1.1a: Room Template System ────────────────────────────────┐
    │       Dependencies: v0.1.0b (basic RoomGeneratorService)        │
    │                     v0.0.11a (EnvironmentContext, biomes)       │
    │                                                                 │
    ├── v0.1.1b: Seeded Generation ───────────────────────────────────┤
    │       Dependencies: v0.1.1a (template system)                   │
    │                     v0.1.0a (Position3D)                        │
    │                                                                 │
    ├── v0.1.1c: Difficulty & Content Scaling ────────────────────────┤
    │       Dependencies: v0.1.1a (template slots)                    │
    │                     v0.1.1b (seeded random)                     │
    │                     v0.0.9 (TierDefinition, LootService)        │
    │                                                                 │
    └── v0.1.1d: Branch Generation & Infinite Mode ───────────────────┘
            Dependencies: v0.1.1a, v0.1.1b, v0.1.1c
```

**Note:** Phases are sequential - each depends on prior phases within v0.1.1.

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.1.1a | ~6 | ~3 | ~20 | High |
| v0.1.1b | ~2 | ~3 | ~22 | Medium |
| v0.1.1c | ~4 | ~4 | ~25 | High |
| v0.1.1d | ~4 | ~3 | ~23 | High |
| **Total** | **~16** | **~13** | **~90** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Template complexity overwhelming | High | Medium | Start simple, iterate |
| Seeded generation not truly reproducible | High | Low | Extensive testing |
| Difficulty scaling feels unfair | Medium | Medium | Playtesting, tuning |
| Infinite mode memory issues | Medium | Medium | Cleanup system, limits |
| Branch generation creates boring layouts | Medium | Medium | Varied content, tuning |

---

## Design Decisions

### Template System

| Decision | Value | Notes |
|----------|-------|-------|
| **Template storage** | JSON configuration | Easy to mod/extend |
| **Slot filling** | Probability-based | Controlled randomness |
| **Description patterns** | Descriptor pool refs | Consistent with v0.0.11 |
| **Template selection** | Weighted by context | Biome/depth appropriate |

### Seeding System

| Decision | Value | Notes |
|----------|-------|-------|
| **Seed format** | Alphanumeric 8-char | Human-shareable |
| **Sub-seed derivation** | Hash-based | Deterministic |
| **Random state** | Per-position caching | Performance |
| **Master seed storage** | Dungeon entity | Persists with save |

### Difficulty Scaling

| Decision | Value | Notes |
|----------|-------|-------|
| **Difficulty range** | 1-100 | Clear numeric scale |
| **Primary factors** | Depth + Distance | Exploration-based |
| **Room type modifiers** | Multiplicative | Stacking bonuses |
| **Monster scaling** | Tier + Level bonus | Two dimensions |

### Infinite Mode

| Decision | Value | Notes |
|----------|-------|-------|
| **Generation trigger** | Player proximity | Lazy generation |
| **Generation radius** | 3 rooms | Balance memory/exploration |
| **Cleanup enabled** | Configurable | Optional memory management |
| **Depth limit** | None (infinite) | True endless |

---

## Files Summary

### Files to Create (New)

| Phase | File | Purpose |
|-------|------|---------|
| 1a | `RoomTemplate.cs` | Template entity |
| 1a | `TemplateSlot.cs` | Slot value object |
| 1a | `SlotType.cs` | Slot type enum |
| 1a | `TemplateSelectionService.cs` | Template selection |
| 1a | `TemplateValidationService.cs` | Template validation |
| 1a | Enhanced `room-templates.json` | Full templates |
| 1b | `SeededRandomService.cs` | Reproducible random |
| 1c | `DifficultyRating.cs` | Difficulty value object |
| 1c | `ContentPlacementService.cs` | Content placement |
| 1c | `scaling-rules.json` | Scaling configuration |
| 1d | `BranchGeneratorService.cs` | Branch generation |
| 1d | `InfiniteDungeonService.cs` | Infinite mode |
| 1d | `branch-rules.json` | Branch configuration |

### Files to Modify

| Phase | File | Changes |
|-------|------|---------|
| 1a | `RoomGeneratorService.cs` | Template-based generation |
| 1a | `IConfigurationProvider.cs` | Template loading |
| 1b | `Dungeon.cs` | Seed property |
| 1b | `GameSessionService.cs` | Seed commands |
| 1c | `Room.cs` | DifficultyRating property |
| 1c | `MonsterService.cs` | Level scaling |
| 1c | `LootService.cs` | Quality scaling |
| 1d | `GameSessionService.cs` | Infinite mode toggle |
| 1d | `Dungeon.cs` | Room removal support |

---

## Final Metrics

| Metric | Before v0.1.1 | After v0.1.1 |
|--------|---------------|--------------|
| Room templates | Basic patterns | Full slot-based system |
| Template slots | 0 | 7 types |
| Seed support | None | Full reproducibility |
| Difficulty system | None | Position-based rating |
| Content placement | Random | Difficulty-scaled |
| Branching types | Linear | 5 types |
| Infinite mode | No | Yes |
| Generation radius | Fixed | Configurable |
| Unit tests (generation) | ~25 | ~115 |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.1.1a Design Spec** - Create template system specification
3. **Implement v0.1.1a** - Build template infrastructure
4. **v0.1.1b Design Spec** - Create seeding specification
5. **Implement v0.1.1b** - Build reproducible generation
6. **v0.1.1c Design Spec** - Create scaling specification
7. **Implement v0.1.1c** - Build difficulty and content systems
8. **v0.1.1d Design Spec** - Create infinite mode specification
9. **Implement v0.1.1d** - Build branching and infinite generation

---

*This scope breakdown establishes a comprehensive dynamic generation system. Room templates provide structured variety, seeded generation enables reproducibility and sharing, difficulty scaling creates progressive challenge, and infinite mode delivers unlimited replayability. Together, these features transform procedural generation into a fully-featured randomization engine.*
