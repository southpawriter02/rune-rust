# v0.0.9b Design Specification: Damage Types & Resistances

**Version:** 0.0.9b
**Phase Name:** Damage Types & Resistances
**Parent Version:** v0.0.9 (Monster Variety & Loot)
**Prerequisites:** v0.0.9a Complete (Monster Definitions)
**Estimated Tests:** ~15 unit tests

---

## 1. Overview

### 1.1 Purpose

Formalize the damage type system and add resistance/vulnerability mechanics to creatures. Damage types affect how much damage is dealt based on target resistances, creating strategic depth in combat through elemental matchups and creature weaknesses.

### 1.2 Scope

**In Scope:**
- `DamageTypeDefinition` entity loaded from JSON configuration
- `DamageResistances` value object for tracking resistance percentages
- `DamageCalculationService` for applying resistance modifiers to damage
- `config/damage-types.json` with default damage types
- Integration with `MonsterDefinition` for monster resistances
- Integration with `Monster` entity for runtime resistances
- Player resistance support (foundation for equipment/buffs)
- Combat output showing resistance/vulnerability effects
- Examine command displaying significant resistances

**Out of Scope:**
- Weapon damage types (planned for v0.0.7, integrated here if available)
- Status effect damage integration (v0.0.6d provides strings only)
- Monster tiers (v0.0.9c)
- Monster traits (v0.0.9c)
- Loot tables (v0.0.9d)
- Equipment-based resistance bonuses (future version)

### 1.3 Design Goals

1. **Percentage-Based**: Resistances work as damage modifiers (-100% to +100%)
2. **Data-Driven**: All damage types defined in JSON configuration
3. **Strategic Depth**: Create meaningful choices around damage types
4. **Extensible**: Foundation for equipment resistances, elemental abilities
5. **Clear Feedback**: Combat output shows when resistances affect damage
6. **Backward Compatible**: Default "physical" damage when type not specified

---

## 2. Data Model

### 2.1 New Definitions

#### DamageTypeDefinition

A configuration-driven definition for a damage type.

**File:** `src/Core/RuneAndRust.Domain/Definitions/DamageTypeDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a type of damage that can be dealt in combat.
/// </summary>
/// <remarks>
/// Damage types are loaded from configuration and determine how
/// resistances affect damage calculations. Each weapon, ability,
/// or effect deals a specific type of damage.
/// </remarks>
public class DamageTypeDefinition
{
    /// <summary>
    /// Gets the unique identifier for this damage type.
    /// </summary>
    /// <example>"physical", "fire", "ice", "lightning"</example>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the display name of this damage type.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets the description of this damage type.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets the color used for displaying this damage type.
    /// </summary>
    /// <remarks>
    /// Used by the renderer for colored damage numbers and labels.
    /// Should be a valid Spectre.Console color name.
    /// </remarks>
    public string Color { get; init; } = "white";

    /// <summary>
    /// Gets the optional icon character for this damage type.
    /// </summary>
    /// <example>"üî•", "‚ùÑ", "‚ö°"</example>
    public string? Icon { get; init; }

    /// <summary>
    /// Gets the display sort order.
    /// </summary>
    public int SortOrder { get; init; } = 0;

    /// <summary>
    /// Creates a validated DamageTypeDefinition.
    /// </summary>
    public static DamageTypeDefinition Create(
        string id,
        string name,
        string description,
        string color = "white",
        string? icon = null,
        int sortOrder = 0)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new DamageTypeDefinition
        {
            Id = id.ToLowerInvariant(),
            Name = name,
            Description = description,
            Color = color,
            Icon = icon,
            SortOrder = sortOrder
        };
    }
}
```

### 2.2 New Value Objects

#### DamageResistances

An immutable value object representing a creature's resistances to damage types.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DamageResistances.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a creature's resistances to various damage types.
/// </summary>
/// <remarks>
/// Resistances are stored as percentages from -100 to +100:
/// - Positive values reduce damage (50 = 50% less damage taken)
/// - Negative values increase damage (-50 = 50% more damage taken, i.e., vulnerability)
/// - 100 = immunity (no damage taken)
/// - -100 = double damage taken
/// </remarks>
public readonly record struct DamageResistances
{
    private readonly Dictionary<string, int>? _resistances;

    /// <summary>
    /// Gets the resistance values as a read-only dictionary.
    /// </summary>
    public IReadOnlyDictionary<string, int> Values =>
        _resistances ?? new Dictionary<string, int>();

    /// <summary>
    /// Gets a DamageResistances with no resistances.
    /// </summary>
    public static DamageResistances None => new();

    /// <summary>
    /// Creates a new DamageResistances instance.
    /// </summary>
    /// <param name="resistances">Dictionary of damage type IDs to resistance percentages.</param>
    public DamageResistances(IReadOnlyDictionary<string, int>? resistances = null)
    {
        if (resistances == null || resistances.Count == 0)
        {
            _resistances = null;
        }
        else
        {
            _resistances = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            foreach (var kvp in resistances)
            {
                // Clamp values to -100 to 100
                var clampedValue = Math.Clamp(kvp.Value, -100, 100);
                _resistances[kvp.Key.ToLowerInvariant()] = clampedValue;
            }
        }
    }

    /// <summary>
    /// Gets the resistance percentage for a specific damage type.
    /// </summary>
    /// <param name="damageTypeId">The damage type ID.</param>
    /// <returns>The resistance percentage (-100 to 100), or 0 if not set.</returns>
    public int GetResistance(string damageTypeId)
    {
        if (string.IsNullOrWhiteSpace(damageTypeId))
            return 0;

        if (_resistances == null)
            return 0;

        return _resistances.TryGetValue(damageTypeId.ToLowerInvariant(), out var value)
            ? value
            : 0;
    }

    /// <summary>
    /// Gets the damage multiplier for a specific damage type.
    /// </summary>
    /// <param name="damageTypeId">The damage type ID.</param>
    /// <returns>
    /// A multiplier where:
    /// - 1.0 = normal damage (0% resistance)
    /// - 0.5 = half damage (50% resistance)
    /// - 0.0 = immune (100% resistance)
    /// - 1.5 = 50% more damage (-50% resistance, vulnerability)
    /// - 2.0 = double damage (-100% resistance)
    /// </returns>
    public float GetMultiplier(string damageTypeId)
    {
        var resistance = GetResistance(damageTypeId);
        // Convert resistance percentage to multiplier
        // 50% resistance = 0.5x damage
        // -50% resistance (vulnerability) = 1.5x damage
        return 1.0f - (resistance / 100.0f);
    }

    /// <summary>
    /// Checks if the creature is vulnerable to a damage type.
    /// </summary>
    /// <param name="damageTypeId">The damage type ID.</param>
    /// <returns>True if resistance is negative.</returns>
    public bool IsVulnerable(string damageTypeId)
    {
        return GetResistance(damageTypeId) < 0;
    }

    /// <summary>
    /// Checks if the creature is resistant to a damage type.
    /// </summary>
    /// <param name="damageTypeId">The damage type ID.</param>
    /// <returns>True if resistance is positive but not immune.</returns>
    public bool IsResistant(string damageTypeId)
    {
        var resistance = GetResistance(damageTypeId);
        return resistance > 0 && resistance < 100;
    }

    /// <summary>
    /// Checks if the creature is immune to a damage type.
    /// </summary>
    /// <param name="damageTypeId">The damage type ID.</param>
    /// <returns>True if resistance is 100%.</returns>
    public bool IsImmune(string damageTypeId)
    {
        return GetResistance(damageTypeId) >= 100;
    }

    /// <summary>
    /// Gets all damage types this creature has non-zero resistance to.
    /// </summary>
    /// <returns>Enumerable of damage type IDs with non-zero resistance.</returns>
    public IEnumerable<string> GetSignificantResistances()
    {
        if (_resistances == null)
            return Enumerable.Empty<string>();

        return _resistances
            .Where(kvp => kvp.Value != 0)
            .OrderByDescending(kvp => Math.Abs(kvp.Value))
            .Select(kvp => kvp.Key);
    }

    /// <summary>
    /// Combines two resistance sets, taking the higher resistance for each type.
    /// </summary>
    /// <param name="other">The other resistance set to combine with.</param>
    /// <returns>A new DamageResistances with combined values.</returns>
    public DamageResistances CombineWith(DamageResistances other)
    {
        var combined = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        // Add all from this
        foreach (var kvp in Values)
        {
            combined[kvp.Key] = kvp.Value;
        }

        // Combine with other (take higher resistance)
        foreach (var kvp in other.Values)
        {
            if (combined.TryGetValue(kvp.Key, out var existing))
            {
                combined[kvp.Key] = Math.Max(existing, kvp.Value);
            }
            else
            {
                combined[kvp.Key] = kvp.Value;
            }
        }

        return new DamageResistances(combined);
    }

    /// <summary>
    /// Creates a DamageResistances from a simple dictionary.
    /// </summary>
    public static DamageResistances FromDictionary(Dictionary<string, int> resistances)
    {
        return new DamageResistances(resistances);
    }
}
```

#### DamageInstance

A value object representing a specific instance of damage being dealt.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DamageInstance.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a single instance of damage being dealt.
/// </summary>
/// <param name="BaseDamage">The raw damage before resistance modifiers.</param>
/// <param name="DamageTypeId">The type of damage being dealt.</param>
/// <param name="FinalDamage">The damage after resistance calculations.</param>
/// <param name="ResistanceApplied">The resistance percentage that was applied.</param>
/// <param name="WasResisted">True if damage was reduced by resistance.</param>
/// <param name="WasVulnerable">True if damage was increased by vulnerability.</param>
/// <param name="WasImmune">True if the target was immune.</param>
public readonly record struct DamageInstance(
    int BaseDamage,
    string DamageTypeId,
    int FinalDamage,
    int ResistanceApplied,
    bool WasResisted,
    bool WasVulnerable,
    bool WasImmune)
{
    /// <summary>
    /// Gets whether any resistance modifier was applied.
    /// </summary>
    public bool HadResistanceEffect => WasResisted || WasVulnerable || WasImmune;

    /// <summary>
    /// Gets a description of the resistance effect.
    /// </summary>
    public string GetResistanceDescription()
    {
        if (WasImmune)
            return "Immune!";
        if (WasVulnerable)
            return $"Vulnerable! ({Math.Abs(ResistanceApplied)}% extra damage)";
        if (WasResisted)
            return $"Resisted ({ResistanceApplied}% reduced)";
        return string.Empty;
    }
}
```

### 2.3 Modified Entities

#### MonsterDefinition (v0.0.9a)

Add base resistances to the monster definition.

**File:** `src/Core/RuneAndRust.Domain/Definitions/MonsterDefinition.cs`

**Add property:**

```csharp
/// <summary>
/// Gets the base damage resistances for this monster type.
/// </summary>
/// <remarks>
/// Values are percentages from -100 (double damage) to +100 (immune).
/// Monsters without resistances will take full damage from all types.
/// </remarks>
public DamageResistances BaseResistances { get; init; } = DamageResistances.None;
```

**Update Create method signature to include:**

```csharp
public static MonsterDefinition Create(
    string id,
    string name,
    string description,
    string examineText,
    int baseHealth,
    int baseAttack,
    int baseDefense,
    int baseExperienceValue,
    AIBehavior aiBehavior = AIBehavior.Aggressive,
    IEnumerable<string>? tags = null,
    int spawnWeight = 100,
    int sortOrder = 0,
    DamageResistances? baseResistances = null)  // NEW
{
    // ... existing validation ...

    return new MonsterDefinition
    {
        // ... existing properties ...
        BaseResistances = baseResistances ?? DamageResistances.None
    };
}
```

#### Monster

Add resistances property to the runtime monster entity.

**File:** `src/Core/RuneAndRust.Domain/Entities/Monster.cs`

**Add property:**

```csharp
/// <summary>
/// Gets the monster's damage resistances.
/// </summary>
/// <remarks>
/// Populated from MonsterDefinition.BaseResistances when spawned.
/// May be modified by tier or traits in future versions.
/// </remarks>
public DamageResistances Resistances { get; private set; } = DamageResistances.None;
```

**Update constructor from definition:**

```csharp
/// <summary>
/// Creates a monster from a MonsterDefinition.
/// </summary>
internal Monster(
    string definitionId,
    string name,
    string description,
    int maxHealth,
    Stats stats,
    int experienceValue,
    DamageResistances resistances)  // NEW
{
    Id = Guid.NewGuid();
    DefinitionId = definitionId;
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Description = description ?? throw new ArgumentNullException(nameof(description));
    MaxHealth = maxHealth > 0 ? maxHealth : throw new ArgumentOutOfRangeException(nameof(maxHealth));
    Health = maxHealth;
    Stats = stats;
    ExperienceValue = experienceValue;
    Resistances = resistances;  // NEW
}
```

#### Player

Add resistances property to the player entity (foundation for future equipment-based resistances).

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

**Add property:**

```csharp
/// <summary>
/// Gets the player's current damage resistances.
/// </summary>
/// <remarks>
/// Base resistances are empty. In future versions, resistances
/// will come from equipped armor, active buffs, or racial traits.
/// </remarks>
public DamageResistances Resistances { get; private set; } = DamageResistances.None;

/// <summary>
/// Sets the player's resistances (used for buff/equipment application).
/// </summary>
/// <param name="resistances">The new resistance values.</param>
public void SetResistances(DamageResistances resistances)
{
    Resistances = resistances;
}
```

---

## 3. Service Interfaces

### 3.1 IDamageCalculationService

**File:** `src/Core/RuneAndRust.Application/Interfaces/IDamageCalculationService.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for calculating damage with resistance modifiers.
/// </summary>
public interface IDamageCalculationService
{
    /// <summary>
    /// Calculates final damage after applying resistance modifiers.
    /// </summary>
    /// <param name="baseDamage">The raw damage before modifiers.</param>
    /// <param name="damageTypeId">The type of damage being dealt.</param>
    /// <param name="targetResistances">The target's resistance values.</param>
    /// <returns>A DamageInstance with calculated values.</returns>
    DamageInstance CalculateDamage(
        int baseDamage,
        string damageTypeId,
        DamageResistances targetResistances);

    /// <summary>
    /// Gets a human-readable description of a resistance effect.
    /// </summary>
    /// <param name="damageTypeId">The damage type.</param>
    /// <param name="resistances">The target's resistances.</param>
    /// <returns>A description like "Resistant (50% reduced)" or "Vulnerable (2x damage)".</returns>
    string GetResistanceDescription(string damageTypeId, DamageResistances resistances);

    /// <summary>
    /// Gets the display label for a resistance value.
    /// </summary>
    /// <param name="resistance">The resistance percentage.</param>
    /// <returns>"Immune", "Resistant", "Vulnerable", or empty string.</returns>
    string GetResistanceLabel(int resistance);
}
```

### 3.2 IGameConfigurationProvider Updates

**File:** `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs`

**Add to interface:**

```csharp
/// <summary>
/// Gets all damage type definitions.
/// </summary>
/// <returns>Read-only list of damage type definitions.</returns>
IReadOnlyList<DamageTypeDefinition> GetDamageTypes();

/// <summary>
/// Gets a damage type definition by ID.
/// </summary>
/// <param name="damageTypeId">The damage type identifier.</param>
/// <returns>The damage type definition or null if not found.</returns>
DamageTypeDefinition? GetDamageTypeById(string damageTypeId);
```

---

## 4. Service Implementations

### 4.1 DamageCalculationService

**File:** `src/Core/RuneAndRust.Application/Services/DamageCalculationService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for calculating damage with resistance modifiers.
/// </summary>
public class DamageCalculationService : IDamageCalculationService
{
    private readonly ILogger<DamageCalculationService> _logger;
    private readonly IGameConfigurationProvider _configProvider;

    /// <summary>
    /// The default damage type when none is specified.
    /// </summary>
    public const string DefaultDamageType = "physical";

    public DamageCalculationService(
        ILogger<DamageCalculationService> logger,
        IGameConfigurationProvider configProvider)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
    }

    /// <inheritdoc />
    public DamageInstance CalculateDamage(
        int baseDamage,
        string damageTypeId,
        DamageResistances targetResistances)
    {
        // Default to physical if not specified
        var normalizedTypeId = string.IsNullOrWhiteSpace(damageTypeId)
            ? DefaultDamageType
            : damageTypeId.ToLowerInvariant();

        var resistance = targetResistances.GetResistance(normalizedTypeId);
        var multiplier = targetResistances.GetMultiplier(normalizedTypeId);

        // Calculate final damage
        var finalDamage = (int)Math.Round(baseDamage * multiplier);

        // Ensure minimum of 0 damage (immune), but no negative damage
        finalDamage = Math.Max(0, finalDamage);

        // Determine resistance status
        var wasImmune = resistance >= 100;
        var wasResisted = resistance > 0 && resistance < 100;
        var wasVulnerable = resistance < 0;

        _logger.LogDebug(
            "Damage calculation: {BaseDamage} {DamageType} damage, " +
            "{Resistance}% resistance = {Multiplier}x = {FinalDamage} final damage",
            baseDamage, normalizedTypeId, resistance, multiplier, finalDamage);

        return new DamageInstance(
            BaseDamage: baseDamage,
            DamageTypeId: normalizedTypeId,
            FinalDamage: finalDamage,
            ResistanceApplied: resistance,
            WasResisted: wasResisted,
            WasVulnerable: wasVulnerable,
            WasImmune: wasImmune);
    }

    /// <inheritdoc />
    public string GetResistanceDescription(string damageTypeId, DamageResistances resistances)
    {
        var resistance = resistances.GetResistance(damageTypeId);

        if (resistance >= 100)
            return "Immune";
        if (resistance > 0)
            return $"Resistant ({resistance}% reduced)";
        if (resistance < 0)
            return $"Vulnerable ({Math.Abs(resistance)}% extra damage)";

        return string.Empty;
    }

    /// <inheritdoc />
    public string GetResistanceLabel(int resistance)
    {
        if (resistance >= 100)
            return "Immune";
        if (resistance >= 75)
            return "Highly Resistant";
        if (resistance >= 50)
            return "Resistant";
        if (resistance >= 25)
            return "Slightly Resistant";
        if (resistance <= -75)
            return "Highly Vulnerable";
        if (resistance <= -50)
            return "Vulnerable";
        if (resistance <= -25)
            return "Slightly Vulnerable";

        return string.Empty;
    }
}
```

### 4.2 MonsterService Updates

**File:** `src/Core/RuneAndRust.Application/Services/MonsterService.cs`

**Update CreateMonsterFromDefinition method:**

```csharp
private Monster CreateMonsterFromDefinition(MonsterDefinition definition)
{
    var stats = new Stats(definition.BaseHealth, definition.BaseAttack, definition.BaseDefense);

    return new Monster(
        definition.Id,
        definition.Name,
        definition.Description,
        definition.BaseHealth,
        stats,
        definition.BaseExperienceValue,
        definition.BaseResistances  // NEW: Pass resistances from definition
    );
}
```

---

## 5. Configuration

### 5.1 JSON Schema

**File:** `config/damage-types.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "damageTypes": [
    {
      "id": "physical",
      "name": "Physical",
      "description": "Standard weapon damage from blunt or sharp weapons.",
      "color": "white",
      "icon": null,
      "sortOrder": 0
    },
    {
      "id": "fire",
      "name": "Fire",
      "description": "Burning heat damage from flames and explosions.",
      "color": "red",
      "icon": null,
      "sortOrder": 1
    },
    {
      "id": "ice",
      "name": "Ice",
      "description": "Freezing cold damage that can slow enemies.",
      "color": "cyan",
      "icon": null,
      "sortOrder": 2
    },
    {
      "id": "lightning",
      "name": "Lightning",
      "description": "Electrical damage that can chain to nearby targets.",
      "color": "yellow",
      "icon": null,
      "sortOrder": 3
    },
    {
      "id": "poison",
      "name": "Poison",
      "description": "Toxic damage that deals damage over time.",
      "color": "green",
      "icon": null,
      "sortOrder": 4
    },
    {
      "id": "holy",
      "name": "Holy",
      "description": "Divine radiant damage, especially effective against undead.",
      "color": "gold1",
      "icon": null,
      "sortOrder": 5
    },
    {
      "id": "dark",
      "name": "Dark",
      "description": "Shadow and necrotic damage from dark magic.",
      "color": "purple",
      "icon": null,
      "sortOrder": 6
    }
  ]
}
```

### 5.2 Monster Resistance Examples

**Update to `config/monsters.json`:**

```json
{
  "monsters": [
    {
      "id": "goblin",
      "name": "Goblin",
      "description": "A small, green creature with sharp teeth and beady eyes.",
      "examineText": "This goblin clutches a rusty dagger...",
      "baseHealth": 30,
      "baseAttack": 8,
      "baseDefense": 2,
      "baseExperienceValue": 25,
      "aiBehavior": "Aggressive",
      "tags": ["humanoid"],
      "spawnWeight": 100,
      "baseResistances": {}
    },
    {
      "id": "skeleton",
      "name": "Skeleton",
      "description": "An animated pile of bones held together by dark magic.",
      "examineText": "Dark magic holds these bones together...",
      "baseHealth": 25,
      "baseAttack": 10,
      "baseDefense": 1,
      "baseExperienceValue": 30,
      "aiBehavior": "Aggressive",
      "tags": ["undead"],
      "spawnWeight": 80,
      "baseResistances": {
        "physical": 25,
        "fire": -50,
        "ice": 0,
        "poison": 100,
        "holy": -50,
        "dark": 50
      }
    },
    {
      "id": "slime",
      "name": "Slime",
      "description": "A quivering mass of translucent, acidic gel.",
      "examineText": "This gelatinous creature pulses and wobbles...",
      "baseHealth": 40,
      "baseAttack": 4,
      "baseDefense": 0,
      "baseExperienceValue": 15,
      "aiBehavior": "Chaotic",
      "tags": ["ooze"],
      "spawnWeight": 40,
      "baseResistances": {
        "physical": 50,
        "fire": -25,
        "ice": -25,
        "lightning": -50,
        "poison": 100
      }
    },
    {
      "id": "fire_elemental",
      "name": "Fire Elemental",
      "description": "A living flame that crackles with intense heat.",
      "examineText": "Pure elemental fire given form and sentience...",
      "baseHealth": 45,
      "baseAttack": 14,
      "baseDefense": 2,
      "baseExperienceValue": 60,
      "aiBehavior": "Aggressive",
      "tags": ["elemental", "fire"],
      "spawnWeight": 20,
      "baseResistances": {
        "physical": 0,
        "fire": 100,
        "ice": -100,
        "poison": 100
      }
    }
  ]
}
```

### 5.3 Configuration DTOs

**File:** `src/Core/RuneAndRust.Application/Configuration/DamageTypeConfigurationDto.cs`

```csharp
using System.Text.Json.Serialization;

namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Root configuration object for damage-types.json.
/// </summary>
public class DamageTypeConfiguration
{
    [JsonPropertyName("damageTypes")]
    public List<DamageTypeDefinitionDto> DamageTypes { get; set; } = [];
}

/// <summary>
/// DTO for deserializing damage type definitions from JSON.
/// </summary>
public class DamageTypeDefinitionDto
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;

    [JsonPropertyName("name")]
    public string Name { get; set; } = string.Empty;

    [JsonPropertyName("description")]
    public string Description { get; set; } = string.Empty;

    [JsonPropertyName("color")]
    public string Color { get; set; } = "white";

    [JsonPropertyName("icon")]
    public string? Icon { get; set; }

    [JsonPropertyName("sortOrder")]
    public int SortOrder { get; set; } = 0;
}
```

**Update MonsterDefinitionDto:**

```csharp
// Add to existing MonsterDefinitionDto class
[JsonPropertyName("baseResistances")]
public Dictionary<string, int>? BaseResistances { get; set; }
```

### 5.4 JsonConfigurationProvider Updates

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`

**Add to implementation:**

```csharp
private List<DamageTypeDefinition>? _damageTypes;

/// <inheritdoc />
public IReadOnlyList<DamageTypeDefinition> GetDamageTypes()
{
    if (_damageTypes == null)
    {
        var config = LoadConfiguration<DamageTypeConfiguration>("damage-types.json");
        _damageTypes = config.DamageTypes.Select(MapToDamageTypeDefinition).ToList();
    }
    return _damageTypes;
}

/// <inheritdoc />
public DamageTypeDefinition? GetDamageTypeById(string damageTypeId)
{
    return GetDamageTypes().FirstOrDefault(d =>
        d.Id.Equals(damageTypeId, StringComparison.OrdinalIgnoreCase));
}

private static DamageTypeDefinition MapToDamageTypeDefinition(DamageTypeDefinitionDto dto)
{
    return DamageTypeDefinition.Create(
        dto.Id,
        dto.Name,
        dto.Description,
        dto.Color,
        dto.Icon,
        dto.SortOrder
    );
}

// Update MapToMonsterDefinition to include resistances:
private static MonsterDefinition MapToMonsterDefinition(MonsterDefinitionDto dto)
{
    var aiBehavior = Enum.TryParse<AIBehavior>(dto.AIBehavior, ignoreCase: true, out var behavior)
        ? behavior
        : AIBehavior.Aggressive;

    var resistances = dto.BaseResistances != null
        ? DamageResistances.FromDictionary(dto.BaseResistances)
        : DamageResistances.None;

    return MonsterDefinition.Create(
        dto.Id,
        dto.Name,
        dto.Description,
        dto.ExamineText,
        dto.BaseHealth,
        dto.BaseAttack,
        dto.BaseDefense,
        dto.BaseExperienceValue,
        aiBehavior,
        dto.Tags,
        dto.SpawnWeight,
        dto.SortOrder,
        resistances  // NEW
    );
}
```

---

## 6. Combat Integration

### 6.1 CombatService Updates

**File:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs`

The CombatService should be updated to use the DamageCalculationService:

```csharp
/// <summary>
/// Handles combat resolution between players and monsters.
/// </summary>
public class CombatService
{
    private readonly Random _random = new();
    private readonly ILogger<CombatService> _logger;
    private readonly IDamageCalculationService _damageCalculator;

    /// <summary>
    /// Creates a new combat service instance.
    /// </summary>
    public CombatService(
        ILogger<CombatService>? logger = null,
        IDamageCalculationService? damageCalculator = null)
    {
        _logger = logger ?? NullLogger<CombatService>.Instance;
        _damageCalculator = damageCalculator
            ?? throw new ArgumentNullException(nameof(damageCalculator));
    }

    /// <summary>
    /// Resolves a single round of combat with damage type support.
    /// </summary>
    public CombatResultWithResistances ResolveCombatRoundWithResistances(
        Player player,
        Monster monster,
        string playerDamageType = "physical")
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(monster);

        // Calculate base damage (attack vs defense + variance)
        var basePlayerDamage = CalculateBaseDamage(player.Stats.Attack, monster.Stats.Defense);

        // Apply resistance modifiers
        var playerDamageInstance = _damageCalculator.CalculateDamage(
            basePlayerDamage,
            playerDamageType,
            monster.Resistances);

        // Apply damage to monster
        var actualPlayerDamage = ApplyDamageToMonster(monster, playerDamageInstance.FinalDamage);

        // Monster counterattack (if alive)
        DamageInstance? monsterDamageInstance = null;
        var actualMonsterDamage = 0;

        if (monster.IsAlive)
        {
            var baseMonsterDamage = CalculateBaseDamage(monster.Stats.Attack, player.Stats.Defense);

            // Monsters deal physical damage by default
            // (future: could have monster damage type from definition)
            monsterDamageInstance = _damageCalculator.CalculateDamage(
                baseMonsterDamage,
                "physical",
                player.Resistances);

            actualMonsterDamage = ApplyDamageToPlayer(player, monsterDamageInstance.Value.FinalDamage);
        }

        return new CombatResultWithResistances(
            PlayerDamage: playerDamageInstance,
            ActualDamageDealt: actualPlayerDamage,
            MonsterDamage: monsterDamageInstance,
            ActualDamageReceived: actualMonsterDamage,
            MonsterDefeated: monster.IsDefeated,
            PlayerDefeated: player.IsDead);
    }

    private int CalculateBaseDamage(int attack, int defense)
    {
        var baseDamage = Math.Max(1, attack - defense);
        var variance = _random.Next(-2, 3);
        return Math.Max(1, baseDamage + variance);
    }

    private int ApplyDamageToMonster(Monster monster, int damage)
    {
        // Monster.TakeDamage already handles defense reduction
        // We pass in the resistance-modified damage directly
        var previousHealth = monster.Health;
        monster.TakeDirectDamage(damage);  // New method that doesn't apply defense again
        return previousHealth - monster.Health;
    }

    private int ApplyDamageToPlayer(Player player, int damage)
    {
        var previousHealth = player.Health;
        player.TakeDirectDamage(damage);  // New method
        return previousHealth - player.Health;
    }
}

/// <summary>
/// Combat result with resistance information.
/// </summary>
public record CombatResultWithResistances(
    DamageInstance PlayerDamage,
    int ActualDamageDealt,
    DamageInstance? MonsterDamage,
    int ActualDamageReceived,
    bool MonsterDefeated,
    bool PlayerDefeated);
```

### 6.2 New TakeDamage Methods

Add methods to Monster and Player for direct damage (post-resistance calculation):

**Monster.cs:**

```csharp
/// <summary>
/// Applies direct damage without defense reduction (used after resistance calculation).
/// </summary>
/// <param name="damage">The final damage amount after all modifiers.</param>
/// <returns>The actual damage dealt.</returns>
public int TakeDirectDamage(int damage)
{
    if (damage < 0) return 0;

    var actualDamage = damage;
    Health = Math.Max(0, Health - actualDamage);
    return actualDamage;
}
```

**Player.cs:**

```csharp
/// <summary>
/// Applies direct damage without defense reduction (used after resistance calculation).
/// </summary>
/// <param name="damage">The final damage amount after all modifiers.</param>
/// <returns>The actual damage dealt.</returns>
public int TakeDirectDamage(int damage)
{
    if (damage < 0) return 0;

    var actualDamage = damage;
    Health = Math.Max(0, Health - actualDamage);
    return actualDamage;
}
```

---

## 7. Rendering Changes

### 7.1 Combat Output with Resistances

**Update SpectreGameRenderer combat display:**

```csharp
public Task RenderCombatResultWithResistancesAsync(
    CombatResultWithResistances result,
    string playerName,
    string monsterName,
    CancellationToken ct = default)
{
    var sb = new StringBuilder();

    // Player attack
    var dmg = result.PlayerDamage;
    var damageType = _configProvider.GetDamageTypeById(dmg.DamageTypeId);
    var damageColor = damageType?.Color ?? "white";

    sb.AppendLine($"{playerName} attacks the {monsterName}!");

    if (dmg.WasImmune)
    {
        sb.AppendLine($"The {monsterName} is [bold]immune[/] to [{damageColor}]{damageType?.Name ?? dmg.DamageTypeId}[/] damage!");
    }
    else
    {
        sb.Append($"[{damageColor}]{result.ActualDamageDealt} {damageType?.Name ?? dmg.DamageTypeId} damage[/]");

        if (dmg.WasVulnerable)
        {
            sb.Append($" [red](Vulnerable! {Math.Abs(dmg.ResistanceApplied)}% extra)[/]");
        }
        else if (dmg.WasResisted)
        {
            sb.Append($" [dim](Resisted {dmg.ResistanceApplied}%)[/]");
        }

        sb.AppendLine("!");
    }

    // Monster defeated or counterattack
    if (result.MonsterDefeated)
    {
        sb.AppendLine($"[green]The {monsterName} has been defeated![/]");
    }
    else if (result.MonsterDamage.HasValue && result.ActualDamageReceived > 0)
    {
        sb.AppendLine($"The {monsterName} strikes back for [red]{result.ActualDamageReceived}[/] damage!");
    }

    if (result.PlayerDefeated)
    {
        sb.AppendLine($"[red]{playerName} has fallen in battle...[/]");
    }

    AnsiConsole.MarkupLine(sb.ToString());
    return Task.CompletedTask;
}
```

### 7.2 Examine Monster with Resistances

**Update examine output:**

```csharp
private string FormatMonsterExamination(Monster monster, MonsterDefinition? definition)
{
    var sb = new StringBuilder();
    sb.AppendLine($"=== {monster.Name} ===");

    if (definition != null && !string.IsNullOrEmpty(definition.ExamineText))
    {
        sb.AppendLine(definition.ExamineText);
        sb.AppendLine();

        if (definition.Tags.Count > 0)
        {
            sb.AppendLine($"Type: {string.Join(", ", definition.Tags)}");
        }
    }
    else
    {
        sb.AppendLine(monster.Description);
        sb.AppendLine();
    }

    sb.AppendLine($"Health: {monster.Health}/{monster.MaxHealth}");

    // Display significant resistances
    var significantResistances = monster.Resistances.GetSignificantResistances().ToList();
    if (significantResistances.Any())
    {
        sb.AppendLine();
        sb.AppendLine("Resistances:");
        foreach (var typeId in significantResistances)
        {
            var resistance = monster.Resistances.GetResistance(typeId);
            var damageType = _configProvider.GetDamageTypeById(typeId);
            var typeName = damageType?.Name ?? typeId;
            var color = damageType?.Color ?? "white";

            string label;
            if (resistance >= 100)
                label = "[bold]Immune[/]";
            else if (resistance > 0)
                label = $"[green]{resistance}% resistant[/]";
            else
                label = $"[red]Vulnerable ({Math.Abs(resistance)}% extra damage)[/]";

            sb.AppendLine($"  [{color}]{typeName}[/]: {label}");
        }
    }

    return sb.ToString();
}
```

### 7.3 Display Examples

**Combat with Vulnerability:**
```
Hero attacks the Skeleton!
12 Fire damage (Vulnerable! 50% extra)!
The Skeleton takes 12 damage. (HP: 25 -> 13)
```

**Combat with Resistance:**
```
Hero attacks the Slime!
5 Physical damage (Resisted 50%)!
The Slime takes 5 damage. (HP: 40 -> 35)
```

**Combat with Immunity:**
```
Hero attacks the Skeleton!
The Skeleton is immune to Poison damage!
```

**Examine with Resistances:**
```
=== Skeleton ===
Dark magic holds these bones together in a mockery of life.
Its hollow eye sockets glow with an eerie blue light.

Type: undead
Health: 25/25

Resistances:
  Poison: Immune
  Dark: 50% resistant
  Physical: 25% resistant
  Fire: Vulnerable (50% extra damage)
  Holy: Vulnerable (50% extra damage)
```

---

## 8. Default Damage Types

| ID | Name | Color | Description |
|----|------|-------|-------------|
| physical | Physical | white | Standard weapon damage |
| fire | Fire | red | Burning heat damage |
| ice | Ice | cyan | Freezing cold damage |
| lightning | Lightning | yellow | Electrical damage |
| poison | Poison | green | Toxic damage |
| holy | Holy | gold1 | Divine damage |
| dark | Dark | purple | Shadow/necrotic damage |

---

## 9. Default Monster Resistances

| Monster | Physical | Fire | Ice | Lightning | Poison | Holy | Dark |
|---------|----------|------|-----|-----------|--------|------|------|
| Goblin | 0% | 0% | 0% | 0% | 0% | 0% | 0% |
| Skeleton | 25% | -50% | 0% | 0% | 100% | -50% | 50% |
| Orc | 0% | 0% | 0% | 0% | 0% | 0% | 0% |
| Giant Spider | 0% | -25% | 0% | 0% | 100% | 0% | 0% |
| Slime | 50% | -25% | -25% | -50% | 100% | 0% | 0% |
| Fire Elemental | 0% | 100% | -100% | 0% | 100% | 0% | 0% |

*Positive = resistance (damage reduction), Negative = vulnerability (damage increase), 100% = immune*

---

## 10. Acceptance Criteria

### 10.1 Functional Requirements

- [ ] Damage type definitions load from `config/damage-types.json`
- [ ] At least 7 default damage types defined (physical, fire, ice, lightning, poison, holy, dark)
- [ ] `DamageResistances` correctly calculates damage multipliers
- [ ] Resistance reduces damage by percentage (50% resistance = 50% damage reduction)
- [ ] Vulnerability increases damage (‚àí50% resistance = 50% damage increase)
- [ ] Immunity (100% resistance) blocks all damage of that type
- [ ] Combat output displays resistance/vulnerability effects
- [ ] Examine command shows monster resistances
- [ ] MonsterDefinition supports baseResistances property
- [ ] Monster entity populated with resistances from definition
- [ ] Player entity has Resistances property (empty by default)
- [ ] Default damage type is "physical" when not specified

### 10.2 Non-Functional Requirements

- [ ] Configuration loading is performant (cached after first load)
- [ ] Invalid configuration produces clear error messages
- [ ] Services are testable with mock dependencies

---

## 11. Test Specifications

### 11.1 DamageResistances Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `GetResistance_ExistingType_ReturnsValue` | Known type returns correct resistance |
| `GetResistance_UnknownType_ReturnsZero` | Unknown type defaults to 0 |
| `GetMultiplier_PositiveResistance_ReducesDamage` | 50% resistance = 0.5x multiplier |
| `GetMultiplier_NegativeResistance_IncreasesDamage` | -50% resistance = 1.5x multiplier |
| `IsImmune_100Resistance_ReturnsTrue` | 100% resistance = immune |

### 11.2 DamageCalculationService Tests (~5 tests)

| Test Name | Description |
|-----------|-------------|
| `CalculateDamage_NoResistance_ReturnsBaseDamage` | 0% resistance = full damage |
| `CalculateDamage_50PercentResistance_HalvesDamage` | 50% resistance halves damage |
| `CalculateDamage_Immunity_ReturnsZero` | 100% resistance = 0 damage |
| `CalculateDamage_Vulnerability_IncreasesDamage` | -50% resistance = 150% damage |
| `CalculateDamage_DefaultsToPhysical` | Empty damage type uses physical |

### 11.3 Configuration Loading Tests (~3 tests)

| Test Name | Description |
|-----------|-------------|
| `GetDamageTypes_LoadsFromJson` | Configuration loads correctly |
| `GetDamageTypeById_ReturnsCorrectDefinition` | Lookup by ID works |
| `GetMonsters_LoadsResistances` | Monster resistances parsed correctly |

### 11.4 Integration Tests (~2 tests)

| Test Name | Description |
|-----------|-------------|
| `Combat_WithVulnerability_IncreasesActualDamage` | Combat correctly applies vulnerability |
| `ExamineMonster_ShowsResistances` | Examine displays resistance info |

---

## 12. Dependencies

### 12.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| MonsterDefinition | v0.0.9a | Required | Extended with BaseResistances |
| MonsterService | v0.0.9a | Required | Updated to pass resistances |
| Monster entity | v0.0.9a | Required | Extended with Resistances |
| Configuration system | v0.0.3 | Complete | JSON loading infrastructure |
| CombatService | v0.0.5 | Complete | Modified for resistance support |

### 12.2 External Dependencies

None new - uses existing System.Text.Json for configuration loading.

---

## 13. Files Summary

### 13.1 New Files

| File | Purpose |
|------|---------|
| `src/Core/RuneAndRust.Domain/Definitions/DamageTypeDefinition.cs` | Damage type entity |
| `src/Core/RuneAndRust.Domain/ValueObjects/DamageResistances.cs` | Resistance value object |
| `src/Core/RuneAndRust.Domain/ValueObjects/DamageInstance.cs` | Damage instance value object |
| `src/Core/RuneAndRust.Application/Interfaces/IDamageCalculationService.cs` | Service interface |
| `src/Core/RuneAndRust.Application/Services/DamageCalculationService.cs` | Service implementation |
| `src/Core/RuneAndRust.Application/Configuration/DamageTypeConfigurationDto.cs` | Configuration DTOs |
| `config/damage-types.json` | Damage type definitions |
| `tests/RuneAndRust.Domain.Tests/ValueObjects/DamageResistancesTests.cs` | Resistance tests |
| `tests/RuneAndRust.Application.Tests/Services/DamageCalculationServiceTests.cs` | Service tests |

### 13.2 Modified Files

| File | Changes |
|------|---------|
| `MonsterDefinition.cs` | Add BaseResistances property |
| `Monster.cs` | Add Resistances property, TakeDirectDamage method |
| `Player.cs` | Add Resistances property, SetResistances, TakeDirectDamage |
| `MonsterService.cs` | Pass resistances when spawning |
| `MonsterDefinitionDto.cs` | Add BaseResistances property |
| `IGameConfigurationProvider.cs` | Add GetDamageTypes, GetDamageTypeById |
| `JsonConfigurationProvider.cs` | Implement damage type and resistance loading |
| `CombatService.cs` | Integrate DamageCalculationService |
| `SpectreGameRenderer.cs` | Display resistance effects in combat and examine |
| `config/monsters.json` | Add resistance values to monsters |

---

## 14. Future Considerations

### 14.1 v0.0.9c Preparation

Monster tiers may modify resistances:
- Elite monsters could have reduced vulnerabilities
- Boss monsters could have increased resistances

### 14.2 v0.0.9d Preparation

No direct interaction with loot system.

### 14.3 Future Equipment Integration

When equipment system is enhanced:
- Armor could grant damage resistances
- Weapons could deal specific damage types
- Buffs could temporarily modify resistances

---

## 15. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking existing combat | Medium | High | Keep original TakeDamage, add TakeDirectDamage |
| Balance issues with resistances | High | Medium | Start conservative, iterate on values |
| Configuration complexity | Low | Medium | Clear JSON schema, validation |
| Performance impact | Low | Low | Simple percentage calculations |
| Missing default damage type | Low | Medium | Default to "physical" when empty |

---

*This design specification provides the foundation for elemental damage and creature resistances, creating strategic depth in combat encounters.*
