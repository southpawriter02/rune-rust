# v0.16.4b Design Specification: Container Loot Table Entity

## Document Information

| Field            | Value                                                                |
| ---------------- | -------------------------------------------------------------------- |
| Version          | v0.16.4b                                                             |
| Parent Version   | v0.16.4 - Container Loot Generation                                  |
| Epic             | v0.16.x - Advanced Loot & Proficiency Systems                        |
| Status           | Draft                                                                |
| Created          | 2025-01-27                                                           |
| Scope Breakdown  | [v0.16.4-scope-breakdown.md](v0.16.4-scope-breakdown.md)             |
| Previous Version | [v0.16.4a-design-specification.md](v0.16.4a-design-specification.md) |

---

## 1. Executive Summary

### 1.1 Overview

Version 0.16.4b introduces the **Container Loot Table Entity**, which tracks container contents and state. This sub-phase creates the `ContainerLootTable` entity, `ContainerContents` value object, and the `ContainerState` enum to manage the lifecycle of containers from discovery through looting.

### 1.2 Key Deliverables

| Category             | Count | Artifact              |
| -------------------- | ----- | --------------------- |
| Domain Entities      | 1     | `ContainerLootTable`  |
| Domain Value Objects | 1     | `ContainerContents`   |
| Domain Enums         | 1     | `ContainerState`      |
| Unit Tests           | ~2    | Entity behavior tests |

### 1.3 Success Metrics

- Container state transitions work correctly
- Contents generated on first access (lazy generation)
- Looted containers return empty on subsequent access
- Unit tests pass for entity behavior

---

## 2. Feature Overview

### 2.1 Feature Tree

```
v0.16.4b: Container Loot Table Entity
├── ContainerState Enum
│   ├── Undiscovered
│   ├── Discovered
│   ├── Locked
│   ├── Open
│   └── Looted
├── ContainerContents Value Object
│   ├── Items collection (IDs)
│   ├── Currency amount
│   └── Quality tier applied
└── ContainerLootTable Entity
    ├── Unique identifier
    ├── Container type reference
    ├── Current state
    ├── Contents (lazy-loaded)
    ├── Location reference
    └── State transition methods
```

### 2.2 Scope Boundaries

**In Scope:**

- `ContainerState` enum with 5 states
- `ContainerContents` value object for tracking loot
- `ContainerLootTable` entity with state management
- State transition logic
- Unit tests for entity behavior

**Out of Scope:**

- Biome modifiers (v0.16.4c)
- Loot generation logic (v0.16.4d)
- Persistence implementation (v0.16.4e)
- Room integration (v0.16.4f)

---

## 3. Architecture Diagrams

### 3.1 Component Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                      DOMAIN LAYER                                │
│                                                                  │
│  ┌─────────────────┐        ┌─────────────────────────────────┐ │
│  │ ContainerType   │        │      ContainerLootTable         │ │
│  │ (from v0.16.4a) │◄───────│      (Entity)                   │ │
│  └─────────────────┘        │                                 │ │
│                             │ • Guid Id                       │ │
│  ┌─────────────────┐        │ • ContainerType Type            │ │
│  │ ContainerState  │◄───────│ • ContainerState State          │ │
│  │ (Enum)          │        │ • ContainerContents? Contents   │ │
│  │                 │        │ • Guid? RoomId                  │ │
│  │ • Undiscovered  │        │ • DateTime? LootedAt            │ │
│  │ • Discovered    │        │                                 │ │
│  │ • Locked        │        │ + Discover()                    │ │
│  │ • Open          │        │ + Unlock()                      │ │
│  │ • Looted        │        │ + Open()                        │ │
│  └─────────────────┘        │ + Loot() → ContainerContents    │ │
│                             │ + SetContents()                 │ │
│                             └─────────────────────────────────┘ │
│                                          │                      │
│                                          ▼                      │
│                             ┌─────────────────────────────────┐ │
│                             │     ContainerContents           │ │
│                             │     (Value Object)              │ │
│                             │                                 │ │
│                             │ • IReadOnlyList<string> ItemIds │ │
│                             │ • int CurrencyAmount            │ │
│                             │ • int AppliedTier               │ │
│                             │                                 │ │
│                             │ + static Empty                  │ │
│                             │ + static Create()               │ │
│                             └─────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 State Machine Diagram

```
                    ┌─────────────────┐
                    │  UNDISCOVERED   │
                    │ (Hidden Cache)  │
                    └────────┬────────┘
                             │ Discover()
                             ▼
┌────────────────────────────────────────────────────┐
│                    DISCOVERED                       │
│              (Visible but not opened)               │
└──────────────┬──────────────┬──────────────────────┘
               │              │
     Requires  │              │ No lock
     key/pick  │              │
               ▼              ▼
      ┌────────────────┐    ┌────────────────┐
      │     LOCKED     │    │      OPEN      │
      │ (Needs unlock) │    │ (Contents visible)
      └───────┬────────┘    └───────┬────────┘
              │ Unlock()            │
              └──────────┬──────────┘
                         │ Loot()
                         ▼
              ┌────────────────────┐
              │      LOOTED        │
              │ (Already emptied)  │
              └────────────────────┘
```

### 3.3 Data Flow Diagram

```
┌──────────────────┐     ┌───────────────────┐     ┌─────────────────────┐
│ Room/Location    │     │ ContainerLoot     │     │ Player Inventory    │
│                  │────▶│ Table Entity      │────▶│                     │
│ Contains         │     │                   │     │ Receives items      │
│ container ref    │     │ Tracks state &    │     │ and currency        │
└──────────────────┘     │ contents          │     └─────────────────────┘
                         └───────────────────┘
                                  ▲
                                  │
                         ┌───────────────────┐
                         │ IContainerLoot    │
                         │ Service           │
                         │ (future v0.16.4d) │
                         │                   │
                         │ Generates contents│
                         └───────────────────┘
```

---

## 4. Feature Section: ContainerState Enum

### 4.1 Purpose

The `ContainerState` enum defines the 5 distinct lifecycle states a container can be in, from initial placement through looting.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/ContainerState.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the lifecycle states of a container.
/// </summary>
/// <remarks>
/// Containers progress through states from undiscovered (for hidden containers)
/// or discovered (for visible containers) through to looted.
/// Not all containers pass through every state.
/// </remarks>
public enum ContainerState
{
    /// <summary>
    /// Container has not been discovered by the player.
    /// </summary>
    /// <remarks>
    /// Applies to hidden containers requiring a perception check.
    /// Regular containers skip this state.
    /// </remarks>
    Undiscovered = 0,

    /// <summary>
    /// Container is visible but has not been interacted with.
    /// </summary>
    /// <remarks>
    /// Initial state for most containers.
    /// Player can see the container but has not opened it.
    /// </remarks>
    Discovered = 1,

    /// <summary>
    /// Container requires unlocking before it can be opened.
    /// </summary>
    /// <remarks>
    /// Applies to locked containers requiring a key or lockpicking skill.
    /// Not all containers have this state.
    /// </remarks>
    Locked = 2,

    /// <summary>
    /// Container is open and contents are visible.
    /// </summary>
    /// <remarks>
    /// Contents have been revealed but not yet taken.
    /// Player can see items and currency inside.
    /// </remarks>
    Open = 3,

    /// <summary>
    /// Container has been emptied of all contents.
    /// </summary>
    /// <remarks>
    /// Terminal state. Container cannot be looted again.
    /// Subsequent access returns empty contents.
    /// </remarks>
    Looted = 4
}
```

### 4.3 State Transition Rules

| From State   | To State   | Method       | Condition               |
| ------------ | ---------- | ------------ | ----------------------- |
| Undiscovered | Discovered | `Discover()` | Perception check passed |
| Discovered   | Locked     | (initial)    | Container has lock      |
| Discovered   | Open       | `Open()`     | Container has no lock   |
| Locked       | Open       | `Unlock()`   | Key used or lock picked |
| Open         | Looted     | `Loot()`     | Player takes contents   |

---

## 5. Feature Section: ContainerContents Value Object

### 5.1 Purpose

The `ContainerContents` value object encapsulates the loot within a container, including item references and currency.

### 5.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/ContainerContents.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the contents of a container, including items and currency.
/// </summary>
/// <remarks>
/// This value object is immutable and created by the container loot generation service.
/// Item IDs reference items in the game's item database.
/// </remarks>
/// <param name="ItemIds">Collection of item identifiers in the container.</param>
/// <param name="CurrencyAmount">Amount of currency (gold) in the container.</param>
/// <param name="AppliedTier">The quality tier applied to generated items.</param>
public readonly record struct ContainerContents(
    IReadOnlyList<string> ItemIds,
    int CurrencyAmount,
    int AppliedTier)
{
    /// <summary>
    /// Gets an empty contents instance representing a looted or empty container.
    /// </summary>
    public static ContainerContents Empty { get; } = new(
        Array.Empty<string>(),
        0,
        0);

    /// <summary>
    /// Gets whether this container has any items.
    /// </summary>
    public bool HasItems => ItemIds.Count > 0;

    /// <summary>
    /// Gets whether this container has any currency.
    /// </summary>
    public bool HasCurrency => CurrencyAmount > 0;

    /// <summary>
    /// Gets whether this container has any contents at all.
    /// </summary>
    public bool HasContents => HasItems || HasCurrency;

    /// <summary>
    /// Gets the total number of items in the container.
    /// </summary>
    public int ItemCount => ItemIds.Count;

    /// <summary>
    /// Creates a new ContainerContents instance with validation.
    /// </summary>
    /// <param name="itemIds">Collection of item identifiers.</param>
    /// <param name="currencyAmount">Amount of currency. Must be non-negative.</param>
    /// <param name="appliedTier">Quality tier applied (0-4). Must be in valid range.</param>
    /// <returns>A validated ContainerContents instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown when itemIds is null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">
    /// Thrown when currencyAmount is negative or appliedTier is out of range.
    /// </exception>
    public static ContainerContents Create(
        IReadOnlyList<string> itemIds,
        int currencyAmount,
        int appliedTier)
    {
        ArgumentNullException.ThrowIfNull(itemIds, nameof(itemIds));
        ArgumentOutOfRangeException.ThrowIfNegative(currencyAmount, nameof(currencyAmount));
        ArgumentOutOfRangeException.ThrowIfNegative(appliedTier, nameof(appliedTier));
        ArgumentOutOfRangeException.ThrowIfGreaterThan(appliedTier, 4, nameof(appliedTier));

        return new ContainerContents(itemIds, currencyAmount, appliedTier);
    }

    /// <summary>
    /// Creates contents with only currency (no items).
    /// </summary>
    /// <param name="amount">Currency amount.</param>
    /// <returns>ContainerContents with only currency.</returns>
    public static ContainerContents CurrencyOnly(int amount) =>
        Create(Array.Empty<string>(), amount, 0);

    /// <summary>
    /// Creates contents with only items (no currency).
    /// </summary>
    /// <param name="itemIds">Collection of item identifiers.</param>
    /// <param name="tier">Quality tier applied.</param>
    /// <returns>ContainerContents with only items.</returns>
    public static ContainerContents ItemsOnly(IReadOnlyList<string> itemIds, int tier) =>
        Create(itemIds, 0, tier);

    /// <inheritdoc />
    public override string ToString() =>
        $"Contents: {ItemCount} item(s), {CurrencyAmount} gold, Tier {AppliedTier}";
}
```

### 5.3 Design Decisions

| Decision                    | Rationale                                         |
| --------------------------- | ------------------------------------------------- |
| `readonly record struct`    | Immutable value semantics, efficient memory usage |
| String item IDs             | References items by ID, not direct item instances |
| Static `Empty` property     | Reusable instance for looted/empty containers     |
| Factory method validation   | Ensures all contents are valid at creation time   |
| Convenience factory methods | Common patterns (currency-only, items-only)       |

---

## 6. Feature Section: ContainerLootTable Entity

### 6.1 Purpose

The `ContainerLootTable` entity represents a container instance in the game world, tracking its type, state, contents, and location.

### 6.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Entities/ContainerLootTable.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a container instance in the game world with its loot state.
/// </summary>
/// <remarks>
/// The ContainerLootTable entity tracks the lifecycle of a container from
/// placement through looting. Contents are lazily generated on first access
/// via the container loot service.
/// </remarks>
public class ContainerLootTable : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this container.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the type of container.
    /// </summary>
    public ContainerType Type { get; private set; }

    /// <summary>
    /// Gets the current state of the container.
    /// </summary>
    public ContainerState State { get; private set; }

    /// <summary>
    /// Gets the contents of the container, if generated.
    /// </summary>
    /// <remarks>
    /// Null until contents are generated by the loot service.
    /// After looting, this contains the original contents for reference.
    /// </remarks>
    public ContainerContents? Contents { get; private set; }

    /// <summary>
    /// Gets the room ID where this container is located.
    /// </summary>
    public Guid? RoomId { get; private set; }

    /// <summary>
    /// Gets the timestamp when this container was looted.
    /// </summary>
    public DateTime? LootedAt { get; private set; }

    /// <summary>
    /// Gets whether this container has been looted.
    /// </summary>
    public bool IsLooted => State == ContainerState.Looted;

    /// <summary>
    /// Gets whether this container can be looted.
    /// </summary>
    public bool CanLoot => State == ContainerState.Open;

    /// <summary>
    /// Gets whether this container needs to be discovered first.
    /// </summary>
    public bool NeedsDiscovery => State == ContainerState.Undiscovered;

    /// <summary>
    /// Gets whether this container is locked.
    /// </summary>
    public bool IsLocked => State == ContainerState.Locked;

    /// <summary>
    /// Gets whether contents have been generated.
    /// </summary>
    public bool HasGeneratedContents => Contents.HasValue;

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private ContainerLootTable()
    {
    }

    /// <summary>
    /// Creates a new container loot table instance.
    /// </summary>
    /// <param name="type">The type of container.</param>
    /// <param name="initialState">The initial state of the container.</param>
    /// <param name="roomId">Optional room ID where container is located.</param>
    /// <returns>A new ContainerLootTable instance.</returns>
    public static ContainerLootTable Create(
        ContainerType type,
        ContainerState initialState = ContainerState.Discovered,
        Guid? roomId = null)
    {
        return new ContainerLootTable
        {
            Id = Guid.NewGuid(),
            Type = type,
            State = initialState,
            Contents = null,
            RoomId = roomId,
            LootedAt = null
        };
    }

    /// <summary>
    /// Creates a hidden container that must be discovered.
    /// </summary>
    /// <param name="type">The type of container (typically HiddenCache).</param>
    /// <param name="roomId">Optional room ID where container is located.</param>
    /// <returns>A new ContainerLootTable in Undiscovered state.</returns>
    public static ContainerLootTable CreateHidden(
        ContainerType type,
        Guid? roomId = null)
    {
        return Create(type, ContainerState.Undiscovered, roomId);
    }

    /// <summary>
    /// Creates a locked container that must be unlocked.
    /// </summary>
    /// <param name="type">The type of container.</param>
    /// <param name="roomId">Optional room ID where container is located.</param>
    /// <returns>A new ContainerLootTable in Locked state.</returns>
    public static ContainerLootTable CreateLocked(
        ContainerType type,
        Guid? roomId = null)
    {
        return Create(type, ContainerState.Locked, roomId);
    }

    /// <summary>
    /// Discovers a hidden container.
    /// </summary>
    /// <returns>True if discovery succeeded, false if not in Undiscovered state.</returns>
    public bool Discover()
    {
        if (State != ContainerState.Undiscovered)
        {
            return false;
        }

        State = ContainerState.Discovered;
        return true;
    }

    /// <summary>
    /// Unlocks a locked container.
    /// </summary>
    /// <returns>True if unlock succeeded, false if not in Locked state.</returns>
    public bool Unlock()
    {
        if (State != ContainerState.Locked)
        {
            return false;
        }

        State = ContainerState.Open;
        return true;
    }

    /// <summary>
    /// Opens a discovered container.
    /// </summary>
    /// <returns>True if open succeeded, false if not in Discovered state.</returns>
    public bool Open()
    {
        if (State != ContainerState.Discovered)
        {
            return false;
        }

        State = ContainerState.Open;
        return true;
    }

    /// <summary>
    /// Sets the generated contents for this container.
    /// </summary>
    /// <param name="contents">The generated contents.</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown if contents have already been generated.
    /// </exception>
    public void SetContents(ContainerContents contents)
    {
        if (Contents.HasValue)
        {
            throw new InvalidOperationException(
                "Container contents have already been generated.");
        }

        Contents = contents;
    }

    /// <summary>
    /// Loots the container, returning its contents.
    /// </summary>
    /// <returns>
    /// The container contents, or Empty if already looted or not open.
    /// </returns>
    public ContainerContents Loot()
    {
        if (State == ContainerState.Looted)
        {
            return ContainerContents.Empty;
        }

        if (State != ContainerState.Open)
        {
            return ContainerContents.Empty;
        }

        State = ContainerState.Looted;
        LootedAt = DateTime.UtcNow;

        return Contents ?? ContainerContents.Empty;
    }

    /// <summary>
    /// Gets the current contents for display purposes.
    /// </summary>
    /// <returns>
    /// The container contents, or Empty if looted or contents not generated.
    /// </returns>
    public ContainerContents GetDisplayContents()
    {
        if (State == ContainerState.Looted)
        {
            return ContainerContents.Empty;
        }

        return Contents ?? ContainerContents.Empty;
    }
}
```

### 6.3 Design Decisions

| Decision                    | Rationale                                            |
| --------------------------- | ---------------------------------------------------- |
| Lazy content generation     | Contents generated only when first accessed          |
| Nullable `Contents`         | Allows tracking whether contents have been generated |
| `LootedAt` timestamp        | Supports persistence and analytics                   |
| Boolean result methods      | State transitions return success/failure             |
| Factory methods for states  | Convenience for creating hidden/locked containers    |
| EF Core private constructor | Supports persistence without breaking encapsulation  |

---

## 7. Data Model Changes

### 7.1 New Enums

| Enum             | File Path                                             | Purpose                    |
| ---------------- | ----------------------------------------------------- | -------------------------- |
| `ContainerState` | `src/Core/RuneAndRust.Domain/Enums/ContainerState.cs` | Container lifecycle states |

### 7.2 New Value Objects

| Value Object        | File Path                                                       | Purpose                 |
| ------------------- | --------------------------------------------------------------- | ----------------------- |
| `ContainerContents` | `src/Core/RuneAndRust.Domain/ValueObjects/ContainerContents.cs` | Container loot contents |

### 7.3 New Entities

| Entity               | File Path                                                    | Purpose                       |
| -------------------- | ------------------------------------------------------------ | ----------------------------- |
| `ContainerLootTable` | `src/Core/RuneAndRust.Domain/Entities/ContainerLootTable.cs` | Container instance management |

---

## 8. Logging Specifications

| Component          | Level       | Event                                                             |
| ------------------ | ----------- | ----------------------------------------------------------------- |
| ContainerLootTable | Information | "Container {Id} state changed from {From} to {To}"                |
| ContainerLootTable | Debug       | "Container {Id} contents set: {ItemCount} items, {Currency} gold" |
| ContainerLootTable | Information | "Container {Id} looted at {Timestamp}"                            |
| ContainerLootTable | Warning     | "Attempted to loot container {Id} in {State} state"               |
| ContainerLootTable | Warning     | "Attempted to set contents on already-populated container {Id}"   |

---

## 9. Unit Testing Requirements

### 9.1 Test Summary

| Test Class                | Test Count | Focus Area               |
| ------------------------- | ---------- | ------------------------ |
| `ContainerContentsTests`  | ~1         | Value object validation  |
| `ContainerLootTableTests` | ~2         | Entity state transitions |

### 9.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/ContainerContentsTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class ContainerContentsTests
{
    [Test]
    public void Create_WithValidParameters_CreatesContents()
    {
        // Arrange
        var itemIds = new List<string> { "sword-iron", "potion-health" };

        // Act
        var contents = ContainerContents.Create(itemIds, 50, 2);

        // Assert
        contents.ItemIds.Should().BeEquivalentTo(itemIds);
        contents.CurrencyAmount.Should().Be(50);
        contents.AppliedTier.Should().Be(2);
        contents.HasItems.Should().BeTrue();
        contents.HasCurrency.Should().BeTrue();
        contents.HasContents.Should().BeTrue();
        contents.ItemCount.Should().Be(2);
    }

    [Test]
    public void Empty_ReturnsEmptyContents()
    {
        // Arrange & Act
        var empty = ContainerContents.Empty;

        // Assert
        empty.HasItems.Should().BeFalse();
        empty.HasCurrency.Should().BeFalse();
        empty.HasContents.Should().BeFalse();
        empty.ItemCount.Should().Be(0);
    }
}
```

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/ContainerLootTableTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Entities;

[TestFixture]
public class ContainerLootTableTests
{
    [Test]
    public void Loot_WhenOpen_ReturnsContentsAndSetsLooted()
    {
        // Arrange
        var container = ContainerLootTable.Create(ContainerType.SmallChest);
        container.Open();
        var contents = ContainerContents.Create(
            new List<string> { "sword-iron" },
            25,
            1);
        container.SetContents(contents);

        // Act
        var lootedContents = container.Loot();

        // Assert
        lootedContents.Should().Be(contents);
        container.State.Should().Be(ContainerState.Looted);
        container.LootedAt.Should().NotBeNull();
    }

    [Test]
    public void Loot_WhenAlreadyLooted_ReturnsEmpty()
    {
        // Arrange
        var container = ContainerLootTable.Create(ContainerType.SmallChest);
        container.Open();
        container.SetContents(ContainerContents.Create(
            new List<string> { "sword-iron" },
            25,
            1));
        container.Loot(); // First loot

        // Act
        var secondLoot = container.Loot();

        // Assert
        secondLoot.Should().Be(ContainerContents.Empty);
        container.IsLooted.Should().BeTrue();
    }
}
```

---

## 10. Use Cases

### UC-001: Open and Loot Container

| Field   | Value                                                                                                                                                                                          |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Actor   | Player                                                                                                                                                                                         |
| Trigger | Player interacts with container                                                                                                                                                                |
| Flow    | 1. Player approaches discovered container<br>2. Player opens container<br>3. System generates contents (via loot service)<br>4. Player loots container<br>5. Contents transferred to inventory |
| Outcome | Player receives items and currency, container marked as looted                                                                                                                                 |

### UC-002: Discover Hidden Container

| Field   | Value                                                                                                                                                               |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Actor   | Player                                                                                                                                                              |
| Trigger | Player passes perception check                                                                                                                                      |
| Flow    | 1. Player in room with hidden container<br>2. Perception check succeeds<br>3. Container transitions from Undiscovered to Discovered<br>4. Container becomes visible |
| Outcome | Hidden container now available for interaction                                                                                                                      |

### UC-003: Access Already Looted Container

| Field   | Value                                                                         |
| ------- | ----------------------------------------------------------------------------- |
| Actor   | Player                                                                        |
| Trigger | Player interacts with looted container                                        |
| Flow    | 1. Player interacts with looted container<br>2. System returns empty contents |
| Outcome | No items or currency received                                                 |

---

## 11. Deliverable Checklist

### 11.1 Domain Layer

- [ ] `ContainerState` enum (`src/Core/RuneAndRust.Domain/Enums/ContainerState.cs`)
- [ ] `ContainerContents` value object (`src/Core/RuneAndRust.Domain/ValueObjects/ContainerContents.cs`)
- [ ] `ContainerLootTable` entity (`src/Core/RuneAndRust.Domain/Entities/ContainerLootTable.cs`)

### 11.2 Tests

- [ ] `ContainerContentsTests` (`tests/RuneAndRust.Domain.UnitTests/ValueObjects/ContainerContentsTests.cs`)
- [ ] `ContainerLootTableTests` (`tests/RuneAndRust.Domain.UnitTests/Entities/ContainerLootTableTests.cs`)

---

## 12. Acceptance Criteria

### 12.1 Functional Criteria

| ID    | Criterion                                              | Verification |
| ----- | ------------------------------------------------------ | ------------ |
| AC-01 | Container generates contents on first access           | Unit test    |
| AC-02 | Looted container returns empty on subsequent access    | Unit test    |
| AC-03 | State transitions follow defined rules                 | Unit test    |
| AC-04 | Hidden containers require discovery before interaction | Unit test    |
| AC-05 | Locked containers require unlock before opening        | Unit test    |

### 12.2 Quality Criteria

| ID    | Criterion                      | Verification    |
| ----- | ------------------------------ | --------------- |
| QC-01 | All code has XML documentation | Code inspection |
| QC-02 | ~2 unit tests pass             | Test execution  |
| QC-03 | Entity follows domain patterns | Code review     |

---

## 13. Dependencies

### 13.1 Prerequisites

| Dependency | Description                       | Status   |
| ---------- | --------------------------------- | -------- |
| v0.16.4a   | ContainerType enum                | Complete |
| v0.16.0    | QualityTier enum (tier 0-4 scale) | Complete |

### 13.2 Provides To

| Consumer | Description                            |
| -------- | -------------------------------------- |
| v0.16.4d | ContainerLootService uses entity       |
| v0.16.4e | Persistence saves/loads entity         |
| v0.16.4f | Room integration references containers |

---

## 14. Future Considerations

### 14.1 Deferred to v0.16.4c

- `BiomeLootModifiers` value object (affects tier and quantity)

### 14.2 Deferred to v0.16.4d

- `IContainerLootService` interface
- Content generation logic calling `SetContents()`

### 14.3 Deferred to v0.16.4e

- Entity persistence via repository
- Loading container state from database

### 14.4 Potential Future Enhancements

- Trapped containers (trap check before opening)
- Container respawning for farming areas
- Partial looting (take some items, leave others)
