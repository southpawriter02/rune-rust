# v0.4.1a Implementation Plan: Core Trap System

**Version:** 0.4.1a
**Parent:** v0.4.1 (Traps & Environmental Hazards)
**Prerequisites:** v0.4.0c Complete (Activation & Destruction)
**Status:** Ready for Implementation
**Target Tests:** ~1463 -> ~1500 (+37 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Establish the foundational `Trap` entity with state management, trigger type definitions, and Room integration. This phase creates the base infrastructure for the trap system that subsequent phases (v0.4.1b/c) will extend with detection mechanics, disarm systems, effects, and environmental hazards.

### Scope

**In Scope:**
- `TrapState` enum (Hidden, Detected, Triggered, Disarmed, Broken)
- `TriggerType` enum (Step, Touch, Open, Proximity, Tripwire)
- `Trap` entity with state tracking and trigger configuration
- `TrapDefinition` for JSON configuration
- `TrapTriggerResult` and `TrapDetectionResult` value objects
- `Room.Traps` collection and management methods
- `ITrapService` interface and `TrapService` implementation
- Trap visibility in room descriptions (detected traps only)
- Configuration schema and sample trap definitions
- Basic examine integration for detected traps
- ~35-37 comprehensive unit tests

**Out of Scope:**
- Trap detection dice checks (v0.4.1b)
- Trap disarm mechanics (v0.4.1b)
- Trap effects (damage, status effects, alerts) (v0.4.1b)
- Trapped containers integration (v0.4.1b)
- Environmental hazards (v0.4.1c)
- Hazard zones (v0.4.1c)
- Saving throws (v0.4.1c)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Trap collection on Room | Separate from Interactables | Clean separation of concerns, traps are hidden dangers not ordinary objects |
| TrapState enum | 5 states | Mirrors InteractiveObject pattern but tailored for traps |
| TriggerType enum | 5 types | Covers common D&D-style triggers, extensible for future |
| Keywords for trap lookup | List<string> | Consistent with existing interactable keyword pattern |
| Reset mechanics | Turn-based countdown | Consistent with button reset from v0.4.0c |

---

## Dependencies from Previous Phases

### Dependencies from v0.4.0c (Activation & Destruction)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `ObjectState` | `Domain/Enums/ObjectState.cs` | Pattern reference for state management |
| `InteractiveObject` | `Domain/Entities/InteractiveObject.cs` | Pattern reference for entity design |
| `DestructibleProperties` | `Domain/ValueObjects/DestructibleProperties.cs` | Pattern reference for value object design |
| `IInteractionService` | `Application/Interfaces/IInteractionService.cs` | Pattern reference for service interface |
| `InteractionService` | `Application/Services/InteractionService.cs` | Pattern reference, integration point |

### Dependencies from v0.4.0a/b (Interactive Objects Core & Containers)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Room.Interactables` | `Domain/Entities/Room.cs` | Pattern for adding Traps collection |
| `Room.AddInteractable()` | `Domain/Entities/Room.cs` | Pattern for AddTrap method |
| `Room.GetInteractableByKeyword()` | `Domain/Entities/Room.cs` | Pattern for GetTrapByKeyword method |
| `InteractionService.GetRoomObjectsDescription()` | `Application/Services/InteractionService.cs` | Pattern for GetRoomTrapsDescription |

### Dependencies from Existing Codebase

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `IEntity` | `Domain/Interfaces/IEntity.cs` | Base interface for Trap entity |
| `Room` | `Domain/Entities/Room.cs` | Host for Traps collection |
| `ILogger<T>` | Microsoft.Extensions.Logging | Structured logging in TrapService |

---

## Current System Analysis

### Existing Room Entity

**Location:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

**Current Collections:**
```
Room
├── _items: List<Item>           → Items property
├── _monsters: List<Monster>     → Monsters property
├── _interactables: List<InteractiveObject> → Interactables property
├── _exits: Dictionary<Direction, RoomExit>
├── _hiddenItems: List<HiddenItem>
└── (NEW) _traps: List<Trap>     → Traps property
```

**Pattern to Follow:**
```csharp
// Existing interactables pattern in Room.cs
private readonly List<InteractiveObject> _interactables = new();
public IReadOnlyList<InteractiveObject> Interactables => _interactables;
public bool HasInteractables => _interactables.Count > 0;

public void AddInteractable(InteractiveObject interactable)
{
    ArgumentNullException.ThrowIfNull(interactable);
    _interactables.Add(interactable);
}
```

### New Trap Integration Flow

```
Room with Traps
    ├── Room.Traps collection (IReadOnlyList<Trap>)
    │   ├── AddTrap(Trap)
    │   ├── RemoveTrap(Trap)
    │   ├── GetTrapByKeyword(string)
    │   ├── GetVisibleTraps()
    │   ├── GetHiddenTraps()
    │   ├── GetActiveTraps()
    │   ├── GetTrapsByTriggerType(TriggerType)
    │   └── GetTrapAttachedTo(string objectId)
    │
    ├── TrapService
    │   ├── GetRoomTrapsDescription(Room) → Visible traps for room display
    │   ├── FindTrap(Room, keyword) → Lookup by keyword
    │   ├── ExamineTrap(Trap) → Detailed description
    │   ├── DetectTrap(Trap) → Mark as detected
    │   ├── DisarmTrap(Trap) → Mark as disarmed
    │   ├── TriggerTrap(Trap) → Trigger and return result
    │   ├── CheckStepTraps(Room) → Check for step triggers
    │   ├── CheckOpenTrap(Room, objectId) → Check for open triggers
    │   ├── ProcessRoomTurnTick(Room) → Handle resets
    │   └── GetRoomTrapSummary(Room) → Statistics
    │
    └── GameSessionService Integration (future)
        └── Examine command checks for traps
```

---

## Detailed Implementation

### Domain Layer

#### 1. TrapState.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/TrapState.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the current state of a trap.
/// </summary>
/// <remarks>
/// <para>Trap state follows a state machine with the following transitions:</para>
/// <code>
/// Hidden -> Detected (via detection check)
/// Hidden -> Triggered (if not detected first)
/// Detected -> Triggered (failed disarm or stepped on)
/// Detected -> Disarmed (successful disarm)
/// Hidden/Detected -> Broken (destroyed by force)
/// Triggered -> Hidden (if trap resets)
/// </code>
/// <para>Terminal states are Disarmed and Broken. Triggered is terminal unless Resets=true.</para>
/// </remarks>
public enum TrapState
{
    /// <summary>
    /// Trap is hidden and has not been detected.
    /// Players cannot see or interact with the trap.
    /// </summary>
    Hidden,

    /// <summary>
    /// Trap has been detected but not yet triggered or disarmed.
    /// Players can see and attempt to disarm the trap.
    /// </summary>
    Detected,

    /// <summary>
    /// Trap has been triggered and its effect has occurred.
    /// Most traps become inert after triggering unless they reset.
    /// </summary>
    Triggered,

    /// <summary>
    /// Trap has been successfully disarmed.
    /// The trap is safe and cannot trigger.
    /// </summary>
    Disarmed,

    /// <summary>
    /// Trap has been broken or destroyed.
    /// Similar to Disarmed but through force rather than skill.
    /// </summary>
    Broken
}
```

#### 2. TriggerType.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/TriggerType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines how a trap is triggered.
/// </summary>
/// <remarks>
/// <para>Different trigger types activate under different conditions:</para>
/// <list type="bullet">
/// <item><description>Step - Movement into trap's location</description></item>
/// <item><description>Touch - Physical interaction with trapped object</description></item>
/// <item><description>Open - Opening a container or door</description></item>
/// <item><description>Proximity - Getting within detection range</description></item>
/// <item><description>Tripwire - Crossing a specific line/path</description></item>
/// </list>
/// </remarks>
public enum TriggerType
{
    /// <summary>
    /// Triggered by stepping on (pressure plates, floor tiles).
    /// Activates when a character enters the trap's location.
    /// </summary>
    Step,

    /// <summary>
    /// Triggered by touching or physically interacting.
    /// Activates when a character touches the trapped object.
    /// </summary>
    Touch,

    /// <summary>
    /// Triggered by opening a container or door.
    /// Activates when the associated object is opened.
    /// </summary>
    Open,

    /// <summary>
    /// Triggered by entering a proximity radius.
    /// Activates when a character gets too close.
    /// </summary>
    Proximity,

    /// <summary>
    /// Triggered by crossing a tripwire line.
    /// Activates when a character crosses the wire's path.
    /// </summary>
    Tripwire
}
```

#### 3. Trap.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Entities/Trap.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a hidden danger that can be triggered by player actions.
/// </summary>
/// <remarks>
/// <para>Traps are hidden dangers placed in rooms that activate when certain
/// conditions are met. They differ from interactive objects in that they
/// start hidden and must be detected before the player can interact with them.</para>
/// <para>Key features:</para>
/// <list type="bullet">
/// <item><description>State machine: Hidden → Detected → Triggered/Disarmed</description></item>
/// <item><description>Detection DC for Perception checks</description></item>
/// <item><description>Disarm DC for skill checks</description></item>
/// <item><description>Optional reset behavior for repeating traps</description></item>
/// <item><description>Can be attached to interactive objects (trapped containers)</description></item>
/// </list>
/// </remarks>
public class Trap : IEntity
{
    // ===== Core Properties =====

    /// <summary>
    /// Gets the unique identifier for this trap instance.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the definition ID from configuration.
    /// </summary>
    /// <remarks>
    /// Links to the trap definition in traps.json for retrieving
    /// default values and effect configurations.
    /// </remarks>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name of this trap.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description shown when the trap is examined.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    // ===== State Properties =====

    /// <summary>
    /// Gets the current state of this trap.
    /// </summary>
    public TrapState State { get; private set; } = TrapState.Hidden;

    /// <summary>
    /// Gets how this trap is triggered.
    /// </summary>
    public TriggerType TriggerType { get; private set; }

    // ===== Detection & Disarm Properties =====

    /// <summary>
    /// Gets the difficulty class to detect this trap (Perception check).
    /// </summary>
    /// <remarks>
    /// Higher values make the trap harder to detect. Typically ranges from 8-20.
    /// </remarks>
    public int DetectionDC { get; private set; }

    /// <summary>
    /// Gets the difficulty class to disarm this trap.
    /// </summary>
    /// <remarks>
    /// Higher values make the trap harder to disarm. Typically ranges from 8-20.
    /// </remarks>
    public int DisarmDC { get; private set; }

    /// <summary>
    /// Gets whether this trap can be disarmed (some traps can only be avoided).
    /// </summary>
    public bool CanBeDisarmed { get; private set; } = true;

    // ===== Reset Properties =====

    /// <summary>
    /// Gets whether this trap resets after triggering.
    /// </summary>
    public bool Resets { get; private set; }

    /// <summary>
    /// Gets the number of turns until a reset trap rearms (-1 if not resetting).
    /// </summary>
    public int ResetDelay { get; private set; } = -1;

    /// <summary>
    /// Gets the current turns remaining until reset (-1 if not pending).
    /// </summary>
    public int TurnsUntilReset { get; private set; } = -1;

    // ===== Attachment Properties =====

    /// <summary>
    /// Gets the ID of the object this trap is attached to (for Open triggers).
    /// </summary>
    /// <remarks>
    /// Used for trapped containers and doors. The trap triggers when
    /// the attached object is opened.
    /// </remarks>
    public string? AttachedObjectId { get; private set; }

    /// <summary>
    /// Gets keywords that can be used to reference this trap when detected.
    /// </summary>
    public IReadOnlyList<string> Keywords { get; private set; } = Array.Empty<string>();

    // ===== Computed Properties =====

    /// <summary>
    /// Gets whether this trap is currently visible (detected or triggered).
    /// </summary>
    public bool IsVisible => State != TrapState.Hidden;

    /// <summary>
    /// Gets whether this trap is active and can still trigger.
    /// </summary>
    public bool IsActive => State == TrapState.Hidden || State == TrapState.Detected;

    /// <summary>
    /// Gets whether this trap has been neutralized (disarmed, broken, or triggered without reset).
    /// </summary>
    public bool IsNeutralized => State == TrapState.Disarmed ||
                                  State == TrapState.Broken ||
                                  (State == TrapState.Triggered && !Resets);

    /// <summary>
    /// Gets whether this trap is pending a reset.
    /// </summary>
    public bool IsPendingReset => State == TrapState.Triggered && Resets && TurnsUntilReset >= 0;

    // ===== Constructors =====

    /// <summary>
    /// Private parameterless constructor for Entity Framework Core.
    /// </summary>
    private Trap() { }

    // ===== Factory Methods =====

    /// <summary>
    /// Creates a new trap instance.
    /// </summary>
    /// <param name="definitionId">The definition ID from configuration.</param>
    /// <param name="name">The display name.</param>
    /// <param name="description">The examination description.</param>
    /// <param name="triggerType">How the trap is triggered.</param>
    /// <param name="detectionDC">Difficulty to detect.</param>
    /// <param name="disarmDC">Difficulty to disarm.</param>
    /// <param name="canBeDisarmed">Whether the trap can be disarmed.</param>
    /// <param name="resets">Whether the trap resets after triggering.</param>
    /// <param name="resetDelay">Turns until reset (if applicable).</param>
    /// <param name="attachedObjectId">ID of attached object (for Open triggers).</param>
    /// <param name="keywords">Keywords for referencing the trap.</param>
    /// <returns>A new Trap instance.</returns>
    /// <exception cref="ArgumentException">Thrown when definitionId or name is null/empty.</exception>
    public static Trap Create(
        string definitionId,
        string name,
        string description,
        TriggerType triggerType,
        int detectionDC,
        int disarmDC,
        bool canBeDisarmed = true,
        bool resets = false,
        int resetDelay = 3,
        string? attachedObjectId = null,
        IEnumerable<string>? keywords = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(definitionId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new Trap
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId.ToLowerInvariant(),
            Name = name,
            Description = description ?? string.Empty,
            TriggerType = triggerType,
            DetectionDC = Math.Max(1, detectionDC),
            DisarmDC = Math.Max(1, disarmDC),
            CanBeDisarmed = canBeDisarmed,
            Resets = resets,
            ResetDelay = resets ? Math.Max(1, resetDelay) : -1,
            AttachedObjectId = attachedObjectId,
            Keywords = keywords?.ToList() ?? new List<string> { name.ToLowerInvariant() }
        };
    }

    /// <summary>
    /// Creates a trap from a definition.
    /// </summary>
    /// <param name="definition">The trap definition.</param>
    /// <returns>A new Trap instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown when definition is null.</exception>
    public static Trap FromDefinition(TrapDefinition definition)
    {
        ArgumentNullException.ThrowIfNull(definition);

        return new Trap
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.Id.ToLowerInvariant(),
            Name = definition.Name,
            Description = definition.Description ?? string.Empty,
            TriggerType = definition.TriggerType,
            DetectionDC = definition.DetectionDC,
            DisarmDC = definition.DisarmDC,
            CanBeDisarmed = definition.CanBeDisarmed,
            Resets = definition.Resets,
            ResetDelay = definition.Resets ? definition.ResetDelay : -1,
            AttachedObjectId = definition.AttachedObjectId,
            Keywords = definition.Keywords.Count > 0
                ? definition.Keywords.ToList()
                : new List<string> { definition.Name.ToLowerInvariant() }
        };
    }

    // ===== State Transition Methods =====

    /// <summary>
    /// Marks the trap as detected.
    /// </summary>
    /// <returns>True if the state was changed.</returns>
    /// <remarks>
    /// Only transitions from Hidden to Detected. Returns false if already
    /// detected or in any other state.
    /// </remarks>
    public bool Detect()
    {
        if (State != TrapState.Hidden)
            return false;

        State = TrapState.Detected;
        return true;
    }

    /// <summary>
    /// Triggers the trap.
    /// </summary>
    /// <returns>True if the trap was triggered.</returns>
    /// <remarks>
    /// Only triggers if the trap is active (Hidden or Detected).
    /// If the trap resets, starts the reset countdown.
    /// </remarks>
    public bool Trigger()
    {
        if (!IsActive)
            return false;

        State = TrapState.Triggered;

        if (Resets)
        {
            TurnsUntilReset = ResetDelay;
        }

        return true;
    }

    /// <summary>
    /// Disarms the trap.
    /// </summary>
    /// <returns>True if the trap was disarmed.</returns>
    /// <remarks>
    /// Only disarms if the trap is Detected and CanBeDisarmed is true.
    /// Hidden traps must be detected first.
    /// </remarks>
    public bool Disarm()
    {
        if (!CanBeDisarmed)
            return false;

        if (State != TrapState.Detected)
            return false;

        State = TrapState.Disarmed;
        return true;
    }

    /// <summary>
    /// Breaks/destroys the trap.
    /// </summary>
    /// <returns>True if the trap was broken.</returns>
    /// <remarks>
    /// Breaks the trap through force, regardless of CanBeDisarmed.
    /// Cannot break already neutralized traps.
    /// </remarks>
    public bool Break()
    {
        if (IsNeutralized)
            return false;

        State = TrapState.Broken;
        return true;
    }

    /// <summary>
    /// Processes a turn tick for resetting traps.
    /// </summary>
    /// <returns>True if the trap reset this turn.</returns>
    /// <remarks>
    /// Decrements TurnsUntilReset each tick. When it reaches 0,
    /// the trap resets to Hidden state and can trigger again.
    /// </remarks>
    public bool ProcessTurnTick()
    {
        if (!IsPendingReset)
            return false;

        TurnsUntilReset--;

        if (TurnsUntilReset < 0)
        {
            TurnsUntilReset = -1;
            State = TrapState.Hidden;
            return true;
        }

        return false;
    }

    // ===== Utility Methods =====

    /// <summary>
    /// Checks if a keyword matches this trap.
    /// </summary>
    /// <param name="keyword">The keyword to check.</param>
    /// <returns>True if the keyword matches.</returns>
    public bool MatchesKeyword(string keyword)
    {
        if (string.IsNullOrWhiteSpace(keyword))
            return false;

        return Keywords.Any(k => k.Equals(keyword, StringComparison.OrdinalIgnoreCase)) ||
               Name.Contains(keyword, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets a display string for the trap's current state.
    /// </summary>
    /// <returns>A human-readable state description.</returns>
    public string GetStateDescription()
    {
        return State switch
        {
            TrapState.Hidden => "hidden",
            TrapState.Detected => "detected",
            TrapState.Triggered => Resets ? "triggered (resetting)" : "triggered",
            TrapState.Disarmed => "disarmed",
            TrapState.Broken => "broken",
            _ => "unknown"
        };
    }

    /// <inheritdoc />
    public override string ToString() => $"{Name} [{State}]";
}
```

#### 4. TrapDefinition.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Definitions/TrapDefinition.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration definition for a trap type loaded from JSON.
/// </summary>
/// <remarks>
/// <para>TrapDefinition serves as the configuration template for creating
/// trap instances. Definitions are loaded from traps.json and used to
/// instantiate Trap entities via Trap.FromDefinition().</para>
/// </remarks>
public class TrapDefinition
{
    /// <summary>
    /// Gets or sets the unique identifier for this definition.
    /// </summary>
    /// <remarks>
    /// Should be lowercase kebab-case (e.g., "pressure-plate-dart").
    /// </remarks>
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the display name of traps created from this definition.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the description shown when examining the trap.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets how this trap is triggered.
    /// </summary>
    public TriggerType TriggerType { get; set; }

    /// <summary>
    /// Gets or sets the difficulty class to detect this trap.
    /// </summary>
    public int DetectionDC { get; set; } = 10;

    /// <summary>
    /// Gets or sets the difficulty class to disarm this trap.
    /// </summary>
    public int DisarmDC { get; set; } = 12;

    /// <summary>
    /// Gets or sets whether this trap can be disarmed.
    /// </summary>
    public bool CanBeDisarmed { get; set; } = true;

    /// <summary>
    /// Gets or sets whether this trap resets after triggering.
    /// </summary>
    public bool Resets { get; set; }

    /// <summary>
    /// Gets or sets the turns until the trap resets.
    /// </summary>
    public int ResetDelay { get; set; } = 3;

    /// <summary>
    /// Gets or sets the ID of an object this trap is attached to.
    /// </summary>
    public string? AttachedObjectId { get; set; }

    /// <summary>
    /// Gets or sets keywords for referencing this trap.
    /// </summary>
    public List<string> Keywords { get; set; } = new();

    /// <summary>
    /// Gets or sets the effect configuration (processed in v0.4.1b).
    /// </summary>
    public TrapEffectDefinition? Effect { get; set; }
}

/// <summary>
/// Configuration for trap effects (placeholder for v0.4.1b).
/// </summary>
public class TrapEffectDefinition
{
    /// <summary>
    /// Gets or sets the damage dice expression (e.g., "2d6").
    /// </summary>
    public string? DamageDice { get; set; }

    /// <summary>
    /// Gets or sets the damage type (e.g., "piercing", "fire").
    /// </summary>
    public string? DamageType { get; set; }

    /// <summary>
    /// Gets or sets status effects applied by the trap.
    /// </summary>
    public List<string> StatusEffects { get; set; } = new();

    /// <summary>
    /// Gets or sets the save DC to reduce/avoid damage.
    /// </summary>
    public int? SaveDC { get; set; }

    /// <summary>
    /// Gets or sets the save type (e.g., "Agility", "Fortitude").
    /// </summary>
    public string? SaveType { get; set; }

    /// <summary>
    /// Gets or sets a message displayed when the trap triggers.
    /// </summary>
    public string? TriggerMessage { get; set; }
}
```

#### 5. TrapTriggerResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapTriggerResult.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of a trap trigger event.
/// </summary>
/// <remarks>
/// Provides factory methods for common result scenarios to ensure
/// consistent messaging and state reporting.
/// </remarks>
public readonly record struct TrapTriggerResult
{
    /// <summary>
    /// Gets whether the trap was triggered.
    /// </summary>
    public bool Triggered { get; init; }

    /// <summary>
    /// Gets the message to display to the player.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the trap that was triggered.
    /// </summary>
    public string TrapName { get; init; }

    /// <summary>
    /// Gets the trigger type that caused the activation.
    /// </summary>
    public TriggerType TriggerType { get; init; }

    /// <summary>
    /// Gets whether the trap will reset.
    /// </summary>
    public bool WillReset { get; init; }

    /// <summary>
    /// Creates a successful trigger result.
    /// </summary>
    public static TrapTriggerResult Success(
        string trapName,
        string message,
        TriggerType triggerType,
        bool willReset = false) => new()
    {
        Triggered = true,
        TrapName = trapName,
        Message = message,
        TriggerType = triggerType,
        WillReset = willReset
    };

    /// <summary>
    /// Creates a result for when no trap was triggered.
    /// </summary>
    public static TrapTriggerResult NoTrigger() => new()
    {
        Triggered = false,
        Message = string.Empty,
        TrapName = string.Empty,
        TriggerType = TriggerType.Step,
        WillReset = false
    };

    /// <summary>
    /// Creates a result for when the trap was already triggered.
    /// </summary>
    public static TrapTriggerResult AlreadyTriggered(string trapName) => new()
    {
        Triggered = false,
        TrapName = trapName,
        Message = $"The {trapName} has already been triggered.",
        TriggerType = TriggerType.Step,
        WillReset = false
    };

    /// <summary>
    /// Creates a result for when the trap was disarmed.
    /// </summary>
    public static TrapTriggerResult WasDisarmed(string trapName) => new()
    {
        Triggered = false,
        TrapName = trapName,
        Message = $"The {trapName} has been disarmed.",
        TriggerType = TriggerType.Step,
        WillReset = false
    };
}
```

#### 6. TrapDetectionResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapDetectionResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of attempting to detect traps.
/// </summary>
public readonly record struct TrapDetectionResult
{
    /// <summary>
    /// Gets whether any traps were detected.
    /// </summary>
    public bool DetectedAny { get; init; }

    /// <summary>
    /// Gets the message to display to the player.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the names of detected traps.
    /// </summary>
    public IReadOnlyList<string> DetectedTrapNames { get; init; }

    /// <summary>
    /// Gets the number of traps that remain hidden.
    /// </summary>
    public int HiddenCount { get; init; }

    /// <summary>
    /// Creates a result for successful detection.
    /// </summary>
    public static TrapDetectionResult Detected(
        IEnumerable<string> detectedNames,
        string message,
        int hiddenRemaining = 0) => new()
    {
        DetectedAny = true,
        DetectedTrapNames = detectedNames.ToList(),
        Message = message,
        HiddenCount = hiddenRemaining
    };

    /// <summary>
    /// Creates a result for no traps detected.
    /// </summary>
    public static TrapDetectionResult NoneDetected(string message, int hiddenCount = 0) => new()
    {
        DetectedAny = false,
        DetectedTrapNames = Array.Empty<string>(),
        Message = message,
        HiddenCount = hiddenCount
    };

    /// <summary>
    /// Creates a result for when no hidden traps exist.
    /// </summary>
    public static TrapDetectionResult NoHiddenTraps() => new()
    {
        DetectedAny = false,
        DetectedTrapNames = Array.Empty<string>(),
        Message = "You don't notice any hidden dangers.",
        HiddenCount = 0
    };
}
```

#### 7. Room.cs Modifications (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

Add the following to the Room entity:

```csharp
// ===== Trap Collection =====
// Add after _interactables field

/// <summary>
/// The traps in this room.
/// </summary>
private readonly List<Trap> _traps = new();

// ===== Trap Properties =====
// Add after Interactables property

/// <summary>
/// Gets the traps in this room.
/// </summary>
public IReadOnlyList<Trap> Traps => _traps;

/// <summary>
/// Gets whether this room has any traps.
/// </summary>
public bool HasTraps => _traps.Count > 0;

/// <summary>
/// Gets whether this room has any active (untriggered, not disarmed) traps.
/// </summary>
public bool HasActiveTraps => _traps.Any(t => t.IsActive);

/// <summary>
/// Gets whether this room has any hidden traps.
/// </summary>
public bool HasHiddenTraps => _traps.Any(t => t.State == TrapState.Hidden);

// ===== Trap Methods =====
// Add after interactable methods

/// <summary>
/// Adds a trap to this room.
/// </summary>
/// <param name="trap">The trap to add.</param>
/// <exception cref="ArgumentNullException">Thrown when trap is null.</exception>
public void AddTrap(Trap trap)
{
    ArgumentNullException.ThrowIfNull(trap);
    _traps.Add(trap);
}

/// <summary>
/// Removes a trap from this room.
/// </summary>
/// <param name="trap">The trap to remove.</param>
/// <returns>True if the trap was removed.</returns>
public bool RemoveTrap(Trap trap)
{
    return _traps.Remove(trap);
}

/// <summary>
/// Gets a trap by keyword (only visible traps).
/// </summary>
/// <param name="keyword">The keyword to search for.</param>
/// <returns>The matching trap, or null if not found.</returns>
public Trap? GetTrapByKeyword(string keyword)
{
    return _traps.FirstOrDefault(t => t.IsVisible && t.MatchesKeyword(keyword));
}

/// <summary>
/// Gets all visible (detected) traps.
/// </summary>
/// <returns>Enumerable of visible traps.</returns>
public IEnumerable<Trap> GetVisibleTraps()
{
    return _traps.Where(t => t.IsVisible);
}

/// <summary>
/// Gets all hidden traps.
/// </summary>
/// <returns>Enumerable of hidden traps.</returns>
public IEnumerable<Trap> GetHiddenTraps()
{
    return _traps.Where(t => t.State == TrapState.Hidden);
}

/// <summary>
/// Gets all active traps (can still trigger).
/// </summary>
/// <returns>Enumerable of active traps.</returns>
public IEnumerable<Trap> GetActiveTraps()
{
    return _traps.Where(t => t.IsActive);
}

/// <summary>
/// Gets traps of a specific trigger type.
/// </summary>
/// <param name="triggerType">The trigger type to filter by.</param>
/// <returns>Enumerable of matching traps.</returns>
public IEnumerable<Trap> GetTrapsByTriggerType(TriggerType triggerType)
{
    return _traps.Where(t => t.TriggerType == triggerType && t.IsActive);
}

/// <summary>
/// Gets a trap attached to a specific object.
/// </summary>
/// <param name="objectId">The object definition ID.</param>
/// <returns>The attached trap, or null if none.</returns>
public Trap? GetTrapAttachedTo(string objectId)
{
    return _traps.FirstOrDefault(t =>
        t.AttachedObjectId != null &&
        t.AttachedObjectId.Equals(objectId, StringComparison.OrdinalIgnoreCase) &&
        t.IsActive);
}
```

---

### Application Layer

#### 8. ITrapService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITrapService.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing traps and their interactions.
/// </summary>
/// <remarks>
/// <para>ITrapService provides the application layer interface for all trap-related
/// operations including detection, examination, triggering, and room management.</para>
/// <para>This foundation phase focuses on state management and display. Detection
/// dice checks and effects are added in v0.4.1b.</para>
/// </remarks>
public interface ITrapService
{
    /// <summary>
    /// Gets a description of visible traps in a room for display.
    /// </summary>
    /// <param name="room">The room to describe.</param>
    /// <returns>A formatted description of visible traps, or empty if none.</returns>
    string GetRoomTrapsDescription(Room room);

    /// <summary>
    /// Finds a trap by keyword in a room.
    /// </summary>
    /// <param name="room">The room to search.</param>
    /// <param name="keyword">The keyword to search for.</param>
    /// <returns>The matching trap, or null if not found.</returns>
    Trap? FindTrap(Room room, string keyword);

    /// <summary>
    /// Examines a detected trap, providing detailed description.
    /// </summary>
    /// <param name="trap">The trap to examine.</param>
    /// <returns>A detailed description of the trap.</returns>
    string ExamineTrap(Trap trap);

    /// <summary>
    /// Marks a trap as detected.
    /// </summary>
    /// <param name="trap">The trap to detect.</param>
    /// <returns>True if the trap was newly detected.</returns>
    bool DetectTrap(Trap trap);

    /// <summary>
    /// Marks a trap as disarmed.
    /// </summary>
    /// <param name="trap">The trap to disarm.</param>
    /// <returns>True if the trap was disarmed.</returns>
    bool DisarmTrap(Trap trap);

    /// <summary>
    /// Triggers a trap manually.
    /// </summary>
    /// <param name="trap">The trap to trigger.</param>
    /// <returns>The result of triggering the trap.</returns>
    TrapTriggerResult TriggerTrap(Trap trap);

    /// <summary>
    /// Checks for step-triggered traps when entering a room.
    /// </summary>
    /// <param name="room">The room being entered.</param>
    /// <returns>The result if a trap was triggered, null otherwise.</returns>
    TrapTriggerResult? CheckStepTraps(Room room);

    /// <summary>
    /// Checks for open-triggered traps when opening an object.
    /// </summary>
    /// <param name="room">The room containing the object.</param>
    /// <param name="objectId">The object being opened.</param>
    /// <returns>The result if a trap was triggered, null otherwise.</returns>
    TrapTriggerResult? CheckOpenTrap(Room room, string objectId);

    /// <summary>
    /// Processes turn ticks for all traps in a room (handles resets).
    /// </summary>
    /// <param name="room">The room to process.</param>
    /// <returns>Messages about reset traps.</returns>
    IEnumerable<string> ProcessRoomTurnTick(Room room);

    /// <summary>
    /// Gets statistics about traps in a room.
    /// </summary>
    /// <param name="room">The room to analyze.</param>
    /// <returns>A summary of trap states.</returns>
    TrapRoomSummary GetRoomTrapSummary(Room room);
}

/// <summary>
/// Summary of trap states in a room.
/// </summary>
public readonly record struct TrapRoomSummary
{
    /// <summary>Gets the total number of traps.</summary>
    public int Total { get; init; }

    /// <summary>Gets the number of hidden traps.</summary>
    public int Hidden { get; init; }

    /// <summary>Gets the number of detected traps.</summary>
    public int Detected { get; init; }

    /// <summary>Gets the number of triggered traps.</summary>
    public int Triggered { get; init; }

    /// <summary>Gets the number of disarmed traps.</summary>
    public int Disarmed { get; init; }

    /// <summary>Gets the number of broken traps.</summary>
    public int Broken { get; init; }
}
```

#### 9. TrapService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/TrapService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using System.Text;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing traps and their interactions.
/// </summary>
/// <remarks>
/// <para>TrapService provides the core trap management functionality for the
/// v0.4.1a foundation phase. Detection dice rolls and effect application
/// are added in v0.4.1b.</para>
/// </remarks>
public class TrapService : ITrapService
{
    private readonly ILogger<TrapService> _logger;

    /// <summary>
    /// Creates a new TrapService instance.
    /// </summary>
    /// <param name="logger">The logger instance.</param>
    /// <exception cref="ArgumentNullException">Thrown when logger is null.</exception>
    public TrapService(ILogger<TrapService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public string GetRoomTrapsDescription(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var visibleTraps = room.GetVisibleTraps().ToList();
        if (!visibleTraps.Any())
        {
            _logger.LogDebug("Room {RoomId} has no visible traps", room.Id);
            return string.Empty;
        }

        var sb = new StringBuilder();
        sb.AppendLine("You notice the following dangers:");

        foreach (var trap in visibleTraps)
        {
            var stateInfo = GetTrapStateDisplay(trap);
            sb.AppendLine($"  {trap.Name}{stateInfo}");
        }

        _logger.LogDebug(
            "Room {RoomId} has {VisibleCount} visible traps",
            room.Id,
            visibleTraps.Count);

        return sb.ToString().TrimEnd();
    }

    /// <inheritdoc />
    public Trap? FindTrap(Room room, string keyword)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentException.ThrowIfNullOrWhiteSpace(keyword);

        var trap = room.GetTrapByKeyword(keyword);

        if (trap != null)
        {
            _logger.LogDebug(
                "Found trap {TrapName} by keyword '{Keyword}' in room {RoomId}",
                trap.Name,
                keyword,
                room.Id);
        }
        else
        {
            _logger.LogDebug(
                "No visible trap found for keyword '{Keyword}' in room {RoomId}",
                keyword,
                room.Id);
        }

        return trap;
    }

    /// <inheritdoc />
    public string ExamineTrap(Trap trap)
    {
        ArgumentNullException.ThrowIfNull(trap);

        if (!trap.IsVisible)
        {
            _logger.LogDebug("Attempted to examine hidden trap {TrapId}", trap.Id);
            return "You don't see any trap there.";
        }

        var sb = new StringBuilder();
        sb.AppendLine(trap.Name);
        sb.AppendLine(trap.Description);
        sb.AppendLine();
        sb.AppendLine($"Status: {trap.GetStateDescription()}");
        sb.AppendLine($"Trigger: {GetTriggerTypeDescription(trap.TriggerType)}");

        if (trap.State == TrapState.Detected)
        {
            if (trap.CanBeDisarmed)
            {
                sb.AppendLine("This trap can be disarmed.");
            }
            else
            {
                sb.AppendLine("This trap cannot be disarmed - it can only be avoided.");
            }
        }

        if (trap.IsPendingReset)
        {
            sb.AppendLine($"The trap is resetting ({trap.TurnsUntilReset} turns remaining).");
        }

        _logger.LogDebug("Examined trap {TrapName} in state {TrapState}", trap.Name, trap.State);

        return sb.ToString().TrimEnd();
    }

    /// <inheritdoc />
    public bool DetectTrap(Trap trap)
    {
        ArgumentNullException.ThrowIfNull(trap);

        if (trap.Detect())
        {
            _logger.LogInformation(
                "Trap '{TrapName}' was detected (DefinitionId: {DefinitionId})",
                trap.Name,
                trap.DefinitionId);
            return true;
        }

        _logger.LogDebug(
            "Trap '{TrapName}' detection failed - current state: {TrapState}",
            trap.Name,
            trap.State);
        return false;
    }

    /// <inheritdoc />
    public bool DisarmTrap(Trap trap)
    {
        ArgumentNullException.ThrowIfNull(trap);

        if (trap.Disarm())
        {
            _logger.LogInformation(
                "Trap '{TrapName}' was successfully disarmed",
                trap.Name);
            return true;
        }

        _logger.LogDebug(
            "Trap '{TrapName}' could not be disarmed - state: {TrapState}, canDisarm: {CanDisarm}",
            trap.Name,
            trap.State,
            trap.CanBeDisarmed);
        return false;
    }

    /// <inheritdoc />
    public TrapTriggerResult TriggerTrap(Trap trap)
    {
        ArgumentNullException.ThrowIfNull(trap);

        if (trap.IsNeutralized)
        {
            if (trap.State == TrapState.Disarmed)
            {
                _logger.LogDebug("Trap '{TrapName}' was already disarmed", trap.Name);
                return TrapTriggerResult.WasDisarmed(trap.Name);
            }
            _logger.LogDebug("Trap '{TrapName}' was already triggered", trap.Name);
            return TrapTriggerResult.AlreadyTriggered(trap.Name);
        }

        if (!trap.IsActive)
        {
            _logger.LogDebug("Trap '{TrapName}' is not active", trap.Name);
            return TrapTriggerResult.AlreadyTriggered(trap.Name);
        }

        trap.Trigger();

        var message = GetTriggerMessage(trap);
        _logger.LogInformation(
            "Trap '{TrapName}' was triggered (TriggerType: {TriggerType}, Resets: {Resets})",
            trap.Name,
            trap.TriggerType,
            trap.Resets);

        return TrapTriggerResult.Success(
            trap.Name,
            message,
            trap.TriggerType,
            trap.Resets);
    }

    /// <inheritdoc />
    public TrapTriggerResult? CheckStepTraps(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var stepTraps = room.GetTrapsByTriggerType(TriggerType.Step).ToList();

        _logger.LogDebug(
            "Checking {Count} step traps in room {RoomId}",
            stepTraps.Count,
            room.Id);

        foreach (var trap in stepTraps)
        {
            // In v0.4.1b, this will include detection checks
            // For now, hidden traps trigger automatically
            if (trap.IsActive)
            {
                return TriggerTrap(trap);
            }
        }

        return null;
    }

    /// <inheritdoc />
    public TrapTriggerResult? CheckOpenTrap(Room room, string objectId)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentException.ThrowIfNullOrWhiteSpace(objectId);

        var trap = room.GetTrapAttachedTo(objectId);

        if (trap != null && trap.IsActive)
        {
            _logger.LogDebug(
                "Found active trap '{TrapName}' attached to object '{ObjectId}'",
                trap.Name,
                objectId);
            return TriggerTrap(trap);
        }

        _logger.LogDebug("No active trap attached to object '{ObjectId}'", objectId);
        return null;
    }

    /// <inheritdoc />
    public IEnumerable<string> ProcessRoomTurnTick(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var messages = new List<string>();

        foreach (var trap in room.Traps)
        {
            if (trap.ProcessTurnTick())
            {
                var resetMessage = $"The {trap.Name} resets with a soft click.";
                messages.Add(resetMessage);
                _logger.LogDebug(
                    "Trap '{TrapName}' reset to hidden state",
                    trap.Name);
            }
        }

        if (messages.Count > 0)
        {
            _logger.LogDebug(
                "Processed turn tick for room {RoomId}: {ResetCount} traps reset",
                room.Id,
                messages.Count);
        }

        return messages;
    }

    /// <inheritdoc />
    public TrapRoomSummary GetRoomTrapSummary(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var summary = new TrapRoomSummary
        {
            Total = room.Traps.Count,
            Hidden = room.Traps.Count(t => t.State == TrapState.Hidden),
            Detected = room.Traps.Count(t => t.State == TrapState.Detected),
            Triggered = room.Traps.Count(t => t.State == TrapState.Triggered),
            Disarmed = room.Traps.Count(t => t.State == TrapState.Disarmed),
            Broken = room.Traps.Count(t => t.State == TrapState.Broken)
        };

        _logger.LogDebug(
            "Room {RoomId} trap summary: Total={Total}, Hidden={Hidden}, Detected={Detected}",
            room.Id,
            summary.Total,
            summary.Hidden,
            summary.Detected);

        return summary;
    }

    // ===== Private Helper Methods =====

    private static string GetTrapStateDisplay(Trap trap)
    {
        return trap.State switch
        {
            TrapState.Detected => " [DETECTED]",
            TrapState.Triggered => trap.Resets ? " [TRIGGERED - resetting]" : " [TRIGGERED]",
            TrapState.Disarmed => " [DISARMED]",
            TrapState.Broken => " [BROKEN]",
            _ => string.Empty
        };
    }

    private static string GetTriggerTypeDescription(TriggerType type)
    {
        return type switch
        {
            TriggerType.Step => "Pressure plate - triggers when stepped on",
            TriggerType.Touch => "Contact trigger - triggers when touched",
            TriggerType.Open => "Container trap - triggers when opened",
            TriggerType.Proximity => "Motion sensor - triggers when approached",
            TriggerType.Tripwire => "Tripwire - triggers when crossed",
            _ => "Unknown trigger mechanism"
        };
    }

    private static string GetTriggerMessage(Trap trap)
    {
        return trap.TriggerType switch
        {
            TriggerType.Step => $"*CLICK* You step on the {trap.Name}!",
            TriggerType.Touch => $"As you touch it, the {trap.Name} activates!",
            TriggerType.Open => $"Opening triggers the {trap.Name}!",
            TriggerType.Proximity => $"The {trap.Name} senses your approach and activates!",
            TriggerType.Tripwire => $"You trip the wire and the {trap.Name} activates!",
            _ => $"The {trap.Name} is triggered!"
        };
    }
}
```

---

## Flow Diagrams

### Trap State Machine

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        TRAP STATE MACHINE                                    │
└─────────────────────────────────────────────────────────────────────────────┘

                              ┌───────────────┐
                              │    HIDDEN     │ (Initial state)
                              │   IsActive    │
                              └───────┬───────┘
                                      │
                    ┌─────────────────┼─────────────────┐
                    │                 │                 │
                    ▼                 ▼                 ▼
            [Detect()]          [Trigger()]       [Break()]
                    │                 │                 │
                    ▼                 │                 │
            ┌───────────────┐        │                 │
            │   DETECTED    │        │                 │
            │   IsActive    │        │                 │
            └───────┬───────┘        │                 │
                    │                 │                 │
        ┌───────────┼────────────────┤                 │
        │           │                │                 │
        ▼           ▼                │                 │
  [Disarm()]  [Trigger()]            │                 │
        │           │                │                 │
        ▼           ▼                ▼                 ▼
┌───────────┐ ┌───────────────┐           ┌───────────────┐
│ DISARMED  │ │   TRIGGERED   │           │    BROKEN     │
│ Terminal  │ │               │           │   Terminal    │
└───────────┘ └───────┬───────┘           └───────────────┘
                      │
                      │ [If Resets=true]
                      ▼
              ┌───────────────┐
              │ ProcessTurn() │
              │ TurnsUntil=0  │
              └───────┬───────┘
                      │
                      └──────► HIDDEN (cycle restarts)
```

### Trap Service Interaction Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     TRAP SERVICE INTERACTION FLOW                            │
└─────────────────────────────────────────────────────────────────────────────┘

    Player enters Room with Traps
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ROOM DESCRIPTION PHASE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────┐                                         │
│  │ GetRoomTrapsDescription(room)  │                                         │
│  │ └─ Only shows visible traps   │                                         │
│  │    (Detected/Triggered)        │                                         │
│  └────────────────────────────────┘                                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         PLAYER COMMAND PHASE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Command: "examine <trap>"                                                  │
│  ┌────────────────────┐     ┌────────────────────┐                          │
│  │ FindTrap(room, kw) │ ──► │ ExamineTrap(trap)  │                          │
│  │ └─ Visible only    │     │ └─ Details + state │                          │
│  └────────────────────┘     └────────────────────┘                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         TURN TICK PHASE                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────┐                                         │
│  │ ProcessRoomTurnTick(room)      │                                         │
│  │ └─ Resetting traps countdown  │                                         │
│  │    Reset ──► Hidden state      │                                         │
│  └────────────────────────────────┘                                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Enums/
│   │   ├── TrapStateTests.cs              (3 tests)
│   │   └── TriggerTypeTests.cs            (3 tests)
│   ├── Entities/
│   │   ├── TrapTests.cs                   (14 tests)
│   │   └── RoomTrapTests.cs               (8 tests)
│   └── ValueObjects/
│       ├── TrapTriggerResultTests.cs      (4 tests)
│       └── TrapDetectionResultTests.cs    (3 tests)
├── RuneAndRust.Application.UnitTests/
│   └── Services/
│       └── TrapServiceTests.cs            (10 tests)
```

### Test Specifications

#### TrapStateTests.cs (3 tests)

| Test Name | Description |
|-----------|-------------|
| `TrapState_HasAllExpectedValues` | Verify all 5 states exist |
| `TrapState_HiddenIsDefault` | Hidden is first/default (0) |
| `TrapState_CanParseFromString` | Enum.Parse works correctly |

#### TriggerTypeTests.cs (3 tests)

| Test Name | Description |
|-----------|-------------|
| `TriggerType_HasAllExpectedValues` | Verify all 5 types exist |
| `TriggerType_StepIsDefault` | Step is first/default (0) |
| `TriggerType_CanParseFromString` | Enum.Parse works correctly |

#### TrapTests.cs (14 tests)

| Test Name | Description |
|-----------|-------------|
| `Create_WithValidParameters_ReturnsTrap` | Valid creation |
| `Create_WithNullDefinitionId_ThrowsException` | Null ID rejected |
| `Create_WithEmptyName_ThrowsException` | Empty name rejected |
| `Create_WithNegativeDetectionDC_ClampsToOne` | DC minimum 1 |
| `FromDefinition_CreatesCorrectTrap` | Definition mapping |
| `Detect_WhenHidden_ReturnsTrue` | Detection from hidden |
| `Detect_WhenAlreadyDetected_ReturnsFalse` | Already detected |
| `Trigger_WhenActive_ReturnsTrue` | Successful trigger |
| `Trigger_WhenDisarmed_ReturnsFalse` | Can't trigger disarmed |
| `Disarm_WhenDetected_ReturnsTrue` | Successful disarm |
| `Disarm_WhenHidden_ReturnsFalse` | Can't disarm hidden |
| `Disarm_WhenCanBeDisarmedFalse_ReturnsFalse` | Non-disarmable trap |
| `ProcessTurnTick_WhenResetting_DecrementsCounter` | Reset countdown |
| `ProcessTurnTick_WhenResetComplete_ReturnsTrue` | Reset completion |

#### RoomTrapTests.cs (8 tests)

| Test Name | Description |
|-----------|-------------|
| `AddTrap_AddsTrapToCollection` | Adding traps |
| `RemoveTrap_RemovesTrapFromCollection` | Removing traps |
| `GetTrapByKeyword_FindsVisibleTrap` | Keyword lookup success |
| `GetTrapByKeyword_DoesNotFindHidden` | Hidden not found |
| `GetVisibleTraps_ReturnsOnlyVisible` | Visibility filtering |
| `GetTrapsByTriggerType_FiltersCorrectly` | Type filtering |
| `GetTrapAttachedTo_FindsAttachedTrap` | Attached trap lookup |
| `HasActiveTraps_ReturnsTrueWhenActive` | Active trap check |

#### TrapServiceTests.cs (10 tests)

| Test Name | Description |
|-----------|-------------|
| `GetRoomTrapsDescription_WithVisibleTraps_ReturnsFormatted` | Description formatting |
| `GetRoomTrapsDescription_WithNoVisibleTraps_ReturnsEmpty` | No visible traps |
| `FindTrap_WithMatchingKeyword_ReturnsTrap` | Finding traps |
| `FindTrap_WithNoMatch_ReturnsNull` | No match handling |
| `ExamineTrap_ReturnsDetailedDescription` | Examination details |
| `ExamineTrap_WhenHidden_ReturnsNotVisible` | Hidden trap error |
| `TriggerTrap_TriggersAndReturnsResult` | Triggering success |
| `TriggerTrap_WhenDisarmed_ReturnsWasDisarmed` | Already disarmed |
| `ProcessRoomTurnTick_ResetsTraps` | Turn tick processing |
| `GetRoomTrapSummary_ReturnsCorrectCounts` | Summary statistics |

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Template |
|-----------|-------|----------|
| Trap detected | Information | "Trap '{TrapName}' was detected (DefinitionId: {DefinitionId})" |
| Trap disarmed | Information | "Trap '{TrapName}' was successfully disarmed" |
| Trap triggered | Information | "Trap '{TrapName}' was triggered (TriggerType: {TriggerType}, Resets: {Resets})" |
| Trap reset | Debug | "Trap '{TrapName}' reset to hidden state" |
| Room description | Debug | "Room {RoomId} has {VisibleCount} visible traps" |
| Find trap success | Debug | "Found trap {TrapName} by keyword '{Keyword}' in room {RoomId}" |
| Find trap failure | Debug | "No visible trap found for keyword '{Keyword}' in room {RoomId}" |
| Examine hidden | Debug | "Attempted to examine hidden trap {TrapId}" |

---

## Implementation Checklist

### Domain Layer
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/TrapState.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/TriggerType.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Entities/Trap.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Definitions/TrapDefinition.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/TrapTriggerResult.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/TrapDetectionResult.cs`
- [ ] Modify `src/Core/RuneAndRust.Domain/Entities/Room.cs` - Add Traps collection

### Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/Interfaces/ITrapService.cs`
- [ ] Create `src/Core/RuneAndRust.Application/Services/TrapService.cs`
- [ ] Update DI registration in `ServiceCollectionExtensions.cs`

### Configuration
- [ ] Create `config/schemas/traps.schema.json`
- [ ] Create `config/traps.json`

### Tests
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Enums/TrapStateTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Enums/TriggerTypeTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Entities/TrapTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Entities/RoomTrapTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/TrapTriggerResultTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/TrapDetectionResultTests.cs`
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/TrapServiceTests.cs`

### Validation
- [ ] All ~37 new tests pass
- [ ] All existing tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | TrapState enum contains all 5 states | Unit test |
| AC-2 | TriggerType enum contains all 5 trigger types | Unit test |
| AC-3 | Trap entity stores all configuration and state | Unit test |
| AC-4 | Trap.Detect() transitions from Hidden to Detected | Unit test |
| AC-5 | Trap.Trigger() transitions to Triggered and starts reset timer | Unit test |
| AC-6 | Trap.Disarm() transitions from Detected to Disarmed | Unit test |
| AC-7 | Trap.Break() transitions to Broken | Unit test |
| AC-8 | Trap.ProcessTurnTick() handles reset countdown | Unit test |
| AC-9 | Room.Traps collection manages traps | Unit test |
| AC-10 | Room.GetTrapByKeyword() finds visible traps only | Unit test |
| AC-11 | TrapService.GetRoomTrapsDescription() formats visible traps | Unit test |
| AC-12 | TrapService.ExamineTrap() provides detailed info | Unit test |
| AC-13 | Detected traps appear in room descriptions | Manual verification |
| AC-14 | ~37 unit tests pass | Test suite |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | Entity properties properly encapsulated | Code review |
| NF-2 | Services follow DI patterns | Code review |
| NF-3 | Logging follows structured patterns | Code review |
| NF-4 | Configuration is JSON-driven | Code review |
| NF-5 | All public methods have XML documentation | Code review |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Room entity modification breaks existing tests | Medium | Low | Add to existing collection pattern, minimal changes |
| TrapState conflicts with ObjectState | Low | Low | Different enum, clear naming |
| Keyword search performance with many traps | Low | Low | LINQ FirstOrDefault is efficient for small collections |
| Reset timer off-by-one errors | Medium | Medium | Comprehensive unit tests for boundary conditions |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Domain/Enums/TrapState.cs` | Trap state enum | ~35 |
| `Domain/Enums/TriggerType.cs` | Trigger type enum | ~35 |
| `Domain/Entities/Trap.cs` | Core trap entity | ~280 |
| `Domain/Definitions/TrapDefinition.cs` | Configuration definition | ~80 |
| `Domain/ValueObjects/TrapTriggerResult.cs` | Trigger result | ~70 |
| `Domain/ValueObjects/TrapDetectionResult.cs` | Detection result | ~60 |
| `Application/Interfaces/ITrapService.cs` | Service interface + TrapRoomSummary | ~120 |
| `Application/Services/TrapService.cs` | Service implementation | ~290 |
| `config/schemas/traps.schema.json` | JSON schema | ~80 |
| `config/traps.json` | Sample trap definitions | ~150 |

### Files to Modify

| File | Changes | Est. Lines Added |
|------|---------|------------------|
| `Domain/Entities/Room.cs` | Add Traps collection + 8 methods | ~80 |
| `Infrastructure/ServiceCollectionExtensions.cs` | Register TrapService | ~3 |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| TrapState values | 0 | 5 |
| TriggerType values | 0 | 5 |
| Trap-related entities | 0 | 1 |
| Trap-related services | 0 | 1 |
| Unit Tests | ~1463 | ~1500 |

---

## Next Steps

After completing this phase:

1. **v0.4.1b (Trap Types & Triggers)** - Detection dice checks, disarm mechanics, trap effects (damage, status), trapped containers, automatic triggering
2. **v0.4.1c (Environmental Hazards)** - Hazard zones, saving throws, ongoing effects

---

*This implementation plan provides a comprehensive roadmap for implementing v0.4.1a. It builds upon the established patterns from v0.4.0 (Interactive Objects) while creating a solid foundation for the trap system that subsequent phases will extend.*
