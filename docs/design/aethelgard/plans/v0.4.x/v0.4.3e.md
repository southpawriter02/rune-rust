# v0.4.3e: The Resonance (Seeding & TUI Integration)

> **Status:** Planned
> **Parent:** v0.4.3 - The Weaver (Magic Core System)
> **Theme:** The weave made manifest—spells given form, power made visible, magic made tangible.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Component Specifications](#component-specifications)
5. [Code Implementation](#code-implementation)
6. [Logging Matrix](#logging-matrix)
7. [Unit Testing Specification](#unit-testing-specification)
8. [Integration Points](#integration-points)
9. [Deliverable Checklist](#deliverable-checklist)
10. [Workflow](#workflow)
11. [Changelog](#changelog)

---

## Overview

v0.4.3e introduces **The Resonance**—the final integration layer that makes the magic system tangible to players. This version seeds starter spells, extends the combat HUD to display Aether Points and Flux levels, and implements the `spells` command to view available magic.

### Design Philosophy

The Resonance follows three core principles:

1. **Visibility**: Players must see their magical resources (AP, Flux) at a glance during combat.
2. **Accessibility**: The `spells` command provides clear, actionable information about available magic.
3. **Domain 4 Compliance**: All spell descriptions use archaeologist-perspective language without precision measurements.

### Key Deliverables

| Component | Purpose |
|-----------|---------|
| **SpellSeeder** | Seeds 12 starter spells across all 4 schools |
| **StatusWidget Extensions** | AP bar rendering with threshold colors |
| **FluxWidget** | Flux bar with threshold indicator (Safe/Elevated/Critical/Overload) |
| **SpellListRenderer** | Renders available spells in a formatted panel |
| **CommandParser Extensions** | Handles `spells`, `cast` routing, and help integration |
| **ContextHelpService Extensions** | Dynamic tips for magic-related situations |

### Visual Design

**Combat HUD (Extended):**
```
╭──────────────────────────────────────────────────────────────────────────╮
│ ERIK THE WANDERER                                                        │
│ HP: ████████░░ 42/50   Stamina: ██████░░░░ 6/10                         │
│ AP: ████░░░░░░ 4/10    Flux: ▓▓▓▓▓▓░░░░ 55 [CRITICAL]                   │
│ Corruption: ░░░░░░░░░░ 5 [Untouched]                                     │
╰──────────────────────────────────────────────────────────────────────────╯
```

**Spell List (`spells` command):**
```
╭─ KNOWN SPELLS ──────────────────────────────────────────────────────────╮
│                                                                          │
│  DESTRUCTION                                                             │
│  ├─ [1] Spark           2 AP  │  8 Flux  │ Fire damage                  │
│  ├─ [2] Frost Touch     3 AP  │ 10 Flux  │ Cold damage                  │
│  └─ [3] Thunder Strike  5 AP  │ 15 Flux  │ Lightning damage             │
│                                                                          │
│  RESTORATION                                                             │
│  ├─ [4] Mend Flesh      3 AP  │  6 Flux  │ Healing                      │
│  └─ [5] Cleansing Light 4 AP  │ 10 Flux  │ Healing + cleanse            │
│                                                                          │
│  ALTERATION                                                              │
│  ├─ [6] Stone Skin      4 AP  │ 12 Flux  │ Fortified buff               │
│  └─ [7] Weaken          3 AP  │  8 Flux  │ Vulnerable debuff            │
│                                                                          │
│  DIVINATION                                                              │
│  └─ [8] Spirit Sight    2 AP  │  4 Flux  │ True seeing                  │
│                                                                          │
│  Current AP: 7/10  │  Flux: 35 [ELEVATED]  │  Risk: 0%                   │
╰──────────────────────────────────────────────────────────────────────────╯
```

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            Program.cs                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ Database Initialization                                         │   │
│  │     │                                                           │   │
│  │     ├─── AbilitySeeder.SeedAsync()                              │   │
│  │     ├─── ConditionSeeder.SeedAsync()                            │   │
│  │     ├─── HazardTemplateSeeder.SeedAsync()                       │   │
│  │     ├─── RoomTemplateSeeder.SeedAsync()                         │   │
│  │     └─── ★ SpellSeeder.SeedAsync() ★  ← NEW                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                         Combat Rendering                                 │
│                                                                          │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐     │
│  │  StatusWidget   │    │   FluxWidget    │    │ SpellListRenderer│     │
│  │  (Extended)     │    │   (NEW)         │    │ (NEW)           │     │
│  │                 │    │                 │    │                 │     │
│  │ • RenderApBar() │    │ • RenderFluxBar │    │ • RenderBySchool│     │
│  │ • GetApColor()  │    │ • GetFluxColor  │    │ • RenderCompact │     │
│  │                 │    │ • GetThreshold  │    │ • RenderDetailed│     │
│  └────────┬────────┘    └────────┬────────┘    └────────┬────────┘     │
│           │                      │                      │               │
│           └──────────────────────┼──────────────────────┘               │
│                                  │                                      │
│                                  ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    CombatHudRenderer                             │   │
│  │                    (Extended)                                    │   │
│  │                                                                  │   │
│  │  Creates status bar with:                                        │   │
│  │  • HP bar (existing)                                             │   │
│  │  • Stamina bar (existing)                                        │   │
│  │  • ★ AP bar (NEW)                                               │   │
│  │  • ★ Flux bar with threshold (NEW)                              │   │
│  │  • ★ Corruption indicator (NEW)                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                         CommandParser                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ HandleCombat(command)                                           │   │
│  │     │                                                           │   │
│  │     ├─── "spells" or "magic" or "sp"                            │   │
│  │     │         │                                                 │   │
│  │     │         └─── DisplaySpellList()                           │   │
│  │     │                    │                                      │   │
│  │     │                    └─── SpellListRenderer.Render()        │   │
│  │     │                                                           │   │
│  │     ├─── "cast <spell> [on <target>]"                           │   │
│  │     │         │                                                 │   │
│  │     │         └─── ExecuteCastCommandAsync() (v0.4.3c)          │   │
│  │     │                                                           │   │
│  │     └─── "help" or "?"                                          │   │
│  │               │                                                 │   │
│  │               └─── DisplayCombatHelp() (extended)               │   │
│  │                         │                                       │   │
│  │                         └─── ★ Includes magic commands ★       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

### Spell Data Flow

```
                    GAME STARTUP
                         │
                         ▼
              ┌─────────────────────┐
              │ SpellSeeder.Seed()  │
              │                     │
              │ 1. Check AnyAsync() │
              │ 2. If empty:        │
              │    - Create 12      │
              │      starter spells │
              │    - AddRangeAsync  │
              │    - SaveChanges    │
              └──────────┬──────────┘
                         │
                         ▼
              ┌─────────────────────┐
              │  Database (Spells)  │
              └──────────┬──────────┘
                         │
          ┌──────────────┴──────────────┐
          │                             │
          ▼                             ▼
┌─────────────────────┐      ┌─────────────────────┐
│ "spells" command    │      │ "cast" command      │
│                     │      │                     │
│ SpellRepository     │      │ SpellRepository     │
│ .GetAvailableFor    │      │ .GetByNameAsync()   │
│  CasterAsync()      │      │                     │
│         │           │      │         │           │
│         ▼           │      │         ▼           │
│ SpellListRenderer   │      │ MagicService        │
│ .Render()           │      │ .CastSpell()        │
└─────────────────────┘      └─────────────────────┘
```

### TUI Component Hierarchy

```
CombatScreenRenderer
│
├── CombatHudRenderer (EXTENDED)
│   │
│   ├── Row 1: Character Name
│   │
│   ├── Row 2: HP + Stamina bars
│   │   ├── StatusWidget.RenderBar(hp, maxHp)
│   │   └── StatusWidget.RenderBar(stamina, maxStamina)
│   │
│   ├── Row 3: AP + Flux bars  ★ NEW ★
│   │   ├── StatusWidget.RenderApBar(ap, maxAp)
│   │   └── FluxWidget.RenderFluxBar(flux)
│   │
│   └── Row 4: Corruption indicator  ★ NEW ★
│       └── CorruptionWidget.RenderIndicator(corruption, level)
│
├── CombatGridRenderer (existing)
│
├── CombatLogRenderer (existing)
│
└── SpellListRenderer  ★ NEW ★
    │
    ├── Header: "KNOWN SPELLS"
    │
    ├── Body: Grouped by school
    │   ├── DESTRUCTION
    │   │   └── Spell entries...
    │   ├── RESTORATION
    │   │   └── Spell entries...
    │   ├── ALTERATION
    │   │   └── Spell entries...
    │   └── DIVINATION
    │       └── Spell entries...
    │
    └── Footer: Current AP | Flux | Risk
```

---

## Decision Trees

### 1. SpellSeeder.SeedAsync Decision Tree

```
SeedAsync(context: DbContext, logger: ILogger?)
│
├── INPUT: Database context, optional logger
│
├── STEP 1: Idempotency Check
│   ├── exists = await context.Spells.AnyAsync()
│   │
│   └── IF exists:
│       ├── Log: "[SpellSeeder] Spells already exist, skipping seed"
│       └── RETURN (no-op)
│
├── STEP 2: Create Starter Spells
│   ├── spells = GetStarterSpells()
│   │   │
│   │   ├── GetDestructionSpells()  → 3 spells
│   │   ├── GetRestorationSpells()  → 2 spells
│   │   ├── GetAlterationSpells()   → 3 spells
│   │   ├── GetDivinationSpells()   → 2 spells
│   │   └── GetAdvancedSpells()     → 2 spells (Tier 2)
│   │
│   └── Total: 12 spells
│
├── STEP 3: Add to Database
│   ├── await context.Spells.AddRangeAsync(spells)
│   └── await context.SaveChangesAsync()
│
├── STEP 4: Log Summary
│   └── Log: "[SpellSeeder] Seeded {Count} spells across {Schools} schools"
│
└── RETURN
```

### 2. SpellListRenderer.Render Decision Tree

```
Render(spells: IEnumerable<Spell>, caster: Combatant, aetherService: IAetherService, themeService: IThemeService)
│
├── INPUT: Available spells, caster info, current Flux, theme
│
├── STEP 1: Group Spells by School
│   ├── grouped = spells.GroupBy(s => s.School)
│   │              .OrderBy(g => (int)g.Key)
│   │
│   └── Schools ordered: Destruction → Restoration → Alteration → Divination
│
├── STEP 2: Build Panel Content
│   │
│   ├── FOR EACH school in grouped:
│   │   │
│   │   ├── Add school header with color
│   │   │   └── "[bold magenta]DESTRUCTION[/]"
│   │   │
│   │   └── FOR EACH spell in school.OrderBy(s => s.ApCost):
│   │       │
│   │       ├── Determine affordability
│   │       │   └── canAfford = caster.CurrentAp >= spell.ApCost
│   │       │
│   │       ├── Determine color
│   │       │   ├── canAfford → school color
│   │       │   └── !canAfford → grey (dimmed)
│   │       │
│   │       └── Format entry:
│   │           └── "  ├─ [color]Spark[/]  2 AP │ 8 Flux │ Fire damage"
│   │
│   └── Add final entry with └─ prefix
│
├── STEP 3: Build Footer
│   ├── currentAp = caster.CurrentAp / caster.MaxAp
│   ├── flux = aetherService.GetCurrentFlux()
│   ├── threshold = aetherService.GetThreshold()
│   ├── risk = Math.Max(0, flux - 50)
│   │
│   └── Footer: "Current AP: 7/10 │ Flux: 35 [ELEVATED] │ Risk: 0%"
│
├── STEP 4: Create Panel
│   ├── panel = new Panel(content)
│   ├── panel.Header("KNOWN SPELLS")
│   ├── panel.Border(BoxBorder.Rounded)
│   └── panel.BorderStyle(theme.BorderColor)
│
└── RETURN panel
```

### 3. StatusWidget.RenderApBar Decision Tree

```
RenderApBar(current: int, max: int, width: int = 10)
│
├── INPUT: Current AP, Max AP, bar width
│
├── STEP 1: Calculate Fill
│   ├── IF max == 0:
│   │   └── RETURN new string('░', width)
│   │
│   ├── pct = (double)current / max
│   ├── filled = (int)(pct * width)
│   └── empty = width - filled
│
├── STEP 2: Build Bar String
│   └── bar = new string('█', filled) + new string('░', empty)
│
└── RETURN bar
```

### 4. StatusWidget.GetApColor Decision Tree

```
GetApColor(current: int, max: int, themeService: IThemeService)
│
├── INPUT: Current AP, Max AP, theme
│
├── STEP 1: Calculate Percentage
│   ├── IF max == 0:
│   │   └── RETURN NeutralColor (grey)
│   │
│   └── pct = (double)current / max * 100
│
├── STEP 2: Determine Color Role
│   └── role = pct switch:
│       ├── <= 20  → "ApCritical"   (red - nearly depleted)
│       ├── <= 40  → "ApLow"        (orange - running low)
│       ├── <= 60  → "ApMedium"     (yellow - mid-range)
│       └── _      → "ApFull"       (cyan/blue - healthy)
│
└── RETURN ParseColor(themeService.GetColor(role))
```

### 5. FluxWidget.RenderFluxBar Decision Tree

```
RenderFluxBar(flux: int, themeService: IThemeService, width: int = 10)
│
├── INPUT: Current Flux (0-100), theme, bar width
│
├── STEP 1: Calculate Fill
│   ├── pct = flux / 100.0
│   ├── filled = (int)(pct * width)
│   └── empty = width - filled
│
├── STEP 2: Determine Color
│   └── color = GetFluxColor(flux, themeService)
│
├── STEP 3: Get Threshold Label
│   └── threshold = flux switch:
│       ├── >= 75 → "[OVERLOAD]"   (bright red)
│       ├── >= 50 → "[CRITICAL]"   (red)
│       ├── >= 25 → "[ELEVATED]"   (yellow)
│       └── _     → "[SAFE]"       (green)
│
├── STEP 4: Build Markup
│   ├── bar = new string('▓', filled) + new string('░', empty)
│   └── markup = $"[{color}]{bar}[/] {flux} [{thresholdColor}]{threshold}[/]"
│
└── RETURN markup
```

### 6. DisplaySpellList Decision Tree

```
DisplaySpellList(state: GameState)
│
├── INPUT: Current game state
│
├── STEP 1: Get Active Combatant
│   ├── combatState = state.CombatState
│   │
│   └── IF combatState == null || !combatState.IsPlayerTurn:
│       ├── Display: "You can only view spells during your turn in combat."
│       └── RETURN ParseResult.None
│
├── STEP 2: Get Caster
│   └── caster = combatState.ActiveCombatant
│
├── STEP 3: Check Archetype
│   ├── archetype = caster.CharacterSource?.Archetype
│   │
│   └── IF archetype != Mystic AND no universal spells available:
│       ├── Display: "You have no magical training."
│       └── RETURN ParseResult.None
│
├── STEP 4: Fetch Available Spells
│   ├── spells = await _spellRepository.GetAvailableForCasterAsync(
│   │               archetype, tier)
│   │
│   └── IF spells.Count == 0:
│       ├── Display: "You know no spells."
│       └── RETURN ParseResult.None
│
├── STEP 5: Render Spell List
│   ├── panel = SpellListRenderer.Render(spells, caster, _aetherService, _theme)
│   └── AnsiConsole.Write(panel)
│
└── RETURN ParseResult.None
```

### 7. ContextHelpService.AnalyzeMagic Decision Tree

```
AnalyzeMagic(combatState: CombatState, aetherService: IAetherService)
│
├── INPUT: Combat state, Aether service
│
├── tips = new List<HelpTip>()
│
├── STEP 1: Check Flux Risk
│   ├── flux = aetherService.GetCurrentFlux()
│   ├── risk = Math.Max(0, flux - 50)
│   │
│   ├── IF risk >= 40:
│   │   └── tips.Add(HelpTip.Critical("HIGH RISK",
│   │         $"Backlash chance is {risk}%! Consider waiting."))
│   │
│   ├── ELSE IF risk >= 20:
│   │   └── tips.Add(HelpTip.Warning("Elevated Risk",
│   │         $"Backlash chance: {risk}%. Cast with caution."))
│   │
│   └── ELSE IF flux >= 25:
│       └── tips.Add(HelpTip.Info("Rising Flux",
│             "Flux is elevated. Powerful spells add risk."))
│
├── STEP 2: Check AP
│   ├── caster = combatState.ActiveCombatant
│   ├── apPct = (double)caster.CurrentAp / caster.MaxAp * 100
│   │
│   ├── IF apPct <= 20:
│   │   └── tips.Add(HelpTip.Warning("Low Aether",
│   │         "AP nearly depleted. Consider resting or items."))
│   │
│   └── ELSE IF apPct <= 40:
│       └── tips.Add(HelpTip.Info("Aether Reserves",
│             "AP running low. Conserve for critical moments."))
│
├── STEP 3: Check Aether Sickness
│   └── IF HasEffect(caster, AetherSickness):
│       └── tips.Add(HelpTip.Warning("Aether Sickness",
│             "-2 WILL, -1 WITS. Cannot concentrate."))
│
├── STEP 4: Check Corruption
│   ├── corruption = caster.CharacterSource?.CurrentCorruption ?? 0
│   │
│   └── IF corruption >= 50:
│       └── tips.Add(HelpTip.Critical("Soul Corruption",
│             $"Corruption at {corruption}. Seeking purification advised."))
│
└── RETURN tips.Take(MaxTips)
```

---

## Component Specifications

### 1. Starter Spells (Domain 4 Compliant)

| # | Name | School | Tier | AP | Flux | Target | Range | Effect | Description |
|---|------|--------|------|-----|------|--------|-------|--------|-------------|
| 1 | Spark | Destruction | 1 | 2 | 8 | SingleEnemy | Close | DAMAGE:Fire:1d6 | "A whisper to the old fire-spirits, coaxing forth a tongue of flame." |
| 2 | Frost Touch | Destruction | 1 | 3 | 10 | SingleEnemy | Touch | DAMAGE:Cold:1d8 | "The caster's hand draws heat from flesh, leaving only the cold of the grave." |
| 3 | Thunder Strike | Destruction | 2 | 5 | 15 | SingleEnemy | Medium | DAMAGE:Lightning:2d8 | "The sky's anger called down upon foes—a gift the Old Ones left behind." |
| 4 | Mend Flesh | Restoration | 1 | 3 | 6 | SingleAlly | Touch | HEAL:2d6 | "Ancient words spoken over wounds, knitting flesh as the elders once did." |
| 5 | Cleansing Light | Restoration | 1 | 4 | 10 | SingleAlly | Close | HEAL:1d8;CLEANSE:1 | "Pure radiance that burns away corruption and soothes the wounded." |
| 6 | Stone Skin | Alteration | 1 | 4 | 12 | Self | Self | STATUS:Fortified:3:2 | "The skin hardens like the Old Ones' shells—briefly proof against harm." |
| 7 | Weaken | Alteration | 1 | 3 | 8 | SingleEnemy | Close | STATUS:Vulnerable:2 | "A curse that frays the target's defenses, leaving them open to harm." |
| 8 | Haste | Alteration | 2 | 5 | 14 | SingleAlly | Close | STATUS:Hasted:2 | "Time bends, granting swiftness to the touched—a dangerous gift." |
| 9 | Spirit Sight | Divination | 1 | 2 | 4 | Self | Self | STATUS:TrueSeeing:3 | "The caster's eyes cloud, then clear—seeing what others cannot." |
| 10 | Analyze Foe | Divination | 1 | 2 | 5 | SingleEnemy | Medium | STATUS:Analyzed:3 | "The target's weaknesses revealed to the discerning eye." |
| 11 | Firebolt | Destruction | 1 | 3 | 10 | SingleEnemy | Medium | DAMAGE:Fire:1d8 | "A bolt of fire hurled from the palm, ancient and terrible." |
| 12 | Sanctuary | Restoration | 2 | 5 | 12 | Self | Self | STATUS:Fortified:2:3;HEAL:1d6 | "A shield of light wraps the caster, turning aside harm." |

### 2. Theme Colors (New Roles)

Add to theme configuration:

```json
{
  "ApFull": "#00CED1",       // Dark Cyan - healthy AP
  "ApMedium": "#FFD700",     // Gold - mid-range
  "ApLow": "#FFA500",        // Orange - running low
  "ApCritical": "#FF4500",   // Orange Red - nearly depleted

  "FluxSafe": "#32CD32",     // Lime Green
  "FluxElevated": "#FFD700", // Gold
  "FluxCritical": "#FF6347", // Tomato
  "FluxOverload": "#FF0000", // Red

  "CorruptionNone": "#808080",    // Grey
  "CorruptionTainted": "#9370DB", // Medium Purple
  "CorruptionAfflicted": "#8B008B", // Dark Magenta
  "CorruptionBlighted": "#4B0082", // Indigo
  "CorruptionLost": "#000000",    // Black

  "SpellDestruction": "#FF4500",  // Orange Red
  "SpellRestoration": "#32CD32",  // Lime Green
  "SpellAlteration": "#9370DB",   // Medium Purple
  "SpellDivination": "#00CED1"    // Dark Cyan
}
```

---

## Code Implementation

### 1. SpellSeeder

**File:** `RuneAndRust.Persistence/Data/SpellSeeder.cs`

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Persistence.Data;

/// <summary>
/// Seeds starter spells for the magic system.
/// All descriptions are Domain 4 compliant.
/// </summary>
public static class SpellSeeder
{
    /// <summary>
    /// Seeds starter spells if none exist.
    /// </summary>
    public static async Task SeedAsync(RuneAndRustDbContext context, ILogger? logger = null)
    {
        // Idempotency check
        if (await context.Spells.AnyAsync())
        {
            logger?.LogDebug("[SpellSeeder] Spells already exist, skipping seed");
            return;
        }

        logger?.LogInformation("[SpellSeeder] Seeding starter spells...");

        var spells = GetStarterSpells();

        await context.Spells.AddRangeAsync(spells);
        await context.SaveChangesAsync();

        // Log summary by school
        var bySchool = spells.GroupBy(s => s.School);
        foreach (var group in bySchool)
        {
            logger?.LogInformation("[SpellSeeder] Seeded {Count} {School} spells",
                group.Count(), group.Key);
        }

        logger?.LogInformation("[SpellSeeder] Seeded {Total} spells across {Schools} schools",
            spells.Count, bySchool.Count());
    }

    /// <summary>
    /// Gets all starter spells.
    /// </summary>
    public static List<Spell> GetStarterSpells()
    {
        var spells = new List<Spell>();

        spells.AddRange(GetDestructionSpells());
        spells.AddRange(GetRestorationSpells());
        spells.AddRange(GetAlterationSpells());
        spells.AddRange(GetDivinationSpells());

        return spells;
    }

    /// <summary>
    /// Gets Destruction school spells.
    /// </summary>
    public static List<Spell> GetDestructionSpells()
    {
        return new List<Spell>
        {
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Spark",
                Description = "A whisper to the old fire-spirits, coaxing forth a tongue of flame.",
                School = SpellSchool.Destruction,
                TargetType = SpellTargetType.SingleEnemy,
                Range = SpellRange.Close,
                ApCost = 2,
                FluxCost = 8,
                BasePower = 6,
                EffectScript = "DAMAGE:Fire:1d6",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            },
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Frost Touch",
                Description = "The caster's hand draws heat from flesh, leaving only the cold of the grave.",
                School = SpellSchool.Destruction,
                TargetType = SpellTargetType.SingleEnemy,
                Range = SpellRange.Touch,
                ApCost = 3,
                FluxCost = 10,
                BasePower = 8,
                EffectScript = "DAMAGE:Cold:1d8",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            },
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Firebolt",
                Description = "A bolt of fire hurled from the palm, ancient and terrible.",
                School = SpellSchool.Destruction,
                TargetType = SpellTargetType.SingleEnemy,
                Range = SpellRange.Medium,
                ApCost = 3,
                FluxCost = 10,
                BasePower = 8,
                EffectScript = "DAMAGE:Fire:1d8",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            },
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Thunder Strike",
                Description = "The sky's anger called down upon foes—a gift the Old Ones left behind.",
                School = SpellSchool.Destruction,
                TargetType = SpellTargetType.SingleEnemy,
                Range = SpellRange.Medium,
                ApCost = 5,
                FluxCost = 15,
                BasePower = 16,
                EffectScript = "DAMAGE:Lightning:2d8",
                Tier = 2,
                Archetype = ArchetypeType.Mystic
            }
        };
    }

    /// <summary>
    /// Gets Restoration school spells.
    /// </summary>
    public static List<Spell> GetRestorationSpells()
    {
        return new List<Spell>
        {
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Mend Flesh",
                Description = "Ancient words spoken over wounds, knitting flesh as the elders once did.",
                School = SpellSchool.Restoration,
                TargetType = SpellTargetType.SingleAlly,
                Range = SpellRange.Touch,
                ApCost = 3,
                FluxCost = 6,
                BasePower = 12,
                EffectScript = "HEAL:2d6",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            },
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Cleansing Light",
                Description = "Pure radiance that burns away corruption and soothes the wounded.",
                School = SpellSchool.Restoration,
                TargetType = SpellTargetType.SingleAlly,
                Range = SpellRange.Close,
                ApCost = 4,
                FluxCost = 10,
                BasePower = 8,
                EffectScript = "HEAL:1d8;CLEANSE:1",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            },
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Sanctuary",
                Description = "A shield of light wraps the caster, turning aside harm.",
                School = SpellSchool.Restoration,
                TargetType = SpellTargetType.Self,
                Range = SpellRange.Self,
                ApCost = 5,
                FluxCost = 12,
                BasePower = 10,
                EffectScript = "STATUS:Fortified:2:3;HEAL:1d6",
                Tier = 2,
                Archetype = ArchetypeType.Mystic
            }
        };
    }

    /// <summary>
    /// Gets Alteration school spells.
    /// </summary>
    public static List<Spell> GetAlterationSpells()
    {
        return new List<Spell>
        {
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Stone Skin",
                Description = "The skin hardens like the Old Ones' shells—briefly proof against harm.",
                School = SpellSchool.Alteration,
                TargetType = SpellTargetType.Self,
                Range = SpellRange.Self,
                ApCost = 4,
                FluxCost = 12,
                BasePower = 0,
                EffectScript = "STATUS:Fortified:3:2",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            },
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Weaken",
                Description = "A curse that frays the target's defenses, leaving them open to harm.",
                School = SpellSchool.Alteration,
                TargetType = SpellTargetType.SingleEnemy,
                Range = SpellRange.Close,
                ApCost = 3,
                FluxCost = 8,
                BasePower = 0,
                EffectScript = "STATUS:Vulnerable:2",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            },
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Haste",
                Description = "Time bends, granting swiftness to the touched—a dangerous gift.",
                School = SpellSchool.Alteration,
                TargetType = SpellTargetType.SingleAlly,
                Range = SpellRange.Close,
                ApCost = 5,
                FluxCost = 14,
                BasePower = 0,
                EffectScript = "STATUS:Hasted:2",
                Tier = 2,
                Archetype = ArchetypeType.Mystic
            }
        };
    }

    /// <summary>
    /// Gets Divination school spells.
    /// </summary>
    public static List<Spell> GetDivinationSpells()
    {
        return new List<Spell>
        {
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Spirit Sight",
                Description = "The caster's eyes cloud, then clear—seeing what others cannot.",
                School = SpellSchool.Divination,
                TargetType = SpellTargetType.Self,
                Range = SpellRange.Self,
                ApCost = 2,
                FluxCost = 4,
                BasePower = 0,
                EffectScript = "STATUS:TrueSeeing:3",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            },
            new Spell
            {
                Id = Guid.NewGuid(),
                Name = "Analyze Foe",
                Description = "The target's weaknesses revealed to the discerning eye.",
                School = SpellSchool.Divination,
                TargetType = SpellTargetType.SingleEnemy,
                Range = SpellRange.Medium,
                ApCost = 2,
                FluxCost = 5,
                BasePower = 0,
                EffectScript = "STATUS:Analyzed:3",
                Tier = 1,
                Archetype = ArchetypeType.Mystic
            }
        };
    }
}
```

### 2. FluxWidget

**File:** `RuneAndRust.Terminal/Rendering/FluxWidget.cs`

```csharp
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using Spectre.Console;

namespace RuneAndRust.Terminal.Rendering;

/// <summary>
/// Renders Flux-related UI elements.
/// </summary>
public static class FluxWidget
{
    /// <summary>
    /// Renders a Flux progress bar with threshold indicator.
    /// </summary>
    public static string RenderFluxBar(int flux, IThemeService themeService, int width = 10)
    {
        // Calculate fill
        var pct = Math.Clamp(flux / 100.0, 0, 1);
        var filled = (int)(pct * width);
        var empty = width - filled;

        // Build bar with special character for flux
        var bar = new string('▓', filled) + new string('░', empty);

        // Get color based on threshold
        var color = GetFluxColor(flux, themeService);

        // Get threshold label
        var (threshold, thresholdColor) = GetThresholdLabel(flux, themeService);

        return $"[{color.ToMarkup()}]{bar}[/] {flux} [{thresholdColor.ToMarkup()}]{threshold}[/]";
    }

    /// <summary>
    /// Gets the color for the Flux display based on current level.
    /// </summary>
    public static Color GetFluxColor(int flux, IThemeService themeService)
    {
        var role = flux switch
        {
            >= 75 => "FluxOverload",   // Bright red
            >= 50 => "FluxCritical",   // Red
            >= 25 => "FluxElevated",   // Yellow
            _ => "FluxSafe"            // Green
        };

        return ParseColor(themeService.GetColor(role));
    }

    /// <summary>
    /// Gets the threshold label and color.
    /// </summary>
    public static (string Label, Color Color) GetThresholdLabel(int flux, IThemeService themeService)
    {
        return flux switch
        {
            >= 75 => ("[OVERLOAD]", ParseColor(themeService.GetColor("FluxOverload"))),
            >= 50 => ("[CRITICAL]", ParseColor(themeService.GetColor("FluxCritical"))),
            >= 25 => ("[ELEVATED]", ParseColor(themeService.GetColor("FluxElevated"))),
            _ => ("[SAFE]", ParseColor(themeService.GetColor("FluxSafe")))
        };
    }

    /// <summary>
    /// Gets the FluxThreshold enum value.
    /// </summary>
    public static FluxThreshold GetThreshold(int flux)
    {
        return flux switch
        {
            >= 75 => FluxThreshold.Overload,
            >= 50 => FluxThreshold.Critical,
            >= 25 => FluxThreshold.Elevated,
            _ => FluxThreshold.Safe
        };
    }

    /// <summary>
    /// Renders a compact Flux indicator for tight spaces.
    /// </summary>
    public static string RenderCompact(int flux, IThemeService themeService)
    {
        var color = GetFluxColor(flux, themeService);
        var threshold = GetThreshold(flux);
        var indicator = threshold switch
        {
            FluxThreshold.Overload => "!!!",
            FluxThreshold.Critical => "!!",
            FluxThreshold.Elevated => "!",
            _ => ""
        };

        return $"[{color.ToMarkup()}]Flux:{flux}{indicator}[/]";
    }

    private static Color ParseColor(string hex)
    {
        return Color.FromMarkup(hex) ?? Color.Grey;
    }
}
```

### 3. StatusWidget Extensions (AP Bar)

**Add to:** `RuneAndRust.Terminal/Rendering/StatusWidget.cs`

```csharp
/// <summary>
/// Gets the color for AP display based on current level.
/// </summary>
public static Color GetApColor(int current, int max, IThemeService themeService)
{
    if (max == 0) return ParseColor(themeService.GetColor("NeutralColor"));

    var pct = (double)current / max * 100;
    var role = pct switch
    {
        <= 20 => "ApCritical",   // Red - nearly depleted
        <= 40 => "ApLow",        // Orange - running low
        <= 60 => "ApMedium",     // Yellow - mid-range
        _ => "ApFull"            // Cyan - healthy
    };

    return ParseColor(themeService.GetColor(role));
}

/// <summary>
/// Renders an AP bar with appropriate styling.
/// </summary>
public static string RenderApBar(int current, int max, IThemeService themeService, int width = 10)
{
    var bar = RenderBar(current, max, width);
    var color = GetApColor(current, max, themeService);
    var dimColor = themeService.GetColor("DimColor");

    return $"[{color.ToMarkup()}]{bar}[/] [{dimColor}]{current}/{max}[/]";
}
```

### 4. CorruptionWidget

**File:** `RuneAndRust.Terminal/Rendering/CorruptionWidget.cs`

```csharp
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using Spectre.Console;

namespace RuneAndRust.Terminal.Rendering;

/// <summary>
/// Renders Corruption-related UI elements.
/// </summary>
public static class CorruptionWidget
{
    /// <summary>
    /// Renders a corruption indicator.
    /// </summary>
    public static string RenderIndicator(int corruption, CorruptionLevel level, IThemeService themeService)
    {
        // Build bar (0-100)
        var width = 10;
        var pct = Math.Clamp(corruption / 100.0, 0, 1);
        var filled = (int)(pct * width);
        var empty = width - filled;
        var bar = new string('█', filled) + new string('░', empty);

        // Get color
        var color = GetCorruptionColor(level, themeService);

        // Get label
        var label = GetCorruptionLabel(level);

        return $"[{color.ToMarkup()}]{bar}[/] {corruption} [{color.ToMarkup()}][{label}][/]";
    }

    /// <summary>
    /// Gets the color for corruption display.
    /// </summary>
    public static Color GetCorruptionColor(CorruptionLevel level, IThemeService themeService)
    {
        var role = level switch
        {
            CorruptionLevel.Lost => "CorruptionLost",
            CorruptionLevel.Blighted => "CorruptionBlighted",
            CorruptionLevel.Afflicted => "CorruptionAfflicted",
            CorruptionLevel.Tainted => "CorruptionTainted",
            _ => "CorruptionNone"
        };

        return ParseColor(themeService.GetColor(role));
    }

    /// <summary>
    /// Gets the label for corruption level.
    /// </summary>
    public static string GetCorruptionLabel(CorruptionLevel level)
    {
        return level switch
        {
            CorruptionLevel.Lost => "LOST",
            CorruptionLevel.Blighted => "Blighted",
            CorruptionLevel.Afflicted => "Afflicted",
            CorruptionLevel.Tainted => "Tainted",
            _ => "Untouched"
        };
    }

    /// <summary>
    /// Renders a compact corruption indicator.
    /// </summary>
    public static string RenderCompact(int corruption, CorruptionLevel level, IThemeService themeService)
    {
        if (level == CorruptionLevel.Untouched)
            return string.Empty; // Don't show if pristine

        var color = GetCorruptionColor(level, themeService);
        return $"[{color.ToMarkup()}]☠ {corruption}[/]";
    }

    private static Color ParseColor(string hex)
    {
        return Color.FromMarkup(hex) ?? Color.Grey;
    }
}
```

### 5. SpellListRenderer

**File:** `RuneAndRust.Terminal/Rendering/SpellListRenderer.cs`

```csharp
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models.Combat;
using Spectre.Console;

namespace RuneAndRust.Terminal.Rendering;

/// <summary>
/// Renders the spell list for combat.
/// </summary>
public static class SpellListRenderer
{
    /// <summary>
    /// Renders the full spell list grouped by school.
    /// </summary>
    public static Panel Render(
        IEnumerable<Spell> spells,
        Combatant caster,
        IAetherService aetherService,
        IThemeService themeService)
    {
        var spellList = spells.ToList();

        if (spellList.Count == 0)
        {
            return new Panel(new Markup("[grey]No spells known.[/]"))
                .Header("[bold]KNOWN SPELLS[/]")
                .Border(BoxBorder.Rounded);
        }

        var rows = new List<IRenderable>();

        // Group by school
        var grouped = spellList
            .GroupBy(s => s.School)
            .OrderBy(g => (int)g.Key);

        var spellNumber = 1;

        foreach (var group in grouped)
        {
            // School header
            var schoolColor = GetSchoolColor(group.Key, themeService);
            rows.Add(new Text(""));
            rows.Add(new Markup($"[bold {schoolColor.ToMarkup()}]{group.Key.ToString().ToUpper()}[/]"));

            // Spells in school
            var schoolSpells = group.OrderBy(s => s.ApCost).ToList();
            for (var i = 0; i < schoolSpells.Count; i++)
            {
                var spell = schoolSpells[i];
                var isLast = i == schoolSpells.Count - 1;
                var prefix = isLast ? "└─" : "├─";

                var entry = FormatSpellEntry(
                    spell,
                    spellNumber++,
                    prefix,
                    caster,
                    schoolColor,
                    themeService);

                rows.Add(new Markup(entry));
            }
        }

        // Footer with current resources
        rows.Add(new Text(""));
        rows.Add(new Rule().RuleStyle(themeService.GetColor("DimColor")));
        rows.Add(CreateFooter(caster, aetherService, themeService));

        var panel = new Panel(new Rows(rows))
            .Header("[bold]KNOWN SPELLS[/]")
            .Border(BoxBorder.Rounded)
            .BorderStyle(Style.Parse(themeService.GetColor("BorderColor")))
            .Padding(1, 0);

        return panel;
    }

    /// <summary>
    /// Formats a single spell entry.
    /// </summary>
    private static string FormatSpellEntry(
        Spell spell,
        int number,
        string prefix,
        Combatant caster,
        Color schoolColor,
        IThemeService themeService)
    {
        // Determine if affordable
        var canAfford = caster.CurrentAp >= spell.ApCost;
        var nameColor = canAfford ? schoolColor.ToMarkup() : "grey";
        var costColor = canAfford ? "white" : "grey dim";

        // Format costs
        var apCost = spell.ApCost.ToString().PadLeft(2);
        var fluxCost = spell.FluxCost.ToString().PadLeft(2);

        // Get effect summary
        var effectSummary = GetEffectSummary(spell);

        // Build entry
        var numberStr = $"[{number}]".PadRight(4);
        var nameStr = Markup.Escape(spell.Name).PadRight(16);

        return $"  {prefix} [{nameColor}]{numberStr}{nameStr}[/] [{costColor}]{apCost} AP │ {fluxCost} Flux │ {effectSummary}[/]";
    }

    /// <summary>
    /// Gets a brief summary of the spell's effect.
    /// </summary>
    private static string GetEffectSummary(Spell spell)
    {
        // Parse effect script for summary
        if (spell.EffectScript.StartsWith("DAMAGE:"))
        {
            var parts = spell.EffectScript.Split(':');
            if (parts.Length >= 2)
            {
                return $"{parts[1]} damage";
            }
        }

        if (spell.EffectScript.StartsWith("HEAL:"))
        {
            return "Healing";
        }

        if (spell.EffectScript.StartsWith("STATUS:"))
        {
            var parts = spell.EffectScript.Split(':');
            if (parts.Length >= 2)
            {
                return $"{parts[1]} effect";
            }
        }

        if (spell.EffectScript.Contains(";"))
        {
            return "Multiple effects";
        }

        return "Special";
    }

    /// <summary>
    /// Creates the footer with current resources.
    /// </summary>
    private static Markup CreateFooter(
        Combatant caster,
        IAetherService aetherService,
        IThemeService themeService)
    {
        var flux = aetherService.GetCurrentFlux();
        var risk = Math.Max(0, flux - 50);
        var threshold = FluxWidget.GetThreshold(flux);
        var (thresholdLabel, thresholdColor) = FluxWidget.GetThresholdLabel(flux, themeService);

        var apColor = StatusWidget.GetApColor(caster.CurrentAp, caster.MaxAp, themeService);
        var fluxColor = FluxWidget.GetFluxColor(flux, themeService);
        var riskColor = risk > 0 ? "red" : "green";

        return new Markup(
            $"  [{apColor.ToMarkup()}]AP: {caster.CurrentAp}/{caster.MaxAp}[/]  │  " +
            $"[{fluxColor.ToMarkup()}]Flux: {flux}[/] [{thresholdColor.ToMarkup()}]{thresholdLabel}[/]  │  " +
            $"[{riskColor}]Risk: {risk}%[/]");
    }

    /// <summary>
    /// Gets the color for a spell school.
    /// </summary>
    public static Color GetSchoolColor(SpellSchool school, IThemeService themeService)
    {
        var role = school switch
        {
            SpellSchool.Destruction => "SpellDestruction",
            SpellSchool.Restoration => "SpellRestoration",
            SpellSchool.Alteration => "SpellAlteration",
            SpellSchool.Divination => "SpellDivination",
            _ => "NeutralColor"
        };

        return Color.FromMarkup(themeService.GetColor(role)) ?? Color.Grey;
    }

    /// <summary>
    /// Renders a compact spell list (for limited space).
    /// </summary>
    public static Table RenderCompact(
        IEnumerable<Spell> spells,
        Combatant caster,
        IThemeService themeService)
    {
        var table = new Table()
            .Border(TableBorder.None)
            .HideHeaders();

        table.AddColumn("Spell");
        table.AddColumn("Cost");

        foreach (var spell in spells.OrderBy(s => s.ApCost))
        {
            var canAfford = caster.CurrentAp >= spell.ApCost;
            var color = canAfford
                ? GetSchoolColor(spell.School, themeService).ToMarkup()
                : "grey";

            table.AddRow(
                new Markup($"[{color}]{Markup.Escape(spell.Name)}[/]"),
                new Markup($"[grey]{spell.ApCost} AP[/]"));
        }

        return table;
    }
}
```

### 6. CommandParser Extensions

**Add to:** `RuneAndRust.Engine/Services/CommandParser.cs`

```csharp
// In HandleCombat method, add after attack commands:

// Spell list command
if (command is "spells" or "magic" or "sp" or "grimoire")
{
    return await DisplaySpellListAsync(state);
}

// Cast command (already added in v0.4.3c)
if (command.StartsWith("cast "))
{
    return await ExecuteCastCommandAsync(command.Substring(5).Trim());
}

// Add new method:

/// <summary>
/// Displays the available spell list.
/// </summary>
private async Task<ParseResult> DisplaySpellListAsync(GameState state)
{
    var combatState = state.CombatState;

    if (combatState == null)
    {
        _inputHandler.DisplayMessage("[grey]Spells can only be viewed in combat.[/]");
        return ParseResult.None;
    }

    if (!combatState.IsPlayerTurn)
    {
        _inputHandler.DisplayMessage("[grey]Wait for your turn.[/]");
        return ParseResult.None;
    }

    var caster = combatState.ActiveCombatant!;

    // Check archetype
    var archetype = caster.CharacterSource?.Archetype ?? ArchetypeType.Warrior;
    var tier = (caster.CharacterSource?.Level ?? 1) / 3 + 1;

    // Get available spells
    var spells = await _spellRepository.GetAvailableForCasterAsync(archetype, tier);
    var spellList = spells.ToList();

    if (spellList.Count == 0)
    {
        if (archetype != ArchetypeType.Mystic)
        {
            _inputHandler.DisplayMessage("[grey]You have no magical training.[/]");
        }
        else
        {
            _inputHandler.DisplayMessage("[grey]You know no spells.[/]");
        }
        return ParseResult.None;
    }

    // Render spell list
    var panel = SpellListRenderer.Render(spellList, caster, _aetherService, _themeService);
    AnsiConsole.Write(panel);

    _logger.LogDebug("[Parser] Displayed {Count} spells for {Caster}",
        spellList.Count, caster.Name);

    return ParseResult.None;
}
```

### 7. Help System Extensions

**Add to DisplayCombatHelp() in CommandParser.cs:**

```csharp
private void DisplayCombatHelp()
{
    _inputHandler.DisplayMessage("=== COMBAT ===");
    _inputHandler.DisplayMessage("");
    _inputHandler.DisplayMessage("Attacks:");
    _inputHandler.DisplayMessage("  attack <target>  - Standard attack (25 stamina, d6 damage)");
    _inputHandler.DisplayMessage("  heavy <target>   - Heavy attack (40 stamina, d8 damage)");
    _inputHandler.DisplayMessage("  quick <target>   - Quick attack (15 stamina, d4 damage)");
    _inputHandler.DisplayMessage("");
    _inputHandler.DisplayMessage("Abilities:");
    _inputHandler.DisplayMessage("  use <ability>    - Use an active ability");
    _inputHandler.DisplayMessage("  abilities, ab    - Show available abilities");
    _inputHandler.DisplayMessage("");

    // NEW: Magic section
    _inputHandler.DisplayMessage("[cyan]Magic (Mystic Only):[/]");
    _inputHandler.DisplayMessage("  [cyan]cast <spell>[/]            - Cast a spell on default target");
    _inputHandler.DisplayMessage("  [cyan]cast <spell> on <target>[/] - Cast on specific target");
    _inputHandler.DisplayMessage("  [cyan]spells, magic, sp[/]       - Show known spells");
    _inputHandler.DisplayMessage("");

    _inputHandler.DisplayMessage("Defense:");
    _inputHandler.DisplayMessage("  defend, block    - Reduce incoming damage");
    _inputHandler.DisplayMessage("  dodge            - Attempt to evade next attack");
    _inputHandler.DisplayMessage("");
    _inputHandler.DisplayMessage("Other:");
    _inputHandler.DisplayMessage("  flee, run        - Attempt to escape combat");
    _inputHandler.DisplayMessage("  wait, pass       - Skip your turn");
    _inputHandler.DisplayMessage("  status           - View detailed combatant status");
    _inputHandler.DisplayMessage("  help, ?          - Show this help");
}
```

### 8. ContextHelpService Extensions

**Add to:** `RuneAndRust.Engine/Services/ContextHelpService.cs`

```csharp
/// <summary>
/// Analyzes magic-related combat state for tips.
/// </summary>
public List<HelpTip> AnalyzeMagic(CombatState combatState, IAetherService aetherService)
{
    var tips = new List<HelpTip>();

    if (combatState?.ActiveCombatant == null)
        return tips;

    var caster = combatState.ActiveCombatant;
    var flux = aetherService.GetCurrentFlux();
    var risk = Math.Max(0, flux - 50);

    // High risk warning
    if (risk >= 40)
    {
        tips.Add(HelpTip.Critical("DANGER",
            $"Backlash chance is {risk}%! Consider physical attacks or waiting."));
    }
    else if (risk >= 20)
    {
        tips.Add(HelpTip.Warning("Elevated Risk",
            $"Backlash chance: {risk}%. Cast with caution."));
    }
    else if (flux >= 25)
    {
        tips.Add(HelpTip.Info("Rising Flux",
            "Flux is elevated. Powerful spells increase risk."));
    }

    // AP warnings
    var apPct = (double)caster.CurrentAp / caster.MaxAp * 100;
    if (apPct <= 20)
    {
        tips.Add(HelpTip.Warning("Low Aether",
            "AP nearly depleted. Use items or rest to recover."));
    }
    else if (apPct <= 40)
    {
        tips.Add(HelpTip.Info("Aether Reserves",
            "AP running low. Conserve for critical moments."));
    }

    // Aether Sickness warning
    if (caster.StatusEffects.Any(e => e.Type == StatusEffectType.AetherSickness))
    {
        var sickness = caster.StatusEffects.First(e => e.Type == StatusEffectType.AetherSickness);
        tips.Add(HelpTip.Warning("Aether Sickness",
            $"-2 WILL, -1 WITS. Cannot concentrate. ({sickness.DurationRemaining} turns)"));
    }

    // Corruption warning
    var corruption = caster.CharacterSource?.CurrentCorruption ?? 0;
    if (corruption >= 50)
    {
        tips.Add(HelpTip.Critical("Soul Corruption",
            $"Corruption at {corruption}. Seek purification."));
    }
    else if (corruption >= 25)
    {
        tips.Add(HelpTip.Warning("Corruption",
            $"Corruption at {corruption}. Avoid Catastrophic backlash."));
    }

    return tips.Take(MaxTips).ToList();
}
```

### 9. Program.cs Seeder Registration

**Add to Program.cs in the initialization block:**

```csharp
using (var scope = host.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<RuneAndRustDbContext>();
    var templateLoader = scope.ServiceProvider.GetRequiredService<ITemplateLoaderService>();
    var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();

    // Existing seeders
    AbilitySeeder.SeedAsync(context).GetAwaiter().GetResult();
    ConditionSeeder.SeedAsync(context).GetAwaiter().GetResult();
    HazardTemplateSeeder.SeedAsync(context).GetAwaiter().GetResult();
    RoomTemplateSeeder.SeedAsync(context, templateLoader, logger).GetAwaiter().GetResult();

    // NEW: Spell seeder
    SpellSeeder.SeedAsync(context, logger).GetAwaiter().GetResult();
}
```

---

## Logging Matrix

### SpellSeeder Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| SeedAsync | AlreadySeeded | Debug | `"[SpellSeeder] Spells already exist, skipping seed"` | - |
| SeedAsync | Starting | Info | `"[SpellSeeder] Seeding starter spells..."` | - |
| SeedAsync | SchoolSeeded | Info | `"[SpellSeeder] Seeded {Count} {School} spells"` | Count, School |
| SeedAsync | Complete | Info | `"[SpellSeeder] Seeded {Total} spells across {Schools} schools"` | Total, Schools |

### SpellListRenderer Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| DisplaySpellListAsync | Displayed | Debug | `"[Parser] Displayed {Count} spells for {Caster}"` | Count, Caster |
| DisplaySpellListAsync | NoMagic | Debug | `"[Parser] {Caster} has no magical training"` | Caster |

### FluxWidget Logging

(No logging - pure rendering)

### ContextHelpService Logging

| Method | Event | Level | Template | Properties |
|--------|-------|-------|----------|------------|
| AnalyzeMagic | TipsGenerated | Debug | `"[ContextHelp] Generated {Count} magic tips"` | Count |

---

## Unit Testing Specification

### Test Class: SpellSeederTests.cs

**File:** `RuneAndRust.Tests/Persistence/Data/SpellSeederTests.cs`

#### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| Seeding | 6 | Basic seeding, idempotency, school coverage |
| Spell Validation | 4 | Required fields, effect scripts |
| Domain 4 Compliance | 4 | No precision measurements in descriptions |

**Total Seeder Tests: 14**

```csharp
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using RuneAndRust.Core.Enums;
using RuneAndRust.Persistence.Data;
using Xunit;

namespace RuneAndRust.Tests.Persistence.Data;

public class SpellSeederTests
{
    [Fact]
    public async Task SeedAsync_SeedsSpells_WhenDatabaseEmpty()
    {
        // Arrange
        using var context = CreateInMemoryContext();

        // Act
        await SpellSeeder.SeedAsync(context);

        // Assert
        var count = await context.Spells.CountAsync();
        count.Should().BeGreaterThan(0);
    }

    [Fact]
    public async Task SeedAsync_IsIdempotent_WhenCalledMultipleTimes()
    {
        // Arrange
        using var context = CreateInMemoryContext();
        await SpellSeeder.SeedAsync(context);
        var initialCount = await context.Spells.CountAsync();

        // Act
        await SpellSeeder.SeedAsync(context);
        var finalCount = await context.Spells.CountAsync();

        // Assert
        finalCount.Should().Be(initialCount);
    }

    [Fact]
    public async Task SeedAsync_SeedsAllFourSchools()
    {
        // Arrange
        using var context = CreateInMemoryContext();

        // Act
        await SpellSeeder.SeedAsync(context);

        // Assert
        var schools = await context.Spells
            .Select(s => s.School)
            .Distinct()
            .ToListAsync();

        schools.Should().Contain(SpellSchool.Destruction);
        schools.Should().Contain(SpellSchool.Restoration);
        schools.Should().Contain(SpellSchool.Alteration);
        schools.Should().Contain(SpellSchool.Divination);
    }

    [Fact]
    public void GetStarterSpells_ReturnsAtLeast12Spells()
    {
        // Act
        var spells = SpellSeeder.GetStarterSpells();

        // Assert
        spells.Should().HaveCountGreaterThanOrEqualTo(12);
    }

    [Fact]
    public void GetStarterSpells_AllSpellsHaveValidEffectScripts()
    {
        // Arrange
        var spells = SpellSeeder.GetStarterSpells();

        // Assert
        foreach (var spell in spells)
        {
            spell.EffectScript.Should().NotBeNullOrWhiteSpace();
            spell.EffectScript.Should().MatchRegex(@"^(DAMAGE|HEAL|STATUS|CLEANSE):");
        }
    }

    [Fact]
    public void GetStarterSpells_AllDescriptionsAreDomain4Compliant()
    {
        // Arrange
        var spells = SpellSeeder.GetStarterSpells();
        var forbiddenPatterns = new[]
        {
            @"\d+%",       // Percentages
            @"\d+\s*m",    // Meters
            @"\d+\s*°",    // Degrees
            @"\d+\s*Hz",   // Hertz
            @"\d+\s*dB"    // Decibels
        };

        // Assert
        foreach (var spell in spells)
        {
            foreach (var pattern in forbiddenPatterns)
            {
                spell.Description.Should().NotMatchRegex(pattern,
                    $"Spell '{spell.Name}' contains forbidden precision measurement");
            }
        }
    }

    [Fact]
    public void GetStarterSpells_AllSpellsHaveRequiredFields()
    {
        // Arrange
        var spells = SpellSeeder.GetStarterSpells();

        // Assert
        foreach (var spell in spells)
        {
            spell.Name.Should().NotBeNullOrWhiteSpace();
            spell.Description.Should().NotBeNullOrWhiteSpace();
            spell.ApCost.Should().BeGreaterThan(0);
            spell.FluxCost.Should().BeGreaterThan(0);
            spell.Tier.Should().BeGreaterThan(0);
        }
    }

    private static RuneAndRustDbContext CreateInMemoryContext()
    {
        var options = new DbContextOptionsBuilder<RuneAndRustDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        return new RuneAndRustDbContext(options);
    }
}
```

### Test Class: SpellListRendererTests.cs

**File:** `RuneAndRust.Tests/Terminal/Rendering/SpellListRendererTests.cs`

#### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| Rendering | 6 | Panel creation, school grouping, formatting |
| Affordability | 4 | Color changes based on AP |
| Footer | 2 | Resource display |

**Total Renderer Tests: 12**

### Test Class: FluxWidgetTests.cs

**File:** `RuneAndRust.Tests/Terminal/Rendering/FluxWidgetTests.cs`

#### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| Bar Rendering | 4 | Fill calculation, character counts |
| Color Selection | 4 | Threshold-based colors |
| Labels | 4 | Threshold labels |

**Total Widget Tests: 12**

### Test Class: MagicIntegrationTests.cs

**File:** `RuneAndRust.Tests/Integration/MagicIntegrationTests.cs`

#### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| Full Cast Cycle | 4 | Seeder → Repository → MagicService → BacklashService |
| Command Flow | 4 | Parser → CombatService → Display |

**Total Integration Tests: 8**

**Grand Total: 46 tests**

---

## Integration Points

### 1. SpellRepository Integration (v0.4.3b)

SpellSeeder populates data accessed by:
```csharp
await _spellRepository.GetAvailableForCasterAsync(archetype, tier);
await _spellRepository.GetByNameAsync(spellName);
```

### 2. AetherService Integration (v0.4.3a)

FluxWidget queries:
```csharp
var flux = _aetherService.GetCurrentFlux();
var threshold = _aetherService.GetThreshold();
```

### 3. BacklashService Integration (v0.4.3d)

ContextHelpService queries:
```csharp
var risk = Math.Max(0, flux - 50);
var corruption = caster.CharacterSource?.CurrentCorruption;
```

### 4. MagicService Integration (v0.4.3c)

CommandParser calls:
```csharp
var result = await _combatService.ExecutePlayerSpellAsync(spellName, targetName);
```

---

## Deliverable Checklist

### Data Layer

- [ ] **SpellSeeder.cs** - Seed 12 starter spells
  - [ ] GetDestructionSpells() - 4 spells
  - [ ] GetRestorationSpells() - 3 spells
  - [ ] GetAlterationSpells() - 3 spells
  - [ ] GetDivinationSpells() - 2 spells
  - [ ] Idempotency check
  - [ ] Domain 4 compliant descriptions

### TUI Components

- [ ] **FluxWidget.cs** - New renderer
  - [ ] RenderFluxBar()
  - [ ] GetFluxColor()
  - [ ] GetThresholdLabel()
  - [ ] RenderCompact()

- [ ] **CorruptionWidget.cs** - New renderer
  - [ ] RenderIndicator()
  - [ ] GetCorruptionColor()
  - [ ] GetCorruptionLabel()
  - [ ] RenderCompact()

- [ ] **SpellListRenderer.cs** - New renderer
  - [ ] Render() - Full grouped display
  - [ ] RenderCompact() - Minimal display
  - [ ] FormatSpellEntry()
  - [ ] GetSchoolColor()
  - [ ] CreateFooter()

- [ ] **StatusWidget.cs** - Extension
  - [ ] GetApColor()
  - [ ] RenderApBar()

### Theme Updates

- [ ] **Theme configuration** - New color roles
  - [ ] AP colors (Full, Medium, Low, Critical)
  - [ ] Flux colors (Safe, Elevated, Critical, Overload)
  - [ ] Corruption colors (None, Tainted, Afflicted, Blighted, Lost)
  - [ ] Spell school colors

### Command System

- [ ] **CommandParser.cs** - Extensions
  - [ ] Handle `spells`/`magic`/`sp` commands
  - [ ] DisplaySpellListAsync() method
  - [ ] Help text updates

- [ ] **ContextHelpService.cs** - Extensions
  - [ ] AnalyzeMagic() method
  - [ ] Flux risk tips
  - [ ] AP warning tips
  - [ ] Corruption tips

### Initialization

- [ ] **Program.cs** - Seeder registration
  - [ ] Add SpellSeeder.SeedAsync() call

### Testing

- [ ] **SpellSeederTests.cs** - 14 tests
- [ ] **SpellListRendererTests.cs** - 12 tests
- [ ] **FluxWidgetTests.cs** - 12 tests
- [ ] **MagicIntegrationTests.cs** - 8 tests

---

## Workflow

### Implementation Order

```
1. CREATE Theme Configuration
   └── Add new color roles for AP, Flux, Corruption, Schools

2. CREATE Data Seeder
   └── SpellSeeder.cs

3. CREATE TUI Widgets
   ├── FluxWidget.cs
   └── CorruptionWidget.cs

4. EXTEND StatusWidget
   └── Add AP bar methods

5. CREATE SpellListRenderer
   └── Full implementation

6. CREATE Tests (TDD)
   ├── SpellSeederTests.cs
   ├── FluxWidgetTests.cs
   └── SpellListRendererTests.cs

7. EXTEND CommandParser
   ├── Add spells command handler
   └── Update help text

8. EXTEND ContextHelpService
   └── Add AnalyzeMagic()

9. REGISTER Seeder
   └── Program.cs modification

10. CREATE Integration Tests
    └── MagicIntegrationTests.cs

11. VERIFY
    ├── Run all tests
    ├── Manual spell list testing
    ├── Verify HUD displays
    └── End-to-end cast cycle
```

### File Creation Order

| Order | File | Layer | Dependencies |
|-------|------|-------|--------------|
| 1 | Theme config updates | Terminal | None |
| 2 | SpellSeeder.cs | Persistence/Data | Spell entity (v0.4.3b) |
| 3 | FluxWidget.cs | Terminal/Rendering | IThemeService, IAetherService |
| 4 | CorruptionWidget.cs | Terminal/Rendering | IThemeService, CorruptionLevel |
| 5 | StatusWidget.cs (modify) | Terminal/Rendering | IThemeService |
| 6 | SpellListRenderer.cs | Terminal/Rendering | All widgets, Spell entity |
| 7 | SpellSeederTests.cs | Tests | SpellSeeder |
| 8 | FluxWidgetTests.cs | Tests | FluxWidget |
| 9 | SpellListRendererTests.cs | Tests | SpellListRenderer |
| 10 | CommandParser.cs (modify) | Engine/Services | SpellListRenderer |
| 11 | ContextHelpService.cs (modify) | Engine/Services | IAetherService |
| 12 | Program.cs (modify) | Terminal | SpellSeeder |
| 13 | MagicIntegrationTests.cs | Tests | All components |

---

## Changelog

```markdown
## v0.4.3e - The Resonance (Seeding & TUI Integration)

**Release Date:** TBD

### Summary
Completed the Magic Core System with starter spell data, enhanced combat HUD
displaying Aether Points and Flux levels, and the `spells` command for viewing
available magic during combat.

### Features
- **Starter Spells**: 12 spells across 4 schools seeded on first run
- **Combat HUD**: Now displays AP bar, Flux bar with threshold, corruption indicator
- **Spells Command**: View available spells grouped by school with costs
- **Context Tips**: Dynamic help tips for high Flux risk, low AP, Aether Sickness
- **School Colors**: Visual distinction for Destruction, Restoration, Alteration, Divination

### Starter Spells
| School | Spells |
|--------|--------|
| Destruction | Spark, Frost Touch, Firebolt, Thunder Strike |
| Restoration | Mend Flesh, Cleansing Light, Sanctuary |
| Alteration | Stone Skin, Weaken, Haste |
| Divination | Spirit Sight, Analyze Foe |

### Technical
- Created `SpellSeeder` with idempotent seeding logic
- Created `FluxWidget` for Flux bar rendering with threshold colors
- Created `CorruptionWidget` for corruption indicator rendering
- Created `SpellListRenderer` for grouped spell display
- Extended `StatusWidget` with AP bar methods
- Extended `CommandParser` with `spells` command
- Extended `ContextHelpService` with magic-related tips
- Added theme colors for AP, Flux, Corruption, and spell schools

### New Files
- `RuneAndRust.Persistence/Data/SpellSeeder.cs`
- `RuneAndRust.Terminal/Rendering/FluxWidget.cs`
- `RuneAndRust.Terminal/Rendering/CorruptionWidget.cs`
- `RuneAndRust.Terminal/Rendering/SpellListRenderer.cs`
- `RuneAndRust.Tests/Persistence/Data/SpellSeederTests.cs`
- `RuneAndRust.Tests/Terminal/Rendering/FluxWidgetTests.cs`
- `RuneAndRust.Tests/Terminal/Rendering/SpellListRendererTests.cs`
- `RuneAndRust.Tests/Integration/MagicIntegrationTests.cs`

### Modified Files
- `RuneAndRust.Terminal/Rendering/StatusWidget.cs` - Added AP bar
- `RuneAndRust.Engine/Services/CommandParser.cs` - Added spells command, help text
- `RuneAndRust.Engine/Services/ContextHelpService.cs` - Added magic tips
- `RuneAndRust.Terminal/Program.cs` - Added SpellSeeder initialization
- Theme configuration - Added new color roles

### Testing
- 46 new unit tests across 4 test classes
- Coverage: Seeding, rendering, widgets, integration

### Commands
```
spells, magic, sp  - View known spells grouped by school
cast <spell>       - Cast on default target
cast <spell> on <target>  - Cast on specific target
```

### HUD Display
```
╭──────────────────────────────────────────────────────────────╮
│ ERIK THE WANDERER                                            │
│ HP: ████████░░ 42/50   Stamina: ██████░░░░ 6/10             │
│ AP: ████░░░░░░ 4/10    Flux: ▓▓▓▓▓▓░░░░ 55 [CRITICAL]       │
│ Corruption: ░░░░░░░░░░ 5 [Untouched]                         │
╰──────────────────────────────────────────────────────────────╯
```

### Domain 4 Compliance
- All spell descriptions use archaeologist-perspective language
- No precision measurements in any spell text
- Threshold labels use qualitative terms (Safe, Elevated, Critical, Overload)
```

---

## v0.4.3 Complete

With v0.4.3e complete, the entire **Magic Core System** (The Weaver) is now implemented:

| Version | Name | Components | Tests |
|---------|------|------------|-------|
| v0.4.3a | The Aether | FluxState, AetherService, FluxChangedEvent | 39 |
| v0.4.3b | The Grimoire | Spell entity, SpellRepository, migration | 35 |
| v0.4.3c | The Incantation | MagicService, cast command, MagicResult | 53 |
| v0.4.3d | The Backlash | BacklashService, Corruption, Aether Sickness | 48 |
| v0.4.3e | The Resonance | SpellSeeder, TUI widgets, spells command | 46 |
| **Total** | | | **221** |

The magic system is now fully playable with:
- 12 starter spells across 4 schools
- Environmental Flux tracking with risk mechanics
- Backlash consequences scaling with severity
- Permanent corruption from Catastrophic failures
- Visual feedback in combat HUD
- Contextual help tips for magic situations
