# Changelog: v0.4.2b - The Lexicon

**Release Date:** 2025-12-30
**Total Tests:** 3621 (48 new tests added)
**Depends On:** v0.4.2a (The Repute - Faction System)

---

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Polymorphic JSON Serialization](#polymorphic-json-serialization)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Database Configuration](#database-configuration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.2b](#directory-structure-after-v042b)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

v0.4.2b establishes the **Dialogue Data Model** foundation for Rune & Rust — the entity structures for branching conversations and the polymorphic condition system that gates dialogue options based on character state, faction standing, inventory, specializations, and skill checks.

**Key Features:**
- **Dialogue Tree Structure:** `DialogueTree` → `DialogueNode` → `DialogueOption` hierarchy
- **8 Polymorphic Condition Types:** Attribute, Level, Reputation, Flag, Item, Specialization, Node, SkillCheck
- **3 Effect Types:** ModifyReputation, GiveItem, SetFlag
- **Condition Evaluator Service:** Full evaluation with AND logic for multiple conditions
- **Visibility Modes:** `ShowLocked` (show greyed-out) vs `Hidden` (completely invisible)
- **JSONB Storage:** Polymorphic conditions/effects stored as JSONB columns in PostgreSQL
- **Flag System:** GameState extended with `Flags` dictionary for quest/dialogue state tracking

**Layers Touched:** Core (Enums, Entities, Conditions, Effects, Models, Interfaces), Engine (Services), Persistence (Repositories, DbContext), Terminal (DI), Tests

**Patterns Used:** Polymorphic JSON serialization with `[JsonDerivedType]`, Result records with factory methods, Repository pattern, Type aliases for namespace conflict resolution, Visitor-like condition evaluation

---

## New Files Created

### Core Layer - Enums (4 files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/DialogueConditionType.cs` | 8-value discriminator for condition polymorphism |
| `RuneAndRust.Core/Enums/ComparisonType.cs` | 6-value comparison operators (>=, ==, >, <, <=, !=) |
| `RuneAndRust.Core/Enums/OptionVisibility.cs` | 2-value visibility mode (ShowLocked, Hidden) |
| `RuneAndRust.Core/Enums/DialogueEffectType.cs` | 8-value discriminator for effect polymorphism |

### Core Layer - Entities (3 files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/DialogueTree.cs` | Root container with NPC metadata, faction association |
| `RuneAndRust.Core/Entities/DialogueNode.cs` | Conversation nodes with speaker, text, terminal flag |
| `RuneAndRust.Core/Entities/DialogueOption.cs` | Player choices with JSONB conditions/effects lists |

### Core Layer - Conditions (9 files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Conditions/DialogueCondition.cs` | Abstract base with `[JsonPolymorphic]` attributes |
| `RuneAndRust.Core/Conditions/AttributeCondition.cs` | Check attribute vs threshold with comparison operator |
| `RuneAndRust.Core/Conditions/LevelCondition.cs` | Minimum character level requirement |
| `RuneAndRust.Core/Conditions/ReputationCondition.cs` | Faction disposition requirement |
| `RuneAndRust.Core/Conditions/FlagCondition.cs` | Game flag true/false check |
| `RuneAndRust.Core/Conditions/ItemCondition.cs` | Item possession with quantity |
| `RuneAndRust.Core/Conditions/SpecializationCondition.cs` | Specialization access check |
| `RuneAndRust.Core/Conditions/NodeCondition.cs` | Spec node unlocked check |
| `RuneAndRust.Core/Conditions/SkillCheckCondition.cs` | Dice roll vs DC with attribute pool |

### Core Layer - Effects (4 files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Effects/DialogueEffect.cs` | Abstract base with `[JsonPolymorphic]` attributes |
| `RuneAndRust.Core/Effects/ModifyReputationEffect.cs` | Change faction reputation by amount |
| `RuneAndRust.Core/Effects/GiveItemEffect.cs` | Give item with quantity |
| `RuneAndRust.Core/Effects/SetFlagEffect.cs` | Set/clear game flag |

### Core Layer - Models (2 files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/ConditionResult.cs` | Result record with Success/Fail/SkillCheck factories |
| `RuneAndRust.Core/Models/OptionVisibilityResult.cs` | Available/Locked/Hidden visibility state |

### Core Layer - Interfaces (2 files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IDialogueConditionEvaluator.cs` | Evaluator interface with 3 methods |
| `RuneAndRust.Core/Interfaces/IDialogueRepository.cs` | Repository interface for tree/node queries |

### Engine Layer (1 file)

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/DialogueConditionEvaluator.cs` | Full condition evaluation with all 8 types |

### Persistence Layer (1 file)

| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Repositories/DialogueRepository.cs` | EF Core repository with eager loading |

### Test Layer (1 file)

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/DialogueConditionEvaluatorTests.cs` | 48 unit tests covering all condition types |

**Total New Files:** 27

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/GameState.cs` | Added `Flags` dictionary with `GetFlag()`/`SetFlag()` methods, updated `Reset()` |
| `RuneAndRust.Core/Interfaces/IInventoryService.cs` | Added `HasItemAsync(Guid characterId, string itemId, int minQuantity)` |
| `RuneAndRust.Engine/Services/InventoryService.cs` | Implemented `HasItemAsync` with GUID and name-based lookup |
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Added 3 DbSets, entity configurations, JSONB converters |
| `RuneAndRust.Terminal/Program.cs` | Registered `IDialogueRepository` and `IDialogueConditionEvaluator` |

**Total Modified Files:** 5

---

## Code Implementation Details

### Enums

#### DialogueConditionType (8 values)

```csharp
public enum DialogueConditionType
{
    Attribute = 0,       // Check character attribute value
    Level = 1,           // Check character level
    Reputation = 2,      // Check faction disposition
    Flag = 3,            // Check game state flag
    Item = 4,            // Check inventory possession
    Specialization = 5,  // Check specialization access
    Node = 6,            // Check spec node unlocked
    SkillCheck = 7       // Dice roll vs DC
}
```

#### ComparisonType (6 values)

```csharp
public enum ComparisonType
{
    GreaterThanOrEqual = 0,  // >= (most common)
    Equal = 1,               // ==
    GreaterThan = 2,         // >
    LessThan = 3,            // <
    LessThanOrEqual = 4,     // <=
    NotEqual = 5             // !=
}
```

#### OptionVisibility (2 values)

```csharp
public enum OptionVisibility
{
    ShowLocked = 0,  // Show as greyed-out with requirement hint
    Hidden = 1       // Completely invisible to player
}
```

**Design Intent:**
- `ShowLocked`: Player sees "[Requires WITS 6]" — guides character building
- `Hidden`: Secret option only revealed when conditions met — rewards exploration

#### DialogueEffectType (8 values)

```csharp
public enum DialogueEffectType
{
    ModifyReputation = 0,   // Change faction standing
    GiveItem = 1,           // Add item to inventory
    TakeItem = 2,           // Remove item from inventory
    SetFlag = 3,            // Set/clear game flag
    StartQuest = 4,         // Begin quest (future)
    CompleteQuest = 5,      // Complete quest objective (future)
    ModifyAttribute = 6,    // Temporary attribute modifier (future)
    TriggerEvent = 7        // Fire game event (future)
}
```

### Entities

#### DialogueTree Entity

```csharp
public class DialogueTree
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string TreeId { get; set; } = string.Empty;          // e.g., "npc_old_scavenger"
    public string NpcName { get; set; } = string.Empty;         // Display name
    public string? NpcTitle { get; set; }                       // Optional title
    public string RootNodeId { get; set; } = "root";            // Starting node
    public FactionType? AssociatedFaction { get; set; }         // For faction-based gating
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime LastModified { get; set; } = DateTime.UtcNow;

    // Navigation
    public ICollection<DialogueNode> Nodes { get; set; } = new List<DialogueNode>();
}
```

#### DialogueNode Entity

```csharp
public class DialogueNode
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public Guid TreeId { get; set; }                            // FK to DialogueTree
    public string NodeId { get; set; } = string.Empty;          // Local ID within tree
    public string SpeakerName { get; set; } = string.Empty;     // Who's speaking
    public string Text { get; set; } = string.Empty;            // Dialogue content
    public bool IsTerminal { get; set; } = false;               // Ends conversation

    // Navigation
    public DialogueTree Tree { get; set; } = null!;
    public ICollection<DialogueOption> Options { get; set; } = new List<DialogueOption>();
}
```

#### DialogueOption Entity

```csharp
public class DialogueOption
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public Guid NodeId { get; set; }                            // FK to DialogueNode
    public string Text { get; set; } = string.Empty;            // Player choice text
    public string? NextNodeId { get; set; }                     // Target node or null for terminal
    public int DisplayOrder { get; set; } = 0;                  // Sort order
    public OptionVisibility VisibilityMode { get; set; }        // ShowLocked or Hidden

    // JSONB Columns
    public List<DialogueCondition> Conditions { get; set; } = new();
    public List<DialogueEffect> Effects { get; set; } = new();

    // Navigation
    public DialogueNode Node { get; set; } = null!;

    // Computed Properties
    public bool HasConditions => Conditions.Count > 0;
    public bool HasEffects => Effects.Count > 0;
    public bool IsTerminal => string.IsNullOrEmpty(NextNodeId);
}
```

### Condition Types

#### Base DialogueCondition (Abstract)

```csharp
[JsonPolymorphic(TypeDiscriminatorPropertyName = "$type")]
[JsonDerivedType(typeof(AttributeCondition), "attribute")]
[JsonDerivedType(typeof(LevelCondition), "level")]
[JsonDerivedType(typeof(ReputationCondition), "reputation")]
[JsonDerivedType(typeof(FlagCondition), "flag")]
[JsonDerivedType(typeof(ItemCondition), "item")]
[JsonDerivedType(typeof(SpecializationCondition), "specialization")]
[JsonDerivedType(typeof(NodeCondition), "node")]
[JsonDerivedType(typeof(SkillCheckCondition), "skillcheck")]
public abstract class DialogueCondition
{
    public abstract DialogueConditionType Type { get; }
    public bool HideWhenFailed { get; set; } = false;  // Override visibility
    public abstract string GetDisplayHint();           // e.g., "[WITS >= 6]"
}
```

#### AttributeCondition

```csharp
public class AttributeCondition : DialogueCondition
{
    public override DialogueConditionType Type => DialogueConditionType.Attribute;
    public CharacterAttribute Attribute { get; set; }     // Which attribute
    public ComparisonType Comparison { get; set; }        // How to compare
    public int Threshold { get; set; }                    // Target value

    public override string GetDisplayHint() =>
        $"[{Attribute} {GetComparisonSymbol()} {Threshold}]";
}
```

#### LevelCondition

```csharp
public class LevelCondition : DialogueCondition
{
    public override DialogueConditionType Type => DialogueConditionType.Level;
    public int MinLevel { get; set; }

    public override string GetDisplayHint() => $"[Level {MinLevel}]";
}
```

#### ReputationCondition

```csharp
public class ReputationCondition : DialogueCondition
{
    public override DialogueConditionType Type => DialogueConditionType.Reputation;
    public FactionType Faction { get; set; }
    public Disposition MinDisposition { get; set; }

    public override string GetDisplayHint() =>
        $"[{Faction}: {MinDisposition}]";
}
```

#### FlagCondition

```csharp
public class FlagCondition : DialogueCondition
{
    public override DialogueConditionType Type => DialogueConditionType.Flag;
    public string FlagKey { get; set; } = string.Empty;
    public bool RequiredValue { get; set; } = true;

    public override string GetDisplayHint() =>
        RequiredValue ? $"[Requires: {FlagKey}]" : $"[Not: {FlagKey}]";
}
```

#### ItemCondition

```csharp
public class ItemCondition : DialogueCondition
{
    public override DialogueConditionType Type => DialogueConditionType.Item;
    public string ItemId { get; set; } = string.Empty;    // GUID or name
    public int MinQuantity { get; set; } = 1;

    public override string GetDisplayHint() =>
        MinQuantity > 1 ? $"[Has: {ItemId} x{MinQuantity}]" : $"[Has: {ItemId}]";
}
```

#### SpecializationCondition

```csharp
public class SpecializationCondition : DialogueCondition
{
    public override DialogueConditionType Type => DialogueConditionType.Specialization;
    public Guid SpecializationId { get; set; }
    public string SpecializationName { get; set; } = string.Empty;

    public override string GetDisplayHint() => $"[Is: {SpecializationName}]";
}
```

#### NodeCondition

```csharp
public class NodeCondition : DialogueCondition
{
    public override DialogueConditionType Type => DialogueConditionType.Node;
    public Guid NodeId { get; set; }
    public string NodeName { get; set; } = string.Empty;

    public override string GetDisplayHint() => $"[Has: {NodeName}]";
}
```

#### SkillCheckCondition

```csharp
public class SkillCheckCondition : DialogueCondition
{
    public override DialogueConditionType Type => DialogueConditionType.SkillCheck;
    public CharacterAttribute Attribute { get; set; }     // Pool attribute
    public int DifficultyClass { get; set; }              // Required net successes
    public string? CheckDescription { get; set; }         // Optional flavor text

    public override string GetDisplayHint() =>
        $"[{Attribute.ToString().ToUpper()} DC {DifficultyClass}]";
}
```

### Effect Types

#### Base DialogueEffect (Abstract)

```csharp
[JsonPolymorphic(TypeDiscriminatorPropertyName = "$type")]
[JsonDerivedType(typeof(ModifyReputationEffect), "modify_reputation")]
[JsonDerivedType(typeof(GiveItemEffect), "give_item")]
[JsonDerivedType(typeof(SetFlagEffect), "set_flag")]
public abstract class DialogueEffect
{
    public abstract DialogueEffectType Type { get; }
    public abstract string GetDescription();   // e.g., "+10 with Dvergr"
}
```

#### ModifyReputationEffect

```csharp
public class ModifyReputationEffect : DialogueEffect
{
    public override DialogueEffectType Type => DialogueEffectType.ModifyReputation;
    public FactionType Faction { get; set; }
    public int Amount { get; set; }

    public override string GetDescription() =>
        Amount >= 0 ? $"+{Amount} with {Faction}" : $"{Amount} with {Faction}";
}
```

#### GiveItemEffect

```csharp
public class GiveItemEffect : DialogueEffect
{
    public override DialogueEffectType Type => DialogueEffectType.GiveItem;
    public Guid ItemId { get; set; }
    public string ItemName { get; set; } = string.Empty;
    public int Quantity { get; set; } = 1;

    public override string GetDescription() =>
        Quantity > 1 ? $"Receive: {ItemName} x{Quantity}" : $"Receive: {ItemName}";
}
```

#### SetFlagEffect

```csharp
public class SetFlagEffect : DialogueEffect
{
    public override DialogueEffectType Type => DialogueEffectType.SetFlag;
    public string FlagKey { get; set; } = string.Empty;
    public bool Value { get; set; } = true;

    public override string GetDescription() =>
        Value ? $"Set: {FlagKey}" : $"Clear: {FlagKey}";
}
```

### Result Models

#### ConditionResult (Record)

```csharp
public record ConditionResult(
    bool Passed,
    DialogueConditionType ConditionType,
    string DisplayHint,
    string? FailureReason = null,
    IReadOnlyList<int>? DiceRolls = null,
    int? NetSuccesses = null)
{
    // Factory Methods
    public static ConditionResult Success(DialogueConditionType type, string hint);
    public static ConditionResult Fail(DialogueConditionType type, string hint, string reason);
    public static ConditionResult SkillCheckSuccess(string hint, IReadOnlyList<int> rolls, int net);
    public static ConditionResult SkillCheckFail(string hint, string reason, IReadOnlyList<int> rolls, int net);

    // Computed
    public bool IsSkillCheck => DiceRolls != null;
}
```

#### OptionVisibilityResult (Record)

```csharp
public record OptionVisibilityResult(
    Guid OptionId,
    bool IsVisible,
    bool IsAvailable,
    string? LockReason = null,
    string? LockHint = null,
    IReadOnlyList<ConditionResult>? ConditionResults = null)
{
    // Factory Methods
    public static OptionVisibilityResult Available(Guid optionId);
    public static OptionVisibilityResult Locked(Guid optionId, string reason, string hint, IReadOnlyList<ConditionResult>? results = null);
    public static OptionVisibilityResult Hidden(Guid optionId);
}
```

### GameState Modification

```csharp
// Added to GameState.cs
public Dictionary<string, bool> Flags { get; set; } = new();

public bool GetFlag(string key) =>
    Flags.TryGetValue(key, out var val) && val;

public void SetFlag(string key, bool value) =>
    Flags[key] = value;

// Updated Reset() method to clear flags
public void Reset()
{
    // ... existing reset logic ...
    Flags.Clear();
}
```

### IInventoryService Addition

```csharp
// Added to IInventoryService.cs
/// <summary>
/// Checks if a character has a specific item in their inventory (v0.4.2b).
/// Used by dialogue conditions to gate options on item possession.
/// </summary>
/// <param name="characterId">The character's ID.</param>
/// <param name="itemId">The item ID or name to check for.</param>
/// <param name="minQuantity">Minimum quantity required (default: 1).</param>
/// <returns>True if the character has the item in sufficient quantity.</returns>
Task<bool> HasItemAsync(Guid characterId, string itemId, int minQuantity = 1);
```

---

## Polymorphic JSON Serialization

### How It Works

The dialogue system uses System.Text.Json's polymorphic serialization to store heterogeneous condition/effect types in a single JSONB column.

**Attributes on Base Class:**

```csharp
[JsonPolymorphic(TypeDiscriminatorPropertyName = "$type")]
[JsonDerivedType(typeof(AttributeCondition), "attribute")]
[JsonDerivedType(typeof(LevelCondition), "level")]
// ... etc
public abstract class DialogueCondition { }
```

**Serialized JSON Example:**

```json
[
  {
    "$type": "attribute",
    "attribute": 0,
    "comparison": 0,
    "threshold": 6,
    "hideWhenFailed": false
  },
  {
    "$type": "reputation",
    "faction": 1,
    "minDisposition": 3,
    "hideWhenFailed": true
  }
]
```

### EF Core JSONB Configuration

```csharp
entity.Property(o => o.Conditions)
    .HasColumnType("jsonb")
    .HasConversion(
        v => JsonSerializer.Serialize(v, JsonSerializerOptions),
        v => JsonSerializer.Deserialize<List<DialogueCondition>>(v, JsonSerializerOptions)
             ?? new List<DialogueCondition>())
    .IsRequired();
```

**JsonSerializerOptions:**

```csharp
private static readonly JsonSerializerOptions JsonSerializerOptions = new()
{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    WriteIndented = false
};
```

---

## Logging Matrix

### DialogueConditionEvaluator

| Event | Level | Template |
|-------|-------|----------|
| Condition entry | Trace | `[DialogueCondition] Evaluating {ConditionType} for {CharName}` |
| Condition result | Debug | `[DialogueCondition] {ConditionType} = {Result} ({Hint})` |
| Attribute check | Trace | `[AttributeCondition] {Attr} = {Value}, Threshold = {Threshold}, Comparison = {Comp}, Result = {Result}` |
| Level check | Trace | `[LevelCondition] CharLevel = {Level}, Required = {Min}, Result = {Result}` |
| Reputation check | Trace | `[ReputationCondition] Faction = {Faction}, Required = {Disposition}, Result = {Result}` |
| Flag check | Trace | `[FlagCondition] Flag '{Key}' = {Value}, Required = {Required}, Result = {Result}` |
| Item check | Trace | `[ItemCondition] Item '{Item}' x{Qty} = {Result}` |
| Spec check | Trace | `[SpecializationCondition] Spec '{Name}' unlocked = {Result}` |
| Node check | Trace | `[NodeCondition] Node '{Name}' ({Id}) unlocked = {Result}` |
| Skill check | Trace | `[SkillCheckCondition] {Attr} pool={Pool}, Rolled={Successes}s/{Botches}b, Net={Net}, DC={DC}, Result = {Result}` |
| Option no conditions | Debug | `[DialogueCondition] No conditions, option available` |
| Option evaluation | Trace | `[DialogueCondition] Evaluating option '{OptionText}' ({ConditionCount} conditions)` |
| All passed | Debug | `[DialogueCondition] All {Count} conditions passed` |
| Option hidden | Debug | `[DialogueCondition] Option hidden (HideWhenFailed or Hidden mode)` |
| Option locked | Debug | `[DialogueCondition] Option locked: {Reason} {Hint}` |
| Node evaluation | Trace | `[DialogueCondition] Evaluating {OptionCount} options for node '{NodeId}'` |
| Node complete | Debug | `[DialogueCondition] Node evaluation complete: {Total} options, {Visible} visible, {Available} available` |

### DialogueRepository

| Event | Level | Template |
|-------|-------|----------|
| GetTreeById | Debug | `[DialogueRepo] GetTreeByIdAsync: {TreeId}` |
| GetTreeByGuid | Debug | `[DialogueRepo] GetTreeByGuidAsync: {Id}` |
| GetNode | Debug | `[DialogueRepo] GetNodeAsync: Tree={TreeId}, Node={NodeId}` |
| GetAllTrees | Debug | `[DialogueRepo] GetAllTreesAsync` |
| AddTree | Debug | `[DialogueRepo] AddTreeAsync: {TreeId} ({NpcName}, {NodeCount} nodes)` |
| SaveChanges | Debug | `[DialogueRepo] SaveChangesAsync: {Count} changes` |

### InventoryService (HasItemAsync)

| Event | Level | Template |
|-------|-------|----------|
| Entry | Trace | `[HasItem] Checking if character {CharacterId} has item '{ItemId}' with quantity >= {MinQuantity}` |
| Found by GUID | Debug | `[HasItem] Found item by GUID: {ItemName} x{Quantity}` |
| Found by name | Debug | `[HasItem] Found item by name: {ItemName} x{Quantity}` |
| Not found | Debug | `[HasItem] Item '{ItemId}' not found or insufficient quantity` |

---

## Test Coverage

**Total New Tests:** 48 tests | **Passed:** 48 | **Failed:** 0 | **Duration:** ~181ms

### Summary by Category

| Category | Test Count | Focus Area |
|----------|------------|------------|
| AttributeCondition | 8 | All 6 comparison operators + boundaries |
| LevelCondition | 4 | Met/exceeded/insufficient/display hint |
| ReputationCondition | 6 | All 5 disposition tiers + factions |
| FlagCondition | 4 | True/false/inverse checks |
| ItemCondition | 4 | Owned/missing/quantity checks |
| SpecializationCondition | 3 | Unlocked/locked + display hint |
| NodeCondition | 3 | Unlocked/locked + display hint |
| SkillCheckCondition | 6 | Pass/fail/botch/net successes/rolls |
| EvaluateOptionAsync | 6 | No conditions/pass/locked/hidden/results |
| EvaluateNodeOptionsAsync | 4 | Multiple options/ordering/mixed visibility |

### Complete Test Inventory

#### DialogueConditionEvaluatorTests (48 tests)

##### AttributeCondition Tests (8)

| Test Name | Description |
|-----------|-------------|
| `EvaluateConditionAsync_AttributeGreaterThanOrEqual_WhenMet_ReturnsSuccess` | WITS 6 >= 6 passes |
| `EvaluateConditionAsync_AttributeGreaterThanOrEqual_WhenNotMet_ReturnsFail` | WITS 5 >= 6 fails |
| `EvaluateConditionAsync_AttributeEqual_WhenExact_ReturnsSuccess` | MIGHT 7 == 7 passes |
| `EvaluateConditionAsync_AttributeEqual_WhenDifferent_ReturnsFail` | MIGHT 8 == 7 fails |
| `EvaluateConditionAsync_AttributeGreaterThan_WhenHigher_ReturnsSuccess` | WILL 6 > 5 passes |
| `EvaluateConditionAsync_AttributeLessThan_WhenLower_ReturnsSuccess` | FINESSE 4 < 5 passes |
| `EvaluateConditionAsync_AttributeLessThanOrEqual_WhenEqual_ReturnsSuccess` | STURDINESS 5 <= 5 passes |
| `EvaluateConditionAsync_AttributeNotEqual_WhenDifferent_ReturnsSuccess` | WITS 4 != 5 passes |

##### LevelCondition Tests (4)

| Test Name | Description |
|-----------|-------------|
| `EvaluateConditionAsync_Level_WhenMet_ReturnsSuccess` | Level 5 >= 5 passes |
| `EvaluateConditionAsync_Level_WhenExceeded_ReturnsSuccess` | Level 10 >= 5 passes |
| `EvaluateConditionAsync_Level_WhenInsufficient_ReturnsFail` | Level 3 >= 5 fails with message |
| `EvaluateConditionAsync_Level_DisplayHint_ShowsRequirement` | Shows "[Level 10]" hint |

##### ReputationCondition Tests (6)

| Test Name | Description |
|-----------|-------------|
| `EvaluateConditionAsync_Reputation_WhenMet_ReturnsSuccess` | Dvergr Friendly met |
| `EvaluateConditionAsync_Reputation_WhenNotMet_ReturnsFail` | TheBound Friendly not met |
| `EvaluateConditionAsync_Reputation_RequiresNeutral_WhenHostile_ReturnsFail` | Below threshold |
| `EvaluateConditionAsync_Reputation_RequiresExalted_WhenFriendly_ReturnsFail` | Above Friendly but below Exalted |
| `EvaluateConditionAsync_Reputation_DisplayHint_ShowsFactionAndDisposition` | Shows "[Dvergr: Friendly]" |
| `EvaluateConditionAsync_Reputation_WhenExalted_ReturnsSuccess` | Exalted threshold met |

##### FlagCondition Tests (4)

| Test Name | Description |
|-----------|-------------|
| `EvaluateConditionAsync_Flag_WhenTrue_ReturnsSuccess` | CompletedTutorial=true passes |
| `EvaluateConditionAsync_Flag_WhenFalse_ReturnsFail` | MetTheElders not set fails |
| `EvaluateConditionAsync_Flag_InverseCheck_WhenFlagNotSet_ReturnsSuccess` | RequiredValue=false, flag absent |
| `EvaluateConditionAsync_Flag_InverseCheck_WhenFlagSet_ReturnsFail` | RequiredValue=false, flag true |

##### ItemCondition Tests (4)

| Test Name | Description |
|-----------|-------------|
| `EvaluateConditionAsync_Item_WhenOwned_ReturnsSuccess` | "Iron Key" owned |
| `EvaluateConditionAsync_Item_WhenMissing_ReturnsFail` | "Ancient Tome" missing |
| `EvaluateConditionAsync_Item_WithQuantity_WhenEnough_ReturnsSuccess` | "Gold Coin" x50 met |
| `EvaluateConditionAsync_Item_WithQuantity_WhenNotEnough_ReturnsFail` | "Gold Coin" x100 not met |

##### SpecializationCondition Tests (3)

| Test Name | Description |
|-----------|-------------|
| `EvaluateConditionAsync_Specialization_WhenUnlocked_ReturnsSuccess` | Berserkr spec unlocked |
| `EvaluateConditionAsync_Specialization_WhenLocked_ReturnsFail` | Stormcaller not unlocked |
| `EvaluateConditionAsync_Specialization_DisplayHint_ShowsName` | Shows "[Is: Runasmidr]" |

##### NodeCondition Tests (3)

| Test Name | Description |
|-----------|-------------|
| `EvaluateConditionAsync_Node_WhenUnlocked_ReturnsSuccess` | "Battle Rage" node unlocked |
| `EvaluateConditionAsync_Node_WhenLocked_ReturnsFail` | "Whirlwind Strike" not unlocked |
| `EvaluateConditionAsync_Node_DisplayHint_ShowsAbilityName` | Shows "[Has: Final Stand]" |

##### SkillCheckCondition Tests (6)

| Test Name | Description |
|-----------|-------------|
| `EvaluateConditionAsync_SkillCheck_WhenPassed_ReturnsSuccess` | 3 successes vs DC 2 |
| `EvaluateConditionAsync_SkillCheck_WhenFailed_ReturnsFail` | 1 success vs DC 3 |
| `EvaluateConditionAsync_SkillCheck_WithBotches_CalculatesNetSuccesses` | 3 successes - 1 botch = 2 net |
| `EvaluateConditionAsync_SkillCheck_Botched_ReturnsNegativeSuccesses` | 0 successes - 2 botches = -2 |
| `EvaluateConditionAsync_SkillCheck_IncludesRolls` | DiceRolls populated in result |
| `EvaluateConditionAsync_SkillCheck_DisplayHint_ShowsDC` | Shows "[WITS DC 4]" |

##### EvaluateOptionAsync Tests (6)

| Test Name | Description |
|-----------|-------------|
| `EvaluateOptionAsync_NoConditions_ReturnsAvailable` | Empty conditions = available |
| `EvaluateOptionAsync_AllConditionsPassed_ReturnsAvailable` | Multiple conditions all pass |
| `EvaluateOptionAsync_OneConditionFails_ShowLocked_ReturnsLockedVisible` | Visible but greyed out |
| `EvaluateOptionAsync_ConditionFails_HideWhenFailed_ReturnsHidden` | HideWhenFailed=true hides |
| `EvaluateOptionAsync_VisibilityModeHidden_WhenFails_ReturnsHidden` | Hidden mode hides failures |
| `EvaluateOptionAsync_IncludesConditionResults` | ConditionResults populated |

##### EvaluateNodeOptionsAsync Tests (4)

| Test Name | Description |
|-----------|-------------|
| `EvaluateNodeOptionsAsync_ReturnsAllOptionResults` | Returns result per option |
| `EvaluateNodeOptionsAsync_RespectsDisplayOrder` | Sorted by DisplayOrder |
| `EvaluateNodeOptionsAsync_MixedVisibility_ReturnsCorrectStates` | Mix of available/locked/hidden |
| `EvaluateNodeOptionsAsync_EmptyOptions_ReturnsEmptyList` | Terminal node handling |

---

## DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// Dialogue System (v0.4.2b - The Lexicon)
services.AddScoped<IDialogueRepository, DialogueRepository>();
services.AddScoped<IDialogueConditionEvaluator, DialogueConditionEvaluator>();
```

**Rationale:**
- Both registered as **Scoped** - tied to unit of work / request lifetime
- `DialogueConditionEvaluator` depends on: `IFactionService`, `IInventoryService`, `ISpecializationRepository`, `IDiceService`, `GameState`
- Matches existing service registration patterns in codebase

---

## Database Configuration

**File:** `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs`

### DbSets Added

```csharp
public DbSet<DialogueTree> DialogueTrees { get; set; } = null!;
public DbSet<DialogueNode> DialogueNodes { get; set; } = null!;
public DbSet<DialogueOption> DialogueOptions { get; set; } = null!;
```

### Entity Configurations

#### DialogueTree Configuration

```csharp
modelBuilder.Entity<DialogueTree>(entity =>
{
    entity.ToTable("DialogueTrees");
    entity.HasKey(t => t.Id);

    entity.HasIndex(t => t.TreeId).IsUnique();
    entity.HasIndex(t => t.AssociatedFaction);

    entity.Property(t => t.TreeId).HasMaxLength(100).IsRequired();
    entity.Property(t => t.NpcName).HasMaxLength(100).IsRequired();
    entity.Property(t => t.RootNodeId).HasMaxLength(100).IsRequired();
    entity.Property(t => t.AssociatedFaction).HasConversion<int?>();

    entity.HasMany(t => t.Nodes)
        .WithOne(n => n.Tree)
        .HasForeignKey(n => n.TreeId)
        .OnDelete(DeleteBehavior.Cascade);
});
```

#### DialogueNode Configuration

```csharp
modelBuilder.Entity<DialogueNode>(entity =>
{
    entity.ToTable("DialogueNodes");
    entity.HasKey(n => n.Id);

    entity.HasIndex(n => new { n.TreeId, n.NodeId }).IsUnique();

    entity.Property(n => n.NodeId).HasMaxLength(100).IsRequired();
    entity.Property(n => n.SpeakerName).HasMaxLength(100).IsRequired();
    entity.Property(n => n.Text).HasMaxLength(2000).IsRequired();

    entity.HasMany(n => n.Options)
        .WithOne(o => o.Node)
        .HasForeignKey(o => o.NodeId)
        .OnDelete(DeleteBehavior.Cascade);
});
```

#### DialogueOption Configuration

```csharp
modelBuilder.Entity<DialogueOption>(entity =>
{
    entity.ToTable("DialogueOptions");
    entity.HasKey(o => o.Id);

    entity.HasIndex(o => new { o.NodeId, o.DisplayOrder });

    entity.Property(o => o.Text).HasMaxLength(500).IsRequired();
    entity.Property(o => o.NextNodeId).HasMaxLength(100);
    entity.Property(o => o.VisibilityMode).HasConversion<int>().IsRequired();

    // JSONB columns with polymorphic serialization
    entity.Property(o => o.Conditions)
        .HasColumnType("jsonb")
        .HasConversion(/* serialization logic */)
        .IsRequired();

    entity.Property(o => o.Effects)
        .HasColumnType("jsonb")
        .HasConversion(/* serialization logic */)
        .IsRequired();

    // Ignore computed properties
    entity.Ignore(o => o.HasConditions);
    entity.Ignore(o => o.HasEffects);
    entity.Ignore(o => o.IsTerminal);
});
```

---

## Verification Results

### Build Output
```
Build succeeded.
    0 Error(s)
    5 Warning(s)

Time Elapsed 00:00:05.53
```

**Note:** Warnings are pre-existing (async methods, version conflicts) and unrelated to this release.

### Test Output
```
Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:    48, Skipped:     0, Total:    48, Duration: 181 ms - RuneAndRust.Tests.dll (net9.0)
```

### Engine Tests (No Regressions)
```
Passed!  - Failed:     0, Passed:  2241, Skipped:     0, Total:  2241, Duration: 3 s
```

---

## Directory Structure After v0.4.2b

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Conditions/ [NEW FOLDER]
│   │   ├── AttributeCondition.cs [NEW]
│   │   ├── DialogueCondition.cs [NEW - base with JsonPolymorphic]
│   │   ├── FlagCondition.cs [NEW]
│   │   ├── ItemCondition.cs [NEW]
│   │   ├── LevelCondition.cs [NEW]
│   │   ├── NodeCondition.cs [NEW]
│   │   ├── ReputationCondition.cs [NEW]
│   │   ├── SkillCheckCondition.cs [NEW]
│   │   └── SpecializationCondition.cs [NEW]
│   ├── Effects/ [NEW FOLDER]
│   │   ├── DialogueEffect.cs [NEW - base with JsonPolymorphic]
│   │   ├── GiveItemEffect.cs [NEW]
│   │   ├── ModifyReputationEffect.cs [NEW]
│   │   └── SetFlagEffect.cs [NEW]
│   ├── Entities/
│   │   ├── DialogueNode.cs [NEW]
│   │   ├── DialogueOption.cs [NEW - with JSONB columns]
│   │   ├── DialogueTree.cs [NEW]
│   │   └── ...
│   ├── Enums/
│   │   ├── ComparisonType.cs [NEW]
│   │   ├── DialogueConditionType.cs [NEW]
│   │   ├── DialogueEffectType.cs [NEW]
│   │   ├── OptionVisibility.cs [NEW]
│   │   └── ...
│   ├── Interfaces/
│   │   ├── IDialogueConditionEvaluator.cs [NEW]
│   │   ├── IDialogueRepository.cs [NEW]
│   │   ├── IInventoryService.cs [MODIFIED - HasItemAsync added]
│   │   └── ...
│   └── Models/
│       ├── ConditionResult.cs [NEW]
│       ├── GameState.cs [MODIFIED - Flags added]
│       ├── OptionVisibilityResult.cs [NEW]
│       └── ...
├── RuneAndRust.Engine/
│   └── Services/
│       ├── DialogueConditionEvaluator.cs [NEW]
│       ├── InventoryService.cs [MODIFIED - HasItemAsync implemented]
│       └── ...
├── RuneAndRust.Persistence/
│   ├── Data/
│   │   └── RuneAndRustDbContext.cs [MODIFIED - Dialogue entities + JSONB]
│   └── Repositories/
│       ├── DialogueRepository.cs [NEW]
│       └── ...
├── RuneAndRust.Terminal/
│   └── Program.cs [MODIFIED - DI registrations]
└── RuneAndRust.Tests/
    └── Engine/
        ├── DialogueConditionEvaluatorTests.cs [NEW - 48 tests]
        └── ...
```

---

## Running Tests

### Full Test Suite
```bash
dotnet test
```

### Dialogue System Tests Only
```bash
# All DialogueConditionEvaluatorTests (48 tests)
dotnet test --filter "DialogueConditionEvaluatorTests"

# AttributeCondition tests only (8 tests)
dotnet test --filter "DialogueConditionEvaluatorTests&Attribute"

# SkillCheck tests only (6 tests)
dotnet test --filter "DialogueConditionEvaluatorTests&SkillCheck"

# Option evaluation tests (6 tests)
dotnet test --filter "DialogueConditionEvaluatorTests&EvaluateOptionAsync"

# Node evaluation tests (4 tests)
dotnet test --filter "DialogueConditionEvaluatorTests&EvaluateNodeOptionsAsync"
```

---

## Design Decisions

### Why Polymorphic JSON Instead of TPH/TPT?

**Problem:** Need to store heterogeneous condition types in DialogueOption without complex inheritance mapping.

**Decision:** Use `[JsonPolymorphic]` with JSONB column storage.

**Rationale:**
- Single column for all condition types (simple schema)
- No JOINs required to load conditions
- Easy to add new condition types without migrations
- PostgreSQL JSONB supports indexing if needed
- System.Text.Json polymorphism is clean and efficient

### Why Separate HideWhenFailed from VisibilityMode?

**Problem:** Some conditions should hide the option when failed, regardless of the option's default visibility mode.

**Decision:** Two-level visibility: `VisibilityMode` on option + `HideWhenFailed` per condition.

**Rationale:**
- Option default: `ShowLocked` (player sees greyed-out options with hints)
- Override: Individual condition can set `HideWhenFailed = true`
- Use case: "[SECRET OPTION]" that shouldn't even hint at existence
- AND logic: If ANY condition with `HideWhenFailed` fails, hide the option

### Why AND Logic for Conditions?

**Problem:** Need to combine multiple requirements (attribute + level + reputation).

**Decision:** All conditions must pass for option to be available.

**Rationale:**
- Simpler mental model for content designers
- OR logic can be achieved with multiple options
- Matches D&D-style prerequisite systems
- Clear failure reason (first failing condition)

### Why Result Records with Factory Methods?

**Problem:** Need rich result objects with pass/fail states and context.

**Decision:** Immutable records with `Success()`, `Fail()`, etc. factory methods.

**Rationale:**
- Immutable by default (records)
- Named factory methods clarify intent
- Can include context (rolls, reasons) without constructor overloads
- Pattern consistency with v0.4.2a `ReputationChangeResult`

### Why GameState.Flags Instead of Database Storage?

**Problem:** Need to track quest/dialogue state flags.

**Decision:** In-memory dictionary on GameState (serialized with save).

**Rationale:**
- Flags are session-scoped (reset on new game)
- High-frequency access (checked every dialogue option)
- No database roundtrip for flag checks
- Serialized with save game data
- Can migrate to DB later if persistence requirements change

### Why Type Aliases for Character and Attribute?

**Problem:**
- CS0104 "ambiguous reference" between `Core.Entities.Character` and `Core.Models.Character`
- `Attribute` conflicts with `System.Attribute`

**Decision:** Type aliases at file scope.

**Rationale:**
- Non-breaking: doesn't require renaming classes
- Local to files that need it
- Clear and explicit disambiguation
- Pattern established in v0.4.2a

---

## Next Steps

Planned for **v0.4.2c - The Voice** (Dialogue Runtime):
- `IDialogueService` for conversation flow management
- Dialogue UI components (ViewModels)
- Effect execution engine
- Save/load dialogue state (current node, visited flags)

Planned for **v0.4.3 - The Lorekeeper** (Content Creation):
- JSON dialogue tree authoring format
- Dialogue tree importer from JSON
- Migration script for initial dialogue content
- Content validation tools

---

## Credits

**Primary Developer:** The Architect (Claude)
**Test Coverage:** 100% for DialogueConditionEvaluator (48/48 tests passing)
**Integration:** Zero regressions in existing tests (2241 Engine tests pass)

---

**Document Version:** 1.0
**Generated:** 2025-12-30
**Implementation Reference:** v0.4.2b "The Lexicon"
