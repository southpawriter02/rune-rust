# v0.18.4e Design Specification: Resource Service Implementation

**Version:** 0.18.4e
**Parent:** v0.18.4 (Specialization-Specific Resources)
**Prerequisites:** v0.18.4d (Service Interfaces), v0.18.0 (Stress System), v0.6.x (Dice System)
**Status:** Design Complete
**Estimated Unit Tests:** ~7

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Service Implementation Architecture](#3-service-implementation-architecture)
4. [Service Implementations](#4-service-implementations)
5. [Data Access Patterns](#5-data-access-patterns)
6. [Event Publishing](#6-event-publishing)
7. [Logging Specifications](#7-logging-specifications)
8. [Unit Testing Requirements](#8-unit-testing-requirements)
9. [Deliverable Checklist](#9-deliverable-checklist)
10. [Acceptance Criteria](#10-acceptance-criteria)
11. [Dependencies](#11-dependencies)
12. [Future Considerations](#12-future-considerations)

---

## 1. Executive Summary

This design specification defines the **Service Layer Implementations** for all three specialization resource systems. These implementations provide the core business logic for rage management, momentum tracking, and coherence stability.

v0.18.4e establishes the **Service Implementations** by defining:

- `RageService` class implementing `IRageService` — 8 methods
- `MomentumService` class implementing `IMomentumService` — 10 methods
- `CoherenceService` class implementing `ICoherenceService` — 9 methods

### Key Deliverables

| Category              | Items                                            |
| --------------------- | ----------------------------------------------- |
| **Service Classes**   | `RageService`, `MomentumService`, `CoherenceService` |
| **Logging & Events**  | Service-level logging and event publishing       |
| **Data Access**       | Repository interaction patterns                 |
| **Tests**             | ~7 unit tests for core service logic            |

---

## 2. Feature Overview

```
v0.18.4e Services
└── Service Layer Implementation
    │
    ├── RageService
    │   ├── Dependency: ICharacterRepository, ILogger
    │   ├── GetRageState() - Retrieve from repo
    │   ├── GainRage() - Calculate, cap, threshold check
    │   ├── ApplyDecay() - Time-based decay logic
    │   ├── GetDamageBonus() - Computed: floor(rage/10)
    │   ├── GetSoakBonus() - Threshold lookup
    │   ├── IsFearImmune() - Threshold check
    │   ├── MustAttackNearest() - Threshold check
    │   └── GetPartyStressReduction() - Threshold check
    │
    ├── MomentumService
    │   ├── Dependency: ICharacterRepository, ILogger
    │   ├── GetMomentumState() - Retrieve from repo
    │   ├── GainMomentum() - Calculate, cap, chain bonus
    │   ├── ApplyDecay() - Reason-based decay
    │   ├── ResetMomentum() - Hard reset logic
    │   ├── GetBonusAttacks() - Threshold lookup
    │   ├── GetMovementBonus() - Computed: floor(mom/20)
    │   ├── GetAttackBonus() - Threshold lookup
    │   ├── GetDefenseBonus() - Threshold lookup
    │   ├── RecordHit() - Increment chain, update time
    │   └── RecordMiss() - Reset chain, apply decay
    │
    └── CoherenceService
        ├── Dependency: ICharacterRepository, IDiceService, ILogger
        ├── GetCoherenceState() - Retrieve from repo
        ├── GainCoherence() - Add, cap at 100
        ├── LoseCoherence() - Subtract, floor at 0
        ├── CheckCascade() - Risk calculation, dice roll
        ├── UpdateApotheosis() - State transition logic
        ├── GetSpellPowerBonus() - Threshold lookup
        ├── GetCriticalCastChance() - Threshold lookup
        ├── CanMeditate() - Combat check
        └── Meditate() - Gain, availability check
```

---

## 3. Service Implementation Architecture

### 3.1 Service Dependencies and Interactions

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          SERVICE LAYER                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐      │
│  │  RageService     │  │ MomentumService  │  │ CoherenceService │      │
│  ├──────────────────┤  ├──────────────────┤  ├──────────────────┤      │
│  │ Dependencies:    │  │ Dependencies:    │  │ Dependencies:    │      │
│  │ · CharacterRepo  │  │ · CharacterRepo  │  │ · CharacterRepo  │      │
│  │ · Logger         │  │ · Logger         │  │ · DiceService    │      │
│  │                  │  │                  │  │ · StressService  │      │
│  │                  │  │                  │  │ · Logger         │      │
│  └────────┬─────────┘  └────────┬─────────┘  └────────┬─────────┘      │
│           │                     │                     │                │
└───────────┼─────────────────────┼─────────────────────┼────────────────┘
            │                     │                     │
            └─────────────────────┼─────────────────────┘
                                  │
            ┌─────────────────────┴─────────────────────┐
            │                                           │
            ▼                                           ▼
    ┌───────────────────┐                    ┌──────────────────┐
    │ CharacterRepository│                    │ Domain Models    │
    ├───────────────────┤                    ├──────────────────┤
    │ · GetById()       │                    │ · RageState      │
    │ · Update()        │                    │ · MomentumState  │
    │ · SaveChanges()   │                    │ · CoherenceState │
    └───────────────────┘                    └──────────────────┘
```

### 3.2 State Retrieval and Persistence Flow

```
Request to Service
       │
       ▼
Check Character Specialization
       │
       ├─ Not Berserker? ──┐
       │                   │
       ▼                   │
Retrieve from Repository   │
       │                   │
       ├─ Cache in Memory  │
       │                   │
       ▼                   │
Perform Calculation        │
(gain, decay, bonuses)     │
       │                   │
       ▼                   │
Update State & Persist     │
       │                   │
       ▼                   │
Publish Event (if notable) │
       │                   │
       └─ Return Result ◄──┘
```

---

## 4. Service Implementations

### 4.1 RageService

**File:** `src/Core/RuneAndRust.Application/Services/RageService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Services.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Persistence.Repositories.Interfaces;

/// <summary>
/// Service for managing Rage resource for Berserker specialization.
/// </summary>
public class RageService : IRageService
{
    private readonly ICharacterRepository _characterRepository;
    private readonly ILogger<RageService> _logger;

    /// <summary>
    /// Initializes a new instance of the RageService.
    /// </summary>
    /// <param name="characterRepository">Character data repository.</param>
    /// <param name="logger">Logger instance.</param>
    public RageService(ICharacterRepository characterRepository, ILogger<RageService> logger)
    {
        _characterRepository = characterRepository ?? throw new ArgumentNullException(nameof(characterRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public RageState? GetRageState(Guid characterId)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.RageState == null)
            {
                _logger.LogDebug("No rage state found for character {CharacterId}", characterId);
                return null;
            }

            return character.RageState;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving rage state for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public RageGainResult GainRage(Guid characterId, int amount, RageSource source)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.RageState == null)
            {
                _logger.LogWarning("Cannot gain rage for character {CharacterId}: no rage state", characterId);
                return new RageGainResult(0, 0, 0, source, false, null);
            }

            var rageState = character.RageState;
            var previousRage = rageState.CurrentRage;
            var scaledAmount = ScaleRageGain(amount, source);
            var newRage = Math.Min(RageState.MaxRage, previousRage + scaledAmount);
            var oldThreshold = rageState.Threshold;
            var newThreshold = RageState.DetermineThreshold(newRage);
            var thresholdChanged = oldThreshold != newThreshold;

            // Update character's rage state (implementation details deferred to repo)
            // _characterRepository.UpdateRageState(characterId, newRage, DateTime.UtcNow);

            _logger.LogInformation(
                "Rage gained: {CharacterId} {Source} {Amount} ({Old}→{New})",
                characterId, source, scaledAmount, previousRage, newRage);

            if (thresholdChanged)
            {
                _logger.LogInformation(
                    "Rage threshold changed: {CharacterId} {OldThreshold}→{NewThreshold}",
                    characterId, oldThreshold, newThreshold);
            }

            return new RageGainResult(previousRage, newRage, scaledAmount, source, thresholdChanged, newThreshold);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error gaining rage for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public RageDecayResult ApplyDecay(Guid characterId)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.RageState == null)
            {
                _logger.LogWarning("Cannot decay rage for character {CharacterId}: no rage state", characterId);
                return new RageDecayResult(0, 0, 0, false, null);
            }

            var rageState = character.RageState;
            var timeSinceLastCombat = DateTime.UtcNow - (rageState.LastCombatTime ?? DateTime.UtcNow);

            // Only decay if >= 1 minute since last combat
            if (timeSinceLastCombat.TotalMinutes < 1.0)
            {
                return new RageDecayResult(rageState.CurrentRage, rageState.CurrentRage, 0, false, null);
            }

            var previousRage = rageState.CurrentRage;
            var decayAmount = RageState.DecayPerNonCombatTurn;
            var newRage = Math.Max(RageState.MinRage, previousRage - decayAmount);
            var oldThreshold = rageState.Threshold;
            var newThreshold = RageState.DetermineThreshold(newRage);
            var thresholdChanged = oldThreshold != newThreshold;

            _logger.LogDebug(
                "Rage decayed: {CharacterId} {Amount} ({Old}→{New})",
                characterId, decayAmount, previousRage, newRage);

            if (thresholdChanged)
            {
                _logger.LogInformation(
                    "Rage threshold changed (decay): {CharacterId} {OldThreshold}→{NewThreshold}",
                    characterId, oldThreshold, newThreshold);
            }

            return new RageDecayResult(previousRage, newRage, decayAmount, thresholdChanged, newThreshold);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error applying rage decay for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public int GetDamageBonus(Guid characterId)
    {
        var rageState = GetRageState(characterId);
        return rageState?.DamageBonus ?? 0;
    }

    /// <inheritdoc/>
    public int GetSoakBonus(Guid characterId)
    {
        var rageState = GetRageState(characterId);
        return rageState?.SoakBonus ?? 0;
    }

    /// <inheritdoc/>
    public bool IsFearImmune(Guid characterId)
    {
        var rageState = GetRageState(characterId);
        return rageState?.FearImmune ?? false;
    }

    /// <inheritdoc/>
    public bool MustAttackNearest(Guid characterId)
    {
        var rageState = GetRageState(characterId);
        return rageState?.MustAttackNearest ?? false;
    }

    /// <inheritdoc/>
    public int? GetPartyStressReduction(Guid characterId)
    {
        var rageState = GetRageState(characterId);
        return rageState?.PartyStressReduction;
    }

    #region Private Methods

    /// <summary>
    /// Scales rage gain based on source and amount.
    /// </summary>
    private static int ScaleRageGain(int amount, RageSource source) =>
        source switch
        {
            RageSource.TakingDamage => Math.Max(1, amount / 5),
            RageSource.DealingDamage => Math.Max(1, amount / 10),
            RageSource.AllyDamaged => 5,
            RageSource.EnemyKill => 15,
            RageSource.RageMaintenance => 5,
            _ => 0
        };

    #endregion
}
```

### 4.2 MomentumService

**File:** `src/Core/RuneAndRust.Application/Services/MomentumService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Services.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Persistence.Repositories.Interfaces;

/// <summary>
/// Service for managing Momentum resource for Storm Blade specialization.
/// </summary>
public class MomentumService : IMomentumService
{
    private readonly ICharacterRepository _characterRepository;
    private readonly ILogger<MomentumService> _logger;

    /// <summary>
    /// Initializes a new instance of the MomentumService.
    /// </summary>
    /// <param name="characterRepository">Character data repository.</param>
    /// <param name="logger">Logger instance.</param>
    public MomentumService(ICharacterRepository characterRepository, ILogger<MomentumService> logger)
    {
        _characterRepository = characterRepository ?? throw new ArgumentNullException(nameof(characterRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public MomentumState? GetMomentumState(Guid characterId)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            return character?.MomentumState;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving momentum state for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public MomentumGainResult GainMomentum(Guid characterId, int amount, MomentumSource source)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.MomentumState == null)
            {
                _logger.LogWarning("Cannot gain momentum for character {CharacterId}: no momentum state", characterId);
                return new MomentumGainResult(0, 0, 0, source, null, false, null);
            }

            var momentumState = character.MomentumState;
            var previousMomentum = momentumState.CurrentMomentum;
            var baseGain = ScaleMomentumGain(amount, source);
            var chainBonus = source == MomentumSource.ChainAttack
                ? momentumState.ConsecutiveHits * MomentumState.ChainBonusPerHit
                : (int?)null;
            var totalGain = baseGain + (chainBonus ?? 0);
            var newMomentum = Math.Min(MomentumState.MaxMomentum, previousMomentum + totalGain);
            var oldThreshold = momentumState.Threshold;
            var newThreshold = MomentumState.DetermineThreshold(newMomentum);
            var thresholdChanged = oldThreshold != newThreshold;

            _logger.LogInformation(
                "Momentum gained: {CharacterId} {Source} {Amount} ({Old}→{New})",
                characterId, source, totalGain, previousMomentum, newMomentum);

            if (thresholdChanged)
            {
                _logger.LogInformation(
                    "Momentum threshold changed: {CharacterId} {OldThreshold}→{NewThreshold}",
                    characterId, oldThreshold, newThreshold);
            }

            return new MomentumGainResult(previousMomentum, newMomentum, totalGain, source, chainBonus, thresholdChanged, newThreshold);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error gaining momentum for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public MomentumDecayResult ApplyDecay(Guid characterId, string reason)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.MomentumState == null)
            {
                return new MomentumDecayResult(0, 0, 0, reason, false, false, null);
            }

            var momentumState = character.MomentumState;
            var previousMomentum = momentumState.CurrentMomentum;
            var decayAmount = CalculateDecayAmount(reason);
            var newMomentum = Math.Max(MomentumState.MinMomentum, previousMomentum - decayAmount);
            var oldThreshold = momentumState.Threshold;
            var newThreshold = MomentumState.DetermineThreshold(newMomentum);
            var thresholdChanged = oldThreshold != newThreshold;
            var chainBroken = reason == "Missed Attack" || reason.Contains("Stun");

            _logger.LogInformation(
                "Momentum decayed: {CharacterId} {Reason} {Amount} ({Old}→{New})",
                characterId, reason, decayAmount, previousMomentum, newMomentum);

            return new MomentumDecayResult(previousMomentum, newMomentum, decayAmount, reason, chainBroken, thresholdChanged, newThreshold);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error applying momentum decay for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public MomentumDecayResult ResetMomentum(Guid characterId, string reason)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.MomentumState == null)
            {
                return new MomentumDecayResult(0, 0, 0, reason, true, false, null);
            }

            var momentumState = character.MomentumState;
            var previousMomentum = momentumState.CurrentMomentum;

            _logger.LogWarning(
                "Momentum reset: {CharacterId} {Reason} ({Old}→0)",
                characterId, reason, previousMomentum);

            return new MomentumDecayResult(previousMomentum, 0, previousMomentum, reason, true, true, MomentumThreshold.Stationary);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error resetting momentum for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public int GetBonusAttacks(Guid characterId)
    {
        var momentumState = GetMomentumState(characterId);
        return momentumState?.BonusAttacks ?? 0;
    }

    /// <inheritdoc/>
    public int GetMovementBonus(Guid characterId)
    {
        var momentumState = GetMomentumState(characterId);
        return momentumState?.MovementBonus ?? 0;
    }

    /// <inheritdoc/>
    public int GetAttackBonus(Guid characterId)
    {
        var momentumState = GetMomentumState(characterId);
        return momentumState?.AttackBonus ?? 0;
    }

    /// <inheritdoc/>
    public int GetDefenseBonus(Guid characterId)
    {
        var momentumState = GetMomentumState(characterId);
        return momentumState?.DefenseBonus ?? 0;
    }

    /// <inheritdoc/>
    public void RecordHit(Guid characterId)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.MomentumState == null)
                return;

            _logger.LogDebug("Recorded hit for character {CharacterId}", characterId);

            // Implementation: increment ConsecutiveHits and update LastActionTime
            // This would typically be done via domain event or repository update method
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error recording hit for character {CharacterId}", characterId);
        }
    }

    /// <inheritdoc/>
    public void RecordMiss(Guid characterId)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.MomentumState == null)
                return;

            _logger.LogDebug("Recorded miss for character {CharacterId}: resetting chain", characterId);

            // Implementation: reset ConsecutiveHits to 0 and apply miss decay
            // ApplyDecay(characterId, "Missed Attack");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error recording miss for character {CharacterId}", characterId);
        }
    }

    #region Private Methods

    /// <summary>
    /// Scales momentum gain based on source and amount.
    /// </summary>
    private static int ScaleMomentumGain(int amount, MomentumSource source) =>
        source switch
        {
            MomentumSource.SuccessfulAttack => MomentumState.GainPerSuccessfulAttack,
            MomentumSource.KillingBlow => MomentumState.GainPerKill,
            MomentumSource.ChainAttack => amount,
            MomentumSource.MovementAction => Math.Max(1, amount / 2),
            _ => 0
        };

    /// <summary>
    /// Calculates decay amount based on reason.
    /// </summary>
    private static int CalculateDecayAmount(string reason) =>
        reason switch
        {
            "Missed Attack" => MomentumState.DecayOnMiss,
            _ when reason.Contains("Stun") => MomentumState.DecayOnStun,
            _ when reason.Contains("Frozen") => MomentumState.DecayOnStun,
            "Idle Turn" => MomentumState.DecayOnIdleTurn,
            _ => 5 // Default minor decay
        };

    #endregion
}
```

### 4.3 CoherenceService

**File:** `src/Core/RuneAndRust.Application/Services/CoherenceService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Services.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Persistence.Repositories.Interfaces;
using RuneAndRust.Application.Services.Interfaces;

/// <summary>
/// Service for managing Coherence resource for Arcanist specialization.
/// </summary>
public class CoherenceService : ICoherenceService
{
    private readonly ICharacterRepository _characterRepository;
    private readonly IDiceService _diceService;
    private readonly IStressService _stressService;
    private readonly ILogger<CoherenceService> _logger;

    /// <summary>
    /// Initializes a new instance of the CoherenceService.
    /// </summary>
    public CoherenceService(
        ICharacterRepository characterRepository,
        IDiceService diceService,
        IStressService stressService,
        ILogger<CoherenceService> logger)
    {
        _characterRepository = characterRepository ?? throw new ArgumentNullException(nameof(characterRepository));
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _stressService = stressService ?? throw new ArgumentNullException(nameof(stressService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public CoherenceState? GetCoherenceState(Guid characterId)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            return character?.CoherenceState;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving coherence state for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public bool GainCoherence(Guid characterId, int amount, CoherenceSource source)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.CoherenceState == null)
            {
                _logger.LogWarning("Cannot gain coherence for character {CharacterId}: no coherence state", characterId);
                return false;
            }

            var coherenceState = character.CoherenceState;
            var previousCoherence = coherenceState.CurrentCoherence;
            var scaledAmount = ScaleCoherenceGain(amount, source);
            var newCoherence = Math.Min(CoherenceState.MaxCoherence, previousCoherence + scaledAmount);

            _logger.LogInformation(
                "Coherence gained: {CharacterId} {Source} {Amount} ({Old}→{New})",
                characterId, source, scaledAmount, previousCoherence, newCoherence);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error gaining coherence for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public bool LoseCoherence(Guid characterId, int amount, string reason)
    {
        try
        {
            var character = _characterRepository.GetById(characterId);
            if (character?.CoherenceState == null)
            {
                _logger.LogWarning("Cannot lose coherence for character {CharacterId}: no coherence state", characterId);
                return false;
            }

            var coherenceState = character.CoherenceState;
            var previousCoherence = coherenceState.CurrentCoherence;
            var newCoherence = Math.Max(CoherenceState.MinCoherence, previousCoherence - amount);

            _logger.LogInformation(
                "Coherence lost: {CharacterId} {Reason} {Amount} ({Old}→{New})",
                characterId, reason, amount, previousCoherence, newCoherence);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error losing coherence for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public CascadeResult CheckCascade(Guid characterId)
    {
        try
        {
            var coherenceState = GetCoherenceState(characterId);
            if (coherenceState == null || coherenceState.CascadeRisk == 0)
                return new CascadeResult(false, 0, null, null, null, false, null);

            // Roll d100 to check cascade
            var roll = _diceService.RollD100();
            var cascadeTriggered = roll <= coherenceState.CascadeRisk;

            if (!cascadeTriggered)
                return new CascadeResult(false, 0, null, null, null, false, null);

            _logger.LogWarning(
                "Cascade triggered: {CharacterId} Risk={Risk}% Roll={Roll}",
                characterId, coherenceState.CascadeRisk, roll);

            // Cascade effects determined from table (v0.19.x)
            // For now, return basic cascade with coherence loss
            return new CascadeResult(
                CascadeTriggered: true,
                CoherenceLost: 10,
                SelfDamage: null,
                StressGained: null,
                CorruptionGained: null,
                SpellDisrupted: true,
                CascadeEffectId: null);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking cascade for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public ApotheosisResult UpdateApotheosis(Guid characterId)
    {
        try
        {
            var coherenceState = GetCoherenceState(characterId);
            if (coherenceState == null)
            {
                return new ApotheosisResult(false, null, null, 0, false, "No coherence state", 0);
            }

            var wasInApotheosis = coherenceState.InApotheosis;
            var isInApotheosis = coherenceState.Threshold == CoherenceThreshold.Apotheosis;

            if (!wasInApotheosis && isInApotheosis)
            {
                _logger.LogWarning("Apotheosis entered: {CharacterId}", characterId);
                return new ApotheosisResult(
                    EnteredApotheosis: true,
                    TurnsRemaining: EstimateTurnsRemaining(characterId),
                    AbilitiesUnlocked: new[] { "Ultimate Ability 1", "Ultimate Ability 2" },
                    StressCostPerTurn: CoherenceState.ApotheosisStressCostPerTurn,
                    ExitedApotheosis: false,
                    ExitReason: null,
                    FinalCoherence: coherenceState.CurrentCoherence);
            }

            if (wasInApotheosis && !isInApotheosis)
            {
                _logger.LogInformation("Apotheosis exited: {CharacterId} Reason=Coherence dropped", characterId);
                return new ApotheosisResult(
                    EnteredApotheosis: false,
                    TurnsRemaining: null,
                    AbilitiesUnlocked: null,
                    StressCostPerTurn: 0,
                    ExitedApotheosis: true,
                    ExitReason: "Coherence dropped below threshold",
                    FinalCoherence: coherenceState.CurrentCoherence);
            }

            return new ApotheosisResult(
                EnteredApotheosis: false,
                TurnsRemaining: wasInApotheosis ? EstimateTurnsRemaining(characterId) : null,
                AbilitiesUnlocked: null,
                StressCostPerTurn: CoherenceState.ApotheosisStressCostPerTurn,
                ExitedApotheosis: false,
                ExitReason: null,
                FinalCoherence: coherenceState.CurrentCoherence);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating apotheosis for character {CharacterId}", characterId);
            throw;
        }
    }

    /// <inheritdoc/>
    public int GetSpellPowerBonus(Guid characterId)
    {
        var coherenceState = GetCoherenceState(characterId);
        return coherenceState?.SpellPowerBonus ?? 0;
    }

    /// <inheritdoc/>
    public int GetCriticalCastChance(Guid characterId)
    {
        var coherenceState = GetCoherenceState(characterId);
        return coherenceState?.CriticalCastChance ?? 0;
    }

    /// <inheritdoc/>
    public bool CanMeditate(Guid characterId)
    {
        var coherenceState = GetCoherenceState(characterId);
        return coherenceState?.CanMeditate ?? false;
    }

    /// <inheritdoc/>
    public bool Meditate(Guid characterId)
    {
        try
        {
            var coherenceState = GetCoherenceState(characterId);
            if (coherenceState == null || !coherenceState.CanMeditate)
            {
                _logger.LogWarning("Cannot meditate for character {CharacterId}: not available", characterId);
                return false;
            }

            var previousCoherence = coherenceState.CurrentCoherence;
            var newCoherence = Math.Min(CoherenceState.MaxCoherence, previousCoherence + CoherenceState.MeditationGain);

            _logger.LogInformation(
                "Meditation performed: {CharacterId} +{Gain} Coherence ({Old}→{New})",
                characterId, CoherenceState.MeditationGain, previousCoherence, newCoherence);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error meditating for character {CharacterId}", characterId);
            throw;
        }
    }

    #region Private Methods

    /// <summary>
    /// Scales coherence gain based on source.
    /// </summary>
    private static int ScaleCoherenceGain(int amount, CoherenceSource source) =>
        source switch
        {
            CoherenceSource.SuccessfulCast => CoherenceState.CastGain,
            CoherenceSource.ControlledChannel => CoherenceState.ChannelGainPerTurn,
            CoherenceSource.MeditationAction => CoherenceState.MeditationGain,
            CoherenceSource.StabilityField => amount,
            _ => 0
        };

    /// <summary>
    /// Estimates turns remaining in Apotheosis based on current stress.
    /// </summary>
    private int EstimateTurnsRemaining(Guid characterId)
    {
        var stressState = _stressService.GetStressState(characterId);
        if (stressState == null)
            return 10; // Default estimate

        var stressRemaining = 100 - stressState.CurrentStress;
        var turnsRemaining = stressRemaining / CoherenceState.ApotheosisStressCostPerTurn;
        return Math.Max(1, turnsRemaining);
    }

    #endregion
}
```

---

## 5. Data Access Patterns

### 5.1 Repository Interface Requirements

```csharp
// From ICharacterRepository:

/// <summary>
/// Gets a character by ID with related resource states.
/// </summary>
Character? GetById(Guid characterId);

/// <summary>
/// Updates character resource states and persists.
/// </summary>
void SaveChanges();
```

### 5.2 Unit of Work Pattern (Optional)

For more complex scenarios with multiple resource updates:

```csharp
using (var transaction = _characterRepository.BeginTransaction())
{
    _rageService.GainRage(characterId, 10, RageSource.DealingDamage);
    _momentumService.RecordHit(characterId);
    _characterRepository.SaveChanges();
    transaction.Commit();
}
```

---

## 6. Event Publishing

### 6.1 Domain Events (Deferred to v0.18.5)

Services may publish domain events for notable state changes:

```csharp
// Future implementation:
public event Action<RageThresholdChangedEvent>? OnRageThresholdChanged;

// In GainRage:
if (thresholdChanged)
{
    OnRageThresholdChanged?.Invoke(new RageThresholdChangedEvent(
        CharacterId: characterId,
        OldThreshold: oldThreshold,
        NewThreshold: newThreshold,
        Timestamp: DateTime.UtcNow));
}
```

---

## 7. Logging Specifications

### 7.1 Log Levels by Event

| Event Type            | Level       | Template                                                      |
| --------------------- | ----------- | ------------------------------------------------------------- |
| Rage gain (normal)    | Information | `"Rage gained: {CharacterId} {Source} {Amount}"`             |
| Rage threshold change | Information | `"Rage threshold changed: {CharacterId} {Old}→{New}"`        |
| Rage decay            | Debug       | `"Rage decayed: {CharacterId} {Amount}"`                     |
| Momentum gain         | Information | `"Momentum gained: {CharacterId} {Source} {Amount}"`         |
| Chain broken          | Information | `"Momentum chain broken: {CharacterId}"`                     |
| Cascade triggered     | Warning     | `"Cascade triggered: {CharacterId} Risk={Risk}%"`            |
| Apotheosis entered    | Warning     | `"APOTHEOSIS ENTERED: {CharacterId}"`                        |
| Apotheosis exited     | Information | `"Apotheosis exited: {CharacterId} Reason={Reason}"`         |

---

## 8. Unit Testing Requirements

### 8.1 Test File Locations

- `tests/RuneAndRust.Application.UnitTests/Services/RageServiceTests.cs` (~3 tests)
- `tests/RuneAndRust.Application.UnitTests/Services/MomentumServiceTests.cs` (~2 tests)
- `tests/RuneAndRust.Application.UnitTests/Services/CoherenceServiceTests.cs` (~2 tests)

### 8.2 Example Test

```csharp
[TestFixture]
public class RageServiceTests
{
    private RageService _rageService;
    private Mock<ICharacterRepository> _mockRepository;
    private Mock<ILogger<RageService>> _mockLogger;

    [SetUp]
    public void SetUp()
    {
        _mockRepository = new Mock<ICharacterRepository>();
        _mockLogger = new Mock<ILogger<RageService>>();
        _rageService = new RageService(_mockRepository.Object, _mockLogger.Object);
    }

    [Test]
    public void GainRage_FromDealingDamage_CalculatesCorrectly()
    {
        // Arrange
        var characterId = Guid.NewGuid();
        var damageAmount = 50;
        var expectedRageGain = 5; // floor(50 / 10)

        var character = new Character { Id = characterId };
        character.SetRageState(RageState.Create(characterId, initialRage: 20));
        _mockRepository.Setup(r => r.GetById(characterId)).Returns(character);

        // Act
        var result = _rageService.GainRage(characterId, damageAmount, RageSource.DealingDamage);

        // Assert
        result.AmountGained.Should().Be(expectedRageGain);
        result.NewRage.Should().Be(25);
    }
}
```

---

## 9. Deliverable Checklist

### 9.1 Service Classes

- [ ] `src/Core/RuneAndRust.Application/Services/RageService.cs`
- [ ] `src/Core/RuneAndRust.Application/Services/MomentumService.cs`
- [ ] `src/Core/RuneAndRust.Application/Services/CoherenceService.cs`

### 9.2 Tests

- [ ] `tests/RuneAndRust.Application.UnitTests/Services/RageServiceTests.cs`
- [ ] `tests/RuneAndRust.Application.UnitTests/Services/MomentumServiceTests.cs`
- [ ] `tests/RuneAndRust.Application.UnitTests/Services/CoherenceServiceTests.cs`

### 9.3 Documentation

- [ ] Create `docs/design/v0.18.x/v0.18.4e-design-specification.md`
- [ ] Update `docs/design/v0.18.x/v0.18.4-scope-breakdown.md` (mark v0.18.4e complete)

---

## 10. Acceptance Criteria

### 10.1 Build Verification

- [ ] Solution builds without errors
- [ ] Solution builds without warnings in new code

### 10.2 Test Verification

- [ ] All new unit tests pass
- [ ] All existing unit tests continue to pass
- [ ] Service tests mock dependencies properly

### 10.3 Functional Verification

- [ ] RageService.GainRage() correctly scales by source
- [ ] RageService.ApplyDecay() respects non-combat timeout
- [ ] MomentumService.GainMomentum() includes chain bonuses
- [ ] MomentumService.RecordMiss() breaks chain and applies decay
- [ ] CoherenceService.CheckCascade() rolls correctly and respects risk
- [ ] CoherenceService.UpdateApotheosis() tracks state transitions
- [ ] All services log appropriately
- [ ] All services handle null states gracefully

---

## 11. Dependencies

### 11.1 Required from Previous Phases

| Item                | Provided By | Used For                 |
| ------------------- | ----------- | ------------------------ |
| `IRageService`      | v0.18.4d    | Interface to implement   |
| `IMomentumService`  | v0.18.4d    | Interface to implement   |
| `ICoherenceService` | v0.18.4d    | Interface to implement   |
| `RageState`         | v0.18.4a    | Domain model             |
| `MomentumState`     | v0.18.4b    | Domain model             |
| `CoherenceState`    | v0.18.4c    | Domain model             |

### 11.2 Required Infrastructure

| Dependency       | Version | Usage                                    |
| ---------------- | ------- | ---------------------------------------- |
| ICharacterRepo   | v0.6.x+ | Load/persist character resource states  |
| IDiceService     | v0.6.x  | Roll for cascade checks (Coherence)     |
| IStressService   | v0.18.0 | Check stress for Apotheosis exit        |
| ILogger<T>       | N/A     | Service-level logging                   |

### 11.3 Deferred to Later Phases

| Item                         | Deferred To | Reason                 |
| ---------------------------- | ----------- | ---------------------- |
| Configuration management     | v0.18.4f    | JSON config loading    |
| Database persistence details | v0.18.4f    | Repository integration |
| Event publishing             | v0.18.5     | Cross-system events    |

---

## 12. Future Considerations

### 12.1 v0.18.4f (Configuration & Persistence)

- Service constructors accept `IConfigurationProvider`
- Configuration values loaded from JSON
- Repository save/update methods called within services

### 12.2 v0.18.5 (Cross-Resource Interactions)

- Services publish domain events
- Event handlers for multi-resource effects
- Party-wide stress effects from Rage

### 12.3 v0.19.x (Effects)

- Cascade effect table integration
- Apotheosis ability resolution
- UI updates for resource state changes

---

## Changelog

| Version | Date       | Changes                        |
| ------- | ---------- | ------------------------------ |
| 1.0     | 2026-01-28 | Initial implementation design  |
