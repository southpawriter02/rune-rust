> **Archived** - This plan has been consolidated. See the complete version at [v0.3.18](../v0.3.x/v0.3.18.md).

# v0.3.18c: The Snapshot (Serialization Efficiency)

This sub-version targets the "Save/Load Stutter." As the player explores, the GameState grows with visited rooms, dead enemies, and looted containers. Serializing this massive graph using reflection-based JSON is slow and allocates gigabytes of temporary strings on the Large Object Heap (LOH). We will switch to Source Generators and Projection Queries to solve this.

Goal: Reduce Save/Load times by 50% and memory allocation by 70% by eliminating reflection-based serialization and implementing metadata-only loading for menus.

## 1. Architecture & Data Flow
	•	Source Generation: Adopt .NET 8 [JsonSerializable] attributes. This generates serialization code at compile-time, eliminating the runtime cost of inspecting GameState properties via reflection.
	•	Metadata Projection: Refactor ISaveGameRepository to ensure the "Load Game" menu never fetches the SerializedState column (the heavy JSON blob). It should only select ID, Name, and Timestamp columns.
	•	Memory Management: Use RecyclableMemoryStream (or standard MemoryStream buffers) with Utf8JsonWriter during serialization to avoid creating intermediate strings before the final database commit.
Data Flow: The Optimized Save Pipeline
	1	Trigger: User initiates Save.
	2	Buffer: SaveManager rents a memory buffer (Stream).
	3	Serialize: JsonSerializer writes directly to the stream using GameStateContext (Source Generated).
	4	Transfer: The stream bytes are converted to the format required by the Persistence layer (String for JSONB, or Byte Array if optimizing storage).
	5	Commit: DbContext pushes the record to PostgreSQL.
	6	Cleanup: Buffer is disposed/returned to pool.

## 2. Logic Decision Trees
A. Load Menu Optimization Logic Input: User requests "Load Game" screen
	1	Query Generation: Construct EF Core query.
	2	Projection Check: Does the query select * (all columns)?
	◦	Yes: STOP. This will pull MBs of JSON for every save slot.
	◦	No: Select new SaveGameSummary { Id, CharacterName, LastPlayed }.
	3	Execution: EF Core generates SQL SELECT Id, Name, LastPlayed FROM SaveGames.
	4	Result: Minimal memory footprint list returned to UI.
B. Serialization Context Selection Input: Object to Serialize
	1	Type Check:
	◦	Is it GameState? -> Use GameStateContext.Default.GameState.
	◦	Is it GameSettings? -> Use SettingsContext.Default.SettingsDto.
	2	Method: Call JsonSerializer.Serialize(stream, data, TypeInfo).
	◦	Avoid: JsonSerializer.Serialize(data) (Triggering reflection).

## 3. Code Implementation
A. JsonSerializerContext Definition File: RuneAndRust.Core/Serialization/GameStateContext.cs Purpose: Instructs the compiler to generate efficient serialization code for these specific types.
using System.Text.Json.Serialization;
using RuneAndRust.Core.Models;
using RuneAndRust.Core.Entities;

namespace RuneAndRust.Core.Serialization;

[JsonSerializable(typeof(GameState))]
[JsonSerializable(typeof(Character))]
[JsonSerializable(typeof(List<InventoryItem>))]
[JsonSerializable(typeof(HashSet<Guid>))] // For VisitedRooms
public partial class GameStateContext : JsonSerializerContext
{
    // Compiler generates the implementation here
}
B. Optimized SaveManager Method File: RuneAndRust.Engine/Services/SaveManager.cs
public async Task SaveGameAsync(int slot, GameState state)
{
    _logger.LogInformation("[Save] Starting optimized save to slot {Slot}", slot);
    var sw = Stopwatch.StartNew();

    // 1. Serialize to UTF-8 Bytes (Fast, low alloc)
    // Using a MemoryStream prevents string allocation on the LOH until the very end
    using var stream = new MemoryStream();
    await JsonSerializer.SerializeAsync(
        stream,
        state,
        GameStateContext.Default.GameState // Use generated type info
    );

    // 2. Prepare Entity
    // Note: If using Postgres JSONB, we must eventually convert to string,
    // but we saved CPU cycles during the traversal/conversion phase.
    var jsonString = Encoding.UTF8.GetString(stream.ToArray());

    var saveGame = new SaveGame
    {
        Id = Guid.NewGuid(),
        SlotNumber = slot,
        CharacterName = state.CurrentCharacter?.Name ?? "Unknown",
        SerializedState = jsonString, // The heavy blob
        LastPlayed = DateTime.UtcNow
    };

    // 3. Persist
    await _repository.SaveSlotAsync(saveGame);

    sw.Stop();
    _logger.LogInformation("[Save] Complete in {Ms}ms. Size: {Size}kb",
        sw.ElapsedMilliseconds, jsonString.Length / 1024);
}
C. Repository Projection (Metadata Only) File: RuneAndRust.Persistence/Repositories/SaveGameRepository.cs
public async Task<List<SaveGameSummary>> GetSummariesAsync()
{
    // Project ONLY the columns we need.
    // EF Core will NOT fetch the 'SerializedState' column.
    return await _context.SaveGames
        .Select(s => new SaveGameSummary(
            s.SlotNumber,
            s.CharacterName,
            s.LastPlayed,
            false // IsEmpty
        ))
        .OrderByDescending(s => s.LastPlayed)
        .ToListAsync();
}

4. Deliverable Checklist (v0.3.18c)
	•	Core:
	◦	[ ] Create GameStateContext class with [JsonSerializable] attributes.
	◦	[ ] Verify all nested types in GameState (e.g., CombatState, Room) are included in the context or serializable properties.
	•	Persistence:
	◦	[ ] Refactor ISaveGameRepository.GetAllOrderedByLastPlayedAsync to use projection (return List<SaveGameSummary>instead of List<SaveGame>).
	•	Engine:
	◦	[ ] Update SaveManager to use GameStateContext.Default for all serialization calls.
	◦	[ ] Update SaveManager to use GameStateContext.Default for all deserialization calls.
	•	Tests:
	◦	[ ] Benchmark comparison: Reflection vs Source Gen serialization speed.

5. Logging Requirements
Reference: logging.md
System
Event
Level
Message Template
Properties
Save
PerfStats
Info
"[Perf] Save serialization took {Ms}ms. Blob size: {Size}KB."
Ms, Size
Save
ContextUse
Trace
"[Save] Using SourceGenerated context for Type: {Type}."
Type
Load
Projection
Debug
"[Persistence] Querying SaveGame metadata only (Projected)."
-

6. Testing Strategy
Unit Tests (SerializationTests.cs):
	•	RoundTrip_Integrity:
	◦	Create complex GameState (Inventory, VisitedRooms, ActiveEffects).
	◦	Serialize via GameStateContext.
	◦	Deserialize via GameStateContext.
	◦	Assert: Input is structurally identical to Output.
	•	SourceGen_Coverage:
	◦	Assert GameStateContext.Default.GameState is not null (verifies compiler ran).
Benchmark (BenchmarkDotNet):
	•	Scenario: Serialize_LargeState.
	◦	Setup: GameState with 1000 visited rooms and 50 inventory items.
	◦	Compare: JsonSerializer.Serialize(state) vs JsonSerializer.Serialize(state, GameStateContext.Default.GameState).
	◦	Target: >40% speed improvement.

7. Draft Changelog (v0.3.18)
# Changelog: v0.3.18 - The Auditor

**Release Date:** 2026-01-XX

## Summary
A dedicated performance release focused on stabilizing the engine for larger dungeon delves. By optimizing memory usage and serialization pipelines, we have eliminated the "hiccups" experienced during saving, loading, and intense combat.

## Changes
- **Core:** Converted `Coordinate` to a readonly struct, reducing memory overhead for map generation by ~60%.
- **Engine:** Implemented A* Pathfinding with Spatial Hashing. Enemies now navigate complex mazes instantly without stalling the game loop.
- **System:** Switched to Source Generated JSON serialization. Saving the game is now significantly faster and generates less garbage memory.
- **UI:** The "Load Game" menu now loads instantly, as it no longer fetches the full save data for every slot, only the necessary metadata.