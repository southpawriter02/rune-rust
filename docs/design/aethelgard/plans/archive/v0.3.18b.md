> **Archived** - This plan has been consolidated. See the complete version at [v0.3.18](../v0.3.x/v0.3.18.md).

Here is the comprehensive implementation plan for v0.3.18b: The Hot Path (Pathfinding & AI).
This sub-version focuses on algorithmic efficiency. As enemy counts rise and maps grow complex (especially with the Dynamic Room Engine), naïve List.Find operations and recursive pathfinding become frame-time killers. We will introduce Spatial Hashing and Priority Queue-based A* to solve this.

v0.3.18b: The Hot Path
Goal: Optimize EnemyAIService and CombatService to handle complex positioning queries in O(1) time and resolve pathfinding in near-linear time using .NET 6+ optimized collections.
1. Architecture & Data Flow
	•	Spatial Indexing: Instead of iterating through List<Combatant> to check if a tile is occupied, we maintain a Dictionary<Coordinate, Guid> (Spatial Hash). This changes collision detection from O(N) to O(1).
	•	A* Pathfinder: Replace any existing BFS/DFS or naive "move toward" logic with a proper A* implementation using System.Collections.Generic.PriorityQueue.
	•	Path Caching: Enemies only recalculate paths if the target moves significantly (>2 tiles) or the path becomes blocked.
Data Flow: The AI Navigation Loop
	1	Turn Start: Enemy AI requests movement to Player.
	2	Cache Check: Is the cached path still valid? (Target hasn't moved far, next step is empty).
	◦	Yes: Use cached step.
	3	Pathfinding:
	◦	Query SpatialHashGrid for obstacles (Walls, Hazards, Other Enemies).
	◦	Execute A* to find optimal nodes.
	4	Movement: Execute Move command.
	5	Update Index: Remove Enemy ID from old Coordinate key, add to new Coordinate key.

2. Logic Decision Trees
A. Movement Selection Logic Input: Enemy Position, Target Position
	1	Adjacency Check: Is Target adjacent?
	◦	Yes: Attack (No movement needed).
	2	Line of Sight (Raycast): Is the path to Target clear of obstacles?
	◦	Yes: Move directly toward Target (Greedy Best-First).
	3	Pathfinding:
	◦	Calculate A* Path.
	◦	Is path found?
	▪	Yes: Take first step. Cache remainder.
	▪	No: Hold position (or wander).
B. Spatial Update Logic Input: Entity moves from A to B
	1	Validate B: Is SpatialHashGrid[B] occupied?
	◦	Yes: Return Error (Collision).
	2	Execute:
	◦	SpatialHashGrid.Remove(A)
	◦	SpatialHashGrid.Add(B, EntityId)
	◦	Update Entity.Position.

3. Code Implementation
A. Spatial Hash Grid File: RuneAndRust.Engine/Performance/SpatialHashGrid.cs
using RuneAndRust.Core.ValueObjects;

public class SpatialHashGrid
{
    // O(1) lookup for "What is at (x,y,z)?"
    private readonly Dictionary<Coordinate, Guid> _grid = new();

    public void Register(Guid entityId, Coordinate position)
    {
        if (_grid.ContainsKey(position))
            throw new InvalidOperationException($"Position {position} already occupied.");

        _grid[position] = entityId;
    }

    public void Move(Guid entityId, Coordinate oldPos, Coordinate newPos)
    {
        if (_grid.TryGetValue(oldPos, out var occupant) && occupant == entityId)
        {
            _grid.Remove(oldPos);
            Register(entityId, newPos);
        }
    }

    public bool IsBlocked(Coordinate position) => _grid.ContainsKey(position);

    public void Clear() => _grid.Clear();
}
B. A Pathfinder (Optimized)* File: RuneAndRust.Engine/Algorithms/Pathfinder.cs
public class AStarPathfinder
{
    private readonly SpatialHashGrid _grid;

    public Stack<Coordinate> FindPath(Coordinate start, Coordinate end)
    {
        var frontier = new PriorityQueue<Coordinate, int>();
        frontier.Enqueue(start, 0);

        var cameFrom = new Dictionary<Coordinate, Coordinate>();
        var costSoFar = new Dictionary<Coordinate, int>();

        cameFrom[start] = start;
        costSoFar[start] = 0;

        while (frontier.Count > 0)
        {
            var current = frontier.Dequeue();

            if (current == end) break;

            foreach (var next in GetNeighbors(current))
            {
                if (_grid.IsBlocked(next) && next != end) continue;

                int newCost = costSoFar[current] + GetMovementCost(current, next);

                if (!costSoFar.ContainsKey(next) || newCost < costSoFar[next])
                {
                    costSoFar[next] = newCost;
                    int priority = newCost + Heuristic(next, end);
                    frontier.Enqueue(next, priority);
                    cameFrom[next] = current;
                }
            }
        }

        return ReconstructPath(cameFrom, start, end);
    }

    private int Heuristic(Coordinate a, Coordinate b)
        => Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y); // Manhattan
}

4. Deliverable Checklist (v0.3.18b)
	•	Engine:
	◦	[ ] Implement SpatialHashGrid service.
	◦	[ ] Integrate SpatialHashGrid into CombatService (update on every move).
	◦	[ ] Implement AStarPathfinder using System.Collections.Generic.PriorityQueue.
	◦	[ ] Refactor EnemyAIService to use Pathfinder instead of logic shortcuts.
	•	Core:
	◦	[ ] Add IMovementCostCalculator interface for terrain costs (Mud, Ash).
	•	Tests:
	◦	[ ] Create benchmarks for Pathfinding (100x100 grid).
	◦	[ ] Verify pathfinding avoids obstacles correctly.

5. Logging Requirements
Reference: logging.md
System
Event
Level
Message Template
Properties
Pathing
Recalculate
Verbose
"[AI] Recalculating path for {Entity}. Dist: {Distance}."
Entity, Distance
Pathing
Blocked
Debug
"[AI] {Entity} path blocked. No route to {Target}."
Entity, Target
Perf
PathTime
Verbose
"[Perf] Pathfinding took {Ms}ms. Nodes checked: {Nodes}."
Ms, Nodes

6. Testing Strategy
Unit Tests (PathfindingTests.cs):
	•	Obstacle_Avoidance:
	◦	Setup: Player at (0,5), Enemy at (0,0), Wall at (0,1) to (0,4).
	◦	Act: Calculate path.
	◦	Assert: Path goes around the wall (e.g., uses X=1 column), not through it.
	•	Unreachable_Target:
	◦	Setup: Target surrounded by walls.
	◦	Act: Calculate path.
	◦	Assert: Returns empty path/null (handles gracefully).
Benchmark (BenchmarkDotNet):
	•	Scenario: AStar_ComplexMaze.
	◦	Generate a 50x50 maze with dead ends.
	◦	Measure execution time for finding path from corner to corner.
	◦	Target: < 1ms per agent.

7. Draft Changelog (v0.3.18b)
# Changelog: v0.3.18b - The Hot Path

**Release Date:** 2026-01-XX

## Summary
Phase two of the "Auditor" milestone focuses on CPU optimization. By implementing A* pathfinding and Spatial Hashing, enemy AI is now smarter and significantly faster, capable of navigating complex hazards without impacting framerate.

## Changes
- **Engine:** Implemented `SpatialHashGrid` for O(1) entity lookups. Combat movement logic now updates this grid in real-time.
- **AI:** Replaced naive movement logic with A* Pathfinding. Enemies will now navigate around hazards and walls intelligently.
- **Performance:** Pathfinding uses .NET 6 `PriorityQueue` for optimal performance.
Would you like to proceed to v0.3.18c: The Snapshot (Serialization Efficiency)?
