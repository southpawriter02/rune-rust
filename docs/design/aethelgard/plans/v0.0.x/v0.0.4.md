Here is the implementation plan for v0.0.4: The Persistence, focusing on integrating PostgreSQL and Entity Framework Core to save and load game state.
v0.0.4: The Persistence (Database Integration)
Goal: Establish the data layer, allowing the application to persist the Character entity created in v0.0.2 to a PostgreSQL database and retrieve it upon restart.

## Table of Contents
- [1. Implementation Workflow](#1-implementation-workflow)
- [2. Code Implementation](#2-code-implementation)
- [3. Architecture Decision Tree](#3-architecture-decision-tree-v004)
- [4. Deliverable Checklist](#4-v004-deliverable-checklist)

1. Implementation Workflow
Execute these commands to prepare the Persistence project and set up EF Core tools.
# 1. Add Nuget Packages to Persistence
dotnet add RuneAndRust.Persistence package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet add RuneAndRust.Persistence package Microsoft.EntityFrameworkCore.Design

# 2. Add Nuget Packages to Terminal (required to run migrations from CLI)
dotnet add RuneAndRust.Terminal package Microsoft.EntityFrameworkCore.Design

# 3. Verify Tooling (ensure 'dotnet ef' is installed globally)
dotnet tool install --global dotnet-ef

2. Code Implementation
A. Core Layer (The Interfaces)
We define the contract for data access here so the Engine remains decoupled from the specific database technology (Postgres).
File: RuneAndRust.Core/Interfaces/IRepository.cs
namespace RuneAndRust.Core.Interfaces;

public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(Guid id);
    Task AddAsync(T entity);
    Task SaveChangesAsync();
}
B. Persistence Layer (The Implementation)
This layer implements the DbContext and the Repository using EF Core.
File: RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs
using Microsoft.EntityFrameworkCore;
using RuneAndRust.Core.Entities;

namespace RuneAndRust.Persistence.Data;

public class RuneAndRustDbContext : DbContext
{
    public RuneAndRustDbContext(DbContextOptions<RuneAndRustDbContext> options)
        : base(options) { }

    public DbSet<Character> Characters { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Fluent API configurations go here
        modelBuilder.Entity<Character>().HasKey(c => c.Id);
    }
}
File: RuneAndRust.Persistence/Repositories/CharacterRepository.cs
using Microsoft.EntityFrameworkCore;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Persistence.Data;

namespace RuneAndRust.Persistence.Repositories;

public class CharacterRepository : IRepository<Character>
{
    private readonly RuneAndRustDbContext _context;

    public CharacterRepository(RuneAndRustDbContext context)
    {
        _context = context;
    }

    public async Task<Character?> GetByIdAsync(Guid id)
    {
        return await _context.Characters.FirstOrDefaultAsync(c => c.Id == id);
    }

    public async Task AddAsync(Character entity)
    {
        await _context.Characters.AddAsync(entity);
    }

    public async Task SaveChangesAsync()
    {
        await _context.SaveChangesAsync();
    }
}
C. Terminal Layer (Configuration & Migration)
We must register the DB Context and generate the database schema.
File: RuneAndRust.Terminal/Program.cs (Update Configuration)
// Add to ConfigureServices:
// Note: Use a valid connection string for your local Postgres instance
var connectionString = "Host=localhost;Database=RuneAndRust;Username=postgres;Password=password";

services.AddDbContext<RuneAndRustDbContext>(options =>
    options.UseNpgsql(connectionString));

services.AddScoped<IRepository<Character>, CharacterRepository>();
Migration Workflow: Once the code is in place, generate the database tables:
# Create the initial migration
dotnet ef migrations add InitialCreate --project RuneAndRust.Persistence --startup-project RuneAndRust.Terminal

# Apply migration to the database
dotnet ef database update --project RuneAndRust.Persistence --startup-project RuneAndRust.Terminal

3. Architecture Decision Tree (v0.0.4)
	•	Q: Why separate IRepository in Core from CharacterRepository in Persistence?
	◦	A: To follow Clean Architecture. The Engine (Logic) depends on Core interfaces. If we swap Postgres for SQLite later, the Engine code doesn't change, only the Persistence implementation does.
	•	Q: Should we use Generic Repositories (IRepository<T>) or Specific (ICharacterRepository)?
	◦	A: Start with a simple Generic interface for v0.0.4. As queries get complex (e.g., "Find character by name"), we will extend it into specific repositories.

4. v0.0.4 Deliverable Checklist
	•	[ ] Postgres: Database RuneAndRust exists and is accessible.
	•	[ ] Migration: The Characters table is created in the database.
	•	[ ] DI: RuneAndRustDbContext is registered in Program.cs.
	•	[ ] Integration Test:
	1	Create a Character in code.
	2	Call repository.AddAsync().
	3	Restart app.
	4	Call repository.GetByIdAsync().
	5	Verify the character data matches.
Once persistence is confirmed, we can move to v0.0.5, where we will implement Spatial Navigation (Rooms and Exits) so the character has somewhere to go.