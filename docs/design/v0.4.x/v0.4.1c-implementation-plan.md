# v0.4.1c Implementation Plan: Environmental Hazards

**Version:** 0.4.1c
**Parent:** v0.4.1 (Traps & Environmental Hazards)
**Prerequisites:** v0.4.1b Complete (Trap Mechanics)
**Status:** Ready for Implementation
**Target Tests:** ~1535 -> ~1560 (+25 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Implement persistent environmental hazards that affect players who remain in or pass through dangerous zones. Hazards deal ongoing damage or apply status effects each turn, with saving throws allowing players to reduce or avoid damage. This phase completes the Traps & Environmental Hazards system.

### Scope

**In Scope:**
- `HazardType` enum (PoisonGas, Fire, Ice, Spikes, AcidPool, Darkness, Electricity, Radiant, Necrotic)
- `SavingThrow` value object for mitigation dice checks
- `HazardZone` entity for persistent area effects
- `HazardDefinition` for JSON configuration
- `HazardEffectResult` value object for processing results
- `Room.HazardZones` collection and management methods
- `IHazardService` interface and `HazardService` implementation
- Entry damage (damage on room entry)
- Per-turn damage (ongoing while in zone)
- Saving throws (halve or negate damage)
- Status effect application
- Hazard duration (permanent vs temporary)
- Configuration schema for hazard definitions
- TurnProcessingService integration

**Out of Scope:**
- Light-based hazards affecting visibility (v0.4.3)
- Weather effects (v0.4.3)
- Spreading/expanding hazards (future)
- Player-created hazards (future)
- Hazard interaction with NPCs/monsters (v0.5.x)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Save formula | 1d20 + attribute modifier vs DC | Standard RPG pattern |
| Halve vs Negate | Configurable per hazard | Flexibility for different hazard severities |
| Duration | -1 = permanent, positive = turns | Simple, intuitive configuration |
| Per-turn vs Entry | Both supported independently | Different hazard behaviors |
| Room-wide | AffectsWholeRoom flag | Foundation for future zone-based hazards |

---

## Dependencies from Previous Phases

### Dependencies from v0.4.1a/b

| Type | Location | Usage |
|------|----------|-------|
| `Trap` entity pattern | `Domain/Entities/Trap.cs` | Pattern for HazardZone |
| `TrapEffect` pattern | `Domain/ValueObjects/TrapEffect.cs` | Pattern for effects |
| `TrapEffectResult` | `Domain/ValueObjects/TrapEffectResult.cs` | Pattern for results |
| `TrapService` | `Application/Services/TrapService.cs` | Pattern for service |
| `Room.Traps` | `Domain/Entities/Room.cs` | Collection pattern |

### Dependencies from Existing Systems

| Type | Location | Usage |
|------|----------|-------|
| `DiceService` | `Application/Services/DiceService.cs` | Damage/save rolls |
| `StatusEffectService` | `Application/Services/StatusEffectService.cs` | Apply effects |
| `Player.TakeDamage` | `Domain/Entities/Player.cs` | Apply damage |
| `Player.GetAttributeModifier` | `Domain/Entities/Player.cs` | Save modifiers |
| `TurnProcessingService` | `Application/Services/TurnProcessingService.cs` | Turn integration |

---

## Current System Analysis

### Current State (Post v0.4.1b)

```
v0.4.1b State
┌─────────────────────────────────────────────────────────────┐
│                        Room Entity                           │
├─────────────────────────────────────────────────────────────┤
│ • Items collection                                          │
│ • Monsters collection                                       │
│ • Interactables collection                                  │
│ • Traps collection (v0.4.1a)                               │
│ • MISSING: HazardZones collection                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                  TurnProcessingService                       │
├─────────────────────────────────────────────────────────────┤
│ • Process status effect ticks                               │
│ • Process trap resets                                       │
│ • MISSING: Process hazard effects                          │
│ • MISSING: Process hazard duration ticks                   │
└─────────────────────────────────────────────────────────────┘
```

### Target State (v0.4.1c)

```
v0.4.1c Target
┌─────────────────────────────────────────────────────────────┐
│                        Room Entity                           │
├─────────────────────────────────────────────────────────────┤
│ • Items, Monsters, Interactables, Traps                     │
│ • HazardZones collection (NEW)                              │
│ • GetActiveHazards(), GetHazardByKeyword()                 │
│ • AddHazardZone(), RemoveHazardZone()                      │
│ • RemoveExpiredHazards()                                    │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                     HazardService                            │
├─────────────────────────────────────────────────────────────┤
│ • ProcessEntryHazards() - entry damage                      │
│ • ProcessTurnHazards() - per-turn damage                   │
│ • ApplyHazardEffect() - damage + saves + status            │
│ • PerformSavingThrow() - roll saves                        │
│ • ProcessHazardTurnTicks() - duration countdown            │
│ • GetRoomHazardsDescription() - room display               │
│ • ExamineHazard() - detailed info                          │
└─────────────────────────────────────────────────────────────┘
```

---

## Detailed Implementation

### Domain Layer

#### 1. HazardType.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/HazardType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of environmental hazards.
/// </summary>
public enum HazardType
{
    /// <summary>Poisonous gas that damages and poisons creatures within.</summary>
    PoisonGas,

    /// <summary>Fire or flames that burn creatures within.</summary>
    Fire,

    /// <summary>Extreme cold that damages and slows creatures within.</summary>
    Ice,

    /// <summary>Sharp spikes that damage creatures moving through.</summary>
    Spikes,

    /// <summary>Corrosive acid that damages and corrodes equipment.</summary>
    AcidPool,

    /// <summary>Magical darkness that obscures vision (no damage).</summary>
    Darkness,

    /// <summary>Electrical energy that shocks creatures within.</summary>
    Electricity,

    /// <summary>Holy or radiant energy (damages undead).</summary>
    Radiant,

    /// <summary>Necrotic energy that drains life force.</summary>
    Necrotic
}
```

#### 2. SavingThrow.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SavingThrow.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a saving throw to avoid or reduce an effect.
/// </summary>
public readonly record struct SavingThrow
{
    /// <summary>Gets the attribute used for the save.</summary>
    public string Attribute { get; init; }

    /// <summary>Gets the DC to beat for success.</summary>
    public int DC { get; init; }

    /// <summary>Gets whether success negates (true) or halves (false) the effect.</summary>
    public bool Negates { get; init; }

    /// <summary>Creates a saving throw.</summary>
    public static SavingThrow Create(string attribute, int dc, bool negates = false) => new()
    {
        Attribute = attribute,
        DC = dc,
        Negates = negates
    };

    /// <summary>Creates a Fortitude save.</summary>
    public static SavingThrow Fortitude(int dc, bool negates = false) => Create("Fortitude", dc, negates);

    /// <summary>Creates an Agility save.</summary>
    public static SavingThrow Agility(int dc, bool negates = false) => Create("Agility", dc, negates);

    /// <summary>Creates a Will save.</summary>
    public static SavingThrow Will(int dc, bool negates = false) => Create("Will", dc, negates);
}
```

#### 3. HazardEffectResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/HazardEffectResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of applying a hazard's effect to a target.
/// </summary>
public readonly record struct HazardEffectResult
{
    public string HazardName { get; init; }
    public int DamageDealt { get; init; }
    public string? DamageType { get; init; }
    public IReadOnlyList<int> DamageRolls { get; init; }
    public bool SaveAttempted { get; init; }
    public bool SaveSucceeded { get; init; }
    public int? SaveRoll { get; init; }
    public int? SaveDC { get; init; }
    public string? SaveAttribute { get; init; }
    public IReadOnlyList<string> StatusEffectsApplied { get; init; }
    public bool WasNegated { get; init; }
    public string Message { get; init; }

    public static HazardEffectResult DamageResult(
        string hazardName, int damage, string damageType,
        IEnumerable<int> rolls, string message,
        bool saveAttempted = false, bool saveSucceeded = false,
        int? saveRoll = null, int? saveDC = null, string? saveAttribute = null) => new()
    {
        HazardName = hazardName, DamageDealt = damage, DamageType = damageType,
        DamageRolls = rolls.ToList(), SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded, SaveRoll = saveRoll, SaveDC = saveDC,
        SaveAttribute = saveAttribute, StatusEffectsApplied = Array.Empty<string>(),
        WasNegated = false, Message = message
    };

    public static HazardEffectResult Negated(
        string hazardName, int saveRoll, int saveDC,
        string saveAttribute, string message) => new()
    {
        HazardName = hazardName, DamageDealt = 0, DamageType = null,
        DamageRolls = Array.Empty<int>(), SaveAttempted = true, SaveSucceeded = true,
        SaveRoll = saveRoll, SaveDC = saveDC, SaveAttribute = saveAttribute,
        StatusEffectsApplied = Array.Empty<string>(), WasNegated = true, Message = message
    };

    public static HazardEffectResult Combined(
        string hazardName, int damage, string? damageType,
        IEnumerable<int> rolls, IEnumerable<string> statusEffects, string message,
        bool saveAttempted = false, bool saveSucceeded = false,
        int? saveRoll = null, int? saveDC = null, string? saveAttribute = null) => new()
    {
        HazardName = hazardName, DamageDealt = damage, DamageType = damageType,
        DamageRolls = rolls.ToList(), SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded, SaveRoll = saveRoll, SaveDC = saveDC,
        SaveAttribute = saveAttribute, StatusEffectsApplied = statusEffects.ToList(),
        WasNegated = false, Message = message
    };

    public static HazardEffectResult NoEffect(string hazardName) => new()
    {
        HazardName = hazardName, DamageDealt = 0, Message = string.Empty,
        DamageRolls = Array.Empty<int>(), StatusEffectsApplied = Array.Empty<string>()
    };
}
```

#### 4. HazardDefinition.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Definitions/HazardDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;

/// <summary>Configuration definition for a hazard type.</summary>
public class HazardDefinition
{
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public HazardType HazardType { get; set; }
    public HazardDamageDefinition? DamagePerTurn { get; set; }
    public HazardDamageDefinition? EntryDamage { get; set; }
    public List<string> StatusEffects { get; set; } = new();
    public int StatusDuration { get; set; } = 3;
    public HazardSaveDefinition? Save { get; set; }
    public bool AffectsWholeRoom { get; set; } = true;
    public int Duration { get; set; } = -1;
    public List<string> Keywords { get; set; } = new();
    public string? EffectMessage { get; set; }
}

/// <summary>Configuration for hazard damage.</summary>
public class HazardDamageDefinition
{
    public string Dice { get; set; } = string.Empty;
    public string DamageType { get; set; } = string.Empty;
    public int Bonus { get; set; }
}

/// <summary>Configuration for hazard saving throw.</summary>
public class HazardSaveDefinition
{
    public string Attribute { get; set; } = string.Empty;
    public int DC { get; set; }
    public bool Negates { get; set; }
}
```

#### 5. HazardZone.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Entities/HazardZone.cs`

Key properties and methods (see design specification for full implementation):

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using RuneAndRust.Domain.Definitions;

/// <summary>Represents a persistent environmental hazard in a room.</summary>
public class HazardZone : IEntity
{
    public Guid Id { get; private set; }
    public string DefinitionId { get; private set; } = string.Empty;
    public string Name { get; private set; } = string.Empty;
    public string Description { get; private set; } = string.Empty;
    public HazardType HazardType { get; private set; }
    public bool IsActive { get; private set; } = true;
    public string? DamagePerTurnDice { get; private set; }
    public string? DamageType { get; private set; }
    public string? EntryDamageDice { get; private set; }
    public IReadOnlyList<string> StatusEffects { get; private set; } = Array.Empty<string>();
    public int StatusDuration { get; private set; } = 3;
    public SavingThrow? Save { get; private set; }
    public bool AffectsWholeRoom { get; private set; } = true;
    public int Duration { get; private set; } = -1;
    public IReadOnlyList<string> Keywords { get; private set; } = Array.Empty<string>();
    public string? EffectMessage { get; private set; }

    // Computed properties
    public bool IsPermanent => Duration < 0;
    public bool IsExpired => !IsPermanent && Duration <= 0;
    public bool DamageOnEntry => !string.IsNullOrEmpty(EntryDamageDice);
    public bool DamagePerTurn => !string.IsNullOrEmpty(DamagePerTurnDice);
    public bool AppliesStatus => StatusEffects.Count > 0;
    public bool HasSave => Save.HasValue;

    private HazardZone() { }

    public static HazardZone FromDefinition(HazardDefinition definition)
    {
        ArgumentNullException.ThrowIfNull(definition);
        // ... implementation per design specification
    }

    public bool ProcessTurnTick()
    {
        if (IsPermanent) return false;
        Duration--;
        if (Duration <= 0) { IsActive = false; return true; }
        return false;
    }

    public void Deactivate() => IsActive = false;
    public bool MatchesKeyword(string keyword) =>
        Keywords.Any(k => k.Equals(keyword, StringComparison.OrdinalIgnoreCase)) ||
        Name.Contains(keyword, StringComparison.OrdinalIgnoreCase);

    public string GetHazardTypeDescription() => HazardType switch
    {
        HazardType.PoisonGas => "Poisonous gas fills the area",
        HazardType.Fire => "Flames burn throughout the area",
        HazardType.Ice => "Bitter cold permeates the area",
        HazardType.Spikes => "Sharp spikes cover the ground",
        HazardType.AcidPool => "Corrosive acid pools on the floor",
        HazardType.Darkness => "Magical darkness obscures vision",
        HazardType.Electricity => "Electrical energy crackles through the air",
        HazardType.Radiant => "Radiant energy fills the area",
        HazardType.Necrotic => "Necrotic energy drains life force",
        _ => "An unknown hazard affects this area"
    };
}
```

#### 6. Room.cs Updates (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

```csharp
// Add private field
private readonly List<HazardZone> _hazardZones = new();

// Add public properties
public IReadOnlyList<HazardZone> HazardZones => _hazardZones;
public bool HasHazards => _hazardZones.Count > 0;
public bool HasActiveHazards => _hazardZones.Any(h => h.IsActive);

// Add methods
public void AddHazardZone(HazardZone hazard)
{
    ArgumentNullException.ThrowIfNull(hazard);
    _hazardZones.Add(hazard);
}

public bool RemoveHazardZone(HazardZone hazard) => _hazardZones.Remove(hazard);

public IEnumerable<HazardZone> GetActiveHazards() =>
    _hazardZones.Where(h => h.IsActive);

public HazardZone? GetHazardByKeyword(string keyword) =>
    _hazardZones.FirstOrDefault(h => h.IsActive && h.MatchesKeyword(keyword));

public IEnumerable<HazardZone> GetHazardsByType(HazardType hazardType) =>
    _hazardZones.Where(h => h.IsActive && h.HazardType == hazardType);

public int RemoveExpiredHazards() =>
    _hazardZones.RemoveAll(h => !h.IsActive && h.IsExpired);
```

---

### Application Layer

#### 7. IHazardService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IHazardService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

/// <summary>Service for managing environmental hazards and their effects.</summary>
public interface IHazardService
{
    string GetRoomHazardsDescription(Room room);
    HazardZone? FindHazard(Room room, string keyword);
    string ExamineHazard(HazardZone hazard);
    IEnumerable<HazardEffectResult> ProcessEntryHazards(Room room, Player player);
    IEnumerable<HazardEffectResult> ProcessTurnHazards(Room room, Player player);
    HazardEffectResult ApplyHazardEffect(HazardZone hazard, Player player, bool isEntry);
    IEnumerable<string> ProcessHazardTurnTicks(Room room);
    HazardRoomSummary GetRoomHazardSummary(Room room);
    SavingThrowResult PerformSavingThrow(Player player, SavingThrow save);
}

public readonly record struct HazardRoomSummary
{
    public int Total { get; init; }
    public int Active { get; init; }
    public int Permanent { get; init; }
    public int Temporary { get; init; }
    public int Expired { get; init; }
}

public readonly record struct SavingThrowResult
{
    public int Total { get; init; }
    public IReadOnlyList<int> Rolls { get; init; }
    public int Modifier { get; init; }
    public int DC { get; init; }
    public bool Success { get; init; }
    public string Attribute { get; init; }
}
```

#### 8. HazardService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/HazardService.cs`

Key implementation (see design specification for complete code):

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;
using System.Text;

public class HazardService : IHazardService
{
    private readonly ILogger<HazardService> _logger;
    private readonly IDiceService _diceService;
    private readonly IStatusEffectService _statusEffectService;

    public HazardService(
        ILogger<HazardService> logger,
        IDiceService diceService,
        IStatusEffectService statusEffectService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _statusEffectService = statusEffectService ?? throw new ArgumentNullException(nameof(statusEffectService));
    }

    public IEnumerable<HazardEffectResult> ProcessEntryHazards(Room room, Player player)
    {
        var results = new List<HazardEffectResult>();
        var activeHazards = room.GetActiveHazards().Where(h => h.DamageOnEntry);

        foreach (var hazard in activeHazards)
        {
            var result = ApplyHazardEffect(hazard, player, isEntry: true);
            if (result.DamageDealt > 0 || result.StatusEffectsApplied.Count > 0 || result.WasNegated)
                results.Add(result);
        }
        return results;
    }

    public IEnumerable<HazardEffectResult> ProcessTurnHazards(Room room, Player player)
    {
        var results = new List<HazardEffectResult>();
        var activeHazards = room.GetActiveHazards().Where(h => h.DamagePerTurn || h.AppliesStatus);

        foreach (var hazard in activeHazards)
        {
            var result = ApplyHazardEffect(hazard, player, isEntry: false);
            if (result.DamageDealt > 0 || result.StatusEffectsApplied.Count > 0 || result.WasNegated)
                results.Add(result);
        }
        return results;
    }

    public HazardEffectResult ApplyHazardEffect(HazardZone hazard, Player player, bool isEntry)
    {
        if (!hazard.IsActive) return HazardEffectResult.NoEffect(hazard.Name);

        var damageDice = isEntry ? hazard.EntryDamageDice : hazard.DamagePerTurnDice;
        if (string.IsNullOrEmpty(damageDice) && !hazard.AppliesStatus)
            return HazardEffectResult.NoEffect(hazard.Name);

        var messageBuilder = new StringBuilder();
        var totalDamage = 0;
        var damageRolls = new List<int>();
        var appliedEffects = new List<string>();
        var saveAttempted = false;
        var saveSucceeded = false;
        int? saveRoll = null;

        // Effect message
        messageBuilder.AppendLine($"[ENVIRONMENTAL HAZARD: {hazard.Name}]");
        messageBuilder.AppendLine(hazard.EffectMessage ?? hazard.GetHazardTypeDescription() + "!");

        // Saving throw
        if (hazard.HasSave)
        {
            saveAttempted = true;
            var save = hazard.Save!.Value;
            var saveResult = PerformSavingThrow(player, save);
            saveRoll = saveResult.Total;
            saveSucceeded = saveResult.Success;

            messageBuilder.AppendLine();
            messageBuilder.AppendLine($"Saving Throw ({save.Attribute}): [{string.Join(",", saveResult.Rolls)}] + {saveResult.Modifier} = {saveResult.Total} vs DC {save.DC}");

            if (saveSucceeded && save.Negates)
            {
                messageBuilder.AppendLine("Save successful! You avoid the hazard's effects.");
                return HazardEffectResult.Negated(hazard.Name, saveResult.Total, save.DC, save.Attribute, messageBuilder.ToString().TrimEnd());
            }
            messageBuilder.AppendLine(saveSucceeded ? "Save successful! Damage halved." : "Save failed!");
        }

        // Apply damage
        if (!string.IsNullOrEmpty(damageDice))
        {
            var damageResult = _diceService.Roll(damageDice);
            damageRolls.AddRange(damageResult.Rolls);
            totalDamage = damageResult.Total;

            if (saveSucceeded && hazard.HasSave && !hazard.Save!.Value.Negates)
                totalDamage /= 2;

            player.TakeDamage(totalDamage, hazard.DamageType);

            messageBuilder.AppendLine();
            var damageInfo = saveSucceeded ? $"[{string.Join(",", damageResult.Rolls)}] = {damageResult.Total} / 2 = {totalDamage}"
                                           : $"[{string.Join(",", damageResult.Rolls)}] = {totalDamage}";
            messageBuilder.AppendLine($"Damage: {damageInfo} {hazard.DamageType} damage");

            _logger.LogInformation("Hazard {HazardName} dealt {Damage} {DamageType} damage to player", hazard.Name, totalDamage, hazard.DamageType);
        }

        // Apply status effects (only on failed save)
        if (hazard.AppliesStatus && !saveSucceeded)
        {
            foreach (var statusEffect in hazard.StatusEffects)
            {
                _statusEffectService.ApplyEffect(player, statusEffect, hazard.StatusDuration);
                appliedEffects.Add(statusEffect);
            }
            if (appliedEffects.Any())
                messageBuilder.AppendLine($"\nYou are afflicted with: {string.Join(", ", appliedEffects)}");
        }

        return HazardEffectResult.Combined(hazard.Name, totalDamage, hazard.DamageType, damageRolls, appliedEffects, messageBuilder.ToString().TrimEnd(), saveAttempted, saveSucceeded, saveRoll, hazard.Save?.DC, hazard.Save?.Attribute);
    }

    public SavingThrowResult PerformSavingThrow(Player player, SavingThrow save)
    {
        var modifier = player.GetAttributeModifier(save.Attribute);
        var roll = _diceService.Roll("1d20");
        var total = roll.Total + modifier;

        _logger.LogDebug("Saving throw {Attribute}: rolled {Roll} + {Modifier} = {Total} vs DC {DC}", save.Attribute, roll.Total, modifier, total, save.DC);

        return new SavingThrowResult
        {
            Total = total,
            Rolls = roll.Rolls.ToList(),
            Modifier = modifier,
            DC = save.DC,
            Success = total >= save.DC,
            Attribute = save.Attribute
        };
    }
}
```

#### 9. TurnProcessingService Integration (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/TurnProcessingService.cs`

```csharp
// In ProcessTurn() method, add:

// Process hazard effects on player
var hazardResults = _hazardService.ProcessTurnHazards(currentRoom, player);
foreach (var result in hazardResults)
{
    messages.Add(result.Message);
}

// Process hazard duration ticks
var hazardExpireMessages = _hazardService.ProcessHazardTurnTicks(currentRoom);
messages.AddRange(hazardExpireMessages);

// Process trap resets (existing from v0.4.1a)
var trapResetMessages = _trapService.ProcessRoomTurnTick(currentRoom);
messages.AddRange(trapResetMessages);
```

---

## Flow Diagrams

### Hazard Processing Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      HAZARD PROCESSING FLOW                                  │
└─────────────────────────────────────────────────────────────────────────────┘

    Player enters room
            │
            ▼
┌───────────────────────┐
│ ProcessEntryHazards() │
│  For each active      │
│  hazard with entry dmg│
└───────────┬───────────┘
            │
            ▼
┌───────────────────────┐
│ ApplyHazardEffect()   │
│  isEntry = true       │
└───────────────────────┘

    Turn processing
            │
            ▼
┌───────────────────────┐
│ ProcessTurnHazards()  │
│  For each active      │
│  hazard with per-turn │
└───────────┬───────────┘
            │
            ▼
┌───────────────────────┐
│ ApplyHazardEffect()   │
│  isEntry = false      │
└───────────┬───────────┘
            │
            ▼
┌───────────────────────┐
│ProcessHazardTurnTicks │
│  Duration countdown   │
│  Expire temp hazards  │
└───────────────────────┘
```

### Saving Throw Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       SAVING THROW FLOW                                      │
└─────────────────────────────────────────────────────────────────────────────┘

    ApplyHazardEffect()
            │
            ▼
┌───────────────────────┐
│   hazard.HasSave?     │────No────► Apply full damage/effects
└───────────┬───────────┘
            │ Yes
            ▼
┌───────────────────────┐
│  PerformSavingThrow() │
│  1d20 + attribute mod │
│  vs DC                │
└───────────┬───────────┘
            │
            ▼
┌───────────────────────┐
│     Save >= DC?       │
└───────────┬───────────┘
       Yes  │   No
            │    └──────► Apply full damage + status
            ▼
┌───────────────────────┐
│   save.Negates?       │
└───────────┬───────────┘
       Yes  │   No
            │    │
            ▼    ▼
    ┌─────────┐   ┌─────────────────┐
    │ No dmg  │   │ Halve damage    │
    │ No efx  │   │ No status efx   │
    └─────────┘   └─────────────────┘
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Enums/HazardTypeTests.cs         (2 tests)
│   └── ValueObjects/SavingThrowTests.cs (4 tests)
│   └── Entities/HazardZoneTests.cs      (8 tests)
├── RuneAndRust.Application.UnitTests/
│   └── Services/HazardServiceTests.cs   (7 tests)
│   └── RoomHazardTests.cs               (4 tests)
```

### Test Specifications (~25 tests)

| Category | Test Name | Description |
|----------|-----------|-------------|
| HazardType | `HasAllExpectedValues` | Verify all 9 hazard types exist |
| HazardType | `CanCastToInt` | Numeric comparison |
| SavingThrow | `Create_WithValidParameters` | Valid creation |
| SavingThrow | `Fortitude_CreatesFortitudeSave` | Factory method |
| SavingThrow | `Agility_CreatesAgilitySave` | Factory method |
| SavingThrow | `Negates_DefaultsToFalse` | Default value |
| HazardZone | `Create_WithValidParameters` | Valid creation |
| HazardZone | `Create_WithNullId_Throws` | Null ID rejected |
| HazardZone | `FromDefinition_CreatesCorrectly` | Definition mapping |
| HazardZone | `ProcessTurnTick_WhenPermanent_False` | Permanent doesn't tick |
| HazardZone | `ProcessTurnTick_Decrements` | Duration countdown |
| HazardZone | `ProcessTurnTick_WhenExpired_True` | Expiration detection |
| HazardZone | `Deactivate_SetsInactive` | Deactivation |
| HazardZone | `MatchesKeyword_FindsMatch` | Keyword matching |
| Room | `AddHazardZone_AddsToCollection` | Adding hazards |
| Room | `RemoveHazardZone_RemovesFromCollection` | Removing hazards |
| Room | `GetActiveHazards_ReturnsOnlyActive` | Active filtering |
| Room | `GetHazardByKeyword_Finds` | Keyword lookup |
| HazardService | `ProcessEntryHazards_AppliesDamage` | Entry damage |
| HazardService | `ProcessTurnHazards_AppliesDamage` | Turn damage |
| HazardService | `ApplyHazardEffect_WithSave_Rolls` | Save rolling |
| HazardService | `ApplyHazardEffect_SuccessfulSave_Halves` | Save halves |
| HazardService | `ApplyHazardEffect_SuccessfulSave_Negates` | Save negates |
| HazardService | `ApplyHazardEffect_FailedSave_FullDamage` | Full damage on fail |
| HazardService | `ProcessHazardTurnTicks_ExpiresTemporary` | Expiration |

---

## Logging Strategy

| Operation | Level | Template |
|-----------|-------|----------|
| Hazard damage dealt | Information | "Hazard {HazardName} dealt {Damage} {DamageType} damage to player" |
| Save success | Information | "Player saved against {HazardName} (rolled {Roll} vs DC {DC})" |
| Status effect applied | Information | "Hazard {HazardName} applied {Effects}" |
| Hazard expired | Debug | "Hazard {HazardName} expired" |
| Saving throw roll | Debug | "Saving throw {Attribute}: rolled {Roll} + {Modifier} = {Total} vs DC {DC}" |
| Hazard found | Debug | "Found hazard {HazardName} by keyword '{Keyword}'" |

---

## Implementation Checklist

### Domain Layer
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/HazardType.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/SavingThrow.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/HazardEffectResult.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Definitions/HazardDefinition.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/Entities/HazardZone.cs`
- [ ] Modify `src/Core/RuneAndRust.Domain/Entities/Room.cs` - Add HazardZones

### Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/Interfaces/IHazardService.cs`
- [ ] Create `src/Core/RuneAndRust.Application/Services/HazardService.cs`
- [ ] Modify `TurnProcessingService.cs` - Integrate hazard processing
- [ ] Modify `GameSessionService.cs` - Entry hazards, examine

### Configuration
- [ ] Create `config/schemas/hazards.schema.json`
- [ ] Create `config/hazards.json` - Sample hazard definitions

### Tests
- [ ] Create `tests/.../Enums/HazardTypeTests.cs`
- [ ] Create `tests/.../ValueObjects/SavingThrowTests.cs`
- [ ] Create `tests/.../Entities/HazardZoneTests.cs`
- [ ] Create `tests/.../Services/HazardServiceTests.cs`
- [ ] Create `tests/.../RoomHazardTests.cs`

### Validation
- [ ] All ~25 new tests pass
- [ ] All existing tests pass (~1535)
- [ ] Build completes with 0 errors

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | HazardType enum contains all 9 hazard types | Unit test |
| AC-2 | SavingThrow stores attribute, DC, negates | Unit test |
| AC-3 | HazardZone entity tracks all properties | Unit test |
| AC-4 | HazardZone.FromDefinition() creates from config | Unit test |
| AC-5 | HazardZone.ProcessTurnTick() handles duration | Unit test |
| AC-6 | Room.HazardZones collection manages hazards | Unit test |
| AC-7 | HazardService.ProcessEntryHazards() applies entry damage | Unit test |
| AC-8 | HazardService.ProcessTurnHazards() applies per-turn damage | Unit test |
| AC-9 | Successful saves halve damage (negates=false) | Unit test |
| AC-10 | Successful saves negate damage (negates=true) | Unit test |
| AC-11 | Status effects apply only on failed saves | Unit test |
| AC-12 | Temporary hazards expire after duration | Unit test |
| AC-13 | Active hazards appear in room descriptions | Manual |
| AC-14 | ~25 unit tests pass | Test suite |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| StatusEffectService interface mismatch | Medium | Low | Review interface before implementation |
| Dice expression parsing errors | Medium | Low | Reuse existing DiceService validation |
| Save halves vs negates confusion | Low | Medium | Clear documentation, thorough testing |
| Turn processing order issues | Medium | Low | Follow existing trap processing pattern |
| Duration countdown edge cases | Low | Medium | Test boundary conditions |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Domain/Enums/HazardType.cs` | Hazard type enum | ~35 |
| `Domain/ValueObjects/SavingThrow.cs` | Save configuration | ~50 |
| `Domain/ValueObjects/HazardEffectResult.cs` | Effect result | ~80 |
| `Domain/Definitions/HazardDefinition.cs` | JSON configuration | ~60 |
| `Domain/Entities/HazardZone.cs` | Core hazard entity | ~150 |
| `Application/Interfaces/IHazardService.cs` | Service interface | ~60 |
| `Application/Services/HazardService.cs` | Service implementation | ~200 |
| `config/schemas/hazards.schema.json` | JSON schema | ~100 |
| `config/hazards.json` | Sample definitions | ~200 |

### Files to Modify

| File | Changes | Est. Lines Added |
|------|---------|------------------|
| `Domain/Entities/Room.cs` | Add HazardZones collection | ~30 |
| `Application/Services/TurnProcessingService.cs` | Hazard turn processing | ~15 |
| `Application/Services/GameSessionService.cs` | Entry hazards, examine | ~30 |
| `Infrastructure/DependencyInjection.cs` | Register HazardService | ~5 |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| Value Objects | +3 from v0.4.1b | +2 more (SavingThrow, HazardEffectResult) |
| Entities | Room only | +HazardZone |
| Services | TrapService | +HazardService |
| Unit Tests | ~1535 | ~1560 |

---

## Next Steps

After completing this phase:

1. **v0.4.2 (Puzzles & Secrets)** - Puzzle mechanisms, secret doors, hidden areas
2. **v0.4.3 (Light & Skills)** - Light sources, darkness effects, skill integration
3. **Integration Testing** - Full hazard + trap + combat integration

---

*This implementation plan completes the v0.4.1 Traps & Environmental Hazards system with persistent area-based dangers, saving throw mechanics, and full turn processing integration.*
