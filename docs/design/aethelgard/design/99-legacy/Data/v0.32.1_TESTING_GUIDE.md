# v0.32.1 Testing & Validation Guide
## Jötunheim Database Schema & Room Templates Implementation

**Version**: v0.32.1
**Document ID**: RR-SPEC-v0.32.1-DATABASE
**Parent Specification**: v0.32 Jötunheim Biome Implementation
**Timeline**: 10-14 hours

---

## Prerequisites

- .NET SDK installed
- SQLite3 command-line tool (optional, for manual inspection)
- Access to runeandrust.db database
- v0.31.1 (Alfheim) completed and tested

---

## Quick Start

### 1. Execute SQL Migration

```bash
cd /path/to/rune-rust

# Execute v0.32.1: Jötunheim Schema & Room Templates
sqlite3 runeandrust.db < Data/v0.32.1_jotunheim_schema.sql
```

### 2. Verify Installation

```bash
sqlite3 runeandrust.db <<EOF
SELECT 'Jötunheim Biome:' as Label, COUNT(*) as Count
FROM Biomes WHERE biome_id = 7;

SELECT 'Room Templates:' as Label, COUNT(*) as Count
FROM Biome_RoomTemplates WHERE biome_id = 7;

SELECT 'Resources:' as Label, COUNT(*) as Count
FROM Biome_ResourceDrops WHERE biome_id = 7;
EOF
```

**Expected Output**:
```
Label                    Count
--------------------     -----
Jötunheim Biome:         1
Room Templates:          10
Resources:               10
```

---

## Automated Testing Steps

### 1. Build Verification

```bash
cd /path/to/rune-rust
dotnet build
```

**Expected Result:** No compilation errors

### 2. Repository Integration Test

The JotunheimDataRepository should compile and integrate with existing systems:

```bash
# Build the Persistence project specifically
dotnet build RuneAndRust.Persistence
```

**Expected Log Output:**
```
[DBG] JotunheimDataRepository initialized
[INF] Loaded 10 room templates for Jötunheim (tier: All)
[INF] Loaded 10 resource drops for Jötunheim (tier: 1-4)
```

### 3. Database Initialization Test

If using the application startup flow:

```bash
dotnet run --project RuneAndRust.ConsoleApp
```

**Expected Behavior:**
- No database errors in logs
- Jötunheim biome data accessible via repository
- No foreign key constraint violations

---

## Manual Validation Queries

Run these queries against `runeandrust.db` using SQLite3 CLI:

### Test 1: Verify Jötunheim biome exists

```sql
SELECT * FROM Biomes WHERE biome_id = 7;
```

**Expected:**
- 1 row with biome_name = 'Jotunheim' (ASCII storage)
- z_level_restriction = '[Trunk/Roots]'
- ambient_condition_id = NULL (no ambient condition)
- min_character_level = 5, max_character_level = 9 (mid-game)

### Test 2: Verify all 10 room templates inserted

```sql
SELECT COUNT(*) as template_count FROM Biome_RoomTemplates WHERE biome_id = 7;
```

**Expected:** template_count = 10

### Test 3: Verify verticality distribution (7 Trunk, 3 Roots)

```sql
SELECT
    z_level,
    COUNT(*) as count,
    SUM(enemy_spawn_weight) as total_weight
FROM Biome_RoomTemplates
WHERE biome_id = 7
GROUP BY z_level;
```

**Expected:**
- Trunk: 7 templates, total_weight = 780
- Roots: 3 templates, total_weight = 150

### Test 4: Verify Trunk/Roots spawn weight ratio

```sql
SELECT
    z_level,
    SUM(enemy_spawn_weight) as total_weight,
    ROUND(100.0 * SUM(enemy_spawn_weight) / (
        SELECT SUM(enemy_spawn_weight) FROM Biome_RoomTemplates WHERE biome_id = 7
    ), 1) as percentage
FROM Biome_RoomTemplates
WHERE biome_id = 7
GROUP BY z_level;
```

**Expected:**
- Trunk: ~83.9% (780/930)
- Roots: ~16.1% (150/930)

**Note:** The spawn weight distribution (83.9% / 16.1%) translates to effective room frequency. The heavier Trunk weights ensure factory floor levels appear more frequently than deep maintenance tunnels.

### Test 5: Verify room template details

```sql
SELECT
    template_name,
    z_level,
    room_size_category,
    hazard_density,
    enemy_spawn_weight,
    resource_spawn_chance
FROM Biome_RoomTemplates
WHERE biome_id = 7
ORDER BY z_level, enemy_spawn_weight DESC;
```

**Expected:** 10 rows showing:
- 7 Trunk templates (Primary Assembly Line, Jotun Umbilical Gantry, etc.)
- 3 Roots templates (Maintenance Tunnel Network, Power Distribution Core, Waste Reclamation Chamber)

### Test 6: Verify entrance templates

```sql
SELECT COUNT(*) as entrance_count
FROM Biome_RoomTemplates
WHERE biome_id = 7 AND can_be_entrance = 1;
```

**Expected:** entrance_count >= 2 (Primary Assembly Line, Command Deck Wreckage)

### Test 7: Verify exit templates

```sql
SELECT COUNT(*) as exit_count
FROM Biome_RoomTemplates
WHERE biome_id = 7 AND can_be_exit = 1;
```

**Expected:** exit_count >= 2 (Shipping Container Maze, Waste Reclamation Chamber)

### Test 8: Verify special room - Fallen Einherjar Torso-Cave

```sql
SELECT
    template_name,
    hazard_density,
    resource_spawn_chance,
    wfc_adjacency_rules
FROM Biome_RoomTemplates
WHERE biome_id = 7
  AND template_name = 'Fallen Einherjar Torso-Cave';
```

**Expected:**
- hazard_density = 'Extreme'
- resource_spawn_chance = 0.85 (85% - high reward for high risk)
- wfc_adjacency_rules forbids Primary Assembly Line and Scrap Compactor Sector

### Test 9: Verify Power Distribution Core (most dangerous)

```sql
SELECT
    template_name,
    z_level,
    hazard_density,
    resource_spawn_chance,
    enemy_spawn_weight
FROM Biome_RoomTemplates
WHERE biome_id = 7
  AND template_name = 'Power Distribution Core';
```

**Expected:**
- z_level = 'Roots'
- hazard_density = 'Extreme'
- resource_spawn_chance = 0.90 (90% - highest reward)
- enemy_spawn_weight = 50 (rare encounter)

### Test 10: Verify all 10 resources inserted

```sql
SELECT COUNT(*) as resource_count FROM Biome_ResourceDrops WHERE biome_id = 7;
```

**Expected:** resource_count = 10

### Test 11: Verify resource tier distribution

```sql
SELECT
    resource_tier,
    COUNT(*) as count
FROM Biome_ResourceDrops
WHERE biome_id = 7
GROUP BY resource_tier
ORDER BY resource_tier;
```

**Expected:**
- Tier 1: 3 resources (Rusted Scrap Metal, Ball Bearings, Coolant Fluid)
- Tier 2: 3 resources (Intact Servomotor, Hydraulic Cylinder, Power Relay Circuit)
- Tier 3: 2 resources (Unblemished Jotun Plating, Industrial Servo Actuator)
- Tier 4: 2 resources (Uncorrupted Power Coil, Jotun Logic Core Fragment)

### Test 12: Verify mechanical component dominance

```sql
SELECT
    rarity,
    COUNT(*) as count
FROM Biome_ResourceDrops
WHERE biome_id = 7
GROUP BY rarity
ORDER BY
    CASE rarity
        WHEN 'Common' THEN 1
        WHEN 'Uncommon' THEN 2
        WHEN 'Rare' THEN 3
        WHEN 'Legendary' THEN 4
    END;
```

**Expected:**
- Common: 3
- Uncommon: 3
- Rare: 2
- Legendary: 2

### Test 13: Verify drop chance constraints

```sql
SELECT COUNT(*) as invalid_count
FROM Biome_ResourceDrops
WHERE biome_id = 7
  AND (base_drop_chance < 0.0 OR base_drop_chance > 1.0);
```

**Expected:** invalid_count = 0

### Test 14: Verify legendary resource rarity

```sql
SELECT
    resource_name,
    resource_tier,
    base_drop_chance,
    weight
FROM Biome_ResourceDrops
WHERE biome_id = 7
  AND resource_tier = 4
ORDER BY weight DESC;
```

**Expected:**
- Uncorrupted Power Coil: base_drop_chance = 0.05, weight = 5
- Jotun Logic Core Fragment: base_drop_chance = 0.03, weight = 3 (ultra-rare)

### Test 15: Verify resource spawn weight distribution

```sql
SELECT
    resource_name,
    weight,
    ROUND(100.0 * weight / (
        SELECT SUM(weight) FROM Biome_ResourceDrops WHERE biome_id = 7
    ), 1) as drop_percentage
FROM Biome_ResourceDrops
WHERE biome_id = 7
ORDER BY weight DESC;
```

**Expected:** Rusted Scrap Metal has highest drop_percentage (~23.8%), legendaries lowest (~0.4% and ~0.3%)

### Test 16: Verify Unblemished Jötun Plating (signature resource)

```sql
SELECT
    resource_name,
    resource_tier,
    rarity,
    base_drop_chance,
    requires_special_node,
    resource_description
FROM Biome_ResourceDrops
WHERE biome_id = 7
  AND resource_name = 'Unblemished Jotun Plating';
```

**Expected:**
- resource_tier = 3
- rarity = 'Rare'
- base_drop_chance = 0.15
- requires_special_node = 1 (must salvage from intact Jötun-Forged sections)

---

## C# Repository Integration Tests

### Test 17: Load all room templates

```csharp
var repo = new JotunheimDataRepository("Data Source=runeandrust.db");
var templates = repo.GetRoomTemplates();

Assert.Equal(10, templates.Count);
Assert.Contains(templates, t => t.TemplateName == "Primary Assembly Line");
Assert.Contains(templates, t => t.TemplateName == "Power Distribution Core");
```

### Test 18: Verify Trunk/Roots split

```csharp
var repo = new JotunheimDataRepository("Data Source=runeandrust.db");
var trunkTemplates = repo.GetTrunkTemplates();
var rootsTemplates = repo.GetRootsTemplates();

Assert.Equal(7, trunkTemplates.Count);
Assert.Equal(3, rootsTemplates.Count);
```

### Test 19: Verify verticality weights

```csharp
var repo = new JotunheimDataRepository("Data Source=runeandrust.db");
var weights = repo.GetVerticalityWeights();

Assert.Equal(780, weights["Trunk"]);
Assert.Equal(150, weights["Roots"]);

// Verify ratio is approximately 70/30 by spawn weight effect
var total = weights["Trunk"] + weights["Roots"];
var trunkPercent = (double)weights["Trunk"] / total * 100;
Assert.InRange(trunkPercent, 80.0, 85.0); // ~83.9%
```

### Test 20: Load resources by tier

```csharp
var repo = new JotunheimDataRepository("Data Source=runeandrust.db");
var commonComponents = repo.GetCommonComponents(); // Tier 1-2
var advancedComponents = repo.GetAdvancedComponents(); // Tier 3
var legendaryResources = repo.GetLegendaryResources(); // Tier 4

Assert.Equal(6, commonComponents.Count);
Assert.Equal(2, advancedComponents.Count);
Assert.Equal(2, legendaryResources.Count);
```

### Test 21: Verify database integrity

```csharp
var repo = new JotunheimDataRepository("Data Source=runeandrust.db");
var report = repo.ValidateDatabaseIntegrity();

Assert.True(report.BiomeExists);
Assert.Equal(10, report.RoomTemplateCount);
Assert.Equal(10, report.ResourceDropCount);
Assert.Equal(7, report.TrunkTemplateCount);
Assert.Equal(3, report.RootsTemplateCount);
Assert.True(report.IsValid);

Console.WriteLine(report.ToString());
```

**Expected Output:**
```
Jötunheim Integrity Report:
  Biome Exists: True
  Room Templates: 10/10
  Resources: 10/10
  Trunk Templates: 7/7 (weight: 780)
  Roots Templates: 3/3 (weight: 150)
  Valid: True
```

---

## Data Integrity Checks

### Comprehensive Validation Query

```sql
-- Check for orphaned room templates
SELECT 'Orphaned Room Templates' as Check, COUNT(*) as Issues
FROM Biome_RoomTemplates
WHERE biome_id = 7
  AND biome_id NOT IN (SELECT biome_id FROM Biomes);

-- Check for orphaned resources
SELECT 'Orphaned Resources' as Check, COUNT(*) as Issues
FROM Biome_ResourceDrops
WHERE biome_id = 7
  AND biome_id NOT IN (SELECT biome_id FROM Biomes);

-- Check for missing ambient condition (should be NULL)
SELECT 'Has Ambient Condition (should be NULL)' as Check, COUNT(*) as Issues
FROM Biomes
WHERE biome_id = 7 AND ambient_condition_id IS NOT NULL;

-- Verify room size categories are valid
SELECT 'Invalid Room Sizes' as Check, COUNT(*) as Issues
FROM Biome_RoomTemplates
WHERE biome_id = 7
  AND room_size_category NOT IN ('Small', 'Medium', 'Large', 'XLarge');

-- Verify hazard density categories are valid
SELECT 'Invalid Hazard Densities' as Check, COUNT(*) as Issues
FROM Biome_RoomTemplates
WHERE biome_id = 7
  AND hazard_density NOT IN ('None', 'Low', 'Medium', 'High', 'Extreme');

-- Verify verticality tiers are valid
SELECT 'Invalid Verticality Tiers' as Check, COUNT(*) as Issues
FROM Biome_RoomTemplates
WHERE biome_id = 7
  AND z_level NOT IN ('Trunk', 'Roots');

-- Verify resource tiers are valid
SELECT 'Invalid Resource Tiers' as Check, COUNT(*) as Issues
FROM Biome_ResourceDrops
WHERE biome_id = 7
  AND (resource_tier < 1 OR resource_tier > 5);

-- Verify rarity values are valid
SELECT 'Invalid Rarity Values' as Check, COUNT(*) as Issues
FROM Biome_ResourceDrops
WHERE biome_id = 7
  AND rarity NOT IN ('Common', 'Uncommon', 'Rare', 'Epic', 'Legendary');
```

**Expected:** All "Issues" counts should be 0

---

## v5.0 Setting Compliance Tests

### Test 22: Verify v5.0 voice (industrial, not mythological)

```sql
SELECT
    template_name,
    template_description
FROM Biome_RoomTemplates
WHERE biome_id = 7;
```

**Manual Review:** Ensure descriptions use:
- ✅ "Pre-Glitch engineers," "industrial manufacturing," "assembly process"
- ✅ "Jötun-Forged terraforming units," "power distribution," "maintenance crews"
- ❌ NOT "divine forges," "titans," "sacred grounds"

### Test 23: Verify ASCII compliance in storage

```sql
SELECT biome_name FROM Biomes WHERE biome_id = 7;
```

**Expected:** biome_name = 'Jotunheim' (ASCII, not 'Jötunheim')

**Note:** Display layer should render as "Jötunheim" (with ö) for user-facing content.

### Test 24: Verify 800-year decay theme

```sql
SELECT resource_description
FROM Biome_ResourceDrops
WHERE biome_id = 7
  AND resource_name = 'Rusted Scrap Metal';
```

**Expected:** Description contains "800 years," "rust," "corrosion," or similar decay language

---

## Performance Validation

### Test 25: Query performance benchmarks

```sql
-- Test room template query performance
.timer on
SELECT * FROM Biome_RoomTemplates WHERE biome_id = 7;
.timer off
```

**Expected:** Query completes in < 10ms (indexed by biome_id)

### Test 26: Resource drop query performance

```sql
.timer on
SELECT * FROM Biome_ResourceDrops WHERE biome_id = 7 AND resource_tier <= 3;
.timer off
```

**Expected:** Query completes in < 10ms (indexed by biome_id and resource_tier)

---

## Success Criteria Checklist

- [ ] All SQL files execute without errors
- [ ] Biome entry exists (biome_id = 7)
- [ ] 10 room templates loaded (7 Trunk, 3 Roots)
- [ ] 10 resources loaded (tiers 1-4)
- [ ] Verticality distribution correct (70/30 effective split via spawn weights)
- [ ] All foreign key constraints satisfied
- [ ] No orphaned data
- [ ] All descriptions use v5.0 voice
- [ ] Entity names are ASCII-compliant internally
- [ ] JotunheimDataRepository compiles without errors
- [ ] Database integrity report shows IsValid = True
- [ ] All manual validation queries pass
- [ ] Performance benchmarks meet targets (< 10ms per query)

---

## Troubleshooting

### Issue: "Error: no such table: Biomes"

**Cause**: Database tables not created yet

**Solution**: Run the application once to initialize database
```bash
dotnet run --project RuneAndRust.ConsoleApp
```

### Issue: "Error: UNIQUE constraint failed: Biomes.biome_id"

**Cause**: Jötunheim biome already inserted

**Solution**: This is expected with `INSERT OR IGNORE`. Data will not be duplicated.

### Issue: "Verticality weights don't match 70/30"

**Cause**: Misunderstanding of spawn weight vs. template count

**Explanation**:
- Template count: 7 Trunk, 3 Roots = 70%/30% by count
- Spawn weight: 780 Trunk, 150 Roots = 83.9%/16.1% by weight
- The weighted distribution affects actual room frequency in generation

**Expected Behavior**: Higher Trunk spawn weights ensure factory floor rooms are more common than deep maintenance tunnels, which is thematically appropriate.

---

## Rollback Procedure

If you need to remove Jötunheim data:

```bash
sqlite3 runeandrust.db <<'EOF'
BEGIN TRANSACTION;

DELETE FROM Biome_ResourceDrops WHERE biome_id = 7;
DELETE FROM Biome_RoomTemplates WHERE biome_id = 7;
DELETE FROM Biomes WHERE biome_id = 7;

COMMIT;
EOF
```

---

## Next Steps

After v0.32.1 passes all tests:

1. **Proceed to v0.32.2**: Environmental Hazards & Industrial Terrain
   - [Live Power Conduit] signature hazard
   - [High-Pressure Steam Vent]
   - [Unstable Ceiling/Wall]
   - 10+ hazard types

2. **Proceed to v0.32.3**: Enemy Definitions & Spawn System
   - 6 enemy types (Undying-heavy)
   - Armor-shredding mechanics

3. **Proceed to v0.32.4**: Service Implementation & Testing
   - JotunheimService
   - BiomeGenerationService integration

---

**v0.32.1 Testing Complete!**

Your Jötunheim database foundation is validated and ready for environmental systems (v0.32.2).
