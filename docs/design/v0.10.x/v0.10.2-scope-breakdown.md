# v0.10.2 Combo System - Scope Breakdown

**Version:** 0.10.2
**Theme:** Ability Trees
**Prerequisites:** v0.10.1c Complete (Combat Actions - Environmental Combat)
**Total Estimated Tests:** ~50 new tests

---

## Executive Summary

The Ability Trees sub-version implements the talent tree system for long-term character progression. Each class has a talent tree with multiple branches for specialization. Players earn talent points on level-up and spend them to unlock abilities, with some abilities having prerequisites or stat requirements. The respec system allows reallocating all points.

Key focus areas:
- **Tree Structure**: AbilityTreeDefinition with branches and nodes
- **Point Management**: Earning, spending, and tracking talent points
- **Prerequisites & Upgrades**: Node requirements and ability ranks

The work is divided into **three sub-parts**:

| Part | Name | Focus | Est. Tests |
|------|------|-------|------------|
| v0.10.2a | Tree Definitions | AbilityTreeDefinition, nodes, branches, config | ~18 |
| v0.10.2b | Talent Point Service | Point earning, spending, allocation tracking | ~18 |
| v0.10.2c | Prerequisites & Respec | Prerequisite validation, ranks, respec system | ~14 |

---

## Existing Infrastructure

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| AbilityDefinition | `Domain/Definitions/AbilityDefinition.cs` | Ability data |
| AbilityService | `Application/Services/AbilityService.cs` | Ability execution |
| ClassDefinition | `Domain/Definitions/ClassDefinition.cs` | Class data |
| Player | `Domain/Entities/Player.cs` | Player entity |
| LevelUpService | `Application/Services/LevelUpService.cs` | Level progression |
| IConfigurationProvider | `Application/Interfaces/IConfigurationProvider.cs` | Config loading |

### Already Implemented (from v0.10.1/v0.10.2)

| Feature | Location | Notes |
|---------|----------|-------|
| IBuffDebuffService | `Application/Interfaces/IBuffDebuffService.cs` | Status effects |
| StatModifier | `Domain/ValueObjects/StatModifier.cs` | Stat modification |
| EventBus | `Application/Services/EventBus.cs` | Event system |

### Needs Implementation (v0.10.2)

| Feature | Part | Notes |
|---------|------|-------|
| AbilityTreeDefinition | v0.10.2a | Tree structure |
| AbilityTreeBranch | v0.10.2a | Branch grouping |
| AbilityTreeNode | v0.10.2a | Individual talents |
| ITalentPointService | v0.10.2b | Point interface |
| TalentPointService | v0.10.2b | Point management |
| TalentAllocation | v0.10.2b | Player allocations |
| PrerequisiteValidator | v0.10.1c | Prereq checking |
| RespecService | v0.10.1c | Point reset |

---

## Feature Analysis & Categorization

### Tree Definition Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| AbilityTreeDefinition entity | High | Domain | **v0.10.2a** |
| AbilityTreeBranch entity | Medium | Tree def | **v0.10.2a** |
| AbilityTreeNode entity | Medium | Branch | **v0.10.2a** |
| ability-trees.json config | High | Config | **v0.10.2a** |
| IAbilityTreeProvider | Medium | Config | **v0.10.2a** |
| Tree-per-class mapping | Medium | Classes | **v0.10.2a** |

### Point Management Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| ITalentPointService | Medium | Application | **v0.10.2b** |
| TalentPointService | High | Service | **v0.10.2b** |
| Points on level-up | Medium | LevelUp | **v0.10.2b** |
| TalentAllocation tracking | Medium | Player | **v0.10.2b** |
| Spend point on node | High | Tree, Player | **v0.10.2b** |
| Unspent points tracking | Low | Player | **v0.10.2b** |

### Prerequisite & Respec Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| Prerequisite validation | High | Nodes, Stats | **v0.10.1c** |
| Stat prerequisites | Medium | Stats | **v0.10.1c** |
| Node prerequisites | Medium | Allocations | **v0.10.1c** |
| Ability ranks/upgrades | Medium | Nodes | **v0.10.1c** |
| IRespecService | Low | Application | **v0.10.1c** |
| RespecService | High | Points, Alloc | **v0.10.1c** |

---

## Part Definitions

---

## v0.10.2a: Tree Definitions

[v0.10.2a Design Specification](v0.10.2a-design-specification.md)

### Overview

Define the ability tree structure with trees per class, branches for specialization, and nodes for individual talents. Trees are loaded from JSON configuration and provide the template for player progression.

### Scope

**In Scope:**
- `AbilityTreeDefinition` entity
- `AbilityTreeBranch` entity
- `AbilityTreeNode` entity
- Tree-to-class mapping
- Branch grouping (e.g., Berserker, Guardian, Champion)
- Node properties (tier, cost, position)
- `IAbilityTreeProvider` interface
- `AbilityTreeProvider` implementation
- `ability-trees.json` configuration
- Tree visualization coordinates (x, y)
- Connection lines between nodes

**Out of Scope:**
- Point spending logic (v0.10.2b)
- Prerequisite validation (v0.10.1c)
- Respec system (v0.10.1c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 3 | `AbilityTreeDefinition`, `AbilityTreeBranch`, `AbilityTreeNode` |
| Interfaces | 1 | `IAbilityTreeProvider` |
| Infrastructure | 1 | `AbilityTreeProvider` |
| Configuration | 1 | `ability-trees.json` |
| Unit Tests | ~18 | Tree loading, structure validation |

### Ability Tree Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ABILITY TREE ARCHITECTURE                         │
└─────────────────────────────────────────────────────────────────────┘

     Configuration                        Domain
     ─────────────                        ──────

   ability-trees.json           ┌─────────────────────────────┐
   ┌─────────────────┐          │   AbilityTreeDefinition     │
   │ {                │          ├─────────────────────────────┤
   │   "treeId": ..., │  ─────▶  │ + TreeId: string            │
   │   "classId": ...,│          │ + ClassId: string           │
   │   "branches": [  │          │ + Name: string              │
   │     { ... }      │          │ + PointsPerLevel: int       │
   │   ]              │          │ + Branches: List<Branch>    │
   │ }                │          └──────────────┬──────────────┘
   └─────────────────┘                          │
                                                │ contains
                                                ▼
                                 ┌─────────────────────────────┐
                                 │     AbilityTreeBranch       │
                                 ├─────────────────────────────┤
                                 │ + BranchId: string          │
                                 │ + Name: string              │
                                 │ + Description: string       │
                                 │ + Nodes: List<TreeNode>     │
                                 └──────────────┬──────────────┘
                                                │ contains
                                                ▼
                                 ┌─────────────────────────────┐
                                 │      AbilityTreeNode        │
                                 ├─────────────────────────────┤
                                 │ + NodeId: string            │
                                 │ + AbilityId: string         │
                                 │ + Tier: int                 │
                                 │ + PointCost: int            │
                                 │ + MaxRank: int              │
                                 │ + PrerequisiteNodeIds: list │
                                 │ + StatPrerequisites: list   │
                                 │ + Position: (X, Y)          │
                                 └─────────────────────────────┘


                    WARRIOR ABILITY TREE VISUALIZATION
                    ──────────────────────────────────

                            ┌───────────────┐
                            │   WARRIOR     │
                            │    (Base)     │
                            └───────┬───────┘
                                    │
                    ┌───────────────┼───────────────┐
                    │               │               │
                    ▼               ▼               ▼
            ┌───────────┐   ┌───────────┐   ┌───────────┐
            │BERSERKER  │   │ GUARDIAN  │   │ CHAMPION  │
            │ (Branch)  │   │ (Branch)  │   │ (Branch)  │
            └─────┬─────┘   └─────┬─────┘   └─────┬─────┘
                  │               │               │
            ┌─────┴─────┐   ┌─────┴─────┐   ┌─────┴─────┐
            │           │   │           │   │           │
            ▼           ▼   ▼           ▼   ▼           ▼
        ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐
        │Frenzy │ │Blood- │ │Shield │ │Taunt  │ │Rallying│ │Battle │
        │ (T1)  │ │lust   │ │Wall   │ │ (T1)  │ │Cry(T1)│ │Master │
        └───┬───┘ │ (T1)  │ │ (T1)  │ └───┬───┘ └───┬───┘ │ (T1)  │
            │     └───────┘ └───┬───┘     │         │     └───────┘
            │                   │         │         │
            ▼                   ▼         ▼         ▼
        ┌───────┐         ┌───────┐ ┌───────┐ ┌───────┐
        │Rage   │         │Iron   │ │Aura of│ │Inspire│
        │ (T2)  │         │Skin   │ │Defense│ │ (T2)  │
        └───────┘         │ (T2)  │ │ (T2)  │ └───────┘
                          └───────┘ └───────┘
            
        T1 = Tier 1 (1 point)   T2 = Tier 2 (2 points, requires T1)
```

### AbilityTreeDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines an ability tree for a class.
/// </summary>
public class AbilityTreeDefinition : IEntity
{
    public Guid Id { get; private set; }
    public string TreeId { get; private set; } = null!;
    public string ClassId { get; private set; } = null!;
    public string Name { get; private set; } = null!;
    public string Description { get; private set; } = null!;
    public int PointsPerLevel { get; private set; } = 1;
    public IReadOnlyList<AbilityTreeBranch> Branches { get; private set; } = [];
    public string? IconPath { get; private set; }
    
    private AbilityTreeDefinition() { }
    
    public static AbilityTreeDefinition Create(
        string treeId,
        string classId,
        string name,
        string description,
        int pointsPerLevel = 1)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(treeId);
        ArgumentException.ThrowIfNullOrWhiteSpace(classId);
        
        return new AbilityTreeDefinition
        {
            Id = Guid.NewGuid(),
            TreeId = treeId.ToLowerInvariant(),
            ClassId = classId.ToLowerInvariant(),
            Name = name,
            Description = description,
            PointsPerLevel = pointsPerLevel
        };
    }
    
    /// <summary>Gets all nodes across all branches.</summary>
    public IEnumerable<AbilityTreeNode> GetAllNodes()
    {
        return Branches.SelectMany(b => b.Nodes);
    }
    
    /// <summary>Finds a node by ID.</summary>
    public AbilityTreeNode? FindNode(string nodeId)
    {
        return GetAllNodes().FirstOrDefault(n => n.NodeId == nodeId);
    }
    
    /// <summary>Gets the total points needed to fully unlock the tree.</summary>
    public int GetTotalPointsRequired()
    {
        return GetAllNodes().Sum(n => n.PointCost * n.MaxRank);
    }
}
```

### AbilityTreeBranch Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// A branch within an ability tree representing a specialization.
/// </summary>
public class AbilityTreeBranch
{
    public string BranchId { get; set; } = null!;
    public string Name { get; set; } = null!;
    public string Description { get; set; } = null!;
    public IReadOnlyList<AbilityTreeNode> Nodes { get; set; } = [];
    public string? IconPath { get; set; }
    
    /// <summary>Gets nodes at a specific tier.</summary>
    public IEnumerable<AbilityTreeNode> GetNodesAtTier(int tier)
    {
        return Nodes.Where(n => n.Tier == tier);
    }
    
    /// <summary>Gets the maximum tier in this branch.</summary>
    public int GetMaxTier()
    {
        return Nodes.Any() ? Nodes.Max(n => n.Tier) : 0;
    }
}
```

### AbilityTreeNode Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// A single node (talent) in an ability tree.
/// </summary>
public class AbilityTreeNode
{
    public string NodeId { get; set; } = null!;
    public string AbilityId { get; set; } = null!;
    public string Name { get; set; } = null!;
    public string Description { get; set; } = null!;
    public int Tier { get; set; }
    public int PointCost { get; set; } = 1;
    public int MaxRank { get; set; } = 1;
    public IReadOnlyList<string> PrerequisiteNodeIds { get; set; } = [];
    public IReadOnlyList<StatPrerequisite> StatPrerequisites { get; set; } = [];
    public NodePosition Position { get; set; } = new(0, 0);
    public string? IconPath { get; set; }
    
    /// <summary>Whether this node has any prerequisites.</summary>
    public bool HasPrerequisites => PrerequisiteNodeIds.Any() || StatPrerequisites.Any();
}

/// <summary>Position for UI layout.</summary>
public record NodePosition(int X, int Y);

/// <summary>A stat requirement for unlocking a node.</summary>
public record StatPrerequisite(string StatId, int MinValue);
```

### IAbilityTreeProvider Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides ability tree definitions.
/// </summary>
public interface IAbilityTreeProvider
{
    /// <summary>Gets the ability tree for a class.</summary>
    AbilityTreeDefinition? GetTreeForClass(string classId);
    
    /// <summary>Gets a tree by its ID.</summary>
    AbilityTreeDefinition? GetTree(string treeId);
    
    /// <summary>Gets all available trees.</summary>
    IReadOnlyList<AbilityTreeDefinition> GetAllTrees();
    
    /// <summary>Finds a node across all trees.</summary>
    AbilityTreeNode? FindNode(string nodeId);
    
    /// <summary>Gets the tree containing a node.</summary>
    AbilityTreeDefinition? GetTreeContainingNode(string nodeId);
}
```

### Ability Trees Configuration

```json
{
  "$schema": "./schemas/ability-trees.schema.json",
  "abilityTrees": [
    {
      "treeId": "warrior-tree",
      "classId": "warrior",
      "name": "Warrior Talents",
      "description": "Master of arms and battlefield tactics",
      "pointsPerLevel": 1,
      "branches": [
        {
          "branchId": "berserker",
          "name": "Berserker",
          "description": "Fury and raw damage",
          "nodes": [
            {
              "nodeId": "frenzy",
              "abilityId": "frenzy",
              "name": "Frenzy",
              "description": "Enter a battle rage increasing attack speed",
              "tier": 1,
              "pointCost": 1,
              "maxRank": 3,
              "prerequisites": [],
              "position": { "x": 0, "y": 1 }
            },
            {
              "nodeId": "bloodlust",
              "abilityId": "bloodlust",
              "name": "Bloodlust",
              "description": "Heal when killing enemies",
              "tier": 1,
              "pointCost": 1,
              "maxRank": 1,
              "prerequisites": [],
              "position": { "x": 1, "y": 1 }
            },
            {
              "nodeId": "rage",
              "abilityId": "rage",
              "name": "Rage",
              "description": "Massive damage boost at low health",
              "tier": 2,
              "pointCost": 2,
              "maxRank": 1,
              "prerequisites": ["frenzy"],
              "statPrerequisites": [{ "stat": "strength", "minValue": 14 }],
              "position": { "x": 0, "y": 2 }
            }
          ]
        },
        {
          "branchId": "guardian",
          "name": "Guardian",
          "description": "Protection and resilience",
          "nodes": [
            {
              "nodeId": "shield-wall",
              "abilityId": "shield-wall",
              "name": "Shield Wall",
              "description": "Massively increased block chance",
              "tier": 1,
              "pointCost": 1,
              "maxRank": 3,
              "prerequisites": [],
              "position": { "x": 0, "y": 1 }
            },
            {
              "nodeId": "taunt",
              "abilityId": "taunt",
              "name": "Taunt",
              "description": "Force enemies to attack you",
              "tier": 1,
              "pointCost": 1,
              "maxRank": 1,
              "prerequisites": [],
              "position": { "x": 1, "y": 1 }
            },
            {
              "nodeId": "iron-skin",
              "abilityId": "iron-skin",
              "name": "Iron Skin",
              "description": "Reduce all damage taken",
              "tier": 2,
              "pointCost": 2,
              "maxRank": 1,
              "prerequisites": ["shield-wall"],
              "position": { "x": 0, "y": 2 }
            },
            {
              "nodeId": "aura-of-defense",
              "abilityId": "aura-of-defense",
              "name": "Aura of Defense",
              "description": "Allies near you take less damage",
              "tier": 2,
              "pointCost": 2,
              "maxRank": 1,
              "prerequisites": ["taunt"],
              "position": { "x": 1, "y": 2 }
            }
          ]
        },
        {
          "branchId": "champion",
          "name": "Champion",
          "description": "Leadership and inspiration",
          "nodes": [
            {
              "nodeId": "rallying-cry",
              "abilityId": "rallying-cry",
              "name": "Rallying Cry",
              "description": "Boost ally morale and stats",
              "tier": 1,
              "pointCost": 1,
              "maxRank": 3,
              "prerequisites": [],
              "position": { "x": 0, "y": 1 }
            },
            {
              "nodeId": "battle-master",
              "abilityId": "battle-master",
              "name": "Battle Master",
              "description": "Improved tactical options",
              "tier": 1,
              "pointCost": 1,
              "maxRank": 1,
              "prerequisites": [],
              "position": { "x": 1, "y": 1 }
            },
            {
              "nodeId": "inspire",
              "abilityId": "inspire",
              "name": "Inspire",
              "description": "Grant allies extra actions",
              "tier": 2,
              "pointCost": 2,
              "maxRank": 1,
              "prerequisites": ["rallying-cry"],
              "position": { "x": 0, "y": 2 }
            }
          ]
        }
      ]
    }
  ]
}
```

### Acceptance Criteria

- [ ] AbilityTreeDefinition loads from JSON
- [ ] Trees are mapped to classes
- [ ] Branches group related talents
- [ ] Nodes define individual talents
- [ ] Tiers organize node hierarchy
- [ ] PointCost defined per node
- [ ] MaxRank supports multi-rank abilities
- [ ] PrerequisiteNodeIds lists requirements
- [ ] StatPrerequisites define stat requirements
- [ ] Position coordinates for UI layout
- [ ] GetAllNodes returns all tree nodes
- [ ] FindNode locates specific nodes
- [ ] ~18 unit tests pass

---

## v0.10.2b: Talent Point Service

[v0.10.2b Design Specification](v0.10.2b-design-specification.md)

### Overview

Implement the talent point management service for earning, spending, and tracking talent points. Players earn points on level-up and spend them to allocate into tree nodes. Allocations are tracked on the player entity.

### Scope

**In Scope:**
- `ITalentPointService` interface
- `TalentPointService` implementation
- `TalentAllocation` entity (player's allocations)
- Points earned on level-up (configurable per tree)
- Unspent points tracking
- Spend point on node
- Current rank tracking for multi-rank nodes
- Cannot exceed MaxRank
- Player.TalentAllocations collection
- Player.UnspentTalentPoints property
- TalentPointSpent event
- Integration with LevelUpService

**Out of Scope:**
- Tree definitions (v0.10.2a)
- Prerequisite validation (v0.10.1c)
- Respec system (v0.10.1c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Interfaces | 1 | `ITalentPointService` |
| Services | 1 | `TalentPointService` |
| Domain Entities | 1 | `TalentAllocation` |
| Player Updates | 2 | TalentAllocations, UnspentTalentPoints |
| Events | 2 | `TalentPointEarnedEvent`, `TalentPointSpentEvent` |
| Unit Tests | ~18 | Point earning, spending, tracking tests |

### Talent Point Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                    TALENT POINT ARCHITECTURE                         │
└─────────────────────────────────────────────────────────────────────┘

                      ┌───────────────────────────┐
                      │      Level Up Event        │
                      └───────────────┬───────────┘
                                      │ OnLevelUp
                                      ▼
                      ┌───────────────────────────┐
                      │    ITalentPointService     │
                      ├───────────────────────────┤
                      │ + GetUnspentPoints()      │
                      │ + GetTotalPointsEarned()  │
                      │ + AwardPoints(count)      │
                      │ + SpendPoint(nodeId)      │
                      │ + GetAllocation(nodeId)   │
                      │ + GetNodeRank(nodeId)     │
                      │ + CanSpendOn(nodeId)      │
                      └───────────────┬───────────┘
                                      │
                      ┌───────────────┴───────────┐
                      │     TalentPointService     │
                      ├───────────────────────────┤
                      │ - _treeProvider           │
                      │ - _prerequisiteValidator  │
                      │                           │
                      │ + CheckHasPoints          │
                      │ + CheckNodeMaxRank        │
                      │ + UpdateAllocation        │
                      └───────────────────────────┘
                               │           │
                               ▼           ▼
                   ┌─────────────────┐  ┌─────────────────┐
                   │     Player      │  │IAbilityTreeProv │
                   │ + Unspent: int  │  │ (get node info) │
                   │ + Allocations[] │  └─────────────────┘
                   └─────────────────┘


    ALLOCATION TRACKING
    ───────────────────

    Player.TalentAllocations:
    ┌─────────────────────────────────────────────────────────┐
    │ NodeId          │ CurrentRank │ MaxRank │ TotalSpent   │
    ├─────────────────┼─────────────┼─────────┼──────────────┤
    │ frenzy          │ 2           │ 3       │ 2            │
    │ shield-wall     │ 3           │ 3       │ 3            │
    │ taunt           │ 1           │ 1       │ 1            │
    │ iron-skin       │ 0           │ 1       │ 0            │
    └─────────────────┴─────────────┴─────────┴──────────────┘

    Total Points Spent: 6
    Unspent Points: 2
```

### ITalentPointService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing talent point allocation.
/// </summary>
public interface ITalentPointService
{
    /// <summary>Gets unspent talent points for a player.</summary>
    int GetUnspentPoints(Player player);
    
    /// <summary>Gets total points earned by a player.</summary>
    int GetTotalPointsEarned(Player player);
    
    /// <summary>Gets total points spent by a player.</summary>
    int GetTotalPointsSpent(Player player);
    
    /// <summary>Awards talent points to a player.</summary>
    /// <param name="player">The player to award points to.</param>
    /// <param name="count">Number of points to award.</param>
    void AwardPoints(Player player, int count);
    
    /// <summary>Spends a point on a tree node.</summary>
    /// <param name="player">The player spending the point.</param>
    /// <param name="nodeId">The node to allocate to.</param>
    /// <returns>Result of the allocation attempt.</returns>
    AllocationResult SpendPoint(Player player, string nodeId);
    
    /// <summary>Gets the current allocation for a node.</summary>
    TalentAllocation? GetAllocation(Player player, string nodeId);
    
    /// <summary>Gets the current rank of a node for a player.</summary>
    int GetNodeRank(Player player, string nodeId);
    
    /// <summary>Checks if a player can spend on a node.</summary>
    bool CanSpendOn(Player player, string nodeId);
    
    /// <summary>Gets all allocations for a player.</summary>
    IReadOnlyList<TalentAllocation> GetAllAllocations(Player player);
    
    /// <summary>Gets allocations for a specific tree.</summary>
    IReadOnlyList<TalentAllocation> GetAllocationsForTree(Player player, string treeId);
}
```

### TalentPointService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class TalentPointService : ITalentPointService
{
    private readonly IAbilityTreeProvider _treeProvider;
    private readonly IPrerequisiteValidator _prerequisiteValidator;
    private readonly IEventBus _eventBus;
    private readonly ILogger<TalentPointService> _logger;
    
    public TalentPointService(
        IAbilityTreeProvider treeProvider,
        IPrerequisiteValidator prerequisiteValidator,
        IEventBus eventBus,
        ILogger<TalentPointService> logger)
    {
        _treeProvider = treeProvider;
        _prerequisiteValidator = prerequisiteValidator;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public int GetUnspentPoints(Player player)
    {
        return player.UnspentTalentPoints;
    }
    
    public int GetTotalPointsEarned(Player player)
    {
        return player.TotalTalentPointsEarned;
    }
    
    public int GetTotalPointsSpent(Player player)
    {
        return player.TalentAllocations.Sum(a => a.CurrentRank * a.PointCostPerRank);
    }
    
    public void AwardPoints(Player player, int count)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(count);
        
        player.AddTalentPoints(count);
        
        _logger.LogInformation("{Player} earned {Count} talent points", player.Name, count);
        _eventBus.Publish(new TalentPointEarnedEvent(player.Id, count, player.UnspentTalentPoints));
    }
    
    public AllocationResult SpendPoint(Player player, string nodeId)
    {
        // Find the node
        var node = _treeProvider.FindNode(nodeId);
        if (node is null)
        {
            return AllocationResult.Failed($"Node not found: {nodeId}");
        }
        
        // Check points available
        if (player.UnspentTalentPoints < node.PointCost)
        {
            return AllocationResult.InsufficientPoints(node.PointCost, player.UnspentTalentPoints);
        }
        
        // Check current rank
        var currentRank = GetNodeRank(player, nodeId);
        if (currentRank >= node.MaxRank)
        {
            return AllocationResult.AtMaxRank(nodeId, node.MaxRank);
        }
        
        // Check prerequisites (delegated to v0.10.1c validator)
        var prereqResult = _prerequisiteValidator.ValidatePrerequisites(player, node);
        if (!prereqResult.IsValid)
        {
            return AllocationResult.PrerequisitesNotMet(prereqResult.FailureReasons);
        }
        
        // Allocate the point
        var allocation = player.TalentAllocations.FirstOrDefault(a => a.NodeId == nodeId);
        if (allocation is null)
        {
            allocation = TalentAllocation.Create(nodeId, node.PointCost);
            player.AddTalentAllocation(allocation);
        }
        else
        {
            allocation.IncrementRank();
        }
        
        player.SpendTalentPoints(node.PointCost);
        
        _logger.LogInformation("{Player} spent {Cost} point(s) on {Node} (rank {Rank}/{Max})",
            player.Name, node.PointCost, nodeId, allocation.CurrentRank, node.MaxRank);
        
        _eventBus.Publish(new TalentPointSpentEvent(player.Id, nodeId, allocation.CurrentRank));
        
        // Grant ability if first rank
        if (allocation.CurrentRank == 1)
        {
            _eventBus.Publish(new AbilityUnlockedEvent(player.Id, node.AbilityId));
        }
        
        return AllocationResult.Success(nodeId, allocation.CurrentRank);
    }
    
    public int GetNodeRank(Player player, string nodeId)
    {
        var allocation = player.TalentAllocations.FirstOrDefault(a => a.NodeId == nodeId);
        return allocation?.CurrentRank ?? 0;
    }
    
    public bool CanSpendOn(Player player, string nodeId)
    {
        var node = _treeProvider.FindNode(nodeId);
        if (node is null) return false;
        
        if (player.UnspentTalentPoints < node.PointCost) return false;
        if (GetNodeRank(player, nodeId) >= node.MaxRank) return false;
        
        var prereqResult = _prerequisiteValidator.ValidatePrerequisites(player, node);
        return prereqResult.IsValid;
    }
}
```

### TalentAllocation Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Tracks a player's allocation into a talent tree node.
/// </summary>
public class TalentAllocation : IEntity
{
    public Guid Id { get; private set; }
    public string NodeId { get; private set; } = null!;
    public int CurrentRank { get; private set; }
    public int PointCostPerRank { get; private set; }
    public DateTime AllocatedAt { get; private set; }
    
    private TalentAllocation() { }
    
    public static TalentAllocation Create(string nodeId, int pointCostPerRank)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(nodeId);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(pointCostPerRank);
        
        return new TalentAllocation
        {
            Id = Guid.NewGuid(),
            NodeId = nodeId.ToLowerInvariant(),
            CurrentRank = 1,
            PointCostPerRank = pointCostPerRank,
            AllocatedAt = DateTime.UtcNow
        };
    }
    
    /// <summary>Increases the rank by one.</summary>
    public void IncrementRank()
    {
        CurrentRank++;
    }
    
    /// <summary>Gets total points spent on this node.</summary>
    public int GetTotalPointsSpent()
    {
        return CurrentRank * PointCostPerRank;
    }
}
```

### AllocationResult Record

```csharp
namespace RuneAndRust.Application.Results;

public record AllocationResult(
    bool IsSuccess,
    AllocationResultType ResultType,
    string? NodeId,
    int? NewRank,
    string? FailureReason)
{
    public static AllocationResult Success(string nodeId, int newRank)
        => new(true, AllocationResultType.Success, nodeId, newRank, null);
    
    public static AllocationResult Failed(string reason)
        => new(false, AllocationResultType.Failed, null, null, reason);
    
    public static AllocationResult InsufficientPoints(int required, int available)
        => new(false, AllocationResultType.InsufficientPoints, null, null, 
            $"Need {required} points, have {available}");
    
    public static AllocationResult AtMaxRank(string nodeId, int maxRank)
        => new(false, AllocationResultType.AtMaxRank, nodeId, maxRank, 
            $"Already at max rank {maxRank}");
    
    public static AllocationResult PrerequisitesNotMet(IEnumerable<string> reasons)
        => new(false, AllocationResultType.PrerequisitesNotMet, null, null, 
            string.Join("; ", reasons));
}

public enum AllocationResultType
{
    Success,
    Failed,
    InsufficientPoints,
    AtMaxRank,
    PrerequisitesNotMet
}
```

### Acceptance Criteria

- [ ] Points awarded on level-up
- [ ] Unspent points tracked
- [ ] SpendPoint allocates to node
- [ ] Cannot spend without points
- [ ] Cannot exceed MaxRank
- [ ] CurrentRank increments correctly
- [ ] TalentAllocation tracked on Player
- [ ] GetNodeRank returns current rank
- [ ] CanSpendOn checks availability
- [ ] GetAllAllocations returns list
- [ ] TalentPointEarnedEvent fires
- [ ] TalentPointSpentEvent fires
- [ ] AbilityUnlockedEvent on first rank
- [ ] ~18 unit tests pass

---

## v0.10.1c: Prerequisites & Respec

[v0.10.1c Design Specification](v0.10.1c-design-specification.md)

### Overview

Implement prerequisite validation for talent nodes and the respec system for reallocating points. Prerequisites can be other nodes that must be unlocked first or stat requirements. The respec system refunds all spent points, allowing players to reallocate.

### Scope

**In Scope:**
- `IPrerequisiteValidator` interface
- `PrerequisiteValidator` implementation
- Node prerequisite checking
- Stat prerequisite checking
- Tier order enforcement
- `IRespecService` interface
- `RespecService` implementation
- Refund all points
- Clear all allocations
- Remove unlocked abilities
- Respec cost (configurable)
- Ability upgrade ranks (enhanced effects at higher ranks)
- Rank-based ability modifications

**Out of Scope:**
- Tree definitions (v0.10.2a)
- Point spending logic (v0.10.2b)
- Partial respec (single branch only, future)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Interfaces | 2 | `IPrerequisiteValidator`, `IRespecService` |
| Services | 2 | `PrerequisiteValidator`, `RespecService` |
| Result Types | 1 | `PrerequisiteResult` |
| Events | 1 | `RespecCompletedEvent` |
| Unit Tests | ~14 | Prerequisite, respec tests |

### Prerequisite & Respec Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                 PREREQUISITE VALIDATION ARCHITECTURE                 │
└─────────────────────────────────────────────────────────────────────┘

                          SpendPoint request
                                 │
                                 ▼
                    ┌───────────────────────────┐
                    │  IPrerequisiteValidator    │
                    ├───────────────────────────┤
                    │ + ValidatePrerequisites   │
                    └───────────────┬───────────┘
                                    │
            ┌───────────────────────┼───────────────────────┐
            ▼                       ▼                       ▼
   [Node Prerequisites]    [Stat Prerequisites]    [Tier Requirements]
            │                       │                       │
            ▼                       ▼                       ▼
   ┌────────────────┐     ┌────────────────┐     ┌────────────────┐
   │ Has "frenzy"   │     │ STR >= 14?     │     │ Tier 1 nodes   │
   │ allocated?     │     │                │     │ unlocked?      │
   └────────────────┘     └────────────────┘     └────────────────┘
            │                       │                       │
            └───────────────────────┴───────────────────────┘
                                    │
                                    ▼
                          PrerequisiteResult
                          (IsValid, Reasons)


    RESPEC FLOW
    ───────────

    Before Respec:                      After Respec:
    ┌─────────────────────────┐        ┌─────────────────────────┐
    │ Player                  │        │ Player                  │
    │ UnspentPoints: 0        │        │ UnspentPoints: 8        │
    │ Allocations:            │ ─────▶ │ Allocations:            │
    │   frenzy: rank 2        │ Respec │   (empty)               │
    │   shield-wall: rank 3   │        │                         │
    │   taunt: rank 1         │        │ Abilities Removed:      │
    │   iron-skin: rank 1     │        │   frenzy, shield-wall,  │
    │ (8 points spent)        │        │   taunt, iron-skin      │
    └─────────────────────────┘        └─────────────────────────┘

    Cost: 100 gold (configurable)
```

### IPrerequisiteValidator Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Validates prerequisites for talent node allocation.
/// </summary>
public interface IPrerequisiteValidator
{
    /// <summary>Validates all prerequisites for a node.</summary>
    /// <param name="player">The player attempting allocation.</param>
    /// <param name="node">The node to validate.</param>
    /// <returns>Validation result.</returns>
    PrerequisiteResult ValidatePrerequisites(Player player, AbilityTreeNode node);
    
    /// <summary>Checks if node prerequisites are met.</summary>
    bool AreNodePrerequisitesMet(Player player, AbilityTreeNode node);
    
    /// <summary>Checks if stat prerequisites are met.</summary>
    bool AreStatPrerequisitesMet(Player player, AbilityTreeNode node);
    
    /// <summary>Gets a list of missing prerequisites.</summary>
    IReadOnlyList<string> GetMissingPrerequisites(Player player, AbilityTreeNode node);
}
```

### PrerequisiteValidator Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class PrerequisiteValidator : IPrerequisiteValidator
{
    private readonly ITalentPointService _talentService;
    private readonly ILogger<PrerequisiteValidator> _logger;
    
    public PrerequisiteValidator(
        ITalentPointService talentService,
        ILogger<PrerequisiteValidator> logger)
    {
        _talentService = talentService;
        _logger = logger;
    }
    
    public PrerequisiteResult ValidatePrerequisites(Player player, AbilityTreeNode node)
    {
        var failureReasons = new List<string>();
        
        // Check node prerequisites
        foreach (var prereqNodeId in node.PrerequisiteNodeIds)
        {
            var prereqRank = _talentService.GetNodeRank(player, prereqNodeId);
            if (prereqRank == 0)
            {
                failureReasons.Add($"Requires {prereqNodeId} to be unlocked");
            }
        }
        
        // Check stat prerequisites
        foreach (var statPrereq in node.StatPrerequisites)
        {
            var statValue = player.GetStatValue(statPrereq.StatId);
            if (statValue < statPrereq.MinValue)
            {
                failureReasons.Add($"Requires {statPrereq.StatId} >= {statPrereq.MinValue} (have {statValue})");
            }
        }
        
        if (failureReasons.Any())
        {
            _logger.LogDebug("Prerequisites not met for {Node}: {Reasons}", 
                node.NodeId, string.Join(", ", failureReasons));
            return PrerequisiteResult.Failed(failureReasons);
        }
        
        return PrerequisiteResult.Valid();
    }
    
    public bool AreNodePrerequisitesMet(Player player, AbilityTreeNode node)
    {
        return node.PrerequisiteNodeIds.All(prereqId => 
            _talentService.GetNodeRank(player, prereqId) > 0);
    }
    
    public bool AreStatPrerequisitesMet(Player player, AbilityTreeNode node)
    {
        return node.StatPrerequisites.All(prereq => 
            player.GetStatValue(prereq.StatId) >= prereq.MinValue);
    }
    
    public IReadOnlyList<string> GetMissingPrerequisites(Player player, AbilityTreeNode node)
    {
        var missing = new List<string>();
        
        foreach (var prereqNodeId in node.PrerequisiteNodeIds)
        {
            if (_talentService.GetNodeRank(player, prereqNodeId) == 0)
            {
                missing.Add(prereqNodeId);
            }
        }
        
        return missing;
    }
}
```

### IRespecService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for respeccing talent allocations.
/// </summary>
public interface IRespecService
{
    /// <summary>Checks if player can afford respec.</summary>
    bool CanAffordRespec(Player player);
    
    /// <summary>Gets the cost to respec.</summary>
    int GetRespecCost(Player player);
    
    /// <summary>Performs a full respec, refunding all points.</summary>
    /// <param name="player">The player to respec.</param>
    /// <returns>Result of the respec.</returns>
    RespecResult Respec(Player player);
    
    /// <summary>Gets number of points that would be refunded.</summary>
    int GetRefundAmount(Player player);
}
```

### RespecService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class RespecService : IRespecService
{
    private readonly IAbilityTreeProvider _treeProvider;
    private readonly IAbilityService _abilityService;
    private readonly IEventBus _eventBus;
    private readonly IRespecConfiguration _config;
    private readonly ILogger<RespecService> _logger;
    
    public RespecService(
        IAbilityTreeProvider treeProvider,
        IAbilityService abilityService,
        IEventBus eventBus,
        IRespecConfiguration config,
        ILogger<RespecService> logger)
    {
        _treeProvider = treeProvider;
        _abilityService = abilityService;
        _eventBus = eventBus;
        _config = config;
        _logger = logger;
    }
    
    public bool CanAffordRespec(Player player)
    {
        return player.Gold >= GetRespecCost(player);
    }
    
    public int GetRespecCost(Player player)
    {
        var baseC = _config.BaseRespecCost;
        var levelMultiplier = _config.LevelMultiplier;
        return baseC + (player.Level * levelMultiplier);
    }
    
    public RespecResult Respec(Player player)
    {
        var cost = GetRespecCost(player);
        
        if (!CanAffordRespec(player))
        {
            return RespecResult.CannotAfford(cost, player.Gold);
        }
        
        if (!player.TalentAllocations.Any())
        {
            return RespecResult.NothingToRespec();
        }
        
        // Calculate refund
        var pointsToRefund = GetRefundAmount(player);
        
        // Collect abilities to remove
        var abilitiesToRemove = player.TalentAllocations
            .Select(a => _treeProvider.FindNode(a.NodeId)?.AbilityId)
            .Where(id => id is not null)
            .Distinct()
            .ToList();
        
        // Clear allocations
        player.ClearAllTalentAllocations();
        
        // Refund points
        player.AddTalentPoints(pointsToRefund);
        
        // Deduct gold
        player.SpendGold(cost);
        
        // Remove abilities granted by talents
        foreach (var abilityId in abilitiesToRemove)
        {
            _abilityService.RemoveAbility(player, abilityId!);
        }
        
        _logger.LogInformation("{Player} respecced: refunded {Points} points, cost {Cost} gold",
            player.Name, pointsToRefund, cost);
        
        _eventBus.Publish(new RespecCompletedEvent(player.Id, pointsToRefund, cost));
        
        return RespecResult.Success(pointsToRefund, cost, abilitiesToRemove.Count);
    }
    
    public int GetRefundAmount(Player player)
    {
        return player.TalentAllocations.Sum(a => a.GetTotalPointsSpent());
    }
}
```

### PrerequisiteResult and RespecResult

```csharp
namespace RuneAndRust.Application.Results;

public record PrerequisiteResult(bool IsValid, IReadOnlyList<string> FailureReasons)
{
    public static PrerequisiteResult Valid()
        => new(true, Array.Empty<string>());
    
    public static PrerequisiteResult Failed(IEnumerable<string> reasons)
        => new(false, reasons.ToList());
}

public record RespecResult(
    bool IsSuccess,
    int PointsRefunded,
    int GoldSpent,
    int AbilitiesRemoved,
    string? FailureReason)
{
    public static RespecResult Success(int points, int gold, int abilities)
        => new(true, points, gold, abilities, null);
    
    public static RespecResult CannotAfford(int cost, int available)
        => new(false, 0, 0, 0, $"Need {cost} gold, have {available}");
    
    public static RespecResult NothingToRespec()
        => new(false, 0, 0, 0, "No talent allocations to reset");
}
```

### Ability Rank Effects

```csharp
// Example: Frenzy ability with rank scaling
// In AbilityService.ExecuteAbility:

public AbilityResult ExecuteAbility(Player player, string abilityId, ICombatant? target)
{
    var ability = _abilityProvider.GetAbility(abilityId);
    var rank = _talentPointService.GetNodeRank(player, GetNodeIdForAbility(abilityId));
    
    // Scale effect based on rank
    var baseValue = ability.BaseValue;
    var scaledValue = baseValue + (ability.ValuePerRank * (rank - 1));
    
    // Example: Frenzy
    // Rank 1: +10% attack speed
    // Rank 2: +15% attack speed
    // Rank 3: +20% attack speed
    
    // Apply the scaled effect...
}
```

### Acceptance Criteria

- [ ] Node prerequisites checked
- [ ] Cannot allocate without prereqs
- [ ] Stat prerequisites checked
- [ ] GetMissingPrerequisites lists missing
- [ ] Respec refunds all points
- [ ] Respec removes abilities
- [ ] Respec costs gold
- [ ] Respec cost scales with level
- [ ] CanAffordRespec checks gold
- [ ] RespecCompletedEvent fires
- [ ] Higher ranks provide enhanced effects
- [ ] Rank scaling is configurable
- [ ] ~14 unit tests pass

---

## Dependencies & Prerequisites

```
v0.10.1c (Environmental Combat) - REQUIRED
    │
    └── Combat Actions complete ──────────────────────────────────────────┐
                                                                          │
v0.10.2 (Ability Trees)                                                   │
    │                                                                     │
    ├── v0.10.2a: Tree Definitions ───────────────────────────────────────┤
    │       Dependencies: Domain, Configuration                           │
    │       Provides: AbilityTreeDefinition, branches, nodes              │
    │                                                                     │
    ├── v0.10.2b: Talent Point Service ───────────────────────────────────┤
    │       Dependencies: v0.10.2a (trees), Player, LevelUpService        │
    │       Provides: ITalentPointService, allocation tracking            │
    │                                                                     │
    └── v0.10.1c: Prerequisites & Respec ─────────────────────────────────┘
            Dependencies: v0.10.2a, v0.10.2b
            Provides: IPrerequisiteValidator, IRespecService
```

---

## Estimated Effort Summary

| Part | New Files | Modified Files | Est. Tests | Complexity |
|------|-----------|----------------|------------|------------|
| v0.10.2a | ~5 | ~1 | ~18 | High |
| v0.10.2b | ~4 | ~2 | ~18 | High |
| v0.10.1c | ~4 | ~2 | ~14 | Medium |
| **Total** | **~13** | **~5** | **~50** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Tree structure complexity | High | Medium | Thorough config validation |
| Prerequisite loops | Medium | Low | Validate no circular deps |
| Respec ability removal | Medium | Low | Track ability sources |
| Rank scaling balance | Medium | Medium | Configurable per ability |

---

## Design Decisions (Confirmed)

### Tree Structure

| Decision | Value | Notes |
|----------|-------|-------|
| **Points Per Level** | 1 | Configurable per tree |
| **Max Tiers** | 3+ | Depends on tree depth |
| **Position** | X, Y integers | For UI layout |

### Point Management

| Decision | Value | Notes |
|----------|-------|-------|
| **Award Timing** | On level-up | Integrated with LevelUpService |
| **Max Ranks** | 1-3 | Per node config |
| **Point Cost** | 1-2 | Higher tiers cost more |

### Respec

| Decision | Value | Notes |
|----------|-------|-------|
| **Cost Type** | Gold | Configurable |
| **Cost Scaling** | Base + (level * mult) | Increases with level |
| **Full Reset** | All points | Partial respec future |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.10.2a Design Spec** - Create detailed design for Tree Definitions
3. **v0.10.2a Implementation** - Build tree structure
4. **v0.10.2b Design Spec** - Create specification for Talent Points
5. **v0.10.2b Implementation** - Build point management
6. **v0.10.1c Design Spec** - Create specification for Prerequisites & Respec
7. **v0.10.1c Implementation** - Build validation and respec

---

*This scope breakdown provides a structured approach to implementing v0.10.2 Ability Trees. The talent tree system provides meaningful long-term progression with specialization branches, prerequisites for advanced abilities, and a respec system for build flexibility.*
