# v0.4.1a Design Specification: Core Trap System

**Version:** 0.4.1a
**Phase Name:** Core Trap System
**Parent Version:** v0.4.1 (Traps & Environmental Hazards)
**Prerequisites:** v0.4.0c Complete (Activation & Destruction)
**Estimated Tests:** ~30 unit tests

---

## 1. Overview

### 1.1 Purpose

Establish the foundational `Trap` entity with state management, trigger type definitions, and Room integration. This phase creates the base infrastructure that subsequent phases will extend with detection mechanics, disarm systems, and trap effects.

### 1.2 Current State

The following infrastructure already exists from prior versions:

| Component | Location | Status |
|-----------|----------|--------|
| `ObjectState` enum | `Domain/Enums/ObjectState.cs` | Complete (20+ states) |
| `InteractiveObject` entity | `Domain/Entities/InteractiveObject.cs` | From v0.4.0a |
| `InteractionService` | `Application/Services/InteractionService.cs` | From v0.4.0a/b/c |
| `DestructibleProperties` | `Domain/ValueObjects/DestructibleProperties.cs` | From v0.4.0c |
| `DiceService` | `Application/Services/DiceService.cs` | Complete |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Complete |
| `Room` entity | `Domain/Entities/Room.cs` | Has Interactables collection |
| `StatusEffectService` | `Application/Services/StatusEffectService.cs` | Complete |
| Perception skill | `Configuration/skills.json` | Complete (uses Wits) |

### 1.3 Scope

**In Scope:**
- `Trap` entity with state tracking and trigger configuration
- `TrapState` enum (Hidden, Detected, Triggered, Disarmed, Broken)
- `TriggerType` enum (Step, Touch, Open, Proximity, Tripwire)
- `TrapDefinition` for JSON configuration
- `TrapTriggerResult` value object for trigger outcomes
- Room.Traps collection and management methods
- `ITrapService` interface definition
- `TrapService` with basic state management
- Trap visibility in room descriptions (detected traps only)
- Configuration schema for trap definitions
- Basic examine integration for detected traps

**Out of Scope:**
- Trap detection dice checks (v0.4.1b)
- Trap disarm mechanics (v0.4.1b)
- Trap effects (damage, status effects, alerts) (v0.4.1b)
- Trapped containers integration (v0.4.1b)
- Automatic trigger on movement/interaction (v0.4.1b)
- Environmental hazards (v0.4.1c)
- Hazard zones (v0.4.1c)
- Dice saves for hazard damage (v0.4.1c)

### 1.4 Design Goals

1. **Foundation First**: Create solid base entity that future phases extend
2. **State Integrity**: All trap state transitions validated and consistent
3. **Hidden by Default**: Traps start hidden and only appear when detected
4. **Trigger Flexibility**: Support multiple trigger mechanisms via enum
5. **Configuration Driven**: Trap definitions loaded from JSON
6. **Testability**: Clean separation enables comprehensive unit testing

---

## 2. Data Model

### 2.1 TrapState Enum (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/TrapState.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the current state of a trap.
/// </summary>
public enum TrapState
{
    /// <summary>
    /// Trap is hidden and has not been detected.
    /// Players cannot see or interact with the trap.
    /// </summary>
    Hidden,

    /// <summary>
    /// Trap has been detected but not yet triggered or disarmed.
    /// Players can see and attempt to disarm the trap.
    /// </summary>
    Detected,

    /// <summary>
    /// Trap has been triggered and its effect has occurred.
    /// Most traps become inert after triggering.
    /// </summary>
    Triggered,

    /// <summary>
    /// Trap has been successfully disarmed.
    /// The trap is safe and cannot trigger.
    /// </summary>
    Disarmed,

    /// <summary>
    /// Trap has been broken or destroyed.
    /// Similar to Disarmed but through force rather than skill.
    /// </summary>
    Broken
}
```

### 2.2 TriggerType Enum (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/TriggerType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines how a trap is triggered.
/// </summary>
public enum TriggerType
{
    /// <summary>
    /// Triggered by stepping on (pressure plates, floor tiles).
    /// Activates when a character enters the trap's location.
    /// </summary>
    Step,

    /// <summary>
    /// Triggered by touching or physically interacting.
    /// Activates when a character touches the trapped object.
    /// </summary>
    Touch,

    /// <summary>
    /// Triggered by opening a container or door.
    /// Activates when the associated object is opened.
    /// </summary>
    Open,

    /// <summary>
    /// Triggered by entering a proximity radius.
    /// Activates when a character gets too close.
    /// </summary>
    Proximity,

    /// <summary>
    /// Triggered by crossing a tripwire line.
    /// Activates when a character crosses the wire's path.
    /// </summary>
    Tripwire
}
```

### 2.3 Trap Entity (NEW)

**File:** `src/Core/RuneAndRust.Domain/Entities/Trap.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents a hidden danger that can be triggered by player actions.
/// </summary>
public class Trap : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this trap instance.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the definition ID from configuration.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name of this trap.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description shown when the trap is examined.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the current state of this trap.
    /// </summary>
    public TrapState State { get; private set; } = TrapState.Hidden;

    /// <summary>
    /// Gets how this trap is triggered.
    /// </summary>
    public TriggerType TriggerType { get; private set; }

    /// <summary>
    /// Gets the difficulty class to detect this trap (Perception check).
    /// </summary>
    public int DetectionDC { get; private set; }

    /// <summary>
    /// Gets the difficulty class to disarm this trap.
    /// </summary>
    public int DisarmDC { get; private set; }

    /// <summary>
    /// Gets whether this trap can be disarmed (some traps can only be avoided).
    /// </summary>
    public bool CanBeDisarmed { get; private set; } = true;

    /// <summary>
    /// Gets whether this trap resets after triggering.
    /// </summary>
    public bool Resets { get; private set; }

    /// <summary>
    /// Gets the number of turns until a reset trap rearms (-1 if not resetting).
    /// </summary>
    public int ResetDelay { get; private set; } = -1;

    /// <summary>
    /// Gets the current turns remaining until reset (-1 if not pending).
    /// </summary>
    public int TurnsUntilReset { get; private set; } = -1;

    /// <summary>
    /// Gets the ID of the object this trap is attached to (for Open triggers).
    /// </summary>
    public string? AttachedObjectId { get; private set; }

    /// <summary>
    /// Gets keywords that can be used to reference this trap when detected.
    /// </summary>
    public IReadOnlyList<string> Keywords { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether this trap is currently visible (detected or triggered).
    /// </summary>
    public bool IsVisible => State != TrapState.Hidden;

    /// <summary>
    /// Gets whether this trap is active and can still trigger.
    /// </summary>
    public bool IsActive => State == TrapState.Hidden || State == TrapState.Detected;

    /// <summary>
    /// Gets whether this trap has been neutralized (disarmed, broken, or triggered without reset).
    /// </summary>
    public bool IsNeutralized => State == TrapState.Disarmed ||
                                  State == TrapState.Broken ||
                                  (State == TrapState.Triggered && !Resets);

    /// <summary>
    /// Gets whether this trap is pending a reset.
    /// </summary>
    public bool IsPendingReset => State == TrapState.Triggered && Resets && TurnsUntilReset >= 0;

    private Trap() { }

    /// <summary>
    /// Creates a new trap instance.
    /// </summary>
    /// <param name="definitionId">The definition ID from configuration.</param>
    /// <param name="name">The display name.</param>
    /// <param name="description">The examination description.</param>
    /// <param name="triggerType">How the trap is triggered.</param>
    /// <param name="detectionDC">Difficulty to detect.</param>
    /// <param name="disarmDC">Difficulty to disarm.</param>
    /// <param name="canBeDisarmed">Whether the trap can be disarmed.</param>
    /// <param name="resets">Whether the trap resets after triggering.</param>
    /// <param name="resetDelay">Turns until reset (if applicable).</param>
    /// <param name="attachedObjectId">ID of attached object (for Open triggers).</param>
    /// <param name="keywords">Keywords for referencing the trap.</param>
    /// <returns>A new Trap instance.</returns>
    public static Trap Create(
        string definitionId,
        string name,
        string description,
        TriggerType triggerType,
        int detectionDC,
        int disarmDC,
        bool canBeDisarmed = true,
        bool resets = false,
        int resetDelay = 3,
        string? attachedObjectId = null,
        IEnumerable<string>? keywords = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(definitionId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new Trap
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId,
            Name = name,
            Description = description,
            TriggerType = triggerType,
            DetectionDC = Math.Max(1, detectionDC),
            DisarmDC = Math.Max(1, disarmDC),
            CanBeDisarmed = canBeDisarmed,
            Resets = resets,
            ResetDelay = resets ? Math.Max(1, resetDelay) : -1,
            AttachedObjectId = attachedObjectId,
            Keywords = keywords?.ToList() ?? new List<string> { name.ToLowerInvariant() }
        };
    }

    /// <summary>
    /// Creates a trap from a definition.
    /// </summary>
    /// <param name="definition">The trap definition.</param>
    /// <returns>A new Trap instance.</returns>
    public static Trap FromDefinition(TrapDefinition definition)
    {
        ArgumentNullException.ThrowIfNull(definition);

        return new Trap
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.Id,
            Name = definition.Name,
            Description = definition.Description,
            TriggerType = definition.TriggerType,
            DetectionDC = definition.DetectionDC,
            DisarmDC = definition.DisarmDC,
            CanBeDisarmed = definition.CanBeDisarmed,
            Resets = definition.Resets,
            ResetDelay = definition.Resets ? definition.ResetDelay : -1,
            AttachedObjectId = definition.AttachedObjectId,
            Keywords = definition.Keywords.ToList()
        };
    }

    /// <summary>
    /// Marks the trap as detected.
    /// </summary>
    /// <returns>True if the state was changed.</returns>
    public bool Detect()
    {
        if (State != TrapState.Hidden)
            return false;

        State = TrapState.Detected;
        return true;
    }

    /// <summary>
    /// Triggers the trap.
    /// </summary>
    /// <returns>True if the trap was triggered.</returns>
    public bool Trigger()
    {
        if (!IsActive)
            return false;

        State = TrapState.Triggered;

        if (Resets)
        {
            TurnsUntilReset = ResetDelay;
        }

        return true;
    }

    /// <summary>
    /// Disarms the trap.
    /// </summary>
    /// <returns>True if the trap was disarmed.</returns>
    public bool Disarm()
    {
        if (!CanBeDisarmed)
            return false;

        if (State != TrapState.Detected)
            return false;

        State = TrapState.Disarmed;
        return true;
    }

    /// <summary>
    /// Breaks/destroys the trap.
    /// </summary>
    /// <returns>True if the trap was broken.</returns>
    public bool Break()
    {
        if (IsNeutralized)
            return false;

        State = TrapState.Broken;
        return true;
    }

    /// <summary>
    /// Processes a turn tick for resetting traps.
    /// </summary>
    /// <returns>True if the trap reset this turn.</returns>
    public bool ProcessTurnTick()
    {
        if (!IsPendingReset)
            return false;

        TurnsUntilReset--;

        if (TurnsUntilReset < 0)
        {
            TurnsUntilReset = -1;
            State = TrapState.Hidden; // Reset to hidden, ready to trigger again
            return true;
        }

        return false;
    }

    /// <summary>
    /// Checks if a keyword matches this trap.
    /// </summary>
    /// <param name="keyword">The keyword to check.</param>
    /// <returns>True if the keyword matches.</returns>
    public bool MatchesKeyword(string keyword)
    {
        return Keywords.Any(k => k.Equals(keyword, StringComparison.OrdinalIgnoreCase)) ||
               Name.Contains(keyword, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets a display string for the trap's current state.
    /// </summary>
    /// <returns>A human-readable state description.</returns>
    public string GetStateDescription()
    {
        return State switch
        {
            TrapState.Hidden => "hidden",
            TrapState.Detected => "detected",
            TrapState.Triggered => Resets ? "triggered (resetting)" : "triggered",
            TrapState.Disarmed => "disarmed",
            TrapState.Broken => "broken",
            _ => "unknown"
        };
    }
}
```

### 2.4 TrapDefinition (NEW)

**File:** `src/Core/RuneAndRust.Domain/Definitions/TrapDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Configuration definition for a trap type.
/// </summary>
public class TrapDefinition
{
    /// <summary>
    /// Gets or sets the unique identifier for this definition.
    /// </summary>
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the display name of traps created from this definition.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the description shown when examining the trap.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets how this trap is triggered.
    /// </summary>
    public TriggerType TriggerType { get; set; }

    /// <summary>
    /// Gets or sets the difficulty class to detect this trap.
    /// </summary>
    public int DetectionDC { get; set; } = 10;

    /// <summary>
    /// Gets or sets the difficulty class to disarm this trap.
    /// </summary>
    public int DisarmDC { get; set; } = 12;

    /// <summary>
    /// Gets or sets whether this trap can be disarmed.
    /// </summary>
    public bool CanBeDisarmed { get; set; } = true;

    /// <summary>
    /// Gets or sets whether this trap resets after triggering.
    /// </summary>
    public bool Resets { get; set; }

    /// <summary>
    /// Gets or sets the turns until the trap resets.
    /// </summary>
    public int ResetDelay { get; set; } = 3;

    /// <summary>
    /// Gets or sets the ID of an object this trap is attached to.
    /// </summary>
    public string? AttachedObjectId { get; set; }

    /// <summary>
    /// Gets or sets keywords for referencing this trap.
    /// </summary>
    public List<string> Keywords { get; set; } = new();

    /// <summary>
    /// Gets or sets the effect configuration (processed in v0.4.1b).
    /// </summary>
    public TrapEffectDefinition? Effect { get; set; }
}

/// <summary>
/// Configuration for trap effects (placeholder for v0.4.1b).
/// </summary>
public class TrapEffectDefinition
{
    /// <summary>
    /// Gets or sets the damage dice expression (e.g., "2d6").
    /// </summary>
    public string? DamageDice { get; set; }

    /// <summary>
    /// Gets or sets the damage type (e.g., "piercing", "fire").
    /// </summary>
    public string? DamageType { get; set; }

    /// <summary>
    /// Gets or sets status effects applied by the trap.
    /// </summary>
    public List<string> StatusEffects { get; set; } = new();

    /// <summary>
    /// Gets or sets the save DC to reduce/avoid damage.
    /// </summary>
    public int? SaveDC { get; set; }

    /// <summary>
    /// Gets or sets the save type (e.g., "Agility", "Fortitude").
    /// </summary>
    public string? SaveType { get; set; }

    /// <summary>
    /// Gets or sets a message displayed when the trap triggers.
    /// </summary>
    public string? TriggerMessage { get; set; }
}
```

### 2.5 TrapTriggerResult Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapTriggerResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the result of a trap trigger event.
/// </summary>
public readonly record struct TrapTriggerResult
{
    /// <summary>
    /// Gets whether the trap was triggered.
    /// </summary>
    public bool Triggered { get; init; }

    /// <summary>
    /// Gets the message to display to the player.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the trap that was triggered.
    /// </summary>
    public string TrapName { get; init; }

    /// <summary>
    /// Gets the trigger type that caused the activation.
    /// </summary>
    public TriggerType TriggerType { get; init; }

    /// <summary>
    /// Gets whether the trap will reset.
    /// </summary>
    public bool WillReset { get; init; }

    /// <summary>
    /// Creates a successful trigger result.
    /// </summary>
    /// <param name="trapName">The name of the triggered trap.</param>
    /// <param name="message">The message to display.</param>
    /// <param name="triggerType">The trigger type.</param>
    /// <param name="willReset">Whether the trap will reset.</param>
    /// <returns>A new TrapTriggerResult.</returns>
    public static TrapTriggerResult Success(
        string trapName,
        string message,
        TriggerType triggerType,
        bool willReset = false) => new()
    {
        Triggered = true,
        TrapName = trapName,
        Message = message,
        TriggerType = triggerType,
        WillReset = willReset
    };

    /// <summary>
    /// Creates a result for when no trap was triggered.
    /// </summary>
    /// <returns>A new TrapTriggerResult.</returns>
    public static TrapTriggerResult NoTrigger() => new()
    {
        Triggered = false,
        Message = string.Empty,
        TrapName = string.Empty,
        TriggerType = TriggerType.Step,
        WillReset = false
    };

    /// <summary>
    /// Creates a result for when the trap was already triggered.
    /// </summary>
    /// <param name="trapName">The name of the trap.</param>
    /// <returns>A new TrapTriggerResult.</returns>
    public static TrapTriggerResult AlreadyTriggered(string trapName) => new()
    {
        Triggered = false,
        TrapName = trapName,
        Message = $"The {trapName} has already been triggered.",
        TriggerType = TriggerType.Step,
        WillReset = false
    };

    /// <summary>
    /// Creates a result for when the trap was disarmed.
    /// </summary>
    /// <param name="trapName">The name of the trap.</param>
    /// <returns>A new TrapTriggerResult.</returns>
    public static TrapTriggerResult WasDisarmed(string trapName) => new()
    {
        Triggered = false,
        TrapName = trapName,
        Message = $"The {trapName} has been disarmed.",
        TriggerType = TriggerType.Step,
        WillReset = false
    };
}
```

### 2.6 TrapDetectionResult Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TrapDetectionResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of attempting to detect traps.
/// </summary>
public readonly record struct TrapDetectionResult
{
    /// <summary>
    /// Gets whether any traps were detected.
    /// </summary>
    public bool DetectedAny { get; init; }

    /// <summary>
    /// Gets the message to display to the player.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the names of detected traps.
    /// </summary>
    public IReadOnlyList<string> DetectedTrapNames { get; init; }

    /// <summary>
    /// Gets the number of traps that remain hidden.
    /// </summary>
    public int HiddenCount { get; init; }

    /// <summary>
    /// Creates a result for successful detection.
    /// </summary>
    /// <param name="detectedNames">Names of detected traps.</param>
    /// <param name="message">The message to display.</param>
    /// <param name="hiddenRemaining">Number of traps still hidden.</param>
    /// <returns>A new TrapDetectionResult.</returns>
    public static TrapDetectionResult Detected(
        IEnumerable<string> detectedNames,
        string message,
        int hiddenRemaining = 0) => new()
    {
        DetectedAny = true,
        DetectedTrapNames = detectedNames.ToList(),
        Message = message,
        HiddenCount = hiddenRemaining
    };

    /// <summary>
    /// Creates a result for no traps detected.
    /// </summary>
    /// <param name="message">The message to display.</param>
    /// <param name="hiddenCount">Number of traps that remain hidden.</param>
    /// <returns>A new TrapDetectionResult.</returns>
    public static TrapDetectionResult NoneDetected(string message, int hiddenCount = 0) => new()
    {
        DetectedAny = false,
        DetectedTrapNames = Array.Empty<string>(),
        Message = message,
        HiddenCount = hiddenCount
    };

    /// <summary>
    /// Creates a result for when no hidden traps exist.
    /// </summary>
    /// <returns>A new TrapDetectionResult.</returns>
    public static TrapDetectionResult NoHiddenTraps() => new()
    {
        DetectedAny = false,
        DetectedTrapNames = Array.Empty<string>(),
        Message = "You don't notice any hidden dangers.",
        HiddenCount = 0
    };
}
```

---

## 3. Room Modifications

### 3.1 Room Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

Add the following members:

```csharp
// Add private field
private readonly List<Trap> _traps = new();

// Add public properties

/// <summary>
/// Gets the traps in this room.
/// </summary>
public IReadOnlyList<Trap> Traps => _traps;

/// <summary>
/// Gets whether this room has any traps.
/// </summary>
public bool HasTraps => _traps.Count > 0;

/// <summary>
/// Gets whether this room has any active (untriggered, not disarmed) traps.
/// </summary>
public bool HasActiveTraps => _traps.Any(t => t.IsActive);

/// <summary>
/// Gets whether this room has any hidden traps.
/// </summary>
public bool HasHiddenTraps => _traps.Any(t => t.State == TrapState.Hidden);

// Add methods

/// <summary>
/// Adds a trap to this room.
/// </summary>
/// <param name="trap">The trap to add.</param>
public void AddTrap(Trap trap)
{
    ArgumentNullException.ThrowIfNull(trap);
    _traps.Add(trap);
}

/// <summary>
/// Removes a trap from this room.
/// </summary>
/// <param name="trap">The trap to remove.</param>
/// <returns>True if the trap was removed.</returns>
public bool RemoveTrap(Trap trap)
{
    return _traps.Remove(trap);
}

/// <summary>
/// Gets a trap by keyword (only visible traps).
/// </summary>
/// <param name="keyword">The keyword to search for.</param>
/// <returns>The matching trap, or null if not found.</returns>
public Trap? GetTrapByKeyword(string keyword)
{
    return _traps.FirstOrDefault(t => t.IsVisible && t.MatchesKeyword(keyword));
}

/// <summary>
/// Gets all visible (detected) traps.
/// </summary>
/// <returns>Enumerable of visible traps.</returns>
public IEnumerable<Trap> GetVisibleTraps()
{
    return _traps.Where(t => t.IsVisible);
}

/// <summary>
/// Gets all hidden traps.
/// </summary>
/// <returns>Enumerable of hidden traps.</returns>
public IEnumerable<Trap> GetHiddenTraps()
{
    return _traps.Where(t => t.State == TrapState.Hidden);
}

/// <summary>
/// Gets all active traps (can still trigger).
/// </summary>
/// <returns>Enumerable of active traps.</returns>
public IEnumerable<Trap> GetActiveTraps()
{
    return _traps.Where(t => t.IsActive);
}

/// <summary>
/// Gets traps of a specific trigger type.
/// </summary>
/// <param name="triggerType">The trigger type to filter by.</param>
/// <returns>Enumerable of matching traps.</returns>
public IEnumerable<Trap> GetTrapsByTriggerType(TriggerType triggerType)
{
    return _traps.Where(t => t.TriggerType == triggerType && t.IsActive);
}

/// <summary>
/// Gets a trap attached to a specific object.
/// </summary>
/// <param name="objectId">The object definition ID.</param>
/// <returns>The attached trap, or null if none.</returns>
public Trap? GetTrapAttachedTo(string objectId)
{
    return _traps.FirstOrDefault(t =>
        t.AttachedObjectId != null &&
        t.AttachedObjectId.Equals(objectId, StringComparison.OrdinalIgnoreCase) &&
        t.IsActive);
}
```

---

## 4. Services

### 4.1 ITrapService Interface (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITrapService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing traps and their interactions.
/// </summary>
public interface ITrapService
{
    /// <summary>
    /// Gets a description of visible traps in a room.
    /// </summary>
    /// <param name="room">The room to describe.</param>
    /// <returns>A formatted description of visible traps.</returns>
    string GetRoomTrapsDescription(Room room);

    /// <summary>
    /// Finds a trap by keyword in a room.
    /// </summary>
    /// <param name="room">The room to search.</param>
    /// <param name="keyword">The keyword to search for.</param>
    /// <returns>The matching trap, or null if not found.</returns>
    Trap? FindTrap(Room room, string keyword);

    /// <summary>
    /// Examines a detected trap.
    /// </summary>
    /// <param name="trap">The trap to examine.</param>
    /// <returns>A description of the trap.</returns>
    string ExamineTrap(Trap trap);

    /// <summary>
    /// Marks a trap as detected.
    /// </summary>
    /// <param name="trap">The trap to detect.</param>
    /// <returns>True if the trap was newly detected.</returns>
    bool DetectTrap(Trap trap);

    /// <summary>
    /// Marks a trap as disarmed.
    /// </summary>
    /// <param name="trap">The trap to disarm.</param>
    /// <returns>True if the trap was disarmed.</returns>
    bool DisarmTrap(Trap trap);

    /// <summary>
    /// Triggers a trap manually.
    /// </summary>
    /// <param name="trap">The trap to trigger.</param>
    /// <returns>The result of triggering the trap.</returns>
    TrapTriggerResult TriggerTrap(Trap trap);

    /// <summary>
    /// Checks for step-triggered traps when entering a room.
    /// </summary>
    /// <param name="room">The room being entered.</param>
    /// <returns>The result if a trap was triggered, null otherwise.</returns>
    TrapTriggerResult? CheckStepTraps(Room room);

    /// <summary>
    /// Checks for open-triggered traps when opening an object.
    /// </summary>
    /// <param name="room">The room containing the object.</param>
    /// <param name="objectId">The object being opened.</param>
    /// <returns>The result if a trap was triggered, null otherwise.</returns>
    TrapTriggerResult? CheckOpenTrap(Room room, string objectId);

    /// <summary>
    /// Processes turn ticks for all traps in a room (handles resets).
    /// </summary>
    /// <param name="room">The room to process.</param>
    /// <returns>Messages about reset traps.</returns>
    IEnumerable<string> ProcessRoomTurnTick(Room room);

    /// <summary>
    /// Gets statistics about traps in a room.
    /// </summary>
    /// <param name="room">The room to analyze.</param>
    /// <returns>A summary of trap states.</returns>
    TrapRoomSummary GetRoomTrapSummary(Room room);
}

/// <summary>
/// Summary of trap states in a room.
/// </summary>
public readonly record struct TrapRoomSummary
{
    /// <summary>Gets the total number of traps.</summary>
    public int Total { get; init; }

    /// <summary>Gets the number of hidden traps.</summary>
    public int Hidden { get; init; }

    /// <summary>Gets the number of detected traps.</summary>
    public int Detected { get; init; }

    /// <summary>Gets the number of triggered traps.</summary>
    public int Triggered { get; init; }

    /// <summary>Gets the number of disarmed traps.</summary>
    public int Disarmed { get; init; }

    /// <summary>Gets the number of broken traps.</summary>
    public int Broken { get; init; }
}
```

### 4.2 TrapService Implementation (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/TrapService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using System.Text;

/// <summary>
/// Service for managing traps and their interactions.
/// </summary>
public class TrapService : ITrapService
{
    private readonly ILogger<TrapService> _logger;

    /// <summary>
    /// Creates a new trap service.
    /// </summary>
    /// <param name="logger">The logger instance.</param>
    public TrapService(ILogger<TrapService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public string GetRoomTrapsDescription(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var visibleTraps = room.GetVisibleTraps().ToList();
        if (!visibleTraps.Any())
        {
            return string.Empty;
        }

        var sb = new StringBuilder();
        sb.AppendLine("You notice the following dangers:");

        foreach (var trap in visibleTraps)
        {
            var stateInfo = GetTrapStateDisplay(trap);
            sb.AppendLine($"  {trap.Name}{stateInfo}");
        }

        return sb.ToString().TrimEnd();
    }

    /// <inheritdoc />
    public Trap? FindTrap(Room room, string keyword)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentException.ThrowIfNullOrWhiteSpace(keyword);

        var trap = room.GetTrapByKeyword(keyword);

        if (trap != null)
        {
            _logger.LogDebug("Found trap {TrapName} by keyword '{Keyword}'", trap.Name, keyword);
        }
        else
        {
            _logger.LogDebug("No visible trap found for keyword '{Keyword}'", keyword);
        }

        return trap;
    }

    /// <inheritdoc />
    public string ExamineTrap(Trap trap)
    {
        ArgumentNullException.ThrowIfNull(trap);

        if (!trap.IsVisible)
        {
            return "You don't see any trap there.";
        }

        var sb = new StringBuilder();
        sb.AppendLine(trap.Name);
        sb.AppendLine(trap.Description);
        sb.AppendLine();
        sb.AppendLine($"Status: {trap.GetStateDescription()}");
        sb.AppendLine($"Trigger: {GetTriggerTypeDescription(trap.TriggerType)}");

        if (trap.State == TrapState.Detected)
        {
            if (trap.CanBeDisarmed)
            {
                sb.AppendLine("This trap can be disarmed.");
            }
            else
            {
                sb.AppendLine("This trap cannot be disarmed - it can only be avoided.");
            }
        }

        if (trap.IsPendingReset)
        {
            sb.AppendLine($"The trap is resetting ({trap.TurnsUntilReset} turns remaining).");
        }

        _logger.LogDebug("Examined trap {TrapName}", trap.Name);

        return sb.ToString().TrimEnd();
    }

    /// <inheritdoc />
    public bool DetectTrap(Trap trap)
    {
        ArgumentNullException.ThrowIfNull(trap);

        if (trap.Detect())
        {
            _logger.LogInformation("Trap {TrapName} was detected", trap.Name);
            return true;
        }

        return false;
    }

    /// <inheritdoc />
    public bool DisarmTrap(Trap trap)
    {
        ArgumentNullException.ThrowIfNull(trap);

        if (trap.Disarm())
        {
            _logger.LogInformation("Trap {TrapName} was disarmed", trap.Name);
            return true;
        }

        return false;
    }

    /// <inheritdoc />
    public TrapTriggerResult TriggerTrap(Trap trap)
    {
        ArgumentNullException.ThrowIfNull(trap);

        if (trap.IsNeutralized)
        {
            if (trap.State == TrapState.Disarmed)
            {
                return TrapTriggerResult.WasDisarmed(trap.Name);
            }
            return TrapTriggerResult.AlreadyTriggered(trap.Name);
        }

        if (!trap.IsActive)
        {
            return TrapTriggerResult.AlreadyTriggered(trap.Name);
        }

        trap.Trigger();

        var message = GetTriggerMessage(trap);
        _logger.LogInformation("Trap {TrapName} was triggered", trap.Name);

        return TrapTriggerResult.Success(
            trap.Name,
            message,
            trap.TriggerType,
            trap.Resets);
    }

    /// <inheritdoc />
    public TrapTriggerResult? CheckStepTraps(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var stepTraps = room.GetTrapsByTriggerType(TriggerType.Step).ToList();

        foreach (var trap in stepTraps)
        {
            // In v0.4.1b, this will include detection checks
            // For now, hidden traps trigger automatically
            if (trap.IsActive)
            {
                return TriggerTrap(trap);
            }
        }

        return null;
    }

    /// <inheritdoc />
    public TrapTriggerResult? CheckOpenTrap(Room room, string objectId)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentException.ThrowIfNullOrWhiteSpace(objectId);

        var trap = room.GetTrapAttachedTo(objectId);

        if (trap != null && trap.IsActive)
        {
            return TriggerTrap(trap);
        }

        return null;
    }

    /// <inheritdoc />
    public IEnumerable<string> ProcessRoomTurnTick(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var messages = new List<string>();

        foreach (var trap in room.Traps)
        {
            if (trap.ProcessTurnTick())
            {
                var resetMessage = $"The {trap.Name} resets with a soft click.";
                messages.Add(resetMessage);
                _logger.LogDebug("Trap {TrapName} reset to hidden", trap.Name);
            }
        }

        return messages;
    }

    /// <inheritdoc />
    public TrapRoomSummary GetRoomTrapSummary(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        return new TrapRoomSummary
        {
            Total = room.Traps.Count,
            Hidden = room.Traps.Count(t => t.State == TrapState.Hidden),
            Detected = room.Traps.Count(t => t.State == TrapState.Detected),
            Triggered = room.Traps.Count(t => t.State == TrapState.Triggered),
            Disarmed = room.Traps.Count(t => t.State == TrapState.Disarmed),
            Broken = room.Traps.Count(t => t.State == TrapState.Broken)
        };
    }

    private string GetTrapStateDisplay(Trap trap)
    {
        return trap.State switch
        {
            TrapState.Detected => " [DETECTED]",
            TrapState.Triggered => trap.Resets ? " [TRIGGERED - resetting]" : " [TRIGGERED]",
            TrapState.Disarmed => " [DISARMED]",
            TrapState.Broken => " [BROKEN]",
            _ => string.Empty
        };
    }

    private string GetTriggerTypeDescription(TriggerType type)
    {
        return type switch
        {
            TriggerType.Step => "Pressure plate - triggers when stepped on",
            TriggerType.Touch => "Contact trigger - triggers when touched",
            TriggerType.Open => "Container trap - triggers when opened",
            TriggerType.Proximity => "Motion sensor - triggers when approached",
            TriggerType.Tripwire => "Tripwire - triggers when crossed",
            _ => "Unknown trigger mechanism"
        };
    }

    private string GetTriggerMessage(Trap trap)
    {
        return trap.TriggerType switch
        {
            TriggerType.Step => $"*CLICK* You step on the {trap.Name}!",
            TriggerType.Touch => $"As you touch it, the {trap.Name} activates!",
            TriggerType.Open => $"Opening triggers the {trap.Name}!",
            TriggerType.Proximity => $"The {trap.Name} senses your approach and activates!",
            TriggerType.Tripwire => $"You trip the wire and the {trap.Name} activates!",
            _ => $"The {trap.Name} is triggered!"
        };
    }
}
```

---

## 5. Configuration

### 5.1 Trap Configuration Schema (NEW)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/schemas/traps.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Traps Configuration",
  "description": "Configuration for traps in the game world",
  "type": "object",
  "properties": {
    "traps": {
      "type": "array",
      "description": "List of trap definitions",
      "items": {
        "$ref": "#/definitions/trapDefinition"
      }
    }
  },
  "definitions": {
    "trapDefinition": {
      "type": "object",
      "required": ["id", "name", "triggerType"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for this trap definition"
        },
        "name": {
          "type": "string",
          "description": "Display name of the trap"
        },
        "description": {
          "type": "string",
          "description": "Description shown when examining the trap"
        },
        "triggerType": {
          "type": "string",
          "description": "How the trap is triggered",
          "enum": ["Step", "Touch", "Open", "Proximity", "Tripwire"]
        },
        "detectionDC": {
          "type": "integer",
          "description": "Difficulty class to detect the trap",
          "minimum": 1,
          "default": 10
        },
        "disarmDC": {
          "type": "integer",
          "description": "Difficulty class to disarm the trap",
          "minimum": 1,
          "default": 12
        },
        "canBeDisarmed": {
          "type": "boolean",
          "description": "Whether the trap can be disarmed",
          "default": true
        },
        "resets": {
          "type": "boolean",
          "description": "Whether the trap resets after triggering",
          "default": false
        },
        "resetDelay": {
          "type": "integer",
          "description": "Turns until the trap resets",
          "minimum": 1,
          "default": 3
        },
        "attachedObjectId": {
          "type": "string",
          "description": "ID of object this trap is attached to (for Open triggers)"
        },
        "keywords": {
          "type": "array",
          "description": "Keywords for referencing the trap",
          "items": {
            "type": "string"
          }
        },
        "effect": {
          "$ref": "#/definitions/trapEffect"
        }
      }
    },
    "trapEffect": {
      "type": "object",
      "description": "Effect configuration (processed in v0.4.1b)",
      "properties": {
        "damageDice": {
          "type": "string",
          "description": "Damage dice expression (e.g., '2d6')"
        },
        "damageType": {
          "type": "string",
          "description": "Type of damage (e.g., 'piercing', 'fire')"
        },
        "statusEffects": {
          "type": "array",
          "description": "Status effects applied by the trap",
          "items": {
            "type": "string"
          }
        },
        "saveDC": {
          "type": "integer",
          "description": "Save DC to reduce/avoid damage",
          "minimum": 1
        },
        "saveType": {
          "type": "string",
          "description": "Type of save required"
        },
        "triggerMessage": {
          "type": "string",
          "description": "Custom message when trap triggers"
        }
      }
    }
  }
}
```

### 5.2 Sample Trap Configuration (NEW)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/traps.json`

```json
{
  "$schema": "./schemas/traps.schema.json",
  "traps": [
    {
      "id": "pressure-plate-dart",
      "name": "Dart Trap",
      "description": "A pressure plate connected to a hidden dart launcher in the wall. Stepping on it will trigger a volley of poisoned darts.",
      "triggerType": "Step",
      "detectionDC": 12,
      "disarmDC": 14,
      "canBeDisarmed": true,
      "resets": true,
      "resetDelay": 3,
      "keywords": ["trap", "dart trap", "pressure plate", "plate"],
      "effect": {
        "damageDice": "2d6",
        "damageType": "piercing",
        "statusEffects": ["poisoned"],
        "saveDC": 12,
        "saveType": "Agility",
        "triggerMessage": "Darts shoot from the wall!"
      }
    },
    {
      "id": "pit-trap-basic",
      "name": "Pit Trap",
      "description": "A section of floor that gives way, revealing a deep pit lined with spikes. The cover is cleverly disguised to match the surrounding floor.",
      "triggerType": "Step",
      "detectionDC": 14,
      "disarmDC": 16,
      "canBeDisarmed": true,
      "resets": false,
      "keywords": ["trap", "pit", "pit trap", "floor"],
      "effect": {
        "damageDice": "3d6",
        "damageType": "piercing",
        "saveDC": 14,
        "saveType": "Agility",
        "triggerMessage": "The floor gives way beneath you!"
      }
    },
    {
      "id": "tripwire-alarm",
      "name": "Alarm Tripwire",
      "description": "A nearly invisible wire stretched across the passage. When broken, it triggers a loud alarm bell.",
      "triggerType": "Tripwire",
      "detectionDC": 10,
      "disarmDC": 8,
      "canBeDisarmed": true,
      "resets": false,
      "keywords": ["wire", "tripwire", "alarm"],
      "effect": {
        "triggerMessage": "A loud alarm bell rings throughout the area!"
      }
    },
    {
      "id": "chest-needle-trap",
      "name": "Needle Trap",
      "description": "A small poisoned needle hidden in the lock mechanism. Attempting to open without care will prick your finger.",
      "triggerType": "Open",
      "detectionDC": 14,
      "disarmDC": 12,
      "canBeDisarmed": true,
      "resets": false,
      "attachedObjectId": "trapped-chest",
      "keywords": ["needle", "trap", "needle trap"],
      "effect": {
        "damageDice": "1d4",
        "damageType": "piercing",
        "statusEffects": ["poisoned"],
        "saveDC": 10,
        "saveType": "Fortitude",
        "triggerMessage": "A needle pricks your finger as you open the chest!"
      }
    },
    {
      "id": "proximity-fire",
      "name": "Fire Rune",
      "description": "A glowing magical rune inscribed on the floor. When someone approaches, it erupts in flames.",
      "triggerType": "Proximity",
      "detectionDC": 8,
      "disarmDC": 18,
      "canBeDisarmed": false,
      "resets": true,
      "resetDelay": 5,
      "keywords": ["rune", "fire rune", "glyph"],
      "effect": {
        "damageDice": "3d8",
        "damageType": "fire",
        "saveDC": 14,
        "saveType": "Agility",
        "triggerMessage": "The rune flares and flames erupt around you!"
      }
    },
    {
      "id": "touch-shock",
      "name": "Shocking Handle",
      "description": "An electrified door handle. Touching it without proper protection delivers a painful shock.",
      "triggerType": "Touch",
      "detectionDC": 16,
      "disarmDC": 14,
      "canBeDisarmed": true,
      "resets": true,
      "resetDelay": 2,
      "keywords": ["handle", "shocking handle", "electric"],
      "effect": {
        "damageDice": "2d8",
        "damageType": "lightning",
        "saveDC": 12,
        "saveType": "Fortitude",
        "triggerMessage": "Electricity surges through your body!"
      }
    },
    {
      "id": "swinging-blade",
      "name": "Swinging Blade",
      "description": "A massive blade concealed in the ceiling. When the pressure plate is triggered, it swings down in a deadly arc.",
      "triggerType": "Step",
      "detectionDC": 10,
      "disarmDC": 15,
      "canBeDisarmed": true,
      "resets": true,
      "resetDelay": 2,
      "keywords": ["blade", "swinging blade", "trap"],
      "effect": {
        "damageDice": "4d6",
        "damageType": "slashing",
        "saveDC": 14,
        "saveType": "Agility",
        "triggerMessage": "A massive blade swings down from the ceiling!"
      }
    },
    {
      "id": "gas-trap",
      "name": "Poison Gas Vent",
      "description": "Hidden vents in the walls that release a cloud of toxic gas when the attached container is opened.",
      "triggerType": "Open",
      "detectionDC": 12,
      "disarmDC": 14,
      "canBeDisarmed": true,
      "resets": false,
      "attachedObjectId": "trapped-container",
      "keywords": ["gas", "vent", "poison gas"],
      "effect": {
        "damageDice": "2d6",
        "damageType": "poison",
        "statusEffects": ["poisoned"],
        "saveDC": 13,
        "saveType": "Fortitude",
        "triggerMessage": "Poisonous gas hisses from hidden vents!"
      }
    }
  ]
}
```

---

## 6. Command Integration

### 6.1 Examine Trap Command

The examine command should work with detected traps:

```csharp
// In GameSessionService or CommandProcessor:

private string ProcessExamineCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return "Examine what?";
    }

    var keyword = string.Join(" ", args);

    // Check for traps first (only visible ones)
    var trap = _trapService.FindTrap(currentRoom, keyword);
    if (trap != null)
    {
        return _trapService.ExamineTrap(trap);
    }

    // Fall through to existing examine logic for objects, items, etc.
    // ...
}
```

### 6.2 Room Description Integration

Update room descriptions to include visible traps:

```csharp
// In room description building:

public string GetFullRoomDescription(Room room)
{
    var sb = new StringBuilder();

    // Room name and description
    sb.AppendLine(room.Name);
    sb.AppendLine(room.Description);

    // Interactive objects
    var objectsDesc = _interactionService.GetRoomObjectsDescription(room);
    if (!string.IsNullOrEmpty(objectsDesc))
    {
        sb.AppendLine();
        sb.AppendLine(objectsDesc);
    }

    // Visible traps (NEW)
    var trapsDesc = _trapService.GetRoomTrapsDescription(room);
    if (!string.IsNullOrEmpty(trapsDesc))
    {
        sb.AppendLine();
        sb.AppendLine(trapsDesc);
    }

    // Exits
    // ...

    return sb.ToString();
}
```

---

## 7. User Experience

### 7.1 Room Description with Detected Trap

```
You are in the Ancient Vault. Dust-covered stone walls
surround a chamber that hasn't been disturbed for centuries.

You notice:
  Heavy Iron Door (closed) - blocking north
  Weathered Wooden Chest (closed)

You notice the following dangers:
  Dart Trap [DETECTED]

Exits: south
```

### 7.2 Examining a Trap

```
> examine trap

Dart Trap
A pressure plate connected to a hidden dart launcher in the wall.
Stepping on it will trigger a volley of poisoned darts.

Status: detected
Trigger: Pressure plate - triggers when stepped on
This trap can be disarmed.
```

### 7.3 Trap After Triggering (Resetting)

```
> examine dart trap

Dart Trap
A pressure plate connected to a hidden dart launcher in the wall.
Stepping on it will trigger a volley of poisoned darts.

Status: triggered (resetting)
Trigger: Pressure plate - triggers when stepped on
The trap is resetting (2 turns remaining).
```

### 7.4 Disarmed Trap

```
> examine pit trap

Pit Trap
A section of floor that gives way, revealing a deep pit.
The cover is cleverly disguised to match the surrounding floor.

Status: disarmed
Trigger: Pressure plate - triggers when stepped on
```

---

## 8. Acceptance Criteria

### 8.1 Functional Requirements

- [ ] `TrapState` enum contains all five states (Hidden, Detected, Triggered, Disarmed, Broken)
- [ ] `TriggerType` enum contains all five trigger types
- [ ] `Trap` entity stores all trap configuration and state
- [ ] `Trap.Detect()` transitions from Hidden to Detected
- [ ] `Trap.Trigger()` transitions to Triggered and starts reset timer if applicable
- [ ] `Trap.Disarm()` transitions from Detected to Disarmed
- [ ] `Trap.Break()` transitions to Broken
- [ ] `Trap.ProcessTurnTick()` handles reset countdown
- [ ] `TrapDefinition` supports JSON configuration
- [ ] `Room.Traps` collection manages traps
- [ ] `Room.GetTrapByKeyword()` finds visible traps
- [ ] `Room.GetTrapsByTriggerType()` filters by trigger type
- [ ] `Room.GetTrapAttachedTo()` finds traps on objects
- [ ] `TrapService.GetRoomTrapsDescription()` formats visible traps
- [ ] `TrapService.ExamineTrap()` provides detailed trap info
- [ ] Detected traps appear in room descriptions
- [ ] Examine command works with detected traps
- [ ] Configuration schema validates trap definitions
- [ ] ~30 unit tests pass

### 8.2 Non-Functional Requirements

- [ ] Entity properties are properly encapsulated
- [ ] Services follow DI patterns
- [ ] Logging follows established patterns
- [ ] Configuration is JSON-driven
- [ ] All public methods have XML documentation

---

## 9. Test Specifications

### 9.1 TrapState Enum Tests (~3 tests)

| Test Name | Description |
|-----------|-------------|
| `TrapState_HasAllExpectedValues` | Verify all states exist |
| `TrapState_HiddenIsDefault` | Hidden is first/default value |
| `TrapState_CanCastToInt` | Values can be compared numerically |

### 9.2 TriggerType Enum Tests (~3 tests)

| Test Name | Description |
|-----------|-------------|
| `TriggerType_HasAllExpectedValues` | Verify all types exist |
| `TriggerType_StepIsDefault` | Step is first/default value |
| `TriggerType_CanCastToInt` | Values can be compared numerically |

### 9.3 Trap Entity Tests (~12 tests)

| Test Name | Description |
|-----------|-------------|
| `Create_WithValidParameters_ReturnsTrap` | Valid creation |
| `Create_WithNullDefinitionId_ThrowsException` | Null ID rejected |
| `Create_WithEmptyName_ThrowsException` | Empty name rejected |
| `FromDefinition_CreatesCorrectTrap` | Definition mapping |
| `Detect_WhenHidden_ReturnsTrue` | Detection from hidden |
| `Detect_WhenAlreadyDetected_ReturnsFalse` | Already detected |
| `Trigger_WhenActive_ReturnsTrue` | Successful trigger |
| `Trigger_WhenDisarmed_ReturnsFalse` | Can't trigger disarmed |
| `Disarm_WhenDetected_ReturnsTrue` | Successful disarm |
| `Disarm_WhenHidden_ReturnsFalse` | Can't disarm hidden |
| `ProcessTurnTick_WhenResetting_DecrementsCounter` | Reset countdown |
| `ProcessTurnTick_WhenResetComplete_ReturnsTrue` | Reset completion |

### 9.4 Room Trap Collection Tests (~6 tests)

| Test Name | Description |
|-----------|-------------|
| `AddTrap_AddsTrapToCollection` | Adding traps |
| `RemoveTrap_RemovesTrapFromCollection` | Removing traps |
| `GetTrapByKeyword_FindsVisibleTrap` | Keyword lookup |
| `GetTrapByKeyword_DoesNotFindHidden` | Hidden not found |
| `GetTrapsByTriggerType_FiltersCorrectly` | Type filtering |
| `GetTrapAttachedTo_FindsAttachedTrap` | Attached trap lookup |

### 9.5 TrapService Tests (~8 tests)

| Test Name | Description |
|-----------|-------------|
| `GetRoomTrapsDescription_WithVisibleTraps_ReturnsFormatted` | Description formatting |
| `GetRoomTrapsDescription_WithNoVisibleTraps_ReturnsEmpty` | No visible traps |
| `FindTrap_WithMatchingKeyword_ReturnsTrap` | Finding traps |
| `FindTrap_WithNoMatch_ReturnsNull` | No match handling |
| `ExamineTrap_ReturnsDetailedDescription` | Examination |
| `TriggerTrap_TriggersAndReturnsResult` | Triggering |
| `ProcessRoomTurnTick_ResetsTraps` | Turn tick processing |
| `GetRoomTrapSummary_ReturnsCorrectCounts` | Summary statistics |

### 9.6 Configuration Tests (~4 tests)

| Test Name | Description |
|-----------|-------------|
| `LoadConfiguration_ParsesValidJson` | JSON parsing |
| `LoadConfiguration_CreatesDefinitions` | Definition creation |
| `GetDefinitionById_ReturnsDefinition` | Definition lookup |
| `TrapEffect_ParsesCorrectly` | Effect configuration |

---

## 10. Dependencies

### 10.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| InteractiveObject entity | v0.4.0a | Complete | Pattern reference |
| InteractionService | v0.4.0a/b/c | Complete | Pattern reference |
| ObjectState enum | v0.0.x | Complete | Reference pattern |
| Room entity | v0.4.0a | Modified | Needs Traps collection |
| DiceService | v0.0.x | Complete | For future detection/disarm |
| SkillCheckService | v0.0.x | Complete | For future detection/disarm |
| StatusEffectService | v0.0.x | Complete | For future trap effects |

### 10.2 External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Microsoft.Extensions.Logging | 9.0.x | Logging |
| System.Text.Json | 9.0.x | Configuration parsing |

---

## 11. Files Summary

### 11.1 New Files

| File | Purpose |
|------|---------|
| `Domain/Enums/TrapState.cs` | Trap state enum |
| `Domain/Enums/TriggerType.cs` | Trigger type enum |
| `Domain/Entities/Trap.cs` | Core trap entity |
| `Domain/Definitions/TrapDefinition.cs` | Trap configuration definition |
| `Domain/ValueObjects/TrapTriggerResult.cs` | Trigger result |
| `Domain/ValueObjects/TrapDetectionResult.cs` | Detection result |
| `Application/Interfaces/ITrapService.cs` | Service interface |
| `Application/Services/TrapService.cs` | Service implementation |
| `Configuration/schemas/traps.schema.json` | JSON schema |
| `Configuration/traps.json` | Trap definitions |
| `Tests/TrapStateTests.cs` | State enum tests |
| `Tests/TriggerTypeTests.cs` | Type enum tests |
| `Tests/TrapTests.cs` | Entity tests |
| `Tests/TrapServiceTests.cs` | Service tests |
| `Tests/RoomTrapTests.cs` | Room integration tests |

### 11.2 Modified Files

| File | Changes |
|------|---------|
| `Domain/Entities/Room.cs` | Add Traps collection and methods |
| `Application/Services/GameSessionService.cs` | Integrate trap examination |
| `Infrastructure/DependencyInjection.cs` | Register TrapService |
| `Presentation/GameView.cs` | Display visible traps in room |

---

## 12. Future Considerations

### 12.1 v0.4.1b Preparation

The following will extend this foundation:
- Trap detection via Perception skill checks
- Trap disarm via skill checks
- Trap effects (damage, status effects, alerts)
- Trapped containers integration
- Automatic trigger on movement/interaction
- Search command for active detection

### 12.2 v0.4.1c Preparation

The following will be built in the final phase:
- HazardZone entity for area effects
- HazardDefinition for persistent dangers
- Ongoing damage/effects per turn
- Dice saves to reduce/avoid damage
- Environmental hazard types (fire, poison gas, ice, spikes)

### 12.3 Integration Points

- **Perception Skill**: Detection checks will use existing SkillCheckService
- **Combat System**: Trap damage will use existing damage system
- **Status Effects**: Trap effects will integrate with StatusEffectService
- **Container System**: Trapped containers will use Open trigger type

---

*This design specification establishes the foundational trap system, enabling hidden dangers with multiple trigger mechanisms that subsequent phases will extend with detection mechanics, disarm systems, effects, and environmental hazards.*
