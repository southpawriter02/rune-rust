# v0.10.3c Design Specification: Zone Control

**Version:** 0.10.3c
**Parent:** v0.10.3 (Combo System)
**Prerequisites:** v0.10.3b Complete (Combo Detection)
**Status:** Design Complete
**Estimated Unit Tests:** ~11

---

## 1. Overview

### Purpose

Implement zone control abilities that create persistent area effects on the combat grid. Zones can deal damage, apply healing, inflict buffs/debuffs, or modify terrain. Zones tick each turn, affect entities within their area based on friendly/enemy targeting, and expire after their configured duration.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Entities** | `ZoneEffect`, `ZoneDefinition` |
| **Enums** | `ZoneEffectType`, `ZoneShape` |
| **Interfaces** | `IZoneEffectService`, `IZoneProvider` |
| **Services** | `ZoneEffectService`, `ZoneProvider` |
| **DTOs** | `ZoneTickResult` |
| **Events** | `ZoneCreatedEvent`, `ZoneExpiredEvent`, `ZoneDamageEvent`, `ZoneHealEvent` |
| **Configuration** | `zones.json` |
| **Tests** | ~11 unit tests |

---

## 2. Feature Overview

```
v0.10.3c Features
â”œâ”€â”€ ZoneEffect Entity
â”‚   â”œâ”€â”€ ZoneId, Name
â”‚   â”œâ”€â”€ EffectType (Damage, Healing, Buff, Debuff, Terrain, Mixed)
â”‚   â”œâ”€â”€ Shape, Center, Radius
â”‚   â”œâ”€â”€ RemainingDuration
â”‚   â”œâ”€â”€ CasterId
â”‚   â”œâ”€â”€ DamageValue, DamageType
â”‚   â”œâ”€â”€ HealValue
â”‚   â”œâ”€â”€ StatusEffectId
â”‚   â”œâ”€â”€ AffectsFriendly, AffectsEnemy
â”‚   â”œâ”€â”€ AffectedCells
â”‚   â”œâ”€â”€ Tick()
â”‚   â””â”€â”€ ContainsPosition()
â”‚
â”œâ”€â”€ ZoneDefinition Entity
â”‚   â”œâ”€â”€ ZoneId, Name, Description
â”‚   â”œâ”€â”€ EffectType, Shape, Radius
â”‚   â”œâ”€â”€ Duration
â”‚   â”œâ”€â”€ DamageValue, DamageType
â”‚   â”œâ”€â”€ HealValue, StatusEffectId
â”‚   â””â”€â”€ AffectsFriendly, AffectsEnemy
â”‚
â”œâ”€â”€ ZoneShape Enum
â”‚   â”œâ”€â”€ Circle
â”‚   â”œâ”€â”€ Square
â”‚   â”œâ”€â”€ Line
â”‚   â”œâ”€â”€ Cone
â”‚   â””â”€â”€ Ring
â”‚
â”œâ”€â”€ ZoneEffectType Enum
â”‚   â”œâ”€â”€ Damage
â”‚   â”œâ”€â”€ Healing
â”‚   â”œâ”€â”€ Buff
â”‚   â”œâ”€â”€ Debuff
â”‚   â”œâ”€â”€ Terrain
â”‚   â””â”€â”€ Mixed
â”‚
â”œâ”€â”€ IZoneEffectService Interface
â”‚   â”œâ”€â”€ CreateZone(zoneId, center, caster)
â”‚   â”œâ”€â”€ RemoveZone(zoneEffectId)
â”‚   â”œâ”€â”€ GetZonesAt(position)
â”‚   â”œâ”€â”€ GetAllActiveZones()
â”‚   â”œâ”€â”€ GetZonesByCaster(casterId)
â”‚   â”œâ”€â”€ TickZones(combatants)
â”‚   â”œâ”€â”€ OnEntityEntered(entity, position)
â”‚   â””â”€â”€ OnEntityExited(entity, position)
â”‚
â”œâ”€â”€ ZoneEffectService Implementation
â”‚   â”œâ”€â”€ Create zone from definition
â”‚   â”œâ”€â”€ Calculate affected cells by shape
â”‚   â”œâ”€â”€ Tick zones and apply effects
â”‚   â”œâ”€â”€ Handle zone expiration
â”‚   â””â”€â”€ Track entity enter/exit
â”‚
â””â”€â”€ Configuration (zones.json)
    â”œâ”€â”€ Wall of Fire (Damage)
    â”œâ”€â”€ Healing Circle (Healing)
    â”œâ”€â”€ Slow Field (Debuff)
    â”œâ”€â”€ Web (Terrain)
    â””â”€â”€ Consecration (Mixed)
```

---

## 3. Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ZONE CONTROL ARCHITECTURE                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      Ability Service       â”‚
                      â”‚   (Zone-creating ability)  â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚ CreateZone
                                      â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚     IZoneEffectService     â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ + CreateZone(def, pos)    â”‚
                      â”‚ + TickZones()             â”‚
                      â”‚ + GetZonesAt(position)    â”‚
                      â”‚ + RemoveZone(zoneId)      â”‚
                      â”‚ + GetAllActiveZones()     â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚      ZoneEffectService     â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ - _activeZones: List      â”‚
                      â”‚ - _grid                   â”‚
                      â”‚                           â”‚
                      â”‚ + CalculateAffectedCells  â”‚
                      â”‚ + ApplyZoneEffect         â”‚
                      â”‚ + CheckForEntities        â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


    ZONE TYPES
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    WALL OF FIRE (Damage)              HEALING CIRCLE (Healing)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”             â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚ğŸ”¥ â”‚ğŸ”¥ â”‚ğŸ”¥ â”‚ğŸ”¥ â”‚             â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤             â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚             â”‚   â”‚ âœš â”‚ âœš â”‚ âœš â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜             â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
                                       â”‚   â”‚ âœš â”‚ âœš â”‚ âœš â”‚   â”‚
    Deals 2d6 fire/turn               â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    Duration: 5 turns                  
                                       Heals 1d6+2/turn
                                       Duration: 3 turns


    SLOW FIELD (Debuff)                WEB (Terrain)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”             â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚ ğŸŒâ”‚ ğŸŒâ”‚ ğŸŒâ”‚   â”‚             â”‚   â”‚ ğŸ•¸â”‚ ğŸ•¸â”‚ ğŸ•¸â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤             â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚ ğŸŒâ”‚ ğŸŒâ”‚ ğŸŒâ”‚   â”‚             â”‚   â”‚ ğŸ•¸â”‚ ğŸ•¸â”‚ ğŸ•¸â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜             â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    
    -50% movement speed               Difficult terrain
    Duration: 4 turns                  + Entangled status
                                       Duration: 6 turns
```

---

## 4. ZoneDefinition Entity

**File:** `src/Core/RuneAndRust.Domain/Definitions/ZoneDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a zone effect template loaded from configuration.
/// </summary>
public class ZoneDefinition : IEntity
{
    public Guid Id { get; private set; }

    /// <summary>Unique identifier for the zone type.</summary>
    public string ZoneId { get; private set; } = null!;

    /// <summary>Display name.</summary>
    public string Name { get; private set; } = null!;

    /// <summary>Description of the zone.</summary>
    public string Description { get; private set; } = null!;

    /// <summary>Type of effect the zone applies.</summary>
    public ZoneEffectType EffectType { get; private set; }

    /// <summary>Shape of the zone.</summary>
    public ZoneShape Shape { get; private set; }

    /// <summary>Radius of the zone in cells.</summary>
    public int Radius { get; private set; }

    /// <summary>Duration in turns.</summary>
    public int Duration { get; private set; }

    /// <summary>Damage dice notation (for Damage/Mixed types).</summary>
    public string? DamageValue { get; private set; }

    /// <summary>Damage type (fire, cold, etc.).</summary>
    public string? DamageType { get; private set; }

    /// <summary>Healing dice notation (for Healing/Mixed types).</summary>
    public string? HealValue { get; private set; }

    /// <summary>Status effect ID to apply (for Buff/Debuff/Terrain types).</summary>
    public string? StatusEffectId { get; private set; }

    /// <summary>Terrain modifier for Terrain type.</summary>
    public string? TerrainModifier { get; private set; }

    /// <summary>Whether this zone affects friendly entities.</summary>
    public bool AffectsFriendly { get; private set; }

    /// <summary>Whether this zone affects enemy entities.</summary>
    public bool AffectsEnemy { get; private set; }

    /// <summary>Monster types affected (for type-specific zones like Consecration).</summary>
    public IReadOnlyList<string> MonsterTypes { get; private set; } = [];

    /// <summary>Icon path.</summary>
    public string? IconPath { get; private set; }

    // EF Core constructor
    private ZoneDefinition() { }

    public static ZoneDefinition Create(
        string zoneId,
        string name,
        string description,
        ZoneEffectType effectType,
        ZoneShape shape,
        int radius,
        int duration,
        bool affectsFriendly,
        bool affectsEnemy)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(zoneId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(radius);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(duration);

        return new ZoneDefinition
        {
            Id = Guid.NewGuid(),
            ZoneId = zoneId.ToLowerInvariant(),
            Name = name,
            Description = description,
            EffectType = effectType,
            Shape = shape,
            Radius = radius,
            Duration = duration,
            AffectsFriendly = affectsFriendly,
            AffectsEnemy = affectsEnemy
        };
    }

    public override string ToString() => $"{Name} ({ZoneId}): {Shape} r{Radius}";
}
```

---

## 5. ZoneEffect Entity

**File:** `src/Core/RuneAndRust.Domain/Entities/ZoneEffect.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// A persistent area effect on the combat grid.
/// </summary>
public class ZoneEffect : IEntity
{
    public Guid Id { get; private set; }

    /// <summary>The zone definition ID.</summary>
    public string ZoneId { get; private set; } = null!;

    /// <summary>Display name.</summary>
    public string Name { get; private set; } = null!;

    /// <summary>Type of effect.</summary>
    public ZoneEffectType EffectType { get; private set; }

    /// <summary>Shape of the zone.</summary>
    public ZoneShape Shape { get; private set; }

    /// <summary>Center position of the zone.</summary>
    public GridPosition Center { get; private set; }

    /// <summary>Radius of the zone.</summary>
    public int Radius { get; private set; }

    /// <summary>Remaining turns until expiration.</summary>
    public int RemainingDuration { get; private set; }

    /// <summary>ID of the entity that created this zone.</summary>
    public Guid CasterId { get; private set; }

    /// <summary>Damage dice notation.</summary>
    public string? DamageValue { get; private set; }

    /// <summary>Damage type.</summary>
    public string? DamageType { get; private set; }

    /// <summary>Heal dice notation.</summary>
    public string? HealValue { get; private set; }

    /// <summary>Status effect to apply.</summary>
    public string? StatusEffectId { get; private set; }

    /// <summary>Terrain modifier.</summary>
    public string? TerrainModifier { get; private set; }

    /// <summary>Whether this zone affects friendly entities.</summary>
    public bool AffectsFriendly { get; private set; }

    /// <summary>Whether this zone affects enemy entities.</summary>
    public bool AffectsEnemy { get; private set; }

    /// <summary>All grid cells affected by this zone.</summary>
    public IReadOnlyList<GridPosition> AffectedCells { get; private set; } = [];

    /// <summary>When the zone was created.</summary>
    public DateTime CreatedAt { get; private set; }

    // EF Core constructor
    private ZoneEffect() { }

    /// <summary>Creates a zone effect from a definition.</summary>
    public static ZoneEffect Create(
        ZoneDefinition definition,
        GridPosition center,
        Guid casterId,
        IEnumerable<GridPosition> affectedCells)
    {
        return new ZoneEffect
        {
            Id = Guid.NewGuid(),
            ZoneId = definition.ZoneId,
            Name = definition.Name,
            EffectType = definition.EffectType,
            Shape = definition.Shape,
            Center = center,
            Radius = definition.Radius,
            RemainingDuration = definition.Duration,
            CasterId = casterId,
            DamageValue = definition.DamageValue,
            DamageType = definition.DamageType,
            HealValue = definition.HealValue,
            StatusEffectId = definition.StatusEffectId,
            TerrainModifier = definition.TerrainModifier,
            AffectsFriendly = definition.AffectsFriendly,
            AffectsEnemy = definition.AffectsEnemy,
            AffectedCells = affectedCells.ToList(),
            CreatedAt = DateTime.UtcNow
        };
    }

    /// <summary>Decrements duration, returns true if expired.</summary>
    public bool Tick()
    {
        RemainingDuration--;
        return RemainingDuration <= 0;
    }

    /// <summary>Checks if a position is within this zone.</summary>
    public bool ContainsPosition(GridPosition position)
    {
        return AffectedCells.Contains(position);
    }

    /// <summary>Gets the count of affected cells.</summary>
    public int GetCellCount() => AffectedCells.Count;

    /// <summary>Whether this zone is expired.</summary>
    public bool IsExpired => RemainingDuration <= 0;

    public override string ToString() => $"{Name} at {Center} ({RemainingDuration} turns left)";
}
```

---

## 6. Zone Enums

**File:** `src/Core/RuneAndRust.Domain/Enums/ZoneEffectType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of zone effects.
/// </summary>
public enum ZoneEffectType
{
    /// <summary>Deals damage each turn.</summary>
    Damage,

    /// <summary>Heals each turn.</summary>
    Healing,

    /// <summary>Applies a buff while in zone.</summary>
    Buff,

    /// <summary>Applies a debuff while in zone.</summary>
    Debuff,

    /// <summary>Modifies terrain (difficult, blocking).</summary>
    Terrain,

    /// <summary>Multiple effect types combined.</summary>
    Mixed
}
```

**File:** `src/Core/RuneAndRust.Domain/Enums/ZoneShape.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Shapes for zone effects.
/// </summary>
public enum ZoneShape
{
    /// <summary>Circular area from center.</summary>
    Circle,

    /// <summary>Square area from center.</summary>
    Square,

    /// <summary>Line extending from center.</summary>
    Line,

    /// <summary>Cone shape from center in a direction.</summary>
    Cone,

    /// <summary>Ring around center (hollow circle).</summary>
    Ring
}
```

---

## 7. IZoneProvider Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IZoneProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides zone definitions from configuration.
/// </summary>
public interface IZoneProvider
{
    /// <summary>Gets a zone definition by ID.</summary>
    ZoneDefinition? GetZone(string zoneId);

    /// <summary>Gets all zone definitions.</summary>
    IReadOnlyList<ZoneDefinition> GetAllZones();

    /// <summary>Gets zones by effect type.</summary>
    IReadOnlyList<ZoneDefinition> GetZonesByType(ZoneEffectType effectType);
}
```

---

## 8. IZoneEffectService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IZoneEffectService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing persistent zone effects.
/// </summary>
public interface IZoneEffectService
{
    /// <summary>Creates a new zone effect.</summary>
    /// <param name="zoneId">The zone definition ID.</param>
    /// <param name="center">Center position of the zone.</param>
    /// <param name="caster">The entity creating the zone.</param>
    /// <returns>The created zone effect.</returns>
    ZoneEffect CreateZone(string zoneId, GridPosition center, ICombatant caster);

    /// <summary>Creates a zone with a custom direction (for Line/Cone shapes).</summary>
    ZoneEffect CreateZone(string zoneId, GridPosition center, Direction direction, ICombatant caster);

    /// <summary>Removes a zone by ID.</summary>
    bool RemoveZone(Guid zoneEffectId);

    /// <summary>Gets all zones affecting a position.</summary>
    IReadOnlyList<ZoneEffect> GetZonesAt(GridPosition position);

    /// <summary>Gets all active zones.</summary>
    IReadOnlyList<ZoneEffect> GetAllActiveZones();

    /// <summary>Gets zones created by a specific caster.</summary>
    IReadOnlyList<ZoneEffect> GetZonesByCaster(Guid casterId);

    /// <summary>Gets total active zone count.</summary>
    int GetActiveZoneCount();

    /// <summary>Ticks all zones and applies effects to entities within.</summary>
    ZoneTickResult TickZones(IEnumerable<ICombatant> combatants);

    /// <summary>Called when an entity enters a zone position.</summary>
    void OnEntityEntered(ICombatant entity, GridPosition position);

    /// <summary>Called when an entity exits a zone position.</summary>
    void OnEntityExited(ICombatant entity, GridPosition position);

    /// <summary>Clears all zones (e.g., combat end).</summary>
    void ClearAllZones();
}
```

---

## 9. ZoneEffectService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/ZoneEffectService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class ZoneEffectService : IZoneEffectService
{
    private readonly IZoneProvider _zoneProvider;
    private readonly ICombatGrid _grid;
    private readonly IDamageService _damageService;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IDiceService _diceService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<ZoneEffectService> _logger;

    private readonly List<ZoneEffect> _activeZones = new();
    private readonly int _maxZonesPerCaster = 10;

    public ZoneEffectService(
        IZoneProvider zoneProvider,
        ICombatGrid grid,
        IDamageService damageService,
        IBuffDebuffService buffDebuffService,
        IDiceService diceService,
        IEventBus eventBus,
        ILogger<ZoneEffectService> logger)
    {
        _zoneProvider = zoneProvider;
        _grid = grid;
        _damageService = damageService;
        _buffDebuffService = buffDebuffService;
        _diceService = diceService;
        _eventBus = eventBus;
        _logger = logger;
    }

    public ZoneEffect CreateZone(string zoneId, GridPosition center, ICombatant caster)
    {
        return CreateZone(zoneId, center, Direction.North, caster);
    }

    public ZoneEffect CreateZone(string zoneId, GridPosition center, Direction direction, ICombatant caster)
    {
        var definition = _zoneProvider.GetZone(zoneId);
        if (definition is null)
        {
            throw new ArgumentException($"Zone definition not found: {zoneId}");
        }

        // Check caster zone limit
        var casterZones = GetZonesByCaster(caster.Id);
        if (casterZones.Count >= _maxZonesPerCaster)
        {
            _logger.LogWarning("{Caster} at max zone limit ({Max}), removing oldest",
                caster.Name, _maxZonesPerCaster);
            RemoveZone(casterZones.First().Id);
        }

        var affectedCells = CalculateAffectedCells(center, definition.Shape, definition.Radius, direction);
        var zone = ZoneEffect.Create(definition, center, caster.Id, affectedCells);

        _activeZones.Add(zone);

        _logger.LogInformation("{Caster} created zone {Zone} at {Position} ({Cells} cells)",
            caster.Name, zone.Name, center, zone.GetCellCount());

        _eventBus.Publish(new ZoneCreatedEvent(zone.Id, zone.ZoneId, zone.Name, center, caster.Id));

        return zone;
    }

    public ZoneTickResult TickZones(IEnumerable<ICombatant> combatants)
    {
        var result = new ZoneTickResult();
        var combatantList = combatants.ToList();
        var zonesToRemove = new List<ZoneEffect>();

        foreach (var zone in _activeZones)
        {
            // Find entities in this zone
            foreach (var combatant in combatantList)
            {
                if (!zone.ContainsPosition(combatant.Position))
                    continue;

                // Check if this zone affects this combatant
                var isFriendly = IsFriendlyToCaster(combatant, zone.CasterId, combatantList);

                if (isFriendly && !zone.AffectsFriendly) continue;
                if (!isFriendly && !zone.AffectsEnemy) continue;

                // Apply zone effect
                ApplyZoneEffect(zone, combatant, result);
            }

            // Tick duration
            if (zone.Tick())
            {
                zonesToRemove.Add(zone);
                result.ExpiredZones.Add(zone.ZoneId);
            }
        }

        // Remove expired zones
        foreach (var zone in zonesToRemove)
        {
            _activeZones.Remove(zone);
            _logger.LogDebug("Zone {Zone} expired", zone.Name);
            _eventBus.Publish(new ZoneExpiredEvent(zone.Id, zone.ZoneId, zone.Name));
        }

        return result;
    }

    private bool IsFriendlyToCaster(ICombatant combatant, Guid casterId, List<ICombatant> allCombatants)
    {
        if (combatant.Id == casterId) return true;

        var caster = allCombatants.FirstOrDefault(c => c.Id == casterId);
        if (caster is null) return false;

        return combatant.TeamId == caster.TeamId;
    }

    private void ApplyZoneEffect(ZoneEffect zone, ICombatant target, ZoneTickResult result)
    {
        switch (zone.EffectType)
        {
            case ZoneEffectType.Damage:
                ApplyDamageEffect(zone, target, result);
                break;

            case ZoneEffectType.Healing:
                ApplyHealingEffect(zone, target, result);
                break;

            case ZoneEffectType.Buff:
            case ZoneEffectType.Debuff:
                ApplyStatusEffect(zone, target);
                break;

            case ZoneEffectType.Terrain:
                ApplyTerrainEffect(zone, target);
                break;

            case ZoneEffectType.Mixed:
                // Apply all applicable effects
                if (zone.DamageValue is not null)
                    ApplyDamageEffect(zone, target, result);
                if (zone.HealValue is not null)
                    ApplyHealingEffect(zone, target, result);
                if (zone.StatusEffectId is not null)
                    ApplyStatusEffect(zone, target);
                break;
        }
    }

    private void ApplyDamageEffect(ZoneEffect zone, ICombatant target, ZoneTickResult result)
    {
        if (zone.DamageValue is null) return;

        var damage = _diceService.Roll(zone.DamageValue);
        _damageService.ApplyDamage(target, new DamageInstance(damage, zone.DamageType ?? "magic"));
        result.DamageDealt += damage;
        result.EntitiesDamaged.Add(target.Id);

        _logger.LogDebug("{Zone} dealt {Damage} {Type} damage to {Target}",
            zone.Name, damage, zone.DamageType ?? "magic", target.Name);

        _eventBus.Publish(new ZoneDamageEvent(zone.Id, target.Id, damage, zone.DamageType ?? "magic"));
    }

    private void ApplyHealingEffect(ZoneEffect zone, ICombatant target, ZoneTickResult result)
    {
        if (zone.HealValue is null) return;

        var heal = _diceService.Roll(zone.HealValue);
        target.Heal(heal);
        result.HealingDone += heal;
        result.EntitiesHealed.Add(target.Id);

        _logger.LogDebug("{Zone} healed {Target} for {Amount}",
            zone.Name, target.Name, heal);

        _eventBus.Publish(new ZoneHealEvent(zone.Id, target.Id, heal));
    }

    private void ApplyStatusEffect(ZoneEffect zone, ICombatant target)
    {
        if (zone.StatusEffectId is null) return;

        _buffDebuffService.ApplyEffect(target, zone.StatusEffectId);
        _logger.LogDebug("{Zone} applied {Status} to {Target}",
            zone.Name, zone.StatusEffectId, target.Name);
    }

    private void ApplyTerrainEffect(ZoneEffect zone, ICombatant target)
    {
        // Apply immobilize/slow via status effect
        if (zone.StatusEffectId is not null)
        {
            _buffDebuffService.ApplyEffect(target, zone.StatusEffectId);
        }
    }

    private IReadOnlyList<GridPosition> CalculateAffectedCells(
        GridPosition center, ZoneShape shape, int radius, Direction direction)
    {
        var cells = new List<GridPosition>();

        switch (shape)
        {
            case ZoneShape.Circle:
                for (int x = -radius; x <= radius; x++)
                {
                    for (int y = -radius; y <= radius; y++)
                    {
                        if (x * x + y * y <= radius * radius)
                        {
                            cells.Add(new GridPosition(center.X + x, center.Y + y));
                        }
                    }
                }
                break;

            case ZoneShape.Square:
                for (int x = -radius; x <= radius; x++)
                {
                    for (int y = -radius; y <= radius; y++)
                    {
                        cells.Add(new GridPosition(center.X + x, center.Y + y));
                    }
                }
                break;

            case ZoneShape.Line:
                var (dx, dy) = GetDirectionOffset(direction);
                for (int i = 0; i <= radius; i++)
                {
                    cells.Add(new GridPosition(center.X + dx * i, center.Y + dy * i));
                }
                break;

            case ZoneShape.Cone:
                // Simplified cone implementation
                var (cdx, cdy) = GetDirectionOffset(direction);
                for (int i = 1; i <= radius; i++)
                {
                    var width = i;
                    for (int w = -width; w <= width; w++)
                    {
                        if (cdx != 0)
                            cells.Add(new GridPosition(center.X + cdx * i, center.Y + w));
                        else
                            cells.Add(new GridPosition(center.X + w, center.Y + cdy * i));
                    }
                }
                break;

            case ZoneShape.Ring:
                for (int x = -radius; x <= radius; x++)
                {
                    for (int y = -radius; y <= radius; y++)
                    {
                        var dist = x * x + y * y;
                        if (dist <= radius * radius && dist >= (radius - 1) * (radius - 1))
                        {
                            cells.Add(new GridPosition(center.X + x, center.Y + y));
                        }
                    }
                }
                break;
        }

        // Filter to valid grid cells
        return cells.Where(c => _grid.IsValidPosition(c)).ToList();
    }

    private static (int dx, int dy) GetDirectionOffset(Direction direction)
    {
        return direction switch
        {
            Direction.North => (0, -1),
            Direction.South => (0, 1),
            Direction.East => (1, 0),
            Direction.West => (-1, 0),
            Direction.NorthEast => (1, -1),
            Direction.NorthWest => (-1, -1),
            Direction.SouthEast => (1, 1),
            Direction.SouthWest => (-1, 1),
            _ => (0, 0)
        };
    }

    public bool RemoveZone(Guid zoneEffectId)
    {
        var zone = _activeZones.FirstOrDefault(z => z.Id == zoneEffectId);
        if (zone is null) return false;

        _activeZones.Remove(zone);
        _eventBus.Publish(new ZoneExpiredEvent(zone.Id, zone.ZoneId, zone.Name));
        return true;
    }

    public IReadOnlyList<ZoneEffect> GetZonesAt(GridPosition position)
    {
        return _activeZones.Where(z => z.ContainsPosition(position)).ToList();
    }

    public IReadOnlyList<ZoneEffect> GetAllActiveZones()
    {
        return _activeZones.ToList();
    }

    public IReadOnlyList<ZoneEffect> GetZonesByCaster(Guid casterId)
    {
        return _activeZones.Where(z => z.CasterId == casterId).ToList();
    }

    public int GetActiveZoneCount() => _activeZones.Count;

    public void OnEntityEntered(ICombatant entity, GridPosition position)
    {
        var zones = GetZonesAt(position);
        foreach (var zone in zones)
        {
            _logger.LogDebug("{Entity} entered zone {Zone}", entity.Name, zone.Name);
        }
    }

    public void OnEntityExited(ICombatant entity, GridPosition position)
    {
        // Remove temporary buffs/debuffs when leaving zone
        var zones = GetZonesAt(position);
        foreach (var zone in zones)
        {
            if (zone.EffectType == ZoneEffectType.Buff || zone.EffectType == ZoneEffectType.Debuff)
            {
                // Remove effect if it was zone-based
                _logger.LogDebug("{Entity} exited zone {Zone}", entity.Name, zone.Name);
            }
        }
    }

    public void ClearAllZones()
    {
        _activeZones.Clear();
        _logger.LogInformation("All zones cleared");
    }
}
```

---

## 10. ZoneTickResult DTO

**File:** `src/Core/RuneAndRust.Application/DTOs/ZoneTickResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of ticking all active zones.
/// </summary>
public class ZoneTickResult
{
    /// <summary>Total damage dealt this tick.</summary>
    public int DamageDealt { get; set; }

    /// <summary>Total healing done this tick.</summary>
    public int HealingDone { get; set; }

    /// <summary>Zones that expired this tick.</summary>
    public List<string> ExpiredZones { get; } = new();

    /// <summary>Entities that took damage.</summary>
    public List<Guid> EntitiesDamaged { get; } = new();

    /// <summary>Entities that were healed.</summary>
    public List<Guid> EntitiesHealed { get; } = new();

    /// <summary>Whether any effects were applied.</summary>
    public bool HasEffects => DamageDealt > 0 || HealingDone > 0 || ExpiredZones.Any();
}
```

---

## 11. Zone Events

**File:** `src/Core/RuneAndRust.Application/Events/ZoneEvents.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>Published when a zone is created.</summary>
public record ZoneCreatedEvent(
    Guid ZoneEffectId,
    string ZoneId,
    string Name,
    GridPosition Center,
    Guid CasterId);

/// <summary>Published when a zone expires or is removed.</summary>
public record ZoneExpiredEvent(
    Guid ZoneEffectId,
    string ZoneId,
    string Name);

/// <summary>Published when a zone deals damage.</summary>
public record ZoneDamageEvent(
    Guid ZoneEffectId,
    Guid TargetId,
    int Damage,
    string DamageType);

/// <summary>Published when a zone heals an entity.</summary>
public record ZoneHealEvent(
    Guid ZoneEffectId,
    Guid TargetId,
    int HealAmount);
```

---

## 12. Configuration File

**File:** `config/zones.json`

```json
{
  "$schema": "./schemas/zones.schema.json",
  "zones": [
    {
      "zoneId": "wall-of-fire",
      "name": "Wall of Fire",
      "description": "A blazing wall that burns enemies",
      "effectType": "Damage",
      "shape": "Line",
      "radius": 4,
      "duration": 5,
      "damageValue": "2d6",
      "damageType": "fire",
      "affectsFriendly": false,
      "affectsEnemy": true,
      "icon": "icons/zones/wall-of-fire.png"
    },
    {
      "zoneId": "healing-circle",
      "name": "Healing Circle",
      "description": "An area of divine healing",
      "effectType": "Healing",
      "shape": "Circle",
      "radius": 2,
      "duration": 3,
      "healValue": "1d6+2",
      "affectsFriendly": true,
      "affectsEnemy": false,
      "icon": "icons/zones/healing-circle.png"
    },
    {
      "zoneId": "slow-field",
      "name": "Slow Field",
      "description": "Time distortion slows movement",
      "effectType": "Debuff",
      "shape": "Circle",
      "radius": 3,
      "duration": 4,
      "statusEffectId": "slowed",
      "affectsFriendly": false,
      "affectsEnemy": true,
      "icon": "icons/zones/slow-field.png"
    },
    {
      "zoneId": "web",
      "name": "Web",
      "description": "Sticky webs that entangle enemies",
      "effectType": "Terrain",
      "shape": "Circle",
      "radius": 2,
      "duration": 6,
      "statusEffectId": "entangled",
      "terrainModifier": "DifficultTerrain",
      "affectsFriendly": false,
      "affectsEnemy": true,
      "icon": "icons/zones/web.png"
    },
    {
      "zoneId": "consecration",
      "name": "Consecration",
      "description": "Holy ground that damages undead and heals allies",
      "effectType": "Mixed",
      "shape": "Circle",
      "radius": 2,
      "duration": 5,
      "damageValue": "1d8",
      "damageType": "radiant",
      "healValue": "1d4",
      "affectsFriendly": true,
      "affectsEnemy": true,
      "monsterTypes": ["undead", "demon"],
      "icon": "icons/zones/consecration.png"
    }
  ]
}
```

---

## 13. Shape Calculation Visualization

```
ZONE SHAPES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    CIRCLE (radius 2)              SQUARE (radius 2)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”         â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚   â”‚ â— â”‚   â”‚   â”‚         â”‚ â–  â”‚ â–  â”‚ â–  â”‚ â–  â”‚ â–  â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚ â— â”‚ â— â”‚ â— â”‚   â”‚         â”‚ â–  â”‚ â–  â”‚ â–  â”‚ â–  â”‚ â–  â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ â— â”‚ â— â”‚ C â”‚ â— â”‚ â— â”‚         â”‚ â–  â”‚ â–  â”‚ C â”‚ â–  â”‚ â–  â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚ â— â”‚ â— â”‚ â— â”‚   â”‚         â”‚ â–  â”‚ â–  â”‚ â–  â”‚ â–  â”‚ â–  â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚ â— â”‚   â”‚   â”‚         â”‚ â–  â”‚ â–  â”‚ â–  â”‚ â–  â”‚ â–  â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜         â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    
    13 cells                       25 cells


    LINE (radius 4, East)          CONE (radius 3, East)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”         â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚         â”‚   â”‚   â”‚ â–¶ â”‚ â–¶ â”‚ â–¶ â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ C â”‚ â• â”‚ â• â”‚ â• â”‚ â• â”‚         â”‚   â”‚ â–¶ â”‚ â–¶ â”‚ â–¶ â”‚ â–¶ â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚   â”‚   â”‚         â”‚ C â”‚ â–¶ â”‚ â–¶ â”‚ â–¶ â”‚ â–¶ â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
                                   â”‚   â”‚ â–¶ â”‚ â–¶ â”‚ â–¶ â”‚ â–¶ â”‚
    5 cells                        â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
                                   â”‚   â”‚   â”‚ â–¶ â”‚ â–¶ â”‚ â–¶ â”‚
                                   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
                                   
                                   18 cells


    RING (radius 2)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚   â”‚ â—‹ â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚ â—‹ â”‚   â”‚ â—‹ â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ â—‹ â”‚   â”‚ C â”‚   â”‚ â—‹ â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚ â—‹ â”‚   â”‚ â—‹ â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚ â—‹ â”‚   â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
    
    8 cells (hollow)
```

---

## 14. Unit Testing Requirements (~11 tests)

| Feature | Tests |
|---------|-------|
| CreateZone creates zone at position | 1 |
| Circle shape calculates cells correctly | 1 |
| Square shape calculates cells correctly | 1 |
| Line shape calculates cells correctly | 1 |
| TickZones applies damage to enemies | 1 |
| TickZones applies healing to allies | 1 |
| TickZones applies status effects | 1 |
| Zone duration decrements on tick | 1 |
| Expired zones removed from active | 1 |
| GetZonesAt returns affecting zones | 1 |
| AffectsFriendly/AffectsEnemy respected | 1 |

---

## 15. Acceptance Criteria

- [ ] CreateZone creates zone at correct position
- [ ] Zone shapes calculated correctly (Circle, Square, Line, Cone, Ring)
- [ ] Circle shape uses distance formula
- [ ] Line shape extends in direction
- [ ] TickZones applies effects to entities
- [ ] Damage zones deal damage each turn
- [ ] Healing zones heal each turn
- [ ] Buff/debuff zones apply status effects
- [ ] Terrain zones apply movement penalties
- [ ] Mixed zones apply multiple effects
- [ ] Zone duration decrements correctly
- [ ] Expired zones removed from active list
- [ ] GetZonesAt returns zones at position
- [ ] GetZonesByCaster filters by caster
- [ ] AffectsFriendly setting respected
- [ ] AffectsEnemy setting respected
- [ ] Max zones per caster enforced
- [ ] Zone overlap stacks effects
- [ ] ZoneCreatedEvent fires
- [ ] ZoneExpiredEvent fires
- [ ] ZoneDamageEvent fires
- [ ] ZoneHealEvent fires
- [ ] ~11 unit tests pass

---

## 16. Dependencies

| From | Required |
|------|----------|
| Domain | `GridPosition`, `ICombatGrid` |
| v0.10.0 | `IBuffDebuffService` for status effects |
| Application | `IDamageService`, `IDiceService`, `IEventBus` |

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
