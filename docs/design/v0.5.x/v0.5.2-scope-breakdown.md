# v0.5.2 Terrain & Cover - Scope Breakdown

**Version:** 0.5.2
**Theme:** Terrain & Cover
**Prerequisites:** v0.5.1 Complete (Range & Melee Combat)
**Total Estimated Tests:** ~85 new tests

---

## Executive Summary

The Terrain & Cover version introduces environmental grid features that affect movement and combat. Grid cells now have terrain types that modify movement costs (difficult terrain) or block movement entirely (impassable). Cover objects provide defense bonuses against ranged attacks, adding tactical depth to positioning decisions. This version leverages the grid foundation from v0.5.0 and the range/LOS systems from v0.5.1.

Key focus areas:
- **Terrain Types**: Normal, difficult, impassable, and hazardous terrain
- **Movement Costs**: Terrain-based movement point modifiers
- **Cover System**: Partial and full cover providing defense bonuses
- **Cover Objects**: Destructible and permanent cover-providing objects
- **Terrain Display**: Visual representation of terrain and cover on the grid

The work is divided into **three sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.5.2a | Terrain Core | TerrainType enum, terrain definitions, movement costs | ~30 |
| v0.5.2b | Cover System | CoverType, CoverObject, defense bonuses | ~30 |
| v0.5.2c | Display & Integration | Terrain/cover rendering, combat integration | ~25 |

---

## Existing Infrastructure

### Already Implemented (from v0.5.1)

| Feature | Location | Notes |
|---------|----------|-------|
| RangeService | `Application/Services/RangeService.cs` | Range validation |
| LineOfSightService | `Application/Services/LineOfSightService.cs` | LOS calculations |
| GridCell.BlocksLOS | `Domain/ValueObjects/GridCell.cs` | LOS blocking |
| RangeType enum | `Domain/Enums/RangeType.cs` | Melee/Ranged/Reach |

### Already Implemented (from v0.5.0)

| Feature | Location | Notes |
|---------|----------|-------|
| CombatGrid | `Domain/Entities/CombatGrid.cs` | Grid management |
| GridPosition | `Domain/ValueObjects/GridPosition.cs` | X,Y coordinates |
| GridCell | `Domain/ValueObjects/GridCell.cs` | Cell state |
| MovementService | `Application/Services/MovementService.cs` | Movement system |
| MovementCosts | `Domain/Constants/MovementCosts.cs` | Base costs |
| GridRenderer | `Presentation/Adapters/GridRenderer.cs` | ASCII display |
| CombatGridService | `Application/Services/CombatGridService.cs` | Grid operations |

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| CombatService | `Application/Services/CombatService.cs` | Combat processing |
| Player.Defense | `Domain/Entities/Player.cs` | Defense stat |
| Monster.Defense | `Domain/Entities/Monster.cs` | Defense stat |
| Room entity | `Domain/Entities/Room.cs` | Room context |

### Needs Implementation (v0.5.2)

| Feature | Phase | Notes |
|---------|-------|-------|
| TerrainType enum | v0.5.2a | Normal, Difficult, Impassable, Hazardous |
| TerrainDefinition | v0.5.2a | Configurable terrain |
| GridCell.TerrainType | v0.5.2a | Terrain per cell |
| Terrain movement costs | v0.5.2a | Movement modifiers |
| Hazardous terrain damage | v0.5.2a | Damage on entry |
| CoverType enum | v0.5.2b | None, Partial, Full |
| CoverObject entity | v0.5.2b | Cover-providing objects |
| Cover defense bonus | v0.5.2b | AC bonus from cover |
| Destructible cover | v0.5.2b | Cover HP and destruction |
| Terrain display | v0.5.2c | ASCII symbols for terrain |
| Cover display | v0.5.2c | ASCII symbols for cover |
| Combat cover integration | v0.5.2c | Defense calculations |

---

## Feature Analysis & Categorization

### Terrain Core Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| TerrainType enum | Low | None | **v0.5.2a** |
| TerrainDefinition | Medium | Configuration | **v0.5.2a** |
| GridCell.TerrainType | Low | GridCell | **v0.5.2a** |
| ITerrainService interface | Low | None | **v0.5.2a** |
| TerrainService | Medium | GridCell, MovementService | **v0.5.2a** |
| Difficult terrain (2x cost) | Medium | MovementService | **v0.5.2a** |
| Impassable terrain | Low | GridCell.IsPassable | **v0.5.2a** |
| Hazardous terrain damage | Medium | CombatService | **v0.5.2a** |
| Terrain configuration | Medium | Config | **v0.5.2a** |

### Cover System Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| CoverType enum | Low | None | **v0.5.2b** |
| CoverObject entity | High | GridPosition | **v0.5.2b** |
| CombatGrid.Cover collection | Medium | CombatGrid | **v0.5.2b** |
| ICoverService interface | Low | None | **v0.5.2b** |
| CoverService | High | LineOfSightService, GridPosition | **v0.5.2b** |
| Partial cover (+2 defense) | Medium | CoverService | **v0.5.2b** |
| Full cover (untargetable) | Medium | CoverService, RangeService | **v0.5.2b** |
| Destructible cover HP | Medium | CoverObject | **v0.5.2b** |
| Cover destruction | Medium | CombatService | **v0.5.2b** |
| Cover configuration | Medium | Config | **v0.5.2b** |

### Display & Integration Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| Terrain ASCII symbols | Medium | GridRenderer | **v0.5.2c** |
| Cover ASCII symbols | Medium | GridRenderer | **v0.5.2c** |
| Terrain legend | Low | Display | **v0.5.2c** |
| Cover legend | Low | Display | **v0.5.2c** |
| Combat defense with cover | Medium | CombatService | **v0.5.2c** |
| Movement with terrain costs | Medium | MovementService | **v0.5.2c** |
| Hazard damage on move | Medium | MovementService | **v0.5.2c** |
| Cover in attack display | Medium | AttackCommand | **v0.5.2c** |

---

## Phase Definitions

---

## v0.5.2a: Terrain Core

[v0.5.2a Design Specification](v0.5.2a-design-specification.md)

### Overview

Establish the terrain system including terrain types, terrain definitions, and movement cost modifications. Cells can be normal, difficult (costs extra movement), impassable (blocks movement), or hazardous (deals damage when entered).

### Scope

**In Scope:**
- `TerrainType` enum (Normal, Difficult, Impassable, Hazardous)
- `TerrainDefinition` for configurable terrain types
- `GridCell.TerrainType` property
- `ITerrainService` interface
- `TerrainService` for terrain calculations
- Difficult terrain movement cost (2x)
- Impassable terrain blocking movement
- Hazardous terrain damage on entry
- Terrain configuration in JSON
- Room terrain layout support
- Terrain-aware movement validation

**Out of Scope:**
- Cover system (v0.5.2b)
- Terrain display (v0.5.2c)
- Full combat integration (v0.5.2c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Enums | 1 | `TerrainType` |
| Domain Definitions | 1 | `TerrainDefinition` |
| GridCell Updates | 1 | Add TerrainType property |
| Application Interfaces | 1 | `ITerrainService` |
| Application Services | 1 | `TerrainService` |
| MovementService Updates | 1 | Terrain cost integration |
| Configuration | 1 | `terrain.json` |
| Unit Tests | ~30 | Terrain, movement cost tests |

### TerrainType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of terrain on grid cells.
/// </summary>
public enum TerrainType
{
    /// <summary>
    /// Normal terrain - standard movement cost.
    /// </summary>
    Normal,

    /// <summary>
    /// Difficult terrain - costs double movement points.
    /// </summary>
    Difficult,

    /// <summary>
    /// Impassable terrain - cannot be entered.
    /// </summary>
    Impassable,

    /// <summary>
    /// Hazardous terrain - deals damage when entered.
    /// </summary>
    Hazardous
}
```

### TerrainDefinition

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration for a type of terrain.
/// </summary>
public class TerrainDefinition
{
    /// <summary>
    /// Gets the unique identifier for this terrain type.
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the terrain type category.
    /// </summary>
    public TerrainType Type { get; private set; } = TerrainType.Normal;

    /// <summary>
    /// Gets the movement cost multiplier (1.0 = normal, 2.0 = double).
    /// </summary>
    public float MovementCostMultiplier { get; private set; } = 1.0f;

    /// <summary>
    /// Gets the damage dealt when entering (for Hazardous terrain).
    /// </summary>
    public string? DamageOnEntry { get; private set; }

    /// <summary>
    /// Gets the damage type for hazardous terrain.
    /// </summary>
    public string? DamageType { get; private set; }

    /// <summary>
    /// Gets whether this terrain blocks line of sight.
    /// </summary>
    public bool BlocksLOS { get; private set; }

    /// <summary>
    /// Gets the ASCII display character.
    /// </summary>
    public char DisplayChar { get; private set; } = '.';

    /// <summary>
    /// Gets the description for the legend.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    private TerrainDefinition() { }

    public static TerrainDefinition Create(
        string id,
        string name,
        TerrainType type,
        float movementCostMultiplier = 1.0f,
        string? damageOnEntry = null,
        string? damageType = null,
        bool blocksLOS = false,
        char displayChar = '.',
        string description = "")
    {
        return new TerrainDefinition
        {
            Id = id,
            Name = name,
            Type = type,
            MovementCostMultiplier = movementCostMultiplier,
            DamageOnEntry = damageOnEntry,
            DamageType = damageType,
            BlocksLOS = blocksLOS,
            DisplayChar = displayChar,
            Description = description
        };
    }

    /// <summary>
    /// Gets whether this terrain is passable.
    /// </summary>
    public bool IsPassable => Type != TerrainType.Impassable;

    /// <summary>
    /// Gets whether this terrain deals damage.
    /// </summary>
    public bool DealsDamage => Type == TerrainType.Hazardous && !string.IsNullOrEmpty(DamageOnEntry);
}
```

### GridCell Modifications

```
MODIFY: GridCell
├── ADD: TerrainType: TerrainType (default: Normal)
├── ADD: TerrainDefinitionId: string? (for custom terrain)
├── ADD: SetTerrain(TerrainType): void
├── ADD: SetTerrainDefinition(string): void
├── ADD: GetMovementCostMultiplier(): float
├── UPDATE: IsPassable considers TerrainType
└── UPDATE: BlocksLOS considers TerrainType
```

### ITerrainService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for terrain calculations and management.
/// </summary>
public interface ITerrainService
{
    /// <summary>
    /// Gets the movement cost for a cell.
    /// </summary>
    int GetMovementCost(GridPosition position, MovementDirection direction);

    /// <summary>
    /// Gets the movement cost multiplier for a position.
    /// </summary>
    float GetMovementCostMultiplier(GridPosition position);

    /// <summary>
    /// Checks if a position is passable.
    /// </summary>
    bool IsPassable(GridPosition position);

    /// <summary>
    /// Checks if terrain deals damage.
    /// </summary>
    bool DealsDamage(GridPosition position);

    /// <summary>
    /// Gets the damage for entering hazardous terrain.
    /// </summary>
    TerrainDamageResult? GetTerrainDamage(GridPosition position);

    /// <summary>
    /// Applies terrain damage to an entity.
    /// </summary>
    TerrainDamageResult ApplyTerrainDamage(Guid entityId, GridPosition position);

    /// <summary>
    /// Gets the terrain type at a position.
    /// </summary>
    TerrainType GetTerrainType(GridPosition position);

    /// <summary>
    /// Gets the terrain definition at a position.
    /// </summary>
    TerrainDefinition? GetTerrainDefinition(GridPosition position);

    /// <summary>
    /// Sets the terrain at a position.
    /// </summary>
    void SetTerrain(GridPosition position, TerrainType type);

    /// <summary>
    /// Sets the terrain definition at a position.
    /// </summary>
    void SetTerrain(GridPosition position, string terrainDefinitionId);

    /// <summary>
    /// Gets all terrain definitions.
    /// </summary>
    IEnumerable<TerrainDefinition> GetAllTerrainDefinitions();
}

public readonly record struct TerrainDamageResult
{
    public bool DamageDealt { get; init; }
    public int Damage { get; init; }
    public string DamageType { get; init; }
    public string TerrainName { get; init; }
    public string Message { get; init; }
}
```

### MovementService Updates

```csharp
// Update MovementService to consider terrain:

public MovementResult Move(Guid entityId, MovementDirection direction)
{
    // ... existing validation ...

    var newPosition = currentPosition.Move(direction);

    // Check terrain passability
    if (!_terrainService.IsPassable(newPosition))
    {
        return new MovementResult
        {
            Success = false,
            FailureReason = MovementFailureReason.CellImpassable,
            Message = "That terrain is impassable."
        };
    }

    // Calculate movement cost with terrain
    var baseCost = MovementCosts.GetCost(direction);
    var terrainMultiplier = _terrainService.GetMovementCostMultiplier(newPosition);
    var totalCost = (int)(baseCost * terrainMultiplier);

    if (entity.MovementPointsRemaining < totalCost)
    {
        return new MovementResult
        {
            Success = false,
            FailureReason = MovementFailureReason.InsufficientMovementPoints,
            Message = $"Insufficient movement points. Need {totalCost}, have {entity.MovementPointsRemaining}."
        };
    }

    // ... perform movement ...

    // Apply hazard damage if applicable
    TerrainDamageResult? hazardDamage = null;
    if (_terrainService.DealsDamage(newPosition))
    {
        hazardDamage = _terrainService.ApplyTerrainDamage(entityId, newPosition);
    }

    return new MovementResult
    {
        Success = true,
        OldPosition = currentPosition,
        NewPosition = newPosition,
        MovementPointsUsed = totalCost,
        MovementPointsRemaining = entity.MovementPointsRemaining - totalCost,
        TerrainDamage = hazardDamage,
        Message = hazardDamage?.DamageDealt == true
            ? $"You move to {newPosition}. {hazardDamage.Value.Message}"
            : $"You move to {newPosition}."
    };
}
```

### User-Facing Changes

**Difficult Terrain Movement:**
```
> move north

You carefully traverse the rubble...

[Movement: D4 → D3]
[Terrain: Difficult (rubble) - 2x movement cost]
[Movement Points: 4 → 2 remaining]
```

**Impassable Terrain:**
```
> move east

You can't move there - the pit is impassable!

[Cell E4: Pit (impassable terrain)]
```

**Hazardous Terrain:**
```
> move north

You step into the flames!

[Movement: D4 → D3]
[Movement Points: 4 → 3 remaining]

[HAZARD DAMAGE]
The fire burns you for 4 damage!
[Fire terrain: 1d6 = 4 fire damage]
HP: 25/30 → 21/30
```

**Position with Terrain Info:**
```
> position

Your Position: D4 (Normal terrain)
Movement Points: 3 / 4

Nearby Terrain:
  North (D3): Difficult (rubble) - 2x cost
  South (D5): Normal (stone floor)
  East (E4): Impassable (pit)
  West (C4): Hazardous (fire) - 1d6 fire damage
```

### Configuration Example

```json
{
  "$schema": "../schemas/terrain.schema.json",
  "terrainDefinitions": [
    {
      "id": "normal-floor",
      "name": "Stone Floor",
      "type": "Normal",
      "movementCostMultiplier": 1.0,
      "displayChar": ".",
      "description": "Normal stone floor"
    },
    {
      "id": "rubble",
      "name": "Rubble",
      "type": "Difficult",
      "movementCostMultiplier": 2.0,
      "displayChar": "~",
      "description": "Difficult terrain - 2x movement cost"
    },
    {
      "id": "shallow-water",
      "name": "Shallow Water",
      "type": "Difficult",
      "movementCostMultiplier": 2.0,
      "displayChar": "≈",
      "description": "Shallow water - 2x movement cost"
    },
    {
      "id": "pit",
      "name": "Pit",
      "type": "Impassable",
      "movementCostMultiplier": 0,
      "displayChar": "○",
      "description": "Deep pit - impassable"
    },
    {
      "id": "wall",
      "name": "Wall",
      "type": "Impassable",
      "movementCostMultiplier": 0,
      "blocksLOS": true,
      "displayChar": "#",
      "description": "Solid wall - impassable, blocks LOS"
    },
    {
      "id": "fire",
      "name": "Fire",
      "type": "Hazardous",
      "movementCostMultiplier": 1.0,
      "damageOnEntry": "1d6",
      "damageType": "Fire",
      "displayChar": "▲",
      "description": "Flames - 1d6 fire damage on entry"
    },
    {
      "id": "acid-pool",
      "name": "Acid Pool",
      "type": "Hazardous",
      "movementCostMultiplier": 1.5,
      "damageOnEntry": "1d4",
      "damageType": "Acid",
      "displayChar": "●",
      "description": "Acid pool - 1d4 acid damage on entry"
    },
    {
      "id": "spike-trap",
      "name": "Spike Trap",
      "type": "Hazardous",
      "movementCostMultiplier": 1.0,
      "damageOnEntry": "1d8",
      "damageType": "Piercing",
      "displayChar": "^",
      "description": "Spike trap - 1d8 piercing damage on entry"
    }
  ]
}
```

### Acceptance Criteria

- [ ] TerrainType enum has Normal, Difficult, Impassable, Hazardous
- [ ] TerrainDefinition stores all terrain properties
- [ ] GridCell.TerrainType stores cell terrain
- [ ] Normal terrain costs 1x movement
- [ ] Difficult terrain costs 2x movement
- [ ] Impassable terrain blocks movement
- [ ] Hazardous terrain deals damage on entry
- [ ] TerrainService calculates movement costs
- [ ] MovementService integrates terrain costs
- [ ] Terrain damage rolls use DiceService
- [ ] Terrain configuration loads from JSON
- [ ] ~30 unit tests pass

---

## v0.5.2b: Cover System

[v0.5.2b Design Specification](v0.5.2b-design-specification.md)

### Overview

Implement the cover system including cover types, cover objects, and defense bonuses. Cover objects can be placed on the grid to provide partial (+2 defense) or full cover (untargetable from certain angles). Destructible cover can be destroyed during combat.

### Scope

**In Scope:**
- `CoverType` enum (None, Partial, Full)
- `CoverObject` entity for cover-providing objects
- `CoverDefinition` for configurable cover types
- `CombatGrid.Cover` collection
- `ICoverService` interface
- `CoverService` for cover calculations
- Partial cover (+2 defense bonus)
- Full cover (cannot be targeted from blocked angle)
- Cover direction calculation (relative to attacker)
- Destructible cover with HP
- Cover destruction mechanics
- Cover configuration in JSON

**Out of Scope:**
- Cover display (v0.5.2c)
- Combat integration display (v0.5.2c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Enums | 1 | `CoverType` |
| Domain Entities | 1 | `CoverObject` |
| Domain Definitions | 1 | `CoverDefinition` |
| CombatGrid Updates | 1 | Add Cover collection |
| Application Interfaces | 1 | `ICoverService` |
| Application Services | 1 | `CoverService` |
| Configuration | 1 | `cover.json` |
| Unit Tests | ~30 | Cover, defense bonus tests |

### CoverType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of cover providing defense bonuses.
/// </summary>
public enum CoverType
{
    /// <summary>
    /// No cover - no defense bonus.
    /// </summary>
    None,

    /// <summary>
    /// Partial cover - +2 defense bonus.
    /// </summary>
    Partial,

    /// <summary>
    /// Full cover - cannot be targeted from blocked direction.
    /// </summary>
    Full
}
```

### CoverDefinition

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration for a type of cover object.
/// </summary>
public class CoverDefinition
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public string Id { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the cover type provided.
    /// </summary>
    public CoverType CoverType { get; private set; } = CoverType.Partial;

    /// <summary>
    /// Gets the defense bonus provided.
    /// </summary>
    public int DefenseBonus { get; private set; } = 2;

    /// <summary>
    /// Gets whether this cover is destructible.
    /// </summary>
    public bool IsDestructible { get; private set; }

    /// <summary>
    /// Gets the maximum HP for destructible cover.
    /// </summary>
    public int MaxHitPoints { get; private set; } = 10;

    /// <summary>
    /// Gets whether this cover blocks movement.
    /// </summary>
    public bool BlocksMovement { get; private set; } = true;

    /// <summary>
    /// Gets whether this cover blocks line of sight.
    /// </summary>
    public bool BlocksLOS { get; private set; }

    /// <summary>
    /// Gets the ASCII display character.
    /// </summary>
    public char DisplayChar { get; private set; } = '▪';

    /// <summary>
    /// Gets the description.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    private CoverDefinition() { }

    public static CoverDefinition Create(
        string id,
        string name,
        CoverType coverType,
        int defenseBonus = 2,
        bool isDestructible = false,
        int maxHitPoints = 10,
        bool blocksMovement = true,
        bool blocksLOS = false,
        char displayChar = '▪',
        string description = "")
    {
        return new CoverDefinition
        {
            Id = id,
            Name = name,
            CoverType = coverType,
            DefenseBonus = defenseBonus,
            IsDestructible = isDestructible,
            MaxHitPoints = maxHitPoints,
            BlocksMovement = blocksMovement,
            BlocksLOS = blocksLOS,
            DisplayChar = displayChar,
            Description = description
        };
    }
}
```

### CoverObject Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a cover-providing object on the combat grid.
/// </summary>
public class CoverObject : IEntity
{
    /// <summary>
    /// Gets the unique identifier.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the definition ID.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the grid position.
    /// </summary>
    public GridPosition Position { get; private set; }

    /// <summary>
    /// Gets the cover type provided.
    /// </summary>
    public CoverType CoverType { get; private set; } = CoverType.Partial;

    /// <summary>
    /// Gets the defense bonus.
    /// </summary>
    public int DefenseBonus { get; private set; } = 2;

    /// <summary>
    /// Gets whether this cover is destructible.
    /// </summary>
    public bool IsDestructible { get; private set; }

    /// <summary>
    /// Gets the current HP.
    /// </summary>
    public int CurrentHitPoints { get; private set; }

    /// <summary>
    /// Gets the maximum HP.
    /// </summary>
    public int MaxHitPoints { get; private set; }

    /// <summary>
    /// Gets whether this cover is destroyed.
    /// </summary>
    public bool IsDestroyed => IsDestructible && CurrentHitPoints <= 0;

    /// <summary>
    /// Gets whether this cover blocks movement.
    /// </summary>
    public bool BlocksMovement { get; private set; } = true;

    /// <summary>
    /// Gets whether this cover blocks LOS.
    /// </summary>
    public bool BlocksLOS { get; private set; }

    /// <summary>
    /// Gets the display character.
    /// </summary>
    public char DisplayChar { get; private set; } = '▪';

    private CoverObject() { }

    /// <summary>
    /// Creates a new cover object.
    /// </summary>
    public static CoverObject Create(
        CoverDefinition definition,
        GridPosition position)
    {
        return new CoverObject
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.Id,
            Name = definition.Name,
            Position = position,
            CoverType = definition.CoverType,
            DefenseBonus = definition.DefenseBonus,
            IsDestructible = definition.IsDestructible,
            CurrentHitPoints = definition.MaxHitPoints,
            MaxHitPoints = definition.MaxHitPoints,
            BlocksMovement = definition.BlocksMovement,
            BlocksLOS = definition.BlocksLOS,
            DisplayChar = definition.DisplayChar
        };
    }

    /// <summary>
    /// Applies damage to this cover.
    /// </summary>
    /// <returns>True if cover was destroyed.</returns>
    public bool TakeDamage(int damage)
    {
        if (!IsDestructible || IsDestroyed)
            return false;

        CurrentHitPoints = Math.Max(0, CurrentHitPoints - damage);
        return IsDestroyed;
    }

    /// <summary>
    /// Gets the HP percentage.
    /// </summary>
    public int GetHpPercentage()
    {
        if (MaxHitPoints == 0)
            return 100;
        return (int)((CurrentHitPoints / (float)MaxHitPoints) * 100);
    }
}
```

### CombatGrid Modifications

```
MODIFY: CombatGrid
├── ADD: _coverObjects: Dictionary<GridPosition, CoverObject>
├── ADD: CoverObjects: IReadOnlyDictionary<GridPosition, CoverObject>
├── ADD: AddCover(CoverObject): bool
├── ADD: RemoveCover(GridPosition): bool
├── ADD: GetCover(GridPosition): CoverObject?
├── ADD: HasCover(GridPosition): bool
└── UPDATE: IsValidPosition considers cover blocking
```

### ICoverService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for cover calculations and management.
/// </summary>
public interface ICoverService
{
    /// <summary>
    /// Gets the cover between an attacker and target.
    /// </summary>
    CoverCheckResult GetCoverBetween(Guid attackerId, Guid targetId);

    /// <summary>
    /// Gets the cover between two positions.
    /// </summary>
    CoverCheckResult GetCoverBetween(GridPosition attacker, GridPosition target);

    /// <summary>
    /// Gets the defense bonus from cover.
    /// </summary>
    int GetDefenseBonus(Guid attackerId, Guid targetId);

    /// <summary>
    /// Checks if a target has full cover from an attacker.
    /// </summary>
    bool HasFullCover(Guid attackerId, Guid targetId);

    /// <summary>
    /// Adds cover to the grid.
    /// </summary>
    bool AddCover(CoverDefinition definition, GridPosition position);

    /// <summary>
    /// Removes cover from the grid.
    /// </summary>
    bool RemoveCover(GridPosition position);

    /// <summary>
    /// Damages cover at a position.
    /// </summary>
    CoverDamageResult DamageCover(GridPosition position, int damage);

    /// <summary>
    /// Gets cover at a position.
    /// </summary>
    CoverObject? GetCover(GridPosition position);

    /// <summary>
    /// Gets all cover providing protection to a position from a direction.
    /// </summary>
    IEnumerable<CoverObject> GetProtectingCover(GridPosition position, GridPosition attackerPosition);
}

public readonly record struct CoverCheckResult
{
    public CoverType CoverType { get; init; }
    public int DefenseBonus { get; init; }
    public CoverObject? CoverObject { get; init; }
    public bool IsBlocked { get; init; }
    public string Message { get; init; }
}

public readonly record struct CoverDamageResult
{
    public bool DamageDealt { get; init; }
    public int DamageAmount { get; init; }
    public int RemainingHp { get; init; }
    public bool Destroyed { get; init; }
    public string CoverName { get; init; }
    public string Message { get; init; }
}
```

### CoverService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for cover calculations.
/// </summary>
public class CoverService : ICoverService
{
    private readonly ICombatGridService _gridService;
    private readonly ILineOfSightService _losService;
    private readonly IConfigurationProvider _configProvider;
    private readonly ILogger<CoverService> _logger;

    public CoverService(
        ICombatGridService gridService,
        ILineOfSightService losService,
        IConfigurationProvider configProvider,
        ILogger<CoverService> logger)
    {
        _gridService = gridService;
        _losService = losService;
        _configProvider = configProvider;
        _logger = logger;
    }

    /// <inheritdoc />
    public CoverCheckResult GetCoverBetween(Guid attackerId, Guid targetId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
        {
            return new CoverCheckResult
            {
                CoverType = CoverType.None,
                Message = "No active grid."
            };
        }

        var attackerPos = grid.GetEntityPosition(attackerId);
        var targetPos = grid.GetEntityPosition(targetId);

        if (!attackerPos.HasValue || !targetPos.HasValue)
        {
            return new CoverCheckResult
            {
                CoverType = CoverType.None,
                Message = "Entity not on grid."
            };
        }

        return GetCoverBetween(attackerPos.Value, targetPos.Value);
    }

    /// <inheritdoc />
    public CoverCheckResult GetCoverBetween(GridPosition attacker, GridPosition target)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
        {
            return new CoverCheckResult { CoverType = CoverType.None };
        }

        // Check for cover objects adjacent to target that are between attacker and target
        var protectingCover = GetProtectingCover(target, attacker).ToList();

        if (!protectingCover.Any())
        {
            return new CoverCheckResult
            {
                CoverType = CoverType.None,
                DefenseBonus = 0,
                Message = "No cover."
            };
        }

        // Get the best cover (full > partial)
        var bestCover = protectingCover
            .OrderByDescending(c => c.CoverType)
            .First();

        if (bestCover.CoverType == CoverType.Full)
        {
            return new CoverCheckResult
            {
                CoverType = CoverType.Full,
                DefenseBonus = 0,
                CoverObject = bestCover,
                IsBlocked = true,
                Message = $"Target has full cover behind {bestCover.Name}."
            };
        }

        return new CoverCheckResult
        {
            CoverType = CoverType.Partial,
            DefenseBonus = bestCover.DefenseBonus,
            CoverObject = bestCover,
            IsBlocked = false,
            Message = $"Target has partial cover (+{bestCover.DefenseBonus} defense) from {bestCover.Name}."
        };
    }

    /// <inheritdoc />
    public int GetDefenseBonus(Guid attackerId, Guid targetId)
    {
        var coverResult = GetCoverBetween(attackerId, targetId);
        return coverResult.DefenseBonus;
    }

    /// <inheritdoc />
    public bool HasFullCover(Guid attackerId, Guid targetId)
    {
        var coverResult = GetCoverBetween(attackerId, targetId);
        return coverResult.CoverType == CoverType.Full;
    }

    /// <inheritdoc />
    public IEnumerable<CoverObject> GetProtectingCover(
        GridPosition position,
        GridPosition attackerPosition)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            yield break;

        // Get line from attacker to target
        var lineCells = _losService.GetLineCells(attackerPosition, position).ToList();

        // Check cells adjacent to target that are on the line
        foreach (var cell in lineCells)
        {
            if (cell.Equals(attackerPosition) || cell.Equals(position))
                continue;

            var cover = grid.GetCover(cell);
            if (cover != null && !cover.IsDestroyed)
            {
                yield return cover;
            }
        }

        // Also check adjacent cells to target for cover objects
        foreach (var adjacent in grid.GetAdjacentCells(position))
        {
            var cover = grid.GetCover(adjacent.Position);
            if (cover != null && !cover.IsDestroyed)
            {
                // Check if cover is between attacker and target
                if (IsPositionBetween(attackerPosition, position, adjacent.Position))
                {
                    yield return cover;
                }
            }
        }
    }

    private bool IsPositionBetween(GridPosition attacker, GridPosition target, GridPosition cover)
    {
        // Simple check: cover is on the line or close to it
        var attackerToTarget = target.DistanceTo(attacker);
        var attackerToCover = cover.DistanceTo(attacker);
        var coverToTarget = cover.DistanceTo(target);

        return attackerToCover < attackerToTarget && coverToTarget <= 1;
    }

    /// <inheritdoc />
    public CoverDamageResult DamageCover(GridPosition position, int damage)
    {
        var grid = _gridService.GetActiveGrid();
        var cover = grid?.GetCover(position);

        if (cover == null)
        {
            return new CoverDamageResult
            {
                DamageDealt = false,
                Message = "No cover at that position."
            };
        }

        if (!cover.IsDestructible)
        {
            return new CoverDamageResult
            {
                DamageDealt = false,
                CoverName = cover.Name,
                Message = $"{cover.Name} cannot be destroyed."
            };
        }

        var destroyed = cover.TakeDamage(damage);

        if (destroyed)
        {
            grid!.RemoveCover(position);
            _logger.LogInformation("Cover {Name} at {Position} destroyed", cover.Name, position);
        }

        return new CoverDamageResult
        {
            DamageDealt = true,
            DamageAmount = damage,
            RemainingHp = cover.CurrentHitPoints,
            Destroyed = destroyed,
            CoverName = cover.Name,
            Message = destroyed
                ? $"{cover.Name} is destroyed!"
                : $"{cover.Name} takes {damage} damage ({cover.CurrentHitPoints}/{cover.MaxHitPoints} HP)."
        };
    }

    // ... other methods ...
}
```

### User-Facing Changes

**Attack with Partial Cover:**
```
> attack goblin

You fire your Longbow at the Goblin at F2...

[Ranged attack - distance: 4 cells]
[Target has partial cover behind Wooden Crate (+2 defense)]
[Attack Roll: 2d6 + 3 = 12 vs AC 13 (11 + 2 cover)]
Miss! Your arrow deflects off the crate.
```

**Attack Blocked by Full Cover:**
```
> attack skeleton

You can't target the Skeleton - it has full cover!

[Distance: 5 cells - in range]
[Full cover: Stone Pillar blocks line of attack]

Move to a different position to get a clear shot.
```

**Destroying Cover:**
```
> attack crate

You swing your axe at the Wooden Crate at E3!

[Attack on cover object]
[Wooden Crate: 6/10 HP → 2/10 HP]

---

> attack crate

The Wooden Crate splinters apart!

[Wooden Crate destroyed!]
The Goblin behind it is now exposed.
```

### Configuration Example

```json
{
  "$schema": "../schemas/cover.schema.json",
  "coverDefinitions": [
    {
      "id": "wooden-crate",
      "name": "Wooden Crate",
      "coverType": "Partial",
      "defenseBonus": 2,
      "isDestructible": true,
      "maxHitPoints": 10,
      "blocksMovement": true,
      "blocksLOS": false,
      "displayChar": "□",
      "description": "Wooden crate providing partial cover"
    },
    {
      "id": "stone-pillar",
      "name": "Stone Pillar",
      "coverType": "Full",
      "defenseBonus": 0,
      "isDestructible": false,
      "blocksMovement": true,
      "blocksLOS": true,
      "displayChar": "█",
      "description": "Stone pillar providing full cover"
    },
    {
      "id": "low-wall",
      "name": "Low Wall",
      "coverType": "Partial",
      "defenseBonus": 2,
      "isDestructible": false,
      "blocksMovement": false,
      "blocksLOS": false,
      "displayChar": "▄",
      "description": "Low wall providing partial cover (can move over)"
    },
    {
      "id": "barrel",
      "name": "Barrel",
      "coverType": "Partial",
      "defenseBonus": 1,
      "isDestructible": true,
      "maxHitPoints": 5,
      "blocksMovement": true,
      "blocksLOS": false,
      "displayChar": "○",
      "description": "Barrel providing light cover"
    },
    {
      "id": "overturned-table",
      "name": "Overturned Table",
      "coverType": "Partial",
      "defenseBonus": 2,
      "isDestructible": true,
      "maxHitPoints": 8,
      "blocksMovement": false,
      "blocksLOS": false,
      "displayChar": "═",
      "description": "Overturned table providing partial cover"
    }
  ]
}
```

### Acceptance Criteria

- [ ] CoverType enum has None, Partial, Full
- [ ] CoverDefinition stores all cover properties
- [ ] CoverObject tracks position and HP
- [ ] Partial cover provides +2 defense bonus
- [ ] Full cover blocks targeting from that angle
- [ ] CoverService calculates cover between positions
- [ ] Destructible cover can take damage
- [ ] Destroyed cover is removed from grid
- [ ] Non-destructible cover ignores damage
- [ ] Cover configuration loads from JSON
- [ ] ~30 unit tests pass

---

## v0.5.2c: Display & Integration

[v0.5.2c Design Specification](v0.5.2c-design-specification.md)

### Overview

Implement terrain and cover display on the ASCII grid and integrate with the combat system. The grid shows terrain types and cover objects with distinct symbols. Combat calculations include cover defense bonuses, and movement shows terrain costs.

### Scope

**In Scope:**
- Terrain ASCII symbols on grid
- Cover ASCII symbols on grid
- Combined terrain/cover legend
- Combat defense calculation with cover
- Attack display showing cover info
- Movement display showing terrain costs
- Hazard damage in movement messages
- Grid render options for terrain/cover
- Room terrain layout configuration
- Combat grid initialization with terrain/cover

**Out of Scope:**
- Flanking (v0.5.3)
- Area effects (v0.5.3)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| GridRenderer Updates | 1 | Terrain/cover rendering |
| CombatService Updates | 1 | Cover in defense calculation |
| MovementService Updates | 1 | Terrain cost display |
| RoomConfiguration Updates | 1 | Terrain layout |
| Grid Initialization Updates | 1 | Load terrain/cover |
| Unit Tests | ~25 | Display, integration tests |

### ASCII Grid with Terrain & Cover

```
Combat Grid                              [Turn 3]
===============================================

     A   B   C   D   E   F   G   H
   +---+---+---+---+---+---+---+---+
 1 | . | . | . | . | ~ | ~ | . | . |
   +---+---+---+---+---+---+---+---+
 2 | . | □ | M | . | . | M | █ | . |
   +---+---+---+---+---+---+---+---+
 3 | . | . | . | ▲ | . | . | . | . |
   +---+---+---+---+---+---+---+---+
 4 | . | . | ▄ | @ | ▄ | . | . | . |
   +---+---+---+---+---+---+---+---+
 5 | ~ | ~ | . | . | . | ○ | . | . |
   +---+---+---+---+---+---+---+---+

Legend:
  @ = You    M = Monster   . = Floor    ~ = Difficult
  □ = Crate  █ = Pillar    ▄ = Wall     ▲ = Fire
  ○ = Pit

Terrain: D3 = Fire (1d6 damage)
Cover: B2 = Wooden Crate (partial, +2 def)

You (D4) | HP: 25/30 | Move: 3/4
```

### Compact Grid with Terrain

```
Combat: Skeleton x2                      [Your Turn]
═══════════════════════════════════════════════════

  A B C D E F G H
1 . . . . ~ ~ . .
2 . □ M . . M █ .     @ = You    M = Monster
3 . . . ▲ . . . .     □ = Cover  █ = Full cover
4 . . ▄ @ ▄ . . .     ~ = Difficult  ▲ = Fire
5 ~ ~ . . . ○ . .     ○ = Impassable

You (D4) | HP: 25/30 | Weapon: Iron Sword (Melee)
```

### GridRenderer Updates

```csharp
// Update GridRenderer to handle terrain and cover:

public string RenderCell(GridCell cell, CoverObject? cover)
{
    // Cover takes precedence for display
    if (cover != null && !cover.IsDestroyed)
        return cover.DisplayChar.ToString();

    // Then check occupancy
    if (cell.IsPlayerOccupied)
        return "@";
    if (cell.IsOccupied)
        return "M";

    // Then terrain
    return GetTerrainChar(cell.TerrainType);
}

private char GetTerrainChar(TerrainType type) => type switch
{
    TerrainType.Normal => '.',
    TerrainType.Difficult => '~',
    TerrainType.Impassable => '○',
    TerrainType.Hazardous => '▲',
    _ => '.'
};

public string RenderLegend(CombatGrid grid)
{
    var legend = new StringBuilder();
    legend.AppendLine("Legend:");
    legend.AppendLine("  @ = You    M = Monster   . = Floor");

    // Add terrain types present on grid
    var terrainTypes = GetUniqueTerrainTypes(grid);
    foreach (var (type, def) in terrainTypes)
    {
        legend.AppendLine($"  {def.DisplayChar} = {def.Name}");
    }

    // Add cover types present on grid
    var coverTypes = GetUniqueCoverTypes(grid);
    foreach (var (type, def) in coverTypes)
    {
        legend.AppendLine($"  {def.DisplayChar} = {def.Name}");
    }

    return legend.ToString();
}
```

### CombatService Cover Integration

```csharp
// Update CombatService attack calculation:

public AttackResult ProcessAttack(Guid attackerId, Guid targetId, Item weapon)
{
    // ... existing attack logic ...

    // Get cover bonus
    var coverResult = _coverService.GetCoverBetween(attackerId, targetId);

    if (coverResult.CoverType == CoverType.Full)
    {
        return new AttackResult
        {
            Success = false,
            Message = $"Target has full cover behind {coverResult.CoverObject?.Name}."
        };
    }

    // Apply cover to defense
    var targetDefense = target.Defense + coverResult.DefenseBonus;

    // Roll attack
    var roll = _diceService.Roll(weapon.AttackDice);
    var total = roll.Total + attackModifier;

    var hit = total >= targetDefense;

    // Build result message with cover info
    var message = new StringBuilder();
    message.AppendLine($"Attack Roll: {roll.Expression} = {total} vs AC {targetDefense}");

    if (coverResult.DefenseBonus > 0)
    {
        message.AppendLine($"[Cover: +{coverResult.DefenseBonus} from {coverResult.CoverObject?.Name}]");
    }

    // ... damage calculation ...
}
```

### User-Facing Changes

**Grid Command with Terrain:**
```
> grid

Combat Grid                              [Turn 3]
===============================================

  A B C D E F G H
1 . . . . ~ ~ . .
2 . □ M . . M █ .
3 . . . ▲ . . . .
4 . . ▄ @ ▄ . . .
5 ~ ~ . . . ○ . .

Legend:
  @ = You (D4)       M = Monster
  . = Stone Floor    ~ = Rubble (2x move)
  □ = Wooden Crate   █ = Stone Pillar
  ▄ = Low Wall       ▲ = Fire (1d6)
  ○ = Pit (impassable)

Combatants:
  @ You (D4) - HP: 25/30 - Move: 3/4
  M Skeleton (C2) - HP: 10/10 [Behind crate: +2 def]
  M Skeleton (F2) - HP: 8/10 [Behind pillar: full cover]
```

**Attack with Cover Display:**
```
> attack skeleton

Which Skeleton?
  1. Skeleton at C2 [Behind Wooden Crate: +2 defense]
  2. Skeleton at F2 [Behind Stone Pillar: FULL COVER]

> 1

You fire your Longbow at the Skeleton at C2...

[Distance: 3 cells - in range]
[Target Cover: Wooden Crate (+2 defense)]
[Attack Roll: 2d6 + 3 = 14 vs AC 14 (12 + 2 cover)]
Hit! 7 damage to Skeleton.

The Skeleton's cover partially deflected your shot.
```

**Movement with Terrain Display:**
```
> move northeast

You carefully pick your way through the rubble...

[Movement: D4 → E3]
[Terrain: Rubble (difficult) - 2x movement cost]
[Movement Points: 4 → 1 remaining]
```

### Room Configuration with Terrain

```json
{
  "rooms": [
    {
      "id": "throne-room",
      "name": "Throne Room",
      "gridWidth": 8,
      "gridHeight": 8,
      "terrain": [
        { "positions": ["E1", "F1", "E5", "F5"], "terrainId": "rubble" },
        { "positions": ["D3"], "terrainId": "fire" },
        { "positions": ["F5"], "terrainId": "pit" }
      ],
      "cover": [
        { "position": "B2", "coverId": "wooden-crate" },
        { "position": "G2", "coverId": "stone-pillar" },
        { "positions": ["C4", "E4"], "coverId": "low-wall" }
      ]
    }
  ]
}
```

### Acceptance Criteria

- [ ] Grid displays terrain symbols correctly
- [ ] Grid displays cover symbols correctly
- [ ] Legend includes all terrain/cover on grid
- [ ] Combat calculates defense with cover bonus
- [ ] Full cover blocks targeting
- [ ] Movement shows terrain cost in output
- [ ] Hazard damage shows in movement result
- [ ] Room configuration loads terrain layout
- [ ] Room configuration loads cover layout
- [ ] Grid initialization applies terrain/cover
- [ ] Combatant list shows cover status
- [ ] ~25 unit tests pass

---

## Dependencies & Prerequisites

```
v0.5.1 (Range & Melee Combat) - REQUIRED
    │
    ├── v0.5.1a: Range Core ─────────────────────┐
    │       RangeType, RangeService              │
    │                                            │
    ├── v0.5.1b: Ranged Weapons ─────────────────┤
    │       Min range, penalties                 │
    │                                            │
    └── v0.5.1c: Line of Sight ──────────────────┘
            LineOfSightService, LOS blocking
                                                 │
v0.5.0 (Combat Grid Foundation) - REQUIRED       │
    │                                            │
    ├── CombatGrid, GridPosition, GridCell ──────┤
    ├── MovementService ─────────────────────────┤
    └── GridRenderer ────────────────────────────┘
                                                 │
                                                 ▼
v0.5.2 (Terrain & Cover)
    │
    ├── v0.5.2a: Terrain Core ─────────────────────────────┐
    │       Dependencies: v0.5.0 (GridCell, MovementService)│
    │       Provides: TerrainType, TerrainService          │
    │                                                      │
    ├── v0.5.2b: Cover System ─────────────────────────────┤
    │       Dependencies: v0.5.1c (LineOfSightService)     │
    │       Provides: CoverType, CoverObject, CoverService │
    │                                                      │
    └── v0.5.2c: Display & Integration ────────────────────┘
            Dependencies: v0.5.2a, v0.5.2b
            Provides: Terrain/cover rendering, combat integration
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.5.2a | ~4 | ~4 | ~30 | Medium |
| v0.5.2b | ~4 | ~3 | ~30 | High |
| v0.5.2c | ~1 | ~5 | ~25 | Medium |
| **Total** | **~9** | **~12** | **~85** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Terrain balance (too punishing) | Medium | Medium | Configurable costs and damage |
| Cover calculations complexity | Medium | Low | Clear direction-based rules |
| Grid rendering performance | Low | Low | Efficient cell iteration |
| Destructible cover exploits | Low | Medium | Balance HP values |
| LOS/cover interaction edge cases | Medium | Medium | Comprehensive unit tests |
| Room configuration complexity | Medium | Low | Clear JSON schema |

---

## Design Decisions (Confirmed)

### Terrain System

| Decision | Value | Notes |
|----------|-------|-------|
| **Difficult Cost** | 2x | Double movement points |
| **Hazard Damage** | On entry | Damage when first entering |
| **Impassable** | Block movement | Cannot enter at all |
| **Terrain Per Cell** | Single type | One terrain per cell |

### Cover System

| Decision | Value | Notes |
|----------|-------|-------|
| **Partial Cover Bonus** | +2 defense | Standard D&D-style |
| **Full Cover** | Untargetable | Cannot be attacked from blocked angle |
| **Cover Direction** | Line-based | Cover must be between attacker and target |
| **Destructible Default** | Configurable | Per cover type in JSON |

### Display System

| Decision | Value | Notes |
|----------|-------|-------|
| **Cover Priority** | Over terrain | Cover char shows instead of terrain |
| **Entity Priority** | Over cover | Entity char shows instead of cover |
| **Dynamic Legend** | Yes | Only show present terrain/cover |

---

## Integration Points

### From v0.5.0
- GridCell for terrain storage
- MovementService for cost integration
- GridRenderer for display

### From v0.5.1
- LineOfSightService for cover direction
- RangeService for attack validation
- GridCell.BlocksLOS for terrain LOS

### To v0.5.3 (Tactical Positioning)
- Terrain for opportunity attack triggers
- Cover for flanking calculations
- Grid state for AoE targeting

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.5.2a Design Spec** - Terrain core system
3. **Implement v0.5.2a** - Build terrain infrastructure
4. **v0.5.2b Design Spec** - Cover system
5. **Implement v0.5.2b** - Build cover mechanics
6. **v0.5.2c Design Spec** - Display and integration
7. **Implement v0.5.2c** - Complete rendering and combat integration

---

*This scope breakdown provides a structured approach to implementing v0.5.2 Terrain & Cover. Each sub-phase builds on the previous, adding environmental tactical depth to the combat grid system.*
