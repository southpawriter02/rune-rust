# v0.2.4: The Adversary's Arsenal

> **Status:** Complete
> **Milestone:** 3 - The Warrior
> **Theme:** Enemy abilities, tactical AI, and telegraphed attacks

## Table of Contents
- [Overview](#overview)
- [Phase A: The Loadout (Data Integration)](#phase-a-the-loadout-data-integration)
- [Phase B: The Tactician (Selection Logic)](#phase-b-the-tactician-selection-logic)
- [Phase C: The Omen (Telegraphs & Chants)](#phase-c-the-omen-telegraphs--chants)
- [Testing Strategy](#testing-strategy)
- [Draft Changelog](#draft-changelog)

## Overview

This version bridges the gap between the Ability System (v0.2.3) and the Enemy AI (v0.2.2). It grants enemies access to Active Abilities, allowing them to use the same EffectScript engine as players, while introducing AI logic to select those abilities intelligently.

- **Phase A: The Loadout** - Data integration for enemy abilities
- **Phase B: The Tactician** - Utility-based AI selection logic
- **Phase C: The Omen** - Telegraphs and multi-turn chant attacks

---

## Phase A: The Loadout (Data Integration)

**Goal:** Establish the Many-to-Many relationship between Enemies and Abilities, seed enemy-specific skills, and update the instantiation pipeline to hydrate enemies with their combat loadouts.

### 1. Architecture & Data Flow

**The Hydration Pipeline**

We must bridge the gap between the static EnemyTemplate (blueprint) and the dynamic Combatant (runtime entity).

1. **Definition (Seeding):** EnemyTemplate now includes a list of AbilityNames (strings).
2. **Resolution (Factory):** When EnemyFactory.CreateFromTemplate() is called:
   - The factory injects IActiveAbilityRepository.
   - It queries the repository for abilities matching the template's list.
   - It populates the Enemy.Abilities collection.
3. **Adaptation (Combat):** When Combatant.FromEnemy() is called:
   - It copies Enemy.Abilities into Combatant.Abilities.
   - The CombatService can now access these abilities for AI decision-making.

**Data Schema:**
- **ActiveAbilities Table:** Already exists (v0.2.3c).
- **EnemyAbilities Join Table (Implicit):** Managed in the Enemy entity logic rather than a strict DB join table.

### 2. Logic Decision Trees

**A. Enemy Creation Logic (Factory Level)**
Input: TemplateID ("und_draugr_01"), PartyLevel
1. Fetch Template: Retrieve EnemyTemplate record.
2. Create Base Enemy: Instantiate Enemy object with scaled stats (v0.2.2a logic).
3. Check Ability Definition: Does Template have AbilityNames?
   - No: Assign default "Basic Attack" ability.
   - Yes: Iterate through names.
4. Repository Lookup: Does ability exist in DB?
   - Yes: Add to Enemy.Abilities.
   - No: Log Warning ("Template references missing ability"), skip.
5. Return: Fully hydrated Enemy.

**B. Fallback Logic**
Input: Enemy with empty Ability list
1. Validation: Combatant.FromEnemy checks ability count.
2. Correction: If count == 0:
   - Inject generic "Strike" ability (Cost: 0, Damage: WeaponDice).
   - Log Warning ("Enemy spawned without abilities").

### 3. Code Implementation

**File:** `RuneAndRust.Core/Models/Combat/EnemyTemplate.cs`
```csharp
public record EnemyTemplate(
    string Id,
    string Name,
    // ... existing properties ...
    List<string> AbilityNames // NEW: List of ability names to look up
);
```

**File:** `RuneAndRust.Core/Entities/Enemy.cs`
```csharp
public class Enemy
{
    // ... existing properties ...

    // NEW: The abilities this specific enemy instance can use
    public List<ActiveAbility> Abilities { get; set; } = new();
}
```

**File:** `RuneAndRust.Engine/Factories/EnemyFactory.cs`
```csharp
public class EnemyFactory : IEnemyFactory
{
    private readonly IActiveAbilityRepository _abilityRepo;

    public async Task<Enemy> CreateFromTemplateAsync(EnemyTemplate template, int partyLevel)
    {
        var enemy = new Enemy
        {
            Name = template.Name,
            // ... apply scaling logic ...
        };

        // Hydrate Abilities
        if (template.AbilityNames != null && template.AbilityNames.Any())
        {
            foreach (var abilityName in template.AbilityNames)
            {
                var ability = await _abilityRepo.GetByNameAsync(abilityName);
                if (ability != null)
                {
                    enemy.Abilities.Add(ability);
                }
                else
                {
                    _logger.LogWarning("Missing ability '{Ability}' for enemy '{Enemy}'", abilityName, template.Id);
                }
            }
        }

        // Ensure at least one ability exists (Fallback)
        if (!enemy.Abilities.Any())
        {
             // Logic to add a default "Attack" ability
        }

        return enemy;
    }
}
```

**File:** `RuneAndRust.Persistence/Data/AbilitySeeder.cs`
```csharp
// Adding Enemy-specific abilities
new ActiveAbility
{
    Name = "Rusty Cleave",
    Archetype = ArchetypeType.Warrior,
    Tier = 1,
    Cost = 15,
    ResourceType = ResourceType.Stamina,
    EffectScript = "DAMAGE:Physical:1d8+2;STATUS:Tetanus:3"
},
new ActiveAbility
{
    Name = "Sonic Screech",
    Archetype = ArchetypeType.Mystic,
    Tier = 2,
    Cost = 20,
    ResourceType = ResourceType.Stamina,
    EffectScript = "DAMAGE:Psychic:1d6;STATUS:Disoriented:2"
}
```

### 4. Logging Matrix

| System | Event | Level | Message Template | Properties |
|---|---|---|---|---|
| Factory | Hydration Start | Debug | "Hydrating abilities for {Enemy}: {Count} templates found." | Enemy, Count |
| Factory | Ability Added | Trace | "Added ability {Ability} to {Enemy}." | Ability, Enemy |
| Factory | Missing Ability | Warning | "Template {Template} references missing ability {Ability}." | Template, Ability |
| Combat | Adapter Sync | Trace | "Synced {Count} abilities from Enemy to Combatant." | Count |

### 5. Testing Requirements

**Unit Tests (EnemyFactoryTests.cs)**
- Hydration_LoadsAbilities: Mock repository, verify abilities added.
- Hydration_SkipsMissing: Repository returns null, verify no nulls in list.
- Fallback_EnsureBasicAttack: Empty abilities -> default "Attack" added.

**Integration Tests (EnemyPersistenceTests.cs)**
- Seeding_VerifyEnemyAbilities: Run Seeder, query DB, verify abilities exist.

### 6. Deliverable Checklist (Phase A)

- [x] Core: Update EnemyTemplate record with AbilityNames.
- [x] Core: Update Enemy entity with List<ActiveAbility>.
- [x] Core: Update Combatant.FromEnemy to copy abilities.
- [x] Engine: Update EnemyFactory to inject IActiveAbilityRepository.
- [x] Engine: Implement async hydration logic in CreateFromTemplateAsync.
- [x] Data: Update AbilitySeeder with 5-10 enemy abilities.
- [x] Data: Update EnemySeeder (Templates) to reference new abilities.
- [x] Tests: Update existing Factory tests to mock the new repo dependency.
- [x] Tests: Add hydration unit tests.

---

## Phase B: The Tactician (Selection Logic)

**Goal:** Implement utility scoring for enemy abilities, enabling the AI to intelligently select between Basic Attacks, Defending, Fleeing, and using Active Abilities based on Archetype, Resources, and Cooldowns.

### 1. Architecture & Data Flow

The AI moves from a Probabilistic State Machine (v0.2.2b) to a Utility Scoring System.

1. **Trigger:** CombatService calls EnemyAIService.DetermineAction at the start of an enemy turn.
2. **Filter:** The service identifies all valid actions (Basic Attack, Defend, Flee, plus all Abilities where CanUse is true).
3. **Evaluation:** Each valid action is assigned a Utility Score (0-100) based on the enemy's Archetype and Combat State.
4. **Selection:** The AI performs a weighted random selection favoring high-scoring actions.
5. **Execution:** The resulting CombatAction payload is returned to the CombatService for execution.

### 2. Logic Decision Trees

**A. Utility Scoring Logic**
Input: Enemy (Archetype), Ability, Target (Player)
- **Base Score:** 50 (Neutral).
- **Healing Abilities:**
  - If Self HP < 30%: Score += 50 (Critical Priority).
  - If Self HP > 80%: Score -= 40 (Wasteful).
- **Damage Abilities:**
  - If Target HP < 20% (Kill Range): Score += 30.
  - If Ability Cost > 50% Current Stamina: Score -= 20 (Conservation).
- **Debuff Abilities:**
  - If Target already has Debuff: Score -= 100 (Redundant).
  - If Target is Immune: Score -= 100 (Useless).
- **Archetype Bias:**
  - Tank: Bonus to Defend/Buffs when HP < 50%.
  - GlassCannon: Bonus to High Damage abilities always.
  - Support: Bonus to Debuffs/Heals.

**B. Execution Pipeline**
Input: CombatAction
1. Type Check:
   - ActionType.Attack -> Use AttackResolutionService (Standard Logic).
   - ActionType.UseAbility -> New Path.
2. Ability Path:
   - Retrieve ActiveAbility from Combatant.Abilities using CombatAction.AbilityId.
   - Call AbilityService.Execute(User, Target, Ability).
   - Log narrative result.

### 3. Code Implementation

**File:** `RuneAndRust.Core/Models/Combat/CombatAction.cs`
```csharp
public record CombatAction(
    ActionType Type,
    Guid SourceId,
    Guid? TargetId = null,
    Guid? AbilityId = null, // Links to the specific ability to use
    string Description = ""
);
```

**File:** `RuneAndRust.Engine/Services/EnemyAIService.cs`
```csharp
public CombatAction DetermineAction(Combatant enemy, CombatState state)
{
    var validActions = new List<(CombatAction Action, int Score)>();
    var player = state.TurnOrder.First(c => c.IsPlayer);

    // 1. Evaluate Basic Attack (Baseline)
    validActions.Add((new CombatAction(ActionType.Attack, enemy.Id, player.Id), 50));

    // 2. Evaluate Abilities
    foreach (var ability in enemy.Abilities)
    {
        if (!_abilityService.CanUse(enemy, ability)) continue;

        int score = CalculateAbilityScore(enemy, ability, player);
        validActions.Add((new CombatAction(ActionType.UseAbility, enemy.Id, player.Id, ability.Id), score));
    }

    // 3. Evaluate Defense (Tank Archetype Logic)
    if (enemy.Archetype == EnemyArchetype.Tank && enemy.CurrentHp < enemy.MaxHp / 2)
    {
        validActions.Add((new CombatAction(ActionType.Defend, enemy.Id), 70));
    }

    // 4. Weighted Selection
    return SelectBestAction(validActions);
}

private int CalculateAbilityScore(Combatant user, ActiveAbility ability, Combatant target)
{
    int score = 50;

    if (ability.EffectScript.Contains("HEAL"))
    {
        var hpPercent = (double)user.CurrentHp / user.MaxHp;
        if (hpPercent < 0.3) score += 50;
        else if (hpPercent > 0.8) score -= 40;
    }

    if (ability.EffectScript.Contains("STATUS"))
    {
        score += 20;
    }

    if (user.Archetype == EnemyArchetype.GlassCannon && ability.EffectScript.Contains("DAMAGE"))
    {
        score += 20;
    }

    return score;
}
```

**File:** `RuneAndRust.Engine/Services/CombatService.cs`
```csharp
public async Task ProcessEnemyTurnAsync(Combatant enemy)
{
    var action = enemy.PlannedAction ?? _aiService.DetermineAction(enemy, _gameState.CombatState!);

    switch (action.Type)
    {
        case ActionType.Attack:
            ExecuteEnemyAttack(enemy, target, AttackType.Standard);
            break;

        case ActionType.UseAbility:
            var ability = enemy.Abilities.First(a => a.Id == action.AbilityId);
            var result = _abilityService.Execute(enemy, target, ability);
            LogCombatEvent(result.Message);
            break;
    }

    NextTurn();
}
```

### 4. Logging Matrix

| System | Event | Level | Message Template | Properties |
|---|---|---|---|---|
| AI | Evaluation | Trace | "[AI] Evaluating {Ability}: Score {Score}" | Ability, Score |
| AI | Selection | Debug | "[AI] Selected {Action} (Ability: {AbilityId})" | Action, AbilityId |
| Combat | Ability Exec | Info | "{Enemy} uses {Ability} on {Target}!" | Enemy, Ability, Target |
| Combat | Resource | Trace | "{Enemy} spent {Cost} Stamina. Remaining: {Current}" | Enemy, Cost, Current |

### 5. Testing Requirements

**Unit Tests (EnemyAIServiceTests.cs)**
- Score_Heal_CriticalHP: Enemy HP at 10%, verify Heal selected.
- Score_Cooldown_Filtering: Ability A on cooldown, verify Ability B selected.
- Score_Archetype_Bias: GlassCannon enemy, verify "Big Hit" has higher score.

**Integration Tests (CombatLoopTests.cs)**
- Execution_Flow: Force AI to select Ability, verify execution and logging.

### 6. Deliverable Checklist (Phase B)

- [x] Core: Update CombatAction to include nullable AbilityId.
- [x] Core: Ensure Combatant adapter exposes Abilities list correctly.
- [x] Engine: Update EnemyAIService to implement Scoring Logic.
- [x] Engine: Implement SelectBestAction weighted randomizer.
- [x] Engine: Update CombatService.ProcessEnemyTurnAsync to handle ActionType.UseAbility.
- [x] Engine: Ensure Enemy resource regeneration happens in NextTurn.
- [x] Tests: Add unit tests for scoring heuristics.
- [x] Tests: Add integration test for enemy ability usage.

---

## Phase C: The Omen (Telegraphs & Chants)

**Goal:** Implement the TelegraphedAbilityService and integrate Chant logic into the Enemy AI. Enemies must clearly broadcast powerful attacks one turn in advance via narrative logs, giving players a window to react.

### 1. Architecture & Data Flow

**The Charge-Release Cycle**

1. **AI Decision:** The EnemyAIService selects a high-impact ability tagged with ChargeTurns > 0.
2. **Initiation (Turn 1):**
   - The CombatService detects the charge requirement.
   - Instead of dealing damage immediately, it applies the [Chanting] or [Charging] status to the enemy.
   - The Omen: A specific TelegraphMessage is logged (e.g., "The Construct's core begins to glow violent red.").
3. **Interruption Window (Player Turn):**
   - The enemy is effectively "Stunned" (cannot dodge/parry) but often gains [Fortified].
   - If the enemy takes damage > InterruptThreshold, the Charge is broken.
4. **Execution (Turn 2):**
   - The AI detects it is [Chanting].
   - It forces the execution of the stored payload (The "Release").
   - The Ability resolves (Damage/Status).

### 2. Logic Decision Trees

**A. AI Planning Logic (Chant Awareness)**
Input: Enemy Combatant
1. Check Status: Is Enemy [Chanting]?
   - Yes: Force Action -> CompleteChant. (Do not evaluate other abilities).
   - No: Proceed to standard Utility Scoring (Phase B).
2. Scoring Modification for Charge Abilities:
   - Base Score: High (70+).
   - Risk Penalty: If Enemy HP < 30% -> Score -50 (Too risky to stand still).
   - Opportunity Bonus: If Player is [Stunned] -> Score +30 (Free hit).

**B. Interruption Logic**
Input: DamageTaken Event
1. Check Status: Is Victim [Chanting]?
   - No: Proceed standard damage.
   - Yes:
     1. Calculate Threshold: MaxHP * 0.10 (10% HP damage to break).
     2. Compare: Is Damage > Threshold?
        - Yes: Remove [Chanting]. Log "Interrupted!". Apply [Stunned] (1 turn).
        - No: Log "The enemy maintains focus through the pain."

### 3. Code Implementation

**File:** `RuneAndRust.Core/Entities/ActiveAbility.cs`
```csharp
public class ActiveAbility
{
    // ... existing properties ...

    // v0.2.4c additions
    public int ChargeTurns { get; set; } = 0; // 0 = Instant
    public string? TelegraphMessage { get; set; } // "The enemy winds up..."
    public int InterruptThreshold { get; set; } = 10; // Damage needed to break
}
```

**File:** `RuneAndRust.Engine/Services/EnemyAIService.cs`
```csharp
public CombatAction DetermineAction(Combatant enemy, CombatState state)
{
    // 1. Check for active Chant (Forced Action)
    if (enemy.HasStatus(StatusEffectType.Chanting))
    {
        return new CombatAction(ActionType.UseAbility, enemy.Id, null,
            AbilityId: enemy.ChanneledAbilityId,
            FlavorText: "unleashes the charged energy!");
    }

    // 2. Standard Scoring...
}
```

### 4. Logging Matrix

| System | Event | Level | Message Template | Properties |
|---|---|---|---|---|
| Combat | Telegraph | Info | "{Enemy} {TelegraphMessage} (Charging)" | Enemy, Message |
| Combat | Release | Info | "{Enemy} finishes charging and casts {Ability}!" | Enemy, Ability |
| Combat | Interrupted | Warning | "{Enemy}'s concentration is BROKEN by the blow!" | Enemy |
| AI | Locked | Trace | "[AI] {Enemy} is Chanting. Forcing execution." | Enemy |

### 5. Testing Strategy

**Unit Tests (TelegraphedAbilityTests.cs)**
- Charge_Initiation: Enemy uses Sunder Earth (Charge: 1), verify [Chanting] applied, no immediate damage.
- Charge_Completion: Enemy starts turn with [Chanting], verify ability executes, status removed.
- Interruption_Success: Enemy is [Chanting] (Threshold: 10), apply 12 Damage, verify [Chanting] removed and [Stunned] applied.

### 6. Deliverable Checklist (Phase C)

- [x] Core: Update ActiveAbility entity with ChargeTurns and TelegraphMessage.
- [x] Core: Add Chanting to StatusEffectType enum.
- [x] Engine: Implement TelegraphedAbilityService.
- [x] Engine: Update EnemyAIService to handle the "Locked in Chant" state.
- [x] Engine: Update CombatService to handle Interruption checks during damage calculation.
- [x] Data: Seed "Heavy" enemy abilities (e.g., Sunder Earth, Core Vent).
- [x] Tests: AI_Continues_Chant_Next_Turn.
- [x] Tests: Damage_Interrupts_Chant.

---

## Testing Strategy

### Unit Tests

**EnemyAIServiceTests.cs:**
- DetermineAction_PrefersHeal_WhenLowHP: Set Enemy HP to 10%, verify Heal selected.
- DetermineAction_RespectsCooldowns: Put Ability A on cooldown, verify Ability B or Attack selected.

**CombatChantTests.cs:**
- Chant_Executes_AfterDelay: Start Chant -> Next Turn -> Effect Applied.
- Chant_Interrupted_ByDamage: Start Chant -> Deal 20 Dmg -> Verify Chant cleared and Effect NOT applied.

---

## Draft Changelog

```markdown
# Changelog: v0.2.4 - The Adversary's Arsenal
**Release Date:** 2025-XX-XX

## Summary
"The Adversary's Arsenal" gives enemies access to the full range of combat mechanics previously reserved for players. Enemies now spawn with specific ability loadouts defined by their template and use AI logic to select the best move for the situation. This update also introduces "Chants"â€”powerful, telegraphed attacks that require players to defend or interrupt.

## Features
- **Enemy Abilities:**
    - Enemies now use Stamina/Aether to cast abilities.
    - Added unique movesets for Draugr (Sunder Armor), Servitors (Repair), and Vargr (Howl).
- **Smart AI:**
    - Enemies evaluate HP, Cooldowns, and Status Effects before acting.
    - Healers will prioritize wounded allies; Strikers will target vulnerable players.
- **Chant System:**
    - Powerful attacks now require 1+ turns to charge.
    - Visual indicators warn players of incoming heavy hits.
    - Dealing sufficient damage interrupts the chant, stunning the enemy.

## Technical
- Extended `EnemyTemplate` to include Ability IDs.
- Refactored `EnemyAIService` to score actions based on utility.
- Added Chant state management to `CombatService`.
```

---

*This completes Milestone 3 - The Warrior. Next: v0.3.0 - The Survivor (Trauma Economy)*
