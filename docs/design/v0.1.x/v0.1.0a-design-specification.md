# v0.1.0a Design Specification: Z-Axis Foundation

**Version:** 0.1.0a
**Phase Name:** Z-Axis Foundation
**Parent Version:** v0.1.0 (Expanded Dungeon & Z-Axis)
**Prerequisites:** v0.0.11 Complete (Descriptors & Ambience)
**Estimated Tests:** ~18 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Position3D Value Object](#4-position3d-value-object)
5. [Direction Enum Extension](#5-direction-enum-extension)
6. [StairType Enum](#6-stairtype-enum)
7. [Vertical Room Connections](#7-vertical-room-connections)
8. [Movement Commands](#8-movement-commands)
9. [Starter Dungeon Update](#9-starter-dungeon-update)
10. [Data Model Changes](#10-data-model-changes)
11. [Logging Specifications](#11-logging-specifications)
12. [Unit Testing Requirements](#12-unit-testing-requirements)
13. [Use Cases](#13-use-cases)
14. [Deliverable Checklist](#14-deliverable-checklist)
15. [Acceptance Criteria](#15-acceptance-criteria)
16. [Dependencies](#16-dependencies)
17. [Future Considerations](#17-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Extend the dungeon coordinate system to support vertical movement between dungeon levels. This foundational phase adds Up and Down directions to the existing cardinal directions, creates a Position3D value object to track three-dimensional coordinates, and enables rooms to connect vertically via stairs, ladders, and other vertical passages.

### 1.2 Current State

| Area | Current State (v0.0.11) | Target State (v0.1.0a) |
|------|-------------------------|------------------------|
| Position tracking | 2D (X, Y) via `Position` | 3D (X, Y, Z) via `Position3D` |
| Movement directions | 4 cardinal (N, S, E, W) | 6 directions (N, S, E, W, Up, Down) |
| Room connections | Horizontal only | Horizontal + vertical |
| Dungeon levels | Single level (Z=0) | Multiple levels (Z=0, 1, ...) |
| Starter dungeon | 5 rooms on single level | 7+ rooms across 2 levels |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Value Objects** | `Position3D` with X, Y, Z coordinates |
| **Enums** | `Direction` extension (Up, Down), `StairType` |
| **Entity Updates** | `Room` position migration, `Dungeon` vertical connections |
| **Commands** | `up`, `down`, `climb`, `descend` movement |
| **Tests** | ~18 new unit tests |

### 1.4 Architectural Significance

This version establishes the **vertical dungeon foundation** that enables all future multi-level features:
- Procedural generation across Z-levels (v0.1.0b)
- Depth-based difficulty scaling (v0.1.0b)
- Multi-level map display (v0.1.0d)
- Future 3D dungeon visualization

---

## 2. Feature Overview

```
v0.1.0a Z-Axis Foundation
├── Position3D Value Object
│   ├── X, Y, Z coordinate properties
│   ├── Move() with delta coordinates
│   ├── MoveUp() / MoveDown() helpers
│   └── Position2D conversion methods
├── Direction Enum Extension
│   ├── Add Up value (Z - 1)
│   ├── Add Down value (Z + 1)
│   └── Update GetOppositeDirection()
├── StairType Enum
│   ├── StairsUp
│   ├── StairsDown
│   ├── Ladder
│   ├── Shaft
│   └── Pit (one-way)
├── Vertical Room Connections
│   ├── Dungeon.ConnectRoomsVertically()
│   ├── Room exit support for Up/Down
│   └── Bidirectional vs one-way connections
├── Movement Commands
│   ├── up / climb commands
│   ├── down / descend commands
│   └── TryMove() extension for vertical
└── Starter Dungeon Update
    ├── Lower level (Z=1) rooms
    ├── Stairs connection to Level 0
    └── Depth-appropriate content
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  CommandParser                  GameView                                     │
│  ├── ParseDirection()           ├── RenderRoom()                            │
│  │   └── "up"/"down" → Direction│   └── Show vertical exits                 │
│  └── Parse("climb"/"descend")   └── DisplayExits()                          │
│                                     └── Include Up/Down                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  GameSessionService                                                          │
│  ├── TryMove(Direction)         // Extended for Up/Down                     │
│  │   ├── Validate exit exists                                               │
│  │   ├── Update player position (Position3D)                                │
│  │   └── Log vertical movement                                              │
│  └── GetExitsDescription()      // Include vertical exits                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Entities:                      Value Objects:           Enums:             │
│  ┌─────────────────────┐       ┌─────────────────────┐  ┌─────────────────┐ │
│  │ Room                │       │ Position3D // NEW   │  │ Direction       │ │
│  │ ├── Position3D      │       │ ├── X: int          │  │ ├── North       │ │
│  │ ├── Exits[Direction]│       │ ├── Y: int          │  │ ├── South       │ │
│  │ └── AddExit()       │       │ ├── Z: int          │  │ ├── East        │ │
│  └─────────────────────┘       │ ├── Move()          │  │ ├── West        │ │
│  ┌─────────────────────┐       │ ├── MoveUp()        │  │ ├── Up    // NEW│ │
│  │ Dungeon             │       │ ├── MoveDown()      │  │ └── Down  // NEW│ │
│  │ ├── ConnectRooms()  │       │ └── ToPosition2D()  │  └─────────────────┘ │
│  │ ├── GetOpposite()   │       └─────────────────────┘  ┌─────────────────┐ │
│  │ │   // Up ↔ Down    │                                │ StairType // NEW│ │
│  │ └── GetRoomByPos3D()│                                │ ├── StairsUp    │ │
│  └─────────────────────┘                                │ ├── StairsDown  │ │
│                                                         │ ├── Ladder      │ │
│  ┌─────────────────────┐                                │ ├── Shaft       │ │
│  │ Player              │                                │ └── Pit         │ │
│  │ └── Position3D      │                                └─────────────────┘ │
│  └─────────────────────┘                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Vertical Movement Flow

```
┌───────────────┐
│ Player Input  │
│ "down" / "up" │
└───────┬───────┘
        │
        ▼
┌───────────────────────────────────────┐
│ CommandParser.ParseDirection()        │
│ ├── "up" / "climb"    → Direction.Up  │
│ └── "down" / "descend"→ Direction.Down│
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────┐
│ GameSessionService.TryMove(direction) │
├───────────────────────────────────────┤
│ 1. Get current room                   │
│ 2. Check room.HasExit(direction)      │
│    ├── No exit? Return failure        │
│    └── Has exit? Continue             │
│ 3. Get target room ID from exit       │
│ 4. Update player position             │
│    └── Position3D with new Z          │
│ 5. Mark room as visited               │
│ 6. Return success message             │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────┐
│ Success: "You descend the stairs."    │
│ Failure: "There is no way down here." │
└───────────────────────────────────────┘
```

### 3.3 Position Coordinate System

```
                    North (+Y)
                        ↑
                        │
                        │
        West (-X) ──────┼────── East (+X)
                        │
                        │
                        ↓
                    South (-Y)

                    Surface (Z=0)
                        │
                        │ Down
                        ▼
                    Level 1 (Z=1)
                        │
                        │ Down
                        ▼
                    Level 2 (Z=2)
                       ...
                    Deeper Underground
```

**Coordinate Convention:**
- X: Horizontal (East = positive, West = negative)
- Y: Horizontal (North = positive, South = negative)
- Z: Vertical (Surface = 0, deeper = positive integers)

---

## 4. Position3D Value Object

### 4.1 Purpose

Replace the existing 2D `Position` value object with a 3D variant that includes Z-axis depth tracking for multi-level dungeon navigation.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/Position3D.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a 3D position in the dungeon grid.
/// </summary>
/// <remarks>
/// Position3D is an immutable value object used to track locations across
/// multiple dungeon levels. The Z coordinate represents depth, where 0 is
/// the surface/entrance level and positive values indicate deeper underground.
/// </remarks>
/// <param name="X">The horizontal coordinate (positive = east, negative = west).</param>
/// <param name="Y">The vertical coordinate on the map (positive = north, negative = south).</param>
/// <param name="Z">The depth coordinate (0 = surface, positive = deeper underground).</param>
public readonly record struct Position3D(int X, int Y, int Z)
{
    /// <summary>
    /// Gets the origin position (0, 0, 0), typically the starting room location.
    /// </summary>
    public static Position3D Origin => new(0, 0, 0);

    /// <summary>
    /// Creates a new position by moving from the current position.
    /// </summary>
    /// <param name="deltaX">The horizontal movement (positive = east, negative = west).</param>
    /// <param name="deltaY">The map vertical movement (positive = north, negative = south).</param>
    /// <param name="deltaZ">The depth movement (positive = deeper, negative = shallower).</param>
    /// <returns>A new Position3D at the resulting coordinates.</returns>
    public Position3D Move(int deltaX, int deltaY, int deltaZ) =>
        new(X + deltaX, Y + deltaY, Z + deltaZ);

    /// <summary>
    /// Creates a new position one level up (toward the surface).
    /// </summary>
    /// <returns>A new Position3D at Z - 1.</returns>
    public Position3D MoveUp() => new(X, Y, Z - 1);

    /// <summary>
    /// Creates a new position one level down (deeper underground).
    /// </summary>
    /// <returns>A new Position3D at Z + 1.</returns>
    public Position3D MoveDown() => new(X, Y, Z + 1);

    /// <summary>
    /// Creates a new position by moving in a cardinal direction.
    /// </summary>
    /// <param name="direction">The direction to move.</param>
    /// <returns>A new Position3D at the resulting coordinates.</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when direction is invalid.</exception>
    public Position3D Move(Direction direction) => direction switch
    {
        Direction.North => new(X, Y + 1, Z),
        Direction.South => new(X, Y - 1, Z),
        Direction.East => new(X + 1, Y, Z),
        Direction.West => new(X - 1, Y, Z),
        Direction.Up => MoveUp(),
        Direction.Down => MoveDown(),
        _ => throw new ArgumentOutOfRangeException(nameof(direction), direction, "Invalid direction")
    };

    /// <summary>
    /// Converts this 3D position to a 2D position (discarding Z).
    /// </summary>
    /// <returns>A Position with the same X and Y coordinates.</returns>
    public Position ToPosition2D() => new(X, Y);

    /// <summary>
    /// Creates a Position3D from a 2D position with the specified Z level.
    /// </summary>
    /// <param name="position">The 2D position.</param>
    /// <param name="z">The Z level (default 0 = surface).</param>
    /// <returns>A new Position3D with the specified coordinates.</returns>
    public static Position3D FromPosition2D(Position position, int z = 0) =>
        new(position.X, position.Y, z);

    /// <summary>
    /// Gets the Manhattan distance to another position.
    /// </summary>
    /// <param name="other">The other position.</param>
    /// <returns>The sum of absolute differences in X, Y, and Z.</returns>
    public int ManhattanDistanceTo(Position3D other) =>
        Math.Abs(X - other.X) + Math.Abs(Y - other.Y) + Math.Abs(Z - other.Z);

    /// <summary>
    /// Returns a string representation of this position.
    /// </summary>
    /// <returns>A formatted string showing the X, Y, and Z coordinates.</returns>
    public override string ToString() => $"({X}, {Y}, Z={Z})";
}
```

### 4.3 Migration Strategy

The existing `Position` value object will be **retained for backwards compatibility** in areas that don't require Z-axis support. However, all dungeon and room-related code will migrate to `Position3D`:

1. `Room.Position` property type changes from `Position` to `Position3D`
2. `Player.Position` property type changes from `Position` to `Position3D`
3. `Dungeon.GetRoomByPosition()` overloaded for both types
4. Conversion methods allow interop between 2D and 3D positions

---

## 5. Direction Enum Extension

### 5.1 Purpose

Add Up and Down values to the existing Direction enum to support vertical movement between dungeon levels.

### 5.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/Direction.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the directions for movement within the dungeon.
/// </summary>
/// <remarks>
/// Directions are used for navigating between rooms and establishing exits.
/// The dungeon uses a 3D grid system where North increases Y, South decreases Y,
/// East increases X, West decreases X, Up decreases Z (toward surface), and
/// Down increases Z (deeper underground).
/// </remarks>
public enum Direction
{
    /// <summary>
    /// Movement toward positive Y coordinates (up on the map).
    /// </summary>
    North = 0,

    /// <summary>
    /// Movement toward negative Y coordinates (down on the map).
    /// </summary>
    South = 1,

    /// <summary>
    /// Movement toward positive X coordinates (right on the map).
    /// </summary>
    East = 2,

    /// <summary>
    /// Movement toward negative X coordinates (left on the map).
    /// </summary>
    West = 3,

    /// <summary>
    /// Movement toward the surface (Z - 1). Used for stairs, ladders going up.
    /// </summary>
    Up = 4,

    /// <summary>
    /// Movement deeper underground (Z + 1). Used for stairs, ladders going down.
    /// </summary>
    Down = 5
}
```

### 5.3 Explicit Values

Explicit integer values are assigned to ensure serialization stability and prevent issues if the enum is persisted or transmitted.

---

## 6. StairType Enum

### 6.1 Purpose

Define the types of vertical connections between dungeon levels. Different stair types provide flavor text variety and may have gameplay implications in future versions.

### 6.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/StairType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of vertical connections between dungeon levels.
/// </summary>
/// <remarks>
/// Different stair types provide varied descriptions and may have
/// gameplay implications such as requiring climbing checks or being
/// one-way passages.
/// </remarks>
public enum StairType
{
    /// <summary>
    /// Standard stone stairs ascending to a higher level.
    /// </summary>
    StairsUp = 0,

    /// <summary>
    /// Standard stone stairs descending to a lower level.
    /// </summary>
    StairsDown = 1,

    /// <summary>
    /// A vertical wooden or metal ladder.
    /// </summary>
    Ladder = 2,

    /// <summary>
    /// An open vertical shaft, may require climbing skill.
    /// </summary>
    Shaft = 3,

    /// <summary>
    /// A one-way drop to a lower level (cannot ascend).
    /// </summary>
    Pit = 4,

    /// <summary>
    /// A spiral staircase winding up or down.
    /// </summary>
    SpiralStairs = 5,

    /// <summary>
    /// A magical portal or teleporter between levels.
    /// </summary>
    Portal = 6
}
```

### 6.3 Stair Type Properties

| Type | Bidirectional | Description Text |
|------|---------------|------------------|
| StairsUp | Yes | "A stone staircase leads upward." |
| StairsDown | Yes | "A stone staircase leads downward." |
| Ladder | Yes | "A wooden ladder extends {direction}." |
| Shaft | Yes* | "An open shaft drops into darkness." |
| Pit | **No** | "A pit yawns beneath you." (down only) |
| SpiralStairs | Yes | "A spiral staircase winds {direction}." |
| Portal | Yes | "A shimmering portal glows {direction}." |

*Shaft may require climbing check in future versions.

---

## 7. Vertical Room Connections

### 7.1 Dungeon Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Dungeon.cs`

#### 7.1.1 GetOppositeDirection Update

```csharp
/// <summary>
/// Gets the opposite direction.
/// </summary>
/// <param name="direction">The direction to reverse.</param>
/// <returns>The opposite direction (North↔South, East↔West, Up↔Down).</returns>
/// <exception cref="ArgumentOutOfRangeException">Thrown when direction is invalid.</exception>
public static Direction GetOppositeDirection(Direction direction) => direction switch
{
    Direction.North => Direction.South,
    Direction.South => Direction.North,
    Direction.East => Direction.West,
    Direction.West => Direction.East,
    Direction.Up => Direction.Down,
    Direction.Down => Direction.Up,
    _ => throw new ArgumentOutOfRangeException(nameof(direction), direction, "Invalid direction")
};
```

#### 7.1.2 ConnectRoomsVertically Method

```csharp
/// <summary>
/// Creates a vertical connection between two rooms with stair type metadata.
/// </summary>
/// <param name="upperRoomId">The ID of the room at the higher Z level (lower Z value).</param>
/// <param name="lowerRoomId">The ID of the room at the lower Z level (higher Z value).</param>
/// <param name="stairType">The type of vertical connection.</param>
/// <exception cref="ArgumentException">Thrown when room IDs are invalid or Z levels are incorrect.</exception>
public void ConnectRoomsVertically(Guid upperRoomId, Guid lowerRoomId, StairType stairType)
{
    if (!_rooms.TryGetValue(upperRoomId, out var upperRoom))
        throw new ArgumentException($"Upper room {upperRoomId} not found", nameof(upperRoomId));
    if (!_rooms.TryGetValue(lowerRoomId, out var lowerRoom))
        throw new ArgumentException($"Lower room {lowerRoomId} not found", nameof(lowerRoomId));

    // Validate Z-level relationship
    if (upperRoom.Position.Z >= lowerRoom.Position.Z)
        throw new ArgumentException(
            $"Upper room Z ({upperRoom.Position.Z}) must be less than lower room Z ({lowerRoom.Position.Z})");

    // Add bidirectional connection (unless it's a pit)
    upperRoom.AddExit(Direction.Down, lowerRoomId);

    if (stairType != StairType.Pit)
    {
        lowerRoom.AddExit(Direction.Up, upperRoomId);
    }

    // Store stair type metadata (for description generation)
    _verticalConnections[(upperRoomId, lowerRoomId)] = stairType;
}

private readonly Dictionary<(Guid, Guid), StairType> _verticalConnections = [];

/// <summary>
/// Gets the stair type for a vertical connection between rooms.
/// </summary>
/// <param name="fromRoomId">The source room ID.</param>
/// <param name="toRoomId">The destination room ID.</param>
/// <returns>The stair type if found; otherwise, null.</returns>
public StairType? GetStairType(Guid fromRoomId, Guid toRoomId)
{
    if (_verticalConnections.TryGetValue((fromRoomId, toRoomId), out var type))
        return type;
    if (_verticalConnections.TryGetValue((toRoomId, fromRoomId), out type))
        return type;
    return null;
}
```

#### 7.1.3 GetRoomByPosition3D Method

```csharp
/// <summary>
/// Retrieves a room by its 3D grid position.
/// </summary>
/// <param name="position">The 3D position to search for.</param>
/// <returns>The room at the specified position if found; otherwise, null.</returns>
public Room? GetRoomByPosition(Position3D position) =>
    _rooms.Values.FirstOrDefault(r => r.Position.Equals(position));

/// <summary>
/// Checks if a room exists at the specified 3D position.
/// </summary>
/// <param name="position">The 3D position to check.</param>
/// <returns>True if a room exists at the position; otherwise, false.</returns>
public bool HasRoomAt(Position3D position) =>
    _rooms.Values.Any(r => r.Position.Equals(position));
```

### 7.2 Room Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

#### 7.2.1 Position Property Migration

```csharp
/// <summary>
/// Gets the 3D position of this room in the dungeon grid.
/// </summary>
public Position3D Position { get; private set; }

/// <summary>
/// Creates a new room with the specified name, description, and 3D position.
/// </summary>
/// <param name="name">The display name of the room.</param>
/// <param name="description">The narrative description shown to players.</param>
/// <param name="position">The 3D position of this room in the dungeon grid.</param>
/// <exception cref="ArgumentNullException">Thrown when name or description is null.</exception>
public Room(string name, string description, Position3D position)
{
    Id = Guid.NewGuid();
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Description = description ?? throw new ArgumentNullException(nameof(description));
    Position = position;
}

/// <summary>
/// Creates a new room with the specified name, description, and 2D position (Z defaults to 0).
/// </summary>
/// <remarks>
/// This constructor is provided for backwards compatibility with existing code
/// that uses 2D positions. The Z coordinate defaults to 0 (surface level).
/// </remarks>
[Obsolete("Use the Position3D constructor for new code. This exists for backwards compatibility.")]
public Room(string name, string description, Position position)
    : this(name, description, Position3D.FromPosition2D(position))
{
}
```

#### 7.2.2 Enhanced GetExitsDescription

```csharp
/// <summary>
/// Gets a human-readable description of the exits from this room.
/// </summary>
/// <returns>A string describing available exits, including vertical directions.</returns>
public string GetExitsDescription()
{
    if (_exits.Count == 0)
        return "There are no visible exits.";

    var horizontalExits = _exits.Keys
        .Where(d => d is Direction.North or Direction.South or Direction.East or Direction.West)
        .Select(d => d.ToString().ToLower());

    var verticalExits = _exits.Keys
        .Where(d => d is Direction.Up or Direction.Down)
        .Select(d => d == Direction.Up ? "up" : "down");

    var allExits = horizontalExits.Concat(verticalExits).ToList();

    return $"Exits: {string.Join(", ", allExits)}";
}
```

---

## 8. Movement Commands

### 8.1 Command Aliases

| Command | Direction | Aliases |
|---------|-----------|---------|
| `up` | Direction.Up | `climb`, `ascend`, `u` |
| `down` | Direction.Down | `descend`, `d` |

### 8.2 GameSessionService Updates

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

The existing `TryMove(Direction direction)` method already handles any direction value. The primary changes are:

1. **Logging enhancement** for vertical movement
2. **Message formatting** for vertical exits

```csharp
/// <summary>
/// Gets a descriptive message for successful movement.
/// </summary>
private string GetMoveMessage(Direction direction, Room targetRoom, StairType? stairType)
{
    // Vertical movement messages
    if (direction == Direction.Up)
    {
        return stairType switch
        {
            StairType.Ladder => $"You climb up the ladder to {targetRoom.Name}.",
            StairType.SpiralStairs => $"You ascend the spiral staircase to {targetRoom.Name}.",
            StairType.Portal => $"You step through the portal and emerge in {targetRoom.Name}.",
            StairType.Shaft => $"You climb up the shaft to {targetRoom.Name}.",
            _ => $"You climb the stairs to {targetRoom.Name}."
        };
    }

    if (direction == Direction.Down)
    {
        return stairType switch
        {
            StairType.Ladder => $"You climb down the ladder to {targetRoom.Name}.",
            StairType.SpiralStairs => $"You descend the spiral staircase to {targetRoom.Name}.",
            StairType.Portal => $"You step through the portal and emerge in {targetRoom.Name}.",
            StairType.Pit => $"You drop down the pit to {targetRoom.Name}.",
            StairType.Shaft => $"You climb down the shaft to {targetRoom.Name}.",
            _ => $"You descend the stairs to {targetRoom.Name}."
        };
    }

    // Horizontal movement (existing behavior)
    return $"You head {direction.ToString().ToLower()}.";
}
```

### 8.3 CommandParser Updates

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Handlers/CommandParser.cs`

```csharp
/// <summary>
/// Parses directional commands including vertical movement.
/// </summary>
private static Direction? ParseDirection(string input)
{
    return input.ToLowerInvariant() switch
    {
        "north" or "n" => Direction.North,
        "south" or "s" => Direction.South,
        "east" or "e" => Direction.East,
        "west" or "w" => Direction.West,
        "up" or "u" or "climb" or "ascend" => Direction.Up,
        "down" or "d" or "descend" => Direction.Down,
        _ => null
    };
}
```

---

## 9. Starter Dungeon Update

### 9.1 Level Layout

**Level 0 (Surface) - Existing rooms with position updates:**
```
        Dungeon Passage (0, 2, 0)
              │
           Armory (0, 1, 0)
              │
Storage ─ Entrance ─ Library
(-1,0,0)   (0,0,0)   (1,0,0)
```

**Level 1 (Underground) - New rooms:**
```
        Forgotten Crypt (0, 1, 1)
              │
        Underground Lake (0, 0, 1) ── Crystal Cavern (1, 0, 1)
```

### 9.2 Vertical Connection

Stairs down from **Dungeon Passage** (0, 2, 0) to **Forgotten Crypt** (0, 1, 1).

### 9.3 Updated CreateStarterDungeon

```csharp
/// <summary>
/// Factory method that creates a pre-configured starter dungeon for new games.
/// </summary>
/// <returns>A new Dungeon with rooms across two levels.</returns>
public static Dungeon CreateStarterDungeon()
{
    var dungeon = new Dungeon("The Forgotten Depths");

    // ===== Level 0 (Surface) =====
    var entrance = new Room(
        "Entrance Hall",
        "A dimly lit hall with ancient stone walls. Cobwebs hang from the ceiling, and the air smells of dust and decay. Faded torches line the walls, barely providing enough light to see.",
        new Position3D(0, 0, 0)
    );

    var armory = new Room(
        "Armory",
        "Weapon racks line the walls, most of them empty. A few rusty weapons remain scattered on the floor. An old armor stand stands in the corner, its occupant long gone.",
        new Position3D(0, 1, 0)
    );
    armory.AddItem(Item.CreateSword());

    var library = new Room(
        "Ancient Library",
        "Towering bookshelves reach toward the shadowy ceiling. Most books have crumbled to dust, but a few ancient tomes remain. A reading desk sits in the center, covered in dust.",
        new Position3D(1, 0, 0)
    );
    library.AddItem(Item.CreateScroll());

    var storage = new Room(
        "Storage Room",
        "Crates and barrels fill this cluttered room. Most contain nothing but rotten supplies, but some treasures might remain hidden among the debris.",
        new Position3D(-1, 0, 0)
    );
    storage.AddItem(Item.CreateHealthPotion());

    var passage = new Room(
        "Dungeon Passage",
        "A narrow corridor stretches into darkness. Strange scratching sounds echo from deeper within. The walls are covered in mysterious runes that seem to pulse with faint light. A worn stone staircase descends into the depths.",
        new Position3D(0, 2, 0)
    );
    passage.AddMonster(Monster.CreateGoblin());

    // ===== Level 1 (Underground) =====
    var crypt = new Room(
        "Forgotten Crypt",
        "Ancient stone sarcophagi line the walls of this dusty chamber. Faded inscriptions hint at the nobles buried here centuries ago. A cold draft rises from deeper tunnels.",
        new Position3D(0, 1, 1)
    );

    var lake = new Room(
        "Underground Lake",
        "A vast underground lake stretches before you, its waters black and still. Bioluminescent fungi on the ceiling cast an eerie blue glow across the cavern.",
        new Position3D(0, 0, 1)
    );
    lake.AddItem(Item.CreateHealthPotion());

    var cavern = new Room(
        "Crystal Cavern",
        "Massive crystals jut from the walls and ceiling, refracting what little light exists into dancing rainbows. The air here feels charged with ancient magic.",
        new Position3D(1, 0, 1)
    );

    // Add all rooms
    dungeon.AddRoom(entrance, isStartingRoom: true);
    dungeon.AddRoom(armory);
    dungeon.AddRoom(library);
    dungeon.AddRoom(storage);
    dungeon.AddRoom(passage);
    dungeon.AddRoom(crypt);
    dungeon.AddRoom(lake);
    dungeon.AddRoom(cavern);

    // Connect Level 0 rooms (horizontal)
    dungeon.ConnectRooms(entrance.Id, Direction.North, armory.Id);
    dungeon.ConnectRooms(entrance.Id, Direction.East, library.Id);
    dungeon.ConnectRooms(entrance.Id, Direction.West, storage.Id);
    dungeon.ConnectRooms(armory.Id, Direction.North, passage.Id);

    // Connect Level 1 rooms (horizontal)
    dungeon.ConnectRooms(crypt.Id, Direction.South, lake.Id);
    dungeon.ConnectRooms(lake.Id, Direction.East, cavern.Id);

    // Connect levels (vertical)
    dungeon.ConnectRoomsVertically(passage.Id, crypt.Id, StairType.StairsDown);

    return dungeon;
}
```

---

## 10. Data Model Changes

### 10.1 New Domain Components

| Type | Name | Location | Description |
|------|------|----------|-------------|
| Value Object | `Position3D` | `Domain/ValueObjects/Position3D.cs` | 3D coordinate (X, Y, Z) |
| Enum | `StairType` | `Domain/Enums/StairType.cs` | Vertical connection types |

### 10.2 Modified Domain Components

| Type | Name | Changes |
|------|------|---------|
| Enum | `Direction` | Add `Up = 4`, `Down = 5` values |
| Entity | `Room` | Change `Position` type to `Position3D` |
| Entity | `Dungeon` | Add `GetOppositeDirection()` Up/Down, `ConnectRoomsVertically()`, `GetRoomByPosition(Position3D)` |
| Entity | `Player` | Change `Position` type to `Position3D` |

### 10.3 Application Layer Updates

| Service | Changes |
|---------|---------|
| `GameSessionService` | Enhanced movement messages for vertical directions |
| `CommandParser` | Add `up`/`down`/`climb`/`descend` command parsing |

---

## 11. Logging Specifications

### 11.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `GameSessionService` | Information | Vertical movement between levels |
| `GameSessionService` | Debug | Movement direction parsing, exit validation |
| `GameSessionService` | Warning | Attempted movement with no exit |
| `Dungeon` | Debug | Room connections created (horizontal/vertical) |
| `Dungeon` | Warning | Invalid vertical connection (wrong Z-level order) |

### 11.2 Log Message Examples

```
[Information] Player descended: Dungeon Passage (Z=0) -> Forgotten Crypt (Z=1) via StairsDown
[Debug] TryMove called with direction: Down
[Debug] Vertical exit found: Down -> room 8a3b...
[Warning] TryMove failed: No exit Down from room Entrance Hall. Available exits: north, east, west
```

---

## 12. Unit Testing Requirements

### 12.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Position3D value object | ~6 |
| Direction enum extension | ~3 |
| StairType enum | ~2 |
| Dungeon vertical connections | ~4 |
| Movement commands | ~3 |
| **Total** | **~18** |

### 12.2 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `Position3DTests.cs` | ~6 | Constructor, Move, MoveUp/Down, ToPosition2D, ManhattanDistance |
| `DirectionTests.cs` | ~3 | GetOppositeDirection for Up/Down, all 6 directions |
| `DungeonVerticalTests.cs` | ~4 | ConnectRoomsVertically, GetStairType, validation |
| `GameSessionMovementTests.cs` | ~3 | TryMove Up/Down, command aliases |
| `StarterDungeonTests.cs` | ~2 | Two levels exist, vertical connection works |

### 12.3 Test Cases

#### Position3DTests.cs

```csharp
[Test]
public void Constructor_SetsCoordinates()
{
    var pos = new Position3D(1, 2, 3);
    Assert.That(pos.X, Is.EqualTo(1));
    Assert.That(pos.Y, Is.EqualTo(2));
    Assert.That(pos.Z, Is.EqualTo(3));
}

[Test]
public void MoveUp_DecreasesZ()
{
    var pos = new Position3D(0, 0, 2);
    var result = pos.MoveUp();
    Assert.That(result.Z, Is.EqualTo(1));
}

[Test]
public void MoveDown_IncreasesZ()
{
    var pos = new Position3D(0, 0, 0);
    var result = pos.MoveDown();
    Assert.That(result.Z, Is.EqualTo(1));
}

[Test]
public void Move_WithDirection_ReturnsCorrectPosition()
{
    var pos = Position3D.Origin;
    Assert.That(pos.Move(Direction.Up), Is.EqualTo(new Position3D(0, 0, -1)));
    Assert.That(pos.Move(Direction.Down), Is.EqualTo(new Position3D(0, 0, 1)));
}

[Test]
public void ToPosition2D_DiscardsZ()
{
    var pos3d = new Position3D(5, 10, 3);
    var pos2d = pos3d.ToPosition2D();
    Assert.That(pos2d.X, Is.EqualTo(5));
    Assert.That(pos2d.Y, Is.EqualTo(10));
}

[Test]
public void ManhattanDistanceTo_IncludesZAxis()
{
    var a = new Position3D(0, 0, 0);
    var b = new Position3D(3, 4, 2);
    Assert.That(a.ManhattanDistanceTo(b), Is.EqualTo(9)); // 3 + 4 + 2
}
```

#### DirectionTests.cs (additions)

```csharp
[Test]
public void GetOppositeDirection_Up_ReturnsDown()
{
    Assert.That(Dungeon.GetOppositeDirection(Direction.Up), Is.EqualTo(Direction.Down));
}

[Test]
public void GetOppositeDirection_Down_ReturnsUp()
{
    Assert.That(Dungeon.GetOppositeDirection(Direction.Down), Is.EqualTo(Direction.Up));
}

[Test]
public void Direction_HasAllSixValues()
{
    var values = Enum.GetValues<Direction>();
    Assert.That(values, Has.Length.EqualTo(6));
    Assert.That(values, Contains.Item(Direction.Up));
    Assert.That(values, Contains.Item(Direction.Down));
}
```

---

## 13. Use Cases

### UC-001: Descend Stairs to Lower Level

**Actor:** Player
**Flow:** Enter room with stairs down → Type "down" or "descend" → Move to lower level room → See new room description with (Z=1) indicator

### UC-002: Climb Stairs to Upper Level

**Actor:** Player
**Flow:** Enter room with stairs up → Type "up" or "climb" → Move to upper level room → See new room description with (Z=0) indicator

### UC-003: Attempt Movement Without Exit

**Actor:** Player
**Flow:** Enter room without vertical exit → Type "down" → Receive message "There is no way down here."

### UC-004: View Available Exits Including Vertical

**Actor:** Player
**Flow:** Enter room with stairs → Type "look" → See exits including "down" or "up" listed

### UC-005: Fall Down Pit (One-Way)

**Actor:** Player
**Flow:** Enter room with pit → Type "down" → Fall to lower level → Attempt "up" → No exit up (pit is one-way)

---

## 14. Deliverable Checklist

### Domain Layer
- [ ] `Position3D.cs` value object created
- [ ] `StairType.cs` enum created
- [ ] `Direction.cs` enum updated with Up/Down
- [ ] `Room.cs` Position property migrated to Position3D
- [ ] `Dungeon.cs` GetOppositeDirection updated
- [ ] `Dungeon.cs` ConnectRoomsVertically method added
- [ ] `Dungeon.cs` GetRoomByPosition(Position3D) overload added
- [ ] `Dungeon.cs` CreateStarterDungeon updated with Level 1

### Application Layer
- [ ] `GameSessionService.cs` movement messages updated
- [ ] Command parsing for up/down/climb/descend

### Presentation Layer
- [ ] `CommandParser.cs` updated for vertical commands
- [ ] Exit display includes vertical directions

### Tests
- [ ] `Position3DTests.cs` (~6 tests)
- [ ] `DirectionTests.cs` updates (~3 tests)
- [ ] `DungeonVerticalTests.cs` (~4 tests)
- [ ] `GameSessionMovementTests.cs` (~3 tests)
- [ ] `StarterDungeonTests.cs` (~2 tests)
- [ ] All ~18 tests passing

### Documentation
- [ ] XML documentation for all new types
- [ ] Updated code comments for modified types

---

## 15. Acceptance Criteria

### Functional

- [ ] Position3D value object stores X, Y, Z coordinates
- [ ] Position3D.MoveUp() decreases Z by 1
- [ ] Position3D.MoveDown() increases Z by 1
- [ ] Position3D.Move(Direction) works for all 6 directions
- [ ] Direction enum includes Up (4) and Down (5) values
- [ ] GetOppositeDirection returns Down for Up and vice versa
- [ ] StairType enum defines 7 vertical connection types
- [ ] ConnectRoomsVertically creates bidirectional vertical exits
- [ ] ConnectRoomsVertically with StairType.Pit creates one-way connection
- [ ] Player can move between Z-levels using up/down commands
- [ ] "climb" and "descend" work as aliases for up/down
- [ ] Room exits description includes vertical directions
- [ ] Starter dungeon has at least 2 levels (Z=0 and Z=1)
- [ ] Starter dungeon has vertical connection between levels

### Quality

- [ ] Build succeeds with 0 errors and 0 warnings
- [ ] All ~18 unit tests pass
- [ ] XML documentation complete for all new/modified types
- [ ] No breaking changes to existing 2D navigation

---

## 16. Dependencies

### 16.1 Prerequisites (REQUIRES)

```
v0.1.0a Z-Axis Foundation
    │
    └── REQUIRES from v0.0.11
        ├── Room entity (exits, items, monsters)
        ├── Dungeon entity (rooms, connections)
        ├── Direction enum (N, S, E, W)
        ├── Position value object
        ├── GameSessionService (movement)
        └── CommandParser (input handling)
```

### 16.2 Provides (to future phases)

```
v0.1.0a Z-Axis Foundation
    │
    └── PROVIDES to v0.1.0b
        ├── Position3D for room coordinates
        ├── Direction.Up/Down for exits
        ├── StairType for vertical flavoring
        ├── ConnectRoomsVertically() method
        └── GetRoomByPosition(Position3D)
```

---

## 17. Future Considerations

### 17.1 Deferred to v0.1.0b (Procedural Room Generation)

- **Room templates with vertical exits**: Templates will use the Up/Down directions
- **Depth-based difficulty scaling**: Uses Z coordinate from Position3D

### 17.2 Deferred to v0.1.0c (Room Types & Hidden Passages)

- **Climbing skill checks for shafts**: StairType.Shaft may require Athletics check
- **Hidden vertical passages**: Secret stairs/ladders

### 17.3 Deferred to v0.1.0d (Map Command & Polish)

- **Multi-level map display**: ASCII map showing different Z levels
- **Level indicator in UI**: Show current Z level in status bar

### 17.4 Out of Scope (Future Versions)

- **Falling damage**: Damage from pits or failed climbing
- **Climbing mechanics**: Skill checks for vertical movement
- **3D visualization**: Graphical dungeon rendering

---

*Document Version: 1.0*
*Last Updated: 2026-01-08*
*Author: Claude*
