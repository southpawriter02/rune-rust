# Changelog: v0.3.23c - The Mouse

**Release Date:** 2025-12-27

---

## Summary

Version 0.3.23c introduces comprehensive TUI mouse support for the Rune & Rust terminal application. This release implements the full mouse interaction infrastructure, including SGR Extended Mouse Mode for VT-compatible terminals, hit-testing services for mapping screen coordinates to game elements, and robust terminal lifecycle management with cleanup guarantees.

The implementation spans the Core Layer (interface definitions, input models), Engine Layer (hit-testing logic, SGR parsing), and Terminal Layer (terminal state management). Key architectural patterns include the Service Repository pattern for `ITerminalService` and `IHitTestService`, the IDisposable pattern for guaranteed cleanup, and reverse-order hit-testing for proper layering semantics. This release adds 53 tests across 3 test classes with 100% pass rate.

The mouse system uses SGR Extended Mode (VT escape codes `\x1b[?1000h` and `\x1b[?1006h`) which supports coordinates beyond 223 columns, addressing the limitations of legacy X10 mouse protocol. Terminal detection covers Windows Terminal, xterm-compatible terminals, iTerm2, VS Code terminal, and Apple Terminal via environment variable inspection.

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/ITerminalService.cs` | Manages terminal state (mouse mode, alternate screen buffer) with lifecycle methods |
| `RuneAndRust.Core/Interfaces/IHitTestService.cs` | Service interface for mapping screen coordinates to game elements with region registration |

### Terminal Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Terminal/Services/TerminalService.cs` | Implementation of `ITerminalService` with SGR Extended Mode support and IDisposable cleanup |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/HitTestService.cs` | Implementation of `IHitTestService` with reverse-order hit-testing for clickable regions |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Terminal/MouseInputTests.cs` | 30 tests for SGR mouse sequence parsing covering all button types, modifiers, scroll, and edge cases |
| `RuneAndRust.Tests/Engine/HitTestServiceTests.cs` | 12 tests for hit-testing logic including overlapping regions, edge detection, and data attachment |
| `RuneAndRust.Tests/Terminal/TerminalServiceTests.cs` | 11 tests for terminal service lifecycle, detection logic, and dispose pattern |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Models/Input/InputEvent.cs` | Enhanced `MouseEvent` record with `MouseButton` enum (Left/Middle/Right/ScrollUp/ScrollDown), `MouseEventType` enum (ButtonDown/ButtonUp/Move/Scroll), factory methods `Click()` and `Scroll()`, convenience properties `IsLeftClick`, `IsRightClick`, and coordinate aliases `X`/`Y` |
| `RuneAndRust.Engine/Services/InputService.cs` | Added `StringBuilder _escapeBuffer` for escape sequence collection, `EscapeSequenceTimeoutMs = 50` constant, `ParseEscapeSequence()` method for VT escape handling, `internal static bool TryParseSgrMouseSequence()` for SGR format parsing with button/modifier decoding, updated version comment to v0.3.23c |
| `RuneAndRust.Terminal/Program.cs` | Registered `ITerminalService` and `IHitTestService` as singletons in DI container (lines 187, 190), added mouse mode initialization on startup if supported (step 3d, lines 271-280), added mouse mode disable calls in Ctrl+C handler (line 496), SIGTERM handler (line 507), and crash handler (lines 523-534) for cleanup guarantee |
| `RuneAndRust.Engine/RuneAndRust.Engine.csproj` | Added `<InternalsVisibleTo Include="RuneAndRust.Tests" />` to expose internal `TryParseSgrMouseSequence()` method for unit testing |
| `RuneAndRust.Tests/Engine/InputServiceTests.cs` | Updated `MouseEvent_StoresCoordinates_Correctly` test to use new enhanced `MouseEvent` constructor with `MouseEventType` and `MouseButton` parameters |

---

## Code Implementation Details

### Enums

#### `HitTargetType` (IHitTestService.cs)

```csharp
public enum HitTargetType
{
    None,              // No target hit
    CombatGridCell,    // A cell in the combat grid
    TurnOrderEntry,    // An entry in the turn order display
    AbilityButton,     // An ability button in the combat HUD
    MenuOption,        // A menu option
    MinimapCell,       // A cell in the minimap
    LogEntry           // An entry in the combat/event log
}
```

#### `MouseButton` (InputEvent.cs)

```csharp
public enum MouseButton
{
    Left = 0,         // Maps to SGR button code 0
    Middle = 1,       // Maps to SGR button code 1
    Right = 2,        // Maps to SGR button code 2
    None = 3,         // Used for movement events
    ScrollUp = 64,    // Maps to SGR button code 64
    ScrollDown = 65   // Maps to SGR button code 65
}
```

Values match SGR mouse protocol button codes for direct mapping.

#### `MouseEventType` (InputEvent.cs)

```csharp
public enum MouseEventType
{
    ButtonDown,  // Mouse button pressed (uppercase 'M' terminator)
    ButtonUp,    // Mouse button released (lowercase 'm' terminator)
    Move,        // Mouse moved (bit 5 set in button code)
    Scroll       // Mouse wheel scrolled (bit 6 set in button code)
}
```

---

### Services and Classes

#### `ITerminalService` (Interface)

**Key Methods:**

```csharp
bool IsMouseEnabled { get; }
void EnableMouseMode();
void DisableMouseMode();
bool IsMouseSupported();
```

**Behaviors:**
- `EnableMouseMode()` emits VT escape sequences `\x1b[?1000h` (button tracking) and `\x1b[?1006h` (SGR extended coordinates)
- `DisableMouseMode()` emits cleanup sequences `\x1b[?1006l` and `\x1b[?1000l`
- `IsMouseSupported()` returns true for Windows Terminal, xterm, screen, tmux, alacritty, kitty, iTerm2, VS Code terminal, and Apple Terminal
- Safe to call `DisableMouseMode()` even if mouse mode was never enabled (idempotent)

#### `TerminalService` (Implementation)

**Key Features:**
- Implements `IDisposable` for guaranteed cleanup on application exit
- Terminal detection via environment variables: `WT_SESSION`, `TERM`, `TERM_PROGRAM`
- Logs all state transitions at Debug level
- Prevents double-enable and double-disable with internal state tracking

**Constants:**
- Supported terminals detected via: xterm-compatible (`TERM` contains "xterm", "screen", "tmux", "alacritty", "kitty"), Windows Terminal (`WT_SESSION` present), iTerm2/VS Code/Apple Terminal (`TERM_PROGRAM` matches)

#### `IHitTestService` (Interface)

**Key Methods:**

```csharp
HitTestResult HitTest(int screenX, int screenY, GamePhase currentPhase);
void RegisterRegion(HitTargetType type, int left, int top, int right, int bottom,
                   int? index = null, int? row = null, int? column = null, object? data = null);
void ClearRegions();
```

**Behaviors:**
- Coordinates are 1-based (matching terminal conventions)
- Hit-testing searches regions in reverse order (last registered = topmost layer)
- Returns `HitTestResult.None` singleton for misses
- `ClearRegions()` should be called before each frame render

#### `HitTestService` (Implementation)

**Key Features:**
- Stores clickable regions as internal `ClickableRegion` records
- Reverse iteration ensures topmost UI elements are hit first in overlapping scenarios
- Logs all hits/misses at Trace level for debugging
- Supports optional metadata attachment (index, row, column, data) for context propagation

**Hit Detection Logic:**
- Inclusive bounds checking: `screenX >= region.Left && screenX <= region.Right && screenY >= region.Top && screenY <= region.Bottom`
- First matching region (from end of list) wins

#### `InputService.TryParseSgrMouseSequence()` (Static Method)

**Signature:**

```csharp
internal static bool TryParseSgrMouseSequence(string sequence, out MouseEvent mouseEvent)
```

**SGR Format:** `[<Cb;Cx;Cy{M|m}`
- Prefix: `[<`
- Cb: Button code (encodes button, modifiers, scroll, move)
- Cx: 1-based column
- Cy: 1-based row
- Terminator: `M` (button down) or `m` (button up)

**Button Code Decoding:**
- Bits 0-1: Button (0=Left, 1=Middle, 2=Right, 3=None)
- Bit 2 (4): Shift modifier
- Bit 3 (8): Alt modifier
- Bit 4 (16): Control modifier
- Bit 5 (32): Move event flag
- Bit 6 (64): Scroll event flag

**Behaviors:**
- Returns `false` for sequences shorter than 6 characters
- Returns `false` for non-SGR formats (missing `[<` prefix or `M`/`m` terminator)
- Returns `false` for malformed content (wrong semicolon count, non-numeric values)
- Handles coordinates exceeding 223 (primary advantage over legacy X10 mode)
- Decodes modifier combinations correctly (e.g., button code 28 = Shift + Alt + Control)

---

### Models

#### `HitTestResult` (Record)

```csharp
public record HitTestResult(
    HitTargetType TargetType,
    int? Index = null,
    int? Row = null,
    int? Column = null,
    object? Data = null
)
```

**Properties:**
- `TargetType`: The UI element type that was hit
- `Index`: Optional index within element type (e.g., turn order position)
- `Row`: Optional grid row for grid-based elements
- `Column`: Optional grid column for grid-based elements
- `Data`: Optional arbitrary context data (e.g., combatant reference for turn order)
- `IsHit`: Computed property returning `TargetType != HitTargetType.None`

**Singleton:** `HitTestResult.None` for "nothing hit" scenario

#### `MouseEvent` (Enhanced Record)

**Constructor:**

```csharp
public record MouseEvent(
    MouseEventType EventType,
    MouseButton Button,
    int ScreenX,
    int ScreenY,
    ConsoleModifiers Modifiers = ConsoleModifiers.None
) : InputEvent
```

**Factory Methods:**

```csharp
public static MouseEvent Click(int x, int y, MouseButton button = MouseButton.Left)
public static MouseEvent Scroll(int x, int y, bool up)
```

**Convenience Properties:**
- `bool IsLeftClick`: True if `EventType == ButtonDown && Button == Left`
- `bool IsRightClick`: True if `EventType == ButtonDown && Button == Right`
- `int X`: Alias for `ScreenX`
- `int Y`: Alias for `ScreenY`

---

## Logging Matrix

### TerminalService

| Event | Level | Template |
|-------|-------|----------|
| Service initialized | Debug | `"[Terminal] TerminalService initialized (v0.3.23c)"` |
| Mouse mode enabled | Debug | `"[Terminal] Mouse mode enabled (SGR Extended)"` |
| Mouse mode disabled | Debug | `"[Terminal] Mouse mode disabled"` |
| Mouse not supported | Debug | `"[Terminal] Mouse not supported in this terminal, skipping enable"` |
| Mouse already enabled | Trace | `"[Terminal] Mouse mode already enabled, skipping"` |
| Mouse not enabled (on disable) | Trace | `"[Terminal] Mouse mode not enabled, skipping disable"` |
| Windows Terminal detected | Trace | `"[Terminal] Windows Terminal detected, mouse supported"` |
| xterm detected | Trace | `"[Terminal] xterm-compatible terminal detected ({Term}), mouse supported"` |
| iTerm2/VS Code/Apple detected | Trace | `"[Terminal] {TermProgram} detected, mouse supported"` |
| No compatible terminal | Trace | `"[Terminal] No known mouse-compatible terminal detected"` |
| Disposing service | Debug | `"[Terminal] Disposing, disabling mouse mode"` |

### InputService

| Event | Level | Template |
|-------|-------|----------|
| Service initialized | Debug | `"[Input] InputService initialized (v0.3.23c)"` |
| Mouse event parsed | Trace | `"[Input] Parsed mouse event: {Type} at ({X}, {Y})"` |
| Non-mouse escape sequence | Trace | `"[Input] Non-mouse escape sequence: ESC{Seq}"` |
| Bare escape key | Trace | `"[Input] Bare escape key pressed"` |
| Unknown escape sequence | Debug | `"[Input] Unknown escape sequence: ESC{Seq}"` |

### HitTestService

| Event | Level | Template |
|-------|-------|----------|
| Service initialized | Debug | `"[HitTest] HitTestService initialized (v0.3.23c)"` |
| Hit detected | Trace | `"[HitTest] Hit at ({X}, {Y}): {Type}"` |
| Miss detected | Trace | `"[HitTest] Miss at ({X}, {Y})"` |
| Region registered | Trace | `"[HitTest] Registered region: {Type} at ({Left},{Top})-({Right},{Bottom})"` |
| Regions cleared | Trace | `"[HitTest] Cleared {Count} regions"` |

### Program.cs Startup

| Event | Level | Template |
|-------|-------|----------|
| Mouse mode enabled on startup | Information | `"[Startup] Mouse mode enabled (SGR Extended)"` |
| Mouse not supported on startup | Debug | `"[Startup] Mouse mode not supported in this terminal"` |

---

## Test Coverage

**Summary:**
```
Total: 53 | Passed: 53 | Failed: 0 | Duration: 499ms
```

---

### Complete Test Inventory

#### MouseInputTests (30 tests)

| Test Name | Description |
|-----------|-------------|
| `TryParseSgrSequence_LeftClick_ReturnsCorrectEvent` | Verifies left click at (10,5) parses as `ButtonDown`, `Left`, coordinates 10,5 |
| `TryParseSgrSequence_LeftClick_AtOrigin_ReturnsCorrectEvent` | Verifies left click at (1,1) parses correctly (edge case for minimum coordinates) |
| `TryParseSgrSequence_RightClick_ReturnsCorrectEvent` | Verifies right click at (20,15) parses as `ButtonDown`, `Right` |
| `TryParseSgrSequence_MiddleClick_ReturnsCorrectEvent` | Verifies middle click at (5,5) parses as `ButtonDown`, `Middle` |
| `TryParseSgrSequence_ButtonUp_ReturnsReleaseEvent` | Verifies lowercase 'm' terminator produces `ButtonUp` event type |
| `TryParseSgrSequence_RightButtonUp_ReturnsReleaseEvent` | Verifies right button release parses correctly |
| `TryParseSgrSequence_ScrollUp_ReturnsScrollEvent` | Verifies button code 64 produces `Scroll` event with `ScrollUp` button |
| `TryParseSgrSequence_ScrollDown_ReturnsScrollEvent` | Verifies button code 65 produces `Scroll` event with `ScrollDown` button |
| `TryParseSgrSequence_WithShift_IncludesModifier` | Verifies button code 4 (bit 2) sets `ConsoleModifiers.Shift` |
| `TryParseSgrSequence_WithAlt_IncludesModifier` | Verifies button code 8 (bit 3) sets `ConsoleModifiers.Alt` |
| `TryParseSgrSequence_WithCtrl_IncludesModifier` | Verifies button code 16 (bit 4) sets `ConsoleModifiers.Control` |
| `TryParseSgrSequence_WithMultipleModifiers_IncludesAllModifiers` | Verifies button code 28 (4+8+16) sets Shift, Alt, and Control simultaneously |
| `TryParseSgrSequence_LargeCoordinates_Works` | Verifies coordinates (250,100) parse correctly (exceeds legacy X10 limit of 223) |
| `TryParseSgrSequence_VeryLargeCoordinates_Works` | Verifies coordinates (1000,500) parse correctly (stress test for SGR extended mode) |
| `TryParseSgrSequence_InvalidFormat_ReturnsFalse` | Verifies malformed sequence `[<invalid` returns false |
| `TryParseSgrSequence_IncompleteSequence_ReturnsFalse` | Verifies truncated sequence `[<0;10` returns false |
| `TryParseSgrSequence_TooShort_ReturnsFalse` | Verifies sequence shorter than 6 characters returns false |
| `TryParseSgrSequence_WrongPrefix_ReturnsFalse` | Verifies sequence missing `[<` prefix returns false |
| `TryParseSgrSequence_WrongTerminator_ReturnsFalse` | Verifies sequence with invalid terminator (not M/m) returns false |
| `TryParseSgrSequence_MissingSemicolons_ReturnsFalse` | Verifies sequence with wrong semicolon count returns false |
| `TryParseSgrSequence_NonNumeric_ReturnsFalse` | Verifies sequence with non-numeric values returns false |
| `TryParseSgrSequence_EmptyString_ReturnsFalse` | Verifies empty string returns false |
| `TryParseSgrSequence_MouseMove_ReturnsCorrectEvent` | Verifies button code 32 (bit 5) produces `Move` event type |
| `MouseEvent_Click_CreatesButtonDownEvent` | Verifies factory method `Click(10,5)` creates `ButtonDown` event with `Left` button |
| `MouseEvent_Click_WithButton_CreatesCorrectEvent` | Verifies factory method `Click(10,5, Right)` creates right-click event |
| `MouseEvent_Scroll_Up_CreatesScrollUpEvent` | Verifies factory method `Scroll(10,5, up: true)` creates scroll-up event |
| `MouseEvent_Scroll_Down_CreatesScrollDownEvent` | Verifies factory method `Scroll(10,5, up: false)` creates scroll-down event |
| `MouseEvent_IsLeftClick_TrueForLeftButtonDown` | Verifies convenience property `IsLeftClick` returns true for left button down |
| `MouseEvent_IsRightClick_TrueForRightButtonDown` | Verifies convenience property `IsRightClick` returns true for right button down |
| `MouseEvent_XY_AliasesWork` | Verifies `X` and `Y` properties correctly alias `ScreenX` and `ScreenY` |

#### HitTestServiceTests (12 tests)

| Test Name | Description |
|-----------|-------------|
| `HitTest_InsideRegion_ReturnsHit` | Verifies click at (15,10) inside region (10,5)-(20,15) returns correct `HitTestResult` with row/column metadata |
| `HitTest_OutsideRegion_ReturnsNone` | Verifies click at (5,3) outside all regions returns `HitTestResult.None` |
| `HitTest_OnEdge_ReturnsHit` | Verifies click exactly on region boundary (10,5) is treated as inside (inclusive bounds) |
| `HitTest_OverlappingRegions_ReturnsTopmost` | Verifies later-registered region wins when two regions overlap (reverse-order search) |
| `HitTest_WithData_ReturnsData` | Verifies custom data object attached to region is returned in `HitTestResult.Data` |
| `HitTest_NoRegionsRegistered_ReturnsNone` | Verifies hit-test with empty region list returns `HitTestResult.None` |
| `ClearRegions_RemovesAll` | Verifies `ClearRegions()` removes all registered regions, causing subsequent hits to return None |
| `ClearRegions_IsIdempotent` | Verifies calling `ClearRegions()` multiple times on empty list does not throw |
| `RegisterRegion_AllParameters_StoresCorrectly` | Verifies all optional parameters (index, row, column, data) are stored and retrieved correctly |
| `RegisterRegion_MultipleTypes_AllAccessible` | Verifies multiple different region types can be registered and hit-tested independently |
| `HitTestResult_None_HasCorrectProperties` | Verifies `HitTestResult.None` singleton has `TargetType = None`, `IsHit = false`, and null optionals |
| `HitTestResult_IsHit_TrueForNonNoneTypes` | Verifies `IsHit` property returns true for any `HitTargetType` except `None` |

#### TerminalServiceTests (11 tests)

| Test Name | Description |
|-----------|-------------|
| `EnableMouseMode_SetsIsMouseEnabled_WhenSupported` | Verifies `EnableMouseMode()` sets `IsMouseEnabled` to true when terminal supports mouse |
| `EnableMouseMode_IsIdempotent` | Verifies calling `EnableMouseMode()` twice does not cause errors or double-emit escape codes |
| `DisableMouseMode_ClearsIsMouseEnabled` | Verifies `DisableMouseMode()` sets `IsMouseEnabled` to false |
| `DisableMouseMode_IsIdempotent` | Verifies calling `DisableMouseMode()` twice does not cause errors |
| `DisableMouseMode_SafeWhenNeverEnabled` | Verifies `DisableMouseMode()` can be called even if `EnableMouseMode()` was never called (safe guard) |
| `IsMouseSupported_ReturnsTrue_ForWindowsTerminal` | Verifies `WT_SESSION` environment variable triggers mouse support detection |
| `IsMouseSupported_ReturnsTrue_ForXterm` | Verifies `TERM=xterm-256color` triggers mouse support detection |
| `IsMouseSupported_ReturnsTrue_ForVSCode` | Verifies `TERM_PROGRAM=vscode` triggers mouse support detection |
| `Dispose_DisablesMouseMode` | Verifies `Dispose()` automatically calls `DisableMouseMode()` for cleanup guarantee |
| `Dispose_IsIdempotent` | Verifies calling `Dispose()` twice does not cause errors (standard IDisposable pattern) |
| `Constructor_StartsWithMouseDisabled` | Verifies newly constructed service has `IsMouseEnabled = false` (safe initial state) |

---

## DI Registration

Added to `RuneAndRust.Terminal/Program.cs`:

```csharp
// Register Terminal Service (v0.3.23c - The Mouse)
services.AddSingleton<ITerminalService, TerminalService>();

// Register Hit Test Service (v0.3.23c - The Mouse)
services.AddSingleton<IHitTestService, HitTestService>();
```

**Lifetime Justification:**
- Singleton: Both services maintain application-wide state (mouse mode enabled/disabled, registered regions) and should persist for the entire application lifetime.

---

## Verification Results

### Build Output

```
Build succeeded.
    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:03.02
```

All projects compiled successfully. The single warning is a pre-existing EntityFrameworkCore version conflict unrelated to this release.

### Test Output

```
Test Run Successful.
Total tests: 53
     Passed: 53
 Total time: 0.4991 Seconds
```

All 53 new mouse-related tests passed on first run. Test execution completed in under 500ms.

**Observable Side Effect:** During test execution, the terminal emitted VT escape sequences for mouse mode enable/disable (visible as `[?1000h[?1006h[?1006l[?1000l` in test output), confirming actual VT code emission.

---

## Directory Structure After Release

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Interfaces/
│   │   ├── ITerminalService.cs         [NEW]
│   │   └── IHitTestService.cs          [NEW]
│   └── Models/Input/
│       └── InputEvent.cs               [MODIFIED]
├── RuneAndRust.Engine/
│   ├── Services/
│   │   ├── HitTestService.cs           [NEW]
│   │   └── InputService.cs             [MODIFIED]
│   └── RuneAndRust.Engine.csproj       [MODIFIED]
├── RuneAndRust.Terminal/
│   ├── Services/
│   │   └── TerminalService.cs          [NEW]
│   └── Program.cs                      [MODIFIED]
└── RuneAndRust.Tests/
    ├── Engine/
    │   ├── HitTestServiceTests.cs      [NEW]
    │   └── InputServiceTests.cs        [MODIFIED]
    └── Terminal/
        ├── MouseInputTests.cs          [NEW]
        └── TerminalServiceTests.cs     [NEW]
```

---

## Running Tests

**Run all mouse-related tests:**

```bash
dotnet test --filter "FullyQualifiedName~MouseInputTests|FullyQualifiedName~HitTestServiceTests|FullyQualifiedName~TerminalServiceTests"
```

**Run specific test class:**

```bash
dotnet test --filter "FullyQualifiedName~RuneAndRust.Tests.Terminal.MouseInputTests"
dotnet test --filter "FullyQualifiedName~RuneAndRust.Tests.Engine.HitTestServiceTests"
dotnet test --filter "FullyQualifiedName~RuneAndRust.Tests.Terminal.TerminalServiceTests"
```

**Run individual test:**

```bash
dotnet test --filter "FullyQualifiedName=RuneAndRust.Tests.Terminal.MouseInputTests.TryParseSgrSequence_LeftClick_ReturnsCorrectEvent"
```

---

## Technical Notes

### SGR Extended vs Legacy X10 Mode

**Legacy X10 Mouse Protocol:**
- Format: `ESC[M{Cb}{Cx}{Cy}` (single-byte coordinates)
- Coordinate limit: 223 (255 - 32 offset)
- Incompatible with UTF-8 terminals

**SGR Extended Mouse Protocol (Used in v0.3.23c):**
- Format: `ESC[<{Cb};{Cx};{Cy}{M|m}` (decimal coordinates)
- Coordinate limit: Theoretical maximum of INT_MAX (practical limit is terminal window size)
- UTF-8 safe
- Distinguishes button down (`M`) from button up (`m`)

### Terminal Detection Strategy

Detection prioritizes most specific indicators first:

1. Windows Terminal: `WT_SESSION` environment variable (unique to WT)
2. xterm-compatible: `TERM` contains "xterm", "screen", "tmux", "alacritty", "kitty"
3. macOS/IDE terminals: `TERM_PROGRAM` equals "iTerm.app", "vscode", or "Apple_Terminal"

Fallback behavior: If no match, `IsMouseSupported()` returns false, and `EnableMouseMode()` becomes a no-op.

### Cleanup Guarantee Architecture

Mouse mode is disabled at four exit points:

1. **Normal exit:** Application calls `Dispose()` on `TerminalService` via DI container disposal
2. **Ctrl+C:** `Console.CancelKeyPress` handler calls `terminalService.DisableMouseMode()` (line 496)
3. **SIGTERM:** `AppDomain.ProcessExit` handler calls `terminalService.DisableMouseMode()` (line 507)
4. **Crash:** Global exception handler attempts cleanup before rendering crash screen (lines 523-534)

This ensures the terminal is restored to a usable state even on abnormal termination.

### Hit-Testing Layering Semantics

Regions are tested in reverse-order (last registered first) to implement painter's algorithm semantics:

```csharp
for (int i = _regions.Count - 1; i >= 0; i--)
{
    // Check if click is inside region[i]...
}
```

This means UI elements rendered "on top" (registered later) will intercept clicks before elements "underneath" (registered earlier), matching visual layering expectations.

---

## Next Steps

Planned work for v0.3.23d and beyond:

- Implement actual click handlers in `CombatScreenRenderer` to invoke abilities via mouse
- Integrate hit-testing into `ExplorationScreenRenderer` for minimap navigation
- Add mouse-over tooltip system using `MouseEventType.Move` events
- Implement drag-and-drop for inventory management
- Add double-click detection with timing threshold (200ms standard)
- Implement mouse wheel scrolling for combat log and journal views
- Add configuration option to disable mouse input for keyboard-only users
- Create visual feedback system for clickable regions (highlight on hover)

---

**End of Changelog v0.3.23c**
