# v0.0.2 Design Specification: Core Game Loop Polish

[v0.0.2 Changelog](../../changelogs/v0.0.2-changelog.md)

**Version:** 0.0.2
**Status:** Implemented
**Focus:** Stabilize the foundation and add essential missing commands
**Prerequisite:** v0.0.1 (Walking Skeleton) - COMPLETE

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Detailed Feature Specifications](#4-detailed-feature-specifications)
   - 4.1 [Load Game Command](#41-load-game-command)
   - 4.2 [Drop Command](#42-drop-command)
   - 4.3 [Use Command](#43-use-command)
   - 4.4 [Item Effects System](#44-item-effects-system)
   - 4.5 [Examine Command](#45-examine-command)
   - 4.6 [Status Command](#46-status-command)
   - 4.7 [Room Re-entry Messages](#47-room-re-entry-messages)
5. [Technical Debt](#5-technical-debt)
6. [Developer Tools: Cheat Code System](#6-developer-tools-cheat-code-system)
7. [Data Model Changes](#7-data-model-changes)
8. [Logging Specifications](#8-logging-specifications)
9. [Unit Testing Requirements](#9-unit-testing-requirements)
10. [Use Cases](#10-use-cases)
11. [Deliverable Checklist](#11-deliverable-checklist)
12. [Documentation Requirements](#12-documentation-requirements)
13. [Acceptance Criteria](#13-acceptance-criteria)

---

## 1. Executive Summary

Version 0.0.2 focuses on **polishing the core game loop** established in v0.0.1. This release adds essential player commands (load, drop, use, examine, status), introduces an item effects system for consumables, implements room re-entry messaging for immersion, and provides developer cheat codes for testing. Additionally, this version addresses technical debt by implementing PostgreSQL persistence and improving input validation.

### Key Deliverables

| Category | Items |
|----------|-------|
| **New Commands** | Load, Drop, Use, Examine, Status |
| **Systems** | Item Effects, Room Visit Tracking, Cheat Codes |
| **Technical Debt** | PostgreSQL Repository, Input Validation |
| **Tests** | ~40 new unit tests, 10 integration tests |

---

## 2. Feature Overview

```
v0.0.2 Features
├── Player Commands
│   ├── Load Game (from saved sessions)
│   ├── Drop Item (from inventory to room)
│   ├── Use Item (consume for effects)
│   ├── Examine (detailed inspection)
│   └── Status (player stats display)
├── Game Systems
│   ├── Item Effects Framework
│   └── Room Visit Tracking
├── Developer Tools
│   └── Cheat Code System
└── Technical Debt
    ├── PostgreSQL Repository
    └── Input Validation
```

---

## 3. Architecture Diagrams

### 3.1 Command Flow Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Presentation Layer                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────────────┐  │
│  │  ConsoleInput   │───▶│   GameView      │───▶│  SpectreGameRenderer    │  │
│  │    Handler      │    │  (Command Loop) │    │                         │  │
│  └─────────────────┘    └─────────────────┘    └─────────────────────────┘  │
│           │                      │                                          │
│           ▼                      ▼                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        GameCommand Records                          │    │
│  │  LoadCommand | DropCommand | UseCommand | ExamineCommand | Status   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             Application Layer                                │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      GameSessionService                              │    │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐            │    │
│  │  │ LoadGameAsync │  │ TryDropItem   │  │ TryUseItem    │            │    │
│  │  └───────────────┘  └───────────────┘  └───────────────┘            │    │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐            │    │
│  │  │ GetExamineInfo│  │ GetPlayerStats│  │ (existing)    │            │    │
│  │  └───────────────┘  └───────────────┘  └───────────────┘            │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                        │
│                    ┌───────────────┴───────────────┐                        │
│                    ▼                               ▼                        │
│  ┌─────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │      ItemEffectService      │  │         IGameRepository             │  │
│  │  (Applies consumable effects)│  │  (PostgreSQL implementation)       │  │
│  └─────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                               Domain Layer                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌─────────────────────┐    │
│  │   Player   │  │    Room    │  │    Item    │  │    GameSession      │    │
│  │ +Heal()    │  │ +AddItem() │  │ +Effect    │  │ +VisitedRooms       │    │
│  │ +DropItem()│  │ +IsVisited │  │ +EffectVal │  │ +MarkRoomVisited()  │    │
│  └────────────┘  └────────────┘  └────────────┘  └─────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Item Effects System Flow

```
┌──────────────────────────────────────────────────────────────────────┐
│                        UseCommand("Health Potion")                    │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                   GameSessionService.TryUseItem()                     │
│  1. Validate active session                                          │
│  2. Find item in player inventory                                    │
│  3. Check if item is usable (ItemType.Consumable)                   │
│  4. Delegate to ItemEffectService                                    │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                    ItemEffectService.ApplyEffect()                    │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │ switch (item.Effect)                                            │ │
│  │ {                                                               │ │
│  │   ItemEffect.Heal => player.Heal(item.EffectValue)             │ │
│  │   ItemEffect.Damage => player.TakeDamage(item.EffectValue)     │ │
│  │   ItemEffect.BuffAttack => player.ApplyBuff(...)               │ │
│  │   ItemEffect.BuffDefense => player.ApplyBuff(...)              │ │
│  │ }                                                               │ │
│  └─────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│               Remove item from inventory (if consumable)              │
│               Return success message with effect description          │
└──────────────────────────────────────────────────────────────────────┘
```

### 3.3 Cheat Code System Architecture

```
┌───────────────────────────────────────────────────────────────────────────┐
│                            ConsoleInputHandler                             │
│  ┌─────────────────────────────────────────────────────────────────────┐  │
│  │  ParseCommand(input)                                                 │  │
│  │    │                                                                 │  │
│  │    ├─► if (input.StartsWith("/") && CheatsEnabled)                  │  │
│  │    │       return CheatCommandParser.Parse(input)                   │  │
│  │    │                                                                 │  │
│  │    └─► else: standard command parsing                               │  │
│  └─────────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌───────────────────────────────────────────────────────────────────────────┐
│                           CheatCommand Records                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌──────────────────────┐ │
│  │ GodModeCmd  │ │  HealCmd    │ │  KillCmd    │ │ TeleportCmd          │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └──────────────────────┘ │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌──────────────────────┐ │
│  │ SetStatCmd  │ │  SpawnCmd   │ │  LootCmd    │ │ GoldCmd              │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └──────────────────────┘ │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐                          │
│  │ LevelUpCmd  │ │  RevealCmd  │ │ NoClipCmd   │                          │
│  └─────────────┘ └─────────────┘ └─────────────┘                          │
└───────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌───────────────────────────────────────────────────────────────────────────┐
│                          CheatCodeService                                  │
│  - Validates cheat commands                                                │
│  - Logs all cheat usage (Warning level)                                   │
│  - Applies effects to GameSession                                         │
│  - Controlled by appsettings.json: "CheatsEnabled": true/false            │
└───────────────────────────────────────────────────────────────────────────┘
```

---

## 4. Detailed Feature Specifications

### 4.1 Load Game Command

**Purpose:** Allow players to load previously saved game sessions from the main menu or during gameplay.

#### Command Syntax
```
load              # Show list of saved games and select
```

#### Workflow

```
User types "load"
       │
       ▼
┌─────────────────────────────────────┐
│ GameSessionService.GetSavedGamesAsync()
│ Returns: List<GameSessionSummary>   │
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ Display saved games to user:        │
│   1. Hero (Last played: 2025-01-06) │
│   2. Wizard (Last played: 2025-01-05│
│   3. [Cancel]                       │
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ User selects game                   │
│ GameSessionService.LoadGameAsync(id)│
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ Render loaded game state            │
│ Display: "Game loaded successfully" │
└─────────────────────────────────────┘
```

#### Implementation Details

**New Command Record:**
```csharp
// Already exists in IInputHandler.cs
public record LoadCommand : GameCommand;
```

**GameView.cs Changes:**
```csharp
case LoadCommand:
    _logger.LogDebug("Handling load command");
    await HandleLoadAsync(ct);
    break;

// New method
private async Task HandleLoadAsync(CancellationToken ct)
{
    var savedGames = await _gameService.GetSavedGamesAsync(ct);

    if (savedGames.Count == 0)
    {
        await _renderer.RenderMessageAsync("No saved games found.", MessageType.Warning, ct);
        return;
    }

    // Add cancel option
    var options = savedGames.ToList();

    var selected = await _inputHandler.GetSelectionAsync(
        "Select a game to load:",
        savedGames,
        g => $"{g.PlayerName} (Last played: {g.LastPlayedAt:g})",
        ct);

    var result = await _gameService.LoadGameAsync(selected.SessionId, ct);

    if (result != null)
    {
        _logger.LogInformation("Game loaded: {SessionId}", selected.SessionId);
        await _renderer.RenderMessageAsync($"Welcome back, {result.Player.Name}!", MessageType.Success, ct);
        Console.WriteLine();
        await _renderer.RenderGameStateAsync(result, ct);
    }
    else
    {
        await _renderer.RenderMessageAsync("Failed to load game.", MessageType.Error, ct);
    }
}
```

#### Logging Requirements
| Level | Event | Properties |
|-------|-------|------------|
| Debug | Load command received | - |
| Debug | Saved games retrieved | `{SavedGameCount}` |
| Information | Game load successful | `{SessionId}`, `{PlayerName}` |
| Warning | No saved games found | - |
| Error | Load failed | `{SessionId}`, `{ErrorMessage}` |

#### Unit Tests
```csharp
[TestFixture]
public class LoadGameTests
{
    [Test]
    public async Task LoadGameAsync_WithValidSessionId_LoadsSession();

    [Test]
    public async Task LoadGameAsync_WithInvalidSessionId_ReturnsNull();

    [Test]
    public async Task GetSavedGamesAsync_ReturnsOrderedByLastPlayed();

    [Test]
    public async Task GetSavedGamesAsync_WhenEmpty_ReturnsEmptyList();

    [Test]
    public async Task LoadGameAsync_UpdatesLastPlayedTimestamp();
}
```

---

### 4.2 Drop Command

**Purpose:** Allow players to remove items from their inventory and place them in the current room.

#### Command Syntax
```
drop <item>       # Drop a specific item
drop sword        # Example: drop sword
```

#### Workflow

```
User types "drop rusty sword"
       │
       ▼
┌─────────────────────────────────────┐
│ Parse: DropCommand("rusty sword")   │
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ GameSessionService.TryDropItem()    │
│   1. Validate active session        │
│   2. Find item in inventory         │
│   3. Remove from inventory          │
│   4. Add to current room            │
│   5. Return success/failure         │
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ Success: "You drop the Rusty Sword."│
│ Failure: "You don't have that item."│
└─────────────────────────────────────┘
```

#### Implementation Details

**New Command Record (IInputHandler.cs):**
```csharp
/// <summary>
/// Command to drop an item from inventory into the current room.
/// </summary>
/// <param name="ItemName">The name of the item to drop.</param>
public record DropCommand(string ItemName) : GameCommand;
```

**ConsoleInputHandler.cs Changes:**
```csharp
// Add to ParseCommand switch expression
"drop" => string.IsNullOrEmpty(argument)
    ? LogAndReturn(new UnknownCommand(input), "Drop command missing item argument")
    : new DropCommand(argument),
```

**GameSessionService.cs - New Method:**
```csharp
/// <summary>
/// Attempts to drop an item from the player's inventory into the current room.
/// </summary>
/// <param name="itemName">The name of the item to drop (case-insensitive).</param>
/// <returns>A tuple indicating success and a descriptive message.</returns>
public (bool Success, string Message) TryDropItem(string itemName)
{
    _logger.LogDebug("TryDropItem called for item: {ItemName}", itemName);

    if (_currentSession == null)
    {
        _logger.LogWarning("TryDropItem failed: No active game session");
        return (false, "No active game session.");
    }

    var currentRoom = _currentSession.CurrentRoom;
    if (currentRoom == null)
    {
        _logger.LogError("TryDropItem failed: Current room is null");
        return (false, "Error: Current room not found.");
    }

    var item = _currentSession.Player.Inventory.GetItemByName(itemName);
    if (item == null)
    {
        _logger.LogDebug("Item not found in inventory: {ItemName}", itemName);
        return (false, $"You don't have '{itemName}' in your inventory.");
    }

    if (_currentSession.Player.Inventory.TryRemove(item))
    {
        currentRoom.AddItem(item);
        _logger.LogInformation(
            "Item dropped: {ItemName} in room {RoomName}. Inventory: {InventoryCount}/{Capacity}",
            item.Name,
            currentRoom.Name,
            _currentSession.Player.Inventory.Count,
            _currentSession.Player.Inventory.Capacity);
        return (true, $"You drop the {item.Name}.");
    }

    _logger.LogWarning("TryDropItem failed unexpectedly for item: {ItemName}", itemName);
    return (false, $"Could not drop '{itemName}'.");
}
```

**Inventory.cs - New Method:**
```csharp
/// <summary>
/// Finds an item in the inventory by name (case-insensitive).
/// </summary>
/// <param name="name">The name of the item to find.</param>
/// <returns>The item if found; otherwise, null.</returns>
public Item? GetItemByName(string name) =>
    _items.FirstOrDefault(i => i.Name.Equals(name, StringComparison.OrdinalIgnoreCase));

/// <summary>
/// Attempts to remove an item from the inventory.
/// </summary>
/// <param name="item">The item to remove.</param>
/// <returns>True if the item was removed; otherwise, false.</returns>
public bool TryRemove(Item item)
{
    if (item == null) return false;
    return _items.Remove(item);
}
```

#### Logging Requirements
| Level | Event | Properties |
|-------|-------|------------|
| Debug | Drop command received | `{ItemName}` |
| Debug | Item not found in inventory | `{ItemName}` |
| Information | Item dropped successfully | `{ItemName}`, `{RoomName}`, `{InventoryCount}`, `{Capacity}` |
| Warning | Drop failed unexpectedly | `{ItemName}` |

#### Unit Tests
```csharp
[TestFixture]
public class DropCommandTests
{
    [Test]
    public async Task TryDropItem_WhenItemInInventory_DropsSuccessfully();

    [Test]
    public async Task TryDropItem_WhenItemNotInInventory_ReturnsFalse();

    [Test]
    public async Task TryDropItem_AddsItemToCurrentRoom();

    [Test]
    public async Task TryDropItem_RemovesItemFromInventory();

    [Test]
    public void TryDropItem_WhenNoActiveSession_ReturnsFalse();

    [Test]
    public async Task DroppedItem_CanBePickedUpAgain();
}
```

---

### 4.3 Use Command

**Purpose:** Allow players to consume items from their inventory to trigger effects (healing, buffs, etc.).

#### Command Syntax
```
use <item>        # Use/consume a specific item
use potion        # Example: use health potion
```

#### Workflow

```
User types "use health potion"
       │
       ▼
┌─────────────────────────────────────┐
│ Parse: UseCommand("health potion")  │
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ GameSessionService.TryUseItem()     │
│   1. Validate active session        │
│   2. Find item in inventory         │
│   3. Check if item is usable        │
│   4. Apply effect via ItemEffectSvc │
│   5. Remove item if consumable      │
│   6. Return success + description   │
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ "You drink the Health Potion.       │
│  Restored 25 HP. (75/100)"          │
└─────────────────────────────────────┘
```

#### Implementation Details

**New Command Record (IInputHandler.cs):**
```csharp
/// <summary>
/// Command to use/consume an item from inventory.
/// </summary>
/// <param name="ItemName">The name of the item to use.</param>
public record UseCommand(string ItemName) : GameCommand;
```

**ConsoleInputHandler.cs Changes:**
```csharp
// Add to ParseCommand switch expression
"use" or "consume" or "drink" or "eat" => string.IsNullOrEmpty(argument)
    ? LogAndReturn(new UnknownCommand(input), "Use command missing item argument")
    : new UseCommand(argument),
```

**GameSessionService.cs - New Method:**
```csharp
/// <summary>
/// Attempts to use an item from the player's inventory.
/// </summary>
/// <param name="itemName">The name of the item to use (case-insensitive).</param>
/// <returns>A tuple indicating success and a descriptive message.</returns>
public (bool Success, string Message) TryUseItem(string itemName)
{
    _logger.LogDebug("TryUseItem called for item: {ItemName}", itemName);

    if (_currentSession == null)
    {
        _logger.LogWarning("TryUseItem failed: No active game session");
        return (false, "No active game session.");
    }

    var item = _currentSession.Player.Inventory.GetItemByName(itemName);
    if (item == null)
    {
        _logger.LogDebug("Item not found in inventory: {ItemName}", itemName);
        return (false, $"You don't have '{itemName}' in your inventory.");
    }

    if (item.Type != ItemType.Consumable)
    {
        _logger.LogDebug("Item not usable: {ItemName} (Type: {ItemType})", itemName, item.Type);
        return (false, $"You cannot use the {item.Name}.");
    }

    var effectResult = _itemEffectService.ApplyEffect(item, _currentSession.Player);

    if (effectResult.Success)
    {
        _currentSession.Player.Inventory.TryRemove(item);
        _logger.LogInformation(
            "Item used: {ItemName}, Effect: {Effect}, Value: {Value}, Player HP: {Health}/{MaxHealth}",
            item.Name,
            item.Effect,
            item.EffectValue,
            _currentSession.Player.Health,
            _currentSession.Player.Stats.MaxHealth);
    }

    return effectResult;
}
```

#### Unit Tests
```csharp
[TestFixture]
public class UseCommandTests
{
    [Test]
    public async Task TryUseItem_HealthPotion_RestoresHealth();

    [Test]
    public async Task TryUseItem_WhenItemNotInInventory_ReturnsFalse();

    [Test]
    public async Task TryUseItem_NonConsumable_ReturnsFalse();

    [Test]
    public async Task TryUseItem_RemovesConsumableFromInventory();

    [Test]
    public async Task TryUseItem_WhenAtFullHealth_StillConsumesPotion();

    [Test]
    public async Task TryUseItem_ReturnsAccurateHealingDescription();
}
```

---

### 4.4 Item Effects System

**Purpose:** Define and apply various effects from consumable items.

#### Effect Types

| Effect | Description | Example Items |
|--------|-------------|---------------|
| `Heal` | Restores player health | Health Potion (+25 HP) |
| `Damage` | Damages the player (cursed items) | Poison Vial (-10 HP) |
| `BuffAttack` | Temporarily increases attack | Strength Elixir (+5 ATK for 3 turns) |
| `BuffDefense` | Temporarily increases defense | Iron Skin Potion (+5 DEF for 3 turns) |
| `None` | No effect (quest items, etc.) | Ancient Scroll |

#### Domain Model Changes

**ItemEffect Enum (new file: Domain/Enums/ItemEffect.cs):**
```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the types of effects that items can have when used.
/// </summary>
public enum ItemEffect
{
    /// <summary>
    /// No effect. Used for quest items, weapons, etc.
    /// </summary>
    None = 0,

    /// <summary>
    /// Restores player health by the effect value.
    /// </summary>
    Heal = 1,

    /// <summary>
    /// Deals damage to the player (cursed items).
    /// </summary>
    Damage = 2,

    /// <summary>
    /// Temporarily increases attack stat.
    /// </summary>
    BuffAttack = 3,

    /// <summary>
    /// Temporarily increases defense stat.
    /// </summary>
    BuffDefense = 4
}
```

**Item.cs Changes:**
```csharp
/// <summary>
/// Gets the effect this item provides when used.
/// </summary>
public ItemEffect Effect { get; private set; }

/// <summary>
/// Gets the magnitude of the effect (healing amount, damage, buff value).
/// </summary>
public int EffectValue { get; private set; }

/// <summary>
/// Gets the duration of the effect in turns (0 for instant effects).
/// </summary>
public int EffectDuration { get; private set; }

// Updated constructor
public Item(string name, string description, ItemType type, int value = 0,
            ItemEffect effect = ItemEffect.None, int effectValue = 0, int effectDuration = 0)
{
    // ... existing initialization ...
    Effect = effect;
    EffectValue = effectValue;
    EffectDuration = effectDuration;
}

// Updated factory method
public static Item CreateHealthPotion() => new(
    "Health Potion",
    "A vial of red liquid that restores health when consumed.",
    ItemType.Consumable,
    value: 25,
    effect: ItemEffect.Heal,
    effectValue: 25
);
```

#### ItemEffectService (new file: Application/Services/ItemEffectService.cs)
```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for applying item effects to players.
/// </summary>
public class ItemEffectService
{
    private readonly ILogger<ItemEffectService> _logger;

    public ItemEffectService(ILogger<ItemEffectService> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Applies an item's effect to the player.
    /// </summary>
    /// <param name="item">The item being used.</param>
    /// <param name="player">The player receiving the effect.</param>
    /// <returns>A tuple with success status and description message.</returns>
    public (bool Success, string Message) ApplyEffect(Item item, Player player)
    {
        _logger.LogDebug(
            "Applying effect: {Effect} (Value: {Value}) from {ItemName} to {PlayerName}",
            item.Effect, item.EffectValue, item.Name, player.Name);

        return item.Effect switch
        {
            ItemEffect.Heal => ApplyHeal(item, player),
            ItemEffect.Damage => ApplyDamage(item, player),
            ItemEffect.BuffAttack => ApplyAttackBuff(item, player),
            ItemEffect.BuffDefense => ApplyDefenseBuff(item, player),
            ItemEffect.None => (false, $"The {item.Name} has no usable effect."),
            _ => (false, $"Unknown effect type for {item.Name}.")
        };
    }

    private (bool Success, string Message) ApplyHeal(Item item, Player player)
    {
        var previousHealth = player.Health;
        var actualHealed = player.Heal(item.EffectValue);

        _logger.LogInformation(
            "Heal applied: {PlayerName} healed {ActualHealed} HP ({PreviousHP} -> {CurrentHP}/{MaxHP})",
            player.Name, actualHealed, previousHealth, player.Health, player.Stats.MaxHealth);

        var verb = item.Name.ToLower().Contains("potion") ? "drink" : "use";
        return (true, $"You {verb} the {item.Name}. Restored {actualHealed} HP. ({player.Health}/{player.Stats.MaxHealth})");
    }

    private (bool Success, string Message) ApplyDamage(Item item, Player player)
    {
        var previousHealth = player.Health;
        var actualDamage = player.TakeDamage(item.EffectValue);

        _logger.LogWarning(
            "Damage applied: {PlayerName} took {ActualDamage} damage ({PreviousHP} -> {CurrentHP}/{MaxHP})",
            player.Name, actualDamage, previousHealth, player.Health, player.Stats.MaxHealth);

        return (true, $"The {item.Name} was cursed! You take {actualDamage} damage. ({player.Health}/{player.Stats.MaxHealth})");
    }

    private (bool Success, string Message) ApplyAttackBuff(Item item, Player player)
    {
        // Note: Full buff system will be implemented in v0.0.6 (Status Effects)
        // For now, log and return a placeholder message
        _logger.LogDebug("Attack buff applied (placeholder): +{Value} for {Duration} turns",
            item.EffectValue, item.EffectDuration);

        return (true, $"You feel stronger! (+{item.EffectValue} Attack for {item.EffectDuration} turns) [Buff system coming in v0.0.6]");
    }

    private (bool Success, string Message) ApplyDefenseBuff(Item item, Player player)
    {
        _logger.LogDebug("Defense buff applied (placeholder): +{Value} for {Duration} turns",
            item.EffectValue, item.EffectDuration);

        return (true, $"Your skin hardens! (+{item.EffectValue} Defense for {item.EffectDuration} turns) [Buff system coming in v0.0.6]");
    }
}
```

#### Unit Tests
```csharp
[TestFixture]
public class ItemEffectServiceTests
{
    [Test]
    public void ApplyEffect_Heal_RestoresCorrectAmount();

    [Test]
    public void ApplyEffect_Heal_DoesNotExceedMaxHealth();

    [Test]
    public void ApplyEffect_Damage_ReducesHealth();

    [Test]
    public void ApplyEffect_Damage_AppliesDefenseReduction();

    [Test]
    public void ApplyEffect_None_ReturnsFalse();

    [Test]
    public void ApplyEffect_BuffAttack_ReturnsPlaceholderMessage();
}
```

---

### 4.5 Examine Command

**Purpose:** Provide detailed information about items in the room, items in inventory, or room features.

#### Command Syntax
```
examine <target>  # Examine an item, monster, or feature
examine sword     # Examine an item
examine goblin    # Examine a monster
examine room      # Re-examine current room (same as look)
```

#### Workflow

```
User types "examine rusty sword"
       │
       ▼
┌─────────────────────────────────────┐
│ Parse: ExamineCommand("rusty sword")│
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ GameSessionService.GetExamineInfo() │
│   1. Check room items               │
│   2. Check inventory items          │
│   3. Check room monsters            │
│   4. Check if "room" keyword        │
│   5. Return detailed description    │
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│ "Rusty Sword                        │
│  Type: Weapon                       │
│  An old sword covered in rust.      │
│  Still sharp enough to cut.         │
│  Value: 5 (damage bonus)"           │
└─────────────────────────────────────┘
```

#### Implementation Details

**New Command Record (IInputHandler.cs):**
```csharp
/// <summary>
/// Command to examine an item, monster, or room feature in detail.
/// </summary>
/// <param name="Target">The name of the target to examine.</param>
public record ExamineCommand(string Target) : GameCommand;
```

**ConsoleInputHandler.cs Changes:**
```csharp
// Add to ParseCommand switch expression
"examine" or "inspect" or "x" => string.IsNullOrEmpty(argument)
    ? LogAndReturn(new UnknownCommand(input), "Examine command missing target")
    : new ExamineCommand(argument),
```

**New DTO (DTOs/ExamineResultDto.cs):**
```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Represents detailed examination information about a target.
/// </summary>
public record ExamineResultDto(
    string Name,
    string Type,
    string Description,
    IReadOnlyDictionary<string, string> Properties
);
```

**GameSessionService.cs - New Method:**
```csharp
/// <summary>
/// Gets detailed examination information about a target.
/// </summary>
/// <param name="target">The name of the target to examine.</param>
/// <returns>Examination result DTO or null if target not found.</returns>
public ExamineResultDto? GetExamineInfo(string target)
{
    _logger.LogDebug("GetExamineInfo called for target: {Target}", target);

    if (_currentSession == null)
    {
        _logger.LogWarning("GetExamineInfo failed: No active game session");
        return null;
    }

    var room = _currentSession.CurrentRoom;
    if (room == null) return null;

    // Check for "room" keyword
    if (target.Equals("room", StringComparison.OrdinalIgnoreCase))
    {
        return CreateRoomExamineResult(room);
    }

    // Check room items
    var roomItem = room.GetItemByName(target);
    if (roomItem != null)
    {
        return CreateItemExamineResult(roomItem, "on the ground");
    }

    // Check inventory items
    var invItem = _currentSession.Player.Inventory.GetItemByName(target);
    if (invItem != null)
    {
        return CreateItemExamineResult(invItem, "in your inventory");
    }

    // Check monsters
    var monster = room.Monsters.FirstOrDefault(m =>
        m.Name.Equals(target, StringComparison.OrdinalIgnoreCase) && m.IsAlive);
    if (monster != null)
    {
        return CreateMonsterExamineResult(monster);
    }

    _logger.LogDebug("Examine target not found: {Target}", target);
    return null;
}

private ExamineResultDto CreateItemExamineResult(Item item, string location)
{
    var properties = new Dictionary<string, string>
    {
        ["Location"] = location,
        ["Value"] = item.Value.ToString()
    };

    if (item.Type == ItemType.Consumable && item.Effect != ItemEffect.None)
    {
        properties["Effect"] = $"{item.Effect} ({item.EffectValue})";
    }

    return new ExamineResultDto(item.Name, item.Type.ToString(), item.Description, properties);
}

private ExamineResultDto CreateMonsterExamineResult(Monster monster)
{
    var healthPercent = (double)monster.Health / monster.Stats.MaxHealth;
    var condition = healthPercent switch
    {
        > 0.75 => "healthy",
        > 0.5 => "wounded",
        > 0.25 => "badly wounded",
        _ => "near death"
    };

    var properties = new Dictionary<string, string>
    {
        ["Condition"] = condition,
        ["Health"] = $"{monster.Health}/{monster.Stats.MaxHealth}"
    };

    return new ExamineResultDto(monster.Name, "Monster", monster.Description, properties);
}

private ExamineResultDto CreateRoomExamineResult(Room room)
{
    var properties = new Dictionary<string, string>
    {
        ["Items"] = room.HasItems ? string.Join(", ", room.Items.Select(i => i.Name)) : "None",
        ["Monsters"] = room.HasMonsters ? string.Join(", ", room.GetAliveMonsters().Select(m => m.Name)) : "None",
        ["Exits"] = string.Join(", ", room.Exits.Keys.Select(d => d.ToString()))
    };

    return new ExamineResultDto(room.Name, "Room", room.Description, properties);
}
```

**SpectreGameRenderer.cs - New Method:**
```csharp
/// <inheritdoc/>
public Task RenderExamineResultAsync(ExamineResultDto result, CancellationToken ct = default)
{
    _logger.LogDebug("Rendering examine result for: {Name}", result.Name);

    var panel = new Panel(result.Description)
        .Header($"[yellow]{Markup.Escape(result.Name)}[/] [grey]({result.Type})[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(Color.Grey);

    AnsiConsole.Write(panel);

    if (result.Properties.Count > 0)
    {
        foreach (var (key, value) in result.Properties)
        {
            AnsiConsole.MarkupLine($"  [cyan]{key}:[/] {Markup.Escape(value)}");
        }
    }

    return Task.CompletedTask;
}
```

#### Unit Tests
```csharp
[TestFixture]
public class ExamineCommandTests
{
    [Test]
    public void GetExamineInfo_RoomItem_ReturnsItemDetails();

    [Test]
    public void GetExamineInfo_InventoryItem_ReturnsItemDetails();

    [Test]
    public void GetExamineInfo_Monster_ReturnsMonsterDetails();

    [Test]
    public void GetExamineInfo_Room_ReturnsRoomDetails();

    [Test]
    public void GetExamineInfo_InvalidTarget_ReturnsNull();

    [Test]
    public void GetExamineInfo_DeadMonster_ReturnsNull();
}
```

---

### 4.6 Status Command

**Purpose:** Display comprehensive player statistics in a formatted view.

#### Command Syntax
```
status            # Display player stats
stats             # Alias for status
```

#### Output Format

```
╭────────────────── Player Status ──────────────────╮
│                                                   │
│  Name:     Hero of the Realm                      │
│                                                   │
│  Health:   ████████░░ 75/100                      │
│  Attack:   15                                     │
│  Defense:  10                                     │
│                                                   │
│  Position: (1, 2)                                 │
│  Room:     The Armory                             │
│                                                   │
│  Inventory: 3/20 items                            │
│                                                   │
╰───────────────────────────────────────────────────╯
```

#### Implementation Details

**New Command Record (IInputHandler.cs):**
```csharp
/// <summary>
/// Command to display detailed player statistics.
/// </summary>
public record StatusCommand : GameCommand;
```

**ConsoleInputHandler.cs Changes:**
```csharp
// Add to ParseCommand switch expression
"status" or "stats" or "stat" => new StatusCommand(),
```

**New DTO (DTOs/PlayerStatsDto.cs):**
```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Comprehensive player statistics for status display.
/// </summary>
public record PlayerStatsDto(
    string Name,
    int Health,
    int MaxHealth,
    int Attack,
    int Defense,
    int PositionX,
    int PositionY,
    string CurrentRoomName,
    int InventoryCount,
    int InventoryCapacity
)
{
    public double HealthPercentage => MaxHealth > 0 ? (double)Health / MaxHealth : 0;
}
```

**GameSessionService.cs - New Method:**
```csharp
/// <summary>
/// Gets comprehensive player statistics.
/// </summary>
/// <returns>Player stats DTO, or null if no active session.</returns>
public PlayerStatsDto? GetPlayerStats()
{
    if (_currentSession == null)
    {
        _logger.LogWarning("GetPlayerStats failed: No active game session");
        return null;
    }

    var player = _currentSession.Player;
    var room = _currentSession.CurrentRoom;

    _logger.LogDebug(
        "GetPlayerStats - Player: {Name}, HP: {Health}/{MaxHealth}, ATK: {Attack}, DEF: {Defense}",
        player.Name, player.Health, player.Stats.MaxHealth, player.Stats.Attack, player.Stats.Defense);

    return new PlayerStatsDto(
        player.Name,
        player.Health,
        player.Stats.MaxHealth,
        player.Stats.Attack,
        player.Stats.Defense,
        player.Position.X,
        player.Position.Y,
        room?.Name ?? "Unknown",
        player.Inventory.Count,
        player.Inventory.Capacity
    );
}
```

**SpectreGameRenderer.cs - New Method:**
```csharp
/// <inheritdoc/>
public Task RenderPlayerStatsAsync(PlayerStatsDto stats, CancellationToken ct = default)
{
    _logger.LogDebug("Rendering player stats for: {PlayerName}", stats.Name);

    var healthColor = stats.HealthPercentage switch
    {
        > 0.5 => Color.Green,
        > 0.25 => Color.Yellow,
        _ => Color.Red
    };

    var healthBar = new ProgressBar(
        (int)(stats.HealthPercentage * 100),
        100,
        width: 20,
        completedColor: healthColor);

    var table = new Table()
        .Border(TableBorder.Rounded)
        .BorderColor(Color.Grey)
        .Title("[yellow]Player Status[/]")
        .HideHeaders()
        .AddColumn("")
        .AddColumn("");

    table.AddRow("[cyan]Name:[/]", stats.Name);
    table.AddRow("[cyan]Health:[/]", $"{healthBar} {stats.Health}/{stats.MaxHealth}");
    table.AddRow("[cyan]Attack:[/]", stats.Attack.ToString());
    table.AddRow("[cyan]Defense:[/]", stats.Defense.ToString());
    table.AddRow("", "");
    table.AddRow("[cyan]Position:[/]", $"({stats.PositionX}, {stats.PositionY})");
    table.AddRow("[cyan]Room:[/]", stats.CurrentRoomName);
    table.AddRow("", "");
    table.AddRow("[cyan]Inventory:[/]", $"{stats.InventoryCount}/{stats.InventoryCapacity} items");

    AnsiConsole.Write(table);
    return Task.CompletedTask;
}
```

#### Unit Tests
```csharp
[TestFixture]
public class StatusCommandTests
{
    [Test]
    public void GetPlayerStats_ReturnsCorrectValues();

    [Test]
    public void GetPlayerStats_NoActiveSession_ReturnsNull();

    [Test]
    public void HealthPercentage_CalculatesCorrectly();
}
```

---

### 4.7 Room Re-entry Messages

**Purpose:** Display different text when a player revisits a room vs first visit for improved immersion.

#### Behavior

| Scenario | Message Type |
|----------|--------------|
| First visit | Full room description |
| Return visit | Shortened "you return to" message |
| `look` command | Always shows full description |

#### Example

**First Visit:**
```
═══════════════════ The Armory ═══════════════════
A dusty room filled with weapon racks. Most are empty,
but a few rusted weapons remain.

Items here:
  * Rusty Sword

Exits: north, south
```

**Return Visit:**
```
You return to the Armory.

Items here:
  * Rusty Sword

Exits: north, south
```

#### Implementation Details

**GameSession.cs Changes:**
```csharp
/// <summary>
/// Set of room IDs that the player has visited.
/// </summary>
private readonly HashSet<Guid> _visitedRooms = [];

/// <summary>
/// Gets a read-only set of visited room IDs.
/// </summary>
public IReadOnlySet<Guid> VisitedRooms => _visitedRooms;

/// <summary>
/// Marks a room as visited.
/// </summary>
/// <param name="roomId">The ID of the room to mark as visited.</param>
public void MarkRoomVisited(Guid roomId)
{
    _visitedRooms.Add(roomId);
}

/// <summary>
/// Checks if a room has been visited before.
/// </summary>
/// <param name="roomId">The ID of the room to check.</param>
/// <returns>True if the room has been visited; otherwise, false.</returns>
public bool HasVisitedRoom(Guid roomId) => _visitedRooms.Contains(roomId);
```

**RoomDto.cs Changes:**
```csharp
/// <summary>
/// Indicates whether this is the player's first time visiting this room.
/// </summary>
public bool IsFirstVisit { get; init; }
```

**GameSessionService.TryMove Changes:**
```csharp
// After successful move, before returning
var isFirstVisit = !_currentSession.HasVisitedRoom(newRoom!.Id);
if (isFirstVisit)
{
    _currentSession.MarkRoomVisited(newRoom.Id);
    _logger.LogDebug("First visit to room: {RoomName}", newRoom.Name);
}
else
{
    _logger.LogDebug("Return visit to room: {RoomName}", newRoom.Name);
}
```

**SpectreGameRenderer.RenderRoomAsync Changes:**
```csharp
public Task RenderRoomAsync(RoomDto room, CancellationToken ct = default)
{
    _logger.LogDebug(
        "Rendering room: {RoomName}, FirstVisit: {IsFirstVisit}",
        room.Name, room.IsFirstVisit);

    if (room.IsFirstVisit)
    {
        RenderRoomInternal(room); // Full description
    }
    else
    {
        RenderReturnVisit(room); // Shortened version
    }

    return Task.CompletedTask;
}

private static void RenderReturnVisit(RoomDto room)
{
    AnsiConsole.MarkupLine($"You return to [yellow]{Markup.Escape(room.Name)}[/].");
    Console.WriteLine();

    // Still show items, monsters, and exits
    RenderRoomContents(room);
}

private static void RenderRoomContents(RoomDto room)
{
    // Extract existing monster/item/exit rendering into this method
    var aliveMonsters = room.Monsters.Where(m => m.IsAlive).ToList();
    if (aliveMonsters.Count > 0)
    {
        // ... existing monster rendering ...
    }

    if (room.Items.Count > 0)
    {
        // ... existing item rendering ...
    }

    // ... existing exit rendering ...
}
```

#### Unit Tests
```csharp
[TestFixture]
public class RoomVisitTrackingTests
{
    [Test]
    public void FirstVisit_MarksRoomAsVisited();

    [Test]
    public void ReturnVisit_RoomAlreadyInVisitedSet();

    [Test]
    public void HasVisitedRoom_ReturnsTrueForVisitedRooms();

    [Test]
    public void HasVisitedRoom_ReturnsFalseForUnvisitedRooms();

    [Test]
    public async Task TryMove_SetsIsFirstVisitCorrectly();

    [Test]
    public void StartingRoom_IsMarkedVisitedOnGameStart();
}
```

---

## 5. Technical Debt

### 5.1 PostgreSQL Repository Implementation

**Status:** Logging already complete (v0.0.2 checkbox marked)

#### PostgresGameRepository.cs
```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Infrastructure.Persistence;

namespace RuneAndRust.Infrastructure.Repositories;

/// <summary>
/// PostgreSQL implementation of <see cref="IGameRepository"/> for production persistence.
/// </summary>
public class PostgresGameRepository : IGameRepository
{
    private readonly GameDbContext _context;
    private readonly ILogger<PostgresGameRepository> _logger;

    public PostgresGameRepository(GameDbContext context, ILogger<PostgresGameRepository> logger)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public async Task<GameSession?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        _logger.LogDebug("GetByIdAsync: {SessionId}", id);

        return await _context.GameSessions
            .Include(s => s.Player)
                .ThenInclude(p => p.Inventory)
            .Include(s => s.Dungeon)
                .ThenInclude(d => d.Rooms)
            .FirstOrDefaultAsync(s => s.Id == id, ct);
    }

    /// <inheritdoc/>
    public async Task<IReadOnlyList<GameSessionSummary>> GetSavedGamesAsync(CancellationToken ct = default)
    {
        _logger.LogDebug("GetSavedGamesAsync called");

        return await _context.GameSessions
            .OrderByDescending(s => s.LastPlayedAt)
            .Select(s => new GameSessionSummary(s.Id, s.Player.Name, s.LastPlayedAt))
            .ToListAsync(ct);
    }

    /// <inheritdoc/>
    public async Task<Guid> SaveAsync(GameSession session, CancellationToken ct = default)
    {
        ArgumentNullException.ThrowIfNull(session);

        _logger.LogDebug("SaveAsync: {SessionId}", session.Id);

        var existing = await _context.GameSessions.FindAsync([session.Id], ct);

        if (existing == null)
        {
            await _context.GameSessions.AddAsync(session, ct);
            _logger.LogInformation("New session saved: {SessionId}", session.Id);
        }
        else
        {
            _context.Entry(existing).CurrentValues.SetValues(session);
            _logger.LogInformation("Session updated: {SessionId}", session.Id);
        }

        await _context.SaveChangesAsync(ct);
        return session.Id;
    }

    /// <inheritdoc/>
    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        _logger.LogDebug("DeleteAsync: {SessionId}", id);

        var session = await _context.GameSessions.FindAsync([id], ct);

        if (session != null)
        {
            _context.GameSessions.Remove(session);
            await _context.SaveChangesAsync(ct);
            _logger.LogInformation("Session deleted: {SessionId}", id);
        }
        else
        {
            _logger.LogWarning("Delete failed - session not found: {SessionId}", id);
        }
    }
}
```

#### DependencyInjection.cs Updates
```csharp
public static IServiceCollection AddInfrastructure(
    this IServiceCollection services,
    IConfiguration configuration,
    bool usePostgres = false)
{
    if (usePostgres)
    {
        var connectionString = configuration.GetConnectionString("PostgreSQL");
        services.AddDbContext<GameDbContext>(options =>
            options.UseNpgsql(connectionString));
        services.AddScoped<IGameRepository, PostgresGameRepository>();
    }
    else
    {
        services.AddSingleton<IGameRepository, InMemoryGameRepository>();
    }

    return services;
}
```

### 5.2 Input Validation Improvements

**Add validation service for consistent input handling:**

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for validating and sanitizing user input.
/// </summary>
public class InputValidationService
{
    private readonly ILogger<InputValidationService> _logger;

    /// <summary>
    /// Validates a player name.
    /// </summary>
    public (bool IsValid, string? ErrorMessage) ValidatePlayerName(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return (false, "Name cannot be empty.");

        if (name.Length > 50)
            return (false, "Name cannot exceed 50 characters.");

        if (name.Any(c => char.IsControl(c)))
            return (false, "Name contains invalid characters.");

        return (true, null);
    }

    /// <summary>
    /// Validates an item name argument.
    /// </summary>
    public (bool IsValid, string? ErrorMessage) ValidateItemName(string itemName)
    {
        if (string.IsNullOrWhiteSpace(itemName))
            return (false, "Item name cannot be empty.");

        if (itemName.Length > 100)
            return (false, "Item name too long.");

        return (true, null);
    }

    /// <summary>
    /// Sanitizes user input to prevent injection attacks.
    /// </summary>
    public string SanitizeInput(string input)
    {
        if (string.IsNullOrEmpty(input)) return input;

        // Remove control characters
        return new string(input.Where(c => !char.IsControl(c) || c == '\n' || c == '\r').ToArray());
    }
}
```

---

## 6. Developer Tools: Cheat Code System

### 6.1 Cheat Code Configuration

**appsettings.json:**
```json
{
  "CheatCodes": {
    "Enabled": true,
    "Prefix": "/",
    "LogUsage": true,
    "RestrictToDebugBuild": true
  }
}
```

**CheatCodeOptions.cs:**
```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration options for the cheat code system.
/// </summary>
public class CheatCodeOptions
{
    public const string SectionName = "CheatCodes";

    public bool Enabled { get; set; } = false;
    public string Prefix { get; set; } = "/";
    public bool LogUsage { get; set; } = true;
    public bool RestrictToDebugBuild { get; set; } = true;
}
```

### 6.2 Cheat Command Records

**CheatCommands.cs (new file: Application/Interfaces/CheatCommands.cs):**
```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Base record for all cheat commands.
/// </summary>
public abstract record CheatCommand : GameCommand;

/// <summary>
/// Toggles invincibility mode.
/// </summary>
public record GodModeCommand : CheatCommand;

/// <summary>
/// Restores player health.
/// </summary>
/// <param name="Amount">Amount to heal, or null for full heal.</param>
public record HealCommand(int? Amount = null) : CheatCommand;

/// <summary>
/// Instantly defeats monsters.
/// </summary>
/// <param name="Target">Target monster name, or null for all monsters.</param>
public record KillCommand(string? Target = null) : CheatCommand;

/// <summary>
/// Teleports the player to a room.
/// </summary>
/// <param name="RoomIdentifier">Room name or ID.</param>
public record TeleportCommand(string RoomIdentifier) : CheatCommand;

/// <summary>
/// Modifies a player stat.
/// </summary>
/// <param name="Stat">The stat to modify (health, attack, defense).</param>
/// <param name="Value">The new value.</param>
public record SetStatCommand(string Stat, int Value) : CheatCommand;

/// <summary>
/// Spawns an item into the player's inventory.
/// </summary>
/// <param name="ItemName">The item to spawn.</param>
public record SpawnCommand(string ItemName) : CheatCommand;

/// <summary>
/// Generates random loot in the current room.
/// </summary>
public record LootCommand : CheatCommand;

/// <summary>
/// Adds gold/currency to the player.
/// </summary>
/// <param name="Amount">Amount of gold to add.</param>
public record GoldCommand(int Amount) : CheatCommand;

/// <summary>
/// Instantly levels up the player.
/// </summary>
/// <param name="Levels">Number of levels to gain (default 1).</param>
public record LevelUpCommand(int Levels = 1) : CheatCommand;

/// <summary>
/// Reveals all rooms on the map.
/// </summary>
public record RevealCommand : CheatCommand;

/// <summary>
/// Toggles movement restriction bypass.
/// </summary>
public record NoClipCommand : CheatCommand;
```

### 6.3 CheatCodeService

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for executing cheat commands.
/// </summary>
public class CheatCodeService
{
    private readonly ILogger<CheatCodeService> _logger;
    private readonly CheatCodeOptions _options;
    private bool _godModeEnabled = false;
    private bool _noClipEnabled = false;

    public CheatCodeService(ILogger<CheatCodeService> logger, IOptions<CheatCodeOptions> options)
    {
        _logger = logger;
        _options = options.Value;
    }

    public bool IsEnabled => _options.Enabled &&
        (!_options.RestrictToDebugBuild || IsDebugBuild());

    public bool IsGodModeActive => _godModeEnabled;
    public bool IsNoClipActive => _noClipEnabled;

    public (bool Success, string Message) ExecuteCheat(CheatCommand command, GameSession session)
    {
        if (!IsEnabled)
        {
            _logger.LogWarning("Cheat attempted while cheats disabled: {CommandType}", command.GetType().Name);
            return (false, "Cheats are not enabled.");
        }

        if (_options.LogUsage)
        {
            _logger.LogWarning(
                "[CHEAT] Command: {CommandType}, Session: {SessionId}, Player: {PlayerName}",
                command.GetType().Name, session.Id, session.Player.Name);
        }

        return command switch
        {
            GodModeCommand => ExecuteGodMode(),
            HealCommand heal => ExecuteHeal(heal, session),
            KillCommand kill => ExecuteKill(kill, session),
            TeleportCommand tp => ExecuteTeleport(tp, session),
            SetStatCommand stat => ExecuteSetStat(stat, session),
            SpawnCommand spawn => ExecuteSpawn(spawn, session),
            LootCommand => ExecuteLoot(session),
            NoClipCommand => ExecuteNoClip(),
            _ => (false, "Unknown cheat command.")
        };
    }

    private (bool Success, string Message) ExecuteGodMode()
    {
        _godModeEnabled = !_godModeEnabled;
        _logger.LogWarning("[CHEAT] God mode: {Status}", _godModeEnabled ? "ENABLED" : "DISABLED");
        return (true, $"God mode {(_godModeEnabled ? "enabled" : "disabled")}.");
    }

    private (bool Success, string Message) ExecuteHeal(HealCommand cmd, GameSession session)
    {
        var amount = cmd.Amount ?? (session.Player.Stats.MaxHealth - session.Player.Health);
        var healed = session.Player.Heal(amount);
        _logger.LogWarning("[CHEAT] Healed {Amount} HP", healed);
        return (true, $"Healed {healed} HP. ({session.Player.Health}/{session.Player.Stats.MaxHealth})");
    }

    private (bool Success, string Message) ExecuteKill(KillCommand cmd, GameSession session)
    {
        var room = session.CurrentRoom;
        if (room == null) return (false, "No current room.");

        var targets = string.IsNullOrEmpty(cmd.Target)
            ? room.GetAliveMonsters().ToList()
            : room.GetAliveMonsters().Where(m =>
                m.Name.Equals(cmd.Target, StringComparison.OrdinalIgnoreCase)).ToList();

        foreach (var monster in targets)
        {
            monster.TakeDamage(monster.Health + 1000); // Guaranteed kill
            _logger.LogWarning("[CHEAT] Killed monster: {MonsterName}", monster.Name);
        }

        return (true, $"Killed {targets.Count} monster(s).");
    }

    private (bool Success, string Message) ExecuteTeleport(TeleportCommand cmd, GameSession session)
    {
        var room = session.Dungeon.GetRoomByName(cmd.RoomIdentifier)
            ?? session.Dungeon.GetRoomById(Guid.TryParse(cmd.RoomIdentifier, out var id) ? id : Guid.Empty);

        if (room == null) return (false, $"Room '{cmd.RoomIdentifier}' not found.");

        session.Player.MoveTo(room.Position);
        _logger.LogWarning("[CHEAT] Teleported to room: {RoomName}", room.Name);
        return (true, $"Teleported to {room.Name}.");
    }

    private (bool Success, string Message) ExecuteSetStat(SetStatCommand cmd, GameSession session)
    {
        // Implementation for stat modification
        _logger.LogWarning("[CHEAT] Set {Stat} to {Value}", cmd.Stat, cmd.Value);
        return (true, $"Set {cmd.Stat} to {cmd.Value}. [Full implementation in v0.0.3]");
    }

    private (bool Success, string Message) ExecuteSpawn(SpawnCommand cmd, GameSession session)
    {
        var item = cmd.ItemName.ToLowerInvariant() switch
        {
            "sword" => Item.CreateSword(),
            "potion" or "health potion" => Item.CreateHealthPotion(),
            "scroll" => Item.CreateScroll(),
            _ => null
        };

        if (item == null) return (false, $"Unknown item: '{cmd.ItemName}'");

        if (session.Player.Inventory.TryAdd(item))
        {
            _logger.LogWarning("[CHEAT] Spawned item: {ItemName}", item.Name);
            return (true, $"Spawned {item.Name}.");
        }

        return (false, "Inventory full.");
    }

    private (bool Success, string Message) ExecuteLoot(GameSession session)
    {
        var room = session.CurrentRoom;
        if (room == null) return (false, "No current room.");

        room.AddItem(Item.CreateHealthPotion());
        room.AddItem(Item.CreateSword());

        _logger.LogWarning("[CHEAT] Generated loot in room: {RoomName}", room.Name);
        return (true, "Loot spawned in the room.");
    }

    private (bool Success, string Message) ExecuteNoClip()
    {
        _noClipEnabled = !_noClipEnabled;
        _logger.LogWarning("[CHEAT] NoClip: {Status}", _noClipEnabled ? "ENABLED" : "DISABLED");
        return (true, $"NoClip {(_noClipEnabled ? "enabled" : "disabled")}.");
    }

    private static bool IsDebugBuild()
    {
#if DEBUG
        return true;
#else
        return false;
#endif
    }
}
```

### 6.4 Cheat Command Parser

```csharp
namespace RuneAndRust.Presentation.Tui.Adapters;

/// <summary>
/// Parses cheat command strings into CheatCommand records.
/// </summary>
public static class CheatCommandParser
{
    public static CheatCommand? Parse(string input, string prefix = "/")
    {
        if (!input.StartsWith(prefix)) return null;

        var parts = input[prefix.Length..].Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 0) return null;

        var cmd = parts[0].ToLowerInvariant();
        var args = parts.Length > 1 ? parts[1..] : [];

        return cmd switch
        {
            "god" or "godmode" => new GodModeCommand(),
            "heal" => new HealCommand(args.Length > 0 && int.TryParse(args[0], out var h) ? h : null),
            "kill" => new KillCommand(args.Length > 0 ? string.Join(" ", args) : null),
            "tp" or "teleport" => args.Length > 0
                ? new TeleportCommand(string.Join(" ", args))
                : null,
            "setstat" => args.Length >= 2 && int.TryParse(args[1], out var v)
                ? new SetStatCommand(args[0], v)
                : null,
            "spawn" => args.Length > 0 ? new SpawnCommand(string.Join(" ", args)) : null,
            "loot" => new LootCommand(),
            "gold" => args.Length > 0 && int.TryParse(args[0], out var g) ? new GoldCommand(g) : null,
            "levelup" => new LevelUpCommand(args.Length > 0 && int.TryParse(args[0], out var l) ? l : 1),
            "reveal" => new RevealCommand(),
            "noclip" => new NoClipCommand(),
            _ => null
        };
    }
}
```

---

## 7. Data Model Changes

### 7.1 New/Modified Entities Summary

| Entity | Change Type | Description |
|--------|-------------|-------------|
| `Item` | Modified | Added `Effect`, `EffectValue`, `EffectDuration` properties |
| `Inventory` | Modified | Added `GetItemByName()`, `TryRemove()` methods |
| `GameSession` | Modified | Added `VisitedRooms` set, `MarkRoomVisited()`, `HasVisitedRoom()` |
| `Room` | No change | - |
| `Player` | No change | - |

### 7.2 New Enums

| Enum | Values |
|------|--------|
| `ItemEffect` | `None`, `Heal`, `Damage`, `BuffAttack`, `BuffDefense` |

### 7.3 New DTOs

| DTO | Purpose |
|-----|---------|
| `ExamineResultDto` | Detailed examination information |
| `PlayerStatsDto` | Comprehensive player statistics |

### 7.4 Database Migration

```sql
-- Migration: Add ItemEffect columns
ALTER TABLE Items ADD COLUMN Effect INTEGER NOT NULL DEFAULT 0;
ALTER TABLE Items ADD COLUMN EffectValue INTEGER NOT NULL DEFAULT 0;
ALTER TABLE Items ADD COLUMN EffectDuration INTEGER NOT NULL DEFAULT 0;

-- Migration: Add VisitedRooms table
CREATE TABLE VisitedRooms (
    SessionId UUID NOT NULL REFERENCES GameSessions(Id) ON DELETE CASCADE,
    RoomId UUID NOT NULL,
    VisitedAt TIMESTAMP NOT NULL DEFAULT NOW(),
    PRIMARY KEY (SessionId, RoomId)
);
```

---

## 8. Logging Specifications

### 8.1 Log Level Guidelines

| Level | Usage |
|-------|-------|
| **Error** | Exceptions, null current room, critical failures |
| **Warning** | Cheat usage, invalid commands, item not found, no active session |
| **Information** | Session events, successful operations, game state changes |
| **Debug** | Command parsing, method entry/exit, detailed state |

### 8.2 Structured Logging Properties

All log messages should use structured logging with meaningful property names:

```csharp
// Good
_logger.LogInformation("Item dropped: {ItemName} in {RoomName}", item.Name, room.Name);

// Avoid
_logger.LogInformation($"Item dropped: {item.Name} in {room.Name}");
```

### 8.3 Required Log Points by Feature

| Feature | Log Points |
|---------|-----------|
| Load Game | Command received, sessions retrieved, load success/failure |
| Drop Item | Command received, item lookup, drop success/failure |
| Use Item | Command received, item lookup, effect applied, consumption |
| Examine | Command received, target lookup, result type |
| Status | Command received, stats retrieved |
| Room Visit | Visit tracked, first vs return visit |
| Cheats | All cheat usage at Warning level with full details |

---

## 9. Unit Testing Requirements

### 9.1 Test Coverage Goals

| Layer | Coverage Target |
|-------|----------------|
| Domain | 90%+ |
| Application | 85%+ |
| Infrastructure | 70%+ |

### 9.2 New Test Files Required

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Entities/
│   │   ├── InventoryTests.cs (add TryRemove, GetItemByName tests)
│   │   └── GameSessionTests.cs (add visit tracking tests)
│   └── Enums/
│       └── ItemEffectTests.cs
├── RuneAndRust.Application.UnitTests/
│   └── Services/
│       ├── GameSessionServiceTests.cs (add new command tests)
│       ├── ItemEffectServiceTests.cs (new)
│       ├── CheatCodeServiceTests.cs (new)
│       └── InputValidationServiceTests.cs (new)
└── RuneAndRust.Infrastructure.IntegrationTests/
    └── Repositories/
        └── PostgresGameRepositoryTests.cs (new)
```

### 9.3 Test Case Summary

| Feature | Test Count |
|---------|-----------|
| Load Game | 5 |
| Drop Command | 6 |
| Use Command | 6 |
| Item Effects | 6 |
| Examine Command | 6 |
| Status Command | 3 |
| Room Visit Tracking | 6 |
| Cheat Codes | 12 |
| PostgreSQL Repository | 8 |
| Input Validation | 6 |
| **Total** | **~64** |

---

## 10. Use Cases

### UC-001: Load Saved Game

**Actor:** Player
**Precondition:** At least one saved game exists
**Main Flow:**
1. Player types "load"
2. System displays list of saved games with player names and dates
3. Player selects a game
4. System loads the game session
5. System displays welcome message and current game state

**Alternative Flow:**
- 2a. No saved games exist: Display "No saved games found" message

### UC-002: Drop Item

**Actor:** Player
**Precondition:** Player has item in inventory
**Main Flow:**
1. Player types "drop <item>"
2. System finds item in inventory
3. System removes item from inventory
4. System adds item to current room
5. System displays "You drop the <item>."

**Alternative Flow:**
- 2a. Item not in inventory: Display "You don't have that item."

### UC-003: Use Health Potion

**Actor:** Player
**Precondition:** Player has health potion and is damaged
**Main Flow:**
1. Player types "use health potion"
2. System finds potion in inventory
3. System applies healing effect
4. System removes potion from inventory
5. System displays healing message with HP values

**Alternative Flow:**
- 2a. Potion not found: Display "You don't have that item."
- 3a. Item not consumable: Display "You cannot use that item."

### UC-004: Examine Item

**Actor:** Player
**Precondition:** Item exists in room or inventory
**Main Flow:**
1. Player types "examine <item>"
2. System finds item in room or inventory
3. System displays detailed item information (name, type, description, properties)

**Alternative Flow:**
- 2a. Item not found: Display "You don't see that here."

### UC-005: View Status

**Actor:** Player
**Precondition:** Active game session
**Main Flow:**
1. Player types "status"
2. System retrieves player statistics
3. System displays formatted status panel with all stats

### UC-006: Room Revisit

**Actor:** Player
**Precondition:** Player has visited a room before
**Main Flow:**
1. Player moves to previously visited room
2. System detects room is in visited set
3. System displays shortened "You return to" message
4. System still displays room contents (items, monsters, exits)

### UC-007: Use Cheat Code

**Actor:** Developer/Tester
**Precondition:** Cheats enabled in configuration
**Main Flow:**
1. Developer types "/heal 50"
2. System parses cheat command
3. System logs cheat usage at Warning level
4. System applies heal effect
5. System displays result message

**Alternative Flow:**
- 1a. Cheats disabled: Display "Cheats are not enabled."

---

## 11. Deliverable Checklist

### 11.1 Features

- [ ] **Load Game Command**
  - [ ] LoadCommand record exists
  - [ ] ConsoleInputHandler parses "load"
  - [ ] GameView handles LoadCommand
  - [ ] Displays saved game list
  - [ ] Loads selected session
  - [ ] Unit tests pass

- [ ] **Drop Command**
  - [ ] DropCommand record exists
  - [ ] ConsoleInputHandler parses "drop <item>"
  - [ ] GameSessionService.TryDropItem() implemented
  - [ ] Inventory.TryRemove() implemented
  - [ ] Inventory.GetItemByName() implemented
  - [ ] Unit tests pass

- [ ] **Use Command**
  - [ ] UseCommand record exists
  - [ ] ConsoleInputHandler parses "use <item>"
  - [ ] GameSessionService.TryUseItem() implemented
  - [ ] Unit tests pass

- [ ] **Item Effects System**
  - [ ] ItemEffect enum created
  - [ ] Item entity updated with effect properties
  - [ ] ItemEffectService implemented
  - [ ] Health potion effect works
  - [ ] Unit tests pass

- [ ] **Examine Command**
  - [ ] ExamineCommand record exists
  - [ ] ConsoleInputHandler parses "examine <target>"
  - [ ] ExamineResultDto created
  - [ ] GameSessionService.GetExamineInfo() implemented
  - [ ] SpectreGameRenderer.RenderExamineResultAsync() implemented
  - [ ] Examines room items
  - [ ] Examines inventory items
  - [ ] Examines monsters
  - [ ] Examines rooms
  - [ ] Unit tests pass

- [ ] **Status Command**
  - [ ] StatusCommand record exists
  - [ ] ConsoleInputHandler parses "status"
  - [ ] PlayerStatsDto created
  - [ ] GameSessionService.GetPlayerStats() implemented
  - [ ] SpectreGameRenderer.RenderPlayerStatsAsync() implemented
  - [ ] Unit tests pass

- [ ] **Room Re-entry Messages**
  - [ ] GameSession.VisitedRooms implemented
  - [ ] MarkRoomVisited() method exists
  - [ ] HasVisitedRoom() method exists
  - [ ] RoomDto.IsFirstVisit property added
  - [ ] SpectreGameRenderer shows different messages
  - [ ] Unit tests pass

### 11.2 Technical Debt

- [x] **Serilog Logging** (completed)
  - [x] Logging in GameSessionService
  - [x] Logging in CombatService
  - [x] Logging in GameView
  - [x] Logging in renderers/handlers
  - [x] Logging in repositories

- [ ] **PostgreSQL Repository**
  - [ ] PostgresGameRepository implemented
  - [ ] Entity Framework migrations created
  - [ ] DependencyInjection updated
  - [ ] Connection string configuration
  - [ ] Integration tests pass

- [ ] **Input Validation**
  - [ ] InputValidationService created
  - [ ] Player name validation
  - [ ] Item name validation
  - [ ] Input sanitization
  - [ ] Unit tests pass

### 11.3 Developer Tools

- [ ] **Cheat Code System**
  - [ ] CheatCodeOptions configuration class
  - [ ] appsettings.json configuration
  - [ ] CheatCommand records created
  - [ ] CheatCommandParser implemented
  - [ ] CheatCodeService implemented
  - [ ] All cheat commands work:
    - [ ] /god
    - [ ] /heal [amount]
    - [ ] /kill [target]
    - [ ] /tp <room>
    - [ ] /setstat <stat> <value>
    - [ ] /spawn <item>
    - [ ] /loot
    - [ ] /noclip
  - [ ] Cheat usage logged at Warning level
  - [ ] Debug build restriction works
  - [ ] Unit tests pass

### 11.4 Testing

- [ ] All new unit tests implemented (~64 tests)
- [ ] All unit tests pass
- [ ] Integration tests for PostgreSQL repository
- [ ] Manual testing completed
- [ ] Test coverage meets targets

### 11.5 Documentation

- [ ] XML documentation on all new public APIs
- [ ] ROADMAP.md updated (v0.0.2 items marked complete)
- [ ] This design specification reviewed and updated

---

## 12. Documentation Requirements

### 12.1 XML Documentation

All new public members must have XML documentation including:
- `<summary>` - Brief description
- `<param>` - For all parameters
- `<returns>` - For methods with return values
- `<remarks>` - For complex behavior
- `<exception>` - For thrown exceptions

### 12.2 Code Comments

- Document non-obvious logic
- Explain "why" not "what"
- Reference future implementations (e.g., "// Full buff system in v0.0.6")

### 12.3 Help Command Updates

Update the help table in GameView.HandleHelpAsync():

```csharp
helpTable.AddRow("[cyan]drop <item>[/]", "Drop an item from inventory");
helpTable.AddRow("[cyan]use <item>[/]", "Use/consume an item");
helpTable.AddRow("[cyan]examine <target>[/]", "Examine an item, monster, or room");
helpTable.AddRow("[cyan]status, stats[/]", "Display your character status");
```

---

## 13. Acceptance Criteria

### 13.1 Feature Acceptance

| Feature | Acceptance Criteria |
|---------|---------------------|
| Load Game | Can load any saved game and continue playing |
| Drop | Item moves from inventory to room, can be picked up again |
| Use | Health potions heal, consumables are removed from inventory |
| Examine | Shows detailed info for items, monsters, and rooms |
| Status | Displays all player stats in formatted panel |
| Room Revisit | Different messages for first visit vs return |
| Cheats | All cheat commands work when enabled |

### 13.2 Quality Acceptance

- [ ] Build succeeds with 0 errors, 0 warnings
- [ ] All 90+ unit tests pass
- [ ] No regressions in existing functionality
- [ ] Code follows existing patterns and conventions
- [ ] All public APIs documented

### 13.3 Performance Acceptance

- [ ] Load game completes in < 500ms
- [ ] Command parsing completes in < 10ms
- [ ] No memory leaks during extended gameplay

---

## Appendix A: File Change Summary

### New Files
```
src/Core/RuneAndRust.Domain/Enums/ItemEffect.cs
src/Core/RuneAndRust.Application/Services/ItemEffectService.cs
src/Core/RuneAndRust.Application/Services/CheatCodeService.cs
src/Core/RuneAndRust.Application/Services/InputValidationService.cs
src/Core/RuneAndRust.Application/Configuration/CheatCodeOptions.cs
src/Core/RuneAndRust.Application/DTOs/ExamineResultDto.cs
src/Core/RuneAndRust.Application/DTOs/PlayerStatsDto.cs
src/Core/RuneAndRust.Application/Interfaces/CheatCommands.cs
src/Infrastructure/RuneAndRust.Infrastructure/Repositories/PostgresGameRepository.cs
src/Presentation/RuneAndRust.Presentation.Tui/Adapters/CheatCommandParser.cs
tests/RuneAndRust.Application.UnitTests/Services/ItemEffectServiceTests.cs
tests/RuneAndRust.Application.UnitTests/Services/CheatCodeServiceTests.cs
tests/RuneAndRust.Application.UnitTests/Services/InputValidationServiceTests.cs
tests/RuneAndRust.Infrastructure.IntegrationTests/Repositories/PostgresGameRepositoryTests.cs
```

### Modified Files
```
src/Core/RuneAndRust.Domain/Entities/Item.cs
src/Core/RuneAndRust.Domain/Entities/Inventory.cs
src/Core/RuneAndRust.Domain/Entities/GameSession.cs
src/Core/RuneAndRust.Application/Interfaces/IInputHandler.cs
src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs
src/Core/RuneAndRust.Application/Services/GameSessionService.cs
src/Core/RuneAndRust.Application/DTOs/RoomDto.cs
src/Infrastructure/RuneAndRust.Infrastructure/DependencyInjection.cs
src/Presentation/RuneAndRust.Presentation.Tui/Adapters/ConsoleInputHandler.cs
src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs
src/Presentation/RuneAndRust.Presentation.Tui/Views/GameView.cs
appsettings.json
```

---

*Document Version: 1.0*
*Last Updated: 2025-01-06*
*Author: Claude Code*
