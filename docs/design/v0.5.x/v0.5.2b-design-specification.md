# v0.5.2b Design Specification: Cover System

**Version:** 0.5.2b
**Phase Name:** Cover System
**Parent Version:** v0.5.2 (Terrain & Cover)
**Prerequisites:** v0.5.2a Complete (Terrain Core)
**Estimated Tests:** ~30 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [CoverType Enum](#4-covertype-enum)
5. [CoverDefinition](#5-coverdefinition)
6. [CoverObject Entity](#6-coverobject-entity)
7. [CombatGrid Modifications](#7-combatgrid-modifications)
8. [CoverService](#8-coverservice)
9. [User-Facing Commands](#9-user-facing-commands)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification implements the cover system that adds tactical depth to ranged combat. Cover objects on the grid provide defense bonuses (partial cover) or block targeting entirely (full cover). Destructible cover can be damaged and destroyed during combat, dynamically changing the battlefield.

Key mechanics:
- **Cover Types**: None, Partial (+2 defense), Full (untargetable)
- **Cover Objects**: Placeable objects with position and HP
- **Directional Cover**: Cover must be between attacker and target
- **Destructible Cover**: Some cover can be destroyed

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Enums** | `CoverType` |
| **Domain Definitions** | `CoverDefinition` |
| **Domain Entities** | `CoverObject` |
| **CombatGrid Updates** | Cover collection and methods |
| **Application Interfaces** | `ICoverService` |
| **Application Services** | `CoverService` |
| **Result Types** | `CoverCheckResult`, `CoverDamageResult` |
| **Configuration** | `cover.json` |
| **Tests** | ~30 unit tests |

### 1.3 Architectural Significance

This version establishes the **Tactical Cover Pattern**:

- **Positional Defense**: Cover between attacker and target provides bonuses
- **Destructible Environment**: Cover can be destroyed, changing tactics
- **Directional Mechanics**: Cover effectiveness depends on relative positions
- **LOS Integration**: Works with existing line of sight system

---

## 2. Feature Overview

```
v0.5.2b Cover System
├── CoverType Enum
│   ├── None (no bonus)
│   ├── Partial (+2 defense)
│   └── Full (cannot be targeted)
├── CoverDefinition
│   ├── Id, Name, CoverType
│   ├── DefenseBonus
│   ├── IsDestructible, MaxHitPoints
│   ├── BlocksMovement, BlocksLOS
│   └── DisplayChar, Description
├── CoverObject Entity
│   ├── Id, DefinitionId, Name
│   ├── Position, CoverType
│   ├── DefenseBonus
│   ├── IsDestructible, CurrentHitPoints, MaxHitPoints
│   ├── IsDestroyed
│   ├── TakeDamage(damage): bool
│   └── GetHpPercentage(): int
├── CombatGrid Modifications
│   ├── _coverObjects: Dictionary
│   ├── AddCover(), RemoveCover()
│   ├── GetCover(), HasCover()
│   └── CoverObjects property
└── CoverService
    ├── GetCoverBetween(attacker, target)
    ├── GetDefenseBonus(attacker, target)
    ├── HasFullCover(attacker, target)
    ├── AddCover(), RemoveCover()
    ├── DamageCover(position, damage)
    └── GetProtectingCover(position, attackerPos)
```

### 2.1 Scope Alignment

**In Scope:**
- `CoverType` enum (None, Partial, Full)
- `CoverObject` entity for cover-providing objects
- `CoverDefinition` for configurable cover types
- `CombatGrid.Cover` collection
- `ICoverService` interface
- `CoverService` for cover calculations
- Partial cover (+2 defense bonus)
- Full cover (cannot be targeted from blocked angle)
- Cover direction calculation (relative to attacker)
- Destructible cover with HP
- Cover destruction mechanics
- Cover configuration in JSON

**Out of Scope:**
- Cover display (v0.5.2c)
- Combat integration display (v0.5.2c)

---

## 3. Architecture Diagrams

### 3.1 Cover Type Effects

```
┌─────────────────────────────────────────────────────────────────────┐
│                       COVER TYPE EFFECTS                             │
└─────────────────────────────────────────────────────────────────────┘

    NO COVER                          PARTIAL COVER
    ┌─────────────────┐               ┌─────────────────┐
    │ Defense: +0     │               │ Defense: +2     │
    │ Targetable: Yes │               │ Targetable: Yes │
    │ Blocks LOS: No  │               │ Blocks LOS: No  │
    │                 │               │                 │
    │       A → T     │               │     A → □ → T   │
    │  (clear shot)   │               │ (harder to hit) │
    └─────────────────┘               └─────────────────┘

    FULL COVER
    ┌─────────────────┐
    │ Defense: N/A    │
    │ Targetable: No  │
    │ Blocks LOS: Yes │
    │                 │
    │     A → █ T     │
    │  (can't target) │
    └─────────────────┘

    A = Attacker, T = Target, □/█ = Cover
```

### 3.2 Cover Direction Calculation

```
┌─────────────────────────────────────────────────────────────────────┐
│                    COVER DIRECTION CALCULATION                       │
└─────────────────────────────────────────────────────────────────────┘

    Cover provides protection if it's BETWEEN attacker and target.

    Example 1: Cover provides protection
    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │
    ├───┼───┼───┼───┼───┤
    │ A │ → │ □ │ → │ T │    A shooting at T
    ├───┼───┼───┼───┼───┤    □ is between them
    │   │   │   │   │   │    Cover IS effective
    └───┴───┴───┴───┴───┘

    Example 2: Cover does NOT provide protection
    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │
    ├───┼───┼───┼───┼───┤
    │ A │ → │ → │ → │ T │    A shooting at T
    ├───┼───┼───┼───┼───┤    □ is beside T, not between
    │   │   │   │ □ │   │    Cover is NOT effective
    └───┴───┴───┴───┴───┘

    Example 3: Adjacent cover provides protection
    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │
    ├───┼───┼───┼───┼───┤
    │ A │ → │ → │ □ │ T │    □ is adjacent to T
    ├───┼───┼───┼───┼───┤    and on the attack line
    │   │   │   │   │   │    Cover IS effective
    └───┴───┴───┴───┴───┘
```

### 3.3 Destructible Cover Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    DESTRUCTIBLE COVER FLOW                           │
└─────────────────────────────────────────────────────────────────────┘

    Attack Cover Object
              │
              ▼
    ┌───────────────────┐
    │ Get Cover at Pos  │──Not found──▶ Fail: No cover
    └────────┬──────────┘
             │Found
             ▼
    ┌───────────────────┐
    │ IsDestructible?   │──No──▶ Fail: Cannot be destroyed
    └────────┬──────────┘
             │Yes
             ▼
    ┌───────────────────┐
    │ Apply Damage      │
    │ TakeDamage(dmg)   │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ HP <= 0?          │──No──▶ Return: Damage dealt
    │ (IsDestroyed)     │           (show remaining HP)
    └────────┬──────────┘
             │Yes
             ▼
    ┌───────────────────┐
    │ Remove Cover      │
    │ from Grid         │
    └────────┬──────────┘
             │
             ▼
    ┌───────────────────┐
    │ Return: Destroyed │
    │ Entities exposed  │
    └───────────────────┘
```

### 3.4 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  ICoverService / CoverService                                        │
│  ├── GetCoverBetween(attackerId, targetId): CoverCheckResult        │
│  ├── GetCoverBetween(attackerPos, targetPos): CoverCheckResult      │
│  ├── GetDefenseBonus(attackerId, targetId): int                     │
│  ├── HasFullCover(attackerId, targetId): bool                       │
│  ├── AddCover(definition, position): bool                           │
│  ├── RemoveCover(position): bool                                    │
│  ├── DamageCover(position, damage): CoverDamageResult               │
│  ├── GetCover(position): CoverObject?                               │
│  └── GetProtectingCover(position, attackerPos): IEnumerable<Cover>  │
├─────────────────────────────────────────────────────────────────────┤
│  CoverCheckResult                                                    │
│  ├── CoverType: CoverType                                           │
│  ├── DefenseBonus: int                                              │
│  ├── CoverObject: CoverObject?                                      │
│  ├── IsBlocked: bool (for full cover)                               │
│  └── Message: string                                                │
├─────────────────────────────────────────────────────────────────────┤
│  CoverDamageResult                                                   │
│  ├── DamageDealt: bool                                              │
│  ├── DamageAmount: int                                              │
│  ├── RemainingHp: int                                               │
│  ├── Destroyed: bool                                                │
│  ├── CoverName: string                                              │
│  └── Message: string                                                │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         DOMAIN LAYER                                 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌────────────────────┐  ┌──────────────────────────────────────┐  │
│  │    CoverType       │  │         CoverDefinition              │  │
│  │      (Enum)        │  │                                      │  │
│  ├────────────────────┤  ├──────────────────────────────────────┤  │
│  │ None    = 0        │  │ + Id: string                         │  │
│  │ Partial = 1        │  │ + Name: string                       │  │
│  │ Full    = 2        │  │ + CoverType: CoverType               │  │
│  └────────────────────┘  │ + DefenseBonus: int                  │  │
│                          │ + IsDestructible: bool               │  │
│                          │ + MaxHitPoints: int                  │  │
│                          │ + BlocksMovement: bool               │  │
│                          │ + BlocksLOS: bool                    │  │
│                          │ + DisplayChar: char                  │  │
│                          │ + Description: string                │  │
│                          └──────────────────────────────────────┘  │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    CoverObject (Entity)                      │  │
│  ├──────────────────────────────────────────────────────────────┤  │
│  │ + Id: Guid                                                   │  │
│  │ + DefinitionId: string                                       │  │
│  │ + Name: string                                               │  │
│  │ + Position: GridPosition                                     │  │
│  │ + CoverType: CoverType                                       │  │
│  │ + DefenseBonus: int                                          │  │
│  │ + IsDestructible: bool                                       │  │
│  │ + CurrentHitPoints: int                                      │  │
│  │ + MaxHitPoints: int                                          │  │
│  │ + IsDestroyed: bool                                          │  │
│  │ + BlocksMovement: bool                                       │  │
│  │ + BlocksLOS: bool                                            │  │
│  │ + DisplayChar: char                                          │  │
│  │ + TakeDamage(damage): bool                                   │  │
│  │ + GetHpPercentage(): int                                     │  │
│  │ + Create(definition, position): CoverObject                  │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │              CombatGrid (Extended from v0.5.0a)              │  │
│  ├──────────────────────────────────────────────────────────────┤  │
│  │ [v0.5.0a] Width, Height, Cells, Entities                     │  │
│  │ [NEW] _coverObjects: Dictionary<GridPosition, CoverObject>   │  │
│  │ [NEW] CoverObjects: IReadOnlyDictionary<Position, Cover>     │  │
│  │ [NEW] AddCover(cover): bool                                  │  │
│  │ [NEW] RemoveCover(position): bool                            │  │
│  │ [NEW] GetCover(position): CoverObject?                       │  │
│  │ [NEW] HasCover(position): bool                               │  │
│  │ [UPDATE] GetAdjacentCells includes cover                     │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. CoverType Enum

### 4.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/CoverType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of cover providing defense bonuses.
/// </summary>
public enum CoverType
{
    /// <summary>No cover - no defense bonus.</summary>
    None = 0,

    /// <summary>Partial cover - +2 defense bonus.</summary>
    Partial = 1,

    /// <summary>Full cover - cannot be targeted from blocked direction.</summary>
    Full = 2
}
```

### 4.2 Cover Type Properties

| Type | Defense Bonus | Targetable | Blocks LOS | Examples |
|------|---------------|------------|------------|----------|
| None | +0 | Yes | No | Open ground |
| Partial | +2 | Yes | No | Crate, low wall, barrel |
| Full | N/A | No | Yes | Pillar, solid wall |

---

## 5. CoverDefinition

### 5.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/Definitions/CoverDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration for a type of cover object.
/// </summary>
public class CoverDefinition
{
    public string Id { get; private set; } = string.Empty;
    public string Name { get; private set; } = string.Empty;
    public CoverType CoverType { get; private set; } = CoverType.Partial;
    public int DefenseBonus { get; private set; } = 2;
    public bool IsDestructible { get; private set; }
    public int MaxHitPoints { get; private set; } = 10;
    public bool BlocksMovement { get; private set; } = true;
    public bool BlocksLOS { get; private set; }
    public char DisplayChar { get; private set; } = '▪';
    public string Description { get; private set; } = string.Empty;

    private CoverDefinition() { }

    public static CoverDefinition Create(
        string id, string name, CoverType coverType,
        int defenseBonus = 2, bool isDestructible = false,
        int maxHitPoints = 10, bool blocksMovement = true,
        bool blocksLOS = false, char displayChar = '▪',
        string description = "")
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        return new CoverDefinition
        {
            Id = id.ToLowerInvariant(),
            Name = name,
            CoverType = coverType,
            DefenseBonus = defenseBonus,
            IsDestructible = isDestructible,
            MaxHitPoints = maxHitPoints,
            BlocksMovement = blocksMovement,
            BlocksLOS = blocksLOS,
            DisplayChar = displayChar,
            Description = description
        };
    }
}
```

---

## 6. CoverObject Entity

### 6.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/Entities/CoverObject.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a cover-providing object on the combat grid.
/// </summary>
public class CoverObject : IEntity
{
    public Guid Id { get; private set; }
    public string DefinitionId { get; private set; } = string.Empty;
    public string Name { get; private set; } = string.Empty;
    public GridPosition Position { get; private set; }
    public CoverType CoverType { get; private set; } = CoverType.Partial;
    public int DefenseBonus { get; private set; } = 2;
    public bool IsDestructible { get; private set; }
    public int CurrentHitPoints { get; private set; }
    public int MaxHitPoints { get; private set; }
    public bool BlocksMovement { get; private set; } = true;
    public bool BlocksLOS { get; private set; }
    public char DisplayChar { get; private set; } = '▪';

    public bool IsDestroyed => IsDestructible && CurrentHitPoints <= 0;

    private CoverObject() { }

    public static CoverObject Create(CoverDefinition definition, GridPosition position)
    {
        ArgumentNullException.ThrowIfNull(definition);
        return new CoverObject
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.Id,
            Name = definition.Name,
            Position = position,
            CoverType = definition.CoverType,
            DefenseBonus = definition.DefenseBonus,
            IsDestructible = definition.IsDestructible,
            CurrentHitPoints = definition.MaxHitPoints,
            MaxHitPoints = definition.MaxHitPoints,
            BlocksMovement = definition.BlocksMovement,
            BlocksLOS = definition.BlocksLOS,
            DisplayChar = definition.DisplayChar
        };
    }

    /// <summary>Applies damage to this cover. Returns true if destroyed.</summary>
    public bool TakeDamage(int damage)
    {
        if (!IsDestructible || IsDestroyed) return false;
        CurrentHitPoints = Math.Max(0, CurrentHitPoints - damage);
        return IsDestroyed;
    }

    /// <summary>Gets the HP percentage (0-100).</summary>
    public int GetHpPercentage() =>
        MaxHitPoints == 0 ? 100 : (int)((CurrentHitPoints / (float)MaxHitPoints) * 100);
}
```

---

## 7. CombatGrid Modifications

**File:** `src/Core/RuneAndRust.Domain/Entities/CombatGrid.cs`

```csharp
// Add to CombatGrid:

#region Cover

private readonly Dictionary<GridPosition, CoverObject> _coverObjects = new();

/// <summary>Gets all cover objects on the grid.</summary>
public IReadOnlyDictionary<GridPosition, CoverObject> CoverObjects => _coverObjects;

/// <summary>Adds cover to the grid.</summary>
public bool AddCover(CoverObject cover)
{
    ArgumentNullException.ThrowIfNull(cover);
    if (!IsInBounds(cover.Position)) return false;
    if (_coverObjects.ContainsKey(cover.Position)) return false;

    _coverObjects[cover.Position] = cover;
    return true;
}

/// <summary>Removes cover from a position.</summary>
public bool RemoveCover(GridPosition position) =>
    _coverObjects.Remove(position);

/// <summary>Gets cover at a position.</summary>
public CoverObject? GetCover(GridPosition position) =>
    _coverObjects.TryGetValue(position, out var cover) ? cover : null;

/// <summary>Checks if there is cover at a position.</summary>
public bool HasCover(GridPosition position) =>
    _coverObjects.ContainsKey(position);

/// <summary>Clears all cover from the grid.</summary>
public void ClearCover() => _coverObjects.Clear();

#endregion
```

---

## 8. CoverService

### 8.1 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ICoverService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

public interface ICoverService
{
    CoverCheckResult GetCoverBetween(Guid attackerId, Guid targetId);
    CoverCheckResult GetCoverBetween(GridPosition attacker, GridPosition target);
    int GetDefenseBonus(Guid attackerId, Guid targetId);
    bool HasFullCover(Guid attackerId, Guid targetId);
    bool AddCover(CoverDefinition definition, GridPosition position);
    bool RemoveCover(GridPosition position);
    CoverDamageResult DamageCover(GridPosition position, int damage);
    CoverObject? GetCover(GridPosition position);
    IEnumerable<CoverObject> GetProtectingCover(GridPosition position, GridPosition attackerPosition);
    IEnumerable<CoverDefinition> GetAllCoverDefinitions();
}

public readonly record struct CoverCheckResult(
    CoverType CoverType, int DefenseBonus, CoverObject? CoverObject,
    bool IsBlocked, string Message);

public readonly record struct CoverDamageResult(
    bool DamageDealt, int DamageAmount, int RemainingHp,
    bool Destroyed, string CoverName, string Message);
```

### 8.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/CoverService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class CoverService : ICoverService
{
    private readonly ICombatGridService _gridService;
    private readonly ILineOfSightService _losService;
    private readonly IGameConfigurationProvider _config;
    private readonly ILogger<CoverService> _logger;
    private readonly Dictionary<string, CoverDefinition> _definitions = new();

    public CoverService(
        ICombatGridService gridService,
        ILineOfSightService losService,
        IGameConfigurationProvider config,
        ILogger<CoverService> logger)
    {
        _gridService = gridService;
        _losService = losService;
        _config = config;
        _logger = logger;
        LoadDefinitions();
    }

    private void LoadDefinitions()
    {
        foreach (var def in _config.GetCoverDefinitions())
            _definitions[def.Id] = def;
    }

    public CoverCheckResult GetCoverBetween(Guid attackerId, Guid targetId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            return new CoverCheckResult(CoverType.None, 0, null, false, "No active grid.");

        var attackerPos = grid.GetEntityPosition(attackerId);
        var targetPos = grid.GetEntityPosition(targetId);

        if (!attackerPos.HasValue || !targetPos.HasValue)
            return new CoverCheckResult(CoverType.None, 0, null, false, "Entity not on grid.");

        return GetCoverBetween(attackerPos.Value, targetPos.Value);
    }

    public CoverCheckResult GetCoverBetween(GridPosition attacker, GridPosition target)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            return new CoverCheckResult(CoverType.None, 0, null, false, "No active grid.");

        var protectingCover = GetProtectingCover(target, attacker).ToList();

        if (!protectingCover.Any())
            return new CoverCheckResult(CoverType.None, 0, null, false, "No cover.");

        // Get the best cover (full > partial)
        var bestCover = protectingCover.OrderByDescending(c => c.CoverType).First();

        if (bestCover.CoverType == CoverType.Full)
        {
            return new CoverCheckResult(
                CoverType.Full, 0, bestCover, true,
                $"Target has full cover behind {bestCover.Name}.");
        }

        return new CoverCheckResult(
            CoverType.Partial, bestCover.DefenseBonus, bestCover, false,
            $"Target has partial cover (+{bestCover.DefenseBonus} defense) from {bestCover.Name}.");
    }

    public int GetDefenseBonus(Guid attackerId, Guid targetId) =>
        GetCoverBetween(attackerId, targetId).DefenseBonus;

    public bool HasFullCover(Guid attackerId, Guid targetId) =>
        GetCoverBetween(attackerId, targetId).CoverType == CoverType.Full;

    public IEnumerable<CoverObject> GetProtectingCover(
        GridPosition position, GridPosition attackerPosition)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) yield break;

        // Get line from attacker to target
        var lineCells = _losService.GetLineCells(attackerPosition, position).ToList();

        // Check cells on the line for cover
        foreach (var cell in lineCells)
        {
            if (cell.Equals(attackerPosition) || cell.Equals(position))
                continue;

            var cover = grid.GetCover(cell);
            if (cover != null && !cover.IsDestroyed)
                yield return cover;
        }

        // Also check adjacent cells to target
        foreach (var adjacent in grid.GetAdjacentCells(position))
        {
            var cover = grid.GetCover(adjacent.Position);
            if (cover != null && !cover.IsDestroyed)
            {
                if (IsPositionBetween(attackerPosition, position, adjacent.Position))
                    yield return cover;
            }
        }
    }

    private bool IsPositionBetween(GridPosition attacker, GridPosition target, GridPosition cover)
    {
        var attackerToTarget = target.DistanceTo(attacker);
        var attackerToCover = cover.DistanceTo(attacker);
        var coverToTarget = cover.DistanceTo(target);
        return attackerToCover < attackerToTarget && coverToTarget <= 1;
    }

    public bool AddCover(CoverDefinition definition, GridPosition position)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null) return false;

        var cover = CoverObject.Create(definition, position);
        return grid.AddCover(cover);
    }

    public bool RemoveCover(GridPosition position)
    {
        var grid = _gridService.GetActiveGrid();
        return grid?.RemoveCover(position) ?? false;
    }

    public CoverDamageResult DamageCover(GridPosition position, int damage)
    {
        var grid = _gridService.GetActiveGrid();
        var cover = grid?.GetCover(position);

        if (cover == null)
            return new CoverDamageResult(false, 0, 0, false, "", "No cover at that position.");

        if (!cover.IsDestructible)
            return new CoverDamageResult(false, 0, cover.CurrentHitPoints, false,
                cover.Name, $"{cover.Name} cannot be destroyed.");

        var destroyed = cover.TakeDamage(damage);

        if (destroyed)
        {
            grid!.RemoveCover(position);
            _logger.LogInformation("Cover {Name} at {Position} destroyed", cover.Name, position);
        }

        return new CoverDamageResult(
            true, damage, cover.CurrentHitPoints, destroyed, cover.Name,
            destroyed
                ? $"{cover.Name} is destroyed!"
                : $"{cover.Name} takes {damage} damage ({cover.CurrentHitPoints}/{cover.MaxHitPoints} HP).");
    }

    public CoverObject? GetCover(GridPosition position) =>
        _gridService.GetActiveGrid()?.GetCover(position);

    public IEnumerable<CoverDefinition> GetAllCoverDefinitions() => _definitions.Values;
}
```

---

## 9. User-Facing Commands

### 9.1 Attack with Partial Cover

```
> attack goblin

You fire your Longbow at the Goblin at F2...

[Ranged attack - distance: 4 cells]
[Target has partial cover behind Wooden Crate (+2 defense)]
[Attack Roll: 2d6 + 3 = 12 vs AC 13 (11 + 2 cover)]
Miss! Your arrow deflects off the crate.
```

### 9.2 Attack Blocked by Full Cover

```
> attack skeleton

You can't target the Skeleton - it has full cover!

[Distance: 5 cells - in range]
[Full cover: Stone Pillar blocks line of attack]

Move to a different position to get a clear shot.
```

### 9.3 Destroying Cover

```
> attack crate

You swing your axe at the Wooden Crate at E3!

[Attack on cover object]
[Wooden Crate: 10/10 HP → 6/10 HP]

---

> attack crate

You swing your axe at the Wooden Crate at E3!

[Attack on cover object]
[Wooden Crate: 6/10 HP → 2/10 HP]

---

> attack crate

The Wooden Crate splinters apart!

[Wooden Crate destroyed!]
The Goblin behind it is now exposed.
```

### 9.4 Examine Cover

```
> examine crate

Wooden Crate
═══════════════════════════════════════
Position: E3
Cover Type: Partial (+2 defense)
Destructible: Yes
HP: 6/10 (60%)
Blocks Movement: Yes
```

---

## 10. Data Model Changes

| Type | Layer | Description |
|------|-------|-------------|
| `CoverType` | Domain/Enums | None, Partial, Full |
| `CoverDefinition` | Domain/Definitions | Configurable cover |
| `CoverObject` | Domain/Entities | Cover instance |
| `CombatGrid` | Domain/Entities | Add cover collection |
| `ICoverService` | Application/Interfaces | Cover service interface |
| `CoverService` | Application/Services | Cover calculations |
| `CoverCheckResult` | Application/DTOs | Cover check result |
| `CoverDamageResult` | Application/DTOs | Cover damage result |

---

## 11. Configuration File Schemas

**File:** `config/cover.json`

```json
{
  "$schema": "./schemas/cover.schema.json",
  "coverDefinitions": [
    {
      "id": "wooden-crate",
      "name": "Wooden Crate",
      "coverType": "Partial",
      "defenseBonus": 2,
      "isDestructible": true,
      "maxHitPoints": 10,
      "blocksMovement": true,
      "blocksLOS": false,
      "displayChar": "□",
      "description": "Wooden crate providing partial cover"
    },
    {
      "id": "stone-pillar",
      "name": "Stone Pillar",
      "coverType": "Full",
      "defenseBonus": 0,
      "isDestructible": false,
      "blocksMovement": true,
      "blocksLOS": true,
      "displayChar": "█",
      "description": "Stone pillar providing full cover"
    },
    {
      "id": "low-wall",
      "name": "Low Wall",
      "coverType": "Partial",
      "defenseBonus": 2,
      "isDestructible": false,
      "blocksMovement": false,
      "blocksLOS": false,
      "displayChar": "▄",
      "description": "Low wall providing partial cover (can move over)"
    },
    {
      "id": "barrel",
      "name": "Barrel",
      "coverType": "Partial",
      "defenseBonus": 1,
      "isDestructible": true,
      "maxHitPoints": 5,
      "blocksMovement": true,
      "blocksLOS": false,
      "displayChar": "○",
      "description": "Barrel providing light cover"
    },
    {
      "id": "overturned-table",
      "name": "Overturned Table",
      "coverType": "Partial",
      "defenseBonus": 2,
      "isDestructible": true,
      "maxHitPoints": 8,
      "blocksMovement": false,
      "blocksLOS": false,
      "displayChar": "═",
      "description": "Overturned table providing partial cover"
    }
  ]
}
```

---

## 12. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `CoverService` | Debug | Cover checks, direction calculations |
| `CoverService` | Information | Cover damage, destruction |
| `CombatGrid` | Debug | Cover add/remove operations |

---

## 13. Unit Testing Requirements

| Feature | Test Count |
|---------|------------|
| CoverType Enum | ~2 |
| CoverDefinition | ~3 |
| CoverObject Creation | ~4 |
| CoverObject.TakeDamage | ~4 |
| CombatGrid Cover Methods | ~4 |
| CoverService.GetCoverBetween | ~6 |
| CoverService.GetProtectingCover | ~4 |
| CoverService.DamageCover | ~3 |
| **Total** | **~30** |

---

## 14. Use Cases

### UC-001: Partial Cover Defense
**Flow:** Attack goblin → Cover between → +2 defense → Higher AC

### UC-002: Full Cover Blocks
**Flow:** Attack skeleton → Full cover → Cannot target → Fail with message

### UC-003: No Cover
**Flow:** Attack goblin → No cover in path → Normal AC

### UC-004: Destroy Cover
**Flow:** Attack crate → Damage applied → HP reaches 0 → Removed → Target exposed

### UC-005: Indestructible Cover
**Flow:** Attack pillar → Not destructible → Fail message

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `CoverType` enum
- [ ] `CoverDefinition` class
- [ ] `CoverObject` entity
- [ ] `CombatGrid` cover collection methods

### Application Layer
- [ ] `ICoverService` interface
- [ ] `CoverService` implementation
- [ ] `CoverCheckResult` record
- [ ] `CoverDamageResult` record

### Configuration
- [ ] `cover.json` with definitions
- [ ] `cover.schema.json`

### Testing
- [ ] ~30 unit tests
- [ ] All tests passing

---

## 16. Acceptance Criteria

### Functional
- [ ] CoverType enum has None, Partial, Full
- [ ] CoverDefinition stores all cover properties
- [ ] CoverObject tracks position and HP
- [ ] Partial cover provides +2 defense bonus (configurable)
- [ ] Full cover blocks targeting from that angle
- [ ] CoverService calculates cover between positions correctly
- [ ] Cover direction calculation works properly
- [ ] Destructible cover can take damage
- [ ] Destroyed cover is removed from grid
- [ ] Non-destructible cover ignores damage
- [ ] Cover configuration loads from JSON

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~30 unit tests pass
- [ ] XML documentation complete

---

## 17. Dependencies

### Required from v0.5.1c

| Type | Usage |
|------|-------|
| `LineOfSightService` | Line tracing for cover detection |
| `LineOfSightService.GetLineCells()` | Path between attacker/target |

### Required from v0.5.0a

| Type | Usage |
|------|-------|
| `CombatGrid` | Base for cover collection |
| `GridPosition` | Position for cover objects |

### Provides to v0.5.2c
- Cover objects for grid display
- Cover calculations for combat integration

---

## 18. Future Considerations

### Deferred to v0.5.2c
- Cover display on ASCII grid
- Combat defense integration in attack display

### Out of Scope for v0.5.2
- Dynamic cover placement by player
- Cover-based abilities
- Explosive cover (deals damage when destroyed)

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: AI Assistant*
