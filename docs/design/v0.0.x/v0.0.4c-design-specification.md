# v0.0.4c Implementation Plan: Ability System

## Overview

**Version:** 0.0.4c
**Status:** Implemented
**Focus:** Define and implement data-driven abilities with costs, cooldowns, and effects
**Prerequisites:** v0.0.4a (Archetype & Class Foundations), v0.0.4b (Resource Pool System)
**Estimated Unit Tests:** ~40
**Estimated Implementation Effort:** Medium-High complexity

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Prerequisites & Dependencies](#prerequisites--dependencies)
3. [Architecture Overview](#architecture-overview)
4. [Domain Layer Implementation](#domain-layer-implementation)
5. [Application Layer Implementation](#application-layer-implementation)
6. [Infrastructure Layer Implementation](#infrastructure-layer-implementation)
7. [Presentation Layer Implementation](#presentation-layer-implementation)
8. [Configuration Files](#configuration-files)
9. [Implementation Phases](#implementation-phases)
10. [Unit Test Specifications](#unit-test-specifications)
11. [Integration Points](#integration-points)
12. [Acceptance Criteria](#acceptance-criteria)
13. [Deliverable Checklist](#deliverable-checklist)

---

## Executive Summary

The Ability System (v0.0.4c) introduces a data-driven ability framework where abilities are loaded from JSON configuration, bound to player classes, and executed with resource costs and cooldown tracking. This system builds upon the Class System (v0.0.4a) and Resource Pool System (v0.0.4b) to create a complete class-based combat experience.

### Key Features
- **AbilityDefinition**: Data-driven ability templates loaded from `config/abilities.json`
- **Ability Costs**: Resource spending validation (Mana, Rage, Energy, Faith, Focus)
- **Ability Cooldowns**: Turn-based cooldown tracking per ability instance
- **Ability Effects**: Damage, healing, buffs, debuffs, and status application
- **Class-Ability Binding**: Classes define which abilities are available
- **Level-Based Unlocks**: Abilities unlock at specific character levels

### Design Principles
1. **Data-Driven**: All ability definitions externalized to JSON
2. **Extensible**: Effect system designed for future expansion
3. **Immutable Definitions**: AbilityDefinition is read-only; PlayerAbility tracks mutable state
4. **Separation of Concerns**: Definition (what) vs Instance (state) vs Service (behavior)

---

## Prerequisites & Dependencies

### From v0.0.4a (Archetype & Class Foundations)

| Component | Purpose for v0.0.4c |
|-----------|---------------------|
| `ClassDefinition` | Contains `StartingAbilityIds` and `PrimaryResourceId` |
| `ClassService` | Provides class lookup for ability binding |
| `Player.ClassId` | Determines which abilities are available |
| `Player.ArchetypeId` | May influence ability availability |

### From v0.0.4b (Resource Pool System)

| Component | Purpose for v0.0.4c |
|-----------|---------------------|
| `ResourceTypeDefinition` | Defines resource types used for ability costs |
| `ResourcePool` | Tracks player's current resource amounts |
| `ResourceService` | Handles `SpendResource()` for ability costs |
| `Player.Resources` | Dictionary of player's resource pools |
| `Player.GetResource()` | Retrieves specific resource pool |

### From Existing Codebase (v0.0.1)

| Component | Purpose for v0.0.4c |
|-----------|---------------------|
| `Player` | Target for ability effects, host for PlayerAbility collection |
| `Monster` | Target for damage/debuff effects |
| `Stats` | Modified by buff/debuff effects |
| `GameSessionService` | Integration point for ability commands |
| `CombatService` | Integration for combat ability execution |
| `IConfigurationLoader` | Interface for loading JSON configuration |

---

## Architecture Overview

### Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────────┐  ┌──────────────────────┐  ┌──────────────────┐   │
│  │   AbilityListView    │  │  AbilityDetailView   │  │  CombatView      │   │
│  │                      │  │                      │  │  (updated)       │   │
│  │ - DisplayAbilities() │  │ - DisplayDetails()   │  │                  │   │
│  │ - ShowCooldowns()    │  │ - ShowEffects()      │  │ - ShowAbilities()│   │
│  │ - ShowCosts()        │  │ - ShowRequirements() │  │ - HandleAbility()│   │
│  └──────────┬───────────┘  └──────────┬───────────┘  └────────┬─────────┘   │
│             │                         │                       │              │
└─────────────┼─────────────────────────┼───────────────────────┼──────────────┘
              │                         │                       │
              ▼                         ▼                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                          AbilityService                                │  │
│  ├───────────────────────────────────────────────────────────────────────┤  │
│  │ + GetAbilityDefinition(id) : AbilityDefinitionDto?                    │  │
│  │ + GetAllAbilities() : IReadOnlyList<AbilityDefinitionDto>             │  │
│  │ + GetAbilitiesForClass(classId) : IReadOnlyList<AbilityDefinitionDto> │  │
│  │ + GetPlayerAbilities(player) : IReadOnlyList<PlayerAbilityDto>        │  │
│  │ + CanUseAbility(player, abilityId) : AbilityValidationResult          │  │
│  │ + UseAbility(player, abilityId, target) : AbilityResult               │  │
│  │ + InitializePlayerAbilities(player, classId) : void                   │  │
│  │ + ProcessTurnEnd(player) : void  // Cooldown reduction                │  │
│  │ + UnlockAbility(player, abilityId) : bool                             │  │
│  │ + GetUnlockedAbilitiesAtLevel(classId, level) : IReadOnlyList<string> │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    GameSessionService (updated)                        │  │
│  ├───────────────────────────────────────────────────────────────────────┤  │
│  │ + TryUseAbility(abilityId, target) : AbilityResult  // NEW            │  │
│  │ + GetPlayerAbilities() : IReadOnlyList<PlayerAbilityDto>  // NEW      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                       CombatService (updated)                          │  │
│  ├───────────────────────────────────────────────────────────────────────┤  │
│  │ + ExecuteAbility(player, ability, target) : CombatResult  // NEW      │  │
│  │ + ApplyAbilityEffects(effects, target) : void  // NEW                 │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ENTITIES                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      AbilityDefinition                               │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + Id: string                      // "shield-bash", "flame-bolt"     │    │
│  │ + Name: string                    // "Shield Bash", "Flame Bolt"     │    │
│  │ + Description: string             // Full description text           │    │
│  │ + ClassIds: IReadOnlyList<string> // Classes that can use this       │    │
│  │ + Cost: AbilityCost               // Resource type and amount        │    │
│  │ + Cooldown: int                   // Turns between uses              │    │
│  │ + Effects: IReadOnlyList<AbilityEffect>  // What the ability does    │    │
│  │ + TargetType: AbilityTargetType   // Self, SingleEnemy, AllEnemies   │    │
│  │ + UnlockLevel: int                // Level required (default 1)      │    │
│  │ + Tags: IReadOnlyList<string>     // "damage", "heal", "buff", etc.  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        PlayerAbility                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + AbilityDefinitionId: string     // Reference to definition         │    │
│  │ + CurrentCooldown: int            // Turns until usable (0 = ready)  │    │
│  │ + TimesUsed: int                  // Usage statistics                │    │
│  │ + IsUnlocked: bool                // Whether player has unlocked     │    │
│  │ + UnlockedAt: DateTime?           // When it was unlocked            │    │
│  │ + IsReady: bool { get; }          // CurrentCooldown == 0            │    │
│  │ + Use(): void                     // Sets cooldown, increments used  │    │
│  │ + ReduceCooldown(amount): void    // Called at turn end              │    │
│  │ + ResetCooldown(): void           // Resets to 0                     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  VALUE OBJECTS                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         AbilityCost                                  │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + ResourceTypeId: string          // "mana", "rage", "energy"        │    │
│  │ + Amount: int                     // Cost amount                     │    │
│  │ + static None: AbilityCost        // Zero-cost ability               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        AbilityEffect                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + EffectType: AbilityEffectType   // Damage, Heal, Buff, Debuff, etc │    │
│  │ + Value: int                      // Amount (damage, heal, etc.)     │    │
│  │ + Duration: int                   // Turns for DoT/buffs (0=instant) │    │
│  │ + StatusEffect: string?           // "poison", "stun", "burning"     │    │
│  │ + StatModifier: StatModifiers?    // For buff/debuff effects         │    │
│  │ + Chance: float                   // Success chance (0.0-1.0)        │    │
│  │ + ScalingStat: string?            // Stat that scales effect         │    │
│  │ + ScalingMultiplier: float        // How much stat affects value     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ENUMS                                                                       │
│  ┌──────────────────────────┐  ┌───────────────────────────────────────┐    │
│  │   AbilityEffectType      │  │      AbilityTargetType                │    │
│  ├──────────────────────────┤  ├───────────────────────────────────────┤    │
│  │ • Damage                 │  │ • Self                                │    │
│  │ • Heal                   │  │ • SingleEnemy                         │    │
│  │ • Buff                   │  │ • AllEnemies                          │    │
│  │ • Debuff                 │  │ • SingleAlly (future)                 │    │
│  │ • DamageOverTime         │  │ • AllAllies (future)                  │    │
│  │ • HealOverTime           │  │ • Area (future)                       │    │
│  │ • Shield                 │  │                                       │    │
│  │ • Summon (future)        │  │                                       │    │
│  │ • Teleport (future)      │  │                                       │    │
│  │ • ResourceGain           │  │                                       │    │
│  │ • CooldownReset          │  │                                       │    │
│  └──────────────────────────┘  └───────────────────────────────────────┘    │
│                                                                              │
│  RECORDS                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ AbilityValidationResult(IsValid, FailureReason)                      │    │
│  │ AbilityResult(Success, EffectsApplied, Message, ResourceChange)      │    │
│  │ AppliedEffect(EffectType, Value, Target, WasResisted)                │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  PLAYER UPDATES                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        Player (additions)                            │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + Abilities: Dictionary<string, PlayerAbility>  // NEW               │    │
│  │ + GetAbility(abilityId): PlayerAbility?         // NEW               │    │
│  │ + HasAbility(abilityId): bool                   // NEW               │    │
│  │ + AddAbility(playerAbility): void               // NEW               │    │
│  │ + Level: int                                    // NEW (for unlocks) │    │
│  │ + ActiveBuffs: List<ActiveBuff>                 // NEW               │    │
│  │ + ActiveDebuffs: List<ActiveDebuff>             // NEW               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          INFRASTRUCTURE LAYER                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                  ConfigurationLoader (updated)                         │  │
│  ├───────────────────────────────────────────────────────────────────────┤  │
│  │ + LoadAbilities(path) : IReadOnlyList<AbilityDefinition>              │  │
│  │ + ValidateAbilityReferences(abilities, classes, resources) : bool     │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  Configuration Files:                                                        │
│  └── config/abilities.json                                                  │
│  └── config/abilities.schema.json                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Ability Execution Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        ABILITY EXECUTION FLOW                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────┐                                                       │
│  │ Player selects   │                                                       │
│  │ ability + target │                                                       │
│  └────────┬─────────┘                                                       │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                  1. VALIDATION PHASE                                │     │
│  │                     AbilityService.CanUseAbility()                  │     │
│  ├────────────────────────────────────────────────────────────────────┤     │
│  │                                                                     │     │
│  │  ┌─────────────────┐                                               │     │
│  │  │ Has Ability?    │──No──► Return: "Ability not learned"          │     │
│  │  └───────┬─────────┘                                               │     │
│  │          │ Yes                                                      │     │
│  │          ▼                                                          │     │
│  │  ┌─────────────────┐                                               │     │
│  │  │ Is Unlocked?    │──No──► Return: "Requires level X"             │     │
│  │  └───────┬─────────┘                                               │     │
│  │          │ Yes                                                      │     │
│  │          ▼                                                          │     │
│  │  ┌─────────────────┐                                               │     │
│  │  │ Off Cooldown?   │──No──► Return: "X turns remaining"            │     │
│  │  └───────┬─────────┘                                               │     │
│  │          │ Yes                                                      │     │
│  │          ▼                                                          │     │
│  │  ┌─────────────────┐                                               │     │
│  │  │ Has Resource?   │──No──► Return: "Need X resource"              │     │
│  │  └───────┬─────────┘                                               │     │
│  │          │ Yes                                                      │     │
│  │          ▼                                                          │     │
│  │  ┌─────────────────┐                                               │     │
│  │  │ Valid Target?   │──No──► Return: "Invalid target"               │     │
│  │  └───────┬─────────┘                                               │     │
│  │          │ Yes                                                      │     │
│  │          ▼                                                          │     │
│  │     Return: IsValid = true                                          │     │
│  │                                                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                  2. COST PHASE                                      │     │
│  │                     ResourceService.SpendResource()                 │     │
│  ├────────────────────────────────────────────────────────────────────┤     │
│  │                                                                     │     │
│  │  Deduct ability.Cost.Amount from player.Resources[resourceType]    │     │
│  │  Log: "Player spent 15 Mana on Flame Bolt"                         │     │
│  │                                                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                  3. COOLDOWN PHASE                                  │     │
│  │                     PlayerAbility.Use()                             │     │
│  ├────────────────────────────────────────────────────────────────────┤     │
│  │                                                                     │     │
│  │  Set playerAbility.CurrentCooldown = abilityDef.Cooldown           │     │
│  │  Increment playerAbility.TimesUsed                                 │     │
│  │                                                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                  4. EFFECT PHASE                                    │     │
│  │                     AbilityService.ApplyEffects()                   │     │
│  ├────────────────────────────────────────────────────────────────────┤     │
│  │                                                                     │     │
│  │  For each effect in ability.Effects:                               │     │
│  │                                                                     │     │
│  │    ┌─────────────────────────────────────────────────────────┐     │     │
│  │    │ Calculate final value:                                   │     │     │
│  │    │   baseValue = effect.Value                              │     │     │
│  │    │   if (effect.ScalingStat != null):                      │     │     │
│  │    │     scalingBonus = player.GetStat(scalingStat)          │     │     │
│  │    │                    * effect.ScalingMultiplier           │     │     │
│  │    │     finalValue = baseValue + scalingBonus               │     │     │
│  │    └─────────────────────────────────────────────────────────┘     │     │
│  │                                                                     │     │
│  │    ┌─────────────────────────────────────────────────────────┐     │     │
│  │    │ Check success (for effects with Chance < 1.0):          │     │     │
│  │    │   if (Random.NextDouble() > effect.Chance):             │     │     │
│  │    │     Log: "Effect failed to apply"                       │     │     │
│  │    │     continue                                            │     │     │
│  │    └─────────────────────────────────────────────────────────┘     │     │
│  │                                                                     │     │
│  │    Switch on effect.EffectType:                                    │     │
│  │                                                                     │     │
│  │    ┌──────────────┬─────────────────────────────────────────┐      │     │
│  │    │ Damage       │ target.TakeDamage(finalValue)           │      │     │
│  │    ├──────────────┼─────────────────────────────────────────┤      │     │
│  │    │ Heal         │ target.Heal(finalValue)                 │      │     │
│  │    ├──────────────┼─────────────────────────────────────────┤      │     │
│  │    │ Buff         │ target.AddBuff(effect, duration)        │      │     │
│  │    ├──────────────┼─────────────────────────────────────────┤      │     │
│  │    │ Debuff       │ target.AddDebuff(effect, duration)      │      │     │
│  │    ├──────────────┼─────────────────────────────────────────┤      │     │
│  │    │ DoT          │ target.AddDoT(effect.StatusEffect,      │      │     │
│  │    │              │              value, duration)           │      │     │
│  │    ├──────────────┼─────────────────────────────────────────┤      │     │
│  │    │ HoT          │ target.AddHoT(value, duration)          │      │     │
│  │    ├──────────────┼─────────────────────────────────────────┤      │     │
│  │    │ Shield       │ target.AddShield(value, duration)       │      │     │
│  │    ├──────────────┼─────────────────────────────────────────┤      │     │
│  │    │ ResourceGain │ player.GainResource(type, value)        │      │     │
│  │    └──────────────┴─────────────────────────────────────────┘      │     │
│  │                                                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                  5. RESULT PHASE                                    │     │
│  │                     Return AbilityResult                            │     │
│  ├────────────────────────────────────────────────────────────────────┤     │
│  │                                                                     │     │
│  │  Return AbilityResult {                                            │     │
│  │    Success = true,                                                 │     │
│  │    Message = "Flame Bolt deals 25 fire damage to Goblin!",        │     │
│  │    EffectsApplied = [ AppliedEffect { Damage, 25, Goblin } ],     │     │
│  │    ResourceSpent = ResourceChange { "mana", 100, 85, Spent }      │     │
│  │  }                                                                 │     │
│  │                                                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Turn End Processing

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      TURN END ABILITY PROCESSING                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  AbilityService.ProcessTurnEnd(player):                                     │
│                                                                              │
│  1. COOLDOWN REDUCTION                                                       │
│     ┌─────────────────────────────────────────────────────────────────┐     │
│     │ For each ability in player.Abilities:                           │     │
│     │   if (ability.CurrentCooldown > 0):                             │     │
│     │     ability.ReduceCooldown(1)                                   │     │
│     │     Log: "Shield Bash cooldown: 2 → 1"                          │     │
│     │   if (ability.CurrentCooldown == 0):                            │     │
│     │     Log: "Shield Bash is now ready!"                            │     │
│     └─────────────────────────────────────────────────────────────────┘     │
│                                                                              │
│  2. DoT/HoT PROCESSING (Future: v0.0.4d or later)                           │
│     ┌─────────────────────────────────────────────────────────────────┐     │
│     │ For each activeEffect in player.ActiveDebuffs (DoT):            │     │
│     │   player.TakeDamage(effect.Value)                               │     │
│     │   effect.Duration -= 1                                          │     │
│     │   if (effect.Duration <= 0):                                    │     │
│     │     player.ActiveDebuffs.Remove(effect)                         │     │
│     │                                                                  │     │
│     │ For each activeEffect in player.ActiveBuffs (HoT):              │     │
│     │   player.Heal(effect.Value)                                     │     │
│     │   effect.Duration -= 1                                          │     │
│     │   if (effect.Duration <= 0):                                    │     │
│     │     player.ActiveBuffs.Remove(effect)                           │     │
│     └─────────────────────────────────────────────────────────────────┘     │
│                                                                              │
│  3. BUFF/DEBUFF EXPIRATION (Future: v0.0.4d or later)                       │
│     ┌─────────────────────────────────────────────────────────────────┐     │
│     │ For each buff/debuff:                                           │     │
│     │   effect.Duration -= 1                                          │     │
│     │   if (effect.Duration <= 0):                                    │     │
│     │     Remove stat modifiers                                       │     │
│     │     Remove from active effects list                             │     │
│     │     Log: "Fortify buff has expired"                             │     │
│     └─────────────────────────────────────────────────────────────────┘     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Domain Layer Implementation

### 1. AbilityDefinition Entity

**File:** `src/Core/RuneAndRust.Domain/Entities/AbilityDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a data-driven ability definition loaded from configuration.
/// </summary>
/// <remarks>
/// AbilityDefinition is immutable and represents the template for abilities.
/// Actual ability state (cooldowns, usage) is tracked by PlayerAbility.
/// </remarks>
public class AbilityDefinition : IEntity
{
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the unique string identifier for this ability.
    /// </summary>
    /// <example>"shield-bash", "flame-bolt", "healing-word"</example>
    public string AbilityId { get; private set; }

    /// <summary>
    /// Gets the display name shown to players.
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// Gets the detailed description of the ability.
    /// </summary>
    public string Description { get; private set; }

    /// <summary>
    /// Gets the class IDs that can use this ability.
    /// </summary>
    public IReadOnlyList<string> ClassIds { get; private set; }

    /// <summary>
    /// Gets the resource cost to use this ability.
    /// </summary>
    public AbilityCost Cost { get; private set; }

    /// <summary>
    /// Gets the number of turns between uses.
    /// </summary>
    public int Cooldown { get; private set; }

    /// <summary>
    /// Gets the effects applied when the ability is used.
    /// </summary>
    public IReadOnlyList<AbilityEffect> Effects { get; private set; }

    /// <summary>
    /// Gets the valid target type for this ability.
    /// </summary>
    public AbilityTargetType TargetType { get; private set; }

    /// <summary>
    /// Gets the level required to unlock this ability.
    /// </summary>
    public int UnlockLevel { get; private set; }

    /// <summary>
    /// Gets tags for categorization and filtering.
    /// </summary>
    public IReadOnlyList<string> Tags { get; private set; }

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private AbilityDefinition()
    {
        AbilityId = null!;
        Name = null!;
        Description = null!;
        ClassIds = Array.Empty<string>();
        Effects = Array.Empty<AbilityEffect>();
        Tags = Array.Empty<string>();
    }

    /// <summary>
    /// Creates a new ability definition.
    /// </summary>
    public static AbilityDefinition Create(
        string abilityId,
        string name,
        string description,
        IEnumerable<string> classIds,
        AbilityCost cost,
        int cooldown,
        IEnumerable<AbilityEffect> effects,
        AbilityTargetType targetType,
        int unlockLevel = 1,
        IEnumerable<string>? tags = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(abilityId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentOutOfRangeException.ThrowIfNegative(cooldown);
        ArgumentOutOfRangeException.ThrowIfLessThan(unlockLevel, 1);

        return new AbilityDefinition
        {
            Id = Guid.NewGuid(),
            AbilityId = abilityId.ToLowerInvariant(),
            Name = name,
            Description = description,
            ClassIds = classIds.Select(c => c.ToLowerInvariant()).ToList(),
            Cost = cost,
            Cooldown = cooldown,
            Effects = effects.ToList(),
            TargetType = targetType,
            UnlockLevel = unlockLevel,
            Tags = tags?.Select(t => t.ToLowerInvariant()).ToList() ?? new List<string>()
        };
    }

    /// <summary>
    /// Gets whether this ability is available to a specific class.
    /// </summary>
    public bool IsAvailableToClass(string classId)
    {
        return ClassIds.Contains(classId.ToLowerInvariant(), StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets whether this ability has a cost.
    /// </summary>
    public bool HasCost => Cost.Amount > 0;

    /// <summary>
    /// Gets whether this ability has a cooldown.
    /// </summary>
    public bool HasCooldown => Cooldown > 0;

    /// <summary>
    /// Gets whether this ability is instant (no cooldown).
    /// </summary>
    public bool IsInstant => Cooldown == 0;
}
```

### 2. PlayerAbility Entity

**File:** `src/Core/RuneAndRust.Domain/Entities/PlayerAbility.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a player's instance of an ability with cooldown and usage tracking.
/// </summary>
public class PlayerAbility
{
    /// <summary>
    /// Gets the ID of the ability definition this instance represents.
    /// </summary>
    public string AbilityDefinitionId { get; private set; }

    /// <summary>
    /// Gets the current cooldown remaining (0 = ready to use).
    /// </summary>
    public int CurrentCooldown { get; private set; }

    /// <summary>
    /// Gets the number of times this ability has been used.
    /// </summary>
    public int TimesUsed { get; private set; }

    /// <summary>
    /// Gets whether the ability has been unlocked.
    /// </summary>
    public bool IsUnlocked { get; private set; }

    /// <summary>
    /// Gets when the ability was unlocked.
    /// </summary>
    public DateTime? UnlockedAt { get; private set; }

    /// <summary>
    /// Gets whether the ability is ready to use (off cooldown).
    /// </summary>
    public bool IsReady => CurrentCooldown == 0;

    /// <summary>
    /// Gets whether the ability is on cooldown.
    /// </summary>
    public bool IsOnCooldown => CurrentCooldown > 0;

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private PlayerAbility()
    {
        AbilityDefinitionId = null!;
    }

    /// <summary>
    /// Creates a new player ability instance.
    /// </summary>
    public static PlayerAbility Create(string abilityDefinitionId, bool isUnlocked = true)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(abilityDefinitionId);

        return new PlayerAbility
        {
            AbilityDefinitionId = abilityDefinitionId.ToLowerInvariant(),
            CurrentCooldown = 0,
            TimesUsed = 0,
            IsUnlocked = isUnlocked,
            UnlockedAt = isUnlocked ? DateTime.UtcNow : null
        };
    }

    /// <summary>
    /// Uses the ability, setting its cooldown and incrementing usage count.
    /// </summary>
    /// <param name="cooldownDuration">The cooldown to set from the ability definition.</param>
    public void Use(int cooldownDuration)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(cooldownDuration);

        CurrentCooldown = cooldownDuration;
        TimesUsed++;
    }

    /// <summary>
    /// Reduces the current cooldown by the specified amount.
    /// </summary>
    /// <param name="amount">Amount to reduce (default 1).</param>
    public void ReduceCooldown(int amount = 1)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(amount);
        CurrentCooldown = Math.Max(0, CurrentCooldown - amount);
    }

    /// <summary>
    /// Resets the cooldown to zero.
    /// </summary>
    public void ResetCooldown()
    {
        CurrentCooldown = 0;
    }

    /// <summary>
    /// Unlocks the ability for use.
    /// </summary>
    public void Unlock()
    {
        if (!IsUnlocked)
        {
            IsUnlocked = true;
            UnlockedAt = DateTime.UtcNow;
        }
    }

    /// <summary>
    /// Locks the ability, preventing use.
    /// </summary>
    public void Lock()
    {
        IsUnlocked = false;
    }
}
```

### 3. AbilityCost Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AbilityCost.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the resource cost to use an ability.
/// </summary>
public readonly record struct AbilityCost
{
    /// <summary>
    /// Gets the resource type required (e.g., "mana", "rage").
    /// </summary>
    public string ResourceTypeId { get; init; }

    /// <summary>
    /// Gets the amount of resource required.
    /// </summary>
    public int Amount { get; init; }

    /// <summary>
    /// Gets whether this cost requires any resource.
    /// </summary>
    public bool HasCost => Amount > 0 && !string.IsNullOrEmpty(ResourceTypeId);

    /// <summary>
    /// Gets a zero-cost instance for abilities with no resource cost.
    /// </summary>
    public static AbilityCost None => new() { ResourceTypeId = string.Empty, Amount = 0 };

    /// <summary>
    /// Creates a new ability cost.
    /// </summary>
    public static AbilityCost Create(string resourceTypeId, int amount)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(resourceTypeId);
        ArgumentOutOfRangeException.ThrowIfNegative(amount);

        return new AbilityCost
        {
            ResourceTypeId = resourceTypeId.ToLowerInvariant(),
            Amount = amount
        };
    }

    public override string ToString() => HasCost ? $"{Amount} {ResourceTypeId}" : "Free";
}
```

### 4. AbilityEffect Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AbilityEffect.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a single effect that an ability applies.
/// </summary>
public readonly record struct AbilityEffect
{
    /// <summary>
    /// Gets the type of effect.
    /// </summary>
    public AbilityEffectType EffectType { get; init; }

    /// <summary>
    /// Gets the base value of the effect.
    /// </summary>
    public int Value { get; init; }

    /// <summary>
    /// Gets the duration in turns (0 = instant).
    /// </summary>
    public int Duration { get; init; }

    /// <summary>
    /// Gets the status effect identifier (e.g., "poison", "stun").
    /// </summary>
    public string? StatusEffect { get; init; }

    /// <summary>
    /// Gets stat modifiers for buff/debuff effects.
    /// </summary>
    public StatModifiers? StatModifier { get; init; }

    /// <summary>
    /// Gets the success chance (0.0 to 1.0, default 1.0 = always succeeds).
    /// </summary>
    public float Chance { get; init; }

    /// <summary>
    /// Gets the stat that scales this effect's value.
    /// </summary>
    public string? ScalingStat { get; init; }

    /// <summary>
    /// Gets the multiplier for stat scaling.
    /// </summary>
    public float ScalingMultiplier { get; init; }

    /// <summary>
    /// Gets a description text override for this effect.
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// Gets whether this effect is instant (no duration).
    /// </summary>
    public bool IsInstant => Duration == 0;

    /// <summary>
    /// Gets whether this effect has stat scaling.
    /// </summary>
    public bool HasScaling => !string.IsNullOrEmpty(ScalingStat) && ScalingMultiplier != 0;

    /// <summary>
    /// Gets whether this effect has a chance to fail.
    /// </summary>
    public bool HasChance => Chance < 1.0f;

    /// <summary>
    /// Creates a damage effect.
    /// </summary>
    public static AbilityEffect Damage(int value, string? scalingStat = null, float scalingMultiplier = 0f)
    {
        return new AbilityEffect
        {
            EffectType = AbilityEffectType.Damage,
            Value = value,
            Duration = 0,
            Chance = 1.0f,
            ScalingStat = scalingStat,
            ScalingMultiplier = scalingMultiplier
        };
    }

    /// <summary>
    /// Creates a healing effect.
    /// </summary>
    public static AbilityEffect Heal(int value, string? scalingStat = null, float scalingMultiplier = 0f)
    {
        return new AbilityEffect
        {
            EffectType = AbilityEffectType.Heal,
            Value = value,
            Duration = 0,
            Chance = 1.0f,
            ScalingStat = scalingStat,
            ScalingMultiplier = scalingMultiplier
        };
    }

    /// <summary>
    /// Creates a damage-over-time effect.
    /// </summary>
    public static AbilityEffect DamageOverTime(int valuePerTurn, int duration, string statusEffect)
    {
        return new AbilityEffect
        {
            EffectType = AbilityEffectType.DamageOverTime,
            Value = valuePerTurn,
            Duration = duration,
            StatusEffect = statusEffect,
            Chance = 1.0f
        };
    }

    /// <summary>
    /// Creates a buff effect with stat modifiers.
    /// </summary>
    public static AbilityEffect Buff(StatModifiers modifiers, int duration, string? description = null)
    {
        return new AbilityEffect
        {
            EffectType = AbilityEffectType.Buff,
            Value = 0,
            Duration = duration,
            StatModifier = modifiers,
            Chance = 1.0f,
            Description = description
        };
    }

    /// <summary>
    /// Creates a debuff effect with stat modifiers.
    /// </summary>
    public static AbilityEffect Debuff(StatModifiers modifiers, int duration, float chance = 1.0f)
    {
        return new AbilityEffect
        {
            EffectType = AbilityEffectType.Debuff,
            Value = 0,
            Duration = duration,
            StatModifier = modifiers,
            Chance = chance
        };
    }

    /// <summary>
    /// Creates a shield/absorb effect.
    /// </summary>
    public static AbilityEffect Shield(int absorbAmount, int duration)
    {
        return new AbilityEffect
        {
            EffectType = AbilityEffectType.Shield,
            Value = absorbAmount,
            Duration = duration,
            Chance = 1.0f
        };
    }

    /// <summary>
    /// Creates a status effect with a chance to apply.
    /// </summary>
    public static AbilityEffect Status(string statusEffect, int duration, float chance = 1.0f)
    {
        return new AbilityEffect
        {
            EffectType = AbilityEffectType.Debuff,
            Value = 0,
            Duration = duration,
            StatusEffect = statusEffect,
            Chance = chance
        };
    }
}
```

### 5. Enums

**File:** `src/Core/RuneAndRust.Domain/Enums/AbilityEffectType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the types of effects an ability can have.
/// </summary>
public enum AbilityEffectType
{
    /// <summary>Deals immediate damage to the target.</summary>
    Damage,

    /// <summary>Restores health to the target.</summary>
    Heal,

    /// <summary>Applies a positive stat modifier to the target.</summary>
    Buff,

    /// <summary>Applies a negative stat modifier to the target.</summary>
    Debuff,

    /// <summary>Deals damage over multiple turns.</summary>
    DamageOverTime,

    /// <summary>Heals over multiple turns.</summary>
    HealOverTime,

    /// <summary>Creates a damage-absorbing shield.</summary>
    Shield,

    /// <summary>Grants resource to the caster.</summary>
    ResourceGain,

    /// <summary>Resets cooldown of another ability.</summary>
    CooldownReset,

    /// <summary>Forces target to attack caster (taunt).</summary>
    Taunt,

    /// <summary>Prevents target from acting (stun).</summary>
    Stun,

    /// <summary>Summons an entity (future feature).</summary>
    Summon,

    /// <summary>Teleports the caster or target (future feature).</summary>
    Teleport
}
```

**File:** `src/Core/RuneAndRust.Domain/Enums/AbilityTargetType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines valid target types for abilities.
/// </summary>
public enum AbilityTargetType
{
    /// <summary>Targets the caster themselves.</summary>
    Self,

    /// <summary>Targets a single enemy.</summary>
    SingleEnemy,

    /// <summary>Targets all enemies in combat.</summary>
    AllEnemies,

    /// <summary>Targets a single ally (future feature).</summary>
    SingleAlly,

    /// <summary>Targets all allies (future feature).</summary>
    AllAllies,

    /// <summary>Targets an area (future feature).</summary>
    Area,

    /// <summary>No target required (passive or toggle).</summary>
    None
}
```

### 6. Result Records

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AbilityResults.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of validating whether an ability can be used.
/// </summary>
/// <param name="IsValid">Whether the ability can be used.</param>
/// <param name="FailureReason">Reason for failure if not valid.</param>
public record AbilityValidationResult(bool IsValid, string? FailureReason = null)
{
    public static AbilityValidationResult Success => new(true);

    public static AbilityValidationResult Fail(string reason) => new(false, reason);

    public static AbilityValidationResult AbilityNotFound => Fail("Ability not found");
    public static AbilityValidationResult AbilityNotLearned => Fail("You haven't learned this ability");
    public static AbilityValidationResult AbilityLocked(int requiredLevel) => Fail($"Requires level {requiredLevel}");
    public static AbilityValidationResult OnCooldown(int turnsRemaining) => Fail($"On cooldown ({turnsRemaining} turns remaining)");
    public static AbilityValidationResult InsufficientResource(string resource, int have, int need) =>
        Fail($"Insufficient {resource}: have {have}, need {need}");
    public static AbilityValidationResult InvalidTarget => Fail("Invalid target for this ability");
    public static AbilityValidationResult NotInCombat => Fail("Can only use this ability in combat");
}

/// <summary>
/// Result of using an ability.
/// </summary>
/// <param name="Success">Whether the ability was used successfully.</param>
/// <param name="Message">Description of what happened.</param>
/// <param name="EffectsApplied">List of effects that were applied.</param>
/// <param name="ResourceSpent">Resource change from the ability cost.</param>
public record AbilityResult(
    bool Success,
    string Message,
    IReadOnlyList<AppliedEffect> EffectsApplied,
    ResourceChange? ResourceSpent = null)
{
    public static AbilityResult Failed(string reason) => new(false, reason, Array.Empty<AppliedEffect>());

    public bool HasEffects => EffectsApplied.Count > 0;

    public int TotalDamageDealt => EffectsApplied
        .Where(e => e.EffectType == AbilityEffectType.Damage && !e.WasResisted)
        .Sum(e => e.Value);

    public int TotalHealingDone => EffectsApplied
        .Where(e => e.EffectType == AbilityEffectType.Heal && !e.WasResisted)
        .Sum(e => e.Value);
}

/// <summary>
/// Represents an effect that was applied during ability execution.
/// </summary>
/// <param name="EffectType">The type of effect applied.</param>
/// <param name="Value">The actual value applied.</param>
/// <param name="TargetName">Name of the target affected.</param>
/// <param name="WasResisted">Whether the effect was resisted.</param>
/// <param name="StatusApplied">Status effect applied, if any.</param>
public record AppliedEffect(
    AbilityEffectType EffectType,
    int Value,
    string TargetName,
    bool WasResisted = false,
    string? StatusApplied = null)
{
    public string GetDescription()
    {
        if (WasResisted)
            return $"{TargetName} resisted the effect";

        return EffectType switch
        {
            AbilityEffectType.Damage => $"Deals {Value} damage to {TargetName}",
            AbilityEffectType.Heal => $"Heals {TargetName} for {Value}",
            AbilityEffectType.Buff => $"Applies buff to {TargetName}",
            AbilityEffectType.Debuff => $"Applies debuff to {TargetName}",
            AbilityEffectType.DamageOverTime => $"Applies {StatusApplied} to {TargetName} ({Value}/turn)",
            AbilityEffectType.Shield => $"Shields {TargetName} for {Value}",
            AbilityEffectType.Stun => $"Stuns {TargetName}",
            AbilityEffectType.Taunt => $"Taunts {TargetName}",
            _ => $"Applies {EffectType} to {TargetName}"
        };
    }
}
```

### 7. Player Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs` (additions)

```csharp
// Add to existing Player class:

/// <summary>
/// Gets the player's abilities keyed by ability definition ID.
/// </summary>
public Dictionary<string, PlayerAbility> Abilities { get; private set; } = new();

/// <summary>
/// Gets the player's current level.
/// </summary>
public int Level { get; private set; } = 1;

/// <summary>
/// Gets a specific ability by its definition ID.
/// </summary>
public PlayerAbility? GetAbility(string abilityId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(abilityId);
    return Abilities.TryGetValue(abilityId.ToLowerInvariant(), out var ability) ? ability : null;
}

/// <summary>
/// Checks whether the player has a specific ability.
/// </summary>
public bool HasAbility(string abilityId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(abilityId);
    return Abilities.ContainsKey(abilityId.ToLowerInvariant());
}

/// <summary>
/// Adds an ability to the player's ability collection.
/// </summary>
public void AddAbility(PlayerAbility ability)
{
    ArgumentNullException.ThrowIfNull(ability);
    Abilities[ability.AbilityDefinitionId] = ability;
}

/// <summary>
/// Removes an ability from the player's collection.
/// </summary>
public bool RemoveAbility(string abilityId)
{
    ArgumentException.ThrowIfNullOrWhiteSpace(abilityId);
    return Abilities.Remove(abilityId.ToLowerInvariant());
}

/// <summary>
/// Gets all abilities that are ready to use.
/// </summary>
public IEnumerable<PlayerAbility> GetReadyAbilities()
{
    return Abilities.Values.Where(a => a.IsReady && a.IsUnlocked);
}

/// <summary>
/// Sets the player's level.
/// </summary>
public void SetLevel(int level)
{
    ArgumentOutOfRangeException.ThrowIfLessThan(level, 1);
    Level = level;
}
```

---

## Application Layer Implementation

### 1. AbilityService

**File:** `src/Core/RuneAndRust.Application/Services/AbilityService.cs`

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages ability definitions, player abilities, and ability execution.
/// </summary>
public class AbilityService
{
    private readonly IReadOnlyList<AbilityDefinition> _abilityDefinitions;
    private readonly ResourceService _resourceService;
    private readonly ILogger<AbilityService> _logger;

    public AbilityService(
        IConfigurationLoader configLoader,
        ResourceService resourceService,
        ILogger<AbilityService> logger)
    {
        _resourceService = resourceService;
        _logger = logger;
        _abilityDefinitions = configLoader.LoadAbilities("config/abilities.json");

        _logger.LogInformation(
            "AbilityService initialized with {AbilityCount} ability definitions",
            _abilityDefinitions.Count);
    }

    /// <summary>
    /// Gets an ability definition by ID.
    /// </summary>
    public AbilityDefinition? GetAbilityDefinition(string abilityId)
    {
        _logger.LogDebug("GetAbilityDefinition: {AbilityId}", abilityId);
        return _abilityDefinitions.FirstOrDefault(
            a => a.AbilityId.Equals(abilityId, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Gets all ability definitions.
    /// </summary>
    public IReadOnlyList<AbilityDefinitionDto> GetAllAbilities()
    {
        return _abilityDefinitions.Select(a => a.ToDto()).ToList();
    }

    /// <summary>
    /// Gets abilities available to a specific class.
    /// </summary>
    public IReadOnlyList<AbilityDefinitionDto> GetAbilitiesForClass(string classId)
    {
        _logger.LogDebug("GetAbilitiesForClass: {ClassId}", classId);
        return _abilityDefinitions
            .Where(a => a.IsAvailableToClass(classId))
            .Select(a => a.ToDto())
            .ToList();
    }

    /// <summary>
    /// Gets a player's abilities with current state.
    /// </summary>
    public IReadOnlyList<PlayerAbilityDto> GetPlayerAbilities(Player player)
    {
        _logger.LogDebug("GetPlayerAbilities: {PlayerName}", player.Name);

        return player.Abilities.Values
            .Select(pa =>
            {
                var definition = GetAbilityDefinition(pa.AbilityDefinitionId);
                return new PlayerAbilityDto(
                    pa.AbilityDefinitionId,
                    definition?.Name ?? pa.AbilityDefinitionId,
                    definition?.Description ?? "",
                    pa.CurrentCooldown,
                    definition?.Cooldown ?? 0,
                    pa.IsReady,
                    pa.IsUnlocked,
                    definition?.Cost.Amount ?? 0,
                    definition?.Cost.ResourceTypeId ?? "",
                    pa.TimesUsed);
            })
            .ToList();
    }

    /// <summary>
    /// Validates whether a player can use an ability.
    /// </summary>
    public AbilityValidationResult CanUseAbility(Player player, string abilityId)
    {
        _logger.LogDebug("CanUseAbility: Player {PlayerName}, Ability {AbilityId}",
            player.Name, abilityId);

        // Check if ability definition exists
        var definition = GetAbilityDefinition(abilityId);
        if (definition == null)
        {
            _logger.LogWarning("Ability not found: {AbilityId}", abilityId);
            return AbilityValidationResult.AbilityNotFound;
        }

        // Check if player has the ability
        var playerAbility = player.GetAbility(abilityId);
        if (playerAbility == null)
        {
            _logger.LogDebug("Player {PlayerName} doesn't have ability {AbilityId}",
                player.Name, abilityId);
            return AbilityValidationResult.AbilityNotLearned;
        }

        // Check if ability is unlocked
        if (!playerAbility.IsUnlocked)
        {
            _logger.LogDebug("Ability {AbilityId} is locked for player {PlayerName}",
                abilityId, player.Name);
            return AbilityValidationResult.AbilityLocked(definition.UnlockLevel);
        }

        // Check cooldown
        if (playerAbility.IsOnCooldown)
        {
            _logger.LogDebug("Ability {AbilityId} is on cooldown: {Cooldown} turns",
                abilityId, playerAbility.CurrentCooldown);
            return AbilityValidationResult.OnCooldown(playerAbility.CurrentCooldown);
        }

        // Check resource cost
        if (definition.HasCost)
        {
            var resourcePool = player.GetResource(definition.Cost.ResourceTypeId);
            if (resourcePool == null)
            {
                _logger.LogWarning("Player {PlayerName} missing resource type {ResourceType}",
                    player.Name, definition.Cost.ResourceTypeId);
                return AbilityValidationResult.InsufficientResource(
                    definition.Cost.ResourceTypeId, 0, definition.Cost.Amount);
            }

            if (resourcePool.Current < definition.Cost.Amount)
            {
                _logger.LogDebug("Insufficient {ResourceType}: have {Have}, need {Need}",
                    definition.Cost.ResourceTypeId, resourcePool.Current, definition.Cost.Amount);
                return AbilityValidationResult.InsufficientResource(
                    definition.Cost.ResourceTypeId, resourcePool.Current, definition.Cost.Amount);
            }
        }

        return AbilityValidationResult.Success;
    }

    /// <summary>
    /// Uses an ability on a target.
    /// </summary>
    public AbilityResult UseAbility(Player player, string abilityId, object? target = null)
    {
        _logger.LogDebug("UseAbility: Player {PlayerName}, Ability {AbilityId}",
            player.Name, abilityId);

        // Validate
        var validation = CanUseAbility(player, abilityId);
        if (!validation.IsValid)
        {
            _logger.LogInformation("Ability use failed: {Reason}", validation.FailureReason);
            return AbilityResult.Failed(validation.FailureReason!);
        }

        var definition = GetAbilityDefinition(abilityId)!;
        var playerAbility = player.GetAbility(abilityId)!;

        // Spend resource
        ResourceChange? resourceSpent = null;
        if (definition.HasCost)
        {
            var pool = player.GetResource(definition.Cost.ResourceTypeId)!;
            var previousValue = pool.Current;
            _resourceService.SpendResource(player, definition.Cost.ResourceTypeId, definition.Cost.Amount);

            resourceSpent = new ResourceChange(
                definition.Cost.ResourceTypeId,
                previousValue,
                pool.Current,
                ResourceChangeType.Spent);

            _logger.LogInformation(
                "Player {PlayerName} spent {Amount} {Resource} on {Ability}",
                player.Name, definition.Cost.Amount, definition.Cost.ResourceTypeId, definition.Name);
        }

        // Set cooldown
        playerAbility.Use(definition.Cooldown);

        // Apply effects
        var appliedEffects = ApplyEffects(player, definition, target);

        // Build result message
        var message = BuildResultMessage(definition, appliedEffects);

        _logger.LogInformation(
            "Player {PlayerName} used {Ability}: {Message}",
            player.Name, definition.Name, message);

        return new AbilityResult(true, message, appliedEffects, resourceSpent);
    }

    /// <summary>
    /// Applies ability effects to target(s).
    /// </summary>
    private List<AppliedEffect> ApplyEffects(Player player, AbilityDefinition definition, object? target)
    {
        var applied = new List<AppliedEffect>();
        var random = new Random();

        foreach (var effect in definition.Effects)
        {
            // Check success chance
            if (effect.HasChance && random.NextDouble() > effect.Chance)
            {
                _logger.LogDebug("Effect {EffectType} failed chance check", effect.EffectType);
                continue;
            }

            // Calculate final value with scaling
            var finalValue = effect.Value;
            if (effect.HasScaling && !string.IsNullOrEmpty(effect.ScalingStat))
            {
                var statValue = GetPlayerStat(player, effect.ScalingStat);
                finalValue += (int)(statValue * effect.ScalingMultiplier);
            }

            // Apply based on effect type
            var targetName = GetTargetName(target, definition.TargetType);
            var appliedEffect = ApplySingleEffect(effect, finalValue, target, targetName, player);
            if (appliedEffect != null)
            {
                applied.Add(appliedEffect);
            }
        }

        return applied;
    }

    private AppliedEffect? ApplySingleEffect(
        AbilityEffect effect,
        int value,
        object? target,
        string targetName,
        Player player)
    {
        switch (effect.EffectType)
        {
            case AbilityEffectType.Damage:
                if (target is Monster monster)
                {
                    monster.TakeDamage(value);
                    return new AppliedEffect(effect.EffectType, value, targetName);
                }
                break;

            case AbilityEffectType.Heal:
                if (target == null || target == player)
                {
                    player.Heal(value);
                    return new AppliedEffect(effect.EffectType, value, player.Name);
                }
                break;

            case AbilityEffectType.Shield:
                // Shield implementation would go here (future)
                return new AppliedEffect(effect.EffectType, value, player.Name);

            case AbilityEffectType.Buff:
                // Buff implementation would go here (future)
                return new AppliedEffect(effect.EffectType, value, player.Name);

            case AbilityEffectType.Debuff:
                if (target is Monster m)
                {
                    // Debuff implementation would go here (future)
                    return new AppliedEffect(effect.EffectType, value, targetName,
                        statusApplied: effect.StatusEffect);
                }
                break;

            case AbilityEffectType.DamageOverTime:
                // DoT implementation would go here (future)
                return new AppliedEffect(effect.EffectType, value, targetName,
                    statusApplied: effect.StatusEffect);

            case AbilityEffectType.Stun:
                // Stun implementation would go here (future)
                return new AppliedEffect(effect.EffectType, value, targetName);

            case AbilityEffectType.Taunt:
                // Taunt implementation would go here (future)
                return new AppliedEffect(effect.EffectType, value, targetName);
        }

        return null;
    }

    private int GetPlayerStat(Player player, string statName)
    {
        return statName.ToLowerInvariant() switch
        {
            "attack" => player.Stats.Attack,
            "defense" => player.Stats.Defense,
            "maxhealth" => player.Stats.MaxHealth,
            "might" => player.Stats.Attack, // Placeholder until full attributes
            "will" => player.Stats.Attack,  // Placeholder
            _ => 0
        };
    }

    private string GetTargetName(object? target, AbilityTargetType targetType)
    {
        if (target is Monster monster)
            return monster.Name;
        if (target is Player player)
            return player.Name;
        return targetType == AbilityTargetType.Self ? "self" : "target";
    }

    private string BuildResultMessage(AbilityDefinition definition, List<AppliedEffect> effects)
    {
        if (effects.Count == 0)
            return $"{definition.Name} had no effect";

        var parts = effects.Select(e => e.GetDescription());
        return $"{definition.Name}: {string.Join(", ", parts)}";
    }

    /// <summary>
    /// Initializes abilities for a player based on their class.
    /// </summary>
    public void InitializePlayerAbilities(Player player, string classId)
    {
        _logger.LogDebug("InitializePlayerAbilities: Player {PlayerName}, Class {ClassId}",
            player.Name, classId);

        var classAbilities = _abilityDefinitions
            .Where(a => a.IsAvailableToClass(classId) && a.UnlockLevel <= player.Level)
            .ToList();

        foreach (var ability in classAbilities)
        {
            var playerAbility = PlayerAbility.Create(ability.AbilityId, isUnlocked: true);
            player.AddAbility(playerAbility);

            _logger.LogInformation(
                "Initialized ability {Ability} for player {PlayerName}",
                ability.Name, player.Name);
        }
    }

    /// <summary>
    /// Processes turn end for ability cooldowns.
    /// </summary>
    public void ProcessTurnEnd(Player player)
    {
        _logger.LogDebug("ProcessTurnEnd abilities for: {PlayerName}", player.Name);

        foreach (var ability in player.Abilities.Values)
        {
            if (ability.IsOnCooldown)
            {
                var previousCooldown = ability.CurrentCooldown;
                ability.ReduceCooldown();

                _logger.LogDebug(
                    "Ability {AbilityId} cooldown: {Previous} → {Current}",
                    ability.AbilityDefinitionId, previousCooldown, ability.CurrentCooldown);

                if (ability.IsReady)
                {
                    var def = GetAbilityDefinition(ability.AbilityDefinitionId);
                    _logger.LogInformation(
                        "{Ability} is now ready for player {PlayerName}",
                        def?.Name ?? ability.AbilityDefinitionId, player.Name);
                }
            }
        }
    }

    /// <summary>
    /// Unlocks an ability for a player.
    /// </summary>
    public bool UnlockAbility(Player player, string abilityId)
    {
        var ability = player.GetAbility(abilityId);
        if (ability == null)
        {
            var definition = GetAbilityDefinition(abilityId);
            if (definition == null)
                return false;

            ability = PlayerAbility.Create(abilityId, isUnlocked: true);
            player.AddAbility(ability);
        }
        else
        {
            ability.Unlock();
        }

        _logger.LogInformation(
            "Unlocked ability {AbilityId} for player {PlayerName}",
            abilityId, player.Name);

        return true;
    }

    /// <summary>
    /// Gets abilities that should unlock at a specific level for a class.
    /// </summary>
    public IReadOnlyList<string> GetUnlockedAbilitiesAtLevel(string classId, int level)
    {
        return _abilityDefinitions
            .Where(a => a.IsAvailableToClass(classId) && a.UnlockLevel == level)
            .Select(a => a.AbilityId)
            .ToList();
    }
}
```

### 2. DTOs

**File:** `src/Core/RuneAndRust.Application/DTOs/AbilityDtos.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Data transfer object for ability definitions.
/// </summary>
public record AbilityDefinitionDto(
    string AbilityId,
    string Name,
    string Description,
    IReadOnlyList<string> ClassIds,
    int CostAmount,
    string CostResourceType,
    int Cooldown,
    string TargetType,
    int UnlockLevel,
    IReadOnlyList<string> Tags,
    IReadOnlyList<AbilityEffectDto> Effects);

/// <summary>
/// Data transfer object for ability effects.
/// </summary>
public record AbilityEffectDto(
    string EffectType,
    int Value,
    int Duration,
    string? StatusEffect,
    float Chance);

/// <summary>
/// Data transfer object for a player's ability instance.
/// </summary>
public record PlayerAbilityDto(
    string AbilityId,
    string Name,
    string Description,
    int CurrentCooldown,
    int MaxCooldown,
    bool IsReady,
    bool IsUnlocked,
    int Cost,
    string CostResourceType,
    int TimesUsed);
```

---

## Infrastructure Layer Implementation

### 1. ConfigurationLoader Updates

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/ConfigurationLoader.cs` (additions)

```csharp
/// <summary>
/// Loads ability definitions from configuration.
/// </summary>
public IReadOnlyList<AbilityDefinition> LoadAbilities(string path)
{
    _logger.LogDebug("Loading abilities from: {Path}", path);

    var json = File.ReadAllText(path);
    var config = JsonSerializer.Deserialize<AbilitiesConfig>(json, _jsonOptions);

    if (config?.Abilities == null)
    {
        _logger.LogWarning("No abilities found in configuration");
        return Array.Empty<AbilityDefinition>();
    }

    var abilities = config.Abilities.Select(CreateAbilityDefinition).ToList();

    _logger.LogInformation(
        "Loaded {Count} ability definitions from {Path}",
        abilities.Count, path);

    return abilities;
}

private AbilityDefinition CreateAbilityDefinition(AbilityConfigEntry entry)
{
    var cost = string.IsNullOrEmpty(entry.CostResource)
        ? AbilityCost.None
        : AbilityCost.Create(entry.CostResource, entry.CostAmount);

    var effects = entry.Effects?.Select(CreateAbilityEffect).ToList()
                  ?? new List<AbilityEffect>();

    return AbilityDefinition.Create(
        entry.Id,
        entry.Name,
        entry.Description,
        entry.ClassIds,
        cost,
        entry.Cooldown,
        effects,
        Enum.Parse<AbilityTargetType>(entry.TargetType, ignoreCase: true),
        entry.UnlockLevel,
        entry.Tags);
}

private AbilityEffect CreateAbilityEffect(EffectConfigEntry entry)
{
    return new AbilityEffect
    {
        EffectType = Enum.Parse<AbilityEffectType>(entry.Type, ignoreCase: true),
        Value = entry.Value,
        Duration = entry.Duration,
        StatusEffect = entry.StatusEffect,
        Chance = entry.Chance,
        ScalingStat = entry.ScalingStat,
        ScalingMultiplier = entry.ScalingMultiplier
    };
}

// Configuration model classes
private class AbilitiesConfig
{
    public List<AbilityConfigEntry>? Abilities { get; set; }
}

private class AbilityConfigEntry
{
    public string Id { get; set; } = "";
    public string Name { get; set; } = "";
    public string Description { get; set; } = "";
    public List<string> ClassIds { get; set; } = new();
    public string CostResource { get; set; } = "";
    public int CostAmount { get; set; }
    public int Cooldown { get; set; }
    public string TargetType { get; set; } = "SingleEnemy";
    public int UnlockLevel { get; set; } = 1;
    public List<string>? Tags { get; set; }
    public List<EffectConfigEntry>? Effects { get; set; }
}

private class EffectConfigEntry
{
    public string Type { get; set; } = "";
    public int Value { get; set; }
    public int Duration { get; set; }
    public string? StatusEffect { get; set; }
    public float Chance { get; set; } = 1.0f;
    public string? ScalingStat { get; set; }
    public float ScalingMultiplier { get; set; }
}
```

---

## Configuration Files

### abilities.json

**File:** `config/abilities.json`

```json
{
  "$schema": "abilities.schema.json",
  "abilities": [
    {
      "id": "shield-bash",
      "name": "Shield Bash",
      "description": "Slam your shield into an enemy, dealing damage with a chance to stun.",
      "classIds": ["shieldmaiden"],
      "costResource": "rage",
      "costAmount": 15,
      "cooldown": 2,
      "targetType": "SingleEnemy",
      "unlockLevel": 1,
      "tags": ["damage", "melee", "stun"],
      "effects": [
        {
          "type": "Damage",
          "value": 15,
          "scalingStat": "attack",
          "scalingMultiplier": 0.5
        },
        {
          "type": "Stun",
          "value": 1,
          "duration": 1,
          "chance": 0.3
        }
      ]
    },
    {
      "id": "taunt",
      "name": "Taunt",
      "description": "Force an enemy to attack you instead of your allies.",
      "classIds": ["shieldmaiden"],
      "costResource": "rage",
      "costAmount": 10,
      "cooldown": 3,
      "targetType": "SingleEnemy",
      "unlockLevel": 1,
      "tags": ["utility", "tank"],
      "effects": [
        {
          "type": "Taunt",
          "value": 0,
          "duration": 2
        }
      ]
    },
    {
      "id": "fortify",
      "name": "Fortify",
      "description": "Harden your defenses, increasing your defense for 3 turns.",
      "classIds": ["shieldmaiden"],
      "costResource": "rage",
      "costAmount": 20,
      "cooldown": 5,
      "targetType": "Self",
      "unlockLevel": 3,
      "tags": ["buff", "defense", "tank"],
      "effects": [
        {
          "type": "Buff",
          "value": 5,
          "duration": 3,
          "description": "+5 Defense"
        }
      ]
    },
    {
      "id": "backstab",
      "name": "Backstab",
      "description": "Strike from the shadows for massive damage. More effective when undetected.",
      "classIds": ["shadow-walker"],
      "costResource": "energy",
      "costAmount": 25,
      "cooldown": 3,
      "targetType": "SingleEnemy",
      "unlockLevel": 1,
      "tags": ["damage", "melee", "stealth"],
      "effects": [
        {
          "type": "Damage",
          "value": 35,
          "scalingStat": "attack",
          "scalingMultiplier": 0.8
        }
      ]
    },
    {
      "id": "shadowstep",
      "name": "Shadowstep",
      "description": "Teleport behind your target, gaining an advantageous position.",
      "classIds": ["shadow-walker"],
      "costResource": "energy",
      "costAmount": 15,
      "cooldown": 2,
      "targetType": "SingleEnemy",
      "unlockLevel": 1,
      "tags": ["utility", "movement", "stealth"],
      "effects": [
        {
          "type": "Buff",
          "value": 0,
          "duration": 1,
          "description": "Behind target - next attack has +50% damage"
        }
      ]
    },
    {
      "id": "poison-blade",
      "name": "Poison Blade",
      "description": "Coat your weapon in poison, causing damage over time.",
      "classIds": ["shadow-walker"],
      "costResource": "energy",
      "costAmount": 20,
      "cooldown": 4,
      "targetType": "SingleEnemy",
      "unlockLevel": 3,
      "tags": ["damage", "dot", "poison"],
      "effects": [
        {
          "type": "Damage",
          "value": 10
        },
        {
          "type": "DamageOverTime",
          "value": 5,
          "duration": 3,
          "statusEffect": "poison"
        }
      ]
    },
    {
      "id": "flame-bolt",
      "name": "Flame Bolt",
      "description": "Hurl a bolt of fire at your enemy, dealing fire damage.",
      "classIds": ["galdr-caster"],
      "costResource": "mana",
      "costAmount": 15,
      "cooldown": 0,
      "targetType": "SingleEnemy",
      "unlockLevel": 1,
      "tags": ["damage", "ranged", "fire", "magic"],
      "effects": [
        {
          "type": "Damage",
          "value": 20,
          "scalingStat": "will",
          "scalingMultiplier": 0.6
        }
      ]
    },
    {
      "id": "frost-nova",
      "name": "Frost Nova",
      "description": "Unleash a wave of frost, damaging and slowing all enemies.",
      "classIds": ["galdr-caster"],
      "costResource": "mana",
      "costAmount": 25,
      "cooldown": 4,
      "targetType": "AllEnemies",
      "unlockLevel": 2,
      "tags": ["damage", "aoe", "ice", "magic", "slow"],
      "effects": [
        {
          "type": "Damage",
          "value": 12,
          "scalingStat": "will",
          "scalingMultiplier": 0.4
        },
        {
          "type": "Debuff",
          "value": 0,
          "duration": 2,
          "statusEffect": "slow"
        }
      ]
    },
    {
      "id": "arcane-shield",
      "name": "Arcane Shield",
      "description": "Create a magical barrier that absorbs incoming damage.",
      "classIds": ["galdr-caster"],
      "costResource": "mana",
      "costAmount": 20,
      "cooldown": 5,
      "targetType": "Self",
      "unlockLevel": 1,
      "tags": ["buff", "defense", "magic", "shield"],
      "effects": [
        {
          "type": "Shield",
          "value": 25,
          "duration": 2,
          "scalingStat": "will",
          "scalingMultiplier": 0.5
        }
      ]
    },
    {
      "id": "healing-word",
      "name": "Healing Word",
      "description": "Speak a word of power that restores health.",
      "classIds": ["blood-priest"],
      "costResource": "faith",
      "costAmount": 20,
      "cooldown": 2,
      "targetType": "Self",
      "unlockLevel": 1,
      "tags": ["heal", "support", "holy"],
      "effects": [
        {
          "type": "Heal",
          "value": 25,
          "scalingStat": "will",
          "scalingMultiplier": 0.6
        }
      ]
    },
    {
      "id": "smite",
      "name": "Smite",
      "description": "Call down holy wrath upon your enemy.",
      "classIds": ["blood-priest"],
      "costResource": "faith",
      "costAmount": 15,
      "cooldown": 1,
      "targetType": "SingleEnemy",
      "unlockLevel": 1,
      "tags": ["damage", "ranged", "holy", "magic"],
      "effects": [
        {
          "type": "Damage",
          "value": 18,
          "scalingStat": "will",
          "scalingMultiplier": 0.5
        }
      ]
    },
    {
      "id": "sanctuary",
      "name": "Sanctuary",
      "description": "Create a protective aura that reduces damage taken.",
      "classIds": ["blood-priest"],
      "costResource": "faith",
      "costAmount": 30,
      "cooldown": 6,
      "targetType": "Self",
      "unlockLevel": 3,
      "tags": ["buff", "defense", "holy", "aura"],
      "effects": [
        {
          "type": "Buff",
          "value": 0,
          "duration": 3,
          "description": "50% damage reduction"
        }
      ]
    },
    {
      "id": "deploy-turret",
      "name": "Deploy Turret",
      "description": "Deploy an automated turret that attacks enemies each turn.",
      "classIds": ["scrap-tinker"],
      "costResource": "focus",
      "costAmount": 25,
      "cooldown": 5,
      "targetType": "None",
      "unlockLevel": 1,
      "tags": ["summon", "utility", "tech"],
      "effects": [
        {
          "type": "Summon",
          "value": 0,
          "duration": 4,
          "statusEffect": "turret"
        }
      ]
    },
    {
      "id": "repair-kit",
      "name": "Repair Kit",
      "description": "Use a repair kit to heal over time.",
      "classIds": ["scrap-tinker"],
      "costResource": "focus",
      "costAmount": 15,
      "cooldown": 3,
      "targetType": "Self",
      "unlockLevel": 1,
      "tags": ["heal", "hot", "tech"],
      "effects": [
        {
          "type": "HealOverTime",
          "value": 8,
          "duration": 3
        }
      ]
    },
    {
      "id": "smoke-bomb",
      "name": "Smoke Bomb",
      "description": "Throw a smoke bomb to blind enemies or escape combat.",
      "classIds": ["scrap-tinker"],
      "costResource": "focus",
      "costAmount": 20,
      "cooldown": 4,
      "targetType": "AllEnemies",
      "unlockLevel": 2,
      "tags": ["debuff", "utility", "tech", "escape"],
      "effects": [
        {
          "type": "Debuff",
          "value": 0,
          "duration": 2,
          "statusEffect": "blind",
          "chance": 0.8
        }
      ]
    }
  ]
}
```

### abilities.schema.json

**File:** `config/abilities.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Abilities Configuration",
  "type": "object",
  "required": ["abilities"],
  "properties": {
    "abilities": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id", "name", "description", "classIds", "targetType"],
        "properties": {
          "id": {
            "type": "string",
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Unique identifier for the ability"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "description": "Display name"
          },
          "description": {
            "type": "string",
            "minLength": 1,
            "description": "Full description"
          },
          "classIds": {
            "type": "array",
            "items": { "type": "string" },
            "minItems": 1,
            "description": "Classes that can use this ability"
          },
          "costResource": {
            "type": "string",
            "description": "Resource type for the cost"
          },
          "costAmount": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Amount of resource required"
          },
          "cooldown": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Turns between uses"
          },
          "targetType": {
            "type": "string",
            "enum": ["Self", "SingleEnemy", "AllEnemies", "SingleAlly", "AllAllies", "Area", "None"],
            "description": "Valid target type"
          },
          "unlockLevel": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Level required to unlock"
          },
          "tags": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Tags for categorization"
          },
          "effects": {
            "type": "array",
            "items": { "$ref": "#/definitions/effect" },
            "description": "Effects applied by the ability"
          }
        }
      }
    }
  },
  "definitions": {
    "effect": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "type": "string",
          "enum": ["Damage", "Heal", "Buff", "Debuff", "DamageOverTime", "HealOverTime", "Shield", "ResourceGain", "CooldownReset", "Taunt", "Stun", "Summon", "Teleport"],
          "description": "Effect type"
        },
        "value": {
          "type": "integer",
          "default": 0,
          "description": "Base value for the effect"
        },
        "duration": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Duration in turns (0 = instant)"
        },
        "statusEffect": {
          "type": "string",
          "description": "Status effect to apply"
        },
        "chance": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "default": 1.0,
          "description": "Success chance (0.0 to 1.0)"
        },
        "scalingStat": {
          "type": "string",
          "description": "Stat that scales the effect"
        },
        "scalingMultiplier": {
          "type": "number",
          "default": 0,
          "description": "Multiplier for stat scaling"
        },
        "description": {
          "type": "string",
          "description": "Override description for the effect"
        }
      }
    }
  }
}
```

---

## Implementation Phases

### Phase 1: Domain Foundation (Priority: Critical)
**Estimated Tasks:** 8

1. Create `AbilityEffectType` enum
2. Create `AbilityTargetType` enum
3. Create `AbilityCost` value object
4. Create `AbilityEffect` value object
5. Create `AbilityDefinition` entity
6. Create `PlayerAbility` entity
7. Create result records (`AbilityValidationResult`, `AbilityResult`, `AppliedEffect`)
8. Update `Player` entity with ability collection and methods

### Phase 2: Infrastructure (Priority: High)
**Estimated Tasks:** 4

1. Create `abilities.json` configuration file
2. Create `abilities.schema.json` schema
3. Update `ConfigurationLoader` with `LoadAbilities()` method
4. Add configuration validation

### Phase 3: Application Services (Priority: High)
**Estimated Tasks:** 6

1. Create `AbilityService` core structure
2. Implement `GetAbilityDefinition()` and collection methods
3. Implement `CanUseAbility()` validation
4. Implement `UseAbility()` execution
5. Implement `InitializePlayerAbilities()`
6. Implement `ProcessTurnEnd()` for cooldowns

### Phase 4: Integration (Priority: Medium)
**Estimated Tasks:** 4

1. Create DTOs (`AbilityDefinitionDto`, `PlayerAbilityDto`, `AbilityEffectDto`)
2. Update `GameSessionService` with `TryUseAbility()` method
3. Integrate with `ResourceService` for ability costs
4. Update `ClassService.ApplyClassToPlayer()` to initialize abilities

### Phase 5: Presentation (Priority: Medium)
**Estimated Tasks:** 3

1. Create ability list display in TUI
2. Add ability usage command handling
3. Display cooldown and cost information

### Phase 6: Testing (Priority: Critical)
**Estimated Tasks:** ~40 unit tests

1. `AbilityDefinitionTests` (~8 tests)
2. `PlayerAbilityTests` (~6 tests)
3. `AbilityCostTests` (~4 tests)
4. `AbilityEffectTests` (~6 tests)
5. `AbilityServiceTests` (~12 tests)
6. `AbilityIntegrationTests` (~4 tests)

---

## Unit Test Specifications

### AbilityDefinitionTests (~8 tests)

```csharp
[TestFixture]
public class AbilityDefinitionTests
{
    [Test]
    public void Create_WithValidParameters_ReturnsDefinition()
    {
        var ability = AbilityDefinition.Create(
            "flame-bolt", "Flame Bolt", "Fire damage",
            new[] { "galdr-caster" },
            AbilityCost.Create("mana", 15),
            cooldown: 0,
            new[] { AbilityEffect.Damage(20) },
            AbilityTargetType.SingleEnemy);

        ability.AbilityId.Should().Be("flame-bolt");
        ability.Name.Should().Be("Flame Bolt");
        ability.ClassIds.Should().Contain("galdr-caster");
    }

    [Test]
    public void Create_NormalizesIdToLowercase();

    [Test]
    public void Create_WithNullId_ThrowsArgumentException();

    [Test]
    public void IsAvailableToClass_WithMatchingClass_ReturnsTrue();

    [Test]
    public void IsAvailableToClass_WithNonMatchingClass_ReturnsFalse();

    [Test]
    public void HasCost_WithZeroCost_ReturnsFalse();

    [Test]
    public void HasCooldown_WithPositiveCooldown_ReturnsTrue();

    [Test]
    public void IsInstant_WithZeroCooldown_ReturnsTrue();
}
```

### PlayerAbilityTests (~6 tests)

```csharp
[TestFixture]
public class PlayerAbilityTests
{
    [Test]
    public void Create_WithUnlockedTrue_StartsReady();

    [Test]
    public void Use_SetsCooldownAndIncrementsTimesUsed();

    [Test]
    public void ReduceCooldown_DecreasesByOne();

    [Test]
    public void ReduceCooldown_DoesNotGoBelowZero();

    [Test]
    public void IsReady_WhenCooldownZero_ReturnsTrue();

    [Test]
    public void Unlock_SetsIsUnlockedAndTimestamp();
}
```

### AbilityCostTests (~4 tests)

```csharp
[TestFixture]
public class AbilityCostTests
{
    [Test]
    public void Create_WithValidParameters_ReturnsCost();

    [Test]
    public void None_HasCostReturnsFalse();

    [Test]
    public void HasCost_WithPositiveAmount_ReturnsTrue();

    [Test]
    public void ToString_FormatsCorrectly();
}
```

### AbilityServiceTests (~12 tests)

```csharp
[TestFixture]
public class AbilityServiceTests
{
    [Test]
    public void GetAbilityDefinition_WithValidId_ReturnsDefinition();

    [Test]
    public void GetAbilityDefinition_WithInvalidId_ReturnsNull();

    [Test]
    public void GetAbilitiesForClass_ReturnsMatchingAbilities();

    [Test]
    public void CanUseAbility_WithValidState_ReturnsSuccess();

    [Test]
    public void CanUseAbility_WithMissingAbility_ReturnsNotLearned();

    [Test]
    public void CanUseAbility_OnCooldown_ReturnsOnCooldown();

    [Test]
    public void CanUseAbility_InsufficientResource_ReturnsInsufficientResource();

    [Test]
    public void UseAbility_DeductsResource();

    [Test]
    public void UseAbility_SetsCooldown();

    [Test]
    public void UseAbility_AppliesDamageEffect();

    [Test]
    public void InitializePlayerAbilities_AddsStartingAbilities();

    [Test]
    public void ProcessTurnEnd_ReducesCooldowns();
}
```

---

## Integration Points

### With v0.0.4a (Class System)

| v0.0.4a Component | v0.0.4c Usage |
|-------------------|---------------|
| `ClassDefinition.StartingAbilityIds` | Used to initialize player abilities |
| `ClassService.ApplyClassToPlayer()` | Trigger for `AbilityService.InitializePlayerAbilities()` |
| `Player.ClassId` | Determines which abilities are available |

### With v0.0.4b (Resource System)

| v0.0.4b Component | v0.0.4c Usage |
|-------------------|---------------|
| `ResourceService.SpendResource()` | Deduct ability costs |
| `Player.GetResource()` | Validate sufficient resources |
| `ResourcePool.Current` | Check available resources |

### With Existing Systems

| Existing Component | v0.0.4c Usage |
|--------------------|---------------|
| `GameSessionService` | Add `TryUseAbility()` command |
| `CombatService` | Execute ability damage/effects |
| `Player.TakeDamage()` | Apply damage effects |
| `Player.Heal()` | Apply healing effects |
| `Monster.TakeDamage()` | Apply damage to enemies |

---

## Acceptance Criteria

### AC-4c-1: Ability Definition Loading
- [ ] Abilities load successfully from `config/abilities.json`
- [ ] All 15 default abilities are present (3 per class)
- [ ] Invalid JSON produces clear error message
- [ ] Missing required fields produce validation error

### AC-4c-2: Ability Costs
- [ ] Ability costs deduct from correct resource pool
- [ ] Insufficient resources prevent ability use
- [ ] Zero-cost abilities work without resource check
- [ ] Cost validation message shows have/need amounts

### AC-4c-3: Ability Cooldowns
- [ ] Cooldown starts after ability use
- [ ] Cooldown decreases by 1 each turn
- [ ] Cooldown at 0 allows ability use
- [ ] UI shows remaining cooldown turns

### AC-4c-4: Ability Effects
- [ ] Damage effects reduce target health
- [ ] Healing effects restore player health
- [ ] Effects respect success chance
- [ ] Stat scaling applies correctly

### AC-4c-5: Class-Ability Binding
- [ ] Players only have abilities for their class
- [ ] Starting abilities initialize at character creation
- [ ] Abilities reference valid class IDs

### AC-4c-6: Level-Based Unlocks
- [ ] Abilities with `unlockLevel > 1` are locked initially
- [ ] Abilities unlock when player reaches required level
- [ ] Locked abilities show level requirement

### AC-4c-7: Logging
- [ ] Service initialization logs ability count
- [ ] Ability use logs player, ability, and results
- [ ] Cooldown changes logged at debug level
- [ ] Validation failures logged with reasons

### AC-4c-8: Unit Tests
- [ ] All ~40 unit tests pass
- [ ] Test coverage includes happy path and error cases
- [ ] Mocks used appropriately for dependencies

---

## Deliverable Checklist

### Domain Layer
- [ ] `AbilityEffectType.cs` enum
- [ ] `AbilityTargetType.cs` enum
- [ ] `AbilityCost.cs` value object
- [ ] `AbilityEffect.cs` value object
- [ ] `AbilityDefinition.cs` entity
- [ ] `PlayerAbility.cs` entity
- [ ] `AbilityResults.cs` (validation and result records)
- [ ] Player entity updates (`Abilities`, `Level`, ability methods)

### Application Layer
- [ ] `AbilityService.cs`
- [ ] `AbilityDefinitionDto.cs`
- [ ] `PlayerAbilityDto.cs`
- [ ] `AbilityEffectDto.cs`
- [ ] DTO mapping extensions
- [ ] `GameSessionService` updates

### Infrastructure Layer
- [ ] `ConfigurationLoader` updates for abilities
- [ ] `config/abilities.json`
- [ ] `config/abilities.schema.json`

### Presentation Layer
- [ ] Ability list display (TUI)
- [ ] Ability usage command
- [ ] Cooldown/cost display

### Tests
- [ ] `AbilityDefinitionTests.cs`
- [ ] `PlayerAbilityTests.cs`
- [ ] `AbilityCostTests.cs`
- [ ] `AbilityEffectTests.cs`
- [ ] `AbilityServiceTests.cs`
- [ ] `AbilityIntegrationTests.cs`

### Documentation
- [ ] XML documentation on all public members
- [ ] JSON schema file
- [ ] Update ROADMAP.md to mark items complete

---

## Future Considerations (v0.0.4d and Beyond)

### Deferred Features (Not in v0.0.4c Scope)
- **Status Effects**: Full implementation of stun, slow, poison tracking
- **Buff/Debuff System**: Active stat modifier tracking and expiration
- **DoT/HoT Processing**: Tick damage/healing at turn boundaries
- **Summon System**: Turret and companion entity management
- **Multi-target Selection**: UI for selecting specific targets in AllEnemies
- **Ability Upgrades**: Enhanced versions of abilities at higher levels
- **Combo System**: Abilities that synergize with each other

### v0.0.4d Integration Points
- Combat command integration (`use <ability> on <target>`)
- Turn processing hooks for DoT/HoT
- Status effect display in combat UI
- Ability tooltips and help text

---

## Dependencies Summary

```
v0.0.4c Ability System
    │
    ├── REQUIRES from v0.0.4a
    │   ├── ClassDefinition.StartingAbilityIds
    │   ├── ClassDefinition.PrimaryResourceId
    │   ├── Player.ClassId
    │   └── ClassService
    │
    ├── REQUIRES from v0.0.4b
    │   ├── ResourceTypeDefinition
    │   ├── ResourcePool
    │   ├── ResourceService.SpendResource()
    │   └── Player.Resources
    │
    ├── REQUIRES from v0.0.1
    │   ├── Player entity
    │   ├── Monster entity
    │   ├── GameSessionService
    │   ├── CombatService
    │   └── ConfigurationLoader
    │
    └── PROVIDES to v0.0.4d
        ├── AbilityService
        ├── AbilityDefinition
        ├── PlayerAbility (with cooldown tracking)
        └── Ability execution framework
```

---

*This implementation plan provides a comprehensive roadmap for implementing the v0.0.4c Ability System. It builds upon the established patterns from v0.0.4a and v0.0.4b while maintaining the clean architecture principles already present in the codebase.*
