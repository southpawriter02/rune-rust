# v0.0.6b Implementation Plan: Monster AI & Flee System

**Version:** 0.0.6b
**Parent:** v0.0.6 (Enhanced Combat System)
**Prerequisites:** v0.0.6a Complete (Multi-Monster Combat Foundation), v0.0.5 Complete (Dice Pool System)
**Status:** Ready for Implementation
**Target Tests:** ~218 -> ~236 (+18 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Presentation Layer](#presentation-layer)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Transform monsters from predictable attackers into tactical opponents with configurable AI behavior patterns, and provide players with a meaningful escape option through the flee command. This phase adds intelligence to combat and establishes the combat log infrastructure needed for v0.0.6c/d status effect integration.

### Scope

**In Scope:**
- `AIBehavior` enum with 5 behavior types (Aggressive, Defensive, Cowardly, Support, Chaotic)
- `AIAction` enum for action types
- `AIDecision` value object representing chosen action
- `AIContext` value object providing decision inputs
- `MonsterAIService` for AI decision-making
- `FleeCommand` with skill check resolution
- `FleeService` for flee mechanics
- `FleeAttemptResult` value object
- `CombatLogEntry` entity for combat history
- `CombatLogType` enum
- `CombatLogService` for log management
- Monster entity modifications (Behavior, CanHeal, HealAmount)
- Combatant modifications (IsDefending, Behavior access)
- CombatEncounter modifications (combat log, round tracking)

**Out of Scope:**
- Status effect application (v0.0.6c)
- AI behavior modification by status effects (v0.0.6d)
- Complex group tactics
- Pathfinding or positioning

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Flee DC formula | 12 + (2 × enemies) | Balanced difficulty scaling |
| Flee skill | Finesse | Represents agility/reflexes |
| Opportunity attack damage | 50% of normal | Punishing but not lethal |
| AI randomness source | Injected Random | Enables deterministic testing |
| Cowardly flee chance | 50% at critical HP | Creates tension without certainty |
| Combat log storage | In-memory list | Simple, sufficient for encounter duration |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.6a (Multi-Monster Combat)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `CombatEncounter` | `Domain/Entities/CombatEncounter.cs` | Combat context, combatant access |
| `Combatant` | `Domain/Entities/Combatant.cs` | AI context, target selection |
| `InitiativeRoll` | `Domain/ValueObjects/InitiativeRoll.cs` | Turn order reference |
| `CombatState` | `Domain/Enums/CombatState.cs` | Combat end states (Fled) |
| `TargetResolver` | `Application/Services/TargetResolver.cs` | Target validation |

### Dependencies from v0.0.5 (Dice Pool System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `DiceService` | `Application/Services/DiceService.cs` | Flee skill check rolls |
| `DicePool` | `Domain/ValueObjects/DicePool.cs` | Flee check dice (1d10) |
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Skill check results |
| `SkillCheckResult` | `Domain/ValueObjects/SkillCheckResult.cs` | Flee check result |
| `SkillCheckService` | `Application/Services/SkillCheckService.cs` | Flee skill checks |
| `SuccessLevel` | `Domain/Enums/SuccessLevel.cs` | Flee success determination |

### Dependencies from v0.0.4 (Core Systems)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Player` | `Domain/Entities/Player.cs` | Flee combatant, damage target |
| `Monster` | `Domain/Entities/Monster.cs` | AI behavior, healing capability |
| `GameSession` | `Domain/Entities/GameSession.cs` | Room navigation on flee |
| `CombatService` | `Domain/Services/CombatService.cs` | Opportunity attacks |
| `PlayerAttributes` | `Domain/ValueObjects/PlayerAttributes.cs` | Finesse for flee checks |

---

## Current System Analysis

### Existing Combat Flow (from v0.0.6a)

**Location:** `src/Core/RuneAndRust.Domain/Entities/CombatEncounter.cs`

**Current Flow:**
```
CombatEncounter.Start()
    ├── Set state to Active
    ├── Set round to 1
    └── Set current turn to first combatant

TURN LOOP (v0.0.6a)
    ├── If Player's turn:
    │   ├── Wait for "attack <target>" command
    │   ├── Resolve attack
    │   └── Advance turn
    │
    └── If Monster's turn:
        ├── Execute basic attack (player always)  <-- TO BE REPLACED
        └── Advance turn
```

### New AI-Driven Combat Flow

```
TURN LOOP (v0.0.6b)
    ├── If Player's turn:
    │   ├── Wait for command ("attack <target>", "flee", etc.)
    │   ├── If "flee":
    │   │   ├── FleeService.AttemptFlee()
    │   │   ├── Log result to combat log
    │   │   ├── If success: End combat, move player
    │   │   └── If failure: Apply opportunity attacks, advance turn
    │   └── If "attack":
    │       ├── Resolve attack
    │       ├── Log to combat log
    │       └── Advance turn
    │
    └── If Monster's turn:
        ├── Build AIContext
        ├── MonsterAIService.DecideAction()
        ├── Log AI decision to combat log
        ├── Execute decided action:
        │   ├── Attack → Resolve attack, log damage
        │   ├── Defend → Set defending flag, log
        │   ├── Heal → Restore HP, log
        │   ├── Flee → Remove from combat (monster only)
        │   └── Wait → Do nothing, log
        └── Advance turn
```

---

## Detailed Implementation

### Domain Layer

#### 1. AIBehavior.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/AIBehavior.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the behavioral pattern for monster AI decision-making.
/// </summary>
/// <remarks>
/// <para>Each behavior type determines how a monster prioritizes actions and selects targets.</para>
/// <para>Behaviors can be configured per monster type via JSON configuration.</para>
/// </remarks>
public enum AIBehavior
{
    /// <summary>
    /// Always attacks, prioritizes lowest HP target.
    /// Uses strongest available ability.
    /// </summary>
    Aggressive,

    /// <summary>
    /// Attacks when HP > 50%, otherwise heals/defends.
    /// Balanced between offense and self-preservation.
    /// </summary>
    Defensive,

    /// <summary>
    /// Attempts to flee when HP < 30%.
    /// Otherwise attacks weakest target.
    /// </summary>
    Cowardly,

    /// <summary>
    /// Prioritizes healing and buffing allies.
    /// Only attacks when alone or no allies need help.
    /// </summary>
    Support,

    /// <summary>
    /// Unpredictable random actions.
    /// May attack, heal, or do nothing.
    /// </summary>
    Chaotic
}
```

#### 2. AIAction.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/AIAction.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the type of action an AI can take during its turn.
/// </summary>
public enum AIAction
{
    /// <summary>Attack a target.</summary>
    Attack,

    /// <summary>Defend, gaining damage reduction for the round.</summary>
    Defend,

    /// <summary>Heal self or ally.</summary>
    Heal,

    /// <summary>Apply buff to self or ally (future use).</summary>
    Buff,

    /// <summary>Attempt to flee combat.</summary>
    Flee,

    /// <summary>Do nothing (skip turn).</summary>
    Wait
}
```

#### 3. CombatLogType.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/CombatLogType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of entries in the combat log.
/// </summary>
public enum CombatLogType
{
    /// <summary>Combat has started.</summary>
    CombatStart,

    /// <summary>A new round has begun.</summary>
    RoundStart,

    /// <summary>A combatant's turn has started.</summary>
    TurnStart,

    /// <summary>An attack was made.</summary>
    Attack,

    /// <summary>Damage was dealt.</summary>
    Damage,

    /// <summary>Healing was done.</summary>
    Heal,

    /// <summary>A combatant defended.</summary>
    Defend,

    /// <summary>A flee attempt was made.</summary>
    Flee,

    /// <summary>A combatant was defeated.</summary>
    Defeat,

    /// <summary>Combat has ended.</summary>
    CombatEnd,

    /// <summary>A status effect was applied (for v0.0.6c/d).</summary>
    StatusApplied,

    /// <summary>A status effect expired (for v0.0.6c/d).</summary>
    StatusExpired,

    /// <summary>AI decision made (for debugging/display).</summary>
    AIDecision
}
```

#### 4. AIDecision.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AIDecision.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a decision made by the monster AI.
/// </summary>
/// <remarks>
/// <para>AIDecision is an immutable value object capturing the result of AI deliberation.</para>
/// <para>The <see cref="Reasoning"/> property provides human-readable explanation for debugging and display.</para>
/// </remarks>
/// <param name="Action">The type of action to take.</param>
/// <param name="Target">The target of the action (if applicable).</param>
/// <param name="AbilityId">The ability to use (if applicable, for future use).</param>
/// <param name="Reasoning">Human-readable explanation of the decision.</param>
public readonly record struct AIDecision(
    AIAction Action,
    Combatant? Target,
    string? AbilityId,
    string Reasoning)
{
    /// <summary>
    /// Creates an attack decision targeting a specific combatant.
    /// </summary>
    /// <param name="target">The combatant to attack.</param>
    /// <param name="reasoning">Explanation for why this target was chosen.</param>
    /// <returns>An attack decision.</returns>
    public static AIDecision Attack(Combatant target, string reasoning) =>
        new(AIAction.Attack, target, null, reasoning);

    /// <summary>
    /// Creates a defend decision (no target needed).
    /// </summary>
    /// <param name="reasoning">Explanation for defending.</param>
    /// <returns>A defend decision.</returns>
    public static AIDecision Defend(string reasoning) =>
        new(AIAction.Defend, null, null, reasoning);

    /// <summary>
    /// Creates a heal decision targeting self or ally.
    /// </summary>
    /// <param name="target">The combatant to heal.</param>
    /// <param name="abilityId">Optional ability ID (for future use).</param>
    /// <param name="reasoning">Explanation for healing.</param>
    /// <returns>A heal decision.</returns>
    public static AIDecision Heal(Combatant target, string? abilityId, string reasoning) =>
        new(AIAction.Heal, target, abilityId, reasoning);

    /// <summary>
    /// Creates a flee decision (monster attempts to escape).
    /// </summary>
    /// <param name="reasoning">Explanation for fleeing.</param>
    /// <returns>A flee decision.</returns>
    public static AIDecision Flee(string reasoning) =>
        new(AIAction.Flee, null, null, reasoning);

    /// <summary>
    /// Creates a wait decision (skip turn).
    /// </summary>
    /// <param name="reasoning">Explanation for waiting.</param>
    /// <returns>A wait decision.</returns>
    public static AIDecision Wait(string reasoning) =>
        new(AIAction.Wait, null, null, reasoning);

    /// <summary>
    /// Returns a formatted string describing the decision.
    /// </summary>
    public override string ToString()
    {
        var targetStr = Target != null ? $" -> {Target.DisplayName}" : "";
        return $"{Action}{targetStr}: {Reasoning}";
    }
}
```

#### 5. AIContext.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AIContext.cs`

```csharp
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Provides context for AI decision-making during a monster's turn.
/// </summary>
/// <remarks>
/// <para>AIContext aggregates all information needed for the AI to make decisions:</para>
/// <list type="bullet">
/// <item>The monster making the decision (<see cref="Self"/>)</item>
/// <item>The current combat encounter state</item>
/// <item>Lists of active allies and enemies</item>
/// <item>Current round number</item>
/// </list>
/// <para>Computed properties provide convenient access to common decision factors.</para>
/// </remarks>
public readonly record struct AIContext(
    Combatant Self,
    CombatEncounter Encounter,
    IReadOnlyList<Combatant> Allies,
    IReadOnlyList<Combatant> Enemies,
    int RoundNumber)
{
    /// <summary>
    /// Gets the monster's current health percentage (0.0 to 1.0).
    /// </summary>
    public float HealthPercentage => Self.MaxHealth > 0
        ? (float)Self.CurrentHealth / Self.MaxHealth
        : 0f;

    /// <summary>
    /// Gets whether the monster is below 50% health.
    /// </summary>
    public bool IsLowHealth => HealthPercentage < 0.5f;

    /// <summary>
    /// Gets whether the monster is below 30% health (critical).
    /// </summary>
    public bool IsCriticalHealth => HealthPercentage < 0.3f;

    /// <summary>
    /// Gets whether there are any active allies.
    /// </summary>
    public bool HasAllies => Allies.Count > 0;

    /// <summary>
    /// Gets allies that are below 50% health.
    /// </summary>
    public IEnumerable<Combatant> WoundedAllies =>
        Allies.Where(a => a.MaxHealth > 0 && (float)a.CurrentHealth / a.MaxHealth < 0.5f);

    /// <summary>
    /// Gets the enemy with the lowest current health.
    /// </summary>
    public Combatant? WeakestEnemy =>
        Enemies.Where(e => e.IsActive).OrderBy(e => e.CurrentHealth).FirstOrDefault();

    /// <summary>
    /// Gets the enemy with the highest current health.
    /// </summary>
    public Combatant? StrongestEnemy =>
        Enemies.Where(e => e.IsActive).OrderByDescending(e => e.CurrentHealth).FirstOrDefault();

    /// <summary>
    /// Gets a random enemy from the active enemies list.
    /// </summary>
    /// <param name="random">Random number generator.</param>
    /// <returns>A random enemy, or null if none available.</returns>
    public Combatant? GetRandomEnemy(Random random)
    {
        var activeEnemies = Enemies.Where(e => e.IsActive).ToList();
        return activeEnemies.Count > 0
            ? activeEnemies[random.Next(activeEnemies.Count)]
            : null;
    }
}
```

#### 6. FleeAttemptResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/FleeAttemptResult.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of an opportunity attack made during a failed flee attempt.
/// </summary>
/// <param name="AttackerName">The name of the attacking monster.</param>
/// <param name="Damage">The amount of damage dealt.</param>
/// <param name="Hit">Whether the attack hit (always true for opportunity attacks).</param>
public readonly record struct OpportunityAttackResult(
    string AttackerName,
    int Damage,
    bool Hit);

/// <summary>
/// Result of an attempt to flee combat.
/// </summary>
/// <remarks>
/// <para>FleeAttemptResult captures the complete outcome of a flee attempt:</para>
/// <list type="bullet">
/// <item>The skill check result (roll, modifiers, total)</item>
/// <item>Whether the flee succeeded</item>
/// <item>Opportunity attacks taken on failure</item>
/// <item>The destination room if successful</item>
/// </list>
/// </remarks>
/// <param name="Success">Whether the flee attempt succeeded.</param>
/// <param name="SkillCheck">The skill check result.</param>
/// <param name="DifficultyClass">The DC that had to be beaten.</param>
/// <param name="OpportunityAttacks">Attacks taken while fleeing (on failure).</param>
/// <param name="TotalDamageTaken">Total damage from opportunity attacks.</param>
/// <param name="DestinationRoomId">The room fled to (if successful).</param>
public readonly record struct FleeAttemptResult(
    bool Success,
    SkillCheckResult SkillCheck,
    int DifficultyClass,
    IReadOnlyList<OpportunityAttackResult> OpportunityAttacks,
    int TotalDamageTaken,
    Guid? DestinationRoomId)
{
    /// <summary>
    /// Creates a successful flee result.
    /// </summary>
    /// <param name="check">The successful skill check.</param>
    /// <param name="dc">The difficulty class that was beaten.</param>
    /// <param name="destinationRoomId">The room the combatant fled to.</param>
    /// <returns>A successful flee result.</returns>
    public static FleeAttemptResult Succeeded(
        SkillCheckResult check,
        int dc,
        Guid destinationRoomId) =>
        new(true, check, dc, Array.Empty<OpportunityAttackResult>(), 0, destinationRoomId);

    /// <summary>
    /// Creates a failed flee result with opportunity attacks.
    /// </summary>
    /// <param name="check">The failed skill check.</param>
    /// <param name="dc">The difficulty class that wasn't beaten.</param>
    /// <param name="attacks">List of opportunity attacks taken.</param>
    /// <param name="totalDamage">Total damage from all opportunity attacks.</param>
    /// <returns>A failed flee result.</returns>
    public static FleeAttemptResult Failed(
        SkillCheckResult check,
        int dc,
        IReadOnlyList<OpportunityAttackResult> attacks,
        int totalDamage) =>
        new(false, check, dc, attacks, totalDamage, null);

    /// <summary>
    /// Returns a display string for the flee result.
    /// </summary>
    public override string ToString()
    {
        var result = Success ? "SUCCESS" : "FAILED";
        return $"Flee {result}: {SkillCheck.TotalResult} vs DC {DifficultyClass}";
    }
}
```

#### 7. CombatLogEntry.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Entities/CombatLogEntry.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Domain.Entities;

/// <summary>
/// A single entry in the combat log tracking events during an encounter.
/// </summary>
/// <remarks>
/// <para>CombatLogEntry records individual events during combat for display and history.</para>
/// <para>Entries are immutable once created and include:</para>
/// <list type="bullet">
/// <item>Timestamp and round number for ordering</item>
/// <item>Type categorization for filtering and display</item>
/// <item>Actor and target information</item>
/// <item>Numeric data (damage, healing) where applicable</item>
/// <item>Critical/miss flags for special formatting</item>
/// </list>
/// </remarks>
public class CombatLogEntry : IEntity
{
    /// <summary>Gets the unique identifier for this entry.</summary>
    public Guid Id { get; private set; }

    /// <summary>Gets the timestamp when the event occurred.</summary>
    public DateTime Timestamp { get; private set; }

    /// <summary>Gets the round number when this occurred.</summary>
    public int RoundNumber { get; private set; }

    /// <summary>Gets the type of log entry.</summary>
    public CombatLogType Type { get; private set; }

    /// <summary>Gets the message to display.</summary>
    public string Message { get; private set; } = string.Empty;

    /// <summary>Gets the combatant who performed the action (if any).</summary>
    public string? ActorName { get; private set; }

    /// <summary>Gets the target of the action (if any).</summary>
    public string? TargetName { get; private set; }

    /// <summary>Gets the damage dealt (if applicable).</summary>
    public int? Damage { get; private set; }

    /// <summary>Gets the healing done (if applicable).</summary>
    public int? Healing { get; private set; }

    /// <summary>Gets whether this was a critical hit/success.</summary>
    public bool IsCritical { get; private set; }

    /// <summary>Gets whether this was a miss/failure.</summary>
    public bool IsMiss { get; private set; }

    /// <summary>
    /// Private parameterless constructor for Entity Framework Core.
    /// </summary>
    private CombatLogEntry() { }

    /// <summary>
    /// Creates a combat log entry with the specified parameters.
    /// </summary>
    /// <param name="roundNumber">The current round number.</param>
    /// <param name="type">The type of event.</param>
    /// <param name="message">The display message.</param>
    /// <param name="actorName">The actor's name (optional).</param>
    /// <param name="targetName">The target's name (optional).</param>
    /// <param name="damage">Damage dealt (optional).</param>
    /// <param name="healing">Healing done (optional).</param>
    /// <param name="isCritical">Whether this was a critical (optional).</param>
    /// <param name="isMiss">Whether this was a miss (optional).</param>
    /// <returns>A new combat log entry.</returns>
    public static CombatLogEntry Create(
        int roundNumber,
        CombatLogType type,
        string message,
        string? actorName = null,
        string? targetName = null,
        int? damage = null,
        int? healing = null,
        bool isCritical = false,
        bool isMiss = false)
    {
        return new CombatLogEntry
        {
            Id = Guid.NewGuid(),
            Timestamp = DateTime.UtcNow,
            RoundNumber = roundNumber,
            Type = type,
            Message = message,
            ActorName = actorName,
            TargetName = targetName,
            Damage = damage,
            Healing = healing,
            IsCritical = isCritical,
            IsMiss = isMiss
        };
    }

    /// <summary>
    /// Returns a formatted string representation of this entry.
    /// </summary>
    public override string ToString() =>
        $"[R{RoundNumber}] {Type}: {Message}";
}
```

#### 8. Update Monster.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Monster.cs`

```csharp
// Add to existing Monster entity after existing properties:

/// <summary>
/// Gets the AI behavior pattern for this monster.
/// </summary>
/// <remarks>
/// Determines how the monster makes decisions during combat.
/// Defaults to <see cref="AIBehavior.Aggressive"/> if not set.
/// </remarks>
public AIBehavior Behavior { get; private set; } = AIBehavior.Aggressive;

/// <summary>
/// Gets whether this monster can heal itself or allies.
/// </summary>
public bool CanHeal { get; private set; }

/// <summary>
/// Gets the heal amount if the monster can heal.
/// </summary>
public int? HealAmount { get; private set; }

/// <summary>
/// Sets the AI behavior for this monster.
/// </summary>
/// <param name="behavior">The behavior pattern to use.</param>
public void SetBehavior(AIBehavior behavior)
{
    Behavior = behavior;
}

/// <summary>
/// Enables healing capability for this monster.
/// </summary>
/// <param name="healAmount">The amount of HP restored per heal action.</param>
public void EnableHealing(int healAmount)
{
    if (healAmount <= 0)
        throw new ArgumentOutOfRangeException(nameof(healAmount), "Heal amount must be positive");

    CanHeal = true;
    HealAmount = healAmount;
}

/// <summary>
/// Restores health to this monster (used for healing).
/// </summary>
/// <param name="amount">The amount of health to restore.</param>
/// <returns>The actual amount healed (capped at MaxHealth).</returns>
public int Heal(int amount)
{
    if (amount < 0)
        throw new ArgumentOutOfRangeException(nameof(amount), "Heal amount cannot be negative");

    var actualHeal = Math.Min(amount, MaxHealth - Health);
    Health += actualHeal;
    return actualHeal;
}

// Update existing factory methods:

/// <summary>
/// Factory method to create a basic goblin enemy with Cowardly behavior.
/// </summary>
/// <returns>A new goblin monster.</returns>
public static Monster CreateGoblin()
{
    var goblin = new Monster(
        "Goblin",
        "A small, green creature with sharp teeth and beady eyes. It looks hostile.",
        30,
        new Stats(30, 8, 2))
    {
        Behavior = AIBehavior.Cowardly  // Goblins flee when hurt
    };
    return goblin;
}

/// <summary>
/// Factory method to create an orc enemy with Aggressive behavior.
/// </summary>
/// <returns>A new orc monster.</returns>
public static Monster CreateOrc()
{
    return new Monster(
        "Orc",
        "A brutish green-skinned warrior wielding a crude axe.",
        50,
        new Stats(50, 15, 3))
    {
        Behavior = AIBehavior.Aggressive  // Orcs fight to the death
    };
}

/// <summary>
/// Factory method to create a goblin shaman with Support behavior.
/// </summary>
/// <returns>A new goblin shaman monster.</returns>
public static Monster CreateGoblinShaman()
{
    var shaman = new Monster(
        "Goblin Shaman",
        "A goblin adorned with crude fetishes and glowing runes.",
        25,
        new Stats(25, 6, 1))
    {
        Behavior = AIBehavior.Support,
        CanHeal = true,
        HealAmount = 10
    };
    return shaman;
}

/// <summary>
/// Factory method to create a skeleton enemy with Aggressive behavior.
/// </summary>
/// <returns>A new skeleton monster.</returns>
public static Monster CreateSkeleton()
{
    return new Monster(
        "Skeleton",
        "An animated pile of bones held together by dark magic.",
        20,
        new Stats(20, 10, 0))
    {
        Behavior = AIBehavior.Aggressive
    };
}

/// <summary>
/// Factory method to create a slime enemy with Chaotic behavior.
/// </summary>
/// <returns>A new slime monster.</returns>
public static Monster CreateSlime()
{
    return new Monster(
        "Slime",
        "A gelatinous blob that oozes across the floor.",
        40,
        new Stats(40, 5, 5))
    {
        Behavior = AIBehavior.Chaotic
    };
}
```

#### 9. Update Combatant.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Combatant.cs`

```csharp
// Add to existing Combatant entity after existing properties:

/// <summary>
/// Gets the AI behavior of this combatant (for monsters).
/// </summary>
/// <remarks>
/// Returns null for player combatants.
/// </remarks>
public AIBehavior? Behavior => Monster?.Behavior;

/// <summary>
/// Gets whether this combatant can heal.
/// </summary>
public bool CanHeal => Monster?.CanHeal ?? false;

/// <summary>
/// Gets the heal amount for this combatant.
/// </summary>
public int? HealAmount => Monster?.HealAmount;

/// <summary>
/// Gets or sets whether this combatant is defending (damage reduction active).
/// </summary>
/// <remarks>
/// When defending, incoming damage is reduced by 50%.
/// Defending flag resets at the start of the combatant's next turn.
/// </remarks>
public bool IsDefending { get; private set; }

/// <summary>
/// Sets the defending state for this combatant.
/// </summary>
/// <param name="defending">True to enable defending, false to disable.</param>
public void SetDefending(bool defending)
{
    IsDefending = defending;
}

/// <summary>
/// Clears temporary combat states (called at start of turn).
/// </summary>
public void ResetTurnState()
{
    IsDefending = false;
}
```

#### 10. Update CombatEncounter.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/CombatEncounter.cs`

```csharp
// Add to existing CombatEncounter entity:

// ===== Combat Log =====

private readonly List<CombatLogEntry> _combatLog = new();

/// <summary>
/// Gets the combat log for this encounter.
/// </summary>
public IReadOnlyList<CombatLogEntry> CombatLog => _combatLog.AsReadOnly();

/// <summary>
/// Adds an entry to the combat log.
/// </summary>
/// <param name="entry">The log entry to add.</param>
public void AddLogEntry(CombatLogEntry entry)
{
    ArgumentNullException.ThrowIfNull(entry);
    _combatLog.Add(entry);
}

/// <summary>
/// Gets the most recent log entries.
/// </summary>
/// <param name="count">Maximum number of entries to return.</param>
/// <returns>The most recent entries, up to the specified count.</returns>
public IEnumerable<CombatLogEntry> GetRecentLogEntries(int count = 10) =>
    _combatLog.TakeLast(count);

/// <summary>
/// Gets log entries for a specific round.
/// </summary>
/// <param name="round">The round number to filter by.</param>
/// <returns>All entries from the specified round.</returns>
public IEnumerable<CombatLogEntry> GetLogEntriesForRound(int round) =>
    _combatLog.Where(e => e.RoundNumber == round);

// ===== Additional Combat Methods =====

/// <summary>
/// Ends combat because a combatant fled.
/// </summary>
public void EndByFlee()
{
    if (State != CombatState.Active)
        throw new InvalidOperationException("Cannot flee from inactive combat");

    State = CombatState.Fled;
}

/// <summary>
/// Removes a monster from combat (when it flees).
/// </summary>
/// <param name="combatant">The monster combatant to remove.</param>
public void RemoveMonster(Combatant combatant)
{
    if (combatant.IsPlayer)
        throw new InvalidOperationException("Cannot remove player using this method");

    // Mark as defeated for removal from turn order
    // (The monster "escapes" rather than being killed)
    combatant.Monster?.TakeDamage(combatant.CurrentHealth);
}

/// <summary>
/// Gets active ally combatants for a monster (excluding self).
/// </summary>
/// <param name="self">The monster requesting allies.</param>
/// <returns>List of active monster allies.</returns>
public IReadOnlyList<Combatant> GetAlliesFor(Combatant self)
{
    return Combatants
        .Where(c => c.IsMonster && c.IsActive && c.Id != self.Id)
        .ToList()
        .AsReadOnly();
}

/// <summary>
/// Gets active enemy combatants for a monster (the player).
/// </summary>
/// <returns>List of active player combatants (usually just one).</returns>
public IReadOnlyList<Combatant> GetEnemiesForMonster()
{
    return Combatants
        .Where(c => c.IsPlayer && c.IsActive)
        .ToList()
        .AsReadOnly();
}
```

### Application Layer

#### 11. MonsterAIService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/MonsterAIService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for making AI decisions for monsters during combat.
/// </summary>
/// <remarks>
/// <para>MonsterAIService evaluates the combat situation and determines the optimal action
/// for a monster based on its <see cref="AIBehavior"/>.</para>
/// <para>Each behavior type has distinct priorities and target selection logic.</para>
/// </remarks>
public class MonsterAIService
{
    private readonly ILogger<MonsterAIService> _logger;
    private readonly Random _random;

    /// <summary>
    /// Creates a new MonsterAIService instance.
    /// </summary>
    /// <param name="logger">Logger for AI decision diagnostics.</param>
    /// <param name="random">Optional random source for testability. If null, uses default Random.</param>
    public MonsterAIService(ILogger<MonsterAIService> logger, Random? random = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _random = random ?? new Random();
    }

    /// <summary>
    /// Determines the action a monster should take based on its behavior and context.
    /// </summary>
    /// <param name="context">The AI decision context containing combat state.</param>
    /// <returns>The decided action with target and reasoning.</returns>
    public AIDecision DecideAction(AIContext context)
    {
        var behavior = context.Self.Behavior ?? AIBehavior.Aggressive;

        _logger.LogDebug(
            "AI deciding for {Monster} with behavior {Behavior}, HP: {HP:F0}%",
            context.Self.DisplayName,
            behavior,
            context.HealthPercentage * 100);

        var decision = behavior switch
        {
            AIBehavior.Aggressive => DecideAggressive(context),
            AIBehavior.Defensive => DecideDefensive(context),
            AIBehavior.Cowardly => DecideCowardly(context),
            AIBehavior.Support => DecideSupport(context),
            AIBehavior.Chaotic => DecideChaotic(context),
            _ => DecideAggressive(context)
        };

        _logger.LogInformation(
            "AI {Monster} decided: {Action} - {Reasoning}",
            context.Self.DisplayName,
            decision.Action,
            decision.Reasoning);

        return decision;
    }

    /// <summary>
    /// Aggressive behavior: Always attack the weakest enemy.
    /// </summary>
    private AIDecision DecideAggressive(AIContext context)
    {
        var target = context.WeakestEnemy;

        if (target == null)
            return AIDecision.Wait("No targets available");

        return AIDecision.Attack(target,
            $"Aggressively targeting weakest enemy ({target.DisplayName})");
    }

    /// <summary>
    /// Defensive behavior: Attack when healthy, heal/defend when low.
    /// </summary>
    private AIDecision DecideDefensive(AIContext context)
    {
        // If health > 50%, attack
        if (!context.IsLowHealth)
        {
            var target = context.StrongestEnemy ?? context.WeakestEnemy;
            if (target != null)
                return AIDecision.Attack(target, "Health good, attacking strongest threat");
        }

        // If can heal and low health, heal self
        if (context.Self.CanHeal)
        {
            return AIDecision.Heal(context.Self, null, "Low health, healing self");
        }

        // Otherwise defend
        return AIDecision.Defend("Low health, taking defensive stance");
    }

    /// <summary>
    /// Cowardly behavior: Flee when critical, otherwise attack weakest.
    /// </summary>
    private AIDecision DecideCowardly(AIContext context)
    {
        // If health < 30%, 50% chance to flee
        if (context.IsCriticalHealth && _random.NextDouble() < 0.5)
        {
            return AIDecision.Flee("Critically wounded, attempting to flee");
        }

        // Otherwise attack weakest target
        var target = context.WeakestEnemy;
        if (target != null)
            return AIDecision.Attack(target, "Attacking weakest target");

        return AIDecision.Wait("No targets available");
    }

    /// <summary>
    /// Support behavior: Prioritize healing allies, then self, then attack.
    /// </summary>
    private AIDecision DecideSupport(AIContext context)
    {
        // Priority 1: Heal wounded allies
        if (context.Self.CanHeal)
        {
            var woundedAlly = context.WoundedAllies.FirstOrDefault();
            if (woundedAlly != null)
            {
                return AIDecision.Heal(woundedAlly, null,
                    $"Healing wounded ally {woundedAlly.DisplayName}");
            }

            // Heal self if low
            if (context.IsLowHealth)
            {
                return AIDecision.Heal(context.Self, null, "Healing self");
            }
        }

        // Priority 2: Attack if no one needs healing
        var target = context.StrongestEnemy;
        if (target != null)
            return AIDecision.Attack(target, "No healing needed, attacking");

        return AIDecision.Wait("Waiting for opportunity");
    }

    /// <summary>
    /// Chaotic behavior: Random action selection.
    /// </summary>
    private AIDecision DecideChaotic(AIContext context)
    {
        var roll = _random.NextDouble();

        // 50% chance to attack
        if (roll < 0.5)
        {
            var target = context.GetRandomEnemy(_random);
            if (target != null)
                return AIDecision.Attack(target, "Chaotic attack!");
        }

        // 20% chance to defend
        if (roll < 0.7)
            return AIDecision.Defend("Chaotic defense!");

        // 15% chance to heal if able
        if (roll < 0.85 && context.Self.CanHeal)
            return AIDecision.Heal(context.Self, null, "Chaotic healing!");

        // 15% chance to do nothing
        return AIDecision.Wait("Chaotically doing nothing!");
    }
}
```

#### 12. FleeService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/FleeService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for handling flee attempts during combat.
/// </summary>
/// <remarks>
/// <para>FleeService manages the mechanics of escaping combat:</para>
/// <list type="bullet">
/// <item>Calculating difficulty class based on enemy count</item>
/// <item>Performing skill checks using Finesse</item>
/// <item>Resolving opportunity attacks on failure</item>
/// </list>
/// </remarks>
public class FleeService
{
    private readonly DiceService _diceService;
    private readonly ILogger<FleeService> _logger;

    /// <summary>
    /// Base difficulty class for fleeing.
    /// </summary>
    public const int BaseFleeDC = 12;

    /// <summary>
    /// Additional DC per enemy in combat.
    /// </summary>
    public const int DCPerEnemy = 2;

    /// <summary>
    /// Damage multiplier for opportunity attacks.
    /// </summary>
    public const float OpportunityAttackDamageMultiplier = 0.5f;

    /// <summary>
    /// Creates a new FleeService instance.
    /// </summary>
    /// <param name="diceService">The dice service for rolling.</param>
    /// <param name="logger">Logger for flee attempt diagnostics.</param>
    public FleeService(DiceService diceService, ILogger<FleeService> logger)
    {
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Attempts to flee from combat.
    /// </summary>
    /// <param name="combatant">The combatant attempting to flee.</param>
    /// <param name="encounter">The current combat encounter.</param>
    /// <param name="previousRoomId">The room to flee to.</param>
    /// <returns>The result of the flee attempt.</returns>
    /// <exception cref="InvalidOperationException">Thrown if there is no escape route.</exception>
    public FleeAttemptResult AttemptFlee(
        Combatant combatant,
        CombatEncounter encounter,
        Guid? previousRoomId)
    {
        ArgumentNullException.ThrowIfNull(combatant);
        ArgumentNullException.ThrowIfNull(encounter);

        if (previousRoomId == null)
        {
            _logger.LogWarning("Flee attempt failed: No previous room");
            throw new InvalidOperationException("Cannot flee - no escape route.");
        }

        var enemies = encounter.GetActiveMonsters().ToList();
        var dc = CalculateFleeDC(enemies.Count);

        _logger.LogDebug(
            "Flee attempt: DC {DC} ({Base} + {Enemies} enemies x {PerEnemy})",
            dc, BaseFleeDC, enemies.Count, DCPerEnemy);

        // Roll flee check (1d10 + Finesse)
        var finesseBonus = combatant.Finesse;
        var dicePool = DicePool.D10();
        var rollResult = _diceService.Roll(dicePool);

        // Create skill check result
        var checkResult = new SkillCheckResult(
            "flee",
            "Flee",
            rollResult,
            finesseBonus,
            0,
            dc,
            $"DC {dc}");

        if (checkResult.IsSuccess)
        {
            _logger.LogInformation(
                "{Combatant} successfully fled combat (rolled {Roll} + {Bonus} = {Total} vs DC {DC})",
                combatant.DisplayName, rollResult.Total, finesseBonus, checkResult.TotalResult, dc);

            return FleeAttemptResult.Succeeded(checkResult, dc, previousRoomId.Value);
        }

        // Failed flee - take opportunity attacks
        var opportunityAttacks = new List<OpportunityAttackResult>();
        var totalDamage = 0;

        foreach (var enemy in enemies)
        {
            var attackResult = ResolveOpportunityAttack(enemy, combatant);
            opportunityAttacks.Add(attackResult);
            if (attackResult.Hit)
                totalDamage += attackResult.Damage;
        }

        _logger.LogInformation(
            "{Combatant} failed to flee (rolled {Roll} + {Bonus} = {Total} vs DC {DC}), took {Damage} damage",
            combatant.DisplayName, rollResult.Total, finesseBonus, checkResult.TotalResult, dc, totalDamage);

        return FleeAttemptResult.Failed(checkResult, dc, opportunityAttacks, totalDamage);
    }

    /// <summary>
    /// Calculates the difficulty class for fleeing based on enemy count.
    /// </summary>
    /// <param name="enemyCount">The number of active enemies.</param>
    /// <returns>The flee DC.</returns>
    public int CalculateFleeDC(int enemyCount)
    {
        return BaseFleeDC + (enemyCount * DCPerEnemy);
    }

    /// <summary>
    /// Resolves an opportunity attack against a fleeing combatant.
    /// </summary>
    private OpportunityAttackResult ResolveOpportunityAttack(
        Combatant attacker,
        Combatant target)
    {
        // Opportunity attacks always hit, deal half damage
        var baseDamage = attacker.Monster?.Stats.Attack ?? 5;
        var damage = (int)(baseDamage * OpportunityAttackDamageMultiplier);
        damage = Math.Max(1, damage); // Minimum 1 damage

        _logger.LogDebug(
            "Opportunity attack: {Attacker} hits {Target} for {Damage} damage",
            attacker.DisplayName, target.DisplayName, damage);

        return new OpportunityAttackResult(attacker.DisplayName, damage, Hit: true);
    }
}
```

#### 13. CombatLogService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/CombatLogService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing combat log entries during encounters.
/// </summary>
/// <remarks>
/// <para>CombatLogService provides factory methods for creating consistently formatted
/// log entries for all combat events.</para>
/// </remarks>
public class CombatLogService
{
    private readonly ILogger<CombatLogService> _logger;

    /// <summary>
    /// Creates a new CombatLogService instance.
    /// </summary>
    /// <param name="logger">Logger for service diagnostics.</param>
    public CombatLogService(ILogger<CombatLogService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Logs a combat start event.
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <param name="monsterCount">Number of monsters in the encounter.</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogCombatStart(CombatEncounter encounter, int monsterCount)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.CombatStart,
            $"Combat begins with {monsterCount} {(monsterCount == 1 ? "enemy" : "enemies")}!");

        encounter.AddLogEntry(entry);
        _logger.LogDebug("Combat log: {Message}", entry.Message);
        return entry;
    }

    /// <summary>
    /// Logs a round start event.
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogRoundStart(CombatEncounter encounter)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.RoundStart,
            $"─── Round {encounter.RoundNumber} ───");

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs an attack action.
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <param name="attackerName">Name of the attacker.</param>
    /// <param name="targetName">Name of the target.</param>
    /// <param name="damage">Damage dealt.</param>
    /// <param name="isCritical">Whether the attack was a critical hit.</param>
    /// <param name="isMiss">Whether the attack missed.</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogAttack(
        CombatEncounter encounter,
        string attackerName,
        string targetName,
        int damage,
        bool isCritical = false,
        bool isMiss = false)
    {
        string message;
        if (isMiss)
            message = $"{attackerName} attacks {targetName} but misses!";
        else if (isCritical)
            message = $"{attackerName} critically hits {targetName} for {damage} damage!";
        else
            message = $"{attackerName} attacks {targetName} for {damage} damage.";

        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Attack,
            message,
            attackerName,
            targetName,
            damage,
            isCritical: isCritical,
            isMiss: isMiss);

        encounter.AddLogEntry(entry);
        _logger.LogDebug("Combat log: {Message}", entry.Message);
        return entry;
    }

    /// <summary>
    /// Logs a heal action.
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <param name="healerName">Name of the healer.</param>
    /// <param name="targetName">Name of the heal target.</param>
    /// <param name="healing">Amount healed.</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogHeal(
        CombatEncounter encounter,
        string healerName,
        string targetName,
        int healing)
    {
        var isSelfHeal = healerName == targetName;
        var message = isSelfHeal
            ? $"{healerName} heals for {healing} HP."
            : $"{healerName} heals {targetName} for {healing} HP.";

        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Heal,
            message,
            healerName,
            targetName,
            healing: healing);

        encounter.AddLogEntry(entry);
        _logger.LogDebug("Combat log: {Message}", entry.Message);
        return entry;
    }

    /// <summary>
    /// Logs a defend action.
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <param name="defenderName">Name of the defending combatant.</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogDefend(CombatEncounter encounter, string defenderName)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Defend,
            $"{defenderName} takes a defensive stance.",
            defenderName);

        encounter.AddLogEntry(entry);
        _logger.LogDebug("Combat log: {Message}", entry.Message);
        return entry;
    }

    /// <summary>
    /// Logs a flee attempt.
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <param name="combatantName">Name of the fleeing combatant.</param>
    /// <param name="result">The flee attempt result.</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogFleeAttempt(
        CombatEncounter encounter,
        string combatantName,
        FleeAttemptResult result)
    {
        string message;
        if (result.Success)
        {
            message = $"{combatantName} successfully flees combat!";
        }
        else
        {
            var damage = result.TotalDamageTaken;
            message = damage > 0
                ? $"{combatantName} fails to flee and takes {damage} damage!"
                : $"{combatantName} fails to flee!";
        }

        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Flee,
            message,
            combatantName,
            damage: result.TotalDamageTaken);

        encounter.AddLogEntry(entry);
        _logger.LogDebug("Combat log: {Message}", entry.Message);
        return entry;
    }

    /// <summary>
    /// Logs a defeat event.
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <param name="defeatedName">Name of the defeated combatant.</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogDefeat(CombatEncounter encounter, string defeatedName)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.Defeat,
            $"{defeatedName} has been defeated!",
            targetName: defeatedName);

        encounter.AddLogEntry(entry);
        _logger.LogDebug("Combat log: {Message}", entry.Message);
        return entry;
    }

    /// <summary>
    /// Logs an AI decision (for debugging/display).
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <param name="monsterName">Name of the monster.</param>
    /// <param name="decision">The AI decision made.</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogAIDecision(
        CombatEncounter encounter,
        string monsterName,
        AIDecision decision)
    {
        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.AIDecision,
            $"[AI] {monsterName}: {decision.Reasoning}",
            monsterName);

        encounter.AddLogEntry(entry);
        return entry;
    }

    /// <summary>
    /// Logs a combat end event.
    /// </summary>
    /// <param name="encounter">The combat encounter.</param>
    /// <param name="outcome">The outcome (Victory, Defeat, Fled).</param>
    /// <returns>The created log entry.</returns>
    public CombatLogEntry LogCombatEnd(CombatEncounter encounter, CombatState outcome)
    {
        var message = outcome switch
        {
            CombatState.Victory => "Victory! All enemies have been defeated.",
            CombatState.PlayerDefeated => "Defeat. You have fallen in battle.",
            CombatState.Fled => "You have escaped from combat.",
            _ => "Combat has ended."
        };

        var entry = CombatLogEntry.Create(
            encounter.RoundNumber,
            CombatLogType.CombatEnd,
            message);

        encounter.AddLogEntry(entry);
        _logger.LogDebug("Combat log: {Message}", entry.Message);
        return entry;
    }
}
```

#### 14. FleeCommand.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Commands/FleeCommand.cs`

```csharp
namespace RuneAndRust.Application.Commands;

/// <summary>
/// Command to attempt fleeing from combat.
/// </summary>
public record FleeCommand : GameCommand;
```

#### 15. FleeResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/DTOs/FleeResult.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of a flee command execution.
/// </summary>
/// <param name="Success">Whether the flee attempt succeeded.</param>
/// <param name="Message">Display message for the player.</param>
/// <param name="AttemptResult">The detailed flee attempt result (if attempted).</param>
/// <param name="PlayerDied">Whether the player died from opportunity attacks.</param>
public record FleeResult(
    bool Success,
    string Message,
    FleeAttemptResult? AttemptResult = null,
    bool PlayerDied = false)
{
    /// <summary>
    /// Creates a failure result (precondition not met).
    /// </summary>
    /// <param name="message">The reason for failure.</param>
    /// <returns>A flee result indicating failure.</returns>
    public static FleeResult Failure(string message) =>
        new(false, message);

    /// <summary>
    /// Creates a successful flee result.
    /// </summary>
    /// <param name="result">The flee attempt result.</param>
    /// <returns>A flee result indicating success.</returns>
    public static FleeResult Succeeded(FleeAttemptResult result) =>
        new(true, "You successfully flee!", result);

    /// <summary>
    /// Creates a failed flee result (skill check failed).
    /// </summary>
    /// <param name="result">The flee attempt result.</param>
    /// <returns>A flee result indicating failure.</returns>
    public static FleeResult Failed(FleeAttemptResult result) =>
        new(false, "You fail to escape!", result);

    /// <summary>
    /// Creates a result where the player died while fleeing.
    /// </summary>
    /// <param name="result">The flee attempt result.</param>
    /// <returns>A flee result indicating player death.</returns>
    public static FleeResult PlayerDiedFleeing(FleeAttemptResult result) =>
        new(false, "You were struck down while fleeing!", result, PlayerDied: true);
}
```

#### 16. CombatDtos.cs (NEW - Additional DTOs)

**File:** `src/Core/RuneAndRust.Application/DTOs/CombatDtos.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Combat log entry for display.
/// </summary>
/// <param name="Timestamp">When the event occurred.</param>
/// <param name="RoundNumber">The combat round.</param>
/// <param name="Type">The type of log entry.</param>
/// <param name="Message">The display message.</param>
/// <param name="IsCritical">Whether this was a critical event.</param>
/// <param name="IsMiss">Whether this was a miss.</param>
public record CombatLogEntryDto(
    DateTime Timestamp,
    int RoundNumber,
    string Type,
    string Message,
    bool IsCritical,
    bool IsMiss)
{
    /// <summary>
    /// Creates a DTO from a domain CombatLogEntry.
    /// </summary>
    public static CombatLogEntryDto FromDomain(Domain.Entities.CombatLogEntry entry)
    {
        return new CombatLogEntryDto(
            entry.Timestamp,
            entry.RoundNumber,
            entry.Type.ToString(),
            entry.Message,
            entry.IsCritical,
            entry.IsMiss);
    }
}

/// <summary>
/// AI decision for display.
/// </summary>
/// <param name="Action">The action type.</param>
/// <param name="TargetName">The target name (if any).</param>
/// <param name="Reasoning">The AI's reasoning.</param>
public record AIDecisionDto(
    string Action,
    string? TargetName,
    string Reasoning)
{
    /// <summary>
    /// Creates a DTO from a domain AIDecision.
    /// </summary>
    public static AIDecisionDto FromDomain(Domain.ValueObjects.AIDecision decision)
    {
        return new AIDecisionDto(
            decision.Action.ToString(),
            decision.Target?.DisplayName,
            decision.Reasoning);
    }
}

/// <summary>
/// Flee attempt result for display.
/// </summary>
/// <param name="Success">Whether the flee succeeded.</param>
/// <param name="RollValue">The dice roll value.</param>
/// <param name="Modifier">The Finesse modifier.</param>
/// <param name="Total">The total result.</param>
/// <param name="DifficultyClass">The DC that had to be beaten.</param>
/// <param name="OpportunityAttackMessages">Messages for each opportunity attack.</param>
/// <param name="TotalDamageTaken">Total damage from opportunity attacks.</param>
public record FleeAttemptResultDto(
    bool Success,
    int RollValue,
    int Modifier,
    int Total,
    int DifficultyClass,
    IReadOnlyList<string> OpportunityAttackMessages,
    int TotalDamageTaken)
{
    /// <summary>
    /// Creates a DTO from a domain FleeAttemptResult.
    /// </summary>
    public static FleeAttemptResultDto FromDomain(Domain.ValueObjects.FleeAttemptResult result)
    {
        var messages = result.OpportunityAttacks
            .Select(a => $"{a.AttackerName} strikes for {a.Damage} damage!")
            .ToList();

        return new FleeAttemptResultDto(
            result.Success,
            result.SkillCheck.DiceResult.Total,
            result.SkillCheck.AttributeBonus,
            result.SkillCheck.TotalResult,
            result.DifficultyClass,
            messages,
            result.TotalDamageTaken);
    }
}
```

### Presentation Layer

#### 17. Update IGameRenderer.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs`

```csharp
// Add to existing IGameRenderer interface:

/// <summary>
/// Renders the combat log.
/// </summary>
/// <param name="entries">Recent log entries to display.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderCombatLogAsync(IReadOnlyList<CombatLogEntryDto> entries, CancellationToken ct = default);

/// <summary>
/// Renders a monster's AI action and result.
/// </summary>
/// <param name="monsterName">Name of the monster.</param>
/// <param name="decision">The decision made.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderMonsterActionAsync(string monsterName, AIDecisionDto decision, CancellationToken ct = default);

/// <summary>
/// Renders a flee attempt result.
/// </summary>
/// <param name="result">The flee attempt result.</param>
/// <param name="ct">Cancellation token.</param>
Task RenderFleeAttemptAsync(FleeAttemptResultDto result, CancellationToken ct = default);
```

#### 18. Update SpectreGameRenderer.cs (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

```csharp
// Add to existing SpectreGameRenderer class:

/// <inheritdoc />
public Task RenderCombatLogAsync(
    IReadOnlyList<CombatLogEntryDto> entries,
    CancellationToken ct = default)
{
    var panel = new Panel(BuildCombatLogText(entries))
        .Header("[grey]Combat Log[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(Color.Grey);

    AnsiConsole.Write(panel);
    return Task.CompletedTask;
}

private static string BuildCombatLogText(IReadOnlyList<CombatLogEntryDto> entries)
{
    if (entries.Count == 0)
        return "[grey]No events yet.[/]";

    var lines = new List<string>();

    foreach (var entry in entries)
    {
        var timestamp = entry.Timestamp.ToString("HH:mm:ss");
        var color = GetLogEntryColor(entry);
        var message = entry.Message;

        if (entry.IsCritical)
            message = $"[yellow bold]{message}[/]";
        else if (entry.IsMiss)
            message = $"[grey]{message}[/]";
        else
            message = $"[{color}]{message}[/]";

        lines.Add($"[grey][[{timestamp}]][/] {message}");
    }

    return string.Join("\n", lines);
}

private static string GetLogEntryColor(CombatLogEntryDto entry)
{
    return entry.Type switch
    {
        "Attack" => "red",
        "Damage" => "red",
        "Heal" => "green",
        "Defend" => "blue",
        "Flee" => "yellow",
        "Defeat" => "red",
        "RoundStart" => "cyan",
        "CombatStart" => "white",
        "CombatEnd" => "white",
        _ => "white"
    };
}

/// <inheritdoc />
public Task RenderMonsterActionAsync(
    string monsterName,
    AIDecisionDto decision,
    CancellationToken ct = default)
{
    var actionColor = decision.Action switch
    {
        "Attack" => "red",
        "Heal" => "green",
        "Defend" => "blue",
        "Flee" => "yellow",
        "Wait" => "grey",
        _ => "white"
    };

    AnsiConsole.MarkupLine($"\n[{actionColor} bold]{monsterName}'s turn:[/]");
    AnsiConsole.MarkupLine($"  [{actionColor}]{decision.Reasoning}[/]");

    if (decision.TargetName != null)
        AnsiConsole.MarkupLine($"  Target: [cyan]{decision.TargetName}[/]");

    return Task.CompletedTask;
}

/// <inheritdoc />
public Task RenderFleeAttemptAsync(
    FleeAttemptResultDto result,
    CancellationToken ct = default)
{
    var table = new Table()
        .Border(TableBorder.Rounded)
        .AddColumn("[yellow]Flee Attempt[/]")
        .AddColumn("Result");

    var modStr = result.Modifier >= 0 ? $"+{result.Modifier}" : result.Modifier.ToString();
    table.AddRow("Roll", $"[{result.RollValue}] {modStr} = [bold]{result.Total}[/]");
    table.AddRow("DC", result.DifficultyClass.ToString());

    var resultColor = result.Success ? "green" : "red";
    var resultText = result.Success ? "SUCCESS!" : "FAILED!";
    table.AddRow("Result", $"[{resultColor} bold]{resultText}[/]");

    AnsiConsole.Write(table);

    if (!result.Success && result.OpportunityAttackMessages.Count > 0)
    {
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[yellow]Opportunity Attacks:[/]");
        foreach (var msg in result.OpportunityAttackMessages)
        {
            AnsiConsole.MarkupLine($"  [red]• {msg}[/]");
        }
        AnsiConsole.MarkupLine($"\n[red bold]Total damage taken: {result.TotalDamageTaken}[/]");
    }
    else if (result.Success)
    {
        AnsiConsole.MarkupLine("\n[green]You escape to the previous room![/]");
    }

    return Task.CompletedTask;
}
```

#### 19. Update ConsoleInputHandler.cs (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/ConsoleInputHandler.cs`

```csharp
// Add to existing ParseCommand method switch statement:

"flee" or "run" or "escape" => new FleeCommand(),
```

---

## Flow Diagrams

### Monster AI Decision Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        MONSTER AI DECISION FLOW                              │
└─────────────────────────────────────────────────────────────────────────────┘

    Monster's Turn Begins
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         BUILD AI CONTEXT                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  • Self (the monster)                                                        │
│  • Combat encounter state                                                    │
│  • Active allies (other monsters)                                            │
│  • Active enemies (the player)                                               │
│  • Current round number                                                      │
│  • Computed: HealthPercentage, IsLowHealth, IsCriticalHealth                │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CHECK STATUS EFFECT OVERRIDES (v0.0.6d)                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  • Feared → Force flee attempt                                               │
│  • Stunned → Skip turn                                                       │
│  • Silenced → Remove ability options                                         │
│  (Placeholder for future implementation)                                     │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      SELECT BEHAVIOR STRATEGY                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐             │
│  │   AGGRESSIVE    │  │   DEFENSIVE     │  │   COWARDLY      │             │
│  ├─────────────────┤  ├─────────────────┤  ├─────────────────┤             │
│  │ Always attack   │  │ HP > 50%: Atk   │  │ HP < 30%: 50%   │             │
│  │ Target: lowest  │  │ HP < 50%: Heal  │  │   chance flee   │             │
│  │   HP enemy      │  │ No heal: Defend │  │ Else: Attack    │             │
│  └─────────────────┘  └─────────────────┘  │   weakest       │             │
│                                            └─────────────────┘             │
│  ┌─────────────────┐  ┌─────────────────┐                                  │
│  │   SUPPORT       │  │   CHAOTIC       │                                  │
│  ├─────────────────┤  ├─────────────────┤                                  │
│  │ Ally < 50%:     │  │ 50%: Attack     │                                  │
│  │   Heal ally     │  │ 20%: Defend     │                                  │
│  │ Self < 50%:     │  │ 15%: Heal       │                                  │
│  │   Heal self     │  │ 15%: Wait       │                                  │
│  │ Else: Attack    │  └─────────────────┘                                  │
│  └─────────────────┘                                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         RETURN AI DECISION                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  AIDecision contains:                                                        │
│  • Action (Attack, Defend, Heal, Flee, Wait)                                 │
│  • Target (if applicable)                                                    │
│  • AbilityId (for future use)                                                │
│  • Reasoning (human-readable explanation)                                    │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Player Flee Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PLAYER FLEE FLOW                                   │
└─────────────────────────────────────────────────────────────────────────────┘

    Player executes "flee" command
                │
                ▼
┌───────────────────────────────┐
│  Validate: In combat?         │
├───────────────────────────────┤
│  No → "You're not in combat." │
└───────────────────────────────┘
                │ Yes
                ▼
┌───────────────────────────────┐
│  Validate: Player's turn?     │
├───────────────────────────────┤
│  No → "It's not your turn."   │
└───────────────────────────────┘
                │ Yes
                ▼
┌───────────────────────────────┐
│  Validate: Escape route?      │
├───────────────────────────────┤
│  No → "Nowhere to run!"       │
│  (PreviousRoomId is null)     │
└───────────────────────────────┘
                │ Yes
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CALCULATE FLEE DC                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│  DC = 12 (base) + (2 × number of active enemies)                             │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────┐                │
│  │  Enemies │  DC   │  Success (Finesse 5)  │  Success (Finesse 10)  │      │
│  │    1     │  14   │        45%            │         65%            │      │
│  │    2     │  16   │        35%            │         55%            │      │
│  │    3     │  18   │        25%            │         45%            │      │
│  │    4     │  20   │        15%            │         35%            │      │
│  │    5     │  22   │         5%            │         25%            │      │
│  └─────────────────────────────────────────────────────────┘                │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      ROLL FLEE CHECK (1d10 + Finesse)                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  Roll Result >= DC  ──────────────────────────────────────────┐             │
│                                                                │             │
│                    ┌───────────────────────────────────────────┘             │
│                    ▼                                                         │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                        SUCCESS                                          │ │
│  ├────────────────────────────────────────────────────────────────────────┤ │
│  │  1. End combat (state = Fled)                                           │ │
│  │  2. Move player to previous room                                        │ │
│  │  3. Monsters remain in original room                                    │ │
│  │  4. Log: "{Player} successfully flees combat!"                          │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Roll Result < DC  ───────────────────────────────────────────┐             │
│                                                                │             │
│                    ┌───────────────────────────────────────────┘             │
│                    ▼                                                         │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                        FAILURE                                          │ │
│  ├────────────────────────────────────────────────────────────────────────┤ │
│  │  1. Each enemy gets opportunity attack                                  │ │
│  │     • Always hits                                                       │ │
│  │     • Deals 50% of normal damage                                        │ │
│  │  2. Apply damage to player                                              │ │
│  │  3. Check if player died                                                │ │
│  │     • Yes: End combat (PlayerDefeated), Game Over                       │ │
│  │     • No: Player's turn is consumed, advance turn                       │ │
│  │  4. Log: "{Player} fails to flee and takes {damage} damage!"            │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Enums/
│   │   └── AIBehaviorTests.cs                    (2 tests)
│   ├── ValueObjects/
│   │   ├── AIDecisionTests.cs                    (4 tests)
│   │   ├── AIContextTests.cs                     (4 tests)
│   │   └── FleeAttemptResultTests.cs             (3 tests)
│   └── Entities/
│       ├── CombatLogEntryTests.cs                (3 tests)
│       └── MonsterBehaviorTests.cs               (4 tests)
├── RuneAndRust.Application.UnitTests/
│   └── Services/
│       ├── MonsterAIServiceTests.cs              (10 tests)
│       ├── FleeServiceTests.cs                   (6 tests)
│       └── CombatLogServiceTests.cs              (6 tests)
```

### Test Files

#### 1. MonsterAIServiceTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Services/MonsterAIServiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class MonsterAIServiceTests
{
    private MonsterAIService _service = null!;
    private Mock<ILogger<MonsterAIService>> _mockLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<MonsterAIService>>();
    }

    private AIContext CreateContext(
        AIBehavior behavior,
        float healthPercent = 1.0f,
        bool hasAllies = false,
        bool hasWoundedAllies = false)
    {
        // Create mock combatant with specified behavior and health
        var monster = Monster.CreateGoblin();
        monster.SetBehavior(behavior);
        // Set health based on percentage
        var damage = (int)(monster.MaxHealth * (1 - healthPercent));
        if (damage > 0) monster.TakeDamage(damage);

        var combatant = Combatant.ForMonster(
            monster,
            new InitiativeRoll(new DiceRollResult(DicePool.D10(), new[] { 5 }, 5), 0),
            0);

        var allies = new List<Combatant>();
        var enemies = new List<Combatant>();

        // Add player as enemy
        var player = new Player("Test");
        var playerCombatant = Combatant.ForPlayer(
            player,
            new InitiativeRoll(new DiceRollResult(DicePool.D10(), new[] { 5 }, 5), 0));
        enemies.Add(playerCombatant);

        // Mock encounter
        var encounter = new Mock<CombatEncounter>();

        return new AIContext(combatant, encounter.Object, allies, enemies, 1);
    }

    [Test]
    public void DecideAction_Aggressive_AttacksWeakestEnemy()
    {
        // Arrange
        _service = new MonsterAIService(_mockLogger.Object);
        var context = CreateContext(AIBehavior.Aggressive);

        // Act
        var decision = _service.DecideAction(context);

        // Assert
        decision.Action.Should().Be(AIAction.Attack);
        decision.Target.Should().NotBeNull();
        decision.Reasoning.Should().Contain("Aggressive");
    }

    [Test]
    public void DecideAction_Aggressive_NoEnemies_ReturnsWait()
    {
        // Arrange
        _service = new MonsterAIService(_mockLogger.Object);
        var monster = Monster.CreateGoblin();
        monster.SetBehavior(AIBehavior.Aggressive);
        var combatant = Combatant.ForMonster(
            monster,
            new InitiativeRoll(new DiceRollResult(DicePool.D10(), new[] { 5 }, 5), 0),
            0);
        var encounter = new Mock<CombatEncounter>();
        var context = new AIContext(combatant, encounter.Object, new List<Combatant>(), new List<Combatant>(), 1);

        // Act
        var decision = _service.DecideAction(context);

        // Assert
        decision.Action.Should().Be(AIAction.Wait);
    }

    [Test]
    public void DecideAction_Defensive_HighHealth_Attacks()
    {
        // Arrange
        _service = new MonsterAIService(_mockLogger.Object);
        var context = CreateContext(AIBehavior.Defensive, healthPercent: 0.8f);

        // Act
        var decision = _service.DecideAction(context);

        // Assert
        decision.Action.Should().Be(AIAction.Attack);
    }

    [Test]
    public void DecideAction_Defensive_LowHealth_NoHeal_Defends()
    {
        // Arrange
        _service = new MonsterAIService(_mockLogger.Object);
        var context = CreateContext(AIBehavior.Defensive, healthPercent: 0.3f);

        // Act
        var decision = _service.DecideAction(context);

        // Assert
        decision.Action.Should().Be(AIAction.Defend);
        decision.Reasoning.Should().Contain("defensive stance");
    }

    [Test]
    public void DecideAction_Cowardly_CriticalHealth_MayFlee()
    {
        // Arrange - use fixed seed for determinism
        var fixedRandom = new Random(42);
        _service = new MonsterAIService(_mockLogger.Object, fixedRandom);
        var context = CreateContext(AIBehavior.Cowardly, healthPercent: 0.2f);

        // Act - run multiple times to verify behavior
        var decisions = Enumerable.Range(0, 100)
            .Select(_ =>
            {
                fixedRandom = new Random(42);
                _service = new MonsterAIService(_mockLogger.Object, fixedRandom);
                return _service.DecideAction(context);
            })
            .ToList();

        // Assert - with 50% chance, should see both flee and attack
        decisions.Should().Contain(d => d.Action == AIAction.Flee || d.Action == AIAction.Attack);
    }

    [Test]
    public void DecideAction_Cowardly_HealthyEnough_Attacks()
    {
        // Arrange
        _service = new MonsterAIService(_mockLogger.Object);
        var context = CreateContext(AIBehavior.Cowardly, healthPercent: 0.5f);

        // Act
        var decision = _service.DecideAction(context);

        // Assert
        decision.Action.Should().Be(AIAction.Attack);
    }

    [Test]
    public void DecideAction_Support_NoWoundedAllies_Attacks()
    {
        // Arrange
        _service = new MonsterAIService(_mockLogger.Object);
        var context = CreateContext(AIBehavior.Support, healthPercent: 0.8f);

        // Act
        var decision = _service.DecideAction(context);

        // Assert
        decision.Action.Should().Be(AIAction.Attack);
    }

    [Test]
    public void DecideAction_Chaotic_ProducesVariedActions()
    {
        // Arrange
        var actions = new HashSet<AIAction>();

        // Act - run with different seeds
        for (var i = 0; i < 100; i++)
        {
            var random = new Random(i);
            _service = new MonsterAIService(_mockLogger.Object, random);
            var context = CreateContext(AIBehavior.Chaotic);
            var decision = _service.DecideAction(context);
            actions.Add(decision.Action);
        }

        // Assert - should see multiple different actions
        actions.Count.Should().BeGreaterThan(1);
    }

    [Test]
    public void DecideAction_LogsDecision()
    {
        // Arrange
        _service = new MonsterAIService(_mockLogger.Object);
        var context = CreateContext(AIBehavior.Aggressive);

        // Act
        _service.DecideAction(context);

        // Assert - verify logging occurred
        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Information,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString()!.Contains("decided")),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Once);
    }
}
```

#### 2. FleeServiceTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Services/FleeServiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class FleeServiceTests
{
    private FleeService _service = null!;
    private Mock<DiceService> _mockDiceService = null!;
    private Mock<ILogger<FleeService>> _mockLogger = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<FleeService>>();
        var diceLogger = new Mock<ILogger<DiceService>>();
        _mockDiceService = new Mock<DiceService>(diceLogger.Object, null);
    }

    [Test]
    public void CalculateFleeDC_OneEnemy_Returns14()
    {
        // Arrange
        _service = new FleeService(_mockDiceService.Object, _mockLogger.Object);

        // Act
        var dc = _service.CalculateFleeDC(1);

        // Assert
        dc.Should().Be(14); // 12 + (1 * 2)
    }

    [Test]
    public void CalculateFleeDC_ThreeEnemies_Returns18()
    {
        // Arrange
        _service = new FleeService(_mockDiceService.Object, _mockLogger.Object);

        // Act
        var dc = _service.CalculateFleeDC(3);

        // Assert
        dc.Should().Be(18); // 12 + (3 * 2)
    }

    [Test]
    public void CalculateFleeDC_FiveEnemies_Returns22()
    {
        // Arrange
        _service = new FleeService(_mockDiceService.Object, _mockLogger.Object);

        // Act
        var dc = _service.CalculateFleeDC(5);

        // Assert
        dc.Should().Be(22); // 12 + (5 * 2)
    }

    [Test]
    public void AttemptFlee_NoPreviousRoom_ThrowsException()
    {
        // Arrange
        var diceLogger = new Mock<ILogger<DiceService>>();
        var realDiceService = new DiceService(diceLogger.Object);
        _service = new FleeService(realDiceService, _mockLogger.Object);

        var player = new Player("Test");
        var combatant = Combatant.ForPlayer(
            player,
            new InitiativeRoll(new DiceRollResult(DicePool.D10(), new[] { 5 }, 5), 0));
        var encounter = CombatEncounter.Create(Guid.NewGuid(), null);

        // Act
        var act = () => _service.AttemptFlee(combatant, encounter, null);

        // Assert
        act.Should().Throw<InvalidOperationException>()
            .WithMessage("*no escape route*");
    }

    [Test]
    public void AttemptFlee_Failure_ReturnsOpportunityAttacks()
    {
        // Arrange - set up dice service to return low roll
        var diceLogger = new Mock<ILogger<DiceService>>();
        var fixedRandom = new Random(1); // Will give low rolls
        var diceService = new DiceService(diceLogger.Object, fixedRandom);
        _service = new FleeService(diceService, _mockLogger.Object);

        var player = new Player("Test");
        var combatant = Combatant.ForPlayer(
            player,
            new InitiativeRoll(new DiceRollResult(DicePool.D10(), new[] { 5 }, 5), 0));

        var encounter = CombatEncounter.Create(Guid.NewGuid(), null);
        var monster = Monster.CreateGoblin();
        encounter.AddCombatant(Combatant.ForMonster(
            monster,
            new InitiativeRoll(new DiceRollResult(DicePool.D10(), new[] { 5 }, 5), 0),
            0));

        var previousRoomId = Guid.NewGuid();

        // Act
        var result = _service.AttemptFlee(combatant, encounter, previousRoomId);

        // Assert - since we can't guarantee failure, check structure
        if (!result.Success)
        {
            result.OpportunityAttacks.Should().NotBeEmpty();
            result.TotalDamageTaken.Should().BeGreaterOrEqualTo(0);
        }
    }

    [Test]
    public void AttemptFlee_OpportunityAttack_DealsHalfDamage()
    {
        // Arrange
        var diceLogger = new Mock<ILogger<DiceService>>();
        var diceService = new DiceService(diceLogger.Object);
        _service = new FleeService(diceService, _mockLogger.Object);

        // Expected: Goblin attack is 8, half is 4
        var expectedMaxDamage = (int)(8 * FleeService.OpportunityAttackDamageMultiplier);

        // Assert
        expectedMaxDamage.Should().Be(4);
    }
}
```

#### 3. CombatLogServiceTests.cs

**File:** `tests/RuneAndRust.Application.UnitTests/Services/CombatLogServiceTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class CombatLogServiceTests
{
    private CombatLogService _service = null!;
    private Mock<ILogger<CombatLogService>> _mockLogger = null!;
    private CombatEncounter _encounter = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<CombatLogService>>();
        _service = new CombatLogService(_mockLogger.Object);
        _encounter = CombatEncounter.Create(Guid.NewGuid(), null);
    }

    [Test]
    public void LogAttack_CreatesCorrectEntry()
    {
        // Act
        var entry = _service.LogAttack(_encounter, "Player", "Goblin", 10);

        // Assert
        entry.Type.Should().Be(CombatLogType.Attack);
        entry.Message.Should().Contain("Player");
        entry.Message.Should().Contain("Goblin");
        entry.Message.Should().Contain("10 damage");
        entry.ActorName.Should().Be("Player");
        entry.TargetName.Should().Be("Goblin");
        entry.Damage.Should().Be(10);
    }

    [Test]
    public void LogAttack_CriticalHit_MarksEntry()
    {
        // Act
        var entry = _service.LogAttack(_encounter, "Player", "Goblin", 20, isCritical: true);

        // Assert
        entry.IsCritical.Should().BeTrue();
        entry.Message.Should().Contain("critically hits");
    }

    [Test]
    public void LogAttack_Miss_MarksEntry()
    {
        // Act
        var entry = _service.LogAttack(_encounter, "Player", "Goblin", 0, isMiss: true);

        // Assert
        entry.IsMiss.Should().BeTrue();
        entry.Message.Should().Contain("misses");
    }

    [Test]
    public void LogHeal_SelfHeal_FormatsCorrectly()
    {
        // Act
        var entry = _service.LogHeal(_encounter, "Goblin Shaman", "Goblin Shaman", 10);

        // Assert
        entry.Type.Should().Be(CombatLogType.Heal);
        entry.Message.Should().Be("Goblin Shaman heals for 10 HP.");
        entry.Healing.Should().Be(10);
    }

    [Test]
    public void LogHeal_AllyHeal_FormatsCorrectly()
    {
        // Act
        var entry = _service.LogHeal(_encounter, "Goblin Shaman", "Goblin", 10);

        // Assert
        entry.Message.Should().Be("Goblin Shaman heals Goblin for 10 HP.");
    }

    [Test]
    public void LogFleeAttempt_Success_CreatesCorrectMessage()
    {
        // Arrange
        var result = FleeAttemptResult.Succeeded(
            new SkillCheckResult("flee", "Flee",
                new DiceRollResult(DicePool.D10(), new[] { 8 }, 8), 5, 0, 14, "DC 14"),
            14,
            Guid.NewGuid());

        // Act
        var entry = _service.LogFleeAttempt(_encounter, "Player", result);

        // Assert
        entry.Type.Should().Be(CombatLogType.Flee);
        entry.Message.Should().Contain("successfully flees");
    }

    [Test]
    public void LogFleeAttempt_Failure_IncludesDamage()
    {
        // Arrange
        var attacks = new[] { new OpportunityAttackResult("Goblin", 4, true) };
        var result = FleeAttemptResult.Failed(
            new SkillCheckResult("flee", "Flee",
                new DiceRollResult(DicePool.D10(), new[] { 3 }, 3), 5, 0, 14, "DC 14"),
            14,
            attacks,
            4);

        // Act
        var entry = _service.LogFleeAttempt(_encounter, "Player", result);

        // Assert
        entry.Message.Should().Contain("fails to flee");
        entry.Message.Should().Contain("4 damage");
        entry.Damage.Should().Be(4);
    }
}
```

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| AI decision start | Debug | "AI deciding for {Monster} with behavior {Behavior}" |
| AI decision result | Information | "AI {Monster} decided: {Action} - {Reasoning}" |
| Flee attempt start | Debug | "Flee attempt: DC {DC}" |
| Flee success | Information | "{Combatant} successfully fled combat" |
| Flee failure | Information | "{Combatant} failed to flee, took {Damage} damage" |
| Opportunity attack | Debug | "Opportunity attack: {Attacker} hits {Target}" |
| Combat log entry | Debug | "Combat log: {Message}" |
| No escape route | Warning | "Flee attempt failed: No previous room" |

### Structured Logging Format

```csharp
// AI Decision
_logger.LogDebug(
    "AI deciding for {Monster} with behavior {Behavior}, HP: {HealthPercent:F0}%",
    context.Self.DisplayName,
    behavior,
    context.HealthPercentage * 100);

_logger.LogInformation(
    "AI {Monster} decided: {Action} - {Reasoning}",
    context.Self.DisplayName,
    decision.Action,
    decision.Reasoning);

// Flee Attempt
_logger.LogDebug(
    "Flee attempt: DC {DC} ({Base} + {Enemies} enemies x {PerEnemy})",
    dc, BaseFleeDC, enemies.Count, DCPerEnemy);

_logger.LogInformation(
    "{Combatant} successfully fled combat (rolled {Roll} + {Bonus} = {Total} vs DC {DC})",
    combatant.DisplayName, rollResult.Total, finesseBonus, checkResult.TotalResult, dc);
```

---

## Implementation Checklist

### Domain Layer
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/AIBehavior.cs`
  - [ ] AIBehavior enum with 5 values
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/AIAction.cs`
  - [ ] AIAction enum with 6 values
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/CombatLogType.cs`
  - [ ] CombatLogType enum with 13 values
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/AIDecision.cs`
  - [ ] Readonly record struct
  - [ ] Factory methods (Attack, Defend, Heal, Flee, Wait)
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/AIContext.cs`
  - [ ] Readonly record struct
  - [ ] Computed properties (HealthPercentage, IsLowHealth, etc.)
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/FleeAttemptResult.cs`
  - [ ] Readonly record struct
  - [ ] OpportunityAttackResult struct
  - [ ] Factory methods (Succeeded, Failed)
  - [ ] XML documentation
- [ ] Create `src/Core/RuneAndRust.Domain/Entities/CombatLogEntry.cs`
  - [ ] Entity class
  - [ ] Create factory method
  - [ ] Private EF constructor
  - [ ] XML documentation
- [ ] Update `src/Core/RuneAndRust.Domain/Entities/Monster.cs`
  - [ ] Add Behavior property
  - [ ] Add CanHeal, HealAmount properties
  - [ ] Add SetBehavior, EnableHealing, Heal methods
  - [ ] Update factory methods with behaviors
- [ ] Update `src/Core/RuneAndRust.Domain/Entities/Combatant.cs`
  - [ ] Add Behavior, CanHeal, HealAmount accessors
  - [ ] Add IsDefending property
  - [ ] Add SetDefending, ResetTurnState methods
- [ ] Update `src/Core/RuneAndRust.Domain/Entities/CombatEncounter.cs`
  - [ ] Add combat log list and methods
  - [ ] Add EndByFlee method
  - [ ] Add RemoveMonster method
  - [ ] Add GetAlliesFor, GetEnemiesForMonster methods

### Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/Services/MonsterAIService.cs`
  - [ ] DecideAction method
  - [ ] Behavior-specific decision methods
  - [ ] Logging integration
- [ ] Create `src/Core/RuneAndRust.Application/Services/FleeService.cs`
  - [ ] AttemptFlee method
  - [ ] CalculateFleeDC method
  - [ ] Opportunity attack resolution
  - [ ] Constants for DC formula
- [ ] Create `src/Core/RuneAndRust.Application/Services/CombatLogService.cs`
  - [ ] Log methods for all combat events
  - [ ] Consistent message formatting
- [ ] Create `src/Core/RuneAndRust.Application/Commands/FleeCommand.cs`
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/FleeResult.cs`
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/CombatDtos.cs`
  - [ ] CombatLogEntryDto
  - [ ] AIDecisionDto
  - [ ] FleeAttemptResultDto
- [ ] Update `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs`
  - [ ] Add RenderCombatLogAsync
  - [ ] Add RenderMonsterActionAsync
  - [ ] Add RenderFleeAttemptAsync
- [ ] Update DI registration for new services

### Presentation Layer
- [ ] Update `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`
  - [ ] Implement RenderCombatLogAsync
  - [ ] Implement RenderMonsterActionAsync
  - [ ] Implement RenderFleeAttemptAsync
- [ ] Update `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/ConsoleInputHandler.cs`
  - [ ] Add flee/run/escape command parsing

### Tests
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/MonsterAIServiceTests.cs` (10 tests)
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/FleeServiceTests.cs` (6 tests)
- [ ] Create `tests/RuneAndRust.Application.UnitTests/Services/CombatLogServiceTests.cs` (6 tests)

### Validation
- [ ] All 18 new tests pass
- [ ] All existing tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | Monsters have configurable AI behavior types | Unit test |
| AC-2 | Aggressive monsters always attack lowest HP enemy | Unit test |
| AC-3 | Defensive monsters heal when below 50% HP | Unit test |
| AC-4 | Defensive monsters defend when low HP and can't heal | Unit test |
| AC-5 | Cowardly monsters attempt flee when below 30% HP | Unit test |
| AC-6 | Support monsters prioritize healing wounded allies | Unit test |
| AC-7 | Chaotic monsters take random actions | Unit test |
| AC-8 | `flee` command initiates escape attempt | Unit test |
| AC-9 | `run` and `escape` work as flee aliases | Unit test |
| AC-10 | Flee DC = 12 + (2 × enemy count) | Unit test |
| AC-11 | Successful flee moves player to previous room | Unit test |
| AC-12 | Failed flee triggers opportunity attacks (50% damage) | Unit test |
| AC-13 | Combat log records all actions | Unit test |
| AC-14 | AI decisions are logged | Unit test |

### Non-Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| NF-1 | All public types have XML documentation | Code review |
| NF-2 | Services use dependency injection | Code review |
| NF-3 | Logging follows established patterns | Code review |
| NF-4 | Random source is injectable for testing | Code review |
| NF-5 | Code follows existing architecture patterns | Code review |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| v0.0.6a not complete | High | Medium | Document dependency, defer implementation |
| v0.0.5 not complete | High | Medium | SkillCheckService required for flee |
| AI becomes predictable | Medium | Medium | Include Chaotic behavior, random elements |
| Flee too easy/hard | Medium | Low | Tunable DC constants, test with various scenarios |
| Combat log grows large | Low | Low | In-memory only, cleared per encounter |
| Integration complexity | Medium | Medium | Test AI decisions in isolation first |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `Domain/Enums/AIBehavior.cs` | AI behavior enum | ~35 |
| `Domain/Enums/AIAction.cs` | AI action enum | ~25 |
| `Domain/Enums/CombatLogType.cs` | Combat log type enum | ~45 |
| `Domain/ValueObjects/AIDecision.cs` | AI decision value object | ~70 |
| `Domain/ValueObjects/AIContext.cs` | AI context value object | ~80 |
| `Domain/ValueObjects/FleeAttemptResult.cs` | Flee result value object | ~90 |
| `Domain/Entities/CombatLogEntry.cs` | Combat log entry entity | ~100 |
| `Application/Services/MonsterAIService.cs` | AI decision service | ~180 |
| `Application/Services/FleeService.cs` | Flee mechanics service | ~130 |
| `Application/Services/CombatLogService.cs` | Combat log service | ~200 |
| `Application/Commands/FleeCommand.cs` | Flee command | ~10 |
| `Application/DTOs/FleeResult.cs` | Flee result DTO | ~50 |
| `Application/DTOs/CombatDtos.cs` | Combat display DTOs | ~100 |
| Test files (3 files) | Unit tests | ~350 |

### Files to Modify

| File | Changes |
|------|---------|
| `Domain/Entities/Monster.cs` | Add Behavior, CanHeal, HealAmount, Heal (~50 lines) |
| `Domain/Entities/Combatant.cs` | Add IsDefending, behavior accessors (~30 lines) |
| `Domain/Entities/CombatEncounter.cs` | Add combat log, helper methods (~60 lines) |
| `Application/Interfaces/IGameRenderer.cs` | Add 3 new render methods (~20 lines) |
| `Presentation.Tui/Adapters/SpectreGameRenderer.cs` | Implement rendering (~120 lines) |
| `Presentation.Tui/Adapters/ConsoleInputHandler.cs` | Add flee command parsing (~5 lines) |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| AI Behavior Types | 0 | 5 |
| AI Action Types | 0 | 6 |
| Combat Log Entry Types | 0 | 13 |
| Application Services | ~8 | ~11 |
| Unit Tests | ~218 | ~236 |

---

## Next Steps

After completing this phase:

1. **v0.0.6c (Status Effect Framework)** - Define status effects, application, duration, stacking rules
2. **v0.0.6d (Status Effect Integration)** - Effect interactions, AI modifications, combat integration

---

*This implementation plan provides step-by-step guidance for implementing monster AI and the flee system. The plan builds on v0.0.6a's combat infrastructure and prepares for v0.0.6c/d's status effect system.*
