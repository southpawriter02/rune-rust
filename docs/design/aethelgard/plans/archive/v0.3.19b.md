> **Archived** - This plan has been consolidated. See the complete version at [v0.3.19](../v0.3.x/v0.3.19.md).

Here is the comprehensive implementation plan for v0.3.19b: The Score (Event Wiring).
This sub-version connects the "silent" game logic to the audio infrastructure built in v0.3.19a. By subscribing to the EventBus (established in v0.1.3a), we ensure that gameplay systems (Combat, Inventory, UI) remain decoupled from audio implementation; they simply broadcast that an event happened, and the audio system decides if a sound should play [Source 155, 5394].

v0.3.19b: The Score
Goal: Implement the AudioEventListener service to subscribe to domain events and map them to SoundCue definitions via a SoundRegistry.
1. Architecture & Data Flow
	•	The Listener Pattern: AudioEventListener is a background service that listens to EventBus. It does not contain game logic; it only translates Events into Cues.
	•	The Registry: A static catalog (SoundRegistry) that acts as a configuration file for which sounds correspond to which events (e.g., EntityDamaged -> SoundCue.Hit).
	•	Context Awareness: The listener checks event payload data (e.g., IsCritical, DamageType) to select specific variations (Heavy Hit vs. Light Hit).
Data Flow: The Feedback Loop
	1	Trigger: CombatService publishes EntityDamagedEvent [Source 2206].
	2	Interception: AudioEventListener receives the event.
	3	Lookup: Listener queries SoundRegistry.GetCueForDamage(event.DamageType, event.IsCritical).
	4	Action: Listener calls _audioService.PlayAsync(cue) [Source 5403].
	5	Output: ConsoleAudioProvider plays the system beep.

2. Logic Decision Trees
A. Combat Event Processing Logic Input: EntityDamagedEvent
	1	Check Magnitude: Is damage > 0?
	◦	No: Stop (Miss/Block handled by separate event).
	2	Check Critical: Is IsCritical == true?
	◦	Yes: Select SoundRegistry.Combat_Crit (High Pitch, Long Decay).
	3	Check Lethal: Is Target.CurrentHP <= 0?
	◦	Yes: Queue SoundRegistry.Combat_Kill (Descending Pitch) after the hit sound.
	4	Default: Select SoundRegistry.Combat_Hit (Medium Pitch).
B. UI Event Processing Logic Input: InputEvent (Key Press)
	1	Context: Is the player in a Menu or Gameplay?
	◦	Menu: SoundRegistry.UI_Blip.
	2	Validation: Did the command fail (e.g., "Cannot move there")?
	◦	Yes: SoundRegistry.UI_Error (Low Buzz).
	◦	No: SoundRegistry.UI_Click (High Click).

3. Code Implementation
A. The Sound Registry File: RuneAndRust.Engine/Data/SoundRegistry.cs Purpose: Centralized definition of all audible cues.
using RuneAndRust.Core.Models;

public static class SoundRegistry
{
    // UI Cues
    public static readonly SoundCue UiNav = new("ui_nav", SoundCategory.UI, 800, 50);
    public static readonly SoundCue UiSelect = new("ui_sel", SoundCategory.UI, 1200, 100);
    public static readonly SoundCue UiError = new("ui_err", SoundCategory.UI, 150, 300);

    // Combat Cues
    public static readonly SoundCue AttackLight = new("atk_lgt", SoundCategory.Combat, 400, 100);
    public static readonly SoundCue AttackHeavy = new("atk_hvy", SoundCategory.Combat, 300, 250);
    public static readonly SoundCue Crit = new("atk_crit", SoundCategory.Combat, 2000, 400); // High pitch notification

    public static SoundCue GetDamageCue(bool isCritical, int damageAmount)
    {
        if (isCritical) return Crit;
        return damageAmount > 10 ? AttackHeavy : AttackLight;
    }
}
B. The Event Listener File: RuneAndRust.Engine/Services/AudioEventListener.cs Purpose: Bridges the EventBus and AudioService.
public class AudioEventListener
{
    private readonly IAudioService _audio;
    private readonly IEventBus _bus;

    public AudioEventListener(IAudioService audio, IEventBus bus)
    {
        _audio = audio;
        _bus = bus;
    }

    public void SubscribeAll()
    {
        // Subscribe to Core Events
        _bus.Subscribe<EntityDamagedEvent>(OnDamaged);
        _bus.Subscribe<EntityDeathEvent>(OnDeath);
        _bus.Subscribe<ItemLootedEvent>(OnLoot);
    }

    private void OnDamaged(EntityDamagedEvent e)
    {
        var cue = SoundRegistry.GetDamageCue(e.IsCritical, e.Amount);
        // Fire and forget - do not await in event handler
        _ = _audio.PlayAsync(cue);
    }

    private void OnDeath(EntityDeathEvent e)
    {
        // Distinct sound for enemy vs player
        var cue = e.IsPlayer ? SoundRegistry.UiError : SoundRegistry.UiSelect;
        _ = _audio.PlayAsync(cue);
    }

    private void OnLoot(ItemLootedEvent e)
    {
        // Higher pitch for better loot?
        _ = _audio.PlayAsync(SoundRegistry.UiSelect);
    }
}

4. Deliverable Checklist (v0.3.19b)
	•	Engine:
	◦	[ ] Implement SoundRegistry with static SoundCue definitions [Source 5395].
	◦	[ ] Implement AudioEventListener class.
	◦	[ ] Register AudioEventListener in Program.cs and call SubscribeAll() on startup.
	•	Integration:
	◦	[ ] Verify CombatService publishes EntityDamagedEvent.
	◦	[ ] Verify InventoryService publishes ItemLootedEvent.
	•	Terminal:
	◦	[ ] Update TerminalInputHandler to trigger UiNav sounds on keypress (optional: usually best handled locally in the UI layer for latency reasons).

5. Logging Requirements
Reference: logging.md
System
Event
Level
Message Template
Properties
Audio
Mapping
Verbose
"[Audio] Mapped event {Event} to cue {CueId}."
Event, CueId
Audio
Fallback
Warning
"[Audio] No cue found for event {Event}. Playing default."
Event

6. Testing Strategy
Unit Tests (AudioEventListenerTests.cs):
	•	Damage_Triggers_Sound:
	◦	Mock IAudioService and IEventBus.
	◦	Simulate EntityDamagedEvent (Normal).
	◦	Assert audio.PlayAsync called with SoundRegistry.AttackLight.
	•	Crit_Triggers_Different_Sound:
	◦	Simulate EntityDamagedEvent (IsCritical = true).
	◦	Assert audio.PlayAsync called with SoundRegistry.Crit.
Manual QA:
	•	Audio Latency Check:
	◦	Start combat. Perform a hit. Ensure the beep occurs immediately with the log message, not seconds later. (If latent, check Task.Run usage in Provider).
	•	Spam Check:
	◦	Use a multi-hit ability (e.g., Whirlwind). Ensure the audio does not "queue up" 5 beeps in a row that play for 3 seconds after the turn ends. (Debounce logic might be needed in v0.3.19c).

7. Draft Changelog (v0.3.19b)
# Changelog: v0.3.19b - The Score

**Release Date:** 2026-02-XX

## Summary
The "Score" update connects the game's event system to the audio engine. Combat actions, inventory management, and UI navigation now generate distinct auditory feedback using a centralized registry.

## Changes
- **Engine:** Implemented `AudioEventListener` to listen for game events.
- **Data:** Created `SoundRegistry` mapping game events (Hit, Crit, Loot) to specific sound frequencies and durations.
- **Combat:** Taking damage now triggers dynamic sound cues based on damage intensity and critical status.
- **UI:** Basic navigation sounds added to menus.