# v0.3.6: The Tactician (Combat View)

> **Status:** Planned
> **Milestone:** Milestone 4.5 - Interface Polish
> **Theme:** Graphical Tactical Dashboard for combat visualization

## Table of Contents
- [Overview](#overview)
- [Phase A: The Battlefield (Grid & Rows)](#phase-a-the-battlefield-grid--rows)
- [Phase B: The Timeline (Initiative & Log)](#phase-b-the-timeline-initiative--log)
- [Phase C: The Telegraph (Intent & Status)](#phase-c-the-telegraph-intent--status)
- [Testing Strategy](#testing-strategy)
- [Changelog (v0.3.6)](#changelog-v036)

## Overview

This milestone transforms the text-heavy combat logs into a graphical Tactical Dashboard. It visualizes the abstract "Front/Back Row" positioning system, displays a dynamic initiative timeline, and exposes enemy intentions to players with high analysis skills (J√∂tun-Readers).

The Combat View is implemented across three phases:

- **Phase A (v0.3.6a): The Battlefield** - Visualizing relative positioning and targeting
- **Phase B (v0.3.6b): The Timeline** - Horizontal turn sequence and rich-text logs
- **Phase C (v0.3.6c): The Telegraph** - Enemy intent indicators and status icons

---

## Phase A: The Battlefield (Grid & Rows)

**Goal:** Implement `CombatGridRenderer` to visualize the 2x2 combat layout (Player Front/Back vs Enemy Front/Back) and enforce row-based targeting logic.

### 1. Architecture & Data Flow

**Concept: The Tactical View**

Combat is abstractly spatial. There is no X/Y movement grid, but there are Zones (Player/Enemy) and Rows (Front/Back).

- **Front Row:** Engaged in melee. Can be hit by melee.
- **Back Row:** Protected. Cannot be hit by melee unless Front Row is empty or weapon has [Reach].

**Data Flow:**

1. **Initialization:** `StartCombat` assigns default rows (Warriors/Skirmishers ‚Üí Front, Mystics/Adepts ‚Üí Back).
2. **State Update:** `CombatService.GetViewModel()` now partitions the `TurnOrder` list into four buckets: `PlayerFront`, `PlayerBack`, `EnemyFront`, `EnemyBack`.
3. **Rendering:** `CombatGridRenderer` builds a 5-column Spectre Grid:
   - [Player Back] [Player Front] [ VS ] [Enemy Front] [Enemy Back]
4. **Targeting:** When the player initiates an attack command, the renderer highlights the target. Validation logic checks if the target is reachable based on the weapon type.

### 2. Logic Decision Trees

#### A. Melee Targeting Validation

**Input:** Attacker, Target, Weapon

1. **Is Weapon Ranged?**
   - Yes: Target is Valid.
2. **Is Weapon Melee?**
   - Check Reach: Does weapon have [Reach] property?
     - Yes: Target is Valid (can hit Back Row).
   - Check Rows: Is Target in Front Row?
     - Yes: Target is Valid.
     - No (Back Row): Is Enemy Front Row Empty?
       - Yes: Target is Valid (Exposed).
       - No: Invalid Target (Blocked by Front Row).

#### B. Grid Rendering Logic

**Input:** CombatViewModel

1. **Create Root Grid:** 5 Columns.
2. **Populate Columns:**
   - For each combatant in PlayerBack: Render Card. Add to Col 1.
   - For each combatant in PlayerFront: Render Card. Add to Col 2.
   - Col 3: Render vertical separator `|` or VS status.
   - For each combatant in EnemyFront: Render Card. Add to Col 4.
   - For each combatant in EnemyBack: Render Card. Add to Col 5.
3. **Highlight Active:** If `Combatant.IsActive`, set border color to Yellow.
4. **Highlight Target:** If `Combatant.Id == SelectedTargetId`, set border to Red (Enemy) or Green (Ally).

### 3. Code Implementation

**File:** `RuneAndRust.Core/Enums/RowPosition.cs`

```csharp
public enum RowPosition
{
    Front = 0,
    Back = 1
}
```

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs`

```csharp
public class Combatant
{
    // ... existing properties ...
    public RowPosition Row { get; set; } = RowPosition.Front;
    public bool IsTargeted { get; set; }
}
```

**File:** `RuneAndRust.Terminal/Rendering/CombatGridRenderer.cs`

```csharp
using Spectre.Console;
using RuneAndRust.Core.ViewModels;

public class CombatGridRenderer
{
    public Panel Render(CombatViewModel vm)
    {
        var grid = new Grid();
        grid.AddColumn(new GridColumn().RightAligned().Width(20));
        grid.AddColumn(new GridColumn().RightAligned().Width(20));
        grid.AddColumn(new GridColumn().Center().Width(4));
        grid.AddColumn(new GridColumn().LeftAligned().Width(20));
        grid.AddColumn(new GridColumn().LeftAligned().Width(20));

        var pBack = new Rows(vm.PlayerTeam.Where(c => c.Row == RowPosition.Back).Select(RenderCard));
        var pFront = new Rows(vm.PlayerTeam.Where(c => c.Row == RowPosition.Front).Select(RenderCard));
        var eFront = new Rows(vm.EnemyTeam.Where(c => c.Row == RowPosition.Front).Select(RenderCard));
        var eBack = new Rows(vm.EnemyTeam.Where(c => c.Row == RowPosition.Back).Select(RenderCard));

        grid.AddRow(pBack, pFront, new Markup("[grey]|[/]"), eFront, eBack);

        return new Panel(grid)
            .Header("[bold]Tactical View[/]")
            .Border(BoxBorder.Rounded)
            .Expand();
    }

    private IRenderable RenderCard(CombatantView c)
    {
        var border = c.IsActive ? Color.Yellow : (c.IsTargeted ? Color.Red : Color.Grey);
        var hpColor = c.HealthStatus.Contains("Healthy") ? "green" : "red";

        var content = new Markup(
            $"[bold {hpColor}]{c.Name}[/]\n" +
            $"{c.HealthStatus}\n" +
            $"{c.StatusEffects}"
        );

        return new Panel(content)
            .BorderColor(border)
            .Padding(0,0,0,0);
    }
}
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Row Assign | Debug | "Assigned {Combatant} to {Row} row." | Combatant, Row |
| Valid Check | Trace | "Target validation: {Attacker} vs {Target} ‚Üí {Result}." | Attacker, Target, Result |
| Render | Trace | "Rendered combat grid. Active: {ActiveId}" | ActiveId |

### 5. Testing Requirements

**Unit Tests (CombatGridTests.cs)**

- **Row_Assignment:**
  - Create Warrior ‚Üí Assert Default Row is Front.
  - Create Mystic ‚Üí Assert Default Row is Back.
- **Validation_Melee:**
  - Setup: Enemy Front Row occupied.
  - Action: Attack Back Row enemy with Dagger.
  - Result: `IsValidTarget` returns False.
- **Validation_Reach:**
  - Setup: Enemy Front Row occupied.
  - Action: Attack Back Row enemy with Spear ([Reach]).
  - Result: `IsValidTarget` returns True.

**Integration Tests**

- **Visual_Highlight:**
  - Set `IsTargeted = true` on Enemy A.
  - Verify Renderer produces Panel with `BorderColor = Color.Red`.

### 6. Deliverable Checklist (Phase A)

- **Core:**
  - [ ] Add `RowPosition` enum.
  - [ ] Add `Row` property to `Combatant`.
  - [ ] Update `CombatViewModel` to expose split team lists.
- **Engine:**
  - [ ] Update `CombatService` to assign rows based on Archetype/Template.
  - [ ] Implement `IsValidTarget(attacker, target, weapon)` logic.
- **Terminal:**
  - [ ] Implement `CombatGridRenderer`.
  - [ ] Update `ExplorationLayout` to include Combat Grid when in Combat Phase.

---

## Phase B: The Timeline (Initiative & Log)

**Goal:** Implement `TimelineRenderer` to visualize the turn queue (Current + Next Round projection) and `CombatLogFormatter` to render rich, color-coded combat events.

### 1. Architecture & Data Flow

**The Timeline Projection Engine:**

To show "who goes next" even across round boundaries, we must project the turn order into the future.

1. **State Source:** `CombatService` holds `TurnOrder` (List of Combatants) and `TurnIndex` (int).
2. **Projection Logic:**
   - Create a queue starting from `TurnIndex`.
   - Append the next round's order (sorted by Initiative) to the end.
   - Take the first 6-8 entries for display.
3. **Rendering:** `TimelineRenderer` draws these entries horizontally, highlighting index 0 (Active).

**The Rich Log Pipeline:**

1. **Event Generation:** `AttackResolutionService` produces an `AttackResult` (Raw Data).
2. **Formatting:** `CombatLogFormatter` converts `AttackResult` into a Spectre Markup string.
3. **Display:** `CombatScreenRenderer` pushes the markup string to the scrolling log panel.

### 2. Logic Decision Trees

#### A. Timeline Projection Logic

**Input:** TurnOrder List, CurrentIndex, WindowSize (e.g., 6)

1. **Current Round Slice:** Take elements from `TurnOrder[CurrentIndex]` to end.
2. **Next Round Slice:**
   - Take `TurnOrder` (full list).
   - Filter: Exclude Dead combatants (HP <= 0).
   - Sort: By Initiative Descending.
3. **Merge:** `Projection = CurrentSlice + NextRoundSlice`.
4. **Truncate:** Take first `WindowSize` elements.
5. **Status Check:**
   - Is Element the Player? ‚Üí Highlight Green.
   - Is Element an Enemy? ‚Üí Highlight Red.

#### B. Log Formatting Logic

**Input:** AttackResult

1. **Prefix:**
   - If `IsCritical`: Add `[bold yellow]CRITICAL HIT! [/]`.
   - If `IsFumble`: Add `[bold red]FUMBLE! [/]`.
   - If `Miss`: Add `[grey]Missed. [/]`.
2. **Damage Type:**
   - Physical ‚Üí `[white]`
   - Fire ‚Üí `[orange1]`
   - Ice ‚Üí `[cyan]`
   - Poison ‚Üí `[green]`
   - Psychic ‚Üí `[purple]`
3. **Compose:** `"{Attacker} hits {Target} for [{Color}]{Damage}[/] damage."`
4. **Append Status:** If `StatusApplied` not null ‚Üí `" {Target} is now [{StatusColor}]{Status}[/]."`

### 3. Code Implementation

**File:** `RuneAndRust.Engine/Services/CombatLogFormatter.cs`

```csharp
public static class CombatLogFormatter
{
    public static string FormatAttack(Combatant attacker, Combatant target, AttackResult result)
    {
        if (!result.IsHit)
            return $"[grey]{attacker.Name} missed {target.Name}.[/]";

        var sb = new StringBuilder();

        if (result.Outcome == AttackOutcome.Critical)
            sb.Append("[bold yellow]CRITICAL![/] ");

        string color = GetDamageColor(result.DamageType);
        sb.Append($"{attacker.Name} hits {target.Name} for [{color}]{result.FinalDamage} {result.DamageType}[/] damage.");

        if (result.StatusApplied != null)
        {
            sb.Append($" [bold]{target.Name}[/] is now [{GetStatusColor(result.StatusApplied.Type)}]{result.StatusApplied.Name}[/]!");
        }

        return sb.ToString();
    }

    private static string GetDamageColor(DamageType type) => type switch
    {
        DamageType.Fire => "orange1",
        DamageType.Ice => "cyan1",
        DamageType.Lightning => "yellow",
        DamageType.Poison => "green",
        DamageType.Psychic => "purple",
        _ => "white"
    };

    private static string GetStatusColor(StatusEffectType type) => "red";
}
```

**File:** `RuneAndRust.Terminal/Rendering/TimelineRenderer.cs`

```csharp
using Spectre.Console;
using RuneAndRust.Core.ViewModels;

public class TimelineRenderer
{
    public Panel Render(CombatViewModel vm)
    {
        var grid = new Grid();
        for(int i=0; i<6; i++) grid.AddColumn(new GridColumn().Center());

        var rowItems = new List<IRenderable>();

        foreach(var entry in vm.TimelineProjection.Take(6))
        {
            var color = entry.IsActive ? "yellow" : "grey";
            var border = entry.IsActive ? BoxBorder.Heavy : BoxBorder.Rounded;

            var panel = new Panel(new Markup($"[{color}]{entry.Name}[/]\n[grey]Init: {entry.Initiative}[/]"))
                .Border(border)
                .BorderColor(entry.IsPlayer ? Color.Cyan1 : Color.Red1);

            rowItems.Add(panel);
        }

        grid.AddRow(rowItems.ToArray());
        return new Panel(grid).Header("Initiative").Expand();
    }
}
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Turn Cycle | Info | "Turn advanced. Active: {Name}. Round: {Round}." | Name, Round |
| Projection | Trace | "Timeline projected: {Order}" | Order (List of IDs) |
| Rich Log | Debug | "Formatted log entry: {MarkupString}" | MarkupString |

### 5. Testing Requirements

**Unit Tests (CombatLogFormatterTests.cs)**

- **Color_Mapping:**
  - Input: `DamageType.Fire` ‚Üí Output contains `[orange1]`.
- **Critical_Formatting:**
  - Input: `Outcome.Critical` ‚Üí Output starts with `[bold yellow]CRITICAL!`.
- **Miss_Formatting:**
  - Input: `IsHit = false` ‚Üí Output is `[grey]...`.

**Unit Tests (TimelineLogicTests.cs)**

- **Projection_WrapAround:**
  - Given: Order [A, B, C], Current B.
  - Result: [B, C, A, B, C]. (Proves it wraps to next round).
- **Projection_SkipsDead:**
  - Given: Order [A, B, C], B is Dead.
  - Result: [A, C, A, C].

**Integration Tests**

- **Visual_Check:**
  - Run combat. Ensure the Timeline Panel renders above/below the Grid.
  - Ensure Active Combatant is visually distinct (Heavy border).

### 6. Deliverable Checklist (Phase B)

- **Core:**
  - [ ] Add `TimelineProjection` property to `CombatViewModel`.
  - [ ] Add `DamageType` to `AttackResult` (if missing).
- **Engine:**
  - [ ] Implement `TimelineProjection` logic in `CombatService.GetViewModel()`.
  - [ ] Implement `CombatLogFormatter` class.
  - [ ] Refactor `CombatService` to use `CombatLogFormatter` for log messages.
- **Terminal:**
  - [ ] Implement `TimelineRenderer` using Spectre Grid.
  - [ ] Integrate Timeline into `CombatScreenRenderer`.

---

## Phase C: The Telegraph (Intent & Status)

**Goal:** Update `CombatService` to pre-calculate enemy actions at the start of a round and render Intent/Status icons on the Tactical Grid based on player perception stats.

### 1. Architecture & Data Flow

**The Planning Phase:**

Currently, AI decides its move on its turn. To implement Telegraphing, we must split AI logic into Planning and Execution.

1. **Round Start:** `CombatService` calls `EnemyAIService.PlanActions()` for all living enemies.
2. **Storage:** The resulting `CombatAction` is stored in `Combatant.PlannedAction`.
3. **Analysis Check:** The engine compares Player WITS + Bonuses vs Enemy Stealth/Level.
4. **ViewModel Mapping:**
   - If Check Passed (or J√∂tun-Reader): Map `PlannedAction` to Icon (e.g., ‚öîÔ∏è).
   - If Check Failed: Map to `?`.
5. **Execution:** When the enemy's turn arrives, it executes the stored plan rather than calculating a new one.

### 2. Logic Decision Trees

#### A. Intent Visibility Logic

**Input:** Player, Enemy

1. **Absolute Reveal:**
   - Is Player J√∂tun-Reader? ‚Üí Reveal.
   - Is Enemy under [Analyzed] status? ‚Üí Reveal.
2. **Attribute Check:**
   - Roll WITS (Player) vs 10 + Enemy.Tier (DC).
   - Success: Reveal.
   - Failure: Hide (`?`).
3. **Icon Resolution:**
   - Attack: ‚öîÔ∏è
   - Defend: üõ°Ô∏è
   - Buff/Heal: ‚ú®
   - Special/Ultimate: ‚ò†Ô∏è

#### B. Status Icon Rendering

**Input:** `List<StatusEffect>`

1. **Iterate Effects:**
2. **Map Type to Icon:**
   - Bleeding: ü©∏
   - Poisoned: ü§¢
   - Stunned: üí´
   - Vulnerable: üíî
   - Fortified: üõ°Ô∏è
   - Hasted: ‚ö°
3. **Format:**
   - If Stacks > 1: `"{Icon}x{Stacks}"`
   - Else: `"{Icon}"`
4. **Join:** Space-separated string.

### 3. Code Implementation

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs`

```csharp
public class Combatant
{
    // ... existing properties ...

    public CombatAction? PlannedAction { get; set; }
    public bool IsIntentRevealed { get; set; }

    public string GetStatusIcons()
    {
        var sb = new StringBuilder();
        foreach (var effect in StatusEffects)
        {
            string icon = effect.Type switch
            {
                StatusEffectType.Bleeding => "ü©∏",
                StatusEffectType.Poisoned => "ü§¢",
                StatusEffectType.Stunned => "üí´",
                StatusEffectType.Vulnerable => "üíî",
                StatusEffectType.Fortified => "üõ°Ô∏è",
                _ => "‚Ä¢"
            };
            sb.Append(effect.Stacks > 1 ? $"{icon}x{effect.Stacks} " : $"{icon} ");
        }
        return sb.ToString().Trim();
    }
}
```

**File:** `RuneAndRust.Engine/Services/CombatService.cs`

```csharp
private void PlanEnemyActions()
{
    foreach (var enemy in _state.TurnOrder.Where(c => !c.IsPlayer && c.CurrentHp > 0))
    {
        enemy.PlannedAction = _aiService.DetermineAction(enemy, _state);

        var player = _state.CurrentCharacter;
        bool isAnalyst = player.Archetype == ArchetypeType.Adept;

        if (isAnalyst || _statusService.HasEffect(enemy, StatusEffectType.Analyzed))
        {
            enemy.IsIntentRevealed = true;
        }
        else
        {
            var check = _dice.Roll(player.Attributes[Attribute.Wits], "Intent Check");
            enemy.IsIntentRevealed = check.Successes >= 1;
        }
    }
}
```

**File:** `RuneAndRust.Terminal/Rendering/CombatGridRenderer.cs`

```csharp
private IRenderable RenderCard(CombatantView c)
{
    var intent = c.IsPlayer ? "" : (c.IntentIcon ?? "?");

    var content = new Markup(
        $"[bold {hpColor}]{c.Name}[/]\n" +
        $"{c.HealthStatus}\n" +
        $"{c.StatusIcons}\n" +
        $"[yellow]{intent}[/]"
    );

    return new Panel(content).BorderColor(border);
}
```

### 4. Logging Requirements

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Plan Action | Trace | "[AI] {Enemy} planned action: {ActionType} vs {Target}" | Enemy, ActionType, Target |
| Intent Check | Debug | "[Combat] Intent check vs {Enemy}: {Result} ({Successes} successes)" | Enemy, Result, Successes |
| Status Render | Trace | "[UI] Rendering status icons for {Combatant}: {Icons}" | Combatant, Icons |

### 5. Testing Requirements

**Unit Tests (CombatServiceTests.cs)**

- **Planning_StoresAction:**
  - Call `StartNewRound()`.
  - Verify `Enemy.PlannedAction` is not null.
- **Reveal_Logic_Analyst:**
  - Set Player Archetype = Adept (J√∂tun-Reader logic).
  - Verify `Enemy.IsIntentRevealed` is true.
- **Reveal_Logic_Roll:**
  - Mock Dice to 0 successes ‚Üí Verify `IsIntentRevealed` false.
  - Mock Dice to 1 success ‚Üí Verify `IsIntentRevealed` true.

**Integration Tests (VisualTests.cs)**

- **Icon_Mapping:**
  - Apply 5 stacks of Bleeding.
  - Verify `GetStatusIcons()` returns "ü©∏x5".

### 6. Deliverable Checklist (Phase C)

- **Core:**
  - [ ] Add `PlannedAction` and `IsIntentRevealed` to `Combatant`.
  - [ ] Add `StatusIcons` and `IntentIcon` strings to `CombatantView`.
- **Engine:**
  - [ ] Update `IEnemyAIService` to support pure decision-making without immediate execution.
  - [ ] Implement `PlanEnemyActions()` in `CombatService`.
  - [ ] Update `ExecuteEnemyTurn` to consume `PlannedAction` if valid.
- **Terminal:**
  - [ ] Update `CombatGridRenderer` to display the new icons in the panel.
  - [ ] Ensure Unicode characters render correctly in the target console.

---

## Testing Strategy

### Unit Tests

- **CombatGridTests.cs:** Row assignment, targeting validation
- **CombatLogFormatterTests.cs:** Color mapping, critical formatting
- **TimelineLogicTests.cs:** Projection wrap-around, dead combatant filtering
- **CombatServiceTests.cs:** Action planning, intent reveal logic

### Integration Tests

- **Visual_Highlight:** Verify rendering produces correct border colors
- **Intent_AI_Sync:** Verify Intent shown in UI matches the action the AI performs

---

## Changelog (v0.3.6)

**Release Date:** 2025-XX-XX

### Summary

Combat has been upgraded from a text stream to a fully visualized Tactical Dashboard. The new interface displays relative positioning (Rows), a predictive Turn Timeline, and reveals enemy intentions to observant players.

### Features

- **Tactical Grid View:**
  - Visualizes Front/Back rows for both Player and Enemies.
  - Cursor-based targeting with range validation (Gold = Valid, Red = Out of Range).
- **Dynamic Timeline:**
  - Horizontal bar showing the upcoming turn order.
  - Highlights the active combatant.
- **The Telegraph System:**
  - Enemies now "telegraph" their moves. High WITS characters can see if an enemy intends to Attack (‚öîÔ∏è) or Block (üõ°Ô∏è) before it happens.
- **Rich Status Indicators:**
  - Status effects are now displayed as icons (ü©∏, ü§¢, ‚ö°) on combatant cards.
- **Rich Combat Log:**
  - Damage Types: Fire damage glows orange, Ice freezes in cyan, Physical remains steel-white.
  - Critical Hits: Bold yellow text announces critical strikes.

### Technical

- Implemented `CombatGridRenderer` using `Spectre.Console`.
- Added `RowPosition` state to Combatants.
- Implemented `TimelineProjection` logic to flatten turn cycles into a linear queue.
- Added `CombatLogFormatter` to centralize Spectre.Console markup generation.
- Refactored `EnemyAIService` to separate decision logic from execution.
