# v0.4.2b Design Specification: Puzzle Types

**Version:** 0.4.2b
**Phase Name:** Puzzle Types
**Parent Version:** v0.4.2 (Puzzles & Riddles)
**Prerequisites:** v0.4.2a Complete (Puzzle Core)
**Estimated Tests:** ~30 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [SequencePuzzle](#4-sequencepuzzle)
5. [CombinationPuzzle](#5-combinationpuzzle)
6. [PatternPuzzle](#6-patternpuzzle)
7. [Puzzle Entity Updates](#7-puzzle-entity-updates)
8. [PuzzleService Updates](#8-puzzleservice-updates)
9. [User-Facing Commands](#9-user-facing-commands)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration File Schemas](#11-configuration-file-schemas)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification implements the three primary puzzle type mechanics building on the core puzzle infrastructure from v0.4.2a. Each puzzle type has unique input handling, validation logic, and player feedback:

- **SequencePuzzle**: Ordered object activation requiring correct step sequence
- **CombinationPuzzle**: Code/combination input with optional partial feedback
- **PatternPuzzle**: Visual pattern matching and reproduction

These type-specific implementations extend the base `Puzzle` entity with specialized data and validation, enabling diverse puzzle challenges throughout dungeon exploration.

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Value Objects** | `SequencePuzzle`, `CombinationPuzzle`, `PatternPuzzle`, `CombinationFeedback` |
| **Puzzle Updates** | Type-specific data properties on Puzzle entity |
| **Service Updates** | Type-specific validation in PuzzleService |
| **Commands** | `input` (combination entry), `pattern` (pattern submission) |
| **InteractiveObject Integration** | `activate` integration for sequence steps |
| **Configuration** | Update `puzzles.json` with type-specific data |
| **Tests** | ~30 unit tests |

### 1.3 Architectural Significance

This version establishes the **Puzzle Type Pattern** for specialized puzzle mechanics:

- **Type-Specific Value Objects**: Each puzzle type has its own configuration object
- **Nullable Type Data**: Puzzle entity holds only relevant type data
- **Polymorphic Validation**: PuzzleService delegates to type-specific validators
- **Interactive Object Integration**: Sequence puzzles integrate with existing activation mechanics
- **Progressive Feedback**: Partial progress shown to players during attempts

---

## 2. Feature Overview

```
v0.4.2b Puzzle Types
├── SequencePuzzle Value Object
│   ├── RequiredSequence (ordered step IDs)
│   ├── StepDescriptions (feedback per step)
│   ├── ResetOnWrongStep (configurable)
│   ├── ConsecutiveSteps (optional timing)
│   ├── StepObjectIds (InteractiveObject links)
│   ├── IsCorrectNextStep() validation
│   ├── IsComplete() check
│   └── GetRemainingSteps() count
├── CombinationPuzzle Value Object
│   ├── Solution (correct code)
│   ├── ValidCharacters (allowed input)
│   ├── CaseSensitive (matching mode)
│   ├── ShowPartialFeedback (optional hints)
│   ├── AlternateSolutions (multiple valid codes)
│   ├── Validate() method
│   └── GetFeedback() partial results
├── PatternPuzzle Value Object
│   ├── TargetPattern (solution pattern)
│   ├── GridWidth/GridHeight (dimensions)
│   ├── PatternElements (valid symbols)
│   ├── ShowTargetPattern (display mode)
│   ├── PatternDisplayDuration (visibility)
│   ├── AcceptRotations (flexible matching)
│   ├── AcceptReflections (flexible matching)
│   └── Validate() method
├── Puzzle Entity Updates
│   ├── SequenceData: SequencePuzzle?
│   ├── CombinationData: CombinationPuzzle?
│   ├── PatternData: PatternPuzzle?
│   └── SetTypeData() method
├── PuzzleService Updates
│   ├── ValidateSequenceStep()
│   ├── ValidateCombination()
│   ├── ValidatePattern()
│   └── GetSequenceProgress()
├── Commands
│   ├── input <code>
│   └── pattern <input>
└── InteractiveObject Integration
    └── activate <object> → sequence step
```

### 2.1 Scope Alignment

**In Scope:**
- `SequencePuzzle` with ordered step requirements
- `CombinationPuzzle` with code and input tracking
- `PatternPuzzle` with pattern display and matching
- Sequence step tracking and validation
- Combination input handling
- Pattern display in TUI
- `input` command for combination entry
- `pattern` command for pattern submission
- `activate` integration for sequence steps
- Partial progress feedback
- Step-by-step sequence validation
- Sequence reset on wrong step (configurable)

**Out of Scope:**
- Riddle puzzles (v0.4.2c)
- Multi-part puzzles (v0.4.2c)
- Hint system (v0.4.2c)
- Puzzle rewards (v0.4.2c)
- `answer` command (v0.4.2c)

---

## 3. Architecture Diagrams

### 3.1 Puzzle Type Hierarchy

```
┌─────────────────────────────────────────────────────────────────────┐
│                           Puzzle Entity                              │
├─────────────────────────────────────────────────────────────────────┤
│  + Id: Guid                                                         │
│  + Type: PuzzleType                                                 │
│  + State: PuzzleState                                               │
│  ...                                                                │
├─────────────────────────────────────────────────────────────────────┤
│  + SequenceData: SequencePuzzle?      (Type == Sequence)            │
│  + CombinationData: CombinationPuzzle? (Type == Combination)        │
│  + PatternData: PatternPuzzle?        (Type == Pattern)             │
└─────────────────────────────────────────────────────────────────────┘
                                 │
                 ┌───────────────┼───────────────┐
                 ▼               ▼               ▼
┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────────┐
│   SequencePuzzle    │ │  CombinationPuzzle  │ │    PatternPuzzle    │
│   (Value Object)    │ │   (Value Object)    │ │   (Value Object)    │
├─────────────────────┤ ├─────────────────────┤ ├─────────────────────┤
│ + RequiredSequence  │ │ + Solution          │ │ + TargetPattern     │
│ + StepDescriptions  │ │ + ValidCharacters   │ │ + GridWidth         │
│ + ResetOnWrongStep  │ │ + CaseSensitive     │ │ + GridHeight        │
│ + StepObjectIds     │ │ + ShowPartialFeedback│ │ + PatternElements  │
├─────────────────────┤ │ + AlternateSolutions│ │ + ShowTargetPattern │
│ + IsCorrectNextStep()│├─────────────────────┤ │ + AcceptRotations   │
│ + IsComplete()      │ │ + Validate()        │ ├─────────────────────┤
│ + GetRemainingSteps()│ │ + GetFeedback()    │ │ + Validate()        │
└─────────────────────┘ └─────────────────────┘ └─────────────────────┘
```

### 3.2 Sequence Puzzle Flow

```
┌─────────────────┐
│  Player enters  │
│      room       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐    ┌─────────────────┐
│ examine puzzle  │───▶│  See sequence   │
│  (Type:Sequence)│    │   description   │
└────────┬────────┘    └─────────────────┘
         │
         ▼
┌─────────────────┐
│ activate object │
│   (step N)      │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│         IsCorrectNextStep(stepId)?       │
└────────────────┬────────────────────────┘
                 │
         ┌───────┴───────┐
         │               │
    [YES]▼          [NO] ▼
┌─────────────┐  ┌─────────────────────┐
│ AddStep()   │  │ ResetOnWrongStep?   │
│ Show success│  └─────────┬───────────┘
└──────┬──────┘            │
       │           ┌───────┴───────┐
       ▼      [YES]▼          [NO] ▼
┌─────────────┐ ┌──────────────┐ ┌──────────────┐
│IsComplete()?│ │ClearSteps()  │ │ Show wrong   │
└──────┬──────┘ │Show reset msg│ │  step msg    │
       │        └──────────────┘ └──────────────┘
  ┌────┴────┐
  │         │
[YES]▼   [NO]▼
┌────────┐ ┌────────────┐
│ SOLVED │ │Continue    │
│        │ │(more steps)│
└────────┘ └────────────┘
```

### 3.3 Combination Puzzle Flow

```
┌─────────────────┐
│  Player enters  │
│      room       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐    ┌──────────────────────┐
│ examine puzzle  │───▶│ See combination lock │
│(Type:Combination)│   │  description         │
└────────┬────────┘    └──────────────────────┘
         │
         ▼
┌─────────────────┐
│  input <code>   │
└────────┬────────┘
         │
         ▼
┌────────────────────────────────────┐
│        Validate(input)             │
└───────────────┬────────────────────┘
                │
        ┌───────┴───────┐
        │               │
   [TRUE]▼         [FALSE]▼
┌────────────┐  ┌─────────────────────────────┐
│   SOLVED   │  │   RecordFailedAttempt()     │
└────────────┘  └──────────────┬──────────────┘
                               │
                               ▼
               ┌───────────────────────────────┐
               │     ShowPartialFeedback?      │
               └───────────────┬───────────────┘
                               │
                       ┌───────┴───────┐
                  [YES]▼          [NO] ▼
               ┌───────────────┐ ┌──────────────┐
               │GetFeedback()  │ │Show "wrong"  │
               │Show positions │ │  message     │
               │& characters   │ └──────────────┘
               └───────────────┘
```

### 3.4 Pattern Puzzle Flow

```
┌─────────────────┐
│  Player enters  │
│      room       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐    ┌──────────────────────────┐
│ examine puzzle  │───▶│ ShowTargetPattern?       │
│  (Type:Pattern) │    └────────────┬─────────────┘
└────────┬────────┘                 │
         │                  ┌───────┴───────┐
         │             [YES]▼          [NO] ▼
         │         ┌──────────────┐ ┌──────────────┐
         │         │Display target│ │Memory puzzle │
         │         │   pattern    │ │(shown once)  │
         │         └──────────────┘ └──────────────┘
         │
         ▼
┌─────────────────┐
│ pattern <input> │
└────────┬────────┘
         │
         ▼
┌────────────────────────────────────────────┐
│             Validate(inputPattern)          │
│  (includes AcceptRotations/AcceptReflections)│
└───────────────────┬────────────────────────┘
                    │
            ┌───────┴───────┐
            │               │
       [TRUE]▼         [FALSE]▼
    ┌────────────┐  ┌────────────────┐
    │   SOLVED   │  │ Show "doesn't  │
    └────────────┘  │  match" msg    │
                    └────────────────┘
```

### 3.5 Service Layer Integration

```
┌─────────────────────────────────────────────────────────────────────┐
│                          PuzzleService                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Existing Methods (v0.4.2a):                                        │
│  + BeginAttempt(player, puzzle): PuzzleAttemptResult                │
│  + AttemptSolve(player, puzzle, input): PuzzleSolveResult           │
│  + GetCurrentAttempt(player, puzzle): PuzzleAttempt?                │
│                                                                      │
│  NEW Type-Specific Methods (v0.4.2b):                               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  + ValidateSequenceStep(puzzle, attempt, stepId):           │   │
│  │        PuzzleStepResult                                      │   │
│  │  + ValidateCombination(puzzle, input): PuzzleSolveResult    │   │
│  │  + ValidatePattern(puzzle, input): PuzzleSolveResult        │   │
│  │  + GetSequenceProgress(puzzle, attempt): SequenceProgress   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  Updated AttemptSolve Flow:                                         │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  switch (puzzle.Type)                                        │   │
│  │  {                                                           │   │
│  │      case Sequence:  → ValidateSequenceStep()                │   │
│  │      case Combination: → ValidateCombination()               │   │
│  │      case Pattern:   → ValidatePattern()                     │   │
│  │      default:        → Generic validation                    │   │
│  │  }                                                           │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
                                 │
                                 │ uses
                                 ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     InteractionService                               │
├─────────────────────────────────────────────────────────────────────┤
│  activate <object>                                                   │
│       │                                                              │
│       ▼                                                              │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  Check if object is linked to sequence puzzle step          │   │
│  │  If yes → PuzzleService.ValidateSequenceStep()              │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. SequencePuzzle

### 4.1 Overview

The `SequencePuzzle` value object configures puzzles that require activating interactive objects in a specific order. Each step links to an `InteractiveObject` in the room, and wrong steps can optionally reset progress.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SequencePuzzle.cs`

### 4.2 Properties

| Property | Type | Description |
|----------|------|-------------|
| `RequiredSequence` | `IReadOnlyList<string>` | Ordered step IDs that must be activated |
| `StepDescriptions` | `IReadOnlyDictionary<string, string>` | Feedback message per step |
| `ResetOnWrongStep` | `bool` | Whether wrong steps clear progress |
| `RequiresConsecutiveSteps` | `bool` | Whether steps must be consecutive (no delays) |
| `MaxTurnsBetweenSteps` | `int` | Maximum turns allowed between steps (0 = unlimited) |
| `StepObjectIds` | `IReadOnlyDictionary<string, Guid>` | Maps step IDs to InteractiveObject IDs |

### 4.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a sequence-based puzzle requiring ordered activation.
/// </summary>
public class SequencePuzzle
{
    /// <summary>
    /// Gets the ordered list of step IDs that must be activated.
    /// </summary>
    public IReadOnlyList<string> RequiredSequence { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets descriptions for each step (for feedback).
    /// </summary>
    public IReadOnlyDictionary<string, string> StepDescriptions { get; private set; }
        = new Dictionary<string, string>();

    /// <summary>
    /// Gets whether wrong steps reset the entire sequence.
    /// </summary>
    public bool ResetOnWrongStep { get; private set; } = true;

    /// <summary>
    /// Gets whether steps must be consecutive (no delays).
    /// </summary>
    public bool RequiresConsecutiveSteps { get; private set; }

    /// <summary>
    /// Gets the max turns between steps (0 = no limit).
    /// </summary>
    public int MaxTurnsBetweenSteps { get; private set; }

    /// <summary>
    /// Gets associated interactive object IDs for each step.
    /// </summary>
    public IReadOnlyDictionary<string, Guid> StepObjectIds { get; private set; }
        = new Dictionary<string, Guid>();

    private SequencePuzzle() { }

    /// <summary>
    /// Creates a sequence puzzle configuration.
    /// </summary>
    /// <param name="sequence">The ordered step IDs.</param>
    /// <param name="stepDescriptions">Optional feedback per step.</param>
    /// <param name="resetOnWrongStep">Whether wrong steps reset progress.</param>
    /// <param name="requiresConsecutive">Whether steps must be consecutive.</param>
    /// <param name="maxTurnsBetween">Maximum turns between steps.</param>
    /// <param name="stepObjectIds">Map of step IDs to object IDs.</param>
    /// <returns>A new SequencePuzzle instance.</returns>
    public static SequencePuzzle Create(
        IEnumerable<string> sequence,
        IDictionary<string, string>? stepDescriptions = null,
        bool resetOnWrongStep = true,
        bool requiresConsecutive = false,
        int maxTurnsBetween = 0,
        IDictionary<string, Guid>? stepObjectIds = null)
    {
        var sequenceList = sequence.ToList();
        ArgumentOutOfRangeException.ThrowIfZero(sequenceList.Count);

        return new SequencePuzzle
        {
            RequiredSequence = sequenceList,
            StepDescriptions = stepDescriptions?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value)
                ?? new Dictionary<string, string>(),
            ResetOnWrongStep = resetOnWrongStep,
            RequiresConsecutiveSteps = requiresConsecutive,
            MaxTurnsBetweenSteps = Math.Max(0, maxTurnsBetween),
            StepObjectIds = stepObjectIds?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value)
                ?? new Dictionary<string, Guid>()
        };
    }

    /// <summary>
    /// Validates if a step is the correct next step.
    /// </summary>
    /// <param name="completedSteps">Steps already completed.</param>
    /// <param name="stepId">The step being attempted.</param>
    /// <returns>True if this is the correct next step.</returns>
    public bool IsCorrectNextStep(IReadOnlyList<string> completedSteps, string stepId)
    {
        if (completedSteps.Count >= RequiredSequence.Count)
            return false;

        return RequiredSequence[completedSteps.Count] == stepId;
    }

    /// <summary>
    /// Checks if the sequence is complete.
    /// </summary>
    /// <param name="completedSteps">Steps completed so far.</param>
    /// <returns>True if all steps completed in order.</returns>
    public bool IsComplete(IReadOnlyList<string> completedSteps)
    {
        if (completedSteps.Count != RequiredSequence.Count)
            return false;

        return completedSteps.SequenceEqual(RequiredSequence);
    }

    /// <summary>
    /// Gets the number of remaining steps.
    /// </summary>
    /// <param name="completedSteps">Steps completed so far.</param>
    /// <returns>Number of steps remaining.</returns>
    public int GetRemainingSteps(IReadOnlyList<string> completedSteps)
    {
        return Math.Max(0, RequiredSequence.Count - completedSteps.Count);
    }

    /// <summary>
    /// Gets the description for a step.
    /// </summary>
    /// <param name="stepId">The step ID.</param>
    /// <returns>The step description, or a default message.</returns>
    public string GetStepDescription(string stepId)
    {
        return StepDescriptions.TryGetValue(stepId, out var desc)
            ? desc
            : $"Step '{stepId}' activated.";
    }

    /// <summary>
    /// Gets the interactive object ID for a step.
    /// </summary>
    /// <param name="stepId">The step ID.</param>
    /// <returns>The object ID, or null if not mapped.</returns>
    public Guid? GetStepObjectId(string stepId)
    {
        return StepObjectIds.TryGetValue(stepId, out var id) ? id : null;
    }

    /// <summary>
    /// Finds the step ID associated with an object.
    /// </summary>
    /// <param name="objectId">The object ID.</param>
    /// <returns>The step ID, or null if not found.</returns>
    public string? GetStepIdForObject(Guid objectId)
    {
        return StepObjectIds.FirstOrDefault(kvp => kvp.Value == objectId).Key;
    }
}
```

---

## 5. CombinationPuzzle

### 5.1 Overview

The `CombinationPuzzle` value object configures puzzles that require entering a correct code or combination. It supports partial feedback showing how many digits are correct, optional alternate solutions, and case sensitivity.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CombinationPuzzle.cs`

### 5.2 Properties

| Property | Type | Description |
|----------|------|-------------|
| `Solution` | `string` | The correct combination |
| `Length` | `int` | Number of characters in solution |
| `ValidCharacters` | `string` | Characters allowed in input |
| `CaseSensitive` | `bool` | Whether matching is case-sensitive |
| `ShowPartialFeedback` | `bool` | Whether to show correct positions |
| `Separator` | `string?` | Separator between input segments |
| `AlternateSolutions` | `IReadOnlyList<string>` | Additional valid solutions |

### 5.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a combination/code-based puzzle.
/// </summary>
public class CombinationPuzzle
{
    /// <summary>
    /// Gets the correct combination.
    /// </summary>
    public string Solution { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the length of the combination.
    /// </summary>
    public int Length { get; private set; }

    /// <summary>
    /// Gets the valid characters/digits for input.
    /// </summary>
    public string ValidCharacters { get; private set; } = "0123456789";

    /// <summary>
    /// Gets whether input is case-sensitive.
    /// </summary>
    public bool CaseSensitive { get; private set; }

    /// <summary>
    /// Gets whether to show partial feedback (correct digits).
    /// </summary>
    public bool ShowPartialFeedback { get; private set; }

    /// <summary>
    /// Gets the separator between input segments (null = none).
    /// </summary>
    public string? Separator { get; private set; }

    /// <summary>
    /// Gets alternate accepted solutions (if any).
    /// </summary>
    public IReadOnlyList<string> AlternateSolutions { get; private set; } = Array.Empty<string>();

    private CombinationPuzzle() { }

    /// <summary>
    /// Creates a combination puzzle configuration.
    /// </summary>
    /// <param name="solution">The correct solution.</param>
    /// <param name="validChars">Valid input characters.</param>
    /// <param name="caseSensitive">Case-sensitive matching.</param>
    /// <param name="showPartialFeedback">Show correct position hints.</param>
    /// <param name="separator">Separator for display.</param>
    /// <param name="alternateSolutions">Additional valid solutions.</param>
    /// <returns>A new CombinationPuzzle instance.</returns>
    public static CombinationPuzzle Create(
        string solution,
        string? validChars = null,
        bool caseSensitive = false,
        bool showPartialFeedback = false,
        string? separator = null,
        IEnumerable<string>? alternateSolutions = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(solution);

        return new CombinationPuzzle
        {
            Solution = solution,
            Length = solution.Length,
            ValidCharacters = validChars ?? "0123456789",
            CaseSensitive = caseSensitive,
            ShowPartialFeedback = showPartialFeedback,
            Separator = separator,
            AlternateSolutions = alternateSolutions?.ToList() ?? Array.Empty<string>()
        };
    }

    /// <summary>
    /// Validates if the input matches the solution.
    /// </summary>
    /// <param name="input">The player's input.</param>
    /// <returns>True if the input is correct.</returns>
    public bool Validate(string input)
    {
        var comparison = CaseSensitive
            ? StringComparison.Ordinal
            : StringComparison.OrdinalIgnoreCase;

        // Normalize input by removing separators
        var normalizedInput = NormalizeInput(input);

        if (Solution.Equals(normalizedInput, comparison))
            return true;

        return AlternateSolutions.Any(alt => alt.Equals(normalizedInput, comparison));
    }

    /// <summary>
    /// Gets partial feedback showing correct positions.
    /// </summary>
    /// <param name="input">The player's input.</param>
    /// <returns>Feedback about correct positions and characters.</returns>
    public CombinationFeedback GetFeedback(string input)
    {
        if (!ShowPartialFeedback)
            return new CombinationFeedback { CorrectPositions = 0, CorrectCharacters = 0 };

        var normalizedInput = NormalizeInput(input);
        var normalizedSolution = CaseSensitive ? Solution : Solution.ToLowerInvariant();
        var compareInput = CaseSensitive ? normalizedInput : normalizedInput.ToLowerInvariant();

        var correctPositions = 0;
        var solutionCharCounts = new Dictionary<char, int>();
        var inputCharCounts = new Dictionary<char, int>();

        // Count exact position matches and character frequencies
        for (int i = 0; i < Math.Min(compareInput.Length, normalizedSolution.Length); i++)
        {
            if (compareInput[i] == normalizedSolution[i])
            {
                correctPositions++;
            }
        }

        // Count character frequencies in solution
        foreach (var c in normalizedSolution)
        {
            solutionCharCounts.TryGetValue(c, out var count);
            solutionCharCounts[c] = count + 1;
        }

        // Count character frequencies in input
        foreach (var c in compareInput)
        {
            inputCharCounts.TryGetValue(c, out var count);
            inputCharCounts[c] = count + 1;
        }

        // Calculate correct characters (in wrong positions)
        var totalCorrectChars = 0;
        foreach (var kvp in inputCharCounts)
        {
            if (solutionCharCounts.TryGetValue(kvp.Key, out var solutionCount))
            {
                totalCorrectChars += Math.Min(kvp.Value, solutionCount);
            }
        }

        var correctCharacters = totalCorrectChars - correctPositions;

        return new CombinationFeedback
        {
            CorrectPositions = correctPositions,
            CorrectCharacters = Math.Max(0, correctCharacters)
        };
    }

    /// <summary>
    /// Validates that input contains only valid characters.
    /// </summary>
    /// <param name="input">The input to validate.</param>
    /// <returns>True if all characters are valid.</returns>
    public bool IsValidInput(string input)
    {
        var normalizedInput = NormalizeInput(input);
        var validSet = CaseSensitive
            ? ValidCharacters.ToHashSet()
            : ValidCharacters.ToLowerInvariant().ToHashSet();

        var compareInput = CaseSensitive ? normalizedInput : normalizedInput.ToLowerInvariant();

        return compareInput.All(c => validSet.Contains(c));
    }

    /// <summary>
    /// Formats input with separators for display.
    /// </summary>
    /// <param name="input">The raw input.</param>
    /// <returns>Formatted input string.</returns>
    public string FormatForDisplay(string input)
    {
        if (string.IsNullOrEmpty(Separator))
            return input;

        return string.Join(Separator, input.ToCharArray());
    }

    private string NormalizeInput(string input)
    {
        if (string.IsNullOrEmpty(Separator))
            return input;

        return input.Replace(Separator, "", StringComparison.Ordinal);
    }
}

/// <summary>
/// Feedback for a combination attempt.
/// </summary>
public readonly record struct CombinationFeedback
{
    /// <summary>
    /// Gets the number of characters in the correct position.
    /// </summary>
    public int CorrectPositions { get; init; }

    /// <summary>
    /// Gets the number of correct characters in wrong positions.
    /// </summary>
    public int CorrectCharacters { get; init; }

    /// <summary>
    /// Gets whether any characters were correct.
    /// </summary>
    public bool HasCorrectChars => CorrectPositions > 0 || CorrectCharacters > 0;
}
```

---

## 6. PatternPuzzle

### 6.1 Overview

The `PatternPuzzle` value object configures puzzles that require matching or reproducing a visual pattern. Patterns are represented as strings with grid dimensions, and validation can optionally accept rotations or reflections of the pattern.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/PatternPuzzle.cs`

### 6.2 Properties

| Property | Type | Description |
|----------|------|-------------|
| `TargetPattern` | `string` | Pattern to match (string encoding) |
| `GridWidth` | `int` | Pattern grid width |
| `GridHeight` | `int` | Pattern grid height |
| `PatternElements` | `IReadOnlyList<string>` | Valid pattern symbols |
| `ShowTargetPattern` | `bool` | Whether pattern is shown before solving |
| `PatternDisplayDuration` | `int` | How long pattern is visible (0 = always) |
| `AcceptRotations` | `bool` | Accept 90/180/270 degree rotations |
| `AcceptReflections` | `bool` | Accept horizontal/vertical reflections |

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Configuration for a pattern matching puzzle.
/// </summary>
public class PatternPuzzle
{
    /// <summary>
    /// Gets the pattern to match (as string representation).
    /// </summary>
    public string TargetPattern { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the pattern grid width.
    /// </summary>
    public int GridWidth { get; private set; }

    /// <summary>
    /// Gets the pattern grid height.
    /// </summary>
    public int GridHeight { get; private set; }

    /// <summary>
    /// Gets the pattern elements/symbols available.
    /// </summary>
    public IReadOnlyList<string> PatternElements { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets whether the pattern is shown before solving.
    /// </summary>
    public bool ShowTargetPattern { get; private set; } = true;

    /// <summary>
    /// Gets how long the pattern is displayed (turns, 0 = always visible).
    /// </summary>
    public int PatternDisplayDuration { get; private set; }

    /// <summary>
    /// Gets whether rotations of the pattern are accepted.
    /// </summary>
    public bool AcceptRotations { get; private set; }

    /// <summary>
    /// Gets whether reflections of the pattern are accepted.
    /// </summary>
    public bool AcceptReflections { get; private set; }

    private PatternPuzzle() { }

    /// <summary>
    /// Creates a pattern puzzle configuration.
    /// </summary>
    /// <param name="targetPattern">The pattern solution.</param>
    /// <param name="gridWidth">Grid width.</param>
    /// <param name="gridHeight">Grid height.</param>
    /// <param name="elements">Valid pattern symbols.</param>
    /// <param name="showTarget">Whether to show the target.</param>
    /// <param name="displayDuration">How long to show (turns).</param>
    /// <param name="acceptRotations">Accept rotated solutions.</param>
    /// <param name="acceptReflections">Accept reflected solutions.</param>
    /// <returns>A new PatternPuzzle instance.</returns>
    public static PatternPuzzle Create(
        string targetPattern,
        int gridWidth,
        int gridHeight,
        IEnumerable<string> elements,
        bool showTarget = true,
        int displayDuration = 0,
        bool acceptRotations = false,
        bool acceptReflections = false)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(targetPattern);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(gridWidth);
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(gridHeight);

        return new PatternPuzzle
        {
            TargetPattern = targetPattern,
            GridWidth = gridWidth,
            GridHeight = gridHeight,
            PatternElements = elements.ToList(),
            ShowTargetPattern = showTarget,
            PatternDisplayDuration = Math.Max(0, displayDuration),
            AcceptRotations = acceptRotations,
            AcceptReflections = acceptReflections
        };
    }

    /// <summary>
    /// Validates if the input pattern matches the target.
    /// </summary>
    /// <param name="inputPattern">The player's pattern input.</param>
    /// <returns>True if the pattern matches.</returns>
    public bool Validate(string inputPattern)
    {
        if (inputPattern == TargetPattern)
            return true;

        if (AcceptRotations)
        {
            var rotations = GetRotations(TargetPattern);
            if (rotations.Contains(inputPattern))
                return true;
        }

        if (AcceptReflections)
        {
            var reflections = GetReflections(TargetPattern);
            if (reflections.Contains(inputPattern))
                return true;

            // Also check reflections of rotations if both are enabled
            if (AcceptRotations)
            {
                var rotations = GetRotations(TargetPattern);
                foreach (var rotation in rotations)
                {
                    var rotatedReflections = GetReflections(rotation);
                    if (rotatedReflections.Contains(inputPattern))
                        return true;
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Renders the target pattern as a display grid.
    /// </summary>
    /// <returns>ASCII representation of the pattern grid.</returns>
    public string RenderGrid()
    {
        return RenderPatternAsGrid(TargetPattern);
    }

    /// <summary>
    /// Renders an input pattern as a display grid.
    /// </summary>
    /// <param name="pattern">The pattern to render.</param>
    /// <returns>ASCII representation of the pattern.</returns>
    public string RenderPatternAsGrid(string pattern)
    {
        var lines = new List<string>();

        // Top border
        lines.Add("  " + string.Concat(Enumerable.Repeat("\u2550\u2550\u2550\u2566", GridWidth - 1)) + "\u2550\u2550\u2550\u2557");
        lines[0] = "  \u2554" + lines[0].Substring(2);

        for (int y = 0; y < GridHeight; y++)
        {
            var row = "  \u2551";
            for (int x = 0; x < GridWidth; x++)
            {
                var index = y * GridWidth + x;
                var symbol = index < pattern.Length ? pattern[index].ToString() : " ";
                row += $" {symbol} \u2551";
            }
            lines.Add(row);

            // Row separator (except for last row)
            if (y < GridHeight - 1)
            {
                var separator = "  \u2560" + string.Concat(Enumerable.Repeat("\u2550\u2550\u2550\u256C", GridWidth - 1)) + "\u2550\u2550\u2550\u2563";
                lines.Add(separator);
            }
        }

        // Bottom border
        lines.Add("  \u255A" + string.Concat(Enumerable.Repeat("\u2550\u2550\u2550\u2569", GridWidth - 1)) + "\u2550\u2550\u2550\u255D");

        return string.Join(Environment.NewLine, lines);
    }

    /// <summary>
    /// Validates that input contains only valid pattern elements.
    /// </summary>
    /// <param name="input">The input to validate.</param>
    /// <returns>True if all characters are valid elements.</returns>
    public bool IsValidInput(string input)
    {
        var validChars = PatternElements.SelectMany(e => e.ToCharArray()).ToHashSet();
        return input.All(c => validChars.Contains(c));
    }

    private List<string> GetRotations(string pattern)
    {
        var rotations = new List<string>();

        // Convert to 2D array for rotation
        var grid = PatternToGrid(pattern);

        // 90 degrees
        var rotated90 = RotateGrid90(grid);
        rotations.Add(GridToPattern(rotated90));

        // 180 degrees
        var rotated180 = RotateGrid90(rotated90);
        rotations.Add(GridToPattern(rotated180));

        // 270 degrees
        var rotated270 = RotateGrid90(rotated180);
        rotations.Add(GridToPattern(rotated270));

        return rotations;
    }

    private List<string> GetReflections(string pattern)
    {
        var reflections = new List<string>();

        var grid = PatternToGrid(pattern);

        // Horizontal reflection
        var horizontalReflection = ReflectGridHorizontal(grid);
        reflections.Add(GridToPattern(horizontalReflection));

        // Vertical reflection
        var verticalReflection = ReflectGridVertical(grid);
        reflections.Add(GridToPattern(verticalReflection));

        return reflections;
    }

    private char[,] PatternToGrid(string pattern)
    {
        var grid = new char[GridHeight, GridWidth];
        for (int i = 0; i < pattern.Length && i < GridWidth * GridHeight; i++)
        {
            grid[i / GridWidth, i % GridWidth] = pattern[i];
        }
        return grid;
    }

    private string GridToPattern(char[,] grid)
    {
        var height = grid.GetLength(0);
        var width = grid.GetLength(1);
        var chars = new char[height * width];
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                chars[y * width + x] = grid[y, x];
            }
        }
        return new string(chars);
    }

    private char[,] RotateGrid90(char[,] grid)
    {
        var height = grid.GetLength(0);
        var width = grid.GetLength(1);
        var rotated = new char[width, height];
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                rotated[x, height - 1 - y] = grid[y, x];
            }
        }
        return rotated;
    }

    private char[,] ReflectGridHorizontal(char[,] grid)
    {
        var height = grid.GetLength(0);
        var width = grid.GetLength(1);
        var reflected = new char[height, width];
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                reflected[y, width - 1 - x] = grid[y, x];
            }
        }
        return reflected;
    }

    private char[,] ReflectGridVertical(char[,] grid)
    {
        var height = grid.GetLength(0);
        var width = grid.GetLength(1);
        var reflected = new char[height, width];
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                reflected[height - 1 - y, x] = grid[y, x];
            }
        }
        return reflected;
    }
}
```

---

## 7. Puzzle Entity Updates

### 7.1 Modifications

**File:** `src/Core/RuneAndRust.Domain/Entities/Puzzle.cs` (modifications)

```
MODIFY: Puzzle
├── ADD: SequenceData: SequencePuzzle?
├── ADD: CombinationData: CombinationPuzzle?
├── ADD: PatternData: PatternPuzzle?
├── ADD: SetSequenceData(SequencePuzzle): void
├── ADD: SetCombinationData(CombinationPuzzle): void
└── ADD: SetPatternData(PatternPuzzle): void
```

### 7.2 Implementation

```csharp
// Add to Puzzle.cs

/// <summary>
/// Gets the sequence puzzle configuration (for Sequence type puzzles).
/// </summary>
public SequencePuzzle? SequenceData { get; private set; }

/// <summary>
/// Gets the combination puzzle configuration (for Combination type puzzles).
/// </summary>
public CombinationPuzzle? CombinationData { get; private set; }

/// <summary>
/// Gets the pattern puzzle configuration (for Pattern type puzzles).
/// </summary>
public PatternPuzzle? PatternData { get; private set; }

/// <summary>
/// Sets the sequence data for a Sequence type puzzle.
/// </summary>
/// <param name="sequenceData">The sequence configuration.</param>
/// <exception cref="InvalidOperationException">If puzzle type is not Sequence.</exception>
public void SetSequenceData(SequencePuzzle sequenceData)
{
    if (Type != PuzzleType.Sequence)
        throw new InvalidOperationException($"Cannot set sequence data on {Type} puzzle.");

    SequenceData = sequenceData ?? throw new ArgumentNullException(nameof(sequenceData));
}

/// <summary>
/// Sets the combination data for a Combination type puzzle.
/// </summary>
/// <param name="combinationData">The combination configuration.</param>
/// <exception cref="InvalidOperationException">If puzzle type is not Combination.</exception>
public void SetCombinationData(CombinationPuzzle combinationData)
{
    if (Type != PuzzleType.Combination)
        throw new InvalidOperationException($"Cannot set combination data on {Type} puzzle.");

    CombinationData = combinationData ?? throw new ArgumentNullException(nameof(combinationData));
}

/// <summary>
/// Sets the pattern data for a Pattern type puzzle.
/// </summary>
/// <param name="patternData">The pattern configuration.</param>
/// <exception cref="InvalidOperationException">If puzzle type is not Pattern.</exception>
public void SetPatternData(PatternPuzzle patternData)
{
    if (Type != PuzzleType.Pattern)
        throw new InvalidOperationException($"Cannot set pattern data on {Type} puzzle.");

    PatternData = patternData ?? throw new ArgumentNullException(nameof(patternData));
}
```

---

## 8. PuzzleService Updates

### 8.1 New Methods

**File:** `src/Core/RuneAndRust.Application/Services/PuzzleService.cs` (modifications)

```
MODIFY: PuzzleService
├── UPDATE: AttemptSolve() - delegate to type-specific validation
├── ADD: ValidateSequenceStep(puzzle, attempt, stepId): PuzzleStepResult
├── ADD: ValidateCombination(puzzle, input): PuzzleSolveResult
├── ADD: ValidatePattern(puzzle, input): PuzzleSolveResult
└── ADD: GetSequenceProgress(puzzle, attempt): SequenceProgress
```

### 8.2 Implementation

```csharp
// Updates to PuzzleService.cs

/// <inheritdoc />
public PuzzleSolveResult AttemptSolve(Player player, Puzzle puzzle, string input)
{
    if (!puzzle.IsSolvable)
    {
        return PuzzleSolveResult.NotSolvable(puzzle);
    }

    // Delegate to type-specific validation
    return puzzle.Type switch
    {
        PuzzleType.Combination => ValidateCombination(puzzle, input),
        PuzzleType.Pattern => ValidatePattern(puzzle, input),
        _ => ValidateGeneric(puzzle, input)
    };
}

/// <summary>
/// Validates a sequence puzzle step.
/// </summary>
/// <param name="puzzle">The sequence puzzle.</param>
/// <param name="attempt">The current attempt.</param>
/// <param name="stepId">The step being activated.</param>
/// <returns>Result of the step validation.</returns>
public PuzzleStepResult ValidateSequenceStep(Puzzle puzzle, PuzzleAttempt attempt, string stepId)
{
    if (puzzle.Type != PuzzleType.Sequence || puzzle.SequenceData == null)
    {
        _logger.LogWarning("ValidateSequenceStep called on non-sequence puzzle {PuzzleId}", puzzle.Id);
        return PuzzleStepResult.WrongStep(puzzle, stepId, false);
    }

    var sequenceData = puzzle.SequenceData;

    if (sequenceData.IsCorrectNextStep(attempt.CompletedSteps, stepId))
    {
        attempt.AddStep(stepId);
        var remaining = sequenceData.GetRemainingSteps(attempt.CompletedSteps);

        if (sequenceData.IsComplete(attempt.CompletedSteps))
        {
            puzzle.Solve();
            attempt.Complete(true);
            _logger.LogInformation("Puzzle {PuzzleId} solved via sequence completion", puzzle.Id);

            return PuzzleStepResult.SequenceCompleted(puzzle, stepId);
        }

        _logger.LogDebug("Sequence step {StepId} correct for puzzle {PuzzleId}, {Remaining} steps remaining",
            stepId, puzzle.Id, remaining);

        return PuzzleStepResult.CorrectStep(puzzle, stepId, remaining);
    }
    else
    {
        // Wrong step
        var shouldReset = sequenceData.ResetOnWrongStep;

        if (shouldReset)
        {
            attempt.Reset();
            _logger.LogDebug("Sequence reset for puzzle {PuzzleId} due to wrong step {StepId}",
                puzzle.Id, stepId);
        }

        return PuzzleStepResult.WrongStep(puzzle, stepId, shouldReset);
    }
}

/// <summary>
/// Validates a combination puzzle input.
/// </summary>
/// <param name="puzzle">The combination puzzle.</param>
/// <param name="input">The player's input.</param>
/// <returns>Result of the validation.</returns>
public PuzzleSolveResult ValidateCombination(Puzzle puzzle, string input)
{
    if (puzzle.Type != PuzzleType.Combination || puzzle.CombinationData == null)
    {
        _logger.LogWarning("ValidateCombination called on non-combination puzzle {PuzzleId}", puzzle.Id);
        return PuzzleSolveResult.NotSolvable(puzzle);
    }

    var combinationData = puzzle.CombinationData;

    // Validate input characters
    if (!combinationData.IsValidInput(input))
    {
        _logger.LogDebug("Invalid input characters for combination puzzle {PuzzleId}", puzzle.Id);
        return PuzzleSolveResult.Incorrect(puzzle, GetRemainingAttempts(puzzle),
            "Invalid characters in input.");
    }

    if (combinationData.Validate(input))
    {
        puzzle.Solve();
        _logger.LogInformation("Combination puzzle {PuzzleId} solved", puzzle.Id);
        return PuzzleSolveResult.Success(puzzle);
    }
    else
    {
        puzzle.RecordFailedAttempt();

        if (puzzle.IsFailed)
        {
            _logger.LogInformation("Combination puzzle {PuzzleId} failed - max attempts reached", puzzle.Id);
            return PuzzleSolveResult.Failure(puzzle);
        }

        var remaining = GetRemainingAttempts(puzzle);
        var feedback = combinationData.GetFeedback(input);
        var message = combinationData.ShowPartialFeedback
            ? $"Incorrect. {feedback.CorrectPositions} correct position(s), {feedback.CorrectCharacters} correct character(s) in wrong position."
            : "Incorrect solution.";

        _logger.LogDebug("Combination attempt failed for puzzle {PuzzleId}, {Remaining} attempts remaining",
            puzzle.Id, remaining);

        return PuzzleSolveResult.Incorrect(puzzle, remaining, message);
    }
}

/// <summary>
/// Validates a pattern puzzle input.
/// </summary>
/// <param name="puzzle">The pattern puzzle.</param>
/// <param name="input">The player's pattern input.</param>
/// <returns>Result of the validation.</returns>
public PuzzleSolveResult ValidatePattern(Puzzle puzzle, string input)
{
    if (puzzle.Type != PuzzleType.Pattern || puzzle.PatternData == null)
    {
        _logger.LogWarning("ValidatePattern called on non-pattern puzzle {PuzzleId}", puzzle.Id);
        return PuzzleSolveResult.NotSolvable(puzzle);
    }

    var patternData = puzzle.PatternData;

    // Validate input elements
    if (!patternData.IsValidInput(input))
    {
        _logger.LogDebug("Invalid pattern elements for puzzle {PuzzleId}", puzzle.Id);
        return PuzzleSolveResult.Incorrect(puzzle, GetRemainingAttempts(puzzle),
            "Invalid pattern elements.");
    }

    if (patternData.Validate(input))
    {
        puzzle.Solve();
        _logger.LogInformation("Pattern puzzle {PuzzleId} solved", puzzle.Id);
        return PuzzleSolveResult.Success(puzzle);
    }
    else
    {
        puzzle.RecordFailedAttempt();

        if (puzzle.IsFailed)
        {
            _logger.LogInformation("Pattern puzzle {PuzzleId} failed - max attempts reached", puzzle.Id);
            return PuzzleSolveResult.Failure(puzzle);
        }

        var remaining = GetRemainingAttempts(puzzle);
        _logger.LogDebug("Pattern attempt failed for puzzle {PuzzleId}, {Remaining} attempts remaining",
            puzzle.Id, remaining);

        return PuzzleSolveResult.Incorrect(puzzle, remaining, "Pattern does not match.");
    }
}

/// <summary>
/// Gets the progress for a sequence puzzle.
/// </summary>
/// <param name="puzzle">The sequence puzzle.</param>
/// <param name="attempt">The current attempt.</param>
/// <returns>Progress information.</returns>
public SequenceProgress GetSequenceProgress(Puzzle puzzle, PuzzleAttempt attempt)
{
    if (puzzle.Type != PuzzleType.Sequence || puzzle.SequenceData == null)
    {
        return new SequenceProgress
        {
            TotalSteps = 0,
            CompletedSteps = 0,
            StepsRemaining = 0
        };
    }

    var sequenceData = puzzle.SequenceData;
    return new SequenceProgress
    {
        TotalSteps = sequenceData.RequiredSequence.Count,
        CompletedSteps = attempt.CompletedSteps.Count,
        StepsRemaining = sequenceData.GetRemainingSteps(attempt.CompletedSteps)
    };
}

private PuzzleSolveResult ValidateGeneric(Puzzle puzzle, string input)
{
    // Generic validation for Logic type or unimplemented types
    // This is a placeholder - actual logic puzzles may need custom validation
    _logger.LogDebug("Generic validation for puzzle {PuzzleId}", puzzle.Id);

    puzzle.RecordFailedAttempt();

    if (puzzle.IsFailed)
    {
        return PuzzleSolveResult.Failure(puzzle);
    }

    return PuzzleSolveResult.Incorrect(puzzle, GetRemainingAttempts(puzzle));
}

private int GetRemainingAttempts(Puzzle puzzle)
{
    if (puzzle.MaxAttempts < 0)
        return -1;

    return Math.Max(0, puzzle.MaxAttempts - puzzle.AttemptCount);
}
```

### 8.3 SequenceProgress Record

```csharp
/// <summary>
/// Progress information for a sequence puzzle.
/// </summary>
public readonly record struct SequenceProgress
{
    /// <summary>Total steps in the sequence.</summary>
    public int TotalSteps { get; init; }

    /// <summary>Number of steps completed.</summary>
    public int CompletedSteps { get; init; }

    /// <summary>Number of steps remaining.</summary>
    public int StepsRemaining { get; init; }

    /// <summary>Progress percentage (0-100).</summary>
    public int ProgressPercent => TotalSteps > 0 ? (CompletedSteps * 100) / TotalSteps : 0;
}
```

---

## 9. User-Facing Commands

### 9.1 Command Overview

| Command | Description | Puzzle Type |
|---------|-------------|-------------|
| `activate <object>` | Activate sequence step | Sequence |
| `input <code>` | Enter combination code | Combination |
| `pattern <input>` | Submit pattern answer | Pattern |
| `examine <puzzle>` | View puzzle details (updated) | All |

### 9.2 Sequence Puzzle Interaction

```
> examine elemental altar

Elemental Altar Puzzle
======================
Four symbols glow around the altar's edge: Fire, Water,
Earth, and Air. They must be activated in the correct
order to unlock the altar's secret.

Type: Sequence
Status: In Progress
Progress: ██░░░░░░ 1/4 steps complete
Difficulty: ★★★☆☆

---

> activate fire symbol

The fire symbol blazes brightly!
[Step 1/4 correct]

---

> activate earth symbol

The earth symbol glows with a warm light.
[Step 2/4 correct]

---

> activate air symbol

The air symbol flickers... then goes dark.
[Wrong step! Sequence reset.]

Progress: ░░░░░░░░ 0/4 steps

---

> activate fire symbol

The fire symbol blazes brightly!
[Step 1/4 correct]

> activate water symbol

The water symbol shimmers.
[Step 2/4 correct]

> activate earth symbol

The earth symbol glows with a warm light.
[Step 3/4 correct]

> activate air symbol

The air symbol swirls with energy!
[Step 4/4 correct]

[PUZZLE SOLVED!]
The altar rumbles and reveals a hidden compartment!
```

### 9.3 Combination Puzzle Interaction

```
> examine vault lock

Vault Lock
==========
A complex lock with four rotating dials, each marked
with numbers 0-9. The correct combination will open
the vault.

Type: Combination
Status: Unsolved
Attempts: 0/3 remaining
Difficulty: ★★☆☆☆

---

> input 1234

You enter: 1-2-3-4

The lock clicks but doesn't open.
[Feedback: 1 correct position, 2 correct digits]

[Attempts: 2/3 remaining]

---

> input 4321

You enter: 4-3-2-1

The lock clicks but doesn't open.
[Feedback: 0 correct positions, 4 correct digits]

[Attempts: 1/3 remaining]

---

> input 4231

You enter: 4-2-3-1

*CLICK*

[PUZZLE SOLVED!]
The vault lock clicks open!
```

### 9.4 Pattern Puzzle Interaction

```
> examine mirror puzzle

Mirror Puzzle
=============
A grid of adjustable mirrors that must be aligned to
direct light beams to the correct positions.

Target Pattern:
  ╔═══╦═══╦═══╗
  ║ / ║ \ ║ / ║
  ╠═══╬═══╬═══╣
  ║ \ ║ / ║ \ ║
  ╠═══╬═══╬═══╣
  ║ / ║ / ║ \ ║
  ╚═══╩═══╩═══╝

Type: Pattern
Status: Unsolved
Difficulty: ★★★★☆

---

> pattern /\/\//\/

You adjust the mirrors...

  ╔═══╦═══╦═══╗
  ║ / ║ \ ║ / ║
  ╠═══╬═══╬═══╣
  ║ \ ║ / ║ / ║
  ╠═══╬═══╬═══╣
  ║ \ ║ / ║ / ║
  ╚═══╩═══╩═══╝

The light beams don't align correctly.
[Pattern does not match]

---

> pattern /\\/\/\/\

You adjust the mirrors...

  ╔═══╦═══╦═══╗
  ║ / ║ \ ║ / ║
  ╠═══╬═══╬═══╣
  ║ \ ║ / ║ \ ║
  ╠═══╬═══╬═══╣
  ║ / ║ / ║ \ ║
  ╚═══╩═══╩═══╝

[PUZZLE SOLVED!]
The light beams converge on the central crystal,
which glows brilliantly!
```

---

## 10. Data Model Changes

### 10.1 Summary

| Type | Layer | Name | Description |
|------|-------|------|-------------|
| Value Object | Domain | `SequencePuzzle` | Ordered step puzzle configuration |
| Value Object | Domain | `CombinationPuzzle` | Code/combination puzzle configuration |
| Value Object | Domain | `PatternPuzzle` | Pattern matching puzzle configuration |
| Record Struct | Domain | `CombinationFeedback` | Partial feedback for combinations |
| Record Struct | Application | `SequenceProgress` | Sequence puzzle progress info |
| Entity Update | Domain | `Puzzle` | Add type-specific data properties |
| Service Update | Application | `PuzzleService` | Add type-specific validation methods |

### 10.2 File Locations

| File | Path |
|------|------|
| `SequencePuzzle.cs` | `src/Core/RuneAndRust.Domain/ValueObjects/` |
| `CombinationPuzzle.cs` | `src/Core/RuneAndRust.Domain/ValueObjects/` |
| `PatternPuzzle.cs` | `src/Core/RuneAndRust.Domain/ValueObjects/` |
| `Puzzle.cs` (update) | `src/Core/RuneAndRust.Domain/Entities/` |
| `PuzzleService.cs` (update) | `src/Core/RuneAndRust.Application/Services/` |
| `IPuzzleService.cs` (update) | `src/Core/RuneAndRust.Application/Interfaces/` |

---

## 11. Configuration File Schemas

### 11.1 Updated Puzzles Configuration

**File:** `config/puzzles.json` (additions)

```json
{
  "$schema": "../schemas/puzzles.schema.json",
  "puzzles": [
    {
      "id": "altar-elements",
      "name": "Elemental Altar",
      "description": "Four symbols glow around the altar's edge: Fire, Water, Earth, and Air. They must be activated in the correct order.",
      "type": "Sequence",
      "difficulty": 3,
      "maxAttempts": -1,
      "canReset": true,
      "hasHints": true,
      "sequenceData": {
        "requiredSequence": ["fire", "water", "earth", "air"],
        "stepDescriptions": {
          "fire": "The fire symbol blazes brightly!",
          "water": "The water symbol shimmers.",
          "earth": "The earth symbol glows with a warm light.",
          "air": "The air symbol swirls with energy!"
        },
        "resetOnWrongStep": true,
        "requiresConsecutiveSteps": false,
        "maxTurnsBetweenSteps": 0,
        "stepObjectIds": {
          "fire": "obj-fire-symbol",
          "water": "obj-water-symbol",
          "earth": "obj-earth-symbol",
          "air": "obj-air-symbol"
        }
      }
    },
    {
      "id": "vault-code",
      "name": "Vault Lock",
      "description": "A complex lock with four rotating dials, each marked with numbers 0-9.",
      "type": "Combination",
      "difficulty": 2,
      "maxAttempts": 3,
      "canReset": true,
      "resetDelay": 5,
      "hasHints": true,
      "combinationData": {
        "solution": "4231",
        "validCharacters": "0123456789",
        "caseSensitive": false,
        "showPartialFeedback": true,
        "separator": "-"
      }
    },
    {
      "id": "mirror-grid",
      "name": "Mirror Puzzle",
      "description": "A grid of adjustable mirrors that must be aligned to direct light beams.",
      "type": "Pattern",
      "difficulty": 4,
      "maxAttempts": -1,
      "canReset": true,
      "patternData": {
        "targetPattern": "/\\/\\/\\/\\",
        "gridWidth": 3,
        "gridHeight": 3,
        "elements": ["/", "\\"],
        "showTargetPattern": true,
        "patternDisplayDuration": 0,
        "acceptRotations": false,
        "acceptReflections": false
      }
    },
    {
      "id": "memory-tiles",
      "name": "Memory Tiles",
      "description": "A grid of tiles that briefly shows a pattern before hiding it.",
      "type": "Pattern",
      "difficulty": 3,
      "maxAttempts": 3,
      "canReset": true,
      "resetDelay": 10,
      "patternData": {
        "targetPattern": "XOXXOOXO",
        "gridWidth": 3,
        "gridHeight": 3,
        "elements": ["X", "O", " "],
        "showTargetPattern": true,
        "patternDisplayDuration": 2,
        "acceptRotations": false,
        "acceptReflections": false
      }
    },
    {
      "id": "word-lock",
      "name": "Word Lock",
      "description": "A lock that requires a four-letter word to open.",
      "type": "Combination",
      "difficulty": 3,
      "maxAttempts": 5,
      "canReset": true,
      "resetDelay": -1,
      "combinationData": {
        "solution": "FIRE",
        "validCharacters": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        "caseSensitive": false,
        "showPartialFeedback": false,
        "alternateSolutions": ["BLAZE", "FLAME"]
      }
    }
  ]
}
```

### 11.2 Updated JSON Schema

**File:** `config/schemas/puzzles.schema.json` (additions to $defs)

```json
{
  "$defs": {
    "puzzleDefinition": {
      "properties": {
        "sequenceData": {
          "$ref": "#/$defs/sequenceData"
        },
        "combinationData": {
          "$ref": "#/$defs/combinationData"
        },
        "patternData": {
          "$ref": "#/$defs/patternData"
        }
      }
    },
    "sequenceData": {
      "type": "object",
      "description": "Configuration for sequence puzzles",
      "properties": {
        "requiredSequence": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Ordered list of step IDs"
        },
        "stepDescriptions": {
          "type": "object",
          "additionalProperties": { "type": "string" },
          "description": "Feedback message per step"
        },
        "resetOnWrongStep": {
          "type": "boolean",
          "default": true,
          "description": "Reset progress on wrong step"
        },
        "requiresConsecutiveSteps": {
          "type": "boolean",
          "default": false,
          "description": "Steps must be consecutive"
        },
        "maxTurnsBetweenSteps": {
          "type": "integer",
          "default": 0,
          "description": "Max turns between steps (0 = unlimited)"
        },
        "stepObjectIds": {
          "type": "object",
          "additionalProperties": { "type": "string" },
          "description": "Map of step IDs to object IDs"
        }
      },
      "required": ["requiredSequence"]
    },
    "combinationData": {
      "type": "object",
      "description": "Configuration for combination puzzles",
      "properties": {
        "solution": {
          "type": "string",
          "description": "The correct combination"
        },
        "validCharacters": {
          "type": "string",
          "default": "0123456789",
          "description": "Valid input characters"
        },
        "caseSensitive": {
          "type": "boolean",
          "default": false,
          "description": "Case-sensitive matching"
        },
        "showPartialFeedback": {
          "type": "boolean",
          "default": false,
          "description": "Show correct positions hint"
        },
        "separator": {
          "type": "string",
          "description": "Separator for display"
        },
        "alternateSolutions": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Additional valid solutions"
        }
      },
      "required": ["solution"]
    },
    "patternData": {
      "type": "object",
      "description": "Configuration for pattern puzzles",
      "properties": {
        "targetPattern": {
          "type": "string",
          "description": "The pattern to match"
        },
        "gridWidth": {
          "type": "integer",
          "minimum": 1,
          "description": "Grid width"
        },
        "gridHeight": {
          "type": "integer",
          "minimum": 1,
          "description": "Grid height"
        },
        "elements": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Valid pattern elements"
        },
        "showTargetPattern": {
          "type": "boolean",
          "default": true,
          "description": "Show target before solving"
        },
        "patternDisplayDuration": {
          "type": "integer",
          "default": 0,
          "description": "Turns to show pattern (0 = always)"
        },
        "acceptRotations": {
          "type": "boolean",
          "default": false,
          "description": "Accept rotated solutions"
        },
        "acceptReflections": {
          "type": "boolean",
          "default": false,
          "description": "Accept reflected solutions"
        }
      },
      "required": ["targetPattern", "gridWidth", "gridHeight", "elements"]
    }
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `PuzzleService` | Information | Sequence completed, combination solved, pattern solved |
| `PuzzleService` | Debug | Step validated, sequence reset, combination attempt, pattern attempt |
| `PuzzleService` | Warning | Wrong puzzle type for operation, invalid input |
| `PuzzleService` | Error | Type data missing for puzzle |

### 12.2 Log Message Examples

```csharp
// Information level
_logger.LogInformation("Puzzle {PuzzleId} solved via sequence completion", puzzle.Id);
_logger.LogInformation("Combination puzzle {PuzzleId} solved", puzzle.Id);
_logger.LogInformation("Pattern puzzle {PuzzleId} solved", puzzle.Id);

// Debug level
_logger.LogDebug("Sequence step {StepId} correct for puzzle {PuzzleId}, {Remaining} steps remaining",
    stepId, puzzle.Id, remaining);
_logger.LogDebug("Sequence reset for puzzle {PuzzleId} due to wrong step {StepId}",
    puzzle.Id, stepId);
_logger.LogDebug("Combination attempt failed for puzzle {PuzzleId}, {Remaining} attempts remaining",
    puzzle.Id, remaining);
_logger.LogDebug("Pattern attempt failed for puzzle {PuzzleId}, {Remaining} attempts remaining",
    puzzle.Id, remaining);
_logger.LogDebug("Invalid input characters for combination puzzle {PuzzleId}", puzzle.Id);

// Warning level
_logger.LogWarning("ValidateSequenceStep called on non-sequence puzzle {PuzzleId}", puzzle.Id);
_logger.LogWarning("ValidateCombination called on non-combination puzzle {PuzzleId}", puzzle.Id);
_logger.LogWarning("ValidatePattern called on non-pattern puzzle {PuzzleId}", puzzle.Id);
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| SequencePuzzle | ~10 |
| CombinationPuzzle | ~8 |
| PatternPuzzle | ~6 |
| Puzzle Entity Updates | ~3 |
| PuzzleService Type Validation | ~3 |
| **Total** | **~30** |

### 13.2 Test Categories

#### SequencePuzzle Tests
- Create with valid sequence
- Create with empty sequence throws
- IsCorrectNextStep validates order
- IsCorrectNextStep returns false for wrong step
- IsComplete validates full sequence
- IsComplete returns false for partial
- GetRemainingSteps calculates correctly
- GetStepDescription returns configured text
- GetStepDescription returns default for unknown
- GetStepIdForObject maps correctly

#### CombinationPuzzle Tests
- Create with valid solution
- Create with empty solution throws
- Validate returns true for correct
- Validate returns true for alternate solution
- Validate returns false for wrong
- CaseSensitive matching works
- GetFeedback calculates correct positions
- GetFeedback calculates correct characters
- IsValidInput validates characters
- FormatForDisplay adds separators

#### PatternPuzzle Tests
- Create with valid pattern
- Create with invalid dimensions throws
- Validate returns true for exact match
- Validate accepts rotations when enabled
- Validate accepts reflections when enabled
- IsValidInput validates elements
- RenderGrid produces correct output

#### Puzzle Entity Update Tests
- SetSequenceData assigns data
- SetSequenceData throws for wrong type
- SetCombinationData throws for wrong type

#### PuzzleService Tests
- ValidateSequenceStep validates correct step
- ValidateCombination validates input
- ValidatePattern validates pattern

---

## 14. Use Cases

### UC-001: Player Examines Sequence Puzzle
**Actor:** Player
**Flow:** Enter room → Examine puzzle → See sequence description → View progress bar

### UC-002: Player Activates Correct Sequence Step
**Actor:** Player
**Flow:** Activate object → Service validates step → Progress updated → Show success feedback

### UC-003: Player Activates Wrong Sequence Step
**Actor:** Player
**Flow:** Activate wrong object → Service detects error → Reset progress (if configured) → Show error feedback

### UC-004: Player Completes Sequence Puzzle
**Actor:** Player
**Flow:** Activate final step → Sequence complete → Puzzle solved → Effects triggered

### UC-005: Player Enters Combination Code
**Actor:** Player
**Flow:** Use `input` command → Service validates → Show feedback → Update attempts

### UC-006: Player Solves Combination Puzzle
**Actor:** Player
**Flow:** Enter correct code → Validation passes → Puzzle solved → Effects triggered

### UC-007: Player Gets Partial Combination Feedback
**Actor:** Player
**Flow:** Enter wrong code → Service calculates feedback → Show correct positions/characters

### UC-008: Player Submits Pattern Input
**Actor:** Player
**Flow:** Use `pattern` command → Service validates → Compare to target → Show result

### UC-009: Player Views Pattern Target
**Actor:** Player
**Flow:** Examine pattern puzzle → ShowTargetPattern enabled → Render grid display

### UC-010: Pattern Accepts Rotation
**Actor:** Player
**Flow:** Submit rotated pattern → AcceptRotations enabled → Validation passes → Solved

---

## 15. Deliverable Checklist

### Domain Layer
- [ ] `SequencePuzzle.cs` value object created
- [ ] `CombinationPuzzle.cs` value object created
- [ ] `CombinationFeedback` record struct created
- [ ] `PatternPuzzle.cs` value object created
- [ ] `Puzzle.cs` updated with type-specific data properties

### Application Layer
- [ ] `PuzzleService.cs` updated with type-specific validation
- [ ] `IPuzzleService.cs` updated with new method signatures
- [ ] `SequenceProgress` record struct created

### Commands
- [ ] `input` command implemented for combinations
- [ ] `pattern` command implemented for patterns
- [ ] `activate` integration with sequence puzzles

### Configuration
- [ ] `puzzles.json` updated with type-specific examples
- [ ] `puzzles.schema.json` updated with type definitions

### Testing
- [ ] ~30 unit tests implemented
- [ ] All tests passing

---

## 16. Acceptance Criteria

### Functional
- [ ] SequencePuzzle tracks ordered step requirements
- [ ] Sequence validates correct step order
- [ ] Wrong sequence steps reset progress (configurable)
- [ ] CombinationPuzzle validates code input
- [ ] Combination feedback shows correct positions (optional)
- [ ] `input` command handles combination entry
- [ ] PatternPuzzle validates pattern matching
- [ ] Pattern display renders in TUI
- [ ] `activate` integration works for sequence steps
- [ ] Puzzle type-specific data stored correctly
- [ ] Rotations and reflections accepted when configured

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~30 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete for all public members
- [ ] All type-specific validation logged appropriately

---

## 17. Dependencies

### 17.1 Prerequisites

| Version | Component | Usage |
|---------|-----------|-------|
| v0.4.2a | Puzzle entity | Base puzzle infrastructure |
| v0.4.2a | PuzzleState enum | State management |
| v0.4.2a | PuzzleType enum | Type classification |
| v0.4.2a | PuzzleAttempt | Progress tracking |
| v0.4.2a | IPuzzleService | Service interface |
| v0.4.2a | PuzzleService | Base service implementation |
| v0.4.0a | InteractiveObject | Sequence step objects |
| v0.4.0c | `activate` command | Sequence step triggers |

### 17.2 Provides For

| Version | Component | Usage |
|---------|-----------|-------|
| v0.4.2c | Riddle puzzles | Riddle validation pattern |
| v0.4.2c | Multi-part puzzles | Component validation |
| v0.4.2c | Hint system | Type-specific hints |
| v0.4.2c | Puzzle rewards | Type-aware rewards |

---

## 18. Future Considerations

### 18.1 Deferred to v0.4.2c
- **Riddle Puzzle Type**: Text-based riddle validation
- **Hint System**: Progressive hints per puzzle type
- **Multi-part Puzzles**: Puzzles spanning multiple rooms
- **Puzzle Rewards**: Full reward system integration
- **`answer` command**: Riddle response interface

### 18.2 Out of Scope
- Timed puzzle challenges
- Procedurally generated puzzles
- Sound/audio pattern puzzles
- Multiplayer puzzle coordination
- Puzzle difficulty scaling based on player stats

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: Claude*
