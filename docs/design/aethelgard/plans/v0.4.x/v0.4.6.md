# v0.4.6: Runic Inscription (Runeforging & Item Properties)

> **Status:** Planned
> **Milestone:** 5.0 - The Saga & The Weaver
> **Theme:** Crafting Depth, Item Customization, Magic-Tech Integration

---

## Table of Contents
- [Overview](#overview)
- [Phase A: The Rune](#phase-a-the-rune)
- [Phase B: The Anvil](#phase-b-the-anvil)
- [Phase C: The Scribe](#phase-c-the-scribe)
- [Phase D: The Power](#phase-d-the-power)
- [Testing Strategy](#testing-strategy)
- [Changelog](#changelog-v045---runic-inscription)

---

## Overview

Milestone v0.4.5 ("Runic Inscription") fleshes out the Runeforging trade, which was introduced as a stub in v0.3.1. While v0.3.1 allowed basic crafting checks, this version implements the full depth of the system: creating "Rune" items, applying "ItemProperties" to existing equipment (embossing/enchanting), and managing the specific risks (Corruption) associated with this trade.

Runeforging in Domain 4 is not high fantasy magic; it is "The Art of Inscription," treating circuit patterns and code fragments as ritualistic runes. It involves physically carving or burning these patterns onto "Iron-Husks" (weapons/armor) to channel "Aetheric Energy."

To manage the complexity, this version is split into 4 sub-versions:

| Phase | Codename | Focus |
|-------|----------|-------|
| A | The Rune | Define `RuneItem` entities and expand `ItemProperty` definitions. |
| B | The Anvil | Implement the `RuneforgingService` for combining Runes with Equipment. |
| C | The Scribe | TUI updates for the Runeforging screen, selecting target items and runes. |
| D | The Power | Integration of `ItemProperty` effects into Combat and Stat calculations. |

---

## Phase A: The Rune (Data Definitions)

**Goal:** Create the concrete data structures for Runes as items and define the library of available Runes.

### 1. Architecture & Data Flow

**Components:**
- **RuneItem (Core):** A specific subclass of `Item` representing a physical rune stone/chip.
- **RuneDefinition (Core):** Static data defining what a specific Rune does (e.g., "Algiz" -> +2 Soak).
- **ItemProperty (Core):** Existing class, expanded to support complex effects beyond simple stats (e.g., "OnHit" triggers).

**Key Concepts:**
- **Rune Item:** The physical object (e.g., "Etched Stone of Uruz"). It takes up inventory space.
- **Inscription:** The process of consuming a Rune Item to permanently add its `ItemProperty` to a weapon or armor.
- **Slots:** Equipment has a limit on how many Runes it can hold (usually 1 or 2 based on Quality).

### 2. Logic Decision Trees

#### A. Property Definition Structure
**Concept:** `EffectScript` parsing.
Instead of hardcoding every effect, we use a simple script syntax for the `ItemProperty`.
- `Stat:Might:1` -> Adds 1 Might.
- `Trigger:OnHit:Damage:Fire:1d4` -> On Hit, deal 1d4 Fire damage.
- `Trigger:OnDefend:Status:Thorns:1` -> On Defend, apply Thorns.

### 3. Code Implementation

#### A. RuneItem Class
**File:** `RuneAndRust.Core/Entities/RuneItem.cs`

```csharp
public class RuneItem : Item
{
    // The specific property this rune bestows when inscribed
    public ItemProperty GrantedProperty { get; set; } = new();

    // Minimum item quality required to accept this rune
    public QualityTier MinimumQuality { get; set; } = QualityTier.Standard;

    public RuneItem()
    {
        ItemType = ItemType.Rune; // Need to add this enum value if missing
        IsStackable = true;
        MaxStackSize = 10;
    }
}
```

#### B. ItemProperty Expansion
**File:** `RuneAndRust.Core/Entities/ItemProperty.cs`

```csharp
public class ItemProperty
{
    // ... existing properties (Id, Name, Description, StatModifiers) ...

    // e.g., OnHit, OnBlock, Passive
    public PropertyTrigger Trigger { get; set; }

    // e.g., "ApplyStatus:Bleed:1", "RestoreHealth:5", "Damage:Fire:2"
    public string EffectScript { get; set; } = string.Empty;
}

public enum PropertyTrigger
{
    Passive,    // Always active (Stats)
    OnHit,      // When user hits enemy
    OnDefend,   // When user is hit
    OnKill,     // When user kills enemy
    OnUse       // Active ability (maybe later)
}
```

### 4. Deliverable Checklist

- [ ] Core: Create `RuneItem` entity.
- [ ] Core: Add `Rune` to `ItemType` enum.
- [ ] Core: Update `ItemProperty` with `Trigger` and `EffectScript`.
- [ ] Data: Create seed data for initial Runes:
  - **Fehu (Wealth/Power):** +1 Resource Gain.
  - **Uruz (Strength):** +1 Might (Passive).
  - **Thurisaz (Thorn):** OnDefend: 1 Dmg to attacker.
  - **Ansuz (Wisdom):** +1 Wits (Passive).
  - **Raidho (Journey):** -10% Travel Fatigue (Passive).
  - **Kenaz (Torch):** +1 Light Radius (Passive).
- [ ] Data: Create recipes to craft these `RuneItem`s (Trade: Runeforging).

---

## Phase B: The Anvil (Runeforging Logic)

**Goal:** Implement the logic for the Runeforging process: validation, cost consumption, risk calculation, and application.

### 1. Architecture & Data Flow

**Components:**
- **RuneforgingService (Engine):** Logic for the inscription process.
- **CraftingService (Engine):** Orchestrates the general roll.
- **RuneSlots:** Logic to determine max slots based on Item Quality.

### 2. Logic Decision Trees

#### A. Inscription Process
**Input:** `Character`, `Equipment` (Target), `RuneItem` (Source)

1. **Validation:**
   - Is `Target` actually Equipment? If no -> Fail.
   - Is `Source` a Rune? If no -> Fail.
   - Does `Target` have free slots?
     - `Count(Properties) < GetMaxSlots(Target.Quality)`.
     - If no -> Fail ("Item is fully inscribed").
   - Is `Target.Quality >= Source.MinimumQuality`? If no -> Fail ("Item quality too low to hold this power").
   - Does `Target` already have this specific Property? (Prevent stacking identical runes if desired).
     - Let's allow stacking stats, but maybe limit unique effects. For v0.4.5, **allow stacking**.

2. **Execution (The Roll):**
   - Roll `WITS` + `Runeforging Skill` (if exists) or just `WITS`.
   - DC = `10 + (RuneTier * 2)`.
   - **Success:**
     - Remove `RuneItem` from Inventory.
     - Add `Source.GrantedProperty` to `Target.Properties`.
     - Log Success.
   - **Failure:**
     - Remove `RuneItem` (Wasted).
     - `Target` takes 10% Durability damage.
     - Log Failure ("The rune crumbles").
   - **Catastrophe (Crit Fail):**
     - Remove `RuneItem`.
     - `Target` becomes "Cursed" or takes massive damage.
     - Player takes **Corruption** (Runeforging risk).

### 3. Code Implementation

#### A. RuneforgingService
**File:** `RuneAndRust.Engine/Services/RuneforgingService.cs`

```csharp
public class RuneforgingService : IRuneforgingService
{
    private readonly IDiceService _dice;

    public Result Inscribe(Character character, Equipment target, RuneItem rune)
    {
        // 1. Validate Slots
        int maxSlots = GetMaxSlots(target.Quality);
        if (target.Properties.Count >= maxSlots)
            return Result.Failure($"Item '{target.Name}' has no free rune slots ({target.Properties.Count}/{maxSlots}).");

        // 2. Validate Quality
        if (target.Quality < rune.MinimumQuality)
            return Result.Failure($"Item quality is too low. Requires {rune.MinimumQuality}.");

        // 3. Roll
        var roll = _dice.RollAttribute(character, AttributeType.Wits); // Simplified
        int dc = 12; // Base DC

        if (roll.Successes >= 1) // Simple success check
        {
            // Apply
            var prop = rune.GrantedProperty; // Clone this if needed to ensure unique ID
            target.Properties.Add(prop);

            // Consume Rune (Caller handles inventory removal? Or Service?)
            // Service should handle if passed Inventory reference, but here we act on models.
            // Caller (Controller) removes rune upon Success.

            return Result.Success($"Successfully inscribed {rune.Name} onto {target.Name}.");
        }
        else
        {
             // Handle Failure
             return Result.Failure("The inscription failed and the rune shattered.");
        }
    }

    private int GetMaxSlots(QualityTier quality) => quality switch
    {
        QualityTier.Scavenged => 0,
        QualityTier.Standard => 1,
        QualityTier.Reinforced => 2,
        QualityTier.Masterwork => 3,
        QualityTier.Artifact => 4,
        _ => 0
    };
}
```

### 4. Deliverable Checklist

- [ ] Engine: Implement `IRuneforgingService` interface.
- [ ] Engine: Implement `RuneforgingService` with `Inscribe` method.
- [ ] Engine: Implement `GetMaxSlots` logic.
- [ ] Engine: Add Corruption/Trauma hooks on Catastrophe (requires `ITraumaService`).
- [ ] Tests: Unit tests for Slot limits, Quality requirements, and Success/Fail outcomes.

---

## Phase C: The Scribe (UI Integration)

**Goal:** Update the Crafting UI to support the specific workflow of Runeforging (Select Item -> Select Rune).

### 1. Architecture & Data Flow

**Components:**
- **CraftingController:** Needs a new mode for "Inscription".
- **CraftingView:** Needs to render the Inscription UI.

**UX Flow:**
1. **Crafting Menu:** Tabs [Bodging] [Alchemy] [Runeforging] [Medicine].
2. **Runeforging Tab:**
   - **Action:** [Forge Rune] (List of Recipes)
   - **Action:** [Inscribe Gear] (New Flow)
3. **Inscribe Flow:**
   - **Select Target:** List `Equipment` in Inventory.
     - Show: Name, Quality, Slots `[X][ ]`.
     - Filter: Only items with `MaxSlots > 0`.
   - **Select Rune:** List `RuneItem`s in Inventory.
     - Show: Name, Effect, MinQuality.
   - **Preview:** "Inscribing [Rune] onto [Sword]. Chance: High. Risk: Corruption."
   - **Confirm:** Execute.

### 2. Code Implementation

#### A. CraftingController
**File:** `RuneAndRust.Terminal/Controllers/CraftingController.cs`

Update `HandleInput` to support sub-menus.

#### B. CraftingView
**File:** `RuneAndRust.Terminal/Views/CraftingView.cs`

Add `RenderInscriptionTargetSelection` and `RenderInscriptionRuneSelection` methods using `Spectre.Console`.

```csharp
public void RenderInscriptionTargetSelection(List<Equipment> equipment)
{
    var table = new Table().Title("Select Item to Inscribe");
    table.AddColumns("Name", "Quality", "Slots", "Current Runes");

    foreach(var item in equipment)
    {
        string slots = DrawSlots(item);
        table.AddRow(item.Name, item.Quality.ToString(), slots, string.Join(", ", item.Properties.Select(p => p.Name)));
    }
    // ...
}
```

### 3. Deliverable Checklist

- [ ] Terminal: Update `CraftingState` to include `InscriptionTargetSelection` and `InscriptionRuneSelection`.
- [ ] Terminal: Update `CraftingView` to render the Inscription workflow.
- [ ] Terminal: Add visual indicators for "Slots" (e.g., `\u25cf` for filled, `\u25cb` for empty).
- [ ] Terminal: Connect the "Inscribe" action to `RuneforgingService.Inscribe`.

---

## Phase D: The Power (Effect Integration)

**Goal:** Ensure that the properties added to items actually do something in the game (Combat, Stats).

### 1. Architecture & Data Flow

**Touchpoints:**
- **StatCalculationService:** Must iterate over equipped items -> properties -> stat modifiers.
- **CombatService:** Must check for "OnHit" / "OnDefend" triggers in item properties.

### 2. Logic Decision Trees

#### A. Stat Calculation
**Process:** `Recalculate(Character)`
1. Reset Derived Stats (MaxHP, etc) to base.
2. Apply Attribute Modifiers.
3. Iterate Equipment:
   - For each `ItemProperty` in `EquippedItem.Properties`:
     - If `Trigger == Passive`:
       - `Stat = Property.StatModifiers[StatName]`.
       - Add `Stat` to `Character.DerivedStats`.

#### B. Combat Triggers
**Process:** `ResolveAttack(Attacker, Defender)`
1. **OnHit:**
   - Iterate `Attacker.Weapon.Properties`.
   - If `Prop.Trigger == OnHit`:
     - Parse `Prop.EffectScript`.
     - Apply Effect (e.g., `Damage:Fire:2` -> `Defender.TakeDamage(2, Fire)`).
2. **OnDefend:**
   - Iterate `Defender.Armor.Properties`.
   - If `Prop.Trigger == OnDefend`:
     - Parse `Prop.EffectScript`.
     - Apply Effect (e.g., `Thorns` -> `Attacker.TakeDamage(1)`).

### 3. Code Implementation

#### A. StatCalculationService
**File:** `RuneAndRust.Engine/Services/StatCalculationService.cs`

```csharp
// In Recalculate(Character char)
foreach (var item in char.Equipment.Values)
{
    foreach (var prop in item.Properties)
    {
        if (prop.Trigger == PropertyTrigger.Passive)
        {
            ApplyModifiers(char, prop.StatModifiers);
        }
    }
}
```

#### B. CombatService
**File:** `RuneAndRust.Engine/Services/CombatService.cs`

```csharp
// Helper method
private void ProcessTriggers(Character source, Character target, PropertyTrigger triggerType)
{
    var equipment = source is Player p ? p.Equipment.Values : Enumerable.Empty<Equipment>(); // Simplify

    foreach (var item in equipment)
    {
        foreach (var prop in item.Properties.Where(p => p.Trigger == triggerType))
        {
            _effectService.ApplyScript(prop.EffectScript, source, target);
        }
    }
}
```

### 4. Deliverable Checklist

- [ ] Engine: Update `StatCalculationService` to include Item Property stats.
- [ ] Engine: Update `CombatService` to call `ProcessTriggers` at appropriate steps (Start of Turn, On Hit, On Defend).
- [ ] Engine: Implement `EffectService` or helper to parse `EffectScript` strings.
- [ ] Engine: Implement basic effects: `Damage`, `Heal`, `Status`.

---

## Testing Strategy

### Unit Tests
| Test Class | Focus | Key Scenarios |
|------------|-------|---------------|
| `RuneforgingServiceTests` | Logic | Validate slot limits, successful inscription, property addition. |
| `StatCalculationServiceTests` | Stats | Equip item with Rune -> Verify player stats increase. |
| `EffectParserTests` | Scripts | Verify "Damage:Fire:2" parses correctly. |

### Integration Tests
| Scenario | Components | Validation |
|----------|------------|------------|
| **The Enchanter** | `RuneforgingService`, `Inventory` | Craft Rune -> Inscribe Sword -> Check Sword has Property. |
| **The Warrior** | `CombatService` | Attack with Fire Rune Sword -> Verify extra damage/burn effect. |
| **The Cursed** | `RuneforgingService` | Force Catastrophe -> Verify Corruption gain. |

---

## Changelog: v0.4.5 - Runic Inscription

**Release Date:** 2025-XX-XX

### Summary
v0.4.5 expands the Runeforging trade from a simple recipe list into a deep equipment customization system. Players can now craft specific Runes and inscribe them onto their gear to unlock powerful stat boosts and combat effects.

### Features
- **Rune Items:** New item type representing magical inscriptions.
- **Inscription System:** Ability to emboss Runes onto weapons and armor.
- **Rune Slots:** Equipment quality now dictates how many runes it can hold.
- **Magical Properties:** Items can now have dynamic stats and on-hit effects.

### Technical
- Implemented `RuneItem` and expanded `ItemProperty`.
- Added `RuneforgingService` for inscription logic.
- Updated `StatCalculationService` to stack item property modifiers.
- Updated `CombatService` to trigger property effects.