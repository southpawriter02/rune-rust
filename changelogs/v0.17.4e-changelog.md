# Changelog: v0.17.4e - Specialization Application Service

**Release Date:** 2026-01-30
**Phase:** Specialization System (5/5)
**Status:** Complete

---

## Overview

Implements the `ISpecializationApplicationService` interface and `SpecializationApplicationService` that orchestrates applying specializations to characters during character creation Step 5 and managing ability tier unlocks during progression. The service validates archetype compatibility, deducts Progression Points, registers specializations on the Player entity, initializes special resources, grants Tier 1 abilities automatically, and tracks Heretical path Corruption warnings. Two result value objects (`SpecializationApplicationResult` and `TierUnlockResult`) capture operation outcomes with factory methods following the established sealed class pattern.

This phase builds on v0.17.4a-d (enums, definitions, ability tiers, provider) to complete the Specialization System, enabling the character creation workflow in v0.17.5.

**Service Method Summary:**

| Method | Purpose | Returns |
| --- | --- | --- |
| `ApplySpecialization` | Applies specialization during creation, grants Tier 1 abilities | `SpecializationApplicationResult` |
| `UnlockTier` | Unlocks Tier 2 or Tier 3 during progression | `TierUnlockResult` |
| `CanApplySpecialization` | Validates preconditions for specialization application | `(bool, string?)` |
| `CanUnlockTier` | Validates preconditions for tier unlock | `(bool, string?)` |
| `GetAvailableSpecializations` | Lists specializations for player's archetype | `IReadOnlyList<SpecializationDefinition>` |
| `GetNextSpecializationCost` | Returns PP cost for next specialization | `int` |

---

## Added

### Application Layer

#### Interfaces

- **`ISpecializationApplicationService`** (`Interfaces/ISpecializationApplicationService.cs`)
    - `public interface` with 6 methods:
        - `ApplySpecialization(Player, SpecializationId)` → `SpecializationApplicationResult`: Full specialization application with Tier 1 abilities
        - `UnlockTier(Player, SpecializationId, int)` → `TierUnlockResult`: Tier 2/3 unlock during progression
        - `CanApplySpecialization(Player, SpecializationId)` → `(bool CanApply, string? Reason)`: 4-check validation
        - `CanUnlockTier(Player, SpecializationId, int)` → `(bool CanUnlock, string? Reason)`: 5-check validation
        - `GetAvailableSpecializations(Player)` → `IReadOnlyList<SpecializationDefinition>`: Archetype-filtered list
        - `GetNextSpecializationCost(Player)` → `int`: 0 for first, 3 for additional
    - Also contains `SpecializationValidationResult` readonly record struct with `IsValid`, `Issues`, and factory methods `Valid`/`Invalid`
    - Also contains `SpecializationApplicationPreview` readonly record struct with 9 properties (SpecializationId, DisplayName, PathType, Tagline, SpecialResourceSummary, Tier1Abilities, TotalAbilityCount, IsHeretical, HereticalWarning)
    - Comprehensive XML documentation with `<summary>`, `<param>`, `<returns>`, `<remarks>`, `<example>`, `<seealso>`

#### Value Objects

- **`SpecializationApplicationResult`** (`ValueObjects/SpecializationApplicationResult.cs`)
    - `public sealed class` with private constructor + factory methods
    - Properties (9): `Success`, `AppliedSpecializationId` (SpecializationId?), `AppliedDefinition` (SpecializationDefinition?), `GrantedAbilities` (IReadOnlyList\<SpecializationAbility>), `SpecialResourceInitialized` (bool), `IsHeretical` (bool), `CorruptionWarning` (string?), `PpCost` (int), `FailureReason` (string?)
    - Factory methods (5): `Succeeded(definition, abilities, resourceInit, ppCost)`, `Failed(reason)`, `AlreadyHasSpecialization(id)`, `CharacterRequired` (static property), `ArchetypeMismatch(required, actual)`
    - Display methods (2): `GetSummary()`, `GetGrantedAbilitiesList()`
    - Pattern matches `ArchetypeApplicationResult` sealed class convention

- **`TierUnlockResult`** (`ValueObjects/TierUnlockResult.cs`)
    - `public sealed class` with private constructor + factory methods
    - Properties (5): `Success`, `UnlockedTier` (SpecializationAbilityTier?), `GrantedAbilities` (IReadOnlyList\<SpecializationAbility>), `PpCost` (int), `FailureReason` (string?)
    - Factory methods (2): `Succeeded(tier)`, `Failed(reason)`
    - Display methods (1): `GetSummary()`

#### Services

- **`SpecializationApplicationService`** (`Services/SpecializationApplicationService.cs`)
    - `public sealed class SpecializationApplicationService : ISpecializationApplicationService`
    - Constructor: `(ISpecializationProvider provider, ILogger<SpecializationApplicationService> logger)` with null checks
    - Constant: `AdditionalSpecializationCost = 3`
    - **ApplySpecialization** — 7-step orchestration:
        1. Log entry with specialization ID and character details
        2. Validate via CanApplySpecialization
        3. Retrieve definition from provider
        4. Calculate and deduct PP cost via Player.SpendProgressionPoints
        5. Register specialization via Player.AddSpecialization
        6. Initialize special resource if definition.HasSpecialResource
        7. Grant Tier 1 abilities via GrantTierAbilities helper
    - **UnlockTier** — 5-step orchestration with ArgumentOutOfRangeException for tier < 2 or > 3
    - **CanApplySpecialization** — 4 checks: definition exists, archetype matches, no duplicate, sufficient PP
    - **CanUnlockTier** — 5 checks: has specialization, definition exists, tier exists, not already unlocked, delegates to tier.CanUnlock()
    - **GetAvailableSpecializations** — Delegates to provider.GetByArchetype(player.Archetype)
    - **GetNextSpecializationCost** — Returns 0 if SpecializationCount == 0, else 3
    - Private helpers: `GrantTierAbilities()`, `InitializeSpecialResource()`
    - Section separators: `═══════` pattern matching codebase convention
    - Comprehensive XML documentation with cross-references
    - Exhaustive structured logging at Debug/Information/Warning levels

### Unit Tests

- **`SpecializationApplicationResultTests`** (`ValueObjects/SpecializationApplicationResultTests.cs`) — 10 test methods
    - `Succeeded_WithDefinition_SetsAllProperties`
    - `Succeeded_WithHereticalSpec_SetsCorruptionWarning`
    - `Succeeded_WithCoherentSpec_NoCorruptionWarning`
    - `Failed_SetsFailureReasonAndFalseSuccess`
    - `AlreadyHasSpecialization_SetsExpectedMessage`
    - `CharacterRequired_SetsExpectedMessage`
    - `ArchetypeMismatch_SetsExpectedMessage`
    - `GetSummary_Success_ContainsSpecializationDetails`
    - `GetSummary_Failure_ContainsFailureReason`
    - `GetGrantedAbilitiesList_ReturnsFormattedAbilityNames`

- **`TierUnlockResultTests`** (`ValueObjects/TierUnlockResultTests.cs`) — 8 test methods
    - `Succeeded_WithTier_SetsAllProperties`
    - `Succeeded_GrantedAbilities_MatchesTierAbilities`
    - `Succeeded_PpCost_MatchesTierUnlockCost`
    - `Failed_SetsFailureReasonAndFalseSuccess`
    - `Failed_HasEmptyGrantedAbilities`
    - `Failed_HasZeroPpCost`
    - `GetSummary_Success_ContainsTierDetails`
    - `GetSummary_Failure_ContainsFailureReason`

- **`SpecializationApplicationServiceTests`** (`Services/SpecializationApplicationServiceTests.cs`) — 30 test methods
    - **Constructor Tests (2):**
        - `Constructor_NullProvider_ThrowsArgumentNullException`
        - `Constructor_NullLogger_ThrowsArgumentNullException`
    - **ApplySpecialization Tests (10):**
        - `ApplySpecialization_FirstSpecialization_AppliesForFree`
        - `ApplySpecialization_Berserkr_GrantsTier1Abilities`
        - `ApplySpecialization_Berserkr_InitializesRageResource`
        - `ApplySpecialization_HereticalSpec_ReturnsCorruptionWarning`
        - `ApplySpecialization_CoherentSpec_NoCorruptionWarning`
        - `ApplySpecialization_SpecWithoutResource_SucceedsWithoutResourceInit`
        - `ApplySpecialization_WrongArchetype_Fails`
        - `ApplySpecialization_NullCharacter_Fails`
        - `ApplySpecialization_UnknownSpecialization_Fails`
        - `ApplySpecialization_AdditionalSpecialization_Costs3PP`
    - **UnlockTier Tests (8):**
        - `UnlockTier_Tier2WithPrerequisites_Succeeds`
        - `UnlockTier_Tier3WithPrerequisites_Succeeds`
        - `UnlockTier_MissingPreviousTier_Fails`
        - `UnlockTier_InsufficientPP_Fails`
        - `UnlockTier_InsufficientRank_Fails`
        - `UnlockTier_AlreadyUnlocked_Fails`
        - `UnlockTier_InvalidTierNumber_ThrowsArgumentOutOfRange`
        - `UnlockTier_NoSpecialization_Fails`
    - **Validation Tests (5):**
        - `CanApplySpecialization_ValidScenario_ReturnsTrue`
        - `CanApplySpecialization_WrongArchetype_ReturnsFalse`
        - `CanApplySpecialization_AlreadyHasSpec_ReturnsFalse`
        - `CanUnlockTier_ValidScenario_ReturnsTrue`
        - `CanUnlockTier_MissingPrerequisite_ReturnsFalse`
    - **Cost & Utility Tests (5):**
        - `GetAvailableSpecializations_ReturnsArchetypeSpecializations`
        - `GetNextSpecializationCost_FirstSpec_ReturnsZero`
        - `GetNextSpecializationCost_AdditionalSpec_ReturnsThree`
        - `GetNextSpecializationCost_MultipleSpecs_ReturnsThree`
        - `GetAvailableSpecializations_NullPlayer_ThrowsArgumentNullException`

### Glossary

- **`config/glossary.json`** — Added 3 glossary entries
    - `specialization-application-service`: Service for applying specializations and managing tier unlocks (sortOrder: 46)
    - `specialization-application-result`: Result value object for specialization application outcomes (sortOrder: 47)
    - `tier-unlock-result`: Result value object for tier unlock outcomes (sortOrder: 48)

---

## Changed

### Domain Layer

- **`Player.cs`** — Added Specialization Management section
    - New properties: `ProgressionPoints` (int), `ProgressionRank` (int, default 1), `SpecializationCount` (computed), `Archetype` (computed Archetype? parsed from ArchetypeId)
    - New private field: `_specializations` (`Dictionary<SpecializationId, HashSet<int>>`) tracking specialization → unlocked tier numbers
    - New methods (8): `AddSpecialization`, `HasSpecialization`, `SpendProgressionPoints`, `HasUnlockedTier`, `UnlockSpecializationTier`, `GrantAbility` (wrapper around AddAbility), `InitializeSpecialResource` (wrapper around InitializeResource), `SetProgressionPoints`, `SetProgressionRank`
    - Full XML documentation on all new members

### Infrastructure Layer

- **`DependencyInjection.cs`** — Added scoped registration for ISpecializationApplicationService
    - `services.AddScoped<ISpecializationApplicationService, SpecializationApplicationService>()`
    - Follows established pattern from IArchetypeApplicationService registration

### Documentation

- **`docs/design/v0.17.x/v0.17.4-scope-breakdown.md`** — Checked off v0.17.4e unit test items
    - `[x] First specialization is free`
    - `[x] Additional specializations cost 3 PP`

- **`docs/design/v0.17.x/v0.17.x-overview.md`** — Checked off v0.17.4 acceptance criteria
    - `[x] First specialization is free`
    - `[x] Specialization grants Tier 1 abilities (3 abilities)`
    - `[x] Path type (Coherent/Heretical) is tracked`

---

## Design Decisions

### Service in Application/Services (Not Infrastructure/Services)

The `SpecializationApplicationService` is placed in `Application/Services`, matching the `ArchetypeApplicationService` location. Application services that orchestrate domain operations belong in the Application layer. This differs from providers (which are in Infrastructure/Services) because providers handle external data loading while application services contain business logic.

### Sealed Class Results (Not Readonly Record Structs)

The design specification suggests `readonly record struct` for result types. However, the established pattern (`ArchetypeApplicationResult`) uses `sealed class` with private constructor and factory methods. This was followed for:
- Consistent pattern across all application result types
- Support for nullable reference properties
- Private constructor enforcement via factory methods
- Display method support (`GetSummary()`, `GetGrantedAbilitiesList()`)

### Player Entity Stub Methods

The design specification references Player methods (`AddSpecialization`, `HasSpecialization`, `SpendProgressionPoints`, etc.) that did not exist. Stub methods were added directly to `Player.cs` in a new `SPECIALIZATION MANAGEMENT` section. This follows the existing pattern where lineage (`SetLineage`), background (`SetBackground`), and archetype (`SetClass`) are all tracked directly on the Player entity.

### Computed Archetype Property

The Player entity stores `ArchetypeId` as a string (set via `SetClass(string, string)`), but the service needs to compare typed `Archetype` enum values. A computed `Archetype` property was added that uses `Enum.TryParse<Archetype>(ArchetypeId, ignoreCase: true, out var archetype)` to bridge the gap. Returns `null` if the ArchetypeId string cannot be parsed to a valid Archetype enum value.

### Validation + Preview Types in Interface File

The `SpecializationValidationResult` and `SpecializationApplicationPreview` readonly record structs are defined in the interface file (`ISpecializationApplicationService.cs`), matching the established pattern from `IArchetypeApplicationService.cs` which includes `ArchetypeValidationResult` and `ArchetypeApplicationPreview`.

### Unified ApplySpecialization Method

The design specification defines separate `ApplyFirstSpecialization` and `UnlockSpecialization` methods. These were unified into a single `ApplySpecialization` method that handles both cases based on `Player.SpecializationCount`. This simplifies the API while maintaining the PP cost logic (0 for first, 3 for additional).

### Comprehensive Test Coverage

The design specification estimates ~2 tests. 48 test methods were implemented across 3 test files for comprehensive coverage matching the established codebase test density. Tests verify both result value objects (factory methods, properties, display methods) and the full service (constructor validation, apply success/failure, tier unlock success/failure, validation methods, cost calculations).

---

## Dependencies

### Prerequisites

| Type | Phase | Usage |
| --- | --- | --- |
| `SpecializationId` | v0.17.4a | Enum key for specialization identification |
| `SpecializationPathType` | v0.17.4a | Path type classification (Coherent/Heretical) |
| `SpecializationDefinition` | v0.17.4b | Domain entity applied to characters |
| `SpecialResourceDefinition` | v0.17.4b | Value object for special resource initialization |
| `SpecializationAbilityTier` | v0.17.4c | Value object containing tier abilities and unlock requirements |
| `SpecializationAbility` | v0.17.4c | Value object for individual abilities granted to players |
| `ISpecializationProvider` | v0.17.4d | Data access for specialization definitions |
| `Archetype` | v0.17.3a | Archetype enum for compatibility validation |
| `Player` | Domain | Entity receiving specializations, abilities, and resources |

### Provides to Future Phases

| Type | Phase | Usage |
| --- | --- | --- |
| `ISpecializationApplicationService` | v0.17.5 | Character creation Step 5 (Specialization Selection) |
| `ApplySpecialization()` | v0.17.5 | Apply player's chosen specialization during creation |
| `UnlockTier()` | Progression | Unlock Tier 2/3 abilities using PP during gameplay |
| `GetAvailableSpecializations()` | v0.17.5 | Populate specialization selection UI |
| `GetNextSpecializationCost()` | v0.17.5 | Display PP cost in creation/progression UI |
| `SpecializationApplicationResult` | v0.17.5 | Display application outcome to player |
| `TierUnlockResult` | Progression | Display tier unlock outcome to player |
| Player specialization stubs | v0.17.5+ | Track specializations, tiers, PP on player entity |

---

## Logging Strategy

| Level | When |
|---|---|
| Information | ApplySpecialization success with full details (specialization name, path type, ability count, resource init, PP cost, Heretical warning) |
| Information | UnlockTier success with tier details and granted abilities |
| Debug | Method entry/exit for all 6 public methods with parameter values |
| Debug | Individual validation check results in CanApplySpecialization and CanUnlockTier |
| Debug | PP cost calculation, ability granting steps, resource initialization |
| Warning | CanApplySpecialization failure reasons (wrong archetype, duplicate, insufficient PP) |
| Warning | CanUnlockTier failure reasons (missing specialization, missing tier, already unlocked, prerequisites not met) |
| Warning | Heretical specialization applied — Corruption risk notification |

All public interface methods log at Debug level on entry with parameter values. Validation failures log at Warning level. Successful operations log at Information level with complete outcome details.

---

## Files Created

| Path | Description |
|---|---|
| `src/Core/RuneAndRust.Application/Interfaces/ISpecializationApplicationService.cs` | Interface with 6 methods + validation and preview types |
| `src/Core/RuneAndRust.Application/ValueObjects/SpecializationApplicationResult.cs` | Sealed result class with 5 factory methods and 2 display methods |
| `src/Core/RuneAndRust.Application/ValueObjects/TierUnlockResult.cs` | Sealed result class with 2 factory methods and 1 display method |
| `src/Core/RuneAndRust.Application/Services/SpecializationApplicationService.cs` | Service implementation with 6 public methods and 2 private helpers |
| `tests/RuneAndRust.Application.UnitTests/ValueObjects/SpecializationApplicationResultTests.cs` | 10 test methods for result value object |
| `tests/RuneAndRust.Application.UnitTests/ValueObjects/TierUnlockResultTests.cs` | 8 test methods for tier unlock result |
| `tests/RuneAndRust.Application.UnitTests/Services/SpecializationApplicationServiceTests.cs` | 30 test methods for service |
| `changelogs/v0.17.4e-changelog.md` | This changelog |

## Files Modified

| Path | Description |
|---|---|
| `src/Core/RuneAndRust.Domain/Entities/Player.cs` | Added Specialization Management section with 4 properties, 8 methods, 1 field |
| `src/Infrastructure/RuneAndRust.Infrastructure/DependencyInjection.cs` | Added scoped registration for ISpecializationApplicationService |
| `config/glossary.json` | Added 3 glossary entries (sortOrder 46-48) |
| `docs/design/v0.17.x/v0.17.4-scope-breakdown.md` | Checked off v0.17.4e deliverables |
| `docs/design/v0.17.x/v0.17.x-overview.md` | Updated v0.17.4 acceptance criteria checkboxes |

---

## Notes

- Total unit tests for v0.17.4e: 48 test methods across 3 test files (10 + 8 + 30)
- Total test suite after v0.17.4e: 9,885 tests (all passing, 0 regressions)
- Build: 0 errors, 0 warnings
- The design specification estimated ~2 tests; 48 methods were implemented for comprehensive coverage
- v0.17.4e completes the Specialization System (phase 5 of 5); v0.17.5 will integrate this into the character creation workflow
- The Player entity stubs use a `Dictionary<SpecializationId, HashSet<int>>` for tracking specializations and unlocked tiers, supporting O(1) lookups
- The `Archetype` computed property on Player bridges the string-based `ArchetypeId` to the typed `Archetype` enum via `Enum.TryParse`
- `ApplyFirstSpecialization` and `UnlockSpecialization` from the design spec were unified into a single `ApplySpecialization` method that handles PP cost based on `SpecializationCount`
- Service uses `AdditionalSpecializationCost = 3` constant matching the specialization unlock cost from the game design
- All new files have `═══════` section separators matching codebase convention
- All public members have XML documentation with `<summary>`, `<param>`, `<returns>`, `<remarks>`, `<example>`, `<seealso>`
- Exhaustive structured logging at Debug/Information/Warning levels throughout all service methods
