# v0.18.0d Design Specification: StressService Implementation

**Version:** 0.18.0d
**Parent:** v0.18.0 (Psychic Stress System)
**Prerequisites:** v0.18.0a-c Complete (Enums, Results, Interface)
**Status:** Design Complete
**Estimated Unit Tests:** ~8

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [StressService Implementation](#5-stressservice-implementation)
6. [Method Implementations](#6-method-implementations)
7. [Logging Specifications](#7-logging-specifications)
8. [Unit Testing Requirements](#8-unit-testing-requirements)
9. [Use Cases](#9-use-cases)
10. [Deliverable Checklist](#10-deliverable-checklist)
11. [Acceptance Criteria](#11-acceptance-criteria)
12. [Dependencies](#12-dependencies)
13. [Future Considerations](#13-future-considerations)

---

## 1. Executive Summary

This design specification defines the `StressService` class — the core implementation of the `IStressService` interface that manages all stress operations including application, resistance checks, recovery, and trauma reset.

v0.18.0d brings the stress system to life by implementing:

- WILL-based resistance checks using `IDiceService`
- Recovery formulas for all `RestType` values
- Threshold transition detection and logging
- Trauma Check reset logic

### Key Deliverables

| Category                 | Items           |
| ------------------------ | --------------- |
| **Application Services** | `StressService` |
| **Tests**                | ~8 unit tests   |

### Core Mechanics Implemented

| Mechanic             | Formula/Logic                                    |
| -------------------- | ------------------------------------------------ |
| Defense Penalty      | `floor(Stress / 20)`                             |
| Resistance Reduction | 0/1/2-3/4+ successes → 0%/50%/75%/100% reduction |
| Short Rest Recovery  | `WILL × 2`                                       |
| Long Rest Recovery   | `WILL × 5`                                       |
| Sanctuary Recovery   | Full reset to 0                                  |
| Milestone Recovery   | Fixed 25                                         |
| Trauma Reset (Pass)  | Reset to 75                                      |
| Trauma Reset (Fail)  | Reset to 50                                      |

---

## 2. Feature Overview

```
v0.18.0d Features
└── StressService (implements IStressService)
    │
    ├── DEPENDENCIES
    │   ├── ICharacterRepository — Character state access
    │   ├── IDiceService — WILL-based resistance rolls
    │   └── ILogger<StressService> — Structured logging
    │
    ├── QUERY IMPLEMENTATIONS
    │   ├── GetStressState() — Read from character
    │   ├── GetDefensePenalty() — floor(stress/20)
    │   ├── HasSkillDisadvantage() — stress >= 80
    │   └── RequiresTraumaCheck() — stress >= 100
    │
    ├── COMMAND IMPLEMENTATIONS
    │   ├── ApplyStress() — With optional resistance
    │   ├── RecoverStress(RestType) — Formula-based
    │   ├── RecoverStress(amount) — Direct recovery
    │   └── ResetAfterTraumaCheck() — 75 or 50
    │
    └── INTERNAL IMPLEMENTATIONS
        └── PerformResistanceCheck() — WILL vs DC
```

---

## 3. Architecture Diagrams

### 3.1 Class Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        StressService                             │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │  Dependencies:                                                   │   │
│  │  - _characterRepository: ICharacterRepository                   │   │
│  │  - _diceService: IDiceService                                   │   │
│  │  - _logger: ILogger<StressService>                              │   │
│  │                                                                  │   │
│  │  Constants:                                                      │   │
│  │  - TraumaPassResetValue = 75                                    │   │
│  │  - TraumaFailResetValue = 50                                    │   │
│  │  - ShortRestMultiplier = 2                                      │   │
│  │  - LongRestMultiplier = 5                                       │   │
│  │  - MilestoneRecovery = 25                                       │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                                                                  │   │
│  │  IStressService Implementation                                   │   │
│  │  ─────────────────────────────────────────────────────────────   │   │
│  │  + GetStressState(Guid): StressState                            │   │
│  │  + GetDefensePenalty(Guid): int                                 │   │
│  │  + HasSkillDisadvantage(Guid): bool                             │   │
│  │  + RequiresTraumaCheck(Guid): bool                              │   │
│  │  + ApplyStress(Guid, int, StressSource, int): Result            │   │
│  │  + RecoverStress(Guid, RestType): StressRecoveryResult          │   │
│  │  + RecoverStress(Guid, int, string): StressRecoveryResult       │   │
│  │  + ResetAfterTraumaCheck(Guid, bool): void                      │   │
│  │  + PerformResistanceCheck(Guid, int, int): StressCheckResult    │   │
│  │                                                                  │   │
│  │  Private Methods                                                 │   │
│  │  ─────────────────────────────────────────────────────────────   │   │
│  │  - GetCharacter(Guid): Character                                │   │
│  │  - CalculateRecoveryAmount(RestType, int): int                  │   │
│  │  - UpdateCharacterStress(Character, int): void                  │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                               │                                         │
│                               │ Implements                              │
│                               ▼                                         │
│                    ┌─────────────────────┐                             │
│                    │   IStressService    │                             │
│                    └─────────────────────┘                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Dependency Flow

```
                    ┌───────────────────────────────┐
                    │        StressService          │
                    └───────────────┬───────────────┘
                                    │
              ┌─────────────────────┼─────────────────────┐
              │                     │                     │
              ▼                     ▼                     ▼
   ┌────────────────────┐  ┌───────────────┐  ┌──────────────────┐
   │ICharacterRepository│  │  IDiceService │  │ ILogger<Service> │
   ├────────────────────┤  ├───────────────┤  ├──────────────────┤
   │ GetById()          │  │ RollWillCheck │  │ LogDebug         │
   │ Update()           │  │   (will, dc)  │  │ LogInformation   │
   └────────────────────┘  │   → successes │  │ LogWarning       │
                           └───────────────┘  └──────────────────┘
```

### 3.3 ApplyStress Flow

```
    ┌────────────────────────────────────────────────────────────────┐
    │                     ApplyStress Flow                            │
    └────────────────────────────────────────────────────────────────┘

              ApplyStress(characterId, amount, source, resistDc)
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  1. Get Character from Repo   │
                    │     previousStress = char.Stress
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  2. Is resistDc > 0?          │
                    └───────────────┬───────────────┘
                           │                │
                          YES              NO
                           │                │
                           ▼                │
              ┌────────────────────────┐    │
              │ 3a. PerformResistance  │    │
              │     Check              │    │
              │     - Roll WILL vs DC  │    │
              │     - Get successes    │    │
              │     - Calc reduction   │    │
              │     - Calc finalStress │    │
              └───────────┬────────────┘    │
                          │                 │
                          ▼                 ▼
                    ┌───────────────────────────────┐
                    │  4. Calculate New Stress      │
                    │     newStress = prev + final  │
                    │     Clamp(0, 100)             │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  5. Update Character Stress   │
                    │     char.Stress = newStress   │
                    │     repository.Update(char)   │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  6. Log Stress Application    │
                    │     - If ThresholdCrossed     │
                    │     - If TraumaTriggered      │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │  7. Return Result             │
                    │     StressApplicationResult   │
                    └───────────────────────────────┘
```

### 3.4 Resistance Check Decision Tree

```
                    ┌──────────────────────────┐
                    │  PerformResistanceCheck  │
                    │  (characterId, base, dc) │
                    └─────────────┬────────────┘
                                  │
                                  ▼
                    ┌──────────────────────────┐
                    │  Get Character WILL      │
                    │  will = char.Attributes  │
                    │         .Will            │
                    └─────────────┬────────────┘
                                  │
                                  ▼
                    ┌──────────────────────────┐
                    │  Roll Resistance Check   │
                    │  successes = _diceService│
                    │    .RollAttributeCheck   │
                    │    (will, dc)            │
                    └─────────────┬────────────┘
                                  │
          ┌───────────────────────┼───────────────────────┐
          │                       │                       │
          ▼                       ▼                       ▼
   ┌─────────────┐        ┌─────────────┐        ┌─────────────┐
   │ 0 successes │        │ 1 success   │        │ 2+ success  │
   │ reduction=0%│        │reduction=50%│        │reduction=75%│
   │ final=base  │        │ final=base/2│        │ final=base/4│
   └─────────────┘        └─────────────┘        └──────┬──────┘
                                                        │
                                                 ┌──────┴──────┐
                                                 ▼             ▼
                                          ┌───────────┐ ┌───────────┐
                                          │4+ success │ │2-3 success│
                                          │reduction= │ │reduction= │
                                          │   100%    │ │    75%    │
                                          │ final=0   │ │ final=    │
                                          │           │ │  base/4   │
                                          └───────────┘ └───────────┘
```

---

## 4. User Stories

### US-18d-1: Apply Combat Stress with Resistance

**As a** combat system developer
**I want to** apply stress with WILL-based resistance
**So that** characters with high WILL are more resistant to fear

**Acceptance Criteria:**

- Resistance roll uses character's WILL attribute
- Successes reduce incoming stress per table
- Full result with resistance details returned

### US-18d-2: Implementation Logging

**As a** developer debugging stress issues
**I want to** see structured logs for stress operations
**So that** I can trace stress changes through the system

**Acceptance Criteria:**

- All stress changes logged with before/after values
- Threshold crossings logged at Information level
- Trauma triggers logged at Warning level

### US-18d-3: Formula-Based Recovery

**As a** rest system developer
**I want to** recovery stress using WILL-based formulas
**So that** high-WILL characters recover faster

**Acceptance Criteria:**

- Short/Long rest use WILL multiplier
- Sanctuary fully resets stress
- Milestone provides fixed 25 recovery

---

## 5. StressService Implementation

### 5.1 Definition

**File:** `src/Core/RuneAndRust.Application/Services/StressService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service implementation for managing character Psychic Stress.
/// </summary>
/// <remarks>
/// <para>
/// Implements the core stress mechanics including:
/// <list type="bullet">
/// <item>WILL-based resistance checks</item>
/// <item>Formula-based recovery (Short/Long rest, Sanctuary, Milestone)</item>
/// <item>Trauma Check reset logic</item>
/// </list>
/// </para>
/// </remarks>
public class StressService : IStressService
{
    #region Constants

    /// <summary>Stress value after passing a Trauma Check.</summary>
    private const int TraumaPassResetValue = 75;

    /// <summary>Stress value after failing a Trauma Check.</summary>
    private const int TraumaFailResetValue = 50;

    /// <summary>Short Rest recovery multiplier (WILL × 2).</summary>
    private const int ShortRestMultiplier = 2;

    /// <summary>Long Rest recovery multiplier (WILL × 5).</summary>
    private const int LongRestMultiplier = 5;

    /// <summary>Milestone recovery fixed amount.</summary>
    private const int MilestoneRecovery = 25;

    #endregion

    #region Dependencies

    private readonly ICharacterRepository _characterRepository;
    private readonly IDiceService _diceService;
    private readonly ILogger<StressService> _logger;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the <see cref="StressService"/> class.
    /// </summary>
    /// <param name="characterRepository">Repository for character data access.</param>
    /// <param name="diceService">Service for dice rolling mechanics.</param>
    /// <param name="logger">Logger for structured logging.</param>
    public StressService(
        ICharacterRepository characterRepository,
        IDiceService diceService,
        ILogger<StressService> logger)
    {
        _characterRepository = characterRepository ??
            throw new ArgumentNullException(nameof(characterRepository));
        _diceService = diceService ??
            throw new ArgumentNullException(nameof(diceService));
        _logger = logger ??
            throw new ArgumentNullException(nameof(logger));
    }

    #endregion

    #region Query Methods

    /// <inheritdoc/>
    public StressState GetStressState(Guid characterId)
    {
        var character = GetCharacter(characterId);
        var state = StressState.Create(character.PsychicStress);

        _logger.LogDebug(
            "Stress state queried for {CharacterId}: {CurrentStress}/{MaxStress} [{Threshold}]",
            characterId, state.CurrentStress, StressState.MaxStress, state.Threshold);

        return state;
    }

    /// <inheritdoc/>
    public int GetDefensePenalty(Guid characterId)
    {
        var character = GetCharacter(characterId);
        return character.PsychicStress / 20;
    }

    /// <inheritdoc/>
    public bool HasSkillDisadvantage(Guid characterId)
    {
        var character = GetCharacter(characterId);
        return character.PsychicStress >= 80;
    }

    /// <inheritdoc/>
    public bool RequiresTraumaCheck(Guid characterId)
    {
        var character = GetCharacter(characterId);
        return character.PsychicStress >= StressState.MaxStress;
    }

    #endregion

    #region Command Methods

    /// <inheritdoc/>
    public StressApplicationResult ApplyStress(
        Guid characterId,
        int amount,
        StressSource source,
        int resistDc = 0)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(amount);

        var character = GetCharacter(characterId);
        var previousStress = character.PsychicStress;

        // Perform resistance check if DC provided
        StressCheckResult? resistanceResult = null;
        int finalStress = amount;

        if (resistDc > 0)
        {
            resistanceResult = PerformResistanceCheck(characterId, amount, resistDc);
            finalStress = resistanceResult.Value.FinalStress;

            _logger.LogDebug(
                "Resistance check for {CharacterId}: {Successes} successes, " +
                "{ReductionPercent:P0} reduction ({BaseStress} → {FinalStress})",
                characterId,
                resistanceResult.Value.Successes,
                resistanceResult.Value.ReductionPercent,
                amount,
                finalStress);
        }

        // Calculate and clamp new stress
        var newStress = Math.Clamp(
            previousStress + finalStress,
            StressState.MinStress,
            StressState.MaxStress);

        // Update character
        UpdateCharacterStress(character, newStress);

        // Create result
        var result = StressApplicationResult.Create(
            previousStress, newStress, source, resistanceResult);

        // Log application
        _logger.LogInformation(
            "Stress applied to {CharacterId}: +{StressGained} [{Source}] " +
            "({PreviousStress} → {NewStress})",
            characterId, result.StressGained, source, previousStress, newStress);

        // Log threshold crossing
        if (result.ThresholdCrossed)
        {
            _logger.LogInformation(
                "Stress threshold crossed for {CharacterId}: {PreviousThreshold} → {NewThreshold}",
                characterId, result.PreviousThreshold, result.NewThreshold);
        }

        // Log trauma trigger
        if (result.TraumaCheckTriggered)
        {
            _logger.LogWarning(
                "TRAUMA CHECK TRIGGERED for {CharacterId}: Stress at {NewStress}",
                characterId, newStress);
        }

        return result;
    }

    /// <inheritdoc/>
    public StressRecoveryResult RecoverStress(Guid characterId, RestType restType)
    {
        var character = GetCharacter(characterId);
        var previousStress = character.PsychicStress;
        var will = character.Attributes.Will;

        // Calculate recovery amount
        var recoveryAmount = CalculateRecoveryAmount(restType, will);

        // Calculate new stress (minimum 0)
        var newStress = restType == RestType.Sanctuary
            ? StressState.MinStress
            : Math.Max(StressState.MinStress, previousStress - recoveryAmount);

        // Update character
        UpdateCharacterStress(character, newStress);

        // Create result
        var result = StressRecoveryResult.Create(previousStress, newStress, restType);

        // Log recovery
        _logger.LogInformation(
            "Stress recovered for {CharacterId}: -{AmountRecovered} [{RecoverySource}] " +
            "({PreviousStress} → {NewStress})",
            characterId, result.AmountRecovered, restType, previousStress, newStress);

        // Log threshold improvement
        if (result.ThresholdDropped)
        {
            _logger.LogInformation(
                "Stress threshold improved for {CharacterId}: {PreviousThreshold} → {NewThreshold}",
                characterId, result.PreviousThreshold, result.NewThreshold);
        }

        return result;
    }

    /// <inheritdoc/>
    public StressRecoveryResult RecoverStress(Guid characterId, int amount, string source)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(amount);
        ArgumentException.ThrowIfNullOrWhiteSpace(source);

        var character = GetCharacter(characterId);
        var previousStress = character.PsychicStress;

        // Calculate new stress
        var newStress = Math.Max(StressState.MinStress, previousStress - amount);

        // Update character
        UpdateCharacterStress(character, newStress);

        // Create result (use Milestone as placeholder for custom sources)
        var result = StressRecoveryResult.Create(previousStress, newStress, RestType.Milestone);

        // Log recovery with custom source
        _logger.LogInformation(
            "Stress recovered for {CharacterId}: -{AmountRecovered} [{Source}] " +
            "({PreviousStress} → {NewStress})",
            characterId, result.AmountRecovered, source, previousStress, newStress);

        return result;
    }

    /// <inheritdoc/>
    public void ResetAfterTraumaCheck(Guid characterId, bool passed)
    {
        var character = GetCharacter(characterId);
        var previousStress = character.PsychicStress;
        var newStress = passed ? TraumaPassResetValue : TraumaFailResetValue;

        // Update character
        UpdateCharacterStress(character, newStress);

        // Log reset
        _logger.LogInformation(
            "Stress reset after Trauma Check for {CharacterId}: " +
            "{Result} → {NewStress} (was {PreviousStress})",
            characterId,
            passed ? "PASSED" : "FAILED",
            newStress,
            previousStress);
    }

    #endregion

    #region Internal Methods

    /// <inheritdoc/>
    public StressCheckResult PerformResistanceCheck(
        Guid characterId,
        int baseStress,
        int dc)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(baseStress);
        ArgumentOutOfRangeException.ThrowIfNegative(dc);

        var character = GetCharacter(characterId);
        var will = character.Attributes.Will;

        // Roll WILL vs DC
        var rollResult = _diceService.RollAttributeCheck(will, dc);
        var successes = rollResult.NetSuccesses;

        // Create resistance result
        return StressCheckResult.Create(successes, baseStress);
    }

    #endregion

    #region Private Methods

    /// <summary>
    /// Gets a character by ID, throwing if not found.
    /// </summary>
    private Character GetCharacter(Guid characterId)
    {
        var character = _characterRepository.GetById(characterId);

        if (character is null)
        {
            _logger.LogWarning(
                "Character not found: {CharacterId}",
                characterId);
            throw new CharacterNotFoundException(characterId);
        }

        return character;
    }

    /// <summary>
    /// Calculates recovery amount based on rest type and WILL.
    /// </summary>
    private static int CalculateRecoveryAmount(RestType restType, int will) =>
        restType switch
        {
            RestType.Short => will * ShortRestMultiplier,
            RestType.Long => will * LongRestMultiplier,
            RestType.Sanctuary => int.MaxValue, // Full reset handled by caller
            RestType.Milestone => MilestoneRecovery,
            _ => 0
        };

    /// <summary>
    /// Updates character stress and persists the change.
    /// </summary>
    private void UpdateCharacterStress(Character character, int newStress)
    {
        character.SetPsychicStress(newStress);
        _characterRepository.Update(character);
    }

    #endregion
}
```

---

## 6. Method Implementations

### 6.1 Recovery Formula Summary

| RestType  | Formula    | Implementation |
| --------- | ---------- | -------------- |
| Short     | `WILL × 2` | `will * 2`     |
| Long      | `WILL × 5` | `will * 5`     |
| Sanctuary | Full Reset | Set to `0`     |
| Milestone | Fixed 25   | `25`           |

### 6.2 Resistance Reduction Summary

| Successes | Reduction | Implementation |
| --------- | --------- | -------------- |
| 0         | 0%        | `base * 1.00`  |
| 1         | 50%       | `base * 0.50`  |
| 2-3       | 75%       | `base * 0.25`  |
| 4+        | 100%      | `0`            |

### 6.3 Trauma Reset Summary

| Result | New Stress | Constant               |
| ------ | ---------- | ---------------------- |
| Passed | 75         | `TraumaPassResetValue` |
| Failed | 50         | `TraumaFailResetValue` |

---

## 7. Logging Specifications

### 7.1 Log Events

| Event               | Level       | Template                                                                                         |
| ------------------- | ----------- | ------------------------------------------------------------------------------------------------ |
| Stress Queried      | Debug       | `"Stress state queried for {CharacterId}: {CurrentStress}/{MaxStress} [{Threshold}]"`            |
| Resistance Check    | Debug       | `"Resistance check for {CharacterId}: {Successes} successes, {ReductionPercent:P0} reduction"`   |
| Stress Applied      | Information | `"Stress applied to {CharacterId}: +{StressGained} [{Source}] ({PreviousStress} → {NewStress})"` |
| Threshold Crossed   | Information | `"Stress threshold crossed for {CharacterId}: {PreviousThreshold} → {NewThreshold}"`             |
| Trauma Triggered    | Warning     | `"TRAUMA CHECK TRIGGERED for {CharacterId}: Stress at {NewStress}"`                              |
| Stress Recovered    | Information | `"Stress recovered for {CharacterId}: -{AmountRecovered} [{RecoverySource}]"`                    |
| Threshold Improved  | Information | `"Stress threshold improved for {CharacterId}: {PreviousThreshold} → {NewThreshold}"`            |
| Trauma Reset        | Information | `"Stress reset after Trauma Check for {CharacterId}: {Result} → {NewStress}"`                    |
| Character Not Found | Warning     | `"Character not found: {CharacterId}"`                                                           |

### 7.2 Example Log Output

```
[10:30:15 DBG] Stress state queried for a1b2c3d4: 35/100 [Uneasy]
[10:31:22 DBG] Resistance check for a1b2c3d4: 2 successes, 75% reduction (20 → 5)
[10:31:22 INF] Stress applied to a1b2c3d4: +5 [Combat] (35 → 40)
[10:31:22 INF] Stress threshold crossed for a1b2c3d4: Uneasy → Anxious
[10:35:45 WRN] TRAUMA CHECK TRIGGERED for a1b2c3d4: Stress at 100
[10:36:12 INF] Stress reset after Trauma Check for a1b2c3d4: PASSED → 75 (was 100)
[10:40:00 INF] Stress recovered for a1b2c3d4: -20 [Long] (75 → 55)
[10:40:00 INF] Stress threshold improved for a1b2c3d4: Panicked → Anxious
```

---

## 8. Unit Testing Requirements

### 8.1 Test Count by Feature

| Feature                | Test Count |
| ---------------------- | ---------- |
| ApplyStress            | ~3         |
| RecoverStress          | ~3         |
| ResetAfterTraumaCheck  | ~1         |
| PerformResistanceCheck | ~1         |
| **Total**              | **~8**     |

### 8.2 StressServiceTests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/StressServiceTests.cs`

```csharp
namespace RuneAndRust.Application.UnitTests.Services;

using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

[TestFixture]
public class StressServiceTests
{
    private Mock<ICharacterRepository> _mockRepository = null!;
    private Mock<IDiceService> _mockDiceService = null!;
    private Mock<ILogger<StressService>> _mockLogger = null!;
    private StressService _service = null!;
    private Character _testCharacter = null!;
    private Guid _characterId;

    [SetUp]
    public void Setup()
    {
        _mockRepository = new Mock<ICharacterRepository>();
        _mockDiceService = new Mock<IDiceService>();
        _mockLogger = new Mock<ILogger<StressService>>();

        _characterId = Guid.NewGuid();
        _testCharacter = CreateTestCharacter(_characterId, stress: 35, will: 4);

        _mockRepository
            .Setup(r => r.GetById(_characterId))
            .Returns(_testCharacter);

        _service = new StressService(
            _mockRepository.Object,
            _mockDiceService.Object,
            _mockLogger.Object);
    }

    #region ApplyStress Tests

    [Test]
    public void ApplyStress_WithNoResistance_AppliesFullStress()
    {
        // Arrange
        var amount = 20;

        // Act
        var result = _service.ApplyStress(
            _characterId, amount, StressSource.Combat, resistDc: 0);

        // Assert
        result.PreviousStress.Should().Be(35);
        result.NewStress.Should().Be(55);
        result.StressGained.Should().Be(20);
        result.ResistanceResult.Should().BeNull();
    }

    [Test]
    public void ApplyStress_WithResistance_ReducesStress()
    {
        // Arrange
        _mockDiceService
            .Setup(d => d.RollAttributeCheck(It.IsAny<int>(), It.IsAny<int>()))
            .Returns(new DiceRollResult { NetSuccesses = 2 }); // 75% reduction

        // Act
        var result = _service.ApplyStress(
            _characterId, 20, StressSource.Combat, resistDc: 2);

        // Assert
        result.StressGained.Should().Be(5); // 20 * 0.25 = 5
        result.ResistanceResult.Should().NotBeNull();
        result.ResistanceResult!.Value.ReductionPercent.Should().Be(0.75m);
    }

    [Test]
    public void ApplyStress_At100_TriggersTraumaCheck()
    {
        // Arrange
        _testCharacter = CreateTestCharacter(_characterId, stress: 85, will: 4);
        _mockRepository.Setup(r => r.GetById(_characterId)).Returns(_testCharacter);

        // Act
        var result = _service.ApplyStress(
            _characterId, 20, StressSource.Combat, resistDc: 0);

        // Assert
        result.NewStress.Should().Be(100);
        result.TraumaCheckTriggered.Should().BeTrue();
        result.ThresholdCrossed.Should().BeTrue();
    }

    #endregion

    #region RecoverStress Tests

    [Test]
    [TestCase(RestType.Short, 4, 8)]   // WILL × 2
    [TestCase(RestType.Long, 4, 20)]   // WILL × 5
    [TestCase(RestType.Milestone, 4, 25)] // Fixed 25
    public void RecoverStress_UsesCorrectFormula(
        RestType restType, int will, int expectedRecovery)
    {
        // Arrange
        _testCharacter = CreateTestCharacter(_characterId, stress: 50, will: will);
        _mockRepository.Setup(r => r.GetById(_characterId)).Returns(_testCharacter);

        // Act
        var result = _service.RecoverStress(_characterId, restType);

        // Assert
        result.AmountRecovered.Should().Be(expectedRecovery);
    }

    [Test]
    public void RecoverStress_Sanctuary_FullyResets()
    {
        // Arrange
        _testCharacter = CreateTestCharacter(_characterId, stress: 85, will: 4);
        _mockRepository.Setup(r => r.GetById(_characterId)).Returns(_testCharacter);

        // Act
        var result = _service.RecoverStress(_characterId, RestType.Sanctuary);

        // Assert
        result.NewStress.Should().Be(0);
        result.IsFullyRecovered.Should().BeTrue();
    }

    [Test]
    public void RecoverStress_DetectsThresholdDrop()
    {
        // Arrange
        _testCharacter = CreateTestCharacter(_characterId, stress: 85, will: 10);
        _mockRepository.Setup(r => r.GetById(_characterId)).Returns(_testCharacter);

        // Act
        var result = _service.RecoverStress(_characterId, RestType.Long);

        // Assert
        result.ThresholdDropped.Should().BeTrue(); // 85 → 35 = Breaking → Uneasy
    }

    #endregion

    #region ResetAfterTraumaCheck Tests

    [Test]
    [TestCase(true, 75)]
    [TestCase(false, 50)]
    public void ResetAfterTraumaCheck_SetsCorrectValue(bool passed, int expectedStress)
    {
        // Arrange
        _testCharacter = CreateTestCharacter(_characterId, stress: 100, will: 4);
        _mockRepository.Setup(r => r.GetById(_characterId)).Returns(_testCharacter);

        // Act
        _service.ResetAfterTraumaCheck(_characterId, passed);

        // Assert
        _mockRepository.Verify(
            r => r.Update(It.Is<Character>(c => c.PsychicStress == expectedStress)),
            Times.Once);
    }

    #endregion

    #region PerformResistanceCheck Tests

    [Test]
    [TestCase(0, 0.00)]
    [TestCase(1, 0.50)]
    [TestCase(2, 0.75)]
    [TestCase(4, 1.00)]
    public void PerformResistanceCheck_CalculatesCorrectReduction(
        int successes, decimal expectedReduction)
    {
        // Arrange
        _mockDiceService
            .Setup(d => d.RollAttributeCheck(It.IsAny<int>(), It.IsAny<int>()))
            .Returns(new DiceRollResult { NetSuccesses = successes });

        // Act
        var result = _service.PerformResistanceCheck(_characterId, 20, 2);

        // Assert
        result.ReductionPercent.Should().Be(expectedReduction);
    }

    #endregion

    #region Helpers

    private static Character CreateTestCharacter(Guid id, int stress, int will)
    {
        var character = Character.Create("TestHero");
        // Set stress and WILL via reflection or test factory
        return character;
    }

    #endregion
}
```

---

## 9. Use Cases

### UC-001: Combat Fear Attack

**Actor:** MonsterAI
**Flow:** Monster fear ability → ApplyStress with DC → Resistance check → Update stress
**Precondition:** Monster has fear ability
**Postcondition:** Character stress modified based on resistance

### UC-002: Rest at Inn

**Actor:** Player
**Flow:** Select Long Rest → RecoverStress(Long) → Display recovery → Update UI
**Precondition:** Character at safe location
**Postcondition:** Stress reduced by WILL × 5

### UC-003: Trauma Check Resolution

**Actor:** TraumaService
**Flow:** Trauma Check completed → ResetAfterTraumaCheck → Continue play
**Precondition:** Character failed/passed trauma check
**Postcondition:** Stress set to 75 or 50

---

## 10. Deliverable Checklist

### Application Layer — Services

- [ ] `src/Core/RuneAndRust.Application/Services/StressService.cs`

### Unit Tests

- [ ] `tests/RuneAndRust.Application.UnitTests/Services/StressServiceTests.cs`

### Documentation

- [ ] XML documentation on class and all methods
- [ ] Structured logging implemented
- [ ] Constants documented

---

## 11. Acceptance Criteria

### Functional Criteria

- [ ] `ApplyStress` clamps results to 0-100 range
- [ ] `ApplyStress` with `resistDc > 0` performs WILL check via `IDiceService`
- [ ] Successful resistance reduces stress per 0/50/75/100% table
- [ ] Failed resistance (0 successes) applies full stress
- [ ] `ThresholdCrossed` detected on threshold boundary crossing
- [ ] `TraumaCheckTriggered` true only when reaching exactly 100
- [ ] `RecoverStress(Short)` uses WILL × 2 formula
- [ ] `RecoverStress(Long)` uses WILL × 5 formula
- [ ] `RecoverStress(Sanctuary)` fully resets to 0
- [ ] `RecoverStress(Milestone)` recovers fixed 25
- [ ] `ResetAfterTraumaCheck(true)` sets stress to 75
- [ ] `ResetAfterTraumaCheck(false)` sets stress to 50

### Quality Criteria

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~8 unit tests pass
- [ ] Structured logging implemented for all operations
- [ ] XML documentation complete

---

## 12. Dependencies

### Required from v0.18.0a-c

| Type                      | Usage                                   |
| ------------------------- | --------------------------------------- |
| `StressState`             | Return from `GetStressState`, constants |
| `StressThreshold`         | Threshold comparison                    |
| `StressSource`            | Parameter categorization                |
| `RestType`                | Recovery type selection                 |
| `StressCheckResult`       | Resistance check result                 |
| `StressApplicationResult` | Apply stress result                     |
| `StressRecoveryResult`    | Recovery result                         |
| `IStressService`          | Interface to implement                  |

### Required Infrastructure

| Type                     | Usage                   |
| ------------------------ | ----------------------- |
| `ICharacterRepository`   | Character data access   |
| `IDiceService`           | WILL-based dice rolling |
| `ILogger<StressService>` | Structured logging      |

### Provides to Consumers

| Consumer      | Usage                                         |
| ------------- | --------------------------------------------- |
| DI Container  | Registered as `IStressService` implementation |
| CombatService | Stress application during combat              |
| RestService   | Stress recovery during rest                   |
| TraumaService | Trauma check reset                            |

---

## 13. Future Considerations

### Deferred to v0.18.0e

- Configuration-based stress source definitions
- Configurable recovery rates
- Configurable reset values

### Deferred to v0.18.0f

- Database persistence optimization
- Stress history tracking

### Deferred to v0.18.3

- Trauma Check execution service
- Permanent Trauma application

### Out of Scope

- Event publishing (consumers poll or use result objects)
- Async operations (not needed for current architecture)

---

_Document Version: 1.0_
_Last Updated: 2026-01-27_
