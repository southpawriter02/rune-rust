# v0.10.0c Design Specification: Effect Triggers & Cleanse

**Version:** 0.10.0c
**Parent:** v0.10.0 (Status Effects System)
**Prerequisites:** v0.10.0b Complete (Buff/Debuff Service)
**Status:** Design Complete
**Estimated Unit Tests:** ~10

---

## 1. Overview

### Purpose

Implement effect triggers that execute on turn events (start/end) and special events, the effect ticking system for DoT (Damage over Time) and HoT (Heal over Time), immunity checking before effect application, and cleanse/dispel mechanics for removing negative or positive effects.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Service Updates** | `TickEffects()`, `IsImmune()`, `Cleanse()`, `Dispel()` |
| **Event Handlers** | `StatusEffectTriggerHandler` |
| **Result Types** | `TickResult` |
| **Trigger Types** | OnApply, OnTurnStart, OnTurnEnd, OnExpire |
| **Events** | `DoTDamageDealtEvent`, `HoTHealingDoneEvent` |
| **Tests** | ~10 unit tests |

---

## 2. Feature Overview

```
v0.10.0c Features
├── Effect Tick System
│   ├── TickEffects(target, timing)
│   ├── Process OnTurnStart triggers
│   ├── Process OnTurnEnd triggers
│   ├── Decrement duration
│   ├── Remove expired effects
│   └── TickResult aggregation
│
├── Trigger Execution
│   ├── ExecuteTrigger(target, effect, trigger)
│   ├── TriggerActionType.Damage → Apply DoT
│   ├── TriggerActionType.Heal → Apply HoT
│   ├── TriggerActionType.ApplyEffect → Chain effects
│   └── PerStack scaling
│
├── Immunity System
│   ├── IsImmune(target, effectId)
│   ├── Check active effect immunities
│   ├── Check innate target immunities
│   └── Block application if immune
│
├── Cleanse Mechanics
│   ├── Cleanse(target, count?) → Remove debuffs
│   └── Dispel(target, count?) → Remove buffs
│
├── StatusEffectTriggerHandler
│   ├── Subscribe to TurnStartedEvent
│   ├── Subscribe to TurnEndedEvent
│   └── Publish DoT/HoT events
│
└── Integration
    ├── Update ApplyEffect with immunity check
    └── Event publishing for DoT/HoT
```

---

## 3. Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      EFFECT TRIGGER FLOW                                │
└─────────────────────────────────────────────────────────────────────────┘

     Turn Event                     Effect Tick                Result
     ──────────                     ───────────                ──────

     [Turn Start] ────────────────▶ TickEffects() 
                                         │
                    ┌────────────────────┼────────────────────┐
                    ▼                    ▼                    ▼
              ┌──────────┐        ┌──────────┐         ┌──────────┐
              │ POISON   │        │ BURNING  │         │ REGEN    │
              │ (DoT)    │        │ (DoT)    │         │ (HoT)    │
              └────┬─────┘        └────┬─────┘         └────┬─────┘
                   │                   │                    │
                   ▼                   ▼                    ▼
              Deal damage         Deal damage          Apply healing
              per stack           (fire type)          
                   │                   │                    │
                   ▼                   ▼                    ▼
              Decrement           Decrement             Decrement
              duration            duration              duration
                   │                   │                    │
                   └───────────────────┴────────────────────┘
                                       │
                                       ▼
                              Remove expired effects
                                       │
                                       ▼
                                 [TickResult]
                              ├── DamageDealt
                              ├── HealingDone
                              └── ExpiredEffects
```

---

## 4. TriggerTiming & TriggerActionType Enums

**File:** `src/Core/RuneAndRust.Domain/Enums/TriggerTiming.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// When an effect trigger activates.
/// </summary>
public enum TriggerTiming
{
    /// <summary>When effect is first applied.</summary>
    OnApply,

    /// <summary>At the start of target's turn.</summary>
    OnTurnStart,

    /// <summary>At the end of target's turn.</summary>
    OnTurnEnd,

    /// <summary>Each turn (alias for OnTurnStart).</summary>
    OnTick,

    /// <summary>When effect expires naturally.</summary>
    OnExpire,

    /// <summary>When effect is removed (any way).</summary>
    OnRemove,

    /// <summary>When target takes damage.</summary>
    OnDamaged,

    /// <summary>When target makes an attack.</summary>
    OnAttack
}
```

**File:** `src/Core/RuneAndRust.Domain/Enums/TriggerActionType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// What action a trigger performs.
/// </summary>
public enum TriggerActionType
{
    /// <summary>Deal damage to target.</summary>
    Damage,

    /// <summary>Heal target.</summary>
    Heal,

    /// <summary>Apply another effect.</summary>
    ApplyEffect,

    /// <summary>Remove an effect.</summary>
    RemoveEffect,

    /// <summary>Temporary stat change.</summary>
    ModifyStat,

    /// <summary>Custom action handler.</summary>
    Custom
}
```

---

## 5. TickResult Record

**File:** `src/Core/RuneAndRust.Application/DTOs/TickResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of ticking status effects for a turn.
/// </summary>
public record TickResult
{
    /// <summary>Total damage dealt by DoT effects.</summary>
    public int DamageDealt { get; set; }

    /// <summary>Total healing done by HoT effects.</summary>
    public int HealingDone { get; set; }

    /// <summary>Effect IDs that expired this tick.</summary>
    public List<string> ExpiredEffects { get; } = new();

    /// <summary>Effect IDs that triggered this tick.</summary>
    public List<string> TriggeredEffects { get; } = new();

    /// <summary>Damage breakdown by effect.</summary>
    public Dictionary<string, int> DamageByEffect { get; } = new();

    /// <summary>Healing breakdown by effect.</summary>
    public Dictionary<string, int> HealingByEffect { get; } = new();

    /// <summary>Whether any effects were processed.</summary>
    public bool HadEffects => TriggeredEffects.Count > 0 || ExpiredEffects.Count > 0;
}
```

---

## 6. IBuffDebuffService Extensions

**Updates to:** `src/Core/RuneAndRust.Application/Interfaces/IBuffDebuffService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

public interface IBuffDebuffService
{
    // ... existing methods from v0.10.0b ...

    /// <summary>Ticks all effects on a target for a given timing.</summary>
    /// <param name="target">The combatant to tick effects for.</param>
    /// <param name="timing">When the tick is occurring.</param>
    /// <returns>Result of the tick processing.</returns>
    TickResult TickEffects(ICombatant target, TriggerTiming timing);

    /// <summary>Checks if a target is immune to an effect.</summary>
    /// <param name="target">The combatant to check.</param>
    /// <param name="effectId">The effect to check immunity for.</param>
    /// <returns>True if target is immune.</returns>
    bool IsImmune(ICombatant target, string effectId);

    /// <summary>Cleanses debuffs from a target.</summary>
    /// <param name="target">The combatant to cleanse.</param>
    /// <param name="count">Number of debuffs to remove (null = all).</param>
    /// <returns>Number of debuffs removed.</returns>
    int Cleanse(ICombatant target, int? count = null);

    /// <summary>Dispels buffs from a target (for use on enemies).</summary>
    /// <param name="target">The combatant to dispel.</param>
    /// <param name="count">Number of buffs to remove (null = all).</param>
    /// <returns>Number of buffs removed.</returns>
    int Dispel(ICombatant target, int? count = null);

    /// <summary>Processes triggers for a specific timing across all effects.</summary>
    void ProcessTriggers(ICombatant target, TriggerTiming timing);
}
```

---

## 7. BuffDebuffService Extensions

**Updates to:** `src/Core/RuneAndRust.Application/Services/BuffDebuffService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public partial class BuffDebuffService : IBuffDebuffService
{
    private readonly IDiceService _diceService;
    private readonly IDamageService _damageService;

    // Constructor update to include new dependencies
    public BuffDebuffService(
        IStatusEffectProvider effectProvider,
        IStatModifierService statModifierService,
        IDiceService diceService,
        IDamageService damageService,
        IEventBus eventBus,
        ILogger<BuffDebuffService> logger)
    {
        _effectProvider = effectProvider;
        _statModifierService = statModifierService;
        _diceService = diceService;
        _damageService = damageService;
        _eventBus = eventBus;
        _logger = logger;
    }

    public TickResult TickEffects(ICombatant target, TriggerTiming timing)
    {
        var result = new TickResult();
        var effectsToRemove = new List<ActiveStatusEffect>();

        foreach (var effect in target.ActiveEffects.ToList())
        {
            var definition = _effectProvider.GetEffect(effect.DefinitionId);
            if (definition is null) continue;

            // Execute triggers for this timing
            foreach (var trigger in definition.Triggers.Where(t =>
                t.Timing == timing || (timing == TriggerTiming.OnTurnStart && t.Timing == TriggerTiming.OnTick)))
            {
                ExecuteTrigger(target, effect, definition, trigger, result);
                result.TriggeredEffects.Add(definition.EffectId);
            }

            // Tick duration on turn start
            if (timing == TriggerTiming.OnTurnStart)
            {
                if (effect.Tick())
                {
                    // Effect expired - execute OnExpire triggers
                    foreach (var expireTrigger in definition.Triggers.Where(t => t.Timing == TriggerTiming.OnExpire))
                    {
                        ExecuteTrigger(target, effect, definition, expireTrigger, result);
                    }

                    effectsToRemove.Add(effect);
                    result.ExpiredEffects.Add(effect.DefinitionId);
                }
            }
        }

        // Remove expired effects
        foreach (var effect in effectsToRemove)
        {
            RemoveEffectInternal(target, effect, EffectRemovalReason.Expired);
        }

        _logger.LogDebug("Ticked effects on {Target}: {Damage} damage, {Healing} healing, {Expired} expired",
            target.Name, result.DamageDealt, result.HealingDone, result.ExpiredEffects.Count);

        return result;
    }

    private void ExecuteTrigger(
        ICombatant target,
        ActiveStatusEffect effect,
        StatusEffectDefinition definition,
        EffectTriggerAction trigger,
        TickResult result)
    {
        var stacks = effect.CurrentStacks;

        switch (trigger.Action)
        {
            case TriggerActionType.Damage:
                var damageRoll = _diceService.Roll(trigger.Value);
                var damageValue = trigger.PerStack ? damageRoll * stacks : damageRoll;

                _damageService.ApplyDamage(target, damageValue, trigger.DamageType ?? "untyped");
                result.DamageDealt += damageValue;
                result.DamageByEffect[definition.EffectId] =
                    result.DamageByEffect.GetValueOrDefault(definition.EffectId) + damageValue;

                _logger.LogDebug("{Effect} dealt {Damage} {Type} damage to {Target}",
                    definition.EffectId, damageValue, trigger.DamageType, target.Name);
                break;

            case TriggerActionType.Heal:
                var healRoll = _diceService.Roll(trigger.Value);
                var healValue = trigger.PerStack ? healRoll * stacks : healRoll;

                target.Heal(healValue);
                result.HealingDone += healValue;
                result.HealingByEffect[definition.EffectId] =
                    result.HealingByEffect.GetValueOrDefault(definition.EffectId) + healValue;

                _logger.LogDebug("{Effect} healed {Target} for {Amount}",
                    definition.EffectId, target.Name, healValue);
                break;

            case TriggerActionType.ApplyEffect:
                ApplyEffect(target, trigger.Value, null);
                _logger.LogDebug("{Effect} applied {ChainEffect} to {Target}",
                    definition.EffectId, trigger.Value, target.Name);
                break;

            case TriggerActionType.RemoveEffect:
                RemoveEffect(target, trigger.Value);
                _logger.LogDebug("{Effect} removed {OtherEffect} from {Target}",
                    definition.EffectId, trigger.Value, target.Name);
                break;

            case TriggerActionType.Custom:
                _logger.LogDebug("{Effect} triggered custom action: {Value}",
                    definition.EffectId, trigger.Value);
                // Custom triggers handled by external systems
                _eventBus.Publish(new CustomTriggerEvent(target.Id, definition.EffectId, trigger.Value));
                break;
        }
    }

    public bool IsImmune(ICombatant target, string effectId)
    {
        // Check if target has any effect that grants immunity to this effect
        foreach (var activeEffect in target.ActiveEffects)
        {
            var definition = _effectProvider.GetEffect(activeEffect.DefinitionId);
            if (definition?.ImmunityIds.Contains(effectId) == true)
            {
                _logger.LogDebug("{Target} is immune to {Effect} via {Source}",
                    target.Name, effectId, activeEffect.DefinitionId);
                return true;
            }
        }

        // Check innate immunities on target
        if (target.ImmuneTo?.Contains(effectId) == true)
        {
            _logger.LogDebug("{Target} has innate immunity to {Effect}", target.Name, effectId);
            return true;
        }

        return false;
    }

    // Updated ApplyEffect with immunity check
    public ApplyResult ApplyEffect(ICombatant target, string effectId, ICombatant? source = null)
    {
        // Check immunity first
        if (IsImmune(target, effectId))
        {
            _logger.LogInformation("{Target} is immune to {Effect}", target.Name, effectId);
            return ApplyResult.Immune(effectId);
        }

        // ... rest of existing ApplyEffect logic ...
    }

    public int Cleanse(ICombatant target, int? count = null)
    {
        var debuffs = target.ActiveEffects
            .Where(e =>
            {
                var def = _effectProvider.GetEffect(e.DefinitionId);
                return def is not null && !def.IsBuff;
            })
            .ToList();

        if (count.HasValue)
        {
            debuffs = debuffs.Take(count.Value).ToList();
        }

        foreach (var debuff in debuffs)
        {
            RemoveEffectInternal(target, debuff, EffectRemovalReason.Cleansed);
        }

        _logger.LogInformation("Cleansed {Count} debuffs from {Target}", debuffs.Count, target.Name);
        _eventBus.Publish(new EffectsCleanedEvent(target.Id, debuffs.Select(d => d.DefinitionId).ToList()));

        return debuffs.Count;
    }

    public int Dispel(ICombatant target, int? count = null)
    {
        var buffs = target.ActiveEffects
            .Where(e =>
            {
                var def = _effectProvider.GetEffect(e.DefinitionId);
                return def?.IsBuff == true;
            })
            .ToList();

        if (count.HasValue)
        {
            buffs = buffs.Take(count.Value).ToList();
        }

        foreach (var buff in buffs)
        {
            RemoveEffectInternal(target, buff, EffectRemovalReason.Dispelled);
        }

        _logger.LogInformation("Dispelled {Count} buffs from {Target}", buffs.Count, target.Name);
        _eventBus.Publish(new EffectsDispelledEvent(target.Id, buffs.Select(b => b.DefinitionId).ToList()));

        return buffs.Count;
    }

    private void RemoveEffectInternal(ICombatant target, ActiveStatusEffect effect, EffectRemovalReason reason)
    {
        var definition = _effectProvider.GetEffect(effect.DefinitionId);
        if (definition?.StatModifiers.Count > 0)
        {
            _statModifierService.RemoveModifiers(target, definition.StatModifiers, effect.CurrentStacks);
        }

        target.RemoveStatusEffect(effect);
        _eventBus.Publish(new EffectRemovedEvent(target.Id, effect.DefinitionId, reason));
    }

    public void ProcessTriggers(ICombatant target, TriggerTiming timing)
    {
        foreach (var effect in target.ActiveEffects)
        {
            var definition = _effectProvider.GetEffect(effect.DefinitionId);
            if (definition is null) continue;

            foreach (var trigger in definition.Triggers.Where(t => t.Timing == timing))
            {
                ExecuteTrigger(target, effect, definition, trigger, new TickResult());
            }
        }
    }
}
```

---

## 8. StatusEffectTriggerHandler

**File:** `src/Core/RuneAndRust.Application/EventHandlers/StatusEffectTriggerHandler.cs`

```csharp
namespace RuneAndRust.Application.EventHandlers;

/// <summary>
/// Subscribes to turn events and processes status effect triggers.
/// </summary>
public class StatusEffectTriggerHandler : IDisposable
{
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<StatusEffectTriggerHandler> _logger;
    private readonly List<IDisposable> _subscriptions = new();

    public StatusEffectTriggerHandler(
        IBuffDebuffService buffDebuffService,
        IEventBus eventBus,
        ILogger<StatusEffectTriggerHandler> logger)
    {
        _buffDebuffService = buffDebuffService;
        _eventBus = eventBus;
        _logger = logger;

        RegisterSubscriptions();
    }

    private void RegisterSubscriptions()
    {
        // Subscribe to turn start events
        _subscriptions.Add(_eventBus.Subscribe<TurnStartedEvent>(OnTurnStarted));

        // Subscribe to turn end events
        _subscriptions.Add(_eventBus.Subscribe<TurnEndedEvent>(OnTurnEnded));

        // Subscribe to damage events for OnDamaged triggers
        _subscriptions.Add(_eventBus.Subscribe<DamageReceivedEvent>(OnDamageReceived));

        // Subscribe to attack events for OnAttack triggers
        _subscriptions.Add(_eventBus.Subscribe<AttackMadeEvent>(OnAttackMade));

        _logger.LogDebug("StatusEffectTriggerHandler registered {Count} subscriptions", _subscriptions.Count);
    }

    private void OnTurnStarted(TurnStartedEvent e)
    {
        var result = _buffDebuffService.TickEffects(e.Combatant, TriggerTiming.OnTurnStart);

        if (result.DamageDealt > 0)
        {
            _eventBus.Publish(new DoTDamageDealtEvent(e.Combatant.Id, result.DamageDealt, result.DamageByEffect));
            _logger.LogDebug("DoT dealt {Damage} to {Target}", result.DamageDealt, e.Combatant.Name);
        }

        if (result.HealingDone > 0)
        {
            _eventBus.Publish(new HoTHealingDoneEvent(e.Combatant.Id, result.HealingDone, result.HealingByEffect));
            _logger.LogDebug("HoT healed {Target} for {Healing}", e.Combatant.Name, result.HealingDone);
        }

        foreach (var expired in result.ExpiredEffects)
        {
            _logger.LogDebug("Effect {Effect} expired on {Target}", expired, e.Combatant.Name);
        }
    }

    private void OnTurnEnded(TurnEndedEvent e)
    {
        var result = _buffDebuffService.TickEffects(e.Combatant, TriggerTiming.OnTurnEnd);

        // OnTurnEnd typically doesn't decrement duration, just triggers
        if (result.DamageDealt > 0)
        {
            _eventBus.Publish(new DoTDamageDealtEvent(e.Combatant.Id, result.DamageDealt, result.DamageByEffect));
        }

        if (result.HealingDone > 0)
        {
            _eventBus.Publish(new HoTHealingDoneEvent(e.Combatant.Id, result.HealingDone, result.HealingByEffect));
        }
    }

    private void OnDamageReceived(DamageReceivedEvent e)
    {
        // Process OnDamaged triggers
        _buffDebuffService.ProcessTriggers(e.Target, TriggerTiming.OnDamaged);
    }

    private void OnAttackMade(AttackMadeEvent e)
    {
        // Process OnAttack triggers
        _buffDebuffService.ProcessTriggers(e.Attacker, TriggerTiming.OnAttack);
    }

    public void Dispose()
    {
        foreach (var sub in _subscriptions)
        {
            sub.Dispose();
        }
        _subscriptions.Clear();
    }
}
```

---

## 9. Additional Events

**File:** `src/Core/RuneAndRust.Application/Events/StatusEffectTriggerEvents.cs`

```csharp
namespace RuneAndRust.Application.Events;

/// <summary>Published when DoT effects deal damage during a tick.</summary>
public record DoTDamageDealtEvent(
    Guid TargetId,
    int TotalDamage,
    Dictionary<string, int> DamageByEffect);

/// <summary>Published when HoT effects heal during a tick.</summary>
public record HoTHealingDoneEvent(
    Guid TargetId,
    int TotalHealing,
    Dictionary<string, int> HealingByEffect);

/// <summary>Published when effects are cleansed from a target.</summary>
public record EffectsCleanedEvent(
    Guid TargetId,
    IReadOnlyList<string> CleanedEffectIds);

/// <summary>Published when effects are dispelled from a target.</summary>
public record EffectsDispelledEvent(
    Guid TargetId,
    IReadOnlyList<string> DispelledEffectIds);

/// <summary>Published when a custom trigger fires.</summary>
public record CustomTriggerEvent(
    Guid TargetId,
    string EffectId,
    string TriggerValue);
```

---

## 10. Effect Trigger Flow Visualization

```
TURN START FLOW:
═══════════════════════════════════════════════════════════════════════

  [TurnStartedEvent] ──▶ StatusEffectTriggerHandler.OnTurnStarted()
                                     │
                                     ▼
                          BuffDebuffService.TickEffects(target, OnTurnStart)
                                     │
              ┌──────────────────────┼──────────────────────┐
              │                      │                      │
              ▼                      ▼                      ▼
        ┌──────────┐          ┌──────────┐          ┌──────────┐
        │ Poison   │          │ Burning  │          │ Regen    │
        │ OnTurn   │          │ OnTurn   │          │ OnTurn   │
        │ Start    │          │ End      │          │ Start    │
        └────┬─────┘          └────┬─────┘          └────┬─────┘
             │                     │ (skip)              │
             ▼                     │                     ▼
        Roll 1d4 × 3          ─────┘                Roll 1d8+2
        (per stack)                                      │
             │                                           │
             ▼                                           ▼
        Deal damage                                 Heal target
        (poison)                                         │
             │                                           │
             ▼                                           ▼
        Tick duration                              Tick duration
        (5 → 4)                                    (5 → 4)
             │                                           │
             └───────────────────────────────────────────┘
                                 │
                                 ▼
                         Aggregate TickResult
                         ├── DamageDealt: 9
                         ├── HealingDone: 7
                         └── ExpiredEffects: []


IMMUNITY CHECK:
═══════════════════════════════════════════════════════════════════════

  ApplyEffect("stunned", target)
              │
              ▼
  IsImmune(target, "stunned") ──────────▶ Check active effects
              │                                   │
              │         ┌─────────────────────────┘
              │         ▼
              │   ┌──────────────────────────────────┐
              │   │ Target has "stunned" effect with │
              │   │ immunityIds: ["stunned"]         │
              │   └──────────────┬───────────────────┘
              │                  │
              ▼                  ▼
        ┌─────────────┐    ┌─────────────┐
        │ Not Immune  │    │   Immune    │
        └──────┬──────┘    └──────┬──────┘
               │                  │
               ▼                  ▼
        Apply effect       Return Immune result


CLEANSE MECHANICS:
═══════════════════════════════════════════════════════════════════════

  Cleanse(target, count: 2)
              │
              ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │ Active Effects:                                                 │
  │ ☠ Poison (DoT, debuff)                                         │
  │ ☠ Burning (DoT, debuff)                                        │
  │ ☠ Slowed (Movement, debuff)                                    │
  │ ✨ Blessed (StatMod, buff)                                      │
  └─────────────────────────────────────────────────────────────────┘
              │
              │ Filter debuffs, take 2
              ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │ To Remove:                                                      │
  │ ☠ Poison                                                        │
  │ ☠ Burning                                                       │
  └─────────────────────────────────────────────────────────────────┘
              │
              │ Remove each, publish events
              ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │ Remaining Effects:                                              │
  │ ☠ Slowed (Movement, debuff)                                    │
  │ ✨ Blessed (StatMod, buff)                                      │
  └─────────────────────────────────────────────────────────────────┘
              │
              ▼
        Return count: 2
```

---

## 11. Unit Testing Requirements (~10 tests)

| Feature | Tests |
|---------|-------|
| TickEffects processes OnTurnStart triggers | 1 |
| TickEffects processes OnTurnEnd triggers | 1 |
| DoT trigger deals damage per tick | 1 |
| HoT trigger heals per tick | 1 |
| PerStack triggers scale with stacks | 1 |
| Tick decrements duration and expires effects | 1 |
| IsImmune returns true for immune targets | 1 |
| ApplyEffect blocked by immunity | 1 |
| Cleanse removes only debuffs | 1 |
| Dispel removes only buffs | 1 |

---

## 12. Acceptance Criteria

- [ ] TickEffects processes all active effects
- [ ] OnTurnStart triggers execute at turn start
- [ ] OnTurnEnd triggers execute at turn end
- [ ] DoT effects deal damage per turn
- [ ] HoT effects heal per turn
- [ ] PerStack triggers scale with current stacks
- [ ] Effects expire when duration reaches 0
- [ ] OnExpire triggers fire when effect expires
- [ ] IsImmune checks active effect immunities
- [ ] IsImmune checks innate target immunities
- [ ] ApplyEffect returns Immune for immune targets
- [ ] Cleanse removes debuffs (count or all)
- [ ] Dispel removes buffs (count or all)
- [ ] TickResult aggregates damage/healing
- [ ] DoTDamageDealtEvent published after DoT
- [ ] HoTHealingDoneEvent published after HoT
- [ ] StatusEffectTriggerHandler subscribes to turn events
- [ ] OnDamaged triggers process on damage
- [ ] OnAttack triggers process on attack
- [ ] ~10 unit tests pass

---

## 13. Dependencies

| From | Required |
|------|----------|
| v0.10.0a | `StatusEffectDefinition`, `ActiveStatusEffect`, `EffectTriggerAction` |
| v0.10.0b | `IBuffDebuffService`, `BuffDebuffService`, `ApplyResult` |
| Application | `IEventBus`, `IDiceService`, `IDamageService` |
| Domain | `ICombatant`, `TriggerTiming`, `TriggerActionType` |
| Events | `TurnStartedEvent`, `TurnEndedEvent` |

---

## 14. Summary

v0.10.0c completes the Status Effects System by adding:
- **Effect tick system** for processing DoT/HoT each turn
- **Trigger execution** for Damage, Heal, ApplyEffect, RemoveEffect
- **Duration management** with automatic expiration
- **Immunity checking** via active effects and innate immunities
- **Cleanse mechanics** to remove debuffs from allies
- **Dispel mechanics** to remove buffs from enemies
- **Event integration** for turn-based trigger processing

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
